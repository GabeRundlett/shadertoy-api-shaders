{
    "Shader": {
        "info": {
            "date": "1505399700",
            "description": "GI Rendering for more complex procedural 'table pool' scene.\nThere are some bugs still :s sorry :)\nAnother version with separate texture generation:\nhttps://www.shadertoy.com/view/llfyRj",
            "flags": 32,
            "hasliked": 0,
            "id": "XlXczj",
            "likes": 15,
            "name": "Let's play! ",
            "published": 3,
            "tags": [
                "gi",
                "lighting",
                "rendering",
                "pt"
            ],
            "usePreview": 1,
            "username": "koiava",
            "viewed": 757
        },
        "renderpass": [
            {
                "code": "//#define MULTIPLE_SAMPLES\n\n#define LOW_RES\n//#define MIDDLE_RES\n//#define HIGH_RES\n\n#ifdef HIGH_RES\t//HD\n    #define RENDERING_RES_X\t1280\n    #define RENDERING_RES_Y\t720\n#else\n    #ifdef MIDDLE_RES\n        #define RENDERING_RES_X\t896\n        #define RENDERING_RES_Y\t504\t\n    #else\n\t\t#define RENDERING_RES_X\t640\n        #define RENDERING_RES_Y\t360\t\n    #endif\n#endif\n\n// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Display : average down and do gamma adjustment\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 renderingResolution = min(iResolution.xy, vec2(float(RENDERING_RES_X), float(RENDERING_RES_Y)));\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    vec2 ratio = renderingResolution / iResolution.xy;\n    \n#ifdef MULTIPLE_SAMPLES\n    int cx = int(iResolution.x / renderingResolution.x);\n    int cy = int(iResolution.y / renderingResolution.y);\n    for(int y=0; y<cy; y++) {\n        for(int x=0; x<cx; x++) {\n            vec2 offset = vec2(x,y) * ratio;\n            col += texture( iChannel0, offset + uv*ratio ).xyz;\n        }\n    }\n    col /= float(cx*cy);\n#else\n    col = texture( iChannel0, uv*ratio ).xyz;\n#endif\n        \n    col = pow( col, vec3(0.4545) );\n    \n    \n    // color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define MULTIPLE_SAMPLES\n#define PIXEL_SAMPLES \t\t2\n#define DL_SAMPLES\t\t\t1\n#define MAX_DEPTH\t\t\t3\n#define LENS_SIZE\t\t\t0.3\n#define CLAMP_VALUE\t\t\t1.5\n#define CLAMP_CAUSTICS\n\n\n//https://www.solidangle.com/research/egsr2013_spherical_rectangle.pdf\n#define SPHERICAL_RECTANGLE\n\n#define LOW_RES\n//#define MIDDLE_RES\n//#define HIGH_RES\n\n#ifdef HIGH_RES\t//HD\n    #define RENDERING_RES_X\t1280\n    #define RENDERING_RES_Y\t720\n#else\n    #ifdef MIDDLE_RES\n        #define RENDERING_RES_X\t896\n        #define RENDERING_RES_Y\t504\t\n    #else\n\t\t#define RENDERING_RES_X\t640\n        #define RENDERING_RES_Y\t360\t\n    #endif\n#endif\n\nconst vec3 backgroundColor = vec3( 0.0 );\n\nvec4 char(vec2 pos, float c) {\n    pos = clamp(pos,0.,1.);  // would be more efficient to exit if out.\n    vec4 tx= texture( iChannel3, pos/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ) )*2. ;\n    vec4 ty= texture( iChannel3, pos/16.012 + fract( floor(vec2(c, 15.999-c/16.012)) / 16.012 ) )/3.0 ;\n    vec4 tz= texture( iChannel2,pos);\n    return  vec4((tx+ty)/(tz*3.0));\n}\n\nbool is_inf(float val) {\n#if __VERSION__ >= 300\n    return isinf(val);\t//webGL 2.0 is required\n#else\n\treturn val != val;\n#endif\n}\n\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.005 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n\nfloat misWeight( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec2 rotateVec(vec2 v, float angle) {\n    vec2 cs = vec2(cos(angle), sin(angle));\n    return vec2(dot(v, cs), dot(v, vec2(cs.y, -cs.x)));\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  float c, s, a1, a2;\n  c = cos (a);  s = sin (a);\n  m[0][0] = (1. - c) * v.x * v.x + c;\n  m[1][1] = (1. - c) * v.y * v.y + c;\n  m[2][2] = (1. - c) * v.z * v.z + c;\n  a1 = (1. - c) * v.x * v.y;  a2 = - s * v.z;\n  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = (1. - c) * v.z * v.x;  a2 = - s * v.y;\n  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = (1. - c) * v.y * v.z;  a2 = - s * v.x;\n  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return m;\n}\n\nvec3 orthogonalize(in vec3 n, inout vec3 v) {\n    return v - n * dot(n, v);\n}\n\n#if __VERSION__ >= 300\nmat3 mat3Inverse( in mat3 m ) { return inverse(m); }\nmat4 mat4Inverse( in mat4 m ) {return inverse(m);}\n#else\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n#endif\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int mtl_id_;\n};\n    \n#define SURFACE_ID_BASE\t0\n#define LIGHT_ID_BASE\t64\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_DISK\t\t4\n#define OBJ_CONE\t\t5\n\n\nstruct Ball { mat4 mtx; int num; };\nstruct Table { vec2 size; vec3 pos; };\nstruct Chalk { mat4 mtx; float size; };\nstruct Cue { mat4 mtx; float r0; float r1; float h; };\n    \nstruct Light {\n    vec3 color_;\n    float intensity_;\n    vec3 pos;\n    vec2 size;\n};\n\n//Weighted sum of Lambertian and Blinn brdfs\nstruct Material {\n    vec3 diffuse_color_;\n    int diffuse_color_tex_;\n    vec3 specular_color_;\n    float specular_roughness_;\n    int specular_roughness_tex_;\n    float specular_weight_;\n    int specular_weight_tex_;\n    int normal_map_;\n    float tex_scale_;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n    float lensSize;\n    float focusDist;\n};\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n    \n// ************ SCENE ***************\n\nCamera camera;\nTable table;\nBall balls[6];\nChalk chalk;\nCue cue;\nLight light;\nMaterial mtl[9];\n\n//***********************************\nMaterial getMaterial(int i) {\n#if __VERSION__ >= 300\n    return mtl[i];\t//webGL 2.0\n#else\n    if(i==0) return mtl[0]; \n    if(i==1) return mtl[1]; \n    if(i==2) return mtl[2]; \n    if(i==3) return mtl[3]; \n    if(i==4) return mtl[4]; \n    if(i==5) return mtl[5];\n    if(i==6) return mtl[6]; \n    if(i==7) return mtl[7]; \n    return mtl[8];\n#endif \n}\n\nLight getLight(int i) {\n    return light;\n}\n\nvec3 getBallTexture(vec2 uv, vec3 color, bool solid, int numb) {\n    vec2 dirToCenter = vec2(0.5, 0.5) - vec2(uv.x + (0.5-uv.x)*0.5, uv.y);\n    float d = sqrt(dot(dirToCenter, dirToCenter));\n    vec3 white = vec3(1.0, 1.0, 0.8);\n    float edgeBlend = 0.005;\n    float r = 0.07;\n    vec3 res;\n    \n    float dirt = texture(iChannel2,uv*1.5).x;\n    \n    vec3 non_solid;\n    float dd = abs(uv.x - 0.5);\n    if(dd < 0.18 - edgeBlend) {\n        non_solid = color;\n    } else if(dd > 0.18 + edgeBlend) {\n        non_solid = white;\n    } else {\n        float blende = ((dd - (0.18 - edgeBlend))/(2.0*edgeBlend))*dirt;\n        non_solid = mix(color, white, blende);\n    }\n    vec3 outside_circle = mix(non_solid, color, solid? 1.0 : 0.0);\n    \n    vec2 scale = vec2(5.0, 8.0);\n    vec4 numc = char(scale*(uv - 0.5) + vec2(0.5), 48.0 + float(numb));\n    numc.xyz = vec3(1.0) - numc.xxx*2.0;\n    vec3 inside_circle = mix(white, numc.xyz, numc.w);\n    \n    bool on_69_mark = (d > 0.047) && (d < 0.057) && (uv.y < 0.5) && (abs(uv.x - 0.5) < 0.03);\n    inside_circle *= vec3((numb == 6 || numb == 9)? (on_69_mark? dirt*dirt : 1.0) : 1.0);\n    res = mix(outside_circle, inside_circle, (d < r - edgeBlend)?1.0 : 0.0);\n    \n    float blendc = ((d - (r - edgeBlend))/(2.0*edgeBlend))*dirt;\n    vec3 on_the_circle = mix(white, color, blendc);\n    res = mix(res, on_the_circle, (abs(d - r) < edgeBlend)?1.0 : 0.0);\n    \n    return res;\n}\n\nvec3 getCueTexture(vec2 uv) {\n    vec3 wood = texture( iChannel1, uv.yx ).xyz;\n    \n    if(uv.y > 1.0)\n        return wood;\n    \n    float k = fract(uv.x / 0.2);\n    float h = 0.3;\n    if(k < h) {\n        return ((h-k)*0.3 < uv.y-h)?wood:vec3(0.0);\n    }else {\n        return ((k-h)*0.3 < uv.y-h)?wood:vec3(0.0);\n    }\n    \n}\n\nvec3 getFabricColor(vec2 uv) {\n    float aa = texture(iChannel1,uv).r*0.5 + texture(iChannel1,uv.yx).r*0.5;//add some more inperfection\n    aa = aa*0.5 + 0.2;\n    \n\treturn vec3(0.3, 0.9, 0.2)*aa*0.3;\n    /*uv = rotateVec(uv, 0.2);\n    uv *= 1110.0;\n    \n    vec2 waves = abs(fract(uv)*2.0-1.0);\n    vec3 c = mix(vec3(0.1, 0.5, 0.0), vec3(0.3, 0.9, 0.2), waves.x+waves.y);\n    return c*(waves.x*waves.y)*aa;*/\n}\n\nvec3 getColor(vec2 uv, int tex) {\n    vec3 c;\n    if(tex==0) c = texture( iChannel0, uv ).xyz; else\n    if(tex==1) c = texture( iChannel1, uv ).xyz; else\n    if(tex==2) c = texture( iChannel2, uv ).xyz; else\n    if(tex==3) c = texture( iChannel3, uv ).xyz; else\n    if(tex==4) c = getBallTexture(uv, vec3(0.5, 0.0, 0.02), true, 7); else\n    if(tex==5) c = getBallTexture(uv, vec3(0.6, 0.6, 0.0), false, 9); else\n    if(tex==6) c = getBallTexture(uv, vec3(0.6, 0.6, 0.1), true, 1); else\n    if(tex==7) c = getCueTexture(uv); else\n    if(tex==8) c = getFabricColor(uv); else\n    if(tex==9) c = getBallTexture(uv, vec3(0.01, 0.01, 0.01), true, 8); else\n    if(tex==10) c = getBallTexture(uv, vec3(0.0, 0.4, 0.0), true, 6); else\n    if(tex==11) c = getBallTexture(uv, vec3(0.26, 0.24, 0.43), true, 4); else\n    c = vec3(0.0);\n    \n    return clamp(c, 0.0, 1.0);\n}\n\nvec2 getTexRes(int tex) {\n#if __VERSION__ >= 300\n    if(tex>=0 && tex < 4){\n        return iChannelResolution[tex].xy;\n    }\n#else\n    if(tex==0) return iChannelResolution[0].xy;\n    if(tex==1) return iChannelResolution[1].xy;\n    if(tex==2) return iChannelResolution[2].xy;\n    if(tex==3) return iChannelResolution[3].xy;\n#endif\n    \n    return vec2(2048, 2048);\n}\n\nvec3 getNormal(vec2 uv, int tex ) {\n#ifdef NORMAL_MAPS\n    const float heightScale = 0.004;\n\n    vec2 res = getTexRes(tex);\n    vec2 duv = vec2(1.0) / res.xy;\n    vec3 c  = getColor( uv, tex).xyz;\n    vec3 c1 = getColor( uv + vec2(duv.x, 0.0), tex).xyz;\n    vec3 c2 = getColor( uv - vec2(duv.x, 0.0), tex).xyz;\n    vec3 c3 = getColor( uv + vec2(0.0, duv.y), tex).xyz;\n    vec3 c4 = getColor( uv - vec2(0.0, duv.y), tex).xyz;\n    \n    float h0\t= heightScale * dot(c , vec3(1.0/3.0));\n    float hpx = heightScale * dot(c1, vec3(1.0/3.0));\n    float hmx = heightScale * dot(c2, vec3(1.0/3.0));\n    float hpy = heightScale * dot(c3, vec3(1.0/3.0));\n    float hmy = heightScale * dot(c4, vec3(1.0/3.0));\n    float dHdU = (hmx - hpx) / (2.0 * duv.x);\n    float dHdV = (hmy - hpy) / (2.0 * duv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0));\n#else\n    return vec3(0.0, 0.0, 1.0);\n#endif\n}\n\nvec3 getRadiance(vec2 uv) {\n    return /*getColor(uv, 2)*lights[0].color_**/vec3(1.0, 1.0, 1.0)*light.intensity_;\n}\n\nvoid createMaterial(vec3 diff,\n                    int diff_tex,\n                    vec3 spec,\n                    float roughness,\n                    int roughness_tex,\n                   \tfloat weight,\n                    int weight_tex,\n                    int normal_map,\n                    float tex_scale,\n                    out Material mtl) {\n    mtl.diffuse_color_ = diff;\n    mtl.diffuse_color_tex_ = diff_tex;\n    mtl.specular_color_ = spec;\n    mtl.specular_roughness_ = roughness;\n    mtl.specular_roughness_tex_ = roughness_tex;\n    mtl.specular_weight_ = weight;\n    mtl.specular_weight_tex_ = weight_tex;\n    mtl.normal_map_ = normal_map;\n    mtl.tex_scale_ = tex_scale;\n}\n\nvoid createLight(vec3 color,\n                 float intensity,\n                 vec3 pos,\n                 vec2 size,\n                 out Light light) {\n    light.color_ = color;\n    light.intensity_ = intensity;\n    light.pos = pos;\n    light.size = size;\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    x = normalize(orthogonalize(z, x));\n    vec3 y = cross(z,x);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\nvoid initScene() {\n    float time = 100.0;//iTime;\n    \n    //init lights\n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float zFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = 0.0;//xFactor*15.0;\n    float z = -3.0;//-zFactor*15.0;\n\n    //create lights\n    createLight(vec3(1.0, 1.0, 0.9), 18.0,\n                vec3(x, 30.0, z),\n                vec2(50.0, 8.0),\n                light);\n        \n    //sphere 1\n    balls[0].num = 9;\n    balls[0].mtx = createCS(vec3(1.5, 0.0, -2.0),\n                     \t\tvec3(0.1, 0.0,  0.0),\n                     \t\tvec3(0.3, 0.5,  0.3));\n    \n    float dist = xFactor * 8.0;\n    dist = max(dist, -1.1);\n    vec3 new_pos = balls[0].mtx[3].xyz + vec3(1.0, 0.0, 0.0) * dist;\n    float angle = dist;\n    mat3 rot = VToRMat(vec3(0.0, 0.0, -1.0), angle);\n    balls[0].mtx[0].xyz *= rot;\n    balls[0].mtx[1].xyz *= rot;\n    balls[0].mtx[2].xyz *= rot;\n    balls[0].mtx[3].xyz = new_pos;\n    \n    \n    //sphere 2\n    balls[1].num = 7;\n    balls[1].mtx = createCS(vec3(-1.1, 0.0, -4.5),\n                     \t\tvec3(0.3, 0.8, 0.0),\n                     \t\tvec3(0.1, 0.0, 0.2));\n\n    balls[2].num = 1;\n    balls[2].mtx = createCS(vec3(3.5, 0.0, -4.2),\n                     \t\tvec3(0.1, 0.5, -0.2),\n                     \t\tvec3(-0.3, 0.2, 0.5));\n    \n    balls[3].num = 8;\n    balls[3].mtx = createCS(vec3(-1.8, 0.0, -10.8),\n                     \t\tvec3(0.0, -0.2, 0.7),\n                     \t\tvec3(0.5, 0.5, -0.1));\n    \n    balls[4].num = 6;\n    balls[4].mtx = createCS(vec3(3.0, 0.0, 1.1),\n                     \t\tvec3(0.1, 0.5, -0.2),\n                     \t\tvec3(0.1, -0.1, 0.5));\n    \n    balls[5].num = 4;\n    balls[5].mtx = createCS(vec3(-2.7, 0.0, -1.5),\n                     \t\tvec3(0.3, 0.5, -0.2),\n                     \t\tvec3(0.1, -0.5, 0.4));\n\n\n    //create cue\n    mat4 trans = createCS(\tvec3(-9.60, -0.2, 15.0),\n                     \tvec3(0.5, -0.02, -1.0),\n                     \tvec3(0.1, 1.0, 0.3));\n    cue.mtx = trans;\n    cue.r0 = 0.45; \n    cue.r1 = 0.2;\n    cue.h = 37.0;\n    \n    //Create chalk\n    trans = createCS(\tvec3(-0.1, -0.7, 5.8),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    chalk.mtx = trans;\n    chalk.size = 0.6;\n    \n    table.size = vec2(3.0, 2.0)*15.0;\n    table.pos = vec3(0.0, -1.0, -4.0);\n    \n    //Create materials\n    // diff color, diff_tex, spec, roughness, roughness_tex, weight, weight_tex, normal_map, tex_scale, Material\n    createMaterial(vec3(0.2, 0.6, 0.3),  8, vec3(1.0, 1.0, 1.0), 0.015, -1, 0.0, -1,  8, 1.0, mtl[0]);//fabric\n    createMaterial(vec3(1.0, 1.0, 1.0),  7, vec3(1.0, 1.0, 1.0), 0.000,  1, 0.5, -1,  1, 1.0, mtl[1]);//cue\n    createMaterial(vec3(0.3, 0.5, 1.0),  5, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.4, -1, -1, 1.0, mtl[2]);//ball 9\n    createMaterial(vec3(0.0, 0.2, 0.4),  4, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.4, -1, -1, 1.0, mtl[3]);//ball 7\n    createMaterial(vec3(1.0, 1.0, 1.0),  6, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.4, -1, -1, 1.0, mtl[4]);//ball 1\n    createMaterial(vec3(0.2, 0.5, 0.8), -1, vec3(1.0, 1.0, 1.0), 0.400, -1, 0.2, -1, -1, 1.0, mtl[5]);//chalk\n    createMaterial(vec3(0.3, 0.5, 1.0),  9, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.4, -1, -1, 1.0, mtl[6]);//ball 8\n    createMaterial(vec3(0.2, 0.8, 0.2), 10, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.4, -1, -1, 1.0, mtl[7]);//ball 6\n    createMaterial(vec3(0.2, 0.8, 0.2), 11, vec3(1.0, 1.0, 1.0), 0.001, -1, 0.4, -1, -1, 1.0, mtl[8]);//ball 4\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(1.0 - Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n//taken from: https://www.shadertoy.com/view/4sSSW3\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n) {\n    vec3 x;\n    vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 sampleHemisphereCosWeighted( in float Xi1, in float Xi2 ) {\n    float theta = acos(clamp(sqrt(1.0-Xi1),-1.0, 1.0));\n    float phi = TWO_PI * Xi2;\n\n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n// ************************   Scattering functions  *************************\nbool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){ return ((dot(n,a)*dot(n,b))>0.0); }\nbool sameHemisphere(in vec3 a, in vec3 b){ return (a.z*b.z>0.0); }\n\nfloat cosTheta(vec3 w) { return w.z; }\nfloat cosTheta2(vec3 w) { return cosTheta(w)*cosTheta(w); }\nfloat absCosTheta(vec3 w) { return abs(w.z); }\nfloat sinTheta2(vec3 w) { return max(0.0, 1.0 - cosTheta2(w)); }\nfloat sinTheta(vec3 w) { return sqrt(sinTheta2(w)); }\nfloat tanTheta2(vec3 w) { return sinTheta2(w) / cosTheta2(w); }\nfloat tanTheta(vec3 w) { return sinTheta(w) / cosTheta(w); }\nfloat cosPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 1.0 : clamp(w.x / sin_Theta, -1.0, 1.0); }\nfloat sinPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 0.0 : clamp(w.y / sin_Theta, -1.0, 1.0); }\nfloat cosPhi2(vec3 w) { return cosPhi(w) * cosPhi(w); }\nfloat sinPhi2(vec3 w) { return sinPhi(w) * sinPhi(w); }\n\nfloat ggx_eval(vec3 wh, float alphax, float alphay) {\n    float tan2Theta = tanTheta2(wh);\n    if (is_inf(tan2Theta)) return 0.;\n    float cos4Theta = cosTheta2(wh) * cosTheta2(wh);\n    float e = ((cosPhi2(wh) + sinPhi2(wh)) / (alphax * alphay)) * tan2Theta;\n    return 1.0 / (PI * (alphax * alphay) * cos4Theta * (1.0 + e) * (1.0 + e));\n}\n\nvec3 ggx_sample(vec3 wi, float alphax, float alphay, float Xi1, float Xi2) {\n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(Xi1);\n    float phi = (Xi2 < a) ? Xi2 / a*PI : PI + (Xi2 - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((Xi2 < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\nfloat ggx_lambda(vec3 w, float alphax, float alphay) {\n    float absTanTheta = abs(tanTheta(w));\n    if (is_inf(absTanTheta)) return 0.;\n    // Compute _alpha_ for direction _w_\n    float alpha_ = sqrt((cosPhi2(w) + sinPhi2(w)) * (alphax * alphay));\n    float alpha2Tan2Theta = (alpha_ * absTanTheta) * (alpha_ * absTanTheta);\n    return (-1.0 + sqrt(1.0 + alpha2Tan2Theta)) / 2.0;\n}\n\nfloat ggx_g1(vec3 w, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(w, alphax, alphay));\n}\n\nfloat ggx_g(vec3 wo, vec3 wi, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(wo, alphax, alphay) + ggx_lambda(wi, alphax, alphay));\n}\n\nfloat ggx_pdf(vec3 wi, vec3 wh, float alphax, float alphay) {\n    return ggx_eval(wh, alphax, alphay) * ggx_g1(wi, alphax, alphay) * abs(dot(wi, wh)) / abs(wi.z);\n}\n\nfloat pow2(in float x) { return x*x; } \nfloat pow5(in float x) { return pow2(x*x)*x; } \nfloat SchlickFresnel(in float IOR, float cosTheta) {\n    float R0 = pow2((1.0 - IOR) / (1.0 + IOR));\n    return R0 + pow5(1.0 - cosTheta) * (1.0 - R0);\n}\n\nvec3 mtlEval(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    float alpha = mtl.specular_roughness_;\n    \n    if(!sameHemisphere(E_local, L_local)) {\n        return vec3(0.0);\n    }\n    \n    //Specular reflection ***********************************\n    float cosThetaO = abs(E_local.z), cosThetaI = abs(L_local.z);\n    vec3 wh = L_local + E_local;\n    // Handle degenerate cases for microfacet reflection\n    if (cosThetaI == 0.0 || cosThetaO == 0.0) return vec3(0.);\n    if (wh.x == 0.0 && wh.y == 0.0 && wh.z == 0.0) return vec3(0.);\n    \n    wh = normalize(wh);\n    \n    float F = SchlickFresnel(1.5, dot(L_local, wh));\n    float D = ggx_eval(wh, alpha, alpha);\n    float G = ggx_g(E_local, L_local, alpha, alpha);\n    vec3 ks = mtl.specular_color_;\n    vec3 kd = mtl.diffuse_color_;\n    \n    vec3 spec = (ks * F * D * G) / (4.0 * cosThetaI * cosThetaO);\n    vec3 diff = kd * vec3(INV_PI) * (1.0 - F);\n\n    return \tmix(diff, spec, mtl.specular_weight_);\n}\n\nfloat pdfDiffuse(in vec3 L_local) {\n    return INV_PI * L_local.z;\n}\n\nfloat pdfSpecular(in vec3 E_local, in vec3 L_local, in float alpha) {\n    vec3 wh = normalize(E_local + L_local);\n    return ggx_pdf(E_local, wh, alpha, alpha) / (4.0 * dot(E_local, wh));\n}\n\nvec3 mtlSample(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in float Xi1, in float Xi2, out vec3 L, out float pdf, out float spec) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    //convert directions to local space\n    vec3 E_local = inv_trans * E;\n    vec3 L_local;\n    \n    float alpha = mtl.specular_roughness_;\n    \n    \n    //vec3 fr = fresnelConductor(dot(L_local, wh), vec3(1.5/1.0), vec3(1.0));\n    float F = (mtl.specular_weight_ == 0.0)?0.0:0.5;//min(fr.x, min(fr.y, fr.z));\n    //Sample specular or diffuse lobe based on fresnel\n    if(rnd() < F) {\n        // Sample microfacet orientation $\\wh$ and reflected direction $\\wi$\n        if (E_local.z == 0.0) return vec3(0.);\n        vec3 wh = ggx_sample(E_local, alpha, alpha, Xi1, Xi2);\n        if (!sameHemisphere(vec3(0.0, 0.0, 1.0), E_local, wh)) {\n            wh = -wh;\n        }\n        \n        L_local = reflect(E_local, wh);\n    \n        if(!sameHemisphere(E_local, L_local)){\n           L_local = -L_local;\n        }\n    } else {\n        L_local = sampleHemisphereCosWeighted( Xi1, Xi2 );\n    }\n    \n    if (!sameHemisphere(E_local, L_local)) {\n        pdf = 0.0;\n    } else {\n        // Compute PDF of _wi_ for microfacet reflection\n        pdf = \tpdfSpecular(E_local, L_local, alpha) * F +\n            \tpdfDiffuse(L_local) * (1.0 - F);\n    }\n  \n    //convert directions to global space\n    L = trans*L_local;\n    \n    if(!sameHemisphere(Ns, E, L) || !sameHemisphere(Ng, E, L)) {\n        pdf = 0.0;\n    }\n    \n    return mtlEval(mtl, Ng, Ns, E, L);\n}\n\nfloat mtlPdf(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    float alpha = mtl.specular_roughness_;\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    vec3 wh = normalize(E_local + L_local);\n    //vec3 fr = fresnelConductor(dot(L_local, wh), vec3(1.5/1.0), vec3(1.0));\n    float F = 0.5;//min(fr.x, min(fr.y, fr.z));\n    \n    return pdfSpecular(E_local, L_local, alpha) * F +\n           pdfDiffuse(L_local)*(1.0 - F);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, vec3 pmin, vec3 pmax, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 OMIN = ( pmin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( pmax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        vec3 p = ray.origin + ray.dir*t;\n        vec3 dim = pmax - pmin;\n        \n        if( EQUAL_FLT( p.x, pmin.x, EPSILON ) ) {\n            isect.normal_  =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_ = (p.zy - pmin.zy) / dim.zy;\n        } else if( EQUAL_FLT( p.x, pmax.x, EPSILON ) ) {\n            isect.normal_  =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_ = (p.zy - pmin.zy) / dim.zy;\n        } else if( EQUAL_FLT( p.y, pmin.y, EPSILON ) ) {\n            isect.normal_  =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_ = (p.xz - pmin.xz) / dim.xz;\n        } else if( EQUAL_FLT( p.y, pmax.y, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_ = (p.xz - pmin.xz) / dim.xz;\n        } else if( EQUAL_FLT( p.z, pmin.z, EPSILON ) ) {\n            isect.normal_  =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_ = (p.xy - pmin.xy) / dim.xy;\n        } else if( EQUAL_FLT( p.z, pmax.z, EPSILON ) ) {\n            isect.normal_  =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_ = (p.xy - pmin.xy) / dim.xy;\n        }\n        isect.position_ = p;\n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool rayConeIntersection( in Ray r, in float radius, in float radius2, in float height1, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float height = (height1 * radius) / (radius - radius2);\n\tfloat phi;\n\tvec3 phit;\n    \n    float k = radius / height;\n    k = k * k;\n    \n    float a = r.dir.x * r.dir.x + r.dir.y * r.dir.y - k * r.dir.z * r.dir.z;\n    float b = 2.0 * (r.dir.x * r.origin.x + r.dir.y * r.origin.y - k * r.dir.z * (r.origin.z - height));\n    float c = r.origin.x * r.origin.x + r.origin.y * r.origin.y - k * (r.origin.z - height) * (r.origin.z - height);\n    \n\t// Compute quadratic cylinder coefficients\n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < 0.0) || (phit.z > height1) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < 0.0) || (phit.z > height1) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = phi/TWO_PI;//(maxZ - minZ);\n        isect.uv_.y = (phit.z)/(height1);///maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\n//intersect unit radius sphere\nbool intersectSphere(Ray r, vec3 sph_o, out float t) { \n    float t0, t1;\n    \n    vec3 L = r.origin - sph_o; \n    float a = dot(r.dir, r.dir); \n    float b = 2.0 * dot(r.dir, L); \n    float c = dot(L, L) - 1.0; \n\n    if (!solveQuadratic(a, b, c, t0, t1)) return false;\n    if (t0 > t1) { float tmp = t0; t0 = t1; t1 = tmp; }\n    if (t0 < 0.0) { t0 = t1; if (t0 < 0.0) return false; }\n    t = t0; \n\n    return true;\n}\n\nbool rayZPlaneIntersection( in Ray ray, in vec3 pos, in vec2 size, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.y ) )\n    \treturn false;\n    \n    vec3 ro = ray.origin - pos;\n    t = ( -ro.y ) / ray.dir.y;\n    \n    isect.position_ = ro + ray.dir*t;\n    \n    if( (isect.position_.x < -size.x*0.5) ||\n       \t(isect.position_.x > size.x*0.5) ||\n      \t(isect.position_.z < -size.y*0.5) ||\n      \t(isect.position_.z > size.y*0.5) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_ = (isect.position_.xz - (-size*0.5)) / size;\n        isect.normal_ \t\t= vec3( 0.0, 1.0, 0.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    float t;\n    Material res_mtl;\n    \n    //intersect balls\n    int ballNum = -1;\n    for(int i=0; i<6; i++) {\n        vec3 pos = balls[i].mtx[3].xyz;\n        if(intersectSphere(ray, pos, t) && (t > distMin) && (t < nearestDist)) {\n            ballNum = balls[i].num;\n            vec3 p = ray.origin + ray.dir * t;\n            hit.normal_ = /*normalize*/(p - pos);//try to remove it's not needed\n            hit.tangent_ = normalize(orthogonalize(hit.normal_, balls[i].mtx[1].xyz));\n            hit.position_ = p;\n\n            if(!forShadowTest) {\n            \tmat4 inv_mtx = inverse(balls[i].mtx);\n\n            \tvec3 p_local = toVec3( inv_mtx*vec4(p, 1.0));\n                float rho, phi, theta;\n            \tcartesianToSpherical( p_local, rho, phi, theta );\n            \thit.uv_.x = clamp((phi+PI*0.5)/PI, 0.0, 1.0);\n            \thit.uv_.y = clamp((theta+PI)/TWO_PI, 0.0, 1.0);\n                \n                /*\n                if(ballNum == 9) {\n                    createMaterial(vec3(0.),  5, vec3(1.0), 0.001, -1, 0.4, -1, -1, 1.0, res_mtl);\n                    mtl.diffuse_color_ = getBallTexture(uv, vec3(0.6, 0.6, 0.0), false, 9);\n                } else if(ballNum == 7) {\n                    createMaterial(vec3(0.),  4, vec3(1.0), 0.001, -1, 0.4, -1, -1, 1.0, res_mtl);\n\t\t\t\t\tmtl.diffuse_color_ = getBallTexture(uv, vec3(0.5, 0.0, 0.02), true, 7);\n                } else if(ballNum == 1) {\n                    createMaterial(vec3(0.),  6, vec3(1.0), 0.001, -1, 0.4, -1, -1, 1.0, res_mtl);\n\t\t\t\t\tmtl.diffuse_color_ = getBallTexture(uv, vec3(0.6, 0.6, 0.1), true, 1);\n                } else if(ballNum == 8) {\n                    createMaterial(vec3(0.),  9, vec3(1.0), 0.001, -1, 0.4, -1, -1, 1.0, res_mtl);\n\t\t\t\t\tmtl.diffuse_color_ = getBallTexture(uv, vec3(0.01, 0.01, 0.01), true, 8);\n                } else if(ballNum == 6) {\n                    createMaterial(vec3(0.), 10, vec3(1.0), 0.001, -1, 0.4, -1, -1, 1.0, res_mtl);\n\t\t\t\t\tmtl.diffuse_color_ = getBallTexture(uv, vec3(0.0, 0.4, 0.0), true, 6);\n\t\t\t\t} else {//if(ballNum == 4) {\n                    createMaterial(vec3(0.), 11, vec3(1.0), 0.001, -1, 0.4, -1, -1, 1.0, res_mtl);\n\t\t\t\t\tmtl.diffuse_color_ = getBallTexture(uv, vec3(0.26, 0.24, 0.43), true, 4);\n                }*/\n            }\n\n            nearestDist = t;\n        }\n    }\n    \n    if(ballNum != -1) {\n        if(ballNum == 9) {\n            hit.mtl_id_ = SURFACE_ID_BASE+2;\n        } else if(ballNum == 7) {\n            hit.mtl_id_ = SURFACE_ID_BASE+3;\n        } else if(ballNum == 1) {\n            hit.mtl_id_ = SURFACE_ID_BASE+4;\n        } else if(ballNum == 8) {\n            hit.mtl_id_ = SURFACE_ID_BASE+6;\n        } else if(ballNum == 6) {\n            hit.mtl_id_ = SURFACE_ID_BASE+7;\n        } else /*if(ballNum == 4) */{\n            hit.mtl_id_ = SURFACE_ID_BASE+8;\n        }\n    }\n    \n    SurfaceHitInfo currentHit;\n    \n    //intersect light\n    bool hit_result = rayZPlaneIntersection( ray, light.pos, light.size, forShadowTest, t, currentHit );\n    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {\n        //Convert results to world space\n        currentHit.position_ = ray.origin + ray.dir * t;\n        currentHit.normal_   = vec3(0.0, -1.0, 0.0);\n        currentHit.tangent_  = vec3(-1.0, 0.0, 0.0);\n\n        nearestDist = t;\n        hit = currentHit;\n        hit.mtl_id_ = LIGHT_ID_BASE+0;\n    }\n    \n    //intersect table\n    float distToTable;\n    hit_result = rayZPlaneIntersection( ray, table.pos, table.size, forShadowTest, distToTable, currentHit );\n    if( hit_result && ( distToTable > distMin ) && ( distToTable < nearestDist ) ) {\n        hit = currentHit;\n        hit.position_ = ray.origin + ray.dir * distToTable;\n        hit.normal_   = vec3(0.0, 1.0, 0.0);\n        hit.tangent_  = vec3(1.0, 0.0, 0.0);\n        hit.mtl_id_ = SURFACE_ID_BASE+0;\n        \n        //createMaterial(vec3(0.),  8, vec3(1.0), 0., -1, 0., -1,  8, 1.0, res_mtl);\n        //mtl.diffuse_color_ = getFabricColor(hit.uv_);\n        \n        nearestDist = distToTable;\n    }\n    \n    //intersect cue\n    mat4 inv_mtx = inverse(cue.mtx);\n    Ray rayLocal;\n    rayLocal.origin = toVec3( inv_mtx*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( inv_mtx*vec4( ray.dir   , 0.0 ) );\n    \n    float h = (cue.h * cue.r0) / (cue.r0 - cue.r1);\n    hit_result = rayConeIntersection( rayLocal, cue.r0, cue.r1, cue.h, forShadowTest, t, currentHit );\n    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {\n        hit = currentHit;\n        hit.position_ = ray.origin + ray.dir * t;\n        hit.normal_   = toVec3( cue.mtx*vec4( currentHit.normal_  , 0.0 ) );\n        hit.tangent_  = toVec3( cue.mtx*vec4( currentHit.tangent_ , 0.0 ) );\n        hit.mtl_id_ = SURFACE_ID_BASE+1;\n\n        //createMaterial(vec3(0.), 7, vec3(1.), 0., 1, 0.5, -1,  -1, 1.0, res_mtl);\n        //mtl.diffuse_color_ = getCueTexture(uv);\n        //mtl.specular_roughness_ = (1.0 - sqrt(texture( iChannel1, uv ).x));\n        \n        nearestDist = t;\n    }\n    \n    //intersect chalk\n    inv_mtx = inverse(chalk.mtx);\n    rayLocal.origin = toVec3( inv_mtx*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( inv_mtx*vec4( ray.dir   , 0.0 ) );\n    \n    hit_result = rayAABBIntersection( rayLocal, -vec3(chalk.size*0.5), vec3(chalk.size*0.5), forShadowTest, t, currentHit );\n    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {\n        hit = currentHit;\n        hit.position_ = ray.origin + ray.dir * t;\n        //currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        hit.normal_   = toVec3( chalk.mtx*vec4( currentHit.normal_  , 0.0 ) );\n        hit.tangent_  = toVec3( chalk.mtx*vec4( currentHit.tangent_ , 0.0 ) );\n        hit.mtl_id_ = SURFACE_ID_BASE+5;\n\n        nearestDist = t;\n    }\n    \n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV,\n                \tin float radius,\n                \tin float focus_dist\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n    camera.focusDist = focus_dist;\n    camera.lensSize = radius;\n}\n\nvoid updateCamera( int strata ) {\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    camera.pos = vec3( 3.3, 6.0, 18.0 );\n    vec3 target = vec3( 0.3, -1.0, -4.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 uv, float ratio, in float Xi1, in float Xi2 ) {\n    Ray ray;\n    \n    vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(uv - 0.5)*iPlaneSize;\n    \n    if( camera.lensSize > EPSILON ) {\n        vec2 uv = uniformPointWithinCircle( camera.lensSize, rnd(), rnd() );\n        vec3 newPos = camera.pos + camera.rotate[0]*uv.x*camera.lensSize + camera.rotate[1]*uv.y*camera.lensSize;\n        vec3 focusPoint = camera.pos - camera.focusDist*camera.rotate[2];\n        vec3 newBack = normalize(newPos - focusPoint);\n        vec3 newRight = normalize( cross( camera.rotate[1], newBack ) );\n        vec3 newUp = cross( newBack, newRight );\n        mat3 newRotate;\n        newRotate[0] = newRight;\n        newRotate[1] = newUp;\n        newRotate[2] = newBack;\n\n        ray.origin = newPos;\n        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    } else {\n        ray.origin = camera.pos;\n        ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    }\n\n\treturn ray;\n}\n\n#ifdef SPHERICAL_RECTANGLE\nstruct SphQuad {\n    vec3 o, x, y, z; // local reference system ’R’\n    float z0, z0sq; //\n    float x0, y0, y0sq; // rectangle coords in ’R’\n    float x1, y1, y1sq; //\n    float b0, b1, b0sq, k; // misc precomputed constants\n    float S; // solid angle of ’Q’\n};\n    \nvoid SphQuadInit(vec3 s,vec3 ex,vec3 ey,vec3 o, out SphQuad squad) {\n    squad.o = o;\n    float exl = length(ex), eyl = length(ey);\n    // compute local reference system ’R’\n    squad.x = ex / exl;\n    squad.y = ey / eyl;\n    squad.z = cross(squad.x, squad.y);\n    // compute rectangle coords in local reference system\n    vec3 d = s - o;\n    squad.z0 = dot(d, squad.z);\n    // flip ’z’ to make it point against ’Q’\n    if (squad.z0 > 0.) {\n    squad.z *= -1.;\n    squad.z0 *= -1.;\n    }\n    squad.z0sq = squad.z0 * squad.z0;\n    squad.x0 = dot(d, squad.x);\n    squad.y0 = dot(d, squad.y);\n    squad.x1 = squad.x0 + exl;\n    squad.y1 = squad.y0 + eyl;\n    squad.y0sq = squad.y0 * squad.y0;\n    squad.y1sq = squad.y1 * squad.y1;\n    // create vectors to four vertices\n    vec3 v00 = vec3(squad.x0, squad.y0, squad.z0);\n    vec3 v01 = vec3(squad.x0, squad.y1, squad.z0);\n    vec3 v10 = vec3(squad.x1, squad.y0, squad.z0);\n    vec3 v11 = vec3(squad.x1, squad.y1, squad.z0);\n    // compute normals to edges\n    vec3 n0 = normalize(cross(v00, v10));\n    vec3 n1 = normalize(cross(v10, v11));\n    vec3 n2 = normalize(cross(v11, v01));\n    vec3 n3 = normalize(cross(v01, v00));\n    // compute internal angles (gamma_i)\n    float g0 = acos(-dot(n0,n1));\n    float g1 = acos(-dot(n1,n2));\n    float g2 = acos(-dot(n2,n3));\n    float g3 = acos(-dot(n3,n0));\n    // compute predefined constants\n    squad.b0 = n0.z;\n    squad.b1 = n2.z;\n    squad.b0sq = squad.b0 * squad.b0;\n    squad.k = 2.*PI - g2 - g3;\n    // compute solid angle from internal angles\n    squad.S = g0 + g1 - squad.k;\n}\n\nvoid SphQuadSample(in vec3 x, SphQuad squad, float u, float v, out LightSamplingRecord sampleRec) {\n    // 1. compute ’cu’\n    float au = u * squad.S + squad.k;\n    float fu = (cos(au) * squad.b0 - squad.b1) / sin(au);\n    float cu = 1./sqrt(fu*fu + squad.b0sq) * (fu>0. ? +1. : -1.);\n    cu = clamp(cu, -1., 1.); // avoid NaNs\n    // 2. compute ’xu’\n    float xu = -(cu * squad.z0) / sqrt(1. - cu*cu);\n    xu = clamp(xu, squad.x0, squad.x1); // avoid Infs\n    // 3. compute ’yv’\n    float d = sqrt(xu*xu + squad.z0sq);\n    float h0 = squad.y0 / sqrt(d*d + squad.y0sq);\n    float h1 = squad.y1 / sqrt(d*d + squad.y1sq);\n    float hv = h0 + v * (h1-h0), hv2 = hv*hv;\n    float yv = (hv2 < 1.-EPSILON) ? (hv*d)/sqrt(1.-hv2) : squad.y1;\n    // 4. transform (xu,yv,z0) to world coords\n    \n    vec3 p = (squad.o + xu*squad.x + yv*squad.y + squad.z0*squad.z);\n    sampleRec.w = p - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    sampleRec.pdf = 1. / squad.S;\n}\n\nvec3 sampleLightSource(in vec3 x, float Xi1, float Xi2, out LightSamplingRecord sampleRec) {\n    vec3 s = light.pos - vec3(1., 0., 0.) * light.size.x * 0.5 -\n        \t\t\t\t vec3(0., 0., 1.) * light.size.y * 0.5;\n    vec3 ex = vec3(light.size.x, 0., 0.);\n    vec3 ey = vec3(0., 0., light.size.y);\n    \n    SphQuad squad;\n    SphQuadInit(s, ex, ey, x, squad);\n    SphQuadSample(x, squad, Xi1, Xi2, sampleRec);\n\treturn getRadiance(vec2(Xi1,Xi2));\n}\n\nfloat sampleLightSourcePdf(in vec3 x, in vec3 wi, float d, float cosAtLight) {\n    vec3 s = light.pos - vec3(1., 0., 0.) * light.size.x * 0.5 -\n        \t\t\t\t vec3(0., 0., 1.) * light.size.y * 0.5;\n    vec3 ex = vec3(light.size.x, 0., 0.);\n    vec3 ey = vec3(0., 0., light.size.y);\n    \n    SphQuad squad;\n    SphQuadInit(s, ex, ey, x, squad);\n    return 1. / squad.S;\n}\n#else\nvec3 sampleLightSource(in vec3 x, float Xi1, float Xi2, out LightSamplingRecord sampleRec) {\n    vec3 p_global = light.pos + vec3(1., 0., 0.) * light.size.x * (Xi1 - 0.5) +\n        \t\t\t\t\t\tvec3(0., 0., 1.) * light.size.y * (Xi2 - 0.5);\n    vec3 n_global = vec3(0.0, -1.0, 0.0);\n    sampleRec.w = p_global - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    float cosAtLight = dot(n_global, -sampleRec.w);\n    vec3 L = cosAtLight>0.0?getRadiance(vec2(Xi1,Xi2)):vec3(0.0);\n    sampleRec.pdf = PdfAtoW(1.0 / (light.size.x*light.size.y), sampleRec.d*sampleRec.d, cosAtLight);\n    \n\treturn L;\n}\n\nfloat sampleLightSourcePdf(in vec3 x, in vec3 wi, float d, float cosAtLight) {\n    return PdfAtoW(1.0 / (light.size.x*light.size.y), d*d, cosAtLight);\n}\n#endif\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.mtl_id_ >= LIGHT_ID_BASE );\n}\n\nLight pickOneLight(out float lightPickingPdf) {\n    lightPickingPdf = 1.0;\n    return light;\n}\n\nvoid fixMtl(inout Material mtl, vec2 uv, out vec3 ns) {\n    uv *= mtl.tex_scale_;\n    if(mtl.diffuse_color_tex_!=-1){\n        mtl.diffuse_color_ = getColor(uv, mtl.diffuse_color_tex_);\n    }\n    \n    if(mtl.specular_roughness_tex_!=-1){\n        mtl.specular_roughness_ = (1.0 - sqrt(getColor(uv, mtl.specular_roughness_tex_).x));\n    } else {\n        mtl.specular_roughness_ = sqrt(mtl.specular_roughness_);\n    }\n    \n    if(mtl.specular_weight_tex_!=-1){\n        mtl.specular_weight_ = (getColor(uv, mtl.specular_weight_tex_).x);\n    }\n    if(mtl.normal_map_!=-1){\n        ns = getNormal(uv, mtl.normal_map_ );\n    } else {\n        ns = vec3(0.0, 0.0, 1.0);\n    }\n}\n\nvec3 sampleBSDF(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex,\n                \tout vec3 wo,\n                \tout float brdfPdfW,\n                \tout vec3 fr,\n                \tout bool hitRes,\n                \tout SurfaceHitInfo hit,\n               \t\tout float spec) {\n    vec3 Lo = vec3(0.0);\n    for(int i=0; i<DL_SAMPLES; i++){\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n        fr = mtlSample(mtl, ng, ns, wi, Xi1, Xi2, wo, brdfPdfW, spec);\n        \n        //fr = eval(mtl, ng, ns, wi, wo);\n\n        float dotNWo = dot(wo, ns);\n        //Continue if sampled direction is under surface\n        if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {\n            Ray shadowRay = Ray(x, wo);\n\n            //abstractLight* pLight = 0;\n            float cosAtLight = 1.0;\n            float distanceToLight = -1.0;\n            vec3 Li = vec3(0.0);\n\n            {\n                float distToHit;\n\n                if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {\n                    if(hit.mtl_id_>=LIGHT_ID_BASE) {\n                        distanceToLight = distToHit;\n                        cosAtLight = dot(hit.normal_, -wo);\n                        if(cosAtLight > 0.0) {\n                            Li = getRadiance(hit.uv_);\n                            //Li = lights[0].color_*lights[0].intensity_;\n                        }\n                    } else {\n                        hitRes = true;\n                    }\n                } else {\n                    hitRes = false;\n                    //TODO check for infinite lights\n                }\n            }\n\n            if (distanceToLight>0.0) {\n                if (cosAtLight > 0.0) {\n                    vec3 contribution = (Li * fr * dotNWo) / brdfPdfW;\n                    if (useMIS/* && !(mtl->isSingular())*/) {\n                        float lightPickPdf = 1.0;\n                        float lightPdfW = sampleLightSourcePdf( x, wi, distanceToLight, cosAtLight );\n                        contribution *= misWeight(brdfPdfW, lightPdfW);\n                    }\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 salmpleLight(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                  \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex ) {\n    vec3 Lo = vec3(0.0);\t//outgoing radiance\n\n    for(int i=0; i<DL_SAMPLES; i++) {\n        float lightPickingPdf = 1.0;\n        \n        vec3 wo;\n        float lightPdfW, lightDist;\n\n        LightSamplingRecord rec;\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n\n        vec3 Li = sampleLightSource( x, Xi1, Xi2, rec );\n        wo = rec.w;\n        lightPdfW = rec.pdf;\n        lightDist = rec.d;\n        lightPdfW *= lightPickingPdf;\n\n        float dotNWo = dot(wo, ns);\n\n        if ((dotNWo > 0.0) && (lightPdfW > EPSILON)) {\n            vec3 fr = mtlEval(mtl, ng, ns, wi, wo);\n            if(dot(fr,fr)>0.0) {\n                Ray shadowRay = Ray(x, wo);\n                if (isLightVisible( shadowRay )) {\n                    vec3 contribution = (Li * fr * dotNWo) / lightPdfW;\n\n                    if (useMIS /*&& !(light->isSingular())*/) {\n                        float brdfPdfW = mtlPdf(mtl, ng, ns, wi, wo);\n                        contribution *= misWeight(lightPdfW, brdfPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 Radiance( in Ray r, int strataCount, int strataIndex ) {\n    vec3 Lo = vec3(0.0), fr, directLight, pathWeight = vec3(1.0, 1.0, 1.0);\n    vec3 wo;\n    float woPdf;\n    float dotWoN;\n    bool hitResult;\n\n    //Calculate first intersections to determine first scattering event\n    Ray ray = r;\n    SurfaceHitInfo event;\n    SurfaceHitInfo nextEvent;\n    float dist;\n    if(!raySceneIntersection( ray, 0.0, false, event, dist )) {\n        return Lo;\n    } else {\n        //We have to add emmision component on first hit\n        if( event.mtl_id_ >= LIGHT_ID_BASE ) {\n            //Light light = getLight(event.mtl_id_ - LIGHT_ID_BASE);\n            float cosAtLight = dot(event.normal_, -ray.dir);\n            if(cosAtLight > 0.0) {\n                Lo = getRadiance(event.uv_);\n                //Lo = light.color_*light.intensity_;\n            }\n        }\n    }\n    \n    float prev_spec;\n\n    for (int i = 0; i < MAX_DEPTH; i++) {\n        if(event.mtl_id_>=LIGHT_ID_BASE){\n        \tbreak;\n    \t}\n        \n        vec3 x = event.position_;\n        vec3 wi = -ray.dir;\n        event.normal_ = -faceforward(event.normal_, wi, event.normal_);\n        \n        Material mtl = getMaterial(event.mtl_id_);\n    \tvec3 ng = event.normal_, ns;\n    \tfixMtl(mtl, event.uv_, ns);\n    \n        mat3 frame;\n        frame[0] = event.tangent_;\n        frame[1] = cross( ng, event.tangent_ );\n        frame[2] = ng;\n        ns = frame*ns;\n        \n        if (dot(wi,ns) < 0.0) { break; }\n        \n        if(i!=0) {\n            strataCount = 1; strataIndex = 0;\n        }\n        \n        float spec;\n\n        //Calculate direct light with 'Light sampling' and 'BSDF sampling' techniques\n        //In addition BSDF sampling does next event estimation and returns all necessary values which corresponds to next event\n       \tdirectLight  = salmpleLight (x, ng, ns, wi, mtl, true, strataCount, strataIndex);\n        directLight += sampleBSDF   (x, ng, ns, wi, mtl, true, strataCount, strataIndex, wo, woPdf, fr, hitResult, nextEvent, spec);\n       \n#ifdef CLAMP_CAUSTICS\n        if(i!=0) {\n            if(prev_spec < spec) {\n                break;\n            }\n        }\n        prev_spec = spec;\n#endif\n        \n        Lo += directLight*pathWeight;\n\n        if (!hitResult || (dotWoN = dot(event.normal_, wo))<0.0) { break; }\n        if (woPdf == 0.0) { break; }\n        pathWeight *= fr*dotWoN / woPdf;\n\n        //Update values for next iteration\n        ray = Ray(event.position_, wo);\n        event = nextEvent;\n    }\n\n    return Lo;\n}\n\nvec3 ClampColor(in vec3 c, in float maxVal) { return min(c, vec3(maxVal)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    vec2 renderingResolution = min(iResolution.xy, vec2(float(RENDERING_RES_X), float(RENDERING_RES_Y)));\n    \n#ifdef MULTIPLE_SAMPLES\n    vec2 pixelCoord = mod(fragCoord.xy, renderingResolution);\n#else\n    vec2 pixelCoord = fragCoord.xy;\n    if(fragCoord.x > renderingResolution.x ||\n      fragCoord.y > renderingResolution.y) discard;\n#endif\n    \n    float fov = radians(25.0);\n    initCamera( vec3(0.), vec3(0.), vec3(0.0, 1.0, 0.0), fov, LENS_SIZE, 23.0);\n    initScene();\n    \n    float ratio = renderingResolution.x/renderingResolution.y;\n    float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n    float strataSize = oneOverSPP;\n\n    vec3 accumulatedColor = vec3( 0.0 );\n    for( int si=0; si<PIXEL_SAMPLES; ++si ){\n        updateCamera( si );\n\t\tvec2 jitter = vec2( strataSize*( float(si) + rnd() ), rnd());\n        vec2 screen_uv = (pixelCoord.xy + jitter) / renderingResolution;//iResolution.xy;\n        Ray ray = genRay( screen_uv, ratio, rnd(), rnd() );\n        accumulatedColor += ClampColor(Radiance( ray, PIXEL_SAMPLES, si ), CLAMP_VALUE);\n    }\n\n    //devide to sample count\n    accumulatedColor = accumulatedColor*oneOverSPP;\n    \n    fragColor = vec4( accumulatedColor, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}