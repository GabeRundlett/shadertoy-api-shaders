{
    "Shader": {
        "info": {
            "date": "1634855572",
            "description": "Just a simple animation of a \"metallish\" metaball to try out some reflections\n\nhttps://twitter.com/NoxWings/status/1451230562564415499",
            "flags": 0,
            "hasliked": 0,
            "id": "7dtSDf",
            "likes": 50,
            "name": "Liquid Metalball",
            "published": 3,
            "tags": [
                "distortion",
                "metaball",
                "reflections",
                "metal",
                "liquid"
            ],
            "usePreview": 0,
            "username": "NoxWings",
            "viewed": 1313
        },
        "renderpass": [
            {
                "code": "// Scene\n\n#define NUM_REFLECTIONS 5\n\nconst float SURF_HIT = 0.01;\nconst float farPlane = 20.0;\nconst int maxSteps = 128;\n\nHit ground(in vec3 p) {\n    return Hit(0, -(length(p-vec3(0, 198.8, 0)) - 200.));\n}\n\nHit metaBall(in vec3 p) {\n    vec3 q = p;\n    q.y += A(cos(animTime * PI) * 1.0 + 1.7, 0.0, 0.0, 4.0);    \n    if (animTime > 10.0) {\n        float t = animTime - 10.0;\n        q.y += -2.5 * t + 0.5 * 10.0 * t*t;\n    }\n    \n    \n    q.xz *= rot2D(q.y);\n    \n    vec3 scale = A(vec3(1), vec3(0.5, 1.0, 0.5), 10., 11.);\n    q *= scale;\n    \n    float r = 1.0;\n    r = A(r, 0.2, 10., 10.5);\n\n    float amp = 0.1;\n    amp = A(amp, sin(animTime * 30.0) * .05 + 0.1, 8.0, 10.);\n    amp = A(amp, 1., 10., 10.5);\n    \n    r += amp * sin(q.x * 8.0 + animTime * 5.0) * sin(q.y * 8.0) * sin(q.z * 8.0);\n    float sphere = sdSphere(q, r);\n    \n    float definition = A(0.7, 0.3, 10., 10.5);\n    sphere *= definition;\n    \n\n    return Hit(1, sphere);\n}\n\nHit ballGround(in vec3 p) {\n    float blend = A(0.5, 0.0, 0.0, 8.0);\n    blend = A(blend, 0.5, 10.0, 11.0);\n\n    return hsmin(metaBall(p), ground(p), blend);\n}\n\nHit map(in vec3 p) {\n    Hit h = ballGround(p);\n    return h;\n}\n\nvec3 mapNormal(in vec3 p, float surfHit) {\n    vec2 e = vec2(0.01, 0.0);\n \tfloat d = map(p).d;\n    return normalize(vec3(\n        d - map(p - e.xyy).d,\n        d - map(p - e.yxy).d,\n        d - map(p - e.yyx).d\n    ));\n}\n\n// -----------------------------------------------------------------------------\n\n// Regular sphere tracing\n// If maxSteps is hit it returns the closest hit found\nTraceResult trace(in vec3 ro, in vec3 rd, in float maxDistance, in int maxSteps) {\n    float d = 0.0;\n    float closestD = maxDistance;\n    Hit closest = Hit(-1, maxDistance);\n    \n    for (int i=0; i < maxSteps && d < maxDistance; i++) {\n    \tvec3 p = ro + rd * d;\n        Hit h = map(p);\n        \n        if (h.d < closest.d) {\n            closest = h;\n            closestD = d;\n        }\n        if (h.d <= SURF_HIT) return TraceResult(closest.id, d, ro, rd);\n        \n        d += h.d;\n    }\n    \n    if (d >= maxDistance) {\n        return TraceResult(-1, maxDistance, ro, rd);\n    }\n\n    return TraceResult(-2, closestD, ro, rd);\n}\n\n// Sphere tracing for reflections\n//\n// If maxSteps is hit it reports the maxDistance\n// It also tries to step away from the surface it is reflecting \n// (mostly eyeballing here to avoid artifacts with bent space around the ball)\nTraceResult traceReflection(Surface s, in float maxDistance, in int maxSteps) {\n    vec3 ro = s.p + s.n * SURF_HIT * 2.0;\n    vec3 rd = reflect(s.rd, s.n);\n    \n    float d = SURF_HIT * 2.0;\n    for (int i=0; i < maxSteps && d < maxDistance; i++) {\n    \n    \tvec3 p = ro + rd * d;\n        Hit h = map(p);\n        \n        if (h.d < SURF_HIT) {\n            return TraceResult(h.id, d, ro, rd);\n        }\n        \n        d += h.d;\n    }\n    \n    return TraceResult(-1, maxDistance, ro, rd);\n}\n\nSurface getSurf(TraceResult tr) { \n    vec3 p = tr.ro + tr.rd * tr.d;\n    vec3 n = mapNormal(p, SURF_HIT);\n    float ao = 0.0;\n    \n    return Surface(\n        tr.id, // material id\n        tr.d,  // distance\n        p,    // position\n        n,    // normal\n        ao,   // ambient occlusion\n        tr.rd    // view ray direction\n    );\n}\n\nstruct LightingResult {\n    Material mat;\n    vec3 color;\n};\n\n// On one iteration I used an environment map for reflections too\n// but currently I'm not using it, I love the simplicity of the real reflections\nvec4 sampleEnv(in samplerCube samp, vec3 dir) {\n    dir.xz = rot2D(270. * DEG2RAD) * dir.xz;\n    return sRGBToLinear(texture(samp, dir));\n}\n\nMaterial matFromSurface(Surface s) {\n    Material m;\n    m.albedo    = vec3(0.0);\n    m.emissive  = vec3(0.0);\n    m.roughness = 1.0;\n    m.metallic  = 0.0;\n    m.ao = s.ao;\n\n    if (s.materialId == -1) {\n        m.albedo    = vec3(0.01);\n        m.roughness = 0.85;\n    } else if (s.materialId == 0) {\n        m.albedo    = vec3(0.01);\n        m.roughness = 0.0;\n    } else if (s.materialId == 1) {\n        m.albedo = vec3(0.1);\n        m.roughness = 0.1;\n        m.metallic = 1.0;\n    } else {\n        m.emissive = vec3(1, 0, 1);\n    }\n    \n    return m;\n}\n\nvec3 calculateLights(Surface s, Material m) {\n    const int lights = 2;\n    Light l[2];\n    l[0].direction = normalize(vec3(1, 1, 0));\n    l[0].ambient = vec3(0.01);\n    l[0].color = vec3(3.0);\n    l[1].direction = normalize(vec3(-1, 1, 0));\n    l[1].ambient = vec3(0.01);\n    l[1].color = vec3(3.0);\n    \n    vec3 color = vec3(0);\n    for (int i=0; i < lights; i++) {\n        vec3 cont = BRDF(l[i], s, m);\n        cont = max(cont, vec3(0));\n        color += cont;\n    }\n    \n    return color;\n}\n\nLightingResult surfaceLighting(inout Surface s) {  \n    if (s.materialId == -1) {\n        // Sky\n        // This one is a bit hacky, \n        // I wanted some kind of dome with somewhat interesting colors so that reflections looked good\n        // I think the dome actually ended up looking somewhat similar to a SH but it was already working this way...\n        s.p.y += 1.1;\n        vec3 n = normalize(vec3(s.p.x, s.p.y, s.p.z));\n\n        Surface floorS = Surface(\n            0,\n            s.dist,\n            s.p,\n            vec3(0,1,0),\n            s.ao,\n            s.rd\n        );\n        Material floorM = matFromSurface(s);\n        vec3 floorColor = calculateLights(floorS, floorM);\n        \n        float floorBlend = S(-.2, 1.2, n.y);\n        \n        Material m = matFromSurface(s);\n        s.n = n;\n        m.roughness = 1.0;\n        \n        vec3 color = mix(floorColor, vec3(0), floorBlend);\n        \n        return LightingResult(m, color);\n    } else if (s.materialId == 0) {\n        // Floor\n        \n        Material m = matFromSurface(s);\n        vec3 floorColor = calculateLights(s, m);\n        \n        return LightingResult(m, floorColor);\n    } else if (s.materialId == 1) {\n        // Ball\n        // The floor part here is for the ball, surface parameter blending\n        // I should probably do something a bit more clear to blend surface parameters\n    \n        Surface floorS = Surface(\n            0,\n            s.dist,\n            s.p,\n            s.n,\n            s.ao,\n            s.rd\n        );\n        Material floorM = matFromSurface(floorS);\n        vec3 floorColor = calculateLights(floorS, floorM);\n        \n        Material m = matFromSurface(s);\n        vec3 ballColor = calculateLights(s, m);\n        \n        float blend = S(-1.1, -0.9, s.p.y); \n        vec3 color = mix(floorColor, ballColor, blend);\n        \n        m.metallic = mix(floorM.metallic, m.metallic, blend);\n        m.roughness = mix(floorM.roughness, m.roughness, blend);\n        \n        return LightingResult(m, color);\n    } else {\n        // error, unset material\n        Material m = matFromSurface(s);\n        vec3 color = calculateLights(s, m);\n        return LightingResult(m, color);\n    }\n}\n\nvec3 lighting(Surface s) {\n    LightingResult current = surfaceLighting(s);\n    vec3 color = current.color;\n    \n    const int reflections = NUM_REFLECTIONS;\n    float extinction = 1.0;\n    \n    for (int i = 0; i < reflections; i++) {\n        TraceResult rh = traceReflection(s, farPlane, maxSteps);\n        \n        s = getSurf(rh);\n        \n        float refAmount = (1.0 - current.mat.roughness);\n        extinction *= refAmount;\n        \n        current = surfaceLighting(s);\n        color += extinction * saturate(current.color) * 0.6;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 screen = uv * 2.0 - 1.0;\n    screen.x *= iResolution.x / iResolution.y;\n    \n    float xCam = A(0.0, -0.2, 0.0, 3.0);\n    xCam = A(xCam, -0.65, 0.0, 9.0);\n    xCam = A(xCam, -0.95, 8.5, 10.0);\n    xCam = A(xCam, -1.0, 10.0, 11.0);\n    \n    float yCam = A(-0.25, -0.08, 0.3, 1.0);\n    yCam = A(yCam, -0.3, 0.5, 2.5);\n    yCam = A(yCam, -0.08, 0.5, 3.0);\n    yCam = A(yCam, -0.06, 4.0, 10.0);\n    yCam = A(yCam, 0.15, 10.0, 10.5);\n    yCam = A(yCam, -0.25, 10.0, 11.0);\n    \n    float camDist = A(1.5, 5.5, 0.0, 2.0);\n    camDist = A(camDist, 3.5, 0.0, 3.0);\n    camDist = A(camDist, 4.0, 3.0, 5.0);\n    camDist = A(camDist, 4.5, 4.0, 7.0);\n    camDist = A(camDist, 3.5, 7.0, 10.0);\n    camDist = A(camDist, 2.0, 9.5, 10.5);\n    camDist = A(camDist, 2.5, 10.0, 11.);\n    \n    Camera cam = createOrbitCamera(\n        screen, \n        vec2(xCam, yCam) *  PI, \n        iResolution.xy, \n        60.0 * DEG2RAD, \n        vec3(0, 0.5, 0), \n        0.0, \n        camDist\n    );\n\n    vec3 ro = cam.position;\n    vec3 rd = cam.direction;\n    \n    TraceResult tr = trace(ro, rd, farPlane, maxSteps);\n    Surface s = getSurf(tr);\n    \n    vec4 col = vec4(lighting(s), 1.0);\n    col = ACESFilm(col);\n    col = linearTosRGB(col);\n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Common / Framework stuff\n\n// -----------------------------------------------------------------------------\n// Basics / Math\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define animTime (mod(iTime, 11.))\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,animTime))\n\nfloat invLerp(float a, float b, float x) {\n    x = clamp(x, a, b);\n    return (x - a) / (b - a);\n}\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float DEG2RAD = PI / 180.;\n\nfloat saturate(in float x) { return clamp(x, 0.0, 1.0); }\nvec2 saturate(in vec2 x) { return clamp(x, vec2(0.0), vec2(1.0)); }\nvec3 saturate(in vec3 x) { return clamp(x, vec3(0.0), vec3(1.0)); }\nvec4 saturate(in vec4 x) { return clamp(x, vec4(0.0), vec4(1.0)); }\n\nmat2 rot2D(float angle) {\n    float ca = cos(angle), sa = sin(angle);\n    return mat2(ca, -sa, sa, ca);\n}\n\nmat3 lookAtMatrix(in vec3 lookAtDirection) {\n\tvec3 ww = normalize(lookAtDirection);\n    vec3 uu = cross(ww, vec3(0.0, 1.0, 0.0));\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, -ww);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n\n// -----------------------------------------------------------------------------\n// Colors\n\nvec4 linearTosRGB(vec4 linearRGB)\n{\n    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = linearRGB * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec4 sRGBToLinear(vec4 sRGB)\n{\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n   \nvec4 ACESFilm(vec4 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n   \n// -----------------------------------------------------------------------------\n// Hits\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k) {\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\n\nstruct Hit {\n    int id;\n    float d; // means distance to surface\n};\n\nstruct TraceResult {\n    int id;\n    float d; // means distance traveled\n    vec3 ro;\n    vec3 rd; \n};\n\nHit hmin(in Hit a, in Hit b) { if (a.d < b.d) return a; return b; }\nHit hmax(in Hit a, in Hit b) { if (a.d > b.d) return a; return b; }\nHit hsmin(in Hit a, in Hit b, in float k) {\n    Hit h = hmin(a, b);\n    h.d = smin(a.d, b.d, k);\n    return h;\n}\nHit hsmax(in Hit a, in Hit b, in float k) {\n    Hit h = hmax(a, b);\n    h.d = smin(a.d, b.d, k);\n    return h;\n}\n\n// -----------------------------------------------------------------------------\n// Materials\n\nstruct Light {\n    vec3 direction;\n    vec3 ambient;\n    vec3 color;\n};\n\nstruct Surface {\n    int materialId;\n    float dist;\n    vec3 p;\n    vec3 n;\n    float ao;\n    vec3 rd;\n};\n    \nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emissive;\n    float ao;\n};\n\n// -----------------------------------------------------------------------------\n// SDFs\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// -----------------------------------------------------------------------------\n// Camera\n\nstruct Camera {\n    vec3 position;\n\tvec3 direction;\n};\n\nCamera createOrbitCamera(vec2 uv, vec2 mouse, vec2 resolution, float fov, vec3 target, float height, float distanceToTarget) {\n    vec2 r = mouse;\n    float halfFov = fov * 0.5;\n    float zoom = cos(halfFov) / sin(halfFov);\n    \n    vec3 position = target + vec3(0, height, 0) + vec3(sin(r.x), 0.0, cos(r.x)) * distanceToTarget ;\n    vec3 direction = normalize(vec3(uv, -zoom));\n    direction.yz = rot2D(-r.y) * direction.yz;\n    direction = lookAtMatrix(target - position) * direction;\n    \n    return Camera(position, direction);\n}\n\n// -----------------------------------------------------------------------------\n// PBR Implementation\n// - Lambert or Burley diffuse    \n// - Schlick Fresnel\n// - GGX NDF\n// - Smith-GGX height-correlated visibility function\n\n// Sources\n// \n// https://learnopengl.com/PBR/Lighting\n// https://google.github.io/filament/Filament.html\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation\n    \nvec3 F_Schlick_full(float HoV, vec3 f0, vec3 f90) {\n    return f0 + (f90 - f0) * pow(1.0 - HoV, 5.0);\n} \n\nvec3 F_Schlick(float HoV, vec3 f0) {\n    return F_Schlick_full(HoV, f0, vec3(1.0));\n} \n    \nfloat Diff_Lambert() {\n    return 1.0 / PI;\n}\n\nvec3 Diff_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    vec3 lightScatter = F_Schlick_full(NoL, vec3(1.0), vec3(f90));\n    vec3 viewScatter = F_Schlick_full(NoV, vec3(1.0), vec3(f90));\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat D_GGX(float NoH, float a) {\n    float a2 = a * a;\n    float f = (NoH * a2 - NoH) * NoH + 1.0;\n    return a2 / (PI * f * f);\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float a) {\n    float a2 = a * a;\n    float NoV2 = NoV*NoV;\n    float NoL2 = NoL*NoL;\n    float GGL = NoL * sqrt(NoV2 * (1.0 - a2) + a2);\n    float GGV = NoV * sqrt(NoL2 * (1.0 - a2) + a2);\n\treturn 0.5 / (GGL + GGV);\n}\n\nfloat GGX_Smith_Approx_Visibility(float NoV, float NoL, float a) {\n    return 1.0 / (2.0 * mix(2.0*NoL*NoV, NoL+NoV, a));\n}\n\nvec3 BRDF(Light l, Surface surf, Material mat) {\n    vec3 V = -surf.rd;\n    vec3 N = surf.n;\n    vec3 L = l.direction;\n    vec3 H = normalize(V + L);\n    \n    float NoV = max(dot(N, V), 0.0);\n    float NoL = max(dot(N, L), 0.0);\n    float NoH = max(dot(N, H), 0.0);\n    float HoV = max(dot(H, V), 0.0);\n    \n    vec3  albedo     = mat.albedo;\n    float roughness  = mat.roughness;\n    float a          = roughness * roughness;\n    float metallic   = mat.metallic;\n    float dielectric = 1.0 - metallic;\n    \n    // Constants\n    vec3 dielectricSpecular = vec3(0.04);\n    vec3 black = vec3(0);\n    \n    // Frenel term\n    vec3 F0 = mix(dielectricSpecular, albedo, metallic);\n    vec3 F  = F_Schlick(HoV, F0);\n    \n    // Normal distribution\n    float D = D_GGX(NoH, a);\n    \n    // Visibility term\n    //     should be equivalent to G / (4.0 * NoL * NoV)\n    //     but it doesn't look the same as https://www.shadertoy.com/view/tdKXR3\n    float Vis = V_SmithGGXCorrelated(NoV, NoL, a);\n    \n    // Specular BRDF Cook Torrance\n    vec3 specular = F * (Vis * D);\n    \n    // Lambert Diffuse\n    //     Should we scale by (1.0 - F) ?? gltf and learnopengl have it but filament doesn't\n    //     Also what about lambert 1/PI ?? https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    //     PI might not be used in IBL only?\n    vec3 kD = vec3(1.0) - F;\n    vec3 c = mix(albedo * (1.0-dielectricSpecular), black, metallic);\n    vec3 diffuse = kD * (c / PI);\n    // vec3 diffuse = (1.0 - F) * diffuseColor * Diff_Burley(NoV, NoL, NoH, a);\n    \n    // Final Color\n    vec3 fakeGI = l.ambient * mat.albedo;\n    vec3 emissive = mat.emissive;\n    vec3 directLight = l.color * NoL * (diffuse + specular);\n    \n    //return vec3(Vis)*NoL;\n    return fakeGI + emissive + directLight;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}