{
    "Shader": {
        "info": {
            "date": "1530589118",
            "description": "t h a n k s\nf o r\nv i e w i n g\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XsVBDK",
            "likes": 7,
            "name": "inversion thing #12412",
            "published": 3,
            "tags": [
                "fractal",
                "texture",
                "tiling",
                "inversion"
            ],
            "usePreview": 0,
            "username": "xdaimon",
            "viewed": 516
        },
        "renderpass": [
            {
                "code": "#define iRes (iResolution.xy)\nvoid mainImage(out vec4 C, in vec2 p) {\n    p = p / iRes;\n    vec3 e;\n    e.xy = .5/iRes;\n    e.z = -e.y;\n    C = texture(iChannel0, p);\n    C += texture(iChannel0, p+e.xy);\n    C += texture(iChannel0, p-e.xy);\n    C += texture(iChannel0, p+e.xz);\n    C += texture(iChannel0, p-e.xz);\n    C/=5.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define ENABLE_INVERSION\n//#define BASIC_INVERSION\n#define SUPER_INVERSION\n\n#define ENABLE_GRAIN\n//#define GRAIN_ALTERNATIVE // good for basic_inv?\n\n#define FRAME_MIX .3\n\n\n#define iTime (iTime*2. + 120.)\n#define iRes (iResolution.xy)\n\n\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hashc(float x) {\n    return fract((cos(x * 12.13) * 19.123) * 17.321);\n}\n\nfloat base_noise(vec2 p) {\n    vec2 pm = mod(p, 1.0);\n    vec2 pd = p - pm;\n    float v0 = hashc(pd.x + pd.y * 41.0);\n    float v1 = hashc(pd.x + 1.0 + pd.y * 41.0);\n    float v2 = hashc(pd.x + pd.y * 41.0 + 41.0);\n    float v3 = hashc(pd.x + pd.y * 41.0 + 42.0);\n    v0 = mix(v0, v1, smoothstep(0.0, 1.0, pm.x));\n    v2 = mix(v2, v3, smoothstep(0.0, 1.0, pm.x));\n    return mix(v0, v2, smoothstep(0.0, 1.0, pm.y));\n}\n\nfloat fractalnoise(vec2 uv) {\n    float v = 0.;\n    for (float i = 0.0; i < 16.0; i += 1.0) {\n        float e = exp2(i/2.);\n        v += base_noise(uv * e + vec2(cos(i) * 53.0, sin(i) * 100.0));\n    }\n    return (v / 16.  - .33) / .3;\n}\n\nfloat mynoise(vec2 uv) {\n    float v = 0.;\n    for (float i = 1.0; i < 10.0; i += 1.0) {\n        float e = exp2(i);\n        float c = cos(i);\n        float s = sin(i);\n        v += base_noise(uv * e + vec2(c*53.,s*100.));\n    }\n    //return (v / 18. / .4 - .6/.4);\n    return v / 8.;\n}\n\nfloat map(vec2 uv, out vec2 uv_mapped) {\n#ifdef ENABLE_INVERSION\n    float t = iTime/70.;\n    vec2 c;\n    //#ifdef PATH1\n    vec2 p2 = vec2(.2, .1112) + vec2(.2, .2) - .3*vec2(.5+.5*cos(t), .5+.5*sin(t));\n    //#endif\n    //#ifdef PATH2\n    vec2 p1 = vec2(.3,.2)+.2*vec2(cos(t),sin(t*1.61));\n    //#endif\n    \n    // take path 2 after sixty seconds because its more 3d i think\n    c = mix(p1,p2,smoothstep(45.,60., t));\n\n\t#ifdef BASIC_INVERSION\n    uv /= 5.;\n    uv = uv / dot(uv, uv) - c;\n    uv -= iTime/30.;\n\t#endif\n    \n\t#ifdef SUPER_INVERSION\n    uv = uv / dot(uv, uv) - c;\n    mat2 rot;\n    float tsh = -iTime/70.;\n    float cc = cos(tsh);\n    float ss = sin(tsh);\n    rot = mat2(vec2(cc,ss),vec2(-ss,cc));\n    uv *= rot;\n    for (float i = 0.; i < 24.; i += 1.) {\n        uv = abs(uv) / (dot(uv, uv)) - c;\n    }\n\t#endif\n#endif\n\n    uv_mapped += uv;\n\n    float th = 3.141592 / 2. + 3.141592;\n    vec2 b1 = vec2(cos(th), sin(th));\n    th += 3.141592 * 2. / 3.;\n    vec2 b2 = vec2(cos(th), sin(th));\n    th += 3.141592 * 2. / 3.;\n    vec2 b3 = vec2(cos(th), sin(th));\n    float d = abs(-.5 + fract(dot(uv, b3)));\n    d = max(d, abs(-.5 + fract(dot(uv, b2))));\n    d = max(d, abs(-.5 + fract(dot(uv, b1))));\n    d = (1. - 2. * d) / .67;\n\n    float height = .3;\n    return clamp(d, 0., height) / height;\n}\n\nfloat mapg(vec2 uv) {\n    vec2 ignore;\n    return map(uv, ignore);\n}\n\nvec2 grad(vec2 uv) {\n    vec2 e = vec2(0.001, 0.);\n    vec2 ret =vec2(mapg(uv + e) - mapg(uv - e),\n                   mapg(uv + e.yx) - mapg(uv - e.yx)\n                  ) / (2. * e.x);\n    return ret;\n}\n\nvec2 fragCoord;\n\nfloat glow;\nvec2 uv_mapped = vec2(0);\nvec2 grad_mapped = vec2(0);\nfloat h_mapped = 0.;\n\nfloat light(vec2 uv) {\n    float h = h_mapped;\n\n    float maxh = 1.;\n    vec3 n = normalize(vec3(-grad_mapped, maxh));\n\n    //try using uv here and [-1,1] range on lo, for some reason this gave more\n    //contrast\n    vec3 p = vec3(fragCoord, h);\n    p.x *= iRes.x / iRes.y;\n\n    vec3 lo = vec3(iMouse.xy / iRes, maxh + 1.);\n    lo.x *= iRes.x / iRes.y;\n\n    vec3 to = p - lo;\n    vec3 ld = normalize(to);\n\n    float li = max(0., pow(-dot(n, ld), 1.));\n    float cm = (1. - smoothstep(0., maxh + 1., length(to)));\n    float dist = 1. - smoothstep(.0, 4., length(to));\n\n    float ret;\n    float fff = texture(iChannel1, vec2(.01,.1)).r;\n    float music = .5*fff*fff*smoothstep(.2,.8,h_mapped);\n    music -= .2*fff*fff*smoothstep(0.7,1.,1.-h_mapped);\n    ret = (li * .8 + cm) * (dist) + (1. - h) * dist * dist + music;\n    //ret = (li * .8 + cm) * (dist*dist);\n    // ret = .7*smoothstep(0,1,(li + cm)*dist + pow(1-h,3.)*dist);\n    // ret = (1.+li)*dist; // nice with height at 1.\n\n    // nice for kifs\n    // return .7*(.66*(1.+li)*dist+.1*(1.-h)); // nice with just height at 1.\n    // or\n    // ret = (.66*(.66+li)*dist + .06);\n\n    // glow += 1.-.1/(.02+h/ret); //dope // good when glow is mult\n    // glow += -.03/(.02+h/ret); //dope\n    // glow += 3.*smoothstep(.98,1.,1.-h-pow(ret,2.));\n    // glow += max(0.,.05/sqrt(h)*pow(ret, 1./10.));\n\n#ifdef ENABLE_GRAIN\n    // vec2 suv = floor(g*fract(uv*100))/g;\n    // vec2 suv = vec2(floor(hash(uv.x*uv.y+2.)*g))/g;\n    // vec2 suv = floor(uv*(500.+csum*300.))/(500.+csum*300.) / csum;\n    // uv = vec2(hash((uv.x+uv.y + uv.x*uv.y + 1.)/(10.*floor(csum*20.)/20.+1.)));\n\n    float grain = .83;\n    //*\n    grain = sqrt(hash12(uv_mapped));\n    #ifdef GRAIN_ALTERNATIVE\n    grain = pow(fractalnoise(100.+uv_mapped*200.), 8.)+.8*grain;\n    grain = pow(fractalnoise(2.+uv_mapped*50.),3.) + .8*grain;\n    #endif\n    grain = 1. - .2*grain;\n    ret *= grain;\n    /*/\n    vec2 e = vec2(.7/iRes.x, 0.);\n    uv_mapped *= 20.;\n    grain = mynoise(uv_mapped);\n    grain += mynoise(uv_mapped+e);\n    grain += mynoise(uv_mapped-e);\n    grain += mynoise(uv_mapped+e.xx);\n    grain += mynoise(uv_mapped-e.xx);\n    grain /= 5.;\n    grain = floor(grain * 1000.) / 1000.;\n    grain = hashc(grain);\n    //ret = grain;\n    ret *= 1.1 - .3 *  sqrt(grain);\n    //*/\n#endif\n    \n    float spot_light = .001/dot(to.xy,to.xy)/(8.*(lo.y)+8.*(iRes.x/iRes.y-lo.x));\n    \n    //float darken = .5;\n    float darken = 1.;\n    \n    return mix(darken*ret,1.,spot_light);\n}\n\nfloat blur(vec2 uv) {\n    vec2 e = vec2(0.0045, 0.);\n    float div = 5.;\n\n    h_mapped += map(uv,uv_mapped);\n    grad_mapped += grad(uv);\n    h_mapped += map(uv + e,uv_mapped);\n    grad_mapped += grad(uv + e);\n    h_mapped += map(uv - e,uv_mapped);\n    grad_mapped += grad(uv - e);\n    h_mapped += map(uv + e.yx,uv_mapped);\n    grad_mapped += grad(uv + e.yx);\n    h_mapped += map(uv - e.yx,uv_mapped);\n    grad_mapped += grad(uv - e.yx);\n\n    glow /= div;\n    uv_mapped /= div;\n    grad_mapped /= div;\n    h_mapped /= div;\n    return light(uv);\n}\n\nvoid mainImage(out vec4 C, in vec2 p) {\n    fragCoord = p / iRes;\n    vec2 uv = fragCoord * 2. - 1.;\n    uv.x *= iRes.x / iRes.y;\n    uv *= 5.;\n\n    // glow = 9.;\n    // glow = 0.;\n\n\t//C = vec4(clamp(blur(uv),0.,1.));\n    C = vec4(blur(uv));\n\n    // C.r*=glow;\n    //or\n    // C.r+=glow;\n    \n    //p = p / iRes;\n    //p -= .5; p *= .8; p += .5;\n    //C *= pow(16.*p.x*p.y*(1.-p.x)*(1.-p.y), .2);\n    //C = pow(C, vec4(1./2.2));\n    \n    vec4 oc = texture(iChannel0, fragCoord);\n    C = mix(oc, C, FRAME_MIX);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}