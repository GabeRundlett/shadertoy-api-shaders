{
    "Shader": {
        "info": {
            "date": "1442419753",
            "description": "Using relatively cheap functions to produce a sharp, jagged, surface with a fake glow.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tSXRm",
            "likes": 90,
            "name": "Jagged Plain",
            "published": 3,
            "tags": [
                "noise",
                "terrain",
                "triangle",
                "glow",
                "rocks",
                "jagged"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 7834
        },
        "renderpass": [
            {
                "code": "/*\n    Jagged Plain\n    ------------\n\n\tI've always found jagged, rocky surfaces difficult to raymarch at acceptable framerates. I wrote a \n\trelatively cheap, fake Voronoi function a while back in an attempt rectify that, but had mixed success. \n\tShadertoy user \"Aiekick\" has made some pretty cool examples with it, so I was glad someone got some\n\tuse out it. :)\n    \n\tAnyway, it can produce some pretty cheap, and reasonably decent looking, rocky surfaces. Unfortunately, \n\tit still isn't fast enough. Thankfully, Shadertoy user Nimitz came up with the idea to use variations \n\ton a triangle function, which does the job nicely. This is an example displaying that.\n\n\tI gave the rocks a bit of fake luminescent glow. It'd look a bit better if the surface had more detail.\n\tEither way, the glow code is very loosely based on something I found in a couple of TekF's examples. \n\tThe inspiration came from IQ's mushroom example.\n\n\tLoosely related examples:\n\n\tRay Marching Experiment nÂ°34 - Aiekick    \n\thttps://www.shadertoy.com/view/XtBXRm\n\n\tSubo Glacius - Aiekick\n\thttps://www.shadertoy.com/view/Ml2XRW\n\n    Another ray marched, perturbed planar surface example that I like.\n    Moon Surface - 4rknova\n    https://www.shadertoy.com/view/4slGRf\n\n*/\n\n#define PI 3.14159265358979\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// 2x2 matrix rotation.\nmat2 rot2( float a ){ float c = cos(a), s = sin(a);\treturn mat2( c, -s,\ts, c ); }\n\n// Cheapish vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\nvec3 triSmooth(in vec3 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\n\n// This is a cheap...ish routine - based on the triangle function - that produces a pronounced jagged \n// looking surface. It's not particularly sophisticated, but it does a surprizingly good job at laying \n// the foundations for a sharp rock face. Obviously, more layers would be more convincing. In fact, \n// I'm disappointed that there weren't enough cycles for one more layer. Unfortunately, this is a \n// GPU-draining distance function. The really fine details have been bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    // This is just one variation on a common technique: Take a cheap function, then\n    // layer it by applying mutations, rotations, frequency and amplitude changes,\n    // etc. Feeding the function into itself, folding it, and so forth can also \n    // produce interesting surfaces, patterns, etc.\n    //\n    // Good examples of the technique include IQ's spiral noise and Nimitz's triangle\n    // noise, each of which can be found on Shadertoy. \n    //\n    float n = dot(tri(p*0.15 + tri(p.yzx*0.075)), vec3(0.444));\n    p = p*1.5773;// - n; // The \"n\" mixes things up more.\n    p.yz = vec2(p.y + p.z, p.z - p.y) * 0.866;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 0.866;\n    n += dot(tri(p*0.225 + tri(p.yzx*0.1125)), vec3(0.222)); \n    \n    return abs(n-0.5)*1.9 + (1.-abs(sin(n*9.)))*0.05; // Range [0, 1]\n    \n/*    \n    // Different setup, using sinusoids, which tends to be quicker on my GPU\n    // than \"fract,\" \"floor,\" etc. Strange, but I'll assume a sinusoid signal\n    // is easier to produce on a GPU than a flooring mechanism. It's all\n    // Voodoo to me. :)\n\t//\n    float n = sin(p.x+sin(p.y+sin(p.z)))*0.57;\n    p *= 1.5773;\n    //p.yz = vec2(p.y + p.z, p.z - p.y) * 1.7321*0.5;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.28;\n    p *= 1.5773;\n    //p.yz = vec2(p.y + p.z, p.z - p.y) * 1.7321*0.5;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.15;\n    \n    return n*0.475+0.475+ ((sin(sin(n*3.)*6.)*0.5+0.5))*0.05;\n\t\n*/    \n\n}\n\n\n// Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n\n// Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p){\n \n     return p.y - surfFunc(p)*1.5;\n \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Tetrahedral normal: I remember a similar version on \"Pouet.net\" years ago, but this one is courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    vec2 e = vec2(0.5773,-0.5773)*0.001;\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n\n// Based on original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i=1.0; i<AO_SAMPLES+1.1; i++){\n        d = i/AO_SAMPLES;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r,0.0,1.0);\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy. I used it to do a bit of fake shadowing.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n// Blackbody color palette. Handy for all kinds of things.\nvec3 blackbodyPalette(float t){\n\n    // t = tLow + (tHigh - tLow)*t;\n    t *= 3200.; // Temperature range. Hardcoded from 0K to 4000K, in this case.    \n    \n    // Planckian locus or black body locus approximated in CIE color space.\n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    // Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    \n    // Converting XYZ color space to RGB: http://www.cs.rit.edu/~ncs/color/t_spectr.html\n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n\n    // Apply Stefanâ€“Boltzmann's law to the RGB color\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 2.25, iTime*5.);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.2, -0.5); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = camPos + vec3(0.0, 0.5, 2.0);// Put it a bit in front of the camera.\n\tvec3 lp2 = camPos + vec3(0.0, 0.5, 9.0);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlp.xy += path(lp.z);\n\tlp2.xy += path(lp2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalizaztion is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(forward, right); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= rot2( path(lookAt.z).x/32. );\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit.\n    //\n    // Note the \"abs\" addition. I don't always use it, but with some distance field setups, it can \n    // reduce popping and increase performance. Although, if not careful, holes can appear. Take out \n    // the \"abs\" call, to see what I'm talking about.\n\tfloat t = 0.0, dt;\n\tfor(int i=0; i<128; i++){\n\t\tdt = map(camPos + rd*t);\n\t\tif(abs(dt)<0.001*(1. + t*0.125) || t>40.0) break; \n\t\tt += dt*0.7; // Without the \"abs\" call, you would need \"t += dt*0.5;,\" or thereabouts.\n\t}\n    \n    t = min(t, 40.0);\n\t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0.0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<40.0001){\n\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n\t    vec3 sn = getNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./3.;\n        // Texture-based bump mapping. Comment this line out to \n        // spoil the illusion.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.04);\n        \n        // Obtaining the texel color. \n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lp-sp;\n\t    vec3 ld2 = lp2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n\t    float lDist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    ld2 /= lDist2;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*0.075);\n\t    float atten2 = 1./(1. + lDist2*lDist2*0.075);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.05;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 8.);\n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5 + 0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\t    \n       \n        // Shadertoy doesn't appear to have anisotropic filtering turned on... although,\n        // I could be wrong. Texture-bumped objects don't appear to look as crisp. Anyway, \n        // this is just a very lame, and not particularly well though out, way to sparkle \n        // up the blurry bits. It's not really that necessary.\n        //vec3 aniso = (0.5-hash33(sp))*0.2;\n\t    //texCol = clamp(texCol + aniso, 0., 1.);\n    \t\n    \t// Darkening the crevices. Otherse known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.75 + 0.25; //surfFunc(sp)*0.5+0.5;//\n        \n        \n        // A bit of fake glow. I was undecided between using normal wrapping, proper subsurface\n        // scattering, or this. It's based on something I saw in a couple of examples by \n        // Shadertoy user \"TekF,\" who has a whole bunch of interesting shaders.\n        //\n        // Basically, you burrow a little below the surface, via the normal, then take a couple \n        // of steps in a direction between the ray and the light. My version is pseudosciencey, and \n        // I'm undecided on it's effectiveness, but it gives the subtle glow I want for this \n        // particular example. It works better with more detailed surfaces.\n\t    float rnd = fract(sin(dot(sp, vec3(7, 157, 113)))*43758.4543);\n        float tRange = 0.25;\n        float nDepth = 0.03;\n        vec3 hf = normalize(rd+ld);\n\t    float ss = tRange*0.5-map( sp-sn*(nDepth+rnd*0.005) + hf*tRange*0.5 ) + (tRange-map( sp-sn*(nDepth*2.+rnd*0.01) + hf*tRange ))*0.5;\n\t    hf = normalize(rd+ld2);\n        float ss2 = tRange*0.5-map( sp-sn*(nDepth+rnd*0.005) + hf*tRange*0.5 ) + (tRange-map( sp-sn*(nDepth*2.+rnd*0.01) + hf*tRange ))*0.5;\n\t    \n\t    ss = max(ss, 0.);\n\t    ss2 = max(ss2, 0.);\n        \n    \t\n    \t// Combing the above terms to produce the surface color.\n        vec3 rCol = getGrey(texCol)*0.5 + texCol*0.5;\n        vec3 sCol = texCol*0.5 + 0.5;\n        sceneCol += (rCol*(diff + ambience) + blackbodyPalette(ss*.6)*sCol*12.0 + spec*texCol*2.)*atten;\n        sceneCol += (rCol*(diff2 + ambience) + blackbodyPalette(ss2*.6)*sCol*12.0 + spec2*texCol*2.)*atten2;\n      \n\t    \n        // Shading.\n        sceneCol *= shading*ao;\n\t\n\t}\n\t\n    // Loose gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}