{
    "Shader": {
        "info": {
            "date": "1697385862",
            "description": "My ray tracing shader",
            "flags": 0,
            "hasliked": 0,
            "id": "dscfRj",
            "likes": 1,
            "name": "Ray-Tracing Andrei-Cn",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "AndreiCN",
            "viewed": 81
        },
        "renderpass": [
            {
                "code": "struct material {\n    vec3 color;\n    float reflectance;\n};\n\nstruct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 getAt(ray r, float t){\n    return r.origin + r.direction * t;\n}\n\nstruct sphere{\n    vec3 position;\n    float radius;\n    material mat;\n};\n\n\nstruct record{\n    vec3 normal;\n    float t;\n    bool didHit;\n    sphere target;\n    material mat;\n};\n\nvec2 projectPointOnPlane(vec3 pointOnSphere, sphere s) {\n    // Calculate the direction vector from the sphere's center to the point on the sphere\n    vec3 direction = normalize(pointOnSphere - s.position);\n    \n    // Convert the point's Cartesian coordinates to spherical coordinates relative to the sphere's center\n    float r = s.radius;\n    float rPrime = length(pointOnSphere - s.position);\n    float theta = acos(direction.z);\n    float phi = atan(direction.y, direction.x);\n    \n    // Convert spherical coordinates to Cartesian coordinates\n    float xPrime = rPrime * sin(theta) * cos(phi);\n    float yPrime = rPrime * sin(theta) * sin(phi);\n    float zPrime = rPrime * cos(theta);\n    \n    // Project onto (0,1) x-axis and (0,1) y-axis planes\n    float xNormalized = (xPrime - (s.position.x - r)) / (2.0 * r);\n    float yNormalized = (yPrime - (s.position.y - r)) / (2.0 * r);\n    \n    return vec2(xNormalized, yNormalized);\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n        // Use Schlick's approximation for reflectance.\n        float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n        r0 = r0*r0;\n        return r0 + (.01-r0)*(1.0 - cosine)*(1.0 - cosine)*(1.0 - cosine)*(1.0 - cosine)*(1.0 - cosine);\n    }\n\nvec3 refract2(vec3 uv, vec3 n, float etai_over_etat) {\n    float cos_theta = min(dot(-uv, n), 1.0);\n    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);\n    vec3 r_out_parallel = -sqrt(abs(1.0 - dot(r_out_perp, r_out_perp))) * n;\n    return r_out_perp + r_out_parallel;\n}\n\nrecord hit_sphere(in ray r, in sphere s, out record h){\n    vec3 oc = r.origin - s.position;\n    highp float half_b = dot(oc, r.direction);\n    highp float c = dot(oc, oc) - s.radius * s.radius;\n    highp float discriminant = half_b * half_b - c;\n    \n    if (discriminant < 0.0) {\n        return h;\n    }else {\n        highp float t = -half_b - sqrt(discriminant);\n        if (t > 0.00001 && t < h.t){\n            h.didHit = true;\n            h.t = t;\n            h.mat = s.mat;\n            h.target = s;\n            h.normal = (getAt(r, t) - s.position) / s.radius;\n            return h;\n        };\n    }\n    return h;\n}\n\nfloat RandomValue(inout int state){\n    state = state * 747796405 + 2891336453;\n    int result = ((state >> ((state >> 52 ) + 128567)) ^ state) * 277803737;\n    result = (result >> 522) ^ result;\n    return float(result) / 4294967295.0;\n}\n\nvec3 RandomVector(inout int state){\n    float x = RandomValue(state);\n    float y = RandomValue(state);\n    float z = RandomValue(state);\n    return vec3(x,y,z);\n}\n\nvec3 RandomVectorInSphere(inout int state){\n    while (true){\n        vec3 vec = RandomVector(state);\n        if (dot(vec, vec) <= 1.0){\n            return vec;\n        }\n    }\n}\n\nconst int numofspheres = 5;\nsphere SPHERES[numofspheres];\n\nvec3 ray_color(ray r, int index){\n    float persistence = - -2.0;\n    vec3 BACKGROUND = vec3(r.direction + 0.5);\n    vec3 color;\n\n    for (int j; j < 40; j ++){\n        record h;\n        h.t = 100000.0;\n        for (int i = 0; i < numofspheres; ++i){\n            sphere s = SPHERES[i];\n            h = hit_sphere(r, s, h);\n        };\n        \n        if (!h.didHit){\n            color += vec3(gl_FragCoord.xy/iResolution.xy, 0.2) * 0.3;\n            color == vec3(0,0,0);\n            break;\n        }\n        vec3 sphereclr = h.mat.color;\n        vec2 sphereUV = projectPointOnPlane(getAt(r, h.t), h.target);\n        int index = int(sphereUV.x * 100000.0 + sphereUV.y * 100000.0) * 200 ;\n        float nosieVal = RandomValue(index);\n\n        color += persistence * sphereclr + nosieVal / 2.0;\n        ray r2;\n        r2.origin = getAt(r, h.t);\n        float refractratio = 1.5;\n        float cos_theta = min(dot(-r.direction, h.normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n        bool cannot_refract = refractratio * sin_theta > 1.0;\n        vec3 direction;\n        \n        if (cannot_refract || reflectance(cos_theta, refractratio) > 0.1345)\n            direction = reflect(r.direction, h.normal);\n        else\n            direction = refract2(r.direction, h.normal, refractratio);\n        \n        //r2.direction = reflect(r.direction, h.normal);\n        r2.direction = direction + RandomVectorInSphere(index) * 3.6;\n        r2.direction = normalize(r2.direction);\n        r = r2;\n\n        persistence *= h.mat.reflectance;\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    highp float ratio = 640.0/360.0;\n    int samplereps = 25;\n    float viewportscale = 1.0;\n/*\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].position = vec3(-sin(iTime) * 0.5 - 0.5, 0.1, -2.0);\n    SPHERES[0].mat.color = vec3(.1, .1, 1.0);\n    SPHERES[0].mat.reflectance = 0.5;\n\n    SPHERES[3].radius = 0.5;\n    SPHERES[3].position = vec3(sin(iTime), 0.1, -2.0 + cos(iTime));\n    SPHERES[3].mat.color = vec3(1.0, .1, 1);\n    SPHERES[3].mat.reflectance = 0.4;\n    \n    SPHERES[4].radius = -1.0;\n    SPHERES[4].position = vec3(cos(iTime), sin(iTime), -2.0 + cos(iTime));\n    SPHERES[4].mat.color = vec3(0, 1.0, 1.0);\n    SPHERES[4].mat.reflectance = -1.0;\n\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].position = vec3(.6, 0.1, -2.0);\n    SPHERES[1].mat.color = vec3(0, 0, 0);\n    SPHERES[1].mat.reflectance = 0.1;\n\n    SPHERES[2].radius = 100.0;\n    SPHERES[2].position = vec3(.6, -100.0, 4.0);\n    SPHERES[2].mat.color = vec3(1, 1, 1);\n*/\n\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].position = vec3(0, 0.1, -0.8);\n    SPHERES[0].mat.color = vec3(0.05, 0.05, 0.05);\n    SPHERES[0].mat.reflectance = 3.0;\n\n    SPHERES[1].radius = 0.4;\n    SPHERES[1].position = vec3(sin(iTime) * 0.8, cos(iTime) * 0.8, -0.8);\n    SPHERES[1].mat.color = vec3(1, 0, 0);\n    SPHERES[1].mat.reflectance = 0.43;\n\n\n    vec2 uv = (FragCoord.xy / iResolution.xy) - 0.5;\n    vec3 pointOnViewport = vec3(uv.x * ratio, uv.y, 0) * viewportscale + vec3(0,0,-.2);\n    int index = int(gl_FragCoord.y * iResolution.x + gl_FragCoord.x);\n    vec3 normpov = normalize(pointOnViewport);\n\n    ray r;\n    r.origin = vec3(0,0,0);\n    r.direction = normpov;\n\n    vec3 color;\n    for (int x = 1; x <= samplereps; x++){\n        for (int y = 1; y <= samplereps; y++){\n            r.direction = normpov + vec3(float(x), float(y), 0) * 0.003;\n            color += ray_color(r, index);\n        }\n    }\n    color /= float(samplereps * samplereps);\n\n    color = vec3(sqrt(color.x), sqrt(color.y), sqrt(color.z));\n\n    FragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}