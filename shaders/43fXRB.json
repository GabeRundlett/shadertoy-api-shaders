{
    "Shader": {
        "info": {
            "date": "1709652445",
            "description": "Glsl menu for GiCad https://github.com/mikelsv/GiCad. Test project. It works!\nTODO: Icons. Levels. Dynamic graphics.",
            "flags": 0,
            "hasliked": 0,
            "id": "43fXRB",
            "likes": 1,
            "name": "Mgl Menu",
            "published": 3,
            "tags": [
                "menu"
            ],
            "usePreview": 0,
            "username": "mikelsv",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "/* JavaScript menu maker  Run to: https://www.programiz.com/javascript/online-compiler/\n\nconst menuItem = [\"Hello\", \"World\", \"1234567890\"];\n\nfunction JsMakeMenu(array){\n    const asciiCodes = array.map((text) => {\n        let codes = \"\";\n        for (let i = 0; i < text.length; i++) {\n          codes += text.charCodeAt(i) + \",\";\n        }\n        return codes;\n    });\n  \n  console.log('Menu menu[] = Menu[](');\n  var size = 0;\n    array.forEach((text, index) => {\n        console.log(`Menu(${index}, ${size}, ${text.length}), // ${text}`);\n        size += text.length;\n    });\n    console.log(\"); // Delete last ','\");\n\n    console.log(\"int menu_text[] = int[](\", asciiCodes.join(\"\").slice(0, -1),\");\");\n}\n\nJsMakeMenu(menuItem);\n*/\n\nstruct _MenuOptions{\n    // Size\n    float cellHeigth, letterWidth;\n    float fontSize;\n    float maxWidth;\n    float borderSize, freeSize;\n\n    // Colors\n    vec3 textColor, bgColor, borderColor, activeColor;\n} MenuOptions;\n\nstruct Menu{\n    int id;\n    int pos, size;\n};\n\nMenu menu[] = Menu[](\nMenu(0, 0, 5), // Hello\nMenu(1, 5, 5), // World\nMenu(2, 10, 10) // 1234567890\n); // Delete last ','\nint menu_text[] = int[]( 72,101,108,108,111,87,111,114,108,100,49,50,51,52,53,54,55,56,57,48 );\n\n// Init\nvoid MenuInit(){\n    MenuOptions.bgColor = vec3(.94, .94, .94);\n    MenuOptions.textColor = vec3(.06, .94, .94);\n    MenuOptions.activeColor = vec3(1.0,0.83,0.22);\n    MenuOptions.borderColor = vec3(.0, .0, .94);    \n    \n    MenuOptions.borderSize = 2.;\n    MenuOptions.freeSize = 10.;    \n    \n    //MenuOptions.cellHeigth = 40.;\n    MenuOptions.letterWidth = 20.;\n    MenuOptions.fontSize = 40.;\n    \n    MenuOptions.maxWidth = 0.;\n    for(int i = 0; i < menu.length(); i ++){\n        MenuOptions.maxWidth = max(MenuOptions.maxWidth, float(menu[i].size) * MenuOptions.letterWidth);\n    }\n}\n\n// Rect functions\nbool InRect(vec2 coord, vec4 rect, out vec2 coordIn){\n    if(coord.x > rect.x && coord.x < rect.z &&\n        coord.y > rect.y && coord.y < rect.w\n    ){\n        coordIn = coord - rect.xy;    \n        return true;\n    }\n    return false;\n}\n\nvoid CropRect(inout vec4 rect, float size){\n    rect.x += size;\n    rect.y += size;\n    rect.z -= size;\n    rect.w -= size;\n}\n\nfloat PrintChar(int c, vec2 p){\n    p.x += .25;\n    \n    vec2 dFdx = dFdx(p / 16.), dFdy = dFdy(p / 16.);\n    if(p.x < .0 || p.x > 1. || p.y < 0. || p.y > 1.)\n        return 0.;//vec4(0,0,0,1e5);\n    \n\treturn textureGrad(iChannel3, p / 16. + fract(vec2(c, 15 - c / 16) / 16.), dFdx, dFdy).x;\n}\n\nvoid DrawMenuText(inout vec4 fragColor, vec2 coord, int menuId, float menuHeight){\n    int size = menu[menuId].size;\n    if(size > 20)\n        size = 0;\n\n    for(int i = 0; i < 200; i ++){ // menu[menuId].size not work. It's freeze.\n        if(i >= size) // Bug fix\n            break;\n    \n        int c = menu_text[menu[menuId].pos + i];\n        fragColor.xyz -= PrintChar(c, (coord - vec2(float(i) * MenuOptions.letterWidth, menuHeight * float(menuId))) / MenuOptions.fontSize);    \n    }        \n}\n\nvoid DrawMenu(inout vec4 fragColor, in vec2 fragCoord, vec2 menuCoord){\n    // Size\n    float menuWidh = MenuOptions.maxWidth;\n    vec2 menuSize = vec2(menuWidh, MenuOptions.fontSize * float(menu.length())) + MenuOptions.borderSize * 2.  + MenuOptions.freeSize * 2.;\n    \n    // Rect\n    vec4 rect = vec4(menuCoord.x, menuCoord.y - menuSize.y, menuCoord.x + menuSize.x, menuCoord.y);\n    vec2 coord, mouseCoord;\n    \n    if(InRect(fragCoord, rect, coord)){\n        // Set background\n        fragColor.xyz = MenuOptions.bgColor;\n    \n        // In border\n        CropRect(rect, MenuOptions.borderSize);\n        \n        if(!InRect(fragCoord, rect, coord)){\n            fragColor.xyz = MenuOptions.borderColor;\n            return ;\n        }\n        \n        // In free\n        CropRect(rect, MenuOptions.freeSize);\n                \n        if(!InRect(fragCoord, rect, coord)){\n            return ;\n        }\n        \n        // Invert Y\n        coord -= vec2(MenuOptions.borderSize, MenuOptions.borderSize );\n    \n        // MenuId\n        int menuId = menu.length() - int(coord.y / MenuOptions.fontSize) - 1;\n        \n        // Mouse\n        float cellY = float(menu.length() - menuId - 1) * MenuOptions.fontSize;\n        vec4 cellRect = vec4(rect.xy, rect.xy) + vec4(0., cellY, MenuOptions.maxWidth, cellY + MenuOptions.fontSize);\n        \n        if(InRect(iMouse.xy, cellRect, mouseCoord))\n            fragColor.xyz = MenuOptions.activeColor;           \n        \n        // Draw\n        coord.y = mod(coord.y, MenuOptions.fontSize) + MenuOptions.fontSize * float(menuId);\n        DrawMenuText(fragColor, coord, menuId, MenuOptions.fontSize);              \n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);    \n    \n    // Init Menu\n    MenuInit();\n    \n    // Draw menu\n    vec2 menuCoord = vec2(80., 400.);\n    DrawMenu(fragColor, fragCoord, menuCoord);\n       \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}