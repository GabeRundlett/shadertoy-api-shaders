{
    "Shader": {
        "info": {
            "date": "1532786300",
            "description": "Applying some volumetric glow to a scene full of random blocky objects, just for the fun of it. Nothing that hasn't been tried before.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl3cWM",
            "likes": 33,
            "name": "Glowing Blocks",
            "published": 3,
            "tags": [
                "random",
                "volumetric",
                "glow",
                "block"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1851
        },
        "renderpass": [
            {
                "code": "/*\n\n\tGlowing Blocks\n\t--------------\n\n\tApplying some volumetric glow to a scene full of random blocky objects, just for the \n\tfun of it. Nothing that hasn't been tried before.\n\n\tI'm not even sure what this is supposed to represent. I was experimenting with cheapish \n\tglow using a backlit point light, then boredom set in. Anyway, back to what I was \n\tsupposed to be coding. :) \n\n\tBy the way, uncommenting the defines \"NO_XY_ROTATION\" and \"NO_GLOW\" gives an abstract\n\tcity block appearance. At some stage, I plan to write an example that expands on that.\n\n\n\tRelated:\n\n\t// I was more focused on producing some abstract glow, but at some stage, \n    // I'd like to make a 3D version of the shader below:\n\tFavela - duvengar\n\thttps://www.shadertoy.com/view/ldGcDh\n\n*/\n\n// DIRECTIVES\n\n// The following defines enable you to change the characteristics of the scene. I prefer\n// the cleaner non-glowing look, but that'd defeat the purpose of the example. :)\n\n// Takes out the cell object rotaion, which gives it more of an abstract city block look.\n//#define NO_XY_ROTATION\n\n// Takes out the glow to focus more on the geometry.\n// Values: No glow - 0, Fiery glow - 1, Cool glow - 2.\n#define GLOW 1\n\n// Just in case the grungy texturing is too busy for your eyes, here's a cleaner look. :)\n//#define NO_TEXTURE\n\n// If you prefer circles.\n//#define DO_CIRCLES\n\n\n// Far plane.\n#define FAR 25.\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// vec2 to vec2 hash. Cheap version using an oldschool trick. Not super trustworthy,\n// but it works well enough in a lot of situations.\nvec2 hash22(vec2 p){ \n    \n    float n = sin(dot(p, vec2(111, 157)));    \n    return fract(vec2(262144, 32768)*n); \n}\n\n// vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = max(abs(n) - .1, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBox(vec3 p, vec3 b){\n\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\n// IQ's 2D signed box formula.\nfloat sBox(vec2 p, vec2 b){\n\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n//vec2 objID;\n\n// ID for inner or outer frame.\nvec2 oID;\n\n// The overlapping random block distance field: In order to render repeat objects that either\n// sit up against one another, or slightly overlap, you have to render more than one cell to\n// avoid artifacts. In this case, I've rendered some repeat boxy objects across the XY plane\n// with random heights. Four cells need to be considered, which means rendering everything\n// four times. This would be better unrolled, tweaked, etc, but I think it reads a little \n// better this way. Anyway, I've explained the process in other examples, like the \"Jigsaw\"\n// example, and so forth.\n\nfloat m(vec3 p){\n\n    // Warp the XY plane a bit to give the scene an undulated look.\n    p.z -= 3. + sin(p.x + p.y)*.125;\n    \n    // Box scale. If you change this, you might need to make box size changes, etc.\n    const float sc = .5;\n    \n    // Cell centering.\n    p += sc*.5;\n    \n    // The initial distance. I can't remember why I wanted this smallish amount. Usually, \n    // you'd set it to some large number.\n    float d = 0.25;\n    \n    //objID = vec2(0);\n    oID = vec2(0);\n    \n    for (int i=0; i<=1; i++){ \n        for (int j=0; j<=1; j++){ \n\n            // The cell ID.\n            vec2 ip = floor((p.xy/sc - vec2(i, j)/2.))*sc + vec2(i, j)/2.*sc;\n            // Local cell position. I remember figuring these out a while\n            // back... I'll take my own word for it. :D\n            vec3 q = vec3((mod(p.xy + vec2(i, j)/2.*sc, sc) - sc/2.), p.z);\n\n            // Two random numbers for each cell... to do some random stuff. :)\n            vec2 rnd = hash22(ip);\n\n            #ifndef NO_XY_ROTATION\n            // Random object rotation about the XY plane.\n            q.xy *= r2((dot(rnd.xy, vec2(.5)) - .5)*6.2831*.15);\n            #endif\n\n            // Another random number to be used for the heights.\n            rnd.x = fract(dot(rnd, vec2(27, 57)))*.25 + .375;\n            // Quantizing the heights -- Not absolutely necessary, but it makes things\n            // look a little neater.\n            rnd.x = floor(rnd.x*25.999)/25.; \n\n            // Also not that necessary, but it shifts the base of the objects to a level\n            // point... that is behind the scene, which means you can't see it... but I\n            // know it's there, and without this line the hidden backwall wouldn't be flat. :D\n            q -= vec3(0, 0, -rnd.x);\n\n            #ifndef DO_CIRCLES\n            // The box objects. I'm using IQ's more expensive functions, just because I need\n            // the distance fields to be more correct away from the centers to get more even\n            // looking glow.\n            float obj = sBox(q, vec3(sc/4. + .05, sc/4. + .05, rnd.x - .005)); // Outer box casing.\n            float obj2 = sBox(q, vec3(sc/4. + .01, sc/4. + .01, rnd.x)); // Inner box.\n            // Four window-like objects.\n            q.xy = abs(abs(q.xy) - .055);\n            float obj2D = sBox(q.xy, vec2(sc/4., sc/4.));\n            #else\n            // Alternative circles.\n            float obj = max(length(q.xy) - (sc/4. + .06), abs(q.z) - rnd.x + .005); // Outer.\n            float obj2 = max(length(q.xy) - (sc/4. + .02), abs(q.z) - rnd.x); // Inner.\n            q.xy = abs(abs(q.xy) - .05);\n            float obj2D = length(q.xy) - sc/4.;\n\t\t\t#endif\n            \n            \n            \n            // Combine the inner and outer boxex, then carve out the windows.\n            float obj3D = max(min(obj, obj2), -(obj2D + .0975)); \n            \n            oID = (obj3D<d)? vec2(obj, obj2) : oID; // ID for inner or outer frame.\n\n\t\t\t// Individual object ID. Not used here.\n            //objID = (obj<d)? ip : objID;\n\n            // Minimum of the four cell objects. Similar to the way Voronoi cells are handled.\n            d = min(d, obj3D);\n\n\n        }\n\t}\n  \n    \n    // Return the scene distance, and include a bit of ray shortening to avoid a few minor\n    // inconsistancies.\n    return d*.85;\n    \n}\n\n\n\n\n// Basic soft shadows.\nfloat shd(in vec3 ro, in vec3 n, in vec3 lp){\n\n    const float eps = .001;\n    \n\tfloat t = 0., shadow = 1., dt;\n    \n    ro += n*eps*1.1;\n    \n    vec3 ld = (lp - ro);\n    float lDist = length(ld);\n    ld /= lDist;\n    \n    \n    //t += hash31(ro + ld)*.005;\n    \n\tfor(int i=0; i<24; i++){\n        \n    \tdt = m(ro + ld*t);\n        \n        shadow = min(shadow, 16.*dt/t);\n         \n \t\tt += clamp(dt, .01, .25);\n        if(dt<0. || t>lDist){ break; } \n\t}\n\n\n    return max(shadow, 0.);\n    \n}\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.0;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = float(i)*.25/5.;        \n        float dd = m(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n/*\n// Standard normal function.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(0.001, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\tm(p + e.yyx) - m(p - e.yyx)));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 nr(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    // It's worth looking into using a fixed epsilon versus using an epsilon value that\n    // varies with resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(3./mix(450., min(850., iResolution.y), .35), 0);//*(1. + t*t*.7);\n\n\tfloat d1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\tfloat d3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\tfloat d5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\tfloat d = m(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\td3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\td5 = m(p + e.yyx), d6 = m(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.001, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\td3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\td5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n    return n; //abs(n - .5)*2.;\n}\n\n\n\nvoid mainImage(out vec4 c, in vec2 u){\n\n    // Camera and ray setup -- Note the one-line unit direction ray setup. Coyote\n    // noticed that. The front light is there too.\n    vec3 r = normalize(vec3(u - iResolution.xy*.5, iResolution.y)), \n         o = vec3( iTime*.5, iTime*.5/12.*1., 0), l = o + vec3(.5, 2., 0);\n    \n    // Tilt the scene along the YZ plane, ever so slightly.\n    r.yz *= r2(3.14159/24.);\n\n    // Ray marching... I should probalby put all this in its own function.\n    float d, t = 0.;\n    \n    // Glow. A point light is place behind the scene, it's attenuation is\n    // calculated at each point along the ray and accumulated. Pretty standard\n    // stuff. Although, most people just accumulate ray distance or scene distance\n    // values, whereas I prefer to accumulate the ray to light distance, just\n    // because I think it looks a little nicer. In this case, I'm also taking\n    // the more expensive step of smooth 3D noise attenuation to give the scene\n    // a fog-like variance.\n    float glow = 0.;\n    \n    // The second light offset. It's arranged to sit a few units back behind\n    // the scene.\n    vec3 l2Offs = vec3(.5, 1.5, 8);\n    // Counter rotating the second light direction to match the scene rotation.\n    l2Offs.yz *= r2(-3.14159/24.);\n    // The second light.\n    vec3 l2 = o + l2Offs;\n    \n    // Jittering the glow. If your glow is looking too bandy, try this.\n    // It doesn't always work, but tends to help in many instances.\n    t = hash31(r + fract(iTime));\n    \n    for(int i=0; i<80;i++){\n        \n        vec3 pp = o + r*t;\n        d = m(pp);\n        \n        \n        #if GLOW > 0\n        // Ray position to point light distance.\n        // Point-light-based glow.\n        float l2D = length(l2 - pp); //4./(1. + d*d);//\n        // Distance based falloff.\n        //float aD = abs(d);\n        //if(aD<.15) glow += 1.*(.15 - aD)/(.0001 + l2D*l2D);\n        // Accumulating the attenuation, whilst applying a little noise.\n        // There's a touch of animation as well to give the glow less of\n        // a static feel.\n        glow += .25/(.0001 + l2D)*noise3D(pp*6. + vec3(iTime, 0, iTime*.5));\n        #endif\n        \n        // The usual break conditions.\n        if(abs(d)<0.001 || t>FAR) break;\n        t += d;\n    }\n    \n    t = min(t, FAR);\n\n    // Saving the object ID. Not used here.\n    //vec2 svObjID = objID;\n    \n    // Outer or inner box identification.\n    float svOID = oID.x < oID.y ? 0. : 1.;\n    \n    // Scene color initiation.s\n    vec3 col = vec3(0);\n    \n    if(t<FAR){\n    \n        // Hit point.\n        vec3 p = o + r*t;\n        //vec3 n = nr(p);\n        // Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 n = nr(p, edge, crv, t);\n        \n        // Texture scale.\n        const float sz0 = 1./1.;\n        // No bump mapping -- I didn't think it added value to the scene.\n        //n = texBump(iChannel0, p*sz0, n, .005);///(1. + t/FAR)\n        \n        float sh = shd(p, n, l);\n        float ao = cao(p, n);\n        sh = min(sh + ao*.2, 1.);\n        \n        \n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        /////\n        // The second light behind the scene.\n        l2 -= p; // Light to surface vector. Ie: Light direction vector.\n        float d2 = max(length(l2), 0.001); // Light to surface distance.\n        l2 /= d2; // Normalizing the light direction vector.\n        float diff2 = max(dot(l2, n), 0.);\n        diff2 = pow(diff2, 4.)*2.;\n        float spec2 = pow(max(dot(reflect(l2, n), r), 0.), 32.);\n        /////\n        \n        // Object color. I applied some sporadic blue pathches, for whateverr eason. \n        // I thought the object facades looked a little too grey without it.\n        float pat = dot(sin(p*6. + cos(p.yzx*6.)), vec3(.166)) + .5;\n        pat = smoothstep(0., .25, pat - .65);\n        vec3 oCol = mix(vec3(1), vec3(2, 3, 8), pat);\n        \n        // Adding a bit of grunge. I thought a grungy facade suited the scene a little\n        // better... Plus, it's a good way to hide poor coding inconsitancies. :)\n       \n        #ifndef NO_TEXTURE\n        vec3 tx = tex3D(iChannel0, p*sz0, n);\n        tx = smoothstep(.0, .7, tx);\n        #else\n        // Some subtle noise. Less grungy, so looks a bit cleaner.\n        vec3 tx = mix(vec3(.28), vec3(.18), noise3D(p*64.)*.66 + noise3D(p*128.)*.34);\n        if(svOID < .5) tx *= 1.15;\n        #endif\n        \n        #if GLOW == 0\n        if(svOID > .5) oCol *= tx*tx*1.5;\n        else oCol *= tx*sqrt(tx)*4.; // Brighten up the outer frames.\n        #else \n        if(svOID > .5) oCol *= tx;\n        else oCol *= sqrt(tx)*1.5; // Brighten up the outer frames.\n        #endif\n        \n        \n\n        \n        float diff = max(dot(l, n), 0.); // Diffuse. \n        diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n        float spec = pow(max(dot(reflect(l, n), r), 0.), 32.); // Specular.\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow(1. - max(dot(r, normalize(r + l)), 0.), 5.);\n\t\tfloat fre2 = mix(.5, 1., Schlick);        \n        \n        // Scene color for light one.\n        col = (oCol*(diff + .25) + vec3(.5, .7, 1)*spec*fre2*2.)*1./(1. + d*.25);\n        \n        // Scene color for light two. The effects are a little hidden by the overwhelming\n        // glow, but the specular highlights accentuate the backlit effect. Comment it out\n        // to see what I mean.\n        vec3 sCol = pow(vec3(1, 1, 1)*spec2, vec3(1, 2, 4)*2.);\n        col += (oCol*(diff2 + .0) + sCol*4.)*1./(1. + d2*.25);\n        \n        \n        // Applying the edges.\n        col *= 1. - edge*.8;\n        \n        // Applying the ambient occlusion and shadows.\n        col *= ao*sh;\n        \n        \n    }\n    \n    \n    #if GLOW > 0    \n    // Applying a fiery palatte to the glow\n    vec3 glowCol = pow(vec3(1.5, 1, 1)*glow, vec3(1, 2.75, 8));\n    // Blue glow.\n    if(GLOW == 2) glowCol = glowCol.zyx;\n    // Adding the glow to the scene. Not that it's applied outsite the the object coloring\n    // block because we need to add the glow to the empty spaces as well. When I haven't applied\n    // glow for a while, I tend to forget this. :)\n    col += glowCol*1.5 + glowCol*glowCol*1.5;\n    \n    // The fiery red is a little overwhelming, so this tones it down a bit.\n    col = mix(col, col.zyx, max(-r.y*.25 + .1, 0.));\n    #endif\n   \n    // Subtle vignette.\n    u /= iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n    // Colored variation.\n    //col = mix(col.zyx/2., col, pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125));\n\n    \n    // Rough gamma correction: The top 5 things graphics programmers forget to do. You will be \n    // shocked when you see item number 3. :D\n    //\n    // For anyone doubting the need to gamma correct, create a red to green linear gradient \n    // across the screen horizontal, gamma correct the top half only, then compare.\n    c = vec4(sqrt(max(col, 0.)), 1.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}