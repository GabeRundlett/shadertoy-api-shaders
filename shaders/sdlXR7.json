{
    "Shader": {
        "info": {
            "date": "1618427986",
            "description": "Distance Field Soft Shadows.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdlXR7",
            "likes": 8,
            "name": "Distance Field Soft Shadows",
            "published": 3,
            "tags": [
                "shadow",
                "softshadow",
                "ssdf"
            ],
            "usePreview": 0,
            "username": "moranzcw",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "// Distance Field Soft Shadows - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653;\n\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// hash by Hugo Elias\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n\n/* -------------------------------------\n\n1. SDF\n\n------------------------------------- */\n\n// SDF boolean\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//SDF functions by iq.\n//see https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat quadSDF( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// scene\nfloat sceneSDF(vec3 samplePoint) {\n    float sphere = sphereSDF(samplePoint + vec3(0.0, -0.5, 0.0), 0.5);\n    float scene = sphere;\n    \n    float cube = boxSDF(samplePoint+ vec3(1.5, -0.75, -1.5), vec3(0.25, 0.75, 0.25));\n    scene = unionSDF(scene, cube);\n    \n    float cylinder = cylinderSDF(samplePoint+ vec3(-1.5, -0.6, 1.5), 0.4, 0.6);\n    scene = unionSDF(scene, cylinder);\n    \n    float size = 4.0;\n    float ground = quadSDF(samplePoint,vec3(size,0.0,size), vec3(size,0.0,-size),\n                        vec3(-size,0.0,-size), vec3(-size,0.0,size));\n    scene = unionSDF(scene, ground);\n    \n    return scene;\n}\n\n/* -------------------------------------\n\n2. Ray Marching\n\n------------------------------------- */\nfloat rayMarching(vec3 origin, vec3 direction, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(origin + depth * direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/* -------------------------------------\n\n3. Visibility for shading point\n\n------------------------------------- */\nfloat visibility(vec3 ro, vec3 rd, float start, float end, float k)\n{\n    float t = start;\n    vec3 p;\n    float dist;\n    float tempVisibility;\n    float visibility = 1.0;\n        \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        p = ro + t * rd;\n        p = vec3(p.x + t * 0.05 * frand(), p.y + t * 0.05 * frand(), p.z + t * 0.05 * frand());\n        dist = sceneSDF(p) + 0.05 * t;\n        \n        tempVisibility = k * dist / t;\n        visibility = min(tempVisibility, visibility);\n        \n        if (dist < EPSILON) \n        {\n\t\t\treturn 0.0;\n        }\n        t += dist * (0.7 + frand() * 0.3); // dither\n        if (t >= end) \n        {\n            break;\n        }\n    }\n    visibility = pow(visibility, 2.0);\n    return visibility;\n}\n\n\n/* -------------------------------------\n\n4. Shading\n\n------------------------------------- */\n// normal\nvec3 surfaceNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// shading\nvec3 lambertShading(vec3 diffuseColor, vec3 p, vec3 normal, vec3 lightDir, vec3 lightIrradiance) {\n    float dotLN = dot(lightDir, normal);\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    return lightIrradiance * dotLN * diffuseColor;\n}\n\nvec3 lambertIllumination(vec3 p) {\n    vec3 normal = surfaceNormal(p);\n    \n    vec3 lightDir = normalize(vec3(sin(0.3*iTime), 0.5, cos(0.3*iTime)));\n    vec3 lightIrradiance = vec3(0.8);\n    vec3 color = vec3(0.0);\n    color += visibility(p + normal*2.0*EPSILON, lightDir, MIN_DIST, MAX_DIST, 6.0) \n            * lambertShading(vec3(1.0), p, normal, lightDir, lightIrradiance);\n      \n    return color;\n}\n\n\n/* -------------------------------------\n\n5. Camera\n\n------------------------------------- */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 cameraOrigin, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - cameraOrigin);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // ray direction\n\tvec3 cameraRayDirInView = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 cameraPos = vec3(8.0 + 3.0 * sin(0.2 * iTime), 4.5, 8.0 - 3.0 * sin(0.2 * iTime));\n    mat3 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 cameraRayDir = viewToWorld * cameraRayDirInView;\n    \n    // distance\n    float dist = rayMarching(cameraPos, cameraRayDir, MIN_DIST, MAX_DIST);\n    \n    // didn't hit\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    \n    // hit point\n    vec3 p = cameraPos + dist * cameraRayDir;\n    \n    // shading\n    vec3 color = lambertIllumination(p) + vec3(0.2);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}