{
    "Shader": {
        "info": {
            "date": "1569023143",
            "description": "Glowing sth.",
            "flags": 0,
            "hasliked": 0,
            "id": "td3GWH",
            "likes": 2,
            "name": "Glowing-S",
            "published": 3,
            "tags": [
                "glow"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define MAX_STEP 60\n#define MAX_DIST 40.0\n#define EPSILON 0.0001\n#define GLOW_COLOR0 vec3(1.0,0.0,0.3)\n#define GLOW_COLOR1 vec3(0.0,0.3,1.0)\n#define SURFACE_COLOR vec3(0.0,1.0,1.0)\n#define AA 2\nfloat sdSphere( in vec3 pos, in float r )\n{\n    return length(pos) - r;\n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nvec2 opUnion( vec2 d1, vec2 d2 ) \n{  \n    return d1.x<d2.x? d1:d2; \n}\n\nvec3 map( in vec3 pos )\n{\n    vec3 p = pos;\n    \n    vec2 d0 = vec2(sdOctahedron(p,3.0), 1.0);\n    \n    vec2 d1 = vec2(sdSphere( p-vec3(0.0,1.2,0.0),2.0 ), 2.5);\n    d1 += 0.2*sin(2.0*p.x+iTime);\n    d1 *= 0.8;\n    \n    \n    d0 = opUnion(d0, d1);\n    \n    \n    vec3 rst = vec3(d0, 0.0);\n    \n    return rst;\n}\n\nvec3 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec3 rst = vec3(0.0, -1.0, MAX_DIST);\n    float t = 0.01;\n    float minDist = MAX_DIST;\n    for ( int i = 0; i < MAX_STEP; ++i )\n    {\n        vec3 p = ro + t * rd;\n        vec3 dist = map(p);\n        minDist = min(minDist, dist.x/t);\n        if ( abs(dist.x)<EPSILON || t>MAX_DIST) break;\n        \n        t += dist.x; \n        rst = vec3(t, dist.y, minDist);\n    }\n    \n    if ( t>MAX_DIST )\n    {\n        rst= vec3(MAX_DIST, -1.0, minDist);\n    }\n    \n    return rst;\n}\n\nvec3 getNormal( in vec3 pos )\n{\n    vec2 offset = vec2(EPSILON, 0.0);\n    return normalize( vec3(map(pos+offset.xyy).x - map(pos-offset.xyy).x,\n                           map(pos+offset.yxy).x - map(pos-offset.yxy).x,\n                           map(pos+offset.yyx).x - map(pos-offset.yyx).x) );\n}\n\nvec3 shading( in vec3 ro, in vec3 rd, in vec3 hit, in vec3 pixCol )\n{\n    vec3 outCol = vec3(0.0);\n    vec3 pos = ro+hit.x*rd;\n    vec3 nor = getNormal(pos);\n    vec3 lightDir = normalize(vec3(0.5, 0.5, 0.5));\n    float diff = max(dot(lightDir, nor), 0.0);\n    if (hit.y == 1.0)\n    {\n        outCol += SURFACE_COLOR*diff;\n    } else\n    {\n        outCol += pixCol*SURFACE_COLOR;//sphere\n    }\n    return outCol;\n}\n\nmat3 getCamera( in vec3 ta, in vec3 ro )\n{\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu,vv,ww);\n}\n\nvec3 render( in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float aTime = iTime*0.4;\n    vec3 ro = vec3(8.0*cos(aTime+mouse.x*6.28),mouse.y*2.0,8.0*sin(aTime+mouse.x*6.28));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 cam = getCamera(ta,ro);\n    vec3 rd = cam*(vec3(uv,0.9));\n    \n    vec3 tex = texture(iChannel0,rd).rgb;\n    vec3 backCol = vec3(tex.r*tex.g*tex.b);\n    col += backCol*backCol*backCol;\n    vec3 hit = raymarch(ro,rd);\n       \n    if ( hit.y>0.0 )\n    {\n        col = shading( ro, rd, hit, col )*2.0;\n    }\n    float glow0 = exp(-24.0*hit.z);\n    float glow1 = exp(-16.0*hit.z);\n    vec3 glowCol = vec3(0.0);\n    float t = fract(iTime*0.5);\n    float y = 3.0*t*(1.0-t); \n    \n    glowCol += 0.5*GLOW_COLOR1*glow0*y;  \n    glowCol += 0.5*GLOW_COLOR1*glow1; \n    glowCol += 0.2*GLOW_COLOR0*exp(-8.0*hit.z); \n    \n    glowCol *= 0.5+0.5*y;\n    return col+glowCol*0.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(0.0);\n    for ( float j = 0.0; j < float(AA); ++j )\n    {\n        for ( float i = 0.0; i < float(AA); ++i )\n        {\n            vec2 off = -0.5+vec2(j,i)/float(AA);\n            col += render(fragCoord+off);\n        }\n    }\n    \n    col /= float(AA*AA);\n    \n    col = pow( col, vec3(0.4546));\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}