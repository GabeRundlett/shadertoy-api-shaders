{
    "Shader": {
        "info": {
            "date": "1559413889",
            "description": "I wanted to recreate the whole scene but it's too much work, so here's one of the shots.\nReference: https://youtu.be/jcZUPDMXzJ8?t=124\nYou can adjust the anti-aliasing level or number of lines per cubic BÃ©zier curve.",
            "flags": 0,
            "hasliked": 0,
            "id": "3t23zh",
            "likes": 18,
            "name": "Dumbo Pink Elephants on Parade",
            "published": 3,
            "tags": [
                "2d",
                "animation",
                "vector",
                "disney",
                "bzier"
            ],
            "usePreview": 0,
            "username": "nyri0",
            "viewed": 818
        },
        "renderpass": [
            {
                "code": "#define AA 1\n#define SPLINE 8\n\n#define ZERO min(iFrame,0)\n\n/* A few explanations are given in my blog post:\n * https://nyri0.fr/en/blog/25\n */\n\n/* Adapted from https://stackoverflow.com/a/218081/8259873\n * Finds out if two lines AB and CD intersect each other */\nint intersects(vec2 A, vec2 B, vec2 C, vec2 D)\n{\n    const vec2 m1 = vec2(1,-1);\n    float c = dot(B, A.yx * m1);\n    vec2 bt = (B - A).yx * m1;\n    if ((dot(C, bt) + c) * (dot(D, bt) + c) > 0.0) return 0;\n\n    c = dot(D, C.yx * m1);\n    bt = (D - C).yx * m1;\n    return ((dot(A, bt) + c) * (dot(B, bt) + c) > 0.0) ? 0 : 1;\n}\n\n/* Utility functions that help calculating the bounding box of \n * a cubic Bezier curve */\nfloat minv(vec4 v)\n{\n    return min(min(v.x,v.y),min(v.z,v.w));\n}\nfloat maxv(vec4 v)\n{\n    return max(max(v.x,v.y),max(v.z,v.w));\n}\n\n/* Calculates the position of the point with parameter t\n * on a cubic Bezier curve */\nvec2 valBezier(vec4 Xs, vec4 Ys, float t)\n{\n    float s = 1.0 - t;\n    vec4 vt = vec4(s*s*s, 3.0*s*s*t, 3.0*s*t*t, t*t*t);\n    return vec2(dot(Xs, vt), dot(Ys, vt));\n}\n\n/* Calculates the number of intersection between the Bezier\n * curve and a line between the given pixel and an arbitrary\n * point outside the curve */\nint nbBezierInter(vec2 uv, vec2[4] pts)\n{\n    const vec2 ref = vec2(0, 1.1);\n    vec4 Xs = vec4(pts[0].x, pts[1].x, pts[2].x, pts[3].x);\n    vec4 Ys = vec4(pts[0].y, pts[1].y, pts[2].y, pts[3].y);\n    if(uv.x < minv(Xs) || uv.x > maxv(Xs)\n       || uv.y < minv(Ys) || uv.y > maxv(Ys))\n        return intersects(uv, ref, pts[0], pts[3]);\n    const int slices = SPLINE;\n    int res = 0;\n    vec2 a = pts[0];\n    float ot = 0.0;\n    for(int i = 1; i < slices; i++)\n    {\n        float t = float(i)/float(slices-1);\n        vec2 b = valBezier(Xs, Ys, t);\n        res += intersects(uv, ref, a, b);\n        a = b;\n    }\n\n    return res;\n}\n\n/* These functions use a Catmull-Rom interpolation to find the control\n * points at the current time and then calculate the number of intersections\n * between the Bezier curve and a line between the given pixel and an\n * arbitrary point outside the curve */\nfloat barry_goldman(vec4 X, vec4 T, float t)\n{\n    vec3 A = ((T.yzw - t) * X.xyz + (t - T.xyz) * X.yzw) / (T.yzw - T.xyz);\n    vec2 B = ((T.zw - t) * A.xy + (t - T.xy) * A.yz) / (T.zw - T.xy);\n\treturn ((T.z - t) * B.x + (t - T.y) * B.y) / (T.z - T.y);\n}\nint nbBezierInter_catmullRom(vec2 uv, vec4[8] pts, vec4 times, float t)\n{\n    vec2[4] inter;\n    for(int l = 0; l < 2; l++) {\n        inter[2*l] = vec2(barry_goldman(vec4(pts[l].x, pts[l+2].x,\n                                           pts[l+4].x, pts[l+6].x),\n                                      times, t),\n                        barry_goldman(vec4(pts[l].y, pts[l+2].y,\n                                           pts[l+4].y, pts[l+6].y),\n                                      times, t));\n        inter[2*l+1] = vec2(barry_goldman(vec4(pts[l].z, pts[l+2].z,\n                                           pts[l+4].z, pts[l+6].z),\n                                      times, t),\n                        barry_goldman(vec4(pts[l].w, pts[l+2].w,\n                                           pts[l+4].w, pts[l+6].w),\n                                      times, t));\n    }\n    return nbBezierInter(uv, inter);\n}\n\n/* Extract 2 points from their compression into an integer */\nvec4 int_to_vec4(uint val) {\n    return vec4((float(val & 255u) - 128.0) / 70.0,\n                (float((val >> 8u) & 255u) - 128.0) / 70.0,\n                (float((val >> 16u) & 255u) - 128.0) / 70.0,\n                (float((val >> 24u) & 255u) - 128.0) / 70.0);\n}\n\n/* A nice looking jump from one position to another */\nvec2 jump(vec2 pos1, vec2 pos2, float t1, float t2, float t)\n{\n    if(t <= t1) return pos1;\n    if(t >= t2) return pos2;\n    float ti = smoothstep(t1, t2, t);\n    return vec2(pos1.x*(1.0-ti) + pos2.x*ti,\n                pos1.y*(1.0-ti) + pos2.y*ti + 0.4*ti*(1.0-ti)*abs(pos2.x-pos1.x));\n}\n\n/* Main function */\nvec3 shot1(vec2 pixCoord, float time)\n{\n    const int nbCurves = 27;\nconst uint data[216] = uint[216] (\n2690162012u,2841486681u,2874714461u,2924981334u,2973871703u,3143940700u,3144399716u,3094657395u,3212884084u,3097083283u,\n3097344153u,3114776992u,3098589607u,2947722947u,2881007538u,2846862001u,2796595631u,2645401777u,2581044653u,2178977244u,\n2112782816u,1926788067u,1992192728u,2327218121u,2092927670u,1722380470u,1537828521u,1335252901u,1335775126u,1218333352u,\n1201162398u,1316243318u,1366511220u,1484937090u,1552046210u,1650745971u,1566859876u,1432180576u,1381455197u,1431065677u,\n1497847116u,1665621317u,1749050183u,1832741437u,1950313789u,2018211403u,2051766347u,2337178439u,2201717582u,1966044481u,\n2014803247u,2200404259u,2552595239u,2640092476u,2756681554u,2840896849u,2857281876u,2924325965u,2957028941u,3075781451u,\n3109664596u,3093674593u,3228809317u,3113401990u,3113662866u,3098065571u,3048257704u,2930290360u,2863509160u,2846075559u,\n2795874723u,2661393062u,2613681825u,2178256862u,2078573013u,1925935831u,1957655243u,2327152585u,2075495093u,1688759987u,\n1504208040u,1335317918u,1302548375u,1218136486u,1200900251u,1316243064u,1383419508u,1535137669u,1585142656u,1634754422u,\n1534026096u,1315853436u,1265061486u,1330137936u,1363365704u,1498764620u,1582192981u,1682792780u,1783587917u,1851026514u,\n1934323284u,2336587845u,2201783109u,1948873787u,2014802985u,2200142363u,2569306915u,2672991026u,2705366596u,2856691264u,\n2873076293u,2940054844u,3023155005u,3091838021u,3142367305u,3092887895u,3211114585u,3112222330u,3112483200u,3096754574u,\n3063724180u,2929438379u,2862657179u,2845158040u,2794957205u,2660541080u,2596511380u,2227934409u,2161804491u,1992718036u,\n1991014086u,2376437176u,2242481573u,2041020587u,1958377895u,1705667514u,1622107562u,1419859116u,1419531425u,1502762390u,\n1552898450u,1687052687u,1635804302u,1517248631u,1433950831u,1266109569u,1214925687u,1263618388u,1313688401u,1364939093u,\n1431261531u,1531663950u,1632131915u,1749771593u,1833134155u,2319155764u,2233698875u,1914401339u,1963618843u,2199290126u,\n2501477142u,2655296293u,2689375568u,2890770504u,2907089997u,2974068292u,2973348164u,3125524038u,3159341643u,3143547997u,\n3261774686u,3163079295u,3180117128u,3147546004u,3131292571u,2980032684u,2913251743u,2895818141u,2829036698u,2660541086u,\n2579275412u,2194904024u,2095022803u,1942581971u,1940747209u,2376436667u,2242547109u,1772450737u,1655663013u,1403016877u,\n1319457696u,1251363486u,1267747478u,1350847880u,1400983684u,1602836869u,1568694153u,1517313664u,1433950832u,1266110081u,\n1231965047u,1263618144u,1313753937u,1364938836u,1397772635u,1565088074u,1632066889u,1749771593u,1833134155u,2319221557u,\n2184022588u,1864789575u,1863937830u,2115861015u,2400747037u,2639304749u\n);\n\n    vec2 uv = (2.0*pixCoord - iResolution.xy) / iResolution.y;\n    vec2 uv_base = vec2(5,2.2) * uv;\n    \n    vec2[5] positions = vec2[5] (\n        uv_base * mix(vec2(1.0,1.0), vec2(0.75,0.75), smoothstep(6.5,20.0,time))\n        \t- jump(vec2(0,0.6), vec2(0.0,-0.75), 6.5, 20.0, time),\n        uv_base * mix(vec2(1.0,1.0), vec2(0.8,0.8), smoothstep(5.5,6.0,time))\n        \t- jump(vec2(0,0.6), vec2(4.5,-0.8), 5.5, 6.0, time),\n        uv_base * mix(vec2(1.0,1.0), vec2(0.8,0.8), smoothstep(4.5,5.0,time))\n        \t- jump(vec2(0,0.6), vec2(-4.5,-0.8), 4.5, 5.0, time),\n        uv_base * mix(vec2(1.0,1.0), vec2(1.1,1.1), smoothstep(3.0,3.5,time))\n        \t- jump(vec2(0,0.6), vec2(4.6,1.0), 3.0, 3.5, time),        \n        uv_base * mix(vec2(1.0,1.0), vec2(1.1,1.1), smoothstep(2.0,2.5,time))\n        \t- jump(vec2(0,0.6), vec2(-4.6,1.0), 2.0, 2.5, time)\n    );\n    \n    int[5] nbInter = int[5] (0,0,0,0,0);\n    float[5] startingTimes = float[5] (5.5,4.5,3.0,2.0,0.0);\n\n    float animTime = 3.0*time;\n    int k;\n    k = int(animTime);\n    for(int i = 0; i < nbCurves; i++) {\n        vec4[8] pts;\n\n        for(int l = 0; l < 2; l++) {\n          pts[l] = int_to_vec4(data[2*nbCurves*(k % 4)+2*i+l]);\n          pts[2+l] = int_to_vec4(data[2*nbCurves*((k + 1) % 4)+2*i+l]);\n          pts[4+l] = int_to_vec4(data[2*nbCurves*((k + 2) % 4)+2*i+l]);\n          pts[6+l] = int_to_vec4(data[2*nbCurves*((k + 3) % 4)+2*i+l]);\n        }\n        vec4 times = vec4(-1, 0, 1, 2);\n\n        for(int j = 0; j < 5; j++) {\n            if(time >= startingTimes[j]) {\n        \t\tnbInter[j] += nbBezierInter_catmullRom(positions[j], pts, times, fract(animTime));\n            }\n        }\n    }\n\n    vec3 col = vec3(0.15,0,0.15);\n    \n    uv = uv + 0.05 * time * vec2(1,0.4);\n    if((nbInter[0] & 1) == 1) {\n        col = vec3(0.55,0.1,0.55);\n    }\n    if((nbInter[1] & 1) == 1) {\n        col = vec3(0.4,0.05,0.3);\n        float dd = mod(uv.y, 0.1);\n        col = mix(col, vec3(0.7,0.15,0.2), 1.0 - smoothstep(0.03, 0.045, dd) + smoothstep(0.085, 0.1, dd));\n    }\n    if((nbInter[2] & 1) == 1) {\n        col = vec3(0.05,0.6,0.6);\n        float dd = mod(uv.x, 0.1);\n        col = mix(col, vec3(0.3,0.9,0.5), 1.0 - smoothstep(0.03, 0.045, dd) + smoothstep(0.085, 0.1, dd));\n    }\n    if((nbInter[3] & 1) == 1 && (nbInter[1] & 1) == 0) {\n        col = vec3(0.1,0.25,0.9);\n        float dd = mod(uv.y - uv.x, 0.15);\n        col = mix(col, vec3(0.05,0.8,0.9), 1.0 - smoothstep(0.05, 0.07, dd) + smoothstep(0.13, 0.15, dd));\n    }\n    if((nbInter[4] & 1) == 1 && (nbInter[2] & 1) == 0) {\n        col = vec3(0.4,0.0,0.4);\n        vec2 uv_o = uv + vec2(0, 0.042 * round(12.0*uv.x));\n        vec2 uv_grid = vec2(round(12.0*uv_o.x), round(12.0*uv_o.y));\n        col = mix(vec3(0.8,0.77,0.2), col, smoothstep(0.35, 0.45, distance(12.0*uv_o, uv_grid)));\n    }\n    \n    return col;\n}\n\n/* Entry point, manages anti-aliasing */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AAf = float(AA);\n    vec3 avgcol = vec3(0);\n    for(int i = ZERO; i < AA; i++) {\n        for(int j = 0; j < AA; j++) {\n            vec2 coord = fragCoord + vec2(i, j) / AAf;\n            avgcol += shot1(coord, iTime);\n        }\n    }\n   \tfragColor = vec4(avgcol / (AAf * AAf), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}