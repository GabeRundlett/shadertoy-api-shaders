{
    "Shader": {
        "info": {
            "date": "1585937424",
            "description": "A graph sorting acceleration structure designed to work efficiently with ray marching. Currently thinking how to optimize it without braking hmmm....",
            "flags": 32,
            "hasliked": 0,
            "id": "wdlyDX",
            "likes": 7,
            "name": "Graph acceleration structure 3D",
            "published": 3,
            "tags": [
                "marching",
                "particles",
                "objects"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 492
        },
        "renderpass": [
            {
                "code": "//Graph is in Buf A, graph traversal is in Buf B\n//You can pause the simulation by setting dt in Common to 0.\n//Change the number of particles by changing N in Common\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    fragColor = texel(ch1, pos);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(64,64)\n#define sN ivec2(4,2)\n#define dt 0.\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define link0 16\n#define linkN 16\n\nstruct links\n{\n    int ids[linkN];\n};\n    \nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n    \nstruct object\n{\n    vec3 X;\n    vec4 q;\n    vec3 P;\n    vec3 L;\n    int type;\n    float m;\n};\n\nvec3 qtransform(vec4 q, vec3 v)\n{ \n\treturn v + 2.0*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n} ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//particle and particle neighbor directional graph buffer \n\nobject obj; vec4 lnk; \n\nvec4 d; int ID; float avgR;\n\n\nobject getObject(int id)\n{\n    object o;\n    vec4 p = texel(ch0, i2xy(ivec3(id, 0, 0)));\n    o.X = p.xyz; o.type = int(p.w);\n    o.q = texel(ch0, i2xy(ivec3(id, 1, 0)));\n    p = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    o.P = p.xyz;\n    o.m = p.w;\n    o.L = texel(ch0, i2xy(ivec3(id, 3, 0))).xyz;\n    return o;\n}\n\nlinks getGraphLinks(int id);\nvec4 getParticlePos(int id);\n\nvec4 saveObject(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(obj.X, obj.type);\n    case 1:\n        return obj.q;\n    case 2:\n        return vec4(obj.P, obj.m);\n    case 3:\n        return vec4(obj.L, 0.);\n    }\n}\n\n \nfloat dist2p(vec3 p, int id);\nvoid sort(int idtemp, int R);\nvoid sortlinks(in links nb, int R);\nvoid sortneighbors(int id, int R);\nvoid sortrandom(int id, int R);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n    \n    ivec3 sid = xy2i(p); ID = sid.x;\n    obj = getObject(ID);\n    links nb = getGraphLinks(ID); //neighbor links\n   \tif(sid.z == 0) //object computation\n    {\n        //compute the force and the torque\n        //TODO\n        vec3 F = vec3(0);\n\n        obj.P += F*dt;\n        obj.X += obj.P*dt/obj.m;\n        \n        if(iFrame<1) //initial conditions\n        {\n            obj.X = 2.*(hash33(pos.xyx + pos.yyx*4.5743) - 0.5);\n            obj.P = 0.001*2.*(hash33(pos.yxy + pos.xxy*PI) - 0.5);\n            obj.L = vec3(0.);\n            obj.q = vec4(0.);\n            obj.type = 0;\n            obj.m = 1.;\n        } \n        \n        U = saveObject(sid.y);\n    }\n    else //graph computation\n    {\n        d = vec4(1e6);\n        lnk = vec4(-1);\n         \n        //local average distance/density\n        avgR = 0.; float NN = 0.;\n        for(int i = min(0,iFrame); i < link0; i++)\n        {\t\n            if(nb.ids[i] >= 0) \n            {\n                NN++;\n        \t\tavgR += dist2p(obj.X, nb.ids[i]);    \n            }\n        }\n        avgR /= NN;\n       \n        sortlinks(nb, sid.y);\n        \n        for(int i = min(0,iFrame); i < linkN; i++)\n        \tsortneighbors(nb.ids[i], sid.y);\n        \n        sortrandom(sid.x, sid.y);\n        \n        U = lnk;\n    }\n}\n\nlinks getGraphLinks(int id)\n{ \n    links L;\n    for(int j = 0; j < linkN/4; j++)\n    {\n        vec4 side0 = texel(ch0, i2xy(ivec3(id, j, 1)));\n        for(int i = j*4; i < j*4 + 4; i++)\n        {\n            L.ids[i] = int(side0[i%4]);\n        }   \n    }\n    return L;\n}\n\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat dist2p(vec3 p, int id)\n{\n    return distance(getParticlePos(id).xyz,p);\n}\n\nbool iscoincidence(int id, int num)\n{\n    bool c = (id == ID) || (id < 0) || any(equal(lnk,vec4(id)));\n    return c;\n}\n\nvoid sort(int idtemp, int R) //sort closest objects in N directions\n{\n    if(iscoincidence(idtemp, R)) return; //particle already sorted\n    vec4 px = getParticlePos(idtemp);\n    vec3 dx = px.xyz - obj.X;\n    \n    if(R < link0/4) //closest\n    {\n        int dir = int(inverseSF(dx, float(link0)).x); \n        int diri = dir%4;\n        int dirR = dir/4;\n        float nd = length(dx);\n        if(dirR == R && nd < d[diri])\n        {\n            d[diri] = nd;\n            lnk[diri] = float(idtemp);\n        }\n    } \n    else // far particles\n    {\n        int dir = int(inverseSF(dx, 4.).x); \n        int diri = dir%4;\n        int rad = R;\n        int dirR = rad;\n        float nd = abs(length(dx) - exp2(float(rad))*avgR);\n        if(dirR == R && nd < d[diri])\n        {\n            d[diri] = nd;\n            lnk[diri] = float(idtemp);\n        }\n    }\n}\n\nvoid sortlinks(in links nb, int R)\n{\n    for(int i = min(0, iFrame); i<linkN; i++) sort(nb.ids[i], R);\n}\n\nvoid sortneighbors(int id, int R)\n{\n    links nb = getGraphLinks(id);\n    sortlinks(nb, R);\n}\n\nvoid sortrandom(int id, int R)\n{\n    for(int i = min(0, iFrame); i<2; i++) sort((12*iFrame+ID+i)%tot_n, R);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//prev closest particle buffer\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n//intersection with the bisector plane\nfloat rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)\n{\n    vec3 n = b - a;\n    float D = length(n);\n    float cosnd = dot(n, d)/D; //ray plane normal angle cosine\n    float l = D*.5 - dot(p - a, n)/D;\n    float t = l/cosnd; //ray parameter\n    return (cosnd>0.)?t:1e10;\n}\n\n//closest voronoi cell and ray intersection\nvec4 findClosestIntersection(vec3 p, vec3 d, vec4 cobj, int mit)\n{\n    int id = int(cobj.w);\n    if(id < 0)\n    {\n        id = 0;\n        cobj.xyz = texel(ch0, i2xy(ivec3(id, 0, 0))).xyz;\n    }\n    \n    int cid = id;\n    vec3 cxy = cobj.xyz;\n \tfloat cd = distance(p, cxy);\n    \n    for(int s = 0; s < mit; s++)\n    {\n        vec3 pxy = cxy;\n        int pid = cid;\n        //t = 1e10;\n        for(int j = 0; j < linkN/4; j++)\n   \t    {\n            vec4 nb = texel(ch0, i2xy(ivec3(pid, j, 1)));\n            for(int i = 0; i < 4; i++)\n            {\n                if(nb[i]<0.) continue; \n                vec3 X = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xyz;\n                float td = distance(p, X);\n                if(td < cd) \n                {\n                    cd = td;\n                    cxy = X;\n                    cid = int(nb[i]);\n                }\n            }\n        }\n       \n        if(pid == cid) break; //found closest voronoi cell\n    }\n   \n    return vec4(cxy,cid);\n}\n\n#define maxd 4.\n#define mind 0.001\n#define maxs 128\n\n//implicit voronoi diagram ray marching\nvec4 rayMarch(vec3 p, vec3 d, int cobjid)\n{\n    float td = 0.; \n    float ld = 0.; \n    float t = 0.;\n   \n    vec4 cobj = vec4(texel(ch0, i2xy(ivec3(cobjid, 0, 0))).xyz, cobjid);\n    cobj = findClosestIntersection(p, d, cobj, 20);\n    int n = 0;\n    for(int i = 0; i < maxs; i++)\n    {\n        //march\n        float DE = sdSphere(p + ld*d - cobj.xyz, 0.05);\n        ld+=DE; td+=DE;\n        \n        //update position\n        p += ld*d; ld = 0.; n++;\n        //find new closest object\n        cobj = findClosestIntersection(p, d, cobj, 4);\n        \n        //outide of the scene\n        if(td > maxd) return vec4(p+ld*d, -1);\n        //has hit the surface\n        if(DE < mind*td) break;\n    }\n    return vec4(p + ld*d, cobj.w);\n}\n\n#define FOV 2.\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1, 0, 0,\n                         0, cos(a.y), sin(a.y),\n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x), sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getRot(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));\n}\n\n#define ldir vec3(1,0,0)\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = (pos - size*0.5)/size.y;\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*PI, PI):vec2(0.1*iTime, PI*0.5);\n    \n    vec3 d = getRay(angles, uv);\n    vec3 p = -2.*getRay(angles, vec2(0.));\n    vec4 prev = pixel(ch1, pos);\n    if(iFrame < 1) prev.w = 0.;\n    vec4 rm = rayMarch(p, d, int(prev.w));\n    if(rm.w >= 0.) //hit object\n    {\n        vec3 pp = texel(ch0, i2xy(ivec3(rm.w, 0, 0))).xyz;\n    \tvec3 n = 0.5*normalize(rm.xyz - pp) + 0.5;\n        U.xyz = vec3(clamp(dot(ldir, n),0.,1.));\n    }\n    else //background\n    {\n        U = texture(iChannel2,  d.yzx);\n    }\n    U.w = rm.w;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}