{
    "Shader": {
        "info": {
            "date": "1678025819",
            "description": "CC0: Walking spirals\nOnce again inspired by twitter stuff: https://twitter.com/junkiyoshi/status/1632340637218672641?s=20",
            "flags": 0,
            "hasliked": 0,
            "id": "ddcGDl",
            "likes": 28,
            "name": "Walking spirals",
            "published": 3,
            "tags": [
                "spirals"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 567
        },
        "renderpass": [
            {
                "code": "// CC0: Walking spirals\n//  Once again inspired by twitter stuff: https://twitter.com/junkiyoshi/status/1632340637218672641?s=20\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat spiralLength(float b, float a) {\n  // https://en.wikipedia.org/wiki/Archimedean_spiral\n  return 0.5*b*(a*sqrt(1.0+a*a)+log(a+sqrt(1.0+a*a)));\n}\n\nvoid spiralMod(inout vec2 p, float a) {\n  vec2 op     = p;\n  float b     = a/TAU;\n  float  rr   = length(op);\n  float  aa   = atan(op.y, op.x);\n  rr         -= aa*b;\n  float nn    = mod1(rr, a);\n  float sa    = aa + TAU*nn;\n  float sl    = spiralLength(b, sa);\n  p           = vec2(sl, rr);\n}\n\nfloat segmentx(vec2 p, float l, float r) {\n  float hl = l*0.5-r;\n  \n  p.x = abs(p.x);\n  \n  float d0 = abs(p.y) -r;\n  float d1 = length(p - vec2(hl, 0.0))-r;\n  return p.x > hl ? d1 : d0;\n}\n\nfloat doubleSpiral(vec2 p, float speed, float toff) {\n  float tm = speed*TIME;\n  const float PERIOD = 14.0;\n  tm += PERIOD*(toff-0.5);\n  mod1(tm, PERIOD);\n  float a = fract(tm);\n  float nt = floor(tm);\n\n  const float lw = 0.01;\n  const float off = 0.376;\n  p.x -= (nt)*off+lw;\n  p.y *= mix(1.0, -1.0, mod(nt, 2.0));\n  vec2 sp0 = p;\n  vec2 sp1 = p;\n  \n  sp1.x -= off;\n  sp1.y = -sp1.y;\n  \n  spiralMod(sp0, .05);\n  spiralMod(sp1, .05);\n\n  vec2 sp2 = sp1;\n\n  const float l = 8.87;\n  sp0.x -= 0.75*l - a*l;\n  sp1.x -= 0.75*l - (a-1.0)*l;\n\n  float d0 = segmentx(sp0, 0.5*l, lw);\n  float d1 = segmentx(sp1, 0.5*l, lw);\n  float d2 = -sp2.x+l;\n  \n  float d = d0;\n  d = min(d, max(-d2, d1));\n  \n  return d;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n\n  for (float i = 0.0; i < 7.0; ++i) {\n    vec2 sp = p;\n    sp *= ROT(TAU*i/3.5);\n    float nx = mod1(sp.y, 1.0);\n    float h0 = hash(nx+123.2+i);\n    float h1 = fract(3677.0*h0);\n    float h2 = fract(8677.0*h0);\n    float h3 = fract(9677.0*h0);\n    float z = mix(0.66, 1.0, h2); \n    sp /= z;\n    float dd = doubleSpiral(sp, 0.5*mix(0.1, 0.4, h0*h0), h1)*z;\n    vec3 bcol = (1.0+cos(1.5*vec3(2.0, 0.0, -1.0)+TAU*h3));\n    col += bcol*smoothstep(aa, -aa, dd);\n  }\n\n  col = 1.0-tanh(col.yxz);\n  col *= vec3(1.0, 0.95, 0.95);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}