{
    "Shader": {
        "info": {
            "date": "1658471681",
            "description": "Based on Cyberpunk 2077 wallpaper [https://store.kde.org/p/1570955/]",
            "flags": 0,
            "hasliked": 0,
            "id": "sdyfRK",
            "likes": 27,
            "name": "Shadertoy glitchy logo",
            "published": 3,
            "tags": [
                "2d",
                "logo",
                "glitch",
                "shadertoy"
            ],
            "usePreview": 1,
            "username": "bitless",
            "viewed": 861
        },
        "renderpass": [
            {
                "code": "// Author: bitless\n// Title: Shadertoy glitchy logo\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\nconst vec2[103] v = vec2[](vec2(-.286,.5),vec2(-.46,.061),vec2(-.354,-.017),vec2(-.5,-.37),vec2(-.442,-.374),vec2(-.33,-.172),vec2(-.329,.112),vec2(-.385,.112),vec2(-.289,.397),vec2(-.257,.263), //\nvec2(-.231,.263),vec2(-.356,-.314),vec2(-.331,-.37),vec2(-.276,-.073),vec2(-.254,-.081),vec2(-.295,-.357),vec2(-.256,-.288),vec2(-.208,-.017),vec2(-.268,.005),vec2(-.186,.354), //\nvec2(-.193,.1),vec2(-.116,-.033),vec2(-.127,-.366),vec2(-.242,-.345),vec2(-.205,-.053),vec2(-.151,-.099), //\nvec2(-.183,-.161),vec2(-.203,-.263),vec2(-.154,-.268), //\nvec2(.001,.074),vec2(-.066,-.331),vec2(-.11,-.374),vec2(-.113,-.09),vec2(-.034,.082),vec2(.004,.315),vec2(.047,.435), //\nvec2(-.036,.013),vec2(-.098,-.124),vec2(-.071,-.275), //\nvec2(.007,.009),vec2(-.044,-.264),vec2(-.021,-.333),vec2(.053,-.264),vec2(.065,-.171),vec2(-.002,-.218),vec2(.004,-.175),vec2(.061,-.146),vec2(.071,-.077),vec2(.015,-.088),vec2(.02,-.052),vec2(.088,-.04),vec2(.094,.009), //\nvec2(.1,.022),vec2(.054,-.371),vec2(.07,-.447),vec2(.097,-.216),vec2(.155,-.437),vec2(.163,-.316),vec2(.126,-.202),vec2(.187,-.144),vec2(.213,.059), //\nvec2(.113,-.062),vec2(.105,-.117),vec2(.118,-.142),vec2(.166,-.085),vec2(.184,.004), //\nvec2(.27,.349),vec2(.246,.159),vec2(.187,.221),vec2(.173,.094),vec2(.236,.077),vec2(.167,-.38),vec2(.278,-.367),vec2(.303,-.242),vec2(.213,-.303),vec2(.262,.077),vec2(.291,.059),vec2(.31,.17),vec2(.268,.142),vec2(.296,.418), //\nvec2(.339,.13),vec2(.289,-.115),vec2(.318,-.227),vec2(.288,-.348),vec2(.36,-.412),vec2(.397,-.119),vec2(.38,.156), //\nvec2(.352,.077),vec2(.313,-.112),vec2(.343,-.289),vec2(.379,-.147), //\nvec2(.39,.168),vec2(.405,-.121),vec2(.432,-.212),vec2(.366,-.453),vec2(.33,-.491),vec2(.383,-.5),vec2(.454,-.237),vec2(.5,.215),vec2(.487,.422),vec2(.47,.124),vec2(.432,-.052),vec2(.389,.31));\n\n\n//Inigo Quiles article \"Simple color palettes\" \n//https://iquilezles.org/articles/palettes/\n#define pal(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) )\n\n// \"Hash without Sine\" by Dave_Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n////////////////////////////////////////\n\nfloat noise11( in float f ) //gradient noise 1D \n{\n    float i = floor( f );\n    f -= i;\n    \n    float u = f*f*(3.-2.*f);\n\n    return mix(hash11( i ), hash11( i + 1. ) , u);\n}\n\nfloat noise12( in vec2 f ) //gradient noise 2D\n{\n    vec2 i = floor( f );\n    f -= i;\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( hash12( i + vec2(0,0) ), \n                     hash12( i + vec2(1,0) ), u.x),\n                mix( hash12( i + vec2(0,1) ), \n                     hash12( i + vec2(1,1) ), u.x), u.y);\n}\n\n\n// IQ's polygon distance field function\n// https://iquilezles.org/articles/distfunctions2d/\n// https://www.shadertoy.com/view/wdBXRW\n\nfloat sdPolygon( in vec2 p, in int f, in int num )\n{\n    //const int num = v.length();\n    float d = dot(p-v[f],p-v[f]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j+f] - v[i+f];\n        vec2 w =    p - v[i+f];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i+f].y, \n                            p.y <v[j+f].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat logo(vec2 gr) //drawing logo\n{\n    float d = sdPolygon(gr,0,10); //S\n    d = min (d,sdPolygon(gr,10,10)); //h\n    d = min (d,sdPolygon(gr,20,6)); //a\n    d = max (d,-sdPolygon(gr,26,3));\n    d = min (d,sdPolygon(gr,29,7)); //d\n    d = max (d,-sdPolygon(gr,36,3));\n    d = min (d,sdPolygon(gr,39,13)); //e\n    d = min (d,sdPolygon(gr,52,9)); //r\n    d = max (d,-sdPolygon(gr,61,5));\n    d = min (d,sdPolygon(gr,66,14)); //t\n    d = min (d,sdPolygon(gr,80,7)); //o\n    d = max (d,-sdPolygon(gr,87,4));\n    return min (d,sdPolygon(gr,91,12)); //y\n}\n\nvoid mainImage( out vec4 O, in vec2 g )\n{\n    vec2 r = iResolution.xy\n        ,uv = (g+g-r)/r.y;\n    \n    float xs = noise11 (floor(uv.y*20.))*sin(floor(uv.y*.5)+iTime); //x-shift for big horizontal stripes\n    xs*=xs*xs;\n    \n    float x = (uv.x+xs*.05)*20. //vertical stripes\n        , cl = floor(x);        //stripe id\n    x -= cl;                    //stripe local x\n    \n    float h = hash11(cl-1.);    //color of previous stripe\n    h = mix(hash11(cl),h,step(x,sin(iTime+h*10.)*.4+.4));  //mixing color of current and previous stripe to draw moving stripes\n    \n    h = sin(h*.7-noise11(uv.x-iTime*1.2)*2.)*.5+.5;  //adding big moving noise for stripes color\n    \n    vec3 C = pal(h,vec3(.8,.5,.3),vec3(.4,1,.7),vec3(1,.2,.6),vec3(.9,.07,.7))*.5-.45; //define background color using palette function\n    \n    C = C * (.5 + sin(uv.y*600.)*.5); //add small horizontal strips (like on analog TV)  \n    \n    cl = noise11 (floor((uv.x+xs*.05)*200.)+iTime)*noise12(vec2(uv.x*5.,iTime)); // adding cyan vertical stripes to background\n    C = mix (C, vec3(0,1,1),cl*cl*cl*.6);\n\n    cl = noise11 (floor(uv.y*200.)+iTime)*noise12(vec2(uv.y*10.,0)+iTime); //adding orange horizontal stripes to background\n    cl*=cl*cl;\n    C = mix (C, vec3(1,.7,0),cl);\n\n    vec2 xy = uv+vec2((xs-cl)*.05+.1,0); //define the coords for the logo with offsets on the horizontal wide stripes and thin orange ones \n    \n    h = noise11(iTime); //adding periodical \"block coding artifacts\"\n    x = 20.;      //num of cells\n    h = h*h*h*noise12(floor(uv*x)); //noise strength\n    xy = ((xy*x-floor(xy*x))*(1.-h*.6)+floor(xy*x))/x; //scale cells\n    \n    ///// drawing logo background\n    cl = noise11(floor(iTime*20.)/4.+.2)*6.28; //strength of the logo shift\n    x = logo(xy*vec2(.5-noise11(iTime)*.1,2.)+vec2(-1,1)*.01+vec2(sin(cl),cos(cl))*.01);  //distance field to logo (scale + shift relative to foreground + noise shift) \n    C = mix (C, vec3(0), smoothstep(.5,.0,x)*.5);   //black shadow on background \n    C = mix (C, vec3(smoothstep(.01,-.03,x),0,0), smoothstep(.005,0.,x-.01)); //logo \"side faces\" (black to red)\n    C = mix (C, vec3(.8,0,.8), smoothstep(.005,-.005,abs(x-.02))*h*.5);        // cyan outline \n\n    ///// drawing logo foreground\n    cl = noise11(floor(iTime*20.)/4.)*6.28; // //strength of the logo shift (and 0.2 seconds earlier than the backgroud)\n    x = logo(xy*vec2(.5-noise11(iTime)*.1,2.)+vec2(sin(cl),cos(cl))*.01); //distance field to logo \n    C = mix (C, vec3(1.-xs,.8-xs*.4,xs*.2), smoothstep(.1,0.,x)*.1); //yellow glow\n    C = mix (C, vec3(1.-xs,.8-xs*.5,xs*.2), smoothstep(.005,0.,x)); //foreground\n    C = mix (C, vec3(0), smoothstep(2./r.y,0.,abs(x-.002)-.001)*.7); //black outline\n    C = mix (C, vec3(.0,.8,.8), smoothstep(.005,-.005,abs(x-.02))*.5*h);   //magenta outline\n\n    C *= (.9 + sin(uv.y*600.)*.2); //add small horizontal strips (like on analog TV)  \n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}