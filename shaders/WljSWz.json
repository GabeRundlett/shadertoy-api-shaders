{
    "Shader": {
        "info": {
            "date": "1565613368",
            "description": "Volume displacement [url]https://docs.arnoldrenderer.com/display/A5AFMUG/Polymesh+to+Volume[/url]\n\nPress 'f' for the gory flesh version, 'l' to disable the texture loop, and mouse click for a closeup.",
            "flags": 48,
            "hasliked": 0,
            "id": "WljSWz",
            "likes": 204,
            "name": "Copper / Flesh",
            "published": 3,
            "tags": [
                "volume",
                "displacement",
                "3dtexture"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 5251
        },
        "renderpass": [
            {
                "code": "/*\n\n    Copper / Flesh\n    --------------\n\n    Press 'f' for the gory flesh version.\n\tPress 'l' to disable the texture loop.\n\tMouse click for a closeup.\n\n\tI was introduced to volume displacement a few weeks ago, which works\n    wonderfully for ray marched SDFs:\n\n\thttps://docs.arnoldrenderer.com/display/A5AFMUG/Polymesh+to+Volume\n\n\tAn FBM domain warp texture is created in Buffer A, and used to adjust\n    the surface distance while marching.\n\n\tThe model is quite slow to march, so I've stored it in a 3D texture.\n\tShadertoy doesn't support writing to 3D textures, so I've used the\n    cubemap feature, and subdivided the 6 2D textures to get another\n    dimension.\n\n*/\n\nbool FLESH = false;\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nbool isMapPass = false;\nbool isBound = false;\n\n// Read head sdf from '3D' texture\nfloat mHead(vec3 p) {\n    p.x = -abs(p.x);\n    p += OFFSET / SCALE;\n    if (isMapPass) {\n    \tfloat bound = fBox(p, 1./SCALE);\n        isBound = bound > .01;\n    \tif (isBound) return bound;\n    }\n    p *= SCALE;\n    float d = mapTex(iChannel0, p, iChannelResolution[0].xy);\n    return d;\n}\n\nfloat g_disp;\n\nvec3 projectOnPlane(vec3 v, vec3 n) {\n\tfloat scalar = dot(n, v) / length(n);\n\tvec3 v1 = n * scalar;\n\treturn v - v1;\n}\n\n// Wrap the fbm texture around the model, focus on getting as\n// much detail as possible on the visible parts.\n// Triplanar mapping would be worth trying here.\nfloat calcDisplacement(vec3 p) {\n    float disp;\n    vec2 uv;\n    p.y += .1;\n    \n    vec3 focus = vec3(.0,.1,1.);\n    vec3 center = -focus * .7;\n    vec3 up = vec3(0,1,0);\n    vec2 rad = vec2(PI/1.25,PI/2.5)/1.5;\n    \n    center *= length(p);\n    \n    p = normalize(p - center);\n    focus = normalize(focus - center);\n    \n    vec3 yPlane = cross(focus, up);\n    vec3 xPlane = cross(focus, yPlane);\n    \n    vec3 xp = normalize(projectOnPlane(p, xPlane));\n    vec3 yp = normalize(projectOnPlane(p, yPlane));\n\t\n    float xa = acos(dot(focus, xp)) * sign(dot(p, yPlane));\n    float ya = acos(dot(focus, yp)) * sign(dot(p, xPlane));\n        \n    uv = .5 - (vec2(xa, ya) / rad / 2.);\n\n    vec4 tex = texture(iChannel2, uv);\n    disp = tex.r;\n    disp = disp * 3. - 1.3;\n    disp = smoothstep(-.5, 5., disp) * 10.;\n\tdisp *= .3;\n  \t\n    if (isMapPass) {\n        g_disp = disp;\n    }\n   \n    // create slight ridges around the edges of holes\n    // I can't decide if I like this\n \tdisp = abs(disp - .1) - .1;\n\n    return disp;\n}\n\nfloat map(vec3 p) {\n    p.y -= .14;\n    #ifndef GIF_EXPORT\n        pR(p.xz, sin(4. * fTime * PI * .5) * .05);\n        pR(p.zy, sin(4. * fTime * PI * 2.) * .03 + .05);\n        if (iMouse.x > 0. && iMouse.y > 0.) {\n            pR(p.zx, ((iMouse.x/iResolution.x)*2.-1.)*.5);\n            pR(p.zy, ((iMouse.y/iResolution.y)*2.-1.)*.5);\n        }\n   \t#else\n    \tpR(p.zy, .05);\n   \t#endif\n    float d = mHead(p);\n    if (d < .1 && ! isBound) {\n        float ds = calcDisplacement(p);\n        d += ds * .03;\n    }\n    return d;\n}\n\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0005,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    vec3 npos;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        npos = pos + eps * invert;\n        nor += map(npos) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nconst int KEY_F = 70;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    //fragColor = texture(iChannel2,fragCoord / iResolution.xy); return;\n    \n    vec3 col;\n\n    vec2 bguv = p + (texture(iChannel2, fragCoord / iResolution.xy).rb* 2. - 1.);\n    \n    float delay = 10. * 1.5;\n    //FLESH = dot(p, vec2(.5)) > sin(clamp(abs(mod(iTime * 1.5, delay * 2.) - delay) - (delay - 1.) / 2., 0., 1.) * PI * .5) * 3. - 1.5;\n    FLESH = bool(texelFetch( iChannel3, ivec2(KEY_F,2),0 ).x);\n    if (FLESH) {\n    \tcol = vec3(0);\n    } else {\n        #ifndef GIF_EXPORT\n    \t\tcol = mix(vec3(.05,.2,.2), vec3(.1,.12,.11), range(2., 1., length(bguv - vec2(1,0))));\n    \t\tcol = mix(col, vec3(.7,.4,.28) * .7, range(4., 1., length(bguv - vec2(-1,3))));\n       \t#else\n        \tcol = vec3(.05,.2,.2);\n        #endif\n    }\n    \n    if (iMouse.z > 0. && iMouse.w > 0.) {\n    \tp /= 1.8;\n    }\n\n    p /= 1.15;\n\n    vec3 camPos = vec3(0,.05,3.2);\n    vec3 rayDirection = normalize(vec3(p + vec2(0,-0),-4));        \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n\n    isMapPass = true;\n\n    for (int i = 0; i < 600; i++) {\n        rayLength += dist * .5;\n        \n        rayPosition = camPos + rayDirection * rayLength;\n        dist = map(rayPosition);\n\n        if (abs(dist) < .0001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 5.) {\n            bg = true;\n            break;\n        }\n    }\n\n    isMapPass = false;    \n            \n    if ( ! bg) {\n        vec3 pos = rayPosition;\n        vec3 rd = rayDirection;\n        vec3 nor = calcNormal(rayPosition);\n        vec3 ref = reflect(rd, nor);\n        vec3 up = normalize(vec3(1));\n\n        // lighitng\n        // IQ - Raymarching - Primitives \n        // https://www.shadertoy.com/view/Xds3zN\n        float hole = range(4., 1., g_disp);\n        float occ = calcAO( pos, nor ) * mix(.5, 1., hole);\n\t\tvec3  lig = normalize( vec3(-.5, 1., .5) );\n        vec3  lba = normalize( vec3(.5, -1., -.5) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= softshadow( pos, lig, 0.01, .5 ) * hole;\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 1.55*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        if (FLESH) {\n        \tcol = vec3(1, 0.8, 0.78) * .3;\n        \tcol = mix(col, vec3(.4,.05,.03) * .5, range(.0, .15, g_disp));\n        \tcol = mix(col, vec3(1,.0,.05) * .2, range(.2, .5, g_disp));\n        \tcol = mix(col, vec3(.05,0,0), range(.4, .5, g_disp));\n        } else {\n\t\t\tcol = pow(texture(iChannel1, ref).rgb, vec3(2.2)) * vec3(1,1,.9);\n        \tcol = mix(col, vec3(0,.3,.2), range(.02, .5, g_disp));\n        \tcol = mix(col, vec3(0,.1,.12), range(.3, .5, g_disp));\n        }\n        col = col*lin;\n\t\tcol += 5.00*spe*vec3(1.10,0.90,0.70);\n    }\n\n    #ifndef GIF_EXPORT\n    \tcol *= range(1.5, .4, length(fragCoord.xy / iResolution.xy - .5));\n   \t#endif\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define GIF_EXPORT\n#ifdef GIF_EXPORT\n\t#define fTime mod(iTime / 4., 1.)\n#else\n\t#define fTime (iTime / 24.)\n#endif\n\n\n/*\n\n    '3D' Texture Utils\n    ------------------\n\n\tThese allow reading and writing to a cubemap texture that's\n    repurposed as a 3D texture of one channel float values.\n\n    The structure can be thought of as a stack of 1 voxel thick slices,\n    where each slice is distributed throughout our 6 cubemap textures.\n\n    The resolution of each slice is small enough that multiple slices\n    can fit into one texture, like a sheet of postage stamps. As we only\n    need to store a single float for each voxel, we can also distribute\n    slices across the 4 rgba channels.\n\n*/\n\nvec2 texSubdivisions = vec2(8,2);\n\n#define MIRROR\n#define SCALE (vec3(4.1,1.73,1.75)/1.1)\n#define OFFSET vec3(.95, .094, -.088)\n\n// #define SCALE vec3(1)\n// #define OFFSET vec3(0)\n\n// Cubemap face ID from direction (normal)\n// 0 x\n// 1 y\n// 2 z\n// 3 -x\n// 4 -y\n// 5 -z\nint faceIdFromDir(vec3 v) {\n    vec3 va = abs(v);\n    int id = 0;\n    float m = va.x;\n    if (va.y > m) id = 1, m = va.y;\n    if (va.z > m) id = 2;\n    if (v[id] < 0.) id += 3;\n    return id;\n}\n\n\n// Direction from uv and cube face ID\n// uv : vec2(0,0) to vec2(1,1)\n// id : 0 to 5\n\nvec3 dirFromFaceId(vec2 uv, int id) {\n    vec3 dir = vec3(.5, .5 - uv.yx);\n    dir = normalize(dir);\n    if (id == 4) dir.yz *= -1.;\n    if (id > 2) dir.xz *= -1., id -= 3;\n    if (id == 1) return (dir * vec3(1,-1,-1)).zxy;\n    if (id == 2) return (dir * vec3(1,1,-1)).zyx;    \n    return dir;\n}\n\n\n// Assign a 3D position to a texture coordinate and channel\n\n// xy is split for each z slice, and further slices\n// are split across channels and cube map faces\n\n// Divide texture into 3d space coordinates\n// uv : 2d texture coordinates vec2(0) - vec2(1)\n// c : rgba channel 0 - 3\n// id : cubemap face id 0 - 6\n// size : cubemap resolution\n\nvec3 texToSpace(vec2 coord, int c, int id, vec2 size) {\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n    vec2 subCoord = floor(coord / subSize);\n    float z = 0.;\n    z += float(id) * 4. * sub.y * sub.x; // face offset\n    z += float(c) * sub.y * sub.x; // channel offset\n    z += subCoord.y * sub.x; // y offset\n    z += subCoord.x; // x offset\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    z /= zRange;\n    vec2 subUv = mod(coord / subSize, 1.);\n    vec3 p = vec3(subUv, z);\n    p = p * 2. - 1.; // range -1:1\n    return p;\n}\n\n\n// As above, but returns four 3D positions,\n// ready for use when writing to each rgba channel.\n\n// See mainCubemap in the Cube A tab\n\nmat4 texToSpace(vec2 coord, int id, vec2 size) {\n    return mat4(\n        vec4(texToSpace(coord, 0, id, size), 0),\n        vec4(texToSpace(coord, 1, id, size), 0),\n        vec4(texToSpace(coord, 2, id, size), 0),\n        vec4(texToSpace(coord, 3, id, size), 0)\n    );\n}\n\n\n// Transform 3D position into it's corresponding cubemap texture\n// ray direction (normal) and channel, so we can lookup its\n// stored value\n\n// p : 3D position in range vec2(-1) to vec2(1)\n// size : cubemap texture resolution\n\n// This is the inverse of texToSpace\n\nvec4 spaceToTex(vec3 p, vec2 size) {\n    p = clamp(p, -1., 1.);\n    p = p * .5 + .5; // range 0:1\n\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n\n    // Work out the z index\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float i = round(p.z * zRange);\n\n    // return vec3(mod(i, sub.x)/sub.x);\n    // translate uv into the micro offset in the z block\n    vec2 coord = p.xy * subSize;\n\n    int faceId = int(floor(i / (4. * sub.y * sub.x)));\n    float channel = mod(floor(i / (sub.x * sub.y)), 4.);\n    float y = mod(floor(i / sub.x), sub.y);\n    float x = mod(i, sub.x);\n    \n    // Work out the macro offset for the xy block from the z block\n    coord += vec2(x,y) * subSize;\n\tcoord /= size;\n    \n    vec3 dir = dirFromFaceId(coord, faceId);\n\n    return vec4(dir, channel);\n}\n\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\n\n// Lookup value from the '3D' texture\n\n// See mHead in the Image tab\n\nfloat mapTex(samplerCube tex, vec3 p, vec2 size) {\n    // stop x bleeding into the next cell as it's the mirror cut\n    #ifdef MIRROR\n        p.x = clamp(p.x, -.95, .95);\n    #endif\n    vec2 sub = texSubdivisions;\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float z = p.z * .5 + .5; // range 0:1\n    float zFloor = (floor(z * zRange) / zRange) * 2. - 1.;\n    float zCeil = (ceil(z * zRange) / zRange) * 2. - 1.;\n    vec4 uvcA = spaceToTex(vec3(p.xy, zFloor), size);\n    vec4 uvcB = spaceToTex(vec3(p.xy, zCeil), size);\n    float a = texture(tex, uvcA.xyz)[int(uvcA.w)];\n    float b = texture(tex, uvcB.xyz)[int(uvcB.w)];\n    return mix(a, b, range(zFloor, zCeil, p.z));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n\n    Head SDF\n    --------\n\n\tThis gets written into a \"3D\" texture using the utilities in Common.\n\t\n\tFor other appearances see:\n\n    * https://www.shadertoy.com/view/wlf3WX\n\t* https://www.shadertoy.com/view/wtf3RM\n\n*/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\nfloat fHalfCapsule(vec3 p, float r) {\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\n}\n\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\n// Modelling\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat helix(vec3 p, float lead, float thick) {\n    // p.z += iTime * .1;\n    float d = (mod(atan(p.y, p.x) - p.z * lead, PI * 2.) - PI) / lead;\n    d = abs(d) - thick;\n    return d;\n}\n\nvoid fMouth(inout float d, vec3 pp) {\n    vec3 p;\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n}\n\nbool isMap = true;\nbool isEye = false;\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    //p.y -= .13;\n\n    vec3 pa = p;\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = pp;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = pp;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n\n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\n    brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // jaw\n\n    p = pp;\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = pp + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // return d;\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    fMouth(d, pp);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    // return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n    if (isMap) isEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // hole\n    p = pp;\n    p += vec3(-.36,.19,.06);\n    pR(p.xz, -.5);\n    pR(p.xy, -.2);\n    p.x += .02;\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}\n\nfloat map(vec3 p) {\n    p -= OFFSET;\n    p /= SCALE;\n   \treturn mHead(p);\n\treturn length(p) - .3;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    int id = faceIdFromDir(rayDir);\n    \n    vec2 coord = fragCoord.xy;\n    vec2 size = iResolution.xy;\n    vec2 uv = coord / size;\n    \n    vec4 lastFrame = texture(iChannel0, rayDir);\n    if (lastFrame.x != 0. && iFrame > 2) {\n        fragColor = lastFrame;\n    \treturn;\n    }\n    \n    mat4 space = texToSpace(coord, id, size);\n    \n    vec3 p0 = space[0].xyz;\n    vec3 p1 = space[1].xyz;\n    vec3 p2 = space[2].xyz;\n    vec3 p3 = space[3].xyz;\n\n    fragColor = vec4(\n        map(p0),\n        map(p1),\n        map(p2),\n        map(p3)\n    );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "/*\n\n    FBM Domain Warp Texture\n    -----------------------\n\n\tBased on \"bp Turbulence\" by blackpolygon https://shadertoy.com/view/Ml3SRf\n\n\tI've picked a nice looking area of the texture for the default loop,\n    if you get bored of that, press 'l' and it'll show more variation.\n\n*/\n\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat random (in vec2 _st) { \n    #ifdef GIF_EXPORT\n    \treturn fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.54531237);\n   \t#endif\n    return texture(iChannel0, _st / iChannelResolution[0].xy).r;\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1. - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 9\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(20.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), \n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.2 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nconst int KEY_L = 76;\n\nvec3 pattern(vec2 st) {\n    \n    #ifdef GIF_EXPORT\n        st = st.yx * .42;\n    \tst.x -= .015;\n        st += vec2(9.24,9.-.07);\n   \t#else\n        st *= .3;\n        st += vec2(-6.7,4.7);// + ((iMouse.xy / iResolution.xy) - .5) * -1.5;\n   \t#endif\n    \n    vec3 color = vec3(0.);\n    vec2 a = vec2(0.);\n    vec2 b = vec2(0.);\n    vec2 c = vec2(60.,800.);\n    \n    a.x = fbm( st);\n    a.y = fbm( st + vec2(1.0));\n    \n    b.x = fbm( st + 4.*a);\n    b.y = fbm( st);\n\n    #ifdef GIF_EXPORT\n    \tc.x = fbm( sin(mod(st + 7.0 * b + fTime, 1.) * PI * 2.)*.3 );\n    \tc.y = fbm( sin(mod(st + 3.944 * b + fTime, 1.) * PI * 2.)*.3 );\n   \t#else\n        bool loop = ! bool(texelFetch( iChannel1, ivec2(KEY_L,2),0 ).x);\n        if (loop) {\n            c.x = fbm( sin(mod(st + 7.0 * b + fTime, 1.) * PI * 2.) );\n            c.y = fbm( sin(mod(st + 3.944 * b + fTime, 1.) * PI * 2.) );\n        } else {\n            c.x = fbm( st + 7.0 * b + fTime * 2. );\n            c.y = fbm( st + 3.944 * b + fTime );\n        }\n   \t#endif\n\n    float f = fbm(st+b+c);\n\n    f *= 1.3;\n    f = pow(f, 3.)*1.9;\n    \n    color = mix(vec3(0.445,0.002,0.419), vec3(1.000,0.467,0.174), clamp((f*f),0.2, 1.0));\n    color = mix(color, vec3(0.413,0.524,0.880), clamp(length(c.x),0.480, 0.92));\n    color *= f * 1.9;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 ir = iResolution.xy;\n    vec2 p = (fragCoord.xy - 0.5*ir.xy )/min(ir.x,ir.y);\n    p.x /= (ir.x/ir.y) / (640./360.);\n    fragColor = vec4(pattern(p), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}