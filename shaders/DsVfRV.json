{
    "Shader": {
        "info": {
            "date": "1698413623",
            "description": "Using a mixture of raymarching and cell by cell traversal techniques to raymarch a pseudo random box subdivision in order to render a basic sci-fi looking scene in realtime.",
            "flags": 32,
            "hasliked": 0,
            "id": "DsVfRV",
            "likes": 84,
            "name": "Offworld Storage Facility",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "voxel",
                "greeble",
                "subdivide"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1461
        },
        "renderpass": [
            {
                "code": "/*\n\n    Offworld Storage Facility\n    -------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n/*\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 3., coc = 2.5;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n*/\n\n\n// IQ's float to float hash. I've added an extra sine wrapping modulo to\n// cater for my annoying AMD based system, which can't wrap sine with a \n// proper degree of accuracy.\nfloat hash11B(float x){ return fract(sin(mod(x, 6.2831853))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a heap of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// If you're interested in bokeh, Dave's function above and some of Shadertoy user, \n// Hornet's, are probably the one's you should be looking at. Xor has some cool simple \n// ones on here too.\n//\nvec4 bloom(sampler2D iCh, vec2 uv){\n\n\n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 3., coc = 2.5;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 2.);\n    //float ra = smoothstep(.1, .9, abs(uv.y - .5)*2.)*2.;\n    //float ra = mix(clamp(l/coc, 0., 2.), smoothstep(.3, 1., abs(uv.y - .5)*2.), .25);\n    //float ra = (smoothstep(.2, 1., length(uv - .5)));\n\n \n\n    // Standard Fibonacci distribution calculations, compliments of Dave Hoskins.\n    const int iter = 96;\n    float rad = 2.5;//max(2.*ra, .5); // Bokeh radius.\n    float r = 1.;\n\tvec4 tot = vec4(0), div = tot;\n    vec2 vangle = vec2(0., rad*.01/sqrt(float(iter)));\n    #define GA 2.3999632 // Golden angle.\n    const mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n    // Aspect ratio.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    \n    \n\tfor (int i = 0; i<iter; i++){\n        \n        #if 1\n        \n        // Dave Hoskin's Fibonacci based scattering. Cheaper and much nicer, so\n        // it's set as the default.\n        // The approx increase in the scale of sqrt(0, 1, 2, 3...).\n        r += 1./r;\n\t    vangle = rot*vangle;\n        vec4 col = texture(iCh, uv - (r - 1.)*vangle*aspect, iResolution.y/450.*1.); \n        \n        #else\n        \n        // A hash based random distribution, for anyone who wants to try it.\n        //int ii = i%10; // For square bokeh.\n        //int jj = i/10;\n    \n        // Random offset contained within a disk or radius n.\n        float fi = float(i) + fract(iTime);\n        //vec2 fi = vec2(ii, jj) - 5. + fract(iTime);\n        vec2 rnd2 = vec2(hash11B(fi), hash11B(fi + .1)*6.2831);\n        vec2 offs = 6.*sqrt(rnd2.x)*vec2(cos(rnd2.y), sin(rnd2.y));\n        offs *= rad;\n        //offs = rad*(offs + (vec2(hash11B(fi), hash11B(fi + .21)) - .5));\n        vec4 col = texture(iCh, uv - offs/iResolution.xy, iResolution.y/450.*1.);  \n  \n        #endif\n         \n        // Thanks to Dave for figuring out how to tweak the colors to produce brighter \n        // contrast. It's common sense... once someone figures it out for you. :D \n        //\n        // Linear falloff -- Not always necessary, but I need things to fade out\n        // toward the edges. Nonlinear falloff is possible too.\n        col *= 1. - float(i)/float(iter); \n        vec4 bokeh = col*col;\n\t\ttot += bokeh*bokeh;\n\t\tdiv += bokeh;\n        \n\t}\n    \n    \n    // Mixing the original value with the bokeh tweaked value according\n    // to the depth of field and a hand tweaked brightness factor.\n    vec4 colOrig = texture(iCh, uv);\n\treturn colOrig + tot/div*2.*ra; //mix(colOrig, colOrig + tot/div*2., ra);///\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Uncomment the \"DpthFld\" function first.\n    //vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    \n    // A bloom function. A lot of it comes from Dave Hoskins's bokeh function.\n    // See the function above for a link to the original.\n    vec4 col = bloom(iChannel0, uv);\n    \n    // Retrieving the stored color only.\n    //vec4 col = texture(iChannel0, uv);\n\n\n    // Subtle vignette.\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Offworld Storage Facility\n    -------------------------\n    \n    Using a mixture of raymarching and cell by cell traversal techniques \n    to raymarch a pseudo random box subdivision in order to render a\n    basic sci-fi looking scene in realtime. The methods used here aren't \n    what I'd call common, but most are not new either.\n    \n    I love perusing static geometry-based sci-fi scenes rendered with \n    applications like Blender, Cinema 4D, etc. Of course, this scene\n    doesn't compare to the beauty and sheer complexity of some of the\n    imagery out there, but hopefully it conveys that it's possible to do \n    more in a pixelshader than rendering a bunch of perfectly aligned \n    flat cubes.\n    \n    The methods used have been described before, but for those not\n    familiar, this is a rendering of a basic 3D subdivided grid, with some\n    extra XYZ axes shuffling to give the appearance of haphazardness.\n    This is definitely not what I'd call a decent random 3D packing, but\n    it was simple to make and efficient enough for the purposes of this\n    realtime demonstration. By the way, with some basic tweaks, this \n    particular packing can look quite random in appearance.\n    \n    A standard raymarching algorithm has been used with the addition of \n    ray-to-cell wall boundary collisions performed in order to advance \n    the ray from cell to cell. This way, you can render artifact free \n    scenes with most of the benefits or raymarching. More importantly, \n    only one cell per pass need be rendered, which means it's much faster. \n    It also means that you can render in more detail without slowing down \n    your GPU.\n    \n    Anyway, the purpose of this example was to demonstrate a traversal of\n    a quasi random box scene in realtime, so not a lot of effort was put\n    into the design -- I'm not sure where I was going with this, but it \n    has subtle Quake 3 overtones. :)\n    \n    \n    \n    Related examples:\n    \n    // This is more of a sliced layer example, but it's still a 3D traversal \n    // of what I'd call an irregular grid and it uses a similar technique.\n    asymmetric blocks layers tower - jt\n    https://www.shadertoy.com/view/DdKBDh\n    \n    // IQ was using a similar technique to this before it was cool. :D\n    Cubescape  - iq\n\thttps://www.shadertoy.com/view/Msl3Rr \n    \n\n*/\n\n// Maximum scene distance.\n#define FAR  15.\n\n// Color scheme - Copper with lights: 0, Titanium with purple: 1\n#define SCHEME 0\n\n// Light type - Direct: 0, Point: 1\n#define LIGHT_TYPE 1\n\n// Object ID.\nint gOID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n \n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed \n    // on account of the fact that I'm not in the habit of questioning stuff written by \n    // Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture \n    // sample, represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like \n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nfloat ubox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n \n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){ \n    //return texture(iChannel2, p).x;\n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n\nfloat hashV(vec2 a, float b){\n\n    vec3 p = vec3(a.x, b, a.y);\n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n\n}\n/*\n// This is IQ's WebGL 2 hash formula: I've modified it slightly to \n// take in the normal decimal floats that we're used to passing. It \n// works here, I think, but I'd consult the experts before using it.\n//\n// I remember reading through a detailed explanation of the C++ hash \n// we all used to use many years ago (which the following would be\n// similar to), but have long since forgotten why it works. By the \n// way Nimitz, and Dave Hoskins have formulae on Shadertoy that's worth\n// looking up.\n//\n// Integer Hash - III - IQ\n// https://www.shadertoy.com/view/4tXyWN\nfloat hash21(vec2 p){\n    \n    uvec2 q = floatBitsToUint(p);\n\tq = 1103515245U*((q>>1U)^q.yx);\n    uint n = 1103515245U*(q.x^(q.y>>3U));\n    return float(n)/float(0xffffffffU);\n}\n*/\n\n\n \n\nvec4 uTone(vec4 x){\n    return ((x*(x*.6 + .1) + .004)/(x*(x*.6 + 1.)  + .06) - .0667)*1.933526;    \n}\n\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nvec3 smin(vec3 a, vec3 b, float k){\n\n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nvec3 smax(vec3 a, vec3 b, float k){\n    \n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 path(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 1., t);\n     \n    // Transcendental path moving around the XY plane.\n    float a = sin(t*.22);\n    float b = cos(t*.28);\n    return vec3(a*4. - b*1.5, (b*1.2 + a*1.), t);\n     \n    \n}\n\n\n/*\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ \n\n    //float h = getTex(iChannel0, p/32.).x; \n    float h = dot(getTex(iChannel0, p/32.), vec3(.299, .587, .114)); \n    float hv = min(h, abs(p.x)/8.);\n    return hv*8. + h*1. + .05;//h*.975 + .025;\n }\n */\n \n // The 3D distance field function to test voxels against. This is\n // just some 3D noise with a path guided tunnel running through it.\n float hm(vec3 p3){\n\n    // Path.\n    vec2 pth = path(p3.z).xy;\n    vec3 p = p3;\n    p.xy -= pth.xy;\n    \n    // Noise with a cylinder (wrapped around a path) taken out of it.\n    float tx = texture(iChannel2, p3/48.).x;\n    return max((tx - .5), -(length(p.xy/vec2(1, 1.5)) -  .85));\n\n}\n\n\n\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec3 hash23(vec3 f){\n    \n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n    \n    // See: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); \n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// Subdivided rectangle grid.\nvec3 getGrid(vec3 p, inout vec3 sc, inout vec3 id){\n    \n \n    // Block offsets.\n    vec3 ipOffs = vec3(0);\n    /*\n    // Alternate Y floor bricks.\n    if(mod(floor(p.y/sc.y) + floor(p.z/sc.z), 2.)<.5){\n        p.x -= sc.x/2.; // Row offset. //*hash21(vec2(0, id.y))\n        ipOffs.x += .5; //*hash21(vec2(0, id.y))\n    }*/\n    \n    // X, Y and Z offsets.\n    vec3 ii = floor(p/sc);\n    //vec3 h3 = vec3(hash21(ii.xy), hash21(ii.yz), hash21(ii.zx))*.5 + .5;//\n    vec3 h3 = vec3(2./3.);//\n    \n    vec3 mp = mod(ii, 2.);//mod(floor(p/sc), 2.);\n    if(mp.x<.5 && mp.y>.5){\n        p.z -= sc.z/2.*h3.x; // Row offset. //*hash21(vec2(0, id.y))\n        ipOffs.z += .5*h3.x; //*hash21(vec2(0, id.y))\n    } \n    if(mp.y<.5 && mp.z>.5){\n        p.x -= sc.x/2.*h3.y; // Row offset. //*hash21(vec2(0, id.y))\n        ipOffs.x += .5*h3.y; //*hash21(vec2(0, id.y))\n    }\n    if(mp.z<.5 && mp.x>.5){\n        p.y -= sc.y/2.*h3.z; // Row offset. //*hash21(vec2(0, id.y))\n        ipOffs.y += .5*h3.z; //*hash21(vec2(0, id.y))\n    }    \n\n \n    // Original position.\n    vec3 oP = p;\n    \n    \n    // Block ID.\n    vec3 ip;\n    \n    //ip = floor(p/sc) + .5;\n    \n    //#define EQUAL_SIDES\n    \n    // Subdivide.\n    for(int i = 0; i<2; i++){\n        \n        // Current block ID.\n        ip = floor(p/sc) + .5;\n        float fi = float(i)*.0617; // Unique loop number.\n        #ifdef EQUAL_SIDES        \n        // Squares.\n        \n        // Random split.\n        if(hash31(ip*sc + .253 + fi)<.333){\n           sc /= 2.;\n           p = oP;\n           ip = floor(p/sc) + .5; \n        }\n        \n        #else\n        \n        // Powers of two rectangles.\n        \n        //vec3 h23 = hash23(ip*sc + .253 + fi);\n        // h42 = texture(iChannel2, ip*sc*113.619 + .253 + fi);\n        \n        // Random X-split.\n        if(hash31(ip*sc + .253 + fi)<.333){//3 && sc.x>1./8.\n        //if(h23.x<.333){\n           sc.x /= 2.;\n           p.x = oP.x;\n           ip.x = floor(p.x/sc.x) + .5;\n        }\n        // Random Y-split.\n        if(hash31(ip*sc + .453 + fi)<.333){ // && sc.y>1./8.\n        //if(h23.y<.333){\n           sc.y /= 2.;\n           p.y = oP.y;\n           ip.y = floor(p.y/sc.y) + .5;\n        }\n        // Random Z-split.\n        if(hash31(ip*sc + .653 + fi)<.333){ // && sc.y>1./8.\n        //if(h23.z<.333){\n           sc.z /= 2.;\n           p.z = oP.z;\n           ip.z = floor(p.z/sc.z) + .5;\n        }        \n        #endif\n         \n    }\n    \n    // Cell ID (id is an \"inout\" variable).\n    id = (ip + ipOffs)*sc;    \n     \n    \n    // Return the local coordinates.\n    return p - ip*sc;\n\n}\n\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec3 gID;\nvec3 gP;\n\n\nvec3 glow; // Glow.\n\nfloat map(vec3 q3){\n  \n\n\n    // Floor. You can barely see it, but it's down there.\n    float fl = abs(q3.y + .1 + 4.) - .1;\n  \n     \n    vec3 sc = vec3(.5, 1, .5); // Scale.\n \n     // Local coordinates and cell ID.\n    vec3 id; // The cell ID is an \"inout\" variable.\n    vec3 p3 = getGrid(q3, sc, id); \n    // 3D coordinates.\n    vec3 p = p3;\n    \n   \n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - p)/gRd;\n    //vec2 rC = (gDir.xz*sc.xz - p)/gRd.xz; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0001;\n    //gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n\n    // The 3D distance field for that particular cell. \n    // See the \"hm\" function, above.\n    float h = hm(id);\n \n\n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    vec3 oSc = sc;\n    sc -= .03;//.1*(hash31(id + .09)*.8 + .2);\n    \n    // Saving the global scale.\n    gSc = sc;\n    \n    \n    \n    // Object distance, inner window object and window light.\n    float d = 1e5;\n    float innerD = 1e5;\n    float winLight = 1e5;\n    \n    \n    // If we're under the 3D distance field zero mark, render an object,\n    // and whatever else, in that cell.\n    if(h<0.){\n   \n\n        // Edge factor.\n        float ef = sqrt(min(min(oSc.x, oSc.y), oSc.z));\n        \n        d = sBoxS(p, vec3(sc.x, sc.y, sc.z)/2., ef*.04);\n        float oD = d;\n        innerD = d + .08;\n        vec3 win;\n        win.x = sBoxS(p, vec3(oSc)/vec3(3.5, 3.5, 2), ef*.04);\n        win.y = sBoxS(p, vec3(oSc)/vec3(2, 3.5, 3.5), ef*.04);\n        win.z = sBoxS(p, vec3(oSc)/vec3(3.5, 2, 3.5), ef*.04);\n        //win.z = sBoxS(p.xz, sc.xz/2., 0.);\n\n        \n\n        win = max(win, -innerD);\n        ////float tx = texture(iChannel2, q3*4.).x;\n        //win += tx*.002;\n\n        // Window frames.\n        d = min(d, min(min(win.x, win.y), win.z));\n        //d = min(d, win.y);\n        //d = min(d, win.z);\n\n\n\n        // Empty out the space in the windowed rooms.\n        d = max(d, -innerD);\n        innerD += .005;\n\n        \n        // Adding some very basic striated greeble lines. You could\n        // do much more interesting stuff than this.\n        vec3 q = p3;\n        q = mod(q, 1./16.) - .5/16.;\n         \n        // X-direction. Left and right box striations.\n        if(hash31(id + .11)<.35){\n            float lx = sBoxS(p.xy, oSc.xy/vec2(3.5) - ef*.06, 0.);\n            d = max(d, -lx);\n            winLight = min(winLight, lx);\n            /*vec2 q = p.xy;\n            d = max(d, -sBoxS(q, sc.xy/8., 0.));        \n            q = mod(q- sc.yz/12., sc.xy/3.) - sc.xy/3.;\n            d = max(d, -sBoxS(q , sc.xy/8., 0.));*/\n        }\n        else d = max(d, -max(abs(q.x) - .25/16., -oD));\n\n        // Z-direction box striations.\n        if(hash31(id + .21)<.35){\n           float lx = sBoxS(p.yz, oSc.yz/vec2(3.5) - ef*.06, 0.);\n            d = max(d, -lx);\n            winLight = min(winLight, lx);\n            /*vec2 q = p.yz;\n            d = max(d, -sBoxS(q, sc.yz/8., 0.));        \n            q = mod(q - sc.yz/12., sc.yz/3.) - sc.xy/3.;\n            d = max(d, -sBoxS(q , sc.yz/8., 0.));*/\n        }\n        else d = max(d, -max(abs(q.z) - .25/16., -oD));\n    \n    }\n    \n \n    // Object ID.\n    gOID = d<innerD && d<fl? 0 : innerD<fl? 1 : 2;\n    \n\n    // Minimum distance.\n    d = min(fl, d);\n\n\n    // If we've hit the light object, add some glow.\n    if(max(winLight, innerD - .1)<d){\n         float rnd = hash31(id + .06);\n         vec3 gCol = .5 + .47*cos(6.2831*rnd/12. + vec3(0, 1.2, 2) + 1.);//vec3(1, .2, .1)\n         glow += gCol/(.001 + dot(p, p)*256.); // Truchet cable lights.\n    }\n\n\n    // Saving the box dimensions and local coordinates.\n    //gSc = vec3(sc.x, h, sc.z);\n    gSc = vec3(sc.x, sc.y, sc.z);\n    gID = id;\n    gP = p;\n    \n \n    // Return the minimum distance.\n    return d;\n}\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iNum) {\n    \n    float d, t = hash31(ro + rd + fract(iTime))*.05;\n    //const float tol = TOLERANCE;\n    vec2 dt = vec2(1e8, 0);\n    int i = 0;\n    \n    glow = vec3(0);\n\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd; \n\n    const int iter = 160;\n    for (i = 0; i<iter; i++) {\n       \n        d = map(ro + rd*t);\n        // IQ's clever edge desparkle trick. :)\n        if (d<dt.x) { dt = vec2(d, t); } \n\n        if (d < .001*(1. + t*.05) || t > FAR) { break; }\n\n        t += min(d*.7, gCD);\n        //t += min(min(d*.7, gCD), .1);\n    }\n    \n    \n    //t = min(t, FAR);\n    \n    if(i == iter - 1) { t = dt.y; }\n\n    iNum = i;\n\n    return min(t, FAR);\n}\n\nfloat softShadow(in vec3 ro, in vec3 ld, float lDist, in float k) {\n    \n    // Shadow value: Initialized to the maximum.\n    float sh = 1.;\n    // Cyberjax's suggestion, to avoid potential divide-by-zero conflicts.\n    float t = 1e-8; \n    \n    /*\n    #if LIGHT_TYPE == 1\n    ld = (ld - ro);\n    float lDist = length(ld);\n    ld /= max(lDist, .0001);\n    #endif\n    */\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(ld)*.5;\n    gRd = ld; \n\n    for (int i = 0; i<48; i++){\n    \n        float d = map(ro + ld*t);\n        sh = min(sh, k*d/t);\n        if (sh<0. || t>lDist) break;\n        t += clamp(min(d, gCD), .01, .5);\n    }\n    \n    return max(sh, 0.); // Shadow range: [0, 1].\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, \n// or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale \n    // texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks \n    // to EvilRyu for reminding me why we perform this step. It's been a while, but I \n    // vaguely recall that it's some kind of orthogonal space fix using the Gram-Schmidt \n    // process. However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n} \n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map\n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.002, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n    \n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += max(hr - d, 0.)*sca;\n        sca *= .75;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\n// Trowbridgeâ€“Reitz (GGX).\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);   \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .88, .6).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Roughness.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return col*(diff + vec3(.2, .4, 1)*spec*PI);\n  \n}\n////////////////////\n\n\nvec3 render(vec3 ro, vec3 rd, vec3 light, inout float tt){\n \n  \n  int iter;\n  float t = rayMarch(ro, rd, iter);\n  tt = t;\n  \n\n  // Saving the cell ID, cell scale, and local coordinates.\n  vec3 svID = gID;\n  vec3 svSc = gSc;\n  vec3 svP = gP;\n  \n  // Glow.\n  vec3 svGlow = glow;\n  \n  // Object ID.\n  int svOID = gOID;\n  \n  // Dark fog color.\n  vec3 fog = mix(vec3(.7, 1, .5), vec3(.5, .7, 1), rd.y*.5 + .5)/64.;\n  \n  // Diferent color scheme fog.\n  #if SCHEME == 1\n  fog = fog.zxy*4.;\n  #endif\n  \n  // Initialize the scene background to the fog.\n  vec3 col = fog;\n   \n  \n  // If we've hit an object, color it in.\n  if (t < FAR) {\n  \n    // Hit point and normal.\n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    \n    \n    // Texture base bump mapping.\n    n = texBump(iChannel1, p*2. + svID/4.*0., n, .005);///(1. + t/FAR)\n    \n    \n    // Light type: Point light or directional light.\n    #if LIGHT_TYPE == 1\n    vec3 ld = light - p; // Point light.\n    float lDist = length(ld);\n    ld /= max(lDist, .001);\n    float atten = 1./(1. + lDist*lDist*.5);\n    #else\n    float lDist = FAR; \n    vec3 ld = normalize(light); // Directional light.\n    float sDist = length(ld*FAR - t*rd)/FAR;\n    float atten = 1./(1. + sDist*sDist*.5);\n    #endif\n    \n    \n    // Shadow and AO.\n    float shd = softShadow(p + n*.0015, ld, lDist, 8.);\n    float ao = calcAO(p, n);\n    \n    // Texturing the surface.\n    float txSc = svOID==0? 1. : 1./3.;\n    vec3 tx = tex3D(iChannel1, (p + svID/4.*0.)*txSc, n);\n  \n   \n    // Material properties.\n    // Adding in some very artificial microfaceted surface roughness.\n    float matType = 1.; // Metallic.\n    float roughness = min(dot(tx, vec3(.299, .587, .114))*3., 1.);\n    float reflectance = .5;\n \n    \n    // Main object color. Some kind of copper, I guess.\n    vec3 oCol = vec3(.8, .6, .4)/3.;\n    \n    \n    #if SCHEME == 1\n    oCol = mix(oCol.yzx, oCol.yyy, .8); // Different color scheme.\n    #endif\n    \n    // Floor color.\n    if(svOID==2) oCol /= 2.;\n    \n    // Window light color. Obviously brighter.\n    if(svOID==1) oCol = vec3(4);\n  \n   \n    // Adding some texture to the color.\n    oCol *= tx*2. + .05;\n    \n    // Randomly shading various objects.\n    float h = hash31(svID + .12);\n    oCol *= h*.5 + .5;\n    \n \n    // Specular reflection. \n    vec3 hv = normalize(ld - rd); // Half vector.\n    vec3 ref = reflect(rd, n); // Surface reflection.\n    vec3 refTx = texture(iChannel3, ref).xyz; refTx *= refTx; // Cube map.\n    float spRef = pow(max(dot(hv, n), 0.), 5.); // Specular reflection.\n    float rf = 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .02));\n    rf *= (svOID == 0)? 32. : .1;\n    oCol += oCol*spRef*refTx.xxx*rf*1.;\n    \n    \n    // BRDF lighting.\n    vec3 ct = BRDF(oCol, n, ld, -rd, matType, roughness, reflectance);\n    \n    // Ambient light.\n    #if LIGHT_TYPE == 1\n    float amb = .4;\n    #else \n    float amb = .3; // A little less ambient light for direct lighting.\n    #endif\n    \n    // Applying lighting and shadows.\n    col = (oCol*amb*(shd*.5 + .5) + ct*shd); \n    \n     \n    #if SCHEME == 1\n    svGlow = svGlow.yzx; // Alternate color scheme.\n    #endif\n    \n    // Adding the window glow.\n    col += oCol*mix(svGlow.zyx, svGlow.yxz, min(length(svP/gSc), 1.))*4.;\n    \n    // AO and attenuation.\n    col *= ao*atten; \n    \n\n  }\n\n  // Applying the fog.\n  col = mix(col, fog, smoothstep(.3, .99, t/FAR));\n  \n  // Scene color.\n  return col;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n  vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n \n  \n  \t// Camera Setup.\n    float speed = 1.;\n    float tm = iTime*speed;\n    vec3 lk = path(tm + .25) + vec3(0, -.05, 0);  // \"Look At\" position. Look down a bit.\n    vec3 ro = path(tm);// + vec3(0, 1.5, 0); // Camera position, doubling as the ray origin.\n    \n    #if LIGHT_TYPE == 1\n    vec3 lp = path(tm + 3.25); // Light position, somewhere near the moving camera.\n   // Light position offset. Redundant here.\n    vec3 loffs =  vec3(0, 0, 0);\n    //vec2 a = sin(vec2(1.57, 0) - lp.z*1.57/10.);\n    //loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    lp += loffs;\n    #else\n    vec3 lp = -vec3(1, -4, -2); // Directional light option.\n    #endif\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 rd = normalize(fwd/FOV + uv.x*rgt + uv.y*up);\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2(path(lk.z).x/24.)*rd.xy; \n\n    float t;\n    vec3 col = render(ro, rd, lp, t);\n    \n    // Applying a bit of last minute Uncharted 2 toning.\n    col = uTone(col.xyzx).xyz;\n    //col = col/(1. + col/2.5); // Rough extended Reinhard toning.\n\n    \n    \n    #if 0\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./2.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), t), blend);\n    #else\n    fragColor = vec4(max(col, 0.), t);\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}