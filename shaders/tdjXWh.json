{
    "Shader": {
        "info": {
            "date": "1553658623",
            "description": "this very quickly hits limits of its environment.\nfirst version got removed, as it crashed opengl.\n2nd version has black frame for speed.\n\nCommonTab has library\nSoundTab has purposeConcept",
            "flags": 8,
            "hasliked": 0,
            "id": "tdjXWh",
            "likes": 1,
            "name": "CostasArray O(n*n*n*n)",
            "published": 3,
            "tags": [
                "prime",
                "chess",
                "entropy",
                "sonar",
                "calculus",
                "interferrence",
                "galois",
                "costasarray",
                "golombruler",
                "repetitionfree",
                "patternfree",
                "schoenberg"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 578
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/tdjSWh\n\n//introducing context:\n// https://www.youtube.com/watch?v=RENk9PK06AQ\n//==[The world's ugliest music - Scott Rickard - TEDxMIA]\n//TagRef: repetitionfree,patternfree,prime, chess, sonar, calculus, interferrence, galois, costasarray, golombruler,entropy,Schoenberg\n//...uglybeauty\n\n//start of structure+definition:\n//start of structure+definition:\n//start of structure+definition:\n\n//[costas array] checker (and non-costas-error visualizer)\n//to be able to check if an array is a [costas array], defined by:\n//- no 2 entries are the same (any entry exists once)\n//- no 2 derivatives (of any degree up to the array-size)between any 2 entries are the same (differential)\n\n//let n=squareSizeInPixels=OrderOfCostasArray\n//then we need\n//n*(n+1)/2*(n*(n+1)/2+1)/2\n//comparisons to check if an array is a costasArray (wellow border)\n//or if it is not a CostasArray (red border)\n\n//FoW (in 2d)\n#define viewZoom 32. \n\n//for compatibility with old opengl versions \n//(and to make arrays forksafe)\n//define shitty array struct\n//, with get()set()wrappers and constant array length code.\n//maxlen 27 ceashes too many tested environments (this first version is a bit shitty, too)\n#define maxLen 26\nstruct arr{int a[maxLen];int len;};\nvoid setN(inout arr u,int n,int s){n=clamp(n,1,maxLen);u.len=max(u.len,n);u.a[n-1]=s;}\nint  getN(arr u,int n){return u.a[clamp(n-1,0,u.len-1)];}//worksafing clamp()is faster than mod()\narr  newA(){arr r; r.len=1; r.a[0]=0;return r;}\n\n\n//modify setArray()to set the size of the array \n//AND the height of its pixels (last parameter)\n//first column is .x of a dot (position of array entry)\n//first column ideally counts up, largest entry sets costasArrayLengh to be tested\n//second column is .y of a dot (array entry value at posiion)\n//\n//theres only 1 pixel per column (later ones overwrite earlier ones)\n//any 2 pixels in the same line will be marked in white\n//where this is found ONCE (is not a CostasArray in that case)\narr setArray(){ //this could be read from a vertex buffer.\n ;arr a=newA() //set costas array of length maxLen\n ;setN(a,1,1) //write array entries\n ;setN(a,2,3)\n ;setN(a,3,4)\n ;setN(a,4,2)\n ;setN(a,5,5)\n//If (you want to see a yellow border)\n//The commonTab lists a few symmetric costasArrays\n//But so far, larger arrays crashed opengl of quite a fre environments.\n//It is silly/naive to do this in 1 fragment shader\n\n//https://www.shadertoy.com/view/3s3BDr\n//has some other costas arrays in its BufferD\n\n/*\n//order 27 crashed my opengl once, that is exactly once too often\n//below is a costas array of length 27 to be tested\n;setN(a, 1,1)\n;setN(a, 2,25)\n;setN(a, 3,19)\n;setN(a, 4,5)\n;setN(a, 5,4)\n;setN(a, 6,12)\n;setN(a, 7,10)\n;setN(a, 8,16)\n;setN(a, 9,26)\n;setN(a,10,7)\n;setN(a,11,18)\n;setN(a,12,6)\n;setN(a,13,23)\n;setN(a,14,27)\n;setN(a,15,24)\n;setN(a,16,8)\n;setN(a,17,21)\n;setN(a,18,11)\n;setN(a,19,3)\n;setN(a,20,22)\n;setN(a,21,17)\n;setN(a,22,20)\n;setN(a,23,13)\n;setN(a,24,15)\n;setN(a,25,2)\n;setN(a,26,9)\n;setN(a,27,14)\n*/     \n\n ;return a;}\n\n//it NEVER checks if any .y>max(.x)or if any .y<1\n//i ommitted that check to let you move something OutOfBounds \n//without getting unnecessarily confused.\n//, though it does check if thy (or their differentials)are identical.\n//checks take time, and this is already O(pow(n,4))complex!\n\n\n\n\n//this code is intentionally coded naively\n//, to support older opengl versions.\n//- simple worksafing structure \n//- all indexing (of getters, setters and arrayLenght) starts at 1.\n//- only costant array lengths\n//- only constant number of loop iterations\n//  (less iterations are done by escape-time-countDowns)\n//- array LENGTH indexind starts at 1 \n//  (an array of 1 entry at index 0 has a length of 1)\n//- first instance o this shader is naive/inefficient loops\n//  , no parallel processing in this one!\n//- set()get()functions are overly specific\n//  , to allow overwriting or to swapping of rows/columns\n//- next to no divideAndConquer/nested-loop-optimization\n\n\n//end of structure and definition\n//end of structure and definition\n//end of structure and definition\n\n\n//[costas array] checker (and non-costas-error visualizer)\n//to be able to check if an array is a [costas array], defined by the criteria:\n//- no 2 entries are the same\n//- no 2 derivatives (of any degree up to the array-size)between any 2 entries are the same (differential)\n//\n//costasArrays are golomb-rulers, but extended into more than 1 domain\n//3d variants exist, but are significantly more complex and have much less utility per complexity\n//\n//this shader marks the first  case  (2 entries       are the same)in white                  , with red    border (not costas)\n//this shader marks the second case  (2 differentials are the same)in black+yellow (or brown), with red    border (not costas)\n//this shader marks all other  cases (no 2 differentials are identical)in pink                   , with yellow border (is costas array)\n//this shader does NOT care for domain/range cyclic costas\n//- its possible, but ends up being less than half as fast (adds a lot of modulo and doubles number of comparisons)\n//- its not much of a difference, as most costas arrays are NOT domain-cyclic or range-cyclic, this is an additional/strong criteria\n//this shader does not care for costas-symmetry\n//- it could easily find diagonal-mirror-symmetry, but thats really not needed, and easily checked visually, orwith an image editor.\n\n//todo: maybe add a UI that lets you toggle pixels in a buffer, and it tells you of your bitmap is a costas array.\n//ideally gain enough intuition to find any costas array of order 30, 31 or 32.\n\n//WARNING, slow inefficient code, because\n//the complexity of the question [is this a costas array] grows exponentially in complexity to array length [n]\n//this needs n*(n+1)/2*(n*(n+1)/2+1)/2 comparisons, it is kinda O(n*n*n*n/4)complex?\n//\n//this quickly exhausts the number of pixels in one fragment shader anyways\n//to parallelize this (up to a copmplexity limit)anyways:\n//remember that sum[1..n] = n*(n+1)/2\n//and we need to compare sum[1..n] differentials (over the .x range), and for each differential we do sum[1..n] comparisons,\n//, to check if(any 2 entries of a list (of differentials)are identical)\n//in total, we get sum[[1]..[sum[[1]..[n]]]] comparisons/pixels and then must check if ANY of these (pixels)is [false]\n//this quickly gets a bit tricky to stride into a 2d array.\n//for array order  29, we need sum[1..[sum[1.. 29]]=sum[1..00435]= 00094830 pixels of binary state.\n//for array order  33, we need sum[1..[sum[1.. 33]]=sum[1..00561]= 00157641 pixels of binary state.\n//for array order 100, we need sum[1..[sum[1..100]]=sum[1..10100]= 51010050 pixels of binary state.\n//and then che check if ANY of your pixels is false, may not be the fastest check.\n//sure, its doable for costas array up to order 29, but it quickly hits bounds of 2d space (where we have like 31*4 addressable bits per fragment?)\n\n//so, yeah, this is the VERIFICATION visualizer of a costas array.\n//finding a costas array is a whole different thing, that is a bit trickier.\n//so far, methods to find costas arrays involve prime permutations and modulo patterns of galois-fields\n//whos exponents quickly exceed 128bit address space.\n//\n//which is why there exists a database of costas arrays, compressed roughly 2 gb in size, up to order 1030\n//and it has [unknown gaps] above oder 29\n//, and it has null entries for any order\n//, whos [prime-number-multiplicity exceeds 4], or is [-1 lower than an order, whos prime multiplicity exceeds 4]:\n//order 32=2*2*2*2*2 and order 31=2*2*2*2*2-1 have NULL known costas arrays, but noone cooperated to really check for all permutations!\n//that has only been done for orders up to 29.\n//order 30 has some known costas arrays, but there are likely some unknown costas arrays of order 30 (as of 2019-03)\n//so yeah, this is a VERY open math question, and its solution-space may even involve diophantine equations within galois-fields.\n\n\n\n\n\n\n\n\n\n//return array type[arr] as list of differentials of [a] with indexDistance [d]=[0<d<a.len]\narr strideDiff(arr a,int d\n){arr r=newA()\n ;for(int i=1;i<maxLen;i++\n ){setN(r,i,getN(a,i)-getN(a,i+d))\n  ;if (i+d>=a.len)break;}\n ;return r;}\n\n//getDupeEntry;\n//return pointers to the first 2 found duplicate entries in [a], comparing from a[0] till a[l].\n//if (there are no duplicate entry in [a] till entry a[l] )return ivec2(-1,-1)\nivec2 getDupeEntryS(ivec2 r,arr a,int i,int j\n){for(i=1;i<j;i++){if(getN(a,i)==getN(a,j))return ivec2(i,j);}\n ;return r;}\n\nivec2 getDupeEntry(arr a\n){ivec2 r=ivec2(-1,-1)//default state of [no dupes found]\n ;for(int i=0;i<maxLen-1;i++\n ){if(i==a.len)return r\n  ;r=getDupeEntryS(r,a,i,a.len-i)\n ;}return r;}\n\n//return if [a] is a [costas array] of order [a.len]\nivec3 isCostas(arr a\n){for(int i=1;i<=a.len;i++\n ){ivec2 dupes=getDupeEntry(strideDiff(a,i))\n  ;if(dupes.x!=-1)return ivec3(dupes,i);//return 2 indexes of found duplicate differential and dx\n  ;}\n ;return ivec3(-1,-1,-1);}//case of no dupes AND all in bounds == is costas Array\n\n\n\nvec4 demoCostas(vec2 u){\n ;arr a=setArray()\n //;setN(a,5,5)\n ;int x=0;\n ;ivec2 v=ivec2(u)\n     //2 early exists likely increase performance quite a lot\n ;if(min(v.x,v.y)<0||max(v.x,v.y)>a.len+1)return vec4(0)\n ;vec4 state=vec4(1,1,0,1)\n ;ivec3 c=ivec3(-1,-1,-1)\n ;c.xy=getDupeEntry(a)\n //silly special case;if it doesnt even fulfill the condition for the checsboard-tower (2 points share 1 line)\n //is handled seperately, because its visualization is simpler/different\n ;if(c.y!=-1){state=vec4(1,0,0,1)\n  ;if(min(v.x,v.y)<1)return state\n  ;if(max(v.x,v.y)>a.len)return state\n  ;if(v.y==getN(a,v.x)&&(v.x==c.x||v.x==c.y))return vec4(1,1,1,1)//2 white points in the same line.y\n  ;if(v.y==getN(a,v.x))return vec4(1,0,1,1)\n  ;return vec4(0,0,1,0);\n  ;}\n ;c=isCostas(a)//getDupeEntry(a)//getDupeEntryS(c,a,1,a.len)//isCostas(a,a.len)\n ;if(c.y!=-1)state=vec4(1,0,0,1)//red outer frame means its not a costas array.\n ;if(min(v.x,v.y)<1)return state\n ;if(max(v.x,v.y)>a.len)return state\n ;vec4 r=vec4(0,0,1,1);\n ;if(v.y==getN(a,v.x))r=vec4(1,0,1,1)\n ;if(c.y!=-1//if there is a duplicate differential, highlight it!\n ){if(v.y==getN(a,v.x)&&(v.x==c.x||v.x==c.x+c.z))r=vec4(1,1,0,1)//2 yellow points ==1 differential\n  ;if(v.y==getN(a,v.x)&&(v.x==c.y||v.x==c.y+c.z))r=vec4(0,0,0,1)//2 black  points ==1 differential ==SAME differential\n  //special case of 3 points sharing the same differential between them, we just tint ALL points green (lazy)\n  ;if(v.y==getN(a,v.x)&&(c.y==c.x+c.z))r=vec4(.5,.5,0,1)//2 yellow points ==1 differential 2 differentials\n  ;}\n ;return r;\n ;\n ;}//should return ivec2(-1,-1)\n\n//You have a linear slider domain [0..2] or domain [0..1] (set by iMouse.x)\n//, that outputs a ratio of range [1/zfar,zfar]\n//this implements that function, and its inverse (asserting a constant zFar)\n//its surprsingly simple; pow(b,a)/b AND its inverse\n\n//you resolved the absurdity of the [axiom of infinity]\n//...while; 0.0<zFar=lessThanOrEqualTo(AddressSpace)\n//, range [1/zfar,zfar] is a finite closed interval.\n\n\n//alost-infinity, bound by address space.\n//#define zFar 100.\n\nvec2 fra(vec2 u,vec2 r){u*=viewZoom/r; u-=.5*viewZoom; u.x*=r.x/r.y;return u;}\n//checkerboard by https://www.shadertoy.com/view/4tG3Wh\n//float checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n\n/*\nfloat aA(vec2 r){return max(r.x,r.y);}\n#define Aa(r)1./aA(r)\nfloat ss(float a,float b){return smoothstep(b,-b,a);}\n*/\n\n\n\n\nvoid mainImage(out vec4 o,vec2 u\n){u=fra(u,iResolution.xy)\n ;vec4 m=vec4(fra(iMouse.xy,iResolution.xy),fra(iMouse.zw,iResolution.xy))\n //;float anchor=ss(.1,length(u)-.1)//a dot inscreenspace center as screenspace anchor to not get lost.\n ;u+=.5*viewZoom;m.xz+=.5*viewZoom//offset context as we only care for positive values\n //;float now=1.-ss(.1,min(u.x,u.y))//mark x=0, y=0 with a corner\n ;//float c=checkerBool(u)//checkerboard raster\n ;//float wavelength=abs(m.z)\n ;//u.x/=wavelength\n ;//m/=wavelength\n //;float g=ratioDemo(u,iResolution.xy,m)\n ;//o=vec4(fract(iDate.w)+i.x/iResolution.x)\n //;g=max(g,anchor)\n //;o=vec4(g,now,c,1)\n ;o=vec4(0)\n //;if(iFrame<10.)o=demoCostas(u);\n ;o=demoCostas(u)\n ;\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nselection of some costasArrays\npersonally i only care for diagonal-mirror-symmetrical costasArrays, because these compress a lot better.\n\nall* symmetrical costas arrays of order 2 are:\n\t1\t2\nall* symmetrical costas arrays of order 3 are:\n\t1\t3\t2\nall* symmetrical costas arrays of order 4 are:\n\t1\t2\t4\t3\nall* symmetrical costas arrays of order 5 are:\n\t1\t3\t4\t2\t5                          <---- demoed \n\t2\t4\t1\t5\t3\nall* symmetrical costas arrays of order 6 are:\n\t1\t4\t5\t3\t2\t6\n\t1\t5\t3\t6\t2\t4\n\t1\t6\t3\t5\t4\t2\n\t1\t6\t4\t3\t5\t2\n\t2\t4\t5\t1\t6\t3\nall* symmetrical costas arrays of order 7 are:\n\t1\t2\t6\t4\t7\t3\t5\n\t1\t2\t7\t4\t6\t5\t3\n\t1\t2\t7\t5\t4\t6\t3\n\t1\t7\t3\t4\t6\t5\t2\n\t2\t1\t5\t7\t3\t6\t4\n\t2\t1\t6\t4\t7\t3\t5\n\t2\t5\t6\t1\t3\t7\t4\n\t2\t5\t6\t4\t1\t7\t3\n\t2\t6\t1\t3\t4\t7\t5\n\t3\t6\t1\t7\t5\t2\t4\nall* symmetrical costas arrays of order 8 are:\n\t1\t5\t8\t4\t2\t7\t6\t3\n\t1\t7\t3\t8\t6\t5\t2\t4\n\t1\t7\t4\t3\t5\t8\t2\t6\n\t3\t5\t1\t8\t2\t7\t6\t4\nall* symmetrical costas arrays of order 9 are:\n\t1\t4\t6\t2\t9\t3\t8\t7\t5\n\t2\t1\t5\t8\t3\t9\t7\t4\t6\nall* symmetrical costas arrays of order 10 are:\n\t1\t7\t4\t9\t3\t5\t8\t6\t2\t10\n\t2\t1\t9\t4\t5\t8\t10\t6\t3\t7\n\t2\t6\t8\t1\t9\t5\t3\t4\t10\t7\n\t2\t8\t9\t4\t1\t3\t7\t5\t10\t6\n\t3\t9\t1\t4\t5\t10\t8\t7\t2\t6\n\t3\t9\t7\t8\t4\t1\t6\t10\t2\t5\t\nall* symmetrical costas arrays of order 11 are:\n\t1\t6\t8\t9\t4\t10\t3\t7\t5\t2\t11\n\t1\t7\t5\t8\t10\t4\t9\t6\t2\t3\t11\n\t1\t7\t11\t6\t8\t4\t2\t5\t10\t9\t3\n\t1\t10\t4\t3\t8\t11\t9\t5\t7\t2\t6\n\t3\t10\t1\t9\t6\t5\t7\t11\t4\t2\t8\nall* symmetrical costas arrays of order 12 are:\n\t1\t2\t8\t12\t7\t9\t5\t3\t6\t11\t10\t4\n\t1\t2\t11\t5\t4\t9\t12\t10\t6\t8\t3\t7\n\t1\t4\t11\t2\t10\t7\t6\t8\t12\t5\t3\t9\n\t3\t6\t1\t12\t10\t2\t7\t9\t8\t5\t11\t4\n\nall* symmetrical costasArrays of order 16 are\n\t1\t13\t3\t16\t14\t8\t10\t6\t15\t7\t12\t11\t2\t5\t9\t4\n\t3\t12\t1\t4\t10\t6\t14\t9\t8\t5\t15\t2\t16\t7\t11\t13\n\t3\t13\t4\t15\t12\t6\t10\t2\t7\t8\t11\t1\t14\t16\t9\t5\n\t6\t14\t10\t7\t9\t1\t4\t16\t5\t3\t12\t11\t15\t2\t13\t8\n\nall* symmetrical costasArrays of order 27 are\n\t1\t25\t19\t5\t4\t12\t10\t16\t26\t7\t18\t6\t23\t27\t24\t8\t21\t11\t3\t22\t17\t20\t13\t15\t2\t9\t14\n\t3\t9\t1\t8\t13\t15\t19\t4\t2\t20\t11\t25\t5\t17\t6\t27\t14\t24\t7\t10\t26\t23\t22\t18\t12\t21\t16\n\t3\t24\t10\t26\t20\t15\t13\t23\t14\t1\t8\t4\t22\t19\t21\t2\t5\t25\t9\t17\t6\t7\t11\t16\t27\t12\t18\n\t4\t17\t21\t9\t11\t16\t25\t12\t1\t7\t26\t22\t14\t15\t13\t20\t23\t3\t24\t6\t18\t8\t2\t27\t10\t5\t19\n\t6\t10\t23\t13\t16\t1\t11\t20\t15\t2\t7\t26\t4\t27\t9\t5\t19\t25\t17\t8\t24\t22\t3\t21\t18\t12\t14\n\t6\t16\t20\t12\t14\t7\t1\t25\t8\t17\t18\t26\t11\t23\t10\t24\t15\t13\t3\t19\t22\t27\t5\t2\t9\t4\t21\n\t6\t23\t14\t8\t21\t1\t26\t4\t22\t20\t12\t11\t16\t3\t17\t13\t15\t24\t27\t10\t5\t9\t2\t18\t25\t7\t19\n\n[*]== there are more than these BUT these extra costas-arrays are just a few SPECIFIC diagonal offsets \n(aslong the mirror axis) of the ones that are listed.\nand theres always the 4 axisAligned mirrors of g-symmetry.\n\nsome symmetrical costasArrays f order 30 are:\n\t1\t23\t14\t12\t18\t26\t30\t20\t25\t11\t10\t4\t16\t3\t21\t13\t22\t5\t19\t8\t15\t17\t2\t28\t9\t6\t29\t24\t27\t7\n\t11\t22\t5\t13\t23\t10\t2\t26\t29\t15\t19\t20\t14\t4\t6\t21\t18\t27\t1\t30\t25\t7\t3\t9\t16\t28\t17\t8\t24\t12\n\t12\t24\t20\t17\t2\t9\t29\t3\t16\t4\t28\t18\t19\t27\t22\t6\t10\t1\t30\t8\t14\t25\t11\t5\t15\t7\t21\t23\t26\t13\n\t13\t26\t2\t21\t29\t4\t9\t11\t15\t27\t12\t8\t17\t18\t7\t22\t1\t30\t20\t23\t6\t24\t19\t16\t10\t3\t25\t5\t28\t14\n\na symmetrical costas array of order 35 is:\n\t1\t12\t7\t27\t32\t30\t3\t24\t31\t17\t19\t2\t16\t29\t20\t13\t10\t35\t11\t15\t23\t33\t21\t8\t26\t25\t4\t34\t14\t6\t9\t5\t22\t28\t18\n\t\na symmetrical costas array of order 65 is:\n\t1\t29\t46\t16\t24\t37\t17\t22\t12\t63\t55\t9\t15\t42\t13\t4\t7\t26\t44\t56\t50\t8\t49\t5\t40\t18\t32\t34\t2\t54\t51\t27\t65\t28\t53\t57\t6\t39\t38\t25\t48\t14\t59\t19\t62\t3\t58\t41\t23\t21\t31\t61\t35\t30\t11\t20\t36\t47\t43\t64\t52\t45\t10\t60\t33\n\na symmetrical costas array of order 99 is:\n1\t33\t94\t11\t21\t59\t40\t85\t39\t44\t4\t75\t88\t36\t73\t56\t60\t45\t67\t61\t5\t24\t55\t22\t87\t30\t92\t64\t37\t26\t49\t51\t2\t79\t38\t14\t29\t35\t9\t7\t97\t63\t89\t10\t18\t70\t62\t76\t31\t99\t32\t78\t65\t74\t23\t16\t96\t71\t6\t17\t20\t47\t42\t28\t53\t95\t19\t69\t68\t46\t58\t86\t15\t54\t12\t48\t82\t52\t34\t91\t98\t77\t93\t90\t8\t72\t25\t13\t43\t84\t80\t27\t83\t3\t66\t57\t41\t81\t50\n\n/**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 mainSound( in int samp, float time ){return vec2(0);}\n\n/*\nthe core idea here is to apply mercury.sexy \nto a very low-entropy asset-library\n, to procedurally generate a target-sequence\n- reuse the same deformations and pointers to a common asset library\n\nfinding or veryfiying a costasArray is hard/slow\n, but compressing a LUT of many costasArrays \n, just to use them as sequencer-basis, is fast and simple\n\nthat sequence is then visual and audible and easily remixed/transitioned\n\nsymmetric costas arrays are a very low entropy entity.\n- with most symmetry-fold of mercury.sexy \nyou more likely add repetition/entropy than reducing it.\n\nwe include all symmetric costas arrays of order less than 30.\n- most of them are not domain or range periodic costas.\n- some of them are mirror-axis.transflection costas for a few offsets\n- - you can offset the context frame \n   along the mirror symmetry axes \n   and sometimes get a costas array from that.\n\nwe exclude all non.-symmetric costas arrays\n- they just do not compress so well. \nthey are valid for this purpose\n, but lack of mirror symmetry near-duplicatesthe LUT-size for them.\n/**/",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}