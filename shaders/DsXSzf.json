{
    "Shader": {
        "info": {
            "date": "1669473833",
            "description": "Exact distance to a 2D rotationally symmetric object. The pattern shouldn't extend beyond the adjacent segments, and should join up smoothly between segments, or overlaps won't be correct. Mouse sets some parameters, see code for other controls.",
            "flags": 16,
            "hasliked": 0,
            "id": "DsXSzf",
            "likes": 16,
            "name": "Rotational Symmetry SDF",
            "published": 3,
            "tags": [
                "sdf",
                "rotation",
                "polygon",
                "asymmetric"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 273
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////\n//\n// Rotational Symmetry SDF, mla, 2022\n// Exact distance to a shape with purely rotational symmetries.\n// Fold down to a fundamental region, but unlike the dihedral case\n// we need to take account of adjacent regions to correctly\n// compute the SDF, though we only need to check the adjacent\n// half regions, so drawing 2 region's worth in total.\n\n// Here we also draw a non-convex polygon, using winding number\n// to find the interior.\n//\n// <mouse>: set rotation and pattern parameter\n// 'r': autorotation\n// 's': skip the folding step\n// 'x': show fundamental region boundaries\n//\n//////////////////////////////////////////////////////////////////\n\nint wind = 0;\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  // Conveniently, this works by shooting out a ray to right, which\n  // handily fits in with our fundamental region construction\n  // which also makes the region face out to the right.\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat segment(vec2 p, vec2 q, vec2 r) {\n  polywind(p,q,r);\n  p -= r; q -= r;\n  float k = dot(p,q)/dot(q,q);\n  k = clamp(k,0.0,1.0);\n  return distance(p,k*q);\n}\n\nfloat ray(vec2 p, vec2 r, vec2 q) {\n  p -= r; q -= r;\n  float k = dot(p,q)/dot(q,q);\n  k = max(k,0.0);\n  return distance(p,k*q);\n}\n\nfloat polydist(float N, vec2 p) {\n    float k = PI/N;\n    float s = cos(k), t = sin(k);\n    float theta = atan(p.y,p.x);\n    if (!key(CHAR_S)) theta = mod(theta+k,2.0*k)-k; \n    // The nearest point in the pattern could be in either of the\n    // two nearest segments, so need to check them both.\n    float r = 0.5*sin(0.5*iTime)+1.0;\n    if (iMouse.x > 0.0) r = 2.0*iMouse.y/iResolution.y;\n    p = length(p)*vec2(cos(theta),sin(theta));\n    vec2 q3 = vec2(r,0);\n    vec2 q0 = rotate(2.0*k)*q3;\n    vec2 q6 = rotate(-2.0*k)*q3;\n    vec2 q1 = vec2(0.75,0);\n    vec2 q4 = rotate(-2.0*k)*q1;\n    vec2 q2 = 0.4*q0;\n    vec2 q5 = 0.4*q3;\n    float d = 1e8;\n    d = min(d,segment(p,q0,q1));\n    d = min(d,segment(p,q1,q2));\n    d = min(d,segment(p,q2,q3));\n    d = min(d,segment(p,q3,q4));\n    d = min(d,segment(p,q4,q5));\n    d = min(d,segment(p,q5,q6));\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = 1.1*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    if (!key(CHAR_R)) p *= rotate(-0.2*iTime);\n    float N = 5.0;\n    if (iMouse.x > 0.0) N = floor(10.0*iMouse.x/iResolution.x)+3.0;\n    float d = polydist(N,p);\n    float px = fwidth(p.x);\n    vec3 col = vec3(0.75+0.25*cos(20.0*PI*d));\n    if ((wind&1) != 0) col.b = 0.0;\n    col = mix(vec3(1,0,0),col,vec3(smoothstep(0.0,px,d-0.005)));\n    if (key(CHAR_X)) {\n      float d = 1e8;\n      d = min(d,ray(p,vec2(0),vec2(cos(PI/N),sin(PI/N))));\n      d = min(d,ray(p,vec2(0),vec2(cos(PI/N),-sin(PI/N))));\n      d = min(d,ray(p,vec2(0),vec2(cos(2.0*PI/N),sin(2.0*PI/N))));\n      d = min(d,ray(p,vec2(0),vec2(cos(2.0*PI/N),-sin(2.0*PI/N))));\n      d = min(d,ray(p,vec2(0),vec2(1,0)));\n      col = mix(vec3(0),col,smoothstep(0.0,px,d-0.0025));\n    }\n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst float PI = 3.141592654;\nmat2 rotate(float t) { return mat2(cos(t),sin(t),-sin(t),cos(t)); }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}