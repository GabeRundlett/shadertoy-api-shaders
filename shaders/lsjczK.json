{
    "Shader": {
        "info": {
            "date": "1492944960",
            "description": "Testing multiple reflections, change ray_bounces_ to produce more or less reflections. Every object acts as a mirror.",
            "flags": 32,
            "hasliked": 0,
            "id": "lsjczK",
            "likes": 8,
            "name": "[ #13 ] - Mirror room",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "reflections",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "Yrai",
            "viewed": 799
        },
        "renderpass": [
            {
                "code": "#define res_ iResolution\n\nvoid mainImage(out vec4 c, in vec2 f) {\n    vec3 pc = texture(iChannel0, f.xy / res_.xy).rgb;\n    \n    pc = pow(pc*1.2, vec3(1.4));\n    c = vec4(pc, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define march_steps_       128\n#define shadow_steps_      40\n#define march_range_       1000.\n#define ray_bounces_       3\n\n#define shadow_perc_       1e-1\n#define dist_perc_         .5\n#define epsilon_           1e-2\n\n#define mouse_x            (iMouse.xy / iResolution.xy).x\n#define mouse_y            (iMouse.xy / iResolution.xy).y\n\n#define mod3_               vec3(.1031, .11369, .13787)\n#define res_                iResolution\n#define time_               iTime\n#define pi_                 3.14159265\n\n#define refraction_index_   .5\n#define fresnel_power_      .5\n\n#define fog_density_        .006\n\n#define ID_BOX              0\n#define ID_SPHERE           1\n#define ID_TORUS            2\n\n\nstruct  t_object      { int id; float d; };\n\nfloat d_cuboid(vec3 p, vec3 s);\nfloat d_torus(vec3 p, float r, float R);\n\nvec2 domain(vec2 uv, float s);\nmat3 rot(vec3 ang);\n\nt_object march(vec3 ro, vec3 rd);\nt_object eval_scene(vec3 p);\nvec3     normal(vec3 p);\n\nvoid  camera(vec2 p, out vec3 ro, out vec3 rd, float or, float oh, vec3 target, float roll, float ll);\nmat3  look_at(vec3 ro, vec3 ta, float roll);\n\n// Shading\nvec3  render(vec2 p, vec3 ro, vec3 rd);\nvec3  pixel_color(vec3 p, vec3 rd, vec3 n, float dis, int mal_id, bool refl);\nvec3  material_builder(vec3 p, vec3 rd, float dis, int id);\nfloat oren_nayar(vec3 l, vec3 rd, vec3 nor, float roughness, float albedo);\nfloat gaussian(vec3 l, vec3 rd, vec3 nor, float shininess);\nfloat fog_exp2(float dist, float density);\nfloat soft_shadow(vec3 ro, vec3 rd);\n\nvec3 hash3_3(vec3 p3);\nfloat perlin_noise3(vec3 p);\n    \n\n// Main \n// ------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n\tvec2 p = domain(fragCoord, 1.);\n    \n    vec3 ro, rd;\n    float t = time_ * .5;\n    vec3 target = 110.*vec3(cos(t)*sin(t), sin(t)*sin(t), cos(t));\n    camera(p, ro, rd, 145.5, 95., target, 0., 1.5);\n    \n    vec3 col = render(p, ro, rd);\n    \n    fragColor = vec4(col, 1.);\n}\n// ------------------------------------------------------\n\n\nt_object eval_scene(vec3 p) {\n    float t = time_ * .5;\n    \n    float bo = -d_cuboid(p - vec3(0., 150., 0.), vec3(150.));\n    vec3 path = 110.*vec3(cos(t)*sin(t), sin(t)*sin(t), cos(t));\n\tfloat sp = length(p - vec3(0., 30., 0.) - path)-30.;\n    p -=  vec3(0., 100., 0.);\n    float tr = d_torus(p * rot(vec3(2.*time_, time_, 0.)), 10., 80.);\n    \n    const int scene_size = 3;\n    float objs[scene_size];\n    objs[0] = bo;\n    objs[1] = sp;\n    objs[2] = tr;\n    \n    float d = objs[0]; int id=0;\n    for(int i = 0; i < scene_size; i++) {\n        if(objs[i] < d) {\n            d = objs[i];\n        \tid = i;\n        }\n    }\n        \n    return t_object(id, d);\n}\n\nvec3 material_builder(vec3 p, vec3 rd, float dis, int id) {    \n    if(id == ID_BOX) {\n        vec3 col = vec3(.5, .1, .1);\n        \n        if(p.y >= 0. && p.y <= 0.1)\n            col = vec3(0.2);\n        if(p.x >= -150. && p.x <= -149.9)\n            col = vec3(1.4, 1.4, 1.);\n        if(p.x >= 149.9 && p.x <= 150.)\n            col = vec3(1., 1.4, 1.);\n        if(p.z >= 149.9 && p.z <= 150.)\n            col = vec3(1., 1., 1.4);\n        if(p.z >= -150. && p.z <= -149.9)\n            col = vec3(1.4, 1., 1.);\n            \n        return col;\n    }\n    else if(id == ID_SPHERE) {\n    \tvec3 col = vec3(1.);\n        \n        return col;\n    }\n    else if(id == ID_TORUS) {\n    \tvec3 col = vec3(1.);\n        \n        return col;\n    }\n}\n\nvec3 render(vec2 p, vec3 ro, vec3 rd) {\n    vec3 pc = vec3(0.);\n  \tvec3 ro_ = ro;\n    vec3 rd_ = rd;\n    vec3 pos_ = vec3(0.);\n    vec3 nor_ = vec3(0.);\n    t_object obj;\n    for(int i = 0; i < ray_bounces_; i++) {\n        obj = march(ro_, rd_);\n        pos_ = ro_ + obj.d * rd_;\n        nor_ = normal(pos_);\n        float fresnel = .5;\n        if(i > 0)\n            fresnel = pow(max(0., 1. + dot(rd_, nor_)), fresnel_power_);\n        \n        if(obj.d > march_range_)\n            break;\n        \n       \tif(obj.id == ID_BOX)\n            pc = mix(pc, pixel_color(pos_, rd_, nor_, obj.d, ID_BOX, false), fresnel);\n        else if(obj.id == ID_SPHERE)\n            pc = mix(pc, pixel_color(pos_, rd_, nor_, obj.d, ID_SPHERE, false), fresnel);\n     \telse if(obj.id == ID_TORUS)\n            pc = mix(pc, pixel_color(pos_, rd_, nor_, obj.d, ID_TORUS, false), fresnel);\n                    \n        rd_ = reflect(rd_, nor_);\n        ro_ = pos_ + rd_ * .02;\n    }\n    \n    return pc;\n}\n\nvec3 pixel_color(vec3 p, vec3 rd, vec3 n, float dis, int mal_id, bool refl) {\n    vec3 l   = normalize(vec3(0.345));\n   \n    vec3 lin = vec3(0.1);\n  \tvec3 brigh = vec3(.1);\n    vec3 mal = material_builder(p, rd, dis, mal_id);\n    \n    float al = 0.05;\n    float spec = gaussian(l, rd, n, 11.1);\n    float diff = max(0., oren_nayar(l, rd, n, 1., 5.) );\n    float refll = 2.*max(0., 1. + dot( reflect(rd, n), n)); \n    float sha = soft_shadow(p + shadow_perc_ * n, l);\n\t\n    lin  += (spec + diff + al + refll) * brigh * sha;\n    \n    vec3 col = mal * lin;\n    \n    return col;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(epsilon_, 0.0);\n    return normalize(vec3(\n        eval_scene(p+e.xyy).d-eval_scene(p-e.xyy).d,\n        eval_scene(p+e.yxy).d-eval_scene(p-e.yxy).d,\n        eval_scene(p+e.yyx).d-eval_scene(p-e.yyx).d\n    ));\n}\n\nt_object march(vec3 ro, vec3 rd) {\n\tfloat d = 1.;\n    float curd = 0.;\n    int id;\n    \n    t_object obj;\n    for(int i=0; i < march_steps_; i++) {\n        if(d < epsilon_ || curd > march_range_) break;\n        obj = eval_scene(ro + curd*rd);\n        d = obj.d*dist_perc_;\n        curd += d;\n    }\n    \n    obj.d = curd;\n    return obj;\n}\n\n// Camera\n// ----------------------------------------------------------------------------------------------------------------------------------\nvoid camera(\n    vec2 p, out vec3 ro, out vec3 rd, float or,\n    float oh, vec3 target, float roll, float ll\n)\n{\n    float mx = 10. * mouse_x;\n    float my = 50. * mouse_y;\n    ro = vec3(or * sin(mx), max(0., oh + my), or * cos(mx));\n    \n    mat3 lam = look_at(ro, target, roll);    \n\trd = normalize(lam * vec3(p.xy, ll)); \n}\n\nmat3 look_at(vec3 ro, vec3 ta, float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Lighting, color calculations\n// ----------------------------------------------------------------------------------------------------------------------------------\nfloat oren_nayar(vec3 l, vec3 rd, vec3 nor, float roughness, float albedo) {  \n  float ldrd = dot(l, rd);\n  float nordl = dot(l, nor);\n  float nordrd = dot(nor, rd);\n\n  float s = ldrd - nordl * nordrd;\n  float t = mix(1., max(nordl, nordrd), step(0., s));\n\n  float sigma2 = roughness * roughness;\n  float a = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\n  float b = .45 * sigma2 / (sigma2 + .09);\n\n  return albedo * max(.0, nordl) * (a + b * s / t) / pi_;\n}\n\nfloat gaussian(vec3 l, vec3 rd, vec3 nor, float shininess) {\n  vec3 h = normalize(l + rd);\n  float theta = acos(dot(h, nor));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\nfloat fog_exp2(float dist, float dens) {\n  const float log2v = -1.442695;\n  float d = dens * dist;\n  return 1. - clamp(exp2(d * d * log2v), 0., 1.);\n}\n\nfloat soft_shadow(vec3 ro, vec3 rd) {\n    float res = 1.;\n    float t = .0001;                     \n\tfloat h = 1.;\n    for(int i = 0; i < shadow_steps_; i++) {         \n        h = eval_scene(ro + rd*t).d;\n        res = min(res, 4.*h/t);          \n\t\tt += clamp(h, .02, 1.);          \n    }\n    return clamp(res, 0., 1.);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Domain transformations\n// ----------------------------------------------------------------------------------------------------------------------------------\nvec2 domain(vec2 uv, float s) {\n    return (2.*uv.xy-res_.xy) / res_.y*s;\n}\n\nmat3 rot(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Noise\n// ----------------------------------------------------------------------------------------------------------------------------------\nvec3 hash3_3(vec3 p3) {\n\tp3 = fract(p3 * mod3_);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n}\n\n\nfloat perlin_noise3(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3. - 2. * pf);\n    \n    return \tmix(\n    \tmix(\n            mix(\n                dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),\n                w.x),\n    \tw.z),\n        mix(\n            mix(\n                dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),\n                w.x),\n     \tw.z),\n\tw.y);\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n\n\n// Primitives\n// ----------------------------------------------------------------------------------------------------------------------------------\nfloat d_cuboid(vec3 p, vec3 s) {\n  vec3 d = abs(p) - s;\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));   \n}\n\nfloat d_torus(vec3 p, float r, float R) {\n    return length(vec2(R - length(p.xz), p.y)) - r;\n}\n// ----------------------------------------------------------------------------------------------------------------------------------",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}