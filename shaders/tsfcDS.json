{
    "Shader": {
        "info": {
            "date": "1585522826",
            "description": "A graph sorting acceleration structure designed to work efficiently with ray marching and physics, has a O(1) complexity for physics and marching(assuming previous closest object is known). From unsorted the sorting speed is O(Nlog(N)), dynamically O(N).",
            "flags": 32,
            "hasliked": 0,
            "id": "tsfcDS",
            "likes": 4,
            "name": "Dynamic graph accel-structure",
            "published": 3,
            "tags": [
                "marching",
                "particles",
                "objects"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 412
        },
        "renderpass": [
            {
                "code": "//Graph is in Buf A, graph traversal is in Buf B\n//You can pause the simulation by setting dt in Common to 0.\n//Change the number of particles by changing N in Common\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nlinks getGraphLinks(int id, int R)\n{ \n    links L;\n    for(int j = 0; j < linkN/4; j++)\n    {\n        vec4 side0 = texel(ch0, i2xy(ivec3(id, j, 1)));\n        for(int i = j*4; i < j*4 + 4; i++)\n        {\n            L.ids[i] = int(side0[i%4]);\n        }   \n    }\n    return L;\n}\n\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat getNd(vec2 p, int id)\n{\n    float d = 1e10;\n    vec4 pp = getParticlePos(id);\n    links nb = getGraphLinks(id, 0);\n    for(int i = 0; i<12; i++)\n    {\n        if(nb.ids[i] >= 0) d = min(d, sdSegment(p, getParticlePos(nb.ids[i]).xy, pp.xy));\n    }\n    return d;\n}\n\nfloat getGraph(vec2 p)\n{\n    float d = 1e10;\n   \n    \td = min(d, getNd(p, (iFrame/30)%tot_n));\n\treturn gauss(d, 1.);\n}\n\nvec2 findPath(vec2 p, vec2 pos, int initguess)\n{\n    int cid = initguess; //closest id\n    vec2 cxy = getParticlePos(cid).xy;\n    float cd = distance(p,cxy); //best distance\n    float d = 1e10;\n    for(int i = 0; i < 30; i++) \n    {\n        int prev_best = cid;\n        vec2 prev_p = cxy;\n        links nb = getGraphLinks(cid, 0);\n        for(int i = 0; i < linkN; i++)\n        {\n            if(nb.ids[i]<0) continue;\n            vec2 pp = getParticlePos(nb.ids[i]).xy;\n            float td = distance(p, pp);\n            if(td < cd) \n            {\n                cd = td;\n                cxy = pp;\n                cid = nb.ids[i];\n            }\n        }\n        d = min(d, sdSegment(pos, prev_p, cxy));\n        if(cid == prev_best) break; //found closest(or impossible to find a better one)\n    }\n    \n    return vec2(gauss(d, 1.), cid);\n}\n\nfloat bisectd(vec2 p, vec2 a, vec2 b)\n{\n    float dd = distance(b,a);\n    return dot(p - a, b - a)/dd - dd*0.5;\n}\n\nfloat bdist(vec2 p, int id)\n{\n    links nbl = getGraphLinks(id, 0);\n    vec2 p0 = getParticlePos(id).xy;\n    float d = 1e10;\n    for(int j = 0; j <8; j++)\n    {\n        if(nbl.ids[j]<0) continue;\n        vec2 pp = getParticlePos(nbl.ids[j]).xy;\n       \td = min(d, bisectd(p, pp, p0));\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    //float gd = getGraph(pos);\n    vec2 path = findPath(iMouse.xy, pos, 0);\n    float e = max(bdist(pos, int(path.y)), 0.);\n    fragColor = sin(0.3*vec4(1,2,3,4)*(e + path.x)) + texel(ch1, pos).zzzz;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(8,8)\n#define sN ivec2(3,2)\n#define dt 0.2\n\n#define loop(x) for(int i = min(0, iFrame); i < x; i++)\n\nconst int tot_n = N.x*N.y;\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nfloat F(float d)\n{\n    return 1./(0.1*d*d+1.) - 1.*exp(-1.*d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst int k = 1664525;  \n\nivec4 hash( ivec4 x )\n{\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    x = ((x>>8)^x.wxyz)*k;\n    return ivec4(x);\n}\n\n#define linkN 12\n\nstruct links\n{\n    int ids[linkN];\n};",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//particle and particle neighbor directional graph buffer \n\nmat4 getParticle(int id);\nvec4 getParticlePos(int id);\nlinks getGraphLinks(int id, int R)\n{ \n    links L;\n    for(int j = 0; j < linkN/4; j++)\n    {\n        vec4 side0 = texel(ch0, i2xy(ivec3(id, j, 1)));\n        for(int i = j*4; i < j*4 + 4; i++)\n        {\n            L.ids[i] = int(side0[i%4]);\n        }   \n    }\n    return L;\n}\nvec4 save(in mat4 data, int i);\nmat4 data; vec4 d; vec4 ppos; int ID;\nfloat avgR; \nfloat dist2p(vec2 p, int id);\nvoid sort(int idtemp, int R);\nvoid sortlinks(in links nb, int R);\nvoid sortneighbors(int id, int R);\nvoid sortrandom(int id, int R);\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n    \n    ivec3 sid = xy2i(p);\n    ID = sid.x;\n   \tif(sid.z == 0) //particle computation\n    {\n        data = getParticle(ID);\n \n        vec2 F = vec2(0,-0.003);\n\n        data[0].zw += F*dt;\n        data[0].xy += data[0].zw*dt;\n\n        //border conditions\n        if(size.x - data[0].x < 2.) data[0].z = -abs(data[0].z);\n        if(data[0].x < 2.) data[0].z = abs(data[0].z);\n        if(size.y - data[0].y < 2.) data[0].w = -abs(data[0].w);\n        if(data[0].y < 2.) data[0].w = abs(data[0].w);\n        \n        if(iFrame<1) //initial condition\n        {\n            data[0].xy = size*hash22(pos);\n            data[0].zw = 2.*(hash22(PI*pos) - 0.5);\n        } \n    }\n    else //graph computation\n    {\n        ppos = getParticlePos(ID);\n        \n        d = vec4(1e6);\n        data = mat4(vec4(-1),vec4(-1),vec4(-1),vec4(-1));\n        \n        links nb = getGraphLinks(ID, sid.y);\n        \n        avgR = 0.; float NN = 0.;\n        for(int i = min(0,iFrame); i < 8; i++)\n        {\t\n            if(nb.ids[i] >= 0) \n            {\n                NN++;\n        \t\tavgR += dist2p(ppos.xy, nb.ids[i]);    \n            }\n        }\n        avgR /= NN;\n        \n        sortlinks(nb, sid.y);\n        \n        for(int i = min(0,iFrame); i < linkN; i++)\n        \tsortneighbors(nb.ids[i], sid.y);\n        \n        sortrandom(sid.x, sid.y);\n    }\n    U = save(data, sid.y);\n}\n\nmat4 getParticle(int id)\n{\n    mat4 da;\n    for(int i = 0; i < sN.x; i++) da[i] = texel(ch0, i2xy(ivec3(id, i, 0))); \n    return da;\n}\n\nvec4 save(in mat4 da, int i)\n{\n    return da[i];\n}\n\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat dist2p(vec2 p, int id)\n{\n    return distance(getParticlePos(id).xy,p);\n}\n\nvoid sort(int idtemp, int R) //sort closest particles in 8 directions\n{\n    if(idtemp == ID || idtemp < 0 || any(equal(data[R], vec4(idtemp)))) return; //particle already sorted\n    vec4 px = getParticlePos(idtemp);\n    vec4 dx = px - ppos;\n    \n    if(R < 2) //closest\n    {\n        int dir = int(4.*((atan(dx.y, dx.x)+PI)/PI)); \n        int diri = dir%4;\n        int dirR = dir/4;\n        float nd = length(dx.xy);\n        if(dirR == R && nd < d[diri])\n        {\n            d[diri] = nd;\n            data[R][diri] = float(idtemp);\n        }\n    } \n    else // far particles\n    {\n        int dir = int(2.*((atan(dx.y, dx.x)+PI)/PI)); \n        int diri = dir%4;\n        int dirR = R;\n        float nd = abs(length(dx.xy) - exp2(float(R))*2.*avgR);\n        if(dirR == R && nd < d[diri])\n        {\n            d[diri] = nd;\n            data[R][diri] = float(idtemp);\n        }\n    }\n    \n  \n}\n\nvoid sortlinks(in links nb, int R)\n{\n    for(int i = min(0, iFrame); i<linkN; i++) sort(nb.ids[i], R);\n}\n\nvoid sortneighbors(int id, int R)\n{\n    links nb = getGraphLinks(id, R);\n    sortlinks(nb, R);\n}\n\nvoid sortrandom(int id, int R)\n{\n    for(int i = 0; i<12; i++) sort((12*iFrame+ID+i)%tot_n, R);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//prev closest particle buffer\n\nlinks getGraphLinks(int id, int R)\n{ \n    links L;\n    for(int j = 0; j < linkN/4; j++)\n    {\n        vec4 side0 = texel(ch0, i2xy(ivec3(id, j, 1)));\n        for(int i = j*4; i < j*4 + 4; i++)\n        {\n            L.ids[i] = int(side0[i%4]);\n        }   \n    }\n    return L;\n}\nvec4 getParticlePos(int id)\n{ \n    return texel(ch0, i2xy(ivec3(id, 0, 0)));\n}\n\nfloat distanceTC(vec2 a, vec2 b)\n{\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nvec3 findClosestObj(vec2 p, int initguess)\n{\n    ivec4 cid = ivec4(initguess, ivec3(-1)); //closest id\n    vec2 cxy = getParticlePos(cid.x).xy;\n    vec4 cd = vec4(distance(p,cxy), vec3(1e10)); //best distance\n    bool found = false;\n    links nb;\n    for(int i = 0; i < 12; i++) \n    {\n        int prev_best = cid.x;\n        vec2 prev_p = cxy;\n        nb = getGraphLinks(cid.x, 0);\n        float safeR = 1e10; //safe radius - if point is inside of it - definitely closest\n        for(int i = 0; i < linkN; i++)\n        {\n            if(nb.ids[i]<0) continue;\n            vec2 pp = getParticlePos(nb.ids[i]).xy;\n            float td = distance(p, pp);\n           \tfloat sR = 0.5*distance(prev_p, pp);\n            if(safeR > sR) safeR = sR;\n            if(td < cd.x) \n            {\n                cd = vec4(td, cd.xyz);\n                cxy = pp;\n                cid = ivec4(nb.ids[i], cid.xyz);\n            }\n            else if(td < cd.y)\n            {\n                cd.yzw = vec3(td, cd.yz);\n                cid.yzw = ivec3(nb.ids[i], cid.yz);\n            }\n            else if(td < cd.z)\n            {\n                cd.zw = vec2(td, cd.z);\n                cid.zw = ivec2(nb.ids[i], cid.z);\n            }\n            else if(td < cd.w)\n            {\n                cd.w = td;\n                cid.w = nb.ids[i];\n            }\n        }\n        //found closest(or impossible to find a better one)\n        if(cid.x == prev_best) \n        {\n            if(cd.x < safeR) found = true;\n            break;\n        }    \n    }\n    \n    if(!found)\n    //check second best\n    for(int j = 1; j < 4; j++)\n    {\n        nb = getGraphLinks(cid[j], 0);\n        for(int i = 0; i < linkN; i++)\n        {\n            if(nb.ids[i]<0) continue;\n            vec2 pp = getParticlePos(nb.ids[i]).xy;\n            float td = distance(p, pp);\n            if(td < cd.x) \n            {\n                cd.x = td;\n                cxy = pp;\n                cid.x = nb.ids[i];\n            }\n        }\n    }\n   \n    return vec3(cxy, cid.x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    int cid = 0;//int(texel(ch1, pos).x); //use prev data - makes it super fast\n    if(iFrame < 1) cid =0;\n    vec3 co = findClosestObj(pos, cid);\n    U.x = co.z;\n    U.y = distance(pos,co.xy);\n    U.z = exp(-0.03*U.y);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}