{
    "Shader": {
        "info": {
            "date": "1514357920",
            "description": "Experimenting with this rendering algorithm, in at attempt to get perfectly antialiased pixels without performing any supersampling. The point being, it should look smooth and [b]also[/b] run fast in all machines. I hope!",
            "flags": 0,
            "hasliked": 0,
            "id": "4tjBRz",
            "likes": 106,
            "name": "Shiny spheres",
            "published": 3,
            "tags": [
                "3d",
                "antialiasing",
                "spheres",
                "filtering",
                "analytiv"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 6618
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2017 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Experimenting with this rendering algorithm, in at attempt to get perfectly antialiased\n// pixels without performing any supersampling.\n//\n// Key ingredients are:\n// 1. analytical sphere to pixel overlap\n//    https://iquilezles.org/articles/spherefunctions\n// 2. analytical surface pattern filtering (ray differentials needed)\n//    https://iquilezles.org/articles/morecheckerfiltering\n// 3. approximate soft shadows with a single ray\n//    https://iquilezles.org/articles/sphereshadow\n\n\n// Algorithm (for eaxh pixel):\n//\n// 1. interesect objects, and record pixel coverage into a list\n// 2. sort list front to back\n// 3. while list contains objects:\n// 4.    shade (with ray differentials for AA)\n// 5.    composite (front to back) \n// 6.    early exit if opaque threshold reached\n// 7. composite with background\n\n\n//-------------------------------------------------------------------------------------------\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n            \nvec2 sphDistances( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.0)) );\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float s = 1.0;\n    vec2 r = sphDistances( ro, rd, sph );\n    if( r.y>0.0 )\n        s = max(r.x,0.0)/r.y;\n    return s;\n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0.0, 1.0 );\n\n}\n\n//-------------------------------------------------------------------------------------------\n#define NUMSPHERES 30\n\nvec4 sphere[NUMSPHERES];\nfloat sphereF[NUMSPHERES];\nfloat vol;\n\n//-------------------------------------------------------------------------------------------\n\nfloat linesTextureGradBox( in float p, in float ddx, in float ddy, int id )\n{\n    float N = float( 2 + 7*((id>>1)&3) );\n\n    float w = max(abs(ddx), abs(ddy)) + 0.01;\n    float a = p + 0.5*w;                        \n    float b = p - 0.5*w;           \n    return 1.0 - (floor(a)+min(fract(a)*N,1.0)-\n                  floor(b)-min(fract(b)*N,1.0))/(N*w);\n}\n\nfloat computeU( in vec3 pos, in vec4 sph, int id )\n{\n    #if 1\n    vec3 q = normalize( pos - sph.xyz );\n    float a = ((id&1)==1) ? acos(q.y) : atan(q.x,q.z);\n    return 6.0*(3.0/3.141593) * a;\n    #else\n    float a = (pos-sph.xyz)[id&1]/sph.w; \n    a += abs(a*a)*sign(a);\n    return 5.0*(3.0/3.141593) * a;\n    #endif\n}\n\nvec4 shade( in vec3 rd, in vec3 pos, in vec3 ddx_pos, in vec3 ddy_pos, \n            in vec3 nor, in int id, in vec4 sph )\n{\n    // compute UVs and filter shape\n    \n\tfloat u     = computeU(     pos, sph, id );\n    float ddx_u = computeU( ddx_pos, sph, id );\n    float ddy_u = computeU( ddy_pos, sph, id );\n\n    // texture\n\tvec3 col = vec3(0.0, 0.2 + 0.4*clamp(1.0-sph.w*2.0,0.0,2.0),0.8);\n    col *= 1.0 - linesTextureGradBox( u, ddx_u-u, ddy_u-u, id );\n\tcol *= sphereF[id];\n    \n    // lighting\n    \n    vec3 ref = reflect(rd,normalize(nor-0.2*rd)); //vec3 ref = reflect(rd,nor);\n\n\t// compute reflection shadow, ambient occlusion and edge proximty\n    float sha = 1.0;\n\tfloat occ = 1.0;\n\tfloat pro = 1e10;\n\tfor( int i=0; i<NUMSPHERES; i++ )\n    {\n        if( i!=id )\n        {\n        sha = min( sha, 10.0*sphSoftShadow(pos+0.005*nor,ref,sphere[i]) );\n        pro = min( pro, abs(length(pos-sphere[i].xyz)-sphere[i].w) );\n      //occ = min( occ, 1.0 - sphOcclusion( pos, nor, sphere[i] ) );\n\t    occ *= 1.0 - sphOcclusion( pos, nor, sphere[i] ); \n        }\n\t}\n\n    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n    occ = occ*0.5 + 0.5*occ*occ;\n    \n\t// light-surface interaction\n    vec3 lig = vec3(occ)*1.4;\n    lig *= 0.7 + 0.3*nor.y;\n    lig += 0.5*fre*fre*occ;\n    lig *= col;\n    lig += 1.2*smoothstep(-0.1,0.10,ref.y )*occ*sha * (0.03+0.97*pow(fre,4.0));\n\n    // glow\n\tfloat g = clamp(pro/(1.0+15.0*vol),0.0,0.5*sph.w);\n    lig += (0.2+0.8*vol)*vec3(0.5*vol,0.4+0.4*vol,1.0)*exp(-15000.0*g*g*20.0);\n    lig += (0.1+0.9*vol)*vec3(0.0,0.50,1.0)*exp(-2000.0*g*g*20.0);\n\n    return vec4(lig,1.0);\n}    \n\nvec4 render( in vec3 ro, in vec3 rd, in float px,\n             in vec3 ddx_ro, in vec3 ddy_ro, \n             in vec3 ddx_rd, in vec3 ddy_rd)\n{\n    vec3 tao[NUMSPHERES];\n    \n    // intersect spheres\n    int num = 0;\n\tfor( int i=0; i<NUMSPHERES; i++ )\n\t{\n\t\tvec4 sph = sphere[i];\n        vec2 dt = sphDistances( ro, rd, sph );\n        float d = dt.x;\n\t    float t = dt.y;\n        //if( t<0.0 ) continue; // skip stuff behind camera\n        \n        float s = max( 0.0, d/t );\n        if( s < px ) // intersection, or close enough to an intersection\n        {\n            tao[num].x = t;                         // depth\n            tao[num].y = 1.0 - clamp(s/px,0.0,1.0); // pixel coverage\n            tao[num].z = float(i);                  // object id\n            num++;\n        }\n\t}\n    \n    if( num==0 ) return vec4(0.0);\n\n    // (bubble) sort intersections, front to back\n\tfor( int i=0; i<num-1; i++ )\n    for( int j=i+1; j<num; j++ )\n    {\n        if( tao[j].x < tao[i].x )\n        {\n            vec3 tm = tao[i];\n            tao[i] = tao[j];\n            tao[j] = tm;\n        }\n\t}\n    \n    // front to back composite to minimize shading cost\n    vec4 col = vec4(0.0,0.0,0.0,0.0);\n    float ot = tao[0].x;\n\tfor( int i=0; i<num; i++ )\n    {\n        float t   = tao[i].x;\n        float al  = tao[i].y;\n        float fid = tao[i].z;\n        int   iid = int(fid);\n\n        /*\n        if( i+1<num )\n        {\n        \tal *= clamp( 0.5 + 0.5*(tao[i+1].x-t)/(px*2.0*t), 0.0, 1.0 );\n        }\n        */\n        \n        vec4 sph = sphere[iid];\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph );\n\n        // compute ray differentials\n        vec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n        vec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n        // shade\n        vec4 tmpcol = shade( rd, pos, ddx_pos, ddy_pos, nor, iid, sph );\n\n        // multiply transparency by coverage\n        tmpcol.a *= al; \n\t\t\n        // composite\n        col.xyz = (1.0-col.w)*tmpcol.w*tmpcol.xyz + col.xyz;\n\t    col.w   = 1.0 - (1.0-tmpcol.w)*(1.0-col.w);  //col.w = col.w + tmpcol.w - tmpcol.w*col.w;\n\n        // early exit on opaque surfaces\n        if( col.a>0.999 ) break;\n    }\n\n    return col;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n    float an = 0.05*iTime;\n\n\tro = vec3(2.5*sin(an),1.0*cos(0.5*an),2.5*cos(an));\n    ta = vec3(0.0,0.0,0.0);\n}\n\n\nvoid calcRayForPixel( in vec2 pix, in float fl, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (2.0*pix-iResolution.xy) / iResolution.y;\n\t\n    // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*158.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n    vol = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        float v = texelFetch( iChannel0, ivec2(i*16,1), 0 ).x-0.5;\n        vol += v*v;\n    }\n    vol/=16.0;\n    vol = vol*8.0;\n    for( int i=0; i<NUMSPHERES; i++ )\n\t{\n\t\tfloat id  = float(i);\n        float ra = pow(id/float(NUMSPHERES-1),8.0);\n\t    vec3  pos = cos( 6.2831*hash3(id*14.0) + 0.5*(1.0-0.7*ra)*hash3(id*7.0)*iTime*0.15 );\n        //vec3  pos = cos( id*11.0 + 7.0*sin(id*17.0+vec3(0,2.0-id,4.0+id)) + iTime*0.05*(1.0-0.7*ra) );\n        \n        pos = normalize(pos) * vec3(1.3,1.0,1.3);\n        pos *= 1.2-0.8*ra;\n        \n        float f = 1.0-ra;//float(i)/float(NUMSPHERES);\n        float a = (0.2+0.8*f)*textureLod( iChannel0, vec2(0.5*f,0.5/2.0), 0.0 ).x;\n\n        sphere[i] = vec4( pos, 1.2*(0.3+0.7*ra) );\n        sphereF[i] = 0.0 + 2.0*a;\n        sphere[i].w *= 0.8 + 0.55*a;\n        sphere[i].xyz *= 1.0 + 0.2*a*(1.0-0.5*ra);\n    }\n\t\t\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    const float fl = 1.8;\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), fl, ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), fl, ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), fl, ddy_ro, ddy_rd );\n\n    float px = (2.0/iResolution.y)*(1.0/fl);\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n    // background\n\tvec3 col = vec3(0.02) + 0.02*rd.y + 0.1*smoothstep(-0.1,0.3,rd.y);\n    \n    // spheres\n    vec4 res = render( ro, rd, px, ddx_ro, ddy_ro, ddx_rd, ddy_rd );\n    col = col*(1.0-res.w) + res.xyz;\n\n    //-----------------------------------------------------\n\t// postpro\n    //-----------------------------------------------------\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    // vignetting    \n    col *= 0.25 + 0.75*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    // dithering\n    col += (1.0/255.0)*hash3(q.x+13.0*q.y);\n    \n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}