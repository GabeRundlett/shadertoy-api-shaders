{
    "Shader": {
        "info": {
            "date": "1478093421",
            "description": "Beginner raymarching blob study during codevember 2016",
            "flags": 0,
            "hasliked": 0,
            "id": "ltcSzH",
            "likes": 7,
            "name": "Beginner blob study",
            "published": 3,
            "tags": [
                "raymarching",
                "beginner",
                "blob",
                "codevember"
            ],
            "usePreview": 0,
            "username": "xorxor",
            "viewed": 874
        },
        "renderpass": [
            {
                "code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n// \n// Thanks to iq's articles\n// https://iquilezles.org/articles/distfunctions\n// and the Raymarching - Primitives sample\n// https://www.shadertoy.com/view/Xds3zN\n\nconst int kNumSpheres = 20;\n\nfloat hash1( float n )\n{\n\treturn fract( sin( n ) * 4121.15393 );\n}\n\nvec3 hash3( float n )\n{\n\treturn fract( sin( vec3( n, n + 1.0, n + 2.0 ) ) *\n\t\t\tvec3( 13.5453123, 31.1459123, 37.3490423 ) );\n}\n\nfloat sphere( vec3 p, float r )\n{\n\treturn length( p ) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 *( b - a ) / k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat sdf( vec3 p )\n{\n\tfloat d = 99999.0;\n\tvec3 t = vec3( 12923.73 + iTime );\n\tfor ( int i = 0; i < kNumSpheres; i++ )\n\t{\n\t\tvec3 ps = vec3( 3.0 ) * cos( t * hash3( float( i ) ) );\n\t\tfloat ds = sphere( p - ps, mix( 0.7, 1.1, hash1( float( i ) ) ) );\n\t\td = smin( d, ds, 0.85 );\n\t}\n\treturn d;\n}\n\nfloat castRay( vec3 ro, vec3 rd )\n{\n\tfloat t = 0.0;\n\tvec3 p;\n\n\tfor ( int i = 0; i < 50; i++ )\n\t{\n\t\tp = ro + rd * t;\n\t\tfloat d = sdf( p );\n\t\tif ( d < 0.01 )\n\t\t{\n\t\t\treturn t;\n\t\t}\n\t\tt += d;\n\t}\n\n\treturn -1.0;\n}\n\nvec3 calcNormal( vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 n = vec3(\n\t\t\tsdf( pos + eps.xyy ) - sdf( pos - eps.xyy ),\n\t\t\tsdf( pos + eps.yxy ) - sdf( pos - eps.yxy ),\n\t\t\tsdf( pos + eps.yyx ) - sdf( pos - eps.yyx ) );\n\treturn normalize( n );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n\tfor ( int i = 0; i < 32; i++ )\n\t{\n\t\tfloat h = sdf( ro + rd * t );\n\t\tres = min( res, 7.0 * h / t );\n\t\tt += h;\n\t\tif ( ( h < 0.01 ) || ( t > maxt ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nmat3 setCamera( vec3 ro, vec3 ta )\n{\n\tvec3 cw = normalize( ta - ro );\n\tvec3 cu = normalize( cross( cw, vec3( 0, 1, 0 ) ) );\n\tvec3 cv = normalize( cross( cu, cw ) );\n\treturn mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * 0.5 ) / iResolution.y;\n\tvec3 ro = vec3( 19.80, 0.0, -2.82 );\n\tvec3 ta = vec3( 0.0 );\n\tmat3 cm = setCamera( ro, ta );\n\tvec3 rd = cm * normalize( vec3( uv, 3.0 ) );\n\n\tvec3 col = vec3( 0.0 );\n\tfloat t = castRay( ro, rd );\n\tif ( t > 0.0 )\n\t{\n\t\tvec3 pos = ro + rd * t;\n\t\tvec3 n = calcNormal( pos );\n\t\tvec3 ref = reflect( rd, n );\n\n\t\tvec3 ldir = normalize( vec3( -0.5, 2.8, -5.0 ) );\n\t\tfloat dif = max( dot( n, ldir ), 0.0 );\n\t\tfloat spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 32.0 );\n\t\tfloat sh = calcShadow( pos, ldir, 0.1, 8.0 );\n\n\t\tcol += dif * sh * vec3( 0.7 );\n\t\tcol += dif * sh * spe * vec3( 1.0 );\n\t}\n\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}