{
    "Shader": {
        "info": {
            "date": "1618105976",
            "description": "Just a torus with a custom cross-section, which rotates. I wish one could buy candy-bars like this :) You can orbit around the torus with the mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dB3Wd",
            "likes": 13,
            "name": "Twisty chocolate-bar torus",
            "published": 3,
            "tags": [
                "3d",
                "phong",
                "torus",
                "candy",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1313
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Twisty chocolate-bar torus - some version of eye-candy ;)\n//\n// Copyright 2021 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// lower AA_SIZE to 2 or 1, if it runs too slow\nconst int AA_SIZE = 3;\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 64;\nconst float STEP_BIAS = .75;\nconst float EPSILON = .0001;\nconst float MAX_DIST = 25.;\n\nmat2 r2d (float rad)\n{\n    float c = cos (rad);\n    float s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat sdBox2D (vec2 p, vec2 size, float r)\n{\n    vec2 q = abs(p) - size;\n    return length(max(q,0.0)) + min(max(q.x, q.y),0.0) - r;\n}\n\nfloat sdTorus (vec3 p, vec3 q)\n{\n    float offset = q.x;\n    float r1 = q.y;\n    float r2 = q.z;\n\n    float angle = atan (p.x, p.z);\n\n    vec2 t = vec2 (length (p.xz) - r1, p.y);\n\n    t *= r2d (3.*angle);\n    t.y = abs (t.y) - offset;\n\n    float r = r2*(1. + .5*(cos(3.*angle)));\n    t *= r2d (iTime);\n    float doubleRectProfile = sdBox2D (t, vec2 (.08, .03), r*.75);\n\n    return doubleRectProfile;\n}\n\nfloat scene (vec3 p)\n{\n    float ground = p.y + 1.;\n\n    float offset = .2;\n    float r1 = 1.;\n    float r2 = .1;\n    float torus = sdTorus (p, vec3 (offset, r1, r2));\n\n    float d = min (torus, ground); \n\n    return d;\n}\n\nfloat raymarch (vec3 ro, vec3 rd)\n{\n    float t = .0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    int i = 0;\n\n    for (; i < MAX_ITER; ++i) {\n        p = ro + d*rd;\n        t = scene (p);\n        if (abs (t) < EPSILON*(1. - .125*t) || d > MAX_DIST) break;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (EPSILON, .0);\n    float d = scene (p);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - d);\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = camForward*zoom + ro;\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos, vec3 lDir)\n{\n    float distToWorld = raymarch (p + .01*n, lDir);\n    float distToLight = distance (p, lPos);\n\n    return distToWorld < distToLight ? .3 : 1.;\n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 n)\n{\n    vec3 p = ro + d*rd;\n\n    vec3 lPos1 = vec3 (4.*cos(iTime), 2., 4.*sin(.4*iTime));\n    vec3 lDir1 = normalize (lPos1 - p);\n    float lDist1 = distance (lPos1, p);\n    float attn1 = 50. / (lDist1*lDist1);\n    vec3 lColor1 = 5.*vec3 (1., .9, .3);\n\n    vec3 lPos2 = vec3 (6.*cos(.3*iTime), 1., 6.*sin(iTime));\n    vec3 lDir2 = normalize (lPos2 - p);\n    float lDist2 = distance (lPos2, p);\n    float attn2 = 60. / (lDist2*lDist2);\n    vec3 lColor2 = 7.*vec3 (.2, .4, 1.);\n\n    vec3 amb = vec3 (.1); \n    float diff1 = max (dot (n, lDir1), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 h1 = normalize (lDir1 - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec1 = pow (max (dot (h1, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    float s1 = shadow (p, n, lPos1, lDir1);\n    float s2 = shadow (p, n, lPos2, lDir2);\n\n    float ao = ao (p, n, .05, 12, .1);\n\n    // don't do material assignment like this, this is a super lazy-ass hack!\n    vec3 torusMaterial = 1.5*vec3(.2, .1, .05);\n    bool isFloor = (p.y < -.5);\n    float phase = cos (20.*(p.x + iTime));\n    float mask = smoothstep (.005*d, .0025*d, .5 + .5*phase);\n    vec3 floorMaterial = 1.5*mix (vec3(.9), vec3 (.1), mask);\n    vec3 diffMaterial = isFloor ? floorMaterial : torusMaterial;\n\n    return amb + ao*(attn1*s1*(diff1*diffMaterial*lColor1 + spec1) +\n                     attn2*s2*(diff2*diffMaterial*lColor2 + spec2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist2cam = 3.;\n    float azimuthAngle = ((iMouse.x/iResolution.x) * 2. - 1.) * 179.;\n    float elevationAngle = 20. + ((iMouse.y/iResolution.y) * 2. - 1.) * -30.;\n    float x = dist2cam*cos (radians (azimuthAngle));\n    float y = dist2cam*sin (radians (elevationAngle));\n    float z = dist2cam*sin (radians (azimuthAngle));\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3 (x, y, z);\n\tfloat fog = .0;\n\tfloat d = .0;\n\tvec3 aim = vec3 (.0);\n\tfloat zoom = 2.5;\n    vec3 color = vec3 (.0);\n\n\tfor (int x = 0; x < AA_SIZE; ++x) {\n\t\tfor (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float  (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n\t\t\tuv = (fragCoord.xy/iResolution.xy + pixelOffset/iResolution.xy);\n    \t\tuv = uv*2. - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\tvec3 rd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n\t\t\td = raymarch (ro, rd);\n\t\t\tfog = 1. / (1. + d*d*.075);\n\t\t\tvec3 p = ro + d*rd;\n\t\t\tvec3 n = normal (p);\n\t\t\tvec3 ctmp = shade (ro, rd, d, n);\n\t\t\tctmp *= fog;\n\n\t\t\tcolor += ctmp;\n\t\t}\n\t}\n\tcolor /= float (AA_SIZE*AA_SIZE);\n\n    // distance-mist, vignette, tone-map, gamma-correct\n\tcolor = mix (color, vec3 (.2, .35, .7), pow (1. - 1./d, 90.));\n    color *= 1. - .25*dot (uv, uv);\n    color = color / (1. + color);\n    color = .2*color + .8*sqrt (color);\n\n    fragColor = vec4(color, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}