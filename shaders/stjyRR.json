{
    "Shader": {
        "info": {
            "date": "1652740102",
            "description": "Here's a fan art of the hexcore, a magical machine from the series Arcane on Netflix. Put the sound if you can! (pause/play soundcloud track if not working)",
            "flags": 64,
            "hasliked": 0,
            "id": "stjyRR",
            "likes": 10,
            "name": "Hexcore fanart",
            "published": 3,
            "tags": [
                "hexcorearcaneraymarchraymarching3d"
            ],
            "usePreview": 0,
            "username": "CyrilGhys",
            "viewed": 467
        },
        "renderpass": [
            {
                "code": "// License :\n// 3.2 - https://www.riotgames.com/en/terms-of-service\n//    \"We reserve all the rights to our IP, but do allow for some personal, non-commercial uses, like fan art.\"\n// https://www.riotgames.com/en/legal\n//    \"Cool free stuff for the community to enjoy, with some exceptions.\"\n\n// Reference :\n// https://www.artstation.com/artwork/wJ09bX\n\n// Constants\n#define PI                       3.1415\n#define TWO_PI                   6.283185\n\n// Global parameters\n#define SSAA                     1\n\n// Raymarching parameters\n#define MAX_STEPS                128\n#define MAX_DIST                 5.\n#define SURFACE_DIST             .0001\n\n// ----------------------------------------------- HEXCORE PARAMS ---------------------------------------------\n\nfloat hexcoreBreathingFrequency = 2.;\nfloat hexcoreBreathingAmplitude = .005;\n\nfloat pyramidOffset = .10;\nfloat pyramidScale = 2.5;\nfloat pyramidHeight = .01;\nfloat pyramidCapWidthT;\nfloat pyramidCapHeightT;\nfloat pyramidCapCylinderRadius;\nvec3 pyramidSymbolColour;\nfloat pyramidSymbolScale;\nfloat pyramidVerticalMaskPaddingBottom;\nfloat pyramidVerticalMaskHeight;\nfloat pyramidVerticalMaskFade;\nfloat pyramidHorizontalMaskWidth;\nfloat pyramidHorizontalMaskFade;\n\nfloat pyramidCountPerCircle = 8.;\n\nfloat triangleThickness = .001;\n\nfloat ringsHeight = .004;\nfloat ringsThickness = .006;\nfloat ringOuterSize = .17;\nfloat ringOuterSpeed;\nfloat ringMidSize = .135;\nfloat ringMidSpeed;\nfloat ringInnerSize = .10;\nfloat ringInnerSpeed;\nvec3 ringLinesColour;\n\nfloat orbRadius = .03;\nvec3 orbBaseColour;\nvec3 orbNoiseColour;\nvec3 orbLightColour;\n\n// #D4AF37\nvec3 edgeColour = vec3(.831, .686, .216);\nfloat edgeHatOffset;\nfloat edgeStrength;\n\nfloat breathing;\nfloat hexcoreRadius;\n\nvec3 fxColor;\nfloat uvScale = 30.;\nfloat rotFactor = 0.;\n\nvoid adaptParams(float musicLoudness, float time)\n{\n    // pyramidHeight = mix(.01, .02, musicLoudness);\n    pyramidCapWidthT = mix(.8, 1., musicLoudness);\n    pyramidCapHeightT = mix(.8, 1., musicLoudness);\n    pyramidCapCylinderRadius = mix(.002, 0., musicLoudness);\n    pyramidSymbolColour = mix(vec3(0., .1, .8), vec3(0.494,0.071,0.553), musicLoudness);\n    pyramidSymbolScale = mix(200., 400., musicLoudness);\n    pyramidVerticalMaskPaddingBottom = mix(.01, 0., pow(musicLoudness, 3.));\n    pyramidVerticalMaskHeight = mix(.025, .035, musicLoudness);\n    pyramidVerticalMaskFade = mix(.005, .001, musicLoudness);\n    pyramidHorizontalMaskWidth = mix(.005, .001, musicLoudness);\n    pyramidHorizontalMaskFade = mix(.8, 0., musicLoudness);\n    \n    ringOuterSpeed = mix(.4, 2., musicLoudness);\n    ringMidSpeed = mix(1.5, 5., musicLoudness);\n    ringInnerSpeed = mix(2.5, 10., musicLoudness);\n    ringLinesColour = mix(vec3(0.039,0.067,0.322), vec3(0.318,0.043,0.467), musicLoudness);\n    \n    orbBaseColour = vec3(1,1, 1); //mix(vec3(0.271,0.416,0.761), vec3(0.275,0.020,0.294), musicLoudness);\n    orbNoiseColour = vec3(1,1, 1); //mix(vec3(0.043,0.294,0.957), vec3(0.306,0.059,0.369), musicLoudness);\n    orbLightColour = vec3(1,1, 1); //mix(vec3(.0, .2, .8), vec3(0.353,0.008,0.541), musicLoudness);\n    \n    edgeHatOffset = mix(.028, .035, musicLoudness);\n    edgeStrength = .1 + .9 * (1. - musicLoudness);\n    \n    breathing = sin(time * hexcoreBreathingFrequency) * hexcoreBreathingAmplitude;\n    hexcoreRadius = pyramidOffset + breathing;\n    \n    fxColor = mix( vec3(0.055,0.129,0.439), vec3(0.361,0.106,0.447), musicLoudness );\n}\n\n// ---------------------------------------------------- MUSIC -------------------------------------------------\n\nbool hasMusicStarted = false;\nfloat musicLengthSeconds = 3. * 60. + 33.;\n\n// down : 0.00 - 0.36\n// mid : 0:36 - 1:00\n// down : 1:00 - 1:04 'what could have been'\n// mid : 1:04 - 1:16\n// up : 1:16 - 1:28\n// down : 1:28 - 2:00\n// mid : 2:00 - 2:32\n// up : 2:32 - 3:24\n// down : 3:24 - 3:33\nfloat timings[8] = float[](\n    36.,\n    60.,\n    64.,\n    77.,\n    88.,\n    120.,\n    152.,\n    204.);\nfloat fade = 2.;\n\nfloat musicFunction(float timer)\n{\n    return .5 * smoothstep(timings[0]-fade, timings[0]+fade, timer)\n         - .5 * smoothstep(timings[1]-fade, timings[1]+fade, timer)\n         + .5 * smoothstep(timings[2]-fade, timings[2]+fade, timer)\n         + .5 * smoothstep(timings[3]-fade, timings[3]+fade, timer)\n         - 1. * smoothstep(timings[4]-fade, timings[4]+fade, timer)\n         + .5 * smoothstep(timings[5]-fade, timings[5]+fade, timer)\n         + .5 * smoothstep(timings[6]-fade, timings[6]+fade, timer)\n         - 1. * smoothstep(timings[7]-fade, timings[7]+fade, timer);\n}\n\nfloat musicLoudness;\nfloat musicVelocity;\n\n// I could not figure out a satisfying way to make 'musicLoudness'\n// depends on the actual music (frequency / waveform analysis to get music's 'strength')\n// So, instead, I'm using time to filter what I want\nvoid processMusic(float time)\n{\n    // TEMP: Use time to filter 'strong' parts of the music\n    if ( texture( iChannel0, vec2( 0.01, 0.25 ) ).x > 0.1 && hasMusicStarted == false )\n    {\n        hasMusicStarted = true;\n    }\n    \n    if ( hasMusicStarted )\n    {        \n        float musicTimer = mod(time, musicLengthSeconds);\n        musicLoudness = clamp( musicFunction(musicTimer), 0., 1.);\n        //musicVelocity = clamp( (musicLoudness - musicFunction(musicTimer - 1.)) * 3., -1., 1.);\n    }\n    \n    // TODO: Analyze and filter music's frequencies and/or waveform\n    {\n    // @source https://www.shadertoy.com/view/Xds3Rr\n    //freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n    //freqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n    //freqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n    //freqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    \n    // average music strength for the given Shadertoy interval\n    // (I don't how many last milliseconds)\n    //float median = 0.;\n    //float maxValue = 0.;\n    //float minValue = 0.;\n    //float average = 0.;\n    //float nbSteps = 20.;\n    //for ( float f=0.5; f < 1.; f+=(1./nbSteps) )\n    //{\n    //    //average += texture( iChannel0, vec2( f, 0.75 ) ).x;\n    //    average += texture( iChannel0, vec2( f, 0.75 ) ).x;\n    //    maxValue = max(maxValue, texture( iChannel0, vec2( f, 0.25 ) ).x);\n    //    minValue = min(minValue, texture( iChannel0, vec2( f, 0.25 ) ).x);\n    //}\n    //average /= nbSteps;\n    //median = (maxValue - minValue);\n    \n    //musicLoudness = smoothstep( .4, .42, pow( average/nbSteps, 1.) );\n    }\n}\n\n// ------------------------------------------------ CUSTOM SDFs -----------------------------------------------\n\n// @source https://www.shadertoy.com/view/ltdBR8\nvec4 hexcorePyramid(vec3 p, float sector, float time)\n{\n    p /= pyramidScale;\n    \n    {\n    // Input function to ease rotation, using fract(time) [0,1]\n    //float time01 = pow(fract(time), 2.);\n    \n    // Overshoot ?\n    //float tRatioOvershoot = .1;\n    //float isOvershooting = step(1. - tRatioOvershoot, time01);\n    \n    // (time01 * PI * .5)                                  -> 90 turn = 1 sec\n    // (time01 * PI * .5) * (1. / PYRAMID_TIME_TO_90_TURN) -> 90 turn = PYRAMID_TIME_TO_90_TURN\n    //float rot = \n    //    (time01 * PI * .55) * (1. / (PYRAMID_TIME_TO_90_TURN * (1. - tRatioOvershoot))) * (1. - isOvershooting)\n    //     + (time01 * -PI * .05) * (1. / (PYRAMID_TIME_TO_90_TURN * tRatioOvershoot)) * isOvershooting;\n    \n    // Only one sector at a time\n    //float shouldRotate =\n    //    step(sector + 1., floor( mod(time, 8.) )) \n    //    - step(sector, floor( mod(time, 8.) ));\n    // & only odd ones\n    //shouldRotate *= mod(sector, 2.);\n    // & only the right amount of time\n    //shouldRotate *= step(1. - PYRAMID_TIME_TO_90_TURN, time01);\n    //rot *= shouldRotate;\n    \n    // Rotate it\n    //p.xz = mat2(cos(rot), -sin(rot),\n    //            sin(rot),  cos(rot)) * p.xz;\n    }\n        \n    // Pyramid basis\n    vec2 size = vec2(cos(PI * .25), sin(PI * .25));\n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -size.x, size.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  size.x, size.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0,      size.y, size.x )) ));\n    d = max( d, abs( dot(p, vec3(  0,      size.y,-size.x )) ));\n    float octa = d - pyramidHeight;\n    \n    // Capping box (both corners, peak and bottom)\n    float boxHeight = mix(0., size.x*pyramidHeight, pyramidCapHeightT);\n    float boxWidth =  mix(0., 1./pyramidScale*.05, pyramidCapWidthT);\n    p.xz = mat2(cos(PI * .25), -sin(PI * .25),\n                sin(PI * .25),  cos(PI * .25)) * p.xz;\n    float box = sdBox(p-vec3(0.,boxHeight,0.), vec3(boxWidth, boxHeight, boxWidth));\n    \n    // Details\n    float angle = TWO_PI / 4.;\n    float sec = round(atan(p.z, p.x) / angle);\n    \n    vec3 pointSectorized = p;\n    pointSectorized.xz = mat2(cos(sec * angle), -sin(sec * angle),\n                              sin(sec * angle),  cos(sec * angle)) * p.xz;\n    \n    vec3 q1 = rotate(pointSectorized, 0., 0., PI * .25);\n    float cyl1 = sdCylinder(q1-vec3(.014,.0,.0), pyramidCapCylinderRadius);\n        \n    d = opIntersection(box, octa);\n    d = opSubtraction(cyl1, d);\n    \n    return vec4(d * pyramidScale, p);\n}\n\nvec4 hexcorePyramidsCircle(vec3 p, float index, float time)\n{\n    float angle = TWO_PI / pyramidCountPerCircle;\n    // atan(p.z, p.y)                         -> [-PI, PI]\n    // atan(p.z, p.y) / (TWO_PI / 8)          -> [-4., 4.]\n    // round( atan(p.z, p.y) / (TWO_PI / 8) ) -> [-4][-3][-2][-1][0][1][2][3]\n    float sector = round(atan(p.z, p.y) / angle);\n    \n    vec3 pointSectorized = p;\n    pointSectorized.yz = mat2(cos(sector * angle), -sin(sector * angle),\n                              sin(sector * angle),  cos(sector * angle)) * p.yz;\n    \n    return hexcorePyramid((pointSectorized - vec3(0., hexcoreRadius, 0.)), (sector + pyramidCountPerCircle * .5) + index, time);\n}\n\nvec4 hexcoreTriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{    \n    float triangle = udTriangle(abs(p), a, b, c) - triangleThickness;\n    \n    vec3 average = (a+b+c) * .333;\n    float t = .8;\n    float box = sdBox(abs(p)-average, t*vec3(a.x-average.x, b.y-average.y, c.z-average.z));\n    \n    float d = opIntersection(triangle, box);\n    \n    return vec4(d, p);\n}\n\nvec4 hexcoreRing(vec3 p, float size)\n{\n    // take absolute value so we carve the cylinder\n    float ring = abs(length(p.xz) - size * .5);\n    // cap it, with absolute value, at top and bottom\n    ring = abs(max(ring, abs(p.y) - ringsHeight * .5)) - ringsThickness;\n    \n    return vec4(ring, p);\n}\n\n// ------------------------------------------------- RAYMARCHING ----------------------------------------------\n// returns the distance from point to the closest object in the scene\nvec4 map(vec3 point, float time)\n{    \n    // PYRAMIDS\n    vec4 pyramids1 = hexcorePyramidsCircle(point.xyz, 00., time);\n    vec4 pyramids2 = hexcorePyramidsCircle(point.yzx, 10., time);\n    vec4 pyramids3 = hexcorePyramidsCircle(point.zxy, 20., time);\n    \n    // TRIANGLES\n    vec2 tri = vec2(hexcoreRadius * cos(PI * .14), hexcoreRadius * sin(PI * .14));\n    vec4 triangles = hexcoreTriangle(point, tri.xyy, tri.yxy, tri.yyx);\n    \n    // RING 1\n    vec3 ring1RotatedPoint = rotate(point, TWO_PI * .250, time * ringOuterSpeed, 0.);\n    vec4 ring1 = hexcoreRing(ring1RotatedPoint, ringOuterSize);\n    // RING 2\n    vec3 ring2RotatedPoint = rotate(point, TWO_PI * .125, time * ringMidSpeed, 0.);\n    vec4 ring2 = hexcoreRing(ring2RotatedPoint, ringMidSize);\n    // RING 3\n    vec3 ring3RotatedPoint = rotate(point, TWO_PI * .825, time * ringInnerSpeed, 0.);\n    vec4 ring3 = hexcoreRing(ring3RotatedPoint, ringInnerSize);\n    \n    // ORB\n    vec4 orb = sdSphere(point, orbRadius);\n    \n    vec4 d = orb;\n    \n    // UNIONS\n    vec4 t;\n    t = ring1; if( t.x<d.x ) d=t;\n    t = ring2; if( t.x<d.x ) d=t;\n    t = ring3; if( t.x<d.x ) d=t;\n    t = pyramids1; if( t.x<d.x ) d=t;\n    t = pyramids2; if( t.x<d.x ) d=t;\n    t = pyramids3; if( t.x<d.x ) d=t;\n    t = triangles; if( t.x<d.x ) d=t;\n    \n    return d;\n}\n\n// @source https://youtu.be/bdICU2uvOdU?t=4788\nvec2 iSphere( in vec3 ro, in vec3 rd, vec3 center, float radius )\n{\n    ro -= center;\n    float b = dot(rd, ro);\n    float c = dot2(ro) - radius*radius;\n    float h = b*b - c;\n    if ( h < 0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2( -b-h, -b+h );\n}\n\n// returns the distance from origin to the closest object in the scene\n// will iterate into 'map' function multiple times\n// taking as many safe smallest steps as possible\n// before either : hitting an object ; getting too far away from origin ; getting too many steps\nvec4 intersect(vec3 rayOrigin, vec3 rayDirection, float time)\n{\n    // distance from origin to furthest safe point (if any) ; the one we'll return\n    vec4 res = vec4(-1.0);\n    \n    vec2 vol = iSphere( rayOrigin, rayDirection, vec3(0.), hexcoreRadius+.035 );\n    \n    if ( vol.y>0.0 )\n    {\n        float t = max( vol.x,0.0 );\n        // March as long as we didn't get too many steps, or if we aren't too far away from the scene\n        for (int i=0; i < MAX_STEPS && t < vol.y; i++)\n        {\n            // point = current furthest safe point ; center of the sphere (sphere tracing)\n            vec3 point = rayOrigin + rayDirection * t;\n\n            // distanceToScene = largest safe next distance to march ; radius of the sphere (sphere tracing)\n            vec4 distancePointScene = map(point, time);\n\n            // If we are really close to the object\n            if (distancePointScene.x < SURFACE_DIST)\n            {\n                res = vec4(t, distancePointScene.yzw);\n                break;\n            }\n\n            t += distancePointScene.x;\n        }\n    }\n    \n    return res;\n}\n\n// -------------------------------------------------- LIGHTING ------------------------------------------------\n// @source https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 point, float time)\n{\n#if 0\n    vec2 offset = vec2(1.0,-1.0) * 0.5773 * 0.0005;\n    return normalize( offset.xyy * map( point + offset.xyy ) + \n\t\t\t\t\t  offset.yyx * map( point + offset.yyx ) + \n\t\t\t\t\t  offset.yxy * map( point + offset.yxy ) + \n\t\t\t\t\t  offset.xxx * map( point + offset.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 normal = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 offset = 0.5773 * (2.0 * vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        normal += offset * map(point + 0.0005 * offset, time).x;\n      //if( normal.x + normal.y + normal.z>100.0 ) break;\n    }\n    return normalize(normal);\n#endif    \n}\n\nfloat getAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occlusion = 0.0;\n    float scale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float height = 0.01 + 0.12*float(i)/4.0;\n        float dist = map( pos + height * nor, time ).x;\n\t\t\t\t// as long as we're getting away from a surface\n\t\t\t\t// height - distance will be 0\n        occlusion += (height - dist) * scale ;\n        scale *= 0.95;\n    }\n\t\t// clamp01 the result for precision purpose\n    return clamp( 1.0 - 3.0*occlusion, 0.0, 1.0 );\n}\n\n// @source https://iquilezles.org/articles/rmshadows/\nfloat getSoftShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k, float time )\n{\n    float res = 1.0;\n    \n    vec2 vol = iSphere( ro, rd, vec3(0.), hexcoreRadius+.035 );\n    if ( vol.y>0.0 )\n    {\n        float t = max( .001,vol.x );\n        for( float t=mint; t<maxt; )\n        {\n            float h = map(ro + rd*t, time).x;\n            if( h<SURFACE_DIST )\n                return 0.0;\n            res = min( res, k*h/t );\n            t += h;\n        }\n    }\n    \n    return res;\n}\n\nvec4 getVolumetricLighting( in vec3 normal, float mint, float maxt, float time )\n{\n    float t = .001;\n    vec4 res;\n    for( float t=mint; t<maxt; )\n    {\n        res = map(normal*t, time);\n        if( res.x < SURFACE_DIST )\n            return vec4(0.);\n        t += res.x;\n    }\n    \n    return vec4(t, res.yzw);\n}\n\n// ----------------------------------------------------- MAIN -------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    // if ssaa is on, sample multiple fragment per pixel\n    #if SSAA >1\n    for( int m=0; m<SSAA; m++ )\n    for( int n=0; n<SSAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(SSAA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float dither = .5 + .5 * sin(fragCoord.x*111.0) * sin(fragCoord.y*125.546);\n        float time = iTime - (1./48.)*(float(m+SSAA+n)+dither)/float(SSAA*SSAA);\n        #else    \n        vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n        \n        processMusic(time);\n        adaptParams(musicLoudness, time);\n    \n        // camera\n        float angle = TWO_PI * time / 40.;\n        vec3 turnAxis = vec3( 0.0, 0.0, 0.0 );\n        float rotDistance = .5+.5*musicLoudness;\n        vec3 rayOrigin = turnAxis + vec3( rotDistance*cos(angle), .3+.2*musicLoudness, rotDistance*sin(angle) );\n\n        // camera-to-world transformation\n        mat3 cameraWorldMatrix = setCamera(rayOrigin, turnAxis, 0.0 );\n\n        // ray direction\n        float focalLength = 3.5;\n        vec3 rayDirection = cameraWorldMatrix * normalize(vec3(uv, focalLength));\n        \n        // background\n        vec3 colour = vec3(1.0 + rayDirection.y) * 0.03;\n\n        // raymarch geometry\n        vec4 t = intersect(rayOrigin, rayDirection, time);\n        if (t.x > 0.0)\n        {\n            vec3 pointNearObject = rayOrigin + rayDirection * t.x;\n\n            // --- Normal\n            vec3 normal = getNormal(pointNearObject, time);\n            \n            // --- 'Handpainted' ambient occlusion\n            // occlude everything pointing inwards\n            float fakeOcclusion = \n                0.1+0.9*clamp(0.5 + 0.5 * dot(normal, normalize(pointNearObject)), 0., 1.);\n            // occlude things in a certain radius from origin\n            fakeOcclusion *= 0.1+0.9*clamp(length(pointNearObject) / .1, 0., 1.);\n            \n            // --- Computed ambient occlusion\n            float occlusion = clamp(getAO(pointNearObject, normal, time) * fakeOcclusion, 0., 1.);\n            \n            vec3 specLightPos = vec3(cos(time), 3., sin(time));\n\n            // --- Orb lighting\n            {\n                // Choose the orb only\n                float orbMask = 1. - clamp( step(orbRadius + .01, length(pointNearObject)), 0., 1. );\n                \n                float noise = 0.;\n                vec3 q = 24.0*pointNearObject+time*.2;\n                noise  = 0.5000*valueNoise3D( q ); q = q*2.01;\n                noise += 0.2500*valueNoise3D( q ); q = q*2.02;\n                noise += 0.1250*valueNoise3D( q ); q = q*2.03;\n                noise += 0.0625*valueNoise3D( q ); q = q*2.01;\n                noise = pow(clamp(noise, 0., 1.), 3.) * 1.5;\n                float facing = pow(abs(dot(normal, rayDirection)), 5.) * 2.;\n                \n                float fresnel = clamp( 1. + dot(rayDirection, normal), 0., 1. );\n                fresnel = pow(fresnel, 5.);\n                \n                vec3 reflection = reflect(normalize(specLightPos), normal);\n                float d = 1. - clamp(.5 + .5 * dot(-reflection, rayDirection), 0., 1.);\n                float specular = smoothstep(.94, .98, d);\n                \n                // Light from orb            \n                float facingInwards = clamp(dot(normal, -normalize(pointNearObject)), 0., 1. );\n                                \n                // Lights the orb receive\n                colour += .005*orbBaseColour*orbMask\n                    + noise*orbNoiseColour*facing*orbMask\n                    + 1.5*orbBaseColour*fresnel*orbMask\n                    + specular*orbMask;\n                // Lights from the orb\n                colour += 30.*orbLightColour*facingInwards*occlusion;\n            }\n            \n            // --- Rings lighting\n            {\n                // Choose the rings only\n                float ringsMask = step(ringInnerSize*.5-.007, length(pointNearObject))\n                    - step(ringOuterSize*.5+.007, length(pointNearObject));\n                \n                // Fish-eye lens\n                vec3 t3 = t.yzw;\n                float delta2 = dot(t3.xz, t3.xz);\n                float delta_offset = 1. - delta2 * 100.;\n                t3.xz *= delta_offset + 0.;\n                \n                // Naive voronoi borders\n                vec3 noise = voronoi3D( 48.*t3+2. );\n                float dist = noise.y - noise.x;\n                float smth = 1.0 - smoothstep(0.0, 0.05, dist);\n                    \n                colour += .8*ringLinesColour*smth*ringsMask;\n            }\n            \n            // --- Pyramids\n            {\n                // Rings' shadows projected onto pyramids' inwards\n                float shadow = getSoftShadow(\n                    vec3(0.), \n                    normalize(pointNearObject), \n                    orbRadius + .005,\n                    hexcoreRadius,\n                    128.,\n                    time);\n                shadow = 0.5+0.5*clamp(shadow, 0., 1.);\n                float facingInwards = clamp(dot(normal, -normalize(pointNearObject)), 0., 1. );\n                \n                // Naive voronoi borders\n                vec3 t3 = t.yzw;\n                vec3 noise = voronoi3D( pyramidSymbolScale*t3+8. );\n                float dist = noise.y - noise.x;\n                float smth = 1.0 - smoothstep(0.0, 0.05, dist);\n                // plus some other noise\n                vec3 q = 128.0*pointNearObject+time;\n                float noise2 = valueNoise3D(q+5.);\n                \n                // Choose the pyramids faces only\n                float verticalMask = smoothstep(hexcoreRadius+pyramidVerticalMaskPaddingBottom, hexcoreRadius+pyramidVerticalMaskPaddingBottom+pyramidVerticalMaskFade, length(pointNearObject))\n                    - smoothstep(hexcoreRadius+pyramidVerticalMaskHeight-pyramidVerticalMaskFade, hexcoreRadius+pyramidVerticalMaskHeight, length(pointNearObject));\n                \n                // Inverse XYZ cross mask, to sort out the pyramids' edges\n                float horizontalMask = 1. -\n                    ( smoothstep(pyramidHorizontalMaskWidth, pyramidHorizontalMaskWidth*pyramidHorizontalMaskFade, abs(t3.x))\n                    + smoothstep(pyramidHorizontalMaskWidth, pyramidHorizontalMaskWidth*pyramidHorizontalMaskFade, abs(t3.z)) );\n                horizontalMask = clamp(horizontalMask, 0., 1.);\n                \n                colour *= mix(1., shadow, facingInwards);\n                colour += 2.*pyramidSymbolColour*(.2*smth+0.8*3.*smth*smoothstep(.6, .7, noise2))*verticalMask*horizontalMask;\n                //colour = vec3(1.)*verticalMask*horizontalMask;\n            }\n            \n            // --- Edge detection goldening + pyramid hat\n            {                \n                float edgeMask = smoothstep(t.x-.02, t.x-.01, length(rayOrigin)) - \n                    (1. - clamp( step(orbRadius + .02, length(pointNearObject)), 0., 1. ));\n                edgeMask = clamp(edgeMask, 0., 1.);\n                \n                // fwidth(normal) same as abs(dFdx(normal))+abs(dFdy(normal))\n                float dfNormal = clamp( round( dot(fwidth(normal), vec3(1.))*10. )/10., 0., 1.);\n                \n                float h = mix(0., cos(PI*.25)*pyramidHeight, pyramidCapHeightT)*pyramidScale*2.;\n                float hatMask = step(hexcoreRadius + h, length(pointNearObject));\n                \n                colour += .5*edgeColour*edgeMask*dfNormal*occlusion*edgeStrength + .1*edgeColour*hatMask*edgeStrength;\n            }\n            \n            // --- Top light\n            {\n                float dif = clamp(normal.y, 0., 1.);\n                \n                float fre = clamp(1. + dot(rayDirection, normal), 0., 1.);\n                fre = pow(fre, 3.);\n                \n                colour += .5*vec3(0., .1, .5) *  dif * occlusion\n                    + vec3(0., .1, .5) * fre;\n            }\n            \n            // --- Side light\n            {\n                float dif = clamp( dot(normal, normalize(vec3(.7, .2, -.4))) , 0., 1.);\n                \n                colour += .07*vec3(.9, .3, .0) *  dif * occlusion;\n            }\n            \n            // colour = vec3(1.) * pow(length(t.yzx), 10.);\n            // colour = vec3(1.) * pow(length(pointNearObject), 1.);\n            // colour = 0.5 + 0.5 * normal;\n        }\n        else\n        {\n            // --- Spiral fx background\n            float fxMask = 1. - smoothstep(0., .8, pow( length(uv) - .5, 3. ));\n            \n            float fxInhaleStrength = 5. * ( 1. - smoothstep( 0., 1., length(uv) * .5 ) );\n            vec2 rotUVs = mat2(cos(fxInhaleStrength), -sin(fxInhaleStrength),\n                               sin(fxInhaleStrength),  cos(fxInhaleStrength)) * (uv) * uvScale;\n            float an = time * rotFactor;\n            rotUVs = mat2(cos(an), -sin(an),\n                          sin(an),  cos(an)) * (rotUVs);\n            \n            float noise = valueNoise2D( rotUVs );\n            \n            noise = smoothstep(.8, 1., noise);\n            \n            colour += .1 * fxColor * noise * fxMask;\n        }\n        \n        // --- Lightnings\n        {\n            //float mask = 1. - smoothstep(0., .05, pow( length(uv) - .5, 3. ));\n            //mask *= 1. - step( 0.15, mod( time - length(uv), 2.) );\n            //mask *= smoothstep( .8, .85, valueNoise2D( .1 * time - uv * 5. ) );\n            \n            //vec2 voro = voronoi2D( time - abs(uv * 8.) );\n            //float dist = voro.y - voro.x;\n            //float bord = 1. - smoothstep(0., .05, dist);\n            \n            //colour += fxColor * bord * mask;\n        }\n        \n        // --- Volumetric lighting?\n        {\n            //vec3 normal = vec3(0.);\n            \n            //vec2 intersections = iSphere( rayOrigin, rayDirection, vec3(0.), orbRadius );\n            //if (intersections.x > 0.)\n           // {\n             //   normal = normalize(rayOrigin + rayDirection * intersections.x);\n            //}\n            \n            //vec4 vol = getVolumetricLighting( \n             //   normal,  \n              //  orbRadius + .005,\n               // hexcoreRadius * 1.3,\n                //time);\n            \n            //colour += vec3(1.) * vol.x;\n        }\n        \n        // vignetting\n        colour *= 1. - .25*dot(uv, uv);\n\n        // gamma        \n        tot += pow(colour,vec3(.45));\n        \n    // if ssaa is on, take the average of the samples\n    #if SSAA >1\n    }\n    tot /= float(SSAA*SSAA);\n    #endif\n    \n    // dithering\n    tot += (1./512.)*(sin(fragCoord.y*111.0) * sin(fragCoord.x*125.546));\n\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 28943,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/sting/what-could-have-been-feat-ray"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// ------------------------------------------------- SHORTHANDS ------------------------------------------------\n\n// @source https://iquilezles.org/articles/distfunctions/\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// ------------------------------------------------- CONVERSION ------------------------------------------------\n\n// example input : 134. \n// example output: 2.14\nfloat convertSecondsToMinutes(float seconds)\n{\n    // 0.017 = 1. / 60.\n    return floor(seconds * .017) + mod(seconds, 60.) * .01;\n}\n\n// example input : 2.14 \n// example output: 134.\nfloat convertMinutesToSeconds(float minutes)\n{\n    return floor(minutes) * 60. + fract(minutes) * 100.;\n}\n\n// ----------------------------------------------------- SDFs -------------------------------------------------\n\nvec4 sdSphere( vec3 p, float radius )\n{\n    return vec4(length(p) - radius, p);\n}\n\nfloat sdCylinder( vec3 p, float radius )\n{\n    return length(p.xz)-radius;\n}\n\n// @source https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 point, vec3 b )\n{\n    vec3 d = abs(point) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// @source https://iquilezles.org/articles/distfunctions/\n// Triangle - exact   (https://www.shadertoy.com/view/4sXXRN)\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n// ------------------------------------------------- POSITIONING ----------------------------------------------\n\n// rot Z, X, Y in radians\nvec3 rotate(vec3 point, float rotX, float rotY, float rotZ)\n{\n    vec3 rotatedPoint = point;\n    \n    rotatedPoint = mat3(cos(rotZ), -sin(rotZ), 0,\n                        sin(rotZ),  cos(rotZ), 0,\n                        0,          0,         1) \n                        \n                 * mat3(1, 0,          0,\n                        0, cos(rotX), -sin(rotX), \n                        0, sin(rotX),  cos(rotX))\n    \n                 * mat3(cos(rotY),  0, sin(rotY),\n                        0,          1, 0,\n                        -sin(rotY), 0, cos(rotY))\n                        \n                 * point;\n    \n    return rotatedPoint;\n}\n\n// --------------------------------------------- PRIMITIVE COMBINATIONS ---------------------------------------\n// -------------------------------- https://iquilezles.org/articles/distfunctions/ ----------------------------\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ---------------------------------------- DEFORMATIONS & DISTORTIONS ----------------------------------------\n\nvec3 opTwist( in vec3 p, float amount )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nvec3 opCheapBend( in vec3 p, float amount )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(amount*p.x);\n    float s = sin(amount*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n// ---------------------------------------------------- NOISE ------------------------------------------------\n\n// @source https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// @source https://www.shadertoy.com/view/4djSRW\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// @source https://www.shadertoy.com/view/4djSRW\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n// @source https://www.shadertoy.com/view/4djSRW\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// @source https://iquilezles.org/articles/voronoilines/\nvec2 voronoi2D( in vec2 x )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    vec2 res = vec2( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2(i, j);\n        vec2  r = vec2(b) - f + hash22(p + b);\n        float d = dot(r, r);\n\n        if( d < res.x )\n        {\n            res.y = res.x;\n            res.x = d;\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return sqrt( res );\n}\n\n// @source https://www.shadertoy.com/view/lsf3WH\nfloat valueNoise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// @source https://www.shadertoy.com/view/4sfGzS\n// Value Noise 3D \nfloat valueNoise3D( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(i+vec3(0,0,0)), \n                        hash13(i+vec3(1,0,0)),f.x),\n                   mix( hash13(i+vec3(0,1,0)), \n                        hash13(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(i+vec3(0,0,1)), \n                        hash13(i+vec3(1,0,1)),f.x),\n                   mix( hash13(i+vec3(0,1,1)), \n                        hash13(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// @source https://www.shadertoy.com/view/ldl3Dl\n// returns closest, second closest, and cell id\nvec3 voronoi3D( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash33( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}