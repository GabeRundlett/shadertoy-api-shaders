{
    "Shader": {
        "info": {
            "date": "1669588746",
            "description": "Based on https://www.shadertoy.com/view/tsfyzn\nAdded some beat pops",
            "flags": 4,
            "hasliked": 0,
            "id": "DslXW2",
            "likes": 14,
            "name": "Synthwave Triangles",
            "published": 3,
            "tags": [
                "retro",
                "landscape",
                "synthwave"
            ],
            "usePreview": 0,
            "username": "elloskelling",
            "viewed": 676
        },
        "renderpass": [
            {
                "code": "// credits to @spalmer for grid smooth function https://www.shadertoy.com/view/wl3Sz2\n#define MAX_STEPS 156\n#define MIN_DISTANCE 0.01\n#define MAX_DISTANCE 16.\n#define GRID_SIZE 4.\n#define speed 6.\n#define MOUNTAIN_COLOR vec3(0.54, 0.11, 1.)\n#define COLOR_PURPLE vec3(0.81, 0.19, 0.78)\n#define COLOR_LIGHT vec3(0.14, 0.91, 0.98)\n#define COLOR_SUN vec3(1., 0.56, 0.098)\n#define MATERIAL_PLANE 1.\n#define MATERIAL_BACK 2.\n#define GRID_THICKNESS .2\n#define COLOR_NIGHT_GRID vec3(0., .15, 0.)\n#define COLOR_NIGHT_SUN vec3(0.5, .0, 0.)\n#define COLOR_NIGHT_MOUNTAIN vec3(0.9, .3, 0.1)\n#define SUNSET_SPEED 3.\n\n\n#define beatScale 3.7\n#define beatBias 0.\n\n\nvec3 lightPos = vec3(0., 3., -10.);\n\nstruct traceResult {\n    bool  isHit;\n    float distanceTo;\n    float material;\n    float planeHeight;\n    vec3 planeNormal;\n};\n\nstruct getDistResult {\n    float distanceTo;\n    float material;\n    float planeHeight;\n    vec3 planeNormal;\n};\n\nfloat sdPlane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat N21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*5677.)*4332.23);\n}\n\nmat2 rot2d(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(vec2(c,-s), vec2(s,c));\n}\n\nfloat getHeight(vec2 id) {\n    //return 0.;\n    float ax = abs(id.x);\n    if (ax < GRID_SIZE) {\n        return 0.;\n    }\n\n    float n = N21(id);\n\n    float wave = sin(id.y/9. + cos(id.x/3.))*sin(id.x/9. + sin(id.y/4.));\n\n    wave = clamp((wave * .5 + .5) + n*.15 - .6, 0., 1.);\n    if (ax < (GRID_SIZE + 5.) && ax >= GRID_SIZE) {\n        wave *= (ax - GRID_SIZE + 1.)*.2;\n    }\n    return (wave*10.);\n}\n\n\ngetDistResult getDist(vec3 p) {\n    float size = GRID_SIZE;\n    vec3 nuv = p * size + vec3(0., 0., iTime * speed);\n    vec2 uv = fract(nuv).xz;\n    vec2 id = floor(nuv).xz;\n\n    vec2 lv = uv;\n\n    float bl = getHeight(id);\n    float br = getHeight(id + vec2(1., 0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = getHeight(id + vec2(0., 1.));\n    float tr = getHeight(id + vec2(1., 1.));\n    float t = mix(tl, tr, lv.x);\n\n    float height = mix(b,t, lv.y);\n\n    float O = bl;\n    float R = br;\n    float T = getHeight(id + vec2(0. -1.));\n    float B = tl;\n    float L = getHeight(id + vec2(-1., 0));\n\n    vec3 n = vec3(2.*(R-L), 2.*(B-T), -4.);\n\n\n    float d = sdPlane(p, -.5 + 0.3*height);\n\n    float db = -p.z + MAX_DISTANCE*.4;\n    d = min(d, db);\n\n    getDistResult result;\n\n    result.distanceTo = d;\n    result.material = MATERIAL_PLANE;\n    result.planeHeight = height;\n    result.planeNormal = normalize(n);\n\n    if (d == db) {\n        result.material = MATERIAL_BACK;\n    }\n\n    return result;\n}\n\ntraceResult trace(vec3 ro, vec3 rd) {\n    traceResult result;\n    float ds, dt;\n    getDistResult dist;\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        vec3 p = ro + rd * ds;\n        dist = getDist(p);\n        dt = dist.distanceTo;\n        ds += dt * .6;\n        if (abs(dt) < MIN_DISTANCE || ds > MAX_DISTANCE) {\n            break;\n        }\n    }\n    result.isHit = abs(dt) < MIN_DISTANCE;\n    result.distanceTo = ds;\n    result.material = dist.material;\n    result.planeHeight = dist.planeHeight;\n    result.planeNormal = dist.planeNormal;\n    return result;\n}\n\nfloat getLightDiffuse(vec3 p, float material, float height, vec3 normal) {\n    vec3 l = normalize(lightPos - p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    return dif;\n}\n\nvec3 starsLayer(vec2 ouv) {\n    vec3 col = vec3(0.);\n\n    vec2 uv = fract(ouv) - .5;\n\n    float d;\n\n    for(int x = -1 ; x <= 1; x++) {\n        for(int y = -1 ; y <= 1; y++) {\n            vec2 offset = vec2(x,y);\n            vec2 id = floor(ouv) + offset;\n            float n = N21(id);\n            if (n > .6) {\n                float n1 = fract(n*123.432);\n                float n2 = fract(n*1234.2432);\n\n                float size = .01 + 0.05 * (n1 - .5);\n\n                vec2 shift = vec2(n1 - .5, n2 - .5);\n                d = max(d, size/length(uv - offset + shift));\n            }\n        }\n    }\n\n\n    return col + d*vec3(.1, .9, .1);\n}\n\nvec3 backgroundStars(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float t = iTime * (speed / 30.);\n\n    float layers = 3.;\n\n    for(float i = 0. ; i < 1. ; i+= 1./layers) {\n        float depth = fract(i + t);\n        float scale = mix(20., .5, depth);\n        float fade = depth * smoothstep(1., .9, depth);\n\n        col += starsLayer(uv * scale + i * 456.32) * fade;\n    }\n    return col;\n}\n\nvec3 getOthersideBackground(vec2 uv) {\n    return backgroundStars(uv/8. + sin(iTime/(speed)));\n}\n\nvec3 getBackground(vec2 uv) {\n    float set = 0. - clamp(sin(iTime/SUNSET_SPEED)*3., -1., 2.);\n\n    float sunDist = length(uv + vec2(0., -2.5 - set));\n    float sun = 1. - smoothstep(2.35, 2.5, sunDist);\n\n    float gradient = sin(uv.y/4. - 3.14/32. + set/3.)*2.;\n    float bands = abs(sin(uv.y * 8. + iTime*2.)) * (1. - step(2.5 + set, uv.y));\n\n    float skyTop = 2.12/distance(uv, vec2(uv.x, 9.5));\n    float skyBottom = 1.12/distance(uv, vec2(uv.x, -1.5));\n\n    vec3 result;\n\n    // sun\n\n    if (set < -1.8) {\n        result = vec3(sun) * (bands > 0. ? bands : 1.) * mix(vec3(0.), COLOR_NIGHT_SUN, ((abs(set) - 1.6) -.2) * 15.);\n        float glow = smoothstep(.1, .5, (1.1)/sunDist);\n        result += glow * COLOR_NIGHT_SUN;\n    } else {\n        result = vec3(sun * gradient * (bands > 0. ? bands : 1.)) * COLOR_SUN;\n        //glow\n        float glow = smoothstep(.1, .5, (1.1)/sunDist) + clamp(-1., 1., set);\n        // result += glow * COLOR_PURPLE;\n\n        // sky\n        result += max(glow * COLOR_PURPLE, ((skyTop * MOUNTAIN_COLOR) + (skyBottom * COLOR_PURPLE))*(1. + set));\n    }\n\n\n\n    if (sun < .5) {\n        // stars\n        vec2 nuv = uv*2.;// + vec2(iTime, 0.);\n        vec2 rize = vec2(-10., 12.);\n        nuv -= rize;\n        nuv *= rot2d(mod(-iTime/15., 6.28));\n        nuv += rize;\n        uv = fract(nuv);\n        vec2 id = floor(nuv);\n        uv -= .5;\n\n        float n = N21(id);\n        uv.x += fract(n*100.32) - .5;\n        uv.y += fract(n*11323.432) - .5;\n\n        float star = smoothstep(.5, 1., (0.03 + (0.02 * (fract(n*353.32) - .5)))/length(uv));\n\n        result += star * step(.8, n);\n    }\n\n    return result;\n}\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\n// (c) spalmer https://www.shadertoy.com/view/wl3Sz2\nfloat gridPow(vec2 uv)\n{\n    vec2 p = uv * GRID_SIZE + vec2(0., iTime * speed);\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    f = max(vec2(0), 1. - f + .5*GRID_THICKNESS);\n    f = pow(f, vec2(fadePower));\n    float g = f.x+f.y; //max(f.x, f.y); //\n    float s = sqrt(GRID_THICKNESS);\n    return mix(g, s, exp2(-.01 / filterWidth2(p)));\n}\n\nvec3 getAlbedo(vec3 p, float material, float height, vec3 normal) {\n    if (material == MATERIAL_BACK) {\n        return getBackground(p.xy);\n    }\n\n    float sunSet = sin(iTime/SUNSET_SPEED)*.5 + .5;\n\n    vec3 col = vec3(0.);\n    float grid = gridPow(p.xz);\n\n    float maxHeight = 2.5;\n\n    vec3 grid_color = COLOR_PURPLE;\n    vec3 cell_color = vec3(0.);\n    vec3 mountain_color = MOUNTAIN_COLOR;\n    mountain_color = mix(mountain_color, COLOR_NIGHT_MOUNTAIN, sunSet);\n\n\n\n    if (height > 0.) {\n        grid_color = mix(COLOR_PURPLE, COLOR_LIGHT, height/maxHeight);\n        cell_color = mountain_color * mix(vec3(0.), mountain_color, height/maxHeight);\n    }\n\n    grid_color = mix(grid_color, COLOR_NIGHT_GRID, sunSet);\n\n    col = mix(vec3(0.), grid_color, grid) + cell_color;\n\n    return vec3(col);\n}\n\nfloat polarTriangle(vec2 uv, float offset) {\n    float a = atan(uv.x, uv.y) + offset;\n    float b = 6.28 / 3.;\n    float l = length(uv);\n\n    float d = cos(a - floor(.5 + a/b) * b) * l;\n\n    return d;\n}\n\nfloat triangleMask(vec2 uv) {\n    return polarTriangle(uv + vec2(0., -.1),3.14 + .5*sin(iTime));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // lightPos.z = sin(iTime/3.)*100.;\n\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05,  0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.17, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.25, 0.25 ) ).x;\n\n    //////////////////\n\n    float beat = 0.25*freqs[0]*freqs[0]\n                +0.35*freqs[1]*freqs[1]\n                +0.25*freqs[2]*freqs[2]\n                +0.15*freqs[3]*freqs[3];\n    beat = sqrt(beat) * beatScale + beatBias;\n\n\n    float beat2 = 0.3*freqs[3]*freqs[3]\n                 +0.4*freqs[4]*freqs[4]\n                 +0.3*freqs[5]*freqs[5];\n    beat2 = sqrt(beat2) * beatScale + beatBias;\n\n    //////////////////\n\n    mouse.x = 0.5;\n    mouse.y = 0.;\n\n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(0., .5, -.4);\n    vec3 lookat = vec3(mouse.x*2.-1., 1. - mouse.y - .6, 0.);\n    float zoom = .4;\n\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0.);\n\n    traceResult tr = trace(ro, rd);\n\n    if (tr.isHit) {\n\n        p = ro + rd * tr.distanceTo;\n\n        vec3 albedo = getAlbedo(p, tr.material, tr.planeHeight, tr.planeNormal);\n\n        float diffuse = getLightDiffuse(p, tr.material, tr.planeHeight, tr.planeNormal)*beat2;\n\n        float fade = 1.;// - clamp((p.z-ro.z)/(MAX_DISTANCE * .8), 0., 1.);\n\n        if (tr.material == MATERIAL_BACK) {\n            col = albedo;\n        } else {\n            col = diffuse * albedo * fade;\n        }\n\n        float triangle = triangleMask(uv*(1.-beat/5.));\n        float fd = fract(triangle - clamp(sin(iTime/3.), 0., 2.));\n        float bc = (1. - step(.2, fd));\n\n        col *= (tr.material == MATERIAL_BACK) ? bc : 1.;\n        if (bc == 0.) {\n            if (tr.material == MATERIAL_BACK) {\n                col = getOthersideBackground(p.xy);\n            } else {\n                col *= vec3(.8);\n            }\n        }\n\n        col += ((1. - step(.2, fd)) - (1. - step(.19, fd)))*.3;\n\n    }\n\n\n    fragColor = vec4(col, 1.);\n    // fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}