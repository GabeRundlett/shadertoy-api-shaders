{
    "Shader": {
        "info": {
            "date": "1671497504",
            "description": "He needs hands\n\nmake sure you click the music thingy :)\n\nCrawling man:\nhttps://www.shadertoy.com/view/mtlGzM\n",
            "flags": 96,
            "hasliked": 0,
            "id": "mlX3R7",
            "likes": 28,
            "name": "Pixel Man 2!",
            "published": 3,
            "tags": [
                "2d",
                "motion",
                "pixelart",
                "human",
                "stickman"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 424
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n// https://lospec.com/palette-list/resurrect-64\n// didn't look as nice imo\n#define c0 vec3(50,51,83)/255.\n#define c1 vec3(72,74,119)/255.\n#define c2 vec3(77,101,180)/255.\n#define c3 vec3(77,155,230)/255.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = .16;\n    vec3 col = texelFetch(iChannel0, ivec2(sc *fragCoord), 0).rgb;\n    vec3 col2 = .5 + .5*cos(.5*pi*(2.5*exp(-2.*length(col)) + vec3(0,1,2)/3.));\n    \n    /*\n    if (col.r == .5) col = c0;\n    else if (col.r == 1.) col = c1;\n    else if (col.b == .5) col = c1;\n    else if (col.b == 1.) col = c2;\n    else if (col.g == .5) col = c2;\n    else if (col.g == 1.) col = c3;\n    //*/\n     \n    col = mix(col, col+col2, .5 - .5 * cos(uv.x + iTime));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 31313,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kynon-duff/wide-putin-walkingsong-for-denise-8-bit-vrc6-castlevania-3-jp-style?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat line(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float d = min((abs(f.x - round(dir.x/dir.y * f.y))),\n                  (abs(f.y - round(dir.y/dir.x * f.x))));\n                  \n    // Restrict to the box bounded by p and q           \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nfloat stride(float t, float i) {\n    float a = pi / 2.;\n    float f = min(1., mod(t + i * a, 2. * a) / a);\n    \n    // Some of these need remapping to [0,1]\n    //return pow(4.*f*(1.-f),2.);\n    //return 4. * f * (1.-f) * (1.-f);\n    return sqrt(1. - pow(2.*f-1., 2.));\n    //return 0.5 * abs(sin(pi * f));\n}\n\n// Gets 3rd point on isosceles triangle equidistant from p, q\nvec2 getTriPoint(vec2 f, vec2 p, vec2 q, float v) {\n    vec2 m = (p+q)/2.; \n    float d = 0.5 * length(p-q);\n    \n    // a=2. is min distance from pq line, so it doesn't snap\n    // into place and skip too many pixels at once\n    float a = 2.; // 3 is believable too\n    if (v > d) \n        a = sqrt(v * v - d * d);\n    \n    vec2 dir = normalize(vec2(p.y - q.y, q.x - p.x));\n    return round(m + a * dir); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    float t = 5. * iTime;\n\n    // (sorry if this is off-screen for you)\n    f -= vec2(64,2) - 0.5;\n      \n    // --- PARAMETERS ---  \n      \n    float silly = -4. * cos(t) * tanh(0.01 * t);  \n      \n    float sw = 6. + 6. * tanh(0.1 * t);     // Stride width\n    vec2 sh = vec2(6); // Stride height (Left, Right)\n    \n    float vHip = 2.;         // Hip vertical motion per step\n    float xHip = 1.-2.*abs(cos(t)); // Hip horizontal offset\n    vec2 dimHip = vec2(2,1); // Hip dims (Length, Height-Osc)\n    float hHip = 23. - silly;// Hip height\n    float aHip = t;//-t      // Hip angle\n    \n    float dTor = 17. + silly;   // Torso length\n    float aTor = pi/2.; // Torso angle\n    \n    vec2 dimSho = vec2(1);  // Shoulder dims (Length, Height-Osc)\n    \n    float dLeg = 9.;  // Leg length/2, dLeg > (vHip+hHip)/2\n    \n    float dFoot = 3.; // Foot length\n    float tf = 3.;    // Toe fluidity (idk how to describe this)\n \n    vec2 dElb = vec2(7);      // Elbow length (Left, Right)\n    vec2 aElb = -0.5 * pi +   // Elbow angle\n                -0.125 * pi * vec2(cos(t), -cos(t)); \n    \n    vec2 dHand = vec2(8);     // Hand length (forearm)\n    vec2 aHand = -0.3 * pi +  // Hand angle \n                 -0.3 * pi * vec2(cos(t), -cos(t));\n    \n    vec2 dFing = vec2(2); // Finger length\n    \n    float dHead = 3.;             // Head distance from neck\n    float aHead = pi/2. - pi/12.; // Head angle from neck\n    \n    \n    // --- POINTS ---\n    \n    // Centre x coord\n    float spd = 0.*0.75 * sw; // (needs improving)\n    float x = spd * t;\n    \n    // Centre (of hip)\n    vec2 p = round(vec2(x - xHip, hHip + vHip * abs(cos(t))));\n    \n    // Hip\n    vec2 pHip1 = round(p - dimHip * vec2(cos(aHip), sin(aHip)));\n    vec2 pHip2 = round(p + dimHip * vec2(cos(aHip), sin(aHip)));\n    \n    // Foot\n    vec2 pFoot1 = round(vec2(x-sw*cos(t), sh.x * stride(.5*t, 0.)));\n    vec2 pFoot2 = round(vec2(x+sw*cos(t), sh.y * stride(.5*t, 1.)));\n        \n    // Toe\n    float o = -pi/12.; // Land on heels or toes?\n    vec2 pToe1 = (vec2(x+tf-sw*cos(t+o), .5*sh.x*stride(.5*t+o, 0.)));\n    vec2 pToe2 = (vec2(x+tf+sw*cos(t+o), .5*sh.y*stride(.5*t+o, 1.)));\n    vec2 fdir1 = normalize(pToe1 - pFoot1);\n    vec2 fdir2 = normalize(pToe2 - pFoot2);\n    pToe1 = round(pFoot1 + dFoot * fdir1);\n    pToe2 = round(pFoot2 + dFoot * fdir2);\n\n    // Knee\n    vec2 pKnee1 = getTriPoint(f, pHip1, pFoot1, dLeg);\n    vec2 pKnee2 = getTriPoint(f, pHip2, pFoot2, dLeg);\n      \n    // Neck\n    vec2 pNeck = round(vec2(x + xHip, p.y) + \n                       dTor * vec2(cos(aTor), sin(aTor)));\n      \n    // Shoulder\n    vec2 pSho1 = round(pNeck - dimSho * vec2(cos(aHip), sin(aHip)));\n    vec2 pSho2 = round(pNeck + dimSho * vec2(cos(aHip), sin(aHip)));\n      \n    // Elbow\n    vec2 pElb1 = round(pSho1 + dElb.x * vec2(cos(aElb.x), sin(aElb.x)));\n    vec2 pElb2 = round(pSho2 + dElb.y * vec2(cos(aElb.y), sin(aElb.y)));\n      \n    // Hand \n    vec2 pHand1 = round(pElb1 + dHand.x * vec2(cos(aHand.x), sin(aHand.x)));\n    vec2 pHand2 = round(pElb2 + dHand.y * vec2(cos(aHand.y), sin(aHand.y)));\n      \n    // Head\n    vec2 dirHead = vec2(cos(aHead), sin(aHead)); \n    vec2 pHead = round(pNeck + dHead * dirHead);\n    \n    \n \n    // --- DRAW ---  \n      \n    // Hip\n    col.b += line(f, pHip1, pHip2);  \n    \n    // Legs\n    col.r += line(f, pHip1,  pKnee1) + \n             line(f, pKnee1, pFoot1) +\n             line(f, pFoot1, pToe1);\n    col.g += line(f, pHip2,  pKnee2) + \n             line(f, pKnee2, pFoot2) +\n             line(f, pFoot2, pToe2);\n       \n    // Torso\n    col.b += line(f, p, pNeck);\n    \n    // Shoulder\n    col.b += line(f, pSho1, pSho2);\n    \n    // Arms\n    col.r += line(f, pSho1, pElb1) +\n             line(f, pElb1, pHand1);\n    col.g += line(f, pSho2, pElb2) + \n             line(f, pElb2, pHand2);\n\n    // Neck\n    col.b += line(f, pNeck, pHead);\n   \n    // Head\n    float head = length(round(f - pHead - 3. * dirHead));\n    float sHead = step(head, 3.5);// - step(head,2.5);\n    col.b += sHead;\n   \n    //col = length(col) * vec3(1);\n    \n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec4 cell(in sampler2D tx, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(tx, 0));\n    p = (p+r) % r;\n    return texelFetch(tx, p, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{ \n    vec4 e = vec4(0);\n    vec4 c = vec4(0);\n    int n = 1;\n    for (int i = -n; i < n + 1; i++) {\n        for (int j = - n; j < n + 1; j++) {\n            e = max(e, cell(iChannel0, ivec2(f + vec2(i,j))));\n            c += cell(iChannel0, ivec2(f + vec2(i,j)));\n        }\n    }\n    c /= 9.;\n    vec4 a = cell(iChannel0, ivec2(f - 1.));\n    e += a;\n\n    if (e.g > 0.)\n        e.rb *= 0.;\n    else if (e.b > 0.)\n        e.r *= 0.;\n        \n    e *= 0.5;\n\n    fragColor = e;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Ideas:\n// - Change stride height randomly to match some obstacles, move body up\n//   and down so it appears to climb over obstacles.\n// - Make zombie army\n// - Pick from collection of movement functions e.g. for stride\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}