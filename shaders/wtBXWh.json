{
    "Shader": {
        "info": {
            "date": "1565751745",
            "description": "Spheres packed in a cube. Spin with the mouse. Takes time to converge.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtBXWh",
            "likes": 21,
            "name": "Fractal Sphere Packing In A Box",
            "published": 3,
            "tags": [
                "3d",
                "cube",
                "sphere",
                "quaternion",
                "spin",
                "render",
                "packing"
            ],
            "usePreview": 0,
            "username": "mathmasterzach",
            "viewed": 878
        },
        "renderpass": [
            {
                "code": "//Spheres packed in a cube\n//Drag with the mouse to spin the cube\n//Spheres have a max size\n//Spheres will try to find more ideal spots to occupy\n\nconst float TAU=2.*acos(-1.);\n\n//Distance between sphere and ray if they intersect, -1 otherwise\nfloat sphereRayDist(vec3 o, vec3 r, vec4 s){\n    vec3 oc = o-s.xyz;\n    float b = dot(oc,r);\n    float c = dot(oc,oc)-s.w*s.w;\n    float t = b*b-c;\n    if( t > 0.0) \n        t = -b - sqrt(t);\n    return t;\n}\n\n//Thanks to iq for this helpful shadow function\nfloat sphereRayShadow(vec3 o,vec3 r,vec4 s,float k){\n    vec3 oc = o - s.xyz;\n    float b = dot(oc,r);\n    float c = dot(oc,oc)-s.w*s.w;\n    float h = b*b-c;\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );\n}\n\n//Thanks to iq for the base of this function as well\nbool intersectsBox(vec3 o,vec3 r){\n    vec3 m = 1./r;\n    vec3 n = m*o;\n    vec3 k = abs(m)*CUBE_SIZE;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return tN<=tF&&tF>=0.;\n}\n\n//color palette code from IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal(float t,vec3 a,vec3 b,vec3 c,vec3 d){\n    return a+b*cos(TAU*(c*t+d));\n}\n\n//render scene with walls and balls\nvec3 trace(vec3 o,vec3 r){\n    int irx=int(iResolution.x);\n    int hit=0;\n    float md=2e20;\n    vec4 msp=vec4(-1.);\n    for(int i=0;i<NUM_BALLS;i++){\n        vec4 sphere=2.*CUBE_SIZE*texelFetch(iChannel0,ivec2(i%irx,i/irx),0);\n        sphere.xyz-=CUBE_SIZE;\n        float d=sphereRayDist(o,r,sphere);\n        if(d<md&&d>=0.){\n        \tmsp=sphere;\n            md=d;\n            hit=1;\n        }\n    }\n    vec3 norm;float td;vec3 to;\n    td=-(o.x-(sign(r.x)*5.))/r.x;\n    to=o+r*td;\n    if(td<md&&td>0.0&&abs(to.y)<5.&&abs(to.z)<5.){\n        md=td;hit=2;norm=vec3(sign(r.x),0.,0.);\n    }\n    td=-(o.z-(sign(r.z)*5.))/r.z;\n    to=o+r*td;\n    if(td<md&&td>0.0&&abs(to.x)<5.&&abs(to.y)<5.){\n        md=td;hit=2;norm=vec3(0.,0.,sign(r.z));\n    }\n    td=-(o.y-(sign(r.y)*5.))/r.y;\n    to=o+r*td;\n    if(td<md&&td>0.0&&abs(to.x)<5.&&abs(to.z)<5.){\n        md=td;hit=2;norm=vec3(0.,sign(r.y),0.);\n    }\n    \n    if(hit>0){\n        vec3 no=o+r*md;\n        \n        float cs=1./(-.5*msp.w-1.)+1.;\n        vec3 c=pal(cs,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n        if(hit==2){\n            c=vec3(.5+.5*mod(floor(no.x+.01) + floor(no.y+.01) + floor(no.z+.01), 2.));\n            if((abs(no.x)>4.9&&abs(no.y)>4.9)||(abs(no.x)>4.9&&abs(no.z)>4.9)||(abs(no.y)>4.9&&abs(no.z)>4.9)){\n            \tc=vec3(1.);\n            }\n        }\n        vec3 lp=vec3(.1,.1,0);\n        float l;\n        if(hit==1){\n        \tl=dot(normalize(r-lp),normalize(msp.xyz-(o+r*md)));\n        }else{\n        \tl=dot(normalize(r-lp),norm);\n        }\n        l+=pow(l,32.);\n        r=-normalize(r-lp);\n        no+=r*.001;\n        float shd=1.;\n        for(int i=0;i<NUM_BALLS;i++){\n        \tvec4 sphere=2.*CUBE_SIZE*texelFetch(iChannel0,ivec2(i%irx,i/irx),0);\n            sphere.xyz-=CUBE_SIZE;\n            shd*=sphereRayShadow(no,r,sphere,5.);\n        }\n        return c*l*shd;\n    }else{\n    \treturn vec3(0.);\n    }\n}\n\n//Apply Quaternion Rotation to vec3\nvec3 rot(vec4 q,vec3 r) {return 2.*cross(q.xyz,q.w*r+cross(q.xyz,r));}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord ){\n    vec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0.,0.,-2.4*CUBE_SIZE);\n    vec3 r = normalize(vec3(uv,1.));\n    vec4 t=texelFetch(iChannel1,ivec2(0,0),0);\n    r+=rot(t,r);\n    o+=rot(t,o);\n    vec3 col;\n    if(intersectsBox(o,r)){\n    \tcol=trace(o,normalize(r));\n    }else{\n    \tcol=vec3(.2);\n    }\n    uv=fragCoord/iResolution.xy;\n    col*=min(sqrt(40.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y)),1.);\n    fragColor=vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ball Placement\n\n//Fake dense makes the cube appear to be more densely packed by spheres\n//It forces spheres to be closer to the edges to avoid a bunch of hidden ones in the middle\n//#define FAKE_DENSE\n\nconst float SET_FACTOR=1.5;\nconst float MAX_BALL_SIZE=.3;\n\n//Hash from David Hoskins at https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//place balls to avoid overlaps with previous balls\n//try new spots to try and find a better one by a certain factor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    int md=int(fragCoord.x+floor(fragCoord.y)*iResolution.x);\n    int irx=int(iResolution.x);\n    if(iFrame==0){\n        fragColor=vec4(hash33(vec3(fragCoord,int(iDate.w))),0);\n        #ifdef FAKE_DENSE\n        \tfragColor=vec4(0.);\n        #endif\n    }else if(md<NUM_BALLS){\n        float d=2e20;float od=2e20;\n        vec3 oldP=texelFetch(iChannel0,ivec2(fragCoord),0).xyz;\n        vec3 p=.9*hash33(vec3(fragCoord,iFrame+int(iDate.w)))+.05;\n        //ball tests\n        for(int i=0;i<md;i++){\n            vec4 s=texelFetch(iChannel0,ivec2(i%irx,i/irx),0);\n            d=min(d,length(p-s.xyz)-s.w);\n            od=min(od,length(oldP-s.xyz)-s.w);\n        }\n        \n        //wall tests\n        d=min(d,p.x);d=min(d,1.-p.x);\n        d=min(d,p.y);d=min(d,1.-p.y);\n        d=min(d,p.z);d=min(d,1.-p.z);\n        \n        od=min(od,oldP.x);od=min(od,1.-oldP.x);\n        od=min(od,oldP.y);od=min(od,1.-oldP.y);\n        od=min(od,oldP.z);od=min(od,1.-oldP.z);\n        \n        //pick best, old or new\n        #ifdef FAKE_DENSE\n        if(d>od*SET_FACTOR&&d<MAX_BALL_SIZE&&(abs(p.x-.5)>.4||abs(p.y-.5)>.4||abs(p.z-.5)>.4||fragCoord.x<20.)){\n        #else\n        if(d>od*SET_FACTOR&&d<MAX_BALL_SIZE){\n        #endif\n            fragColor=vec4(p,d);\n        }else{\n        \tfragColor=vec4(oldP,od);\n        }\n    }else{\n    \tfragColor=vec4(-1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int NUM_BALLS=1000;//set this to as many as your computer can handle\nconst float CUBE_SIZE=5.;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Camera Rotation, Click And Drag With Velocity\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if(iFrame==0){\n        fragColor=vec4(0.,0.,0.,1.);\n        //initialize velocity\n        if(fragCoord.x>1.&&fragCoord.x<3.&&fragCoord.y<1.){\n        \tfragColor=vec4(.08,.02,0.,0.);\n        }\n    }else{\n        if(fragCoord.x<1.&&fragCoord.y<1.){\n            vec4 p=texelFetch(iChannel0,ivec2(0),0);\n            vec4 v=texelFetch(iChannel0,ivec2(1,0),0)/3.;\n            vec2 rx = vec2( sin(v.x/2.),cos(v.x/2.));\n   \t\t\tvec2 ry = vec2(-sin(v.y/2.),cos(v.y/2.));\n            //Quaternion multiplication simplification for basis elements\n            vec4 d=vec4(-rx.y*ry.y,rx.x*ry.x,-rx.x*ry.y,rx.y*ry.x);\n            //Full Quaternion multiplication\n            fragColor = normalize(vec4(d.x*p.x-d.y*p.y-d.z*p.z-d.w*p.w,\n                                       d.x*p.y+d.y*p.x+d.z*p.w-d.w*p.z,\n                                       d.x*p.z-d.y*p.w+d.z*p.x+d.w*p.y,\n                                       d.x*p.w+d.y*p.z-d.z*p.y+d.w*p.x));\n        }else if(fragCoord.x<2.&&fragCoord.y<1.){\n            vec4 v=texelFetch(iChannel0,ivec2(1,0),0);\n            vec4 m=texelFetch(iChannel0,ivec2(2,0),0);\n            v=.98*v;\n            if(m.z>.5){\n            \tv.xy+=(iMouse.xy-m.xy)/iResolution.xy;\n            }\n            fragColor=v;\n        }else if(fragCoord.x<3.&&fragCoord.y<1.){\n            fragColor = iMouse;\n        }else{\n            fragColor = vec4(0.);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}