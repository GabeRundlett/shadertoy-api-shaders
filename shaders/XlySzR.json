{
    "Shader": {
        "info": {
            "date": "1482429686",
            "description": "playing with a distorted distance field—I like the way it moves. features a half-assed version of iq’s ambient occlusion (see link in the code).",
            "flags": 0,
            "hasliked": 0,
            "id": "XlySzR",
            "likes": 5,
            "name": "intersections",
            "published": 3,
            "tags": [
                "cubes",
                "space"
            ],
            "usePreview": 0,
            "username": "mahalis",
            "viewed": 810
        },
        "renderpass": [
            {
                "code": "// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\n// -----------------\n\nconst float pi = 3.14159;\n\nfloat d(vec3 position) {\n    float centerDistance = length(position);\n    float shrinkRate = pi * 3.;\n    float newDistance = pow(centerDistance + sin(centerDistance * shrinkRate) / shrinkRate, 1.2);\n    return opInt(sdCube(opRepeat((rX(position, iTime * 0.11) + (sin(iTime * 0.23 + position.y * 5.0) * 0.2 * vec3(0.37,0.,1.19))) * (newDistance / centerDistance) + vec3(0., iTime * 0.05, 0.), vec3(0.1)), 0.03), sdSphere(position, 0.4 + sin(iTime * 0.43) * 0.1));\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return (vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x;\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 130; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(0., 0., 0., 1.);\n}\n\n// ambient occlusion using iq’s technique from https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat occlusion(vec3 position, vec3 normal) {\n    const float aoStep = 0.2;\n    float aoAcc = 0.;\n    const float distanceScale = 0.5; // decrease for less attenuation of shadows\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float sampleDistance = aoStep * fi;\n        aoAcc += (sampleDistance - max(0., d(position + normal * sampleDistance))) / exp2(fi * distanceScale);\n    }\n    return aoAcc;\n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(-0.3, 1.0, 0.5)  - position);\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotV = max(0.0, dot(normal, toEye));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    const float ambience = 0.4;\n    float shadow = smoothstep(0.0, 0.1, march(position + normal * 0.01, toLight, 0.002).w);\n    vec3 color = vec3(ndotL * shadow + (1.0 - occlusion(position, normal)) * ambience + pow(ndotH, 8.) * 0.4 * shadow);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cameraPosition = rY(vec3(0.0, 0.7, 1.0) * 1.5, iTime * 0.2);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    vec4 marchResult = march(cameraPosition, rayDirection, 0.0001);\n    if (marchResult.w > 0.0) {\n        fragColor = vec4(0.0); // “sky” color\n    } else {\n        vec3 position = marchResult.xyz;\n        fragColor = vec4(lightSurface(position, gradient(position, marchResult.w), -rayDirection), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}