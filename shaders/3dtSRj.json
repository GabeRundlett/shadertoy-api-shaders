{
    "Shader": {
        "info": {
            "date": "1572815431",
            "description": "wip\n7-segment 7 segment seven-segment seven segment, sevensegment",
            "flags": 0,
            "hasliked": 0,
            "id": "3dtSRj",
            "likes": 13,
            "name": "7 segment display",
            "published": 3,
            "tags": [
                "clock",
                "led",
                "7segment",
                "7segment",
                "lcd",
                "sevensegment",
                "sevensegment"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 1572
        },
        "renderpass": [
            {
                "code": "// Current code for: 7 segment display (wip)\n// Date: 2020 6/26\n// Tags: led, lcd, seven, clock\n// Description: wip\n\n// optimize\n// - by not redefining arrays each/every time function called\n// - \n\n// rendering\n// - implement raytracing (reject intersections with glass pane by 7-segment texture mapped)\n// - have blue glow white center\n// = distributed shadows\n\n// i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582\n#define TAU (2.*PI)\n\n//#define iDate (iDate*5000.)\n\nconst float[10] seg0 = float[](1., 0., 1., 1., 0., 1., 1., 1., 1., 1.);\nconst float[10] seg1 = float[](1., 0., 0., 0., 1., 1., 1., 0., 1., 1.);\nconst float[10] seg2 = float[](1., 1., 1., 1., 1., 0., 0., 1., 1., 1.);\nconst float[10] seg3 = float[](0., 0., 1., 1., 1., 1., 1., 0., 1., 1.);\nconst float[10] seg4 = float[](1., 0., 1., 0., 0., 0., 1., 0., 1., 0.);\nconst float[10] seg5 = float[](1., 1., 0., 1., 1., 1., 1., 1., 1., 1.);\nconst float[10] seg6 = float[](1., 0., 1., 1., 0., 1., 1., 0., 1., 1.);\n\n\n\nfloat SDF_lineseg (vec2 p, vec2 a, vec2 b) {\n    // https://youtu.be/PMltMdi1Wzg\n    // tho i couldve derived a less efficient (yet still accurate)\n    // formula myself, i didnt want to take the time\n    float t = clamp(dot(p-a, b-a)/dot(b-a, b-a), 0., 1.);\n    return length(p-a-(b-a)*t)-.1;\n}\n\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n\nfloat DE_seg (vec2 p, vec2 a, float rot) {\n    p -= a;\n    p.xy = p.xy*(1.-rot)+p.yx*rot;\n    //return SDF_lineseg(p, vec2(0.), vec2(1., 0.));\n    #define segw .12\n    #define segt -.02\n    float SDFp = -1e9;\n    SDFp = max( SDFp, (    SDF_plane(p, vec2(0.), normalize(vec2(-1., -1.)) )       - segt ));\n    SDFp = max( SDFp, (    SDF_plane(p, vec2(0.), normalize(vec2(-1., 1.)) )        - segt ));\n    SDFp = max( SDFp, (    SDF_plane(p, vec2(0., -segw), normalize(vec2(0., -1.)) ) - segt ));\n    SDFp = max( SDFp, (    SDF_plane(p, vec2(0., segw), normalize(vec2(0., 1.)) )   - segt ));\n    SDFp = max( SDFp, (    SDF_plane(p, vec2(1., 0.), normalize(vec2(1., -1.)) )    - segt ));\n    SDFp = max( SDFp, (    SDF_plane(p, vec2(1., 0.), normalize(vec2(1., 1.)) )     - segt ));\n    return SDFp;\n}\n\nfloat DE_7seg (vec2 p, float id) {\n    float SDFp = 1e9;\n    //\n    #if 0\n    float[10] seg0 = float[](1., 0., 1., 1., 0., 1., 1., 1., 1., 1.);\n    float[10] seg1 = float[](1., 0., 0., 0., 1., 1., 1., 0., 1., 1.);\n    float[10] seg2 = float[](1., 1., 1., 1., 1., 0., 0., 1., 1., 1.);\n    float[10] seg3 = float[](0., 0., 1., 1., 1., 1., 1., 0., 1., 1.);\n    float[10] seg4 = float[](1., 0., 1., 0., 0., 0., 1., 0., 1., 0.);\n    float[10] seg5 = float[](1., 1., 0., 1., 1., 1., 1., 1., 1., 1.);\n    float[10] seg6 = float[](1., 0., 1., 1., 0., 1., 1., 0., 1., 1.);\n    #endif\n    //\n    //\n    //\n    // top\n    SDFp = min(SDFp, DE_seg(p, vec2(0., 0.), 0.)+(1.-seg0[int(id)])*1e9 );\n    // top left\n    SDFp = min(SDFp, DE_seg(p, vec2(0., 0.), 1.)+(1.-seg1[int(id)])*1e9 );\n    // top right\n    SDFp = min(SDFp, DE_seg(p, vec2(1., 0.), 1.)+(1.-seg2[int(id)])*1e9 );\n    // middle\n    SDFp = min(SDFp, DE_seg(p, vec2(0., 1.), 0.)+(1.-seg3[int(id)])*1e9 );\n    // bottom left\n    SDFp = min(SDFp, DE_seg(p, vec2(0., 1.), 1.)+(1.-seg4[int(id)])*1e9 );\n    // bottom right\n    SDFp = min(SDFp, DE_seg(p, vec2(1., 1.), 1.)+(1.-seg5[int(id)])*1e9 );\n    // bottom\n    SDFp = min(SDFp, DE_seg(p, vec2(0., 2.), 0.)+(1.-seg6[int(id)])*1e9 );\n    //\n    return SDFp;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 finalCol = vec3(0.);\n    #define spp 1.\n    #define samplei 0.\n    //for (float samplei=0.; samplei<spp; ++samplei) {\n        vec2 p = (fragCoord.xy-iResolution.xy/2.)/iResolution.y;\n        //\n        p *= 5.;\n        p.y = -p.y;\n        p.x -= .5;\n        p.y -= -1.;\n        //\n        //#define iDate vec4(vec3(0.), iTime*60.*18.)\n        //\n        #define minute floor(iDate.w/60.)\n        float hour = floor(iDate.w/60./60.);\n    if (hour > 12.) { hour -= 12.; }\n        //\n        //\n        //vec3 retina = vec3(0., 0., 100./255.)*mod(floor(p.x*1.)+floor(p.y*1.), 2.);\n        vec3 retina;\n        //\n        float SDFp = 1e9;\n        SDFp = min(SDFp, DE_7seg(p-vec2(2., 0.), mod(minute, 10.) ));\n        SDFp = min(SDFp, DE_7seg(p-vec2(0., 0.), mod(floor(minute/10.), 6.) ));\n        #if 1\n        SDFp = min(SDFp, DE_7seg(p-vec2(-2, 0.), mod(hour, 10.) ));\n        SDFp = min(SDFp, DE_7seg(p-vec2(-4, 0.), mod(floor(hour/10.), 2.) ));\n        //\n        //SDFp = min(SDFp, length(p-vec2(sin(float(iFrame)*PI/60.), 3.)) < .1 ? 1. : 0);\n        SDFp = min(SDFp, length(p-vec2(-.5, 0.5))-.05);\n        SDFp = min(SDFp, length(p-vec2(-.5, 1.5))-.05);\n        #endif\n        //\n        if (SDFp > 0.) {\n            retina = mix(\n                vec3(0., 0., 100./255.),\n                vec3(0., 1., 1.),\n                1./(1.+pow(SDFp, 1.)*3. )\n            );\n        }\n        else {\n            retina = vec3(1.);\n        }\n        finalCol = retina;\n    //}\n    //\n    fragColor = vec4(finalCol/spp, 1.);\n}\n\n\n\n\n\n/*\n// Old code for: \"the worlds best raymarcher...\"\n// Created: 2019-11-03\n// Tags: raymarching\n// Description: \"I'm so happy I can make analytically rigorous 3D grapics :)\"\n\nconst vec3 origin = vec3(0., 0., 0.);\n\nconst vec3 lightcol = vec3(1., 1., 1.);\n\nfloat lerp (float a, float b, float t) {\n    float p = a+(b-a)*t;\n    p = 3.*p*p-2.*p*p*p;\n    return p;\n}\n\nvec3 hadamard (vec3 a, vec3 b) {\n    return vec3(a.x*b.x, a.y*b.y, a.z*b.z);\n}\n\nfloat planeSDF (vec3 p) {\n    return p.y+2.;\n}\n\nfloat sphereSDF (vec3 p) {\n    float s = 5.;\n    p = vec3(mod(p.x+iTime, s)-s/2., p.y, p.z);\n    return max(length(p-vec3(0., 0., 2.))-2., 0.-length(p-vec3(0., 0., 1.9)));\n}\n\nfloat sphere1 (vec3 p) {\n    float s = 1e5;\n    s = min(s, length(p-vec3(0., 0., 2.))-2.);\n    return s;\n}\n\nfloat sphere2 (vec3 p) {\n    return length(p-vec3(5., 0., 2.))-2.;\n}\n\nfloat sphere3 (vec3 p) {\n    return length(p-vec3(10., 0., 2.))-2.;\n}\n\nfloat SDF (vec3 p) {\n    float SDFp = planeSDF(p);\n    SDFp = min(sphere1(p), SDFp);\n    SDFp = min(sphere2(p), SDFp);\n    SDFp = min(sphere3(p), SDFp);\n    return SDFp;\n}\n\nvec3 RFX (vec3 p) {\n    float SDFp = SDF(p);\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,\n            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,\n            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp\n        )\n    );\n}\n\nvec3 TEXcolor (vec3 p, vec3 incidentd) {\n    vec3 RFXp = RFX(p);\n    vec3 headingd = reflect(incidentd, RFXp);\n    // lightning that gets obsorbed\n    float lightness = 0.;\n    // diffuse light\n        // point light\n        vec3 light1p = vec3(0., 2., 0.);\n        vec3 light1d = normalize(light1p-p);\n        // directional light\n        light1d = normalize(vec3(cos(iTime), 1., sin(iTime)));\n    \tfloat diff = 0.;\n    \tdiff = dot(light1d, RFXp);\n        // diff = dot(light1d, headingd);\n    \t// float light1dzx = atan(light1d.z, light1d.x);\n    \t// float headingdzx = atan(headingd.z, headingd.x);\n    \t// float headingdzxr = sqrt(headingd.z*headingd.z+headingd.x*headingd.x);\n    \t// headingd.x = headingdzxr*cos(headingdzx-light1dzx);\n    \t// headingd.z = headingdzxr*sin(headingdzx-light1dzx);\n    \t// float light1dyx = atan(light1d.y, light1d.x);\n    \t// float headingdyx = atan(headingd.y, headingd.x);\n    \t// float headingdyxr = sqrt(headingd.y*headingd.y+headingd.x*headingd.x);;\n    \t// headingd.x = headingdyxr*cos(headingdyx+3.141/2.-light1dyx);\n    \t// headingd.y = headingdyxr*sin(headingdyx+3.141/2.-light1dyx);\n    \t// diff = acos(headingd.y)/3.14159;\n    \t// diff = clamp(headingd.y, 0., 1.);\n    \t// diff = 1.-acos(diff)/3.14159;\n    \tdiff = clamp(diff/2.+1., 0., 1.);\n    lightness += diff;\n    // ambient light\n    // lightness = 0.3+0.7*lightness;\n    // lightness = clamp(lightness, 0., 1.);\n    \n    // texture that absorbs tje light just like in real life\n    float czk = mod(floor(p.x)+floor(p.z)+floor(p.y), 2.);\n    // czk = mod(floor(p.x*3.)+floor(p.y*3.), 2.)/2.;\n    czk = 1.;\n    vec3 col = vec3(.2)+vec3(0., czk*.5, czk*.5);\n    if (planeSDF(p) < 1e-2) {\n        czk = mod(floor(p.x)+floor(p.z), 2.);\n        col = vec3(.2)+vec3(0., czk*.5, 0.);\n    }\n    // combined them to get a thing 'sumcol'\n    vec3 sumcol = hadamard(lightcol*lightness, col);\n    // then add specular wich reflects all the light that hits it\n    // from major light sources\n    float specular = 0.;\n    specular = clamp(dot(light1d, headingd), 0., 1.);\n    specular = pow(specular, 10.);\n    sumcol += specular;\n    return sumcol;\n}\n\nfloat TEXrindex (vec3 p) {\n    if (planeSDF(p)<1e-2) {\n        return .5;\n    }\n    if (sphere1(p)<1e-2) {\n        return .3;\n    }\n    return 0.;\n}\n\nvec3 bg (vec3 direction) {\n    vec3 lightd = normalize(vec3(cos(iTime), 1., sin(iTime)));\n    float ind = clamp(dot(normalize(direction), lightd), 0., 1.);\n    // return vec3(0., 0., 100./255.)+pow(ind, 306.)*3.;\n    return lightcol*(.5+pow(ind, 306.)*3.);\n}\n\nvec3 march (vec3 origin, vec3 direction) {\n    bool hit = false;\n    float compoundedd = 0.;\n    float closestDE = 1e10;\n    float rcount = 0.;\n    // usina number as an array of digits =D\n    float rarray = 0.;\n    vec3 finalTX = vec3(1.);\n    for (int i=0; i<200; ++i) {\n        if ((compoundedd>200. || origin.y>16.) && rcount == 0.) {\n            return bg(direction);\n        }\n        float SDFp = SDF(origin);\n        float DE = SDF(origin);\n        if (DE > .1 && DE < 100.) {\n            DE *= .9;\n        }\n        if (SDFp < 1e-2) {\n            origin += direction*(SDFp-1e-4);\n            vec3 objcol = TEXcolor(origin, direction);\n            float shiny = TEXrindex(origin);\n            // if (shiny == 0. && rcount == 0.) {\n            \treturn objcol;\n            // }\n            return objcol*(1.-shiny)+bg(origin)*shiny;\n        }\n        origin += direction*DE;\n        compoundedd += DE;\n    }\n    return bg(direction);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 maus = iMouse.xy;\n    if (maus.x == 0.) {\n        maus.x = iResolution.x/2.;\n    }\n    if (maus.y == 0.) {\n        maus.y = iResolution.y/2.;\n    }\n    vec2 screen = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 dir1 = vec3(screen.x, screen.y, 1.);\n    dir1 = normalize(dir1);\n    float dir1zytheta = atan(dir1.z, dir1.y);\n    float dir1zyr = sqrt(dir1.z*dir1.z+dir1.y*dir1.y);\n    float dir2phi = dir1zytheta+clamp((maus.y-iResolution.y/2.)/iReso\nlution.x*10.+0., -3.14/4.,3.14/2.);\n    dir1.y = dir1zyr*cos(dir2phi);\n    dir1.z = dir1zyr*sin(dir2phi);\n    float dir1zxtheta = atan(dir1.z, dir1.x);\n    float dir1zxr = sqrt(dir1.z*dir1.z+dir1.x*dir1.x);\n    float dir2theta = dir1zxtheta+(maus.x-iResolution.x/2.)/iResolution.x*10./2.*2.;\n    dir1.x = dir1zxr*cos(dir2theta);\n    dir1.z = dir1zxr*sin(dir2theta);\n    \n    vec3 retina = march(vec3(5., 0., iTime*0.-7.), dir1);\n    fragColor = vec4(retina, 1.);\n}\n/**/\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}