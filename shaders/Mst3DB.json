{
    "Shader": {
        "info": {
            "date": "1452073123",
            "description": "Click and move you mouse to move the triangle and see what happens!",
            "flags": 32,
            "hasliked": 0,
            "id": "Mst3DB",
            "likes": 1,
            "name": "The simplest path tracer",
            "published": 3,
            "tags": [
                "raytrace",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "marty1885",
            "viewed": 1178
        },
        "renderpass": [
            {
                "code": "//TODO: Apply FXAA to decrease noise.\n\n#define M_PI           3.14159265358979323846  /* pi */\n#define SAMPLE_NUM 128\n#define MAX_BOUNCE_DEPTH 8\n#define LIGHT_EMIT_STRENGTH 20.0\n#define GAMMA 2.2\n\n//NOTE : NEVER make this over 3. It crashes my AMD HD 7850 GPU.\n#define TRIANGLE_NUM 4\n\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    vec3 up;\n};\n    \nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Triangle\n{\n    vec3 vertex[3];\n    vec3 reflectColor;\n    vec3 emitColor;\n};\n\nTriangle sceneTriangle[TRIANGLE_NUM];\n\nCamera lookAt(vec3 position, vec3 direction, vec3 up)\n{\n    Camera cam;\n    cam.position = position;\n    cam.direction = normalize(direction - position);\n    cam.up = normalize(up);\n    return cam;\n}\n\nRay createRay(vec3 origin, vec3 direction)\n{\n\tRay ray;\n    ray.origin = origin;\n    ray.direction = direction;\n    return ray;\n}\n\nRay createCameraRay(Camera cam, vec2 uv)\n{\n    vec3 right = normalize(cross(cam.direction,cam.up));\n    vec3 direction = cam.direction\n        + cam.up * 2.0 * (uv.y - 0.5)\n        + right * 2.0 * (0.5 - uv.x);\n    Ray ray;\n    ray = createRay(cam.position, direction);\n    return ray;\n}\n\n//return val => mat4 [0] = vec4(u,v,distance,0)\n//\t\t\t\t\t\t \t\t   [1] = vec4(normal,0)\n//\t\t\t\t\t\t \t\t   [2] = vec4(reflectColor,1)\n//\t\t\t\t\t\t \t\t   [3] = vec4(emitColor,1)\nmat4 findIntersection(Ray ray, Triangle triangle)\n{\n\tvec3 v0v1 = triangle.vertex[1] - triangle.vertex[0];\n\tvec3 v0v2 = triangle.vertex[2] - triangle.vertex[0];\n\tvec3 pvec = cross(ray.direction,v0v2);\n\tfloat det = dot(v0v1,pvec);\n\tfloat u, v, t;\n    mat4 intersection;\n\n\t// ray and triangle are parallel if det is close to 0\n\tif(det < 1e-7 && det > -1e-7)\n\t\treturn mat4(-1);\n\n\tfloat invDet = 1.f / det;\n\n\tvec3 tvec = ray.origin - triangle.vertex[0];\n\tu = dot(tvec, pvec) * invDet;\n\tif(u < 0.f || u > 1.f)\n\t\treturn mat4(-1);\n\n\tvec3 qvec = cross(tvec, v0v1);\n\tv = dot(ray.direction, qvec) * invDet;\n\tif(v < 0.f || u + v > 1.f)\n\t\treturn mat4(-1);\n\n\tt = dot(v0v2, qvec) * invDet;\n    \n    mat4 result;\n    result[0] = vec4(u, v, t,0);\n    result[1] = vec4(0, 1, 0,0);\n    result[2] = vec4(triangle.reflectColor,1);\n    result[3] = vec4(triangle.emitColor,1);\n\n    \n\treturn result;\n}\nmat4 findIntersectionScene(Ray ray)\n{\n    mat4 hit;\n    hit[0].z = -1.0;\n    \n    for(int i=0;i<TRIANGLE_NUM;i++)\n    {\n        mat4 hitProp = findIntersection(ray,sceneTriangle[i]);\n        if((hitProp[0].z < hit[0].z || hit[0].z < 0.0) && hitProp[0].z > 0.0)\n        {\n            hit = hitProp;\n        }\n    }\n    return hit;\n}\n\nvec2 randSeed;\nhighp float rand()\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(randSeed.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    highp float val = fract(sin(sn) * c);\n    randSeed = texture(iChannel0,vec2(randSeed)).xy;\n    return val;\n}\n\nRay createRandomReflect(Ray ray, mat4 hit)\n{\n\tvec3 normal = hit[1].xyz;\n\tif(dot(normal,ray.direction) > 0.0)\n    \tnormal = -normal;\n\n    vec3 worldUp = vec3(1,1,0);\n\tvec3 e0 = normalize(normal);\n\tvec3 e1 = normalize(cross(e0,worldUp));\n\tvec3 e2 = normalize(cross(e0,e1));\n\n\t//Create evenly distributed ray\n\t//reference: http://mathworld.wolfram.com/SpherePointPicking.html\n\n    float phi = rand()*M_PI*2.0;\n\tfloat x = rand();\n\tfloat theta = abs(acos(x));//NOTE : sometimes acos will give a small negiative number.\n\tvec3 direction = normalize(sin(theta)*cos(phi)*e1 +\n\t\tsin(theta)*sin(phi)*e2 +\n\t\tabs(cos(theta))*e0);\n\n    vec3 intersection = normalize(ray.direction)*hit[0].z + ray.origin;\n\tvec3 origin = intersection\n\t\t+direction*0.0001; //workaround float point accuracy issue\n    \n\tRay reflect = createRay(origin, direction);\n\treturn reflect;\n}\n\nvec3 trace(Ray ray)\n{\n    Ray currentRay = ray;\n    vec3 renderedColor = vec3(0,0,0);\n    vec3 factor = vec3(1,1,1);\n    \n    for(int i=0;i<MAX_BOUNCE_DEPTH;i++)\n    {\n        mat4 hit = findIntersectionScene(currentRay);\n        if(hit[0].z > 0.0)\n        {\n            renderedColor += hit[3].xyz*factor;\n            factor *= hit[2].xyz;\n            currentRay = createRandomReflect(ray,hit);//Ideal Deffuse BRDF\n        }\n        else\n            break;\n    }\n    \n    return renderedColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //create a Camera\n    Camera camera = lookAt(vec3(0,4.0,7.0),vec3(0,0.0,0.0),vec3(0,1,0));\n    \n    //Initlaze rand() using uv coord\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    randSeed = uv;\n    \n    Ray ray = createCameraRay(camera,uv);\n    \n    //TODO : Move the scene initlization to a  buffer so we onlt need to init it once.\n    vec2 mouseUV = iMouse.xy/iResolution.xy - vec2(0.5);\n    mouseUV *= M_PI * 2.0;\n    vec3 offset = vec3(mouseUV.x,mouseUV.y,0);\n    if(offset.y < -2.3)\n        offset.y = -2.29999;\n    if(iMouse.x == 0.0)\n        offset = vec3(0,0,0);\n    \n    //Big Plain\n    sceneTriangle[0].vertex[0] = vec3(100,-2,-5);\n    sceneTriangle[0].vertex[1] = vec3(-100,-2,-100);\n    sceneTriangle[0].vertex[2] = vec3(-5,-2,100);\n    sceneTriangle[0].reflectColor = vec3(1,1,1);\n    sceneTriangle[0].emitColor = vec3(0,0,0);\n   \n    //Light Source\n    sceneTriangle[1].vertex[0] = vec3(-1.7,1,1.7);\n    sceneTriangle[1].vertex[1] = vec3(-1.7,1,0);\n    sceneTriangle[1].vertex[2] = vec3(0,1,0);\n    sceneTriangle[1].reflectColor = vec3(1,1,1);\n    sceneTriangle[1].emitColor = vec3(0.8,0.7,0.65)*LIGHT_EMIT_STRENGTH;\n\n    //Small triangle\n    sceneTriangle[2].vertex[0] = vec3(-2.0,0.3,2.0) + offset;\n    sceneTriangle[2].vertex[1] = vec3(-2.0,0.3,0) + offset;\n    sceneTriangle[2].vertex[2] = vec3(0,0.3,0) + offset;\n    sceneTriangle[2].reflectColor = vec3(1,1,1);\n    sceneTriangle[2].emitColor = vec3(0,0,0);\n    \n    //Light Source2\n    sceneTriangle[3].vertex[0] = vec3(-1.7,1,1.7);\n    sceneTriangle[3].vertex[1] = vec3(0,1,1.7);\n    sceneTriangle[3].vertex[2] = vec3(0,1,0);\n    sceneTriangle[3].reflectColor = vec3(1,1,1);\n    sceneTriangle[3].emitColor = vec3(0.8,0.7,0.65)*LIGHT_EMIT_STRENGTH;\n    \n    vec3 renderColor = vec3(0,0,0);\n    for(int i=0;i<SAMPLE_NUM;i++)\n    \trenderColor += trace(ray);//Recursize Path tracing\n    renderColor /= float(SAMPLE_NUM);\n    \n    //Gamma correction\n    renderColor = pow(renderColor,vec3(1.0/GAMMA));\n    \n    fragColor = vec4(renderColor,0.0);\n}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Generate a random texture\nvec2 randSeed;\nhighp float rand()\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(randSeed.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    highp float val = fract(sin(sn) * c);\n    randSeed.x = val;\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    randSeed = uv;\n    fragColor = vec4(rand(),rand(),0.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}