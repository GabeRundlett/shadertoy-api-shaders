{
    "Shader": {
        "info": {
            "date": "1703080333",
            "description": "How many coronas can you do around one given tile ?\nMouse click + drag tile, Mouse.x + SPACE to rotate.\nAnswer here: https://shadertoy.com/view/Mcf3D4\nref: https://en.wikipedia.org/wiki/Heesch%27s_problem\n",
            "flags": 48,
            "hasliked": 0,
            "id": "4clGW4",
            "likes": 18,
            "name": "corona tilings / Heesch problem2",
            "published": 3,
            "tags": [
                "tiling",
                "puzzle",
                "short",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 377
        },
        "renderpass": [
            {
                "code": "// interactive variant of https://shadertoy.com/view/Mcf3D4\n\n#define S(v) smoothstep(20./R.y,0., v)           // AA draw\n\nfloat M(vec2 U, float a) {                       // --- tear-shape tile SDF\n    U *= 8.* mat2(cos( a - vec4(0,33,11,0)));    // local frame â†’ to peak direction\n    U.y = abs(U.y);                              // tear symmetry\n    float l = length(U);\n    return U.x/l < .867 || l*l > 3. \n      ? l  - 1.                                  // circle part\n      : 1. - length( U - vec2(1.732,1) );        // peak part\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / R.y;\n         \n    float d = 9.;\n    for(int i; i<12; i++)                        \n        d = min( d, M( U - T(i).xy, T(i).z ) );  // find tile closest to the pixel\n                                        \n    O = vec4( max( S( abs(d) ) ,                 // outline\n                   .5 * S(d) ) );                // fill\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// === manage tiles. .xy = pos, .z = angle, .w = edit\n\n#define keyDown(a)  ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    int i = int(u), k, j;\n    if ( i > 11 || u.y > 1. ) return;                // we manage 12 tiles\n    \n    O = iFrame < 1                                   // init: tile on grid, random angle\n        ? vec4( vec2(i%4, i/4)/vec2(3,2)*(R/R.y-.3)+.15, float(i*16807%31)*6.28/31., 0 )\n        : T(i);                                      // previous state\n        \n    if ( iMouse.z > 0. ) {                           // mouse pressed\n        vec2 M = iMouse.xy / R.y;\n        if ( iMouse.w > 0. ) {                       // on click\n            float d = 9., l;\n            for(; k<12; k++ ) {\n                l = length( M - T(k).xy );           // find tile closest to mouse\n                if ( l < d ) j = k, d = l;\n            }\n            O.w = float( j == i && d < .125 );       // set edit mode for the closest ( if under mouse )\n        }\n        if( O.w == 1. )                              // tile in edit mode:\n            if ( keyDown(32) )   \n                 O.z -= .05* ( M.x - T(i).x );       //   SPACE pressed: tilt angle\n            else O.xy = M;                           //   else: follow mouse\n     }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define T(i) texelFetch( iChannel0, ivec2(i,0), 0 )\n#define R    iResolution.xy\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}