{
    "Shader": {
        "info": {
            "date": "1607236489",
            "description": "Study Raymarching",
            "flags": 96,
            "hasliked": 0,
            "id": "WdGfWw",
            "likes": 3,
            "name": "Raymarching_test_5",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "RisingMoon",
            "viewed": 351
        },
        "renderpass": [
            {
                "code": "vec4 tex0(vec2 uv){\n    return texture(iChannel0,uv);\n}\n\nvec4 tex1(vec2 uv){\n    return texture(iChannel1,uv);\n}\n\nvec4 tex2(vec2 uv){\n    return texture(iChannel2,uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 fColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 color0 = tex0(uv);\n    fColor.rgb = mix(fColor.rgb, color0.rgb, color0.a * pow(REFLECT_COEFFICIENT, 0.0));\n    vec4 color1 = tex1(uv);\n    fColor.rgb = mix(fColor.rgb, color1.rgb, color1.a * pow(REFLECT_COEFFICIENT, 1.0));\n    vec4 color2 = tex2(uv);\n    fColor.rgb = mix(fColor.rgb, color2.rgb, color2.a * pow(REFLECT_COEFFICIENT, 2.0));\n\n    fragColor = fColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 24815,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/woe-magnumopus/soft-music-to-relax-morning"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//最远视距\nfloat FAR = 100.0;\n//最近视距\nfloat NEAR = 1.0;\n//最大检测次数\nconst int MAX_MARCHING_TIMES = 355;\n//阴影检测次数\nconst int SHADOW_MARCHING_TIMES = 30;\n//反射检测次数\nconst int REFLECT_MARCHING_TIMES = 128;\n//阴影最远距离\nfloat MAX_SHADOW_DISTANCE = 5.0;\n//最小float\nconst float MIN_FLOAT = 0.001;\n//反射系数\nfloat REFLECT_COEFFICIENT = 0.25;\n\n//物体间距\nfloat spacing = 0.0;\n//环境光颜色\nvec3 ambient = vec3(0.3, 0.3, 0.4);\n//视角位置\nvec3 eyePos = vec3(10.0, 5.0, 0.0);\n//摄像机速度\nfloat cameraSpeed = 5.0;\n\n//点光源\nstruct pointLight{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n\n//球型的SDF公式\nfloat sphereSdf(vec3 pos){\n    //圆形半径\n    float sphereRadius = 1.0;\n    return length(pos) - sphereRadius;\n}\n\n//圆柱的SDF公式\nfloat cylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n//心的SDF公式\nfloat heartSdf(vec3 pos){\n    pos -= vec3 (spacing, 0.0, -spacing);\n    vec3 bound = vec3(1.0, 1.0, 1.0);\n    vec3 q = abs(pos) - bound;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//旋转\nvec3 pR(vec3 p, float a) {\n\treturn cos(a)*p + sin(a)*vec3(p.y, -p.x,0.0);\n}\n\n//场景的SDF公式\nfloat sceneSdf(vec3 pos){\n    float result = cylinder(pR(pos,15.0),1.0,1.0);\n    return result;\n    \n    //float result = min(sphereSdf(pos), sdTorus(pos));\n    //result = min(result, sdOctahedron(pos));\n    //result = min(result, boxSdf(pos));\n    //result = min(result, box1Sdf(pos));\n    //result = min(result, sdCone(pos));\n}\n\n//眼睛到最近表面的最短距离\nfloat rayMarchingDistance(vec3 eye, vec3 direction, float start, float end){\n    // 检测的距离\n    float depth = start;\n    for (int i = 0;i < MAX_MARCHING_TIMES;i++){\n        //从眼睛出发的射线\n        float dist = sceneSdf(eye + direction * depth);\n        if (abs(dist) < MIN_FLOAT){\n            return depth;\n        }\n        depth += dist;\n        if (dist >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\n//射线检测\nfloat rayCast(vec3 eye, vec3 direction, float start, float end){\n    // 检测的距离\n    float depth = start;\n    for (int i = 0;i < REFLECT_MARCHING_TIMES;i++){\n        //从眼睛出发的射线\n        float dist = sceneSdf(eye + direction * depth);\n        if (abs(dist) < MIN_FLOAT){\n            return depth;\n        }\n        depth += dist;\n        if (dist >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\n//阴影检测\nfloat softShadow(vec3 startPos, vec3 lightDir, out float depth){\n    // 检测的距离\n    depth = NEAR;\n    for (int i = 0;i < SHADOW_MARCHING_TIMES;i++){\n        //从眼睛出发的射线\n        float dist = sceneSdf(startPos + lightDir * depth);\n        if (abs(dist) < MIN_FLOAT){\n            break;\n        }\n        depth += dist;\n        if (dist >= MAX_SHADOW_DISTANCE){\n            depth = MAX_SHADOW_DISTANCE;\n            break;\n        }\n    }\n    \n    float coefficient = step(MAX_SHADOW_DISTANCE, depth);\n    return coefficient;\n}\n\n//获取从像素出发的所有方向\nvec3 getDirectionByPixel(float fov, vec2 size, vec2 fragCoord){\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//法线\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n    sceneSdf(vec3(p.x + MIN_FLOAT, p.y, p.z)) - sceneSdf(vec3(p.x - MIN_FLOAT, p.y, p.z)),\n    sceneSdf(vec3(p.x, p.y + MIN_FLOAT, p.z)) - sceneSdf(vec3(p.x, p.y - MIN_FLOAT, p.z)),\n    sceneSdf(vec3(p.x, p.y, p.z  + MIN_FLOAT)) - sceneSdf(vec3(p.x, p.y, p.z - MIN_FLOAT))\n    ));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\n//视角矩阵\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = normalize(cross(s, f));\n    return mat3(s, u, -f);\n    //\tvec4(s, 0.0),\n    //\tvec4(u, 0.0),\n    //\tvec4(-f, 0.0),\n    //\tvec4(0.0, 0.0, 0.0, 1)\n    //\t);\n}\n\n//添加点光源\nvec3 addPointLight(pointLight light, vec3 modelColor, vec3 pos, vec3 normal, vec3 viewDir){\n    vec3 lightPos = light.pos;\n    vec3 lightColor = light.color;\n    float lightIntensity = light.intensity;\n\n    float specularCoefficient = 0.6;\n\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 reflectDir = normalize(reflect(-lightDir, normal));\n\n    float NdotL = dot(normal, lightDir);\n    float NdotV = dot(normal, viewDir);\n    float VdotR = dot(viewDir, reflectDir);\n\n    vec3 diffuse = modelColor * lightColor * max(0.0, NdotL);\n    vec3 specular = specularCoefficient * lightColor * pow(max(0.0, VdotR), 10.0);\n    //计算阴影\n    float dist;\n    float shadow = softShadow(pos, lightDir, dist);\n\n\n    //光照颜色\n    vec3 color = diffuse + specular;\n    //光源强度\n    color *= max(0.0, 1.0 - distance(lightPos, pos)/lightIntensity);\n    //阴影\n    color *= shadow;\n\n    return color;\n}\n\n//添加方向光\nvec3 addDirectionalLight(vec3 lightDir, vec3 lightColor, float lightIntensity, vec3 modelColor,\nvec3 pos, vec3 normal, vec3 viewDir){\n    //反射系数\n    float specularCoefficient = 0.6;\n\n    vec3 reflectDir = normalize(reflect(-lightDir, normal));\n\n    float NdotL = dot(normal, lightDir);\n    float NdotV = dot(normal, viewDir);\n    float VdotR = dot(viewDir, reflectDir);\n\n    vec3 diffuse = modelColor * lightColor * max(0.0, NdotL);\n    vec3 specular = specularCoefficient * lightColor * pow(max(0.0, VdotR), 10.0);\n    //计算阴影\n    float dist;\n    float shadow = softShadow(pos, lightDir, dist);\n\n    //光照颜色\n    vec3 color = diffuse + specular;\n    //光源强度\n    color *= lightIntensity;\n    //阴影\n    color *= shadow;\n\n    return color;\n}\n\n//绘制点光源\nvec3 drawPointLight(pointLight light, vec3 eye, vec3 dir){\n    vec3 lightDir = normalize(light.pos - eye);\n    float LdotD = dot(lightDir, dir);\n    vec3 color = light.color * step(0.9997, LdotD);\n    return color;\n}\n\n//获取反射位置\nvoid reflectAll(inout vec3 viewDir, inout vec3 eye, inout vec3 normal, inout vec3 pos, inout float distance){\n    vec3 reflectDir = reflect(viewDir, normal);\n    float reflectDist = rayCast(pos, reflectDir, NEAR, 30.0);\n    //\trayCast(pos, reflectDir, distance);\n    vec3 reflectPos = pos + reflectDir * reflectDist;\n    eye = pos;\n    viewDir = reflectDir;\n    normal = estimateNormal(reflectPos);\n    pos = reflectPos;\n    distance = reflectDist;\n}\n\nvec4 screenBuffer(vec3 iResolution,float iTime,vec2 fragCoord, float reflectTimes){\n    //还原可视坐标\n    vec3 dir = getDirectionByPixel(90.0, iResolution.xy, fragCoord);\n    vec3 eye = eyePos;\n    mat3 viewMatrix = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    dir = viewMatrix * dir;\n    float dist = rayMarchingDistance(eye, dir, NEAR, FAR);\n    vec3 pos = eye + dir * dist;\n    vec3 normal = estimateNormal(pos);\n    vec3 viewDir = dir;\n\n    for (float i = 0.0;i < 2.0;i+=1.0){\n        if (i > reflectTimes-MIN_FLOAT){\n            break;\n        }\n        float distance = 30.0/i;\n        reflectAll(viewDir, eye, normal, pos, distance);\n        dist = distance;\n        if (dist > 30.0 - MIN_FLOAT){\n            return vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    }\n\n\n    vec3 modelColor = vec3(1.0, 1.0, 1.0);\n    vec3 bgColor = vec3(0.0, 0.0, 0.1);\n\n    //点光源\n    pointLight pointLights[3];\n    pointLights[0] = pointLight(vec3 (sin(iTime/2.0 + radians(120.0))*7.0, 3.0, cos(iTime/2.0 + radians(120.0))*7.0), vec3(1.0, 0.0, 0.0), 20.0);\n    pointLights[1] = pointLight(vec3 (sin(iTime/2.0 + radians(240.0)) * 7.0, 3.0, cos(iTime/2.0 + radians(240.0)) * 7.0), vec3(0.0, 0.0, 1.0), 20.0);\n    pointLights[2] = pointLight(vec3 (sin(iTime/2.0) * 7.0, 3.0, cos(iTime/2.0) * 7.0), vec3(0.0, 1.0, 0.0), 20.0);\n\n    vec3 lightColor0 = addPointLight(pointLights[0], modelColor, pos, normal, viewDir);\n    vec3 lightColor1 = addPointLight(pointLights[1], modelColor, pos, normal, viewDir);\n    vec3 lightColor2 = addPointLight(pointLights[2], modelColor, pos, normal, viewDir);\n\n    //方向光\n    //    vec3 directionalLight0 = addDirectionalLight(normalize(vec3(1.0, 1.0, 1.0)), vec3(1.0, 1.0, 1.0), 0.1, modelColor, pos, normal, viewDir);\n    //\tvec3 directionalLight1 = addDirectionalLight(normalize(vec3(-1.0, 1.0, -1.0)), vec3(1.0, 1.0, 1.0), 0.2, modelColor, pos, normal, viewDir);\n\n\n\n    vec3 color = ambient;\n    color += lightColor0;\n    color += lightColor1;\n    color += lightColor2;\n    //    color += directionalLight0;\n    //\tcolor += directionalLight1;\n\n    if (dist > FAR - MIN_FLOAT){\n        color = bgColor;\n    }\n\n    //绘制虚拟点光源\n    vec3 drawLight1 = drawPointLight(pointLights[0], eye, viewDir);\n    vec3 drawLight2 = drawPointLight(pointLights[1], eye, viewDir);\n    vec3 drawLight3 = drawPointLight(pointLights[2], eye, viewDir);\n    color.xyz += drawLight1;\n    color.xyz += drawLight2;\n    color.xyz += drawLight3;\n\n    return vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n    eyePos = vec3(cos(radians(mouse.x * 180.0 + iTime * cameraSpeed)) * 10.0, 5.0, sin(radians(mouse.x * 180.0 + iTime * cameraSpeed)) *10.0);\n    eyePos += eyePos * mouse.y * 0.7;\n    \n    vec4 color = screenBuffer(iResolution,iTime,fragCoord, 0.0);\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n    eyePos = vec3(cos(radians(mouse.x * 180.0 + iTime * cameraSpeed)) * 10.0, 5.0, sin(radians(mouse.x * 180.0 + iTime * cameraSpeed)) *10.0);\n    eyePos += eyePos * mouse.y * 0.7;\n    \n    vec4 color = screenBuffer(iResolution,iTime,fragCoord, 1.0);\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n    eyePos = vec3(cos(radians(mouse.x * 180.0 + iTime * cameraSpeed)) * 10.0, 5.0, sin(radians(mouse.x * 180.0 + iTime * cameraSpeed)) *10.0);\n    eyePos += eyePos * mouse.y * 0.7;\n    \n    vec4 color = screenBuffer(iResolution,iTime,fragCoord, 2.0);\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}