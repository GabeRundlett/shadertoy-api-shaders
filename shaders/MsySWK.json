{
    "Shader": {
        "info": {
            "date": "1466948852",
            "description": "Raymarching a 2D Sierpinski Carpet pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsySWK",
            "likes": 72,
            "name": "Raymarched 2D Sierpinski",
            "published": 3,
            "tags": [
                "raymarch",
                "heightmap",
                "environment",
                "sierpinski"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 5726
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRaymarched 2D Sierpinski\n\t------------------------\n\n\tRaymarching a 2D Sierpinski Carpet pattern. The raymarching process is pretty straight\n\tforward. Basically, Sierpinski height values are added to a plane. Height maps with \n\tsharp edges don't raymarch particularly well, so a little edge smoothing was necessary,\n\tbut that's about it.\n\n\tThe rest is just lighting. Most of it is made up. A bit of diffuse, specular, fake \n\tenvironment mapping, etc.\n\t\n\n*/\n\n#define FAR 5.\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Sierpinski Carpet heightmap - Essentially, space is divided into 3 each iteration, \n// and a shape of some kind is rendered. In this case, it's a smooth edged rectangle (w)\n// with a bit of curvature (l) around the sides.\n//\n// There are some opportunites to optimize, but I'll leave it partly readable for now.\n//\nfloat heightMap(vec2 p){\n    \n    p /= 2.; // Extra scaling.\n    \n    float  h = 0., a = 1., sum = 0.; // Height, amplitude, sum.\n    \n    for(int i=0; i<4; i++){\n    \n        p = fract(p)*3.; // Subdividing space.\n        // Far more interesting, mutated subdivision, courtesy of Aiekick.\n        //p = fract(p+sin(p.yx*9.)*0.025 + cos(p.yx*9.)*0.025)*3.; \n        // Another one with a time component.\n        //p = fract(p + sin(p*9. + cos(p.yx*13. + iTime*2.))*0.02)*3.;\n        \n        vec2 w = .5 - abs(p - 1.5); // Prepare to make a square. Other shapes are also possible.\n        float l = sqrt( max(16.0*w.x*w.y*(1.0-w.x)*(1.0-w.y), 0.))*.5+.5; // Edge shaping.\n        w = smoothstep(0., .05, w); // Smooth edge stepping.\n        h = max(h, w.x*w.y*a*l); // Producing the smooth edged, shaped square.\n        //h += w.x*w.y*a*l;\n        //h = max(h, abs(abs(w.x)-abs(w.y))*a*l);\n        sum += a; // Keep a total... This could be hardcoded to save cycles.\n        a *= .4; // Lower the amplitude for the next subdivision, just because it looks tidier.\n        //if(i==2)a*=.75;\n    }\n    \n    return h/sum;\n    \n}\n\n// Raymarching a heightmap on an XY-plane. Pretty standard.\nfloat map(vec3 p){\n\n    // Cheap, lame distortion, if you wanted it.\n    //p.xy += sin(p.xy*7. + cos(p.yx*13. + iTime))*.01;\n    \n    // Back plane, placed at vec3(0, 0, 1), with plane normal vec3(0., 0., -1).\n    // Adding some height to the plane from the heightmap. Not much else to it.\n    return 1. - p.z - heightMap(p.xy)*.125;\n    \n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Standard normal function.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 3., occ = 0.;\n    for(int i=0; i<5; i++){\n    \n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    // Note that the ray is starting just above the raised plane, since nothing is\n    // in the way. It's normal practice to start at zero.\n    float d, t = 0.75; \n    for(int j=0;j<32;j++){\n      \n        d = map(ro + rd*t); // distance to the function.\n        // The plane \"is\" the far plane, so no far=plane break is needed.\n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n\n        t += d*.7; // Total distance from the camera to the surface.\n    \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// It gives you a scalar curvature value for an object's signed distance function, which \n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n// calculations, I'm assuming. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = 0.02, amp = 8., ampInit = 0.6;\n\n    vec2 e = vec2(-1., 1.)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 envMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit directional ray with no divide, courtesy of Coyote.\n    vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n    \n    // Rotating the XY-plane back and forth, for a bit of variance.\n    // 2D rotation with fewer instructions, courtesy of Fabrice Neyret.\n    vec2 a = sin(vec2(1.570796, 0) - sin(iTime/4.)*.3);\n    rd.xy = rd.xy*mat2(a, -a.y, a.x);\n    \n    \n    // Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(iTime, cos(iTime/4.), 0.);\n    \n    \n    // Light position, hovering around camera.\n    vec3 lp = ro + vec3(cos(iTime/2.)*.5, sin(iTime/2.)*.5, -.5);\n    \n    // Standard raymarching segment. Because of the straight forward setup, not many \n    // iterations are needed.\n \tfloat t = trace(ro, rd);\n    \n   \n    // Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp);\n    \n    \n\t// Texture scale factor.\n    const float tSize0 = 1./2.;\n    // Texture-based bump mapping.\n\tsn = doBumpMap(iChannel0, sp*tSize0, sn, 0.002);    \n    \n    \n    // Point light.\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light distance.\n    float atten = 1./(1. + lDist*lDist*.125); // Light attenuation.\n    ld /= lDist; // Normalizing the light direction vector.\n    \n   // Obtaining the surface texel, then ramping up the contrast a bit.\n    vec3 oC = smoothstep(0., 1., tex3D(iChannel0, sp*tSize0, sn));\n    // Using the height map to highlight the raised squares. Not for any particular reason.\n    oC *= smoothstep(0., .125, heightMap(sp.xy))*1.5 + .5;\n\n    \n    float diff = max(dot(ld, sn), 0.); // Diffuse.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.); // Specular.\n    float fre = clamp(dot(sn, rd) + 1., .0, 1.); // Fake fresnel, for the glow.\n    \n    // Shading. Note, there are no actual shadows. The camera is front on, so the following\n    // two functions are enough to give a shadowy appearance.\n    float crv = curve(sp); // Curve value, to darken the crevices.\n    float ao = calculateAO(sp, sn); // Ambient occlusion, for self shadowing.\n \n    \n    // Combining the terms above to light the texel.\n    vec3 col = (oC*(diff + .25) + vec3(1, .7, .3)*spec) + vec3(.1, .3, 1)*pow(fre, 4.)*4.;\n    \n    col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.; // Fake environment mapping.\n    //col += envMap(reflect(rd, sn), sn)*4.;\n    \n    // Applying the shades.\n    col *= (atten*crv*ao);\n    \n    // Vignette.\n    vec2 uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125);\n\n    \n    // Presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}