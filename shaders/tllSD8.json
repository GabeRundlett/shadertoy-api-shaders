{
    "Shader": {
        "info": {
            "date": "1562786282",
            "description": "Practice reflection ",
            "flags": 0,
            "hasliked": 0,
            "id": "tllSD8",
            "likes": 4,
            "name": "Reflection party",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "menger"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 562
        },
        "renderpass": [
            {
                "code": "float bpm =125.;\nfloat pi =acos(-1.);\nconst int nu =6;\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q = abs(p);\n\tvec3 kv = max(s-q,0.0);\n\treturn length(max(q-s,0.0))-min(min(kv.x,kv.y),kv.z);\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np =2.0*pi/n;\n\tfloat r = atan(p.x,p.y)+0.5*np;\n\tr = mod(r,np)-0.5*np;\n\treturn length(p.xy)*vec2(sin(r),cos(r));\n}\n\nfloat cro(vec3 p,float s){\n\tvec3 q =abs(p);\n\t\n\tvec3 km = max(vec3(s)-q,0.0);\n\treturn min( -min(km.y,km.x),min(-min(km.z,km.y),-min(km.z,km.x)));\n}\n\nfloat nPrism(vec3 p,vec2 h,float n,float s){\n\tfloat np =pi*2.0/n;\n\tfloat r = atan(p.x,p.y);\n\tr = mod(r,np)-0.5*np;\n\tvec2 kp = length(p.xy)*vec2(cos(r),sin(r));\n\tvec3 kv = vec3(abs(kp.x)-h.x,abs(kp.y)-s*h.x*tan(np*0.5),abs(p.z)-h.y);\n\tfloat d = length(vec2(max(kv.x,0.0),max(kv.y,0.0)));\n\treturn length(vec2(d,max(kv.z,0.0)))-min(min(max(-kv.x,0.0),max(-kv.y,0.0)),max(-kv.z,0.0));\n}\n\nvec2 rot (vec2 p,float r){\n\tmat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n\treturn m*p;\n}\nvec3 hsv(vec3 c){\n\treturn ((clamp(abs(fract(c.x+vec3(0.,1.,2.)/3.)*6.-3.)-1.,0.0,1.0)-1.)*c.y+1.)*c.z;\n}\nfloat menger (vec3 p){\n\tvec3 pm =p;\n\tp.xz = rot(p.xz,iTime);\n\tp.zy =rot(p.yz,iTime);\n    float bt0 =pow(abs(sin(iTime*(bpm*pi/60.))),10.0);\n\tfloat s =1.+bt0*0.3;\n\tfloat d = cube(p,vec3(s));\n\tfloat k =s*2.0;\n\tfloat d1 ;\n\tfloat d2 =99999.;\n  \n\tfloat bt =  1./6.*(clamp(abs(sin(0.05*iTime*(120.*pi/60.))),0.2,0.8)-0.2);\n\tfor(int i =0;i <4;i++){\n\ts/=3.0;\n\tvec3 sn =sign(p);\n\t//p.xy = rot(p.xy,bt)*sn.xy;\n\t//p.xz = rot(p.xz,bt)*sn.xz;\n\td1 = cro(p,s);\n\tk/=3.0+6.*bt+0.3*bt0;\n\tp =mod(p+0.5*k+sn*bt,k)-0.5*k;\n\td1 = min(d1,d2);\n\td2 =d1;\n\t}\n\tpm.y =-abs(pm.y);\n\tpm.yz = rot(pm.yz,0.5*pi);\n\tpm.z +=13.5; \n\tvec2 kn =1.1*vec2(1.1,1.7);\n\tvec3 pm2 =pm;\n\tvec2 id1  = floor(pm.xy/kn)*kn-kn*0.5;\n\tpm.xy=mod(pm.xy,kn)-kn*0.5;\n\tfloat knt =0.1;\n\tfloat bt2 =  0.2*pow(abs(sin(-0.25*length(id1)+knt+iTime*(bpm*pi/60.))),10.0);\n\tfloat d3 = nPrism(pm,vec2(0.5,10.5-bt2),6.0,1.0-3.5*bt2);\n\tpm2.xy +=kn*0.5;\n\tvec2 id2  = floor(pm2.xy/kn)*kn-kn*0.5;\n\tpm2.xy=mod(pm2.xy,kn)-kn*0.5;\n\tfloat bt3 =  0.2*pow(abs(sin(-0.25*length(id2)+knt+iTime*(bpm*pi/60.))),10.0);\n\td3 = min(d3,nPrism(pm2,vec2(0.5,10.5-bt3),6.0,1.0-3.5*bt3));\n\treturn min(d3,max(d,-d1));\n}\nvec4 spheres(vec3 p,float s){\n\tfloat kt =iTime*2.;\n\tfloat ra =3.0;\n\tfloat ds;\n\tfloat ds2 =999.;\n\t const int kn =nu;\n\tfloat fkn = float(kn);\n  \tvec3 col =vec3(0.0);;\n\tfor(int i=0;i<kn;i++){\n\tfloat fi =float(i);\n\tvec3 ap = vec3(ra*cos(kt+pi*fi*2./fkn),0.,ra*sin(kt+pi*fi*2./fkn));\n\tds = length(p-ap);\n    \tcol +=exp(-6.*ds)*hsv(vec3(0.0+fi*1./3.0,0.8,1.0));\n   \tds = length(p-ap)-s;\n\tds =min(ds,ds2);\n\tds2 =ds;\n\t}\n\tp.xz = pmod(p.xz,20.);\n\tfloat pky =2.2;\n\tp.y = mod(p.y,pky)-0.5*pky;\n\tfloat pkz =12.;\n\tfloat mpz = p.z; \n\tp.z = mod(p.z-iTime*pkz*bpm/60.,pkz)-0.5*pkz;\n\t\t\n\tfloat dcs =length(vec2(length(p.xy),max(abs(p.z)-0.1,0.0)));\n\tvec3 lecol = exp(-26.*dcs)*vec3(1.);\n\tfloat far =30.;\n\tfloat near =3.;\n\t\n\tlecol = mix(vec3(0.),lecol,clamp((far-mpz)/(far-near),0.0,1.0));\n\tcol +=lecol;\n\tds = min(ds,dcs);\n\treturn vec4(col,ds);\n}\nfloat dist (vec3 p){\n\t\n\tfloat d =menger(p);\n\t\n\treturn d;\n}\nvec3 gn(vec3 p){\n    vec4 n = vec4(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += 0.0001;\n        n[i] = dist(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n}\n\nfloat shadow(vec3 p,vec3 rd,float hn){\n\tfloat d;\n\tfloat t =0.0001;\n\tfloat res =1.0;\n\tfor(int i =0;i<16;i++){\n\t\td = menger(p+rd*t);\n\t\tres = min(res,hn*d/t);\n\t\tt += clamp(d,0.2,1.0);\n\t}\n\treturn res;\n\t\t\n}\n\nvec3 lighting(vec3 p,vec3 rd){\n\tvec3 n = gn(p);\n\tvec3 col =vec3(0.0);\n\tvec3 ld;\n\tfloat kt =iTime*2.;\n\tfloat ra =3.0;\n\tfloat md = menger(p);\n\t\n\tconst int kn =nu;\n\tfloat fkn = float(kn);\n\t\t\n\tif(md<0.01){\n\t\t\n\t\tfor(int i=0;i<kn;i++){\n\t\t\tfloat fi =float(i);\n\t\t\tld = normalize(vec3(ra*cos(kt+pi*fi*2./fkn),0.,ra*sin(kt+pi*fi*2./fkn))-p);\n\t\t\tfloat ndl = max(dot(n,ld),0.0);\n\t\t\tvec3 R = normalize(-ld+2.*n*ndl);\n\t\t\tfloat spec = pow(max(dot(R,-rd),0.0)*sign(ndl),15.);\n\t\t\tvec3 adcol = vec3(ndl*0.4+spec)*hsv(vec3(0.0+fi*1./3.0,1.0,1.0));\n\t\t\tfloat sha = shadow(p+n*0.001,ld,16.);\n\t\t\tcol +=adcol*sha;\n\t\t}\n\t}\n\treturn col;\n}\n\nvec3 draw(vec3 ro,vec3 rd){\n\tfloat t =0.001;\n\tfloat d =0.;\n\tfloat hit =0.001;\n\tvec3 ac =vec3(0.0);\n\tfor(int i =1;i<99;i++){\n\t\td =dist(ro+rd*t);\n        vec4 s4 = spheres(ro +rd*t,0.);\n\t\tt+=min(d,s4.w);\n\t\tac += s4.xyz;\n\t\tif(d<hit||t>1000.)break;\n\t}\n\tvec3 bgcol =vec3(0.,0.,0.);\n\tvec3 col = vec3(0.);\n\tfloat far =30.;\n\tfloat near =3.;\n\tcol = lighting(ro+rd*t,rd);\n\t\n\t\n\t\n\tvec3 pm = ro+rd*t;\n\tvec3 normal = gn(ro+rd*t);\n\tvec3 rerd = normalize(-rd+normal*max(dot(normal,-rd),0.0)*2.);\n\tfloat ret =0.001;\n\tfloat red =0.;\n\tvec3 reac =vec3(0.);\n\tfor(int i =1;i<39;i++){\n\t\td =dist(pm+rerd*ret);\n        \tvec4 s4 = spheres(pm +rerd*ret,0.);\n\t\tret+=min(d,s4.w);\n\t\treac += s4.xyz;\n\t\tif(d<hit||t>1000.)break;\n\t}\n\tvec3 recol =vec3(0.);\n\trecol = lighting(pm+rerd*ret,rerd);\n\trecol +=0.4*reac;\n\tcol =0.6*col+recol ;\n\tcol = mix(bgcol,col,clamp((far-t)/(far-near),0.0,1.0));\n\treturn col+0.4*ac;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ( fragCoord.xy / iResolution.xy ) -0.5;\n\tp.y *= iResolution.y/iResolution.x;\n\tfloat kt =-iTime*0.8;\n\tfloat ra =10.0+2.0*sin(iTime);\n\tvec3 ro = vec3(ra*cos(kt),0.4,ra*sin(kt));\n\tvec3 ta =vec3(0.,-0.6,0.);\n\tvec3 cdir = normalize(ta-ro);\n\tvec3 up = vec3(0.,1.,0.);\n\tvec3 side = cross(cdir,up);\n\tup = cross(side,cdir);\n\tfloat fov =0.9;\n\tvec3 rd =normalize(up*p.y+side*p.x+cdir*fov);\n\tvec3 col;\n\tcol = draw(ro,rd);\n\tfragColor = vec4(col, 1.0 );\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}