{
    "Shader": {
        "info": {
            "date": "1584628968",
            "description": "Tracking 4 closest particles and the 2 side particles which make a voronoi edge. Allows for advanced voronoi stuff: interpolation and physics. Also as it turns out edge tracking implicitly also holds the Delaunay triangulation.",
            "flags": 32,
            "hasliked": 0,
            "id": "WsXcWH",
            "likes": 13,
            "name": "Voronoi edge tracking II",
            "published": 3,
            "tags": [
                "particles"
            ],
            "usePreview": 1,
            "username": "michael0884",
            "viewed": 892
        },
        "renderpass": [
            {
                "code": "// Fork of \"Quadruple voronoi diagram\" by michael0884. https://shadertoy.com/view/tdscRr\n// 2020-03-17 19:00:53\n\n\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 grad(ivec2 p)\n{\n    ivec4 sp = get(p);\n    ivec4 spx = get(p+ivec2(1,0));\n    ivec4 spy = get(p+ivec2(0,1));\n    return tanh(100.*(abs(vec4(spx - sp)) + abs(vec4(spy - sp))));\n}\n\nivec4 getve(ivec2 p)\n{\n    return floatBitsToInt(texel(ch2, p));\n}\n\nfloat edge_distance(vec2 spos, vec2 pos)\n{\n    ivec2 p = ivec2(spos);\n   \n    ivec4 ve = getve(p);//edge side particles\n    \n    //if invalid\n    if(any(equal(ve.xy, ve.zw)) || any(equal(ivec4(-1), ve))) return 1e10;\n   \n    vec4 p0 = getParticle(ve.z);\n    vec4 p1 = getParticle(ve.w);\n   \n    vec4 pe0 = getParticle(ve.x);\n    vec4 pe1 = getParticle(ve.y);\n    \n    vec2 edge0 = circumcenter(p0.xy, p1.xy, pe0.xy);\n    vec2 edge1 = circumcenter(p0.xy, p1.xy, pe1.xy);\n   \n    return sdSegment(pos, edge0, edge1);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec4 getEdge(ivec2 p, out ivec4 nb, out mat4 edgep)\n{\n    nb = getve(p);//edge side particles\n   \n    vec4 p0 = getParticle(nb.z);\n    vec4 p1 = getParticle(nb.w);\n    edgep[0] = p0;\n    edgep[1] = p1;\n   \n    vec4 pe0 = getParticle(nb.x);\n    vec4 pe1 = getParticle(nb.y);\n    edgep[2] = pe0;\n    edgep[3] = pe1;\n    \n    vec2 edge0 = circumcenter(p0.xy, p1.xy, pe0.xy);\n    vec2 edge1 = circumcenter(p0.xy, p1.xy, pe1.xy);\n\treturn vec4(edge0, edge1);\n}\n\n//I dont like this code hmm\nvec2 find_next_point(ivec2 nb, vec2 c0, vec2 c1, vec2 cc)\n{\n    vec2 p; \n    ivec4 cp;\n    vec2 dx = normalize(mix(c0,c1,0.5) - cc);\n    vec2 dy = normalize(c0 - cc);\n    for(float y = 0.; y < 2.; y++)\n    {\n        for(float x = 1.; x < 4.; x++)\n        {\n            p = cc + dx*x + dy*y;\n            cp = getve(ivec2(p+1.));\n            if(all(equal(cp.zw,nb.xy)) ) break;\n        }\n        if(all(equal(cp.zw,nb.xy)) ) break;\n    }\n    return p;\n}\n\nint exclude(ivec2 ij, int i)\n{\n    return (i == ij.x)?ij.y:ij.x;\n}\n\nfloat sample_border(vec2 spos, vec2 pos)\n{\n    ivec2 p = ivec2(spos);\n    \n    ivec4 cp = getve(p).zwzw;//closest particles \n    vec4 p0 = getParticle(cp.x);\n\n    \n    ivec4 nb; mat4 edgep;\n    int prev = -1; int next = -1;\n    float de = 1e10;\n    for(int i = 0; i < 10; i++) //loop around\n    {\n    \tvec4 edge = getEdge(p, nb, edgep);\n        de = min(de,sdSegment(pos, edge.xy, edge.zw));\n        \n        //go to next edge\n        next = nb.y;\n        prev = exclude(nb.zw, cp.x);\n        //p = ivec2(round( edge.zw + 2.*normalize(0.5*(p0.xy + getParticle(next).xy) - edge.zw) ));\n        p = ivec2(find_next_point(ivec2(cp.x, prev), p0.xy, edgep[3].xy, edge.zw));\n        de = min(de, length(edgep[3].xy - pos));\n                \n        if(next == cp.y || next == cp.x) break;\n    }\n    return de;\n}\n\n/*float sample_neighbors(vec2 spos, vec2 pos)\n{\n    ivec2 p = ivec2(spos);\n    \n    ivec4 cp = getve(p);//closest particles \n\n    \n    ivec4 nb; mat4 edgep;\n    int prev = -1; int next = -1;\n    float de = 1e10;\n    for(int i = 0; i < 10; i++) //loop around\n    {\n    \tvec4 edge = getEdge(p, nb, edgep);\n        de = min(de,sdSegment(pos, edge.xy, edge.zw));\n        \n        //go to next edge\n        next = nb.y;\n        prev = exclude(nb.zw, cp.x);\n        //p = ivec2(round( edge.zw + 2.*normalize(0.5*(p0.xy + getParticle(next).xy) - edge.zw) ));\n        p = ivec2(find_next_point(ivec2(cp.x, prev), p0.xy, edgep[3].xy, edge.zw));\n        de = min(de, length(edgep[3].xy - pos));\n                \n        if(next == cp.y || next == cp.x) break;\n    }\n    return de;\n}*/\n\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{   \n    float i0 = gauss(sample_border(iMouse.xy, pos), prad);\n    float i = gauss(edge_distance(pos, pos), prad/5.);\n    ivec4 cp = getve(ivec2(pos));\n    col.xyz = 1.5*(sin(2.*vec3(3,2,1)*i0 + i*vec3(1,1,1.5))) + 0.25*(0.5 + 0.5*sin(vec3(1,2,3)*float(cp.x))); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//particle buffer\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat F(float d)\n{\n    return -1./(1.+0.05*d);\n}\n\nvec2 Fv(vec2 p0, vec2 p1)\n{\n    return normalize(p1-p0)*F(distance(p1,p0));\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos);\n        //this pixel value\n        U = texel(ch1, pos);\n        int id = xy2i(p);\n        \n        //neighbors\n   \t\tivec4 cp = get(ivec2(U.xy));\n   \t    vec4 p1 = getParticle(cp.y);\n   \t    vec4 p2 = getParticle(cp.z);\n   \t    vec4 p3 = getParticle(cp.w);\n        \n        vec2 F = Fv(U.xy, p1.xy) +\n            \t Fv(U.xy, p2.xy) +\n            \t Fv(U.xy, p3.xy);\n        \n        \n        ivec4 mnb = get(ivec2(iMouse.xy));\n        \n\t\tif(any(equal(ivec2(id),mnb.xy)) && iMouse.z>0.)\n        {\n            F += 0.0*(iMouse.xy - iMouse.zw); \n        }\n        \n        U.xy += F*dt;\n        \n        if(size.x - U.x < 2.) U.x = size.x - 2.;\n        if(U.x < 2.) U.x = 2.;\n        if(size.y - U.y < 2.) U.y = size.y - 2.;\n        if(U.y < 2.) U.y = 2.;\n \n        //this pixel value\n        if(iFrame<1)\n        {\n            U.xy = size*hash22(pos);\n\t\t\tU.zw = 2.*(hash22(3.14159*pos) - 0.5);\n        }\n    }\n    else discard;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define N ivec2(32,32)\n#define dt 0.5\n#define prad 2.\n\nint tot_n = N.x*N.y;\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * 15.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\nuniform sampler2D fake;\n\nivec4 get(ivec2 p)\n{\n    return floatBitsToInt(texel(fake, p));\n}\n\nvec4 save(ivec4 v)\n{\n    return intBitsToFloat(v);\n}\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nvoid swap(inout int x, inout int y)\n{\n    int b = x;\n    x = y;\n    y = b;\n}\n\nvoid swap(inout float x, inout float y)\n{\n    float b = x;\n    x = y;\n    y = b;\n}\n\nvec2 circumcenter(vec2 x, vec2 y, vec2 z)\n{\n    vec2 xy = y - x;\n    vec2 xz = z - x;\n    vec2 a = 0.5*(x+y);\n    vec2 b = 0.5*(x+z);\n    vec2 d = vec2(dot(xy,a), dot(xz,b));\n    float det = determinant(mat2(xy, xz));\n    return vec2(determinant(mat2(d.x, xy.y, d.y, xz.y)),determinant(mat2(xy.x, d.x, xz.x, d.y)))/det;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//4th order voronoi diagram \n\nivec4 u; //ids\nvec4 d; //distances\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p)+0.5;\n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        //insert\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        //insert\n        d = vec4(d.x, dtemp, d.yz);\n        u = ivec4(u.x, utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        //insert\n        d = vec4(d.xy, dtemp, d.z);\n        u = ivec4(u.xy, utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        //insert\n        d = vec4(d.xyz, dtemp);\n        u = ivec4(u.xyz, utemp);\n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(t.x, p);\n    sort(t.y, p);\n    sort(t.z, p);\n    sort(t.w, p);\n}\n\nvoid randupd(ivec2 p)\n{\n    for(int i = 0; i < 4; i++)\n    {\n    \t//go through the entire array sudorandomly\n    \tint t = ((iFrame + p.x + p.y*int(iResolution.x))^(1<<(3*i)))%tot_n;\n    \tsort(t, p);    \n    }\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    randupd(p);\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 3);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //particle indecies \n    u = ivec4(1);\n    d = vec4(1e10); \n   \n    update(p);\n    \n    U = save(u);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//voronoi edge tracking\n\n//neighbors \nvec4 nbxy; //positions\nivec2 nbu; //ids\n\n//side particles\nvec2 d;\nivec2 u;\n\nbool isSame(ivec3 a, ivec3 b) //is the id triplet the same\n{\n    return any(equal(a.xxx,b)) && any(equal(a.yyy,b)) && any(equal(a.zzz,b));\n}\n\nbool isEdgeParticle(int id, vec2 pxy)\n{\n    //edge point guess\n    vec2 cc = circumcenter(nbxy.xy, nbxy.zw, pxy);\n    //check the voronoi diagram at the guess\n    if(cc.x < 0. || cc.y < 0. || cc.x > size.x || cc.y > size.y) return false;\n    ivec4 t = get(ivec2(cc));\n    //the first 3 closest particles at the edge point pretty much always are the particles that produce the edge\n    return isSame(t.xyz, ivec3(nbu.xy, id));\n}\n\nvec4 getParticle(int id)\n{\n    return texel(ch1, i2xy(id));\n}\n\nivec4 getve(ivec2 p)\n{\n    return floatBitsToInt(texel(ch2, p));\n}\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id).xy, p);\n}\n\nvoid sort(int utemp, ivec2 p)\n{\n    vec2 pos = vec2(p);\n    if(any(equal(ivec2(utemp),nbu)) || utemp == -1) return; //if particle is in the edge pair\n    vec4 partic = getParticle(utemp);\n    float dtemp = distance(partic.xy, pos);\n    if(isEdgeParticle(utemp, partic.xy))\n    {\n        //sorting\n        if(d.x >= dtemp)\n        {\n            if(d.x == dtemp) return;\n            //insert\n            d = vec2(dtemp, d.x);\n            u = ivec2(utemp, u.x);\n        }\n        else if(d.y >= dtemp)\n        {\n            if(d.y == dtemp) return;\n            //insert\n            d = vec2(d.x, dtemp);\n            u = ivec2(u.x, utemp);\n        }   \n    }\n}\n\nvoid upd(ivec2 p, ivec2 dx)\n{\n    ivec4 t = get(p+dx);\n    sort(t.x, p);\n    sort(t.y, p);\n    sort(t.z, p);\n    sort(t.w, p);\n    ivec4 tt = getve(p+dx);\n    sort(tt.x, p);\n    sort(tt.y, p);\n}\n\nvoid updrad(ivec2 p, int R)\n{\n    int r = 1<<R;\n    upd(p, ivec2(r, 0));\n    upd(p, ivec2(-r, 0));\n    upd(p, ivec2(0, r));\n    upd(p, ivec2(0, -r));\n}\n\nvoid update(ivec2 p)\n{\n    upd(p, ivec2(0));\n    updrad(p, 0);\n    updrad(p, 1);\n    updrad(p, 2);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    ivec4 t = get(p);\n    \n    nbu = t.xy; //edge pair\n    nbxy = vec4(getParticle(t.x).xy,getParticle(t.y).xy);\n   \n    //particle indecies\n    ivec4 prev = getve(p); \n    u = ivec2(-1);\n    d = vec2(1e10); \n   \n    update(p);\n    \n    if(any(equal(u,ivec2(-1)))) //if not found the edge use the old data\n    {\n        u = prev.xy;\n        if(any(equal(nbu, prev.xx))) u.x = prev.z;\n        if(any(equal(nbu, prev.yy))) u.y = prev.w;\n    }\n    \n    U = vec4(intBitsToFloat(u), intBitsToFloat(nbu));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}