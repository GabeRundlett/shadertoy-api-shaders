{
    "Shader": {
        "info": {
            "date": "1612215306",
            "description": "Not Physically accurate, but it sure is pretty. See the code for details.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttcfRH",
            "likes": 32,
            "name": "Something like the Night Sky",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "sky",
                "night"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 1476
        },
        "renderpass": [
            {
                "code": "// Something like the Night Sky by Zi7ar21 --- February 1st, 2020\n// Updated February 1st, 17:15 Mountain Time\n\n// If you didn't find this on Shadertoy, the original can be found at:\n// https://www.shadertoy.com/view/ttcfRH\n\n/*\nThis is a somewhat Night-Sky like scene. It is rendered in 2D, and is NOT physically accurate.\nI didn't take into account proper gas colors, gas distribution, etc.\nAlso the stars have a Blackbody pallete but the probability of a random sampled star's\ncolor and luminance is not based on something accurate like Hertzsprung-Russell.\n*/\n\n// Hashes https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 pos) {\n\tvec3 p3  = fract(vec3(pos.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nfloat noise(vec2 n) {\n    vec4 b = vec4(floor(n), ceil(n)); \n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b.xy), hash12(b.zy), f.x), mix(hash12(b.xw), hash12(b.zw), f.x), f.y);\n}\n\n// Atmospheric Distortion \"Twinkling\"\nfloat noise(vec2 coord, float n) {\n    float componenta = hash13(vec3(coord, round(n - 0.5)));\n    float componentb = hash13(vec3(coord, round(n + 0.5)));\n    float componentc = mix(componenta, componentb, mod(n, 1.0));\n    return componentc;\n}\n\n// FBM Terrain Line\nfloat noise(float coord) {\n    float componenta = hash11(round(coord - 0.5));\n    float componentb = hash11(round(coord + 0.5));\n    return mix(componenta, componentb, mod(coord, 1.0));\n}\n\n// Color Offset, as Reccomended by user \"elenzil\"\n// https://www.shadertoy.com/user/elenzil\nvec3 colorednoise(vec2 coord, float n) {\n    vec3 componenta = hash33(vec3(coord, round(n - 0.5)));\n    vec3 componentb = hash33(vec3(coord, round(n + 0.5)));\n    vec3 componentc = mix(componenta, componentb, mod(n, 1.0));\n    return componentc;\n}\n\n// FBM https://www.shadertoy.com/view/3dSBRh\n#define octaves 8\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.4;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tv += a * noise(x);\n\t\tx  = x * 2.0;\n\t\ta *= 0.6;\n\t}\n\n\treturn v;\n}\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tv += a * noise(x);\n\t\tx  = x * 2.0;\n\t\ta *= 0.5;\n\t}\n\n\treturn v;\n}\n\n// Blackbody Coloration (Made into a Function by LoicVDB)\n// https://www.shadertoy.com/view/4tdGWM\nvec3 blackbody(float temperature) {\n    vec3 O = vec3(0.0);\n\n    for(float i = 0.0; i < 3.0; i += 0.1) {\n        float f = 1.0 + 0.5 * i;\n\n        O[int(i)] += 10.0 * (f * f * f) / (exp((19e3 * f / temperature)) - 1.0);\n    }\n\n    return O;\n}\n\n// Stars\nvec3 stars(vec2 coord) {\n    float luminance = max(0.0, (hash12(coord) - 0.985));\n    float temperature = (hash12(coord + iResolution.xy) * 6000.0) + 4000.0;\n    vec3 colorshift = normalize(colorednoise(coord, float(iTime * 16.0)));\n    return (luminance * noise(coord, iTime * 4.0)) * blackbody(temperature) * 4.0 * (colorshift * 0.5 + 1.0);\n}\n\n// Galaxy\nfloat galaxygas(vec2 coord) {\n    return max(0.0, fbm((coord * 4.0) + fbm(coord * 4.0)) - 0.35);\n}\n\nfloat galaxydust(vec2 coord) {\n    return max(0.0, fbm((coord * 2.0) + fbm(coord * 2.0) + vec2(4.0, 4.0)) - 0.5);\n}\n\n// Nebula\nfloat nebula(vec2 coord) {\n    float gas0 = max(0.0, fbm((coord * 2.0) + fbm(coord * 2.0) + vec2(4.0, 4.0)) - length(coord));\n    float gas1 = max(0.0, fbm((coord * 4.0) + fbm(coord * 2.0) + vec2(4.0, 4.0)) - length(coord * 1.01));\n    return max(0.0, gas0 - gas1);\n}\n\n// Main Image\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    if(fbm((uv.x + 4.0) * 4.0) > (uv.y + 0.5) * 4.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n        return;\n    }\n\n    vec3 star = stars(fragCoord);\n    float gas = galaxygas(uv);\n    vec3 dust = galaxydust(uv) * vec3(0.500, 0.400, 0.300);\n    vec3 nebulae = nebula(uv)  * vec3(0.600, 0.500, 0.750);\n    vec3 color = star + mix(vec3(gas), dust * 0.5, 0.75) + nebulae;\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}