{
    "Shader": {
        "info": {
            "date": "1620503224",
            "description": "I though it'd be fun to put some springs into a cube and use my bilinear patch intersector. Pull the vertices with the mouse. I must say, they look a lot nicer than triangles.",
            "flags": 48,
            "hasliked": 0,
            "id": "Ns2SzG",
            "likes": 48,
            "name": "Springy Cube",
            "published": 3,
            "tags": [
                "3d",
                "simulation",
                "cube",
                "physics",
                "spring",
                "softbody",
                "bilinearpatch"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 641
        },
        "renderpass": [
            {
                "code": "Intersect iScene(in vec3 ro, in vec3 rd) {\n    Intersect scene = Intersect(false, -1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    // Ground plane\n    addPlane(vec3(0.0, PLANE_HEIGHT, 0.0), vec3(0.0, 1.0, 0.0), 0, ro, rd, scene);\n\n    // Vertices (joints)\n    for (int n=0; n < joints.length(); n++) {\n        vec3 joint = getJoint(n).pos;\n        addSphere(joint, JOINT_SIZE, 1, ro, rd, scene);\n    }\n\n    // Faces\n    for (int n=0; n < faces.length(); n++) {\n        vec3 a = getJoint(faces[n][0]).pos;\n        vec3 b = getJoint(faces[n][1]).pos;\n        vec3 c = getJoint(faces[n][2]).pos;\n        vec3 d = getJoint(faces[n][3]).pos;\n        addBilinearPatch(a, b, c, d, 2, ro, rd, scene);\n    }\n\n    return scene;\n}\n\nvec3 getSky(in vec3 rd) {\n    return mix(vec3(1.0), vec3(0.25, 0.25, 1.0), 0.5 + 0.5 * rd.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = CAMERA_POS;\n    vec3 rd = normalize(vec3(uv, -FOCAL_LENGTH));\n\n    fragColor = vec4(getSky(rd), 1.0);\n\n    Intersect scene = iScene(ro, rd);\n    if (scene.hit) {\n        scene.nor *= sign(dot(scene.nor, -rd)); // Flip the normal towards the camera\n        vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n        if (scene.id == 0) { // Plane\n            fragColor.rgb = vec3(mod(dot(floor(scene.uv), vec2(1.0)), 2.0));\n            fragColor.rgb /= 0.4 * max(1.0, 0.2 * scene.dist); // Fade\n        }\n\n        if (scene.id == 1) { // Sphere\n            fragColor.rgb = vec3(0.0, 0.5, 1.0);\n        }\n\n        if (scene.id == 2) { // Patch\n            float checkers = mod(dot(floor(scene.uv * 8.0), vec2(1.0)), 2.0);\n            fragColor.rgb = vec3(0.5 + 0.5 * checkers, 0.0, 0.0);\n        }\n\n        fragColor.rgb *= max(0.0, mix(dot(scene.nor, light), dot(scene.nor, -rd), 0.5));\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75)); // Tonemap\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3[] joints = vec3[](\n    vec3(-1.5,  1.5, -1.5),\n    vec3(-1.5,  1.5,  1.5),\n    vec3( 1.5,  1.5,  1.5),\n    vec3( 1.5,  1.5, -1.5),\n    vec3(-1.5, -1.5, -1.5),\n    vec3(-1.5, -1.5,  1.5),\n    vec3( 1.5, -1.5,  1.5),\n    vec3( 1.5, -1.5, -1.5)\n);\n\nconst ivec4[] faces = ivec4[](\n    ivec4(0, 1, 2, 3),\n    ivec4(4, 5, 6, 7),\n    ivec4(0, 4, 5, 1),\n    ivec4(1, 5, 6, 2),\n    ivec4(2, 6, 7, 3),\n    ivec4(3, 7, 4, 0)\n);\n\n// Settings\n#define CAMERA_POS vec3(0.0, 0.0, 6.0)\n#define FOCAL_LENGTH 1.0\n\n#define JOINT_SIZE 0.15\n#define JOINT_MASS 10.0\n\n#define PLANE_HEIGHT -2.0\n\n#define GRAVITY 0.1\n#define SPRINGINESS 0.25\n#define DAMPING 0.99\n#define SPEED_LIMIT 0.5\n\n// Utilities\nstruct Joint {\n    vec3 pos;\n    vec3 vel;\n    float mass;\n};\n\n#define getJoint(id)                                  \\\n    Joint(texelFetch(iChannel0, ivec2(id, 0), 0).xyz, \\\n          texelFetch(iChannel0, ivec2(id, 1), 0).xyz, \\\n          JOINT_MASS)                                 \\\n\n// Intersectors\nstruct Intersect {\n    bool hit;\n    float dist;\n    vec3 pos;\n    vec3 nor;\n    vec2 uv;\n    int id;\n};\n\n// Plane intersector\nfloat iPlane(in vec3 o, in vec3 n, in vec3 ro, in vec3 rd) {\n    float d = dot(rd, n);\n    if (d != 0.0) return dot(o - ro, n) / d;\n    return -1.0;\n}\n\n// Adds a plane to the scene\nvoid addPlane(in vec3 o, in vec3 n, in int id, in vec3 ro, in vec3 rd, inout Intersect scene) {\n    ro -= o;\n    float d = dot(rd, n);\n    if (d != 0.0) {\n        float t = -dot(ro, n) / d;\n        if (t > 0.0 && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = ro + rd * t;\n            scene.nor = n;\n            vec3 v = n.x != 0.0 && n.z != 0.0 ? normalize(vec3(-n.z, 0.0, n.x)) : vec3(1.0, 0.0, 0.0);\n            scene.uv = scene.pos * mat2x3(v, cross(v, n));\n            scene.id = id;\n            scene.pos += o;\n        }\n    }\n}\n\n// Adds a sphere to the scene\nvoid addSphere(in vec3 o, in float r, in int id, in vec3 ro, in vec3 rd, inout Intersect scene) {\n    ro -= o;\n\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    float discr = b * b - a * c;\n    if (discr > 0.0) {\n        float t = -(sign(c) * sqrt(discr) + b) / a;\n        if (t > 0.0 && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = ro + rd * t;\n            scene.nor = scene.pos / r;\n            scene.uv = vec2(atan(scene.nor.z, scene.nor.x) / 6.28, atan(scene.nor.y, length(scene.nor.xz)) / 3.14) + 0.5;\n            scene.id = id;\n            scene.pos += o;\n        }\n    }\n}\n\n// Adds a bilinear patch to the scene\n// Vertices are expected to be winding in counterclockwise order\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nvoid addBilinearPatch(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in int id, in vec3 ro, in vec3 rd, inout Intersect scene) {\n    vec2 m = rd.yz / rd.x;\n    vec3 p = a - b + c - d, q = d - a, r = b - a;\n    vec2 c1 = p.yz - p.x * m, c2 = q.yz - q.x * m, c3 = r.yz - r.x * m;\n    vec2 c4 = (ro.x - a.x) * m + a.yz - ro.yz;\n\n    // Quadratic coefficients (reversed as a trick to deal with edge cases)\n    float qa = cross2D(c4, c2);\n    float qb = cross2D(c4, c1) + cross2D(c3, c2);\n    float qc = cross2D(c3, c1);\n\n    float discr = qb * qb - 4.0 * qa * qc;\n    if (discr > 0.0) {\n        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(discr) - qb); // Solve quadratic in v\n        vec2 u = -(c4.x + c3.x * v) / (c1.x * v + c2.x);\n        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ro.x) / rd.x;\n\n        // Get closest intersection in view and add it to the scene\n        for (int n=0; n < 2; n++) {\n            if (t[n] > 0.0 && (scene.hit ? t[n] < scene.dist : true) && abs(u[n] - 0.5) < 0.5 && abs(v[n] - 0.5) < 0.5) {\n                scene.hit = true;\n                scene.dist = t[n];\n                scene.pos = ro + rd * t[n];\n                scene.nor = normalize(cross(p * v[n] + q, p * u[n] + r));\n                scene.uv = vec2(u[n], v[n]);\n                scene.id = id;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n\n    // Simulation\n    if (iFragCoord.x < joints.length() && iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            if (iFragCoord.y == 0) fragColor.xyz = joints[iFragCoord.x] - vec3(0.0, 0.0, 1.0);\n            if (iFragCoord.y == 1) {\n                vec3 joint = joints[iFragCoord.x];\n                fragColor.xyz = vec3(normalize(joint.zx) * vec2(-0.05, 0.05), 0.0) + vec3(0.0, 0.2, -0.05);\n            }\n        }\n\n        if (iFrame > 0) {\n            Joint joint1 = getJoint(iFragCoord.x);\n            vec3 startPos1 = joints[iFragCoord.x];\n\n            // Accumulate gravitational and spring forces\n            vec3 totalForce = vec3(0.0, -GRAVITY, 0.0);\n            for (int i=0; i < joints.length(); i++) {\n                if (i == iFragCoord.x) continue;\n                Joint joint2 = getJoint(i);\n                vec3 startPos2 = joints[int(float(i) + 0.5)]; // Why +0.5?\n\n                float restLength = distance(startPos1, startPos2);\n                vec3 force = normalize(joint2.pos - joint1.pos);\n                float extension = restLength - distance(joint2.pos, joint1.pos);\n                force *= -SPRINGINESS * extension;\n\n                totalForce += force;\n            }\n\n            // Update\n            joint1.vel += totalForce / joint1.mass;\n            joint1.pos += joint1.vel;\n            joint1.pos.y = max(joint1.pos.y, JOINT_SIZE + PLANE_HEIGHT);\n            joint1.vel *= DAMPING * sign(joint1.pos.y - PLANE_HEIGHT - JOINT_SIZE);\n\n            // Attract to mouse\n            if (iMouse.z > 0.0) {\n                vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 ro = CAMERA_POS;\n                vec3 rd = normalize(vec3(mouse, -FOCAL_LENGTH));\n\n                bool closest = true;\n                vec3 targetPos = ro + rd * iPlane(joint1.pos, vec3(0.0, 0.0, 1.0), ro, rd);\n                float targetDist = distance(joint1.pos, targetPos);\n                for (int n=0; n < joints.length(); n++) {\n                    if (n == iFragCoord.x) continue;\n                    vec3 joint2 = getJoint(n).pos;\n                    vec3 targetPos2 = ro + rd * iPlane(joint2, vec3(0.0, 0.0, 1.0), ro, rd);\n                    if (distance(joint2, targetPos2) < targetDist) {\n                        closest = false;\n                        break;\n                    }\n                }\n\n                if (closest) {\n                    joint1.vel = (targetPos - joint1.pos) * 0.5;\n                    joint1.vel = normalize(joint1.vel) * min(length(joint1.vel), SPEED_LIMIT);\n                }\n            }\n\n            // Store\n            if (iFragCoord.y == 0) fragColor.xyz = joint1.pos;\n            if (iFragCoord.y == 1) fragColor.xyz = joint1.vel;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}