{
    "Shader": {
        "info": {
            "date": "1520684612",
            "description": "Non-warped helix distance",
            "flags": 0,
            "hasliked": 0,
            "id": "MstcWs",
            "likes": 30,
            "name": "Helix Distance",
            "published": 3,
            "tags": [
                "spiral",
                "helix",
                "twist"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 1462
        },
        "renderpass": [
            {
                "code": "/*\n\nHelix Distance\n--------------\n\nI've been wanting to create nice even helix shapes, most of the methods\nI've seen usually twist some geometry around an axis, but this leads to\na squashed cross-section with large radiuses.\n\nInstead, here I'm finding an approximate closest point on the helix and\nusing that to calculate the distance. To see how this looks, enable\nVISUALISE_CLOSEST below and click around the canvas.\n\nI'm also constructing 'helix coordinates' which you can see visualised\nas the uv texture. These can also be used for twisting regular geometry\naround the helix.\n\nThere's a seam that appears for small radii, for which I don't think\nthere's a neat solution. The problem is, as you approach the central\naxis of a helix, the closest point could be on the opposite side, this\nvaries with the thickness of the pipe geometry too.\n\nThese Wikipedia pages are helpful when thinking about the geometry\nof helices:\n\n* https://en.wikipedia.org/wiki/Helix_angle\n* https://en.wikipedia.org/wiki/Lead_(engineering)\n\n*/\n\n//#define VISUALISE_CLOSEST\n\n// --------------------------------------------------------\n// Structs\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec2 uv;\n    int id;\n};\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 rayOrigin;\n    vec3 rayDirection;\n};\n\n\n// --------------------------------------------------------\n// Utilities\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n    \n// Repeat space along one axis\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    return fLineSegment(p, a, b) - r;\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\nvec3 intersectPlane(vec3 rayOrigin, vec3 rayDirection, vec3 normal, float offset) {\n\tfloat dist = dot(normal, normal * offset - rayOrigin) / dot(normal, rayDirection);\n\treturn rayOrigin + rayDirection * dist;\n}\n\n// Cartesian to polar coordinates\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; // distance from the plane it lies on\n    float a = atan(p.y, p.z); // angle around center\n    float r = length(p.zy); // distance from center\n    return vec3(x, a, r);\n}\n\n// Polar to cartesian coordinates\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.y) * p.z,\n        cos(p.y) * p.z\n    );\n}\n\n// Closest of two points\nvec3 closestPoint(vec3 pos, vec3 p1, vec3 p2) {\n    if (length(pos - p1) < length(pos - p2)) {\n        return p1;\n    } else {\n        return p2;\n    }\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n// --------------------------------------------------------\n// Helix\n// --------------------------------------------------------\n\nvec2 closestPointOnRepeatedLine(vec2 line, vec2 point){\n\n    // Angle of the line\n    float a = atan(line.x, line.y);\n\n    // Rotate space so we can easily repeat along\n    // one dimension\n    pR(point, -a);\n\n    // Repeat to create parallel lines at the corners\n    // of the vec2(lead, radius) polar bounding area\n    float repeatSize = sin(a) * line.y;\n    float cell = pMod1(point.x, repeatSize);\n\n    // Rotate space back to where it was\n    pR(point, a);\n\n    // Closest point on a line\n    line = normalize(line);\n    float d = dot(point, line);\n    vec2 closest = line * d;\n\n    // Part 2 of the repeat, move the line along it's\n    // perpendicular by the repeat cell\n    vec2 perpendicular = vec2(line.y, -line.x);\n    closest += cell * repeatSize * perpendicular;\n\n    return closest;\n}\n\n// Closest point on a helix\nvec3 closestHelix(vec3 p, float lead, float radius) {\n\n    p = cartToPolar(p);\n    p.y *= radius;\n\n    vec2 line = vec2(lead, radius * PI * 2.);\n    vec2 closest = closestPointOnRepeatedLine(line, p.xy);\n\n    closest.y /= radius;\n    vec3 closestCart = polarToCart(vec3(closest, radius));\n\n    return closestCart;\n}\n\n\n// Cartesian to helix coordinates\nvec3 helixCoordinates(vec3 p, vec3 closest, float lead, float radius) {\n    float helixAngle = atan((2. * PI * radius) / lead);\n    vec3 normal = normalize(closest - vec3(closest.x,0,0));\n    vec3 tangent = vec3(1,0,0) * rotationMatrix(normal, helixAngle);\n    float x = (closest.x / lead) * radius * PI * 2.;\n    float y = dot(p - closest, cross(tangent, normal));\n    float z = dot(p - closest, normal);\n    return vec3(x,y,z);\n}\n\nvec3 mousePos;\nbool mouseDown;\n\nModel visualiseClosest(vec3 p) {\n    float lead = 3.;\n    float radius = 1.5;\n    \n    vec3 helix = closestHelix(p, lead, radius);\n    float d = length(p - helix) - .1;\n    \n    vec3 testPoint = vec3(sin(iTime * .75) * 3., cos(iTime * .75) * .8, 0.);\n    if (mouseDown) {\n    \ttestPoint = mousePos;\n    }\n\n    vec3 testHelix = closestHelix(testPoint, lead, radius);\n\n    d = min(d, length(p - testHelix) - .2);\n    d = min(d, length(p - testPoint) - .1);\n    d = min(d, fCapsule(p, testPoint, testHelix, .05));\n\n    return Model(d, vec2(0), 0);\n}\n\nModel map(vec3 p) {\n    #ifdef VISUALISE_CLOSEST\n\t\treturn visualiseClosest(p);\n   \t#endif\n    \n    float phase = iTime * PI * 2. / 8. - .5;\n    float lead = mix(1., 8., sin(phase) * .5 + .5);\n    float radius = mix(0.001, 1.8, cos(phase) * .5 + .5);\n\n    vec3 helix = closestHelix(p, lead, radius);\n    float d = length(p - helix) - .5;\n    \n    vec3 hp = helixCoordinates(p, helix, lead, radius);\n\tvec2 uv = vec2(hp.x, atan(hp.y, hp.z) / PI / 2.);\n    \n    return Model(d, uv, 0);\n}        \n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 render(Hit hit){\n    vec3 col;\n    if (hit.isBackground) {\n        col = vec3(.1);\n    } else {\n        vec2 uv = hit.model.uv;\n        uv *= vec2(4., 8.);\n        uv = cos(uv * PI * 2.);\n        uv = smoothstep(.5, .55, uv);\n        col = vec3(1.-uv.yx, 1.);\n        #ifdef VISUALISE_CLOSEST\n        col = vec3(1);\n        #endif\n        vec3 light = normalize(vec3(.5,1,0));\n\t    vec3 diffuse = vec3(dot(hit.normal, light) * .5 + .5);\n\t\tcol *= diffuse;\n    }\n    #ifndef VISUALISE_CLOSEST\n    if (hit.isBackground || hit.pos.z > 0.) {\n\t\tvec3 debugPlanePos = intersectPlane(\n            hit.rayOrigin, hit.rayDirection, vec3(0,0,1), 0.\n        );\n        float dist = map(debugPlanePos).dist;\n        vec3 meter = vec3(mod(dist, 1./4.));\n        col = mix(col, meter, .5);\n    }\n    #endif\n\treturn col;\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 30.;\nconst float INTERSECTION_PRECISION = .001;\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .1;\n\n\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nHit raymarch(vec3 rayOrigin, vec3 rayDirection){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float rayLength = 0.;\n    Model model;\n\n    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++){\n        if (currentDist < INTERSECTION_PRECISION || rayLength > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(rayOrigin + rayDirection * rayLength);\n        currentDist = model.dist;\n        rayLength += currentDist * (1. - FUDGE_FACTOR);\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (rayLength > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = rayOrigin + rayDirection * rayLength;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(model, pos, isBackground, normal, rayOrigin, rayDirection);\n}\n\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n\n\tvec3 camPos = vec3(0,0,-6);\n    vec3 camTar = vec3(0);\n    vec3 camUp = vec3(0,1,0);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n\n    float focalLength = 2.;\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n\n    vec3 mouseRayDirection = normalize(camMat * vec3(m, focalLength));\n    mousePos = intersectPlane(camPos, mouseRayDirection, vec3(0,0,1), 0.);\n    mouseDown = iMouse.z > 0.;\n    \n    Hit hit = raymarch(camPos, rayDirection);\n\n    vec3 color = render(hit);\n   \tcolor = pow(color, vec3(1. / 2.2)); // Gamma\n    fragColor = vec4(color,1);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}