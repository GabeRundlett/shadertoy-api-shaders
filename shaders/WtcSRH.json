{
    "Shader": {
        "info": {
            "date": "1580348380",
            "description": "Based off user  alijaya's ray marching phong template.\nStill learning..",
            "flags": 0,
            "hasliked": 0,
            "id": "WtcSRH",
            "likes": 1,
            "name": "Attraction-1",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "timF",
            "viewed": 279
        },
        "renderpass": [
            {
                "code": "#define EPSILON 0.01\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 2000.0\n#define MAX_MARCHING_STEP 256\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n\tvec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n// sphere function\nfloat sdSphere( vec3 p, float radius ) {\n    return length(p) - radius;\n}\n\n// Octahedron function\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// smooth union function\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n\n// box function\nfloat sdBox( vec3 p, float width, float height, float depth ) {\n    vec3 d = abs(p) - vec3(width, height, depth);\n    return max(d.x, max(d.y, d.z));\n}\n\n// cylinder function\nfloat sdCylinder( vec3 p, float radius, float height ) {\n    return max(length(p.xz) - radius, abs(p.y) - height);\n}\n\nfloat sdUnion( float sd1, float sd2 ) {\n    return min(sd1, sd2);\n}\n\nfloat sdIntersect( float sd1, float sd2 ) {\n    return max(sd1, sd2);\n}\n\nfloat sdSubstract( float sd1, float sd2 ) {\n    return max(sd1, -sd2);\n}\n\nmat4 rotationMatrix(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// change this\nfloat sdScene( vec3 p ) {\n    float finalShape = 0.0;\n    float sphereTest = sdSphere(p, 200.0);\n    float sphereTest2 = sdSphere(p, 200.0);\n    vec4 spherePos = vec4(p,0.0); // the center sphere position\n    \n    float sphereScale = 1.0;\n    \n    \n    float sphere1 = sdSphere( spherePos.xyz, sphereScale); // center sphere\n    \n    //offsets of the left and right octa so they are uniform\n    vec2 octaOffset = vec2(4.8+sin(iTime*2.)*.2,.4);\n    \n    //sizeing\n    float octaSize = 2.0;\n    float boxSize = .95;\n    \n    float leftOcta = sdOctahedron(p - vec3(octaOffset.x,octaOffset.y,0.0), octaSize);\n    float leftOctaSub = sdBox(p - vec3(octaOffset.x,octaOffset.y,0.0),boxSize,boxSize,boxSize);\n    float rightOcta = sdOctahedron(p + vec3(octaOffset.x,octaOffset.y-1.,0.0), octaSize);\n    float rightOctaSub = sdBox(p + vec3(octaOffset.x,octaOffset.y-1.,0.0),boxSize,boxSize,boxSize);\n    \n    leftOcta = sdSubstract(leftOcta,leftOctaSub);\n    rightOcta = sdSubstract(rightOcta,rightOctaSub);\n    float lConnection = 3.2 + sin(iTime*120.)*.08;\n    float rConnection = 3. + sin(iTime*120.)*.08;\n    \n    \n    \n    finalShape = opSmoothUnion(opSmoothUnion(sphere1, leftOcta,lConnection),rightOcta,rConnection);\n    //finalShape = min(sphereTest,finalShape );\n    \n    //finalShape = min(sphereTest, sphereTest2);\n    \n    return finalShape;\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n    \tsdScene(p+xe) - sdScene(p-xe),\n        sdScene(p+ye) - sdScene(p-ye),\n        sdScene(p+ze) - sdScene(p-ze)\n    ));\n}\n\n// ray marching algorithm\nfloat getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d );\n        \n        if (dist < EPSILON) { // inside a scene\n            return depth;\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return MAX_DISTANCE;\n        }\n    }\n    \n    return MAX_DISTANCE;\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    }\n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 circleMovement = vec3(0.0,3.0 + sin(iTime*.2)*4.,-4.0);\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 200.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 0., 0.); // where to look at (this camera use two point system)\n    cam.pos = circleMovement; // the position of the camera\n    \n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n    \n    // create 8 points of cube\n    vec3 points[8];\n    for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n            for (int k=0; k<2; k++) {\n                points[i*4+j*2+k] = vec3(float(i) * 2. - 1., float(j) * 2. - 1., float(k) * 2. - 1.);\n            }\n        }\n    }\n    \n    // render\n    float dist = getSDF(ray);\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(0.);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1, 0.1, 0.2);\n    vec3 diffuseColor = vec3(0.7, 0.2, 0.2);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(-2,2,-3);\n    light1.color = vec3(1., 0.5, 0.3);\n    \n    Light light2;\n    light2.pos = vec3(2,2,3);\n    light2.color = vec3(1., 0.8, 0.5);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}