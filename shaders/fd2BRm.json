{
    "Shader": {
        "info": {
            "date": "1645894976",
            "description": "experiment on paint brush as texture",
            "flags": 32,
            "hasliked": 0,
            "id": "fd2BRm",
            "likes": 27,
            "name": "painted 3D scene",
            "published": 3,
            "tags": [
                "raytracing",
                "paint",
                "stylized",
                "brush",
                "strokes"
            ],
            "usePreview": 1,
            "username": "mdb",
            "viewed": 738
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = 1.0 - exp(-texture(iChannel0, uv));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//inspired from: https://www.shadertoy.com/view/XllGRl\n\n#define NUMBER_STROKES 500\n#define MULT 2\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n/* brush                                                                            */\n//////////////////////////////////////////////////////////////////////////////////////\n\n//Random\n\nuint seed = 2647417u;\nuint seed3;\n\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvoid hash2(){\n    seed3 ^= 2747636419u;\n    seed3 *= 2654435769u;\n    seed3 ^= seed3 >> 16;\n    seed3 *= 2654435769u;\n    seed3 ^= seed3 >> 16;\n    seed3 *= 2654435769u;\n}\n\nfloat random2(){\n    hash2();\n    return float(seed3)/4294967295.0;\n}\n\nfloat noise(vec2 x){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0 - 2.0*f);\n    \n    vec2 p = floor(x);\n\tfloat a = texture(iChannel0, (p+vec2(0.0, 0.0))/256.0).x;\n\tfloat b = texture(iChannel0, (p+vec2(1.0,0.0))/256.0).x;\n\tfloat c = texture(iChannel0, (p+vec2(0.0,1.0))/256.0).x;\n\tfloat d = texture(iChannel0, (p+vec2(1.0,1.0))/256.0).x;\n\n    \n\treturn a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\n\nvec2 seed2 = vec2(0.0);\nfloat fbm(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    x += seed2;\n    for(int i = 0; i < detail; i++){\n        float n = noise(x);\n        a += b*n;\n        t += b;\n        b *= 0.7;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\n\n#define PI 3.14159265359\n\n\n\nvec2 mn = vec2(0.0, 0.0);\nvec3 random_sphere(){\n    const float a = 4.0*PI/float(NUMBER_STROKES);\n    const float d = sqrt(a);\n    const float M1 = round(PI/d);\n    const float d1 = PI/M1;\n    const float d2 = a/d1;\n\n    float teta = PI*(mn.x + 0.5)/M1;\n    float M2 = round(2.0*PI*sin(teta)/d2);\n\n    float phi = 2.0*PI*mn.y/M2;\n\n    mn.y += 1.0;\n    if (mn.y > M2){\n        mn.x += 1.0;\n        mn.y = 0.0;\n    } \n    \n    teta += random() * 0.2 - 0.1;\n    phi += random() * 0.2 - 0.1;\n    return vec3(sin(teta)*cos(phi), cos(teta), sin(teta)*sin(phi));\n       \n}\n\nvec3 random_sphere2(){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    float s = sqrt(1.0-z*z);\n    return vec3(s*cos(teta), s*sin(teta), z);\n}\n//aux///////////\n\nvec3 colorRamp(vec3 col1, vec3 col2, vec3 col3, float t){\n    if (t < 0.5){\n        t*=2.0;\n        t = t*t*(3.0 - 2.0*t);\n        return mix(col1, col2, t);\n    }else{\n        t = (t-0.5)*2.0;\n        t = t*t*(3.0 - 2.0*t);\n        return mix(col2, col3, t);\n    }\n}\n\n//brush\n\nvec4 brush(vec2 uv){ //color && alpha\n    uv.y += 0.4*(fbm(vec2(uv.x*2.0, 0.5), 2) - 0.5);\n    //color\n    float t = 0.3 + 0.4*fbm(uv*vec2(10.0, 60.0) + 10.0, 3);\n    t += 0.6*fbm(uv*2.0+20.0, 2)-0.3;\n    t += 0.7*noise(seed2)-0.35;\n    \n    //strength\n    float b = 1.0;\n    b *= pow(fbm(uv*vec2(1.0, 3.0), 8), 2.0);\n    b *= smoothstep(0.9, 0.5, 2.0*max(abs(uv.x - 0.5), abs(uv.y - 0.5)));\n    b = smoothstep(0.17, 0.3, b);\n    \n    return vec4(colorRamp(vec3(0.404,0.133,0.357), \n                     vec3(1.000,0.690,0.259),\n                     vec3(0.753,0.165,0.165), t), b);\n}\n\nint rot_idx = 0;\nvec4 brush2(vec2 uv){ //color && alpha\n    uv.y += 0.4*(fbm(vec2(uv.x*2.0, 0.5), 2) - 0.5);\n    //color\n    float t = 0.3 + 0.4*fbm(uv*vec2(10.0, 60.0) + 10.0, 3);\n    t += 0.6*fbm(uv*2.0+20.0, 2)-0.3;\n    t += 0.7*noise(seed2)-0.35;\n    \n    //strength\n    float b = 1.0;\n    b *= pow(fbm(uv*vec2(1.0, 3.0), 8), 2.0);\n    b *= smoothstep(0.9, 0.5, 2.0*max(abs(uv.x - 0.5), abs(uv.y - 0.5)));\n    b = smoothstep(0.27, 0.3, b);\n    \n    vec3 colors[3] = vec3[3](\n        vec3(0.769,0.769,0.769),\n        vec3(0.188,0.169,0.153),\n        vec3(0.263,0.259,0.259)\n    );\n    rot_idx += 1;\n    rot_idx %= 3;\n    return vec4(colorRamp(vec3(0.204,0.157,0.114), \n                     colors[rot_idx],\n                     vec3(0.239,0.173,0.141), t), b);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n/* rtx                                                                              */\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec4 intersect(vec3 ro, vec3 rd, vec3 p, inout vec3 n){\n    float t = dot(p - ro, n)/dot(rd, n);\n    \n    if (t < 0.0) return vec4(-1.0);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    if (dot(n, up) > 0.95) up = vec3(0.7071, 0.0, 0.7071);\n    \n    vec3 u = normalize(cross(up, n));\n    vec3 v = cross(u, n);\n    \n    vec3 p2 = ro + rd*t;\n    vec2 uv;\n    \n    uv.x = dot(u, p2 - p);\n    uv.y = dot(v, p2 - p);\n    uv *= vec2(7.0, 10.0); //size\n    if(abs(uv.x) > 1.0 || abs(uv.y) > 1.0) return vec4(-1.0);\n    \n    uv = uv*0.5+0.5;\n    vec4 b = brush(uv);\n    \n    if (b.w < random2()) return vec4(-1.0);\n    \n    n = normalize(n + 0.5*v*(fbm(vec2(20.0, 60.0)*uv, 3) - 0.5));\n    \n    return vec4(t, b.rgb);\n}\n\n\nvec3 scene(vec3 ro, vec3 rd){\n    float t = 1e10;\n    vec3 col = vec3(0.000,0.000,0.000);\n    \n    for(int i = 0; i < NUMBER_STROKES; i++){\n       vec3 pos = random_sphere();\n       vec3 n = normalize(pos + 0.5*vec3(random(), random(), random()) - 0.25);\n       seed2 = vec2(random(), random()) * 256.0;\n       pos *= 0.5;\n       \n       if (dot(-ro, pos) > 0.0) continue;\n       \n       vec4 inter = intersect(ro, rd, pos, n);\n       if (inter.x > 0.0 && inter.x < t){\n           t = inter.x;\n           col = 0.5*vec3(0.059,0.102,0.122);\n           //light1\n           const vec3 l1 = normalize(vec3(1.0, 1.0, 0.0)); \n           const vec3 c1 = 2.0*vec3(1.000,0.812,0.302);\n           float dNL1 = dot(n, l1);\n           col += inter.yzw * c1 * max(0.0, dNL1);\n           if (dNL1 > 0.0)\n               col += c1 * pow(max(0.0, dot(reflect(normalize(pos - ro), n), l1)), 10.0);\n\n\n           //light2\n           const vec3 l2 = normalize(vec3(-1.0, 0.0, 0.2)); \n           const vec3 c2 = vec3(0.004,0.255,0.145);\n           col += inter.yzw * c2 * pow(max(0.0, dot(n, l2)), 4.0);\n               \n           \n       }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    seed3 = uint(fragCoord.y*iResolution.x + fragCoord.x) + uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    vec3 ro = vec3(sin(iTime*0.5), 0.5, cos(iTime*0.5));\n    \n    vec3 dir0 = normalize(-ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    vec3 col = vec3(0.0);\n    if (length(uv) < 0.6){\n    for(int i = 0; i < MULT; i++)\n        col += scene(ro, rd);\n    col /= float(MULT);\n    }\n    \n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).rgb, 0.3);\n    \n    \n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}