{
    "Shader": {
        "info": {
            "date": "1653659810",
            "description": "Credit to IQ for his raymarching primitives shader\nThis shader is trying to reproduce this image https://www.youtube.com/watch?v=k3WkJq478To\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7s3cWM",
            "likes": 13,
            "name": "SynthCity",
            "published": 3,
            "tags": [
                "synth"
            ],
            "usePreview": 0,
            "username": "rcargou",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "//Credit to IQ for his raymarching primitives shader\n// This shader is trying to reproduce this image https://www.youtube.com/watch?v=k3WkJq478To\n\n#define AA 2   // make this 2 or 3 for antialiasing\n\n\n#define floor_mat 1.0f\n#define sky_mat 2.0f\n#define building_mat 3.0f\n#define big_building_mat 4.0f\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat stripes(float y) {\n\n    float b = clamp(0.0f, 1.0f, 1.0 - y * 2.0f); \n    //b = 1.0f - b;\n    float h = y + 0.3f;\n    float s = smoothstep(0.3, 0.21, abs(sin(-iTime * 1.5f + h*h * 30.0f)));\n    return s*b;\n}\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\nfloat oscillate() {\n    return sin(iTime * 1.0f);\n}\n\nfloat mapBigBuildings(vec3 p) {\n    float scale = 1.0f/3.0f;\n    float id = floor(p.x / scale);\n    float scale_fact = clamp(abs(id / 50.0f), 0.5, 44.5f);\n    p.x = mod(p.x, scale) - scale/2.0f;\n    \n    float h = hash(vec2(id)).x;\n    p.y += 0.6f;\n    p.y /= 13.0f / scale_fact;//\n    p.x /= 7.0f;\n    p.z += 5.0f;\n    \n    p.z /= 10.0f;\n    p.y += h / 5.0f;\n    float b1 = sdBox(p + vec3(0.1f, 0.0f, 0.0f), vec3(0.05f, 0.1f, 0.02f));\n    float b2 = sdBox(p + vec3(0.0f, 0.0f, 0.0f), vec3(0.05f, 0.2f, 0.05f));\n    float b3 = sdBox(p + vec3(-0.05f, 0.0f, -0.1f), vec3(0.05f, 0.1f, 0.05f));\n    return min(b1, min(b2, b3));\n}\n\nfloat mapBuildings(vec3 p) {\n\n    float scale = 1.0f/3.0f;\n    float x = p.x;\n    float z = p.z;\n    p.x += iTime * 0.4f ;\n     \n    float angle = iTime / 10000.0f;\n    \n    \n    //p.x = cos(angle) * p.x - sin(angle) * p.z;\n    //p.z = sin(angle)* x + cos(angle) * z;\n        \n    vec3 id = floor(p/scale);\n    if (-id.z + 1.0f > 8.0f)\n    return 10000.0f;\n    float h = hash(id.xz).x;\n    p.xz = mod(p.xz, scale) - scale/2.0f;\n  p.x -= 0.05f;\n p.y += 0.6f;\n    if (h < 0.1f)\n    p.y *= 0.6f;\n    p.x += h/10.0f;\n     p *= 1.2f;\n    float b1 = sdBox(p + vec3(0.1f, 0.0f, 0.0f), vec3(0.05f, 0.1f, 0.02f));\n    float b2 = sdBox(p + vec3(0.0f, 0.0f, 0.0f), vec3(0.05f, 0.2f, 0.05f));\n    float b3 = sdBox(p + vec3(-0.05f, 0.0f, -0.1f), vec3(0.05f, 0.1f, 0.05f));\n    if (h > 0.3)\n    b2 = 10000.0f;\n    \n    return min(b1, min(b2, b3));\n}\n\nvec2 map2( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    float dFloor = pos.y + 0.75;// + cos(pos.x / 35.0f);\n \n    res = opU(res, vec2(dFloor, floor_mat) );\n        float dSky = pos.z + 6.5;\n    res = opU(res, vec2(dSky, sky_mat) );\n    return res;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    float dFloor = pos.y + 0.75;// + cos(pos.x / 35.0f);\n \n    \n    float dSky = pos.z + 6.5;\n    res = opU(res, vec2(dSky, sky_mat) );\n    res = opU(res, vec2(mapBuildings(pos), building_mat) );\n    res = opU(res, vec2(mapBigBuildings(pos), big_building_mat));\n    //res = opU(res, vec2(mapBigBuildings(pos), big_building_mat));\n    //res = opU(res, vec2(mapBigBuildings(pos * vec3(1.0f, 4.5f, 1.0f) + vec3(0.0f, 0.0f, -1.0f)), big_building_mat));\n    //res = opU(res, vec2(mapBigBuildings(pos * vec3(1.0f, 6.5f, 1.0f) + vec3(-3.0f, 0.0f, -1.0f)), big_building_mat));\n    //res = opU(res, vec2(mapBigBuildings(pos * vec3(1.0f, 2.0f, 1.0f) + vec3(3.0f, 0.0f, -1.0f)), big_building_mat));\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 200.0;\n       \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.00005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x * 0.6f;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec2 castRay2( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 200.0;\n       \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.00005*t;\n\t    vec2 res = map2( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x * 0.6f;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 shade_floor(vec3 pos) {\n    vec3 col = vec3(0.0025f, 0.0005, 0.002);\n    pos.x+= iTime * 0.4;\n    float scale = 3.0f;\n    vec2 fuv=fract(scale * pos.xz);\n    \n    fuv = abs(abs(fuv) - 0.5);\n    \n    col += vec3(0.6f, 0.01f, 0.6f) * 85.5f * smoothstep(0.47, 0.5, smax(fuv.x, fuv.y, 15.0f));\n    \n    //col += col * 200.0f * smoothstep(.0f, 1.5, min(fuv.x, fuv.y));\n   // col += vec3(.3f) * smoothstep(0.1, 0.35, abs(fuv.x)*abs(fuv.y) );\n   \n     float f= 1.0f / length(pos/15.0f - vec3(0.0f, 0.0f, -0.1f * 20.0f + 1.0f));\n    f = clamp(0.0f, 1.0f, pow(f,2.9f));\n    f = smoothstep(0.2f, 0.9f, f) * 0.7;\n   // col += mix(vec3(250.0f / 255.0f, 0.0f / 255.0f, 124.0f/255.0f), vec3(0.0f), 1.0f-f);\n    return col;\n}\n\n\nfloat window(vec2 uv, vec3 p) {\n\n    float s = 1.0f;\n    vec3 id = floor(p);\n    vec2 fuv = abs(fract(uv * s) - vec2(0.5f));\n    vec2 fid = uv  - fract(uv);\n    float size = 0.20f;\n    float f = smoothstep(size, size - 0.1f, max(fuv.x, fuv.y));\n    vec2 h = hash(fid + id.zx);\n    f *= step(h.x, 0.6f);\n    return f;\n}\n\nvec3 shade_window(vec3 pos, vec3 nor, float r) {\n    \n    if (abs(nor.y) > 0.001f)\n        return vec3(.0f);\n    vec2 uv = vec2(pos.x * nor.z + pos.z * nor.x + pos.y * 0.0f, \n    pos.y * nor.z + pos.y * nor.x + pos.z * nor.y );\n    float window_factor = window(uv * 40.0f, pos);\n    vec3 c_window = vec3(0.4f, 0.4f, 0.4f) * 5.0f;\n    float d = 9.0f;\n    window_factor *= smoothstep(d, d - 10.0f, r);\n//    return vec3(r/100.0f);\n    return c_window * window_factor;\n}\n\nvec3 shade_buildings(vec3 pos, float t) {\n    float f= 1.0f / length(pos/15.0f - vec3(0.0f, 0.0f, -0.1f * 20.0f + 1.0f));\n    f = clamp(0.0f, 1.0f, pow(f,2.9f));\n    f = smoothstep(0.2f, 0.9f, f) * 0.7;\n    vec3 nor = calcNormal(pos);\n    vec3 col = mix(vec3(250.0f / 255.0f, 0.0f / 255.0f, 124.0f/255.0f), vec3(0.0f), 1.0f-f);\n      pos.x += 0.4 * iTime;\n   \n    vec3 c_window = shade_window(pos, nor, t);\n    return c_window + col;\n}\n\nvec3 shade_sky(vec2 uv) {\nvec3 col;\n   \n        vec3 col_top = vec3(0.001f, 0.0f, 0.02f);\n        vec3 col_bot = vec3(0.1, 0.02, 0.24);\n        vec3 col_light = vec3(420.0f / 255.0f, 0.0f / 255.0f, 104.0f/255.0f);\n        \n \n        col = mix(col_bot, col_top, min(1.0f, 0.3 + uv.y * 1.3f) );\n        float i = length(1.3f * (uv-vec2(0.0f, -0.3f))*vec2(0.2f, 2.0f));\n         //i = .8f / length(uv.y - 1.0f);\n//        i = clamp(0.0f, 1.0f, i);\n  //      col = col_sun * (1.0f - i) + col;\n        vec3 col_sun = vec3(1.0f, 0.3f, 0.2f) * 1.0f;\n       // col_sun = pow(col_sun, vec3(1.3f + 0.6f * oscillate()) );\n        float j = length(4.0f * (uv - vec2(0.0f, -0.2f)) * vec2(0.6, .6f));\n        float sun_value= smoothstep( 1.5, 1.4f, j);\n        sun_value *= smoothstep(0.9f, 1.0f, 1.0f-stripes(uv.y*2.0f));\n        col = mix(col, col_sun, sun_value*1.5f );\n        col = mix(col_light*0.7f, col, clamp(0.0f, 1.0f, i/1.4f));\n        //uv.x += iTime * 0.05f;\n        float star = texture(iChannel0, texture(iChannel1, uv).xz).r;\n            uv.xy += texture(iChannel1, uv*200.0f).xy/10.0f;\n    uv.x+= iTime * 0.01f;\n        vec2 closest_star = voronoi(uv*100.0f);\n        star = (2.5f * pow(texture(iChannel1, uv*1.0f).x, 3.0f)) / length(closest_star);\n        star = pow(star, 1.0f);\n        float star_treshold = 3.9f;\n        star = mix(star, 0.0f, smoothstep(1.5, 1.4, j));\n        col = mix(col, vec3(0.4f), smoothstep(star_treshold - 0.01, star_treshold, star));\n     return col;\n}\n\nvec3 shade(vec2 res, vec3 pos, vec2 uv) {\n    vec3 col;\n    \n    if (res.y == floor_mat) {\n        col = vec3(0.2f);\n        col = shade_floor(pos);\n    } else if (res.y == sky_mat) {\n        col = shade_sky(uv);\n    } else if (res.y == building_mat) {\n        col = shade_buildings(pos, res.x);\n    } else if (res.y == big_building_mat) {\n        vec3 nor =calcNormal(pos);\n          vec3 col_light = vec3(420.0f / 255.0f, 0.0f / 255.0f, 104.0f/255.0f);\n        \n \n        col = col_light*0.2f + 0.3f*shade_window(pos/10.0f, nor, 0.0f);\n        col *= smoothstep(0.9, -0.3, uv.y*4.0f + 0.6f);\n//        col = calcNormal(pos);\n    }\n\n    return col;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, vec2 uv )\n{ \n    vec3 col = vec3(.0f);\n    vec2 res = castRay(ro,rd);\n    \n    vec2 res2 = castRay2(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if (res.y != sky_mat && !(res.y == big_building_mat && res2.y == floor_mat)) {\n        vec3 pos = ro + rd * t;\n        col = shade(res, pos, uv);\n        if (res.y == building_mat) {\n            col = mix(col, shade(res2, ro + rd * res2.x, uv), 0.01);\n        }\n    } else  {\n        vec3 pos = ro + rd * res2.x;\n        col = shade(res2, pos, uv);\n    }\n   \treturn vec3(col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0.0f);//iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        p.y += sin(p.x - 1.57)/-13.0f;\n\t\t// camera (ro = ray origin)\t\n        vec3 ro = vec3( 0.0f, 0.5f, 10.0f);\n        vec3 ta = vec3( 0.0f, 2.05, 1.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,0.8) );\n  \n        // render\t\n        vec3 col = render( ro, rd, p );\n        col += vec3(0.1f, 0.0f, 0.07f) / 2.0f;\n\n\t\t// gamma\n        col = pow( col, vec3(0.6545 + 0.2f * oscillate()) );\n        tot += col;\n        \n        \n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}