{
    "Shader": {
        "info": {
            "date": "1679688722",
            "description": "My path tracer. HDR. Bloom. Thanks to IQ for some of the intersection functions and his tutorials for inspiration. Volumetrics. Space to reset. I just switched to using a more accurate method of lighting.",
            "flags": 48,
            "hasliked": 0,
            "id": "DdtXRM",
            "likes": 2,
            "name": "Ray-Path tracer attempt 2",
            "published": 3,
            "tags": [
                "pathtracer"
            ],
            "usePreview": 0,
            "username": "pathtracerenthusiast",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "//To change camera settings or the scene, go to the 'Buffer A' tab.\n//To change the bloom threshold settings ,,go to the 'Buffer B' tab.\n\n//I used the Bing AI to imporve this code.\nvec3 blur(sampler2D s, vec2 p, int w) {\n  vec2 invRes = 1. / vec2(textureSize(s, 0));\n  vec3 color = vec3(0.);\n  for (int x = -w; x <= w; x++) {\n    for (int y = -w; y <= w; y++) {\n      vec2 uv = p + vec2(x, y) * invRes;\n      color += texture(s, uv).xyz;\n    }\n  }\n  color /= float((2 * w + 1) * (2 * w + 1));\n  return color;\n}\n\n//The constant below is the size of the bloom. Increasing this reduces performance\n//by quite a bit.\n#define size 2.*((R.x+R.y)*.00119047619)\nvoid mainImage( out vec4 o,  vec2 i )\n{\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    //Comment out to remove bloom.\n    o.xyz += blur(iChannel1,i/R,int(size));\n    \n    //Comment out the above and uncomment the below to see what will be bloomed.\n    //o.xyz = texelFetch(iChannel1,ivec2(i),0).xyz;\n    \n    o /= o+1.;\n    o = pow(o,vec4(1./2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//NOTE: When making any changes in the code in this tab, and the mode is zero,\n//you must reset the time for the changes to take effect.\n//The light can be found below.\n#define shutAp .6\n#define fcsDist 1.3\n#define blurAmt .003\n#define numLvls 8\n#define spp 1.\n#define FOV 75.\n#define fovInDeg 1\nconst float mode = 0.;\n//mode=0.: Develop; the image develops over multiple frames.\n//mode=1.; Realtime; the image is signifigantly more noisy, but changes take effect\n//immediatly.\n//Any other value of mode: FPS; same as Develop, but resets the image every\n//->mode<- frames. FPS MODE NOT RECCOMENDED. Develop mode reccomended.\n\n//To add objects, look in the 'Common' tab.\nvoid getScene(float t, out World world, out Viewer cam) {\n    cam = Viewer(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(0.5,2.,-5.));\n    \n    \n    mat2 rx = rot(d2r(-5.));\n    cam.uu.zy *= rx;\n    cam.vv.zy *= rx;\n    cam.ww.zy *= rx;\n    \n    mat2 ry = rot(-d2r(-1.));\n    cam.uu.xz *= ry;\n    cam.vv.xz *= ry;\n    cam.ww.xz *= ry;\n    \n    mat2 rz = rot(-d2r(-2.));\n    cam.uu.yx *= rz;\n    cam.vv.yx *= rz;\n    cam.ww.yx *= rz;\n    \n    world.spheres[0] = Sphere(vec3(-1.5,.5,3.),1.5,Mat(.1,vec3(1.),vec3(0.),vec3(1.)));\n    world.spheres[1] = Sphere(vec3(1.5,0.,2.),1.,Mat(.9,vec3(1.),vec3(0.),vec3(1.)));//vec3(1.5,0.,2.)\n    \n    world.boxes[0] = Box(vec3(0.,9.05,2.),vec3(6.,.1,6.),d2r(vec3(0.)),Mat(.25,vec3(.5),vec3(1.25),vec3(.5)));\n    world.boxes[1] = Box(vec3(6.05,3.,2.),vec3(.1,6.,6.),d2r(vec3(0.)),Mat(.75,vec3(0.,1.,0.),vec3(0.),vec3(0.,1.,0.)));\n    world.boxes[2] = Box(vec3(-6.05,3.,2.),vec3(.1,6.,6.),d2r(vec3(0.)),Mat(.75,vec3(1.,0.,0.),vec3(0.),vec3(1.,0.,0.)));\n    world.boxes[3] = Box(vec3(0.,3.,6.05),vec3(6.,6.,.1),d2r(vec3(0.)),Mat(.75,vec3(.25,.4,1.),vec3(0.),vec3(.25,.4,1.)));\n    \n    world.planes[0] = Plane(vec4(normalize(vec3(0.,1.,0.)),-1.),Mat(.5,vec3(1.),vec3(0.),vec3(1.)));\n}\n\nvec3 getSky(float t,vec3 rd) {\n    vec3 color = vec3(.25,.55,.85);\n    color = mix(color,vec3(.2),sat(.7-3.*rd.y));\n    color = mix(color,vec3(.05),sat(1.-5.*abs(rd.y)));\n    return color;\n    return vec3(0.);\n}\n\n\nHit intersect(vec3 ro, vec3 rd, World world) {\n    vec3 r = vec3(9999.,-1.,-1.);\n    \n    for(int i = 0; i<d_spw;i++) {\n        float d = sphereInt(ro,rd,world.spheres[i]);\n        if(d<r.x&&d>=.001) r = vec3(d,i,0.);\n    }\n    \n    for(int i = 0; i<WorldSize;i++) {\n        float d = planeInt(ro,rd,world.planes[i].p);;\n        if(d<r.x&&d>=.001) r = vec3(d,i,1.);\n    }\n    \n    for(int i = 0; i<d_bpw;i++) {\n        mat3 rot = rot3(-world.boxes[i].rot);\n        float d = boxInt((ro-world.boxes[i].pos)*rot,rd*rot,world.boxes[i].siz);\n        if(d<r.x&&d>=.001) r = vec3(d,i,2.);\n    }\n    \n    Hit h = Hit(int(r.y),int(r.z),vec3(0.),r.x);\n    \n    vec3 p = ro+rd*h.len;\n    \n    if(h.type==0) h.nor = normalize(p-world.spheres[h.id].pos);\n    else if(h.type==1) h.nor = world.planes[h.id].p.xyz;\n    else if(h.type==2) {Box b = world.boxes[h.id];h.nor = boxNor(b,b.pos+(p-b.pos)*rot3(-b.rot))*rot3(b.rot);}\n    \n    return h;\n}\n\nbool shadow(vec3 ro,vec3 rd,float len,World world) {\n    vec3 r = vec3(9999.,-1.,-1.);\n    \n    for(int i = 0; i<d_spw*WorldSize;i++) {\n        float d = sphereInt(ro,rd,world.spheres[i]);\n        if(d<r.x&&d>=.001) r = vec3(d,i,0.);\n    }\n    \n    for(int i = 0; i<WorldSize;i++) {\n        float d = planeInt(ro,rd,world.planes[i].p);\n        if(d<r.x&&d>=.001) r = vec3(d,i,1.);\n    }\n    \n    for(int i = 0; i<d_bpw;i++) {\n        mat3 rot = rot3(-world.boxes[i].rot);\n        float d = boxInt((ro-world.boxes[i].pos)*rot,rd*rot,world.boxes[i].siz);\n        if(d<r.x&&d>=.001) r = vec3(d,i,2.);\n    }\n    \n    if(r.x>=len||r.y==-1.) return true;\n    return false;\n    \n}\n\nvec3 newRay(inout vec3 ro,inout vec3 rd,vec3 p,vec3 n,Mat m) {\n    vec3 oro = ro; vec3 ord = rd;\n    ro = p;\n    vec3 reflected = reflect(rd,n);\n    rd = normalize((1.0001-m.r)*reflected+m.r*cosDir(reflected));\n    return mix(m.col,m.spc,1.-m.r);\n}\n\nvoid mainImage( out vec4 o, in vec2 i ){\n    irand(i,float(iFrame));\n    \n    float ftime;\n    if(mode==0.){\n        o = texelFetch(iChannel0,ivec2(i),0);\n        ftime = 0.;\n    } else if(mode==1.) {\n        o = vec4(0.);\n        ftime = iTime;\n    }else{\n        if(iTimeDelta*mode>1.) {\n        o = vec4(0.);\n        }else{\n        o = texelFetch(iChannel0,ivec2(i),0);\n        }\n        ftime = 0.;\n    }\n    if(texture(iChannel3, vec2(32.5/256.0,0.25)).x > 0.1) o = vec4(0.);\n    \n    #if fovInDeg==0\n    float dv = 1./tan(FOV/2.);\n    #else\n    float dv = 1./tan(PI*FOV/360.);\n    #endif\n    \n    vec3 ttcol = vec3(0.);\n    for(float _i = 0.; _i<spp;_i++) {\n        vec2 p1 = (-R+ 2.*(i + rand2())) / R.y;\n        \n        vec3 er = normalize(vec3(p1,dv));\n        float ctime = ftime - rand()*shutAp/24.;\n        \n        World world;\n        Viewer cam;\n        getScene(ctime,world,cam);\n        \n        \n        vec3 rd = er.x*cam.uu + er.y*cam.vv+er.z*cam.ww;\n        \n        vec3 go = blurAmt*vec3(-1.+2.*rand2(),0.);\n        vec3 gd = normalize( er*fcsDist-go );\n        cam.ro += go.x*cam.uu + go.y*cam.vv;\n        rd += gd.x*cam.uu + gd.y*cam.vv;\n        rd = normalize(rd);\n        \n        //The light is down here because the volumetric script also needs to access it,\n        //and because we can precompute it.\n        Light l = Light(vec3(0.,8.9,2.)+uniformVec()*.1,vec3(1.),40.);\n        \n        vec3 tcol = vec3(0.);\n        vec3 fcol = vec3(1.);\n        float ft;\n        vec3 fn;\n        vec3 oro = cam.ro; vec3 ord = rd;\n        for(int _j = 0; _j<numLvls;_j++) {\n            Hit hit = intersect(cam.ro,rd,world);\n            if(hit.type==-1) {tcol+=getSky(ctime,rd)*fcol;ft=-1.;break;}\n            if(_j==0) {ft = hit.len;fn=hit.nor;}\n            \n            vec3 p = hit.len*rd+cam.ro;\n            Mat mat;\n            if(hit.type==0) {mat = world.spheres[hit.id].m;}\n            else if(hit.type==1) {mat = world.planes[hit.id].m;}\n            else if(hit.type==2) {mat = world.boxes[hit.id].m;}\n            /*\n            vec3 color = vec3(0.);\n            \n            vec3 L = normalize(l.pos-p);\n            float d = length(l.pos-p);\n            \n            if(shadow(p,L,d,world)){\n                vec3 radiance = l.col*l.str/(d*d);\n                vec3 H = normalize(-rd+L);\n                vec3 kd = vec3(mat.r);\n                vec3 ks = 1.-kd;\n                \n                vec3 dif = kd*mat.col;\n                vec3 spec = ks*pow(md(hit.nor,H),2.5/mat.r);\n                color += (dif+spec)*md(hit.nor,L)*radiance;\n            }\n            */\n            \n            tcol += mat.ems*fcol;\n            fcol *= newRay(cam.ro,rd,p,hit.nor,mat);\n            if(_j>2){\n                float m = max(fcol.x,max(fcol.y,fcol.z));\n                if(rand()>m) break;\n                fcol /= m;\n            }\n        }\n        \n        ttcol += tcol;\n    }\n    o += vec4(ttcol / spp,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n#define PI 3.1415926523\n#define sat(a) clamp(a,0.,1.)\n#define md(a,b) max(dot(a,b),0.)\n#define d2r(a) a*(PI/180.)\n\nfloat _seed;\nfloat rand(void) {\n    _seed += 1.;\n    return fract(81.29*sin(38.23*+_seed-12.13)-12.21);\n}\nvec2 rand2(void) {return vec2(rand(),rand());}\nfloat srand(float s) {\n    return fract(81.29*sin(38.23*s-12.13)-12.21);\n}\nvoid irand(vec2 c,float f){\n    _seed = srand(f)*f+srand(c.x)*c.y+srand(c.y)*c.x;\n}\n\n\nstruct Mat {\n    float r;\n    vec3 col;\n    vec3 ems;\n    vec3 spc;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float rad;\n    Mat m;\n};\n\nstruct Plane {\n    vec4 p;\n    Mat m;\n};\n\nstruct Box{\n    vec3 pos,siz,rot;\n    Mat m;\n};\n\nstruct Quad {\n    vec3 v0,v1,v2,v3;\n    Mat m;\n};\n\n//d_spw => Spheres per world\n//d_bpw => Boxes per world\n//WorldSize => Planes per world (For now). Not reccomended to change this.\n#define d_spw 2\n#define d_bpw 4\n#define WorldSize 1\nstruct World {\n    Sphere spheres[d_spw];\n    Plane planes[WorldSize];\n    Box boxes[d_bpw];\n};\n//TODO: Add more uses for WorldSize. Use it for lights as well? Should the number of planes be kept at 1?\nstruct Viewer {\n    vec3 uu;\n    vec3 vv;\n    vec3 ww;\n    vec3 ro;\n};\n\nstruct Hit {\n    int id;\n    int type;\n    vec3 nor;\n    float len;\n};\n\nstruct Light {\n    vec3 pos,col;\n    float str;\n};\n\n\nfloat sphereInt( in vec3 ro, vec3 rd, Sphere sphere) {\n    ro -= sphere.pos;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sphere.rad*sphere.rad;\n    float h = b*b - c;\n    if( h<0. ) return -1.;\n    h = sqrt( h );\n    return -b-h;\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)-p.w)/dot(rd,p.xyz);\n}\n//The following function was generated by Bing AI\nfloat quadInt(vec3 ro, vec3 rd, Quad q) {\n    // Compute quad normal and plane constant\n    vec3 n = cross(q.v1 - q.v0, q.v2 - q.v0);\n    float d = dot(n, q.v0);\n    \n    // Check if ray is parallel to quad\n    float nd = dot(n, rd);\n    if (abs(nd) < 1e-6) return -1.;\n    \n    // Compute ray-plane intersection\n    float t = (d - dot(n, ro)) / nd;\n    if (t < 0.) return -1.;\n    vec3 p = ro + t * rd;\n    \n    // Check if intersection point is inside quad\n    vec3 e0 = q.v1 - q.v0;\n    vec3 e1 = q.v2 - q.v1;\n    vec3 e2 = q.v3 - q.v2;\n    vec3 e3 = q.v0 - q.v3;\n    vec3 c0 = p - q.v0;\n    vec3 c1 = p - q.v1;\n    vec3 c2 = p - q.v2;\n    vec3 c3 = p - q.v3;\n    if (dot(n, cross(e0, c0)) > 0. &&\n        dot(n, cross(e1, c1)) > 0. &&\n        dot(n, cross(e2, c2)) > 0. &&\n        dot(n, cross(e3, c3)) > 0.) {\n        return t;\n    }\n    \n    // Otherwise, no hit\n    return -1.;\n}\n\nfloat boxInt( in vec3 ro, in vec3 rd, vec3 b) \n{\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*b;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return -1.;\n    return tN;\n}\n\nconst float bias = 1.0001;\nvec3 boxNor(Box b,vec3 p){\n    vec3 q = p-b.pos;\n    vec3 d = b.siz;\n    return normalize(vec3(ivec3(q/d*bias)));\n}\n\nvec3 cosDir(vec3 nor)\n{\n    float u = rand();\n    float v = rand();\n    float a = 2.*PI*v; float b = 2.*u-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*PI;\n    float x = rand()*2.-1.;\n    float z = rand();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c,-s,\n                 s, c);\n}\nmat3 rot3(vec3 a){\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    \n    mat3 xm = mat3(1., 0., 0.,\n                   0., c.x, -s.x,\n                   0., s.x, c.x );\n    \n    mat3 ym = mat3(c.y, 0.,-s.y,\n                   0.,1.,0.,\n                   s.y,0.,c.y);\n    \n    mat3 zm = mat3(c.z,s.z,0.,\n                   -s.z,c.z,0.,\n                   0.,0.,1.);\n    \n    \n    return xm*ym*zm;\n}\nvec3 hemi(vec3 n){\n    vec3 o = uniformVec();\n    float sd = sign(dot(n,o));\n    sd = sd==0.?1.:sd;\n    return o*sd;\n}\n//Hi! Do you hate the scene? Change the constand in the rz variable under the scene to zero to fix that. :)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 o, vec2 i )\n{\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    o.xyz = dot(o.xyz,vec3(1.))>2.?o.xyz:vec3(0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}