{
    "Shader": {
        "info": {
            "date": "1678900448",
            "description": "Press:\nWASD to move\nSpace to draw\nR to reset\nC to clear\n\nYou can also change number of limbs in the common tab, >20 ish looks cool",
            "flags": 48,
            "hasliked": 0,
            "id": "dsVGRc",
            "likes": 35,
            "name": "Interactive Jumper",
            "published": 3,
            "tags": [
                "distancefield",
                "game",
                "interactive",
                "buffer"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "#define ss(a) smoothstep(-1., 1., a)\n\n// From iq: https://iquilezles.org/articles/simpleik/\nvec2 solve(vec2 p, float r1, float r2, float i) {\n    float h = dot(p,p);\n    float w = h + r1*r1 - r2*r2;\n    float s = max(4.0*r1*r1*h - w*w,0.0);\n    return (w*p + i * vec2(-p.y,p.x)*sqrt(s)) * 0.5/h;\n}\n\nvoid drawGrabber(vec2 px, inout vec3 col, vec4 txBody, float i) {\n\n    // Grabber data - position and active state\n    vec4 txGrab = cell(ch0, ivec2(1, i));\n    \n    // Normal and tangent lines at grab point (debugging)\n    // vec2 n0 = norm(ch2, ivec2(txQ.xy));\n    // vec2 n1 = vec2(-n0.y, n0.x);\n        \n    // Hip position\n    vec2 hip = txBody.xy + hipOffset(ch0, t, i);\n    \n    // Mix foot between grab position and hip, using active state\n    float mx = grabMix(txGrab.z);\n    vec2 foot = mix(hip, txGrab.xy, mx);\n    \n    // Use IK to get knee position\n    float r = 0.35 * grabRadius;\n    vec2 knee = hip + solve(foot - hip, r, r, 1.); //2.*mod(i,2.)-1.); \n    knee = mix(hip, knee, mx);\n    \n    // Distances\n    // float dn0 = seg(px, txQ.xy, txQ.xy - 20. * n0);    \n    // float dn1 = seg(px, txQ.xy - 20. * n1, txQ.xy + 20. * n1);\n    float dHip      = length(px - hip);\n    float dFoot     = length(px - foot);\n    float dKnee     = length(px - knee);\n    float dBodyHip  = seg(px, txBody.xy, hip);\n    float dHipKnee  = seg(px, hip, knee); \n    float dKneeFoot = seg(px, knee, foot);\n    float dGrab     = length(px-foot); //abs(grabRadius - length(px - foot));\n    float dWhite    = min(dHip, min(dFoot, dKnee));\n    float dBlack    = min(dBodyHip, min(dHipKnee, dKneeFoot));\n    \n    // Smoothstep\n    float sWhite  = ss(jointRadius - dWhite); \n    float sBlack  = ss(lineThick - dBlack);\n    float sBlack2 = ss(0.5 * jointRadius - dWhite);\n    float sGrab   = ss(2. * jointRadius - dGrab);\n    \n    // Draw\n    if (txGrab.z == inFrames + outFrames)\n        col = mix(col, vec3(1,0,0), 0.5 * sGrab); \n    col = mix(col, vec3(0), sBlack);\n    col = mix(col, vec3(1), sWhite);   \n    col = mix(col, vec3(0), sBlack2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    \n    ivec2 ipx = ivec2(px);\n    vec4 txBody = cell(ch0, ivec2(0,0)); \n    vec4 txB    = cell(ch2, ipx);\n    \n    // Distances\n    float dBody = length(px - txBody.xy);   \n\n    // Smoothstep\n    float sBodyW = ss(bodyRadius - dBody);\n    float sBodyB = ss(lineThick - abs(bodyRadius - dBody));\n    float sB     = ss(2. - txB.r);\n        \n    //vec2 n = norm(ch2, ipx);\n    //vec2 txUv = vec2(atan(n.y,n.x)/pi, 4.*txB.r/res.y) + 0.02 * t;\n    //vec3 col = texture(ch1, txUv).rgb;\n    \n    // Draw\n    vec3 col = vec3(0.8) / cosh(2.3 * length(uv));\n    \n    col = mix(col, vec3(0), sB);    \n    for (float i = 0.; i < limbs; i++) \n        drawGrabber(px, col, txBody, i);      \n    col = mix(col, vec3(1), sBodyW);\n    col = mix(col, vec3(0), sBodyB);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define KEYBOARD iChannel1\n\n// This buffer stores point information\n\n// note:\n// could calculate body's next position in grab position logic\n// so grab position isn't delayed by a frame\n\n// Grab logic reference:\n//            inactive, 0 -> cooldown out, in+1\n//        cooldown out, n -> cooldown out, n+1\n// cooldown out, in+out-1 -> active, in+out\n//         active, in+out -> cooldown in, in\n//         cooldown in, n -> cooldown in, n-1\n//         cooldown in, 1 -> inactive, 0\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);    \n    vec4 txBody  = cell(ch0, ivec2(0, 0));      // Body point\n    vec4 txA     = cell(ch0, ipx);              // Current cell\n    vec4 txBodyD = cell(ch2, ivec2(txBody.xy)); // Distance at body\n    \n    // Initialize points on reset\n    if (iFrame < 3 || key_down(KEY_RESET)) {\n            txA = vec4(0.5 * res, 0, 0);\n    }\n    \n    // Body position\n    if (ipx == ivec2(0, 0)) {\n    \n        // Update velocity\n        txA.z += 0.5 * (key_val(KEY_D) - key_val(KEY_A));\n        txA.w += 0.5 * (key_val(KEY_W) - key_val(KEY_S));\n             \n        // Push away from grab position if active\n        for (float i = 0.; i < limbs; i++) {\n            vec4 txGrab = cell(ch0, ivec2(1, i));\n            vec2 n = norm(ch2, ivec2(txGrab.xy));\n               \n            if (txGrab.z == inFrames + outFrames)\n                txA.zw -= 0.5 / limbs * vec2(-n.y,n.x);      \n        }\n        \n        // Normal\n        vec2 n = norm(ch2, ivec2(txA.xy));\n        \n        // Move tangent to curve\n        txA.zw += 0.03 * vec2(-n.y,n.x);\n        \n        // Aim for fixed distance from curve\n        if (txBodyD.r < 0.5 * grabRadius)\n            txA.zw -= 0.05 * n;\n        else\n            txA.zw += 0.25 * n;\n        \n        // Friction\n        txA.zw *= 0.95;\n        \n        // Old/New distance to buffer\n        float d0 = cell(ch2, ivec2(txA.xy)).r;          \n        float d1 = cell(ch2, ivec2(txA.xy + txA.zw)).r; \n        \n        // If crossed boundary then push back\n        if (d0 > bodyRadius && d1 < bodyRadius) \n            txA.zw = -n * length(txA.zw);\n        \n        // Update position\n        txA.xy += txA.zw;\n        txA.xy = clamp(txA.xy, vec2(bodyRadius + lineThick), \n                               res - bodyRadius - lineThick);\n    } \n    \n    // Save old body position\n    else if (ipx == ivec2(0, 1)) \n        txA = txBody;\n        \n    // Lerp body normal between frames\n    else if (ipx == ivec2(0, 2)) {\n        vec2 n = norm(ch2, ivec2(txBody.xy));\n        txA.xy = mix(txA.xy, n, 0.05);\n    }\n    \n    // Grab position\n    else if (ipx.x == 1) {\n    \n        // Hip position\n        vec2 hip = txBody.xy + hipOffset(ch0, t, px.y);\n        \n        // Distance field value at hip position\n        float dField = cell(ch2, ivec2(hip)).r;\n        \n        // Distance from cell to hip position\n        float dHip = length(txA.xy - hip);\n  \n        // Inactive (grab position == hip position)\n        if (txA.z == 0.) { \n            // Become active\n            if (dField <= grabRadius) {\n                vec2 nHip = norm(ch2, ivec2(hip));\n                txA.xy = hip + (dField-lineThick-jointRadius) * nHip;\n                txA.z = inFrames + 1.;\n            }\n        } \n        \n        // Cooldown into body\n        else if (txA.z <= inFrames) \n            txA.z--; \n            \n        // Cooldown out of body\n        else if (txA.z < inFrames + outFrames) \n            txA.z++;\n            \n        // Active\n        else if (txA.z == inFrames + outFrames) { \n            vec2 pq = normalize(hip - txA.xy);\n            vec2 n = norm(ch2, ivec2(txA.xy));\n            \n            // idea: become inactive if previous limb is active\n            // vec4 txGrab0 = cell(ch0, ivec2(1, mod(px.y + 1., limbs)));\n            \n            // Become inactive if out of range or below tangent\n            if (dHip > grabRadius || dot(pq, n) > 0.) { \n                txA.z = inFrames;\n            }\n        }\n        \n        txA.z = clamp(txA.z, 0., inFrames + outFrames);\n    }\n   \n   fragColor = txA;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define t iTime\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define mlength(a) max(abs((a).x), abs((a).y))\n#define res iResolution.xy\n\n// low inFrames+outFrames and high limbs is really unsettling\n#define bodyRadius 14.\n#define jointRadius (0.5 * bodyRadius)\n#define grabRadius 110.\n#define lineThick 2.\n#define inFrames 30.\n#define outFrames 30.\n\n// Change me!\n#define limbs 3.\n\n#define key_val(key) texelFetch(KEYBOARD, ivec2(key, 0), 0).x\n#define key_down(key) int(key_val(key)) == 1\n#define KEY_RESET 82\n#define KEY_SPACE 32\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_C 67\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\nvec4 cell(in sampler2D ch, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(ch, 0));\n    p = (p+r) % r;\n    return texelFetch(ch, p, 0);\n}\n\n// Taken from stb's shader:\n// https://www.shadertoy.com/view/3tfcDM\nvec2 norm(in sampler2D ch, in ivec2 p) {\n    ivec3 e = ivec3(0, -1, 1);\n    return normalize(vec2(cell(ch, p-e.zx).r - cell(ch, p-e.yx).r,\n                          cell(ch, p-e.xz).r - cell(ch, p-e.xy).r));\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// [0, inFrames, inFrames + outFrames] -> [0, 1, 0]\nfloat grabMix(float i) {\n    if (i <= inFrames)\n        return pow(i / inFrames, 2.);   \n    return (i - inFrames) / outFrames;\n}\n\nvec2 hipOffset(in sampler2D ch, float t, float i) {\n    // Lerped normal\n    vec2 n = normalize(cell(ch, ivec2(0,2)).xy);\n    \n    // Rotate each hip by index\n    n *= rot(2. * pi * i / limbs + pi/limbs); // was t, not pi/2.\n    \n    return 2. * bodyRadius * n;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define KEYBOARD iChannel1\n\n// This buffer stores the distance field\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    \n    vec4 txBody  = cell(ch0, ivec2(0, 0)); // Body point\n    vec4 txBody0 = cell(ch0, ivec2(0, 1)); // Previous body point\n    vec4 txB     = cell(ch2, ipx);         // Current cell\n    \n    // Initialize on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) {\n        float d = seg(px, vec2(0.25,0.5)*res,vec2(0.75,0.5)*res);//length(px - 0.5 * res);\n        //d = min(d, abs(0.48 * res.y - mlength(px - 0.5 * res)));\n        txB = vec4(d, 0, 0, 0);\n    } else if (key_down(KEY_C)) {\n        float d = length(px - 0.5 * res);\n        txB = vec4(d, 0, 0, 0);\n    }\n    \n    // Draw distances if space pressed\n    if (key_down(KEY_SPACE)) {\n        float d = seg(px, txBody.xy, txBody0.xy);\n        txB.r = min(txB.r, d);\n    }\n    \n    fragColor = txB;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}