{
    "Shader": {
        "info": {
            "date": "1457552547",
            "description": "A basic raytracer with help from inigo's article: https://iquilezles.org/articles/simplegpurt/simplegpurt.htm",
            "flags": 0,
            "hasliked": 0,
            "id": "XdcSzH",
            "likes": 25,
            "name": "A ray tracer",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "refraction"
            ],
            "usePreview": 0,
            "username": "knightcrawler25",
            "viewed": 3401
        },
        "renderpass": [
            {
                "code": "const int iterations = 5;\nconst float maxDist = 1000.0;\nconst vec3 amb = vec3(1.0);\nconst float eps = 1e-3;\n\nstruct Camera\n{\n\tvec3 up, right, forward;\n\tvec3 position;\n};\n\nCamera cam;\nvec4 spheres[10];\nvec4 colors[10];\nvec2 materials[10];\n\nvoid init()\n{\n    // X Y Z Radius\n    spheres[0] = vec4(      0,       0,    -1.5,    0.1);\n    spheres[1] = vec4(      0,    0.25,    -1.5,    0.1);\n    spheres[2] = vec4(      0,    -0.7,    -1.5,    0.3);\n    spheres[3] = vec4(      0,    -0.1,    -1.5,    0.3);\n    spheres[4] = vec4(      0,    -0.1,    -1.5,    0.15);\n    spheres[5] = vec4( 1001.0,       0,       0, 1000.0); \n    spheres[6] = vec4(-1001.0,       0,       0, 1000.0);\n    spheres[7] = vec4(      0,  1001.0,       0, 1000.0); \n    spheres[8] = vec4(      0, -1001.0,       0, 1000.0);\n    spheres[9] = vec4(      0,       0, -1002.0, 1000.0);\n\n    //R G B Diffuse\n    colors[0] = vec4(1.0, 0.8, 0.0,-1.0);\n    colors[1] = vec4(0.0, 0.0, 1.0,-1.0);\n    colors[2] = vec4(1.0, 1.0, 1.0, 1.0);\n    colors[3] = vec4(1.0, 1.0, 1.0, 1.0);\n    colors[4] = vec4(1.0, 0.0, 0.0, 1.0);\n    colors[5] = vec4(0.0, 1.0, 0.0, 0.7);\n    colors[6] = vec4(1.0, 0.0, 0.0, 0.7);\n    colors[7] = vec4(1.0, 1.0, 1.0, 0.7);\n    colors[8] = vec4(1.0, 1.0, 1.0, 0.7);\n    colors[9] = vec4(1.0, 1.0, 1.0, 0.7);\n\n    //Reflection Coeff, Refraction index\n    materials[0] = vec2 (0.0, 0.0);\n    materials[1] = vec2 (0.0, 0.0);\t\t\t\t\n    materials[2] = vec2 (1.0, 0.0);\t\n    materials[3] = vec2 (0.1, 0.8);\t\n    materials[4] = vec2 (0.1, 0.8);\t\n    materials[5] = vec2 (0.0, 0.0);\t\t\t\t\n    materials[6] = vec2 (0.0, 0.0);\t\t\t\t\n    materials[7] = vec2 (0.1, 0.0);\t\t\t\t\n    materials[8] = vec2 (0.1, 0.0);\t\t\t\t\n    materials[9] = vec2 (0.1, 0.0);\t\n\n    cam.up       = vec3(0.0, 1.0, 0.0);\n    cam.right    = vec3(1.0, 0.0, 0.0);\n    cam.forward  = vec3(0.0, 0.0,-1.0);\n    cam.position = vec3(0.0, 0.0,-0.2);\n}\n\nvec3 getRayDir(vec2 fragCoord)\n{\n  vec2 uv = (fragCoord.xy / iResolution.xy )*2.0 - 1.0;\n  uv.x *= iResolution.x/iResolution.y;                   \n  return normalize(uv.x * cam.right + uv.y * cam.up + cam.forward);\n}\n\n\n// The Intersection funtions and shading funcs are taken from inigo's article:\n// https://iquilezles.org/articles/simplegpurt\n\nbool intersectSphere(vec3 ro, vec3 rd, vec4 sp, float tm, out float t)\n{\n    bool r = false;\n\tvec3 v = ro - sp.xyz;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - sp.w*sp.w;\n\tt = b*b-c;\n    if( t > 0.0 )\n    {\n        t = -b-sqrt(t);\n        r = (t > 0.0) && (t < tm);\n    }\n    return r;\n}\n\nfloat calcInter(vec3 ro, vec3 rd, out vec4 ob, out vec4 col,out vec2 mat)\n{\n\tfloat tm = maxDist;\n\tfloat t;\n\n\tif(intersectSphere(ro,rd,spheres[0],tm,t)) { ob = spheres[0]; col = colors[0]; tm = t; mat = materials[0]; }\n\tif(intersectSphere(ro,rd,spheres[1],tm,t)) { ob = spheres[1]; col = colors[1]; tm = t; mat = materials[1]; }\n\tif(intersectSphere(ro,rd,spheres[2],tm,t)) { ob = spheres[2]; col = colors[2]; tm = t; mat = materials[2]; }\n\tif(intersectSphere(ro,rd,spheres[3],tm,t)) { ob = spheres[3]; col = colors[3]; tm = t; mat = materials[3]; }\n\tif(intersectSphere(ro,rd,spheres[4],tm,t)) { ob = spheres[4]; col = colors[4]; tm = t; mat = materials[4]; }\n\tif(intersectSphere(ro,rd,spheres[5],tm,t)) { ob = spheres[5]; col = colors[5]; tm = t; mat = materials[5]; }\n\tif(intersectSphere(ro,rd,spheres[6],tm,t)) { ob = spheres[6]; col = colors[6]; tm = t; mat = materials[6]; }\n\tif(intersectSphere(ro,rd,spheres[7],tm,t)) { ob = spheres[7]; col = colors[7]; tm = t; mat = materials[7]; }\n\tif(intersectSphere(ro,rd,spheres[8],tm,t)) { ob = spheres[8]; col = colors[8]; tm = t; mat = materials[8]; }\n    if(intersectSphere(ro,rd,spheres[9],tm,t)) { ob = spheres[9]; col = colors[9]; tm = t; mat = materials[9]; }\n\n\treturn tm;\n}\n\nbool inShadow(vec3 ro,vec3 rd,float d)\n{\n\tfloat t;\n\tbool ret = false;\n\n\tif(intersectSphere(ro,rd,spheres[2],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[3],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[4],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[5],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[6],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[7],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[8],d,t)){ ret = true; }\n\n\treturn ret;\n}\n\nvec3 calcShade(vec3 pt, vec4 ob, vec4 col,vec2 mat,vec3 n)\n{\n\n\tfloat dist,diff;\n\tvec3 lcol,l;\n\n\tvec3 color = vec3(0.0);\n\tvec3 ambcol = amb * (1.0-col.w) * col.rgb;\n\tvec3 scol = col.w * col.rgb;\n\n\tif(col.w > 0.0) //If its not a light\n\t{\n\t\tl = spheres[0].xyz - pt;\n\t\tdist = length(l);\n\t\tl = normalize(l);\n\t\tlcol = colors[0].rgb;\n\t\tdiff = clamp(dot(n,l),0.0,1.0);\n\t\tcolor += (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);\n\t\tif(inShadow(pt,l,dist))\n\t\t\tcolor *= 0.7;\n\n\t\tl = spheres[1].xyz - pt;\n\t\tdist = length(l);\n\t\tl = normalize(l);\n\t\tvec3 lcol = colors[1].rgb;\n\t\tdiff = clamp(dot(n,l),0.0,1.0);\n\t\tcolor += (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);\n\n\t\tif(inShadow(pt,l,dist))\n\t\t\tcolor *= 0.7;\n\t}\n\telse\n\t\tcolor = col.rgb;\n\n\treturn color;\n}\n\nfloat getFresnel(vec3 n,vec3 rd,float r0)\n{\n    float ndotv = clamp(dot(n, -rd), 0.0, 1.0);\n\treturn r0 + (1.0 - r0) * pow(1.0 - ndotv, 5.0);\n}\n\nvec3 getReflection(vec3 ro,vec3 rd)\n{\n\tvec3 color = vec3(0);\n\tvec4 ob,col;\n    vec2 mat;\n\tfloat tm = calcInter(ro,rd,ob,col,mat);\n\tif(tm < maxDist)\n\t{\n\t\tvec3 pt = ro + rd*tm;\n\t\tvec3 n = normalize(pt - ob.xyz);\n\t\tcolor = calcShade(pt,ob,col,mat,n);\n\t}\n\treturn color;\n}\n\nvoid rotObjects()\n{\n\tspheres[0].x += sin(iTime) * 0.4;\n    spheres[0].z += cos(iTime) * 0.4;\n    \n    spheres[1].x += sin(iTime) * -0.3;\n    spheres[1].z += cos(iTime) * -0.3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n\tfloat fresnel,tm;\n\tvec4 ob,col;\n    vec2 mat;\n\tvec3 pt,refCol,n,refl;\n\n\tvec3 mask = vec3(1.0);\n\tvec3 color = vec3(0.0);\n\tvec3 ro = cam.position;\n\tvec3 rd = getRayDir(fragCoord);\n    \n    rotObjects();\n\t\n\tfor(int i = 0; i < iterations; i++)\n\t{\n\t\ttm = calcInter(ro,rd,ob,col,mat);\n\t\tif(tm < maxDist)\n\t\t{\n\t\t\tpt = ro + rd*tm;\n\t\t\tn = normalize(pt - ob.xyz);\n\t\t\tfresnel = getFresnel(n,rd,mat.x);\n\t\t\tmask *= fresnel;\n            \n\t\t\tif(mat.y > 0.0) // Refractive\n\t\t\t{\n\t\t\t\tro = pt - n*eps;\n\t\t\t\trefl = reflect(rd,n);\n\t\t\t\trefCol = getReflection(ro, refl);\n\t\t\t\tcolor += refCol * mask;\n\t\t\t\tmask = col.rgb * (1.0 - fresnel) * (mask / fresnel);\n\t\t\t\trd = refract(rd, n, mat.y);\n\t\t\t}\n\t\t\telse if(mat.x > 0.0) // Reflective\n\t\t\t{\n\t\t\t\tcolor += calcShade(pt,ob,col,mat,n) * (1.0 - fresnel) * mask / fresnel;\n\t\t\t\tro = pt + n*eps;\n\t\t\t\trd = reflect(rd, n);\n\t\t\t}\n\t\t\telse // Diffuse\n            {\n\t\t\t\tcolor += calcShade(pt,ob,col,mat,n) * mask/fresnel;\n                break;\n            }\n\t\t}\n\t}\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}