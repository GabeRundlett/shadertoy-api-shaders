{
    "Shader": {
        "info": {
            "date": "1707615020",
            "description": "balls of fbm, more fun with balls",
            "flags": 0,
            "hasliked": 0,
            "id": "4Xs3RS",
            "likes": 6,
            "name": "fbm balls",
            "published": 3,
            "tags": [
                "fbm"
            ],
            "usePreview": 0,
            "username": "pb",
            "viewed": 202
        },
        "renderpass": [
            {
                "code": "//philip.bertani@gmail.com\n\nfloat numOct  = 6. ;  //number of fbm octaves\nvec3 nn;\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 5e5 );\n}\n\nmat2 rot2(float an){float cc=cos(an),ss=sin(an); return mat2(cc,-ss,ss,cc);}\n\n//this is the noise func everyone uses...\nfloat noise(vec3 p) {\n    vec2 i = floor(p.yz);\n    vec2 f = fract(p.yz);\n    float a = random(i + vec2(0.,0.));\n    float b = random(i + vec2(1.,0.));\n    float c = random(i + vec2(0.,1.));\n    float d = random(i + vec2(1.,1.));\n    vec2 u = f*f*(3.-2.*f); \n    \n    return mix( mix(a,b,u.x), mix(c,d,u.x), u.y);\n}\n\nfloat fbm3d(vec3 p) {\n\n    float v = 0.;\n    float a = .4;\n\n    for (float i=0.; i< numOct ; i++) {\n        v += a * noise(p);\n        \n        p += nn * 8.;\n        a *= .7 * (1. + cos( nn.x + nn.y + p.z/3.  ) ) ;\n    }\n    return v;\n}\n\n\nfloat dist_func01(vec3 p) {\n\n    p = mod(p-5.,10.)-5. ;\n  \n    float dist = length(p) - 4.5;\n    \n    return dist;\n}\n\nvec3 gradient(vec3 p) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = .001 * dpn; \n\n    vec3 df = dpn.xxx * dist_func01(p+dp.xxx) +\n              dpn.yyx * dist_func01(p+dp.yyx) +\n              dpn.xyy * dist_func01(p+dp.xyy) +\n              dpn.yxy * dist_func01(p+dp.yxy);\n\n    return normalize(df); \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y ;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 rd = normalize( vec3(uv, -1.2) );  \n    vec3 ro = vec3(5,0,-iTime*3.); \n    \n    float delta = iTime/ 20. ; \n        \n    rd.yz *= rot2(-delta/2. );\n    rd.xz *= rot2(delta*3.);\n    vec3 p = ro ;\n\n    float dist = 0., totdist = 0.;\n    for (float i=0.; i< 100.; i++) {\n        dist = length( mod(p-5.,10.)-5. ) - 4.;\n        p += dist * rd;\n        totdist += dist;\n    }\n    \n    nn = gradient(p);\n    \n    vec3 light = normalize( vec3( cos(iTime*2.), sin(iTime*3.) , 0.)  );\n    \n    nn = cross(light, nn);\n    \n    vec3 q = vec3( fbm3d(p), fbm3d(p.yzx), fbm3d(p.zxy) ) ;\n\n    float f = fbm3d(p + q);\n    \n    vec3 cc = q.x*vec3(1,1,0) + q.y*vec3(1,0,1) + q.z*vec3(0,1,1);\n    //cc *= f ;   \n\n    fragColor = vec4( cc * exp(-totdist/1e1),1.0);\n    \n    fragColor = 1. - exp(-fragColor * fragColor); \n    \n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}