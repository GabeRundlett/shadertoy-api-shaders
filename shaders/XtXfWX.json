{
    "Shader": {
        "info": {
            "date": "1513478569",
            "description": "Various HSV-to-RGB conversion functions. Drag in top part to display a single function or in bottom part to compare two functions. Pause and rewind time for development mode.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtXfWX",
            "likes": 17,
            "name": "Plenty of HSV to RGB",
            "published": 3,
            "tags": [
                "spectrum",
                "rgb",
                "rainbow",
                "hsv",
                "hue",
                "function",
                "hsv2rgb",
                "conversion"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 923
        },
        "renderpass": [
            {
                "code": "#define borderW 10.0\n#define lineW 2.0\n#define dim 0.85\n#define num_f 10.\n\n// From http://blog.saikoled.com/post/45630908157/implementing-arbitrary-color-correction-with-the\nvec3 hsi2rgb(float H, float S, float I) {\n\tfloat r, g, b;\n\tfloat M_PI = radians(180.0);\n\tH = mod(H*360.0, 360.0); // cycle H around to 0-360 degrees\n\tH *= M_PI / 180.0; // Convert to radians.\n\tS = S > 0. ? (S < 1. ? S : 1.) : 0.; // clamp S and I to interval [0,1]\n\tI = I > 0. ? (I < 1. ? I : 1.) : 0.;\n\t// Math! Thanks in part to Kyle Miller.\n\tif(H < 2.09439) {\n\t\tr = I / 3. * (1. + S * cos(H) / cos(1.047196667 - H));\n\t\tg = I / 3. * (1. + S * (1. - cos(H) / cos(1.047196667 - H)));\n\t\tb = I / 3. * (1. - S);\n\t} else if(H < 4.188787) {\n\t\tH -= 2.09439;\n\t\tg = I / 3. * (1. + S * cos(H) / cos(1.047196667 - H));\n\t\tb = I / 3. * (1. + S * (1. - cos(H) / cos(1.047196667 - H)));\n\t\tr = I / 3. * (1. - S);\n\t} else {\n\t\tH -= 4.188787;\n\t\tb = I / 3. * (1. + S * cos(H) / cos(1.047196667 - H));\n\t\tr = I / 3. * (1. + S * (1. - cos(H) / cos(1.047196667 - H)));\n\t\tg = I / 3. * (1. - S);\n\t}\n\treturn vec3(r, g, b);\n}\n// From http://blog.saikoled.com/post/45630908157/implementing-arbitrary-color-correction-with-the\nvec4 hsi2rgbw_4(float H, float S, float I) {\n\tfloat r, g, b, w;\n\tfloat cos_h, cos_1047_h;\n\tfloat M_PI = radians(180.0);\n\tH = mod(H*360.0, 360.0); // cycle H around to 0-360 degrees\n\tH *= M_PI / 180.0; // Convert to radians.\n\tS = S > 0. ? (S < 1. ? S : 1.) : 0.; // clamp S and I to interval [0,1]\n\tI = I > 0. ? (I < 1. ? I : 1.) : 0.;\n\tif(H < 2.09439) {\n\t\tcos_h = cos(H);\n\t\tcos_1047_h = cos(1.047196667 - H);\n\t\tr = S * I / 3. * (1. + cos_h / cos_1047_h);\n\t\tg = S * I / 3. * (1. + (1. - cos_h / cos_1047_h));\n\t\tb = 0.;\n\t\tw = (1. - S) * I;\n\t} else if(H < 4.188787) {\n\t\tH -= 2.09439;\n\t\tcos_h = cos(H);\n\t\tcos_1047_h = cos(1.047196667 - H);\n\t\tg = S * I / 3. * (1. + cos_h / cos_1047_h);\n\t\tb = S * I / 3. * (1. + (1. - cos_h / cos_1047_h));\n\t\tr = 0.;\n\t\tw = (1. - S) * I;\n\t} else {\n\t\tH -= 4.188787;\n\t\tcos_h = cos(H);\n\t\tcos_1047_h = cos(1.047196667 - H);\n\t\tb = S * I / 3. * (1. + cos_h / cos_1047_h);\n\t\tr = S * I / 3. * (1. + (1. - cos_h / cos_1047_h));\n\t\tg = 0.;\n\t\tw = (1. - S) * I;\n\t}\n\treturn vec4(r, g, b, w);\n}\nvec3 hsi2rgbw(float h, float s, float i) {\n\tvec4 col = hsi2rgbw_4(h,s,i);\n\treturn col.rgb+ col.a;\n}\n// Spectrum with 6 distict peaks in hue and 3 in value\nvec3 hsv2rgb_peak6(float h, float s, float v) {\n\tvec3 hueP = max(vec3(0),abs(mod(h* 12.+ vec3( 0, 8,4),12.)- 6.)- 5.);\n\tvec3 hue1 = max(vec3(0),abs(mod(h* 12.+ vec3(11, 7,3),12.)- 6.)- 5.);\n\tvec3 hue2 = max(vec3(0),abs(mod(h* 12.+ vec3( 2,10,6),12.)- 6.)- 5.);\n\tvec3 hue3 = max(vec3(0),abs(mod(h* 12.+ vec3( 1, 9,5),12.)- 6.)- 5.);\n\tvec3 hueF = mat3(3,1,0,0,3,1,1,0,3)* hue1*.25;\n\tvec3 hueC = mat3(1,0,1,1,1,0,0,1,1)* hue2*1.;\n\tvec3 hueL = mat3(3,0,1,1,3,0,0,1,3)* hue3*.25;\n\tvec3 hue = hueP+ hueF+ hueC+ hueL;\n\treturn v* mix(vec3(1),hue,s);\n}\n// Constant brightness but desaturated\nvec3 hsv2rgb_cosine15(float h, float s, float v) {\n\tvec3 hue = .5+ .5* cos((3.* h+ vec3(0,2,1))* radians(120.0));\n\treturn v* mix(vec3(1),clamp(hue,0.,1.),s);\n}\n// Constant brightness but muddy mixes of primary colors\nvec3 hsv2rgb_cosine10(float h, float s, float v) {\n\tvec3 hue = .5*cos(min(vec3(.5),1.5 *abs(fract(h+.5+ vec3(0,2,1)/3.)-0.5))*radians(360.))+ .5;\n\treturn v* mix(vec3(1),clamp(hue,0.,1.),s);\n}\n// Approximates official HSV using cosine\nvec3 hsv2rgb_tricos(float h, float s, float v) {\n\treturn v* mix(vec3(1),clamp(cos(radians(120.)* (3.* h+ vec3(0,2,1)))+ .5,0.,1.),s);\n}\n// Simplified FastLED spectrum implementation\nvec3 hsv2rgb_spectrum(float h, float s, float v) {\n\treturn v* mix(vec3(1),clamp(1.- abs(1.- mod(3.* h+ vec3(1,0,2), 3.)),0.,1.),s);\n}\n// Simplified FastLED rainbow implementation\nvec3 hsv2rgb_rainbow(float h, float s, float v) {\n\tvec3 hue = vec3(0);\n\tfloat x = fract(h) * (8. / 3.) - 1.;\n\tif(x < 0.) {\n\t\thue.x = (-x) + max(0., 1. / 3. - abs(x + (1. / 3.)));\n\t\thue.y = 1. + x;\n\t} else if(x < 1. / 3.) {\n\t\thue.y = 1. - x;\n\t\thue.z = x;\n\t} else if(x < 2. / 3.) {\n\t\thue.y = 1. - (x * 2. - (1. / 3.));\n\t\thue.z = x * 2. - (1. / 3.);\n\t} else {\n\t\thue.x = x - 1. + (1. / 3.);\n\t\thue.z = 1. - (x - 1. + (1. / 3.));\n\t}\n\treturn v* mix(vec3(1),clamp(hue,0.,1.),s);\n}\n\n// Official HSV to RGB conversion\nvec3 hsv2rgb(float h, float s, float v) {\n\treturn v* mix(vec3(1),clamp(abs(mod(h* 6.+ vec3(0,4,2),6.)- 3.)- 1.,0.,1.),s);\n}\nvec3 cubic(vec3 x) {\n\treturn x* x* (3.0- 2.0* x);\n}\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth(float h, float s, float v) {\n\treturn v* mix(vec3(1),cubic(clamp(abs(mod(h* 6.+ vec3(0,4,2),6.)- 3.)- 1.,0.,1.)),s);\n}\nint uint8_t(int a) {\n\treturn clamp(a,0,255);\n}\nint uint8_t(float a) {\n\treturn uint8_t(int(floor(a* 255.)));\n}\nint scale8(int i, int scale) {\n\treturn i* (1+ scale)>> 8;\n}\nint scale8_video_LEAVING_R1_DIRTY(int i, int scale) {\n\treturn ((i* scale)>> 8)+ ((i!= 0&& scale!= 0)? 1: 0);\n}\nvec3 hsv2rgb_raw_C(float hsvhue,float hsvsat,float hsvval) {\n\t// Convert hue, saturation and brightness ( HSV/HSB ) to RGB\n\t// \"Dimming\" is used on saturation and brightness to make\n\t// the output more visually linear.\n\t// Apply dimming curves\n\tint hue = uint8_t(hsvhue);\n\tint sat = uint8_t(hsvsat);\n\tint val = uint8_t(hsvval);\n\tint value = uint8_t(val);\n\tint saturation = uint8_t(sat);\n\t// The brightness floor is minimum number that all of\n\t// R, G, and B will be set to.\n\tint invsat = uint8_t(255- saturation);\n\tint brightness_floor = uint8_t((value* invsat)/ 256);\n\t// The color amplitude is the maximum amount of R, G, and B\n\t// that will be added on top of the brightness_floor to\n\t// create the specific hue desired.\n\tint color_amplitude = uint8_t(value- brightness_floor);\n\t// Figure out which section of the hue wheel we're in,\n\t// and how far offset we are within that section\n\tint section = uint8_t(hue/ 0x40); // 0..2\n\tint offset = uint8_t(hue% 0x40); // 0..63\n\tint rampUp = uint8_t(offset); // 0..63\n\tint rampDown = uint8_t((0x40- 1)- offset); // 63..0\n\t// We now scale rampUp and rampDown to a 0-255 range -- at least\n\t// in theory, but here's where architecture-specific decisions\n\t// come in to play:\n\t// To scale them up to 0-255, we'd want to multiply by 4.\n\t// But in the very next step, we multiply the ramps by other\n\t// values and then divide the resulting product by 256.\n\t// So which is faster?\n\t//   ((ramp * 4) * otherValue) / 256\n\t// or\n\t//   ((ramp    ) * otherValue) /  64\n\t// It depends on your processor architecture.\n\t// On 8-bit AVR, the \"/ 256\" is just a one-cycle register move,\n\t// but the \"/ 64\" might be a multi-cycle shift process. So on AVR\n\t// it's faster do multiply the ramp values by four, and then\n\t// divide by 256.\n\t// On ARM, the \"/ 256\" and \"/ 64\" are one cycle each, so it's\n\t// faster to NOT multiply the ramp values by four, and just to\n\t// divide the resulting product by 64 (instead of 256).\n\t// Moral of the story: trust your profiler, not your instincts.\n\t// Since there's an AVR assembly version elsewhere, we'll\n\t// assume what we're on an architecture where any number of\n\t// bit shifts has roughly the same cost, and we'll remove the\n\t// redundant math at the source level:\n\t//  // scale up to 255 range\n\t//  //rampUp *= 4; // 0..252\n\t//  //rampDown *= 4; // 0..252\n\t// compute color-amplitude-scaled-down versions of rampUp and rampDown\n\tint rampUp_amp_adj = uint8_t((rampUp* color_amplitude)/ (256/ 4));\n\tint rampDown_amp_adj = uint8_t((rampDown* color_amplitude)/ (256/ 4));\n\t// add brightness_floor offset to everything\n\tint rampUp_adj_with_floor = uint8_t(rampUp_amp_adj+ brightness_floor);\n\tint rampDown_adj_with_floor = uint8_t(rampDown_amp_adj+ brightness_floor);\n\tint rgbr,rgbg,rgbb;\n\tif(section!= 0) {\n\t\tif(section== 1) {\n\t\t\t// section 1: 0x40..0x7F\n\t\t\trgbr = brightness_floor;\n\t\t\trgbg = rampDown_adj_with_floor;\n\t\t\trgbb = rampUp_adj_with_floor;\n\t\t} else {\n\t\t\t// section 2; 0x80..0xBF\n\t\t\trgbr = rampUp_adj_with_floor;\n\t\t\trgbg = brightness_floor;\n\t\t\trgbb = rampDown_adj_with_floor;\n\t\t}\n\t} else {\n\t\t// section 0: 0x00..0x3F\n\t\trgbr = rampDown_adj_with_floor;\n\t\trgbg = rampUp_adj_with_floor;\n\t\trgbb = brightness_floor;\n\t}\n\treturn vec3(rgbr,rgbg,rgbb)/ 255.;\n}\n// Ported FastLED spectrum function\nvec3 hsv2rgb_fl_spectrum(float hsvhue,float hsvsat,float hsvval) {\n\tint hsv2hue = scale8(uint8_t(hsvhue),191);\n\treturn hsv2rgb_raw_C(float(hsv2hue)/ 255.,hsvsat,hsvval);\n}\n// Ported FastLED rainbow function\nvec3 hsv2rgb_fl_rainbow(float hsvhue,float hsvsat,float hsvval) {\n\t// Yellow has a higher inherent brightness than\n\t// any other color; 'pure' yellow is perceived to\n\t// be 93% as bright as white.  In order to make\n\t// yellow appear the correct relative brightness,\n\t// it has to be rendered brighter than all other\n\t// colors.\n\t// Level Y1 is a moderate boost, the default.\n\t// Level Y2 is a strong boost.\n\tint Y1 = uint8_t(1);\n\t// G2: Whether to divide all greens by two.\n\t// Depends GREATLY on your particular LEDs\n\tint G2 = uint8_t(0);\n\t// gScale: what to scale green down by.\n\t// Depends GREATLY on your particular LEDs\n\tint gScale = uint8_t(0);\n\tint hue = uint8_t(hsvhue);\n\tint sat = uint8_t(hsvsat);\n\tint val = uint8_t(hsvval);\n\tint offset = uint8_t(hue& 0x1F); // 0..31\n\t// offset8 = offset * 8\n\tint offset8 = uint8_t(offset);\n\t{\n\t\t// On ARM and other non-AVR platforms, we just shift 3.\n\t\toffset8 <<= 3;\n\t}\n\tint third = uint8_t(scale8(offset8,(256/ 3))); // max = 85\n\tint r,g,b;\n\tif(!((hue& 0x80)!= 0)) {\n\t\t// 0XX\n\t\tif(!((hue& 0x40)!= 0)) {\n\t\t\t// 00X\n\t\t\t//section 0-1\n\t\t\tif(!((hue& 0x20)!= 0)) {\n\t\t\t\t// 000\n\t\t\t\t//case 0: // R -> O\n\t\t\t\tr = 255- third;\n\t\t\t\tg = third;\n\t\t\t\tb = 0;\n\t\t\t} else {\n\t\t\t\t// 001\n\t\t\t\t//case 1: // O -> Y\n\t\t\t\tif(Y1!= 0) {\n\t\t\t\t\tr = 171;\n\t\t\t\t\tg = 85+ third;\n\t\t\t\t\tb = 0;\n\t\t\t\t} else {\n\t\t\t\t\tr = 170+ third;\n\t\t\t\t\tint twothirds = uint8_t(scale8(offset8,((256* 2)/ 3))); // max=170\n\t\t\t\t\tg = 85+ twothirds;\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//01X\n\t\t\t// section 2-3\n\t\t\tif(!((hue& 0x20)!= 0)) {\n\t\t\t\t// 010\n\t\t\t\t//case 2: // Y -> G\n\t\t\t\tif(Y1!= 0) {\n\t\t\t\t\tint twothirds = uint8_t(scale8(offset8,((256* 2)/ 3))); // max=170\n\t\t\t\t\tr = 171- twothirds;\n\t\t\t\t\tg = 170+ third;\n\t\t\t\t\tb = 0;\n\t\t\t\t} else {\n\t\t\t\t\tr = 255- offset8;\n\t\t\t\t\tg = 255;\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 011\n\t\t\t\t// case 3: // G -> A\n\t\t\t\tr = 0;\n\t\t\t\tg = 255- third;\n\t\t\t\tb = third;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// section 4-7\n\t\t// 1XX\n\t\tif(!((hue& 0x40)!= 0)) {\n\t\t\t// 10X\n\t\t\tif(!((hue& 0x20)!= 0)) {\n\t\t\t\t// 100\n\t\t\t\t//case 4: // A -> B\n\t\t\t\tr = 0;\n\t\t\t\tint twothirds = uint8_t(scale8(offset8,((256* 2)/ 3))); // max=170\n\t\t\t\tg = 171- twothirds; //K170?\n\t\t\t\tb = 85+ twothirds;\n\t\t\t} else {\n\t\t\t\t// 101\n\t\t\t\t//case 5: // B -> P\n\t\t\t\tr = third;\n\t\t\t\tg = 0;\n\t\t\t\tb = 255- third;\n\t\t\t}\n\t\t} else {\n\t\t\tif(!((hue& 0x20)!= 0)) {\n\t\t\t\t// 110\n\t\t\t\t//case 6: // P -- K\n\t\t\t\tr = 85+ third;\n\t\t\t\tg = 0;\n\t\t\t\tb = 171- third;\n\t\t\t} else {\n\t\t\t\t// 111\n\t\t\t\t//case 7: // K -> R\n\t\t\t\tr = 170+ third;\n\t\t\t\tg = 0;\n\t\t\t\tb = 85- third;\n\t\t\t}\n\t\t}\n\t}\n\t// This is one of the good places to scale the green down,\n\t// although the client can scale green down as well.\n\tif(G2!= 0) g = g>> 1;\n\tif(gScale!= 0) g = scale8_video_LEAVING_R1_DIRTY(g,gScale);\n\t// Scale down colors if we're desaturated at all\n\t// and add the brightness_floor to r, g, and b.\n\tif(sat!= 255) {\n\t\tif(sat== 0) {\n\t\t\tr = 255;\n\t\t\tb = 255;\n\t\t\tg = 255;\n\t\t} else {\n\t\t\tif(r!= 0) r = scale8(r,sat);\n\t\t\tif(g!= 0) g = scale8(g,sat);\n\t\t\tif(b!= 0) b = scale8(b,sat);\n\t\t\tint desat = uint8_t(255- sat);\n\t\t\tdesat = scale8(desat,desat);\n\t\t\tint brightness_floor = uint8_t(desat);\n\t\t\tr += brightness_floor;\n\t\t\tg += brightness_floor;\n\t\t\tb += brightness_floor;\n\t\t}\n\t}\n\t// Now scale everything down if we're at value < 255.\n\tif(val!= 255) {\n\t\tval = scale8_video_LEAVING_R1_DIRTY(val,val);\n\t\tif(val== 0) {\n\t\t\tr = 0;\n\t\t\tg = 0;\n\t\t\tb = 0;\n\t\t} else {\n\t\t\tif(r!= 0) r = scale8(r,val);\n\t\t\tif(g!= 0) g = scale8(g,val);\n\t\t\tif(b!= 0) b = scale8(b,val);\n\t\t}\n\t}\n\treturn vec3(r,g,b)/255.;\n}\nvec4 total(vec3 f) {\n\treturn vec4(f,f.x+f.y+f.z);\n}\nbool singleMode;\nfloat gain(float i) {\n\treturn .5* iResolution.y- 2.* borderW- (iMouse.x< 10. ? i* 2.5* lineW : 0.);\n}\nfloat off(float i) {\n\treturn borderW+ (iMouse.x< 10. ? i* 2.5* lineW : 0.);\n}\nvec4 rgb;\nvec3 combine(vec3 col, float n) {\n\tif(iMouse.x>= 10.) {\n\t\tif(singleMode) {\n\t\t\tn = 0.;\n\t\t} else if(n> 0.) {\n\t\t\tn = 2.;\n\t\t}\n\t}\n\trgb *= pow(dim,n);\n\tvec3 cols = vec3(.2,.8,.2);\n\tcol = mix(col,cols.zzz,rgb.a);\n\tcol = mix(col,cols.xxy,rgb.b);\n\tcol = mix(col,cols.yxx,rgb.r);\n\tcol = mix(col,cols.xyx,rgb.g);\n\trgb = vec4(0);\n\treturn col;\n}\nvec2 resi,reso,frag;\nfloat sat, val;\nvoid satval(float x) {\n\tsat = 1.0- clamp(iTime,0.,1.)* clamp(sin(iTime* .99+ (frag.x+ x)*resi.x* 2.)+ .255,0.,1.);\n\tval = 1.0- clamp(iTime,0.,1.)* clamp(sin(iTime* .61+ (frag.x+ x)*resi.x* 2.)+ .125,0.,1.);\n}\nvoid plot(float x, float og, vec4 val, vec2 pos) {\n\tfloat o = off(og);\n\tfloat g = gain(og);\n\tvec4 y = o+g*val;\n\tfloat dr = distance(vec2(x,y.r),pos);\n\tfloat dg = distance(vec2(x,y.g),pos);\n\tfloat db = distance(vec2(x,y.b),pos);\n\tfloat da = distance(vec2(x,y.a),pos);\n\tvec4 res = clamp(lineW- vec4(dr,dg,db,da),0.,1.);\n\trgb = max(rgb,res);\n}\nvoid plot(float x, float og, vec3 val, vec2 pos) {\n\tplot(x,og,total(val),pos);\n}\nbool shown(float which) {\n\treturn iMouse.x< 10.\n\t|| floor(fract(iMouse.y/ iResolution.y* 2.)* num_f)== which\n\t|| !singleMode&& floor(iMouse.x/ iResolution.x* num_f)== which;\n}\nvec4 image(vec2 U) {\n\treso = iResolution.xy;\n\tresi = 1./iResolution.xy;\n\tfrag = U;\n\tsingleMode = iMouse.y>= .5* iResolution.y;\n\tsatval(0.);\n\tvec3 col;\n#define FILL(NUM,FUNC) \\\n\tif(frag.y* resi.y>= .5+ .5* (NUM)/ num_f&& shown(NUM)) {\\\n\t\tcol = FUNC(frag.x*resi.x,sat,val);\\\n\t} else\n\tFILL(9.,hsv2rgb_cosine15   )\n\tFILL(8.,hsv2rgb_cosine10   )\n\tFILL(7.,hsv2rgb_fl_spectrum)\n\tFILL(6.,hsv2rgb_fl_rainbow )\n\tFILL(5.,hsi2rgb            )\n\tFILL(4.,hsi2rgbw           )\n\tFILL(3.,hsv2rgb_peak6      )\n\tFILL(2.,hsv2rgb_smooth     )\n\tFILL(1.,hsv2rgb            )\n\tFILL(0.,hsv2rgb_tricos     )\n#undef FILL\n\t{col = vec3(0);}\n\trgb = vec4(0);\n#define PLOT(NUM,FUNC) {\\\n\tif(shown(NUM)) {\\\n\t\tfor(float i = -lineW; i<= lineW; i++) {\\\n\t\t\tsatval(i);\\\n\t\t\tplot(i+ frag.x,NUM,FUNC((frag.x+ i)* resi.x,sat,val),frag);\\\n\t\t}\\\n\t\tcol = combine(col,NUM);\\\n\t}}\n\tPLOT(9.,hsv2rgb_cosine15   )\n\tPLOT(8.,hsv2rgb_cosine10   )\n\tPLOT(7.,hsv2rgb_fl_spectrum)\n\tPLOT(6.,hsv2rgb_fl_rainbow )\n\tPLOT(5.,hsi2rgb            )\n\tPLOT(4.,hsi2rgbw           )\n\tPLOT(3.,hsv2rgb_peak6      )\n\tPLOT(2.,hsv2rgb_smooth     )\n\tPLOT(1.,hsv2rgb            )\n\tPLOT(0.,hsv2rgb_tricos     )\n#undef PLOT\n\treturn vec4(col,1);\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfragColor = image(fragCoord);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}