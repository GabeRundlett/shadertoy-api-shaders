{
    "Shader": {
        "info": {
            "date": "1433862711",
            "description": "godrays in screen space from a occlusion map, click to move the square",
            "flags": 0,
            "hasliked": 0,
            "id": "4tfSRn",
            "likes": 22,
            "name": "simple godrays in screenspace",
            "published": 3,
            "tags": [
                "2d",
                "godrays",
                "screenspace"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 4430
        },
        "renderpass": [
            {
                "code": "//by Ethan Alexander Shulman known as public_int_i\n//This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License\n//http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nconst vec2 sunPos = vec2(.5);\nconst vec3 sunColor = vec3(1.,.95,.95);\n\nconst float sunSize = .2;\nconst float godrayReach = .7;\nconst int godrayIter = 32;\nconst float godrayIntensity = .045;\nconst float godrayStep = (sunSize/2.)/float(godrayIter);\n\n\nconst vec3 backgroundColor = vec3(0.);\n\nconst vec2 occlusionSize = vec2(.1);\n\n\nfloat occlusionMap(in vec2 uv) {\n    vec2 occlusionLoc = iMouse.xy/iResolution.xy;\n    if (iMouse.w < 1.) {\n        occlusionLoc = vec2(sin(iTime*.6)*.2+.5,cos(iTime*.76)*.2+.5);\n    }    \n    float d = length(max(abs(uv-occlusionLoc)-vec2(occlusionSize),0.));\n    d = max(-(length(mod(uv-occlusionLoc,occlusionSize*.5)-occlusionSize*.25)-occlusionSize.x*.5),d);\n    return floor(1.03-d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n    float cl = occlusionMap(uv);\n    vec2 sunDir = sunPos-uv;\n    float sunLen = length(sunDir);\n    if (sunLen < sunSize) {\n        fragColor = vec4(mix(sunColor,vec3(cl*.3),cl),1.);\n        return;\n    }\n    vec3 c = backgroundColor;\n    \n    float cb;\n   \tc = mix(c,vec3(cl*.3),cl);\n    cl = 0.;\n    if (sunLen < godrayReach) {\n        \n        sunDir = normalize(sunDir);\n        uv += sunDir*max(0.,(sunLen-sunSize));\n        sunLen = 1.-sunLen/godrayReach;\n        int maxIter = int(sunLen*float(godrayIter));\n        \n        for (int i = 0; i < godrayIter; i++) {\n            \n            cl += max(0.,1.-occlusionMap(uv))*sunLen;\n                \n            if (i > maxIter) {\n                break;\n            }\n            \n            uv += sunDir*godrayStep;\n        }\n        \n        cl *= godrayIntensity;\n        c += min(1.,cl)*sunColor;\n    }\n    \n    fragColor = vec4(c,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}