{
    "Shader": {
        "info": {
            "date": "1465388127",
            "description": "Using a randomized 3D tile to add some pronounced surfacing to a warped plane.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sGSRV",
            "likes": 217,
            "name": "Abstract Plane",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "abstract",
                "plane",
                "mapping",
                "environment",
                "tile"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 16047
        },
        "renderpass": [
            {
                "code": "/*\n    Abstract Plane\n    --------------\n\n\tPerforming 2nd order distance checks on randomized 3D tiles to add some pronounced \n\tsurfacing to a warped plane... Verbose description aside, it's a pretty simple process. :)\n\n\tI put this example together some time ago, but couldn't afford a reflective pass, so \n\tforgot about it. Anyway, I was looking at XT95's really nice \"UI\" example - plus a \n\tcouple of my own - and realized that a little bit of environment mapping would work \n\tnicely. I'm using a less sophisticated environment mapping function than XT95's, but \n\tit produces the desired effect. \n\t\n    By the way, XT95's is really worth taking a look at. It gives off a vibe of surrounding \n\tarea lights. I tested it on other surfaces and was pretty pleased with the results. The \n\tlink is below.\n\n\tAs for the geometry itself, it's just a variation of 3D repetitive tiling. I colored in\n\tsome of the regions - Greyscale with a splash of color is on page five of the \"Tired Old \n\tCliche Design\" handbook. :) However, I also to wanted to show that it's possible to \n\tidentify certain regions within the tile in a similar way to which it is done with regular \n\tVoronoi.\t\n\n\tOther examples:\n    \n\t// Excellent environment mapping example.\n\tUI easy to integrate - XT95    \n\thttps://www.shadertoy.com/view/ldKSDm\n\n\t// As abstact terrain shaders go, this is my favorite. :)\n\tSomewhere in 1993 - nimitz\n\thttps://www.shadertoy.com/view/Md2XDD\n*/\n\n\n#define FAR 40.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n \n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    \n    // Try this one for a regular, beveled Voronoi looking pattern. It's faster to\n    // hone in on too, which is a bonus.\n    //p = fract(p)-.5;    \n    //return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec3(.5));\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n    \n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    //p = abs(fract(p)-.5);\n    //return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    //return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n\n// The 3D tiling process. I've explained it in the link below, if you're interested in the process.\n//\n// Cellular Tiled Tunnel\n// https://www.shadertoy.com/view/MscSDB\nfloat cellTile(in vec3 p){\n    \n    p /= 5.5;\n    // Draw four overlapping objects at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // First order.\n        \n    return d.x*2.66; // Normalize... roughly.\n    \n}\n\n\nvec3 cellTileColor(in vec3 p){\n    \n    \n    int cellID = 0;\n    \n    p/=5.5;\n    \n    vec3 d = (vec3(.75)); // Set the maximum.\n   \n    \n    // Draw four overlapping shapes using the darken blend \n    // at various positions on the tile.\n    d.z = drawObject(p - vec3(.81, .62, .53)); if(d.z<d.x)cellID = 1;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawObject(p - vec3(.39, .2, .11)); if(d.z<d.x)cellID = 2;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06)); if(d.z<d.x)cellID = 3;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawObject(p - vec3(.2, .82, .64)); if(d.z<d.x)cellID = 4;\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n   \n    \n    vec3 col = vec3(.25);//vec3(.7, .8, 1);\n    \n   \n    if (cellID == 3) col = vec3(1, .05, .15);\n    //vec3(.1, .8, .0);//vec3(.4, .7, 1.);//vec3(.8, .4, .2);//vec3(1, .05, .15)//\n    \n    // Extra color, if desired.\n    //if (cellID == 4) col = vec3(.1, .8, .0);//vec3(.5, .4, .35);\n    \n    // Interesting, but probably a little to abstract for this example.\n    //col *= (vec3(clamp(sin(d.x*24.*6.283)*2., 0., 1.)) + .5);\n    \n    return col;\n    \n    \n    \n    //return (1.-sqrt(d.x)*1.33);\n    \n}\n\n\n// Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p){\n    \n    float n = (.5-cellTile(p))*1.5;\n    return p.y + dot(sin(p/2. + cos(p.yzx/2. + 3.14159/2.)), vec3(.5)) + n;\n \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.0;\n    \n    for (int i = 0; i < 96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<0.0025*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d*.7;  // Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the larger than usual sampline distance (epsilon value). It's an old trick to give\n    // rounded edges, and with the right objects it gives a slightly blurred antialiased look.\n    vec2 e = vec2(0.015, -0.015);\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n*/\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy. I used it to do a bit of fake shadowing.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected ray at the surface hit point, then \n// pass it into a 3D function. If you wanted, you could convert the 3D ray coordinates (p) \n// to polar coordinates and index into a repeat texture. It can be pretty convincing (in an \n// abstract way) and allows environment mapping without the need for a cube map, or a \n// reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n   \n    // Some functions work, and others don't. The surface is created with the function\n    // below, so that makes it somewhat believable.\n    float c = cellTile(p*6.);\n    c = smoothstep(0.2, 1., c); // Contract gives it more of a lit look... kind of.\n    \n    return vec3(pow(c, 8.), c*c, c); // Icy glow... for whatever reason. :)\n    // Alternate firey glow.\n    //return vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.));\n\n}\n\n// Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 3.5, iTime*6.);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(0, .25, -.25); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, .75, 2);// Put it a bit in front of the camera.\n\tvec3 lp2 = ro + vec3(0, .75, 9);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\tlp2.xy += path(lp2.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.57; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= rot2( path(lk.z).x/64. );\n    \n    /*    \n    // Mouse controls, as per TambakoJaguar's suggestion.\n    // Works better if the line above is commented out.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/ \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n\t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    vec3 sn = getNormal(sp);\n        \n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        // Texture-based bump mapping.\n\t    sn = texBump(iChannel0, sp*tSize0, sn, 0.01);\n        \n        // Obtaining the texel color. \n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lp-sp;\n\t    vec3 ld2 = lp2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n\t    float lDist2 = max(length(ld2), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    ld2 /= lDist2;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*0.025);\n\t    float atten2 = 1./(1. +lDist2*lDist2*0.025);\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.1;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 8.);\n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\n    \t\n    \t// Darkening the crevices. Otherse known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.5+0.5; //smoothstep(-.05, .1, cellTile(sp));//\n        shading *= smoothstep(-.1, .15, cellTile(sp));\n        \n        \n        // I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        // to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*.5;\n    \n\n        // Combining the above terms to procude the final color.\n        vec3 rCol = cellTileColor(sp)*dot(texCol, vec3(.299, .587, .114));\n        sceneCol += (rCol*(diff + ambience) + vec3(.8, .95, 1)*spec*1.5 + env)*atten;\n        sceneCol += (rCol*(diff2 + ambience) + vec3(.8, .95, 1)*spec2*1.5 + env)*atten2;\n        \n        // Cube mapping, for those who want more believable environment mapping.\n        //vec3 rfCol = texture(iChannel1, reflect(rd, sn)).xyz; // Forest scene.\n        //sceneCol += rfCol*rfCol*.25;\n        \n\n        // Shading.\n        sceneCol *= shading*ao;\n        \n        \n\t\n\t}\n    \n    // Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    // the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    sceneCol = mix(sceneCol, vec3(.0, .003, .01), smoothstep(0., FAR-5., t));\n    \n    \n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}