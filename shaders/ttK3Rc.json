{
    "Shader": {
        "info": {
            "date": "1579620447",
            "description": "voronoi particle tracking is awesome!",
            "flags": 32,
            "hasliked": 0,
            "id": "ttK3Rc",
            "likes": 26,
            "name": "chaotic particle swarm",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "particles",
                "flownoise",
                "midpoint"
            ],
            "usePreview": 0,
            "username": "unnick",
            "viewed": 1527
        },
        "renderpass": [
            {
                "code": "//its still a mystery to me how to make particles interact with each other though\n//ive seen some people use the gauss-seidel method to solve a poisson equation\n//but idk how that works\n\n//i use a divergence-free vector field together with the midpoint method to move particles\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    vec4 state = texelFetch(iChannel0, ivec2(_pos), 0);\n    float len = length(state.xy - _pos);\n    col = exp(-len*len*.2) * sqrt(sin((state.z + vec4(0,1,2,0)/3.) * tau) * .5 + .5);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void swap(inout vec4 state, ivec2 p, ivec2 offs) {\n    if(any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0))))) return;\n    vec4 n = texelFetch(iChannel0, p+offs, 0);\n    vec2 tmp = vec2(p+1);\n    if(length(n.xy-tmp) < length(state.xy-tmp)) state = n;\n}\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    //check if any neighbooring particles are closer to the current pixel\n    //than the particle currently stored\n    for(int i = 1; i <= checkradius; i++) {\n        swap(col, pos, ivec2( i, 0));\n        swap(col, pos, ivec2( 0, i));\n        swap(col, pos, ivec2(-i, 0));\n        swap(col, pos, ivec2( 0,-i));\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    //initial conditions\n    if(iFrame == 0) col = vec4(1e4);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define res iResolution.xy\n#define ires ivec2(iResolution.xy)\n#define tau 6.283185\n\n//velocity field\n#define speed .2\n#define posscale 2e-3\n#define timescale .1\n//particle creation\n#define npartchance .01\n#define mindist 7.\n//voronoi tracking\n#define checkradius 2\n\nuint hash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash3i1f(uvec3 p) {\n    return float(hash(hash(hash(p.x) ^ p.y) ^ p.z) >> 8) / 16777216.;\n}\n\n//computes the x and y derivatives of a noise field \nvec2 noise(vec3 p) {\n    uvec3 i = uvec3(ivec3(floor(p)));\n     vec3 f =             fract(p)  ;\n    vec3  u = f*f*f*(f*(f*6.-15.)+10.);\n    vec3 du = 30.*f*f*(f*(f-2.)+1.);\n    \n    vec2 ga = sin((hash3i1f(i+uvec3(0,0,0))+vec2(0,.25))*tau);\n    vec2 gb = sin((hash3i1f(i+uvec3(1,0,0))+vec2(0,.25))*tau);\n    vec2 gc = sin((hash3i1f(i+uvec3(0,1,0))+vec2(0,.25))*tau);\n    vec2 gd = sin((hash3i1f(i+uvec3(1,1,0))+vec2(0,.25))*tau);\n    vec2 ge = sin((hash3i1f(i+uvec3(0,0,1))+vec2(0,.25))*tau);\n    vec2 gf = sin((hash3i1f(i+uvec3(1,0,1))+vec2(0,.25))*tau);\n    vec2 gg = sin((hash3i1f(i+uvec3(0,1,1))+vec2(0,.25))*tau);\n    vec2 gh = sin((hash3i1f(i+uvec3(1,1,1))+vec2(0,.25))*tau);\n    \n    float va = dot(ga, f.xy - vec2(0,0));\n    float vb = dot(gb, f.xy - vec2(1,0));\n    float vc = dot(gc, f.xy - vec2(0,1));\n    float vd = dot(gd, f.xy - vec2(1,1));\n    float ve = dot(ge, f.xy - vec2(0,0));\n    float vf = dot(gf, f.xy - vec2(1,0));\n    float vg = dot(gg, f.xy - vec2(0,1));\n    float vh = dot(gh, f.xy - vec2(1,1));\n    \n    return mix(mix(mix(ga, gb, u.x), mix(gc, gd, u.x), u.y),\n               mix(mix(ge, gf, u.x), mix(gg, gh, u.x), u.y), u.z)\n         + du.xy * mix(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va,\n                       u.yx*(ve-vf-vg+vh) + vec2(vf,vg) - ve, u.z);\n}\n\nvec2 fluidnoise(vec3 p) {\n    vec2 total = vec2(0);\n    float amp = 1.;\n    for(int i = 0; i < 5; i++) {\n        total += noise(p) * amp;\n        p *= 2.; p += 4.3; amp *= 1.5;\n    }\n    return total.yx * vec2(-1,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void swap(inout vec4 state, ivec2 p, ivec2 offs) {\n    if(any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0))))) return;\n    vec4 n = texelFetch(iChannel0, p+offs, 0);\n    vec2 tmp = vec2(p+1);\n    if(length(n.xy-tmp) < length(state.xy-tmp)) state = n;\n}\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    //check if any neighbooring particles are closer to the current pixel\n    //than the particle currently stored\n    for(int i = 1; i <= checkradius; i++) {\n        swap(col, pos, ivec2( i, 0));\n        swap(col, pos, ivec2( 0, i));\n        swap(col, pos, ivec2(-i, 0));\n        swap(col, pos, ivec2( 0,-i));\n    }\n    //move particles according to the fluidnoise vector field with the midpoint method\n    vec2 tmp = col.xy + fluidnoise(vec3(col.xy * posscale, iTime * timescale)) * .5 * speed;\n    col.xy += fluidnoise(vec3(tmp * posscale, (iTime+iTimeDelta*.5) * timescale)) * speed;\n    //create a new particle with a small chance if\n    //the distance to the nearest particle is too big\n    bool cansplit = hash3i1f(uvec3(pos,iFrame)) < npartchance;\n    vec4 newpart = vec4(_pos, hash3i1f(uvec3(pos,iFrame+1000)), 0);\n    if(length(col.xy - _pos - 1.) >= mindist && cansplit) col = newpart;\n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void swap(inout vec4 state, ivec2 p, ivec2 offs) {\n    if(any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0))))) return;\n    vec4 n = texelFetch(iChannel0, p+offs, 0);\n    vec2 tmp = vec2(p+1);\n    if(length(n.xy-tmp) < length(state.xy-tmp)) state = n;\n}\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    //check if any neighbooring particles are closer to the current pixel\n    //than the particle currently stored\n    for(int i = 1; i <= checkradius; i++) {\n        swap(col, pos, ivec2( i, 0));\n        swap(col, pos, ivec2( 0, i));\n        swap(col, pos, ivec2(-i, 0));\n        swap(col, pos, ivec2( 0,-i));\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void swap(inout vec4 state, ivec2 p, ivec2 offs) {\n    if(any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0))))) return;\n    vec4 n = texelFetch(iChannel0, p+offs, 0);\n    vec2 tmp = vec2(p+1);\n    if(length(n.xy-tmp) < length(state.xy-tmp)) state = n;\n}\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    //check if any neighbooring particles are closer to the current pixel\n    //than the particle currently stored\n    for(int i = 1; i <= checkradius; i++) {\n        swap(col, pos, ivec2( i, 0));\n        swap(col, pos, ivec2( 0, i));\n        swap(col, pos, ivec2(-i, 0));\n        swap(col, pos, ivec2( 0,-i));\n    }\n    //move particles according to the fluidnoise vector field with the midpoint method\n    vec2 tmp = col.xy + fluidnoise(vec3(col.xy * posscale, iTime * timescale)) * .5 * speed;\n    col.xy += fluidnoise(vec3(tmp * posscale, (iTime+iTimeDelta*.5) * timescale)) * speed;\n    \n    \n    \n    \n    \n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}