{
    "Shader": {
        "info": {
            "date": "1685482722",
            "description": "Animated view of simulated interferometric fringes to explore different aberrations.",
            "flags": 0,
            "hasliked": 0,
            "id": "mldSW7",
            "likes": 1,
            "name": "Aberration I",
            "published": 3,
            "tags": [
                "interferometry",
                "aberations",
                "seidel",
                "zernike"
            ],
            "usePreview": 0,
            "username": "itishappy",
            "viewed": 135
        },
        "renderpass": [
            {
                "code": "// factorial\nint fact(int x) {\n    int prod = 1;\n    for (int i = 2; i <= x; i++) {\n        prod *= i;\n    }\n    return prod;\n}\n\n// radial term\nfloat r(int m, int n, float rho) {\n    if ((n - m) % 2 == 1) return 0.;\n    int avg = (n + m) / 2;\n    int dev = (n - m) / 2;\n    float sum = 0.;\n    for (int k = 0; k <= dev; k++) {\n        int sgn = 1 - 2 * (k % 2);\n        int num = sgn * fact(n - k);\n        int den = fact(k) * fact(avg - k) * fact(dev - k);\n        int cooef = num / den;\n        sum += float(cooef) * pow(rho, float(n - 2 * k));\n    }\n    return sum;\n}\n\n// full zernike polynomial\nfloat zernike(int m, int n, float rho, float theta) {\n    float a;\n    if (m >= 0) {\n        a = cos(float(m) * theta);\n    } else {\n        m *= -1;\n        a = sin(float(m) * theta);\n    }\n    return r(m, n, rho) * a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center and normalize coordinates\n    vec2 uv = 0.8 * (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // polar decomposition\n    float rho = length(uv);\n    float theta = atan(uv.y, uv.x);\n    \n    // computes the height of each point for a given set of aberrations\n    // MAGIC HAPPENS HERE: TRY THESE LINES!\n    // float h = zernike(1, 1, rho, theta) + 0.5 * zernike(-1, 1, rho, theta);\n    // float h = zernike(0, 2, rho, theta) - 1.6 * zernike(-1, 1, rho, theta);\n    float h = zernike(-2, 2, rho, theta) - 0.5 * zernike(0, 4, rho, theta);\n    // float h = zernike(1, 5, rho, theta) + 0.5 * zernike(-1, 1, rho, theta);\n    // float h = 0.4 * zernike(-2, 4, rho, theta) - 0.8 * zernike(-1, 3, rho, theta) + 0.6 * zernike(2, 2, rho, theta);\n    \n    // base color\n    vec3 col = mix(vec3(1.), vec3(0., 0., 1.), h) * mix(vec3(1.), vec3(1., 0., 0.), -h);\n    \n    // aperture and color normalization\n    if (length(uv) > 1.0) {\n        col = vec3(0.);\n    } else {\n        col = clamp(col, vec3(0.), vec3(1.));\n    }\n\n    // fringes\n    col *= pow(sin(3.14159265359 * (2. * h + 0.5 * cos(iTime))), 2.);\n\n    // output\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}