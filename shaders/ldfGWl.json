{
    "Shader": {
        "info": {
            "date": "1382310379",
            "description": "A simple raymarched table with a marble sphere at the top, while I learn raymarching. Really unoptimized. Really messy code. Never meant to be seen by anyone, ever. Got many functions from iquilezles.org and from other sources.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldfGWl",
            "likes": 5,
            "name": "Simple Table",
            "published": 3,
            "tags": [
                "simple",
                "raymarch",
                "sphere",
                "wood",
                "table",
                "marble"
            ],
            "usePreview": 0,
            "username": "HLorenzi",
            "viewed": 504
        },
        "renderpass": [
            {
                "code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid fUnionMat(inout float curDist, inout float curMat, float dist, in float mat)\n{\n\tif (dist < curDist) {\n\t\tcurMat = mat;\n\t\tcurDist = dist;\n\t}\n}\n\nfloat fSubtraction(float a, float b)\n{\n\treturn max(-a,b);\n}\n\nfloat fIntersection(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\nfloat fUnion(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat pSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat pRoundBox(vec3 p, vec3 b, float r)\n{\n \treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat distanceField(vec3 p, inout float m)\n{\n\tfloat d = p.z;\n\tm = 1.0;\n\t\n\tfloat table = pRoundBox(vec3(0,0,-12) + p, vec3(14,6,0.5), 0.4);\n\ttable = fIntersection(pSphere(vec3(0,0,-74) + p, 63.2), table);\n\ttable = fUnion(pRoundBox( (vec3(9.0 + cos(p.z) * 0.3,4.0 + cos(p.z) * 0.2,-6) + p) , vec3(1,1,6), 0.2), table);\n\ttable = fUnion(pRoundBox( (vec3(-9.0 - cos(p.z) * 0.3,4.0 + cos(p.z) * 0.2,-6) + p) , vec3(1,1,6), 0.2), table);\n\ttable = fUnion(pRoundBox( (vec3(-9.0 - cos(p.z) * 0.3,-4.0 - cos(p.z) * 0.2,-6) + p) , vec3(1,1,6), 0.2), table);\n\ttable = fUnion(pRoundBox( (vec3(9.0 + cos(p.z) * 0.3,-4.0 - cos(p.z) * 0.2,-6) + p) , vec3(1,1,6), 0.2), table);\n\t\n\tfloat sphere1 = pSphere(vec3(6,1,-16) + p, 3.0);\n\t\n\tfUnionMat(d, m, table, 2.0);\n\tfUnionMat(d, m, sphere1, 3.0);\n\t\n\treturn d;\t\n}\n\n\nvec3 normalFunction(vec3 p)\n{\n\tconst float eps = 0.01;\n\tfloat m;\n    vec3 n = vec3( (distanceField(vec3(p.x-eps,p.y,p.z),m) - distanceField(vec3(p.x+eps,p.y,p.z),m)),\n                   (distanceField(vec3(p.x,p.y-eps,p.z),m) - distanceField(vec3(p.x,p.y+eps,p.z),m)),\n                   (distanceField(vec3(p.x,p.y,p.z-eps),m) - distanceField(vec3(p.x,p.y,p.z+eps),m))\n\t\t\t\t );\n    return normalize( n );\n}\n\nvec4 raymarch(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.1;\n\tconst int maxIter = 120;\n\t\n\tfloat dist = 0.0;\n\t\n\tfloat material = 0.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tfloat distEval = distanceField(from + increment * dist, material);\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += distEval;\n\t}\n\t\n\t\n\tif (dist >= maxDist) {\n\t\tmaterial = 0.0;\n\t}\n\t\n\treturn vec4(dist, 0.0, 0.0, material);\n}\n\nfloat shadow(vec3 from, vec3 increment)\n{\n\tconst float minDist = 10.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i = 0; i < 80; i++) {\n\t\tfloat m;\n        float h = distanceField(from + increment * t,m);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, 2.0 * h / t);\n        t += h * 0.5;\n\t\t//if (t >= 20.0) break;\n    }\n    return res;\n}\n\nvec4 getPixel(vec3 from, vec3 to, vec3 increment)\n{\n\tvec4 c = raymarch(from, increment);\n\t\n\tvec3 hitPos = from + increment * c.x;\n\tvec3 normal = normalFunction(hitPos);\n\tvec3 lightPos = normalize(hitPos - vec3(16,14,-20));\n\t\n\tfloat diffuse = max(0.0, dot(normal, -lightPos));\n\tfloat shade = shadow(hitPos, lightPos) * 0.8 + 0.2;\n\t\n\tvec4 m = vec4(0,0,0,1);\n\t\n\tif (c.w == 1.0) {\n\t\t\n\t\tfloat specular;\t\n\t\tif (dot(normal, -lightPos) < 0.0) {\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow(max(0.0, dot(reflect(-lightPos, normal), normalize(from - hitPos))), 10.0);\n\t\t}\n\t\t\t\n\t\tm = texture(iChannel1,vec2(hitPos.x / 40.0,hitPos.y / 40.0));\n\t\treturn (m * 0.3 + m * diffuse) * shade;\n\t}\n\telse if (c.w == 2.0) {\n\t\t\n\t\tfloat specular;\t\n\t\tif (dot(normal, -lightPos) < 0.0) {\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow(max(0.0, dot(reflect(-lightPos, normal), normalize(from - hitPos))), 15.0);\n\t\t}\n\t\t\n\t\tvec3 reflInc = reflect(increment, normal);\n\t\tvec4 refl = raymarch(hitPos + reflInc, reflInc);\n\t\tif (refl.w == 3.0) {\n\t\t\tvec3 reflHitPos = hitPos + reflInc * refl.x;\n\t\t\tm = mix(\n\t\t\t\ttexture(iChannel0,vec2(hitPos.x * hitPos.z / 120.0,hitPos.y / 40.0)),\n\t\t\t\tvec4(0.2,1.2,1.7,1) *\n\t\t\t\t\ttexture(iChannel0,vec2(reflHitPos.x * reflHitPos.z / 120.0,reflHitPos.y / 40.0)),\n\t\t\t\tclamp(14.0 - reflHitPos.z, 0.0, 1.0) * 0.3);\n\t\t} else {\n\t\t\tm = texture(iChannel0,vec2(hitPos.x * hitPos.z / 120.0,hitPos.y / 40.0));\n\t\t}\n\t\t\n\t\t\n\t\treturn (m * 0.3 + m * diffuse + vec4(1,1,1,1) * specular) * shade;\n\t} else if (c.w == 3.0) {\n\t\t\n\t\tfloat specular;\t\n\t\tif (dot(normal, -lightPos) < 0.0) {\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow(max(0.0, dot(reflect(-lightPos, normal), normalize(from - hitPos))), 100.0);\n\t\t}\n\t\t\n\t\tm = vec4(0.2,1.2,1.7,1) * texture(iChannel0,vec2(hitPos.x * hitPos.z / 120.0,hitPos.y / 40.0));\n\t\t\n\t\t\n\t\treturn (m * 0.3 + m * diffuse + vec4(1,1,1,1) * specular) * shade;\t\t\n\t}\n\t\n\treturn m;\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\t// Camera\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 vPos = -1.0 + 2.0 * q;\n\t\n\t// Camera up vector.\n\tvec3 vuv=vec3(0,0,1); \n\t\n\t// Camera lookat.\n\tvec3 vrp=vec3(0,0,12.0);\n\t\n\tfloat dist = 20.0;//(cos(iTime / 3.0) * 30.0 + 40.0);\n\tvec3 prp = vec3(cos(iTime / 1.0) * dist,sin(iTime / 1.0) * dist,\n\t\t\t\t   17.0 + cos(iTime / 3.0) * 14.0);\n\t\n\t// Camera setup.\n\tvec3 vpn=normalize(vrp-prp);\n\tvec3 u=normalize(cross(vuv,vpn));\n\tvec3 v=cross(vpn,u);\n\tvec3 vcv=(prp+vpn) * 1.0;\n\tvec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n\tvec3 scp=normalize(scrCoord-prp);\n\t\n\t\n\t\n\tvec4 col = getPixel(prp, vrp, scp);\n    col = pow(col, vec4(1.0 / 2.2));\n    col = col*2.5-0.5;\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}