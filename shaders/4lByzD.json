{
    "Shader": {
        "info": {
            "date": "1507591270",
            "description": "lets see if i can crunch/optimize \nhttps://www.shadertoy.com/view/4tSyzD\nyes i can, and then paniq did a better crunch later on, and then i made a post  where this backup is relevant for\nhttp://ollj.turboherz.de/opengl-cancer\ncrunch time!",
            "flags": 32,
            "hasliked": 0,
            "id": "4lByzD",
            "likes": 11,
            "name": "Simplex SageMath.toBary/det",
            "published": 3,
            "tags": [
                "raytrace",
                "tetrahedron",
                "3simplex",
                "tetraeder",
                "barycentricfrustumcull"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1525
        },
        "renderpass": [
            {
                "code": "mat3 c2bm(vec3 a,vec3 b,vec3 c,vec3 d//carthesian to barycentric matrix\n){vec3 f=a-c;mat3 m=mat3(cross(c-b,b-d),cross(f,c-d),cross(b-a,a-d))\n ;return m/dot(m[0],f);}\n\n//get barycentric coordinates for point from the fourth vertex\n//,three plane normals with premultiplied inverse determinant\nvec4 c2b(vec3 p3, mat3 m, vec3 t\n){vec3 w=(t-p3)*m//scaled distance weights of point to individual planes\n ;return vec4(w,1.-w.x-w.y-w.z);}\n//vec3 b2c(vec3 p[4],vec4 w){return p[0]*w.x+p[1]*w.y + p[2]*w.z+p[3]*w.w;}\n\n//barycentric to normal\nvec3 b2n(mat3 m,vec4 w){return normalize(m*(w.w-w.xyz));}\n\n//return intersection of ray and tetrahedron\n//as well as the barycentric coordinates and normals of the hit points\nbool iSimplex3(vec3 u[4],v22 r//uv,RayOrigin,Ray\n,inout float n,inout vec4 b,inout vec3 p//nearIntersection,nearBarycenter,nearNormal\n){mat3 m=c2bm(u[0],u[1],u[2],u[3])\n ;vec4 o=c2b(u[3],m,r.a)//origin(barycentric)\n ;vec4 d=c2b(u[3],m,r.a+r.b)-o//direction(bariucentric)\n ;vec4 t=-o/d\n ;n=-1./0.;float f=1./0.//near&far intersections valid since GL 4.1\n ;for(int i=0;i<4; ++i\n ){if(d[i]<0.)f=min(f,t[i])\n  ;else       n=max(n,t[i]);}\n ;if((f<=.0)||(f<=n))return false\n ;b=o+d*n\n ;p=b2n(m,step(b,vec4(mi(b)))) //step()=normal of nearest plane (in barycentric)\n ;return true;}\n\nvoid camera(out vec3 ro,out vec3 rd\n){float a=iTime*.1\n ;float d=2.5\n ;ro=vec3(d*sin(a),1,d*cos(a))\n ;rd=vec3(0,-.3,0);}\n\nvec3 background(){return vec3(0);}\n\n//from:  https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p\n){vec3 q = fract(vec3(p)*vec3(.1031, .1030, .0973))\n ;q += dot(q, q.yzx + 19.19)\n ;return fract((q.xx+q.yz)*q.zy);}\n\nvec3 feet_curve(float t\n){float subt=mod(t,3.)\n ;float x = sin(radians(min(subt*180.0,180.0)))\n ;float a0 = radians((t - subt)/3.0 * 30.0)\n ;float a1 = a0 + radians(30.0)\n ;float a = mix(a0, a1, min(subt,1.0))\n ;return vec3(cos(a),sin(a),mix(-1.0,-0.8,x));}\n\nvec3 calc_intersection(vec3 ro, vec3 rd\n){ro = ro.zxy\n ;rd = rd.zxy\n ;vec3 p[4]\n ;float ti = iTime * 8.0\n ;p[0]=feet_curve(ti)\n ;p[1]=feet_curve(ti+12.+1.)\n ;p[2]=feet_curve(ti+24.+2.)\n ;//spring animation\n ;ti = iTime * 4.0\n ;vec2 cuv = hash21(float(int(ti / 5.0))) * 2.0 - 1.0\n ;ti = mod(ti, 5.0) * 2.0\n ;float rk = (10.0 - ti) / (1.0 + (10.0 - ti))\n ;float spr=clamp(rk * ((8.0 - sin(ti * 8.0) / (ti * ti))/8.0), 0.0, 2.0)\n ;p[3] = vec3(mix(vec2(0.0), cuv, spr), mix(-0.7, 0.5, spr))\n ;vec3 l = normalize(vec3(1.0, -1.0, -1.0))\n ;float plane_t=-(ro.z + 1.0) / rd.z\n ;float neart\n ;vec4 nearb\n ;vec3 nearn\n ;if (iSimplex3(p,v22(ro,rd),neart,nearb,nearn)\n ){vec4 c=nearb\n  ;float lit = 0.2 + 0.8 * max(0.0, dot(-l, nearn))\n  #if 0 \n  ;mat3 m=mat3(1);return c.x*m[0]+c.y*m[1]+c.z*m[2]+c.w*vec3(1,0,1)//fullbright anbient \n  #endif\n  #if 0\n  ;return h0.n*.5+.5;//fullbright normal\n  #endif\n  ;mat3 m=mat3(1);\n  ;return lit*(c.x*(m[1]+m[2]*.5)+c.y*(m[0]+m[1]*.5)\n              +c.z*(m[0]+m[2]*.5)+c.w*(m[2]+m[0]*.5))\n ;}else if (plane_t>0.\n ){vec3 plane_p = ro + rd * plane_t\n  ;float sh = iSimplex3(p,v22(plane_p,-l),neart,nearb,nearn)?0.2:0.5\n  ;return vec3(sh) * abs(rd.z)\n ;} else return vec3(0.0);}\n\nmat3 calcLookAtMatrix(vec3 ro,vec3 rd,float o//ray,roll\n){rd=normalize(rd-ro)\n ;ro=normalize(cross(rd,vec3(sin(o),cos(o),0.0)))\n ;return mat3(ro,normalize(cross(ro,rd)),rd);}\n \nvoid mainImage(out vec4 c,vec2 u \n){u=(u.xy*2.-iR.xy)/iR.y\n ;vec3 ro, rd\n ;camera( ro, rd)\n ;mat3 camMat=calcLookAtMatrix(ro,rd,0.)//0.=roll\n ;rd=normalize(camMat*vec3(u,2))//2. =lens length\n ;c.xyz=background()\n ;c.xyz=calc_intersection(ro,rd)\n ;c.w=1.;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define iR iResolution\n\nstruct v22{vec3 a,b;};\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec4 a){return min(mi(a.xy),mi(a.zw));}\n\n\n\n\n/*\nthere is a way to speed this up, with more branches\n, by doing viewfrustums in barycentroicCoords.\nbecause (we skip a lot of calculations) with smart branching\n, set by simplex-frustum culling, \nbecause (simplex-self-occlusion is more likely in higher dimensions) \nThe more dimensions we have, the more likely we skip a triangle-trace:\n\nI alredy did it in 2d, whre frustums are easily visualized:\n  https://www.shadertoy.com/view/3tffRH\n\nWe define a branch condition\n, that is a viewfrustum around 2 (in 2d) or 2 (in 3d) points.\nwe have as many frustums as triangles (in 2d) or lines (in 2d)\nin 3d, you have 4 viewfrustums for 4 triangleFaces\n\nwe only have to trace a triangle, iff [rayTarget] is inside the viewfrustum\n, set by TriangleCorners and [rayOrigin]\nwether or not the [rayTarget] point is inside or outside a viewfrustum\n, depends only on (3 of 4) signs of its barycentric coordinates.\nif (sum of these 3 signs is == -3) [rayTarget] is inside the Viewfrustum\n(4th sign == baricentricDistance2triangle. By ignoring the 4th sign\n, we assert a 3simplex that lacks one side == triangular frustum)\nbecause, if you ignore 1 of 4 baricentric coordinatesof a simplex\n, you have a viewfrustum==simplex with one missing \"boundary\"\n (in 4d, that boundary is a 3simplex)\n\nto get a frustum (of up to 4 frustums in 3d):\nOne of the points for the barycentric transform\n, that is NOT on the place of our frustum, is replaced by the [RayOrigin]:\ncarthersian2barycentric(rayTarget,rayOrigin,corner0,corner1,corner2) \n (corner4 of the traced simplex is replaced here)\ncalculates barycentricCoords of [rayTarget] \n within the 3simplex[rayOrigin,corner0,corner1,corner2]\n\nyou may think, its dumb, to calculate (up to) 4 barycentricTransforms for 4 frustums.\nthankfully, all determinants(of these barycentric transformation matrices) \n are identical! (and they likely share more parameters)\n\n\n\n\n// barycentricfrustumcull, raytrace, 3simplex, tetraeder,tetrahedron, \n\n/*\nbackup of a catchy reply\nThe [url=https://www.shadertoy.com/view/4lByzD]commontab of this shader[/url]\nhas a long reply,with the concept of a lot of optimizing conditionals,that would use\n[url=https://www.shadertoy.com/view/3tffRH] barycentric-frustum-culling of this 2d shader[/url]\nbut in 3d\n\nin 3d that calculates up to 4 viewFustrums == barycentricMatrices, that share many parameters (not just the determinant), and checks 3 of their signs to tell the position of RayDirection within the fustrum.\n\n(by calculating (up to) 3 more barycentricCoordinates) for more conditionals,\nwe can be VERY analytically occlusionOptimitsic = assert that the first traced triangles occlude all other triangles (left to be traced only if they are not occluded)\n,and know this condition before tracing, by using [url=https://www.shadertoy.com/results?query=barycentricfrustumcull]extended barycentri-frustum-cull[/url]ing, that:\nmay also check, if the first 1 triangle  occludes the other 3 triangles ==1 simplexCorner is behind the plane of the other3 SimplexCorners, as seen from RayOrigin (first triangle occludes all other 3) (this checks 1 barycentric sign)\nmay also check, if the first 2 triangles occludes the other 2 triangles ==(trickier but doable, with very little overhead) (this compares 2*2 barycentric signs sign)\nmay also check, if the first 3 triangles occludes the other 1 triangle  ==if(rayDirection was in all other 3 fustrums) the last triangle is occluded by all others togetheer (==convexHull)\n*/\n\n\n/*\n----- main pseudoFunction:\n\nbecause (there is always fully occluded triangle\n, we assert that the 4th triangle that we trace is occluded\n, i take that 1:4 chance to maybe skip 1 trace.)\nwe check 3 sides one after another (and trace it only if RayOrigin is in the frustum).\nfor each of 3 frustums[\n if (RayOrigin is in the Viewfrustum[0,1,2]) we trace triangle[0,1,2]\n , and memorize intersectionDistance (==zFar==infinity if ray looks away)\n we only keep the smallest intersectionDistance (and maybe an analytic surface normal\n , and some texture properties)\n we buffer 3 bools, that memorize, if RayTarget was in these 3 viewfrustums\n}\n\nif we already traced 3 triangles, we can skip the 4th triangle\n, since all simplexes are convex.\nelse if RayOrigin is in the Viewfrustum[3], we trace triangle[3]\n, and memorize intersectionDistance (==zFar==infinity if ray looks away)\n\nwe return the shortest intersectionDistance (and maybe an analytic surface normal\n, and some texture properties)\n\n\n\n---- to further speed this up, we can check\n, if (the first triangle occludes all other triangles)\nbecause (1 triangle can occlude all other triangles) \n we assert this to be the first triangle, to be traced)\nfor that we calculate \n carthersian2barycentric(rayOrigin,corner4,corner0,corner1,corner2)\ncorner4 is NOT part of the triangle, that we assume to occlude all other triangles.\nin baricentric coordinates, one sign() tells us\n, if corner4 is infront or behind \n (or or coplanarily on) the triangle(corner0,corner1,corner2)\nif it is behind, we can just trace one triangle\n, and directly return IntersectionDistant...\n\n\n\n--- to further speed this up, there is a case\n , where 2 of 4 triangles occlude the other 2 triangles. \n it can be spotted analytically.\n\nbecause (2 triangles can occlude the other 2 triangles) \n we assert the first 2 triangles to occlude the other 2 triangles.\n (all other 3d cases are already caught above)\n\nconditional logic here is:\nif(2 points, that are NOT part oour first 2 DIFFERENT frustums\n, are both inside the OTHER frustum \n   (after ignoring 2 (!!) signs==boundaries of each frustum here)) \n   than the first 2 triangles occlude the other 2 triangles \n   (and we can skipp all other traces)\n\nto check this, we compare 2*2 sign of pairs of the first 2 frustums\n, (i may have messed up triangle chirality, whic hmay flip surfaceNormal)\ncarthersian2barycentric(rayOrigin,corner4,corner0,corner1,corner2)\ncarthersian2barycentric(rayOrigin,corner0,corner4,corner1,corner2)\n\n\ni started to conceptualize pseudocode this in THIS commontab of BELOW\nhttps://www.shadertoy.com/view/4lByzD  \nBEFORE remembering, that the (now) parent shader\nhttps://www.shadertoy.com/view/4tSyzD\npretty much has all the missing code of that\n*/\n\n\n\n\n\n\n\n/*\nvec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c){\n ;mat2 m=mat2(a.x-c.x,b.x-c.x\n             ,a.y-c.y,b.y-c.y)\n ;p*=inverse(m)\n ;return vec3(1.-p.x-p.y,p)\n ;//above should be similar to below\n ;b=b-a\n ;c=c-a\n ;p=p-a\n ;a.x=b.x*c.y-c.x*b.y\n ;float v=(p.x*c.y-c.x*p.y)/a.x\n ;float w=(b.x*p.y-p.x*b.y)/a.x\n ;return vec3(1.-v-w,v,w);}\n\n//asserting the above matrix inverse to be correct\n//the below extenions to 3d works just fine\n\n//  https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Barycentric_coordinates_on_tetrahedra\nvec4 barycentric(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d){\n ;mat3 m=mat3(vec3(a.x,b.x,c.x)-d.x\n             ,vec3(a.y,b.y,c.y)-d.y\n             ,vec3(a.z,b.z,c.z)-d.z)\n ;//it may make sense to pre-calculate the determinant of this matrix (without d?)\n ;//to only have 1 division for 3 (or 4) barycentric() calculations\n ;//this is more specivic mat3 inverse() calculation\n ;p*=inverse(m)\n ;return vec4(1.-p.x-p.y-p.t,p);}\n\n//useCase\n//q=barycentric(p,a,b,c,d)\n//if (max(max(q.x,q.y),max(q.z,q.w))<0.) p is insite tetraeder[a,b,c,d] \n//s=sign(q) //every sign equals wether it is inside or outside of one plane of the tetraeder.\n//make a tetraeder of a=Campos b,c,d=triangleCorners p=camTarget\n//and check the signs= sign(barycentric(p,a,b,c,d))\n//to see if the ray hits or misses\n//(the sign of the [a,b,c] plane is irrelevant here)\n//we care for the sign of the planes [p,a,b] [p,a,c] [p,b,c]\n//\n//to trace a simplex in barycentric\n//as first step, it may make sense to calculate the 3 surface normals\n//and if any of them faces away from RayDirection, its an occluded ==skippable face.\n//if any of the 3 normals faces away from Camera, calculate the 4th normal,too\n\nfloat pd(vec2 b,vec2 c){return dot(b,c.yx*vec2(1,-1));}\n//float pd(vec2 b,vec2 c){return b.x*c.y-b.y*c.x;}\n\n\n//chirality of a,b,c inpputs sets sign of normal!!!\nvec3 triangleNormal(vec3 a,vec3 b,vec3 c\n){//return b.yzx*c.zxy-b.zxy*c.yzx//short and slow\n  return vec3(pd(b.yz,c.yz) \n             ,pd(b.zx,c.zx)\n             ,pd(b.xy,c.xy));}//fast for using 3 dot!\n\n//return if rd looks towards Triangle-front or towards triangle-back \nfloat normalToCamera(vec3 rd,vec3 a,vec3 b,vec3 c){\n ;if(dot(triangleNormal(a,b,c),a-rd)>0.)return 1.;return 0.;}\n\n//return if [rd] is in tetraeder [ro,a,b,c]\nfloat isInTetraeder(vec3 ro,vec3 rd,vec3 a,vec3 b,vec3 c){\n ;rd=sign(barycentric(rd,ro,a,b,c).yzw)//all signs of rd must be negative\n ;if(suv(rd)==-3.)return 1.;return 0.;}\n\nfloat traceTriangle(vec3 ro,vec3 rd,vec3 a,vec3 b,vec3 c\n){//return SQARED distance to intersection with triangle\n //return very LARGE value, if there is no intersection\n ;return 0.;}//todo\n\n#define tsb(x,a,b,c) t.x=normalToCamera(rd,a,b,c);if(t.x>0.){if(isInTetraeder(ro,rd,a,b,c)>0.)t.x=traceTriangle(ro,rd,a,b,c);}\n\n//barycentric simplex tracing (with 1,2 or 3 mat3 inversions)\n//return nearest intersection of ray (ro,rd) with tetraedere (a,b,c,d)\n//return 9999. if there is no intersection\nfloat traceSimplexBary(vec3 ro,vec3 rd,vec3 a,vec3 b,vec3 c,vec3 d\n){vec4 t=vec4(0)\n ;//may even check all 4 points, if dot(point-ro,rd) looks at the point or away from it.\n ;//if it looks away from all 3 points of a triangle, we can skip that triangle\n ;//mat4 n=mat4 0//i may use this to buffer 3 surface normals\n ;tsb(x,a,b,c)\n ;tsb(y,b,c,d)//may have to swivel this to correct places\n ;tsb(z,c,d,a)//may have to swivel this to correct places\n ;if(suv(t.xyz)<3.)tsb(w,a,b,d)//may have to swivel this to correct places\n  else  t.w=9999.//large value means no intersection\n ;return mi(t)\n ;}\n /**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 to_bary(vec3 p[4], vec3 t) {\n    // plucked straight out of SageMath\n    // it's possible to crunch these equations further but ain't nobody got time for that\n\n//ollj disagreed:\n//ollj knows that using defines and differentiating them \n//is THE way to find patterns:\n\n//#defines may not be faster\n//, but the patterns that you find with them likely are faster\n//or at least make it easier to make special or general cases.\n    \n#define bar0(b,a) ((p[a].z - t.z)*p[3].y - p[a].y*(p[3].z - t.z) - (p[a].z - p[3].z)*t.y)*p[b].x \n//looks like a LABEL_swap (a<->b) happened above. it is correct, do not sweat it!\n#define bar1(a,b) ((p[a].z - t.z)*p[3].y - p[a].y*(p[3].z - t.z) - (p[a].z - p[3].z)*t.y)*p[b].x \n#define bar2(a,b) ((p[a].z - t.z)*p[b].y - p[a].y*(p[b].z - t.z) - (p[a].z - p[b].z)*t.y)*p[3].x \n#define bar3(a,b) ((p[a].z - p[3].z)*p[b].y - p[a].y*(p[b].z - p[3].z) - (p[a].z - p[b].z)*p[3].y)*t.x\nfloat det = (\n+((p[1].z-p[3].z)*p[2].y-p[1].y*(p[2].z-p[3].z)-(p[1].z-p[2].z)*p[3].y)*p[0].x \n-((p[0].z-p[3].z)*p[2].y-p[0].y*(p[2].z-p[3].z)-(p[0].z-p[2].z)*p[3].y)*p[1].x \n+((p[0].z-p[3].z)*p[1].y-p[0].y*(p[1].z-p[3].z)-(p[0].z-p[1].z)*p[3].y)*p[2].x \n-((p[0].z-p[2].z)*p[1].y-p[0].y*(p[1].z-p[2].z)-(p[0].z-p[1].z)*p[2].y)*p[3].x);\nvec3 w=vec3((-bar0(1,2)+bar1(1,2)-bar2(1,2)+bar3(1,2))\n           ,(+bar0(0,2)-bar1(0,2)+bar2(0,2)-bar3(0,2))\n           ,(-bar0(0,1)+bar1(0,1)-bar2(0,1)+bar3(0,1)));\n//return vec4(w,det-(w.x+w.y+w.z))/det;//  det/det!=1. is possible for some det!!!\nreturn vec4(w/det,1)-vec4(0,0,0,(w.x+w.y+w.z))/det;//overly explicit\n}//this kind of looks like a matrix-transpose would be useful,\n\nvec3 from_bary(vec3 p[4], vec4 w)\n{return p[0]*w.x+p[1]*w.y+p[2]*w.z+p[3]*w.w;}\n\n// return the intersection of ray and tetrahedron as well as the barycentric\n// coordinates of the hit points\nbool iSimplex3(vec3 p[4], vec3 ro, vec3 rd, \n               out float near, out float far, \n               out vec4 bnear, out vec4 bfar) {\n    // convert ray endpoints to barycentric basis\n    // this can be optimized further by caching the determinant\n    vec4 r0 = to_bary(p, ro);\n    vec4 r1 = to_bary(p, ro + rd);\n\n    // build barycentric ray direction from endpoints\n    vec4 brd = r1 - r0;\n    // compute ray scalars for each plane\n    vec4 t = -r0/brd;\n    \n    near = -1.0 / 0.0;\n    far = 1.0 / 0.0;    \n    for (int i = 0; i < 4; ++i) {\n        // equivalent to checking dot product of ray dir and plane normal\n        if (brd[i] < 0.0) {\n            far = min(far, t[i]);\n        } else {\n            near = max(near, t[i]);\n        }\n    }\n    \n    bnear = r0 + brd * near;\n    bfar = r0 + brd * far;\n    \n    return (far > 0.0) && (far > near);\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = iTime * 0.1;\n    float d = 2.5;\n\tcamPos = vec3(d*sin(an),1.0,d*cos(an));\n    camTar = vec3(0.0,-0.3,0.0);\n}\n\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 feet_curve(float t) {\n    float subt = mod(t, 3.0);\n    float x = sin(radians(min(subt*180.0,180.0)));\n    float a0 = radians((t - subt)/3.0 * 30.0);\n    float a1 = a0 + radians(30.0);\n    float a = mix(a0, a1, min(subt,1.0));\n\treturn vec3(cos(a),sin(a),mix(-1.0,-0.8,x));\n}\n\nvec3 calc_intersection( in vec3 ro, in vec3 rd ) {\n    ro = ro.zxy;\n    rd = rd.zxy;\n    vec3 p[4];\n    float ti = iTime * 8.0;\n    p[0] = feet_curve(ti);\n    p[1] = feet_curve(ti + 12.0 + 1.0);\n    p[2] = feet_curve(ti + 24.0 + 2.0);\n    // do a little spring animation\n    ti = iTime * 4.0;\n    vec2 cuv = hash21(float(int(ti / 5.0))) * 2.0 - 1.0;\n    ti = mod(ti, 5.0) * 2.0;\n    float rk = (10.0 - ti) / (1.0 + (10.0 - ti));\n    float spr = clamp(rk * ((8.0 - sin(ti * 8.0) / (ti * ti))/8.0), 0.0, 2.0);\n    p[3] = vec3(mix(vec2(0.0), cuv, spr), mix(-0.7, 0.5, spr));\n    \n    vec3 l = normalize(vec3(1.0, -1.0, -1.0));\n    \n    float plane_t = -(ro.z + 1.0) / rd.z;\n    \n    float t0, t1;\n    vec4 c0, c1;\n    if (iSimplex3(p, ro, rd, t0, t1, c0, c1)) {\n        vec4 c = (t0 > 0.0)?c0:c1;\n        \n        vec3 n;\n        float lc = min(min(c.x, c.y), min(c.z, c.w));\n        if (c.x == lc) {\n            n = cross(p[2] - p[1], p[3] - p[1]);\n        } else if (c.y == lc) {\n            n = cross(p[0] - p[2], p[3] - p[2]);\n        } else if (c.z == lc) {\n            n = cross(p[1] - p[0], p[3] - p[0]);\n        } else {\n            n = cross(p[2] - p[0], p[1] - p[0]);\n        }\n        n = normalize(n);\n        float lit = max(0.0, dot(l, -n)*0.5+0.5);\n        \n        return lit * (\n              c.x * vec3(0.0, 1.0, 0.5)\n        \t+ c.y * vec3(1.0, 0.5, 0.0)\n            + c.z * vec3(1.0, 0.0, 0.5)\n            + c.w * vec3(0.5, 0.0, 1.0));\n    } else if (plane_t > 0.0) {\n\t    vec3 plane_p = ro + rd * plane_t;\n        float sh = iSimplex3(p, plane_p, -l, t0, t1, c0, c1)?0.2:0.5;\n        return vec3(sh) * abs(rd.z);\n    } else {        \n        return vec3(0.0);\n    }\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    col = calc_intersection( ro, rd );\n\t   \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}