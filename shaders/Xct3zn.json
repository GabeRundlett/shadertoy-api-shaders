{
    "Shader": {
        "info": {
            "date": "1711313900",
            "description": "Simple cellular automata where there are only two rules:\n- if all four direct neighbors have the same base color, the cell becomes a darker version of that color\n- otherwise, each cell has a 50% chance of becoming the color of one of its direct neighbors",
            "flags": 32,
            "hasliked": 0,
            "id": "Xct3zn",
            "likes": 3,
            "name": "Cell War ",
            "published": 3,
            "tags": [
                "simulation",
                "cellularautomata",
                "conflict"
            ],
            "usePreview": 0,
            "username": "michionlion",
            "viewed": 90
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define CELL_SIZE 8.0\n#define CELL_POINT 0.5\n#define INITIAL_GROUP_SIZE 30000.0\n#define NUM_COLORS 5.0\n#define COLOR_DEPTH 8.0\n#define FRAMES_PER_STEP 1\n\n\nvec2 cellToUV(ivec2 cell) {\n    return (vec2(cell) + CELL_POINT) * CELL_SIZE / iResolution.xy;\n}\n\nivec2 uvToCell(vec2 uv) {\n    // Scale UV coordinates to pixel space, then adjust for CELL_SIZE to get cell coordinates.\n    return ivec2(uv * iResolution.xy / CELL_SIZE);\n}\n\nint getColorIndex(float value) {\n    return int(value * ((NUM_COLORS * COLOR_DEPTH) - 1.0)) % int(NUM_COLORS * COLOR_DEPTH);\n}\n\nfloat getColorStore(int index) {\n    return float(index) / ((NUM_COLORS * COLOR_DEPTH) - 1.0);\n}\n\nvec3 getColor(int index) {\n    // Define base colors\n    vec3 colors[8] = vec3[8](\n        vec3(0.5, 0.0, 0.0), // Red\n        vec3(0.0, 0.5, 0.0), // Green\n        vec3(0.0, 0.0, 0.5), // Blue\n        vec3(0.5, 0.5, 0.1), // Yellow\n        vec3(0.1, 0.5, 0.5), // Cyan\n        vec3(0.5, 0.1, 0.5), // Magenta\n        vec3(0.9, 0.4, 0.0), // Orange\n        vec3(0.7, 0.5, 0.8) // Lavender\n    );\n    \n    vec3 lightColors[8] = vec3[8](\n        vec3(1.0, 0.1, 0.1), // Red\n        vec3(0.1, 1.0, 0.1), // Green\n        vec3(0.1, 0.1, 1.0), // Blue\n        vec3(1.0, 1.0, 0.0), // Yellow\n        vec3(0.0, 1.0, 1.0), // Cyan\n        vec3(1.0, 0.0, 1.0), // Magenta\n        vec3(1.0, 0.8, 0.4), // Orange\n        vec3(0.9, 0.7, 1.0) // Lavender\n    );\n\n    // Determine the color and saturation level\n    int colorIndex = index / int(COLOR_DEPTH);\n    int saturationLevel = index % int(COLOR_DEPTH);\n\n    // Base color\n    vec3 baseColor = colors[colorIndex];\n    \n    // Light color\n    vec3 lighterColor = lightColors[colorIndex];\n\n    // Calculate the mix factor for the saturation\n    float mixFactor = (float(saturationLevel) + 1.0) / COLOR_DEPTH;\n\n    // Calculate the final color by mixing based on the saturation level\n    vec3 col = mix(lighterColor, baseColor, mixFactor);\n\n    return col;\n}\n\nint colorOf(ivec2 cell) {\n    return getColorIndex(texture(iChannel0, cellToUV(cell)).a);\n}\n\nint baseColor(int color) {\n    return int(color / int(COLOR_DEPTH)) * int(COLOR_DEPTH);\n}\n\nint darken(int color) {\n    return color + int(color % int(COLOR_DEPTH) != int(COLOR_DEPTH) - 1);\n}\n\nint lighten(int color, int into) {\n    if(color == baseColor(color)) return into;\n    return color - 1;\n}\n\nint colorLevel(int color) {\n    return color % int(COLOR_DEPTH);\n}\n\nint getNextCellColor(vec2 uv, ivec2 cell, ivec2 size) {\n    int current = getColorIndex(texture(iChannel0, uv).a);\n    int base = baseColor(current);\n    int next = current;\n    \n    int above = colorOf(cell + ivec2( 0, 1));\n    int below = colorOf(cell + ivec2( 0,-1));\n    int right = colorOf(cell + ivec2( 1, 0));\n    int left  = colorOf(cell + ivec2(-1, 0));\n    \n    int options[8] = int[8](\n        current,current,current,current,\n        baseColor(above),\n        baseColor(below),\n        baseColor(right),\n        baseColor(left)\n    );\n    \n    // darken\n    bvec4 surround = bvec4(\n        options[4] == base,\n        options[5] == base,\n        options[6] == base,\n        options[7] == base);\n    if(all(surround)) {\n        next = darken(current);\n    } else {\n        // random takeover\n        int r = int(random(vec2(cell*size), iTime)*8.0);\n        next = lighten(current, options[r]);\n    }\n    \n    return next;\n}\n\n//int getInitialCellColor(ivec2 cell, ivec2 size) {\n    //return (cell.y * 8 + cell.x) % 64;\n    //return int(random(vec2(cell * size), iTime) * NUM_COLORS) * int(COLOR_DEPTH);\n//    return int(simplex(vec2(cell * size) * (1.0 / INITIAL_GROUP_SIZE)) * NUM_COLORS) * int(COLOR_DEPTH);\n//}\n\nfloat warpDomain(vec2 uv) {\n    // Two layers of noise - one for coarse base shapes, another for finer details\n    float baseNoise = simplex(uv * 0.005); // Coarse base noise scale\n    float detailNoise = simplex((uv + baseNoise) * 0.01); // Finer detail noise\n\n    // Blend between base shapes and finer details\n    return mix(baseNoise, detailNoise, 0.5);\n}\n\nint getInitialCellColor(ivec2 cell, ivec2 size) {\n    // Warp domain with noise\n    float warpedNoise = warpDomain(vec2(cell) * CELL_SIZE);\n\n    // Normalize noise to 0.0 - 1.0\n    warpedNoise = warpedNoise * 0.5 + 0.5;\n\n    // Quantize the noise value into discrete steps\n    int quantizedNoise = int(floor(warpedNoise * NUM_COLORS));\n\n    // Ensure color index falls within the expected range\n    quantizedNoise = clamp(quantizedNoise, 0, int(NUM_COLORS - 1.0));\n\n    // Calculate final color index\n    return quantizedNoise * int(COLOR_DEPTH);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    ivec2 size = ivec2(iResolution.xy / CELL_SIZE);\n    ivec2 cell = uvToCell(uv);\n    \n    if(iFrame == 0) {\n        int color = getInitialCellColor(cell, size);\n        fragColor = vec4(getColor(color), getColorStore(color));\n        //fragColor = texture(iChannel1, uv);\n    } else if (iFrame % FRAMES_PER_STEP == 0) {\n        int color = getNextCellColor(uv, cell, size);\n        fragColor = vec4(getColor(color), getColorStore(color));\n        //fragColor = texture(iChannel0, uv);\n    } else {\n        int color = getColorIndex(texture(iChannel0, uv).a);\n        fragColor = vec4(getColor(color), getColorStore(color));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Gold Noise function\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SRT = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\n\nfloat random(in vec2 coordinate, in float seed) {\n    return fract(sin(dot(coordinate*seed, vec2(PHI, PI)))*SRT);\n}\n\n\n// Simplex Noise function\nvec3 permute(vec3 x) {\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nfloat simplex(vec2 uv) {\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(uv + dot(uv, C.yy));\n    vec2 x0 = uv -   i + dot(i, C.xx);\n    \n    // Other corners\n    vec2 i1;\n    // i1.x = step(x0.y, x0.x); i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}