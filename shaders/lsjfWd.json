{
    "Shader": {
        "info": {
            "date": "1502917136",
            "description": "experimenting with generalizations of venn, a silly color-picker now screams: \"We  can do this the hard way or the difficult way!\"\nme\" All ColorPickers are Yellow. Some Syllogisms are ColorPickers.-> Some syllogisms are yellow.\"\n\"Difficult it is then!\"",
            "flags": 0,
            "hasliked": 0,
            "id": "lsjfWd",
            "likes": 1,
            "name": "difficult syllogism color picker",
            "published": 3,
            "tags": [
                "differential",
                "syllogism",
                "venn"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 613
        },
        "renderpass": [
            {
                "code": "/*\nsandboxing how I can efficiently visualize distances to 3 ring-shapes\nby mixing 3 colors,\nd stores distances to 3 shapes.\n//differentials of distance to 2 shapes if miv(d)-d;\ne=miv(abs(d-1.1))-(d-1.1);//miv() = vectorMin()\n//above extends on that, b also making shapes \"rings\"\n*abs(atan(e)/acos(-1.)); gets nice transitions from e\nsign(e)*sign(d)* for highlights/contrast.\n\nthe mixing is easy. keeping context on a 3*venn/syllogism is not.\n\nfor a \"more useful\" color picker,\nI would like a more continous gradient, but have no odea how.\n\nthis was never intended to become anything like a color picker.\nor a   https://en.wikipedia.org/wiki/Syllogism\n*/\n\n\n/*\ntiny framework 2017-08\nI use \"bisymmetry\" as shorthand for \"gradient from symmetry to assymmetry\"\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//zoom of view Frame\n#define ViewZoom 4.\n\n/* end__.Parameters\n   start.Static\n*/\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\n#define dd(a) dot(a,a)\n//making a triangle wave;\n#define fr(a) fract(a)\n#define ss2t(a) a=abs(a*2.-1.)\n#define grid(u) mav(abs(fr(u)*2.-1.))\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n\n/* end__.Static\n   start.Implicit\n*/\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n v1 u=fra(U);\n v2 c=v2(0);\n v3 m=v3(fra(iMouse.xy),fra(iMouse.zw));\n if(iMouse.z<=0.){\n  m.xy=vec2(sin(iTime),cos(iTime*1.61));\n }\n //m.xy=abs(m.xy);//mouse is always positive.\n /*main*/\n vec3 d;\n d.x=dd(u-.5);;\n d.y=dd(u+.5);\n d.z=dd(u-m.xy);//3 distances\n d=sqrt(d);\n //d=abs(d-1.);\n vec3 e=miv(abs(d-1.1))-(d-1.1);\nfloat tol=1e-10;\n //e=-((e+tol));\n    c=sign(d)*sign(e.zxy)*abs(atan(e.zxy)/acos(-1.));\n    /*\n if (e.x<tol)c.x=d.x;\n if (e.y<tol)c.y=d.y;\n if (e.z<tol)c.z=d.z;\n */\n  c=mix(c+.5,fract(c*2.),sin(iTime*.61));\n return c;}\n//#define \n\nvoid mainImage( out vec4 O,in vec2 U){O=vec4(c(U),1);}\n/* end__.Main\n   start.Tail\n*/\n\n\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}