{
    "Shader": {
        "info": {
            "date": "1603823295",
            "description": "Simulation of a colored cube moving on a checkerboard.\n\nThe cube move one step forward, then one step rightward, then one step forward, ...",
            "flags": 0,
            "hasliked": 0,
            "id": "llBXRm",
            "likes": 6,
            "name": "Colored Cube on a Checkerboard",
            "published": 3,
            "tags": [
                "cube",
                "checkerboard",
                "colored"
            ],
            "usePreview": 0,
            "username": "Nauja",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "/**\n * Simulation of a colored cube moving on a checkerboard.\n *\n * The cube move one step forward, then one step rightward, then one step forward, ...\n *\n * Although the cube seems to rotate infinitely, it only rotates by 90Â° (either forward or\n * rightward) during [0, PI] seconds then go back to its initial rotation. The cube always stays\n * at position (0, 0, 0) but move a little upward during its rotation.\n *\n * The floor moves one tile backward or leftward during [0, PI] seconds then go back to its\n * initial position.\n *\n * So we have an infinite loop where everything move during [0, PI] seconds then go back to\n * the initial state.\n *\n *\n * The forward movement follows a periodic function looking like:\n *\n *     /         /         /\n *    /         /         /\n *   /         /         /\n *  /         /         /\n * /    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n *\n *\n * The rightward movement follows a periodic function looking like:\n *\n *          /         /         /\n *         /         /         /\n *        /         /         /\n *       /         /         /\n * _____/    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n *\n * So every PI seconds, the cube is moving either forward or rightward.\n *\n * To create the illusion that the cube is moving one tile forward and one tile rightward each\n * step, many equations include an offset of 1.0 if sin(time) > 0.0. You can set ENABLE_FLOOR_OFFSET\n * to 0.0 to disable this offset for the floor and you will see that its position is reset each time.\n */\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define SPEED 1.0 // how fast is the simulation\n#define ENABLE_FLOOR_OFFSET 1.0\n#define PI 3.1415926535897932384626433832795\n#define PI2 6.28318530718\n\n//------------------------------------------------------------------\n\n// possible shapes\n#define SHAPE_VOID 0.0\n#define SHAPE_FLOOR 1.0\n#define SHAPE_CUBEFRAME 2.0\n// cube faces are arranged in the order they will touch the floor\n#define SHAPE_CUBEFACEDOWN 3.0\n#define SHAPE_CUBEFACEFRONT 4.0\n#define SHAPE_CUBEFACERIGHT 5.0\n#define SHAPE_CUBEFACEUP 6.0\n#define SHAPE_CUBEFACEBACK 7.0\n#define SHAPE_CUBEFACELEFT 8.0\n\n// intersected shape\nstruct Shape\n{        \n    float d; // distance\n    float t; // type of shape\n    vec3 c; // color\n};\n\n// colors of each face of the cube\nconst vec3 CubeFaces[6] = vec3[6](\n    vec3(1.0, 0.65, 0.0), // yellow, down\n    vec3(0.14, 1.0, 0.0), // green, front\n    vec3(1.0, 0.0, 0.0), // red, right\n    vec3(1.0, 1.0, 1.0), // white, up\n    vec3(0.0, 0.55, 1.0), // blue, back\n    vec3(1.0, 0.31, 0.0) // orange, left\n);\n\n//------------------------------------------------------------------\n\n// create a quaternion\nvec4 quat(in vec3 v, in float a)\n{\n    return vec4(v * sin(a / 2.0), cos(a / 2.0));\n}\n\nvec4 quat_inv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 p2q(in vec3 p)\n{\n    return vec4(p, 0);\n}\n\nvec4 q_mul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\nvec3 rotate(in vec3 p, in vec4 q)\n{\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\nShape opU( Shape d1, Shape d2 )\n{\n    if (d1.d<d2.d) {\n        return d1;\n    }\n    return d2;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n\n// test intersection with a box https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// test intersection with the black frame of the cube\nfloat sdCubeFrame(vec3 p, vec3 b)\n{    \n    return opSubtraction(\n        sdBox(p, b * vec3(0.9, 0.9, 1.1)),\n        opSubtraction(\n            sdBox(p, b * vec3(0.9, 1.1, 0.9)),\n            opSubtraction(\n                sdBox(p, b * vec3(1.1, 0.9, 0.9)),\n                sdBox(p, b)\n            )\n        )\n    );\n}\n\n// test intersection with the colored cube\nShape sdColoredCube( in vec3 pos )\n{\n    Shape res = Shape( 1e10, SHAPE_VOID, vec3(0.0, 0.0, 0.0) );\n\n    {\n      res = opU( res, Shape( sdCubeFrame( pos, vec3(0.25, 0.25, 0.25) ), SHAPE_CUBEFRAME, vec3(0.0, 0.0, 0.0 )) );\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.24, 0.0), vec3(0.225, 0.01, 0.225)), SHAPE_CUBEFACEDOWN, vec3(0.0, 0.0, 0.0 ) )); // yellow, down\n      res = opU( res, Shape( sdBox( pos+vec3(-0.24, 0.0, 0.0), vec3(0.01, 0.225, 0.225)), SHAPE_CUBEFACEFRONT, vec3(0.0, 0.0, 0.0)) ); // green, front\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.0, 0.24), vec3(0.225, 0.225, 0.01)), SHAPE_CUBEFACERIGHT, vec3(0.0, 0.0, 0.0 ) )); // red, right\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.0, -0.24), vec3(0.225, 0.225, 0.01)), SHAPE_CUBEFACELEFT, vec3(0.0, 0.0, 0.0 ) )); // orange, left\n      res = opU( res, Shape( sdBox( pos+vec3(0.24, 0.0, 0.0), vec3(0.01, 0.225, 0.225)), SHAPE_CUBEFACEBACK, vec3(0.0, 0.0, 0.0 ) )); // blue, back\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, -0.24, 0.0), vec3(0.225, 0.01, 0.225)), SHAPE_CUBEFACEUP, vec3(0.0, 0.0, 0.0 ) )); // white, up\n    }\n    \n    return res;\n}\n\n//------------------------------------------------------------------\n\n/**\n * calculate the forward movement\n * \n *     /         /         /\n *    /         /         /\n *   /         /         /\n *  /         /         /\n * /    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n */\nfloat advanceX(in float time)\n{\n    return mod(min(time - floor(time / PI2) * PI, PI * ceil(time / PI2)) * ceil(sin(time)), PI) / 2.0;\n}\n\n/**\n * same as advanceX but without the reset every [PI, 2PI]\n *\n * This is used to compute the forward movement when time == PI without having the\n * reset to 0.\n */\nfloat advanceX2(in float time)\n{\n    return (time - floor(time / PI2) * PI) / 2.0;\n}\n\n/**\n * calculate the rightward movement\n * \n *          /         /         /\n *         /         /         /\n *        /         /         /\n *       /         /         /\n * _____/    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n */\nfloat advanceZ(in float time)\n{\n    return mod(min(time - PI - floor((time - PI) / PI2) * PI, PI * ceil((time- PI) / PI2)) * (1.0 - ceil(sin(time))), PI) / 2.0;\n}\n\n// test intersection with the scene\nShape map( in float time, in vec3 pos )\n{\n    Shape res = Shape( 1e10, SHAPE_VOID, vec3(0.0, 0.0, 0.0) );\n\n    {\n        pos += vec3(0.0, -0.25, 0.0);\n        pos += vec3(0.0, -0.10, 0.0) * abs(sin(time));\n    \tpos = rotate(pos, q_mul(\n            quat(vec3(0.0, 0.0, 1.0), advanceX(time)),\n        \tquat(vec3(1.0, 0.0, 0.0), advanceZ(time))\n       \t));\n    \tres = opU( res, sdColoredCube(pos) );\n    }\n    \n    return res;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nShape raycast( in float time, in vec3 ro, in vec3 rd )\n{\n    Shape res = Shape(-1.0,SHAPE_VOID,vec3(0.0,0.0, 0.0));\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = Shape( tp1, SHAPE_FLOOR, vec3(1.0, 1.0, 1.0) );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            Shape h = map( time, ro+rd*t );\n            if( abs(h.d)<(0.0001*t) )\n            { \n                res = Shape(t,h.t, h.c); \n                break;\n            }\n            t += h.d;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in float time, in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( time, ro + rd*t ).d;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in float time, in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(time, pos+0.0005*e).d;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in float time, in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map(time, pos + h*nor ).d;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in float time, in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in float time, in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    Shape res = raycast(time, ro,rd);\n    float t = res.d;\n    if( res.t != SHAPE_VOID )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (res.t == SHAPE_FLOOR) ? vec3(0.0,1.0,0.0) : calcNormal(time, pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = res.c;\n        float ks = 1.0;\n        \n        /**\n         * Every PI time, our cube is moving forward or rightward.\n         * \n         * shift is used to shift the first row to the left if == 1\n         */\n        float shift = ceil(sin(time)) * ENABLE_FLOOR_OFFSET;\n        float face = floor(time / PI);\n        if (res.t > SHAPE_CUBEFRAME)\n        {\n            if (res.t == SHAPE_CUBEFACEUP)\n            {\n            \tcol = CubeFaces[int(mod(face + 3.0, 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEDOWN)\n            {\n            \tcol = CubeFaces[int(mod(face, 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEFRONT)\n            {\n            \tcol = CubeFaces[int(mod(face + 1.0 + mod(face, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEBACK)\n            {// 1 - 3, 2-3; 3-5, 4-5, 5-1, 6-1\n            \tcol = CubeFaces[int(mod(face + 4.0 + mod(face, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACELEFT)\n            {\n            \tcol = CubeFaces[int(mod(face + 4.0 + mod(face + 1.0, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACERIGHT)\n            {\n            \tcol = CubeFaces[int(mod(face + 1.0 + mod(face + 1.0, 2.0), 6.0))];   \n            }\n        }\n        else if(res.t == SHAPE_FLOOR)\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n            \n            vec3 pos2 = pos;\n       \t\tpos2 += vec3(-0.25, 0.0, -0.25);\n            pos2 += vec3(0.5, 0.0, 0.0) * advanceX(time) / advanceX2(PI);\n       \t\tpos2 += vec3(0.0, 0.0, -0.5) * advanceZ(time) / advanceX2(PI);\n            float tileX = floor((pos2.x + 0.5) / 0.5f);\n            float tileZ = floor(-pos2.z / 0.5f) + shift;\n       \t\t//pos += vec3(0.0, 0.0, -1.0) * time * max(ceil(-1.0*sin(time)), 0.0) / 5.0;\n            float f = checkersGradBox( time, 1.7*pos.xz, 1.7*dpdx.xz, 2.5*dpdy.xz /* blur */);\n            col = 0.15 + f*vec3(0.05); // luminance + f * contrast\n            ks = 0.4; // godray ?\n            float f1 = floor(mod((pos2.x + 0.5 * shift) / 0.5, 2.0));\n            float f2 = clamp(floor(mod((pos2.z + 0.5 * f1) / 0.5, 2.0)), 0.15, 0.25);\n            col = vec3(f2, f2, f2);\n            /**\n             * tileX <= 0.0 && tileZ <= 0.0 : only tiles behind the cube\n             * abs(tileX - tileZ) <= 1.0 : only the diagonal\n             * tileZ >= tileX : one tile up, then one left, then one up, ...\n             */\n            if (tileX <= 0.0 && tileZ <= 0.0 && abs(tileX - tileZ) <= 1.0 && tileZ >= tileX)\n            {\n                /**\n                 * tileX + tileZ : initial color of the tile\n                 * + face : shift by the current cube face that is down\n                 * - shift : shift by one for odd rows\n                 */\n             \tcol = CubeFaces[int(mod(tileX + tileZ + face - shift, 6.0))];   \n            }\n        }\n\n        // lighting\n        float occ = calcAO( time, pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow(time, pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow(time, pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*4.0*SPEED;\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 2.5*cos(0.1/**time*/), 1.3, 2.5*sin(0.1/**time */) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( time, ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}