{
    "Shader": {
        "info": {
            "date": "1563652837",
            "description": "Testing simple color blending with metaball-y spheres",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsSz2",
            "likes": 3,
            "name": "ray-marched sphere colors test",
            "published": 3,
            "tags": [
                "test",
                "sdf"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 540
        },
        "renderpass": [
            {
                "code": "#define CLOSE_ENOUGH .001\n#define K .6\n#define RED vec3(.9,.1,.1)\n#define GREEN vec3(1.,.9,1.)\n\nstruct sdf_return\n{\n\tfloat sdf;\n    vec3 col;\n};\n\nstruct sphere\n{\n\tvec3 c;\n    float r;\n    vec3 col;\n};\n    \nstruct ray\n{\n\tvec3 o;\n    vec3 d;\n};\n    \nstruct dirLight\n{\n\tvec3 d;\n    float i;\n};\n\nfloat sphDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat dist_smooth( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdf(vec3 p, sphere s1, sphere s2)\n{\n    float sdist1 = sphDist(p, s1);\n    float sdist2 = sphDist(p, s2);\n\treturn dist_smooth(sdist1, sdist2, K);\n}\n\nsdf_return scene(vec3 p, sphere s1, sphere s2)\n{\n    \n    float sdist1 = sphDist(p, s1);\n    float sdist2 = sphDist(p, s2);\n    //from iq : https://iquilezles.org/articles/distfunctions\n    float h = clamp( 0.5 + 0.5*(sdist2-sdist1)/K, 0.0, 1.0 );\n    vec3 col = mix( s2.col, s1.col, h); \n    \n    return sdf_return(dist_smooth(sdist1, sdist2, K), col);\n}\n\n//from iq https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p, sphere s1, sphere s2 )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH,s1,s2 ) + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH,s1,s2 ) + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH,s1,s2 ) + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH,s1,s2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    sphere s1 = sphere(vec3(cos(iTime),-sin(iTime*1.4),10.0), .2, RED);\n    sphere s2 = sphere(vec3(sin(iTime),sin(iTime),10.0), .6, GREEN);\n    \n    dirLight l = dirLight(normalize(vec3(iTime, iTime, -1000.0)), 1.0);\n\t\n    ray r = ray(vec3(uv.x, uv.y, .0), normalize(vec3(uv.xy, 4.0)));\n    \n    vec3 col = vec3(1.0,1.0,.8);\n    \n    float dist = .0;\n    while(dist < 50.0)\n    {\n        vec3 rp = r.o + r.d *dist;\n        sdf_return r = scene(rp, s1, s2);\n        \n        if(r.sdf < CLOSE_ENOUGH)\n        {\n        \tvec3 n = calcNormal(rp,s1,s2);\n            col = r.col * max(dot(l.d, n), .0) * l.i;\n            break;\n        }\n        dist += r.sdf;\n    }\n\t\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}