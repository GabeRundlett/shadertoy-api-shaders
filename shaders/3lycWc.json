{
    "Shader": {
        "info": {
            "date": "1611848425",
            "description": "Creating snow effect using cellular2x2 function made by Stefan Gustavson",
            "flags": 0,
            "hasliked": 0,
            "id": "3lycWc",
            "likes": 0,
            "name": "it's snowing",
            "published": 3,
            "tags": [
                "noise",
                "function",
                "worleynoise",
                "snow",
                "min",
                "cellularnoise",
                "2x2",
                "permute"
            ],
            "usePreview": 0,
            "username": "YitingLiu",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "// Inspired by Stefan Gustavson's work on Worley noise 2x2 \n// I created the snow effect \n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2(vec2 P) {\n\t#define K 0.142857142857 // 1/7\n\t#define K2 0.0714285714285 // K/2\n\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, 7.0)*K+K2;\n\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\tvec4 dx = Pfx + jitter*ox;\n\tvec4 dy = Pfy + jitter*oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t// Sort out the two smallest distances\n#if 0\n\t// Cheat and pick only F1\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn d.xx; // F1 duplicated, F2 not computed\n#else\n\t// Do it right and find both F1 and F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx;\n\td.y = min(d.y, d.z);\n\td.y = min(d.y, d.w);\n\treturn sqrt(d.xy);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = fragCoord.xy/iResolution.y;\n\n\tvec2 F = cellular2x2(st*100.+vec2(iTime/2000.,iTime));\n\tF += cellular2x2(st/1000.);\n\tF /= st+vec2(0.,1.)-abs(sin(iTime*0.5));\n\n\tfloat n =0.5-0.5*F.y;\n\tfragColor = vec4(n*iTime, n*iTime,n*iTime, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}