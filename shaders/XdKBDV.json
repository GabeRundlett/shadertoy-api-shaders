{
    "Shader": {
        "info": {
            "date": "1530578912",
            "description": "Ok, I was bored. Really just a random copy/paste from other shaders here just for the fun of it...\nIf you can follow my code, then you are either insane or a genius, not sure which..\n\n2020/01/23 - Now with crappy volumetrics and bonus extra nuttiness!!!\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XdKBDV",
            "likes": 5,
            "name": "Dancing Hills - With bonus nutty",
            "published": 3,
            "tags": [
                "sun",
                "mountains",
                "aurora",
                "hills"
            ],
            "usePreview": 0,
            "username": "uqone",
            "viewed": 1178
        },
        "renderpass": [
            {
                "code": "\n#define TAU 6.2831853071\n\nvec3 Aurora(in vec2 fragCoord) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float o = texture(iChannel3, uv * 0.25 + vec2(0.0, iTime * 0.025)).r;\n    float d = (texture(iChannel2, uv * 0.25 - vec2(0.0, iTime * 0.02 + o * 0.02)).r * 2.0 - 1.0) * texture(iChannel0, uv * 0.25 - vec2(0.0, iTime * 0.02 + o * 0.02)).r;\n    \n    float v = uv.y + d * 0.1;\n    v = 1.0 - abs(v * 2.0 - 1.0);\n    v = pow(v, 2.0 + sin((iTime * 0.2 + d * 0.25) * TAU) * 0.5);\n    \n    vec3 color = vec3(0.0);\n    \n    float x = (1.0 - uv.x * 0.75);\n    float y = 1.0 - abs(uv.y * 2.0 - 1.0);\n    color += vec3(x * 0.75, y, x) * v;\n    \n    vec2 seed = fragCoord.xy;\n    vec2 r;\n    r.x = fract(sin((seed.x * 12.9898) + (seed.y * 78.2330)) * 43758.5453);\n    r.y = fract(sin((seed.x * 53.7842) + (seed.y * 47.5134)) * 43758.5453);\n\n    float s = mix(r.x, (sin((iTime * 2.5 + 60.0) * r.y) * 0.5 + 0.5) * ((r.y * r.y) * (r.y * r.y)), 0.04); \n    color += pow(s, 30.0) * (1.0 - v);\n    \n    return color;\n}\n\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n    \n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.) * 2.0; // Red / Green \n    \n    float bpow = clamp(texture(iChannel3, vec2(0.0, iTime * 0.025)).r * 3.5, 0.0, 1.0);\n    \n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) * bpow ; // Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n    col += vec3(1.0, .8, .55) * pow( max(dot(rd,sundir),0.), 15. ) * .6; // Sun\n    col += pow(max(dot(rd, sundir),0.), 150.0) *.15;\n    \n    return col;\n}\n\nvec3 sky( in vec2 fragCoord )\n{\n    //screen coords\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//camera ray\n\tvec3 dir = normalize( vec3(v.x, v.y+.5, 1.5) );\n\t\n    //Scene\n    //vec3 col = vec3( checker(dir.xz/dir.y*.5+vec2(0.,-iTime*2.)) ) + skyColor(reflect(dir,vec3(0.,1.,0.)))*.3;\n    vec3 col = skyColor(reflect(dir,vec3(0.,1.,0.)))*.3;\n    col = mix(col, skyColor(dir), exp(-max(-v.y*9.-4.8,0.)) );\n\n    //Vignetting\n\tcol *= .7 + .3*pow(q.x*q.y*(1.-q.x)*(1.-q.y)*16., .1);\n        \n\treturn col;\n}\n\n\n//vec3 sunDir = normalize( vec3(0.15,0.7,0.65) );\nvec3 sunDir = normalize( vec3(-1.0,-0.2,0.0) );\n//vec3 sunDir = normalize( -vec3(1.15,0.7,0.65) );\n\nfloat mapBk( in vec3 pos )\n{\n    float l = length(pos.xz);\n    float f = smoothstep( 1000.0, 1500.0, l );\n    \n    float c = pow(texture( iChannel1, 0.001 + 0.00003*pos.xz ).x, 0.5);\n    float c2 = pow(texture( iChannel1, 0.001 + 0.00003*pos.xy ).x, 0.5);\n    \n    //float h = 200.0*f*texture( iChannel2, 0.001 + 0.00003*pos.xz ).x;\n    float h = 280.0*f*texture( iChannel0, 0.001 + 0.00003*pos.xz ).x * (c + c2); // mountains height\n\n    return pos.y-h;\n}\n\nvec3 calcNormalBk( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapBk( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapBk( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapBk( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapBk( pos + e.xxx ) );\n}\n\nvec3 shadeBk( in vec3 ro, in vec3 rd, in float t )\n{\n    float eps = 0.005;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalBk( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.14,0.14,0.12);\n    mateD = mix( mateD, vec3(0.03,0.03,0.0), smoothstep(0.5,1.95, nor.y ) );\n    \n    //mateD *= 0.3;\n    //mateD *= 0.75; // brightness\n    mateD *= 0.5; // brightness\n    //mateD *= 0.25; // brightness\n    //mateD = pow(mateD * 0.3, vec3(1.1));\n  \n    mateD *= 0.1 + 2.0*texture( iChannel1, pos.xz*0.005 ).x;\n\n    //vec3 mateD = mix(texture( iChannel3, pos.xz*0.005 ).rgb, texture( iChannel1, pos.xz*0.005 ).rgb, nor.y * 0.5 + 0.5) * 0.2;\n    \n   // vec3 hal = normalize( sunDir-rd );\n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    //float sha = calcSoftShadowBk( pos, sunDir, 16.0 );\n    //dif1 *= sha;\n\n    // sun\n    vec3 col = 8.0*vec3(1.8,1.2,0.8)*dif1;\n    // sky\n    col += 4.0*vec3(0.3,0.7,1.0)*clamp(0.2+0.8*nor.y,0.0,1.0);\n    \n    col *= mateD;\n\n    return col;\n}\n\nfloat intersectBk( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n\n    float maxdist = 2000.0;\n    float t = 1000.0;\n\n    for( int i=0; i<30; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = mapBk( p );\n        res = t;\n        if( h<(0.0001*t) ||  t>maxdist ) break;\n        t += h*0.75;\n    }\n\n    if( t>maxdist ) res = -1.0;\n\n    return res;\n}\n\n#define BLOOMRAYS_STEPS\t\t\t64.0\n#define\tBLOOMRAYS_DECAY\t\t\t0.975\n#define\tBLOOMRAYS_WEIGHT\t\t0.23\n#define\tBLOOMRAYS_DENSITY\t\t1.0\n\nvec3 calcScatter(vec3 org, vec3 ro, vec3 rd) \n{\n    vec3\tlens = vec3(0.0, 0.0, 0.0);\n\tvec3\tScreenLightPos = vec3(0.0, 0.125, 0.0);//vec3(0.5);\n\tvec3\tdeltaTexCoord = (rd/*org*/ - ScreenLightPos);\n    vec3 \tpos = rd;//org;\n\n\tdeltaTexCoord *= 1.0 / float(float(BLOOMRAYS_STEPS) * BLOOMRAYS_DENSITY);\n\n\tfloat illuminationDecay = 1.0;\n\n\tfor (float g = 0.0; g < BLOOMRAYS_STEPS; g += 1.0)\n\t{\n\t\tpos -= deltaTexCoord;\n\n        float tm = intersectBk( ro, pos );\n   \t\tfloat grey = clamp(tm, 0.0, 1.0);\n        \n\t\tlens.xyz += (grey * illuminationDecay * BLOOMRAYS_WEIGHT) / (g+1.0);\n\n\t\tilluminationDecay *= BLOOMRAYS_DECAY;\n\n\t\tif (illuminationDecay <= 0.0)\n\t\t\tbreak;\n\t}\n\n\treturn vec3(1.0)-clamp(lens, 0.0, 1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, out float resT, vec2 fragCoord )\n{\n    resT = 10000.0;\n\tvec3 col = vec3(0.0);\n    float smp = texture(iChannel0, fragCoord/iResolution.xy).x;\n    \n    // distant mountains\n   \tfloat tm = intersectBk( ro, rd );\n   \tif( tm>-0.5  )\n   \t{\n       \tcol = shadeBk( ro, rd, tm );\n       \tfloat fa = 1.0-exp(-0.001*tm);\n       \tvec3 pos = ro + rd*tm;\n       \tfa *= exp(-0.001*pos.y);\n       \t//col = mix( col, vec3(0.4,0.5,0.65), fa );\n       \tresT = tm;\n        \n        float off = (fragCoord.y/(iResolution.y/3.0)) * 0.5 + 0.5;\n        off = pow(off, 0.75);\n        vec3 aur = clamp(Aurora(vec2(fragCoord.x, (iResolution.y / 2.0) * off)), 0.0, 1.0) * 0.25;\n        //col = (col + col + (col * aur) / 3.0);\n        vec3 aurPow = pow(col * (aur * 8.0), vec3(2.0));\n        col = clamp((col + col + aurPow) / 3.0, 0.0, 1.0);\n   \t}\n    else\n    {\n     \tvec3 sk = clamp(sky( fragCoord ), 0.0, 1.0);\n   \t\tvec3 aur = clamp(Aurora(fragCoord*(smp*0.5+0.5)), 0.0, 1.0);\n    \tvec3 sk2 = mix(aur, sk, clamp(length(aur), 0.0, 0.75));\n    \tsk = mix(sk * 0.25, clamp(sk2 * 0.333, 0.0, 1.0), clamp(length(sk2), 0.0, 1.0));\n        col = sk;\n    }\n    \n    float pw = clamp(tm * 0.0005 + 0.35, 0.0, 1.0);\n    pw = clamp(pow(pw, 8.0), 0.0, 1.0) * 1.5;\n    \n    vec3 aur2 = clamp(Aurora(fragCoord), 0.0, 1.0);\n    vec3 aur3 = clamp(Aurora(vec2(iResolution*0.5)), 0.0, 1.0) * pw;\n    vec3 vLight = calcScatter(ro + rd*tm, ro, rd) * (aur2 + aur3);\n    //return vLight;\n    return col + vLight;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\n    // camera\n    float an = 0.0;// - 1.25- 1.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3(5.7*sin(an),1.6,5.7*cos(an));\n    //vec3 ta = vec3(0.0,1.6,0.0);\n    vec3 ta = vec3(0.0,2.65,0.0);\n    \n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-5.5) );\n    \n    // render\n    float t;\n    vec3 col = clamp(render( ro, rd, t, fragCoord), 0.0, 1.0);\n\n    fragColor = vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}