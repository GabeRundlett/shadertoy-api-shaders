{
    "Shader": {
        "info": {
            "date": "1580029688",
            "description": "straight up fork of thorn0906 and iq\nhttps://www.shadertoy.com/view/3d2XRd",
            "flags": 0,
            "hasliked": 0,
            "id": "wtG3W3",
            "likes": 4,
            "name": "Voxel Mandelbulb  With Normals",
            "published": 3,
            "tags": [
                "octree"
            ],
            "usePreview": 0,
            "username": "Chrisy",
            "viewed": 429
        },
        "renderpass": [
            {
                "code": "// Sample the envmap in multiple places and pick the highest valued one. Not really physically accurate if not 1\n#define SKY_SAMPLES 1\n// How many directions to sample the lighting & BRDF at\n// Setting it to 0 disables the envmap lighting and switches to a constant light\n#define MAT_SAMPLES 0\n\n// Set this to 1 for a liquid-like animation\n#define ANIMATE 0\n// Try turning that on and this off to see the animation more clearly\n#define CAMERA_MOVEMENT 0\n\n// Enable this to see the exact raymarched model\n#define MARCH 0\n\n// The size of the scene. Don't change unless you change the distance function\nconst float root_size = 3.;\n// The resolution, in octree levels. Feel free to play around with this one\nconst int levels = 10;\n\n// The maximum iterations for voxel traversal. Increase if you see raymarching-like\n//\thole artifacts at edges, decrease if it's too slow\nconst int MAX_ITER = 1024;\n// Note, though, that the fake AO might look weird if you change it much\n\n// These are parameters for the Mandelbulb, change if you want. Higher is usually slower\nconst float Power = 4.;\nconst float Bailout = 1.5;\nconst int Iterations = 7;\n\n#define STACKLESS\n\n// -----------------------------------------------------------------------------------------\n\nconst float  offset =pow(root_size,float(levels));\n\nvec3 snap (vec3 pos)\n{\n    return round(pos*offset)/offset;\n}\n\n// This is from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n// \tbecause it had code that I could just copy and paste\nfloat dist(vec3 pos) {\n    // This function takes ~all of the rendering time, the trigonometry is super expensive\n    // So if there are any faster approximations, they should definitely be used\n\tvec3 z = snap(pos);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    for (int i = 0; i < Iterations; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n        \n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n        #if ANIMATE\n        theta += iTime*0.5;\n        #endif\n\t\tfloat phi = atan(z.y,z.x);\n        #if ANIMATE\n        phi += iTime*0.5;\n        #endif\n\t\tdr = pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tpos = snap(pos);\n    vec2 e = vec2(1.0,-1.0)*(1.0/offset);\n    return normalize( e.xyy*dist( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*dist( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*dist( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*dist( pos + e.xxx ) );\n   \n}\n\n// -----------------------------------------------------------------------------------------\n\n\n#define PI 3.1415926535\nconst float IPI = 1./PI;\nconst float R2PI = sqrt(2./PI);\n\nstruct Material {\n    vec3 base_color;\n    float roughness;\n};\n\nfloat sqr(float x) { return x*x; }\n#define saturate(x) clamp(x,0.,1.)\n\nvec2 isect(in vec3 pos, in float size, in vec3 ro, in vec3 rd, out vec3 tmid, out vec3 tmax) {\n    vec3 mn = pos - 0.5 * size;\n    vec3 mx = mn + size;\n    vec3 t1 = (mn-ro) / rd;\n    vec3 t2 = (mx-ro) / rd;\n    vec3 tmin = min(t1, t2);\n    tmax = max(t1, t2);\n    tmid = (pos-ro)/rd; // tmax;\n    return vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\nstruct ST {\n    vec3 pos;\n\tint scale; // size = root_size * exp2(float(-scale));\n    vec3 idx;\n    float h;\n} stack[levels];\n\nint stack_ptr = 0; // Next open index\nvoid stack_reset() { stack_ptr = 0; }\nvoid stack_push(in ST s) { stack[stack_ptr++] = s; }\nST stack_pop() { return stack[--stack_ptr]; }\nbool stack_empty() { return stack_ptr == 0; }\n\n\n// -----------------------------------------------------------------------------------------\n\n#if MARCH\n\n// Simple ray marcher for visualizing the exact distance function\nbool trace(in vec3 ro, in vec3 rd, out vec2 t, out vec3 pos, out int iter, out float size) {\n\tsize = 0.;\n    \n    t = vec2(0.);\n    pos = ro;\n    iter = MAX_ITER;\n    while (iter --> 0 && t.x < root_size) {\n        float d = dist(pos);\n        if (d < 0.01)\n            return true;\n        t += d;\n        pos += rd*d;\n    }\n    return false;\n}\n\n#else\n\n// The distance to the corner of the voxel; thanks, abje!\n// This removes artifacts (present when d_corner = 0.5);\nconst float d_corner = sqrt(0.75);\n\n// The actual ray tracer, based on https://research.nvidia.com/publication/efficient-sparse-voxel-octrees\nbool trace(in vec3 ro, in vec3 rd, out vec2 t, out vec3 pos, out int iter, out float size) {\n    stack_reset();\n    \n    //-- INITIALIZE --//\n    \n    int scale = 0;\n    size = root_size;\n    vec3 root_pos = vec3(0);\n    pos = root_pos;\n    vec3 tmid;\n    vec3 tmax;\n    bool can_push = true;\n    float d;\n    t = isect(pos, size, ro, rd, tmid, tmax);\n    float h = t.y;\n    \n    // Initial push, sort of\n    // If the minimum is before the middle in this axis, we need to go to the first one (-rd)\n    vec3 idx = mix(-sign(rd), sign(rd), lessThanEqual(tmid, vec3(t.x)));\n    scale = 1;\n    size *= 0.5;\n    pos += 0.5 * size * idx;\n    \n    iter = MAX_ITER;\n    while (iter --> 0) { // `(iter--) > 0`; equivalent to `for(int i=128;i>0;i--)`\n        t = isect(pos, size, ro, rd, tmid, tmax);\n        \n        d = dist(pos);\n        \n        if (d < size*d_corner) { // Voxel exists\n            if (scale >= levels)// || d < -size)\n                return true; // Filled leaf\n            \n            if (can_push) {\n                //-- PUSH --//\n                \n                #ifndef STACKLESS\n                if (t.y < h) // Don't add this if we would leave the parent voxel as well\n                    stack_push(ST(pos, scale, idx, h));\n                #endif\n                h = t.y;\n                scale++;\n                size *= 0.5;\n                idx = mix(-sign(rd), sign(rd), lessThanEqual(tmid, vec3(t.x)));\n                pos += 0.5 * size * idx;\n                continue;\n            }\n        }\n        \n        //-- ADVANCE --//\n        \n        // Advance for every direction where we're hitting the middle (tmax = tmid)\n        vec3 old = idx;\n        idx = mix(idx, sign(rd), equal(tmax, vec3(t.y)));\n        pos += mix(vec3(0.), sign(rd), notEqual(old, idx)) * size;\n        \n        // If idx hasn't changed, we're at the last child in this voxel\n        if (idx == old) {\n            //-- POP --//\n            #ifdef STACKLESS\n            \n            vec3 target = pos;\n            size = root_size;\n            pos = root_pos;\n            scale = 0;\n\n            vec3 tmid, tmax;\n            t = isect(pos, size, ro, rd, tmid, tmax);\n            if (t.y <= h)\n                return false;\n\n            float nh = t.y;\n            for (int j = 0; j < 100; j++) { // J is there just in case\n                scale++;\n                size *= 0.5;\n                idx = sign(target-pos);\n                pos += idx * size * 0.5;\n                t = isect(pos, size, ro, rd, tmid, tmax);\n\n                // We have more nodes to traverse within this one\n                if (t.y > h) {\n                    nh = t.y;\n                } else break;\n            }\n            h = nh;\n            \n            #else\n            if (stack_empty() || scale == 0) return false; // We've investigated every voxel on the ray\n            \n            ST s = stack_pop();\n            pos = s.pos;\n            scale = s.scale;\n            size = root_size * exp2(float(-scale));\n\t\t\tidx = s.idx;\n            h = s.h;\n            #endif\n            \n            can_push = false; // No push-pop inf loops\n        } else can_push = true; // We moved, we're good\n    }\n    \n    return false;\n}\n#endif\n\n// -----------------------------------------------------------------------------------------\n\n\n// We want to shade w/ the mipmap\nvec3 sky(vec3 dir) {\n    return texture(iChannel1, dir).xyz;\n}\n\n// And see the sharp version\nvec3 sky_cam(vec3 dir) {\n    return texture(iChannel0, dir).xyz;\n}\n\n// https://shaderjvo.blogspot.com/2011/08/van-ouwerkerks-rewrite-of-oren-nayar.html\nvec3 oren_nayar(vec3 from, vec3 to, vec3 normal, Material mat) {\n    // Roughness, A and B\n    float roughness = mat.roughness;\n    float roughness2 = roughness * roughness;\n    vec2 oren_nayar_fraction = roughness2 / (roughness2 + vec2(0.33, 0.09));\n    vec2 oren_nayar = vec2(1, 0) + vec2(-0.5, 0.45) * oren_nayar_fraction;\n    // Theta and phi\n    vec2 cos_theta = saturate(vec2(dot(normal, from), dot(normal, to)));\n    vec2 cos_theta2 = cos_theta * cos_theta;\n    float sin_theta = sqrt((1.-cos_theta2.x) * (1.-cos_theta2.y));\n    vec3 light_plane = normalize(from - cos_theta.x * normal);\n    vec3 view_plane = normalize(to - cos_theta.y * normal);\n    float cos_phi = saturate(dot(light_plane, view_plane));\n    // Composition\n    float diffuse_oren_nayar = cos_phi * sin_theta / max(cos_theta.x, cos_theta.y);\n    float diffuse = cos_theta.x * (oren_nayar.x + oren_nayar.y * diffuse_oren_nayar);\n    \n    return mat.base_color * diffuse;\n}\n\n\n// These bits from https://simonstechblog.blogspot.com/2011/12/microfacet-brdf.html\n\nfloat schlick_g1(vec3 v, vec3 n, float k) {\n    float ndotv = dot(n, v);\n    return ndotv / (ndotv * (1. - k) + k);\n}\n\nvec3 brdf(vec3 from, vec3 to, vec3 n, Material mat, float ao) {\n    float ior = 1.5;\n    \n    // Half vector\n    vec3 h = normalize(from + to);\n    \n    // Schlick fresnel\n    float f0 = (1.-ior)/(1.+ior);\n    f0 *= f0;\n    float fresnel = f0 + (1.-f0)*pow(1.-dot(from, h), 5.);\n    \n    // Beckmann microfacet distribution\n    float m2 = sqr(mat.roughness);\n    float nh2 = sqr(saturate(dot(n,h)));\n    float dist = (exp( (nh2 - 1.)\n    \t/ (m2 * nh2)\n    \t))\n        / (PI * m2 * nh2*nh2);\n    \n    // Smith's shadowing function with Schlick G1\n    float k = mat.roughness * R2PI;\n    float geometry = schlick_g1(from, n, k) * schlick_g1(to, n, k);\n    \n    return saturate((fresnel*geometry*dist)/(4.*dot(n, from)*dot(n, to))\n        + ao*(1.-f0)*oren_nayar(from, to, n, mat));\n}\n\n\n// -----------------------------------------------------------------------------------------\n\n\n// By Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec2 t, int iter, vec3 pos) {\n\n    // This pretends the Mandelbulb is actually a sphere, but it looks okay w/ AO.\n    vec3 n = normalize(pos);\n     n = calcNormal(pos);\n    // And this isn't accurate even for a sphere, but it ensures the edges are visible.\n    n = faceforward(n,-rd,-n);\n    \n\n   \n    \n    Material mat = Material(vec3(1.,.9,.7), 0.9);\n\n    #if MAT_SAMPLES\n    vec3 acc = vec3(0.);\n    int j;\n    for (j = 0; j < MAT_SAMPLES; j++) {\n        vec3 lightDir;\n        vec3 lightCol = vec3(0.);\n        for (int i = 0; i < SKY_SAMPLES; i++) {\n            vec3 d = hash33(0.2*pos+0.5*n+float(i+j*SKY_SAMPLES));\n            d = normalize(d);\n            vec3 c = sky(d);\n            if (length(c) > length(lightCol)) {\n                lightCol = c;\n                lightDir = d;\n            }\n        }\n        acc +=\n            2.*pow(lightCol, vec3(2.2)) * brdf(lightDir, -rd, n, mat, (float(iter)/float(MAX_ITER)));\n    }\n    return acc / float(j);\n\t#else\n    vec3 lightDir = reflect(rd,n);\n    return 2.*brdf(lightDir, -rd, n, mat, (float(iter)/float(MAX_ITER)));\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    #if CAMERA_MOVEMENT\n    float r = iTime;\n    #else\n    float r = 12.0*iMouse.x/iResolution.x;\n    #endif\n    vec3 ro = vec3(2.0*sin(0.5*r),1.5-iMouse.y/iResolution.y,1.6*cos(0.5*r));\n    vec3 lookAt = vec3(0.0);\n    vec3 cameraDir = normalize(lookAt-ro);\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 left = normalize(cross(cameraDir, up)); // Might be right\n    vec3 rd = cameraDir;\n    float FOV = 0.5; // Not actual FOV, just a multiplier\n    rd += FOV * up * uv.y;\n    rd += FOV * left * uv.x;\n    // `rd` is now a point on the film plane, so turn it back to a direction\n    rd = normalize(rd);\n    \n    vec2 t;\n    vec3 pos;\n    float size;\n    int iter;\n    \n    vec3 col = trace(ro, rd, t, pos, iter, size) ? shade(ro, rd, t, iter, pos) : sky_cam(rd);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}