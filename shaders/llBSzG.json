{
    "Shader": {
        "info": {
            "date": "1444526665",
            "description": "Doing your own implementation of a mandelbrot shader is something I consider to be like a \"Hello, world!\" of shader-programming :) Thus I had to do it. It does 100 iterations per fragment and a very simple 4x4-grid super-sampling.",
            "flags": 0,
            "hasliked": 0,
            "id": "llBSzG",
            "likes": 3,
            "name": "basic mandelbrot set",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot",
                "zoom",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1278
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// mandelbrot-set fragment-shader with 4x4-grid super-sampling, which steps\n// through z = z^2 + c, z = z^3 + c and z = z^4 + c switching every two seconds\n//\n// Copyright 2015 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// 0 disbled, 1 enabled\n#define MSAA 0\n\nconst float PI = 3.14159265358979323846;\nconst vec4 red = vec4 (1., .0, .0, 1.);\nconst vec4 green = vec4 (.0, 1., .0, 1.);\nconst vec4 blue = vec4 (.0, .0, 1., 1.);\nconst vec4 white = vec4 (1.);\nconst vec4 orange = vec4 (1., .4, .125, 1.);\nconst vec4 black = vec4 (.0, .0, .0, 1.);\nconst vec4 cyan = vec4 (.0, 1., 1., 1.);\nconst vec4 magenta = vec4 (1., .0, 1., 1.);\nconst vec4 yellow = vec4 (1., 1., .0, 1.);\n\nfloat deg2rad (in float degree)\n{\n    return degree * PI / 180.;\n}\n\nmat2 rot2dZ (in float angle)\n{\n    float rad = deg2rad (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    return mat2 ( c, s, -s, c);\n}\n\nvec4 gradient (float v) {\n    float steps = 7.;\n    float step = 1. / steps;\n    vec4 col = black;\n\n    if (v >= .0 && v < step) {\n        col = mix (yellow, orange, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (orange, red, (v - step) * steps);\n    } else if (v >= 2.0 * step && v < 3.0 * step) {\n        col = mix (red, magenta, (v - 2.0 * step) * steps);\n    } else if (v >= 3.0 * step && v < 4.0 * step) {\n        col = mix (magenta, cyan, (v - 3.0 * step) * steps);\n    } else if (v >= 4.0 * step && v < 5.0 * step) {\n        col = mix (cyan, blue, (v - 4.0 * step) * steps);\n    } else if (v >= 5.0 * step && v < 6.0 * step) {\n        col = mix (blue, green, (v - 5.0 * step) * steps);\n    }\n\n    return col;\n}\n\nvec4 calc (vec2 c, int type)\n{\n    vec4 col = white;\n    vec2 z = vec2 (.0);\n    float lengthLimit = 5.;\n    float iter = .0;\n    const float maxIter = 100.;\n\n    for (float i = 0.; i < maxIter; i += 1.) {\n        // z = z^2 + c\n        if (type == 0) {\n            z = mat2 (z, -z.y, z.x) * z + c;\n        }\n\n        // z = z^3 + c\n        if (type == 1) {\n            float zr = z.x * z.x - z.y * z.y;\n            float zi = z.y * z.x + z.x * z.y;\n            z = vec2 (zr * z.x - zi * z.y,  zr * z.y + z.x * zi) + c;\n        }\n\n        // z = z^4 + c\n        if (type == 2) {\n            float zr = z.x * z.x - z.y * z.y;\n            float zi = z.y * z.x + z.x * z.y;\n            float zzr = zr * z.x - zi * z.y;\n            float zzi = zr * z.y + z.x * zi;\n            z = vec2 (zzr * z.x - zzi * z.y,  zzr * z.y + z.x * zzi) + c;\n        }\n        \n        if (length (z) > lengthLimit && iter == .0) {\n            iter = i;\n        }\n    }\n\n    return length (z) <= lengthLimit ? vec4 (0) : gradient (iter / maxIter);\n}\n\nvec4 mandel (vec2 c, vec2 size)\n{\n    vec2 msaa[16];\n    msaa[0]  = vec2 (.125, .125);\n    msaa[1]  = vec2 (.125, .375);\n    msaa[2]  = vec2 (.125, .625);\n    msaa[3]  = vec2 (.125, .875);\n    msaa[4]  = vec2 (.375, .125);\n    msaa[5]  = vec2 (.375, .375);\n    msaa[6]  = vec2 (.375, .625);\n    msaa[7]  = vec2 (.375, .875);\n    msaa[8]  = vec2 (.625, .125);\n    msaa[9]  = vec2 (.625, .375);\n    msaa[10] = vec2 (.625, .625);\n    msaa[11] = vec2 (.625, .875);\n    msaa[12] = vec2 (.875, .125);\n    msaa[13] = vec2 (.875, .375);\n    msaa[14] = vec2 (.875, .625);\n    msaa[15] = vec2 (.875, .875);\n\n    vec4 result = vec4 (.0);\n\n    #if MSAA\n    for (int i = 0; i < 16; ++i) {\n        result += calc (c + msaa[i] * size, int (mod (.5 * iTime, 3.)));\n    }\n\tresult /= 16.;\n    #else\n        result = calc (c, int (mod (.5 * iTime, 3.)));\n    #endif\n\n\treturn result;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p)\n{\n    vec2 res = iResolution.xy;\n    float t = iTime;\n    float s = 1.75 + sin (.5 * t);\n    p = p / res * vec2 (iResolution.x / iResolution.y, 1.);\n    p += vec2 (-1., -.5);\n    mat2 r = rot2dZ (90. * cos (.5 * t));\n    fragColor = mandel (r * s * p, s/res);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}