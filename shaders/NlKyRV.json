{
    "Shader": {
        "info": {
            "date": "1661890616",
            "description": "Generating a basic animation to use as input for stable-diffusion. I'll post the results below when they're rendered.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlKyRV",
            "likes": 9,
            "name": "rotating rainbow squares 2",
            "published": 3,
            "tags": [
                "square",
                "rainbow",
                "rotating"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "// Fork of \"rotating rainbow square\" by ufffd. https://shadertoy.com/view/ftVyzG\n// 2022-08-30 06:10:17\n\nfloat drawSquare(in vec2 uv, in vec2 p, in float size) {\n    // p = rotate(p, iTime);\n    // uv = rotate(uv, iTime*2.);\n    return SS(-0.02, (abs(uv.x-p.x) + abs(uv.y-p.y)) / size);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = ( 2.*fragCoord - R ) / R.y;          // [-1,1] vertically\n    \n    vec3 col = vec3(0.);\n    \n    float piTime = iTime*PI;\n    float spinTime = piTime / 6.;\n    float capTime = iTime;\n    float colorTime = iTime / 6.;\n    \n    for (int i = 0; i<4; i++) {\n        float fi = float(i);\n        vec2 nuv = rotate(uv,-piTime/12.);\n        vec2 suv = rotate(uv,spinTime); // +fi*PI/8.\n        suv = rotate(suv,sin(fi*PI/8.)); // +fi*PI/8.\n        suv *= 1.+sin(piTime+fi*PI/6.)*0.1;\n        suv *= 1.+fi*0.1;\n\n        float sq = max(abs(suv.x), abs(suv.y));\n        sq = SS(0.5,abs(sq-.15));\n        sq = cubicPulse(0.5,0.05,sq)*5.;\n        col += sq*spectral_zucconi6(fract(colorTime+fi/20.)*300.+400.);\n        \n        suv *= 0.9+noise(vec3(nuv*10.,iTime*2.))*0.2;\n        \n        sq = max(abs(suv.x), abs(suv.y));\n        sq = SS(0.5,abs(sq-.15));\n        sq = cubicPulse(0.5,0.05,sq)*5.;\n        col += 0.5*sq*spectral_zucconi6(fract(colorTime+fi/20.)*300.+400.);\n        \n        suv *= 0.9+noise(vec3(nuv*30.,iTime*3.))*0.2;\n        \n        sq = max(abs(suv.x), abs(suv.y));\n        sq = SS(0.5,abs(sq-.15));\n        sq = cubicPulse(0.5,0.05,sq)*5.;\n        col += 0.5*sq*spectral_zucconi6(fract(colorTime+fi/20.)*300.+400.);\n    }\n    \n    vec2 pt = vec2(0.,1.);\n    vec2 pb = vec2(0.,-1.);\n    vec2 pl = vec2(-1.,0.);\n    vec2 pr = vec2(1.,0.);\n    \n    // 8 step cap\n    float t3 = fract((5./6.)*capTime*0.4)*3.; // 0-3\n    float t4 = fract((5./6.)*capTime*0.3+1.)*4.; // 0-4\n    \n    vec2 p1,p2;\n    \n    if (t3 < 1.) {\n        p1 = mix(pb,pt,fract(t3));\n    } else if (t3 < 2.) {\n        p1 = mix(pt,pr,fract(t3));\n    } else {\n        p1 = mix(pr,pb,fract(t3));\n    }\n    \n    if (t4 < 1.) {\n        p2 = mix(pb,pl,fract(t4));\n    } else if (t4 < 2.) {\n        p2 = mix(pl,pt,fract(t4));\n    } else if (t4 < 3.) {\n        p2 = mix(pt,pr,fract(t4));\n    } else {\n        p2 = mix(pr,pb,fract(t4));\n    }\n    \n    p1 *= 0.5;\n    p2 *= 0.5;\n    \n    float d1 = drawSquare(uv,p1,0.25);\n    col += d1*spectral_zucconi6(fract(colorTime)*300.+400.);\n    \n    float d2 = drawSquare(uv,p2,0.25);\n    col += d2*spectral_zucconi6(fract(colorTime+PI)*300.+400.);\n\n    // tonemap & output\n    col = filmicToneMapping(col);    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SS(a,b) smoothstep(0.5-a,0.5+a,b)\n#define PI 3.141592653589793\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat saturate (float x){\n    return min(1.0, max(0.0,x));\n}\n\nvec3 saturate (vec3 x){\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n// --- MATLAB Jet Colour Scheme ----------------------------------------\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}