{
    "Shader": {
        "info": {
            "date": "1628764197",
            "description": "This code forks from this: https://www.shadertoy.com/view/NlSSRV\n\nRough explanation: https://medium.com/@snoopethduckduck/procedural-sword-generation-69b8b7bc197\n\nInteractive version: https://snoopethduckduck.itch.io/sword-maker",
            "flags": 32,
            "hasliked": 0,
            "id": "slBXWc",
            "likes": 114,
            "name": "Procedural Swords",
            "published": 3,
            "tags": [
                "procedural",
                "generative",
                "sword",
                "pixelart",
                "cool",
                "weapon",
                "dawnbringer"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 3281
        },
        "renderpass": [
            {
                "code": "\n// gem interior colors\nvec3 darkMap( int index,  float v ) {\n    vec3[5] arr;\n    \n    if (index == 0)      // blue \n        arr = vec3[] ( vec3(95,205,228), vec3(99,155,255), vec3(91,110,225), vec3(48,96,130),vec3(63,63,116));\n    else if (index == 1) // red \n        arr = vec3[] ( vec3(238,195,154),vec3(215,123,186),vec3(217,87,99),  vec3(172,50,50),vec3(69,40,60));\n    else if (index == 2) // green \n        arr = vec3[] ( vec3(153,229,80), vec3(106,190,48), vec3(55,148,110), vec3(48,96,130),vec3(63,63,116));\n    else if (index == 3) // brown\n        arr = vec3[] ( vec3(217,160,102),vec3(180,123,80), vec3(143,86.,59), vec3(102,57,49),vec3(69,40,60));\n    else if (index == 4) // grey\n        arr = vec3[] ( vec3(155,173,183),vec3(132,126,135),vec3(105,106,106),vec3(89,86,82), vec3(50,60,57));\n    else if (index == 5) // pink\n        arr = vec3[] ( vec3(215,123,186),vec3(217,87,99),  vec3(118,66,138), vec3(63,63,116),vec3(50,60,57));\n   \n   return arr[ min(5, int(v)) ] / 255.;\n}\n\n// gem interior outline colors\nvec3 lightMap( int index, float v ) {\n    vec3[5] arr;\n    \n    if (index == 0)      // blue\n        arr = vec3[] ( vec3(255),vec3(203,219,252),vec3(95,205,228), vec3(99,155,255), vec3(91,110,225));\n    else if (index == 1) // gold \n        arr = vec3[] ( vec3(255),vec3(251,242,54), vec3(255,182,45), vec3(223,113,38), vec3(172,50,50));\n    else if (index == 2) // green\n        arr = vec3[] ( vec3(255),vec3(203,219,252),vec3(153,229,80), vec3(106,190,48), vec3(55,148,110));\n    else if (index == 3) // brown \n        arr = vec3[] ( vec3(255),vec3(238,195,154),vec3(217,160,102),vec3(180,123,80), vec3(143,86,59));\n    else if (index == 4) // grey\n        arr = vec3[] ( vec3(255),vec3(203,219,252),vec3(155,173,183),vec3(132,126,135),vec3(105,106,106));\n    else if (index == 5) // pink\n        arr = vec3[] ( vec3(255),vec3(238,195,154),vec3(215,123,186),vec3(217,87,99),  vec3(118,66,138));\n    \n    return arr[ min(5, int(v)) ] / 255.;\n}\n\n// handle colors\nvec3 handleMap ( int index, float v) {\n    vec3[6] arr;\n    if (index == 0)      // blue\n        arr = vec3[] ( vec3(63,63,116),vec3(48,96,130),vec3(91,110,225),vec3(95,205,228),vec3(203,219,252),vec3(255));\n    else if (index == 1) // gold\n        arr = vec3[] ( vec3(69,40,60),vec3(172,50,50),vec3(223,113,38),vec3(255,182,45),vec3(251,242,54),vec3(255));\n    else if (index == 2) // green\n        arr = vec3[] ( vec3(63,63,116),vec3(48,96,130),vec3(55,148,110),vec3(106,190,48),vec3(153,229,80),vec3(203,219,252));\n    else if (index == 3) // brown\n        arr = vec3[] ( vec3(69,40,60),vec3(102,57,49),vec3(143,86,59),vec3(180,123,80),vec3(217,160,102),vec3(238,195,154));\n    else if (index == 4) // grey\n        arr = vec3[] ( vec3(50,60,57),vec3(118,66,138),vec3(105,106,106),vec3(155,173,183),vec3(203,219,252),vec3(255));\n    else if (index == 5) // pink\n        arr = vec3[] ( vec3(50,60,57),vec3(63,63,116),vec3(118,66,138),vec3(217,87,99),vec3(215,123,186),vec3(238,195,154));\n   return arr[ min(5, int(5. * v)) ] / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setDimGem(iFrame);\n    setDimHandle(iFrame);\n    \n    float h = dimGem.y + 0.5 * dimHandle.y;\n        \n    float sf = 1.2 * (2. * dimGem.y + dimHandle.y) / iResolution.y; //2.\n    vec2 osc = vec2(0., sf * (24. * cos(iTime) + 8.));\n    \n    // gem coord\n    vec2 coord = ceil(sf * fragCoord + osc + vec2(dimGem.x, -dimHandle.y)\n               - sf * 0.5 * iResolution.xy\n               + vec2(0.,h)  );\n\n    // handle coord\n    vec2 coord2 = ceil( sf * fragCoord + osc + 0.5 * vec2(dimHandle.x, -4.)\n                - sf * 0.5 * iResolution.xy       \n                + vec2(0.,h) );\n                \n    // gem color\n    vec3 col = texelFetch(iChannel0, ivec2(coord), 0).rgb;\n    // handle shape\n    float B = texelFetch(iChannel1, ivec2(coord2), 0).x;\n    // handle noise\n    float C = texelFetch(iChannel2, ivec2(coord2), 0).x;\n    \n    // index for handle, gem interior outline\n    int index = randIndex(iFrame, 5. + 1., 0.);\n    \n    // index for gem interior\n    int index2 = randIndex(iFrame, 5. + 1., floor(iDate[3] / float(reset)) - 100.);\n   \n    // color gem\n    if ( col.r == 1. )\n        col = vec3(34,32,52) / 255.;\n    else if ( col.r == 0. )\n        col = vec3(0.);\n    else if (col.g > 0.)\n        col = lightMap(index, col.g - 1.); \n    else if (col.b > 0.)\n        col = darkMap(index2, col.b - 1.); \n        \n    vec3 col2;\n    float t = 100. * C;\n    \n    // color handle\n    if (B == 1.) {\n    \n        // cos with high frequency t generates linework\n        float v = 0.5 * (1. - cos(pi * t));  \n    \n        // shade top lighter, bottom darker\n        v = min(1., v * (0.6 + 0.9 * coord2.y / dimHandle.y));\n\n        // shade left side darker\n        if (coord2.x <= 0.5 * dimHandle.x - 1.)\n            v = max(0., v - 2. / 6.);\n        \n        col2 = handleMap(index, v);\n    }\n    \n    // background\n    else if (B == 0.) {\n        vec2 uv = fragCoord / iResolution.y; \n        uv = mod(1.5 * uv + vec2(0.05 * iTime), 1.);\n        if ((uv.x > 0.5 && uv.y > 0.5) || (uv.x < 0.5 && uv.y < 0.5))\n            col2 = vec3(143,86,59) / 255.;\n        else\n            col2 = vec3(102,57,49) / 255.;\n    } \n    \n    // outline of handle\n    else\n        col2 = vec3(34, 32, 52) / 255.;\n        \n    if (col.x == 0.)\n        fragColor = vec4(col2,1.);\n    else \n        fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// top variants for the gem\nfloat hexTop (int index, vec2 uv) {\n    if (index == 0) // pointy\n        return abs(uv.x) + abs(uv.y);\n    if (index == 1) // right diag / \n        return abs(uv.x - (dimGem.x - 2.)) + abs(uv.y);\n    if (index == 2) // left diag\n        return abs(uv.x + (dimGem.x - 2.)) + abs(uv.y);\n    if (index == 3) // square\n        return uv.x; \n    if (index == 4) // square -> diag\n        return uv.x + uv.y;\n    if (index == 5) // diag -> square\n        return -uv.x + uv.y;       \n}\n\n\nfloat hexagon (int index, vec2 uv, vec2 dim) {\n    // rectangle shape\n    float d = max(dim.y/dim.x * abs(uv.x), abs(uv.y));\n\n    // (modified) diamond shape\n    float d2 = uv.y > 0. ? hexTop(index, uv) \n                         : abs(uv.x) + abs(uv.y);\n\n    // intersect both shapes\n    return step(d, dim.y) * step(d2, dim.y);\n}\n\n// forms ---_-_ shape to color with\nfloat stepHole (float v, float h) {\n    return step(h,v ) + (step(h, v + 2.) - step(h, v + 1.));\n}\n\n// choose length of each ---_-_ segment, depending on gem height \nfloat chooseN(vec2 dimGem) {\n    float h = 2. * dimGem.y;\n    if (h <= 14.)\n        return 2.;\n    if (h <= 21.)\n        return 3.;\n    if (h <= 28.)\n        return 4.;\n    return 5.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    // I think it goes off last value for some reason (maybe update order)\n    vec2 dimgem = setDimGem(iFrame); \n    \n    vec2 uv = coord - dimGem;\n    \n    int index = randIndex(iFrame, 5. + 1., -31.5);\n    \n    // split channels by parts\n    // r: outline, b: interior outline, g: interior\n    vec3 col = vec3(hexagon(index, uv, dimGem) - 0.5 * hexagon(index, uv, dimGem - 1.),\n                    hexagon(index, uv, dimGem - 1.) -  hexagon(index, uv, dimGem - 2.),\n                    hexagon(index, uv, dimGem - 2.));\n    \n    // remove bottom outline so handle and gem don't overlap\n    if (coord.y < 1.)\n        col.r = 0.;\n    \n    // apply shades to interior outline + interior\n    // ( repeatedly run stepHole to get ---_-_ pattern, overlay higher indexes\n    //   min index is 1., and -step(dim.x, fragCoord.x) makes left side darker )\n    vec2 shade = vec2(1.);\n    float n = chooseN(dimGem);\n    for (float i = 1.; i < n; i++) { \n        shade = max(shade, \n                    1. + (n-i) * stepHole(ceil(2. * dimGem.y / n) * i, coord.y)\n                       - step(dimGem.x, coord.x));                  \n    }\n    \n    // make the top bright (white outline wraps around to the left)\n    if (coord.y > 2. * dimGem.y - 2.)\n        shade = vec2(1.);\n        \n    // split the top interior to two shades (left and right)\n    else if (coord.y > 2. * dimGem.y - 4.)\n        shade = vec2(2.- step(dimGem.x, coord.x),1.);\n    \n    col.bg *= shade;\n\n    fragColor = vec4(col, 1.);   \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// change randStart to generate new \"seed\"\nconst float randStart = 123.;\n\n// number of frames each sprite lasts for\nconst int reset = 120;\n\nconst float pi = 3.14519;\n\n\n// ( resetting dims is buggy - seems fine if new value < old value though,\n//   arbitrarily large 500 works fine )\n\n// half gem dimensions \nvec2 dimGem = vec2(500);\n\n// handle dimensions (not half)\nvec2 dimHandle = vec2(500);\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n// get an index for arrays (not optimal at all)\nint randIndex ( int frame, float maxIndex, float offset ) {\n    return int(maxIndex * hash1(randStart + offset +  floor(float(frame) / float(reset))));\n}\n\n// if you want custom width/height, change the values below\nvec2 setDimGem(int frame) {    \n    float gen = randStart + floor(float(frame) / float(reset));\n    float width = round(3. + 3. * hash1(gen));\n    float height = max(2. * width, round(40. * hash1(100. + gen)));\n    return dimGem = vec2(width, height);\n}\n\nvec2 setDimHandle(int frame) {    \n    float gen = randStart + floor(float(frame) / float(reset));\n    float width = 2. * round(10. + 8. * hash1(50. + gen));\n    float height = 2. * round(14. + 12. * hash1(150. + gen));\n    return dimHandle = vec2(width, height);\n}\n\n/*\n\nRough explanation of how this works:\n\nBuffer A: \nGenerates hexagon gem in bottom left of screen.\nWidth, height, top shape and shading are chosen here. (but not color)\n\nBuffer B:\nGenerates shape of handle in bottom left of screen.\nInitial state with noise is generated, then various cellular automata are run on it\nto get an appropriate shape.\nWidth, height of handle are chosen here (sort of).\n\nBuffer C:\nGenerates mirrored noise to color the handle with.\n\nImage:\nTransforms the gem and handle so they are together.\nPicks color schemes for the gem outline, gem interior, and handle.\nOverlays noise from buffer C onto the handle shape.\nDraws a background.\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float random ( vec2 st ) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat Cell( in vec2 p )\n{\n    if (p.x <= dimHandle.x && p.y <= dimHandle.y)\n        return texelFetch(iChannel0, ivec2(p), 0 ).x;    \n    return 0.;\n}\n\nfloat CA ( vec2 px, float e ) {\n    float k = Cell(px+vec2(-1,-1)) + 1.5 * Cell(px+vec2(0,-1)) + Cell(px+vec2(1,-1))\n      + 1.5 * Cell(px+vec2(-1, 0))                       + 1.5 * Cell(px+vec2(1, 0))\n            + Cell(px+vec2(-1, 1)) + 1.5 * Cell(px+vec2(0, 1)) + Cell(px+vec2(1, 1));\n    \n    if ( e == 1. && k < 4.5 )\n        e = 0.;\n    else if ( e == 0. && k > 6. )\n        e = 1.;      \n        \n    return e;\n}\n\nfloat sumNeighbours ( vec2 px ) {\n    return Cell(px+vec2(0, -1)) + Cell(px+vec2(-1, 0)) +\n           Cell(px+vec2(0, 1))  + Cell(px+vec2(1, 0));\n}\n\nfloat prodNeighbours ( vec2 px ) {\n    return (Cell(px+vec2(0, -1)) + Cell(px+vec2(0, 1))) * \n           (Cell(px+vec2(-1, 0)) + Cell(px+vec2(1, 0)));\n}\n\nbool hasWhiteNeighbour ( vec2 px ) {   \n    return sumNeighbours(px) > 0.;\n}\n\nbool isInteriorCorner ( vec2 px, float e ) {\n    return e == 0.5 && prodNeighbours(px) >= 2.25;     \n}\n\nbool isExteriorCorner ( vec2 px, float e ) {\n    return e == 0.5 && sumNeighbours(px) == 1.;\n}\n\nbool isBlackOutlined( vec2 px, float e ) {\n    return e == 0. && sumNeighbours(px) == 2.;\n}\n\nbool wasInDiagCorner( vec2 px, float e ) {\n    // this shouldn't work but somehow it does\n    return e == 1. && prodNeighbours(px) < 2.; \n}\n\nbool isIsolated ( vec2 px ) {\n    return sumNeighbours(px) == 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    setDimHandle(iFrame);\n    \n    vec2 px = coord;    \n    float e = Cell(px);\n    \n    // reset staff after a number of frames\n    int frame = iFrame % reset;\n      \n    // initial state - generate noise\n    if ( frame == 0 && coord.x <= dimHandle.x && coord.y <= dimHandle.y ) {\n      \n        // get symmetric rand value (random works best with low iTime values)\n        float d = abs(0.5 * dimHandle.x - coord.x);    \n        float rand = random(vec2(d , coord.y) + mod(iTime,201.315));\n        \n        // likely horizontal at top\n        if ( coord.y > dimHandle.y - 4.)\n            e = step(0.18, rand);\n            \n        // guarantee exposed \"pole\"\n        else if ( coord.y > 6. && coord.y < 12.)\n            e = 0.;\n            \n        // 50% rand noise in other regions   \n        else\n            e = step(0.5, rand);\n                                \n        // centre cells are 1. ( insert a \"pole\" ) \n        // ( maybe cut out the side values? )\n        e = max(e, step(d, 1.));\n        \n        // cut off edges, so outline will work\n        e *= step(coord.x, dimHandle.x - 2.) * step(2., coord.x) * \n             step(coord.y, dimHandle.y - 2.) * step(2., coord.y);          \n    }\n    \n    // run cellular automata on noise\n    else if ( frame < 5 ) {\n        e = CA(px, e);                 \n    }\n    \n    // reinsert noise at top, so horizontal bit is more likely\n    else if ( frame < 6 && coord.y > dimHandle.y - 4. \n              && coord.x <= dimHandle.x && coord.y <= dimHandle.y) {\n              \n        float d = abs(0.5 * dimHandle.x - coord.x);    \n        float rand = random(vec2(d , coord.y) + mod(iTime,201.315));\n        \n        e = step(0.18, rand);\n        \n        // cut off edges, so outline will work\n        e *= step(coord.x, dimHandle.x - 2.) * step(2., coord.x) * \n             step(coord.y, dimHandle.y - 2.) * step(2., coord.y);    \n    }\n    \n    // run cellular automata on noise again\n    else if ( frame < 10 ) {\n        e = CA(px, e);                 \n    }\n        \n    // re-insert centre cells so a \"pole\" definitely exists\n    else if ( frame < 11 ) {\n        e = min(1., \n            e + step(coord.y, dimHandle.y) \n            * step(2., coord.y) \n            * max(e, step(abs(0.5 * dimHandle.x - coord.x), 1.)));\n    } \n    \n    // generate outline\n    else if ( frame < 12 )\n        e = (e == 0. && hasWhiteNeighbour(px)) ? .5 : e;\n    \n    // remove interior outlines + interior (axis-aligned) corners\n    else if ( frame < 17 )\n        e = (isInteriorCorner(px, e) || isBlackOutlined(px, e)) ? 1. : e;\n    \n    // remove exterior (diagonal) corner outlines\n    else if ( frame < 18 )\n        e = isExteriorCorner(px, e) ? 0. : e;\n    \n    // turn newly exposed bits into outlines\n    else if ( frame < 19)\n        e = wasInDiagCorner(px, e) ? 0.5 : e;\n    \n    // remove any corners formed from deleting diagonal corners\n    else if ( frame < 20 ) \n        e = isExteriorCorner(px, e) ? 0. : e;\n    \n    // one more for good luck ( remove pixels without any neighbours )\n    else if ( frame < 21 ) \n        e = isIsolated(px) ? 0. : e;\n    \n    // remove artifacts ( sloppy )\n    else if ( frame == reset - 1 )\n        e = 0.;\n        \n  fragColor = vec4(e);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Most of this code was stolen from iq:\n// https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// generate mirrored noise\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    setDimHandle(iFrame);\n\n    // uncomment iTime for a cool look\n    vec2 uv = vec2(abs(coord.x - 0.5 * dimHandle.x), coord.y)\n            + 20. * floor(float(iFrame) / float(reset));// + iTime;\n \n\tfloat f = 0.0;\n\t\n\tuv *= 0.01;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf =  0.5000 * noise( uv ); uv = m*uv;\n    f += 0.2500 * noise( uv ); uv = m*uv;\n\tf += 0.1250 * noise( uv ); uv = m*uv;\n\tf += 0.0625 * noise( uv ); uv = m*uv;\n\t\n\tf = 0.5 + 0.5 * f;\n\n    fragColor = vec4(f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}