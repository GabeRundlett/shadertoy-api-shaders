{
    "Shader": {
        "info": {
            "date": "1463351393",
            "description": "Practising spot lights, soft shadows and distance functions.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsKXzD",
            "likes": 2,
            "name": "Spotlight Torus",
            "published": 3,
            "tags": [
                "torus",
                "spotlight"
            ],
            "usePreview": 0,
            "username": "docwhite",
            "viewed": 796
        },
        "renderpass": [
            {
                "code": "const float Detail = 0.0025;\n\nmat4 Rot4X(float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n    \n    return mat4( 1, 0, 0, 0,\n                 0, c,-s, 0,\n                 0, s, c, 0,\n                 0, 0, 0, 1);\n}\n\nfloat sdTorus(vec3 p, vec2 t, vec3 c) {\n    p -= c;\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdSphere(vec3 p, vec3 c, float rad) {\n\treturn length(p-c) - rad;\n}\n\nfloat sdPlane(vec3 p) {\n\treturn p.y + 0.5;\n}\n\nfloat map(vec3 p) {\n    mat4 rot = Rot4X(iTime);\n    vec4 rotated = rot * vec4(p, 1.0);\n    float torus = sdTorus(rotated.xyz, vec2(0.3, 0.1), vec3(0.0, 0.1, 0.0));\n    float sphere = sdSphere(p, vec3(cos(iTime), 0.0, sin(iTime)), 0.5);\n    float plane = sdPlane(p);\n    \n    \n    \n    return min(torus, plane);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0.0, Detail);\n    return -normalize(vec3(\n        map(p-e.yxx)-map(p+e.yxx),\n        map(p-e.xyx)-map(p+e.xyx),\n        map(p-e.xxy)-map(p+e.xxy)\n    ));\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float k) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 32; i++) {\n    \tfloat h = map(ro + rd * t);\n        if (h < 0.001) { return 0.0; }\n        res = min(res, k*h/t);\n       \tt += h;\n    }\n    return res;\n}\n\nfloat spotLight(vec3 p, vec3 n) {\n    vec3 spotDir = normalize(vec3(0.0, -1.0, 0.0));\n    vec3 spotPos = vec3(0.0, 1.0, 0.0);\n    float coneAngle = 20.0;\n    float coneDelta = 30.0;\n    \n\tvec3 lray = normalize(spotPos - p);\n    float falloff = (dot(lray, -spotDir) - cos(radians(coneDelta))) / (cos(radians(coneAngle)) - cos(radians(coneDelta)));\n    float diffuse = max(0.0, dot(lray, n));\n    float sh = softShadow(p, lray, 0.01, 32.0);\n    return diffuse * falloff * sh;\n}\n\nfloat light(vec3 p, vec3 dir) {\n    vec3 n = normal(p);\n    float diffuse = spotLight(p, n);\n    return diffuse;\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n    float d = 1.0;\n    vec3 p;\n    for (int i = 0; i < 128; ++i) {\n        if (d > Detail && t < 50.0) {\n            p = ro + rd * t;\n            d = map(p);\n            t += d;\n        }\n    }\n    float bg = 0.0;\n    float col;\n    if (d < Detail) {\n    \tcol = light(p-Detail*rd, rd);\n    } else {\n        col = bg;    \n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 cu = normalize( cross(cw,-cp) );\n\tvec3 cv = normalize( cross(cu,-cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n\t// Camera\t\n\tvec3 ro = vec3(0.0, 1.0, -3.5);\n\tvec3 ta = vec3(0.0);\n    mat3 ca = setCamera(ro, ta);\n    vec3 rd = ca * normalize(vec3(uv.xy, 2.0));\n    \n    float t = trace(ro, rd);\n    //float fog = 1.0 / (1.0 + t * t * 0.1);\n    //vec3 fc = vec3(fog);\n    //fragColor = vec4(fc,1.0);\n    fragColor = vec4(t, t, t, 1.0);\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}