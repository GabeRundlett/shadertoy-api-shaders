{
    "Shader": {
        "info": {
            "date": "1571602185",
            "description": "Code based on https://www.shadertoy.com/view/wdc3zX and uses trad code from iq and all\nTemple based on Temple of Concordia, Agrigento https://sketchfab.com/3d-models/temple-of-concordia-agrigento-b28\nMade for the 3rd issue of https://fanzine.cookie.paris/",
            "flags": 0,
            "hasliked": 0,
            "id": "wdtSR4",
            "likes": 5,
            "name": "Anaglyph Temple",
            "published": 3,
            "tags": [
                "anaglyph"
            ],
            "usePreview": 0,
            "username": "Koltes",
            "viewed": 490
        },
        "renderpass": [
            {
                "code": "// Code based on https://www.shadertoy.com/view/wdc3zX and uses trad code from iq and all\n// Temple based on Temple of Concordia, Agrigento https://sketchfab.com/3d-models/temple-of-concordia-agrigento-b28946ad96af42b29f248a4d89050d16\n// Made for the 3rd issue of https://fanzine.cookie.paris/\n\nconst float divergence = 1.0;\nconst float fieldOfView = 1.5;\n\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nvec3 look (vec3 eye, vec3 target, vec2 anchor, float fov) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * fov + right * anchor.x + up * anchor.y);\n}\n\nfloat hash1( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat hash2(vec2 co) {\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash3(vec3 p) {\n\tp  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n\treturn fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 oi = vec2(0,1);\n\treturn mix(mix(mix( hash3(p),\n\t\t\t\t\t\thash3(p+oi.yxx),f.x),\n\t\t\t\tmix( hash3(p+oi.xyx),\n\t\t\t\t\t\thash3(p+oi.yyx),f.x),f.y),\n\t\t\tmix(mix( hash3(p+oi.xxy),\n\t\t\t\t\t\thash3(p+oi.yxy),f.x),\n\t\t\t\tmix( hash3(p+oi.xyy),\n\t\t\t\t\t\thash3(p+oi.yyy),f.x),f.y),f.z);\n}\n\nfloat fbm (vec3 p, float s) {\n\tfloat value = 0.0;\n\tfloat amplitude = 1.;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tvalue += amplitude * noise(p);\n\t\tp *= 2.;\n\t\tp.yx *= rot(iTime*s*.5);\n\t\tp.yz *= rot(iTime*s*.3);\n\t\tp.xz *= rot(iTime*s*.6);\n\t\tamplitude *= .5;\n\t}\n\treturn value;\n}\n\nvec3 camera (vec3 eye) {\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    if (iMouse.z > 0.5) {\n        eye.yz *= rot(mouse.y*3.1415);\n        eye.xz *= rot(mouse.x*3.1415);\n    }\n    return eye;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCone( in vec3 p, in float a )\n{\n    float q = length(p.xy);\n    return dot(vec2(sin(a),cos(a)),vec2(q,p.z));\n}\n\nfloat sdColumn(vec3 p) {\n    float a = atan(p.z, p.x);\n    float d = length(p.xz) - (1. - p.y * 0.02 + sin(a * 20.) * .1);\n    d = max(d, -p.y);\n    d = max(d, p.y - 10.);\n    \n    float dCone = sdCone(p.xzy*vec3(1,1,-1)+vec3(0,0,2.), 1.45);\n    dCone = max(dCone, -p.y + 9.8);\n    dCone = max(dCone, p.y - 10.2);\n    \n    d = smoothmin(d, dCone, 0.2);\n    d = smoothmin(d, sdBox(p - vec3(0, 10.5, 0), vec3(1.1, 0.3, 1.1)), 0.2);\n    \n    return d;\n}\n\nfloat sdTemple(vec3 p) {\n    p.xz = abs(p.xz);\n    const float sep = 6.;\n    float d = sdColumn(p - vec3(sep*0.5, 0, sep*5.5));\n    d = min(d, sdColumn(p - vec3(sep*1.5, 0, sep*5.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*5.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*4.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*3.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*2.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*1.5)));\n    d = min(d, sdColumn(p - vec3(sep*2.5, 0, sep*0.5)));\n    const float minisep = 5.;\n    d = min(d, sdColumn(p - vec3(minisep*0.5, 0, minisep*4.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*4.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*3.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*2.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*1.5)));\n    d = min(d, sdColumn(p - vec3(minisep*1.5, 0, minisep*0.5)));\n    \n    float dTop = sdBox(p - vec3(0,11.5,0), vec3(sep*2.5+1.1, 1., sep*5.5+1.1));\n    dTop = min(dTop, sdBox(p - vec3(0, 13.5, sep*5.5-3.5), vec3(sep*2.5+1.1, 1., 4.6)));\n    dTop = max(dTop, -sdBox(p, vec3(sep*2.5-1.1, 20., sep*5.5-1.1)));    \n    dTop += fbm(p, 0.)*.1;\n    d = min(d, dTop);\n    \n    vec3 q = p;\n    q.x -= (sep*2.5+3.);\n    q.y -= 14.5;\n    q.xy *= rot(.2);\n    float dTri = q.y;\n    dTri = max(dTri, -(p.y - 14.5));\n    dTri = max(dTri, p.x - (sep*2.5+1.));\n    dTri = max(dTri, abs(p.z - sep*5.5 - .7) - 1.);\n    dTri += fbm(p, 0.)*.1;\n    d = min(d, dTri);\n    \n    const float stepsep = 1.;\n    float dSteps = sdBox(p - vec3(0, -0.3, 0), vec3(sep*3.+0.*stepsep, .6, sep*6.+0.*stepsep)) + smoothstep(0.05, 0., abs(fract(p.x*.4)-.5))*.1;\n    dSteps = min(dSteps, sdBox(p - vec3(0, -0.9, 0), vec3(sep*3.+1.*stepsep, .6, sep*6.+1.*stepsep)) + smoothstep(0.05, 0., abs(fract(p.x*.4+.5)-.5))*.1);\n    dSteps = min(dSteps, sdBox(p - vec3(0, -1.5, 0), vec3(sep*3.+2.*stepsep, .6, sep*6.+2.*stepsep)) + smoothstep(0.05, 0., abs(fract(p.x*.4)-.5))*.1);\n    dSteps = min(dSteps, sdBox(p - vec3(0, -2.1, 0), vec3(sep*3.+3.*stepsep, .6, sep*6.+3.*stepsep)) + smoothstep(0.05, 0., abs(fract(p.x*.4+.5)-.5))*.1);\n    dSteps += fbm(p, 0.)*.2;\n    d = min(d, dSteps);\n    \n    float dGround = p.y + 2.4;\n    dGround += fbm(p, 0.)*.1;\n    d = min(d, dGround);\n    \n    return d;\n}\n\nfloat sdCloud (vec3 p) {\n\tp.y -= 40.-20.*sin(6.283/8.*clamp(length(p.xz)/200.,0.,1.));\n\tfloat shape = abs(p.y+5.*fbm(p*.2, .01))-5.*(noise(p*.1+iTime*.1)-.4);\n\tshape = mix(1.,shape, clamp(length(p.xz),0.,1.));\n\treturn shape;\n}\n\nfloat geometry (vec3 pos) {\n    pos = camera(pos);\n    float scene = sdTemple(pos);\n    scene = min(scene, sdCloud(pos));\n    return scene;\n}\n\nfloat raymarch ( vec3 eye, vec3 ray ) {\n    float dither = random(ray.xy+fract(iTime));\n    float total = dither;\n    const int count = 50;\n    for (int index = count; index > 0; --index) {\n        float dist = geometry(eye+ray*total);\n        dist *= 0.9+.1*dither;\n        total += dist;\n        if (dist < 0.001 * total)\n            return float(index)/float(count);\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 diverg = vec2(divergence, 0.);\n    vec3 eye = vec3(10,1,50);\n    vec3 target = vec3(-10,15,0);\n    \n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 eyeLeft = eye - diverg.xyy;;\n    vec3 eyeRight = eye + diverg.xyy;\n    vec3 rayLeft = look(eyeLeft, target, uv, fieldOfView);\n    vec3 rayRight = look(eyeRight, target, uv, fieldOfView);\n    float red = raymarch(eyeLeft, rayLeft);\n    float cyan = raymarch(eyeRight, rayRight);\n    fragColor = vec4(red,vec2(cyan),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}