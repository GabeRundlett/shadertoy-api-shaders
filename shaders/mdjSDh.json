{
    "Shader": {
        "info": {
            "date": "1670352791",
            "description": "A basic multi-layered perlin noise shader implementation",
            "flags": 0,
            "hasliked": 0,
            "id": "mdjSDh",
            "likes": 1,
            "name": "Multi-layer perlin noise",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "gradient"
            ],
            "usePreview": 0,
            "username": "bsodium",
            "viewed": 105
        },
        "renderpass": [
            {
                "code": "/*\n * Interpolation function between a0 and a1\n * The weight w should be in the range [0.0, 1.0]\n */\nfloat interpolate(float a0, float a1, float w) {\n    if (0.0 > w) return a0;\n    if (1.0 < w) return a1;\n\n    //return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;\n    return (a1 - a0) * ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w) + a0;\n    //return (a1 - a0) * w + a0;\n}\n\n/* \n * Generate a random direction vector.\n */\nvec2 randomGradient(int ix, int iy, float seed) {\n    float random = fract(sin(dot(vec2(ix, iy), vec2(12.9898, 78.233))) * 43758.5453 + seed);\n    return normalize(vec2(cos(random * 2.0 * 3.14159265359), sin(random * 2.0 * 3.14159265359)));\n}\n\n/* \n * Compute the dot-product of the distance and gradient vectors.\n */\nfloat dotGridGradient(int ix, int iy, float x, float y) {\n    // Get gradient from integer coordinates\n    vec2 gradient = randomGradient(ix, iy, iTime);\n\n    // Compute the distance vector\n    float dx = x - float(ix);\n    float dy = y - float(iy);\n\n    // Compute the dot-product\n    return (dx*gradient.x + dy*gradient.y);\n}\n\n// Compute Perlin noise at coordinates x, y\nfloat perlin(float x, float y) {\n    // Grid cell coordinates\n    int x0 = int(floor(x));\n    int x1 = x0 + 1;\n    int y0 = int(floor(y));\n    int y1 = y0 + 1;\n\n    // Interpolation weights\n    float sx = x - float(x0);\n    float sy = y - float(y0);\n\n    // Interpolate between grid point gradients\n    float n0, n1, ix0, ix1, value;\n\n    n0 = dotGridGradient(x0, y0, x, y);\n    n1 = dotGridGradient(x1, y0, x, y);\n    ix0 = interpolate(n0, n1, sx);\n\n    n0 = dotGridGradient(x0, y1, x, y);\n    n1 = dotGridGradient(x1, y1, x, y);\n    ix1 = interpolate(n0, n1, sx);\n\n    value = interpolate(ix0, ix1, sy);\n    return value; // Return value in range -1 to 1.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    uv *= 10.0; // Control grid resolution\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Low frequency\n    float n1 = perlin(uv.x, uv.y);\n    \n    uv *= 2.0;\n    \n    // Medium frequency\n    float n2 = perlin(uv.x, uv.y);\n    \n    uv *= 2.0;\n    \n    // High frequency\n    float n3 = perlin(uv.x, uv.y);\n    \n    // Compute average\n    float n = (n1 + n2 + n3) / 3.0;\n    \n    fragColor = vec4(n, n, n, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}