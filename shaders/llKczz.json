{
    "Shader": {
        "info": {
            "date": "1535019152",
            "description": "Playing with an idea for cheap sdf-based AO. Visuals inspired by [url=http://www.pouet.net/prod.php?which=75720]Zetsubo[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "llKczz",
            "likes": 12,
            "name": "Experimental AO",
            "published": 3,
            "tags": [
                "ambientocclusion"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 950
        },
        "renderpass": [
            {
                "code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat min3(float a,float b,float c){return min(min(a,b),c);}\nfloat min4(float a,float b,float c,float d){return min(min(a,b),min(c,d));}\nfloat min8(float a,float b,float c,float d,float e,float f,float g,float h){return min(min4(a,b,c,d),min4(e,f,g,h));}\n\nfloat noise(float t)\n{\n    return fract(sin(t*124.1231)*432.423432)*.1+.1;\n}\n\nfloat scene(vec3 p)\n{\n    float t=floor(iTime*4.);\n\tfloat r1 = noise(t+.1);\n\tfloat r2 = noise(t+.2);\n\tfloat r3 = noise(t+.3);\n\tfloat r4 = noise(t+.4);\n\tfloat r5 = noise(t+.5);\n\tfloat r6 = noise(t+.6);\n\tfloat r7 = noise(t+.7);\n\tfloat r8 = noise(t+.8);\n\treturn min8(\n        sdBox(p+vec3( .2, .2, .2),vec3(r1)),\n        sdBox(p+vec3( .2, .2,-.2),vec3(r2)),\n        sdBox(p+vec3( .2,-.2, .2),vec3(r3)),\n        sdBox(p+vec3( .2,-.2,-.2),vec3(r4)),\n        sdBox(p+vec3(-.2, .2, .2),vec3(r5)),\n        sdBox(p+vec3(-.2, .2,-.2),vec3(r6)),\n        sdBox(p+vec3(-.2,-.2, .2),vec3(r7)),\n        sdBox(p+vec3(-.2,-.2,-.2),vec3(r8))\n    );\n    \n    return max(\n        sdBox(p,vec3(.5)),\n        -min3(\n            sdBox(p,vec3(.6,.3,.3)),\n            sdBox(p,vec3(.3,.6,.3)),\n            sdBox(p,vec3(.3,.3,.6))\n        )\n    );\n}\n\nvec2 rotate(vec2 a, float b)\n{\n  \tfloat c = cos(b);\n  \tfloat s = sin(b);\n  \treturn vec2(\n\t    a.x * c - a.y * s,\n\t    a.x * s + a.y * c\n  \t);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n  \tvec2 uv = (fragCoord / iResolution.xy) - .5;\n  \tuv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-10);\n    vec3 dir = normalize(vec3(uv, 7));\n\n    cam.yz = rotate(cam.yz, sin(iTime*.5)*.5+.5);\n    dir.yz = rotate(dir.yz, sin(iTime*.5)*.5+.5);\n\n    cam.xz = rotate(cam.xz, iTime*.5);\n    dir.xz = rotate(dir.xz, iTime*.5);\n    \n    float t = 0.;\n    float k = 0.;\n    for (int i = 0; i< 100; ++i)\n    {\n        k = scene(cam + dir * t);\n        t += k;\n        if(k < .001)\n            break;\n    }\n    vec3 h = cam + dir * t;\n\n    vec2 o = vec2(.001, 0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy)-scene(h-o.xyy),\n        scene(h+o.yxy)-scene(h-o.yxy),\n        scene(h+o.yyx)-scene(h-o.yyx)\n    ));\n\n    const float aoMaxDist = .1;\n    float aoDist = scene(h+n*aoMaxDist);\n    aoDist = max(0.,aoDist);\n    float ao = pow(aoDist/aoMaxDist, .7)*.15+.85;\n    \n    float light = smoothstep(-1.,1.,dot(n,normalize(vec3(1,2,3))))*.15+.85;\n    fragColor = vec4(k < .001 ? ao * light : 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}