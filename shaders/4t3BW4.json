{
    "Shader": {
        "info": {
            "date": "1539774665",
            "description": "Quadtree Truchet - Based on Christopher Carlson's \"Multi-Scale Truchet Patterns\" paper. Mouse down to show the underlying quadtree grid structure.",
            "flags": 0,
            "hasliked": 0,
            "id": "4t3BW4",
            "likes": 136,
            "name": "Quadtree Truchet",
            "published": 3,
            "tags": [
                "truchet",
                "pattern",
                "multiscale",
                "quadtree",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 3390
        },
        "renderpass": [
            {
                "code": "/*\n\n\tQuadtree Truchet\n\t----------------\n\n    A multiscale, multitile, overlapped, weaved Truchet pattern. However, since\n\tthat description is a little verbose, I figured that a quadtree Truchet was as \n\tgood a description as any. :) The mild weave effect is provided via the\n\t\"INCLUDE_LINE_TILES\" define.\n\n\tIn order to produce a varied looking Truchet pattern, there are a couple of\n\tsimple things you can try: One is to use more than one tile, and the other is \n\tto stitch weaved tiles together to produce a cool under-over effect. There are \n    a few examples on Shadertoy of each, which are easy enough to find -- Just do\n\ta search for \"Truchet\" and look for the multitile and weaved examples.\n\n    Lesser known variations include using Truchet tiles that overlap one another, \n    and stitching together multiscaled tiles -- usually on something like a quadtree \n    grid. This example uses elements of all of the aforementioned.\n\n\tIn the past, I've combined two non-overlapping tile scales, but had never \n    considered taking it beyond that... until I came across Christopher Carlson's\n\tarticle, \"Multi-Scale Truchet Patterns.\" If you follow the link below and refer\n\tto the construction process, you'll see that the idea behind it is almost \n\trudimentary. As a consequence, I figured that it'd take me five minutes to put \n\tthe ideas into pixel shader form. Unfortunately, they say the dumber you are, \n\tthe more overconfident you'll be, and to cut a long story short... It took me \n\tlonger than five minutes. :D\n\n\tThe code below is somewhat obfuscated and strewn with defines - The defines are\n\tmy fault, since I wanted to provide a few rendering options. However, the \n\tremaining complication boils down to the necessity to render overlapping tiles\n\ton a quadtree grid in an environment that doesn't allow random pixel access. The \n\tonly example along those lines I could find on here was IQ's hierachical Voronoi \n\tdemonstration, which is pretty cool, but it contains a lot of nested iterations.\n\tRendering tiles in that manner wasn't really sufficient, so I had to write\n\tthings in a way that used fewer iterations, but it was at the cost of legibility.\n\n\tEither way, the idea is pretty simple: Construct a grid, randomly render some \n\tTruchet tiles, subdivide the remaining squares into four, randomly render some \n    more tiles in reverse color order, then continue ad infinitum. By the way, I\n\tconstructed this on the fly using the best method I could think of at the time.\n\tHowever, if anyone out there has a more elegant solution, feel free to post it. :)\n\t\n\tNaturally, the idea can be extended to 3D. Three levels with this particular \n\tsetup might be a little slow. However, two levels using a non overlapping tile\n\tis definitely doable, so I intend to produce an example along those lines in the \n\tnear future.\n\n\n\tBased on the following:\n\n\tMulti-Scale Truchet Patterns  - Christopher Carlson\n\thttps://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n    Linking paper containing more detail:\n    http://archive.bridgesmathart.org/2018/bridges2018-39.pdf\n\n\tQuadtree Related:\n\n\t// Considers overlap.\n\thttps://www.shadertoy.com/view/Xll3zX\n\tVoronoi - hierarchical - IQ\n\n    // No overlap, but I really like this one.\n    SDF Raymarch Quadtree - Paniq\n\thttps://www.shadertoy.com/view/MlffW8\n\n\t// Multilevel, and nice and simple.\n\tquadtree - 4 - FabriceNeyret2\n\thttps://www.shadertoy.com/view/ltlyRH\n\n\t// A really simple non-overlapping quadtree example.\n\tRandom Quadtree - Shane\n\thttps://www.shadertoy.com/view/llcBD7\n\n*/\n\n\n// DEFINES: Feel free to try them out.\n\n// Colored setting: White: 0, Spectrum: 1, Pink: 2.\n#define COLOR 1\n\n// Showing the different tile layers stacked on top of one another. Aesthetically, I prefer \n// this more, because it has a raised look about it. However, you can't make out the general \n// pattern as well, so it's off by default.\n//#define STACKED_TILES\n\n// This option produces art deco looking patterns, which are probably more interesting, but \n// I wanted the default pattern to be more simplistic. \n//#define INCLUDE_LINE_TILES\n\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(57, 27)));\n    \n    return fract(vec2(262144, 32768)*n);\n    \n    /*\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".35,\" insted of \".5\" that you'd expect to see. .\n    return sin(p*6.2831853 + iTime/2.)*.24;\n    */\n}\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n/*\n// IQ's 2D unsigned box formula.\nfloat sBox(vec2 p, vec2 b){ return length(max(abs(p) - b, 0.)); }\n\n// IQ's 2D signed box formula.\nfloat sBoxU(vec2 p, vec2 b){\n\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n \n    // Screen coordinates.    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling, rotation and transalation.\n    vec2 oP = uv*5.;    \n    oP *= r2(sin(iTime/8.)*3.14159/8.);    \n    oP -= vec2(cos(iTime/8.)*0., -iTime);\n    \n\n    // Distance field values -- One for each color. They're \"vec4\"s to hold the three \n    // layers and an an unused spare. The grid vector holds grid values, strangely enough. :)\n    vec4 d = vec4(1e5), d2 = vec4(1e5), grid = vec4(1e5);\n    \n    // Random constants for each layer. The X values are Truchet flipping threshold\n    // values, and the Y values represent the chance that a particular sized tile\n    // will render.\n    //\n    // The final Y entry needs to fill in the remaiming grid spaces, so it must have a 100% \n    // chance of success -- I'd rather not say how long it took me to figure that out. :D\n    const vec2 rndTh[3] = vec2[3]( vec2(.5, .35), vec2(.5, .7), vec2(.5, 1));\n    \n    \n    // The scale dimentions. Gets multiplied by two each iteration. \n    float dim = 1.;\n    \n    \n    \n    // If you didn't need to worry about overlap, you wouldn't need to consider neighboring\n    // cell rendering, which would make this far less complicated - One loop and a break.\n    \n    // Three tile levels. \n\tfor(int k=0; k<3; k++){\n        \n    \t// Base cell ID.\n\t\tvec2 ip = floor(oP*dim);\n             \n        // Abje reminded me that for a 2x2 neighbor check, just make the following changes:\n        //vec2 ip = floor(oP*dim + .5);\n        //for(int j=-1; j<=0; j++){\n            //for(int i=-1; i<=0; i++){\n        //\n        // In this particular case, I'm using a 3x3 sweep because I need the internal field pattern \n        // overlay to be balanced. However, in general, Abje's faster suggestion is the way to go.\n             \n        \n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n\n                // The neighboring cell ID.\n                vec2 rndIJ = hash22(ip + vec2(i, j));\n                \n                // The cell IDs for the previous dimension, or dimensions, as the case may be.\n                // Because the tiles overlap, rendering order matters. In this case, the tiles \n                // need to be laid down from largest (k = 0) to smallest (k = 2). If a large tile\n                // has taken up the space, you need to check on the next iterations and skip --\n                // so as not to lay smaller tiles over the larger ones.\n                //\n                // So why not just break from the loop? Unfortunately, there are neighboring\n                // cells to check, and the IDs need to be calculated from the perspective of \n                // each cell neighbor... Yeah, I'm confused too. You can either take my word\n                // for it, or better yet, come up with a more elegant solution. :)\n                vec2 rndIJ2 = hash22(floor((ip + vec2(i, j))/2.));\n                vec2 rndIJ4 = hash22(floor((ip + vec2(i, j))/4.));\n\t\t\t\t\n                // If the previous large tile has been rendered, continue.\n                if(k==1 && rndIJ2.y<rndTh[0].y) continue;\n                // If any of the two previous larger tiles have been rendered, continue.\n                if(k==2 && (rndIJ2.y<rndTh[1].y || rndIJ4.y<rndTh[0].y)) continue;\n              \n                \n                // If the random cell ID at this particular scale is below a certain threshold, \n                // render the tile. The code block below is a little messy, due to to fact that I\n                // wanted to render a few different tile styles without bloating things too much.\n                // This meant a bunch of random coordinate flipping, reflecting, etc. As mentioned,\n                // I'll provide a much simpler example later.                \n\t\t\t\t//\n                if(rndIJ.y<rndTh[k].y){\n\n                    // Local cell coordinates. The following is equivalent to:\n                    // vec2 p = mod(oP, 1./dim) - .5/dim - vec2(i, j)/dim;\n                    vec2 p = oP - (ip + .5 + vec2(i, j))/dim;\n\n                    \n                    // The grid square.\n                    float square = max(abs(p.x), abs(p.y)) - .5/dim; \n     \t\t\t    \n                    // The grid lines.\n                    const float lwg = .01;\n                    float gr = abs(square) - lwg/2.;\n                    grid.x = min(grid.x, gr);\n\n\t\t\t\t\t\n                    // TILE COLOR ONE.\n                    \n                    // Standard Truchet rotation and flipping -- based on a random cell ID.\n                    if(rndIJ.x<rndTh[k].x) p.xy = p.yx;\n                    if(fract(rndIJ.x*57.543 + .37)<rndTh[k].x) p.x = -p.x;\n                    \n\n\n                    // Rotating by 90 degrees, then reflecting across both axes by the correct\n                    // distance to produce four circles on the midway points of the grid boundary\n                    // lines... A lot of this stuff is just practice. Do it often enough and \n                    // it'll become second nature... sometimes. :)\n                    vec2 p2 = abs(vec2(p.y - p.x, p.x + p.y)*.7071) - vec2(.5, .5)*.7071/dim;\n                    float c3 = length(p2) - .5/3./dim;\n                    \n                    float c, c2;\n\n                    // Truchet arc one.\n                    c = abs(length(p - vec2(-.5, .5)/dim) - .5/dim) - .5/3./dim;\n\n                    // Truchet arc two.\n                    if(fract(rndIJ.x*157.763 + .49)>.35){\n                        c2 = abs(length(p - vec2(.5, -.5)/dim) - .5/dim) - .5/3./dim;\n                    }\n                    else{  \n                        // Circles at the mid boundary lines -- instead of an arc.\n                        // c2 = 1e5; // In some situations, just this would work.\n                        c2 = length(p -  vec2(.5, 0)/dim) - .5/3./dim;\n                        c2 = min(c2, length(p -  vec2(0, -.5)/dim) - .5/3./dim);\n                    }\n\n\n                    // Randomly overiding some arcs with lines.\n                    #ifdef INCLUDE_LINE_TILES\n                        if(fract(rndIJ.x*113.467 + .51)<.35){\n                        \tc = abs(p.x) - .5/3./dim;\n                        }\n                        if(fract(rndIJ.x*123.853 + .49)<.35){ \n                        \tc2 = abs(p.y) - .5/3./dim;\n                        }\n                    #endif\n\n\n\t\t\t\t\t// Truch arcs, lines, or dots -- as the case may be.\n                    float truchet = min(c, c2);\n\n                    // Carving out a mild channel around the line to give a faux weave effect.\n                    #ifdef INCLUDE_LINE_TILES\n                    \tfloat lne = abs(c - .5/12./4.) - .5/12./4.;\n     \t\t\t\t\ttruchet = max(truchet, -lne);\n                    #endif\n\n                    // Each tile has two colors. This is the first, and it's rendered on top.\n                    c = min(c3, max(square, truchet));\n                    d[k] = min(d[k], c); // Tile color one.\n    \n                    \n                    // TILE COLOR TWO.\n                    // Repeat trick, to render four circles at the grid vertices.\n                    p = abs(p) - .5/dim;\n                    float l = length(p);\n                    // Four circles at the grid vertices and the square.\n                    c = min(l - 1./3./dim, square);\n                    //c = max(c, -truchet);\n                    //c = max(c, -c3);\n                    d2[k] = min(d2[k], c); // Tile color two.\n                    \n                    // Rendering some circles at the actual grid vertices. Mouse down to see it.\n                    grid.y = min(grid.y, l - .5/8./sqrt(dim)); //.05/(dim*.35 + .65)\n                    grid.z = min(grid.z, l);\n                    grid.w = dim;\n\n\n                }\n                 \n\n\n            }\n        }\n        \n        // Subdividing. I.e., decrease the tile size by doubling the frequency.\n        dim *= 2.;\n        \n        \n    }\n    \n    \n    // The scene color. Initiated to grey.\n    vec3 col = vec3(.25);\n    \n    \n    // Just a simple lined pattern.\n    float pat3 = clamp(sin((oP.x - oP.y)*6.283*iResolution.y/24.)*1. + .9, 0., 1.)*.25 + .75;\n    // Resolution based falloff... Insert \"too may different devices these days\" rant here. :D\n    float fo = 5./iResolution.y;\n    \n    \n    // Tile colors. \n    vec3 pCol2 = vec3(.125);    \n    vec3 pCol1 = vec3(1);\n    \n    //The spectrum color option overides the pink option.\n    #if COLOR ==  1\n    pCol1 = vec3(.7, 1.4, .4);//Spectrum.\n    #elif COLOR ==  2\n    // Pink version.\n    pCol1 = mix(vec3(1, .1, .2), vec3(1, .1, .5), uv.y*.5 + .5);;\n    pCol2 = vec3(.1, .02, .06); \n    #endif\n    \n    \n    \n    \n\t#ifdef STACKED_TILES\n        // I provided this as an option becaue I thought it might be useful\n        // to see the tile layering process.\n\n        float pw = .02;\n        d -= pw/2.;\n        d2 -= pw/2.;\n    \n        // Render each two-colored tile, switching colors on alternating iterations.\n    \tfor (int k=0; k<3; k++){\n\n            col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d2[k]))*.35);\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo, d2[k]));\n            col = mix(col, pCol2, 1. - smoothstep(0., fo, d2[k] + pw));  \n\n            col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d[k]))*.35);\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo, d[k]));\n            col = mix(col, pCol1, 1. - smoothstep(0., fo, d[k] + pw));\n            \n            vec3 temp = pCol1; pCol1 = pCol2; pCol2 = temp;\n        }\n\n        col *= pat3;\n    \n    #else\n   \n        // Combining the tile layers into a continuous surface. I'd like to say that\n        // I applied years of topological knowledge to arrive at this, but like most\n        // things, I threw a bunch of formulas at the screen in frustration until I \n        // fluked the solution. :D There was a bit of logic applied though. :)\n        d.x = max(d2.x, -d.x);\n        d.x = min(max(d.x, -d2.y), d.y);\n        d.x = max(min(d.x, d2.z), -d.z);\n\n        // A couple of distance field patterns and a shade.\n        float pat = clamp(-sin(d.x*6.283*20.) - .0, 0., 1.);\n        float pat2 = clamp(sin(d.x*6.283*16.)*1. + .9, 0., 1.)*.3 + .7;\n        float sh = clamp(.75 + d.x*2., 0., 1.);\n\n        #if COLOR == 1\n\n            col *= pat;\n\n    \t\t// Render the combined shape.\n            d.x = -(d.x + .03);\n\n            col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.x)));\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo, d.x));\n            col = mix(col, vec3(.8, 1.2, .6), 1. - smoothstep(0., fo*2., d.x + .02));\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo*2., d.x + .03));\n            col = mix(col, vec3(.7, 1.4, .4)*pat2, 1. - smoothstep(0., fo*2., d.x + .05));\n\n            col *= sh; \n\n        #else\n\n            //d.x -= .01;\n            col = pCol1;\n\n    \t\t// Render the combined shape.\n            col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.x))*.35);\n            col = mix(col, vec3(0), 1. - smoothstep(0., fo, d.x));\n            col = mix(col, pCol2, 1. - smoothstep(0., fo, d.x + .02));\n\n\n            col *= pat3; // Line decroation.\n        #endif\n\n\t#endif\n    \n  \n \n    // Mild spotlight.\n    col *= max(1.15 - length(uv)*.5, 0.);\n    \n    \n    // Click the left mouse button to show the underlying quadtree grid structure. It's\n    // helpful to see the cell borders to see the random tile constructions.\n    if(iMouse.z>0.){\n        \n        \n        vec3 vCol1 = vec3(.8, 1, .7);\n        vec3 vCol2 = vec3(1, .7, .4);\n        \n        #if COLOR == 2\n        vCol1 = vCol1.zxy;\n        vCol2 = vCol2.zyx;\n        #endif\n        \n        // Grid lines.\n        vec3 bg = col;\n        col = mix(col, vec3(0), (1. - smoothstep(0., .02, grid.x - .02))*.7);\n        col = mix(col, vCol1 + bg/2., 1. - smoothstep(0., .01, grid.x));\n\n        // Circles on the grid vertices.\n        fo = 10./iResolution.y/sqrt(grid.w);\n        col = mix(col, vec3(0), (1. - smoothstep(0., fo*3., grid.y - .02))*.5);\n    \tcol = mix(col, vec3(0), 1. - smoothstep(0., fo, grid.y - .02));\n        col = mix(col, vCol2, 1. - smoothstep(0., fo, grid.y));\n        col = mix(col, vec3(0), 1. - smoothstep(0., fo, grid.z - .02/sqrt(grid.w)));\n    }\n    \n    \n    // Mix the colors, if the spectrum option is chosen.\n    #if COLOR == 1\n    col = mix(col, col.yxz, uv.y*.75 + .5); //.zxy\n    col = mix(col, col.zxy, uv.x*.7 + .5); //.zxy\n    #endif\n    \n\n    // Rough gamma correction, and output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}