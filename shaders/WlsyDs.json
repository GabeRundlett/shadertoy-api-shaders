{
    "Shader": {
        "info": {
            "date": "1593457128",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "WlsyDs",
            "likes": 9,
            "name": "Day 192",
            "published": 3,
            "tags": [
                "mograph",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./50.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[11](4.2*speed,7.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 1.2*speed, 1.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nvec2 r22(vec2 u){\n    u *= 126.3262;\n\tfloat uv = fract(dot(u, u*vec2(0.35,0.86)));\n\tu /= 124.3262;\n    return fract(sin(vec2(uv*u.y + u.x*uv*0.15 - u.y) - u)*215.125);\n}\n\nfloat starLayer(vec2 u, float sc){\n\tfloat d = 10e5;\n    u *= sc;\n    vec2 id = floor(u);\n    vec2 uv = fract(u) - 0.1;\n\tvec2 r = r22(id)*2. - 1.;\n\tvec2 rb = r22(id + 6.4);\n\td = min(d, (length(uv - r*1. ) - rb.x*0.04)/sc);\n\treturn d;\n}\n\nfloat starNoise(vec2 u){\n\tfloat d = 10e6;\n    \n    d = min(d, starLayer(u,16.));\n    d = min(d, starLayer(u,36.))/0.7;\n    \n    return d; \n}\n\n// oh no\n#define smease(p,g) ease(p, 1.5, 1.24, 0.76, 1.)\n \n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    uv.y = - uv.y;\n    \n    //t += sumScenes(1.)- 0.;\n    \n    t = mod(t, sumScenes(9.)  );\n    \n    vec2 triW = vec2(0.2,0.2)*0.25;\n    \n    float its = 15.;\n    float scene = 0.;\n    \n    vec2 p = uv;\n\n    vec4 q = vec4(p,1,1);\n\n    float dt = 10e5;\n    float dFirst = 10e5;\n\tfloat boxdel = 10e5; \n    \n    for(float i = 0.; i < its; i++){\n        float tsc = i/its*2.;\n        float enva = eass((t - tsc)/scenes[0]*2.,3.);\n\n        float envb = eass((t - tsc - scenes[0])/scenes[1]*2.,3.);\n\n        float envc = eass((t - tsc - sumScenes(1.))/scenes[2]*1.,3.);\n        float envd = eass((t - tsc - sumScenes(2.))/scenes[3]*1.,7.);\n\n        float enve = eass((t - tsc - sumScenes(3.))/scenes[4]*1.,3.);\n\n        float envf = eass((t - tsc - sumScenes(4.))/scenes[5]*1.,1.);\n\n        float envg = eass((t - tsc - sumScenes(5.))/scenes[6]*1.,3.);\n\n        float envh = eass((t - tsc - sumScenes(6.))/scenes[7]*1.,3.);\n\n        vec2 b = p;\n\n\n        //b = mix(b,abs(b),1.);\n\n        b *= rot(pi*0. );\n\n\n        float itsifs = 0. + envf*0.3  - envh*0.3;\n        for(float j = 0.; j < itsifs + 1.; j++){\n            vec2 f = abs(b);\n            //b -= 0.01;\n\n            //f -= 0.1*envf;\n            f *= rot(0.25*pi);\n            //f *= rot(0.25*pi*envf);\n            \n            b = mix(b,f,smoothstep(0.,1.,itsifs - j));\n\n        }\n\n        b.xy *= rot(tau*i/its*(0.6*envc - 0.6*envd) );\n\n        //b.y -= 0.3;\n        //b.y += 0.2*enva;\n\n        //b.y += sin((i)/1. - t*pi)*0.1;\n        //b.xy *= rot(i*0.4 + iTime/3.);\n\n        vec2 g = b;\n\n        float ld = 10e5;\n\n        \n        ld = min(ld,abs(length(b + vec2(0.24,0.04))-0.01));\n        \n        //\n        vec2 bc = b - vec2(-0.2 + enva*0.1 - envh*0.1,0.04);\n        float dc = length(bc);\n        ld = min(ld,\n                 max(\n                     abs( pmod(atan(bc.y,bc.x),0.4))\n                 \t*length(bc)/smoothstep(1.,0.98,length(bc)*(4.  + sin(atan(bc.y,bc.x)*4.) )),\n                     -dc + 0.04\n                \t)\n                 );\n        ld = min(ld,abs(dc-0.04));\n        \n        \n        \n        //\n        bc = b - vec2(0.34 - envc*0.1 + envh*0.1,-0.3);\n        \n        dc = length(bc);\n        \n        ld = min(ld,\n                 max(\n                     abs( pmod(atan(bc.y,bc.x),0.4))\n                 \t*length(bc)/smoothstep(1.,0.98,length(bc)*(4. + sin(atan(bc.y,bc.x)*4.))),\n                     -dc + 0.04\n                \t)\n                 );\n        ld = min(ld,(dc-0.05));\n        \n        //\n        float tri = sdTri(g,vec2(0.5,0.5));\n        ld = max(ld, -tri);\n        ld = min(ld,abs(tri));\n        \n        //\n        \n        \n        bc = b - vec2(0.4 - enva*0.3 + envh*0.3,0.24);\n        \n        dc = length(bc);\n        \n        ld = min(ld,\n                 max(\n                     abs( pmod(atan(bc.y,bc.x),0.4))\n                 \t*length(bc)/smoothstep(1.,0.98,length(bc)*(4.  + sin(atan(bc.y,bc.x)*3.5))),\n                     -dc + 0.1\n                \t)\n                 );\n        \n        float crem = dc - 0.1;\n\t\t\n        ld = min(ld,abs(dc-0.1));\n        \n        \n        b = abs(b ) - vec2(0.3*envb - envh*0.3,0.4);\n        b *= rot(-0.25*pi + 0.25*pi*envb - envh*0.25*pi);\n\t\t\n        float lbd = sdBox(b,vec2(0.,0.5));\n        lbd = min(lbd, sdBox(b - vec2(0.2,0.3),vec2(0.0,0.8)));\n        //ld = min(ld,boxdel);\n        lbd = sdBox(b - vec2(0.1,0.0),vec2(0.1,0.5));\n        ld = min(ld,abs(lbd));\n        \n        if(i == 0.)\n            boxdel = lbd;\n        \n        //boxdel = min(boxdel, sdBox(b - vec2(0.2,0.3),vec2(0.0,0.8)));\n        \n        \n        b *= rot(-0.25*pi);\n\t\t//ld = min(ld,sdBox(b,vec2(0.00,0.5)));\n        //ld = min(ld,abs(sdBox(pmod( (b -vec2(0.1,0.)),vec2(.3,0.1)),vec2(0.02,0.02))));\n        \n\n        vec4 q = vec4(b,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n\n\n        q = pmod(abs(q),0.05);\n\n        float dbq = sdBox(q,vec4(0.01 ));\n\n        float slider = smoothstep(0.,1.,i/its + 0.3 )*1.;\n\t\t\n        \n        ld = max(ld,-crem);\n        \n        float ldb = ld;\n        ld = mix(ld,abs(dbq),slider);\n\n\t\t\n        \n        ld = mix(ld,max(ld,ldb),slider);\n\n        \n        dt = min(dt,abs(ld));\n\n        dt = mix(dt, abs(pmod(dt ,0.04 )) ,slider);\n        dt = abs(dt) - 0.0001;\n        \n        float stars = starNoise((p + 0.04*envg)*rot(0.25*envg));\n        \n        stars = max(stars, max(abs(p.x),abs(p.y)) - 0.5*envc + envh*0.5);\n        \n        stars = max(stars, -sdTri(p,vec2(0.5,0.5)));\n        stars = max(stars, -boxdel);\n\n        \n        dt = min(dt, stars);\n\t\t\n        \n        dt = max(dt, -boxdel);\n        \n    }\n    d = min(d,dt); \n    \n    \n\n    \n    \n    //d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    if (abs(uv.x) > 0.5)\n        col -= col;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}