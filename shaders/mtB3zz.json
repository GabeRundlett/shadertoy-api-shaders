{
    "Shader": {
        "info": {
            "date": "1672760276",
            "description": "symbol1111",
            "flags": 0,
            "hasliked": 0,
            "id": "mtB3zz",
            "likes": 5,
            "name": "symbol1111",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "symbol",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "chenxianming",
            "viewed": 2232
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define count 1.\n#define smooth 0\n\nconst mat2 m = mat2(-1.1, -.4, .3, 1.0);\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise( in vec2 p) {\n    return sin(p.x) * sin(p.y);\n}\n\nfloat fbm4(vec2 p) {\n    float f = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        f += 1.5 * .1 * noise(p * i);\n        p = m * p * abs(i - 2.) * 2.3;\n    }\n\n    return f / 0.99999990;\n}\n\nvec2 fbm4_2(vec2 p) {\n    p += ( hash12( p * 50. + fract( iTime ) ) ) * -.001;\n   \n    return vec2(fbm4(p), fbm4(p + vec2(7.8)));\n}\n\nfloat myNoise( in vec2 f ){\n  f *= m;\n  return ( cos( f.x + .18975 ) * sin( f.y + .494516 ) + .1615246 );\n}\n\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        x *= rotation( float( i ) );\n        float a = pow( f, -H );\n        a = smoothstep( 0., .05, a );\n        \n        t += a*myNoise(f*x * rotation( float(i) ));\n\n    }\n    return t;\n}\n\n// iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 sdBezierExtrude(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    // check for colinear\n    //if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < 0.0001)\n    //    return sdLinearSegment(pos, A, C);\n\n\t// first, calc curve T value\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\tfloat t;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        // 1 root\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 _t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n\t\t// 3 roots, but only need two\n\t\tvec3 r1 = d + (c + b * _t.x) * _t.x;\n\t\tvec3 r2 = d + (c + b * _t.y) * _t.y;\n\t\t//t = length(r2.xyz) < length(r1.xyz) ? _t.y : _t.x;\n        t = dot(r2,r2) < dot(r1,r1) ? _t.y : _t.x; // quicker\n        \n    }\n    \n    vec3 _tan = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));  // spline tangent\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 binormal = normalize(cross(up, _tan));\n    vec3 _normal = cross(_tan, binormal);\n\n\tvec3 t1 = cross(_normal, _tan); // no need to normalize this?\n\tmat3 mm = mat3(t1, cross(_tan, t1), _tan);\n    pos.xyz = mix(mix(A, B, t), mix(B, C, t), t) - pos; // spline position\n    return vec4(pos.xyz*mm, t);\n}\n\nfloat calcSymbol( vec3 pos, bool isBg ){\n\n    vec3 p = pos;\n    \n    if( isBg ){\n        p.xy *= .5;\n        p.y -= .15;\n        p.z -= .1;\n        \n    }else{\n        p.xz *= rotation( iTime * .5 );\n    }\n\n    p += (fbm4_2(p.yz - iTime * ( isBg ? .1 : .2 ) ).y * ( isBg ? 2.5 : -2.5 ) * fbm4_2(p.xz- iTime * ( isBg ? .5 : 1. ) * .5).x * 2. * cos(p).y * 1.) * .6;\n    \n    vec3 v = vec3( 0. );\n    vec3 pOri = p;\n    \n    v = vec3( 0., 0., -5. );\n    \n    float d = length( pos + v ) - .1;\n    \n    vec3 a = vec3( -1., 0., 0. );\n    vec3 b = vec3( 0., 1.1, 0. );\n    vec3 c = vec3( 1.01, 0., 0. );\n\n    vec4 bz = sdBezierExtrude(p, a, b, c);\n\n    float g = sdBox(bz.xyz, vec3( .1, .1, .1 ) );\n\n    d = min( d, g );\n    \n    a = vec3( -1.4, -0.6, 0. );\n    b = vec3( .1, -1.45, 0. );\n    c = vec3( 1.04, -0.25, 0. );\n    \n    bz = sdBezierExtrude(p, a, b, c);\n    \n    d = min( d, sdBox(bz.xyz, vec3( .1, .1, .1 ) ) );\n    \n    p.xy *= rotation( PI * .25 );\n    \n    v = vec3( 0. );\n    v.x -= .71;\n    v.y += .91;\n    \n    p += v;\n    d = min( d, sdBox( p, vec3( .1 ) ) );\n    p = pOri;\n    \n    a = vec3( -1., 0., 0. );\n    b = vec3( 0., -.8, 0. );\n    c = vec3( .5, -0.25, 0. );\n    \n    bz = sdBezierExtrude(p, a, b, c);\n    \n    d = min( d, sdBox(bz.xyz, vec3( .1, .1, .1 ) ) );\n    \n    a = vec3( -.3, 0.1, 0. );\n    b = vec3( 0.3, .25, 0. );\n    c = vec3( .55, -0.15, 0. );\n    \n    bz = sdBezierExtrude(p, a, b, c);\n    \n    d = min( d, sdBox(bz.xyz, vec3( .1, .1, .1 ) ) );\n\n    v = vec3( 0. );\n    \n    p.xy *= rotation( PI * .25 );\n    \n    v.x -= .28;\n    v.y += .52;\n    \n    p += v;\n    d = min( d, sdBox( p, vec3( .1 ) ) );\n\n    if( isBg ){\n        d = pow( d, .9 );\n    }\n\n    return d;\n}\n\nfloat map(vec3 pos) {\n\n    float d = calcSymbol( pos, false );\n\n    float bg = calcSymbol( pos, true );\n    \n    d = min( d, bg * 1.6 );\n    \n    #if smooth==0\n    \n    vec3 p = pos;\n    \n    p = mod(p+0.4 * vec3(1.),vec3( 1.4, 1.4, .5 ))-0.4*vec3( 1. );\n    \n    float bg2 = calcSymbol( p, true );\n\n    d = min( d, bg2 * 2.1 );\n    \n    #endif\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time varying pixel color\n    float tt = iTime * .2;\n\n    uv = (uv - .5) * 2.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 origin = vec3(cos(tt) * -3.2, 0.0, sin(tt) * -3.2);\n    vec3 ta = vec3(0.0, 0., 0.0);\n\n    origin = vec3(0., 0., -3.2);\n\n    // camera matrix\n    vec3 ww = normalize(ta - origin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec3 ray = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = 0.0;\n\n    const float tmax = 5.0;\n\n    for (int i = 0; i < 18; ++i) {\n        vec3 p = origin + ray * t;\n        float distance = map(p);\n        t += distance * 0.9999;\n    }\n    \n    vec2 uv2 = ( fragCoord.xy / iResolution.xy - .5 ) * .01;\n    \n    vec3 col = vec3( fbm( vec2( fbm( uv2 - .5 - sin( atan( uv2.x, uv2.y ) + iTime * .1 ), 1. ) ), .1 ) * .00015 );\n    vec3 lig = normalize(vec3( cos( iTime ), .7, .9 ));\n    vec3 hal = normalize(lig - ray);\n    // vec3 spcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (t < tmax) {\n        vec3 pos = origin + t * ray;\n        vec3 nor = calcNormal(pos);\n\n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n        float p = fbm( vec2( fbm( nor.xy * .15 - iTime * .01, 1. ) ), 1.9 );\n        \n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n\n        col = spe + vec3( p * .3 + .5 ) * amb + vec3(.5) * dif + vec3(.3);\n    }\n\n    \n\n    // gamma        \n    col = sqrt(col);\n    tot += col;\n    \n    #if smooth == 1\n    \n    float px = hash12( uv * 50. + fract( iTime ) ) * .2;\n    tot = mix( tot, vec3( .1 ), px );\n    \n    #endif\n\n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}