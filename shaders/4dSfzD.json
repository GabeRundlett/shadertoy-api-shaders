{
    "Shader": {
        "info": {
            "date": "1499695827",
            "description": "This is a 14 tap hexagonal version of IQ's Voronoi line-distance formula, with some additional smoothing for the rounded look. It's nothing exciting, but has been included for completeness.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dSfzD",
            "likes": 20,
            "name": "Hexagonal Voronoi Line Distance",
            "published": 3,
            "tags": [
                "voronoi",
                "line",
                "hexagon",
                "distance",
                "edge",
                "bump"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1787
        },
        "renderpass": [
            {
                "code": "/*\n\n\tHexagonal Voronoi Line Distance\n\t-------------------------------\n\n\tAs the lacklustre title suggests, this is a hexagonal Voronoi implementation of the \n\t\"point to nearest cell edge distance\" formula. It uses fewer taps than the square\n\tgrid versions, but those gains are probably offset by the hexagonal transforms, etc. \n\tI kind of prefer the square grid version, but I thought it'd be nice to put this up \n\tfor comparison, and just in case someone required a reference.\n\n\tDr2 has been putting up a few hexagonal Voronoi examples lately. I was going to\n\tincorporate his code, but I thought I'd use one of my own versions, just to provide\n\ta mildly different perspective. It uses cheaper hexagonal transforms, but that may \n\tbe at the expense of less variation in point spread... I'm not sure.\n\n\tI did this for the novelty. Feel free to check out the Voronoi function, but it's\n\tpretty straight forward. Basically, you convert to a hexagonal grid, offset cell \n\tcenter points, find the nearest cell point, then perform another pass to determine the \n\tnearest edge to the nearest cell point. As you can see, the edges are pretty uniform.\n\n\tThe rest is just some very lazy prettying up. In case it isn't obvious, visually\n\tspeaking, this is just a rehash of my last example with a few simple changes. The\n\teffects are all fake. It's a essentially a bump mapped example with some shading to\n\tgive the impression of some shadowing.\n\n\t// Other examples:\n\n    // Another hexagonal Voronoi edge example using a more relaxed, but faster, method.\n    Voronoi Of The Week - Dr2\n\thttps://www.shadertoy.com/view/lsjBz1\n\n\t// The original point to nearest edge example.\n\tVoronoi distances - iq\n\thttps://www.shadertoy.com/view/ldl3W8\n\t// His well written article that describes the process in more detail.\n\t// https://iquilezles.org/articles/voronoilines\n\n*/\n\n//#define SCROLL\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    \n    #ifdef SCROLL\n    return fract(vec2(262144, 32768)*n); \n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    return sin( p*6.2831853 + iTime )*.5 + .5; \n    #endif\n}\n\n// IQ's polynomial-based smooth minimum function.\nfloat smin( float a, float b, float k ){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n    \n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n// Converting to the hexagonal grid.\nvec2 pixToHex(vec2 p){\n    \n    return floor(vec2(p.x + .57735*p.y, 1.1547*p.y) + 1./3.);\n}\n\n// Randomized hexagonal offset point.\nvec2 hexPt(vec2 p) {\n\n    // The offset value is restricted to the radius of the incircle of the\n    // hexagon, or apothem as it's technically known.\n    return vec2(p.x - p.y*.5, .8660254*p.y) + (hash22(p) - .5)*.8660254/2.;\n    \n}\n\n\n// Scene object ID, and individual cell IDs. Used for coloring.\nfloat objID; // The rounded web lattice, or the individual Voronoi cells.\n//vec2 cellID; // Individual Voronoi cell IDs.\n\n// This is a hexagonal variation on a regular 2-pass Voronoi traversal that produces\n// a Voronoi pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It uses element from an old hexagonal Voronoi example, \n// and is based on IQ's original example. It was inspired by Dr2's hexagonal examples.\n// The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to attempt to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Desert Town - dr2\n// https://www.shadertoy.com/view/XslBDl\nvec3 Voronoi(vec2 p){\n    \n    // Convert to the hexagonal grid.\n    vec2 pH = pixToHex(p); // Map the pixel to the hex grid.\n\n    // There'd be a heap of ways to get rid of this array and speed things up. The\n    // most obvious, would be unrolling the loops, but there'd be more elegant ways.\n    // Either way, I've left it this way just to make the code easier to read.\n \n    // Hexagonal grid offsets. \"vec2(0)\" represents the center, and the other offsets effectively circle it.\n    // Thanks, Abje. Hopefully, the compiler will know what to do with this. :)\n\tconst vec2 hp[7] = vec2[7](vec2(-1), vec2(0, -1), vec2(-1, 0), vec2(0), vec2(1), vec2(1, 0), vec2(0, 1)); \n    \n    \n    // Voronoi cell ID containing the minimum offset point distance. The nearest\n    // edge will be one of the cells edges.\n    vec2 minCellID = vec2(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec2 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., lMd = 8., lMd2 = 8., lnDist, d;\n    \n    for (int i=0; i<7; i++){\n    \n        // Determine the offset hexagonal point.\n        vec2 h = hexPt(pH + hp[i]) - p;\n        // Determine the distance metric to the point.\n    \td = dot(h, h);\n    \tif( d<md ){ // Perform updates, if applicable.\n            \n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = h; \n            //cellID = h + p; // For cell coloring.\n            minCellID = hp[i]; // Record the minimum distance cell ID.\n        }\n    }\n    \n    // Second pass: Point to nearest cell-edge distance.\n    //\n    // With the ID of the cell containing the closest point, do a sweep of all the\n    // surrounding cell edges to determine the closest one. You do that by applying\n    // a standard distance to a line formula.\n    for (int i=0; i<7; i++){\n    \n         // Determine the offset hexagonal point in relation to the minimum cell offset.\n        vec2 h = hexPt(pH + hp[i] + minCellID) - p - mo; // Note the \"-mo\" to save some operations. \n        \n        // Skip the same cell.\n        if(dot(h, h)>.00001){\n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article (link above) for a visual representation.            \n            lnDist = dot(mo + h*.5, normalize(h));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based\n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // Polynomial-based smooth minimum. The last factor controls the roundness of the \n            // edge joins. Zero gives you sharp joins, and something like \".25\" will produce a\n            // more rounded look.\n            lMd = smin(lMd, lnDist, .1);\n            // Exponential-based smooth minimum.\n            //lMd = sminExp(lMd, lnDist, 20.); \n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n            \n        }\n\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but I'm not \n    // positive. Although not used here, the standard minimum point distance is returned also.\n    return max(vec3(lMd, lMd2, md), 0.);\n    \n    \n}\n\n// This is a bit messy. I'll tidy it up later, but it's basically just playing with\n// the Voronoi isovalues to geometrically show some lines, and so forth.\nfloat bumpFunc(vec2 p){ \n\n    vec3 v = Voronoi(p*4.);\n\tfloat c = v.x; // Range: [0, 1]\n    \n    // ID - used for scene object coloring.\n    objID = 0.;\n    \n    const float edge = .08;\n    const float edge2 = .08;\n    \n    if( c<edge) { // Main outer borders.\n        c = ((edge - c)/edge)*.1;\n        objID = 1.;\n    }\n    else {\n       c = (v.x - edge)/(1. - edge);\n        \n       if(c>edge2) { // Inner cells.\n           objID = 2.;\n           c = (v.y - edge2)/(1. - edge2)*2.;\n           \n        }\n        else { // Dark, inner borders.\n            c = abs(c - edge2)/(1. - edge2);\n           \n        }\n    }\n    \n    // Return the manipulated Voronoi value.\n    return c;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n\n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane \n    // situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*0.15 + .1, sin(iTime)*0.15 + .1, -1.); // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n \n\t// Scrolling.\n    #ifdef SCROLL\n    sp.x -= iTime/8.;\n    lp.x -= iTime/8.;\n    #endif     \n\n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(2./iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    \n    float svObjID = objID; // Save the object ID here.\n    float fx = bumpFunc(sp.xy - eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy - eps.yx); // Same for the nearby sample in the Y-direction.\n  \n    float fx2 = bumpFunc(sp.xy + eps.xy); // Same for the nearby sample in the X-direction.\n    float fy2 = bumpFunc(sp.xy + eps.yx); // Same for the nearby sample in the Y-direction.\n    float edge = abs(fx + fy + fx2 + fy2 - 4.*f);//abs(fx - f)+ abs(fy - f);\n    edge = smoothstep(0., 8., edge/eps.x);//sqrt(edge/eps.x*8.)\n   \n \t// Controls how much the bump is accentuated.\n\tfloat bumpFactor = .1;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx - f)/eps.x; // Change in X\n    fy = (fy - f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n   \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1. + lDist*lDist*0.15);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth or the impression of ambient occlusion.\n    atten *= f*.7 + .3; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    //diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.); \n\n\t\n    // TEXTURE COLOR\n    //\n\t// Fake tri-planar texel lookup, and by that I mean, I've moved the Z-position up by a fraction\n    // of the heightmap amount to give the impression that this is a 3D lookup. The rest is a  regular\n    // tri-planar lookup. Not sure if it made a difference, but it can't hurt.\n    vec3 nsn = max(abs(sn), .001);\n    nsn /= dot(nsn, vec3(1));\n    vec3 texCol = vec3(0), txA, txB, txC;\n    sp.z = -f*.2; // Moving the Z position out a bit - That's the fake bit.\n    txA = texture(iChannel0, sp.xy*2.).xyz;\n    txB = texture(iChannel0, sp.zx*2.).xyz;\n    txC = texture(iChannel0, sp.yz*2.).xyz;\n    // Rough sRGB to linear conversion... That's a whole other conversation. :)\n    texCol = txA*txA*nsn.z + txB*txB*nsn.y + txC*txC*nsn.x; \n    texCol = smoothstep(.0, .5, texCol)*2.;\n \n    \n    if(svObjID>1.5) { // Salmon colored interior cells.\n        \n        texCol *= vec3(1.85, .7, .65);\n        // Some subtle leopard spot patterning.\n        texCol *= 1. - smoothstep(0., .05, Voronoi(sp.xy*32.).x - .025)*.25;\n        \n        // texCol = texCol.yzx; // Other colors, if you prefer. texCol.xzy, etc.\n        \n        \n    }\n    else if(svObjID>.5) { // Lighter outer edges.\n        texCol *= vec3(1.6, 1, .75);\n        // Some subtle reptilian patterning.\n        texCol *= smoothstep(0., .05, Voronoi(sp.xy*48.).x - .05)*.35 + .65;\n    }\n    else texCol *= .25; // Dark inner edges.\n        \n    \n\n\t// Mixing in some subtle purple for a bit more color variance. Made up on the spot.\n    texCol = mix(texCol, texCol.zyx, dot(sin(sp.xy*4. + cos(sp.yx*8.)), vec2(.0625)) + .125);\n         \n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol * (diff + 0.25) + vec3(.5, .7, 1)*spec*2.)*atten;\n\n    // Applying a subtle edge outline.\n    if(svObjID>1.5) col *= 1. - edge*.65;\n    else if(svObjID>.5) col *= 1. - edge*.35;\n\n    // Mixing in the gradient for some fake shadowing.\n    col *= min(mix(max(fx, 0.), max(fy, 0.), .5)*.5 + .25, 1.25);\n    \n    \n    \n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}