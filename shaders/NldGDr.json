{
    "Shader": {
        "info": {
            "date": "1635999450",
            "description": "Building off of my previous shader and some of the advice I got from FabriceNeyret2 here:\nhttps://www.shadertoy.com/view/7d3SDS\n\nThere is a lot more to learn from those comments in terms of golfing and coding in general.",
            "flags": 0,
            "hasliked": 0,
            "id": "NldGDr",
            "likes": 13,
            "name": "Simplex Experiment #2",
            "published": 3,
            "tags": [
                "triangles",
                "simplex"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "//barycentric\n#define eps 8./iResolution.y\n#define S smoothstep\n\n//#define cross2D(a,b) a.y*b.x-a.x*b.y\n#define cross2D(a,b) (a).y*(b).x-(a).x*(b).y\n//skew matrix often written as \n//mat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\nmat2 skew = mat2(2./sqrt(3.), 0., 1./sqrt(3.), 1.); \n\n//This hash is pretty bad\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\n\n// based on comments from FabriceNeyret2\n// https://www.shadertoy.com/view/7d3SDS\n// super elegant\nvec2 bary(vec2 A, vec2 B, vec2 C, vec2 P){\n    \n    //We want areas for the three triangles created\n    //with out point P and the 3 sides\n    //we get a triangle with vectors AtoB and AtoP\n    //Repeat with B and C\n    vec3 tri = vec3(length(cross2D(B-A,P-A)),\n                    length(cross2D(C-B,P-B)),\n                    length(cross2D(A-C,P-C))\n                    );\n    //If P is in the middle, all areas are equal\n    //If P lays between two sub triangles, those areas\n    //will be equal and there will be one other area\n    \n    \n    //chill sort to find the smallest area triangle\n   \n    //id which we will swap simultenously\n    vec3 id = vec3(1.,2.,3.);\n   \n    //swap to get minumum at x\n    //swap remaining two to get minumum at y\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    if(tri.y < tri.x) tri = tri.yxz, id = id.yxz;\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    //with tri sorted, can do smoothstep without abs\n    \n    \n    //Those areas become a coordinate system because together \n    //they tell us relatively how close P is to any of \n    //the three sides.\n    \n    //so \"borders\" are like with uv.x-uv.y but now 3d \n    //border of area1 and area2 like (uv.y-uv.x)\n    float f1 = S(0.,eps, tri.y-tri.x - 0.02);\n    //border of area1 and area3 (uv.z-uv.y)\n    float f2 = S(0.,eps, tri.z-tri.x - 0.02);\n    return vec2(id.x,f1*f2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 3.*(fragCoord*2.-iResolution.xy)/iResolution.y;\n    uv.x += iTime/4.;\n    uv *= skew;\n    vec2 uvFL = floor(uv);\n    uv = fract(uv);\n    \n    vec2 f = 1.0 - S(0., eps, abs(uv-0.5)-0.48 );\n    float fd =  S(0., eps, abs(uv.x-uv.y)-0.02 );\n    \n    float side = sign(uv.x-uv.y);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(vec3(0,2,4));\n    \n    vec2 stuff = bary(vec2(0.), \n                       vec2(1.,side<0.), \n                       vec2(side>0.,1.),\n                       uv);\n                       \n    col = 0.5 + 0.5*cos(vec3(1.,2.,4.)/3. + \n          badHash(uvFL+side*0.5 + stuff.x/3.)*80. + iTime/2. );\n  \n    col *= f.x;\n    col *= f.y;\n    col *= fd;\n    col *= stuff.y;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}