{
    "Shader": {
        "info": {
            "date": "1599756907",
            "description": "Area lights (sphere, line and rectangle) using the most representative point method. ",
            "flags": 32,
            "hasliked": 0,
            "id": "3dsBD4",
            "likes": 41,
            "name": "Area Lights",
            "published": 3,
            "tags": [
                "procedural",
                "brdf",
                "arealight",
                "ibl",
                "pbr",
                "ggx"
            ],
            "usePreview": 1,
            "username": "piyushslayer",
            "viewed": 1608
        },
        "renderpass": [
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* My implementation of 3 types of real-time area light sources (sphere, line, and rectangle).\n* See Buffer A for more details.\n*\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = textureLod(iChannel0, uv, 0.).rgb;\n    // for yucky color banding artifacts\n    col += hash12(fragCoord * iResolution.xy + vec2(iFrame)) * .00392;\n    fragColor = vec4(pow(col, vec3(.4545)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* Contains all the helper functions used by Buffer A for the area lights.\n*\n*/\n\n#define saturate(x) clamp(x, 0., 1.)\n#define dot2(x) dot(x, x)\n\n#define EPS .0002\n#define SMOL_EPS .0000002\n\n#define PI 3.1415926535\n#define TWO_PI 6.283185307\n#define PI_INV .3183098861\n\n#define DRAW_LIGHTS\n\n// enable/disable these for floor normal map and roughness\n#define FLOOR_DISPLACEMENT\n#define FLOOR_ROUGHNESS\n\n#define T (iTime * .25)\n\n#define SPHERE_LIGHT_POS vec3(9. * cos(T), 6. * abs(sin(T)) \\\n\t\t- .75 + SPHERE_LIGHT_RADIUS, 1.)\n#define SPHERE_LIGHT_RADIUS (sin(T) * .5 + .7)\n#define SPHERE_LIGHT_VOLUME_RADIUS 20.\n#define SPHERE_LIGHT_INTENSITY 256.\n            \n#define LINE_LIGHT_RADIUS (sin(T) * .075 + .125)\n#define LINE_LIGHT_VOLUME_RADIUS 20.\n#define LINE_LIGHT_INTENSITY 512.\n            \n#define RECT_LIGHT_RADIUS 4.\n#define RECT_LIGHT_INTENSITY 64.\n            \n#define LIGHT_COLOR vec3(1., .6, .3)\n            \n#define SPHERE_ALBEDO vec3(.2, .01, .6)\n#define REFLECTION_STEPS 8\n            \n#define SILVER_F0 vec3(.95, .93, .88)\n#define PLASTIC_F0 vec3(.05)\n\n#define CAMERA_POS vec3(0., 9., 21.)\n#define CAMERA_FAR 100.\n\nstruct Ray\n{\n    vec3 origin, direction;\n};\n    \nstruct Rect\n{\n\tvec3 center, a, b, c, d; \n\tvec3 up, right, front;\n    vec2 halfSize;\n};\n    \nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1. / float(0xffffffffU));\n}\n\nmat3 rotZ(float a)\n{\n\treturn mat3(cos(a), -sin(a), 0.,\n                sin(a),  cos(a), 0.,\n                \t0., \t 0., 1.);\n}\n\nvec3 rotateAround(vec3 v, vec3 k, float theta)\n{\n  return v * cos(theta) + cross(k, v) * sin(theta) + k * dot(k, v) * (1. - cos(theta));\n}\n\nmat3 getCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, lookAt);\n}\n\nRay getCameraRay(vec2 uv)\n{\n    vec3 origin = CAMERA_POS;\n    vec3 target = vec3(0., 1., 0.);\n    mat3 camera = getCameraMatrix(origin, target);\n    vec3 direction = normalize(camera * vec3(uv, 2.5));\n    return Ray(origin, direction);\n}\n\nvoid initRect(out Rect rect, float t)\n{\n    rect.up = vec3(0., 0., 1.);\n    rect.right = vec3(1., 0., 0.);\n    rect.front = normalize(cross(rect.right, rect.up));\n    vec2 widthScale = vec2(cos(t), sin(t)) * .25 + .75;\n    rect.halfSize = vec2(2.5, 1.5) * widthScale;\n    \n    rect.center = vec3(0., 6., sin(t) * 4. - 1.5);\n    \n    rect.a = rect.center + rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.b = rect.center - rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;\n    rect.c = rect.center - rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n    rect.d = rect.center + rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;\n}\n\n\n// Based on the technique in EA's frostbite engine\nfloat rectSolidAngle(vec3 p, vec3 v0, vec3 v1, vec3 v2, vec3 v3)\n{\n    vec3 n0 = normalize(cross(v0, v1));\n    vec3 n1 = normalize(cross(v1, v2));\n    vec3 n2 = normalize(cross(v2, v3));\n    vec3 n3 = normalize(cross(v3, v0));\n    \n    float g0 = acos(dot(-n0, n1));\n\tfloat g1 = acos(dot(-n1, n2));\n\tfloat g2 = acos(dot(-n2, n3));\n\tfloat g3 = acos(dot(-n3, n0));\n    \n    return g0 + g1 + g2 + g3 - 2. * PI;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* My implementation of 3 types of area light sources (sphere, line, and rectangle). Based on most \n* representative point techniques by Brian Karis (Epic) and SÃ©bastien Lagarde (Unity). The general\n* idea is to calculate the location of a point light on the surface of the light source and use that\n* point as the light direction to calculate the diffuse and specular components of the area light. \n*\n* https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n* https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n*\n*/\n\nvec3 lineStart, lineEnd;\nRect rect;\n\nvec2 sdUnion(vec2 a, vec2 b)\n{\n \treturn a.x < b.x ? a : b;  \n}\n\nfloat sdPlane(vec3 pos, float height)\n{\n\tfloat plane = pos.y - height;\n#ifdef FLOOR_DISPLACEMENT\n    return plane - textureLod(iChannel0, pos.xz * .04, 0.).r * .01;   \n#else\n    return plane;\n#endif\n}\n\nfloat sdPlaneNoDisplacement(vec3 pos, float height)\n{\n\treturn pos.y - height;\n}\n\nfloat sdSphere(vec3 position, vec3 center, float radius)\n{\n\treturn length(position - center) - radius;   \n}\n\nfloat sdCapsule(vec3 position, vec3 start, vec3 end, float radius)\n{\n    vec3 pa = position - start, ba = end - start;\n    float h = saturate(dot(pa, ba) / dot(ba, ba));\n    return length(pa - ba * h) - radius;\n}\n\nfloat sdRect(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross(ba, ad);\n\n    return sqrt(\n        (sign(dot(cross(ba, nor), pa)) +\n         sign(dot(cross(cb, nor), pb)) +\n         sign(dot(cross(dc, nor), pc)) +\n         sign(dot(cross(ad, nor), pd)) < 3.)\n\n        ?\n\n        min(min(min(\n\t\tdot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa),\n\t\tdot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)),\n\t\tdot2(dc * clamp(dot(dc, pc) / dot2(dc), 0., 1.) - pc)),\n\t\tdot2(ad * clamp(dot(ad, pd) / dot2(ad), 0., 1.) - pd))\n        \n        :\n        \n        dot(nor, pa) * dot(nor, pa) / dot2(nor) \n    );\n}\n\nvec2 sdScene(vec3 pos)\n{\n\tvec2 result = sdUnion(vec2(sdPlaneNoDisplacement(pos, -.75), 3.), \n\t\t\t\t\t\tvec2(sdSphere(pos, vec3(-4.5, .75, 0.), 1.5), 1.05));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(-1.5, .75,0.), 1.5), 1.25));\n    \n\tresult = sdUnion(result, vec2(sdSphere(pos, vec3(1.5, .75, 0.), 1.5), 1.45));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(4.5, .75, 0.), 1.5), 1.65));\n\n#ifdef DRAW_LIGHTS\n\tresult = sdUnion(result, vec2(sdSphere(pos, SPHERE_LIGHT_POS, SPHERE_LIGHT_RADIUS),\n                                  0.));\n    \n    result = sdUnion(result, vec2(sdCapsule(pos, lineStart, lineEnd, \n                                          LINE_LIGHT_RADIUS), 0.));\n    \n    result = sdUnion(result, vec2(sdRect(pos, rect.a, rect.b, rect.c, rect.d), 0.));\n#endif\n    \n    return result;\n}\n\nvec2 sdSceneNormal(vec3 pos)\n{\n\tvec2 result = sdUnion(vec2(sdPlane(pos, -.75), 3.), \n\t\t\t\t\t\tvec2(sdSphere(pos, vec3(-4.5, .75, 0.), 1.5), 1.05));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(-1.5, .75, 0.), 1.5), 1.25));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(1.5, .75, 0.), 1.5), 1.45));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(4.5, .75, 0.), 1.5), 1.65));\n    \n    return result;\n}\n\nvec2 sdSceneNoLights(vec3 pos)\n{\n\tvec2 result = sdUnion(vec2(sdPlaneNoDisplacement(pos, -.75), 3.), \n\t\t\t\t\t\tvec2(sdSphere(pos, vec3(-4.5, .75, 0.), 1.5), 1.05));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(-1.5, .75, 0.), 1.5), 1.25));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(1.5, .75, 0.), 1.5), 1.45));\n    \n    result = sdUnion(result, vec2(sdSphere(pos, vec3(4.5, .75, 0.), 1.5), 1.65));\n    \n    return result;\n}\n\nvec3 calculateNormal(vec3 pos)\n{\n\tvec2 eps = vec2(EPS, 0.);\n    return normalize(vec3(sdSceneNormal(pos + eps.xyy).x, \n                          sdSceneNormal(pos + eps.yxy).x, \n                          sdSceneNormal(pos + eps.yyx).x) \n                     - sdSceneNormal(pos).x);\n}\n\nvec2 rayMarch(Ray ray)\n{\n\tfloat dist = 0.;\n    vec2 result = vec2(-1.);\n    for(int i = 0; i < 128; ++i)\n    {  \n        result = sdScene(ray.origin + ray.direction * dist);\n        if (result.x < EPS * dist || dist >= CAMERA_FAR) break;\n        dist += result.x;\n    }\n\n    if (dist >= CAMERA_FAR) result.y = -1.;\n    return vec2(dist, result.y);\n}\n\nvec2 rayMarchNoLights(Ray ray)\n{\n\tfloat dist = 0.;\n    vec2 result = vec2(-1.);\n    for(int i = 0; i < 64; ++i)\n    {  \n        result = sdSceneNoLights(ray.origin + ray.direction * dist);\n        if (result.x < EPS * dist || dist >= CAMERA_FAR) break;\n        dist += result.x;\n    }\n\n    if (dist >= CAMERA_FAR) result.y = -1.;\n    return vec2(dist, result.y);\n}\n#if 1\nfloat softShadow(Ray ray)\n{\n \tfloat shadow = 1., dist = 0.;\n    for (int i = 0; i < 64; ++i)\n    {\n        vec2 result = sdSceneNoLights(ray.origin + ray.direction * dist);\n        if (result.y > 0.)\n        {\n            // iq's soft shadow hack\n            shadow = min(shadow, .5 + .5 * result.x / (.125 * dist));\n            if (shadow < 0.) break;\n            dist += clamp(result.x, .005, .5);\n        }\n    }\n    return smoothstep(0., 1., max(shadow, 0.));\n}\n#else\nfloat softShadow(Ray ray)\n{\n    float t = 0.;\n\tfor(int i = 0; i < 64; ++i)\n    {\n        float h = sdSceneNoLights(ray.origin + ray.direction * t).x;\n        if (h < EPS)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;   \n}\n#endif\n\nfloat normalDistributionGGXSphere(float NdotH, float alpha, float alphaPrime)\n{\n    float alpha2 = alpha * alpha;\n    float alphaPrime2 = alphaPrime * alphaPrime;\n    float NdotH2 = NdotH * NdotH;\n    \n    return \n        \t\t\t (alpha2 * alphaPrime2)\n    \t/ /*----------------------------------------*/\n        \t  pow(NdotH2 * (alpha2 - 1.) + 1., 2.);      \n}\n\nfloat normalDistributionGGXLine(float NdotH, float alpha, float alphaPrime)\n{\n    float alpha2 = alpha * alpha;\n    float alphaPrime2 = alphaPrime * alphaPrime;\n    float NdotH2 = NdotH * NdotH;\n    \n    return \n        \t\t\t (alpha2 * alphaPrime)\n    \t/ /*----------------------------------------*/\n        \t  pow(NdotH2 * (alpha2 - 1.) + 1., 2.);      \n}\n\nfloat normalDistributionGGXRect(float NdotH, float alpha, float alphaPrime)\n{\n    float alpha2 = alpha * alpha;\n    float alpha4 = alpha2 * alpha2;\n    float alphaPrime3 = alphaPrime * alphaPrime * alphaPrime;\n    float NdotH2 = NdotH * NdotH;\n    \n    return \n        \t\t\t \t(alpha2 * alphaPrime3)\n    \t/ /*-------------------------------------------------*/\n        \t  \t(pow(NdotH2 * (alpha2 - 1.) + 1., 2.));      \n}\n\n// Schlick-Beckmann GGX approximation used for smith's method\nfloat geometrySchlickGGX(float NdotX, float k)\n{\n    return \n        \t\t\t\t\tNdotX\n    \t/ /*----------------------------------------*/\n    \t  \t  max(NdotX * (1. - k) + k, SMOL_EPS);\n}\n\nfloat geometrySmith(float NdotV, float NdotL, float roughness)\n{\n \tfloat roughnessplusone = roughness + 1.;\n    float k = roughnessplusone * roughnessplusone / 8.;\n    \n    return geometrySchlickGGX(NdotV, k) * geometrySchlickGGX(NdotL, k);\n}\n\n// Schlick's approximation for Fresnel equation\nvec3 fresnelSchlick(vec3 F0, float dotProd)\n{\n    return F0 + (1. - F0) * pow(1. - dotProd, 5.);\n}\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    // Generated using google filament cmgen tool\n    return max(\n          vec3( .754554516862612,  .748542953903366,  .790921515418539)\n        + vec3(-.083856548007422,  .092533500963210,  .322764661032516) * (n.y)\n        + vec3( .308152705331738,  .366796330467391,  .466698181299906) * (n.z)\n        + vec3(-.188884931542396, -.277402551592231, -.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    // https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\n    const vec4 c0 = vec4(-1., -.0275,  -.572,  .022);\n    const vec4 c1 = vec4( 1.,  .0425,  1.040, -.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec4 sphereLight(vec3 p, vec3 n, vec3 v, vec3 r, vec3 f0, float NdotV, float roughness,\n                 float metalness, out vec3 fresnel, out float attenuation)\n{\n    vec3 L = (SPHERE_LIGHT_POS - p);\n    vec3 centerToRay = dot(L, r) * r - L;\n    vec3 closestPoint = L + centerToRay * saturate(SPHERE_LIGHT_RADIUS\n\t\t\t\t\t\t\t\t/ length(centerToRay));\n    vec3 l = normalize(closestPoint);\n    vec3 h = normalize(v + l);\n    float lightDist = length(closestPoint);\n    \n    float NdotL = max(dot(n, l), 0.);\n    float NdotH = max(dot(n, h), 0.);\n    float VdotH = max(dot(h, v), 0.);\n    \n    attenuation = pow(saturate(1. - pow(lightDist / SPHERE_LIGHT_VOLUME_RADIUS, 4.)), 2.)  \n            \t\t\t\t\t/ (lightDist * lightDist + 1.);\n        \n\tattenuation *= softShadow(Ray(p + n * EPS, l));\n    \n    float alpha = roughness * roughness;\n    float alphaPrime = saturate(alpha + (SPHERE_LIGHT_RADIUS / (2. * lightDist)));\n    \n    fresnel = fresnelSchlick(f0, VdotH);\n    vec3 specular = normalDistributionGGXSphere(NdotH, alpha, alphaPrime)\n        * geometrySmith(NdotV, NdotL, roughness)\n        * fresnel;\n    \n \treturn vec4(specular, NdotL);   \n}\n\nvec4 lineLight(vec3 p, vec3 n, vec3 v, vec3 r, vec3 f0, float NdotV, float roughness,\n                 float metalness, out vec3 fresnel, out float attenuation)\n{\n    vec4 result = vec4(0.);\n    vec3 l0 = lineStart - p, l1 = lineEnd - p;\n    float lengthL0 = length(l0), lengthL1 = length(l1);\n    float NdotL0 = dot(n, l0) / (2. * lengthL0);\n    float NdotL1 = dot(n, l1) / (2. * lengthL1);\n    result.w = (2. * saturate(NdotL0 + NdotL1)) / \n        \t (lengthL0 * lengthL1 + dot(l0, l1) + 2.); // NdotL\n    \n    vec3 ld = l1 - l0;\n    float RdotL0 = dot(r, l0);\n    float RdotLd = dot(r, ld);\n    float L0dotLd = dot(l0, ld);\n    float distLd = length(ld);\n    \n    float t = (RdotL0 * RdotLd - L0dotLd ) / (distLd * distLd - RdotLd * RdotLd);\n    \n    // point on the line\n    vec3 closestPoint = l0 + ld * saturate(t);\n    // point on the tube based on its radius\n    vec3 centerToRay = dot(closestPoint, r) * r - closestPoint;\n    closestPoint = closestPoint + centerToRay * saturate(LINE_LIGHT_RADIUS \n\t\t\t\t\t\t/ length(centerToRay));\n    vec3 l = normalize(closestPoint);\n    vec3 h = normalize(v + l);\n    float lightDist = length(closestPoint);\n    \n    float NdotH = max(dot(n, h), 0.);\n    float VdotH = dot(h, v);\n    \n    float denom = lightDist / LINE_LIGHT_VOLUME_RADIUS;\n    attenuation = 1. / (denom * denom + 1.);\n        \n\tattenuation *= softShadow(Ray(p + n * EPS, normalize(l0 + ld * .5)));\n    \n    float alpha = roughness * roughness;\n    float alphaPrime = saturate(alpha + (LINE_LIGHT_RADIUS / (2. * lightDist)));\n    \n    fresnel = fresnelSchlick(f0, VdotH);\n    result.xyz = normalDistributionGGXLine(NdotH, alpha, alphaPrime)\n        * geometrySmith(NdotV, result.w, roughness)\n        * fresnel;\n    \n    return result;\n}\n\nvec3 rayPlaneIntersect(Ray ray)\n{\n   return ray.origin + ray.direction * (dot(rect.front, rect.center - ray.origin)\n\t\t\t\t\t\t\t\t\t\t/ dot(rect.front, ray.direction));\n}\n\nvec4 rectLight(vec3 p, vec3 n, vec3 v, vec3 r, vec3 f0, float NdotV, float roughness,\n                 float metalness, out vec3 fresnel, out float attenuation)\n{\n \tvec4 result = vec4(0.);\n    \n    // facing side check\n    float windingCheck = dot(cross(rect.right, rect.up), rect.center - p);\n    if (windingCheck > 0.)\n        return result;\n    \n    vec3 v0 = rect.a - p;\n    vec3 v1 = rect.b - p;\n    vec3 v2 = rect.c - p;\n    vec3 v3 = rect.d - p;\n    \n    float solidAngle = rectSolidAngle(p, v0, v1, v2, v3);\n    \n    // diffuse\n    result.w = solidAngle * .2 * (\n        saturate(dot(normalize(v0), n)) +\n        saturate(dot(normalize(v1), n)) +\n        saturate(dot(normalize(v2), n)) +\n        saturate(dot(normalize(v3), n)) +\n        saturate(dot(normalize(rect.center - p), n)));    \n    \n    attenuation = softShadow(Ray(p + n * EPS, normalize(rect.center)));\n    \n    // specular\n\tRay rectRay = Ray(p, r);\n    vec3 planePointCenter = rayPlaneIntersect(rectRay) - rect.center;\n    // project point on the plane on which the rectangle lies\n    vec2 planePointProj = vec2(dot(planePointCenter, rect.right), \n                               dot(planePointCenter, rect.up));\n    // translate the point to the top-right quadrant of the rectangle, project it on\n    // the rectangle or its edge and translate back using sign of the original point.\n    vec2 c = min(abs(planePointProj), rect.halfSize) * sign(planePointProj);\n    vec3 L = rect.center + rect.right * c.x + rect.up * c.y - p;\n    \n    vec3 l = normalize(L);\n    vec3 h = normalize(v + l);\n    float lightDist = length(L);\n    \n    float NdotH = max(dot(n, h), 0.);\n    float VdotH = dot(h, v);\n\n    float alpha = roughness * roughness;\n    float alphaPrime = saturate(alpha + (RECT_LIGHT_RADIUS / (2. * lightDist)));\n    \n    fresnel = fresnelSchlick(f0, VdotH);\n    result.xyz = normalDistributionGGXRect(NdotH, alpha, alphaPrime)\n        * geometrySmith(NdotV, result.w, roughness)\n        * fresnel;\n    \n    return result;\n}\n\nvec3 renderScene(Ray ray)\n{\n    // update line light position & rotation\n    //float t = iTime * .25;\n    vec3 lineRotation = vec3(2., 0., 0.) * rotZ(T);\n    vec3 linePosition = vec3(6. * sin(T), 3., 5.);\n    lineStart = linePosition - lineRotation;\n    lineEnd = linePosition + lineRotation;\n    \n\tinitRect(rect, T);\n    \n    vec3 col = vec3(0.);\n    vec2 marchResult = rayMarch(ray);\n    vec3 position = ray.origin + ray.direction * marchResult.x;\n    vec3 normal = calculateNormal(position);\n    vec3 viewDirection = -ray.direction;\n    vec3 reflectDirection = reflect(ray.direction, normal);\n    \n    float NdotV = max(dot(normal, viewDirection), 0.);\n    \n    vec3 albedo = SPHERE_ALBEDO;\n    \n    float roughness = fract(marchResult.y), metalness = .88;\n    vec3 reflectance = SILVER_F0;  \n\n    if (marchResult.y > -1.)\n    {\n        if (marchResult.y > 2.)\n        {\n            albedo = pow(textureLod(iChannel0, position.xz * .18, 0.).rgb, vec3(2.2));\n#ifdef FLOOR_ROUGHNESS\n            roughness = albedo.r * .5;\n#else\n            roughness = .05;\n#endif\n            metalness = .05;\n            reflectance = PLASTIC_F0;\n        }\n        else if (marchResult.y < .5)\n            return LIGHT_COLOR * RECT_LIGHT_INTENSITY;\n        \n        vec3 F0 = mix(reflectance, albedo, metalness);\n        \n        vec3 sphereLightFresnel = vec3(0.);\n        float sphereLightAttenuation = 1.;\n        vec4 sphereLightDiffSpec = sphereLight(position, normal, viewDirection, \n\t\t\t\treflectDirection, F0, NdotV, roughness, metalness, sphereLightFresnel, \n\t\t\t\tsphereLightAttenuation);\n        vec3 sphereLightKd = 1. - sphereLightFresnel;\n    \tsphereLightKd *= 1. - metalness;\n\n        vec3 lineLightFresnel = vec3(0.);\n        float lineLightAttenuation = 1.;\n        vec4 lineLightDiffSpec = lineLight(position, normal, viewDirection, \n\t\t\t\treflectDirection, F0, NdotV, roughness, metalness, lineLightFresnel, \n\t\t\t\tlineLightAttenuation);\n        vec3 lineLightKd = 1. - lineLightFresnel;\n        lineLightKd *= 1. - metalness;\n        \n        vec3 rectLightFresnel = vec3(0.);\n        float rectLightAttenuation = 1.;\n        vec4 rectLightDiffSpec = rectLight(position, normal, viewDirection, \n\t\t\t\treflectDirection, F0, NdotV, roughness, metalness, rectLightFresnel, \n\t\t\t\trectLightAttenuation);\n\t\tvec3 rectLightKd = 1. - rectLightFresnel;\n        rectLightKd *= 1. - metalness;\n        \n        col += (sphereLightKd * PI_INV * albedo + sphereLightDiffSpec.xyz)\n            * SPHERE_LIGHT_INTENSITY * sphereLightDiffSpec.w * sphereLightAttenuation;\n        \n        col += (lineLightKd * PI_INV * albedo + lineLightDiffSpec.xyz)\n            * LINE_LIGHT_INTENSITY * lineLightDiffSpec.w * lineLightAttenuation;\n\n        col += (rectLightKd * PI_INV * albedo + rectLightDiffSpec.xyz)\n            * RECT_LIGHT_INTENSITY * rectLightDiffSpec.w * rectLightAttenuation;\n        \n        col += albedo * .025; // global ambient\n        \n        // calculate glossy reflection + ibl\n        float glossiness = roughness * roughness;\n        vec3 indirectSpecular = vec3(.1125, .1875, .25) + reflectDirection.y * .35;\n        Ray reflectRay = Ray(position, vec3(0.));\n        for (int i = 0; i < REFLECTION_STEPS; ++i)\n        {\n\t\t\tfloat percentage = float(i) / float(REFLECTION_STEPS);\n            vec3 delta = rotateAround(vec3(0., 1., 0.), reflectDirection, \n                                      TWO_PI * percentage);\n\t\t\treflectRay.direction = normalize(delta * glossiness + reflectDirection);\n        \tvec2 indirectMarchResult = rayMarchNoLights(reflectRay);\n            \n            if (floor(indirectMarchResult.y) == 3.)\n            {\n                vec3 indirectPosition = position + indirectMarchResult.x\n                    \t* reflectRay.direction;\n                indirectSpecular += textureLod(iChannel0, indirectPosition.xz * .18, 0.).rgb;\n            }  \n            else if(floor(indirectMarchResult.y) == 1.)\n                indirectSpecular += SPHERE_ALBEDO;\n\t\t\t\n        }\n        \n        indirectSpecular /= float(REFLECTION_STEPS);\n        \n        vec2 dfg = PrefilteredDFG_Karis(roughness, NdotV);\n        vec3 specularColor = F0 * dfg.x + dfg.y;\n        vec3 ibl = indirectSpecular * specularColor\n            + Irradiance_SphericalHarmonics(normal) * PI_INV * albedo;\n        \n        col += ibl * .84;\n        col *= LIGHT_COLOR;\n    }   \n\n    // fog\n    return mix(col, vec3(.01, .006, .004), // brown-ish fog color\n               \t\tclamp(1. - exp(-marchResult.x * .08), 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blueNoise = texelFetch(iChannel1,\n\t\t\t\t\t\t(iFrame * ivec2(113, 127)) & 63, 0).rg;\n    vec2 uv = (2. * (fragCoord + blueNoise) - iResolution.xy) / iResolution.y;\n    vec2 st = fragCoord / iResolution.xy;\n    \n    Ray ray = getCameraRay(uv);\n    \n    vec3 col = renderScene(ray);\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A basic TAA implementation based on the variance clipping technique by Marco Salvi (Nvidia).\n*\n*/\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0),  ivec2(0, -1), \n\tivec2(0, 1),  ivec2(-1, 0)\n);\n\nconst float gaussian[8u] = float[]\n(\n    .0625, .0625,\n    .0625, .0625,\n    .125,  .125,\n    .125,  .125\n);\n\nvec3 RGBToYCoCg(vec3 RGB)\n{\n    float Y = dot(RGB, vec3(1, 2,  1))  * .25;\n    float Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.);\n    float Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg)\n{\n    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - (.5 * 256. / 255.);\n\tfloat Cg= YCoCg.z - (.5 * 256. / 255.);\n\tfloat R= Y + Co - Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 currentBuffer = RGBToYCoCg(textureLod(iChannel0, uv, 0.).rgb);\n    vec3 historyBuffer = RGBToYCoCg(textureLod(iChannel1, uv, 0.).rgb);\n\n    vec3 mean = currentBuffer;\n    vec3 variance = currentBuffer * currentBuffer;\n    vec3 filtered = currentBuffer * .25;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 neighborTexel = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy) + offsets[i], 0).rgb);\n        mean += neighborTexel;\n        variance += neighborTexel * neighborTexel;\n        filtered += neighborTexel * gaussian[i];\n    }\n    \n    mean /= 9.;\n    variance /= 9.;\n    const float stDevMultiplier = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean));\n\tvec3 colorMin = min(filtered, mean - stDevMultiplier * sigma);\n\tvec3 colorMax = max(filtered, mean + stDevMultiplier * sigma);\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n    \n    vec3 outColor = mix(historyBuffer, filtered, .05);\n\n\tfragColor = vec4(YCoCgToRGB(outColor), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}