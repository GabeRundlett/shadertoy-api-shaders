{
    "Shader": {
        "info": {
            "date": "1706467506",
            "description": "Remainder of x/y: green is positive, red is negative, blue is zero.\nLeft-click to select division method:\nBottom-left - native (whatever your GLSL implementation does).\nBottom-right - truncated (same as C99/C++11).\nTop-left - floor.\nTop-right - euclidean.",
            "flags": 0,
            "hasliked": 0,
            "id": "lcSXRG",
            "likes": 6,
            "name": "Integer division",
            "published": 3,
            "tags": [
                "glsl",
                "integer",
                "division"
            ],
            "usePreview": 1,
            "username": "FordPerfect",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Since the GLSL spec VERY HELPFULLY declares\n// that the result of signed integer devision is\n// undefined when either of the arguments is negative,\n// several manual implementations are provided.\n// NOTE: this is written to produce well-defined\n// correct results for all inputs, not for performance,\n// nor conciseness.\n// NOTE: the GLSL spec DOES provide more guarantees\n// then e.g. C/C++ Standards regarding '+', '-',\n// '*' and shifts in signed integer arithmetic. This\n// code DOES rely on said guarantees and, as such,\n// may not be correct in C/C++ out of the box.\n// The provided division/modulo methods (see\n// e.g. https://en.wikipedia.org/wiki/Modulo#Variants_of_the_definition\n// for details) are (x/y produces quotient q and remainder r):\n// 1. Truncating division (standardized in C99/C++11):\n//     q=trunc(x/y)\n// 2. Floor division (advocated by Donald Knuth):\n//     q=floor(x/y)\n// 3. Euclidean division (standard in mathematics):\n//     0<=r<abs(y)\n// All of these additionally satisfy q*y+r=x (which\n// makes the result unique).\n// If y=0 (so the division is undefined), the arbitrarily\n// chosen well-defined value (0,0) is returned instead.\n// If the result cannot be expressed in target type\n// (INT_MIN/-1), the value congruent to the\n// result modulo 2^32 is returned.\n// NOTE: the euclidean division is the only one\n// that, for y=1<<n (0<=n<32), is equivalent\n// to (x>>n,x&(y-1)).\n// All implementations produce quotient in x-part,\n// and remainder in y-part of an ivec2.\n\n// Unsigned abs(), to deal with INT_MIN.\nuint uabs(int x) {return x<0?-uint(x):uint(x);}\n\nivec2 NATIVE(int x,int y)\n{\n    return ivec2(x/y,x%y);\n}\n\nivec2 TRUNCATED(int x,int y)\n{\n    if(y==0) return ivec2(0,0); // Arbitrary well-defined result on error.\n    int q=int(uabs(x)/uabs(y)),r=int(uabs(x)%uabs(y));\n    return ivec2((x^y)<0?-q:q,x<0?-r:r);\n}\n\nivec2 FLOOR(int x,int y)\n{\n    if(y==0) return ivec2(0,0); // Arbitrary well-defined result on error.\n    int q=int(uabs(x)/uabs(y)),r=int(uabs(x)%uabs(y));\n    if((x^y)<0&&r!=0) {q=q+1;r=int(uabs(y))-r;}\n    return ivec2((x^y)<0?-q:q,y<0?-r:r);\n}\n\nivec2 EUCLIDEAN(int x,int y)\n{\n    if(y==0) return ivec2(0,0); // Arbitrary well-defined result on error.\n    int q=int(uabs(x)/uabs(y)),r=int(uabs(x)%uabs(y));\n    if(x<0&&r!=0) {q=q+1;r=int(uabs(y))-r;}\n    return ivec2((x^y)<0?-q:q,r);\n}\n\nivec2 DIVMOD(int x,int y)\n{\n    switch(int(2.0*abs(iMouse.z)/iResolution.x)+2*int(2.0*abs(iMouse.w)/iResolution.y))\n    {\n        case 0: return NATIVE(x,y);\n        case 1: return TRUNCATED(x,y);\n        case 2: return FLOOR(x,y);\n        case 3: return EUCLIDEAN(x,y);\n    }\n    return ivec2(0,0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    xy*=8.0;\n    ivec2 z=ivec2(roundEven(xy));\n    ivec2 id=DIVMOD(z.x,z.y);\n    vec3 col=vec3(0.375);\n    if(z.x==0||z.y==0) col*=0.5;\n    col*=smoothstep(0.5,0.5-fwidth(xy.x),abs(xy.x-roundEven(xy.x)));\n    col*=smoothstep(0.5,0.5-fwidth(xy.y),abs(xy.y-roundEven(xy.y)));\n    vec2 t=(id.y>-10&&id.y<+10?\n        vec2(abs(float(id.y)/16.0),0.75):\n        vec2(1.0-1.0/16.0,0.75));\n    col=mix(\n        col,\n        (id.y<0?vec3(0.9,0.5,0.5):(id.y==0?vec3(0.2,0.8,0.8):vec3(0.2,0.8,0.2))),\n        min(1.5*texture(iChannel0,fract(xy-0.5)/16.0+t,0.75).x,1.0));\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}