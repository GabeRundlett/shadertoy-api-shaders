{
    "Shader": {
        "info": {
            "date": "1665085749",
            "description": "Playing too much with fractals and weird sounds can hurt your mind.",
            "flags": 0,
            "hasliked": 0,
            "id": "stKBzt",
            "likes": 5,
            "name": "Fork Fractal An NikolaErce 712",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "kifs"
            ],
            "usePreview": 0,
            "username": "NikolaErceg",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[7]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) \n{\n\tc=mod(c,7.); // cycle palette\n\tint p=0;\n\tvec3 color=vec3(0.);\n\tfor(int i=0;i<7;i++) {\n\t\tif (float(i)-c<=.0) { // check loop index against color value\n\t\t\tcolor=palette[i]; // store color picked\t\n\t\t}\n\t}\n\treturn color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) \n{\n    s*=.5;\n    c=mod(c-.5,7.);\n    vec3 color1=vec3(0.0),color2=vec3(0.0);\n    for(int i=0;i<7;i++) {\n        if (float(i)-c<=.0) {\n            color1 = palette[i];\n            color2 = palette[(i+1>6)?0:i+1];\n        }\n    }\n    // smooth mix the two colors\n    return mix(color1,color2,smoothstep(.5-s,.5+s,fract(c)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// define the colors \n\tpalette[6]=vec3(255,000,000)/255.;\n\tpalette[5]=vec3(255,127,000)/255.;\n\tpalette[4]=vec3(255,255,000)/255.;\n\tpalette[3]=vec3(150,050,050)/255.;\n\tpalette[2]=vec3(000,050,50)/255.;\n\tpalette[1]=vec3(075,000,130)/255.;\n\tpalette[0]=vec3(143,000,255)/255.;\n\t\n\tvec3 color=vec3(0.);\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\tif (uv.x>.9) { \n\t\tcolor=getsmcolor(uv.y*7.+iTime*.5,.25+.75*abs(sin(iTime))); //gradient function\n\t} else if (uv.x<.1) {\n\t\tcolor=getcolor(uv.y*7.-iTime*.5); // basic function\n\t} \n\n\tvec2 p=(uv-.5);\n\tp.x*=iResolution.x/iResolution.y;\n\t\n\n\t// fractal\n    float a=iTime*.50;\t\n    float b=iTime*1.;\t\n\tfloat ot=1000.;\n\tmat2 rot=mat2(cos(a),sin(a),-sin(a),cos(a));\n\tp+=sin(b)*.005;\n    float l=length(p);\n    for(int i=0;i<15;i++) {\n\t\tp*=rot;\n        p=abs(p)*1.2-1.;\n        ot=min(ot,abs(dot(p,p)-sin(b+l*20.)*.015-.15)); //orbit trap\n\t}\n\tot=max(0.,.1-ot)/.1; //orbit trap \n\tif (length(max(vec2(0.),abs(uv-.5)-vec2(.485,.47)))>0.0) color*=0.; // border \t\n\tif (iMouse.w<1. || length(max(vec2(0.),abs(uv-.5)-vec2(.37,.46)))<0.01) {\n\t\tcolor=getsmcolor(ot*4.+l*10.-iTime*7.,1.)*(1.-.4*step(.5,1.-dot(p,p))); //get color gradient for orbit trap value\t\n\t}\n    color=mix(vec3(length(color))*.5,color,.6); // saturation adjustment\n    color*=1.-pow(l*1.1,5.); color+=pow(max(0.,.2-l)/.2,3.)*1.2; // center glow\n    fragColor = vec4(color,1.0)*min(1.,iTime*.3);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}