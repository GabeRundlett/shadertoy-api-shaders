{
    "Shader": {
        "info": {
            "date": "1680731703",
            "description": "Simple shader for camera control.\nUse WASD for translating the camera.\nUse arrow keys to rotate camera.\nHold C or V to increase or decrease translational velocity.\nHold R or T to zoom in and out.",
            "flags": 48,
            "hasliked": 0,
            "id": "dsVXRh",
            "likes": 1,
            "name": "Randomly Rotating Reflective Cub",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "control",
                "infinite"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 260
        },
        "renderpass": [
            {
                "code": "# define MAX_NUM_STEPS 75\n# define SHAPE_CUBE 1 // Set to 1 for cubes, 0 for spheres\n# define RANDOM_ROTATION 1 // Set to 1 for random rotation, 0 for no rotation\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n    return length(pos-center) - radius;\n}\n\nfloat sdSphereWorld(in vec3 pos){\n    pos = mod(pos, 1.0);\n    return sdSphere(pos, vec3(0.5), 0.25);\n}\n\nvec3 normalSphereWorld(in vec3 pos){\n    float sd = sdSphereWorld(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n        sdSphereWorld(pos - e.xyy),\n        sdSphereWorld(pos - e.yxy),\n        sdSphereWorld(pos - e.yyx)\n    ));\n    return normal;\n}\n\nfloat sdBox(in vec3 pos, in vec3 center, in vec3 dimensions){\n    vec3 q = abs(pos - center) - dimensions;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec3 rotateVector(vec3 v, vec3 axis, float angle) {\n    return v * cos(angle) + cross(axis, v) * sin(angle) + axis * dot(axis, v) * (1.0 - cos(angle));\n}\n\nvec3 randomAxis(float seed) {\n    float phi = mod(seed * 1.618033988749895, 1.0) * 6.283185307179586;\n    float costheta = mod(seed * 2.718281828459045, 1.0) * 2.0 - 1.0;\n    float theta = acos(costheta);\n\n    float x = sin(theta) * cos(phi);\n    float y = sin(theta) * sin(phi);\n    float z = cos(theta);\n    return vec3(x, y, z);\n}\n\nfloat randomAngle(float seed) {\n    return mod(seed * 3.141592653589793, 1.0) * 6.283185307179586;\n}\n\nfloat sdBoxWorld(in vec3 pos){\n    vec3 cubeCenter = vec3(floor(pos.x) + 0.5, floor(pos.y) + 0.5, floor(pos.z) + 0.5);\n    pos = mod(pos, 1.0);\n    #if RANDOM_ROTATION\n        float seed = cubeCenter.x * 137.0 + cubeCenter.y * 89.0 + cubeCenter.z * 61.0;\n        vec3 axis = randomAxis(seed);\n        float angle = randomAngle(seed);\n        pos = rotateVector(pos - vec3(0.5), axis, angle) + vec3(0.5);\n    #endif\n    float soft = 0.025; // Soft edges.\n    float sd = sdBox(pos, vec3(0.5), vec3(0.125)) - soft;\n    float reduction = 0.90; // Reduce the min signed distance for rotations\n    return sd * reduction;\n}\n\n\nvec3 normalBoxWorld(in vec3 pos){\n    float sd = sdBoxWorld(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n        sdBoxWorld(pos - e.xyy),\n        sdBoxWorld(pos - e.yxy),\n        sdBoxWorld(pos - e.yyx)\n    ));\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz);\n    vec3 right = normalize(cross(forward, vec3(0,0,1)));\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    float zoom = texelFetch(iChannel0, ivec2(CAMERA_ZOOM, 0), 0).x;\n    vec3 viewDir = normalize(forward*0.8*zoom + right * uv.x + up * uv.y);\n    \n    // Calculate color.\n    vec3 color = vec3(0.1,0,0);\n    vec3 reflectionConstant = vec3(1.0);\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.0;\n    int maxNumSteps = MAX_NUM_STEPS;\n    int numSteps = 0;\n    float minDist = 0.001;\n    vec3 prevPos = pos;\n    float prevSD = 0.0;\n    float sd = 0.0;\n    for(; numSteps < maxNumSteps; numSteps++){\n        prevSD = sd;\n        #if SHAPE_CUBE\n            sd = sdBoxWorld(pos);\n        #else\n            sd = sdSphereWorld(pos);\n        #endif\n        if(sd < minDist){\n            // Collision with shape.\n            pos = mix(pos, prevPos, (minDist - sd) / (prevSD - sd));\n            \n            #if SHAPE_CUBE\n                vec3 normal = normalBoxWorld(pos);\n            #else\n                vec3 normal = normalSphereWorld(pos);\n            #endif\n            if(dot(dir, normal) < 0.0){\n                dir = reflect(dir, normal);\n                reflectionConstant *= 0.8;\n                if(mod(pos.x, 0.1) < 0.01 || mod(pos.y, 0.1) < 0.01 || mod(pos.z, 0.1) < 0.01){\n                    if(mod(pos.x, 2.0) < 1.0){\n                        reflectionConstant.x *= 0.4;\n                    }\n                    if(mod(pos.y, 2.0) < 1.0){\n                        reflectionConstant.y *= 0.4;\n                    }\n                    if(mod(pos.z, 2.0) < 1.0){\n                        reflectionConstant.z *= 0.4;\n                    }\n                }\n            }\n            //\n        }\n        prevPos = pos;\n        pos += normalize(dir) * sd;\n        dist += sd;\n        color += vec3(0.04,0.05,0.06) * sd * reflectionConstant;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --Global variables.\n\n// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_T  = 84;\n\n//\nconst int PREVIOUS_TIME = 0;\n\nconst int CAMERA_POS = 2;\nconst int CAMERA_SENSITIVITY = 3;\nconst int CAMERA_DIRECTION = 4;\nconst int CAMERA_ZOOM = 5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // Accelerate.\n    float sensitivity = texelFetch(iChannel0, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.03;\n            prevColor.r = 0.03;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 1000.){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.00001){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Zoom.\n    float zoom = texelFetch(iChannel0, ivec2(CAMERA_ZOOM, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_ZOOM,0)){\n        if(zoom == 0.){\n            zoom = 1.0;\n            prevColor.r = 1.0;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_R,0), 0 ).x > 0.5){\n            prevColor.r *= 1.02;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_T,0), 0 ).x > 0.5){\n            prevColor.r /= 1.02;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(0,1,0);\n    }\n    forward = normalize(forward);\n    vec3 right = normalize(cross(forward, vec3(0,0,1)));\n    vec3 up = cross(right, forward);\n    if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION,0)){\n        bool arrowRight = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n        bool arrowLeft = texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n        bool arrowUp = texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x > 0.5;\n        bool arrowDown = texelFetch( iChannel1, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n        float rotationSensitivity = 0.018/zoom;\n        if(arrowRight){\n            forward = normalize(forward + right*rotationSensitivity);\n        }\n        if(arrowLeft){\n            forward = normalize(forward - right*rotationSensitivity);\n        }\n        if(arrowUp){\n            forward = normalize(forward + up*rotationSensitivity);\n        }\n        if(arrowDown){\n            forward = normalize(forward - up*rotationSensitivity);\n        }\n    \tvec3 right = normalize(cross(forward, vec3(0,0,1)));\n    \tvec3 up = cross(right, forward);\n        prevColor.xyz = normalize(forward);\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel1, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x > 0.5;\n        if(wDown){\n        \tprevColor.xyz += forward*sensitivity;\n        }\n        if(sDown){\n        \tprevColor.xyz -= forward*sensitivity;\n        }\n        if(dDown){\n        \tprevColor.xyz += right*sensitivity;\n        }\n        if(aDown){\n        \tprevColor.xyz -= right*sensitivity;\n        }\n        if(spaceDown){\n        \tprevColor.xyz += up*sensitivity;\n        }\n        if(shiftDown){\n        \tprevColor.xyz -= up*sensitivity;\n        }\n    }\n    \n    \n    \n    // Write data/color.\n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}