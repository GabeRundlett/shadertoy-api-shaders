{
    "Shader": {
        "info": {
            "date": "1671565902",
            "description": "Inspired by @matthen2 on Twitter: [url]https://twitter.com/matthen2/status/1604117218027077634[/url]\n\nSee: [url]https://golem.ph.utexas.edu/category/2014/04/the_modular_flow_on_the_space.html[/url] for the maths\n\n<mouse x>: control zoom.\n\n",
            "flags": 16,
            "hasliked": 0,
            "id": "dlXGRN",
            "likes": 43,
            "name": "Modular Flow",
            "published": 3,
            "tags": [
                "flow",
                "modular",
                "eigenvector",
                "eigenvalue"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 577
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////\n//\n// Modular Flow,mla, 2022\n//\n// Apply a stretch and squeeze transform (x,y)-> (kx,y/k) to a lattice, \n// add just the right skew, and you get a nice looping flow pattern.\n// \n// Inspiration:\n// https://twitter.com/matthen2/status/1604117218027077634\n// https://twitter.com/etiennejcb/status/1604946331411292166 (@Bleuje)\n//\n// For the maths:\n// https://golem.ph.utexas.edu/category/2014/04/the_modular_flow_on_the_space.html\n//\n// <mouse-x> to zoom\n// 'g' shows underlying grid\n// 'r' shows fundamental region\n//\n////////////////////////////////////////////////////////////////////////\n\n// Find a canonical representative under the group action - generally\n// the length of the vector decreases to a minimum, then increases\n// again, so just iterate both ways to find the smallest (breaking ties\n// the same way if two vectors are minimal).\nvec2 reduce(vec2 p, mat2 A, mat2 Ainv) {\n  if (p == vec2(0)) return p;\n  while (true) {\n    vec2 p1 = A*p;\n    if (dot(p1,p1) >= dot(p,p)) break;\n    p = p1;\n  }\n  while (true) {\n    vec2 p1 = Ainv*p;\n    if (dot(p1,p1) > dot(p,p)) break;\n    p = p1;\n  }\n  return p;\n}\n\nvec3 getcol(vec2 ix) {\n  //if (ix == vec2(0)) return vec3(1); // Show centre point\n  uint h = uint(int(ix.x)*12345^int(ix.y));\n  h = ihash(h);\n  return h2rgb(float(h)/exp2(32.0));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // A can be any suitable element of the modular group. This\n    // one has nice eigenvectors. Since determinant is 1, the\n    // eigenvalues are real and distinct if Tr(A) > 2, and the\n    // product of the eigenvalues is 1. If this is the case,\n    // we have an eigendecomposition A = P'XP where P is the\n    // matrix of eigenvectors and X is the diagonal matrix\n    // of the eigenvalues k,1/k.\n    mat2 A = mat2(2,1,1,1); // Must have Tr(A) > 2 and det(A) = 1\n    //A = mat2(0,-1,1,3); // Alternative matrix\n    float a = A[0][0], b = A[1][0], c = A[0][1], d = A[1][1];\n    assert(a+d > 2.0);\n    assert(a*d - b*c == 1.0);\n    float tr = a+d, disc = tr*tr-4.0;\n    float l0 = 0.5*(tr-sqrt(disc)), l1 = 0.5*(tr+sqrt(disc)); // l1 = 2.618\n    vec2 e0 = normalize(vec2(-b,a-l0)), e1 = normalize(vec2(-b,a-l1));\n    mat2 P = mat2(e0,e1); // Eigenvector matrix\n    //P = mat2(-1, 1.618034,-1,-0.618034); // For A = (2,1,1,1) (unnormalized)\n    mat2 Ainv = inverse(A), Pinv = inverse(P);\n    float cycle = log(l1); // Largest eigenvalue\n\n    // Compute skewed uv and grid cell indices\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv += 0.25; uv = rotate(uv,0.1*iTime); uv -= 0.25;\n    uv *= 8.0;\n    if (iMouse.x > 0.0) uv *= exp2(3.0*iMouse.x/iResolution.x-1.0);\n    float px = fwidth(uv.x);\n    float k = exp(cycle*fract(0.25*iTime)-0.5); // Time loop (repeat every 4 seconds)\n    uv *= vec2(k,1.0/k);\n    uv = P*uv;\n    vec2 ix = round(uv);\n    uv -= ix;\n    vec2 uv0 = uv; // Remember skewed uv\n    uv = Pinv*uv;\n    uv *= vec2(1.0/k,k); // uv now unskewed \n    vec2 ix0 = ix; // Unreduced cell index\n    ix = reduce(ix,A,Ainv);\n\n    // Now do the drawing\n    vec3 col = vec3(1,1,0.75);\n    if (key(CHAR_G)) {\n      // show grid\n      vec2 uv1 = 0.5-abs(uv0);\n      float d = min(uv1.x,uv1.y);\n      float px = fwidth(d);\n      vec3 col0 = vec3(0), col1 = vec3(0);\n      if (mod(ix0.x+ix0.y,2.0) == 0.0) col0 = col;\n      else col1 = col;\n      col = mix(col0,col1,smoothstep(-px,px,d)); // Show cells\n    }\n    float radius = 0.32;\n    vec3 dcol = getcol(ix);\n    vec2 rad = rotate(vec2(1,0),0.25*ix.x*iTime);\n    dcol *= smoothstep(0.0,px,segment(uv,-rad,rad)-0.01); \n    col = mix(dcol,col,vec3(smoothstep(0.0,px,length(uv)-radius)));\n    col *= smoothstep(0.0,px,abs(length(uv)-radius)-0.01);\n    if (key(CHAR_R) && ix0 != ix) col *= 0.5; // Fundamental region\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool alert = false;\nint assert(bool b) {\n if (!b) alert = true;\n return 0;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n//const int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_R = 82;\n//const int CHAR_S = 83;\n//const int CHAR_T = 84;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}