{
    "Shader": {
        "info": {
            "date": "1691864405",
            "description": "Based off https://www.shadertoy.com/view/4t3BWl",
            "flags": 0,
            "hasliked": 0,
            "id": "dljcWw",
            "likes": 17,
            "name": "Matrix background for Lively",
            "published": 3,
            "tags": [
                "matrix",
                "purple"
            ],
            "usePreview": 0,
            "username": "stopsecret",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "/*\n  All credit goes to this shader: https://www.shadertoy.com/view/4t3BWl\n  I just made this version for a computer background\n*/\n\nconst int ITERATIONS = 30;   //use less value if you need more performance\nconst float SPEED = .1;\n\nconst float STRIP_CHARS_MIN =  7.;\nconst float STRIP_CHARS_MAX = 40.;\nconst float STRIP_CHAR_HEIGHT = 0.15;\nconst float STRIP_CHAR_WIDTH = 0.10;\nconst float ZCELL_SIZE = 1. * (STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX);  //the multiplier can't be less than 1.\nconst float XYCELL_SIZE = 12. * STRIP_CHAR_WIDTH;  //the multiplier can't be less than 1.\n\nconst int BLOCK_SIZE = 10;  //in cells\nconst int BLOCK_GAP = 2;    //in cells\n\nconst float WALK_SPEED = 1. * XYCELL_SIZE;\nconst float BLOCKS_BEFORE_TURN = 3.;\n\n\nconst float PI = 3.14159265359;\n\n\n//        ----  random  ----\n\nfloat hash(float v) {\n    return fract(sin(v)*43758.5453123);\n}\n\nfloat hash(vec2 v) {\n    return hash(dot(v, vec2(5.3983, 5.4427)));\n}\n\nvec2 hash2(vec2 v)\n{\n    v = vec2(v * mat2(127.1, 311.7,  269.5, 183.3));\n\treturn fract(sin(v)*43758.5453123);\n}\n\nvec4 hash4(vec2 v)\n{\n    vec4 p = vec4(v * mat4x2( 127.1, 311.7,\n                              269.5, 183.3,\n                              113.5, 271.9,\n                              246.1, 124.6 ));\n    return fract(sin(p)*43758.5453123);\n}\n\nvec4 hash4(vec3 v)\n{\n    vec4 p = vec4(v * mat4x3( 127.1, 311.7, 74.7,\n                              269.5, 183.3, 246.1,\n                              113.5, 271.9, 124.6,\n                              271.9, 269.5, 311.7 ) );\n    return fract(sin(p)*43758.5453123);\n}\n\n\n//        ----  symbols  ----\n//  Slightly modified version of \"runes\" by FabriceNeyret2 -  https://www.shadertoy.com/view/4ltyDM\n//  Which is based on \"runes\" by otaviogood -  https://shadertoy.com/view/MsXSRn\n\nfloat rune_line(vec2 p, vec2 a, vec2 b) {   // from https://www.shadertoy.com/view/4dcfW8\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n\treturn length(p - b * h);                         // dist to segment\n}\n\nfloat rune(vec2 U, vec2 seed, float highlight)\n{\n\tfloat d = 1e5;\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n        vec4 pos = hash4(seed);\n\t\tseed += 1.;\n\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) pos.y = .0;\n\t\tif (i == 1) pos.x = .999;\n\t\tif (i == 2) pos.x = .0;\n\t\tif (i == 3) pos.y = .999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec4 snaps = vec4(2, 3, 2, 3);\n\t\tpos = ( floor(pos * snaps) + .5) / snaps;\n\n\t\tif (pos.xy != pos.zw)  //filter out single points (when start and end are the same)\n\t\t    d = min(d, rune_line(U, pos.xy, pos.zw + .001) ); // closest line\n\t}\n\treturn smoothstep(0.1, 0., d) + highlight*smoothstep(0.4, 0., d);\n}\n\nfloat random_char(vec2 outer, vec2 inner, float highlight) {\n    vec2 seed = vec2(dot(outer, vec2(269.5, 183.3)), dot(outer, vec2(113.5, 271.9)));\n    return rune(inner, seed, highlight);\n}\n\n\n//        ----  digital rain  ----\n\n// xy - horizontal, z - vertical\nvec3 rain(vec3 ro3, vec3 rd3, float time) {\n    vec4 result = vec4(0.);\n\n    // normalized 2d projection\n    vec2 ro2 = vec2(ro3);\n    vec2 rd2 = normalize(vec2(rd3));\n\n    // we use formulas `ro3 + rd3 * t3` and `ro2 + rd2 * t2`, `t3_to_t2` is a multiplier to convert t3 to t2\n    bool prefer_dx = abs(rd2.x) > abs(rd2.y);\n    float t3_to_t2 = prefer_dx ? rd3.x / rd2.x : rd3.y / rd2.y;\n\n    // at first, horizontal space (xy) is divided into cells (which are columns in 3D)\n    // then each xy-cell is divided into vertical cells (along z) - each of these cells contains one raindrop\n\n    ivec3 cell_side = ivec3(step(0., rd3));      //for positive rd.x use cell side with higher x (1) as the next side, for negative - with lower x (0), the same for y and z\n    ivec3 cell_shift = ivec3(sign(rd3));         //shift to move to the next cell\n\n    //  move through xy-cells in the ray direction\n    float t2 = 0.;  // the ray formula is: ro2 + rd2 * t2, where t2 is positive as the ray has a direction.\n    ivec2 next_cell = ivec2(floor(ro2/XYCELL_SIZE));  //first cell index where ray origin is located\n    for (int i=0; i<ITERATIONS; i++) {\n        ivec2 cell = next_cell;  //save cell value before changing\n        float t2s = t2;          //and t\n\n        //  find the intersection with the nearest side of the current xy-cell (since we know the direction, we only need to check one vertical side and one horizontal side)\n        vec2 side = vec2(next_cell + cell_side.xy) * XYCELL_SIZE;  //side.x is x coord of the y-axis side, side.y - y of the x-axis side\n        vec2 t2_side = (side - ro2) / rd2;  // t2_side.x and t2_side.y are two candidates for the next value of t2, we need the nearest\n        if (t2_side.x < t2_side.y) {\n            t2 = t2_side.x;\n            next_cell.x += cell_shift.x;  //cross through the y-axis side\n        } else {\n            t2 = t2_side.y;\n            next_cell.y += cell_shift.y;  //cross through the x-axis side\n        }\n        //now t2 is the value of the end point in the current cell (and the same point is the start value in the next cell)\n\n        //  gap cells\n        vec2 cell_in_block = fract(vec2(cell) / float(BLOCK_SIZE));\n        float gap = float(BLOCK_GAP) / float(BLOCK_SIZE);\n        if (cell_in_block.x < gap || cell_in_block.y < gap || (cell_in_block.x < (gap+0.1) && cell_in_block.y < (gap+0.1))) {\n            continue;\n        }\n\n        //  return to 3d - we have start and end points of the ray segment inside the column (t3s and t3e)\n        float t3s = t2s / t3_to_t2;\n\n        //  move through z-cells of the current column in the ray direction (don't need much to check, two nearest cells are enough)\n        float pos_z = ro3.z + rd3.z * t3s;\n        float xycell_hash = hash(vec2(cell));\n        float z_shift = xycell_hash*11. - time * (0.5 + xycell_hash * 1.0 + xycell_hash * xycell_hash * 1.0 + pow(xycell_hash, 16.) * 3.0);  //a different z shift for each xy column\n        float char_z_shift = floor(z_shift / STRIP_CHAR_HEIGHT);\n        z_shift = char_z_shift * STRIP_CHAR_HEIGHT;\n        int zcell = int(floor((pos_z - z_shift)/ZCELL_SIZE));  //z-cell index\n        for (int j=0; j<2; j++) {  //2 iterations is enough if camera doesn't look much up or down\n            //  calcaulate coordinates of the target (raindrop)\n            vec4 cell_hash = hash4(vec3(ivec3(cell, zcell)));\n            vec4 cell_hash2 = fract(cell_hash * vec4(127.1, 311.7, 271.9, 124.6));\n\n            float chars_count = cell_hash.w * (STRIP_CHARS_MAX - STRIP_CHARS_MIN) + STRIP_CHARS_MIN;\n            float target_length = chars_count * STRIP_CHAR_HEIGHT;\n            float target_rad = STRIP_CHAR_WIDTH / 2.;\n            float target_z = (float(zcell)*ZCELL_SIZE + z_shift) + cell_hash.z * (ZCELL_SIZE - target_length);\n            vec2 target = vec2(cell) * XYCELL_SIZE + target_rad + cell_hash.xy * (XYCELL_SIZE - target_rad*2.);\n\n            //  We have a line segment (t0,t). Now calculate the distance between line segment and cell target (it's easier in 2d)\n            vec2 s = target - ro2;\n            float tmin = dot(s, rd2);  //tmin - point with minimal distance to target\n            if (tmin >= t2s && tmin <= t2) {\n                float u = s.x * rd2.y - s.y * rd2.x;  //horizontal coord in the matrix strip\n                if (abs(u) < target_rad) {\n                    u = (u/target_rad + 1.) / 2.;\n                    float z = ro3.z + rd3.z * tmin/t3_to_t2;\n                    float v = (z - target_z) / target_length;  //vertical coord in the matrix strip\n                    if (v >= 0.0 && v < 1.0) {\n                        float c = floor(v * chars_count);  //symbol index relative to the start of the strip, with addition of char_z_shift it becomes an index relative to the whole cell\n                        float q = fract(v * chars_count);\n                        vec2 char_hash = hash2(vec2(c+char_z_shift, cell_hash2.x));\n                        if (char_hash.x >= 0.1 || c == 0.) {  //10% of missed symbols\n                            float time_factor = floor(c == 0. ? time*5.0 :  //first symbol is changed fast\n                                    time*(1.0*cell_hash2.z +   //strips are changed sometime with different speed\n                                            cell_hash2.w*cell_hash2.w*4.*pow(char_hash.y, 4.)));  //some symbols in some strips are changed relatively often\n                            float a = random_char(vec2(char_hash.x, time_factor), vec2(u,q), max(1., 3. - c/2.)*0.2);  //alpha\n                            a *= clamp((chars_count - 0.5 - c) / 2., 0., 1.);  //tail fade\n                            if (a > 0.) {\n                                float attenuation = 1. + pow(0.06*tmin/t3_to_t2, 2.);\n                                vec3 col = (c == 0. ? vec3(0.67, 0.6, 1.) : vec3(0.3, 0.1, 0.50)) / attenuation;\n                                float a1 = result.a;\n                                result.a = a1 + (1. - a1) * a;\n                                result.xyz = (result.xyz * a1 + col * (1. - a1) * a) / result.a;\n                                if (result.a > 0.98)  return result.xyz;\n                            }\n                        }\n                    }\n                }\n            }\n            // not found in this cell - go to next vertical cell\n            zcell += cell_shift.z;\n        }\n        // go to next horizontal cell\n    }\n\n    return result.xyz * result.a;\n}\n\n\n//        ----  main, camera  ----\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n\tfloat c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nvec3 rotateX(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(1.,0.,0.,0.,c,-s,0.,s,c) * v;\n}\n\nvec3 rotateY(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c,0.,-s,0.,1.,0.,s,0.,c) * v;\n}\n\nvec3 rotateZ(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c,-s,0.,s,c,0.,0.,0.,1.) * v;\n}\n\nfloat smoothstep1(float x) {\n    return smoothstep(0., 1., x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (STRIP_CHAR_WIDTH > XYCELL_SIZE || STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX > ZCELL_SIZE) {\n        // error\n        fragColor = vec4(1., 0., 0., 1.);\n        return;\n    }\n\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\n    float time = iTime * SPEED;\n\n    const float turn_rad = 0.25 / BLOCKS_BEFORE_TURN;   //0 .. 0.5\n    const float turn_abs_time = (PI/2.*turn_rad) * 1.5;  //multiplier different than 1 means a slow down on turns\n    const float turn_time = turn_abs_time / (1. - 2.*turn_rad + turn_abs_time);  //0..1, but should be <= 0.5\n\n    float level1_size = float(BLOCK_SIZE) * BLOCKS_BEFORE_TURN * XYCELL_SIZE;\n    float level2_size = 4. * level1_size;\n    float gap_size = float(BLOCK_GAP) * XYCELL_SIZE;\n\n    vec3 ro = vec3(gap_size/2., gap_size/2., 0.);\n    vec3 rd = vec3(uv.x, 2.0, uv.y);\n\n    float tq = fract(time / (level2_size*4.) * WALK_SPEED);  //the whole cycle time counter\n    float t8 = fract(tq*4.);  //time counter while walking on one of the four big sides\n    float t1 = fract(t8*8.);  //time counter while walking on one of the eight sides of the big side\n\n    vec2 prev;\n    vec2 dir;\n    if (tq < 0.25) {\n        prev = vec2(0.,0.);\n        dir = vec2(0.,1.);\n    } else if (tq < 0.5) {\n        prev = vec2(0.,1.);\n        dir = vec2(1.,0.);\n    } else if (tq < 0.75) {\n        prev = vec2(1.,1.);\n        dir = vec2(0.,-1.);\n    } else {\n        prev = vec2(1.,0.);\n        dir = vec2(-1.,0.);\n    }\n    float angle = floor(tq * 4.);  //0..4 wich means 0..2*PI\n\n    prev *= 4.;\n\n    const float first_turn_look_angle = 0.4;\n    const float second_turn_drift_angle = 0.5;\n    const float fifth_turn_drift_angle = 0.25;\n\n    vec2 turn;\n    float turn_sign = 0.;\n    vec2 dirL = rotate(dir, -PI/2.);\n    vec2 dirR = -dirL;\n    float up_down = 0.;\n    float rotate_on_turns = 1.;\n    float roll_on_turns = 1.;\n    float add_angel = 0.;\n    if (t8 < 0.125) {\n        turn = dirL;\n        //dir = dir;\n        turn_sign = -1.;\n        angle -= first_turn_look_angle * (max(0., t1 - (1. - turn_time*2.)) / turn_time - max(0., t1 - (1. - turn_time)) / turn_time * 2.5);\n        roll_on_turns = 0.;\n    } else if (t8 < 0.250) {\n        prev += dir;\n        turn = dir;\n        dir = dirL;\n        angle -= 1.;\n        turn_sign = 1.;\n        add_angel += first_turn_look_angle*0.5 + (-first_turn_look_angle*0.5+1.0+second_turn_drift_angle)*t1;\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else if (t8 < 0.375) {\n        prev += dir + dirL;\n        turn = dirR;\n        //dir = dir;\n        turn_sign = 1.;\n        add_angel += second_turn_drift_angle*sqrt(1.-t1);\n        //roll_on_turns = 0.;\n    } else if (t8 < 0.5) {\n        prev += dir + dir + dirL;\n        turn = dirR;\n        dir = dirR;\n        angle += 1.;\n        turn_sign = 0.;\n        up_down = sin(t1*PI) * 0.37;\n    } else if (t8 < 0.625) {\n        prev += dir + dir;\n        turn = dir;\n        dir = dirR;\n        angle += 1.;\n        turn_sign = -1.;\n        up_down = sin(-min(1., t1/(1.-turn_time))*PI) * 0.37;\n    } else if (t8 < 0.750) {\n        prev += dir + dir + dirR;\n        turn = dirL;\n        //dir = dir;\n        turn_sign = -1.;\n        add_angel -= (fifth_turn_drift_angle + 1.) * smoothstep1(t1);\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else if (t8 < 0.875) {\n        prev += dir + dir + dir + dirR;\n        turn = dir;\n        dir = dirL;\n        angle -= 1.;\n        turn_sign = 1.;\n        add_angel -= fifth_turn_drift_angle - smoothstep1(t1) * (fifth_turn_drift_angle * 2. + 1.);\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else {\n        prev += dir + dir + dir;\n        turn = dirR;\n        //dir = dir;\n        turn_sign = 1.;\n        angle += fifth_turn_drift_angle * (1.5*min(1., (1.-t1)/turn_time) - 0.5*smoothstep1(1. - min(1.,t1/(1.-turn_time))));\n    }\n\n    if (iMouse.x > 10. || iMouse.y > 10.) {\n        vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n        up_down = -0.7 * mouse.y;\n        angle += mouse.x;\n        rotate_on_turns = 1.;\n        roll_on_turns = 0.;\n    } else {\n        angle += add_angel;\n    }\n\n    rd = rotateX(rd, up_down);\n\n    vec2 p;\n    if (turn_sign == 0.) {\n        //  move forward\n        p = prev + dir * (turn_rad + 1. * t1);\n    }\n    else if (t1 > (1. - turn_time)) {\n        //  turn\n        float tr = (t1 - (1. - turn_time)) / turn_time;\n        vec2 c = prev + dir * (1. - turn_rad) + turn * turn_rad;\n        p = c + turn_rad * rotate(dir, (tr - 1.) * turn_sign * PI/2.);\n        angle += tr * turn_sign * rotate_on_turns;\n        rd = rotateY(rd, sin(tr*turn_sign*PI) * 0.2 * roll_on_turns);  //roll\n    }  else  {\n        //  move forward\n        t1 /= (1. - turn_time);\n        p = prev + dir * (turn_rad + (1. - turn_rad*2.) * t1);\n    }\n\n    rd = rotateZ(rd, angle * PI/2.);\n\n    ro.xy += level1_size * p;\n\n    ro += rd * 0.2;\n    rd = normalize(rd);\n\n    vec3 col = rain(ro, rd, time);\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}