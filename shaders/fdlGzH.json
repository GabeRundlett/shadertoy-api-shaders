{
    "Shader": {
        "info": {
            "date": "1624424212",
            "description": "Converted my raymarching code into raytracing code.\n\nAdded fresnel, ggx, and gamma correction.\n\nLacking multiple bounces, I'll make that later",
            "flags": 0,
            "hasliked": 0,
            "id": "fdlGzH",
            "likes": 5,
            "name": "Raytracer - Base",
            "published": 3,
            "tags": [
                "raytracing",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "SpinningCube",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "// Filmic tonemapping curve by milesWaugh\n\nconst float epsilon = 0.001;\nconst float focalLength = 1.;\nconst float renderDist = 85.;\nconst float pi = 3.141592653589793;\n\nvec3 camera;\nfloat nearestDist;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfRoughness;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = 1.*vec3(.2, 0.4, 0.6);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nvec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius ) {\n    vec3 offset = pos - rayOrigin;\n    float dot1 = dot(offset, rayDir);\n    float dot2 = dot(offset, offset);\n    if (dot1 < 0.) {\n        return vec4(-1., 0, 0, 0);\n    }\n    if (dot2 - dot1 * dot1 < radius * radius) {\n        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));\n        return vec4(dot1 - near, (rayOrigin + (rayDir * (dot1 - near))) - pos);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0.)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvoid addIntersector( vec4 surface, vec3 col, float roughness ) {\n    float dist = surface.x;\n    if ( dist < nearestDist && dist > 0. ) {\n        nearestDist = dist;\n        if (updateMat) {\n        \tsurfCol = col;\n            surfRoughness = roughness*roughness;\n            surfNormal = normalize(surface.yzw);\n        }\n    }\n}\n\nfloat scene( vec3 rayOrigin, vec3 rayDir)\n{\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    addIntersector( Sphere( rayOrigin, rayDir, vec3(0, 0, 6), 1.), vec3(0.4,.2, 0.01), .1 );\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(3, 1, 22), 2.), vec3(0.1,0.2, 0.8), .1 );\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 7, 100), 8.), vec3(.5,0.03, 0.01), .1 );\n    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1.), vec3(0.1, 0.3, 0.1), 0.1 );\n    \n    return nearestDist;\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    \n    nearestDist = renderDist;\n        \n    scene(start, rayDir);\n        \n    if ( nearestDist < renderDist ) {\n        return vec4(1., rayDir * nearestDist + start);\n    }\n    else {\n        return vec4(0., rayDir * nearestDist + start);\n    }\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, vec3(-10, 50, 20), 1., surfNormal);\n    //directionalLight( ray, rayDir, normalize(vec3(-2,2,-1)), surfNormal, 1., 0. );\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    //return color;\n    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    float fog = clamp(length(ray - camera)/(renderDist), 0., 1.);\n    fog = fog*fog*fog;\n    //fog = fog*fog;\n    fog = smoothstep(0., 1., fog);\n    \n    vec3 finalCol = mix(surfCol * (diffuse + ambient), specular + ambient, fresnel(1.5, surfRoughness, surfNormal, -rayDir));\n    finalCol = mix(finalCol, ambient, fog);\n    \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cosTime = cos(iTime/5.);\n    cosTime = 6.*-cosTime+6.;\n    camera = vec3(.5*cosTime, .6*cosTime+0.3, 5.*cosTime-5.);\n    //camera = vec3(0,0,0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    vec3 col;\n    \n    if (rayData.x == 1.) {\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = ambient;\n    }\n\n    // Output to screen, filmic tonemapping, and gamma correction.\n    fragColor = vec4(pow(filmic(col),vec3(1./2.2)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}