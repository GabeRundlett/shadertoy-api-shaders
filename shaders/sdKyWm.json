{
    "Shader": {
        "info": {
            "date": "1654998745",
            "description": "Official covfefe shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdKyWm",
            "likes": 3,
            "name": "Covfefe",
            "published": 3,
            "tags": [
                "covfefe"
            ],
            "usePreview": 0,
            "username": "zovox",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define FAR (10.)\n#define TAO (2.*PI)\n\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat smooth_floor(float x) {\n    return smoothstep(0.5, 1., fract(x))+floor(x);\n}\n\nfloat dfScene(in vec3 z0){\n    float mind = 1E32;\n    const float detail = 4.;\n    for(float vert = 0.; vert < detail; vert += 1.) {\n        for(float horiz = 0.; horiz < detail; horiz += 1.) {\n            z0.xy=Kaleido(z0.xy, 2.+saw(iTime/PI/E)*4.);\n            z0.yz=Rotate(z0.yz, (.25+1.5*saw(iTime/GR/PI))*PI);\n            float d = sdBox(z0, vec3(.125));\n            z0.y -= .125;\n            if(d < mind) mind = d;\n        }   \n    }\n\n\treturn mind;\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / 1024., 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//main march\nvec4 marchScene(vec2 uv) {\n    \n    float movement = iTime/PI;\n    //camera\n    vec3 rd = normalize(vec3(uv, -1./GR));\n    vec3 ro = vec3(0.0, 0., 2.);\n    \n    //rotate camera\n    rd.xz *= rot(-movement);\n    ro.xz *= rot(-movement);\n    ro += rd/512.;\n    \n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n   \tfloat ns;\n    vec3 p;\n    for (int i = 0; i <16; i++) {\n        rp = ro + rd * d;\n        p = rp;\n        ns = dfScene(p);\n        d += ns;\n        if(d > FAR)\n        {\n            break;\n        }\n        \n    }\n    float fog = smoothstep(.75, .9, d/FAR);\n    vec3 n = surfaceNormal(p);\n    return vec4(n, 1.)*(1.-fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 t1 = marchScene(uv);\n    fragColor = t1;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}