{
    "Shader": {
        "info": {
            "date": "1579023278",
            "description": "So this is day 26 of the thing ",
            "flags": 32,
            "hasliked": 0,
            "id": "ttV3WD",
            "likes": 8,
            "name": "Day 26 - Gold",
            "published": 3,
            "tags": [
                "gold",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 393
        },
        "renderpass": [
            {
                "code": "// thanks to mla and Kali!\n// They have super nice examples on inversion\n\n// it's really simple, basically\n// p /= dot(p,p);\n// p = sin(p);\n// SDFs\n// return distance*dot(p,p);\n\n\n// and ofc Inigo quilez for pallete!\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 10.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.2;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*4.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.;\n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    \n    //fragColor = max(fragColor, 0.);\n    \n    //fragColor.xyz = pow(fragColor.xyz, vec3(1.5,1. + sin(iTime)*0.2,1. - cos(iTime)*0.4));\n\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    //fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define mx (200. + 200.*iMouse.x/iResolution.y)\n\n#define iTime (iTime*0.6 + 23.)\nstruct Mat {\n    vec3 albedo;\n\tfloat metalness; \n\tfloat roughness;\n};\nMat mats[2] = Mat[](\n\tMat(vec3(1)*4.,0.9,0.0),\n\tMat(vec3(1,1,1.),0.1,0.9)\n);  \n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn dir + right*uv.x + up*uv.y;\n}\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\nfloat r11(float u){\n\treturn fract(sin(u*4125.57)*1115.125235);\n}\n///  Dave hoskins hash\nvec3 r33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x),  cos(x))\n#define pmod(p, x) mod(p,x) - x*0.5\nfloat sdBlocksA(vec3 p, float scale) {\n    \n    float modDist = 26.*scale;\n    vec3 r = r33(floor(p/modDist) + 20.2) - 0.5;\n    vec3 rSign = sign(r);\n    \n    //r = smoothstep(0.,1., r*3.);\n    //r *= rSign;\n    vec3 rOrig = r;\n    r = sign(r)*pow(clamp(abs(r)*80.5, 0. ,1.), vec3(20.));\n\tfloat scaleO = scale;    \n\n    scale *= 1. + abs(rOrig.x)*3.;\n    p = pmod(p,modDist);\n    \n\n    \n    if (scale < 3.){\n        scale = 1. + rOrig.y*3.;\n    \tp -= r*6.*scaleO;\n    } else {\n    \tp -= r*6.*scaleO;\n    }\n    //p -= clamp(r*4., vec3(-1.4), vec3(1.4))*6.;\n    \n    p.xy *= rot(r.x*19. + iTime*r.z*1.);\n    p.yz *= rot(r.y*19. + iTime*r.x*1.);\n    //p.xz *= rot(r.z*19. + iTime*r.y*1.);\n    \n    //p.xz *= rot(r.y*29.);\n    p = abs(p);\n    \n    \n    for (int i = 0; i < 2 ; i++){\n    \tp = abs(p);\n        //p.xy *= rot(0.4);\n        //p.yz *= rot(0.4);\n        p.xz *= rot(r.y*0.7 * step(0.,r.x));\n        p.z -= .2;\n        p.xy *= rot(sign(r.x)*PI*0.25);\n        p.yz *= rot(r.y*2.*0.2);\n        //p.y -= 0.2 * r.x*scale*2.;\n    }\n    \n    \n    p -= 1.*scale;\n    float d = max(p.x, max(p.y, p.z));\n    \n    d = max(d, dot(p + 0.33*scale, normalize(vec3(1))));\n    \n    \n    p = max(p,-(abs(p.y*0.5) - 0.7));\n    \n    d *= 0.2;\n    return d;\n\n}\nvec3 glow = vec3(0);\n\n#define dmin(a, b) a.x < b.x ? a : b\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    p.xy *= rot(0.3);\n        \n    d =  dmin(d,vec2(sdBlocksA(p, 1.), 0.));\n    p.xz *= rot(0.4);\n    d =  dmin(d,vec2(sdBlocksA(p, 10.), 0.));\n    p.yz *= rot(0.4);\n    d =  dmin(d,vec2(sdBlocksA(p, 4.), 0.));\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.1,0.);\n    return normalize( map(p).x -\n    \tvec3(\n        \tmap(p - t.xyy).x,\n        \tmap(p - t.yxy).x,\n        \tmap(p - t.yyx).x\n        )\n    );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(0,0,0. + mx + iTime*90.);\n    ro.y += sin(iTime)*50.;\n    ro.x += sin(iTime + sin(iTime*0.4)*1.5)*100.;\n    vec3 roO = ro;\n    vec3 lookAt = ro + vec3(0,0,1);\n    lookAt.x += sin(iTime);\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    //rd.xz *= rot(sin(iTime*0.1));\n    vec3 rdO = rd;\n    vec3 p = ro; float t = 0., tO = 0.;\n    vec3 att = vec3(1);\n    \n    const int iterations = 200;\n    float bounce = 0.;\n    for (int i  = 0;i <= iterations + min(0, iFrame); i++){\n    \tvec2 d = map(p);\n        glow += vec3( exp(-d.x) );\n        if(d.x < 0.001){\n            vec3 lightPos = roO + vec3(0,1,0);\n            //lightPos = vec3(0,0,0);\n            vec3 lightCol = vec3(1.);\n            \n            vec3 L = normalize(lightPos - p);\n            //L = normalize(vec3(-1));\n            vec3 H = normalize(L - rdO);\n            //H *= 1.;\n            //vec3 lightCol = vec3(0.5,0.5,0.2);\n                  \n\n            int id = int(d.y);\n            float METALNESS = mats[id].metalness;\n            float ROUGHNESS = mats[id].roughness;\n            vec3 albedo = mats[id].albedo;\n            albedo = vec3(1);\n            vec3 N = getNormal(p);\n            vec3 V = normalize(ro - p);\n            //vec3 V = -rd;\n\n            vec3 F0 = vec3(0.04); \n            F0 = mix(F0, albedo, METALNESS);\n\n\n            // calculate per-light radiance\n            float distL    = length(lightPos - p)*0.003;\n            float attenuation = 1.0 / (distL * distL);\n            attenuation = clamp(attenuation, 0. ,10.);\n            //float attenuation = dist*0.02;\n            //attenuation = 1.;\n            vec3 radiance     = lightCol * attenuation;        \n\n            // cook-torrance brdf\n            float NDF = DistributionGGX(N, H, ROUGHNESS);   \n            float G   = GeometrySmith(N, V, L, ROUGHNESS);      \n            vec3 F    = fresnelSchlick(clamp(dot(N, V), 0.0, 1.0), F0);     \n\n            vec3 kS = F;\n            vec3 kD = vec3(1.0) - kS;\n            kD *= 1.0 - METALNESS;\t  \n\n            vec3 numerator    = NDF * G * F;\n            float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n            vec3 specular     = numerator / max(denominator, 0.001);  \n\n            // add to outgoing radiance Lo\n            float NdotL = max(dot(N, L), 0.0); \n            att *= vec3(.62,.576,.388)*1.4;\n            col += (kD * albedo / PI + specular) * radiance * NdotL * attenuation*att; \n  \n            vec3 ambient = vec3(0.01) ;          \n     \n            if (bounce == 0.){\n            \ttO = t;\n            }\n            bounce++;\n            ro = p;\n            rd = reflect(rd, N);\n            t = 0.;\n            d.x = 2.6;\n            if (bounce > 2.){\n                break;\n            }\n \n        }\n            \n        if(t > 300. || i == iterations){\n            if (bounce == 0.){\n            \ttO = t;\n            }\n            break;\n        }   \n        t += d.x;\n    \tp = ro + rd*t;\n    }\n    col += glow*0.0007*vec3(.62,.576,.388)*exp(-tO*0.005);\n    col *= 1.5;\n    //col = mix(col, vec3(0.1), smoothstep(0.,1.,tO*0.002));\n    col = pow(col, vec3(0.45));\n    col = smoothstep(0., 0.8,col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}