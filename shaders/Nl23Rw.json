{
    "Shader": {
        "info": {
            "date": "1623625733",
            "description": "Having some fun with typography and making dice cause @blackle / cheezy music added for your enjoyment. (play some music to make the background EQ move)",
            "flags": 64,
            "hasliked": 0,
            "id": "Nl23Rw",
            "likes": 53,
            "name": "Dice Game | Die Die Die",
            "published": 3,
            "tags": [
                "raymarching",
                "game",
                "text",
                "audio",
                "visualizer",
                "typography",
                "dice"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 5155
        },
        "renderpass": [
            {
                "code": "/**\n\n     _____     __     ______     ______        ______     ______     __    __     ______    \n    /\\  __-.  /\\ \\   /\\  ___\\   /\\  ___\\      /\\  ___\\   /\\  __ \\   /\\ \"-./  \\   /\\  ___\\   \n    \\ \\ \\/\\ \\ \\ \\ \\  \\ \\ \\____  \\ \\  __\\      \\ \\ \\__ \\  \\ \\  __ \\  \\ \\ \\-./\\ \\  \\ \\  __\\   \n     \\ \\____-  \\ \\_\\  \\ \\_____\\  \\ \\_____\\     \\ \\_____\\  \\ \\_\\ \\_\\  \\ \\_\\ \\ \\_\\  \\ \\_____\\ \n      \\/____/   \\/_/   \\/_____/   \\/_____/      \\/_____/   \\/_/\\/_/   \\/_/  \\/_/   \\/_____/ \n                                                                                           \n\n    @byt3_m3chanic | 06/13/2021\n    \n    more typography stuff | die = 1 dice\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .001\n\nfloat sampleFreq(float freq) { return texture(iChannel0, vec2(freq, 0.25)).x;}\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n//@iq\nfloat box(vec3 p, vec3 b, in vec4 r )\n{   r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\tvec3 d = abs(p) - b+vec3(r.x,0,0);\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n// Letters from 2D to 3D extruded SDF's\nfloat getD(vec2 uv)\n{\n    float letd = box(uv,vec2(.125,.25),vec4(.125,.125,.00,0));\n    letd=abs(letd)-.05;\n    letd=min(box(uv+vec2(.125, .0),vec2(.05,.3)),letd);\n    return letd;\n}\nfloat getI(vec2 uv)\n{\n    uv.y=abs(uv.y);\n    float leti = box(uv,vec2(.05,.3));\n    leti = min(box(uv-vec2(.0, .25),vec2(.20,.05)),leti);\n    return leti;\n}\nfloat getC(vec2 uv)\n{\n    float letc = box(uv-vec2(.125,0),vec2(.25,.25),vec4(0,0,.2,.2));\n    letc=abs(letc)-.05;\n    letc=max(letc,-box(uv-vec2(.715 , .0),vec2(.5,.5)));\n    return letc;\n}\nfloat getE(vec2 uv)\n{\n    uv.y=abs(uv.y);\n    float lete = box(uv-vec2(.0, .0),vec2(.05,.3));\n    lete = min(box(uv-vec2(.1, .0),vec2(.10,.05)),lete);\n    lete = min(box(uv-vec2(.125, .25),vec2(.15,.05)),lete);\n    return lete;\n}\n//@iq\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat glow=0.,g_hs,s_hs;\nfloat mtime,time;\nmat2 turn,r90,r180;\n\nfloat dice(vec3 p)\n{\n    vec3 p3 = vec3(abs(p.x),p.y,abs(p.z));\n    vec3 p2 = vec3(abs(p.x),p.yz);\n    \n    float dz = .1;\n    float ox = .35;\n    float cz = .575;\n    \n    float base = box(p,vec3(.5,.5,.5))-.075;\n    // has to be a better way - I dont know it yet\n    float dots;\n    dots = length(abs(p)-vec3(ox,ox,cz))-dz;\n    dots = min(length(p2-vec3(cz,ox,ox))-dz,dots);\n    dots = min(length(p2-vec3(cz,-ox,-ox))-dz,dots);\n    dots = min(length(p3-vec3(ox,-cz,ox))-dz,dots);\n    dots = min(length(p3-vec3(ox,-cz,0))-dz,dots);\n    dots = min(length(p-vec3(cz,0,0))-dz,dots);\n    dots = min(length(p-vec3(0,cz,0))-dz,dots);\n    dots = min(length(p-vec3(0,0,cz))-dz,dots);\n    \n    base = max(base,-dots);\n    \n    return base;\n}\n\nvec2 map(vec3 pos, float sg)\n{\n    pos.y+=.85;\n    vec2 res = vec2(1e5,0.);\n    vec3 q = pos-vec3(0.,.75,0.);\n    vec3 p = pos-vec3(0.,.5,0.);\n\n    q.xz*=turn;\n\n    float amount = 8.;\n    float a = atan(q.z, q.x);\n    //@shane rep\n    float ia = floor(a/6.2831853*amount);\n    ia = (ia + .5)/amount*6.2831853;\n    //id and wave\n    float id = -mod(ia,.0);\n    float cy = sin( id*2. + (iTime * .5) * PI) * 0.5;\n    q.y +=cy;\n    q.xz *= rot(ia);\n    q.x -= 3.65;\n  \n    float hs = hash21(vec2(id,3.34));\n    int pk = int(floor(hs*10.));\n    //turn dice to random side\n    vec3 dp = q;\n    dp.yx*=turn;\n    dp.zx*=turn;\n    if(pk==1) dp.yz*=r90;\n    if(pk==2) dp.yz*=-r90;\n    if(pk==3) dp.xy*=r90;\n    if(pk==4) dp.xy*=-r90;\n    if(pk==5) dp.xy*=r180;\n\n    float d1 = dice(dp);\n    if(d1<res.x){\n        res = vec2(d1,2.);\n        hit=p;\n        g_hs=hs;\n    }\n\n    p.yz+=vec2(-1.5,.0);\n    p*=.35;\n    \n    float ld=getD(p.xz+vec2(.70,0.));\n    ld=abs(abs(ld)-.025)-.0075;\n    float td = opx(ld,p.y,.025);\n    \n    float li=getI(p.xz+vec2(.20,0.));\n    li=abs(abs(li)-.025)-.0075;\n    float ti = opx(li,p.y,.025);    \n\n    float lc=getC(p.xz-vec2(.30,0.));\n    lc=abs(abs(lc)-.025)-.0075;\n    float tc = opx(lc,p.y,.025); \n    \n    float le=getE(p.xz-vec2(.70,0.));\n    le=abs(abs(le)-.025)-.0075;\n    float te = opx(le,p.y,.025); \n    \n    td=min(ti,td);\n    td=min(tc,td);\n    td=min(te,td);\n    \n    if(td<res.x)\n    {\n        res=vec2(td,3.);\n    \thit=pos;\n    }\n    \n    if(sg>0.) glow += .0001/(.01+td*td);\n\n    float flr = pos.y+1.5;\n    if(flr<res.x)\n    {\n        res=vec2(flr,1.);\n    \thit=pos;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += ray.x * .75;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec4 FC = vec4(0.078,0.078,0.078,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,192, 1.);\n\n    hitPoint = hit;\n    s_hs=g_hs;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(3,8,-8);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h * .95;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        \n        diff *= shdw;\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n\n        if(m==1.){\n        vec3 clr =mix(vec3(0.000,0.502,0.016),vec3(0.043,0.529,0.596),uv.y+.5);\n            h=vec3(.15);\n            //big back visualizer\n            vec2 uv = (hitPoint.xz-vec2(0,0))*1.5;\n            vec2 f = fract(uv)-.5;\n            vec2 fid = floor(uv)+.5;\n            float ht = sampleFreq(abs(fid.x)*.05);\n            float ff = box(f,vec2(.45));\n            ff=smoothstep(.011,.01,ff);\n            \n            if(ht>abs(fid.y*.095)) h=mix(h,clr,ff);\n            \n            ref = vec3(.8)-fresnel;\n            C+=diff*h;\n        }\n        \n        if(m==2.){\n            vec3 hp = hitPoint;\n            h=s_hs>.5?vec3(0):vec3(1);\n            ref = vec3(.6)-fresnel;\n            C+=(diff*h)+spec;\n        }\n  \n        if(m==3.){\n            h=vec3(.95);\n            ref = vec3(.6)-fresnel;\n            C+=diff*h;\n        }\n\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    \n    } else {\n        C = FC.rgb;ref=vec3(.35);\n    }\n\n    C = mix(FC.rgb,C,  exp(-.000025*d*d*d));     \n    \n   // \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r90=rot(90.*PI/180.);\n    r180=rot(180.*PI/180.);\n    mtime=floor(abs(T));\n    turn = rot(T*20.*PI/180.);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,6.25);\n    vec3 rd = normalize(vec3(uv,-1));\n    // camera //\n    mat2 rx =rot(-1.4);\n    mat2 ry =rot(-.2);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n    // camera //\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 3.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.000015*d*d*d));\n    }\n    \n    //glow \n    glow=clamp(glow,0.,.85);\n    vec3 clr =mix(vec3(0.024,0.878,0.733),vec3(0.337,0.839,0.000),uv.y+.5);\n    C = mix(C,clr,glow);\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    // gamma\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 32382,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/rxpapi/dice-game"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}