{
    "Shader": {
        "info": {
            "date": "1565235162",
            "description": "for more wikipedia.org/wiki/Smoothness, THIS IS THE smin() sabs() collection, trying to unify and sort smin()-likes\nWAS child/subset of a huge code collection: https://www.shadertoy.com/view/XlVyDK\naimed to have 3 muscles around a bone with smin-skin",
            "flags": 0,
            "hasliked": 0,
            "id": "3t2XzW",
            "likes": 7,
            "name": "sMin sAbs collectioin Bone3",
            "published": 3,
            "tags": [
                "smin",
                "bone",
                "muscle",
                "collection",
                "sabs"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 677
        },
        "renderpass": [
            {
                "code": "//start of smin()collection  2023-08\n//\n//miq() maq() = fast   minMax Quadratic   (fast , low continuity  , is not commutative, order matters)\n//mip() map() = medium minMax Polynomial  (performance compromise , is not commutative, order matters)\n//mie() mae() = slow   minMax Exponential (slow , smoothest       , is     commutative == sum of parallel resistors)\n//miq() maq() = slow   generalization of mie() mae(), untested, unknown\n//  \n//all (smooth) union functions have 3-letters as function name\n//    - longer common labels are popularized by: https://mercury.sexy/hg_sdf/\n//1st letter == [m...] (from min()+max())\n//2nd letter selects 1of3 boolean fuzzy-unions:\n//    [...a...]=mAx/union=OR\n//  , [...i...]=mIn/intersection=AND\n//  , [...e...]=aNotB    (mo*() mu*() namespaces are already shorthand for modulos and multiplications)\n//3rd letter selects type-of-smoothing-union\n//    -  pick and chose compromises (ideally LOD-scaled-by-distance-to-camera)\n//smoothUnion flavors == type-of-smoothing-union:\n//m*q()==sMin[Q]uadratic      fast   ,nonCommutative! low    continuity (worse                reflections) (quadratic continuity)\n//m*p()==sMin[P]olynomial     medium ,nonCommutative! decent continuity (better               reflections)\n//m*e()==sMin[E]xponential    slow   ,   commutative! great  continuity (exponentially better reflections)\n//m*g()==sMin[G]eneral        slowest,   commutative? a generalization of \"exponential\"\n//      \n//uses prefix notation to be more type independent: eg su(a,b) == a-b  (infix notation is more type constraining)\n//\n//asymetric smooth unions: https://www.shadertoy.com/view/sscXDs\n//sAbs()                 : sabs==smin(abs(x0),abs(x2),smoothness) https://www.shadertoy.com/results?query=sabs\n//(this collection lacks sabs(), it pre-dates COMMON use of sabs()\n//(except for almostIdentity() of iqHeart, which is an sAbs()-special-case-subset.)\n//\n//\n//[m*q]== sMinQuadratic is fast (use for low LOD, because reflection on it may look suboptimal (low continuity))\n//symmetry: maq()miq()meq() all use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//uses ar() preCalculation to evade division by 0 AND to scale inputs to fit better to other smin flavors: (soft logic,by @paniq? ) \nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union, useful to scale different smin types more similar.\n//sMinQuadratic has 1 uncaught use-case; max(-a,b),gets negated,which is fixed|evaded by swapping a and b inputs\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,(ma0(k.z-b)))\n#define mima2(a,b,k) mima3((a+b),abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,((b)*k.y),k)          //unifying subroutine for *quadratic()\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\nfloat maq(float a,float b,float k){return mima(a,b,vec4( 1, 1,ar(k)));}//sMaxQuadrartic()  // max( a, b,k)==-min(-a,-b,k)\nfloat miq(float a,float b,float k){return mima(a,b,vec4(-1, 1,ar(k)));}//sMinQuadrartic()  //-max(-a,-b,k)== min( a,b,k)\nfloat meq(float a,float b,float k){return mima(a,b,vec4( 1,-1,ar(k)));}//sDifQuadrartic()  // max( a,-b,k)==-min(-a,b,k)\n//by using mima(), this easily extends to vec2..vec4, but most use cases of trhis are only type float.\n//\n//\n//[m*p]== sMinPolynomial (by Inigo Quilez) is fast but not commutative; mip2() is subroutine\n#define mip2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mip2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))   //ientity using mix() and less prefix notation\n//#define mip(a,b,k) mip2(a,b,k,sat(u5(((b)-(a))/(k)))) //backup with less prefix notation\n#define mip(a,b,k) mip2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))   //sMinPolynomial\n#define map(a,b,k) ne(mip(ne(a),ne(b),k))                         //sMaxPolynomial\n#define mep(a,b,k) ne(mip(   a ,ne(b),k))                         //sDifPolynomial\n//by using mip2(), this easily extends to vec2..vec4\n//\n//\n//[m*e]==sMinExponential is slow but commutative (identical to the resistance-sum of 2 parallel resistors)\n//as this uses a LOT of reciprocals, ONLY when you want to mix() this with the above smin-flavors, , you should pre-reciprocal the [k] of [m*e], by doing:  k=1./K\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k) //sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))                    //sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)                        //sMinExponential\n//by using mae(), this easily extends to vec2..vec4\n//\n//\n//below is rarely used, and theres multipla generalization-approaches.\n//as extension to sMinExponential, sAvgExponential() uses commutative property of sMaxExponential() \n//to get an AVERAGE of more than 2 inputs [a,b].\n//the resistorSum of parallel resistors is the reciprocal of the sum of all ReciprocalResistances.\n//recsum() is a subroutine of sAvgExponential() , with more than 1 input\nfloat recsum(vec2 a){return 1./(su(1./a));}\n//the 1/x division can be deferred for speed (as below)\n//that is trivial with 2 or 3 [a,b,c], tricky with more\n//... see infionite grid of 1OhmResistors : https://xkcd.com/356/\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)   //sMaxExponential with no prefix notation\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))       \n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//abve 2 lines have 2 or 3 reciprocals, multiplied, to save on 1 division\n//for 4 inputs==parallelResistors the solution is = resistor4(a,b,c,d)=1./((1./a)+(1./b)+(1./c)+(1./d))\n//but this case was not yet needed on shadertoy, and more divisions come at a cost.\n#define mipo2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define mipo3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)                    //sAvgExponential\n//maAv can be used to calculate a smooth layer of [skin]\n//around multiple [bones,muscles and other organs]\n//\n//\n//\n//[m*p]== sMinGeneral  of  /3lycWd  (also returns [c] for texture interpolation)\n//estends sMinExponential, not sure by how much\n//untested, no [max] or [union] function namespace\nfloat mig(float a, float b,float k,float p,out float c\n){float m=pow(ma0(k-ab(a-b)),p)*.5/p/pow(k,p-1.)\n ;c=m*p/k;if(a>b)c-=1.;return min(a,b)-m;}\n#define smix(a,b,c) mix(a,b,abs(c))\n/*\ntext by iq, 2021-01-30\nI think the better generalization (with one less pow and one less division is): \n\nfloat smin(float a, float b, float k, float p, out float t){\n    float h = max(k - abs(a-b), 0.0)/k;\n    t = 0.5 * pow(h, p);\n    float m = t*k/p; \n    t = (a < b) ? t : t-1.0;\n    return min(a,  b) - m;}\nor as I like to code it, \nvec2 smin( float a, float b, float k, float p ){\n    float h = max(k - abs(a-b), 0.0)/k;\n    float m = 0.5 * pow(h, p);\n    float s = m*k/p; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);}\n*/\n//\n//end of smin collection\n\n\n\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(iTime*vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-mipo3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\nw11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n);}//somehow almost correct.\n\nvec4 demoSmin(vec2 u,vec2 m,vec2 n//smin (exponential and polinomial) , with automativDifferenciation\n){w11 a=w11(u.x-m.x*9.,1.)\n ;w11 b=w11(u.x-m.x*9.,1.)\n ;m.x=abs(m.x)+.2//optional evasion of very short wavelength\n ;vec4 c=vec4(0)\n ;float amp=1.//m.y\n ;a=   mu(co(di(a,di(m.x,mu(pi,.5)))),amp)//a.b is analytic first derivative of a.a\n ;b=ad(mu(si(di(b,di(m.x,mu(pi,.5)))),amp),mu(si(b),.3))//b.b is analytic first derivative of b.a\n ;a=su(co(mu(a,2.)),mu(a,.2))\n ;b=su(si(mu(b,2.)),mu(b,.561))\n ;w11 d=mae(a,b,1./m.y)\n ;w11 e=mae(a,b,1./m.y)\n ;w11 f=map(a,b,3.*m.y)\n ;c.y=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.x=abs(b.a-u.y)/sqrt(1.+b.b*b.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.z=abs(d.a-u.y)/sqrt(1.+d.b*d.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.w=abs(f.a-u.y)/sqrt(1.+f.b*f.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;//c=abs(c-.2)-.1//optional shows how this is NOT distance2Sin()\n ;c=abs(c-aaa*2.)-aaa*.5//optional double line\n ;c=smoothstep(aaa,-aaa,c)\n ;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n ;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec4 y=vec4(angleToColor(vec3(rainb.y,1,1)),c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(angleToColor(vec3(rainb.z,1,1)),c.z)//coordinate system in magenta/pink\n ;vec4 w=vec4(angleToColor(vec3(rainb.w,1,1)),c.w)//coordinate system in magenta/pink\n ;x.xyz*=x.w;y.xyz*=y.w;z.xyz*=z.w;w.xyz*=w.w//alpha premultiplied\n ;x=pdOver(y,x)\n ;x=pdOver(z,x)\n ;x=pdOver(w,x)\n ;return x;}\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n//end of smin collection\n\n\n\n                      \n\n\n                      \n                      \n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n\nvec2 debugHg2(vec3 u){\n ;vec2 r=vec2(zFar,0.)\n ;float t=cos(iTime)*.4+.5\n ;//r=minx(r,CoordCross(u))//coordinate crosses\n ;u.x=1.-u.x//flip towards light source\n ;//r=box(u,vec3(1))-t\n ;//r=length(u-bicapsule3(u,vec3(-.5,0,2),vec3(.5,0,2),.7,.2))-.1\n ;//bicapsule(u,vec3(1,0,0),vec3(0,0,1),.5,2.)\n ;//r=Blob(u)\n ;//r=fPlane(abs(u),vec3(1,1,1),-1.5)//the raymarcher is not ideal for this one,with its alpha fadeout.\n ;//r=boxf(u,vec3(1))-.5\n ;//r=corner(u.xy)\n ;//r=cylinder(u,1.,1.)\n ;//failed to make a rounded cylinder via roundit()\n ;//r=ls(u,vec3(0),vec3(1,2,3))-t\n ;//r=lsY(u,vec2(1,2))//could not get it to work instantly\n ;//r=torus(u,1.)-1.\n ;//r=disc(u,vec2(1.))-2.//could not get it to work instantly\n ;//r=hexCircum(u,1.)-1.\n ;//r=fCone(u,1.,2.)\n ;return r;}\n//2-distance input unions\n//note,for higher dimensions,i may prefer; input (a,b); over; input (a.x,a.y)\n#define miChamfer(a,b,r) mi(mi(a,b),(a-r+b)*sq(.5))\n#define maChamfer(a,b,r) ma(ma(a,b),(a+r+b)*sq(.5))\n#define meChamfer(a,b,r) maChamfer(a,-b,r)\n//above chamfer are worse around 90deg; below chamfer is worse near 180deg. both are still good upper bounds. below is \"smoother\"\n#define chamfer1802(a,b,r,e) mi(a,b)-(e)*(e)*.25/(r)\n#define chamfer180(a,b,r) chamfer1802(a,b,r,ma0(r-abs(a-(b))))\n//a is 2 distances,b is a radius //todo,compare with mima()\n#define miRound(a,b) mi(ma0(a),-b)+le(ma0(b+a))//is likely wrong\n#define maRound(a,b) -fOpRoundMin(-a,b)//is likely wrong\n#define meRound(a,b) fOpRoundMin(a*vec2(1,-1),r);}//is likely wrong\n/*\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat micolumns _M(1.)\n ;p.x+=sqrt(.5)*-r+c*sqrt(2.)\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b)\n ;}\n\nfloat macolumns _M(-1.)\n p.y+=c;p.x=sqrt(.5)*(r+c)/p.x\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=-mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b);}//fails on its own\n#define mecolumns(a,b,r,n) -macolumns(a,-b,r,n)/**/\n\n\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return mi(mi(a,b),.5*(u+a+abs(mo(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\nvec2 debugHg(vec3 u){\n ;return debugHg2(u)\n ;float r=0.\n ;u.z-=1.\n ;float t=cos(iTime)*.4+.5\n ;float a=box(u   ,vec3(1))-t\n ;//u.xy*=r2(1.)\n ;float b=box(u-1.,vec3(1))-.2\n ;//return mi(a,b)\n ;//return ma(a,b)\n ;//return ma(a,-b)\n ;//return miChamfer(a,b,0.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return miChamfer(a,b,3.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return maChamfer(a,b,.5)//not sure if broken or tracer issue\n ;//return meChamfer(a,b,.5)\n ;//return chamfer180(a,b,.5)//round chamfer is best\n ;//return -chamfer180(-a,-b,.5)//max() round chamfer is weird but fun\n ;//return -chamfer180(-a,b,.23)//max(a,-b) round chamfer easily gets discotinuous\n ;//return chamfer180(a,b,3.5)//overchamfering round is bumpy\n ;//return miRound(a,b)//todo fixme\n ;//return mistairs(a,b,.5,13.)\n ;//return mistairs(a,b,.5,13.)\n ;//return mestairs(a,b,.5,13.)\n ;a=micolumns(a,b,.5,4.)\n ;//return mecolumns(a,b,.5,4.)\n ;//return mucolumns(a,b,.5,4.) \n ;//return macolumns(a,b,.5,4.)//macolumns fails\n ;//return mecolumns(a,b,.5,4.)\n ;//return pipe(a,b,.2)\n ;//return engrave(a,b,.5)\n ;//return -groove(-a,b,.5,.1)\n ;//return tongue(a,b,.5,.1)\n ;return vec2(a,1);}\n\n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\n\n//someone overthought checkerboard patterns\n//float xnor(float x,float y){return abs(x+y-1.);}// abs(0+0-1)-1 abs(1+0-1)-0 abs(0+1-1)-0 abs(1+1-1)-1\n//xnor(xnor(e.x,e.y),e.z)//checkerboard3d\n\n\n\n                    \n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\n\n#define fsaa (2./min(iResolution.x,iResolution.y))\n                       \nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n\n//float gm3(mat3 a,int n){return a[n/3][n%3];}//use a matrix as if it is a list.\n\n\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n#define sm(a,b)smoothstep(a-10./iResolution.y,a,b)\n      \n                     \n\n//where .a is a distance .b is intended to be a colorCode. if(any(.b<0)) it encodes a 4d textureID;else ist is a texturte.rgba\nstruct v14{vec1 a;vec4 b;};\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;} \n//these likely have simpler expressions,its too late timeofday for me to bother now.\nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//todo,  define a mix for struct v14\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\n\nvec4 demo2d1(vec2 u,vec2 m,vec2 n\n){vec2 i=mix(n,m,abs(cos(iTime*2.)))\n ;vec4 c=sqrt(vec4(dd    (m-u) ,dd    (n-u) ,dd    (u) ,dd    (i-u)))//abs(cos())bounce for direction\n ;vec4 d=     vec4(ma(abs(m-u)),ma(abs(n-u)),ma(abs(u)),ma(abs(i-u)))\n ;c=mix(c,d,2.*(cos(iTime)))\n ;float thick=.005,diam=.1\n ;c=smoothstep(.01,-.01,abs(abs(c-diam)-diam+thick)-thick)//i know theres better ways to do this abs(abs())identities...\n ;c.xy+=c.w;return vec4(c.xyz,ma(c.xyz))\n ;vec4 a=pdOver(vec4(0,c.y,0,c.y),vec4(c.x,0,0,c.x))//green over red\n ;c     =pdOver(vec4(c.w,c.w,0,c.w),vec4(0,0,c.z,c.z))//yellow over blue\n ;c     =pdOver(a,c)//green over red over yellow over blue\n ;return c;}\n\nvec3 sspm(float a,vec3 b){return smoothstep(a,-a,b);}\n\n\nvoid mainImage(out vec4 O,vec2 u\n){O=vec4(0)\n ;//O=pdOver(O,demoshit(u))//mouseCoords\n ;u=fra(u)\n ;vec2 auto=(cs(iTime*.5)+vec2(.8,0))*1.2+cs(iTime*3.61)*.2\n ;vec4 mouse=iMouse;\n ;mouse=iMouseZwFix(mouse,true)\n ;vec2 m=mix(auto,fra(mouse.xy),sign(mouse.z))\n ;vec2 n=mix(auto.yx,fra(mouse.zw),sign(mouse.z))\n ;O=pdOver(O,demo2d1(u,m,n))//mouseCoords is a reasonable top layer\n //you may want to comment out somelayers for performand over seizures.\n\n ;//O=pdOver(O,demoSmin(u,m,n))//ad 1d smin\n ;O=pdOver(O,demoSminBone3(u,m,n))//muscles around a bone, kinda\n ;//if(O.w>=1.)return;O=pdOver(O,demoComplex(u,m,n))\n ;//if(O.w>=1.)return ;float c=checkerBoolT(u*1.61)\n ;//if(c<.5)O=pdOver(O,demoRainbow(u,m,n))//hue gradients\n ;//else   O=pdOver(O,demo2NoiseCel(u,m)*vec4(.3,.3,.3,1.))//celularNoise\n ;}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//this code is extracted from a way too big collection: https://www.shadertoy.com/view/XlVyDK\n//with a bias for smin:\n\n/*\n/**/\n\n//has AD=automatic Differentiation via chain rule but only demoes it in 1d\n//note to self,default background is black,otherwise tiny shadertoy shaders will be white image on white background.\n\n#define vec1 float\n#define norma normalize\n//#define ss smoothstep\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.) could need benchmarking\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1 //https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define cl(a,b,c) mi(ma(a,0.),1.)//till i define this for AD\n#define sat(x) cl(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define u5cos(a) u5(cos(a))\nstruct v11{vec1 a;vec1 b;};\nstruct v22{vec2 a;vec2 b;};\nstruct v33{vec3 a;vec3 b;};//for 2 domains(density/distance field)\nstruct v44{vec4 a;vec4 b;};\nstruct v444{vec4 a;vec4 b;vec4 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v333{vec3 a;vec3 b;vec3 c;};\nstruct v3333{vec3 a;vec3 b;vec3 c;vec3 d;};\nstruct v222{vec2 a;vec2 b;vec2 c;};\n//v222 g222(vec3 a,vec3 b){return v222(vec2(a.x,b.x),vec2(a.y,b.y),vec2(a.z,b.z));}\nv222 g222(v33 a){return v222(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv3333 muv(v3333 a,vec4 b){return v3333(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nvec4 ddv(v3333 a){return vec4(dd(a.a),dd(a.b),dd(a.c),dd(a.d));}\n//above [v*] struct implies matrix arithmetic,below [w*] struct implies AD,wherelater spaces are (analytic) lower-exponent-differentials\n//[.b] is always a derivative of [.a],along one (of multiple) domain(s)\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\nstruct DAm2{w13 x;w13 y;w13 z;};//for 3 domains (density/distance field) \nstruct DAm1{w12 x;w12 y;};//for 2 domains (heightmap,isoline,contour)\nstruct DAm0{w11 x;};//for 2 domains (heightmap,isoline,contour)\n\n\n\n\n\nw11 ma(w11 a,vec1 b){return w11(max(a.a,b),max(a.b,b));}\nw11 mi(w11 a,vec1 b){return w11(min(a.a,b),min(a.b,b));}\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define viewZoom 3.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/viewZoom)\n#define fra(u)(u-.5*iResolution.xy)*viewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n//DAm2 maxdm(DAm2 a,v2 p){return DAm2(maxd(a.a,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\n//DAm2 mindm(DAm2 a,v2 p){return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\n//DAm2 maxdm(DAm2 a,vec1 p){return maxdm(a,v2(p));}\n//DAm2 mindm(DAm2 a,vec1 p){return mindm(a,v2(p));}//needed for fast clamping\n//w13 maxdm(w13 a,w13 b,w13 c){return maxd(maxd(a,b),c);}\n//w13 maxdm(DAm2 a){return maxdm(a.a,a.y,a.z);}\n//The 3(or 2)dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN p)]:\n//where N=number of domains,range [0..3]\nv444 da_domain(vec3 p){return v444(vec4(p.x,1,0,0),vec4(p.y,0,1,0),vec4(p.z,0,0,1));}\nv33 da_domain(vec2 p){return v33(vec3(p.x,1,0),vec3(p.y,0,1));}\nvec2 da_domain(vec1 p){return vec2(p,1);}//for 1 domain(linear equation)\n//vNN() declares c11() c22() c33() c44()... for implicit typecasting into structs; v11 v22 v33 v44\nv11 c11(vec1 a,vec1 b){return v11(a,b);}\nv11 c11(vec1 a){return v11(a,a);}\n#define vNNv(z,x) {return z(x(a),x(b));}\n#define vNNu(z,x,y) z x(vec1 a,y b)vNNv(z,y) z x(y a,vec1 b)vNNv(z,y) z x(vec1 a,vec1 b)vNNv(z,y)\n#define vNN(z,y,x) vNNu(z,y,x) z y(x a,x b){return z(a,b);} z y(x a){return z(a,a);}\nvNN(v22,c22,vec2)\nvNN(v33,c33,vec3)\nvNN(v44,c44,vec4)\n\n\n//param1MAT dreaming of vec5 and vec2x2,also,this keeps define-namespace unused,by declating function sets!\n//lets me type \" a=min(vec3(a),float(b)) a=pow(vec3(a),float(b)) \" with less explicit typecasting and shorter aliases:\n//negate,reciprocal,abs,log,sin,asin,cos,acos,tan,atan,fract,floor\n#define NE(y,z) z ne(z a){return -a;}y ne(y a){return y(-a.a,-a.b);}\nNE(v11,vec1)NE(v22,vec2)NE(v33,vec3)NE(v44,vec4)\nw13 ne(w13 a){return w13(-a.a,-a.b);}\nw12 ne(w12 a){return w12(-a.a,-a.b);}\nw11 ne(w11 a){return w11(-a.a,-a.b);}\n#define def1E(z,y,x) x z(x a){return y(a);}\n#define def1(a,b) def1E(a,b,vec1) def1E(a,b,vec2) def1E(a,b,vec3) def1E(a,b,vec4)\n#define re(a) di(1.,b)\ndef1(ab,abs)def1(sg,sign)def1(sq,sqrt)\ndef1(ln,log)def1(ex,exp)\ndef1(si,sin)def1(asi,asin)\ndef1(co,cos)def1(aco,acos)\ndef1(ta,tan)def1(ata,atan)\ndef1(fr,fract)\ndef1(fl,floor)\n//----param2MAT\n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(ne(a)))\n#define sub(a,b) ((a)-(b))\n#define add(a,b) ((a)+(b))//sub(a,ne(b))\n#define div(a,b) ((a)/(b))\n#define mul(a,b) ((a)*(b)) //di(a,re(b)) reciprocal define may lose time&precision\n//a lot of these just reserve namespaces //dot() is special for folding to a vec1 uses defD()\n#define def2D(z,y,x) vec1 z(vec1 a,x b){return y(x(a),b);} vec1 z(x a,vec1 b){return y(a,x(b));}\n#define def2F(z,y,x) vec1 z(x a,x b){return y(a,b);}\n#define defF(a,b) def2F(a,b,vec1) def2F(a,b,vec2) def2F(a,b,vec3) def2F(a,b,vec4)\n#define defD(a,b) defF(a,b) def2D(a,b,vec2) def2D(a,b,vec3) def2D(a,b,vec4)\n//vNN operands foldlike this:\n#define vXX(z,y) z(y(a.a,b),y(a.b,b))\n#define vXY(z,y) z(y(a.a,b.a),y(a.b,b.a))\n#define vvZ(z,w,v,y) w z(w a,v b){return y(w,z);}w z(w a,vec1 b){return y(w,z);}w z(v11 a,v b){return y(w,z);}\n#define vvY(z,w,v,y) w z(w a,v b){return y(w,z);}w z(v a,w b){return y(w,z);}w z(w a,w b){return y(w,z);}\n#define vvX(y,w,v) vvZ(y,w,v,vXX) vvY(y,w,v11,vXY)\n#define vMM(z) vvX(z,v22,vec2)vvX(z,v33,vec3)vvX(z,v44,vec4)v11 z(v11 a,v11 b){return vXY(v11,z);}v11 z(v11 a,vec1 b){return vXX(v11,z);}\n//alias2_NinputAsVec; due to symmetrically defined alising,in favor of min() max() functions (previously called miv() mav()):\n//note that dt(vec4 a)==dot(dot(a.x,a.y),dot(a.z,a.w)),equivalent to ad(vec4 a)\n//note that po(vec4 a)==pow(pow(a.x,a.y),pow(a.z,a.w)),which is quite silly\n//note that su(vec4 a)==(a.x-a.y)-(a.z-a.w)=a.x+a.w-a.y-a.z=a.x+a.w-(a.y+a.z)\n//note that di(vec4 a)==(a.x/a.y)/(a.z/a.w)=a.x*a.w/a.y/a.z=a.x*a.w-(a.y*a.z)\n\n//typeless-generalized function calls are split into 9 def* sub-defines:\n//this generates a LOT of typed-functions on runtime via defM()\n//with all relevant permutations, including \"1 param is float, one is vec3\"\n//AND \"one param is vec2 the other is also vec2\" ...)\n//(this compacted style emerged from making general-automatic-differentiation in GLES100.)\n\n#define Fo1(u,t) vec1 u(t a){return u(a.x,a.y);}\n#define Fo2(u,t) vec1 u(t a){return u(u(a.xy),a.z);}\n#define Fo3(u,t) vec1 u(t a){return u(u(a.xy),u(a.zw));}\n#define Fon(u) Fo1(u,vec2) Fo2(u,vec3) Fo3(u,vec4)\n//(alternatively fo() couls also be defined as dot(a,1.),where parts of a are negated or reciprocal)\n#define def2U(z,y,x) x z(vec1 a,x b){return y(x(a),b);} x z(x a,vec1 b){return y(a,x(b));}\n#define def2E(z,y,x) x z(x a,x b){return y(a,b);}\n#define def2(a,b) def2E(a,b,vec1) def2E(a,b,vec2) def2E(a,b,vec3) def2E(a,b,vec4)\n#define defU(a,b) def2(a,b) def2U(a,b,vec2) def2U(a,b,vec3) def2U(a,b,vec4)\n#define defM(a,b) defU(a,b) vMM(a) Fon(a)\ndefM(po,pow)\ndefM(mi,min)defM(ma,max)\ndefM(su,sub)defM(di,div)\ndefM(ad,add)defM(mu,mul)\ndefM(mo,mod)\ndefM(st,step)\n\n/*\n//higher domains for high-domain-permutations/zOrder/Noise\n//v33 su(vec3 a,v33 b){return v33(a-b.a,a-b.b);}\nv33 g33(vec2 a){return v33(vec3(a.x),vec3(a.y));}\nv333 su(vec3 a,v333 b){return v333(a-b.a,a-b.b,a-b.c);}\nv333 g333(v33 a,vec3 b){return v333(a.a,a.b,b);}\nv3333 g3333(vec3 a,v333 b){return v3333(a,b.a,b.b,b.c);}\nv44 fl(v44 a){return v44(fl(a.a),fl(a.b));}\nv44 fr(v44 a){return v44(fr(a.a),fr(a.b));}\n/**/\n\n//polar Complex dot()\nconst vec3 vs=vec3(-1,0,1);\n#define le(a) sq(dd(a))\ndefD(dt,dot)\n#define dd(a) dot(a,a)\n//vMM(dt)//breaks a pattern,due to being a foldingprojection\nFon(dt)\nvec2 perp(vec2 a){return a.yx*vs.xz;}\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nfloat perpdot(vec2 a,vec2 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n//\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(vec1 a){return cs(vec2(a,a));}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c2(c)-(c.a-c.b*i)\n#define c2(a)c4(anaa(a)).xy\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(vec1 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(vec1 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n\n\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time [t]\nfloat checkerBoolT(vec2 h,float t){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(t)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h,float t){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(t)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n\n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n\n\n \n//---param3MAT\n//SF3() is a hot mess to be simplified a lot! //only allows for vec1 ot vecmax\n//explicit namespace fold for scalar operations\n#define fi3(m,z,a,b,c) {return z(m(a),m(b),m(c));}\n#define Q3(z,a,b,c){return z(a,b,c);}\n#define SF3(n,y,z,a,b,c) n y(n a,n b,n c)fi3(n,z,a,b,c) n y(n a,n b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,n b,n c)fi3(n,z,a,b,c) n y(vec1 a,n b,vec1 c)fi3(n,z,a,b,c)\n#define scalar3(y,z) vec1 y(vec1 a,vec1 b,vec1 c)Q3(z,a,b,c) SF3(vec2,y,z,a,b,c) SF3(vec3,y,z,a,b,c) SF3(vec4,y,z,a,b,c)\nscalar3(mx,mix)\n//---param1AD Automatic Differenciation (needs param2MAT)\n//todo AD for;tan,asin,acos,atan,reciprocal\n//memo museum: for consistency structure changed: d->v00->v11;d1->v01->w12;d2->v02->w13\n//...the swivels oof d; are .xd ,the swivels of v0N (and [w*]) are .ab\nvec1 rec(float a){return(a==0.)?a:1./a;}//return [1/a] ,work safe//sqrt()and divisions require a worksave reciprocal operator:\n#define sqD(h)h sq(h a){vec1 q=sq(a.a);return h(q,.5*rec(q)*a.b);}\n#define cmD(h,i) h cmd(w11 a,i b){return h(a.a,mu(a.b,b));}\ncmD(w11,vec1)cmD(w12,vec2)cmD(w13,vec3)cmD(w14,vec4)//cmd() is special case of component-wise-multiplication,special because a.x==1: is subroutine of abs()\n//i am not too sure about my implementation on fr();\n//the hell,just use mo()instead,mo()has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)-=.0)\nvec1 jud(vec1 a){return mx(a,-1.,st(fr(a),0.)*st(0.,fract(a)));}\nvec2 jud(vec2 a){return vec2(jud(a.x),jud(a.y));}\nvec3 jud(vec3 a){return vec3(jud(a.x),jud(a.y),jud(a.z));}\nvec4 jud(vec4 a){return vec4(jud(a.x),jud(a.y),jud(a.z),jud(a.w));}\n//i should definitely define this by fract,and not by floor.\n//because fm-modulation taught me that i need fract()a lot more than floor()\n#define frD(h)h fr(h a){return h(fl(a.a),jud(a.b));}\n#define abD(h)h ab(h a){return cmd(w11(ab(a.a),sg(a.a)),a.b);}//w13(abs(a.x),sign(a.x)*a.d);}\n#define siD(h)h si(h a){return h(si(a.a),mu(co(a.a),a.b));}\n#define coD(h)h co(h a){return h(co(a.a),mu(ne(si(a.a)),a.b));}\n#define lgD(h)h ln(h a){return h(ln(a.a),di(a.b,a.a));}\n#define exD(h)h ex(h a){vec1 x=exp(a.a);return h(x,x*a.b);}\n#define DA1(h)h(w11)h(w12)h(w13)h(w14)\nDA1(abD)DA1(siD)DA1(coD)DA1(lgD)DA1(exD)DA1(sqD)DA1(frD)//because different functions have unique derivatives,\n//fl(a)=a-fr(a); hasvery slightly lower precision?rarely relevant.fract()has great precision on float!\n#define fl(a) su(a,fr(a))\n//---Param2AD are trickier: https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mo()mx()mi()ma()\n//AD_mo() ideally should be replaced by fr(),but that adds 1dvd()and 1mu(),BUT DA_mo(a,b) outperforms mu(fr(di(a,b)),b),via [reciprocal product rule]\n#define moD(h,i)h mo(h a,i b){return h(mo(a.a,b  ),fr(a.b));}\n#define moE(h,i)h mo(h a,i b){return h(mo(a.a,b.a),fr(a.b));}\n#define moF(h,i)h(w11,i)h(w12,i)h(w13,i)h(w14,i)\nmoF(moD,vec1)moF(moE,w11)\n#define miG(r,h,j) r mo(h a,r b){return r(mod(a.a,b.a),j(0));}\nmiG(w14,w13,vec4)miG(w14,w12,vec4)miG(w14,w11,vec4)miG(w13,w11,vec3)miG(w13,w12,vec3)\nw13 mo(vec1 a,w13 b){return w13(mod(a,b.a),vec3(0));}\nw12 mo(vec1 a,w12 b){return w12(mod(a,b.a),vec2(0));}\nw11 mo(vec1 a,w11 b){return w11(mod(a,b.a),0.);}\n//substraction is simple,because \"differentiation is integration\"; https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for; https://en.wikipedia.org/wiki/Translation_(geometry)\n//BUT if we substract a struct da from a vec1 or w11,we must negate the .b part.\n//i possibly messed this one up by not flipping the .a part,but i an not sure there.\n#define suNN(h,i,j)h su(i a,j b){return h(su(a.a,b.a),a.b);}h su(j a,i b){return h(su(a.a,b.a),-b.b);}\nsuNN(w12,w12,w11)suNN(w13,w13,w11)suNN(w13,w13,w12)//the leftmost param equals the larger param of the other 2 params\nsuNN(w14,w14,w11)suNN(w14,w14,w12)suNN(w14,w14,w13)//..the rightmost param is always smaller than the middle param\n#define suNM(t)t su(t a,vec1 b){return t(su(a.a,b),a.b);}t su(vec1 a,t b){return t(su(a,b.a),-b.b);}\n#define suMM(t)suNM(t)t su(t a,t b){return t(su(a.a,b.a),su(a.b,b.b));}\nsuMM(w11)suMM(w12)suMM(w13)suMM(w14)\n//in the end mix() has an identity,and that identity does translate into DA:\n#define mixd(a,b,c) ad(mu(c,su(a,b),a)\n//a big issue of this is that mixd() and mind() where defined as MAT-functions,vut using the AD-labeling\n//so is just deleted that junk code\n//I define mind()and=maxd(-,-)instead of maxd()and=mind(-,-)\n//because min()is far more common than max(),for z-buffering.\n//negation identity:max(a,b)--min(-a,-b),requires struct negation\n//addition is negated substraction.\n#define ad(a,b) su(a,ne(b))\n//AD_mu simplifies contextually ,scalar multiplication is tautological product_rule.\n#define adM2(h) h mu(h a,vec1 b){return h(mu(a.a,b),mu(a.b,b));}\n#define adM1(h) adM2(h)h mu(vec1 a,h b){return mu(b,a);}\n#define atta(h,i,j) h mu(i a,j b){return h(mu(a.a,b.a),ad(mu(a.b,b.a),mu(a.a,b.b)));}\n#define attA(h) atta(h,h,w11)atta(h,h,h)atta(h,w11,h)\nadM1(w11)adM1(w12)adM1(w13)adM1(w14)\natta(w11,w11,w11)attA(w12)attA(w13)attA(w14)//oh i really like this attA()-way of folding it\nDAm2 mu(DAm2 p,vec3 s){return DAm2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nDAm1 mu(DAm1 p,vec2 s){return DAm1(mu(p.x,s.x),mu(p.y,s.y));}\nDAm0 mu(DAm0 p,vec1 s){return DAm0(mu(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define rXX(h) h di(h a,vec1 b){return h(di(a.a,b),di(a.b,b));}h di(vec1 a,h b){return h(di(a,b.a),di((mu(ne(a),b.b)),mu(b.a,b.a)));}\nrXX(w11)rXX(w12)rXX(w13)rXX(w14)\n//inverse scalar multiplication is a tautolotgy.\n//some of these may be nonsensical\n#define rXY(h,i,j) i di(h a,i b){return i(di(a.a,b.a),di((mu(ne(a.a),b.b)),(b.a*b.a)));}i di(i a,j b){return i(di(a.a,b.a),di((su(mu(a.b,b.a),mu(a.a,b.b))),(mu(b.a,b.a))));}\nrXY(w13,w12,w11)\nrXY(w11,w13,w13)\nrXY(w12,w13,w11)\nrXY(w11,w14,w14)//just guessing this line\nrXY(w12,w14,w11)//just guessing this line\n//All exponential functions utilize their Base_E_identity:...which is still not efficient,but comes down to O(exp(n*log(n)))\n//pow (x,y)-=exp(log(x)*y)//baseE exponential and logarythmic functions.\n#define po(x,y)ex(mu(ln(x),x))\n/*\n//It gets trickier with functions that take 3 parameters:,applying the\n//https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem)with first derivatives.\n#define v0q vec1 q=length(vec2(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nw11 le(w11 x,w11 y){v0q;return w11(ll2\nw12 le(w12 x,w12 y){v0q;return w12(ll2\nw13 le(w13 x,w13 y){v0q;return w13(ll2\nw13 lengthw13(DAm2 u){return le(u.x,u.y);}//2*3domain\n//above is planar length 2 input parameters.below is 3d length.\nw13 le(w13 x,w13 y,w13 z){float q=length(vec3(x.a,y.a,z.a));return w13(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nw13 le(DAm2 u){return le(u.x,u.y,u.z);}//3*3domain\n//the utility of a length()function is clear.*/\n//su(ab(p),s)equals a translation away from the origin by [s] AND mirroring at origin,via abs()\n//...so it it clamps a an implicit surface to a limited \"thickness\" (in 3 domains),also translating its first derivatives.\nw12 suab(w12 p,vec1 s){return su(ab(p),s);}\nw11 suab(w11 p,vec1 s){return su(ab(p),s);}\nw13 suab(w13 p,vec1 s){return su(ab(p),s);}\nDAm2 suab(DAm2 p,vec3 s){return DAm2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nDAm1 suab(DAm1 p,vec2 s){return DAm1(suab(p.x,s.x),suab(p.y,s.y));}\nDAm0 suab(DAm0 p,vec1 s){return DAm0(suab(p.x,s));}\n\n//spheretracker /ePr is referenced by bicapsule() and other unsigned distances\n//ideally only a 4d marcher is defined,with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\nconst float iterRm=256.;\nconst float eRm=.0001;\nconst float zFar=200000.;\nconst vec2 EN=vec2(.005,0);\nfloat dFb(vec3 p);\n#define dNdom(u,a,b) (a(u+EN.b).x-a(u-EN.b).x)\n#define dNormal3X(u,a) normalize(vec3(dNdom(u,a,xyy),dNdom(u,a,yxy),dNdom(u,a,yyx)))\n \n\n//spheretracker\n//ideally only a 4d marcher is defined, with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\n//const float iterRm=160.;\n//const float eRm=.001;\n//const float zFar=20000.;\n\n//\"crossproduct\" and \"determinant\" are related,cross() is the bilin()* of a lin()_determinant()\n//therefore i can fold the detemrinant() mnamespace onto the cross() namespace.\n//a cross() has 2 inpouts,where a determinant() has 1 input\n//we generalize \"crossproduct\" into its ternary: \"find the only vector that in a 90deg angle to all inputs\"\nvec2 cr(vec2 a){return a.yx*vec2(-1,1);}//rotBy4\nvec3 cr(vec3 a,vec3 b){return cross(a,b);}\n//vec4 cr(vec4 a,vec4 b,vec4 c){\n//solve LinearEquation for   dot(a,d)=0;dot(b,d)=0;dot(c,d)=0;with additional constrains to length(d)==1\n//}\n//[a bilinear (2 input vectors) product with a vector result only exists in 3d and 7d,in 7f it has more than 2 results (handedness,signs)\n//7d_dotproduct() is the octonion_pairing to 3d_quaternion.\nfloat det2d(vec2 a,vec2 b){return dot(a,cr(b));}//a.x*b.y-a.y*b.x//2d determinant(mat2(a,b))==det2d(a,b)==perpendicular dotproduct perpdot dotperp\n                                                                                       \n                                                                                       \n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\nfrflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)frflpm(v44,c44)\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\nfloat Blob(vec3 p){p=ab(p);p=mx(p,p.yzx,st(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) ad(dt(p,n),d)\n#define abm(a,b) su(ab(a),b)//ditance taxicap   -b\n#define lbm(a,b) su(le(a),b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))//==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a))//i am not convinced by this one\n#define box(a,b) roundit(abm(a,b))\nfloat fBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(ma(d,vec3(0)))+ma(min(d,vec3(0)));}\n\n#define tiny .000001\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define ls2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sq(ls2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n//float lsNaive(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n //if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);//branching FAST line segment with a length of 1.\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;return dot(m,u.yx);}\n//return unsigned distance of [u] to line trough(0,0)and [m]\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\n//return distance of [u] to line_segment from(0,0)to [m]\n//[m] must NOT be normalized!\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//all above functions require m to be normalized, which is done exmplicityly with thebelow fiunctions.\n#define lineN(u,m) line(u,normalize(m))\n#define lsa(u,m)   abs(line(u,m))\n#define lsaN(u,m)  abs(line(u,normalize(m)))\n#define ilsN(u,m)  ils(u,normalize(m))\n#define ls1N(u,m)  ls1(u,normalize(m))\n#define lsN(u,m)   ls(u,normalize(m),m)\n#define lssN(u,n,a)lss13(u,normalize(n),a)\n//signed infinite line (unique because it has a sign bias), 2 variants are likely quite identical.\n#define lineInf(p,a,b) dot(normalize(vec2((b-a).yx)*vec2(1,-1)),p-a)\n#define lineInfbbb(u,m) dot(u-m.xy,(m.zw-m.xy)*vec2(-1,1))//signed distance to line \n//likely very identical to lineInf() ???//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//more generally,f should be normalized here for proper caling, but scaling is irrelevant as we only care fror the sign \n#define lsY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\nfloat lsYbbb(vec2 u,vec2 m,vec2 n){m=m-n;return (u.x-n.x)*m.y/m.x-u.y+n.y;}//likely identical to lsY()???\n//note that a torus can not be mStretch()ed into a tube\n\n\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n\n                                                                                       \nvec2 abx(vec2 a){return vec2(abs(a.x),a.y);}\n\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\nstruct v21{vec2 a;vec1 b;};//currently only for alpha compositing plans\nstruct v31{vec3 a;vec1 b;};//...for MAT arithmetic\nstruct v41{vec4 a;vec1 b;};\nv21 su(v21 a,v21 b){return v21(a.a-b.a,a.b-b.b);}\nv21 mu(v21 a,v21 b){return v21(a.a*b.a,a.b*b.b);}\nv21 mu(v21 a,vec1 b){return v21(a.a*b,a.b*b);}\nv31 su(v31 a,v31 b){return v31(a.a-b.a,a.b-b.b);}\nv31 mu(v31 a,v31 b){return v31(a.a*b.a,a.b*b.b);}\nv31 mu(v31 a,vec1 b){return v31(a.a*b,a.b*b);}\nv41 su(v41 a,v41 b){return v41(a.a-b.a,a.b-b.b);}\nv41 mu(v41 a,v41 b){return v41(a.a*b.a,a.b*b.b);}\nv41 mu(v41 a,vec1 b){return v41(a.a*b,a.b*b);}\n//generalizing alpha-compositing functions,named after porterDuff\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent,.W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs with their alpha;\n// a.xyz*=a.w ; b.xyz*=b.w\n//.x inputs (ant interpolants) should be sat()ed,or you likely get [color inverted hazes],this version si still not haze-free?\n//ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//ommits 2 functions,that return a or b,for simplicity\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n//#define pd5(z)z pdOut(z a,z b){return ut(b,a.b);}z pdOver(z a,z b){return ad(ut(b,a.b),a);}z pdAtop(z a,z b){return ad(ut(b,a.b),mu(a,b.b));}z pdXor(z a,z b){return ad(ut(b,a.b),ut(a,b.b));}\n//pd5(v11)pd5(v21)pd5(v31)pd5(v41)//if you want alpha seperated in a struct\n//making tweening/unifying functionms of alpha compositing is silly fun. c is best range [0..1]\n//this reduces it to 5. within pd() unifying function,because 4/5 include ut(a,b),i segregate 1/5_pdIn()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\nvec3 pf(vec4 a,float c,vec4 b//c sets a mix type of this generalized function\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//c sets a mix type.makes little sense to bilinn 4 functions on a plane,done anyways\n ;a=mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w)\n ;return a;}//you likely want to a=sat(a) the c.x input,or have some negative-outlineglow-colors on -1>c>1\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a){return rainbowt(-a,1./3.);}\nvec3 rainbows(float a,float b){return u5cos(2.*pi*ab012(a,b));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbows(float a){return rainbows(-a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 rainbows(vec3 c){ToRgb(rainbows)//cos-mix\nvec3 rainbowt(vec3 c){ToRgb(rainbowt)//linear-mix not identical to the below,but close\n\n                                                                                       \n#define hsv2rgb(c) c.z*mx(1.,sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt    //3 tri waves, most blurry, fast and precise, consoidder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}