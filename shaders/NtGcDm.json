{
    "Shader": {
        "info": {
            "date": "1661838214",
            "description": "This is an implementation of an animation from Craig S. Kaplan's \"Animated Color Mappings of Hinged Squares\" https://isohedral.ca/hinged-squares/ that appeared in the Bridges 2021 conference. Is this too complicated for golfing? Or am I just a n00b?",
            "flags": 0,
            "hasliked": 0,
            "id": "NtGcDm",
            "likes": 17,
            "name": "Kaplan Hinged Squares (279 ch)",
            "published": 3,
            "tags": [
                "loop",
                "squares",
                "golf",
                "reproduction",
                "hinged"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Part of my Hinged Squares series:\n\n// Fathauer Hinged Squares    https://www.shadertoy.com/view/ftVyWw\n// Kaplan Hinged Squares      https://www.shadertoy.com/view/NtGcDm\n// Kaplan 5-Color Squares     https://www.shadertoy.com/view/slGyzy\n\n// This is the second, both in order and in complexity, of my hinged square shaders.\n// Basically, Professor Kaplan noticed that if you took the color out of Robert Fathauer's\n// hinged squares, you could repeat the loop after only half of the original animation. I\n// hope he considers this an homage to his work.\n\n// https://isohedral.ca/hinged-squares/\n// https://archive.bridgesmathart.org/2021/bridges2021-23.pdf\n\n// I tried to golf this one, but I think I should have been able to do better. I bet\n// one of the golfing experts on this site will squeeze this down into a tweet in no time. :)\n\n// From coyote: 279 chars (-3)\n//*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    mat2  M = mat2(cos(mod(iTime/2.,.78) + vec4(0,11,33,0)));\n    O = iResolution.yyyx*.5;\n    vec2  N = M*M[0], // == vec2( cos(iTime), sin(iTime) )\n          s = .08*N.yy,\n          S = mod( u = mod(((u-O.wx)/O.x - vec2(-.1,.1 + s*N) + s/.8) * M, (s+=.2)+s) - s, s) - s*.5;        \n    N = max(S = abs( u.x*u.y<0.?M*S:S*M ),.1);\n    O *= N.x+N.y - min(max(S.x,S.y),.1)-.104;\n}\n/**/\n\n// From iapafoto: 283 chars (-1)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    mat2  M = mat2(cos(mod(iTime/2.,.78) + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy*.5,\n          N = M*M[0], // == vec2( cos(iTime), sin(iTime) )\n          s = .08*N.yy,\n          S = mod( u = mod(((u-R)/R.y + vec2(.1,-.1 - s*N) + s/.8) * M, (s+=.2)+s) - s, s) - s*.5;        \n\n    O = (   length(   max(S = abs(  u.x * u.y < 0. ?   M*S : S*M ) - .1 ,0.)) \n                    - min(max(S.x,S.y),0.)\n                    - .004\n        ) * R.yyyy;\n}\n/**/\n\n// From coyote: 284 chars (-25)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    mat2  M = mat2(cos(mod(iTime/2.,.78) + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy*.5,\n          N = M*M[0], // == vec2( cos(iTime), sin(iTime) )\n          s = .08*N.yy,\n          a = s + .2,\n          S = mod( u = mod( (   (u-R) / R.y\n                              + vec2(.1, -.1 - s*N ) + s/.8\n                            ) * M\n                          , a+a ) -a\n                 ,a ) - a*.5;        \n\n    O = (   length(   max(S = abs(  u.x * u.y < 0. ?   M*S : S*M ) - .1 ,0.)) \n                    - min(max(S.x,S.y),0.)\n                    - .004\n        ) * R.yyyy;\n}\n/**/\n\n// From iapafoto and coyote: 309 chars (-5)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = mod(iTime, 1.57), s = sin(t),  a = abs(s) * .08 + .2; \n    mat2  M = mat2(cos(t/2. + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy*.5, S;\n    u = mod( S = mod( (   ( u - R ) / R.y\n                         + .1* ( vec2(1, -1. - s*cos(t) *.8 ) + s )\n                      ) * M\n                    , a+a ) -a\n           ,a) - a*.5;        \n\n    O = ( abs(   length( max(u = abs(  S.x * S.y < 0. ?   M*u :u*M ) - .1 ,0.)) \n               + min(max(u.x,u.y),0.)\n             ) - .004\n        ) * R.yyyy;\n}\n/**/\n\n// From FabriceNeyret2: 314 chars (-16)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = mod(iTime, 1.57), s = sin(t),  a = abs(s) / 12.5 + .2; \n    mat2  M = mat2(cos(t/2. + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy, S;\n    u = mod( S = mod( (   ( u+u - R ) / R.y\n                         + .1* ( vec2(1, -1. - s*cos(t) *.8 ) + s )\n                      ) * M\n                    , a+a ) -a\n           ,a) - a*.5;        \n\n    O = ( abs(   length( max(u = abs(  S.x * S.y < 0. ?   M*u :u*M ) - .1 ,0.)) \n               + min(max(u.x,u.y),0.)\n             ) - .004\n        ) * R.y *.5 + O*0.;\n}\n/**/\n\n// From FabriceNeyret2: 330 chars (-49)\n/*\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float a = mod(iTime*.5, .78), s = sin(a+a); \n    mat2  M = mat2(cos(a + vec4(0,11,33,0)));\n    vec2  R = iResolution.xy,\n          u = (   ( U+U - R ) / R.y\n                + .1* ( vec2(1, -1. - s*cos(a+a) *.8 ) + s )\n              ) * M;\n    a = abs(s) / 12.5 + .2;\n    u = mod(u, a+a) -a;\n    u.x * u.y < 0. ? M = inverse(M) :M; \n\n    O = ( abs(   length( max(u = abs( (mod(u,a) - a*.5) *M ) - .1 ,0.)) \n               + min(max(u.x,u.y),0.)\n             ) - .004\n        ) * R.y *.5 + O*0.;\n}\n/**/\n\n// My golfing attempt: 379 chars\n/*\n#define r(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution;\n    u = 2.0 * u/R.y - vec2(R.x/R.y, 1.);\n    \n    float c, a = mod(iTime * .5, .78); // PI / 4\n    \n    u += vec2(.1, -.1 - sin(a * 4.) * .04) + sin(a + a) * .1;\n    u *= r(a);\n    \n    c = abs(sin(a + a)) / 12.5 + .2;\n    \n    u = mod(u, c+c);\n    \n    a = u.x > c ^^ u.y > c ? -a : a;\n    \n    u = mod(u, c);\n    \n    vec2 d = abs(r(-a) * (u - c*.5)) - .1;\n    \n    O *= 0.;\n    O += max(0., abs(length(max(d,0.)) + min(max(d.x,d.y),0.)) - .004) * R.y * .5;\n}\n/**/\n\n// Original pre-golf: 790 chars\n/*\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotAng(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nconst float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n    p.x = -p.x;\n    \n    float a = mod(iTime * 0.5, PI * 0.25);\n    vec2 p0 = p;\n    \n    p += sin(a + a) * 0.1;\n    p.y -= sin(a* 4.) * 0.04;\n    p += vec2(0.1, -0.1);\n    p *= rotAng((a));\n    vec2 center = abs(vec2(sin(a + a))) / 25.0 + 0.1;\n    \n    p = mod(p, 4.0 * center);\n    if (p.x > 2.0 * center.x)\n    {\n        p.x -= 2.0 * center.x;\n        a = -a;\n    }\n    if (p.y > 2.0 * center.x)\n    {\n        p.y -= 2.0 * center.x;\n        a = -a;\n    }\n    mat2 r = rotAng(-a);\n\n    fragColor = vec4(0);\n    \n    fragColor.xyz += max(0.000, (abs(sdBox(r * (p - center), vec2(0.1)))) - 0.004) * iResolution.y * 0.5 ;\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}