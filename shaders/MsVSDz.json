{
    "Shader": {
        "info": {
            "date": "1463937462",
            "description": "This is a game based in a maze. You have to find the exit of the maze but be careful with the walls and comment your points!\nYou can move the light with the arrow keys and restart the game with enter :)\n",
            "flags": 48,
            "hasliked": 0,
            "id": "MsVSDz",
            "likes": 18,
            "name": "Dark 2D maze game",
            "published": 3,
            "tags": [
                "pgatr",
                "migjrv",
                "urjc",
                "migrvj",
                "dark2dmaze"
            ],
            "usePreview": 0,
            "username": "jcanadilla",
            "viewed": 2277
        },
        "renderpass": [
            {
                "code": "/*//////////////////////////////////////////////////////////////////////////\n// MÁSTER UNIVERSITARIO INFORMÁTICA GRÁFICA, REALIDAD VIRTUAL Y JUEGOS    //\n// PROCESADORES GRÁFICOS Y APLICACIONES EN TIEMPO REAL                    //\n// TRABAJO DE INVESTIGACIÓN - SOMBRAS 2D                                  //\n// AUTOR:                                                                 //\n// - Javier Cañadilla Casco                                               //\n//                                                                        //\n//////////////////////////////////////////////////////////////////////////*/\n\n#define NUM_RAYS 64\n\nconst vec2 txLightPos       = vec2(1.0, 0.0);\nconst vec2 txState          = vec2(2.0, 0.0);\nconst vec2 txPoints         = vec2(3.0, 0.0);\nconst vec2  RESET_LIGHT_POS = vec2(750.0, 400.0);\n\nvec4 loadValue( in vec2 re ) {\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n#define STATE_ON_MENU   -2.0\n#define STATE_ON_START  -1.0\n#define STATE_ON_GAME    0.0\n#define STATE_ON_OVER    1.0\n#define STATE_ON_WIN     2.0\n\n#define GAME_MENU       state.x == STATE_ON_MENU\n#define GAME_START      state.x == STATE_ON_START\n#define GAME_PLAY       state.x == STATE_ON_GAME\n#define GAME_FINISH     state.x == STATE_ON_OVER\n\n/***** PRINT DIGITS *****/\n//Code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat SampleDigit(const in float n, const in vec2 vUV) {\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value ) {\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits ) {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n//===============\n\n\n/*****  PRINT TEXT:  *****/\n//Code from:  https://www.shadertoy.com/view/XsBSDm\nfloat g_cw = 15.; // char width in normalized units\nfloat g_ch = 30.; // char height in normalized units\n\nfloat g_cwb = .6; // character width buffer as a percentage of char width\nfloat g_chb = .5; // line buffer as a percentage of char height\n\n// vertical segment with the bottom of the segment being s\n// and having length d\nfloat vd( vec2 s, float d, vec2 uv ) {    \n    float t = (d * (uv.y - s.y)) / (d*d);\n    t = clamp(t, 0., 1.);\n    return .1 * length((s + t * vec2(0., d)) - uv);\n}\n\n// horizontal segment with the left of the segment being s\n// and having length d\nfloat hd( vec2 s, float d, vec2 uv ) {    \n    float t = (d * (uv.x - s.x)) / (d*d);\n    t = clamp(t, 0., 1.);\n    return .1 * length((s + t * vec2(d, 0.)) - uv);\n}\n\n// divide the experience into cells.\nvec2 mod_uv(vec2 uv) {\n    return vec2(mod(uv.x, g_cw * (1. + g_cwb)), \n                mod(uv.y, g_ch * (1. + g_chb)));\n}\n\n// ---------------------------------------------\n// ALPHABET\nfloat a(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .9, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw, uv));\n    return r;\n}\n\nfloat b(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(.0, g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\nfloat c(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .9, uv));\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .9, uv));\n    return r;\n}\n\nfloat d(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(0.), g_cw * .9, uv));\n    r = min(r, hd(vec2(.0, g_ch), g_cw * .9, uv));\n    return r;\n}\n\nfloat e(vec2 uv) {    \n    float r = hd(vec2(.0, g_ch), g_cw, uv);\n    r = min(r, vd(vec2(0.), g_ch, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat f(vec2 uv) {\n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat g(vec2 uv) {    \n    float r = hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv);\n    r = min(r, vd(vec2(0., g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, .1 * g_ch), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .5, g_ch * .6), g_cw * .4, uv));\n    return r;\n}\n\nfloat h(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, hd(vec2(.0, g_ch * .6), g_cw, uv));\n    return r;\n}\nfloat i(vec2 uv) {    \n    float r = hd(vec2(0.), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch), g_cw, uv));\n    return r;\n}\n\nfloat j(vec2 uv) {    \n    float r = vd(vec2(g_cw, g_ch * .1), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(0., g_ch * .1), g_ch * .2, uv));\n    return r;\n}\n\nfloat k(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, g_ch*.7), g_ch * .3, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\n\nfloat l(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\nfloat m(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, hd(vec2(0., g_ch), g_cw * .3, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .6), .3 * g_ch, uv));\n    r = min(r, hd(vec2(g_cw * .7, g_ch), g_cw * .3, uv));\n    return r;\n}\n\nfloat n(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));    \n    r = min(r, vd(vec2(g_cw * .1, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .9, 0.), g_ch * .2, uv));\n    return r;\n}\n\nfloat o(vec2 uv){    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    return r;\n}\n\nfloat p(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(0., g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    return r;\n}\nfloat q(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .8, uv);\n    r = min(r, hd(vec2(g_cw * .1, g_ch), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .8, uv));\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));    \n    r = min(r, vd(vec2(g_cw * .7, g_ch * -.05), g_cw * .4, uv));\n    return r;\n}\n\nfloat r(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, hd(vec2(.0, g_ch), g_cw, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .7), g_ch * .3, uv));\n    r = min(r, hd(vec2(0., g_ch * .6), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .5, uv));\n    return r;\n}\n\nfloat s(vec2 uv) {    \n    float r = hd(vec2(0.), g_cw * .9, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .4, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch * .6), g_cw * .7, uv));\n    r = min(r, vd(vec2(0., g_ch * .7), g_ch * .2, uv));\n    r = min(r, hd(vec2(g_cw * .2, g_ch), g_cw * .8, uv));\n    return r;\n}\n\nfloat t(vec2 uv) {    \n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch, uv));\n    return r;\n}\n\nfloat u(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .1), g_ch * .9, uv);\n    r = min(r, hd(vec2(g_cw * .1, 0.), g_cw * .8, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .1), g_ch * .9, uv));\n    return r;\n}\n\nfloat v(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .5), g_ch * .5, uv);\n    r = min(r, vd(vec2(g_cw, g_ch * .5), g_ch * .5, uv));\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .2), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .2), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch * .1, uv));\n    return r;\n}\n\nfloat w(vec2 uv) {    \n    float r = vd(vec2(0.), g_ch, uv);\n    r = min(r, vd(vec2(g_cw, 0.), g_ch, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .1), g_ch * .3, uv));\n    r = min(r, hd(vec2(0.), g_cw * .3, uv));\n    r = min(r, hd(vec2(g_cw * .7, 0.), g_cw * .3, uv));\n    return r;\n}\n\nfloat x(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .9), g_ch * .1, uv);\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw, 0.), g_ch * .2, uv));    \n    r = min(r, vd(vec2(g_cw, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .3), g_ch * .1, uv));    \n    r = min(r, vd(vec2(0.), g_ch * .2, uv));\n    \n    return r;\n}\n\nfloat y(vec2 uv) {    \n    float r = vd(vec2(0., g_ch * .8), g_ch * .2, uv);\n    r = min(r, vd(vec2(g_cw * .2, g_ch * .6), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .8, g_ch * .6), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw, g_ch * .8), g_ch * .2, uv));\n    r = min(r, vd(vec2(g_cw * .5, 0.), g_ch * .5, uv));\n    \n    return r;\n}\n\nfloat z(vec2 uv) {    \n    float r = hd(vec2(0., g_ch), g_cw, uv);\n    r = min(r, vd(vec2(g_cw * .9, g_ch * .9), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .7, g_ch * .7), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .5, g_ch * .5), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .3, g_ch * .3), g_ch * .1, uv));\n    r = min(r, vd(vec2(g_cw * .1, g_ch * .1), g_ch * .1, uv));\n    r = min(r, hd(vec2(0.), g_cw, uv));\n    return r;\n}\n\n// ---------------------------------------------\n// MACROS\n\n#define A if (cs == idx) { tx = min(tx, a(uv)); } idx++;\n#define B if (cs == idx) { tx = min(tx, b(uv)); } idx++;\n#define C if (cs == idx) { tx = min(tx, c(uv)); } idx++;\n#define D if (cs == idx) { tx = min(tx, d(uv)); } idx++;\n#define E if (cs == idx) { tx = min(tx, e(uv)); } idx++;\n#define F if (cs == idx) { tx = min(tx, f(uv)); } idx++;\n#define G if (cs == idx) { tx = min(tx, g(uv)); } idx++;\n#define H if (cs == idx) { tx = min(tx, h(uv)); } idx++;\n#define I if (cs == idx) { tx = min(tx, i(uv)); } idx++;\n#define J if (cs == idx) { tx = min(tx, j(uv)); } idx++;\n#define K if (cs == idx) { tx = min(tx, k(uv)); } idx++;\n#define L if (cs == idx) { tx = min(tx, l(uv)); } idx++;\n#define M if (cs == idx) { tx = min(tx, m(uv)); } idx++;\n#define N if (cs == idx) { tx = min(tx, n(uv)); } idx++;\n#define O if (cs == idx) { tx = min(tx, o(uv)); } idx++;\n#define P if (cs == idx) { tx = min(tx, p(uv)); } idx++;\n#define Q if (cs == idx) { tx = min(tx, q(uv)); } idx++;\n#define R if (cs == idx) { tx = min(tx, r(uv)); } idx++;\n#define S if (cs == idx) { tx = min(tx, s(uv)); } idx++;\n#define T if (cs == idx) { tx = min(tx, t(uv)); } idx++;\n#define U if (cs == idx) { tx = min(tx, u(uv)); } idx++;\n#define V if (cs == idx) { tx = min(tx, v(uv)); } idx++;\n#define W if (cs == idx) { tx = min(tx, w(uv)); } idx++;\n#define X if (cs == idx) { tx = min(tx, x(uv)); } idx++;\n#define Y if (cs == idx) { tx = min(tx, y(uv)); } idx++;\n#define Z if (cs == idx) { tx = min(tx, z(uv)); } idx++;\n#define SP idx++;\n#define NL idx+=int(cc - mod(float(idx), cc));\n\n// ---------------------------------------------\n\n\n// Periodic saw tooth function that repeats with a period of \n// 4 and ranges from [-1, 1].  \n// The function starts out at 0 for x=0,\n//  raises to 1 for x=1,\n//  drops to 0 for x=2,\n//  continues to -1 for x=3,\n//  and then rises back to 0 for x=4\n// to complete the period\n\nvec3 drawText( in vec4 fragColor, in vec2 fragCoord ) {\n    float display_width = 1010.;\n    float cc = floor(display_width / (g_cw * (1. + g_cwb))); // character count per line\n    \n    vec2 uv = (fragCoord.xy) / iResolution.xx;\n    uv.y = iResolution.y/iResolution.x - uv.y;  // type from top to bottom, left to right   \n    uv *= display_width;\n\n    int cs = int(floor(uv.x / (g_cw * (1. + g_cwb))) + cc * floor(uv.y/(g_ch * (1. + g_chb))));\n\n    uv = mod_uv(uv);\n    uv.y = g_ch * (1. + g_chb) - uv.y; // paint the character from the bottom left corner\n    vec3 ccol = .35 * vec3(.1, .3, .2) * max(smoothstep(3., 0., uv.x), smoothstep(5., 0., uv.y));   \n    uv -= vec2(g_cw * g_cwb * .5, g_ch * g_chb * .5);\n    \n    float tx = 10000.;\n    int idx = 0;\n    \n    NL \n    NL \n    NL \n    NL \n    NL \n    NL \n    SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP G A M E SP O V E R \n    NL\n        \n    vec3 tcol = vec3(1.0, 0.7, 0.0) * smoothstep(.2, .0, tx);\n    \n    vec3 terminal_color = tcol;\n    \n    return terminal_color;\n}   \n\n\nvec3 drawText2( in vec4 fragColor, in vec2 fragCoord ) {\n    float display_width = 1010.;\n    float cc = floor(display_width / (g_cw * (1. + g_cwb))); // character count per line\n    \n    vec2 uv = (fragCoord.xy) / iResolution.xx;\n    uv.y = iResolution.y/iResolution.x - uv.y;  // type from top to bottom, left to right   \n    uv *= display_width;\n\n    int cs = int(floor(uv.x / (g_cw * (1. + g_cwb))) + cc * floor(uv.y/(g_ch * (1. + g_chb))));\n\n    uv = mod_uv(uv);\n    uv.y = g_ch * (1. + g_chb) - uv.y; // paint the character from the bottom left corner\n    vec3 ccol = .35 * vec3(.1, .3, .2) * max(smoothstep(3., 0., uv.x), smoothstep(5., 0., uv.y));   \n    uv -= vec2(g_cw * g_cwb * .5, g_ch * g_chb * .5);\n    \n    float tx = 10000.;\n    int idx = 0;\n    \n    NL \n    NL \n    NL \n    NL \n    NL \n    NL \n    SP SP SP SP SP SP SP SP SP SP SP P R E S S SP E N T E R SP T O SP S T A R T\n    NL\n    vec3 tcol = vec3(1.0, 0.7, 0.0) * smoothstep(.2, .0, tx);\n    \n    vec3 terminal_color = tcol;\n    \n    return terminal_color;\n} \n\nvec3 drawText3( in vec4 fragColor, in vec2 fragCoord ) {\n    float display_width = 1010.;\n    float cc = floor(display_width / (g_cw * (1. + g_cwb))); // character count per line\n    \n    vec2 uv = (fragCoord.xy) / iResolution.xx;\n    uv.y = iResolution.y/iResolution.x - uv.y;  // type from top to bottom, left to right   \n    uv *= display_width;\n\n    int cs = int(floor(uv.x / (g_cw * (1. + g_cwb))) + cc * floor(uv.y/(g_ch * (1. + g_chb))));\n\n    uv = mod_uv(uv);\n    uv.y = g_ch * (1. + g_chb) - uv.y; // paint the character from the bottom left corner\n    vec3 ccol = .35 * vec3(.1, .3, .2) * max(smoothstep(3., 0., uv.x), smoothstep(5., 0., uv.y));   \n    uv -= vec2(g_cw * g_cwb * .5, g_ch * g_chb * .5);\n    \n    float tx = 10000.;\n    int idx = 0;\n    \n    NL \n    NL \n    NL \n    NL \n    NL \n    NL \n    SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP Y O U SP W I N \n    NL\n        \n    vec3 tcol = vec3(1.0, 0.7, 0.0) * smoothstep(.2, .0, tx);\n    \n    vec3 terminal_color = tcol;\n    \n    return terminal_color;\n}   \n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\nfloat scene(vec2 p){\n           \n    //Beginning: right upper corner.\n    float d1 = lineDist(p, vec2(650, 450), vec2(650, 350), 10.0); //Vertical\n    float d2 = lineDist(p, vec2(800, 350), vec2(710, 350), 10.0); //Horizontal\n    \n    float d3 = lineDist(p, vec2(710, 350), vec2(710, 300), 10.0); //Vertical\n    float d4 = lineDist(p, vec2(650, 350), vec2(600, 350), 10.0); //Horizontal\n    float d5 = lineDist(p, vec2(710, 300), vec2(650, 300), 10.0); //Horizontal\n    \n    float d6 = lineDist(p, vec2(600, 350), vec2(600, 150), 10.0); //Vertical\n    float d7 = lineDist(p, vec2(650, 300), vec2(650, 250), 10.0); //Vertical\n    \n    float d8 = lineDist(p, vec2(600, 200), vec2(650, 200), 10.0); //Horizontal\n    float d9 = lineDist(p, vec2(650, 250), vec2(710, 250), 10.0); //Horizontal\n    \n    float d10 = lineDist(p, vec2(650, 200), vec2(650, 150), 10.0); //Vertical\n    float d11 = lineDist(p, vec2(710, 250), vec2(710, 200), 10.0); //Vertical\n    \n    float d12 = lineDist(p, vec2(650, 150), vec2(700, 150), 10.0); //Horizontal\n    \n    float d13 = lineDist(p, vec2(700, 150), vec2(700, 100), 10.0); //Vertical\n    \n    float d14 = lineDist(p, vec2(700, 100), vec2(600, 100), 10.0); //Horizontal\n    \n    //Right down corner\n    float d15 = lineDist(p, vec2(600, 100), vec2(600, 50), 10.0); //Vertical\n    float d16 = lineDist(p, vec2(800, 50), vec2(670, 50), 10.0); //Horizontal\n\n    //Left down corner\n    float d17 = lineDist(p, vec2(600, 50), vec2(80, 50), 10.0); //Horizontal\n\n    //Go center\n    float d18 = lineDist(p, vec2(200, 50), vec2(200, 100), 10.0); //Vertical\n    float d19 = lineDist(p, vec2(200, 100), vec2(250, 100), 10.0); //Horizontal\n    float d20 = lineDist(p, vec2(250, 100), vec2(250, 150), 10.0); //Vertical\n    \n    float d21 = lineDist(p, vec2(5, 100), vec2(150, 100), 10.0); //Horizontal\n    float d22 = lineDist(p, vec2(150, 100), vec2(150, 150), 10.0); //Vertical\n    float d23 = lineDist(p, vec2(150, 150), vec2(200, 150), 10.0); //Horizontal\n    float d24 = lineDist(p, vec2(200, 150), vec2(200, 200), 10.0); //Vertical\n    float d25 = lineDist(p, vec2(200, 200), vec2(300, 200), 10.0); //Horizontal\n    \n    float d26 = lineDist(p, vec2(300, 300), vec2(300, 100), 10.0); //Vertical\n    \n    float d27 = lineDist(p, vec2(300, 100), vec2(500, 100), 10.0); //Horizontal\n    \n    //Inverse L in center\n    float d28 = lineDist(p, vec2(535, 150), vec2(535, 400), 10.0); //Vertical\n    float d29 = lineDist(p, vec2(535, 150), vec2(350, 150), 10.0); //Horizontal\n    float d30 = lineDist(p, vec2(100, 400), vec2(590, 400), 10.0); //Horizontal\n    \n    //Left of L\n    float d31 = lineDist(p, vec2(300, 200), vec2(450, 200), 10.0); //Horizontal\n    float d32 = lineDist(p, vec2(535, 250), vec2(350, 250), 10.0); //Horizontal\n    float d38 = lineDist(p, vec2(300, 300), vec2(400, 300), 10.0); //Horizontal\n    \n    \n    //Left upper corner\n    float d33 = lineDist(p, vec2(100, 400), vec2(100, 250), 10.0); //Vertical\n    float d34 = lineDist(p, vec2(100, 250), vec2(0, 250), 10.0); //Horizontal\n    float d35 = lineDist(p, vec2(0, 300), vec2(50, 300), 10.0); //Horizontal\n    float d36 = lineDist(p, vec2(50, 350), vec2(100, 350), 10.0); //Horizontal\n    float d37 = lineDist(p, vec2(50, 450), vec2(50, 400), 10.0); //Vertical\n    \n    //To finish\n    float d39 = lineDist(p, vec2(4, 200), vec2(150, 200), 10.0); //Horizontal\n    float d40 = lineDist(p, vec2(100, 200), vec2(100, 150), 10.0); //Vertical\n    float d41 = lineDist(p, vec2(50, 150), vec2(50, 100), 10.0); //Vertical\n    float d42 = lineDist(p, vec2(150, 200), vec2(150, 250), 10.0); //Vertical\n    float d43 = lineDist(p, vec2(150, 250), vec2(240, 250), 10.0); //Horizontal\n    float d44 = lineDist(p, vec2(240, 250), vec2(240, 350), 10.0); //Vertical\n    float d45 = lineDist(p, vec2(150, 350), vec2(450, 350), 10.0); //Horizontal\n    float d46 = lineDist(p, vec2(450, 350), vec2(450, 300), 10.0); //Vertical\n    float d47 = lineDist(p, vec2(450, 300), vec2(490, 300), 10.0); //Horizontal\n    float d48 = lineDist(p, vec2(530, 350), vec2(495, 350), 10.0); //Horizontal\n    float d49 = lineDist(p, vec2(100, 300), vec2(190, 300), 10.0); //Horizontal\n    \n    \n    //Lateral walls\n    float d50 = lineDist(p, vec2(0, 5), vec2(800, 5), 10.0);\n    float d51 = lineDist(p, vec2(797, 0), vec2(797, 450), 10.0);\n    float d52 = lineDist(p, vec2(0, 447), vec2(800, 447), 10.0);\n\tfloat d53 = lineDist(p, vec2(4, 447), vec2(4, 250), 10.0);\n    float d54 = lineDist(p, vec2(4, 200), vec2(4, 0), 10.0);\n    \n    //Maze merge\n    float d = merge(d1, d2);\n    d = merge(d, d3);\n    d = merge(d, d4);\n    d = merge(d, d5);\n    d = merge(d, d6);\n    d = merge(d, d7);\n    d = merge(d, d8);\n    d = merge(d, d9);\n\td = merge(d, d10);\n    d = merge(d, d11);\n    d = merge(d, d12);\n    d = merge(d, d13);   \n    d = merge(d, d14);   \n    d = merge(d, d15);\n    d = merge(d, d16);\n    d = merge(d, d17);\n\td = merge(d, d18);\n\td = merge(d, d19);\n\td = merge(d, d20);\n\td = merge(d, d21);\n\td = merge(d, d22);\n\td = merge(d, d23);\n\td = merge(d, d24);\n\td = merge(d, d25);\n\td = merge(d, d26);\n\td = merge(d, d27);\n\td = merge(d, d28);\n\td = merge(d, d29);\n\td = merge(d, d30);\n\td = merge(d, d31);\n    d = merge(d, d32);\n \td = merge(d, d33);\n\td = merge(d, d34);\n\td = merge(d, d35);\n    d = merge(d, d36);\n    d = merge(d, d37);\n    d = merge(d, d38);\n\td = merge(d, d39);\n\td = merge(d, d40);\n\td = merge(d, d41);\n    d = merge(d, d42);\n    d = merge(d, d43);\n    d = merge(d, d44);\n    d = merge(d, d45);\n\td = merge(d, d46);\n\td = merge(d, d47);\n    d = merge(d, d48);\n    d = merge(d, d49);\n    d = merge(d, d50);\n    d = merge(d, d51);\n    d = merge(d, d52);\n    d = merge(d, d53);\n    d = merge(d, d54);\n    \n    return d;\n    \n}\n\nfloat drawGoal(vec2 p){\n\t return boxDist(translate(p, vec2(5.0, 225.0)), vec2(20.0, 20.0), 0.0);\n    \n}\n\nfloat castShadow(vec2 p, vec2 pos, float radius) {\n   \n    vec2 dir = normalize(pos - p);\n    float distanceLight = length(p - pos);\n    \n    float lightFraction = radius * distanceLight;\n    \n    float totalDistance = 0.01;\n    \n    for(int i = 0; i < NUM_RAYS; ++i){\n    \tfloat sceneDistance = scene(p + dir * totalDistance);   \n        \n        if(sceneDistance < -radius) return 0.0;\n        \n        lightFraction = min(lightFraction, sceneDistance / distanceLight);\n        \n        //Go ahead\n        totalDistance += max(1.0, abs(sceneDistance));\n        if(totalDistance > distanceLight) break;\n    }\n    \n    lightFraction = clamp((lightFraction * distanceLight + radius) / (2.0 * radius), 0.0, 1.0);\n    lightFraction = smoothstep(0.0, 1.0, lightFraction);\n    return lightFraction;\n}\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius){\n\n    float distanceLight = length(p - pos);\n    \n    if(distanceLight > range) return vec4(0.0);\n    \n    float shadow = castShadow(p, pos, radius);\n    float fall = (range - distanceLight)/range;\n    fall *= fall;\n    float source = fillMask(circleDist(p - pos, radius));\n    return (shadow * fall + source) * color;\n    \n}\n\nfloat luminance(vec4 col){\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum){\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float state = loadValue(txState).x;\n    vec4 result;\n    \n    if(state == -2.0){\n\t\tresult.xyz = mix(result.xyz, drawText2(fragColor, fragCoord), (0.5+0.5*sin(25.0*iTime)));  \n    }else{\n        vec2 p = fragCoord.xy + vec2(0.5);\n        vec2 c = iResolution.xy / 2.0;\n\n        float dist = scene(p);\n\n        vec2 lightPosition = loadValue(txLightPos).xy;\n        //vec2 lightPosition = RESET_LIGHT_POS;\n        vec4 lightColor = vec4(1.0, 0.70, 0.0, 1.0);\n        setLuminance(lightColor, 0.5);\n\n        //gradiente\n        vec4 color = vec4(0.0, 0.0, 0.0, 1.0) * (1.0 - length(c - p) /iResolution.x);\n\n        //light\n        color += drawLight(p, lightPosition, lightColor, dist, 250.0, 5.0);\n\n        //Draw Goal\n        float goal = drawGoal(p);\n        color += drawLight(p, lightPosition, lightColor, goal, 250.0, 0.0);\n        \n        //Shape fill\n        color = mix(color, vec4(1.0, 0.4, 0.0,1.0), fillMask(goal));\n\n        //Shape outline\n        color = mix(color, vec4(0.1, 0.1, 0.1,1.0), innerBorderMask(goal, 1.5));\n\n        result = clamp(color, 0.0, 1.0);\n        \n        if(loadValue(txState).x == STATE_ON_OVER) {\n            result.xyz = mix(result.xyz, drawText(fragColor, fragCoord), 1.5);   \n        }\n        \n        if(loadValue(txState).x == STATE_ON_WIN ) {\n            result.xyz = mix(result.xyz, drawText3(fragColor, fragCoord), 1.5);   \n        }\n        \n        result.xyz = mix( result.xyz, vec3(1.0,0.70,0.2), state * (0.2+0.5*sin(20.0*iTime)) );\n        \n        float points = loadValue(txPoints).x;\n        vec2 posCounter = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n        posCounter.x -= 2.75;\n        float f = PrintInt( (posCounter-vec2(-1.5,0.8))*10.0, points );\n        result.xyz = mix( result.xyz, vec3(1.0,1.0,1.0), f );\n        \n    }\n    fragColor =  result;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*//////////////////////////////////////////////////////////////////////////\n// MÃSTER UNIVERSITARIO INFORMÃTICA GRÃFICA, REALIDAD VIRTUAL Y JUEGOS    //\n// PROCESADORES GRÃFICOS Y APLICACIONES EN TIEMPO REAL                    //\n// TRABAJO DE INVESTIGACIÃ“N - SOMBRAS 2D                                  //\n// AUTOR:                                                                 //\n// - Javier CaÃ±adilla Casco                                               //\n//                                                                        //\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct Wall{\n    vec2 begin;\n    vec2 end;\n};\n\n\nconst float KEY_SPACE       = 32.5/256.0;\nconst float KEY_UP          = 38.5/256.0;\nconst float KEY_DOWN        = 40.5/256.0;\nconst float KEY_LEFT\t\t= 37.5/256.0;\nconst float KEY_RIGHT\t\t= 39.5/256.0;\nconst float KEY_R           = 82.5 / 256.0;\nconst float KEY_RETURN      = 13.5 / 256.0;\nconst vec2  RESET_LIGHT_POS = vec2(750.0, 400.0);\nconst int   NUM_WALLS       = 54;\n\nconst vec2 txPoints         = vec2(3.0, 0.0);\nconst vec2 txLightPos       = vec2(1.0, 0.0);\nconst vec2 txState          = vec2(2.0, 0.0);\n\n#define STATE_ON_MENU   -2.0\n#define STATE_ON_START  -1.0\n#define STATE_ON_GAME    0.0\n#define STATE_ON_OVER    1.0\n#define STATE_ON_WIN    2.0\n\n#define GAME_MENU       state.x == STATE_ON_MENU\n#define GAME_START      state.x == STATE_ON_START\n#define GAME_PLAY       state.x == STATE_ON_GAME\n#define GAME_FINISH     state.x == STATE_ON_OVER\n#define GAME_WIN        state.x == STATE_ON_WIN\n\n\n//============================================================\n\nfloat keyPress(float ascii) {\n    return texture(iChannel1, vec2((float(ascii))/256., 0.0)).x ;\n}\n\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re ) {\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//===============\n\nvoid loadWalls(inout Wall walls[54]){\n    //Beginning: right upper corner.\n    walls[0] = Wall(vec2(650, 450), vec2(650, 350)); //Vertical\n    walls[1] = Wall(vec2(800, 350), vec2(710, 350)); //Horizontal\n    walls[2] = Wall(vec2(710, 350), vec2(710, 300)); //Vertical\n    walls[3] = Wall(vec2(650, 350), vec2(600, 350)); //Horizontal\n    walls[4] = Wall(vec2(710, 300), vec2(650, 300)); //Horizontal    \n    walls[5] = Wall(vec2(600, 350), vec2(600, 150)); //Vertical\n    walls[6] = Wall(vec2(650, 300), vec2(650, 250)); //Vertical\n    walls[7] = Wall(vec2(600, 200), vec2(650, 200)); //Horizontal\n    walls[8] = Wall(vec2(650, 250), vec2(710, 250)); //Horizontal\n    walls[9] = Wall(vec2(650, 200), vec2(650, 150)); //Vertical\n    walls[10] = Wall(vec2(710, 250), vec2(710, 200)); //Vertical\n    walls[11] = Wall(vec2(650, 150), vec2(700, 150)); //Horizontal\n    walls[12] = Wall(vec2(700, 150), vec2(700, 100)); //Vertical\n    walls[13] = Wall(vec2(700, 100), vec2(600, 100)); //Horizontal\n\t//Right down corner    \n    walls[14] = Wall(vec2(600, 100), vec2(600, 50)); //Vertical\n    walls[15] = Wall(vec2(800, 50), vec2(670, 50)); //Horizontal\n    //Left down corner\n    walls[16] = Wall(vec2(600, 50), vec2(80, 50)); //Horizontal\n    //Go center\n    walls[17] = Wall(vec2(200, 50), vec2(200, 100)); //Vertical\n    walls[18] = Wall(vec2(200, 100), vec2(250, 100)); //Horizontal\n    walls[19] = Wall(vec2(250, 100), vec2(250, 150)); //Vertical\n    walls[20] = Wall(vec2(5, 100), vec2(150, 100)); //Horizontal\n    walls[21] = Wall(vec2(150, 100), vec2(150, 150)); //Vertical\n    walls[22] = Wall(vec2(150, 150), vec2(200, 150)); //Horizontal\n    walls[23] = Wall(vec2(200, 150), vec2(200, 200)); //Vertical\n    walls[24] = Wall(vec2(200, 200), vec2(300, 200)); //Horizontal\n    walls[25] = Wall(vec2(300, 300), vec2(300, 100)); //Vertical\n    walls[26] = Wall(vec2(300, 100), vec2(500, 100)); //Horizontal\n    //Inverse L in center\n    walls[27] = Wall(vec2(535, 150), vec2(535, 400)); //Vertical\n    walls[28] = Wall(vec2(535, 150), vec2(350, 150)); //Horizontal\n    walls[29] = Wall(vec2(100, 400), vec2(590, 400)); //Horizontal\n    //Left of L\n    walls[30] = Wall(vec2(300, 200), vec2(450, 200)); //Horizontal\n    walls[31] = Wall(vec2(535, 250), vec2(350, 250)); //Horizontal\n    walls[32] = Wall(vec2(300, 300), vec2(400, 300)); //Horizontal  \n    //Left upper corner\n    walls[33] = Wall(vec2(100, 400), vec2(100, 250)); //Vertical\n    walls[34] = Wall(vec2(100, 250), vec2(0, 250)); //Horizontal\n    walls[35] = Wall(vec2(0, 300), vec2(50, 300)); //Horizontal\n    walls[36] = Wall(vec2(50, 350), vec2(100, 350)); //Horizontal\n    walls[37] = Wall(vec2(50, 450), vec2(50, 400)); //Vertical\n    //To finish\n    walls[38] = Wall(vec2(4, 200), vec2(150, 200)  ); //Horizontal\n    walls[39] = Wall(vec2(100, 200), vec2(100, 150)); //Vertical\n    walls[40] = Wall(vec2(50, 150), vec2(50, 100)  ); //Vertical\n    walls[41] = Wall(vec2(150, 200), vec2(150, 250)); //Vertical\n    walls[42] = Wall(vec2(150, 250), vec2(240, 250)); //Horizontal\n    walls[43] = Wall(vec2(240, 250), vec2(240, 350)); //Vertical\n    walls[44] = Wall(vec2(150, 350), vec2(450, 350)); //Horizontal\n    walls[45] = Wall(vec2(450, 350), vec2(450, 300)); //Vertical\n    walls[46] = Wall(vec2(450, 300), vec2(490, 300)); //Horizontal\n    walls[47] = Wall(vec2(530, 350), vec2(495, 350)); //Horizontal\n    walls[48] = Wall(vec2(100, 300), vec2(190, 300)); //Horizontal\n    //Lateral walls\n    walls[49] = Wall(vec2(0, 5), vec2(800, 5));\n    walls[50] = Wall(vec2(797, 0), vec2(797, 450));\n    walls[51] = Wall(vec2(0, 447), vec2(800, 447));\n    walls[52] = Wall(vec2(4, 447), vec2(4, 250));\n    walls[53] = Wall(vec2(4, 200), vec2(4, 0));    \n    \n}\n\nbool collisionWithWall(vec2 lightPos, Wall wall){\n    //Vertical\n    if(wall.begin.x == wall.end.x && wall.begin.y != wall.end.y){\n    \tif(\n            (lightPos.x >= wall.begin.x - 5.0 && lightPos.x <= wall.begin.x + 5.0)\n          && ((lightPos.y <= wall.begin.y && lightPos.y >= wall.end.y)||(lightPos.y >= wall.begin.y && lightPos.y <= wall.end.y))\n          ) \n            return true;\n    }else{ //Horizontal\n        if(\n           (lightPos.y >= wall.begin.y - 5.0 && lightPos.y <= wall.begin.y + 5.0)\n           &&\n           ((lightPos.x <= wall.begin.x && lightPos.x >= wall.end.x)||(lightPos.x >= wall.begin.x && lightPos.x <= wall.end.x))\n        )\n            return true;\n    }    \n    return false;\n}\n\nbool collisionWithGoal(vec2 lightPos){\n    \n    vec2 bottomLeft = vec2(5.0, 215.0);\n    vec2 upperLeft   = vec2(5.0, 215.0 + 20.0);\n    vec2 bottomRight = vec2(5.0 + 20.0, 215.0);\n    vec2 upperRight = vec2(25.0, 215.0 + 20.0);\n    \n    if(\n    \t(lightPos.x >= bottomLeft.x && lightPos.y >= bottomLeft.y) &&\n        (lightPos.x >= upperLeft.x && lightPos.y <= upperLeft.y) &&\n        (lightPos.x <= bottomRight.x && lightPos.y >= bottomRight.y) &&\n        (lightPos.x <= upperRight.x && lightPos.y <= upperRight.y)\n    )\n    \treturn true;\n    \n    return false; // boxes overlap\n\n}\n\nWall walls[NUM_WALLS];\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 state = loadValue(txState);\n    vec2 lightPos = loadValue(txLightPos).xy;\n    float points = loadValue(txPoints).x;\n\t    \n    loadWalls(walls);\n    \n    //Reset game state on first frame\n    if(iFrame == 0){\n        state = vec4(-2.0);\n        lightPos = RESET_LIGHT_POS;\n    \t\n    }\n    \n    if(GAME_MENU){\n        if(texture(iChannel1, vec2(KEY_RETURN, 0.25)).x == 1.0){\n            state.x = STATE_ON_START;\n        }\n    }\n    //State .0 => Reset game state\n    else if(GAME_START){\n        state.x = 0.0;\n        state.y = 0.0;\n        lightPos = RESET_LIGHT_POS;\n        points = 0.0;\n    }\n    \n    //State .1 => Playing\n    else if(GAME_PLAY){\n        bool isDie = false;\n    \tbool isWin = false;\n        \n        float moveUp    = texture( iChannel1, vec2(KEY_UP,0.25) ).x;\n        float moveDown  = texture( iChannel1, vec2(KEY_DOWN,0.25) ).x;\n        float moveRight = texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n        float moveLeft  = texture( iChannel1, vec2(KEY_LEFT,0.25) ).x;\n        \n        float reset  = texture( iChannel1, vec2(KEY_R,0.25) ).x;\n        \n        if(moveUp == 1.0){\n        \tlightPos.y += 3.50;\n        }else if(moveDown == 1.0){\n            lightPos.y -= 3.50;\n        }else if(moveRight == 1.0){\n            lightPos.x += 3.50;\n        }else if(moveLeft == 1.0){\n            lightPos.x -= 3.50;\n        }\n    \n        \n        for(int id = 0; id < NUM_WALLS; id++){\n            if(collisionWithWall(lightPos, walls[id])){\n                isDie = true;\n                break;\n            }\n            \n            if(collisionWithGoal(lightPos)){\n                isWin = true;\n                break;\n            }\n        }\n        \n        if(reset == 1.0 || isDie) {\n            state.x = STATE_ON_OVER;  \n        }else if(isWin){\n        \tstate.x = STATE_ON_WIN;    \n        }else{\n            points += 0.018;\n        }\n        \n        \n    }else if(GAME_FINISH || GAME_WIN){\n        if(texture(iChannel1, vec2(KEY_RETURN, 0.25)).x == 1.0){\n        \tstate.x = STATE_ON_START;   \n        }\n    }\n    \n    \n    storeValue(txState, state, fragColor, fragCoord);\n\tstoreValue(txLightPos, vec4(lightPos, 0.0, 0.0), fragColor, fragCoord);\n    storeValue(txPoints, vec4(points, 0.0, 0.0, 0.0), fragColor, fragCoord);\n\n\n}\n\n//  color = mix(color, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n// color = mix(color, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}