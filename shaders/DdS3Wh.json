{
    "Shader": {
        "info": {
            "date": "1667531523",
            "description": "Old creature of mine put in some fractal tunnel (inspired by Nusan)",
            "flags": 0,
            "hasliked": 0,
            "id": "DdS3Wh",
            "likes": 24,
            "name": "[phreax] lost sentinel",
            "published": 3,
            "tags": [
                "raymarching",
                "tunnel",
                "modeling",
                "glow",
                "matrix",
                "creature"
            ],
            "usePreview": 0,
            "username": "phreax",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define SIN(x)  (.5+.5*sin(x))\n#define PI 3.141592\n#define PHI 1.618033988749895\n\n\nfloat tt, gl, mat, cid;\nvec3 ro;\n\n\n// from shadertoy user tdhopper\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nvec3 pal(float t) {\n        vec3 cols[] = vec3[](vec3(0.510,0.510,0.510), vec3(0.102,0.675,0.918), vec3(0.427,0.220,1.000), vec3(0.259,1.000,0.443), vec3(1.000,0.220,0.894));\n        return cols[int(t) % cols.length()];\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// iq's impulse function\nfloat impulse2( float x, float k) {\n    \n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat impulse( float x, float k, float e) {\n    \n    float h = k*pow(x, e);\n    return h*exp(1.0-h);\n}\n\n// repetitive, continues pulse function for animation\nfloat continuesPulse(float x, float k, float e, float period) {\n   \n\treturn impulse(mod(x, period), k, e);\n    \n}\n\n// repetitive, continues pulse function for animation\nfloat continuesPulse2(float x, float k, float period) {\n   \n\treturn impulse2(mod(x, period), k);\n    \n}\n\n// remap [0,1] -> [a, b])\nfloat remap(float x, float a, float b) {\n    return a*x+b;\n}\n\n\nfloat cyl(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sph(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat cylcap( vec3 p, float r, float h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat ring(vec3 p, float h, float rout, float rin) {\n    return max(cylcap(p, h, rout), -cylcap(p, 2.*h, rin));\n}\n\nfloat box(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n/*\n\tp = abs(p) - r;\n    return max(p.x, max(p.y, p.z));\n}\n*/\n\nvec2 repeat(vec2 p, vec2 s) {\n   \treturn (fract(p/s-.5)-.5)*s;\n}\n\nfloat repeat(float p, float s) {\n   \treturn (fract(p/s-.5)-.5)*s;\n}\n\nfloat sdOctopus(vec3 p) {\n    float s = 0.4;\n    vec3 q = p;\n    \n    \n    q.z = abs(q.z);\n     \n    q.y = -abs(q.y);\n    q.yz *= rot(PI*0.25);\n    q.z = abs(q.z);\n    q.y = -abs(q.y);\n    q.yz *= rot(PI*0.125);\n    q.z = abs(q.z);\n   \n    q.xz *= rot(-PI*0.25);\n\n    q.xz -= 0.5;\n \n    int maxIter = 20;\n    float d = 1e6;\n    float alpha = remap(continuesPulse((tt), 0.7, 4.0, 5.0), -0.45, 0.15);\n\n    for(int i=1; i < maxIter; i++) { \n        q.xz *= rot(-alpha);\n        q.z-=10./float(maxIter);\n        s -= 0.8/float(maxIter);\n        float b = box(q, vec3(s))-.01;\n        d = min(d, b);              \n    }\n    \n    float head = fIcosahedron(p, .7);\n    \n    d = min(d, head);\n  \n    return d;\n}\n\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0);\n    off.x += sin(p.z*.1)*4.;\n    off.y += sin(p.z*.12)*3.;\n    return off;\n}\n\nvec2 moda(vec2 p, float s) {\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    a = (fract(a/s-.5)-.5)*s;\n    return r*vec2(cos(a), sin(a));\n       \n}\n\nfloat repeat2(inout float p, float size) {\n  float c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nvoid cam(inout vec3 p) {\n\tp.z += tt*5.;// + 7.*sin(.1*tt);\n    p -= tunnel(p);\n}\n\nfloat map(vec3 p) {\n\n    vec3 np = p;\n\n    float tunr = 10.;\n    float vrep = 10.;\n    \n    p += tunnel(p);\n   \n    vec3 vvp = p;\n    vvp.z += vrep/2.;\n    cid = 1.+(repeat2(vvp.z, vrep)/vrep)*10.;\n    float octo;\n    \n    {\n    \n        vec3 q = p;\n        float pulse = continuesPulse((tt), 0.7, 3.0, 5.0);\n        float pulse2 = continuesPulse2((tt-1.), 3., 5.0);\n  \n        q.z += 5.;\n        \n        q.z -= remap(pulse, 1.5, 10.0);   \\\n        q.z -= 1.5*tt + tt *remap(pulse2, 0., 3.5);\n                \n       // float oid = repeat2(q.z, 30.);\n        q.xz *= rot(-PI*.5);\n        vec3 o1 = q;\n        vec3 o2 = q;\n\n        o1.xy += vec2(-4.5*sin(tt), 3.3*cos(.4*tt));\n        //o2.x -= 5.0;\n\n        o1.xz *= rot(.4*sin(tt*.4));\n        float s = 1.8;\n        octo = 1./s*sdOctopus(o1/s);\n    }\n\n    vec3 bp = p;\n    vec3 vp = p;\n    vec3 cp = p;\n    vec3 sp = p;\n    \n\t\n    bp.x = atan(p.y, p.x)*30./3.1415;\n    bp.y = length(p.xy)-tunr;\n\n    \n    bp.xz = repeat(bp.xz, vec2(4));\n    bp.xz = abs(bp.xz) - 1.; \n    bp.x -= bp.z*.4;\n     \n    for(float i = 0.; i < 3.; i += 1.) {\n        bp.xz *= rot(tt*.1+cid);\n        //bp.yz *= rot(5.*i);\n      \n        bp.xz = abs(bp.xz) - 1. - .1*SIN(i*tt*.3);\n\n        bp.x += .1;\n \n    }\n      \n    float b = .9*box(bp, vec3(.8));\n\n\n    float dz = abs(ro.z-np.z);\n    float fade = exp(-sqrt(dz)*.4);\n    \n    cp.xy *= rot(.08*p.z);\n    cp.x = abs(cp.x) - 3.;\n    cp.x += sin(0.25*cp.y+sin(tt))*2.;\n    cp.z = repeat(cp.z, 5.);\n    \n    float vid = repeat2(vp.z, vrep);\n    vp.yz *= rot(PI*.5);\n    float veil = ring(vp, max(0., .01), tunr, tunr-.1);\n    \n    float gls = SIN(vid*2.+2.*tt);\n    gl += .018/(.1+pow(abs(veil), 8.));\n    \n    float tun = b;\n    \n   // repeat2(sp.z, vrep);\n    //sp.y -= 9.4;\n    //sp.z -= vrep/2.;\n    //float stone = .3*fIcosahedron(sp, 1.5);\n\n    mat = tun < octo ? 0. : 1.+cid;\n    \n    float d = min(tun, octo);\n    return d;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    tt = 1.5*iTime;\n    \n    vec3 ls = vec3(0, 0, -10.0); // light source\n\tvec3 col = vec3(0);\n    \n    ro = vec3(0, 0, -20);\n    vec3 rd = normalize(vec3(-uv, .7)); \n    \n    vec3 gcol = vec3(0.467,0.706,0.933);\n\n    cam(ro);\n    cam(ls);\n    vec3 p = ro;\n    float d = 0.1;\n    \n    float l_mat = 0.;\n    float l_cid = 0.;\n    \n    float i, t= .1;\n    for(i=0.; i<150.; i++) {\n        d = map(p);\n        \n        if(d < 0.001 || d > 20.) break;\n        \n        p += d*rd;\n        t += d;\n        l_mat = mat;\n        l_cid = cid;     \n    }\n    \n    if(d < 0.001) {\n        vec2 e = vec2(0.0035, -0.0035);\n        \n        vec3 al = pal(l_cid);\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        vec3 l = normalize(ls-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        float sss = smoothstep(0., 1., map(p+l*.4))/.4;\n        float ao = calcAO(p, n);\n\n        if(l_mat < 1.) {\n           // gcol = mix(gcol, al, .2);\n            col += pow(i/100., 1.2)*3.*gcol*exp(-t*t*0.001);\n        } else {\n            col +=  .2*spe+.8*al*(.3+.8*dif+1.5*sss) + .2*ao;\n          \n          \n        }\n    }\n    \n    col += 0.08*gl*gcol;\n           \n    col = pow(col, vec3(1.4));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}