{
    "Shader": {
        "info": {
            "date": "1723027321",
            "description": "source https://glslsandbox.com/e#76247.1 https://glslsandbox.com/e#79119.0",
            "flags": 0,
            "hasliked": 0,
            "id": "MfjyDK",
            "likes": 1,
            "name": "cubic fractalic",
            "published": 3,
            "tags": [
                "fractal",
                "cubic"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 82
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n\nconst float pi = acos(-1.);\nconst float pi2 = pi * 2.0;\n\nvec3 lightDir = vec3(0.15, .5, -.05);\n\nmat2 rot(float a){\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 pmod(vec2 p, float d){\n\tfloat a = atan(p.x, p.y) + pi / d;\n\tfloat n = pi2 / d;\n\ta = floor(a / n) * n;\n\treturn p * rot(-a);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(max(d.x, d.y), d.z), 0.);\n}\n\nfloat sdSphere(vec3 p, float r){\n\treturn length(p) - r;\n}\n#define time iTime\n#define resolution iResolution.xy\nfloat map(vec3 p){\n\tp.xy *= rot(floor(p.z * .0005) * .005);\n\tp.xy = pmod(p.xy, 4.);\n\tp.y -= 2.;\n\tp.z = mod(p.z, 8.) - 4.;\n\tfloat d1 = sdBox(p, vec3(1., .3, .4));\n\tfor(int i = 0; i< 4; i++){\n\t\tp = abs(p) - 1.;\n\t\tp.xy *= rot(time * .03);\n\t\tp.xz *= rot(time * .0035);\n\t}\n\td1 = min(d1, sdBox(p, vec3(.5, .3, .4)));\n\treturn d1;\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n#define R2(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H2(h)(cos((h)*3.3+vec3(2,3.5,2))*2.5+0.8)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 p = ( gl_FragCoord.xy * 2. - resolution.xy ) / min(resolution.x, resolution.y);\n\n  vec2 uv = ( C - .5*iResolution.xy ) / iResolution.y;\n\tvec3 color = vec3(0.0);\n\t//color.xy = p;\n\tvec4 O2=vec4(0);\n    vec3 p4,r4=iResolution,d4=normalize(vec3((C-.5*r4.xy)/r4.y,1.));\n    float g=0.,e=1.;\n    for(float i=0.;i<129.;++i){\n        p4=g*d4;\n      \n        p4.z-=5.;\n        p4=R(p4, normalize(vec3(1,2,3)), iTime*2.);\n        p4+=cross(sin(p4*.4+iTime*3.),cos(p4.zxy*.3+iTime*2.));\n        g+=e=(length(p4-clamp(p4,-1.,1.))-.1)*.7;\n        O2.xyz+=mix(vec3(1.),H2(dot(p4,p4)),2.9);\n    }\n    \n\tvec3 cPos = vec3(0., 0., -3.+iTime);\n  \n\tvec3 t = vec3(0., 0., time);\n\tvec3 fwd = normalize(t - cPos);\n\tvec3 u = normalize(vec3(0., 1., 0.))*O2.xyz;\n\tvec3 side = normalize(cross(u, fwd));\n\tu = normalize(cross(fwd, side));\n\tvec3 rd = normalize(p.x * side + p.y * u + fwd * (1. - .1 * (1. - dot(p, p))));\n\t\n\tfloat d;\n\tfloat ac,ac2;\n\t\n\tfor(int i = 0; i < 100; i++){\n\t\td = map(cPos);\n\t\t\n\t\td = max(abs(d), 0.001);\n\t\tif(mod(length(cPos.z* 4.), 150.) < 3.){\n\t\t\tac2 += exp(-d * 3.);\n\t\t\t//ac += exp(-d * 3.);\n\t\t}\t\t\n\t\tac += exp(-d * 3.);\n        \n\t\tcPos += d * rd;\n\t}\n\t\n\tfloat base = (ac * 0.05 + ac2 * 0.01) * 0.35 * (1.0 - length(p) * 0.2);\n\tcolor.r = pow(base * 0.8, 1.7);\n\tcolor.g = pow(base * 0.6, 2.2);\n\tcolor.b = pow(base * 1.3, 0.7);\n    vec3 p3,r=iResolution,\n    d3=normalize(vec3((C-.5*r.xy)/r.y,1));  \n       d3.xz *= rot(time * 1.0035);\n    for(float i=1.,s,e,g=0.42,l;\n        ++i<80.;\n        O+=abs(cos(vec4(4,3,24,1)+log(s)*.8))*s*1e-4/i\n    )\n    {\n        p3=g*d3;\n   \n        s=2.;\n        l=dot(p3,p3);\n        p3=abs(abs(p3))-.5;\n        \n        p3.x<p3.y?p3=p3.yxz:p3;\n        p3.y<p3.z?p3=p3.xzy:p3;\n        for(int i=0;i++<8;){\n            s*=e=2./clamp(dot(p3,p3),.024+cos(10.*sin(iTime*.2))*.022,1.35);\n            p3=abs(p3)*e-vec2(2.5*l,12.).xxy*color;\n        }\n        g+=e=length(p3-clamp(p3,-2.,1.))/s;\n    }\n    O.xyz=pow(O.xyz,vec3(1.1,.6,.5));\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    O*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.55), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}