{
    "Shader": {
        "info": {
            "date": "1570782177",
            "description": "Inktober, but with shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "WsKGRt",
            "likes": 3,
            "name": "shadetober #10 (pattern)",
            "published": 3,
            "tags": [
                "inktober",
                "shadertober",
                "shadetober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "percentcer",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "#define MAX_MARCHING_STEPS 256\n#define PI 3.14159\n#define MAX_DEPTH 40.0\n\nconst float EPSILON = .001;\n\n// copied from iq's page on shapes\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// copied from iq's page on shapes\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// this could be cleaned up. can we use functors?\nvec3 gradient(vec3 p) {\n    return normalize(vec3(\n    \tsdOctahedron(vec3(p.x + EPSILON, p.yz), 1.) - sdOctahedron(vec3(p.x - EPSILON, p.yz), 1.),\n    \tsdOctahedron(vec3(p.x, p.y + EPSILON, p.z), 1.) - sdOctahedron(vec3(p.x, p.y - EPSILON, p.z), 1.),\n    \tsdOctahedron(vec3(p.xy, p.z + EPSILON), 1.) - sdOctahedron(vec3(p.xy, p.z - EPSILON), 1.)\n    ));\n}\n\n// copied from the internet\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t0.0,                                0.0,                                0.0,                                1.0\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5, .5);\n    uv.x *= iResolution.x / iResolution.y;\n    float cdist = 1. - length(uv);\n\n    // background light\n    vec3 col = vec3(cdist * .3, cdist * .4, cdist * .5) * 3.;\n    \n    // pos out of screen neg into screen\n    vec4 eye4 = rotation3d(vec3(0.,.2,.4), iTime) * vec4(vec3(0., 0., 5.), 1.);\n    vec3 eye = eye4.xyz;\n    vec2 pix = fragCoord - iResolution.xy * .5;\n    // not sure what this is doing. divide the height by the tan of half of the FOV. confusing.\n    float unsure_z = iResolution.y / tan((PI * .5) * .5);\n    vec3 ray = normalize(vec3(pix, -unsure_z));\n    \n    float depth = 0.0f;\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n        vec3 hPoint = eye + depth * ray;\n        vec3 point = opRep(hPoint, vec3(3., 3., 3.));\n        float dist = sdOctahedron(point, 1.);\n        if (dist < EPSILON && depth > 1.) {\n            col = mix(gradient(point) * 1.25 * (20. / float(i)),\n                      col,\n                      depth / MAX_DEPTH);\n            break;\n        }\n        depth += dist;\n        if (depth > MAX_DEPTH) {\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}