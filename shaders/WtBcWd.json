{
    "Shader": {
        "info": {
            "date": "1595642243",
            "description": "Exploring fractal sdfs",
            "flags": 0,
            "hasliked": 0,
            "id": "WtBcWd",
            "likes": 3,
            "name": "Sierpinski Split Tone",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "reflection",
                "sierpinski"
            ],
            "usePreview": 0,
            "username": "kstyler",
            "viewed": 352
        },
        "renderpass": [
            {
                "code": "const int MAX_D=100;\nconst float DELTA=0.0065;\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat serpinski(vec3 p){\n    float Scale = 2.;\n    vec3 a1 = vec3(1,1,1);\n    vec3 a2 = vec3(-1,-1,1);\n    vec3 a3 = vec3(1,-1,-1);\n    vec3 a4 = vec3(-1,1,-1);\n    vec3 c;\n    int n = 0;\n    float dist, d;\n    while (n < 6) {\n        c = a1; \n        dist = length(p-a1);\n        d = length(p-a2);\n        if (d < dist) { \n            c = a2; \n            dist=d; \n        }\n        d = length(p-a3); \n        if (d < dist) { \n            c = a3; \n            dist=d; \n        }\n        d = length(p-a4); \n        if (d < dist) { \n            c = a4; \n            dist=d; \n        }\n        p = Scale*p-c*(Scale-1.0);\n        n++;\n    }\n\n    return length(p) * pow(Scale, float(-n));\n}\n\nfloat map(vec3 p){\n    return serpinski(p)-0.0135;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,DELTA);\n    \n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n\n}\nvec3 skyColor(vec3 rd){\n    \n    vec3 outLight = vec3(0.125);\n    outLight+= addLight(vec3(0.7,0.5,0.),normalize(-vec3(0.2,0.05,0.2)),rd);\n    \n    \n    outLight+=addLight(vec3(0.1,0.3,0.7),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(sin(iTime/2.)/3.,cos(iTime/4.)/2.1,sin(iTime/4.)/3.);\n    vec3 rd = normalize(vec3(uv,1));\n   \n    rd.xz*=rot(iTime/8.);\n    rd.xy*=rot(iTime/8.);\n   \n    vec3 color = vec3(0); \n    vec3 accum = vec3(0); \n    float tot = 0.;\n    for(int i = 0; i<MAX_D;i++){\n        vec3 p = ro+rd*tot;\n        float dst = map(p);\n        tot+=dst;\n      \n        vec3 n = normal(p);\n      \n        if(dst>DELTA){\n         color = skyColor(rd);\n        }\n        \n        else{\n            \n            color += skyColor(reflect(rd,n));\n            ro=p;\n            rd = reflect(rd,n);  \n        }\n        \n        accum+=0.013*color;\n        \n    }\n    \n    fragColor = vec4((accum),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}