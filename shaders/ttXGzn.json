{
    "Shader": {
        "info": {
            "date": "1555488750",
            "description": "Attempt to implement FXAA.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttXGzn",
            "likes": 5,
            "name": "FXAA 3.11 - PC Quality",
            "published": 3,
            "tags": [
                "tutorial",
                "fxaa",
                "pc",
                "quality"
            ],
            "usePreview": 0,
            "username": "effendiian",
            "viewed": 2422
        },
        "renderpass": [
            {
                "code": "/*****************************************\n * FXAA 3.11 Implementation - effendiian\n * -------------------------------------\n * FXAA implementation based off of the \n * work by Timothy Lottes in the Nvidia white paper:\n * https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n *\n * Also used these resources:\n * - https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/\n * - https://blog.codinghorror.com/fast-approximate-anti-aliasing-fxaa/\n *****************************************/\n\n// Turn off FXAA.\n// #define FXAA 0\n\n// Turn on FXAA.\n// #define FXAA 1\n\n// Turn on split screen between no-FXAA and FXAA.\n#define FXAA 2\n\n/*\n/\tFXAA setting, defined via preprocessor variables\n*/\n#ifndef FXAA_PRESET\n    #define FXAA_PRESET 5\n    #define FXAA_DEBUG_SKIPPED 0\n    #define FXAA_DEBUG_PASSTHROUGH 0\n    #define FXAA_DEBUG_HORZVERT 0\n    #define FXAA_DEBUG_PAIR 0\n    #define FXAA_DEBUG_NEGPOS 0\n    #define FXAA_DEBUG_OFFSET 0\n\t#define FXAA_DEBUG_HIGHLIGHT 0\n\t#define FXAA_LUMINANCE 1\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 0)\n    #define FXAA_EDGE_THRESHOLD      (1.0/4.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/12.0)\n    #define FXAA_SEARCH_STEPS        2\n    #define FXAA_SEARCH_ACCELERATION 4\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       1\n    #define FXAA_SUBPIX_CAP          (2.0/3.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 1)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/16.0)\n    #define FXAA_SEARCH_STEPS        4\n    #define FXAA_SEARCH_ACCELERATION 3\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 2)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        8\n    #define FXAA_SEARCH_ACCELERATION 2\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 3)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        16\n    #define FXAA_SEARCH_ACCELERATION 1\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 4)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        24\n    #define FXAA_SEARCH_ACCELERATION 1\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_PRESET == 5)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        32\n    #define FXAA_SEARCH_ACCELERATION 1\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX              1\n    #define FXAA_SUBPIX_FASTER       0\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))\n\n// --------------------------------------\n// Helper functions.\n// --------------------------------------\n\n// ---------------------\n// Conversion functions.\n\n// ToVec2\nvec2 ToVec2( float value ) { return vec2(value, value); }\n\n// ToVec3\nvec3 ToVec3( float value ) { return vec3(value, value, value); }\nvec3 ToVec3( vec2 vector, float z ) { return vec3(vector.x, vector.y, z); }\nvec3 ToVec3( vec2 vector ) { return ToVec3(vector, 0.0); }\n\n// ToVec4\nvec4 ToVec4( vec2 vector, float z, float w ) { return vec4(vector.x, vector.y, z, w); }\nvec4 ToVec4( vec2 vector, float z ) { return ToVec4(vector, z, 0.0); }\nvec4 ToVec4( vec2 vector ) { return ToVec4(vector, 0.0); }\nvec4 ToVec4( vec3 vector, float w ) { return vec4(vector.x, vector.y, vector.z, w); }\nvec4 ToVec4( vec3 vector ) { return ToVec4(vector, 0.0); }\nvec4 ToVec4( float value, float w ) { return vec4(value, value, value, w); }\nvec4 ToVec4( float value ) { return ToVec4(value, 0.0); }\n\n// ---------------------\n// Texture sampler functions.\n\n// Return sampled image from a point + offset texel space.\nvec4 TextureOffset( sampler2D tex, \n                    vec2 uv, \n                    vec2 offset ) {\n\t\n    // Return color from the specified location.\n    return texture(tex, uv + offset); \n        \n}\n\n// ---------------------\n// Grayscale functions.\n\n// Return grayscaled image based off of the selected color channel.\nvec3 Grayscale( vec3 color, int index ) {\n    int selectedChannel = clamp(index, 0, 2); // [0]r, [1]g, [2]b.\n\treturn ToVec3(color[selectedChannel]);\n}\n\n// Return grayscaled image based off of the selected color channel.\nvec4 Grayscale( vec4 color, int index ) {\n    int selectedChannel = clamp(index, 0, 3); // [0]r, [1]g, [2]b, [3]a.\n\treturn ToVec4(color[selectedChannel]);\n}\n\n// Default to green color channel when no index is supplied.\nvec3 Grayscale( vec3 color ) { return Grayscale(color, 1); }\nvec4 Grayscale( vec4 color ) { return Grayscale(color, 1); }\n\n// ---------------------\n// Luminance functions.\n\n// Map RGB to Luminance linearly.\nfloat LinearRGBLuminance( vec3 color ) {\n    \n    // Weights for relative luma from here: https://en.wikipedia.org/wiki/Luma_(video)\n    vec3 weight = vec3(0.2126729, 0.7151522, 0.0721750);\n    \n    // Get the dot product:\n    // - color.r * weight.r + color.g * weight.g + color.b * weight*b.\n\treturn dot(color, weight);\n}\n\n// Luminance based off of the original specification.\nfloat FXAALuminance( vec3 color ) {\n    \n    #if FXAA_LUMINANCE == 0\n    \n    return LinearRGBLuminance( color );\n    \n    #else\n    \n\treturn color.g * (0.587/0.299) + color.r;\n    \n    #endif\n}\n\n// ---------------------\n// Vertical/Horizontal Edge Test functions.\n\nfloat FXAAVerticalEdge( float lumaO,\n                       float lumaN, \n                       float lumaE, \n                       float lumaS, \n                       float lumaW,\n                       float lumaNW,\n                       float lumaNE,\n                       float lumaSW,\n                       float lumaSE ) {\n    \n    // Slices to calculate.\n    float top = (0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE);\n    float middle = (0.50 * lumaW ) + (-1.0 * lumaO) + (0.50 * lumaE );\n    float bottom = (0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE);\n    \n    // Return value.\n    return abs(top) + abs(middle) + abs(bottom);\n}\n\nfloat FXAAHorizontalEdge( float lumaO,\n                       float lumaN, \n                       float lumaE, \n                       float lumaS, \n                       float lumaW,\n                       float lumaNW,\n                       float lumaNE,\n                       float lumaSW,\n                       float lumaSE ) {\n    \n    // Slices to calculate.\n    float top = (0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW);\n    float middle = (0.50 * lumaN ) + (-1.0 * lumaO) + (0.50 * lumaS );\n    float bottom = (0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE);\n    \n    // Return value.\n    return abs(top) + abs(middle) + abs(bottom);\n}\n\n// ------------------------\n// FXAA specific functions.\n// ------------------------\n\n// Entry point for the FXAA process.\nvec3 applyFXAA(sampler2D textureSource, \n               vec2 textureDimensions, \n               vec2 pixelPosition,\n               vec2 screenResolution) {\n    \n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = pixelPosition / screenResolution;\n    \n    // Calculate distance between pixels in texture space.\n    vec2 texel = vec2(1.0, 1.0) / textureDimensions;\n    \n    // Caculate the luminance.\n    // float luma = FXAALuminance(rgbO.xyz);\n    // float luma = LinearRGBLuminance(clamp(rgbO.xyz, 0.0, 1.0));\n    \n    //-------------------------\n    // 1. LOCAL CONTRAST CHECK\n    \n    // Sample textures from cardinal directions.\n    vec3 rgbN = TextureOffset(textureSource, uv, vec2(0, -texel.y)).rgb; // NORTH\n    vec3 rgbW = TextureOffset(textureSource, uv, vec2(-texel.x, 0)).rgb; // WEST\n    vec3 rgbO = TextureOffset(textureSource, uv, vec2(0, 0)).rgb; // ORIGIN\n    vec3 rgbE = TextureOffset(textureSource, uv, vec2(texel.x, 0)).rgb; // EAST\n    vec3 rgbS = TextureOffset(textureSource, uv, vec2(0, texel.y)).rgb; // SOUTH\n    \n    #if FXAA == 0\n    return rgbO; // Skip FXAA if it is off.\n    #endif    \n    \n    // Calculate the luminance for each sampled value.\n    float lumaN = FXAALuminance(rgbN);\n    float lumaW = FXAALuminance(rgbW);\n    float lumaO = FXAALuminance(rgbO);\n    float lumaE = FXAALuminance(rgbE);\n    float lumaS = FXAALuminance(rgbS);\n    \n    // Calculate the minimum luma range.\n    float minLuma = min( lumaO, min( min( lumaN, lumaW ), min( lumaS, lumaE ) ) );\n    float maxLuma = max( lumaO, max( max( lumaN, lumaW ), max( lumaS, lumaE ) ) );\n    float localContrast = maxLuma - minLuma;    \n    \n    // Check for early exit.\n    if(localContrast < max( FXAA_EDGE_THRESHOLD_MIN, maxLuma * FXAA_EDGE_THRESHOLD )) {\n        \n        #if FXAA_DEBUG_SKIPPED\n                \n        return vec3(0);\n        \n        #else\n        \n    \treturn rgbO;\n        \n        #endif\n    }\n        \n    //-------------------------\n    // 2. SUB-PIXEL ALIASING TEST\n    \n    // Calculate the pixel contrast ratio.\n    // - Sub-pixel aliasing is detected by taking the ratio of the \n    // pixel contrast over the local contrast. This ratio nears 1.0\n    // in the presence of single pixel dots and otherwise falls off\n    // towards 0.0 as more pixels contribute to an edge. This ratio\n    // is transformed into the amount of lowpass filter to blend in\n    // at the end of the algorithm.\n    \n    #if FXAA_SUBPIX > 0\n    \n    // Calculate sum of local samples for the lowpass.\n    vec3 rgbL = (rgbN + rgbW + rgbO + rgbE + rgbS);\n    \n        #if FXAA_SUBPIX_FASTER\n\n        // Average the lowpass now since this skips the addition of the diagonal neighbors (NW, NE, SW, SE).\n        rgbL *= (1.0/5.0);\n\n        #endif    \n\n    // Calculate the lowpass luma.\n    // - Lowpass luma is calculated as the average between the luma of neigboring pixels.\n\tfloat lumaL = (lumaN + lumaW + lumaS + lumaE) * 0.25;\n\n    // Calculate the pixel contrast.\n    // - Pixel contrast is the abs() difference between origin pixel luma and lowpass luma of neighbors.\n    float pixelContrast = abs(lumaL - lumaO);\n    \n    // Remember: \n    // - pixel contrast is the origin - lowpass(neighbors).\n    // - local contrast is the min(origin + neighbors) - max(origin + neighbors) < threshold.\n   \n    // Calculate the ratio between the pixelContrast and localContrast.\n    float contrastRatio = pixelContrast / localContrast;\n    float lowpassBlend = 0.0; // Default is zero. Will be changed depending on subpixel level.\n    \n    \t#if FXAA_SUBPIX == 1\n    \n    \t// Normal subpixel aliasing. Set based on FXAA algorithm for subpixel aliasing.\n    \tlowpassBlend = max( 0.0, contrastRatio - FXAA_SUBPIX_TRIM ) * FXAA_SUBPIX_TRIM_SCALE;\n    \tlowpassBlend = min( FXAA_SUBPIX_CAP, lowpassBlend );\n    \n    \t#elif FXAA_SUBPIX == 2\n    \n    \t// Full force subpixel aliasing. Set blend to ratio.\n    \tlowpassBlend = contrastRatio;\n    \n    \t#endif\n    \n\t#endif\n    \n    // Show selected pixels if debug mode is active.\n    #if FXAA_DEBUG_PASSTHROUGH\n    \n    \t#if FXAA_SUBPIX > 0    \n    \n    \treturn vec3(localContrast, lowpassBlend, 0.0);\n    \n    \t#else \n    \t\n    \treturn vec3(localContrast, 0.0, 0.0);\t\n    \n    \t#endif\n    \n    #endif\n    \n    //-------------------------\n    // 3. VERTICAL & HORIZONTAL EDGE TEST\n    \n    // Sample the additional diagonal neighbors.\n    vec3 rgbNW = TextureOffset(textureSource, uv, vec2(-texel.x, -texel.y)).rgb; // NORTH-WEST\n    vec3 rgbNE = TextureOffset(textureSource, uv, vec2(texel.x, -texel.y)).rgb; // NORTH-EAST\n    vec3 rgbSW = TextureOffset(textureSource, uv, vec2(-texel.x, texel.y)).rgb; // SOUTH-WEST\n    vec3 rgbSE = TextureOffset(textureSource, uv, vec2(texel.x, texel.y)).rgb; // SOUTH-EAST\n    \n    // Average additional neighbors when sub-pix aliasing is on and it isn't in 'fast' mode.\n    #if FXAA_SUBPIX > 0\n    \t#if FXAA_SUBPIX_FASTER == 0\n    \t\t// Add missing neighbors and average them.\n    \t\trgbL += (rgbNW + rgbNE + rgbSW + rgbSE);  \n    \t\trgbL *= (1.0/9.0);\n    \t#endif\n    #endif\n    \n    // Calculate luma for additional neighbors.\n    float lumaNW = FXAALuminance(rgbNW);\n    float lumaNE = FXAALuminance(rgbNE);\n    float lumaSW = FXAALuminance(rgbSW);\n    float lumaSE = FXAALuminance(rgbSE);\n    \n    // Calculate the vertical and horizontal edges. (Uses algorithm from FXAA white paper).\n    float edgeVert = FXAAVerticalEdge(lumaO, lumaN, lumaE, lumaS, lumaW, lumaNW, lumaNE, lumaSW, lumaSE);\n    float edgeHori = FXAAHorizontalEdge(lumaO, lumaN, lumaE, lumaS, lumaW, lumaNW, lumaNE, lumaSW, lumaSE);\n    \n    // Check if edge is horizontal.\n    bool isHorizontal = edgeHori >= edgeVert;\n    \n    #if FXAA_DEBUG_HORZVERT\n    if(isHorizontal) \n    {\n    \treturn vec3(1.0, 0.75, 0.0);\n    } \n    else \n    {\n        return vec3(0.10, 0.10, 1.0);\n    }\n    #endif\n    \n    //-------------------------\n    // 4. FIND HIGHEST CONTRAST PAIR 90deg TO EDGE\n    \n    // Contain the appropriate sign for the top left.\n    float edgeSign = isHorizontal ? -texel.y : -texel.x; // Note, if isHorizontal == true, -texel.y is applied (not -texel.x).\n    \n    // Calculate the gradients. The luma used changes based on the horizontal edge status.\n    float gradientNeg = isHorizontal ? abs(lumaN - lumaO) : abs(lumaW - lumaO);\n    float gradientPos = isHorizontal ? abs(lumaS - lumaO) : abs(lumaE - lumaO); \n    \n    // Calculate the luma based on its direction.\n    // It is an average of the origin and the luma in the respective direction.\n    float lumaNeg = isHorizontal ? ((lumaN + lumaO) * 0.5) : ((lumaW + lumaO) * 0.5);    \n    float lumaPos = isHorizontal ? ((lumaS + lumaO) * 0.5) : ((lumaE + lumaO) * 0.5);\n    \n    // Select the highest gradient pair.\n    bool isNegative = (gradientNeg >= gradientPos);\n    float gradientHighest = isNegative ? gradientNeg : gradientPos; // Assign higher pair.\n    float lumaHighest = isNegative ? lumaNeg : lumaPos;\n    \n    // If gradient pair in the negative direction is higher, flip the edge sign.\n    if(isNegative) { edgeSign *= -1.0; }\n    \n    #if FXAA_DEBUG_PAIR\n    return isHorizontal ? vec3(0.0, gradientHighest, lumaHighest) : vec3(0.0, lumaHighest, gradientHighest); \n    #endif\n    \n    //-------------------------\n    // 5. END-OF-EDGE SEARCH\n    \n    // Select starting point.\n    vec2 pointN = vec2(0.0, 0.0);\n    pointN.x = uv.x + (isHorizontal ? 0.0 : edgeSign * 0.5);\n    pointN.y = uv.y + (isHorizontal ? edgeSign * 0.5 : 0.0);\n    \n    // Assign search limiting values.\n    gradientHighest *= FXAA_SEARCH_THRESHOLD;\n    \n    // Prepare variables for search.\n    vec2 pointP = pointN; // Start at the same point.\n    vec2 pointOffset = isHorizontal ? vec2(texel.x, 0.0) : vec2(0.0, texel.y);\n    float lumaNegEnd = lumaNeg;\n    float lumaPosEnd = lumaPos;\n    bool searchNeg = false;\n    bool searchPos = false;\n    \n    // Apply values based on FXAA flags.\n    if(FXAA_SEARCH_ACCELERATION == 1) {\n        \n    \tpointN += pointOffset * vec2(-1.0);\n    \tpointP += pointOffset * vec2(1.0);\n        // pointOffset *= vec2(1.0);\n        \n    } else if(FXAA_SEARCH_ACCELERATION == 2) {    \n        \n    \tpointN += pointOffset * vec2(-1.5);\n    \tpointP += pointOffset * vec2(1.5);\n        pointOffset *= vec2(2.0);\n        \n    } else if(FXAA_SEARCH_ACCELERATION == 3) {  \n        \n    \tpointN += pointOffset * vec2(-2.0);\n    \tpointP += pointOffset * vec2(2.0);\n        pointOffset *= vec2(3.0);\n        \n    } else if(FXAA_SEARCH_ACCELERATION == 4) { \n        \n    \tpointN += pointOffset * vec2(-2.5);\n    \tpointP += pointOffset * vec2(2.5);\n        pointOffset *= vec2(4.0);\n        \n    }\n    \n    // Perform the end-of-edge search.\n    for(int i = 0; i < FXAA_SEARCH_STEPS; i++) \n    {\n        if(FXAA_SEARCH_ACCELERATION == 1) {            \n            if(!searchNeg) { lumaNegEnd = FXAALuminance(texture(textureSource, pointN).rgb); }\n            if(!searchPos) { lumaPosEnd = FXAALuminance(texture(textureSource, pointP).rgb); } \n        } \n        else\n        {\n            if(!searchNeg) { lumaNegEnd = FXAALuminance(textureGrad(textureSource, pointN, pointOffset, pointOffset).rgb); }\n            if(!searchPos) { lumaPosEnd = FXAALuminance(textureGrad(textureSource, pointP, pointOffset, pointOffset).rgb); } \n        }\n        \n        // Search for significant change in luma compared to current highest pair.\n        searchNeg = searchNeg || (abs(lumaNegEnd - lumaNeg) >= gradientNeg);\n        searchPos = searchPos || (abs(lumaPosEnd - lumaPos) >= gradientPos);\n        \n        \n        // Display debug information regarding edges.\n        #if FXAA_DEBUG_NEGPOS\n        \n        if(searchNeg) { \n        \treturn vec3(abs(lumaNegEnd - gradientNeg), 0.0, 0.0);  \n        } else if(searchPos) { \n        \treturn vec3(0.0, 0.0, abs(lumaPosEnd - gradientPos));  \n        }\n\n        #endif\n        \n        // Determine if search is over early.\n        if(searchNeg && searchPos) { break; }\n        \n        // If still searching, increment offset.\n        if(!searchNeg) { pointN -= pointOffset; }\n        if(!searchPos) { pointP += pointOffset; }\n    }\n    \n    //-------------------------\n    // 6. SUB-PIXEL SHIFT\n    \n    // Determine if sub-pixel center falls on positive or negative side.\n    float distanceNeg = isHorizontal ? uv.x - pointN.x : uv.y - pointN.y;\n    float distancePos = isHorizontal ? pointP.x - uv.x : pointP.y - uv.y;\n   \tbool isCloserToNegative = distanceNeg < distancePos;\n    \n    // Assign respective luma.\n    float lumaEnd = isCloserToNegative ? lumaNegEnd : lumaPosEnd;\n    \n    // Check if pixel is in area that receives no filtering.\n    if( ((lumaO - lumaNeg) < 0.0) == ((lumaEnd - lumaNeg) < 0.0) ) {\n    \tedgeSign = 0.0;\n    }\n    \n    // Compute sub-pixel offset and filter span.\n    float filterSpanLength = (distancePos + distanceNeg);\n    float filterDistance = isCloserToNegative ? distanceNeg : distancePos;\n    float subpixelOffset = ( 0.5 + ( filterDistance * (-1.0 / filterSpanLength) ) ) * edgeSign;\n    \n    #if FXAA_DEBUG_OFFSET  \n    \n    if(subpixelOffset < 0.0) {\n    \treturn isHorizontal ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 0.7, 0.1); // neg-horizontal (red) : neg-vertical (gold)\n    } \n    \n    if(subpixelOffset > 0.0) {\n    \treturn isHorizontal ? vec3(0.0, 0.0, 1.0) : vec3(0.1, 0.3, 1.0); // pos-horizontal (blue) : pos-vertical (skyblue)\n    }\n        \n    #endif\n    \n    // Resample using the subpixel offset.\n    vec3 rgbOffset = textureLod(textureSource, vec2( uv.x + (isHorizontal ? 0.0 : subpixelOffset), uv.y + (isHorizontal ? subpixelOffset : 0.0)), 0.0).rgb;\n    \n    // return vec3((lumaN + lumaS + lumaE + lumaW + lumaNW + lumaNE + lumaSW + lumaSE) * (1.0/9.0));\n    \n    #if FXAA_DEBUG_HIGHLIGHT\n    \n    return isHorizontal ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n    \n    #endif\n    \n    // Return the FXAA effect.\n    #if FXAA_SUBPIX == 0\n    \n    return vec3(rgbOffset);\n    \n    #else\n    \n    return mix(rgbOffset, rgbL, lowpassBlend);\n    \n    #endif\n}\n\n// ------------------------\n// Main function.\n// ------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    \n    #if (FXAA == 2)\n    \n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec3 resultFXAA = vec3(1.0);\n    \n    float speed = 0.45;\n    vec2 extents = vec2(0.1, 0.8);\n    float divisor = ( ((sin(iTime * speed) * 0.5) + 0.5) * extents.y ) + extents.x;\n    float increment = 0.005;\n    \n    float divNeg = divisor - increment;\n    float divPos = divisor + increment;\n    \n    if(uv.x >= divNeg && uv.x <= divPos) { resultFXAA = vec3(0.1); }\n    if(uv.x < divNeg) { resultFXAA = mix(texture(iChannel0, vec2(uv.x, uv.y)).xyz, vec3(0.9, 0.9, 0.9), 0.1); }\n    if(uv.x > divPos) { resultFXAA = applyFXAA(iChannel0, iChannelResolution[0].xy, fragCoord, iResolution.xy); }   \n    \n    #else\n        \n    // Calculuate the FXAA value for the whole screen.\n    vec3 resultFXAA = applyFXAA(iChannel0, iChannelResolution[0].xy, fragCoord, iResolution.xy);\n    \n    #endif\n    \n    // Return the sampled pixel.\n    fragColor = ToVec4(resultFXAA, 1.0);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}