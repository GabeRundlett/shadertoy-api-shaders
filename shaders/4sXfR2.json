{
    "Shader": {
        "info": {
            "date": "1496913232",
            "description": "First foray into raymarching. Tried to do something simple and soothing for the eyes. See comments for more info.\nMouse for camera FOV /distance.\n",
            "flags": 64,
            "hasliked": 0,
            "id": "4sXfR2",
            "likes": 24,
            "name": "Chromium kiss",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "material"
            ],
            "usePreview": 0,
            "username": "grinist",
            "viewed": 1184
        },
        "renderpass": [
            {
                "code": "// Tried to do something sensible with predefined materials per primitive.\n// Probably the interesting thing is material blending based on distances to primitives.\n// Materials are only solved once we know the final ray position, so the logic doesn't need to be\n// dragged around for all the marchers.\n// This and per-frame initialization of trivial trigonometry for the distance scene\n// helped performance quite a bit.\n// Tried to get a faux metal thing going to illustrate lerping better.\n// The surface shading is definitely not academic reference material worth studying. :D\n\n// Update: Restructured lighting / shading. Added reflections and some swithces / extra parameters.\n// Not certain about the fog term propagation with reflections, but it looks close.\n// Added mouse controls for camera fov and distance.\n\n#define PI 3.1415926536\n#define TAU (2.0 * PI)\n#define DEG2RAD (PI / 180.0)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define time (iTime * 0.8)\n#define RING_SPHERES 8\n#define RING_RADIUS 4.2\n#define SMIN_K 0.65\n#define MARCH_MAX_STEPS 100\n#define MAX_RAY_TRAVEL 25.0\n#define DIST_EPSILON 0.001\n#define MAX_RAY_BOUNCES 3\n\n// lighting contributions\n#define AMBIENT_CONTRIBUTION\n#define DIFFUSE_CONTRIBUTION\n#define SPECULAR_CONTRIBUTION\n#define FRESNEL_CONTRIBUTION\n#define FOG_CONTRIBUTION\n#define REFLECTION_CONTRIBUTION\n\nstruct Material\n{\n    vec3 diffColor;\n    vec3 specColor;\n    vec3 smr; // smoothness, metallic, reflectivity\n};\n\n// needs GLSL ES 3.0\nconst Material materials[6] = Material[6](\n  Material(vec3(0.7, 0.45, 0.25), vec3(1.0, 0.7, 0.5), vec3(0.1, 0.1, 0.0)), \t// ground\n  Material(vec3(0.91, 0.13, 0.23), vec3(1.0, 0.82, 0.79), vec3(0.1, 0.3, 0.0)),\t// ring spheres\n  Material(vec3(0.96, 0.57, 0.18), vec3(1.0, 0.85, 0.68), vec3(0.4, 0.1, 0.05)),\n  Material(vec3(0.13, 0.72, 0.29), vec3(0.36, 1.0, 0.40), vec3(0.6, 0.2, 0.08)),\n  Material(vec3(0.12, 0.51, 0.59), vec3(0.72, 0.94, 1.0), vec3(0.6, 0.9, 0.1)),\n  Material(vec3(0.3, 0.5, 0.7), vec3(1.0, 1.0, 1.0), vec3(0.8, 0.8, 0.5)) \t\t// orbiting sphere\n);\n\n\n// ----- Incremental trigonometry\nfloat tsin = 0.0;\nfloat tcos = 0.0;\nfloat tcosd = 0.0;\nfloat tsind = 0.0;\n\nvoid trigInit(float startAngle, float increment)\n{\n\ttsin = sin(startAngle);\n\ttcos = cos(startAngle);\n\ttsind = sin(increment);\n\ttcosd = cos(increment);\n}\n\nvoid trigInc()\n{\n\tfloat sinn = tsin * tcosd + tcos * tsind;\n\tfloat cosn = tcos * tcosd - tsin * tsind;\n\ttsin = sinn;\n\ttcos = cosn;\n}\n// -----\n\n// cosine gradient, a - constant, b - multiplier, c - phase, d - frequency\nvec3 cosGradient(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return a + b * cos(TAU * (c + d * t));\n}\n\n// returns the vector with smallest x component\nvec2 xmin(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n// returns the vector with smallest x component\nvec3 xmin(vec3 a, vec3 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n// returns the vector with smallest x component\nvec4 xmin(vec4 a, vec4 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n// returns 1.0 if (a == b == 1.0) or (a == b == 0.0), 0.0 otherwise.\n// \"complement of xor for floats\"\nfloat nxorf(float a, float b)\n{\n    return abs(a + b - 1.0);\n}\n\n// iq's polynomial smooth min\nfloat smin(float a, float b, float k)\n{\n    float h = saturate(0.5 + 0.5 * (b - a) / k);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// -----\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n#define HASHSCALE1 443.8975\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// -----\n\n// Returns the interpolant in [0.0, 1.0], inverse lerp\nfloat lerpstep(float a, float b, float x)\n{\n    return (a == b) ? step(x, a) : clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n\n// Interpolating with 1/x: https://www.shadertoy.com/view/Xd2yRd\n// ----------\n\n// Interpolates from 0 to 1 with slope of k at x=0 and 1/k at x=1.\n// k must be greater than zero.\n// k<1: ease in, k=1: lerp, k>1: ease out\nfloat rxEase(float x, float k)\n{\n    k = clamp(k, 0.0001, 10000.0) - 1.0; // clamp optional, if you know your k\n    x = clamp(x, 0.0, 1.0);\n    float kx = k * x;\n    return (x + kx) / (kx + 1.0);    \n}\n\n// Interpolates from 0 to 1 with slope of k at x=0 and x=1.\n// k must be greater than zero.\n// k<1: sigmoid, k=1: lerp, k>1: seat\nfloat rxEase2(float x, float k)\n{\n    k = clamp(k, 0.0001, 10000.0); // clamp optional, if you know your k\n    x = 0.5 - x; // re-center at 0\n    float s = sign(x);\n    x = clamp(abs(x) * 2.0, 0.0, 1.0);\n    return 0.5 + 0.5 * s * x / (x * (k - 1.0) - k);\n}\n\n// Interpolates from 0 to 1 between [a, b], with slope of k at x=a and 1/k at x=b.\n// k must be greater than zero.\n// k<1: ease in, k=1: lerp, k>1: ease out\nfloat rxStep(float a, float b, float x, float k)\n{\n    return (a == b) ? step(x, a) : rxEase(clamp((x - a) / (b - a), 0.0, 1.0), k);\n}\n\n// Interpolates from 0 to 1 between [a, b], with slope of k at x=a and x=b.\n// k must be greater than zero.\n// k<1: sigmoid, k=1: lerp, k>1: seat\nfloat rxStep2(float a, float b, float x, float k)\n{\n    return (a == b) ? step(x, a) : rxEase2(clamp((x - a) / (b - a), 0.0, 1.0), k);\n}\n\n// ----------\n\nvec3 desaturateColor(vec3 color)\n{\n    return vec3(dot(vec3(0.2126, 0.7152, 0.0722), color));\n}\n\nfloat sWavyPlane(vec3 p)\n{\n    // this is still complex\n\treturn p.y + 0.05 * sin((p.z + 0.5 * p.x) * 3.0 - time * 3.0) + 0.06 * sin((0.4 * p.z + p.x) * 2.0 - time);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat sPlane(vec3 p, vec3 n, float d)\n{\n\treturn dot(p, n) + d;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\n// Init frame global stuff for scene\nfloat sphereRadius;\nfloat tsinInit;\nfloat tcosInit;\nfloat tsindInit;\nfloat tcosdInit;\nvec3 orbiterPos;\nvec3 lightPos;\nvoid sceneInit()\n{\n    sphereRadius = 0.65 + sin(time * 2.0) * 0.1;\n    trigInit(PI * 0.125 + time * 0.2, TAU / float(RING_SPHERES));\n    tsinInit = tsin;\n    tcosInit = tcos;\n    tsindInit = tsind;\n    tcosdInit = tcosd;\n    \n    vec2 orbiterXZ = vec2(cos(time * 0.8), -sin(time * 0.9));\n\torbiterPos = vec3(orbiterXZ.x * RING_RADIUS, 0.6, orbiterXZ.y * RING_RADIUS);\n    lightPos = vec3(0.0 + cos(time * 0.4) * 9.0, 3.5, 0.0 + sin(time * 0.4) * 9.0);\n}\n\nvoid trigReset()\n{\n    tsin = tsinInit;\n    tcos = tcosInit;\n    tsind = tsindInit;\n    tcosd = tcosdInit;\n}\n\n// Distance equation scene, used by all marches (mainray, shadow, AO) and normal\nfloat distScene(vec3 pos)\n{\n    const float y = 0.6;\n    const float crad = RING_RADIUS;\n    float res = sWavyPlane(pos);\n\n    float os = sdSphere(pos - orbiterPos, 0.65);\n\n\ttrigReset();\n    // could use polar domain repetition for rs or symmetry\n    for (int i = 0; i < RING_SPHERES; i++)\n    {\n\t    float rs = sdSphere(pos - vec3(tcos * crad, y, tsin * crad), sphereRadius + tcos * 0.15);\n        trigInc();\n\t    float ros = smin(rs, os, SMIN_K);\n\t    res = min(res, ros);\n    }\n\n    return res;\n}\n\nvoid lerpMaterial(inout Material matr1, Material matr2, float lerp)\n{\n    matr1.diffColor = mix(matr1.diffColor, matr2.diffColor, lerp);\n    matr1.specColor = mix(matr1.specColor, matr2.specColor, lerp);\n    matr1.smr = mix(matr1.smr, matr2.smr, lerp);\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    const float y = 0.6;\n    const float crad = RING_RADIUS;\n    float r = sWavyPlane(pos);\n    vec4 res = vec4(r, 0.0, 0.0, 0.0);\n    \n    float os = sdSphere(pos - orbiterPos, 0.65);\n\n\ttrigReset();\n    for (int i = 0; i < RING_SPHERES; i++)\n    {\n\t    float rs = sdSphere(pos - vec3(tcos * crad, y, tsin * crad), sphereRadius + tcos * 0.15);\n        trigInc();\n        float mat = 1.0 + mod(float(i), 4.0);\n        // lerp material based on distances to original primitives\n\t    vec4 ros = vec4(smin(rs, os, SMIN_K), mat, 5.0, rxStep2(0.0, max(rs, os), rs, 0.75));\n\t    res = xmin(res, ros);\n    }\n\n    // create material\n    vec3 matrs = res.yzw;\n    int matr1Index = int(matrs.x);\n    int matr2Index = int(matrs.y);\n    float lerp = matrs.z;\n    Material matr = materials[matr1Index];\n    Material matr2 = materials[matr2Index];\n    if (lerp > 0.0)\n        lerpMaterial(matr, matr2, lerp);\n\n    if (matr1Index == 0)\n    {\n        float mul = 0.85 + 0.15 * hash12(pos.xz * 0.01);\n        vec2 check = floor(mod(pos.xz, 2.0));\n        mul *= 1.0 - saturate(1.0 - length(pos.xz) * 0.22) * 0.2 * nxorf(check.x, check.y);\n        matr.diffColor *= mul;\n    }\n    \n    matr.smr.x = clamp(matr.smr.x, 0.001, 1.0);\n    return matr;\n}\n\n// Calculates normal\nvec3 normal(vec3 pos)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    distScene(pos + eps.xyy) - distScene(pos - eps.xyy),\n\t    distScene(pos + eps.yxy) - distScene(pos - eps.yxy),\n\t    distScene(pos + eps.yyx) - distScene(pos - eps.yyx));\n\treturn normalize(nor);\n}\n\n// Main raymarch for primary and secondary reflected rays\nfloat march(vec3 ro, vec3 rd, float maxt, inout int steps)\n{\n    float h = DIST_EPSILON;\n    float t = 0.0;\n    const int maxSteps = MARCH_MAX_STEPS;\n    //int maxSteps = int(50.0 + sin(time * 6.0) * 40.0);\n    for(steps = 0; steps < maxSteps; steps++)\n    {\n        if (abs(h) < DIST_EPSILON * t)\n            return t;\n        if (t >= maxt)\n            return maxt;\n\t    h = distScene(ro + rd * t);\n        t += h;\n    }\n\n    return t;\n}\n\n// Shadow raymarch\nfloat shadow(vec3 ro, vec3 rd, float maxt, float k)\n{\n    float s = 1.0;\n    float h = 0.01;\n    float t = h;\n    for(int i = 0; i < 100; i++)\n    {\n        if (t >= maxt)\n            break;\n\t    h = distScene(ro + rd * t);\n        if (abs(h) < DIST_EPSILON * t)\n            return 0.0;\n        s = min(s, k * h / t);\n        t += h;\n    }\n\n    return s;\n}\n\n// AO raymarch / step\nfloat AO(vec3 ro, vec3 rd)\n{\n\tfloat total = 0.0;\n    float scatter = 1.0;\n    for(float i = 0.0; i < 10.0; i += 1.0)\n    {\n        float hr = 0.01 + 0.05 * i;\n        vec3 pos = ro + rd * hr;\n        float dd = distScene(pos);\n        total += -(dd - hr) * scatter;\n        scatter *= 0.65;\n    }\n    return saturate(1.0 - 2.5 * total);\n}\n\nvec3 skyCol(vec3 rd)\n{\n    //return texture(iChannel0, rd).rgb;\n    return cosGradient(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                  vec3(0.525, 0.408, 0.409), vec3(0.9, 0.97, 0.8), clamp(rd.y * 0.6 + 0.5, 0.3, 1.0));\n}\n\nvec3 ambientCol(vec3 rd)\n{\n    return cosGradient(vec3(0.5, 0.5, 0.5), vec3(0.3, 0.3, 0.3),\n                  vec3(0.578, 0.507, 0.481), vec3(0.5, 0.5, 0.4), clamp(rd.y * 0.4 + 0.6, 0.3, 1.0));\n}\n\nvec3 skyCol(vec3 rd, float frequency)\n{\n    return mix(ambientCol(rd), skyCol(rd), frequency);\n}\n\n// returns vec2(diffuseTerm, specularTerm)\nvec2 dirLight(vec3 pos, vec3 nor, vec3 ref, inout Material matr, float dotNV, vec3 lightPos)\n{\n    vec3 lightVec = normalize(lightPos);\n    float dotNL = dot(nor, lightVec);\n    float diff = saturate(dotNL);\n\n    float shdw = 1.0;\n    if(diff > 0.001)\n    {\n        shdw = clamp(shadow(pos, lightVec, MAX_RAY_TRAVEL, 12.0), 0.0, 1.0);\n        diff *= shdw;\n    }\n\n    float pp = saturate(dot(ref, lightVec));\n    float spec = matr.smr.x * shdw * pow(pp, 128.0 * matr.smr.x);\n\n    return vec2(diff, spec);\n}\n\n\n// returns vec2(diffuseTerm, specularTerm)\nvec2 pointLight(vec3 pos, vec3 nor, vec3 ref, inout Material matr, float dotNV, vec3 lightPos, float attenuationTerm)\n{\n    vec3 lightDir = normalize(lightPos);\n    vec3 lightVec = lightPos - pos;\n    float lDistSq = dot(lightVec, lightVec);\n    float intensity = 1.0 / (1.0 + attenuationTerm * lDistSq);\n    float lDist = sqrt(lDistSq);\n    lightVec /= lDist;\n    float dotNL = dot(nor, lightVec);\n    float diff = saturate(dotNL) * intensity;\n\n    float shdw = 1.0;\n    if(diff > 0.001)\n    {\n        shdw = clamp(shadow(pos, lightVec, lDist, 6.0), 0.0, 1.0);\n        diff *= shdw;\n    }\n\n    float pp = saturate(dot(ref, lightVec));\n    float spec = matr.smr.x * shdw * intensity * pow(pp, 128.0 * matr.smr.x);\n\n    return vec2(diff, spec);\n}\n\n// returns vec2(diffuseTerm, specularTerm)\nvec2 spotLight(vec3 pos, vec3 nor, vec3 ref, inout Material matr, float dotNV, vec3 lightPos, float attenuationTerm, vec3 lightTarget, vec2 spotCutoff)\n{\n    vec3 lightDir = normalize(lightPos - lightTarget);\n    vec3 lightVec = lightPos - pos;\n    float lDistSq = dot(lightVec, lightVec);\n    float intensity = 1.0 / (1.0 + attenuationTerm * lDistSq);\n    float lDist = sqrt(lDistSq);\n    lightVec /= lDist;\n    float cutoff = smoothstep(spotCutoff.x, spotCutoff.y, saturate(dot(lightVec, lightDir)));\n    intensity *= cutoff;\n    float dotNL = dot(nor, lightVec);\n    float diff = saturate(dotNL) * intensity;\n\n    float shdw = 1.0;\n    if(diff > 0.001)\n    {\n        shdw = clamp(shadow(pos, lightVec, lDist, 6.0), 0.0, 1.0);\n        diff *= shdw;\n    }\n\n    float pp = saturate(dot(ref, lightVec));\n    float spec = matr.smr.x * shdw * intensity * pow(pp, 128.0 * matr.smr.x);\n\n    return vec2(diff, spec);\n}\n\nvec4 render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 finalCol = vec3(0.0);\n    float rayContribution = 1.0; // current ray contribution to final color\n    vec3 raySpecular = vec3(1.0);// current ray specular contribution\n    float depth = MAX_RAY_TRAVEL;\n    float tt = 0.0;\n    float ff = 1.0;\n    for (int i = 0; i <= MAX_RAY_BOUNCES; i++)\n    {\n        vec3 col = skyCol(rd);\n        vec3 fogColor = col;\n        // sky only\n        if (uv.y > 0.1)\n            return vec4(col, depth);\n\n        // main raymarch\n        int steps = 0;\n        float t = march(ro, rd, MAX_RAY_TRAVEL, steps);\n        // store depth\n        if (i == 0)\n            depth = t;\n\n        // marched to sky\n        if (t >= MAX_RAY_TRAVEL)\n        {\n            // mix ray contribution\n\t       \tfinalCol = mix(finalCol, col * raySpecular, rayContribution);\n            break;\n        }\n\n        vec3 pos = ro + t * rd;\n        vec3 nor = normal(pos);\n\n        // material\n        Material matr = matScene(pos, depth, steps);\n\n        // shade\n        float ao = AO(pos, nor);\n        float dotNV = dot(nor, rd);\n        \n        vec3 ref = reflect(rd, nor);\n        vec3 refCol = skyCol(ref, matr.smr.x); // mimic low frequency reflection\n\n        vec3 surf = vec3(0.0);\n#ifdef AMBIENT_CONTRIBUTION\n        vec3 ambient = ambientCol(nor);\n        surf += (0.6 + 0.4 * nor.y) * ambient * ao * matr.diffColor;\n        // since the ao is visible only below the spheres, lift the ao a bit toward ground\n        surf += 0.15 * materials[0].diffColor * (1.0 - ao);\n#endif\n        \n        vec3 specCol = mix(matr.specColor, refCol, matr.smr.y);\n\n        // first light\n        vec2 lighting = spotLight(pos, nor, ref, matr, dotNV, lightPos, 0.004, orbiterPos, vec2(0.775, 0.875));\n        float diff = lighting.x;\n        float spec = lighting.y;\n        vec3 lightColor = vec3(1.4);\n\n#ifdef DIFFUSE_CONTRIBUTION\n        surf += lightColor * matr.diffColor * saturate(diff - matr.smr.y) * ao;\n#endif\n#ifdef SPECULAR_CONTRIBUTION\n        surf += lightColor * specCol * spec;\n#endif\n        // second light\n        /*\n        lighting = dirLight(pos, nor, ref, matr, dotNV, vec3(1.0, 1.0, 0.0));\n        diff = lighting.x;\n        spec = lighting.y;\n        lightColor = vec3(0.25);\n\n#ifdef DIFFUSE_CONTRIBUTION\n        surf += lightColor * matr.diffColor * saturate(diff - matr.metallic) * ao;\n#endif\n#ifdef SPECULAR_CONTRIBUTION\n        surf += lightColor * specCol * spec;\n#endif\n\t\t*/\n        \n#ifdef FRESNEL_CONTRIBUTION\n        float fresnel = matr.smr.s * pow(saturate(1.0 + dotNV), 2.0);\n        surf += fresnel * mix(specCol, refCol, matr.smr.s) * ao * ao;\n#endif\n        \n#ifdef FOG_CONTRIBUTION\n        // reflected fog might not be correct, but I don't want to store intermediate ray results\n        tt += t;\n        float fog = exp(-0.008 * t * t);\n        ff *= fog;\n        col = mix(fogColor, surf, ff);\n#else\n        float fog = 1.0;\n        col = surf;\n#endif\n\n        // mix ray contribution, tint reflected color\n       \tfinalCol = mix(finalCol, col * raySpecular, rayContribution);\n#ifdef REFLECTION_CONTRIBUTION\n        raySpecular = matr.specColor;\n        rayContribution *= matr.smr.z * fog;\n#else\n        rayContribution = 0.0;\n#endif\n        \n        if (rayContribution <= 0.0)\n            break;\n        \n        // secondary reflected ray\n        rd = ref;\n        ro = pos + rd * 0.01;\n    }\n    \n\treturn vec4(saturate(finalCol), depth);\n}\n\nvec3 perspRay(vec2 uv, vec3 camPos, vec3 camTarget, float fov)\n{\n    fov *= DEG2RAD;\n    float focal = 1.0 / tan(fov * 0.5); // vertical fov\n    \n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camUp = vec3(0.0, 1.0, 0.0);\n\tvec3 camRight = normalize(cross(camForward, camUp));\n\tcamUp = normalize(cross(camRight, camForward));\n\treturn normalize(uv.x * camRight + uv.y * camUp + focal * camForward);\n}\n\nvec3 orthoRay(vec2 uv, inout vec3 camPos, vec3 camTarget, float size)\n{\n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camUp = vec3(0.0, 1.0, 0.0);\n\tvec3 camRight = normalize(cross(camForward, camUp));\n\tcamUp = normalize(cross(camRight, camForward));\n    camPos += (uv.x * camRight * size + uv.y * camUp * size);\n    return camForward;\n}\n\n// maps mouse xy to range, if not pressed returns def\nvec2 mouse(vec2 def, vec4 range)\n{\n    if (iMouse.z <= 0.0)\n        return def;\n    vec2 m = iMouse.xy / iResolution.xy;\n    m.x = mix(range.x, range.y, m.x);\n    m.y = mix(range.z, range.w, m.y);\n    return m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    vec2 m = mouse(vec2(70.0, 0.0), vec4(100.0, 20.0, 10.0, 0.0));\n\n    sceneInit();\n\n    // camera setup\n\tvec3 camPos = vec3(0.0, 3.0 + sin(time * 0.5) * 1.3, 7.0 + sin(time * 0.5) * 0.5) + vec3(0.0, 0.0, m.y);\n\tvec3 camTarget = vec3(0.0, 2.0 + sin(time * 0.5) * 0.5, 0.0);\n    vec3 ray = perspRay(uv, camPos, camTarget, m.x);\n    //vec3 ray = orthoRay(uv, camPos, camTarget, 4.0);\n\n    // render, depth is stored in col.a\n    vec4 col = render(camPos, ray, uv);\n\n    // vignette\n    vec3 v = vec3(smoothstep(0.4, 4.0, length(uv)));\n    col.rgb *= vec3(1.0) - v * vec3(1.0, 0.8, 0.6);\n    \n    // slight gamma crush\n    fragColor = vec4(pow(col.rgb, vec3(1.1)), col.a);\n    \n    //fragColor = vec4(1.0 - col.aaa / MAX_RAY_TRAVEL, col.a); // visualize depth\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 9933,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/magic-sword/13-journeys-end-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}