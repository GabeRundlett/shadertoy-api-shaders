{
    "Shader": {
        "info": {
            "date": "1717484836",
            "description": "Coursework on computer graphics at MUCTR.\nAt that time it was: msdos, watcom c++, svga linear framebuffer...",
            "flags": 32,
            "hasliked": 0,
            "id": "XXy3Wz",
            "likes": 1,
            "name": "msdos fire element",
            "published": 3,
            "tags": [
                "fire",
                "msdos",
                "dos",
                "element"
            ],
            "usePreview": 0,
            "username": "zenbooster",
            "viewed": 122
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// a perspective correct triangle rasterizer, in a shader!! :D\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Triangle\n{\n    vec3 a; vec2 aUV;\n    vec3 b; vec2 bUV;\n    vec3 c; vec2 cUV;\n    vec3 n;\n};\n\nconst float a = 4.;\nconst vec3 vertsThdr[4]  = \n    vec3[4]( vec3( 0., 0., a * sqrt(6.) / 4.),\n    vec3( a / sqrt(3.), 0.,  -a * sqrt(6.) / 12. ),\n    vec3( -a / sqrt(12.),  a / 2.,  -a * sqrt(6.) / 12.),\n    vec3( -a / sqrt(12.),  -a / 2.,  -a * sqrt(6.) / 12.) );\n\nTriangle triangles[4];\n\nvoid createThdr( void )\n{\n    triangles[0].a = vertsThdr[0]; triangles[0].aUV = vec2(0.0,0.0);\n    triangles[0].b = vertsThdr[1]; triangles[0].bUV = vec2(1.0,0.0);\n    triangles[0].c = vertsThdr[2]; triangles[0].cUV = vec2(1.0,1.0);\n    triangles[0].n = vec3( 0.0, 0.0, 1.0 );\n\n    triangles[1].a = vertsThdr[0]; triangles[1].aUV = vec2(0.0,0.0),\n    triangles[1].b = vertsThdr[3]; triangles[1].bUV = vec2(1.0,1.0),\n    triangles[1].c = vertsThdr[1]; triangles[1].cUV = vec2(0.0,1.0),\n    triangles[1].n = vec3( 0.0, 0.0, 1.0 );\n\n    triangles[2].a = vertsThdr[0]; triangles[2].aUV = vec2(0.0,0.0);\n    triangles[2].b = vertsThdr[2]; triangles[2].bUV = vec2(1.0,0.0);\n    triangles[2].c = vertsThdr[3]; triangles[2].cUV = vec2(1.0,1.0);\n    triangles[2].n = vec3( 1.0, 0.0, 0.0 );\n\n    triangles[3].a = vertsThdr[1]; triangles[3].aUV = vec2(0.0,0.0);\n    triangles[3].b = vertsThdr[3]; triangles[3].bUV = vec2(1.0,1.0);\n    triangles[3].c = vertsThdr[2]; triangles[3].cUV = vec2(0.0,1.0);\n    triangles[3].n = vec3( 1.0, 0.0, 0.0 );\n}\n\nfloat cross2d( in vec2 a, in vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nconst vec3 lig = normalize( vec3( 0.3,0.7,0.5) );\n\nvec3 pixelShader( in vec3 nor, in vec2 uv, in float z, in vec3 wnor )\n{\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float brdf = 0.5 + 0.8*dif;\n    brdf *= 6.0*exp2( -0.7*abs(z) );\n\t\t\t\n\tvec3 mate = texture( iChannel0, uv ).xyz * abs(wnor.x) + \n\t\t        texture( iChannel0, uv ).xyz * abs(wnor.y) + \n\t\t        texture( iChannel0, uv ).xyz * abs(wnor.z);\n\t\n    vec3 col = brdf * mate;\t\n\t\n    return sqrt( col );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.8;\n\tmat4 mdv = setTranslation( 0., 0., -5.0 ) * \n\t\t       setRotation( 0.6, 0.0,  0.0 ) * \n\t\t       setRotation( speed*iTime, speed*iTime, speed*iTime );\n\n    vec2 px = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n    createThdr();\n\n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n\n    // clear zbuffer\n    float mindist = -1000000.0;\n\n    // render triangles\n    for( int i=0; i<4; i++ )\n    {\n        // transform to eye space\n        vec3 ep0 = (mdv * vec4(triangles[i].a,1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(triangles[i].b,1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(triangles[i].c,1.0)).xyz;\n        vec3 nor = (mdv * vec4(triangles[i].n,0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0/ep0.z;\n        float w1 = 1.0/ep1.z;\n        float w2 = 1.0/ep2.z;\n\n        vec2 cp0 = 2.0*ep0.xy * -w0;\n        vec2 cp1 = 2.0*ep1.xy * -w1;\n        vec2 cp2 = 2.0*ep2.xy * -w2;\n\n        // fetch vertex attributes, and divide by z\n        vec2 u0 = triangles[i].aUV * w0;\n        vec2 u1 = triangles[i].bUV * w1;\n        vec2 u2 = triangles[i].cUV * w2;\n\n        //-----------------------------------\n        // rasterize\n        //-----------------------------------\n\n        // calculate areas for subtriangles\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n\t\t\n        // if all positive, point is inside triangle\n        if( all(greaterThan(di,vec3(0.0))) )\n        {\n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n\n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n            vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n            uv *= z;\n\n\t\t\t// depth (-1/z) buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n\n\t\t\t\t// perform lighting/shading\n\t\t\t\tcolor = pixelShader( nor, uv, z, triangles[i].n );\n\t\t\t}\n        }\n    }\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "highp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nbool pal(float k, float c, out float v)\n{\n    bool res;\n\n    float cb = k / 256.;\n    float ce = (k + 64.) / 256.;\n    \n    res = (c >= cb) && (c < ce);\n\n    if(res)\n    {\n        v = (c - cb) * 4.;\n    }\n\n    return res;\n}\n\nvec3 palette(float c)\n{\n    vec3 res = vec3(0);\n   \n    float v;\n    if(pal(0., c, v))\n    {\n        res = vec3(v, 0., 0.);\n    }\n    else\n    if(pal(64., c, v))\n    {\n        res = vec3(1., v, 0.);\n    }\n    else\n    if(pal(128., c, v))\n    {\n        res = vec3(1., 1., v);\n    }\n    else\n    if(pal(192., c, v))\n    {\n        res = vec3(1., 1., v);\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float px_x = 1. / iResolution.x;\n    float px_y = 1. / iResolution.y;\n    \n    if(iFrame == 0)\n    {\n        fragColor = vec4(1.);\n    }\n    else\n    if(uv.y < px_y)\n    {\n        fragColor = vec4(rand(uv*iTime));\n    }\n    else\n    {\n        float col_0 = texture(iChannel0, uv - vec2(px_x, 2.*px_y)).a;\n        float col_1 = texture(iChannel0, uv - vec2(0., 2.*px_y)).a;\n        float col_2 = texture(iChannel0, uv - vec2(-px_x, 2.*px_y)).a;\n        float col_3 = texture(iChannel0, uv - vec2(px_x, px_y)).a;\n        float col_4 = texture(iChannel0, uv - vec2(-px_x, px_y)).a;\n        float col_5 = texture(iChannel0, uv - vec2(px_x, 0.)).a;\n        float col_6 = texture(iChannel0, uv - vec2(0., 0.)).a;\n        float col_7 = texture(iChannel0, uv - vec2(-px_x, 0.)).a;\n        float col = (col_0 + col_1 + col_2 + col_3 + col_4 + col_5 + col_6 + col_7) / 8.;\n       \n        if (col > 0.)\n        {\n            col -= px_y / 1.5;\n        }\n        fragColor = vec4(palette(col), col);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}