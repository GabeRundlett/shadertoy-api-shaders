{
    "Shader": {
        "info": {
            "date": "1541152881",
            "description": "Experimental modern style(8 ball) table pool game.\nuse space to hit the ball.\nDemo shows Real-time path tracing with Physically based materials, procedural textures, DoF, Camera and Object motion blur, Area Light, Volumetric scattering, ...",
            "flags": 48,
            "hasliked": 0,
            "id": "MttfW2",
            "likes": 38,
            "name": "Unfinished PT game",
            "published": 3,
            "tags": [
                "game",
                "globalillumination",
                "pathtracing",
                "billiard",
                "tablepool"
            ],
            "usePreview": 1,
            "username": "koiava",
            "viewed": 2701
        },
        "renderpass": [
            {
                "code": "\n\nvec3 getColor(in vec2 uv, in sampler2D tex) {\n    vec3 c0 = texture(tex, uv).rgb;\n    vec3 c1 = vec3(0.);\n/*\n    float bluramount = 1.0 / 800.0;\n    const float repeats = 32.0;\n    float strata = 1.0/repeats;\n    for (float i = 0.; i < repeats; i++) { \n    \tfloat xi = strata*(float(i)+rnd());\n        float angle = degrees(xi*360.);\n        //vec2 q = vec2(cos(degrees((grid(i,dists)/repeats)*360.)),sin(degrees((grid(i,dists)/repeats)*360.))) * (1./(1.+mod(i,dists)));\n        vec2 q = vec2(cos(angle),sin(angle)) *  sqrt(rnd()+bluramount); \n        vec2 uv2 = uv+(q*bluramount);\n        c1 += texture(tex,vec2(uv2.x,uv2.y)).rgb/2.;\n        \n        \n        //One more to hide the noise.\n        q = vec2(cos(angle),sin(angle)) *  sqrt(rnd()+bluramount); \n        uv2 = uv+(q*bluramount);\n        c1 += texture(tex,vec2(uv2.x,uv2.y)).rgb/2.;\n    }\n    c1 /= repeats;*/\n    \n    return mix(c0, c1, 0.0);\n}\n/*\n//https://www.shadertoy.com/view/XstBzM\nvec3 tonemapping(vec3 color, float exposure)\n{\n\tcolor *= exposure;\n    \n    float A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.10;\n\tfloat E = 0.015;\n\tfloat F = 0.40;\n\tfloat W = 11.2;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n    \n    return color;\n}\n\nvec3 LinearToSRGB(vec3 color )\n{\n\tvec3 sRGBLo = color * 12.92;\n    const float powExp = 1.0/2.4;\n\tvec3 sRGBHi = ( pow( abs ( color ), vec3(powExp, powExp, powExp)) * 1.055) - 0.055;\n\tvec3 sRGB;\n    sRGB.x = ( color.x <= 0.0031308) ? sRGBLo.x : sRGBHi.x;\n    sRGB.y = ( color.y <= 0.0031308) ? sRGBLo.y : sRGBHi.y;\n    sRGB.z = ( color.z <= 0.0031308) ? sRGBLo.z : sRGBHi.z;\n\treturn sRGB;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec2 renderingResolution = min(iResolution.xy, vec2(float(RENDERING_RES_X), float(RENDERING_RES_Y)));\n\t\n    vec2 ratio = renderingResolution / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec3 col = texture(iChannel1, uv*ratio).xyz;\n    //vec3 col = texture(iChannel1, uv*ratio).www;\n    vec3 col = getColor(uv*ratio, iChannel1).xyz;\n    //col = tonemapping( col, 2.0 );\n    //col = LinearToSRGB(col );\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define LOW_RES\n//#define MIDDLE_RES\n//#define HIGH_RES\n//\n#define MOTION_BLUR\n\n//#define VOLUMETRIC_SHADOWS\n#define VOLUME_DIRECT_LIGHT_SAMPLES 1\n#define SURFACE_DIRECT_LIGHT_SAMPLES 1\n\n#define LENS_SIZE\t\t\t0.3\n\n#ifdef HIGH_RES\t//HD\n    #define RENDERING_RES_X\t1280\n    #define RENDERING_RES_Y\t720\n#else\n    #ifdef MIDDLE_RES\n        #define RENDERING_RES_X\t896\n        #define RENDERING_RES_Y\t504\t\n    #else\n\t\t#define RENDERING_RES_X\t640\n        #define RENDERING_RES_Y\t360\t\n    #endif\n#endif\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.005 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\nstruct Ball { mat4 mtx; mat4 mtx_prev; vec3 v; };\nstruct Table { vec2 size; vec3 pos; };\nstruct Chalk { mat4 mtx; float size; };\nstruct Cue { mat4 mtx; float r0; float r1; float h; };\nstruct Ray { vec3 origin; vec3 dir; float time; };\nstruct Camera {\n    mat4 mtx;\n    mat4 mtx_prev; \n    float fovV;\n    float lensSize;\n    float focusDist;\n};\n    \n\nconst int numBalls = 16;\nconst Table table = Table(vec2(4.0, 2.0)*15.0, vec3(0.0, -1.0, 0.0));\n    \n//http://billiards.colostate.edu/bd_articles/2017/may17.pdf\nconst vec3 ballcolors[16] = vec3[](\n    vec3( .98,  .95,  .9),//0\n    vec3( .6,  .6,  .1),//1\n    vec3( .2,  .2,  .8),//2\n    vec3( .86, .03, .03),//3\n    vec3( .3,  .24, .43),//4\n    vec3( .91, .24, .0),//5\n    vec3( .0,  .4,  .0),//6\n    vec3( .5,  .0,  .02),//7\n    vec3( .01, .01, .01),//8\n    vec3( .6,  .6,  .0),//9\n    vec3( .2,  .2,  .8),//10\n    vec3( .86, .03, .03),//11\n    vec3( .3,  .24, .43),//12\n    vec3( .91, .24, .0),//13\n    vec3( .0,  .4,  .0),//14\n    vec3( .5,  .0,  .02)//15\n);\n    \n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec2 rotateVec(vec2 v, float angle) {\n    vec2 cs = vec2(cos(angle), sin(angle));\n    return vec2(dot(v, cs), dot(v, vec2(cs.y, -cs.x)));\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  float c, s, a1, a2;\n  c = cos (a);  s = sin (a);\n  m[0][0] = (1. - c) * v.x * v.x + c;\n  m[1][1] = (1. - c) * v.y * v.y + c;\n  m[2][2] = (1. - c) * v.z * v.z + c;\n  a1 = (1. - c) * v.x * v.y;  a2 = - s * v.z;\n  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = (1. - c) * v.z * v.x;  a2 = - s * v.y;\n  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = (1. - c) * v.y * v.z;  a2 = - s * v.x;\n  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return m;\n}\n\nmat4 translateMtx(vec3 p) {\n    mat4 t;\n    t[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    t[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    t[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    t[3] = vec4(p, 1.0);\n    return t;\n}\n\n//build rotation matrix around point p and vector v of angle a\nmat4 VToRMat (vec3 p, vec3 v, float a)\n{\n    mat4 m;\n    float c, s, a1, a2;\n    c = cos (a); \n    s = sin (a);\n    m[0][0] = (1. - c) * v.x * v.x + c;\n    m[1][1] = (1. - c) * v.y * v.y + c;\n    m[2][2] = (1. - c) * v.z * v.z + c;\n    a1 = (1. - c) * v.x * v.y;\n    a2 = - s * v.z;\n    m[0][1] = a1 + a2;\n    m[1][0] = a1 - a2;\n    a1 = (1. - c) * v.z * v.x;\n    a2 = - s * v.y;\n    m[2][0] = a1 + a2;\n    m[0][2] = a1 - a2;\n    a1 = (1. - c) * v.y * v.z;\n    a2 = - s * v.x;\n    m[1][2] = a1 + a2;\n    m[2][1] = a1 - a2;\n    \n    m[0][3] = 0.0;\n    m[1][3] = 0.0;\n    m[2][3] = 0.0;\n    m[3][0] = 0.0;\n    m[3][1] = 0.0;\n    m[3][2] = 0.0;\n    m[3][3] = 1.0;\n    \n    return translateMtx(p) * m * translateMtx(-p);\n}\n\nvec3 orthogonalize(in vec3 n, in vec3 v) {\n    return v - n * dot(n, v);\n}\n\nmat3 rotAroundX(float alpha) {\n    mat3 mtx;\n    mtx[0] = vec3(1.0,         0.0,        0.0);\n    mtx[1] = vec3(0.0,  cos(alpha), sin(alpha));\n    mtx[2] = vec3(0.0, -sin(alpha), cos(alpha));\n    return mtx;\n}\n\nmat3 rotAroundY(float alpha) {\n    mat3 mtx;\n    mtx[0] = vec3(cos(alpha), 0.0, -sin(alpha));\n    mtx[1] = vec3(       0.0, 1.0,         0.0);\n    mtx[2] = vec3(sin(alpha), 0.0,  cos(alpha));\n    return mtx;\n}\n\nmat4 fromPosRot(in vec3 p, in mat3 r) {\n    mat4 mtx;\n    mtx[0] = vec4(r[0], 0.0);\n    mtx[1] = vec4(r[1], 0.0);\n    mtx[2] = vec4(r[2], 0.0);\n    mtx[3] = vec4(p, 1.0);\n    return mtx;\n}\n\nvec3 slerp(vec3 a, vec3 b, float t) {\n\tfloat theta = acos(dot(a, b));\n    return \ta * sin((1.0 - t)*theta) / sin(theta) +\n    \t\tb * sin(t*theta) / sin(theta);\n}\n\nmat4 mtxLerp(in mat4 a, in mat4 b, float p) {\n    mat4 mtx = a;\n    for(int i=0; i<3; i++) {\n    \tvec3 rot_vec = normalize(cross(a[i].xyz, b[i].xyz));\n        float rot_angle = acos(dot(a[i].xyz, b[i].xyz));\n        mat4 rot = VToRMat(vec3(0.), -rot_vec, p * rot_angle);\n        mtx = rot * mtx;\n    }\n    mtx[3].xyz = mix(a[3].xyz, b[3].xyz, p);\n    return mtx;\n}\n\nmat4 mtxLerp2(in mat4 a, in mat4 b, float p) {\n    mat4 mtx = a;\n    mtx[0].xyz = normalize(mix(a[0].xyz, b[0].xyz, p));\n    mtx[1].xyz = normalize(mix(a[1].xyz, b[1].xyz, p));\n    mtx[2].xyz = normalize(mix(a[2].xyz, b[2].xyz, p));\n    mtx[1].xyz = orthogonalize(mtx[0].xyz, mtx[1].xyz);\n    mtx[2].xyz = orthogonalize(mtx[0].xyz, mtx[2].xyz);\n    mtx[2].xyz = orthogonalize(mtx[1].xyz, mtx[2].xyz);\n    mtx[3].xyz = mix(a[3].xyz, b[3].xyz, p);\n    return mtx;\n}\n\n#if __VERSION__ >= 300\nmat3 mat3Inverse( in mat3 m ) { return inverse(m); }\nmat4 mat4Inverse( in mat4 m ) {return inverse(m);}\n#else\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n#endif\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    x = normalize(orthogonalize(z, x));\n    vec3 y = cross(z,x);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\n\n\nvoid saveBall(in Ball ball, int id, in ivec2 p, inout vec4 fragColor) {\n    for(int i=0; i<4; i++) {\n    \tfragColor = (p.y == id && p.x == i)? ball.mtx[i] : fragColor;\n    }\n#ifdef MOTION_BLUR\n    for(int i=0; i<4; i++) {\n    \tfragColor = (p.y == id && p.x == 4+i)? ball.mtx_prev[i] : fragColor;\n    }\n#endif\n    fragColor = (p.y == id && p.x == 8)? vec4(0.0, ball.v) : fragColor;\n}\n\nBall loadBall(in sampler2D tex, in int id) {\n    Ball ball;\n    for(int i=0; i<4; i++) {\n        ball.mtx[i] = texelFetch(tex, ivec2(i, id), 0);\n    }\n#ifdef MOTION_BLUR\n    for(int i=0; i<4; i++) {\n        ball.mtx_prev[i] = texelFetch(tex, ivec2(4+i, id), 0);\n    }\n#endif\n    vec4 tmp = texelFetch(tex, ivec2(8, id), 0);\n    ball.v   = tmp.yzw;\n    return ball;\n}\n\nvoid saveCue(in Cue cue, in ivec2 p, inout vec4 fragColor) {\n    vec4 fragColorOld = fragColor;\n    \n    fragColor = mix(fragColor, cue.mtx[0], vec4(p.y == 50));\n    fragColor = mix(fragColor, cue.mtx[1], vec4(p.y == 51));\n    fragColor = mix(fragColor, cue.mtx[2], vec4(p.y == 52));\n    fragColor = mix(fragColor, cue.mtx[3], vec4(p.y == 53));\n\tfragColor = mix(fragColor, vec4(cue.r0, cue.r1, cue.h, 0.0), vec4(p.y == 54));\n\n    fragColor = mix(fragColorOld, fragColor, vec4(p.x == 0));\n}\n\nCue readCue(in sampler2D tex){\n    Cue cue;\n    cue.mtx[0] = texelFetch(tex, ivec2(0, 50), 0);\n    cue.mtx[1] = texelFetch(tex, ivec2(0, 51), 0);\n    cue.mtx[2] = texelFetch(tex, ivec2(0, 52), 0);\n    cue.mtx[3] = texelFetch(tex, ivec2(0, 53), 0);\n    vec4 a = texelFetch(tex, ivec2(0, 54), 0);\n    cue.r0 = a.x; \n    cue.r1 = a.y;\n    cue.h = a.z;\n    return cue;\n}\n\nvoid saveCamera(in Camera camera, in ivec2 p, inout vec4 fragColor) {\n    vec4 fragColorOld = fragColor;\n    \n    fragColor = mix(fragColor, camera.mtx[0], vec4(p.y == 60));\n    fragColor = mix(fragColor, camera.mtx[1], vec4(p.y == 61));\n    fragColor = mix(fragColor, camera.mtx[2], vec4(p.y == 62));\n    fragColor = mix(fragColor, camera.mtx[3], vec4(p.y == 63));\n    fragColor = mix(fragColor, camera.mtx_prev[0], vec4(p.y == 64));\n    fragColor = mix(fragColor, camera.mtx_prev[1], vec4(p.y == 65));\n    fragColor = mix(fragColor, camera.mtx_prev[2], vec4(p.y == 66));\n    fragColor = mix(fragColor, camera.mtx_prev[3], vec4(p.y == 67));\n\tfragColor = mix(fragColor, vec4(camera.fovV, camera.lensSize, camera.focusDist, 0.), vec4(p.y == 68));\n\n    fragColor = mix(fragColorOld, fragColor, vec4(p.x == 0));\n}\n\nCamera readCamera(in sampler2D tex) {\n    Camera c;\n    c.mtx[0] = texelFetch(tex, ivec2(0, 60), 0);\n    c.mtx[1] = texelFetch(tex, ivec2(0, 61), 0);\n    c.mtx[2] = texelFetch(tex, ivec2(0, 62), 0);\n    c.mtx[3] = texelFetch(tex, ivec2(0, 63), 0);\n    c.mtx_prev[0] = texelFetch(tex, ivec2(0, 64), 0);\n    c.mtx_prev[1] = texelFetch(tex, ivec2(0, 65), 0);\n    c.mtx_prev[2] = texelFetch(tex, ivec2(0, 66), 0);\n    c.mtx_prev[3] = texelFetch(tex, ivec2(0, 67), 0);\n    vec4 a = texelFetch(tex, ivec2(0, 68), 0);\n    c.fovV = a.x;\n    c.lensSize = a.y;\n    c.focusDist = a.z;\n    return c;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "Ball balls[numBalls];\nCue cue;\nCamera camera;\n//vec3 tavle_pos = \nvec2 tablemin = table.pos.xy - table.size / 2.0f;//vec3(0.0, -1.0, 0.0).xz - vec2(3.0, 2.0)*15.0 * 0.5;\nvec2 tablemax = table.pos.xy + table.size / 2.0f;//vec3(0.0, -1.0, 0.0).xz + vec2(3.0, 2.0)*15.0 * 0.5;\n\nvec4 char(vec2 pos, float c) {\n    pos = clamp(pos,0.,1.);  // would be more efficient to exit if out.\n    vec4 tx= texture( iChannel3, pos/16. + fract( floor(vec2(c, 15.999-c/16.)) / 16. ) )*2. ;\n    vec4 ty= texture( iChannel3, pos/16.012 + fract( floor(vec2(c, 15.999-c/16.012)) / 16.012 ) )/3.0 ;\n    vec4 tz= texture( iChannel2,pos);\n    return  vec4((tx+ty)/(tz*3.0));\n}\n\nvec3 getBallTexture(vec2 uv, vec3 color, int num) {\n    vec3 white = vec3(1.0, 1.0, 0.8);\n    if(num == 0) {\n        return white;\n    } else {\n        bool solid = (num < 9);\n        float edgeBlend = 0.01;\n        vec2 dirToCenter = vec2(0.5, 0.5) - vec2(uv.x + (0.5-uv.x)*0.5, uv.y);\n        float d = sqrt(dot(dirToCenter, dirToCenter));\n        float r = 0.07;\n        vec3 res;\n\n        float dirt = texture(iChannel2,uv*1.5).x;\n\n        vec3 non_solid;\n        float dd = abs(uv.y - 0.5) * 2.0f;\n        if(dd < 0.18 - edgeBlend) {\n            non_solid = color;\n        } else if(dd > 0.18 + edgeBlend) {\n            non_solid = white;\n        } else {\n            float blende = ((dd - (0.18 - edgeBlend))/(2.0*edgeBlend))*dirt;\n            non_solid = mix(color, white, blende);\n        }\n        vec3 outside_circle = mix(non_solid, color, solid? 1.0 : 0.0);\n        vec3 inside_circle = vec3(0.);\n        vec2 scale = vec2(5.0, 8.0);\n        if(num > 9) {\n            vec4 numc1 = char(scale*(uv - 0.5) + vec2(0.3, 0.5), 48.0 + float(num-10));\n            vec4 numc2 = char(scale*(uv - 0.5) + vec2(0.7, 0.5), 48.0 + float(num/10));\n            numc1.xyz = vec3(1.0) - numc1.xxx*2.0;\n            numc2.xyz = vec3(1.0) - numc2.xxx*2.0;\n            inside_circle = mix(white, numc1.xyz, numc1.w)*mix(white, numc2.xyz, numc2.w);\n        } else {\n            vec4 numc = char(scale*(uv - 0.5) + vec2(0.5), 48.0 + float(num));\n            numc.xyz = vec3(1.0) - numc.xxx*2.0;\n            inside_circle = mix(white, numc.xyz, numc.w);\n        }\n\n        bool on_69_mark = (d > 0.047) && (d < 0.057) && (uv.y < 0.5) && (abs(uv.x - 0.5) < 0.03);\n        inside_circle *= vec3((num == 6 || num == 9)? (on_69_mark? dirt*dirt : 1.0) : 1.0);\n        res = mix(outside_circle, inside_circle, (d < r - edgeBlend)?1.0 : 0.0);\n\n        float blendc = ((d - (r - edgeBlend))/(2.0*edgeBlend))*dirt;\n        vec3 on_the_circle = mix(white, color, blendc);\n        res = mix(res, on_the_circle, (abs(d - r) < edgeBlend)?1.0 : 0.0);\n        return res;\n    }\n}\n\nvoid initBalls() {\n    const int rack_pattern[15] = int[](1, 2, 9, 10, 8, 3, 4, 14, 7, 11, 12, 6, 15, 13, 5);\n    int b = 0;\n    for(int i=0; i<5; i++) {\n        for(int j=0; j<=i; j++) {\n            balls[rack_pattern[b]].v = vec3(0.);\n            balls[rack_pattern[b]].mtx = createCS(vec3(-12.0 - float(i)*2.0, 0.0, float(i) - float(j)*2.0),\n                                    vec3(rnd(), rnd(), 0.0),\n                                    vec3(0.0, rnd(), rnd()));\n            b++;\n    \t}\n    }\n    \n    balls[0].v = vec3(0.);\n    balls[0].mtx = createCS(vec3(14.0, 0.0, 0.0),\n                            vec3(1.0, 0.0, 0.0),\n                            vec3(0.0, 0.0, 1.0));\n    \n#ifdef MOTION_BLUR\n    for(int i=0; i<numBalls; i++) {balls[i].mtx_prev = balls[i].mtx;}\n#endif\n}\n\n\nvoid initCamera(in vec3 pos, in vec3 target, in float fovV, in float radius, in float focus_dist) {\n\tconst vec3 upDir = vec3(0.0, -1.0, 0.0);\t\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.mtx[0] = vec4(right, 0.0);\n    camera.mtx[1] = vec4(up, 0.0);\n    camera.mtx[2] = vec4(back, 0.0);\n    camera.mtx[3] = vec4(pos, 1.0);\n    camera.mtx_prev = camera.mtx;\n    camera.fovV = fovV;\n    camera.focusDist = focus_dist;\n    camera.lensSize = radius;\n}\n\nvoid loadBalls() {\n    for(int i=0; i<numBalls; i++) {\n        balls[i] = loadBall(iChannel0, i);\n    }\n}\n\nvoid updateball(int ballid) {\n    vec3 pos = balls[ballid].mtx[3].xyz;\n    float speed = length(balls[ballid].v);\n    //if(speed > 0.001) {\n    bool is_moving = (speed > 0.0);\n    for(int j=0; j<numBalls; j++) {\n        if(ballid != j) {\n            vec3 pos2 = balls[j].mtx[3].xyz;\n            vec3 vec = pos2 - pos;\n            float dist2 = dot(vec, vec);\n            if(dist2 < 4.0) {\n                vec  = normalize(vec) * (2.0 - sqrt(dist2));\n                balls[j].v += vec*0.46;\n                balls[ballid].v += -vec*0.46;\n                is_moving = true;\n            }\n        }\n    }\n\n    if(is_moving) {\n        speed = length(balls[ballid].v);//update speed\n        vec3 dir = normalize(balls[ballid].v);\n        vec3 dir_new = dir;\n        vec3 new_pos = pos + dir * speed;\n\n\n        if(new_pos.x > tablemax.x - 1.0) {\n            new_pos.x = tablemax.x - 1.0;//this is wrong\n            dir_new = reflect(dir, vec3(1.0, 0.0, 0.0));\n            speed *= 0.9;\n        }\n\n        if(new_pos.x < tablemin.x + 1.0) {\n            new_pos.x = tablemin.x + 1.0;//this is wrong\n            dir_new = reflect(dir, vec3(-1.0, 0.0, 0.0));\n            speed *= 0.9;\n        }\n\n        if(new_pos.z > tablemax.y - 1.0) {\n            new_pos.z = tablemax.y - 1.0;//this is wrong\n            dir_new = reflect(dir, vec3(0.0, 0.0, -1.0));\n            speed *= 0.9;\n        }\n\n        if(new_pos.z < tablemin.y + 1.0) {\n            new_pos.z = tablemin.y + 1.0;//this is wrong\n            dir_new = reflect(dir, vec3(0.0, 0.0, 1.0));\n            speed *= 0.9;\n        }\n\n        float angle = speed;\n        vec3 rot_vec = cross(vec3(0.0, 1.0, 0.0), dir);\n        mat4 rot = VToRMat(vec3(0.), rot_vec, -angle);\n        mat4 new_mtx = rot * balls[ballid].mtx;\n        new_mtx[3].xyz = new_pos;\n#ifdef MOTION_BLUR\n        balls[ballid].mtx_prev = balls[ballid].mtx;\n#endif\n        balls[ballid].mtx = new_mtx;\n        balls[ballid].v = dir_new * sqrt(speed*speed * 0.97);\n    }\n}\n\nvoid updateCueAndCamera() {\n\tvec3 avg_pos = vec3(0.);\n    for(int i=0; i<numBalls; i++) {\n    \tavg_pos += balls[i].mtx[3].xyz;\n    }\n    avg_pos /= float(numBalls);\n    \n    \n    if(length(balls[0].v) < 0.03) {\n        vec3 cue_pos = cue.mtx[3].xyz;\n        vec3 cue_dir = cue.mtx[2].xyz;\n        vec3 white_ball_pos = balls[0].mtx[3].xyz;\n        \n        vec3 desired_cue_dir = normalize(normalize(avg_pos-white_ball_pos)/* + vec3(0.0, -0.1, 0.0)*/);\n\n        //mx from -1 to 1\n        float mx = (iMouse.x==0.0) ? 0.0 : ((iMouse.x / iResolution.x)*2.0 - 1.0);\n       \tdesired_cue_dir = rotAroundY(mx*2.0) * desired_cue_dir;\n        vec3 desired_cue_pos = white_ball_pos - cue_dir * (cue.h + 3.0 + sin(iTime*5.0)*3.0);\n        vec3 target = mix(avg_pos, white_ball_pos + cue_dir * (cue.h + 20.0), 0.5);\n        \n\t\tfloat rot_angle = acos(dot(cue_dir, desired_cue_dir));\n        if(rot_angle > 0.005) {\n            vec3 rot_vec = normalize(cross(cue_dir, desired_cue_dir));\n            vec3 rot_pos = cue_pos + cue_dir * cue.h;\n            mat4 rot = VToRMat(rot_pos, -rot_vec, 0.05*rot_angle);\n            cue.mtx = rot * cue.mtx;\n        }\n        \n        cue.mtx[3].xyz = mix(desired_cue_pos, cue.mtx[3].xyz, 0.96);\n        //just to make it orthogonal again\n        cue.mtx = createCS(\tcue.mtx[3].xyz,\n                            cue.mtx[2].xyz,\n                            cue.mtx[0].xyz);\n        \n        float my = iMouse.y / iResolution.y;\n        vec3 left = normalize(cross(cue_dir, vec3(0.0, -1.0, 0.0)));\n        vec3 desired_cam_pos = white_ball_pos - cue_dir * cue.h * (0.2 + my) + vec3(0., 3.0 + 10.0 * my, 0.) + left * 5.0 * my;\n        vec3 desired_cam_dir = -normalize(target - desired_cam_pos);\n        mat4 desired_mtx = createCS(desired_cam_pos,\n                                    desired_cam_dir,\n                                    normalize(cross(vec3(0.0, -1.0, 0.0), desired_cam_dir)));\n\n        camera.mtx_prev = camera.mtx;\n        camera.mtx = mtxLerp2(camera.mtx, desired_mtx, 0.2);\n    }\n}\n\n#define updateaabb(lbox, rboxx, rmin, axis) \n\nvoid updateAABB(in ivec2 p, inout vec4 fragColor){\n    const float big = 1000.;\n    vec4 box = vec4(big, big, -big, -big);\n    for(int i=0; i<numBalls; i++) {\n        vec3 pos = balls[i].mtx[3].xyz;\n        box.z = mix(box.z, pos.x, float(pos.x > box.z));\n        box.w = mix(box.w, pos.z, float(pos.z > box.w));\n       \tbox.x = mix(box.x, pos.x, float(pos.x < box.x));\n        box.y = mix(box.y, pos.z, float(pos.z < box.y));\n    }\n    box.xy -= vec2(1.0, 1.0);\n    box.zw += vec2(1.0, 1.0);\n    fragColor = (p.y == 30 && p.x == 0)? box : fragColor;\n    /*\n    //Object partitioning along long side of the AABB\n    vec4 lbox = box;\t//left child\n\tvec4 rbox = box;\t//right child\n    if(box.z - box.x > box.w - box.y) {\n        lbox.z = -1000.0;\n        rbox.x =  1000.0;\n        for(int i=0; i<numBalls; i++) {\n            float p = balls[i].mtx[3].x;\n            lbox.z = mix(lbox.z, p + 1.0, float(p + 1.0 > lbox.z));\n            rbox.x = mix(rbox.x, p - 1.0, float(p - 1.0 < rbox.x));\n        }\n    } else {\n        lbox.w = -1000.0;\n        rbox.y =  1000.0;\n        for(int i=0; i<numBalls; i++) {\n            float p = balls[i].mtx[3].y;\n            lbox.w = mix(lbox.z, p + 1.0, float(p + 1.0 > lbox.w));\n            rbox.y = mix(rbox.y, p - 1.0, float(p - 1.0 < rbox.y));\n        }\n    }\n    \n    fragColor = (p.y == 31 && p.x == 0)? lbox : fragColor;\n    fragColor = (p.y == 32 && p.x == 0)? rbox : fragColor;*/\n}\n\nvoid initCue() {\n    cue.mtx = createCS(vec3(-9.60, -0.2, 15.0), normalize(vec3(0.5, -0.02, -1.0)), normalize(vec3(0.1, 1.0, 0.3)));\n    cue.r0 = 0.45; \n    cue.r1 = 0.2;\n    cue.h = 37.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 p = ivec2(fragCoord);\n    if(int(fragCoord.x) < 16 && int(fragCoord.y) < 128 ) {\n        \n        if(iFrame == 0) {\n            initBalls();\n            initCue();\n            vec3 cameraTarget = vec3(0., 0., -4.);\n            vec3 camDir = vec3(1.0, 0.2, 0.0);\n            float cameraDist = 40.0;\n            initCamera(cameraTarget + camDir*cameraDist, cameraTarget, 18.0, LENS_SIZE, cameraDist);\n            if(p.y < numBalls) {\n                int ballid = p.y;\n            \tsaveBall(balls[ballid], ballid, p, fragColor);\n            }\n            //saveBalls(p, fragColor);\n            saveCue(cue, p, fragColor);\n            saveCamera(camera, p, fragColor);\n        } else {\n            \n            loadBalls();\n            cue = readCue(iChannel0);\n            camera = readCamera(iChannel0);\n\n            if( (texelFetch( iChannel1, ivec2(32,0),0 ).x > 0.0 &&\n                texelFetch( iChannel1, ivec2(32,2),0 ).x == 0.0) &&\n                length(balls[0].v) < 0.01){\n                vec3 cue_dir = cue.mtx[2].xyz;\n                balls[0].v = vec3(cue_dir.x, 0.0, cue_dir.z) * 2.0;\n            }\n            \n            if(p.y < numBalls) {\n                int ballid = p.y;\n            \tupdateball(ballid);\n                saveBall(balls[ballid], ballid, p, fragColor);\n            }\n            updateCueAndCamera();\n\t\t\t//initCamera(vec3(-17.0, 10.0, 0.0), vec3(-17.2, 0.0, 0.0), 18.0, LENS_SIZE, 10.0);\n            saveCue(cue, p, fragColor);\n            saveCamera(camera, p, fragColor);\n\n        }\n        \n        updateAABB(p, fragColor);\n    } else if(int(fragCoord.y) >= 128 && int(fragCoord.y) < 256 && int(fragCoord.x) < 512) {//ball textures\n        if(iFrame < 10) {\n            int x = int(fragCoord.x);\n            int y = int(fragCoord.y) - 128;\n            int ballid = x / 64 + (y / 64)*8;\n            ballid = clamp(ballid, 0, 16);\n            vec2 uv = vec2(mod(fragCoord.x, 64.0f) / 64.0f, mod(fragCoord.y, 64.0f) / 64.0f);\n\n            uv -= vec2(0.5, 0.5);\n            uv /= vec2(2.0f, 4.0f);\n            uv += vec2(0.5, 0.5);\n            vec3 c = getBallTexture(uv, ballcolors[ballid], ballid);\n            fragColor = vec4(c, 1.);\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    } else {\n        discard;\n        //fragColor = vec4(0.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define PIXEL_SAMPLES \t\t2\n#define MAX_DEPTH\t\t\t2\n\n#define CLAMP_VALUE\t\t\t2.5\n#define VOLUME_SCAATTERING\t0.0003\t\t\t//Increase for more fog\n#define CDF_SIZE 2\n\n//https://www.solidangle.com/research/egsr2013_spherical_rectangle.pdf\n#define SPHERICAL_RECTANGLE\n\n\nconst vec3 backgroundColor = vec3( 0.0 );\n\nbool is_inf(float val) {\n#if __VERSION__ >= 300\n    return isinf(val);\t//webGL 2.0 is required\n#else\n\treturn val != val;\n#endif\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n\nfloat misWeight( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\n//////////////////////////////////////////////////////////////////////////\n\n\n    \n#define SURFACE_ID_BASE\t0\n#define LIGHT_ID_BASE\t64\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_DISK\t\t4\n#define OBJ_CONE\t\t5\n\nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int mtl_id_;\n};\n    \nstruct Light {\n    vec3 color_;\n    float intensity_;\n    vec3 pos;\n    vec2 size;\n};\n\n//Weighted sum of Lambertian and Blinn brdfs\nstruct Material {\n    vec3 diffuse_color_;\n    int diffuse_color_tex_;\n    float specular_roughness_;\n    int specular_roughness_tex_;\n    bool metal_;\n    float specular_weight_;\n    int specular_weight_tex_;\n    int normal_map_;\n    float tex_scale_;\n};\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n    \n// ************ SCENE ***************\n\n\nconst int num_mtl = 5;\nChalk chalk;\nLight light;\nMaterial mtl[num_mtl];\n\n//***********************************\nMaterial createMaterial(vec3 diff,\n                    int diff_tex,\n                    float roughness,\n                    int roughness_tex,\n                    bool metal,\n                   \tfloat weight,\n                    int weight_tex,\n                    int normal_map,\n                    float tex_scale) {\n    Material mtl;\n    mtl.diffuse_color_ = diff;\n    mtl.diffuse_color_tex_ = diff_tex;\n    mtl.specular_roughness_ = roughness;\n    mtl.specular_roughness_tex_ = roughness_tex;\n    mtl.metal_ = metal;\n    mtl.specular_weight_ = weight;\n    mtl.specular_weight_tex_ = weight_tex;\n    mtl.normal_map_ = normal_map;\n    mtl.tex_scale_ = tex_scale;\n    return mtl;\n}\n\nMaterial getMaterial(int i) {\n    if(i >= num_mtl) {\n        int ballid = i - num_mtl;\n        return createMaterial(vec3(0.), 6 + ballid, 0.001, -1, false, 0.6, -1, -1, 1.0);\n    } else {\n#if __VERSION__ >= 300\n    return mtl[i];\t//webGL 2.0\n#else\n    if(i==0) return mtl[0]; \n    if(i==1) return mtl[1]; \n    if(i==2) return mtl[2]; \n    return mtl[2];\n#endif \n    }\n}\n\nLight getLight(int i) {\n    return light;\n}\n\nvec3 getBallTexture(vec2 uv, vec3 color, int num) {\n    uv = vec2(1.0 - uv.y, uv.x);\n    uv -= vec2(0.5, 0.5);\n    uv *= vec2(4.0f, 2.0f);\n    uv += vec2(0.5, 0.5);\n    uv = min(uv, vec2(0.97));\n    uv = max(uv, vec2(0.03));\n    \n    int px = (num > 7 ? num - 8 : num) * 64 + int(uv.x * 64.0);\n    int py = 128 + (num > 7 ? 1 : 0) * 64 + int(uv.y * 64.0);\n    uv = vec2(float(px), float(py)) / iResolution.xy;\n    return texture(iChannel0,uv).xyz;\n}\n\nvec3 getCueTexture(vec2 uv) {\n    vec3 wood = texture( iChannel1, uv.yx ).xyz;\n    \n    if(uv.y > 1.0) {\n        return wood;\n    } else {\n    \tfloat k = fract(uv.x / 0.2);\n    \tfloat h = 0.3;\n    \tfloat a = mix(-1.0, 1.0, float(k < h));\n    \treturn (a*(h-k)*0.3 < uv.y-h)?wood:vec3(0.01);\n    }\n}\n\nvec3 getFabricColor(vec2 uv) {\n    float aa = texture(iChannel1,uv).r*0.5 + texture(iChannel1,uv.yx).r*0.5;//add some more inperfection\n\treturn vec3(0.3, 0.9, 0.2)*(aa*0.5 + 0.2)*0.6;\n}  \n    \nvec3 getColor(vec2 uv, int tex) {\n    vec3 c;\n    if(tex==0) c = texture( iChannel0, uv ).xyz; else\n    if(tex==1) c = texture( iChannel1, uv ).xyz; else\n    if(tex==2) c = texture( iChannel2, uv ).xyz; else\n    if(tex==3) c = texture( iChannel3, uv ).xyz; else\n    if(tex==4) c = getCueTexture(uv); else\n    if(tex==5) c = getFabricColor(uv); else\n    if(tex > 5) {\n        int ballid = tex - 6;\n    \tc = getBallTexture(uv, ballcolors[ballid], ballid);\n    }\n    return clamp(c, 0.0, 1.0);\n}\n\nvec2 getTexRes(int tex) {\n#if __VERSION__ >= 300\n    if(tex>=0 && tex < 4){\n        return iChannelResolution[tex].xy;\n    }\n#else\n    if(tex==0) return iChannelResolution[0].xy;\n    if(tex==1) return iChannelResolution[1].xy;\n    if(tex==2) return iChannelResolution[2].xy;\n    if(tex==3) return iChannelResolution[3].xy;\n#endif\n    \n    return vec2(2048, 2048);\n}\n\n//#define NORMAL_MAPS\nvec3 getNormal(vec2 uv, int tex ) {\n#ifdef NORMAL_MAPS\n    const float heightScale = 0.004;\n\n    vec2 res = getTexRes(tex);\n    vec2 duv = vec2(1.0) / res.xy;\n    vec3 c  = getColor( uv, tex).xyz;\n    vec3 c1 = getColor( uv + vec2(duv.x, 0.0), tex).xyz;\n    vec3 c2 = getColor( uv - vec2(duv.x, 0.0), tex).xyz;\n    vec3 c3 = getColor( uv + vec2(0.0, duv.y), tex).xyz;\n    vec3 c4 = getColor( uv - vec2(0.0, duv.y), tex).xyz;\n    \n    float h0\t= heightScale * dot(c , vec3(1.0/3.0));\n    float hpx = heightScale * dot(c1, vec3(1.0/3.0));\n    float hmx = heightScale * dot(c2, vec3(1.0/3.0));\n    float hpy = heightScale * dot(c3, vec3(1.0/3.0));\n    float hmy = heightScale * dot(c4, vec3(1.0/3.0));\n    float dHdU = (hmx - hpx) / (2.0 * duv.x);\n    float dHdV = (hmy - hpy) / (2.0 * duv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0));\n#else\n    return vec3(0.0, 0.0, 1.0);\n#endif\n}\n\nvec3 getRadiance(vec2 uv) {\n    return light.color_*light.intensity_;\n}\n\nvoid createLight(vec3 color,\n                 float intensity,\n                 vec3 pos,\n                 vec2 size,\n                 out Light light) {\n    light.color_ = color;\n    light.intensity_ = intensity;\n    light.pos = pos;\n    light.size = size;\n}\n\nvoid initScene() {\n    createLight(vec3(1.0, 1.0, 0.9), 8.0, vec3(0.0, 20.0, 0.0), vec2(40.0, 8.0), light);\n\n    //Create materials\n    //diff color, diff_tex, roughness, roughness_tex, weight, weight_tex, normal_map, tex_scale\n    mtl[0] = createMaterial(vec3(0.2, 0.6, 0.3),  5, 0.015, -1, false, 0.0, -1, -1, 1.0);//fabric\n    mtl[1] = createMaterial(vec3(1.0, 1.0, 1.0),  4, 0.000,  1, false, 0.3, -1, -1, 1.0);//cue\n    mtl[2] = createMaterial(vec3(0.2, 0.5, 0.8), -1, 0.400, -1, false, 0.2, -1, -1, 1.0);//chalk\n    mtl[3] = createMaterial(vec3(0.5, 0.3, 0.0), -1, 0.100, -1, false, 0.6, -1, -1, 1.0);//table wood\n    mtl[4] = createMaterial(vec3(0.9, 0.9, 0.5), -1, 0.030, -1, false, 0.9, -1, -1, 1.0);//chalk metal head\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(1.0 - Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nfloat copysignf(in float x, in float y){\n     uint ix = floatBitsToUint(x);\n     uint iy = floatBitsToUint(y);\n     return uintBitsToFloat((ix&uint(0x7fffffff))|(iy&uint(0x80000000)));\n}\n\nvoid branchlessONB(vec3 n, out vec3 b1, out vec3 b2){\n    float sign = copysignf(1.0f, n.z);\n    float a = -1.0f / (sign + n.z);\n    float b = n.x * n.y * a;\n    b1 = vec3(1.0f + sign * n.x * n.x * a, sign * b, -sign * n.x);\n    b2 = vec3(b, sign + n.y * n.y * a, -n.y);\n}\n\nmat3 mat3FromNormal(in vec3 n) {\n    vec3 x, y;\n    branchlessONB(n, x, y);\n    return mat3(x,y,n);\n}\n\nvoid cart2sph(in vec3 xyz, out float rho, out float phi,out float theta) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nvec3 sph2cart( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in float Xi1, in float Xi2 ) {\n    float theta = acos(clamp(sqrt(1.0-Xi1),-1.0, 1.0));\n    float phi = TWO_PI * Xi2;\n    return sph2cart( 1.0, phi, theta );\n}\nvec3 sphericalToCartesian(\tin float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2, out float pdf ) {\n    pdf = 1.0 / (2.0 * PI);\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2,out float pdf ) {\n    pdf = 1.0 / (4.0 * PI);\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n// ************************   Scattering functions  *************************\nbool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){ return ((dot(n,a)*dot(n,b))>0.0); }\nbool sameHemisphere(in vec3 a, in vec3 b){ return (a.z*b.z>0.0); }\n\nfloat cosTheta(vec3 w) { return w.z; }\nfloat cosTheta2(vec3 w) { return cosTheta(w)*cosTheta(w); }\nfloat absCosTheta(vec3 w) { return abs(w.z); }\nfloat sinTheta2(vec3 w) { return max(0.0, 1.0 - cosTheta2(w)); }\nfloat sinTheta(vec3 w) { return sqrt(sinTheta2(w)); }\nfloat tanTheta2(vec3 w) { return sinTheta2(w) / cosTheta2(w); }\nfloat tanTheta(vec3 w) { return sinTheta(w) / cosTheta(w); }\nfloat cosPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 1.0 : clamp(w.x / sin_Theta, -1.0, 1.0); }\nfloat sinPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 0.0 : clamp(w.y / sin_Theta, -1.0, 1.0); }\nfloat cosPhi2(vec3 w) { return cosPhi(w) * cosPhi(w); }\nfloat sinPhi2(vec3 w) { return sinPhi(w) * sinPhi(w); }\n\nfloat ggx_eval(vec3 wh, float alphax, float alphay) {\n    float tan2Theta = tanTheta2(wh);\n    if (is_inf(tan2Theta)) {\n        return 0.;\n    } else {\n    \tfloat cos4Theta = cosTheta2(wh) * cosTheta2(wh);\n    \tfloat e = ((cosPhi2(wh) + sinPhi2(wh)) / (alphax * alphay)) * tan2Theta;\n    \treturn 1.0 / (PI * (alphax * alphay) * cos4Theta * (1.0 + e) * (1.0 + e));\n    }\n}\n\nvec3 ggx_sample(vec3 wi, float alphax, float alphay, float Xi1, float Xi2) {\n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(Xi1);\n    float phi = (Xi2 < a) ? Xi2 / a*PI : PI + (Xi2 - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((Xi2 < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\nfloat ggx_lambda(vec3 w, float alphax, float alphay) {\n    float absTanTheta = abs(tanTheta(w));\n    if (is_inf(absTanTheta)) {\n        return 0.;\n    } else {\n    \t// Compute _alpha_ for direction _w_\n    \tfloat alpha_ = sqrt((cosPhi2(w) + sinPhi2(w)) * (alphax * alphay));\n    \tfloat alpha2Tan2Theta = (alpha_ * absTanTheta) * (alpha_ * absTanTheta);\n    \treturn (-1.0 + sqrt(1.0 + alpha2Tan2Theta)) / 2.0;\n    }\n}\n\nfloat ggx_g1(vec3 w, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(w, alphax, alphay));\n}\n\nfloat ggx_g(vec3 wo, vec3 wi, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(wo, alphax, alphay) + ggx_lambda(wi, alphax, alphay));\n}\n\nfloat ggx_pdf(vec3 wi, vec3 wh, float alphax, float alphay) {\n    return ggx_eval(wh, alphax, alphay) * ggx_g1(wi, alphax, alphay) * abs(dot(wi, wh)) / abs(wi.z);\n}\n\nfloat pow2(in float x) { return x*x; } \nfloat pow5(in float x) { return pow2(x*x)*x; } \nfloat SchlickFresnel(in float IOR, float cosTheta) {\n    float R0 = pow2((1.0 - IOR) / (1.0 + IOR));\n    return R0 + pow5(1.0 - cosTheta) * (1.0 - R0);\n}\n\nvec3 mtlEval(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    if(!mtl.metal_ && mtl.specular_weight_ == 0.0) {//pure diffuse\n        return mtl.diffuse_color_ * vec3(INV_PI);\n    } else {\n        mat3 trans = mat3FromNormal(Ns);\n        mat3 inv_trans = mat3Inverse( trans );\n\n        vec3 E_local = inv_trans * E;\n        vec3 L_local = inv_trans * L;\n        float cosThetaO = abs(E_local.z), cosThetaI = abs(L_local.z);\n\n        if(!sameHemisphere(E_local, L_local) || (cosThetaI == 0.0 || cosThetaO == 0.0)) {\n            return vec3(0.0);\n        } else {\n            float alpha = mtl.specular_roughness_;\n            vec3 wh = L_local + E_local;\n            wh = normalize(wh);\n\n            float F = mtl.metal_? 1.0 : SchlickFresnel(1.6, dot(L_local, wh))* mtl.specular_weight_;\n            float D = ggx_eval(wh, alpha, alpha);\n            float G = ggx_g(E_local, L_local, alpha, alpha);\n\n            vec3 spec = vec3(F * D * G) / (4.0 * cosThetaI * cosThetaO);\n            vec3 diff = mtl.diffuse_color_ * vec3(INV_PI) * (1.0 - F);\n            return \tdiff + spec;\n        }\n    }\n}\n\nfloat pdfDiffuse(in vec3 L_local) {\n    return INV_PI * L_local.z;\n}\n\nfloat pdfSpecular(in vec3 E_local, in vec3 L_local, in float alpha) {\n    vec3 wh = normalize(E_local + L_local);\n    return ggx_pdf(E_local, wh, alpha, alpha) / (4.0 * dot(E_local, wh));\n}\n\nvec3 mtlSample(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in float Xi1, in float Xi2, out vec3 L, out float pdf) {\n    if(!mtl.metal_ && mtl.specular_weight_ == 0.0) {//pure diffuse\n        mat3 trans = mat3FromNormal(Ns);\n        vec3 L_local = sampleHemisphereCosWeighted( Xi1, Xi2 );\n        L = trans*L_local;\n        pdf = pdfDiffuse(L_local);\n        return mtl.diffuse_color_ * vec3(INV_PI);\n    } else {\n        mat3 trans = mat3FromNormal(Ns);\n        mat3 inv_trans = mat3Inverse( trans );\n\n        //convert directions to local space\n        vec3 E_local = inv_trans * E;\n        vec3 L_local;\n\n        if (E_local.z == 0.0) { \n            return vec3(0.);\n        } else {\n            float alpha = mtl.specular_roughness_;\n            float F = mtl.metal_? 1.0 : SchlickFresnel(1.6, E_local.z)* mtl.specular_weight_;\n            //Sample specular or diffuse lobe based on fresnel\n            if(rnd() < F) {\n                // Sample microfacet orientation $\\wh$ and reflected direction $\\wi$\n                vec3 wh = ggx_sample(E_local, alpha, alpha, Xi1, Xi2);\n                L_local = reflect(-E_local, wh);\n            } else {\n                L_local = sampleHemisphereCosWeighted( Xi1, Xi2 );\n            }\n\n            if (!sameHemisphere(E_local, L_local)) {\n                pdf = 0.0;\n            } else {\n                // Compute PDF of _wi_ for microfacet reflection\n                pdf = \tpdfSpecular(E_local, L_local, alpha) * F +\n                        pdfDiffuse(L_local) * (1.0 - F);\n            }\n\n            //convert directions to global space\n            L = trans*L_local;\n\n            if(!sameHemisphere(Ns, E, L) || !sameHemisphere(Ng, E, L)) {\n                pdf = 0.0;\n            }\n\n            return mtlEval(mtl, Ng, Ns, E, L);\n        }\n    }\n}\n\nfloat mtlPdf(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    float alpha = mtl.specular_roughness_;\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    vec3 wh = normalize(E_local + L_local);\n    float F = mtl.metal_? 1.0 : SchlickFresnel(1.6, E_local.z)* mtl.specular_weight_;\n    \n    return pdfSpecular(E_local, L_local, alpha) * F +\n           pdfDiffuse(L_local)*(1.0 - F);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n    if ( discrim <= 0.0 ){\n        return false;\n    } else {\n        float rootDiscrim = sqrt( discrim );\n\n        float t_0 = (-B-rootDiscrim)/(2.0*A);\n        float t_1 = (-B+rootDiscrim)/(2.0*A);\n\n        t0 = min( t_0, t_1 );\n        t1 = max( t_0, t_1 );\n\n        return true;\n    }\n}\n\nbool rayAABBIntersection( in Ray ray, vec3 pmin, vec3 pmax, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 OMIN = ( pmin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( pmax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t ) {\n        return false;\n    } else {\n        if( !forShadowTest ) {\n            vec3 p = ray.origin + ray.dir*t;\n            vec3 dim = pmax - pmin;\n\n            if( EQUAL_FLT( p.x, pmin.x, EPSILON ) ) {\n                isect.normal_  =  vec3( -1.0, 0.0, 0.0 );\n                isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n                isect.uv_ = (p.zy - pmin.zy) / dim.zy;\n            } else if( EQUAL_FLT( p.x, pmax.x, EPSILON ) ) {\n                isect.normal_  =  vec3( 1.0, 0.0, 0.0 );\n                isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n                isect.uv_ = (p.zy - pmin.zy) / dim.zy;\n            } else if( EQUAL_FLT( p.y, pmin.y, EPSILON ) ) {\n                isect.normal_  =  vec3( 0.0, -1.0, 0.0 );\n                isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n                isect.uv_ = (p.xz - pmin.xz) / dim.xz;\n            } else if( EQUAL_FLT( p.y, pmax.y, EPSILON ) ) {\n                isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n                isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n                isect.uv_ = (p.xz - pmin.xz) / dim.xz;\n            } else if( EQUAL_FLT( p.z, pmin.z, EPSILON ) ) {\n                isect.normal_  =  vec3( 0.0, 0.0, -1.0 );\n                isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n                isect.uv_ = (p.xy - pmin.xy) / dim.xy;\n            } else if( EQUAL_FLT( p.z, pmax.z, EPSILON ) ) {\n                isect.normal_  =  vec3( 0.0, 0.0, 1.0 );\n                isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n                isect.uv_ = (p.xy - pmin.xy) / dim.xy;\n            }\n            isect.position_ = p;\n            isect.uv_ /= 2.0;\n        }\n\n        return true;\n    }\n}\n\nbool rayConeIntersection( in Ray r, in float radius, in float radius2, in float height1, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float height = (height1 * radius) / (radius - radius2);\n    float k = radius / height;\n    k = k * k;\n    \n    float a = r.dir.x * r.dir.x + r.dir.y * r.dir.y - k * r.dir.z * r.dir.z;\n    float b = 2.0 * (r.dir.x * r.origin.x + r.dir.y * r.origin.y - k * r.dir.z * (r.origin.z - height));\n    float c = r.origin.x * r.origin.x + r.origin.y * r.origin.y - k * (r.origin.z - height) * (r.origin.z - height);\n    \n\t// Compute quadratic cone coefficients\n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n    if (!solveQuadratic( a, b, c, t0, t1) || ( t1 < 0.0 )){\n\t\treturn false;\n    } else {\n        vec3 p;\n        vec3 p0 = r.origin + r.dir * t0;\n        vec3 p1 = r.origin + r.dir * t1;\n        \n        bool t0_is_valid = (t0 > 0.0) && (p0.z > 0.0) && (p0.z < height1);\n        bool t1_is_valid = (t1 > 0.0) && (p1.z > 0.0) && (p1.z < height1);\n        \n        if(!t0_is_valid && !t1_is_valid) {\n            return false;\n        } else {\n            t = mix(t1, t0, float(t0_is_valid));\n            \n            if( !forShadowTest ) {\t\n            \tp = mix(p1, p0, vec3(t0_is_valid));\n                float phi = atan(p.y,p.x) + PI;\n                isect.position_ = p;\n                isect.uv_.x = (phi)/TWO_PI;\n                isect.uv_.y = (p.z)/(height1);\n                isect.normal_ = normalize( vec3( p.xy, 0.0 ) );\n                isect.tangent_ = orthogonalize(isect.normal_, vec3( 0.0, 0.0, 1.0 ));\n            }\n\n        \treturn true;\n        }\n    }\n}\n\n//intersect unit radius sphere\nbool intersectSphere(Ray r, vec3 sph_o, out float t) { \n    float t0, t1;\n    \n    vec3 L = r.origin - sph_o; \n    float a = dot(r.dir, r.dir); \n    float b = 2.0 * dot(r.dir, L); \n    float c = dot(L, L) - 1.0; \n\n    if (!solveQuadratic(a, b, c, t0, t1)) {\n        return false;\n    } else {\n    \tt = mix(mix(-1.0, t1, t1 > 0.0), t0, t0 > 0.0);\n    \treturn (t > 0.0);\n    }\n}\n\nbool rayZPlaneIntersection( in Ray ray, in vec3 pos, in vec2 size, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    t = (pos.y - ray.origin.y) / ray.dir.y;\n    isect.position_ = ray.origin + ray.dir*t;\n    vec3 p_loc \t\t= isect.position_ - pos;\n    isect.uv_ \t\t= (p_loc.xz - (-size*0.5)) / size;\n    isect.normal_ \t= vec3( 0.0, 1.0, 0.0 );\n    isect.tangent_ \t= vec3( 1.0, 0.0, 0.0 );\n    return ((p_loc.x > -size.x*0.5) && (p_loc.x < size.x*0.5) && (p_loc.z > -size.y*0.5) && (p_loc.z < size.y*0.5));\n}\n\nvec4 loadAABB(int idx){\n    return texelFetch(iChannel0, ivec2(0, 30 + idx), 0);\n}\n/*\nbool shadowRaySceneIntersection( in Ray ray, in float distMin ) {\n    \n}*/\n\nbool rayTableIntersection( in Ray ray, in float distMin, in bool forShadowTest, inout SurfaceHitInfo hit, inout float nearestDist ) {\n    SurfaceHitInfo currentHit;\n    \n    //intersect table\n    float distToTable;\n    bool hit_result = rayZPlaneIntersection( ray, table.pos, table.size, forShadowTest, distToTable, currentHit );\n    if( hit_result && ( distToTable > distMin ) && ( distToTable < nearestDist ) ) {\n        if(forShadowTest){\n            return false;\n        } else {\n            hit = currentHit;\n            hit.position_ = ray.origin + ray.dir * distToTable;\n            hit.normal_   = vec3(0.0, 1.0, 0.0);\n            hit.tangent_  = vec3(1.0, 0.0, 0.0);\n            hit.mtl_id_ = SURFACE_ID_BASE+0;\n\n            nearestDist = distToTable;\n        }\n    }\n    /*\n    //intersect frame\n    float dist;\n    hit_result = rayZPlaneIntersection( ray, table.pos + vec3(table.size.x*0.5+1.0, 1.2, 0.0), vec2(2.0, table.size.y-4.0), forShadowTest, dist, currentHit );\n    if( hit_result && ( dist > distMin ) && ( dist < nearestDist ) ) {\n        if(forShadowTest){\n            return false;\n        } else {\n            hit = currentHit;\n            hit.position_ = ray.origin + ray.dir * dist;\n            //hit.normal_   = vec3(0.0, 1.0, 0.0);\n            //hit.tangent_  = vec3(1.0, 0.0, 0.0);\n            hit.mtl_id_ = SURFACE_ID_BASE+3;\n\n            nearestDist = dist;\n        }\n    }\n    \n    hit_result = rayZPlaneIntersection( ray, table.pos + vec3(-table.size.x*0.5-1.0, 1.2, 0.0), vec2(2.0, table.size.y-4.0), forShadowTest, dist, currentHit );\n    if( hit_result && ( dist > distMin ) && ( dist < nearestDist ) ) {\n        if(forShadowTest){\n            return false;\n        } else {\n            hit = currentHit;\n            hit.position_ = ray.origin + ray.dir * dist;\n            //hit.normal_   = vec3(0.0, 1.0, 0.0);\n            //hit.tangent_  = vec3(1.0, 0.0, 0.0);\n            hit.mtl_id_ = SURFACE_ID_BASE+3;\n\n            nearestDist = dist;\n        }\n    }\n    \n    hit_result = rayZPlaneIntersection( ray, table.pos + vec3(0.0, 1.2, -table.size.y*0.5-1.0), vec2(table.size.x-4.0, 2.0), forShadowTest, dist, currentHit );\n    if( hit_result && ( dist > distMin ) && ( dist < nearestDist ) ) {\n        if(forShadowTest){\n            return false;\n        } else {\n            hit = currentHit;\n            hit.position_ = ray.origin + ray.dir * dist;\n            //hit.normal_   = vec3(0.0, 1.0, 0.0);\n            //hit.tangent_  = vec3(1.0, 0.0, 0.0);\n            hit.mtl_id_ = SURFACE_ID_BASE+3;\n\n            nearestDist = dist;\n        }\n    }\n    \n    hit_result = rayZPlaneIntersection( ray, table.pos + vec3(0.0, 1.2, table.size.y*0.5+1.0), vec2(table.size.x-4.0, 2.0), forShadowTest, dist, currentHit );\n    if( hit_result && ( dist > distMin ) && ( dist < nearestDist ) ) {\n        if(forShadowTest){\n            return false;\n        } else {\n            hit = currentHit;\n            hit.position_ = ray.origin + ray.dir * dist;\n            hit.normal_   = vec3(0.0, 1.0, 0.0);\n            hit.tangent_  = vec3(1.0, 0.0, 0.0);\n            hit.mtl_id_ = SURFACE_ID_BASE+3;\n\n            nearestDist = dist;\n        }\n    }*/\n}\n\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    float t;\n    Material res_mtl;\n    SurfaceHitInfo currentHit;\n    \n    vec3 aabbmin, aabbmax;\n    float tt;\n    int ballid = -1;\n    \n    rayTableIntersection(ray, distMin, forShadowTest, hit, nearestDist);\n    \n   /* vec4 laabb = loadAABB(1);\n    vec4 raabb = loadAABB(2);\n    \n    aabbmin = vec3(laabb.x, -1.0, laabb.y) - EPSILON;\n    aabbmax = vec3(laabb.z,  1.0, laabb.w) + EPSILON;\n    bool hitl = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);\n    \n    aabbmin = vec3(raabb.x, -1.0, raabb.y) - EPSILON;\n    aabbmax = vec3(raabb.z,  1.0, raabb.w) + EPSILON;\n    bool hitr = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);\n    */\n    \n    vec4 aabb = loadAABB(0);\n    aabbmin = vec3(aabb.x, -1.0, aabb.y) - EPSILON;\n    aabbmax = vec3(aabb.z,  1.0, aabb.w) + EPSILON;\n    bool bhit = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);\n    \n    if(/*forShadowTest || hitl || hitr*/bhit){\n        //intersect balls\n        for(int i=0; i<numBalls; i++) {\n            Ball ball = loadBall(iChannel0, i);\n\n#ifdef MOTION_BLUR\n            vec3 pos = mix(ball.mtx_prev[3].xyz, ball.mtx[3].xyz, ray.time);\n#else\n            vec3 pos = ball.mtx[3].xyz;\n#endif\n            if(intersectSphere(ray, pos, t) && (t > distMin) && (t < nearestDist)) {\n                if(forShadowTest){\n                    return false;\n                } else {\n                    ballid = i;\n                    vec3 p = ray.origin + ray.dir * t;\n                    hit.normal_ = /*normalize*/(p - pos);//try to remove it's not needed\n                    hit.tangent_ = normalize(orthogonalize(hit.normal_, ball.mtx[1].xyz));\n                    hit.position_ = p;\n\n                    mat4 mtx;\n#ifdef MOTION_BLUR\n            \t\tmtx = mtxLerp2(ball.mtx_prev, ball.mtx, ray.time);\n#else\n            \t\tmtx = ball.mtx;\n#endif\n                    mat4 inv_mtx = inverse(mtx);\n\n                    vec3 p_local = toVec3( inv_mtx*vec4(p, 1.0));\n                    float rho, phi, theta;\n                    cart2sph( p_local, rho, phi, theta );\n                    hit.uv_.x = clamp((phi+PI*0.5)/PI, 0.0, 1.0);\n                    hit.uv_.y = clamp((theta+PI)/TWO_PI, 0.0, 1.0);\n                }\n\n                nearestDist = t;\n            }\n        }\n\n        if(ballid != -1) {\n            hit.mtl_id_ = SURFACE_ID_BASE + num_mtl + ballid;\n        }\n    }\n    \n    \n    //intersect light\n    bool hit_result = rayZPlaneIntersection( ray, light.pos, light.size, forShadowTest, t, currentHit );\n    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {\n        //Convert results to world space\n        currentHit.position_ = ray.origin + ray.dir * t;\n        currentHit.normal_   = vec3(0.0, -1.0, 0.0);\n        currentHit.tangent_  = vec3(-1.0, 0.0, 0.0);\n\n        nearestDist = t;\n        hit = currentHit;\n        hit.mtl_id_ = LIGHT_ID_BASE+0;\n    }\n    \n    //intersect cue\n    float distToCue;\n    Cue cue = readCue(iChannel0);\n    mat4 inv_mtx = inverse(cue.mtx);\n    Ray rayLocal;\n    rayLocal.origin = toVec3( inv_mtx*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( inv_mtx*vec4( ray.dir   , 0.0 ) );\n    \n    //float h = (cue.h * cue.r0) / (cue.r0 - cue.r1);\n    hit_result = rayConeIntersection( rayLocal, cue.r0, cue.r1, cue.h, forShadowTest, distToCue, currentHit );\n    if( hit_result && ( distToCue > distMin ) && ( distToCue < nearestDist ) ) {\n        currentHit.position_ = ray.origin + ray.dir * distToCue;\n        //currentHit.position_ = toVec3( cue.mtx*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( cue.mtx*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( cue.mtx*vec4( currentHit.tangent_ , 0.0 ) );\n        currentHit.mtl_id_ = SURFACE_ID_BASE+1;\n\n        hit = currentHit;\n        nearestDist = distToCue;\n    }\n    /*\n    //intersect chalk\n    inv_mtx = inverse(chalk.mtx);\n    rayLocal.origin = toVec3( inv_mtx*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( inv_mtx*vec4( ray.dir   , 0.0 ) );\n    \n    hit_result = rayAABBIntersection( rayLocal, -vec3(chalk.size*0.5), vec3(chalk.size*0.5), forShadowTest, t, currentHit );\n    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {\n        hit = currentHit;\n        hit.position_ = ray.origin + ray.dir * t;\n        //currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        hit.normal_   = toVec3( chalk.mtx*vec4( currentHit.normal_  , 0.0 ) );\n        hit.tangent_  = toVec3( chalk.mtx*vec4( currentHit.tangent_ , 0.0 ) );\n        hit.mtl_id_ = SURFACE_ID_BASE+2;\n\n        nearestDist = t;\n    }*/\n    \n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n/////////////////////////////////////////////////////////////////////// \nRay genRay(Camera c, in vec2 uv, float ratio, in float Xi1, in float Xi2, in float time ) {\n    Ray ray;\n    ray.time = time;\n    \n    vec2 iPlaneSize=2.*tan(0.5*c.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(uv - 0.5)*iPlaneSize;\n    \n    mat4 mtx;\n#ifdef MOTION_BLUR\n    mtx = mtxLerp2(c.mtx_prev, c.mtx, ray.time);\n#else\n    mtx = c.mtx;\n#endif\n    \n    if( c.lensSize > EPSILON ) {\n        vec2 uv = uniformPointWithinCircle( c.lensSize, rnd(), rnd() );\n        vec3 newPos = mtx[3].xyz + mtx[0].xyz*uv.x*c.lensSize + mtx[1].xyz*uv.y*c.lensSize;\n        vec3 focusPoint = mtx[3].xyz - c.focusDist*mtx[2].xyz;\n        vec3 newBack = normalize(newPos - focusPoint);\n        vec3 newRight = normalize( cross( mtx[1].xyz, newBack ) );\n        vec3 newUp = cross( newBack, newRight );\n        mat3 newRotate;\n        newRotate[0] = newRight;\n        newRotate[1] = newUp;\n        newRotate[2] = newBack;\n\n        ray.origin = newPos;\n        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    } else {\n        ray.origin = mtx[3].xyz;\n        ray.dir = toVec3(mtx*normalize(vec4(ixy.x, ixy.y, -1.0, 1.0)));\n    }\n\n\treturn ray;\n}\n\n#ifdef SPHERICAL_RECTANGLE\nstruct SphQuad {\n    vec3 o, x, y, z; // local reference system ’R’\n    float z0, z0sq; //\n    float x0, y0, y0sq; // rectangle coords in ’R’\n    float x1, y1, y1sq; //\n    float b0, b1, b0sq, k; // misc precomputed constants\n    float S; // solid angle of ’Q’\n};\n    \nvoid SphQuadInit(vec3 s,vec3 ex,vec3 ey,vec3 o, out SphQuad squad) {\n    squad.o = o;\n    float exl = length(ex), eyl = length(ey);\n    // compute local reference system ’R’\n    squad.x = ex / exl;\n    squad.y = ey / eyl;\n    squad.z = cross(squad.x, squad.y);\n    // compute rectangle coords in local reference system\n    vec3 d = s - o;\n    squad.z0 = dot(d, squad.z);\n    // flip ’z’ to make it point against ’Q’\n    if (squad.z0 > 0.) {\n    squad.z *= -1.;\n    squad.z0 *= -1.;\n    }\n    squad.z0sq = squad.z0 * squad.z0;\n    squad.x0 = dot(d, squad.x);\n    squad.y0 = dot(d, squad.y);\n    squad.x1 = squad.x0 + exl;\n    squad.y1 = squad.y0 + eyl;\n    squad.y0sq = squad.y0 * squad.y0;\n    squad.y1sq = squad.y1 * squad.y1;\n    // create vectors to four vertices\n    vec3 v00 = vec3(squad.x0, squad.y0, squad.z0);\n    vec3 v01 = vec3(squad.x0, squad.y1, squad.z0);\n    vec3 v10 = vec3(squad.x1, squad.y0, squad.z0);\n    vec3 v11 = vec3(squad.x1, squad.y1, squad.z0);\n    // compute normals to edges\n    vec3 n0 = normalize(cross(v00, v10));\n    vec3 n1 = normalize(cross(v10, v11));\n    vec3 n2 = normalize(cross(v11, v01));\n    vec3 n3 = normalize(cross(v01, v00));\n    // compute internal angles (gamma_i)\n    float g0 = acos(-dot(n0,n1));\n    float g1 = acos(-dot(n1,n2));\n    float g2 = acos(-dot(n2,n3));\n    float g3 = acos(-dot(n3,n0));\n    // compute predefined constants\n    squad.b0 = n0.z;\n    squad.b1 = n2.z;\n    squad.b0sq = squad.b0 * squad.b0;\n    squad.k = 2.*PI - g2 - g3;\n    // compute solid angle from internal angles\n    squad.S = g0 + g1 - squad.k;\n}\n\nvoid SphQuadSample(in vec3 x, SphQuad squad, float u, float v, out LightSamplingRecord sampleRec) {\n    // 1. compute ’cu’\n    float au = u * squad.S + squad.k;\n    float fu = (cos(au) * squad.b0 - squad.b1) / sin(au);\n    float cu = 1./sqrt(fu*fu + squad.b0sq) * (fu>0. ? +1. : -1.);\n    cu = clamp(cu, -1., 1.); // avoid NaNs\n    // 2. compute ’xu’\n    float xu = -(cu * squad.z0) / sqrt(1. - cu*cu);\n    xu = clamp(xu, squad.x0, squad.x1); // avoid Infs\n    // 3. compute ’yv’\n    float d = sqrt(xu*xu + squad.z0sq);\n    float h0 = squad.y0 / sqrt(d*d + squad.y0sq);\n    float h1 = squad.y1 / sqrt(d*d + squad.y1sq);\n    float hv = h0 + v * (h1-h0), hv2 = hv*hv;\n    float yv = (hv2 < 1.-EPSILON) ? (hv*d)/sqrt(1.-hv2) : squad.y1;\n    // 4. transform (xu,yv,z0) to world coords\n    \n    vec3 p = (squad.o + xu*squad.x + yv*squad.y + squad.z0*squad.z);\n    sampleRec.w = p - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    sampleRec.pdf = 1. / squad.S;\n}\n\nvec3 sampleLightSource(in vec3 x, in vec3 n, float Xi1, float Xi2, out LightSamplingRecord sampleRec) {\n    vec3 s = light.pos - vec3(1., 0., 0.) * light.size.x * 0.5 -\n        \t\t\t\t vec3(0., 0., 1.) * light.size.y * 0.5;\n    vec3 ex = vec3(light.size.x, 0., 0.);\n    vec3 ey = vec3(0., 0., light.size.y);\n    \n    SphQuad squad;\n    SphQuadInit(s, ex, ey, x, squad);\n    SphQuadSample(x, squad, Xi1, Xi2, sampleRec);\n    \n    //we don't have normal for volumetric particles\n    if(dot(n,n) < EPSILON) {\n        SphQuadSample(x, squad, Xi1,Xi2, sampleRec);\n    } else {\n        LightSamplingRecord w[CDF_SIZE];\n        float ww[CDF_SIZE];\n        const float strata = 1.0 / float(CDF_SIZE);\n        for(int i=0; i<CDF_SIZE; i++) {\n            float xi = strata*(float(i)+rnd());\n            SphQuadSample(x, squad, xi, rnd(), w[i]);\n            ww[i] = (i == 0)? 0.0 : ww[i-1];\n            ww[i] += max(0.0, dot(w[i].w, n));\n        }\n\n        float a = Xi1 * ww[CDF_SIZE-1];\n        for(int i=0; i<CDF_SIZE; i++) {\n            if(ww[i] > a) {\n                sampleRec = w[i];\n                sampleRec.pdf *= (ww[i] - ((i == 0)? 0.0 : ww[i-1])) / ww[CDF_SIZE-1];\n                sampleRec.pdf *= float(CDF_SIZE);\n                break;\n            }\n        }\n    }\n    \n\treturn getRadiance(vec2(Xi1,Xi2));\n}\n\nfloat sampleLightSourcePdf(in vec3 x, vec3 ns, in vec3 wi, float d, float cosAtLight) {\n    vec3 s = light.pos - vec3(1., 0., 0.) * light.size.x * 0.5 -\n        \t\t\t\t vec3(0., 0., 1.) * light.size.y * 0.5;\n    vec3 ex = vec3(light.size.x, 0., 0.);\n    vec3 ey = vec3(0., 0., light.size.y);\n    \n    SphQuad squad;\n    SphQuadInit(s, ex, ey, x, squad);\n    return 1. / squad.S;\n}\n#else\nvec3 sampleLightSource(in vec3 x, vec3 ns, float Xi1, float Xi2, out LightSamplingRecord sampleRec) {\n    vec3 p_global = light.pos + vec3(1., 0., 0.) * light.size.x * (Xi1 - 0.5) +\n        \t\t\t\t\t\tvec3(0., 0., 1.) * light.size.y * (Xi2 - 0.5);\n    vec3 n_global = vec3(0.0, -1.0, 0.0);\n    sampleRec.w = p_global - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    float cosAtLight = dot(n_global, -sampleRec.w);\n    vec3 L = cosAtLight>0.0?getRadiance(vec2(Xi1,Xi2)):vec3(0.0);\n    sampleRec.pdf = PdfAtoW(1.0 / (light.size.x*light.size.y), sampleRec.d*sampleRec.d, cosAtLight);\n    \n\treturn L;\n}\n\nfloat sampleLightSourcePdf(in vec3 x, vec3 ns, in vec3 wi, float d, float cosAtLight) {\n    return PdfAtoW(1.0 / (light.size.x*light.size.y), d*d, cosAtLight);\n}\n#endif\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.mtl_id_ >= LIGHT_ID_BASE );\n}\n\nvoid fixMtl(inout Material mtl, vec2 uv, out vec3 ns) {\n    uv *= mtl.tex_scale_;\n    if(mtl.diffuse_color_tex_!=-1){\n        mtl.diffuse_color_ = getColor(uv, mtl.diffuse_color_tex_);\n    }\n    \n    if(mtl.specular_roughness_tex_!=-1){\n        mtl.specular_roughness_ = (1.0 - sqrt(getColor(uv, mtl.specular_roughness_tex_).x));\n    } else {\n        mtl.specular_roughness_ = sqrt(mtl.specular_roughness_);\n    }\n    \n    if(mtl.specular_weight_tex_!=-1){\n        mtl.specular_weight_ = (getColor(uv, mtl.specular_weight_tex_).x);\n    }\n    if(mtl.normal_map_!=-1){\n        ns = getNormal(uv, mtl.normal_map_ );\n    } else {\n        ns = vec3(0.0, 0.0, 1.0);\n    }\n}\n\nvec3 sampleBSDF(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                \tin vec3 wi,\n                \tin float time,\n                  \tin Material mtl,\n                \tout vec3 wo,\n                \tout float brdfPdfW,\n                \tout vec3 fr,\n                \tout bool hitRes,\n                \tout SurfaceHitInfo hit) {\n    vec3 Lo = vec3(0.0);\n    float Xi1 = rnd();\n    float Xi2 = rnd();\n    fr = mtlSample(mtl, ng, ns, wi, Xi1, Xi2, wo, brdfPdfW);\n\n    //fr = eval(mtl, ng, ns, wi, wo);\n\n    float dotNWo = dot(wo, ns);\n    //Continue if sampled direction is under surface\n    if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {\n        Ray shadowRay = Ray(x + ng*EPSILON, wo, time);\n\n        //abstractLight* pLight = 0;\n        float cosAtLight = 1.0;\n        float distanceToLight = -1.0;\n        vec3 Li = vec3(0.0);\n\n        float distToHit;\n\n        if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {\n            if(hit.mtl_id_>=LIGHT_ID_BASE) {\n                distanceToLight = distToHit;\n                cosAtLight = dot(hit.normal_, -wo);\n                if(cosAtLight > 0.0) {\n                    Li = getRadiance(hit.uv_);\n                    //Li = lights[0].color_*lights[0].intensity_;\n                }\n            } else {\n                hitRes = true;\n            }\n        } else {\n            hitRes = false;\n            //TODO check for infinite lights\n        }\n\n        if (distanceToLight>0.0) {\n            if (cosAtLight > 0.0) {\n                Lo += ((Li * fr * dotNWo) / brdfPdfW) * misWeight(brdfPdfW, sampleLightSourcePdf(x, ns, wi, distanceToLight, cosAtLight));\n            }\n        }\n    }\n\n    return Lo;\n}\n\nvec3 salmpleLight(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                  \tin vec3 wi,\n                  in float time,\n                  \tin Material mtl) {\n    vec3 Lo = vec3(0.0);\t//outgoing radiance\n\tconst float strata = 1.0 / float(SURFACE_DIRECT_LIGHT_SAMPLES);\n    for(int i=0; i<SURFACE_DIRECT_LIGHT_SAMPLES; i++){\n        LightSamplingRecord rec;\n        float xi = strata*(float(i)+rnd());\n        vec3 Li = sampleLightSource( x, ns, xi, rnd(), rec );\n\n        float dotNWo = dot(rec.w, ns);\n        if ((dotNWo > 0.0) && (rec.pdf > EPSILON)) {\n            vec3 fr = mtlEval(mtl, ng, ns, wi, rec.w);\n            if(dot(fr,fr)>0.0) {\n                Ray shadowRay = Ray(x + ng*EPSILON, rec.w, time);\n                if (isLightVisible( shadowRay )) {\n                    Lo += ((Li * fr * dotNWo) / rec.pdf) * misWeight(rec.pdf, mtlPdf(mtl, ng, ns, wi, rec.w));\n                }\n            }\n        }\n    }\n\n    return Lo / float(SURFACE_DIRECT_LIGHT_SAMPLES);\n}\n\nvec3 salmpleLightForParticle(in vec3 x, in float time) {\n    vec3 Lo = vec3(0.0);\t//outgoing radiance\n\n    LightSamplingRecord rec;\n    vec3 Li = sampleLightSource( x, vec3(0.0), rnd(), rnd(), rec );\n\n    float dotNWo = rec.w.y;\n    if (dotNWo > 0.02 && rec.pdf > EPSILON) {\n        float fr = VOLUME_SCAATTERING / (4.0 * PI);\n        float phasePdf = 1.0 / (2.0 * PI);\n        \n        bool v = true;\n#ifdef VOLUMETRIC_SHADOWS\n        Ray shadowRay = Ray(x, rec.w, time);\n        v = isLightVisible( shadowRay );\n#endif\n        Lo += ((Li * fr * float(v)) / rec.pdf) * misWeight(rec.pdf, phasePdf);\n    }\n\n    return Lo;\n}\n\n\n//tacken from sjb\nvoid sampleEquiAngular(\n\tRay ray,\n\tfloat maxDistance,\n\tfloat Xi,\n\tvec3 lightPos,\n\tout float dist,\n\tout float pdf)\n{\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(lightPos - ray.origin, ray.dir);\n\t\n\t// get distance this point is from light\n\tfloat D = length(ray.origin + delta*ray.dir - lightPos);\n\n\t// get angle of endpoints\n\tfloat thetaA = atan(0.0 - delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\t\n\t// take sample\n\tfloat t = D*tan(mix(thetaA, thetaB, Xi));\n\tdist = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n//*****************************************************************************\n\nvec3 DirectLightOnVolume(in Ray ray, in float len) {\n    const float strata = 1.0/float(VOLUME_DIRECT_LIGHT_SAMPLES);\n    vec3 volumeDirectLight = vec3(0.);\n    for(int i=0; i<VOLUME_DIRECT_LIGHT_SAMPLES; i++) {\n        float particleDist;\n        float particlePdf;\n        //avoid sampling other side of the light\n        float maxt = -(ray.origin.y - light.pos.y) / ray.dir.y;//doesn't work :(\n        len = (ray.dir.y > 0.0) ? min(maxt, len) : len;\n        float xi = strata*(float(i)+rnd());\n        \n        sampleEquiAngular( ray, len, xi, light.pos, particleDist, particlePdf );\n        vec3 particlePos = ray.origin + particleDist*ray.dir;\n        volumeDirectLight += salmpleLightForParticle(particlePos, ray.time) / particlePdf;\n        //volumeDirectLight += samplePhaseForParticle(particlePos, ray.time) / particlePdf;\n    }\n    return volumeDirectLight / float(VOLUME_DIRECT_LIGHT_SAMPLES);\n}\n\nvec3 Radiance(in Ray r) {\n    vec3 Lo = vec3(0.0), fr, directLight, pathWeight = vec3(1.0, 1.0, 1.0);\n    vec3 wo;\n    float woPdf;\n    float dotWoN;\n    bool hitResult;\n    \n    //Calculate first intersections to determine first scattering event\n    Ray ray = r;\n    SurfaceHitInfo event;\n    SurfaceHitInfo nextEvent;\n    float dist = 1000.0;\n    if(!raySceneIntersection( ray, 0.0, false, event, dist )) {\n        //return Lo;\n        dist = 1000.0;\n    } else {\n        //We have to add emmision component on first hit\n        if( event.mtl_id_ >= LIGHT_ID_BASE ) {\n            //Light light = getLight(event.mtl_id_ - LIGHT_ID_BASE);\n            float cosAtLight = dot(event.normal_, -ray.dir);\n            if(cosAtLight > 0.0) {\n                Lo = getRadiance(event.uv_);\n            }\n        }\n    }\n    \n    float prev_spec;\n\n    for (int i = 0; i < MAX_DEPTH; i++) {\n        if(VOLUME_SCAATTERING!=0.0) {\n        \tLo += DirectLightOnVolume(ray, dist)*pathWeight;\n        }\n        \n        \n        if(dist > 999.0 || event.mtl_id_>=LIGHT_ID_BASE){\n        \tbreak;\n    \t}\n        vec3 x = event.position_;\n        vec3 wi = -ray.dir;\n        event.normal_ = -faceforward(event.normal_, wi, event.normal_);\n        \n        Material mtl = getMaterial(event.mtl_id_);\n    \tvec3 ng = event.normal_, ns;\n       \n    \tfixMtl(mtl, event.uv_, ns);\n    \n        mat3 frame;\n        frame[0] = event.tangent_;\n        frame[1] = cross( ng, event.tangent_ );\n        frame[2] = ng;\n        ns = frame*ns;\n      \n        if (dot(wi,ns) < 0.0) { break; }\n        \n        //Calculate direct light with 'Light sampling' and 'BSDF sampling' techniques\n        //In addition BSDF sampling does next event estimation and returns all necessary values which corresponds to next event\n       \tdirectLight  = salmpleLight (x, ng, ns, wi, ray.time, mtl);\n        directLight += sampleBSDF   (x, ng, ns, wi, ray.time, mtl, wo, woPdf, fr, hitResult, nextEvent);\n        \n   \n        Lo += directLight*pathWeight;\n\n        if (!hitResult || (dotWoN = dot(event.normal_, wo))<0.0) { break; }\n        if (woPdf == 0.0) { break; }\n        pathWeight *= fr*dotWoN / woPdf;\n\n        //Update values for next iteration\n        dist = length(nextEvent.position_ - event.position_);\n        ray = Ray(event.position_, wo, r.time);\n        event = nextEvent;\n    }\n\n    return vec3(Lo);\n}\n\nvec3 ClampColor(in vec3 c, in float maxVal) { return min(c, vec3(maxVal)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    vec2 renderingResolution = min(iResolution.xy, vec2(float(RENDERING_RES_X), float(RENDERING_RES_Y)));\n\n    vec2 pixelCoord = fragCoord.xy;\n    if(fragCoord.x > renderingResolution.x ||\n       fragCoord.y > renderingResolution.y) {\n        //fragColor = vec4( 0.0 );\n        discard;\n    } else {\n        //float fov = radians(30.0);//mix( radians(17.0), radians(7.0), pow(clamp(float(iFrame - 120) / 100.0, 0.0, 1.0),2.0));\n        Camera camera = readCamera(iChannel0);\n\n        initScene();\n\n        float dist_min = 1000.0;\n        float ratio = renderingResolution.x/renderingResolution.y;\n        float var = 0.0;\n        vec3 accumulatedColor = vec3( 0.0 );\n        float tStrata = 1.0/float(PIXEL_SAMPLES);\n        for( int si=0; si<PIXEL_SAMPLES; ++si ){\n            vec2 jitter = vec2(rnd(), rnd());\n            vec2 screen_uv = (pixelCoord.xy + jitter) / renderingResolution;//iResolution.xy;\n            Ray ray = genRay( camera, screen_uv, ratio, /*tStrata*(float(si)+rnd())*/rnd(), rnd(), tStrata*(float(si)+rnd()) );\n            vec3 rad = Radiance(ray);\n            rad = ClampColor(rad, CLAMP_VALUE);\n            float la = length(accumulatedColor);\n            if(si > 0) { var += abs(length(rad) - la) / (la == 0.0? 1.0 : la);}\n            accumulatedColor += rad;\n        }\n\n        //devide to sample count\n        accumulatedColor /= float(PIXEL_SAMPLES);\n        var /= float(PIXEL_SAMPLES);\n\n        fragColor = vec4( accumulatedColor, var );\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}