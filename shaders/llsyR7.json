{
    "Shader": {
        "info": {
            "date": "1504183337",
            "description": "mouse.xy moves the middle Control Vectors, and a 180deg rotated one.\nIs \nmin(DistanceToquadraticBezierA,DistanceToquadraticBezierB)\nequal to solving a cubic root?\nif (that is true) an nth root is solvable by solving for distances to [n cubic Bezier]s.",
            "flags": 0,
            "hasliked": 0,
            "id": "llsyR7",
            "likes": 8,
            "name": "solved nth root?",
            "published": 3,
            "tags": [
                "bezier",
                "intersection",
                "spline",
                "cubic",
                "euclidean",
                "root",
                "bisymmetry",
                "qudratic",
                "solving"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1315
        },
        "renderpass": [
            {
                "code": "//2d Euclidean Bezier spline is root solving\n//self       : https://www.shadertoy.com/view/llsyR7\n//grandparent: https://www.shadertoy.com/view/MtscRM\n//parent     : https://www.shadertoy.com/view/4ddXRH\n// - Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n// - - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// - - Inspired by http://www.pouet.net/topic.php?which=9119\n// - - ... and various shaders by iq, T21, and demofox\n//\n//Uses [Lib.Frame.7] 2017-09 extending: https://www.shadertoy.com/view/4tfcz4\n//\"Bisymmetry\"= shorthand for \"gradient from symmetry to assymmetry\", explained below:\n\n/* end__.Attributes\n   start.Head\n*/\n\n/*\nYou can analytically solve for n-roots over n-domains relatively easily (proof later)\nThe number of domains is the number of dimensions that a function/surface/line has.\n- linear, quadratic, cubic, hypercubic\nA \"root\" is a point where f(xyzw)=.0; this is root-solving a function.\n- Highest exponent of a function == Upper limit of number of roots.\n- Highest exponent is described with the same namespaces;\n- - linear, quadratic, cubic, hypercubic\nA \"root\" equates to \"where does f(x) intersect with a line\"\n- For simplicity, f(x) is rotaed/transformed so that the line is y=0;\n- The tricky part (for opengl) is to store an array of roots\n- - For simplicity, assume we tested that a root exist or just know it):\n- - - this is done by testing where your function WOULD BE undefined:\n- - - - check if any divisor==0.;\n- - - - check if log(a) has an a<=0;\n- - - - check if pow(a,b) has any a==.0 AND B==.0 //\n- - - - check if pow(a,b) has any a<0. AND  0.<abs(b)<1. (still doable with complex numbers)\n- - - - ... + anything else where your axiomes are incomplete or inconsistent (or both)\n- - - the problem os assuming that a root exists where there is none is that your function is not defined there.\n- 2 non parallel coplanar lines have 1 root\n- a line and a non-tangential circle/ellipse/parabola/QuadraticFunction\n- .... has 2 roots.  it has 1 root if it is tangential.\n- ...\n- This shader solves roots for a QuadraticFunction==bezier.\n- beziers can be extended smoothly, when the normals at the fused ends are the same.\n- fusing 2 quadratic functions makes a cubic function.\n-...\n- [bezier][n] can have all its roots solved, by splitting it into multiple quadratic bezier][0], and solving a cubic function?\n- - distance to quadratic bezier is cubic, because length(a)==sqrt(dot(a,a)) adds one root.\n- - getting shortest euclidean distance to a (planar) [cubic bezier] equals cubic root solving.\n- if (BezierA and BezierB share one start/end controlVector, with identical normal)\n- - distanceto.BezierA returns one root of a cubic function?\n- - distanceto.BezierB returns one root of a cubic function?\n-         if (BezierA and BezierB share one start/end controlVector, with identical normal)\n- ... and if (BezierB and BezierC share one start/end controlVector, with identical normal)\n- -  distanceto.BezierA returns one     root of a quadratic function?\n- - distanceto.BezierB returns one     root of a quadratic function?\n- - distanceto.BezierB returns one     root of a quadratic function?\n\n... We just calculate the smallest absolute root of all roots.\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//planar zoom.\n#define ViewZoom 3.\n//sub-pixel blur\n#define fsaa 14./min(iResolution.x,iResolution.y)\n//View Frame\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n/* End__.Parameters\n   Start.Lib.Frame.7\n*/\n\n//index starts at 0!\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u5(a) (a*.5+.5)\n#define u2(a) (a*2.-1.)\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}//max of vector\n#define miv(a) -mav(-a)\n//triangle wave //euclidean grid\n#define tri(a) a=abs(u2(fract(a))\n#define grid(a) mav(tri(a))\n//clamp().special clamp.general; //clamp().pseudo.inverse\n#define sat(a) clamp(a,0.,1.)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//stretch; mirror_centric, most common, atomic\n#define stretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretchMinus; positive values do not change; stretchPlus; negatives do not change.\n#define stretchM(u,m) stretch((u*2.+m),m)*.5\n#define stretchP(u,m) stretch((u*2.-m),m)*.5\n#define dd(a) dot(a,a)\n//perpendicular ==90deg rotation, relevant for distance to line\nv1 perp(v1 a){return v1(-a.y,a.x);}\n//return [perpendicular dot product], relevant for distance to line\nv0 dotp(v1 a,v1 b){return dot(perp(a),b);}\n//return distance of [u] from segment, from [a] to [b]\nv0 dSegment(v1 p,v1 a,v1 b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n//---trigonometry, rotations and (distance to) Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a) vec2(cos(a),sin(a))\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes because; phi.xy-1.=1/phi.xy\nconst v1 phi=v1(sqrt(5.)*.5)+v1(-.5,.5);\n//a not too work save plotter for quadratic functions.\nv1 evalQuad(v1 t,v1 A,v1 B,v1 C){A=(1.-t)*(A/B+C/A);return A*A;}\n//Solve quadratic equation for roots \nv2 SolveQuad(v2 a){float e=-a.x/3.;v0 p=a.y+a.x*e,t=p*p*p,\n q=-(2.*a.x*a.x-9.*a.y)*e/9.+a.z,d=q*q+4.*t/27.;if(d>.0){v1 x=(v1(1,-1)*sqrt(d)-q)*.5;\n return v2(suv(sign(x)*pow(abs(x),v1(1./3.)))+e);}v1 m=cs(acos(-sqrt(-27./t)*q*.5)/3.)\n  *v1(1,sqrt(3.));return v2(m.x+m.x,-suv(m),m.y-m.x)*sqrt(-p/3.)+e;}\n//return squared distance to line segment\nv0 dLine(v1 a,v1 b,v1 p){a=a-p;b-=p;p=b-a;return dd(a+p*sat(-dot(a,p)/dd(p)));}\n#define ddb(a) (dd(d+(c+b*t.a)*t.a))\n// Find the signed distance from a point to a bezier curve\nv0 dBezier(v1 p,v1 A,v1 B,v1 C){   \n //B=mix(B+v1(1e-4), B, abs(sign(B * 2.0 - A - C)));//colinear CV triviality\n v1 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p;v2 k=v2(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b),\n t=sat(SolveQuad(k));return sqrt(miv(v2(ddb(x),ddb(y),ddb(z))));}\n//---window function curve fittings.y:  https://www.shadertoy.com/view/Xtscz7\n#define bma(b,a,c) (((b)-(a))*(c)+a)\n//float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}//doesnt look too good.\n#define wLinear(x,a,b) a*(x*(b/a-1.)+1.)\n//float Cosine(float x, float a, float b){return (b-a)*(1.-cos(x*acos(-1.)))*.5 + a;}\n#define wCosine(x,a,b) (bma(b,a,(1.-cos(x*acos(-1.)))*.5)\n//float Smoothstep(0,1,x), without sat(a);\n#define wSs2(x) (x)*(x)*(3.-2.*(x))\n#define wSs(x,a,b) wSs2((x)-(a)/((b)-(a)))//this is not too useful, without sat it sucks\n//bma(b,a,x*x*(3.-2.*x))\n//lower lipschitz == less likely spheretracking overestimation.\n//most general, smoothest most excessive, most zigzag, lowest lipschitz\n#define wHermiteD(x,a,b,e,f) (b+.5*x*(e+b-a+x*(a-b+e+x*3.*(e*3.+f+x*5./3.*(-e*3.-f+x*.4*(e*3.+f))))))\n#define wHermite(x,a,b,c,d) HermiteD(x,a,b,(c-b),(a-d))\n//special case of Hermite(), with a smooth .5 average. medium zigzag\n#define wCatmullRom(x,a,b,c,d) ((((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b)\n//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n#define wCubic(x,a,b,c,d) ((((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b)\n//Cosine() is smoother than Cubic()\n//fast good monochrome distance field visualization.\nv3 rg(v3 c){v3 b=smoothstep(fsaa,-fsaa,c);\n return mix(fract(c*4.),b,.5+(atan(c))/acos(-1.));}\n//---hash\n//hash11 fast mediocre, better for mobile gpu.\nv0 h11(float p){v2 f=fract(v2(p)*.1031);f+=dot(f,f.yzx+19.19);\n return fract((f.x+f.y)*f.z);}\n\n/* End__.Lib.Frame.7\n   Start.Main\n*/\n\n#define dd(a) dot(a,a)\nvoid mainImage(out v3 O, in v1 U ){\n v1 u=fra(U);\n v1 m=mix(fra(iMouse.xy),v1(u5(cs(iTime))*vec2(1,phi.x)*2.),step(iMouse.z,.0));\n // set the bezier cubic control vectors\n const v1 A=vec2(0);\n v1 C=v1(0,1),B=2.*m-.5*(A+C);   \n vec4 c=vec4(1);//4 colors .a is yellow\n    \n //render 2* quadratic Bezier\n c.r=dBezier(u,A, B, C);//unsigned distance to                bezier curve\n c.g=dBezier(u,A,-B,-C);//unsigned distance to 180deg rotated bezier curve (lazy symmetry)\n \n c.a=min(c.r,c.g);//yellow is min() union.\n c.rg=mix(c.rg,c.aa,u5(cos(iTime*phi.y)));//mix yellow into rg, oscillating cos([0..1]) \n //c.r=min(c.r,c.g);//c.g=c.r;//monochrome alternative\n \n c-=.1;//all above Lie-spheres (Lie-beziers) have the same radius\n\n //add dots for UI illustration:\n c.a=min(length(u-m),length(u+m));\n c.a-=.05;//UI dots have a different radius.\n c.b=min(c.b,c.a);//add blue, (or white)?\n  \n //c=fract(c*4.)\n c=rg(c);//illustrate gradient with mix(fract(),smoothstep())\n O=vec4(c.xyz,1.);}\n/* End__.Main\n   Start.Bisymmetry\n*/\n\n\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/\n\n/* End__.Bisymmetry\n   Start.Dump.Memo\n*/\n\n//memo on bezier bounding volume: http://i.imgur.com/b4q3r2n.jpg\n//if a bezier is meant to define a surface, and i want to trace the BV first\n//but the *.tricky points for the BV possibly make the BV not worth calculating.\n//still worth buffering for a static object?",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}