{
    "Shader": {
        "info": {
            "date": "1710373949",
            "description": "just raymarching through a box and averaging the values we sampled along the way\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MXSXRm",
            "likes": 10,
            "name": "3D Function/Volume Visualizer",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "math",
                "volume",
                "sdf",
                "visualization",
                "map",
                "functions",
                "fields"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 215
        },
        "renderpass": [
            {
                "code": "// iChannel0 = Buffer A\n\n// min/max XYZ range for the input point\nconst vec2 domain = 3. * vec2(-1., 1.);\n\n// use a colormap (see end of Common)\nconst bool use_cmap = false;\n\n// your 3D function\nfloat volume(vec3 p)\n{\n    //return log(p.y * p.y + .05) * sin(safe_pow(p.x, p.z));\n    //return abs(sin(p.x * p.x + p.y * p.y) - p.z * p.z) < .2 ? 1. : 0.;\n    //return abs(sin(p.x * p.z - p.y) - sin(2. * p.y)) < .2 ? 1. : 0.;\n    return abs(\n        remap01(cos(p.z + 1.7 * iTime), -1., 1.)\n        * p.x * p.x + p.y * p.y\n        - sin(p.x) * p.z * p.z * sin(3. * p.z * p.z)\n    ) < .2 ? 2. : 0.;\n}\n\nvec3 tint()\n{\n    return rgb_saturate(\n        flim_rgb_sweep(iTime * .05 + .6),\n        .95\n    );\n}\n\nvec3 negative_tint()\n{\n    return .8 * rgb_saturate(\n        flim_rgb_sweep(iTime * .05 + .27),\n        .95\n    );\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // setup camera\n    \n    vec3 cam_pos_spherical = vec3(\n        /* r     */ 1.25,\n        /* theta */ PI_OVER_2,\n        /* phi   */ TAU * iTime * .08 - PI_OVER_2\n    );\n    if (iMouse.z > .1)\n    {\n        vec2 mouse_uv = screen_to_uv(iMouse.xy);\n        cam_pos_spherical.y = PI_OVER_2 + 1.5 * mouse_uv.y;\n        cam_pos_spherical.z = -PI_OVER_2 - 1.5 * mouse_uv.x;\n    }\n    vec3 cam_pos = spherical2cart(cam_pos_spherical);\n    cam_pos += vec3(0, 0, .1);\n\n    float cam_fov = 80.;\n    float cam_zoom = 90. / cam_fov;\n    \n    vec3 target_pos = vec3(0);\n    vec3 cam_forward = normalize(target_pos - cam_pos);\n    vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    vec3 cam_up = cross(cam_right, cam_forward);\n\n    // generate ray\n    Ray ray;\n    ray.orig = cam_pos;\n    ray.dir = normalize(\n        cam_forward\n        + cam_right * (uv.x / cam_zoom)\n        + cam_up * (uv.y / cam_zoom)\n    );\n    \n    // check intersection with the container box which\n    // goes from (-.5, -.5, -.5) to (.5, .5, .5)\n    Hit hit;\n    ray_aabb(vec3(-.5), vec3(.5), ray, hit);\n    \n    // shade\n    vec3 col = vec3(0);\n    if (hit.hit)\n    {\n        // constant or randomized step sizes?\n        const bool use_random_stepping = true;\n        \n        // raymarch through the box\n        if (use_random_stepping)\n        {\n            // step size range\n            float min_step = .005;\n            float max_step = .02;\n            \n            // initial t along the ray\n            float step_size = remap(random(), 0., 1., min_step, max_step);\n            float t = hit.tmin + step_size;\n            \n            // keep stepping forward until we reach hit.tmax\n            int n_samples = 0;\n            while (t < hit.tmax)\n            {\n                // point along the ray inside the volume\n                vec3 p = ray.orig + t * ray.dir;\n                \n                // step forward\n                step_size = remap(random(), 0., 1., min_step, max_step);\n                t += step_size;\n                \n                // sample the input 3D function\n                vec3 p_mapped = remap(\n                    p,\n                    -.5, .5,\n                    domain.x, domain.y\n                );\n                float v = volume(p_mapped);\n                \n                // collect sample\n                if (use_cmap)\n                {\n                    col += colormap(.3 * v);\n                }\n                else\n                {\n                    // use another tint for negative values\n                    vec3 final_tint = tint();\n                    if (v < 0.)\n                    {\n                        v = -v;\n                        final_tint = negative_tint();\n                    }\n                    \n                    col += .9 * v * final_tint;\n                }\n                n_samples++;\n            }\n            \n            // average out the samples\n            if (n_samples > 0)\n            {\n                col /= float(n_samples);\n            }\n        }\n        else\n        {\n            // number of volume samples\n            int n_samples = 20;\n            \n            // collect samples\n            for (int i = 0; i < n_samples; i++)\n            {\n                // point along the ray inside the volume\n                float t = mix(\n                    hit.tmin,\n                    hit.tmax,\n                    (float(i) + .5) / float(n_samples)\n                );\n                vec3 p = ray.orig + t * ray.dir;\n                \n                // sample the input 3D function\n                vec3 p_mapped = remap(\n                    p,\n                    -.5, .5,\n                    domain.x, domain.y\n                );\n                float v = volume(p_mapped);\n                \n                // collect sample\n                if (use_cmap)\n                {\n                    col += colormap(.3 * v);\n                }\n                else\n                {\n                    // use another tint for negative values\n                    vec3 final_tint = tint();\n                    if (v < 0.)\n                    {\n                        v = -v;\n                        final_tint = negative_tint();\n                    }\n                    \n                    col += .9 * v * final_tint;\n                }\n            }\n            \n            // average out the samples\n            col /= float(n_samples);\n        }\n        \n        // slightly brigthen the box\n        col += vec3(.01);\n    }\n    \n    // glow\n    col += tint() * 0.12 * pow(max(0.0, dot(ray.dir, normalize(-cam_pos))), 6.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n\n    // box jitter sampling\n    const int num_samples = 8;\n    vec3 col = vec3(0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        col += render(frag_coord + vec2(random() - .5, random() - .5));\n    }\n    col /= float(num_samples);\n    \n    // color grading\n    col = pow(col, vec3(1.2));\n    col += .015 * pow(tint(), vec3(6.));\n    \n    // noise\n    col += remap(random(), 0., 1., -.007, .005);\n    \n    // flim\n    col = flim_transform(col, 0.);\n    \n    // output\n    frag_col = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n\n\n\n/*-----------------------------------------------\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n-----------------------------------------------*/\n\n// parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.);\nconst float flim_pre_formation_filter_strength = 0.;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = .5;\nconst float flim_extended_gamut_green_rot = 2.;\nconst float flim_extended_gamut_blue_rot = .1;\nconst float flim_extended_gamut_red_mul = 1.;\nconst float flim_extended_gamut_green_mul = 1.;\nconst float flim_extended_gamut_blue_mul = 1.;\n\nconst float flim_sigmoid_log2_min = -10.;\nconst float flim_sigmoid_log2_max = 22.;\nconst float flim_sigmoid_toe_x = .44;\nconst float flim_sigmoid_toe_y = .28;\nconst float flim_sigmoid_shoulder_x = .591;\nconst float flim_sigmoid_shoulder_y = .779;\n\nconst float flim_negative_film_exposure = 6.;\nconst float flim_negative_film_density = 5.;\n\nconst vec3 flim_print_backlight = vec3(1);\nconst float flim_print_film_exposure = 6.;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1);\nconst float flim_post_formation_filter_strength = 0.;\nconst float flim_midtone_saturation = 1.02;\n\n//-----------------------------------------------\n\nfloat flim_wrap(float inp, float start, float end)\n{\n    return start + mod(inp - start, end - start);\n}\n\nfloat flim_remap(\n    float inp,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    return out_start\n        + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat flim_remap_clamp(\n    float inp,\n    float inp_start,\n    float inp_end,\n    float out_start,\n    float out_end\n)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0., 1.);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nfloat flim_remap01(\n    float inp,\n    float inp_start,\n    float inp_end\n)\n{\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0., 1.);\n}\n\nvec3 flim_blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.;\n        h = 0.;\n    }\n\n    if (s == 0.)\n    {\n        h = 0.;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2. + c[0] - c[2];\n        }\n        else\n        {\n            h = 4. + c[1] - c[0];\n        }\n\n        h /= 6.;\n\n        if (h < 0.)\n        {\n            h += 1.;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 flim_blender_hsv_to_rgb(vec3 hsv)\n{\n    float f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.)\n        {\n            h = 0.;\n        }\n\n        h *= 6.;\n        int i = int(floor(h));\n        f = h - float(i);\n        rgb = vec3(f, f, f);\n        p = v * (1. - s);\n        q = v * (1. - (s * f));\n        t = v * (1. - (s * (1. - f)));\n\n        if (i == 0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 flim_blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = flim_blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + .5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n\n    return flim_blender_hsv_to_rgb(hsv);\n}\n\nfloat flim_rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.;\n}\n\nfloat flim_rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat flim_rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat flim_rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 flim_rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = flim_rgb_avg(inp);\n    float mono2 = flim_remap01(\n        mono, black_point / 1000.,\n        1. - (white_point / 1000.)\n    );\n    return inp * (mono2 / mono);\n}\n\nvec3 flim_rgb_sweep(float hue)\n{\n    hue = flim_wrap(hue * 360., 0., 360.);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), flim_remap01(hue, 0., 60.));\n    col = mix(col, vec3(0, 1, 0), flim_remap01(hue, 60., 120.));\n    col = mix(col, vec3(0, 1, 1), flim_remap01(hue, 120., 180.));\n    col = mix(col, vec3(0, 0, 1), flim_remap01(hue, 180., 240.));\n    col = mix(col, vec3(1, 0, 1), flim_remap01(hue, 240., 300.));\n    col = mix(col, vec3(1, 0, 0), flim_remap01(hue, 300., 360.));\n    \n    return col;\n}\n\nvec3 flim_rgb_exposure_sweep_test(vec2 uv0to1)\n{\n    float hue = 1. - uv0to1.y;\n    float exposure = flim_remap(uv0to1.x, 0., 1., -5., 10.);\n    return flim_rgb_sweep(hue) * pow(2., exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(\n    float inp,\n    float toe_x,\n    float toe_y,\n    float shoulder_x,\n    float shoulder_y\n)\n{\n    // clip\n    inp = clamp(inp, 0., 1.);\n    toe_x = clamp(toe_x, 0., 1.);\n    toe_y = clamp(toe_y, 0., 1.);\n    shoulder_x = clamp(shoulder_x, 0., 1.);\n    shoulder_y = clamp(shoulder_y, 0., 1.);\n\n    // calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // shoulder\n    float shoulder_pow =\n        -slope / (\n            ((shoulder_x - 1.) / pow(1. - shoulder_x, 2.))\n            * (1. - shoulder_y)\n        );\n    return\n        (1. - pow(1. - (inp - shoulder_x) / (1. - shoulder_x), shoulder_pow))\n        * (1. - shoulder_y)\n        + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2., flim_sigmoid_log2_min);\n    float fac = flim_remap01(\n        log2(mono + offset),\n        flim_sigmoid_log2_min,\n        flim_sigmoid_log2_max\n    );\n\n    // calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(\n        fac,\n        flim_sigmoid_toe_x,\n        flim_sigmoid_toe_y,\n        flim_sigmoid_shoulder_x,\n        flim_sigmoid_shoulder_y\n    );\n\n    // calculate dye density\n    fac *= max_density;\n\n    // mix factor\n    fac = pow(2., -fac);\n\n    // clip and return\n    return clamp(fac, 0., 1.);\n}\n\nvec3 flim_rgb_color_layer(\n    vec3 inp,\n    vec3 sensitivity_tone,\n    vec3 dye_tone,\n    float max_density\n)\n{\n    // normalize\n    vec3 sensitivity_tone_norm =\n        sensitivity_tone / flim_rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / flim_rgb_max(dye_tone);\n\n    // dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mix_fac = flim_dye_mix_factor(mono, max_density);\n\n    // dye mixing\n    return mix(dye_tone_norm, vec3(1), mix_fac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // exposure\n    inp *= pow(2., exposure);\n\n    // blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(\n        inp,\n        vec3(0, 0, 1),\n        vec3(1, 1, 0),\n        max_density\n    );\n\n    // green-sensitive layer\n    result *= flim_rgb_color_layer(\n        inp,\n        vec3(0, 1, 0),\n        vec3(1, 0, 1),\n        max_density\n    );\n\n    // red-sensitive layer\n    result *= flim_rgb_color_layer(\n        inp,\n        vec3(1, 0, 0),\n        vec3(0, 1, 1),\n        max_density\n    );\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(\n    float primary_hue,\n    float scale,\n    float rotate,\n    float mul\n)\n{\n    vec3 result = flim_blender_hsv_to_rgb(vec3(\n        flim_wrap(primary_hue + (rotate / 360.), 0., 1.),\n        1. / scale,\n        1.\n    ));\n    result /= flim_rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(\n        0.,\n        red_scale,\n        red_rot,\n        red_mul\n    );\n    m[1] = flim_gamut_extension_mat_row(\n        1. / 3.,\n        green_scale,\n        green_rot,\n        green_mul\n    );\n    m[2] = flim_gamut_extension_mat_row(\n        2. / 3.,\n        blue_scale,\n        blue_rot,\n        blue_mul\n    );\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // develop negative\n    inp = flim_rgb_develop(\n        inp,\n        flim_negative_film_exposure,\n        flim_negative_film_density\n    );\n\n    // backlight\n    inp *= backlight_ext;\n\n    // develop print\n    inp = flim_rgb_develop(\n        inp,\n        flim_print_film_exposure,\n        flim_print_film_density\n    );\n\n    return inp;\n}\n\n// -------------------------------\n\nvec3 flim_transform(vec3 inp, float exposure)\n{\n    // eliminate negative values\n    inp = max(inp, 0.);\n\n    // pre-Exposure\n    inp *= pow(2., flim_pre_exposure + exposure);\n\n    // clip very large values for float precision issues\n    inp = min(inp, 5000.);\n\n    // gamut extension matrix (Linear BT.709)\n    mat3 extend_mat = flim_gamut_extension_mat(\n        flim_extended_gamut_red_scale,\n        flim_extended_gamut_green_scale,\n        flim_extended_gamut_blue_scale,\n        flim_extended_gamut_red_rot,\n        flim_extended_gamut_green_rot,\n        flim_extended_gamut_blue_rot,\n        flim_extended_gamut_red_mul,\n        flim_extended_gamut_green_mul,\n        flim_extended_gamut_blue_mul\n    );\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // backlight in the extended gamut\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // upper limit in the print (highlight cap)\n    const float big = 10000000.;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // pre-formation filter\n    inp = mix(\n        inp,\n        inp * flim_pre_formation_filter,\n        flim_pre_formation_filter_strength\n    );\n\n    // convert to the extended gamut\n    inp *= extend_mat;\n\n    // negative & print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // convert from the extended gamut\n    inp *= extend_mat_inv;\n\n    // eliminate negative values\n    inp = max(inp, 0.);\n\n    // white cap\n    inp /= white_cap;\n\n    // black cap (-1 = auto)\n    if (flim_black_point == -1.)\n    {\n        vec3 black_cap = negative_and_print(vec3(0.), backlight_ext);\n        black_cap /= white_cap;\n        inp = flim_rgb_uniform_offset(\n            inp,\n            flim_rgb_avg(black_cap) * 1000.,\n            0.\n        );\n    }\n    else\n    {\n        inp = flim_rgb_uniform_offset(inp, flim_black_point, 0.);\n    }\n\n    // post-formation filter\n    inp = mix(\n        inp,\n        inp * flim_post_formation_filter,\n        flim_post_formation_filter_strength\n    );\n\n    // clip\n    inp = clamp(inp, 0., 1.);\n\n    // midtone saturation\n    float mono = flim_rgb_avg(inp);\n    float mix_fac =\n        (mono < .5)\n        ? flim_remap01(mono, .05, .5)\n        : flim_remap01(mono, .95, .5);\n    inp = mix(\n        inp,\n        flim_blender_hue_sat(inp, .5, flim_midtone_saturation, 1.),\n        mix_fac\n    );\n\n    // clip\n    inp = clamp(inp, 0., 1.);\n\n    // OETF\n    inp = pow(inp, vec3(1. / 2.2));\n\n    return inp;\n}\n\n/*____________________ end ____________________*/\n\n\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    bool hit;\n    float tmin;\n    float tmax;\n};\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(const vec3 box_min, const vec3 box_max, const Ray r, out Hit hit) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    hit.tmin = t0;\n    hit.tmax = t1;\n    hit.hit = t1 > max(t0, 0.0);\n}\n\nvec3 spherical2cart(vec3 s)\n{\n    float sin_theta = sin(s.y);\n    return s.x * vec3(\n        sin_theta * cos(s.z),\n        sin_theta * sin(s.z),\n        cos(s.y)\n    );\n}\n\n// https://www.desmos.com/calculator/n4mfhffj1n\nfloat f_cmap(float x, float v)\n{\n    if (abs(v) < .0001) v = .0001;\n    float p = pow(2., v);\n    return (1. - pow(p, -x)) / (1. - 1. / p);\n}\n\n// https://www.shadertoy.com/view/DdcyRf\nvec3 colormap(float x)\n{\n    //float t = .1 * iTime;\n    //float t = .75 - 1.1 * x;\n    //float t = .25 * x;\n    float t = .6 + .8 * x;\n    \n    // https://www.desmos.com/calculator/sdqk904uu9\n    vec3 tone = 10. * vec3(\n        cos(6.283 * t),\n        cos(6.283 * (t - .3333)),\n        cos(6.283 * (t - .6667))\n    );\n    \n    x = smoothstep(-.04, 1., x);\n    vec3 c = vec3(\n        f_cmap(x, tone.r),\n        f_cmap(x, tone.g),\n        f_cmap(x, tone.b)\n    );\n    \n    return c;\n}\n\nfloat safe_pow(float a, float b)\n{\n    if (abs(a) < .00001)\n        return a;\n    if (a < 0.)\n        return pow(-a, b);\n    return pow(a, b);\n}\n\nvec3 rgb_saturate(vec3 c, float sat)\n{\n    return mix(vec3(dot(c, vec3(.3, .58, .12))), c, sat);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}