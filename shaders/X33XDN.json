{
    "Shader": {
        "info": {
            "date": "1719435553",
            "description": "See the first comment for tutorial and description.\nSee the first comment for tutorial and description.\nSee the first comment for tutorial and description.\nSee the first comment for tutorial and description.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "X33XDN",
            "likes": 22,
            "name": "DLS + Wire Cross + Clock + Rot",
            "published": 3,
            "tags": [
                "2d",
                "binary",
                "simulation",
                "digital",
                "wires",
                "ui",
                "physics",
                "gui",
                "chip",
                "logic",
                "turing",
                "sim",
                "wire",
                "gates",
                "complete",
                "dls",
                "voltage"
            ],
            "usePreview": 1,
            "username": "beans_please",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "// the image tab finally takes the wire state info from the\n// simulation buffer and displays them with different colors.\n// it also shows a panel at the top left showing the available\n// draw modes with their icons, and highlighting the selected\n// one. it also shows a circle outline around the cursor when\n// the mouse button is down and draw mode is set to erase.\n// it iterates through the gate buffer and renders the logic\n// gates.\n\n#if SHADERTOY\n// iChannel3 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SIM_BUF iChannel0\n#define ICHANNEL_GATE_BUF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid dls_fetch(\n    ivec2 icoord,\n    out int wire_state,\n    out int last_updated\n)\n{\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(iResolution.xy)\n    ))\n    {\n        wire_state = WIRE_STATE_NOT_WIRE;\n        last_updated = -1;\n        return;\n    }\n    \n    vec4 data = texelFetch(ICHANNEL_SIM_BUF, icoord, 0);\n    dls_decode(data, wire_state, last_updated);\n}\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out int rotation,\n    out int clock_interval,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_GATE_BUF, icoord, 0);\n    gate_buf_decode(\n        data,\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n}\n\nvec3 render_gate(\n    vec3 col,\n    int gate_type,\n    int clock_interval,\n    vec2 block_uv,\n    float block_uv_1px\n)\n{\n    if (gate_type == GATE_TYPE_AND)\n    {\n        if (point_inside_and_gate(block_uv))\n        {\n            col = COL_AND_GATE;\n        }\n        \n        float sd = sd_and_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_OR)\n    {\n        if (point_inside_or_gate(block_uv))\n        {\n            col = COL_OR_GATE;\n        }\n        \n        float sd = sd_or_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_XOR)\n    {\n        if (point_inside_xor_gate(block_uv))\n        {\n            col = COL_XOR_GATE;\n        }\n        \n        float sd = sd_xor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NOT)\n    {\n        if (point_inside_not_gate(block_uv))\n        {\n            col = COL_NOT_GATE;\n        }\n        \n        float sd = sd_not_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NAND)\n    {\n        if (point_inside_nand_gate(block_uv))\n        {\n            col = COL_NAND_GATE;\n        }\n        \n        float sd = sd_nand_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_NOR)\n    {\n        if (point_inside_nor_gate(block_uv))\n        {\n            col = COL_NOR_GATE;\n        }\n        \n        float sd = sd_nor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_XNOR)\n    {\n        if (point_inside_xnor_gate(block_uv))\n        {\n            col = COL_XNOR_GATE;\n        }\n        \n        float sd = sd_xnor_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_SWITCH)\n    {\n        if (point_inside_switch_gate(block_uv))\n        {\n            col = COL_SWITCH_GATE;\n        }\n        \n        float sd = sd_switch_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_CLOCK)\n    {\n        if (point_inside_clock_gate(block_uv))\n        {\n            col = COL_CLOCK_GATE;\n        }\n        \n        float sd = sd_clock_gate(block_uv, clock_interval);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (gate_type == GATE_TYPE_CROSS)\n    {\n        float sd = sd_cross_gate(block_uv);\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    return col;\n}\n\nvec3 render_gates(\n    vec3 col,\n    vec2 coord\n)\n{\n    ivec2 icoord = ivec2(coord);\n    for (int i = 0; i < N_GATES; i++)\n    {\n        int gate_type;\n        int gate_rotation;\n        int clock_interval;\n        ivec2 gate_icoord_bl;\n        gate_fetch(i, gate_type, gate_rotation, clock_interval, gate_icoord_bl);\n\n        if (gate_type == GATE_TYPE_NONE)\n        {\n            continue;\n        }\n        \n        ivec2 gate_icoord_tr = gate_icoord_bl + GATE_SIZE_PX;\n        if (any(lessThan(icoord, gate_icoord_bl))\n            || any(greaterThanEqual(icoord, gate_icoord_tr)))\n        {\n            continue;\n        }\n        \n        vec2 block_uv_norot = clamp(\n            (coord - vec2(gate_icoord_bl) - .5) / float(GATE_SIZE_PX),\n            0.,\n            1.\n        );\n        vec2 block_uv = rotate_block_uv(block_uv_norot, gate_rotation);\n        float block_uv_1px = 1. / float(GATE_SIZE_PX);\n        \n        col = render_gate(\n            col,\n            gate_type,\n            clock_interval,\n            block_uv,\n            block_uv_1px\n        );\n    }\n    return col;\n}\n\nvec3 render_eraser_size_indicator(\n    vec3 col,\n    vec2 coord,\n    int draw_mode\n)\n{\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    if (iMouse.z < .5 || draw_mode != DRAW_MODE_ERASE || mouse_in_toolbar)\n    {\n        return col;\n    }\n    \n    float eraser_thick = eraser_thickness_px(is_key_down(Key_Shift));\n\n    float d = distance(coord, iMouse.xy);\n    float sd = max(\n        -(d - eraser_thick),\n        d - eraser_thick - 3.\n    );\n    col = mix(\n        col,\n        vec3(.7),\n        remap01(sd, .4, -.4)\n    );\n    return col;\n}\n\nvec3 render_draw_mode_block(\n    vec3 col,\n    int block_idx,\n    vec2 block_uv,\n    float block_uv_1px\n)\n{\n    if (block_idx == DRAW_MODE_WIRE)\n    {\n        float sd = sd_oriented_box(block_uv, vec2(.38), vec2(.7), .15);\n        sd = min(\n            sd,\n            sd_oriented_box(block_uv, vec2(.3), vec2(.6), .07)\n        );\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_ERASE)\n    {\n        float sd = sd_oriented_box(block_uv, vec2(.45), vec2(.68), .24);\n        sd = min(\n            sd,\n            max(\n                sd_oriented_box(block_uv, vec2(.32), vec2(.6), .24),\n                -sd_oriented_box(block_uv, vec2(.35), vec2(.6), .15)\n            )\n        );\n        \n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_WIRE_LOW)\n    {\n        float sd = distance(block_uv, vec2(.5)) - .24;\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n        \n        sd = distance(block_uv, vec2(.5)) - .18;\n        col = mix(\n            col,\n            vec3(.68, .05, .02),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_WIRE_HIGH)\n    {\n        float sd = distance(block_uv, vec2(.5)) - .24;\n        col = mix(\n            col,\n            vec3(.7),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n        \n        sd = distance(block_uv, vec2(.5)) - .18;\n        col = mix(\n            col,\n            vec3(.02, .45, .01),\n            remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n        );\n    }\n    else if (block_idx == DRAW_MODE_GATE_AND)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_AND, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_OR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_OR, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_XOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_XOR, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NOT)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NOT, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NAND)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NAND, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_NOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_NOR, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_XNOR)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_XNOR, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_SWITCH)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_SWITCH, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_CLOCK)\n    {\n        block_uv = remap(block_uv, .08, .92, 0., 1.);\n        col = render_gate(col, GATE_TYPE_CLOCK, 0, block_uv, block_uv_1px);\n    }\n    else if (block_idx == DRAW_MODE_GATE_CROSS)\n    {\n        col = render_gate(col, GATE_TYPE_CROSS, 0, block_uv, block_uv_1px);\n    }\n    \n    return col;\n}\n\nvec3 render_draw_mode_toolbar(\n    vec3 col,\n    vec2 coord,\n    int draw_mode\n)\n{\n    vec2 toolbar_uv = dls_toolbar_uv(coord, iResolution.xy);\n    \n    if (!point_inside_dls_toolbar(toolbar_uv, iResolution.xy))\n    {\n        return col;\n    }\n    \n    int block_idx = dls_toolbar_block_idx(toolbar_uv);\n    vec2 block_uv = dls_toolbar_block_uv(toolbar_uv, iResolution.xy);\n    float block_uv_1px = (1. / iResolution.x) / TOOLBAR_BLOCK_SIZE;\n\n    // highlight selected\n    if (block_idx == draw_mode)\n    {\n        col = mix(col, vec3(.3), .4);\n    }\n    else\n    {\n        col = mix(col, vec3(.1), .4);\n    }\n\n    // draw mode icon\n    col = render_draw_mode_block(\n        col,\n        block_idx,\n        block_uv,\n        block_uv_1px\n    );\n    \n    // separator line\n    float sd = 1e9;\n    if (block_idx > 0)\n    {\n        sd = min(sd, abs(block_uv.x - 0.) - .008);\n    }\n    if (block_idx < (N_TOOLBAR_BLOCKS - 1))\n    {\n        sd = min(sd, abs(block_uv.x - 1.) - .008);\n    }\n    col = mix(\n        col,\n        vec3(.03),\n        remap01(sd, .4 * block_uv_1px, -.4 * block_uv_1px)\n    );\n    \n    return col;\n}\n\nvec3 view_transform(vec3 col)\n{\n    col = max(col, 0.);\n    col = pow(col, vec3(1. / 2.2));\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n\n    // current pixel's values from the DLS buffer\n    int wire_state;\n    int last_updated;\n    dls_fetch(icoord, wire_state, last_updated);\n    \n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    int iter;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse,\n        iter\n    );\n\n    // wires and background\n    vec3 col = vec3(0);\n    if (wire_state == WIRE_STATE_NOT_WIRE)\n    {\n        col = COL_BACKGROUND;\n    }\n    else if (wire_state == WIRE_STATE_DISCONNECTED)\n    {\n        col = COL_WIRE_DISCONNECTED;\n    }\n    else if (wire_state == WIRE_STATE_LOW)\n    {\n        col = COL_WIRE_LOW;\n    }\n    else if (wire_state == WIRE_STATE_HIGH)\n    {\n        col = COL_WIRE_HIGH;\n    }\n    \n    // gates\n    col = render_gates(col, frag_coord);\n    \n    // eraser size indicator\n    col = render_eraser_size_indicator(\n        col,\n        frag_coord,\n        draw_mode\n    );\n    \n    // draw mode toolbar\n    col = render_draw_mode_toolbar(\n        col,\n        frag_coord,\n        draw_mode\n    );\n\n    // output\n    col = view_transform(col);\n    frag_col = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SHADERTOY 1\n\nprecision highp float;\nprecision highp int;\n\n\n\n/*_________________ math utils ________________*/\n\nconst float PI = 3.141592653589793238462643383;\nconst float TAU = 6.283185307179586476925286767;\nconst float PI_OVER_2 = 1.570796326794896619231321692;\nconst float INV_PI = .318309886183790671537767527;\nconst float INV_TAU = .159154943091895335768883763;\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t * (b - a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T v, float start, float end) \\\n{ \\\n    return start + mod(v - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T v, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start \\\n        + ((out_end - out_start) / (inp_end - inp_start)) * (v - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp( \\\n    T v, \\\n    float inp_start, \\\n    float inp_end, \\\n    float out_start, \\\n    float out_end \\\n) \\\n{ \\\n    T t = clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T v, float inp_start, float inp_end) \\\n{ \\\n    return clamp((v - inp_start) / (inp_end - inp_start), 0., 1.); \\\n}\n\n#define FUNC_LENGTH_SQ(T) \\\nfloat length_sq(T v) \\\n{ \\\n    return dot(v, v); \\\n}\n\n#define FUNC_DIST_SQ(T) \\\nfloat dist_sq(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LENGTH_SQ(vec2)\nFUNC_LENGTH_SQ(vec3)\nFUNC_LENGTH_SQ(vec4)\n\nFUNC_DIST_SQ(vec2)\nFUNC_DIST_SQ(vec3)\nFUNC_DIST_SQ(vec4)\n\nfloat chebyshev_dist(vec2 a, vec2 b)\n{\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nfloat chebyshev_dist(vec3 a, vec3 b)\n{\n    return max(\n        max(abs(a.x - b.x), abs(a.y - b.y)),\n        abs(a.z - b.z)\n    );\n}\n\nfloat chebyshev_dist(vec4 a, vec4 b)\n{\n    return max(\n        max(\n            max(abs(a.x - b.x), abs(a.y - b.y)),\n            abs(a.z - b.z)\n        ),\n        abs(a.w - b.w)\n    );\n}\n\n#define idiv_ceil(a, b) ((a + b - 1) / b)\n\nint iabs(int v)\n{\n    if (v < 0)\n    {\n        return -v;\n    }\n    return v;\n}\n\nint imin(int a, int b)\n{\n    if (a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint imax(int a, int b)\n{\n    if (a > b)\n    {\n        return a;\n    }\n    return b;\n}\n\nint iclamp(int v, int start, int end)\n{\n    if (v < start)\n    {\n        v = start;\n    }\n    if (v > end)\n    {\n        v = end;\n    }\n    return v;\n}\n\nfloat min_component(vec2 v)\n{\n    return min(v.x, v.y);\n}\n\nfloat min_component(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat min_component(vec4 v)\n{\n    return min(min(min(v.x, v.y), v.z), v.w);\n}\n\nfloat max_component(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nfloat max_component(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat max_component(vec4 v)\n{\n    return max(max(max(v.x, v.y), v.z), v.w);\n}\n\nint min_component(ivec2 v)\n{\n    return imin(v.x, v.y);\n}\n\nint min_component(ivec3 v)\n{\n    return imin(imin(v.x, v.y), v.z);\n}\n\nint min_component(ivec4 v)\n{\n    return imin(imin(imin(v.x, v.y), v.z), v.w);\n}\n\nint max_component(ivec2 v)\n{\n    return imax(v.x, v.y);\n}\n\nint max_component(ivec3 v)\n{\n    return imax(imax(v.x, v.y), v.z);\n}\n\nint max_component(ivec4 v)\n{\n    return imax(imax(imax(v.x, v.y), v.z), v.w);\n}\n\n// credits to AHSEN (https://www.shadertoy.com/user/01000001)\n// https://www.desmos.com/calculator/5d6ph151vi interactive :D\nfloat bicubic(float a, float b, float c, float d, float t)\n{\n    float one = t - 1.;\n    float two = t - 2.;\n    float three = t - 3.;\n    return (\n        (-one * two * three * a)\n        + (t * one * two * d)\n        + (3. * t * two * three * b)\n        - (3. * t * one * three * c)\n    ) / 6.;\n}\n\n// |a| * |b| * sin(theta)\nfloat cross2d(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// references for barycentric coordinates\n// https://www.desmos.com/calculator/8g8xjejuox\n// https://www.shadertoy.com/view/mdjBWK\n\nvec3 cartesian_to_barycentric(\n    vec2 p,\n    vec2 v0,\n    vec2 v1,\n    vec2 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        cross2d(v1 - p, v2 - p),\n        cross2d(v2 - p, v0 - p),\n        cross2d(v0 - p, v1 - p)\n    ) / cross2d(v1 - v0, v2 - v0);\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nvec3 cartesian_to_barycentric(\n    vec3 p,\n    vec3 v0,\n    vec3 v1,\n    vec3 v2,\n    bool clamp_,\n    out bool p_is_outside\n)\n{\n    vec3 b = vec3(\n        length(cross(v1 - p, v2 - p)),\n        length(cross(v2 - p, v0 - p)),\n        length(cross(v0 - p, v1 - p))\n    ) / length(cross(v1 - v0, v2 - v0));\n    p_is_outside = min(min(b.x, b.y), b.z) < 0.;\n    if (clamp_)\n    {\n        b = max(b, 0.);\n        b /= (b.x + b.y + b.z);\n    }\n    return b;\n}\n\nfloat barycentric_interpolate(vec3 b, float v0, float v1, float v2)\n{\n    return dot(b, vec3(v0, v1, v2));\n}\n\nvec2 barycentric_interpolate(vec3 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec3 barycentric_interpolate(vec3 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nvec4 barycentric_interpolate(vec3 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return b.x * v0 + b.y * v1 + b.z * v2;\n}\n\nfloat barycentric_interpolate(vec2 b, float v0, float v1, float v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec2 barycentric_interpolate(vec2 b, vec2 v0, vec2 v1, vec2 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec3 barycentric_interpolate(vec2 b, vec3 v0, vec3 v1, vec3 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\nvec4 barycentric_interpolate(vec2 b, vec4 v0, vec4 v1, vec4 v2)\n{\n    return barycentric_interpolate(\n        vec3(b.x, b.y, 1. - b.x - b.y),\n        v0, v1, v2\n    );\n}\n\n// angle from 0 to TAU\nfloat get_angle(vec2 p)\n{\n    float a = atan(p.y, p.x);\n    if (a < 0.)\n    {\n        return a + TAU;\n    }\n    return a;\n}\n\nmat2 rotate_2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec3 spherical_to_cartesian(vec2 s)\n{\n    float sin_theta = sin(s.x);\n    return vec3(\n        sin_theta * cos(s.y),\n        sin_theta * sin(s.y),\n        cos(s.x)\n    );\n}\n\nvec2 screen_to_uv01(vec2 coord, vec2 res)\n{\n    return coord / res;\n}\n\nvec2 screen_to_uv_horizontal(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.x;\n}\n\nvec2 screen_to_uv_vertical(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / res.y;\n}\n\nvec2 screen_to_uv_fit(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / min_component(res);\n}\n\nvec2 screen_to_uv_fill(vec2 coord, vec2 res)\n{\n    return (2. * coord - res) / max_component(res);\n}\n\n// for some reason we can't use intBitsToFloat() or floatBitsToInt() to store\n// integers below this value in a buffer.\nconst int BUFFER_MIN_INTEGER = 8388608;\n\n// * x must not be higher than 4,286,578,688 (see BUFFER_MIN_INTEGER above)\n// * for your sanity, don't use negative values\nfloat encode_int_for_buffer(int v)\n{\n    return intBitsToFloat(v + BUFFER_MIN_INTEGER);\n}\n\nint decode_int_from_buffer(float v)\n{\n    return floatBitsToInt(v) - BUFFER_MIN_INTEGER;\n}\n\n// pack two 16-bit integers in a single 32-bit integer\n// * both arguments should be in the 0-65535 range\n// * a must be less than 65279 (see the functions above)\nint pack_i16(int a, int b)\n{\n    return (a << 16) | b;\n}\n\n// unpack two 16-bit integers from a single 32-bit integer\nvoid unpack_i16(int v, out int a, out int b)\n{\n    a = (v >> 16) & 65535;\n    b = v & 65535;\n}\n\n// unpack the first 16-bit integer from a 32-bit integer\nint unpack_i16_a(int v)\n{\n    return (v >> 16) & 65535;\n}\n\n// unpack the second 16-bit integer from a 32-bit integer\nint unpack_i16_b(int v)\n{\n    return v & 65535;\n}\n\nbool icoord_in_bounds(ivec2 icoord, ivec2 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y;\n}\n\nbool icoord_in_bounds(ivec3 icoord, ivec3 ires)\n{\n    return\n        icoord.x >= 0 &&\n        icoord.y >= 0 &&\n        icoord.z >= 0 &&\n        icoord.x < ires.x &&\n        icoord.y < ires.y &&\n        icoord.z < ires.z;\n}\n\nint icoord_to_idx(ivec2 icoord, ivec2 ires)\n{\n    return icoord.x + (icoord.y * ires.x);\n}\n\nint icoord_to_idx(ivec3 icoord, ivec3 ires)\n{\n    return icoord.x + (icoord.y * ires.x) + (icoord.z * ires.x * ires.y);\n}\n\nivec2 idx_to_icoord(int idx, ivec2 ires)\n{\n    return ivec2(idx % ires.x, idx / ires.x);\n}\n\nivec3 idx_to_icoord(int idx, ivec3 ires)\n{\n    return ivec3(\n        idx % ires.x,\n        (idx % (ires.x * ires.y)) / ires.x,\n        idx / (ires.x * ires.y)\n    );\n}\n\n/*__________________ keyboard _________________*/\n\n// put this code in every buffer that uses the keyboard input:\n/*\n#if SHADERTOY\n// iChannelX must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannelX\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n*/\n\n#if SHADERTOY\n\n#define define_keyboard_utils \\\n \\\n/* https://github.com/stevensona/shader-toy/blob/c4833b972649d78a2ee090af60b79a3907e8e091/src/extensions/keyboard/keyboard_shader_extension.ts#L11 */ \\\nconst int \\\n    Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, \\\n    Key_Ctrl = 17, Key_Alt = 18, Key_Pause = 19, Key_Caps = 20, \\\n    Key_Escape = 27, Key_PageUp = 33, Key_PageDown = 34, Key_End = 35, \\\n    Key_Home = 36, Key_LeftArrow = 37, Key_UpArrow = 38, Key_RightArrow = 39, \\\n    Key_DownArrow = 40, Key_Insert = 45, Key_Delete = 46, Key_0 = 48, \\\n    Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52, Key_5 = 53, Key_6 = 54, \\\n    Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, Key_C = 67, \\\n    Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72, \\\n    Key_I = 73, Key_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, \\\n    Key_O = 79, Key_P = 80, Key_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, \\\n    Key_U = 85, Key_V = 86, Key_W = 87, Key_X = 88, Key_Y = 89, Key_Z = 90, \\\n    Key_LeftWindow = 91, Key_RightWindows = 92, Key_Select = 93, \\\n    Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99, \\\n    Key_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, \\\n    Key_Numpad7 = 103, Key_Numpad8 = 104, Key_Numpad9 = 105, \\\n    Key_NumpadMultiply = 106, Key_NumpadAdd = 107, Key_NumpadSubtract = 109, \\\n    Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112, \\\n    Key_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, \\\n    Key_F7 = 118, Key_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, \\\n    Key_F12 = 123, Key_NumLock = 144, Key_ScrollLock = 145, \\\n    Key_SemiColon = 186, Key_Equal = 187, Key_Comma = 188, Key_Dash = 189, \\\n    Key_Period = 190, Key_ForwardSlash = 191, Key_GraveAccent = 192, \\\n    Key_OpenBracket = 219, Key_BackSlash = 220, Key_CloseBraket = 221, \\\n    Key_SingleQuote = 222; \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 1), 0).x > .5; \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 0), 0).x > .5; \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return texelFetch(SHADERTOY_KEYBOARD_CH, ivec2(key, 2), 0).x > .5; \\\n}\n\n#else\n\n#define define_keyboard_utils \\\n \\\nconst int Key_Space = 32; \\\n \\\nbool is_key_pressed(int key) \\\n{ \\\n    return isKeyPressed(key); \\\n} \\\n \\\nbool is_key_down(int key) \\\n{ \\\n    return isKeyDown(key); \\\n} \\\n \\\nbool is_key_toggled(int key) \\\n{ \\\n    return isKeyToggled(key); \\\n}\n\n#endif\n\n\n\n/*___________________ SDF _____________________*/\n\n// most but not all of these are from the following article\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sd_segment_2sided(vec2 p, vec2 a, vec2 b)\n{\n    vec2 tangent_unnorm = b - a;\n    float tangent_len = length(tangent_unnorm);\n    vec2 tangent = tangent_unnorm / tangent_len;\n    \n    float u = dot(p - a, tangent);\n    if (u < 0. || u > tangent_len)\n    {\n        return min(distance(p, a), distance(p, b));\n    }\n    else\n    {\n        vec2 normal = vec2(-tangent.y, tangent.x);\n        return dot(p - a, normal);\n    }\n}\n\nfloat sd_ring(vec2 p, vec2 n, float r, float thickness)\n{\n    p.x = abs(p.x);\n    \n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n\n    return max( abs(length(p)-r)-thickness*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-thickness*0.5)))*sign(p.x) );\n}\n\nfloat sd_oriented_box(vec2 p, vec2 a, vec2 b, float thickness)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,thickness)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sd_parabola(vec2 pos, float width, float height)\n{\n    pos.x = abs(pos.x);\n\n    float ik = width*width/height;\n    float p = ik*(height-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) // 1 root\n    {\n        float r = sqrt(h);\n        x = pow(q+r,1.0/3.0) + pow(abs(q-r),1.0/3.0)*sign(p);\n    }\n    else        // 3 roots\n    {\n        float r = sqrt(p);\n        x = 2.0*r*cos(acos(q/(p*r))/3.0); // see https://www.shadertoy.com/view/WltSD7 for an implementation of cos(acos(x)/3) without trigonometrics\n    }\n    \n    x = min(x,width);\n    \n    return length(pos-vec2(x,height-x*x/ik)) * \n           sign(ik*(pos.y-height)+pos.x*pos.x);\n}\n\nfloat sd_bezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = length_sq(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( length_sq(d+(c+b*t.x)*t.x),\n                   length_sq(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt(res);\n}\n\n#define DEFINE_SD_POLYGON(n_sides) \\\nfloat sd_polygon(vec2 p, vec2[n_sides] v) \\\n{ \\\n    float d = dot(p-v[0],p-v[0]); \\\n    float s = 1.0; \\\n    for( int i=0, j=n_sides-1; i<n_sides; j=i, i++ ) \\\n    { \\\n        vec2 e = v[j] - v[i]; \\\n        vec2 w =    p - v[i]; \\\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 ); \\\n        d = min( d, dot(b,b) ); \\\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x); \\\n        if( all(c) || all(not(c)) ) s*=-1.0;   \\\n    } \\\n    return s*sqrt(d); \\\n}\n\n\n\n/*___________ bezier sdf approx. ______________*/\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, float t)\n{\n    return mix(\n        mix(a, b, t),\n        mix(b, c, t),\n        t\n    );\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    return mix(\n        mix(\n            mix(a, b, t),\n            mix(b, c, t),\n            t\n        ),\n        mix(\n            mix(b, c, t),\n            mix(c, d, t),\n            t\n        ),\n        t\n    );\n}\n\nconst int BEZIER_RES = 6;\n\nfloat sd_bezier_approx(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    float sd = 1e9;\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        sd = min(sd, sd_segment(\n            p,\n            bezier(a, b, c, float(i) / float(BEZIER_RES)),\n            bezier(a, b, c, float(i + 1) / float(BEZIER_RES))\n        ));\n    }\n    return sd;\n}\n\nfloat sd_bezier_approx(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    float sd = 1e9;\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        sd = min(sd, sd_segment(\n            p,\n            bezier(a, b, c, d, float(i) / float(BEZIER_RES)),\n            bezier(a, b, c, d, float(i + 1) / float(BEZIER_RES))\n        ));\n    }\n    return sd;\n}\n\n\n\n/*______________ DLS constants ________________*/\n\nconst int WIRE_STATE_NOT_WIRE = 0;\nconst int WIRE_STATE_DISCONNECTED = 1;\nconst int WIRE_STATE_LOW = 2;\nconst int WIRE_STATE_HIGH = 3;\n\nconst int DRAW_MODE_WIRE = 0;\nconst int DRAW_MODE_ERASE = 1;\nconst int DRAW_MODE_WIRE_LOW = 2;\nconst int DRAW_MODE_WIRE_HIGH = 3;\nconst int DRAW_MODE_GATE_AND = 4;\nconst int DRAW_MODE_GATE_OR = 5;\nconst int DRAW_MODE_GATE_XOR = 6;\nconst int DRAW_MODE_GATE_NOT = 7;\nconst int DRAW_MODE_GATE_NAND = 8;\nconst int DRAW_MODE_GATE_NOR = 9;\nconst int DRAW_MODE_GATE_XNOR = 10;\nconst int DRAW_MODE_GATE_SWITCH = 11;\nconst int DRAW_MODE_GATE_CLOCK = 12;\nconst int DRAW_MODE_GATE_CROSS = 13;\nconst int N_DRAW_MODES = 14;\n\nconst float TOOLBAR_BLOCK_SIZE = .05;\nconst int N_TOOLBAR_BLOCKS = N_DRAW_MODES;\n\nconst float BRUSH_THICKNESS_NORMAL_PX = 4.3;\nconst float BRUSH_THICKNESS_SMALL_PX = 3.;\n\nconst float ERASER_THICKNESS_NORMAL_PX = 26.;\nconst float ERASER_THICKNESS_SMALL_PX = 6.;\n\nfloat brush_thickness_px(bool small)\n{\n    return small ? BRUSH_THICKNESS_SMALL_PX : BRUSH_THICKNESS_NORMAL_PX;\n}\n\nfloat eraser_thickness_px(bool small)\n{\n    return small ? ERASER_THICKNESS_SMALL_PX : ERASER_THICKNESS_NORMAL_PX;\n}\n\nconst vec3 COL_BACKGROUND = vec3(.024, .036, .062);\nconst vec3 COL_WIRE_DISCONNECTED = vec3(.013, .013, .024);\nconst vec3 COL_WIRE_LOW = vec3(.680, .074, .028);\nconst vec3 COL_WIRE_HIGH = vec3(.074, .659, .032);\nconst vec3 COL_AND_GATE = vec3(.12, .101, .06);\nconst vec3 COL_OR_GATE = vec3(.077, .12, .06);\nconst vec3 COL_XOR_GATE = vec3(.107, .06, .12);\nconst vec3 COL_NOT_GATE = vec3(.12, .06, .075);\nconst vec3 COL_NAND_GATE = vec3(.06, .12, .066);\nconst vec3 COL_NOR_GATE = vec3(.06, .07, .13);\nconst vec3 COL_XNOR_GATE = vec3(.06, .12, .112);\nconst vec3 COL_SWITCH_GATE = vec3(.08, .05, .13);\nconst vec3 COL_CLOCK_GATE = vec3(.04, .07, .14);\n\nconst float GATE_ICON_THICKNESS = .02;\nconst int GATE_SIZE_PX = 80;\n\n// amount of empty space at the top & bottom,\n// this is there because gates are basically\n// considered squares but the actual shapes\n// are more elongated, so to make the\n// intersection tests more accurate, we account\n// for the vertical empty space at the top and\n// bottom of the gates. intersection tests are\n// used to avoid spawning a gate on top of\n// another one.\n// since the gate SDFs have 20% vertical margins\n// we'll use the same ratio here.\nconst int GATE_VERT_PADDING = int(.2 * float(GATE_SIZE_PX));\n\nconst int GATE_TYPE_NONE = 0;\nconst int GATE_TYPE_AND = 1;\nconst int GATE_TYPE_OR = 2;\nconst int GATE_TYPE_XOR = 3;\nconst int GATE_TYPE_NOT = 4;\nconst int GATE_TYPE_NAND = 5;\nconst int GATE_TYPE_NOR = 6;\nconst int GATE_TYPE_XNOR = 7;\nconst int GATE_TYPE_SWITCH = 8;\nconst int GATE_TYPE_CLOCK = 9;\nconst int GATE_TYPE_CROSS = 10;\n\nconst int GATE_ROT_NONE = 0;\nconst int GATE_ROT_90CW = 1;\nconst int GATE_ROT_180CW = 2;\nconst int GATE_ROT_270CW = 3;\nconst int N_GATE_ROT = 4;\n\nconst int N_CLOCK_INTERV = 5;\nconst int CLOCK_INTERV[N_CLOCK_INTERV] = int[](\n    128,\n    64,\n    32,\n    8,\n    4\n);\n\n// size of the block of pixels at the bottom left corner of\n// the gate buffer to represent gates. this determines the\n// maximum number of gates that can be there at a time.\nconst ivec2 GATE_BUF_SIZE = ivec2(10, 5);\nconst int N_GATES = GATE_BUF_SIZE.x * GATE_BUF_SIZE.y;\n\n\n\n/*_________ DLS buffer data encoding __________*/\n\nvec4 dls_encode(int wire_state, int last_updated)\n{\n    wire_state = iclamp(wire_state, 0, 3);\n    return vec4(\n        encode_int_for_buffer((last_updated << 2) | wire_state),\n        0, 0, 0\n    );\n}\n\nvoid dls_decode(\n    vec4 data,\n    out int wire_state,\n    out int last_updated\n)\n{\n    int packed = decode_int_from_buffer(data.x);\n    wire_state = packed & 3;\n    last_updated = packed >> 2;\n}\n\nvec4 gate_buf_encode(\n    int gate_type,\n    int rotation,\n    int clock_interval,\n    ivec2 icoord_bl\n)\n{\n    return vec4(\n        encode_int_for_buffer((gate_type << 16) | rotation),\n        encode_int_for_buffer(clock_interval),\n        encode_int_for_buffer((icoord_bl.x << 16) | icoord_bl.y),\n        0\n    );\n}\n\nvoid gate_buf_decode(\n    vec4 data,\n    out int gate_type,\n    out int rotation,\n    out int clock_interval,\n    out ivec2 icoord_bl\n)\n{\n    int packed = decode_int_from_buffer(data.x);\n    gate_type = packed >> 16;\n    rotation = packed & ((1 << 16) - 1);\n    \n    clock_interval = decode_int_from_buffer(data.y);\n    \n    packed = decode_int_from_buffer(data.z);\n    icoord_bl = ivec2(\n        packed >> 16,\n        packed & ((1 << 16) - 1)\n    );\n}\n\nvec4 data_buf_encode(\n    ivec2 res,\n    int draw_mode,\n    bool prev_mouse_down,\n    ivec2 prev_imouse,\n    int iter\n)\n{\n    int prev_mouse_down_01 = (prev_mouse_down ? 1 : 0);\n    return vec4(\n        encode_int_for_buffer((res.x << 16) | res.y),\n        encode_int_for_buffer((draw_mode << 1) | prev_mouse_down_01),\n        encode_int_for_buffer((prev_imouse.x << 16) | prev_imouse.y),\n        encode_int_for_buffer(iter)\n    );\n}\n\nvoid data_buf_decode(\n    vec4 data,\n    out ivec2 res,\n    out int draw_mode,\n    out bool prev_mouse_down,\n    out ivec2 prev_imouse,\n    out int iter\n)\n{\n    int packed = decode_int_from_buffer(data.x);\n    res = ivec2(\n        packed >> 16,\n        packed & ((1 << 16) - 1)\n    );\n    \n    packed = decode_int_from_buffer(data.y);\n    draw_mode = packed >> 1;\n    prev_mouse_down = bool(packed & 1);\n    \n    packed = decode_int_from_buffer(data.z);\n    prev_imouse = ivec2(\n        packed >> 16,\n        packed & ((1 << 16) - 1)\n    );\n    \n    iter = decode_int_from_buffer(data.w);\n}\n\n\n\n/*_________________ DLS SDFs __________________*/\n\nvec2 rotate_block_uv(vec2 uv, int rotation)\n{\n    if (rotation == GATE_ROT_90CW)\n    {\n        return vec2(1. - uv.y, uv.x);\n    }\n    if (rotation == GATE_ROT_180CW)\n    {\n        return 1. - uv;\n    }\n    if (rotation == GATE_ROT_270CW)\n    {\n        return vec2(uv.y, 1. - uv.x);\n    }\n    return uv;\n}\n\nvec2 unrotate_block_uv(vec2 uv, int rotation)\n{\n    if (rotation == GATE_ROT_90CW)\n    {\n        return vec2(uv.y, 1. - uv.x);\n    }\n    if (rotation == GATE_ROT_180CW)\n    {\n        return 1. - uv;\n    }\n    if (rotation == GATE_ROT_270CW)\n    {\n        return vec2(1. - uv.y, uv.x);\n    }\n    return uv;\n}\n\nvec2 GATE_TOP_INPUT_UV = vec2(0., .65);\nvec2 GATE_BOTTOM_INPUT_UV = vec2(0., .35);\nvec2 GATE_CENTER_INPUT_UV = vec2(0., .5); // for single-input gates\n\n#define N_SIDES_AND_GATE (4 + BEZIER_RES + BEZIER_RES - 1)\nDEFINE_SD_POLYGON(N_SIDES_AND_GATE)\n\nbool point_inside_and_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_AND_GATE];\n    p[0] = vec2(.5, .2);\n    p[1] = vec2(.2, .2);\n    p[2] = vec2(.2, .8);\n    p[3] = vec2(.5, .8);\n    for (int i = 1; i <= BEZIER_RES; i++)\n    {\n        p[3 + i] = bezier(\n            vec2(.5, .8),\n            vec2(.5 + .13, .8),\n            vec2(.75, .5 + .13),\n            vec2(.75, .5),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 1; i < BEZIER_RES; i++)\n    {\n        p[3 + BEZIER_RES + i] = bezier(\n            vec2(.75, .5),\n            vec2(.75, .5 - .13),\n            vec2(.5 + .13, .2),\n            vec2(.5, .2),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    \n    return sd_polygon(block_uv, p) < 0.;\n}\n\nbool point_inside_nand_gate(vec2 block_uv)\n{\n    return point_inside_and_gate(block_uv);\n}\n\nfloat sd_and_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_bezier_approx(\n        block_uv,\n        vec2(.5, .8),\n        vec2(.5 + .13, .8),\n        vec2(.75, .5 + .13),\n        vec2(.75, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.75, .5),\n        vec2(.75, .5 - .13),\n        vec2(.5 + .13, .2),\n        vec2(.5, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.5, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.5, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_and_gate(vec2 block_uv)\n{\n    float sd = sd_and_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n#define N_SIDES_OR_GATE (3 * BEZIER_RES)\nDEFINE_SD_POLYGON(N_SIDES_OR_GATE)\n\nbool point_inside_or_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_OR_GATE];\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[i] = bezier(\n            vec2(.2, .8),\n            vec2(.5, .8),\n            vec2(.75, .5),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[BEZIER_RES + i] = bezier(\n            vec2(.75, .5),\n            vec2(.5, .2),\n            vec2(.2, .2),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    for (int i = 0; i < BEZIER_RES; i++)\n    {\n        p[2 * BEZIER_RES + i] = bezier(\n            vec2(.2, .2),\n            vec2(.43, .5),\n            vec2(.2, .8),\n            float(i) / float(BEZIER_RES)\n        );\n    }\n    \n    return sd_polygon(block_uv, p) < 0.;\n}\n\nbool point_inside_xor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nbool point_inside_nor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nbool point_inside_xnor_gate(vec2 block_uv)\n{\n    return point_inside_or_gate(block_uv);\n}\n\nfloat sd_or_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_bezier_approx(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.5, .8),\n        vec2(.75, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.75, .5),\n        vec2(.5, .2),\n        vec2(.2, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.43, .5),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.28, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.28, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_or_gate(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_xor_gate_no_output_line(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    \n    sd = min(sd, sd_bezier_approx(\n        block_uv + vec2(.08, 0),\n        vec2(.2, .8),\n        vec2(.43, .5),\n        vec2(.2, .2)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_xor_gate(vec2 block_uv)\n{\n    float sd = sd_xor_gate_no_output_line(block_uv);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nfloat sd_gate_dot_and_output_line(vec2 block_uv)\n{\n    // dot (the dot at the end of NOT, NOR, XNOR, etc.)\n    float sd = abs(\n        distance(\n            block_uv,\n            vec2(.84, .5)\n        ) - .05\n    ) - GATE_ICON_THICKNESS;\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n#define N_SIDES_NOT_GATE 3\nDEFINE_SD_POLYGON(N_SIDES_NOT_GATE)\n\nbool point_inside_not_gate(vec2 block_uv)\n{\n    vec2 p[N_SIDES_NOT_GATE] = vec2[](\n        vec2(.2, .2),\n        vec2(.8, .5),\n        vec2(.2, .8)\n    );\n    return sd_polygon(block_uv, p) < 0.;\n}\n\nfloat sd_not_gate(vec2 block_uv)\n{\n    float sd = sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.8, .5)\n    ) - GATE_ICON_THICKNESS;\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .8),\n        vec2(.8, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.2, .2),\n        vec2(.2, .8)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_CENTER_INPUT_UV,\n        GATE_CENTER_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    \n    return sd;\n}\n\nfloat sd_nand_gate(vec2 block_uv)\n{\n    float sd = sd_and_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nfloat sd_nor_gate(vec2 block_uv)\n{\n    float sd = sd_or_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nfloat sd_xnor_gate(vec2 block_uv)\n{\n    float sd = sd_xor_gate_no_output_line(block_uv);\n    sd = min(sd, sd_gate_dot_and_output_line(block_uv));\n    return sd;\n}\n\nconst vec2 SWITCH_GATE_CIRCLE_CENTER = vec2(.46, .5);\nconst float SWITCH_GATE_CIRCLE_RADIUS = .29;\n\nbool point_inside_switch_gate(vec2 block_uv)\n{\n    return\n        dist_sq(block_uv, SWITCH_GATE_CIRCLE_CENTER)\n        < (SWITCH_GATE_CIRCLE_RADIUS * SWITCH_GATE_CIRCLE_RADIUS);\n}\n\nfloat sd_switch_gate(vec2 block_uv)\n{\n    float sd = abs(\n        distance(\n            block_uv,\n            SWITCH_GATE_CIRCLE_CENTER\n        ) - SWITCH_GATE_CIRCLE_RADIUS\n    ) - GATE_ICON_THICKNESS;\n    \n    // input line 1\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_TOP_INPUT_UV,\n        GATE_TOP_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // input line 2\n    sd = min(sd, sd_segment(\n        block_uv,\n        GATE_BOTTOM_INPUT_UV,\n        GATE_BOTTOM_INPUT_UV + vec2(.2, 0)\n    ) - GATE_ICON_THICKNESS);\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    // text\n    {\n        // S\n    \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.38, .62),\n            vec2(.3, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.3, .62),\n            vec2(.38, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.38, .38),\n            vec2(.3, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        // W\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.42, .62),\n            vec2(.42, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.42, .38),\n            vec2(.46, .5)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.46, .5),\n            vec2(.5, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.5, .38),\n            vec2(.5, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        // C\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.62, .62),\n            vec2(.54, .62)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.54, .62),\n            vec2(.54, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(.54, .38),\n            vec2(.62, .38)\n        ) - .5 * GATE_ICON_THICKNESS);\n    }\n    \n    return sd;\n}\n\nbool point_inside_clock_gate(vec2 block_uv)\n{\n    return chebyshev_dist(block_uv, vec2(.48, .5)) < .26;\n}\n\nfloat sd_clock_gate(vec2 block_uv, int clock_interval)\n{\n    float sd = abs(\n        chebyshev_dist(block_uv, vec2(.48, .5)) - .26\n    ) - GATE_ICON_THICKNESS;\n    \n    // triangle waves\n    for (int i = 0; i < clock_interval + 1; i++)\n    {\n        float left_x = mix(.22, .74, float(i) / float(clock_interval + 1));\n        float right_x = mix(.22, .74, float(i + 1) / float(clock_interval + 1));\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(mix(left_x, right_x, 0.), .5),\n            vec2(mix(left_x, right_x, .25), .66)\n        ) - .7 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(mix(left_x, right_x, .25), .66),\n            vec2(mix(left_x, right_x, .75), .34)\n        ) - .7 * GATE_ICON_THICKNESS);\n        \n        sd = min(sd, sd_segment(\n            block_uv,\n            vec2(mix(left_x, right_x, .75), .34),\n            vec2(mix(left_x, right_x, 1.), .5)\n        ) - .7 * GATE_ICON_THICKNESS);\n    }\n    \n    // output line\n    sd = min(sd, sd_segment(\n        block_uv,\n        vec2(.76, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\nconst vec2 CROSS_TOP_LEFT_INPUT_UV = vec2(.36, .64);\nconst vec2 CROSS_BOTTOM_RIGHT_INPUT_UV = vec2(.64, .36);\nconst vec2 CROSS_TOP_RIGHT_INPUT_UV = vec2(.64, .64);\nconst vec2 CROSS_BOTTOM_LEFT_INPUT_UV = vec2(.36, .36);\n\nfloat sd_cross_gate(vec2 block_uv)\n{\n    block_uv = abs(block_uv - .5) + .5;\n\n    float sd = sd_segment(\n        block_uv,\n        vec2(.5, .5),\n        vec2(.64, .64) - (.06 * .7071068)\n    ) - .7 * GATE_ICON_THICKNESS;\n    \n    sd = min(sd, abs(\n        distance(\n            block_uv,\n            vec2(.64, .64)\n        ) - .06\n    ) - .7 * GATE_ICON_THICKNESS);\n    \n    return sd;\n}\n\n// usually we use a single function like point_inside_X_gate()\n// for both rendering the gate's interior fill color and also\n// disabling the DLS simulation inside the gate. The cross\n// component doesn't have a fill color, but also its\n// \"point_inside\" function doesn't match its actual shape.\n// Instead, it's designed to disable DLS in specific areas to\n// avoid leakage.\nbool point_inside_cross_gate_for_dls(vec2 block_uv)\n{\n    float x = block_uv.x;\n    float y = block_uv.y;\n    return\n        (abs(x - .5) < ((.64 - .5) + .06) && abs(y - .5) < ((.64 - .5) - .06))\n        || (abs(y - .5) < ((.64 - .5) + .06) && abs(x - .5) < ((.64 - .5) - .06));\n}\n\nbool point_inside_gate(vec2 block_uv, int gate_type)\n{\n    if (gate_type == GATE_TYPE_AND)\n    {\n        return point_inside_and_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_OR)\n    {\n        return point_inside_or_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_XOR)\n    {\n        return point_inside_xor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NOT)\n    {\n        return point_inside_not_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NAND)\n    {\n        return point_inside_nand_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_NOR)\n    {\n        return point_inside_nor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_XNOR)\n    {\n        return point_inside_xnor_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_SWITCH)\n    {\n        return point_inside_switch_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_CLOCK)\n    {\n        return point_inside_clock_gate(block_uv);\n    }\n    else if (gate_type == GATE_TYPE_CROSS)\n    {\n        return point_inside_cross_gate_for_dls(block_uv);\n    }\n    return false;\n}\n\nbool point_inside_gate_output(vec2 block_uv)\n{\n    float sd = sd_segment(\n        block_uv,\n        vec2(.89, .5),\n        vec2(1, .5)\n    ) - GATE_ICON_THICKNESS;\n    return sd < 0.;\n}\n\n\n\n/*_______________ DLS toolbar _________________*/\n\nvec2 dls_toolbar_uv(vec2 coord, vec2 res)\n{\n    return coord / res.x;\n}\n\nbool point_inside_dls_toolbar(vec2 toolbar_uv, vec2 res)\n{\n    vec2 uv_top_left = vec2(0, res.y) / res.x;\n    return\n        toolbar_uv.x <= TOOLBAR_BLOCK_SIZE * float(N_TOOLBAR_BLOCKS)\n        && toolbar_uv.y >= (uv_top_left.y - TOOLBAR_BLOCK_SIZE);\n}\n\nint dls_toolbar_block_idx(vec2 toolbar_uv)\n{\n    return iclamp(\n        int(toolbar_uv.x / TOOLBAR_BLOCK_SIZE),\n        0,\n        N_TOOLBAR_BLOCKS - 1\n    );\n}\n\nvec2 dls_toolbar_block_uv(vec2 toolbar_uv, vec2 res)\n{\n    vec2 uv_top_left = vec2(0, res.y) / res.x;\n    return vec2(\n        mod(toolbar_uv.x, TOOLBAR_BLOCK_SIZE) / TOOLBAR_BLOCK_SIZE,\n        (toolbar_uv.y - (uv_top_left.y - TOOLBAR_BLOCK_SIZE)) / TOOLBAR_BLOCK_SIZE\n    );\n}\n\n\n\n// The following is a copy of the tutorial comment posted by the author\n// under the original shader (https://www.shadertoy.com/view/XXG3zW).\n\n/*\n[b]DON'T PANIC[/b]\nIf it says \"Compiled in 0.0 secs\" and shows a black screen, it's lying to you. The shader is still being compiled, just wait for 30-60 seconds.\n\n[b]What's this?[/b]\nThis is a digital logic simulation shader for learning and experimenting with logic gates and digital circuits like binary adders, ALUs (arithmetic logic units), and if you're really nerdy, entire basic CPUs. It simulates logic values propagating inside wires, and logic gates that read & manipulate those values at their inputs and outputs.\n[url=https://www.shadertoy.com/view/M3tXWn]See the first version.[/url]\n\n[b]Who made this?[/b]\nThis shader is written by bean ([url=https://github.com/bean-mhm]GitHub[/url]).\n\n[b]Controls[/b]\n- [i]Click[/i] to [b]select tools in the toolbar[/b]\n- [i]Hold Mouse[/i] to [b]draw/erase wires when wire brush or eraser selected[/b]\n- [i]Hold Shift[/i] to [b]use smaller brush/eraser size[/b]\n- [i]Click[/i] to [b]inject logic values / add gates[/b]\n- [i]Alt+Click[/i] [b]on a gate to rotate it[/b]\n- [i]Ctrl+Click[/i] [b]on a clock to change the interval[/b]\n- [i]Press C[/i] to [b]clear the screen[/b]\n\n[b]WARNING[/b]\nResolution changes will reset everything and cause data loss.\n\n[b]Toolbar[/b]\nClick on the icons in the toolbar to change the draw mode to one of the following, respectively.\n- Wire brush\n- Eraser\n- Inject 0 in wire\n- Inject 1 in wire\n- AND gate\n- OR gate\n- XOR gate\n- NOT gate\n- NAND gate\n- NOR gate\n- XNOR gate\n- SWITCH gate\n- Clock\n- Cross\n\n[b]How logic gates work[/b]\n\nThe following terms refer to the same thing: 0, false, low, and off. Same with 1, true, high, and on.\n\n[i]AND[/i] outputs true if both inputs are true.\n[i]OR[/i] outputs true if either input is true.\n[i]XOR[/i] outputs true if the inputs have different values.\n\n[i]NOT[/i] outputs the inverted version of the input ([i]NOT[/i] has only one input).\n\n[i]NAND[/i] outputs true if either input is false.\n[i]NOR[/i] outputs true if both inputs are false.\n[i]XNOR[/i] outputs true if the inputs have equal values.\n\n[i]SWITCH[/i] outputs the first input only if the second input is true, does nothing otherwise. It acts like a tri-state buffer.\n\n[b]Clock and Cross[/b]\nThe [i]Clock[/i] component oscillates its output with a constant frequency that can be changed by [i]Ctrl+Click[/i]ing on it.\nA [i]Cross[/i] connects the pixels at the two ends on each axis, allowing you to cross wires.\n\n[b]Gate limit[/b]\nThe maximum number of gates is 50 by default. You can increase it by changing the GATE_BUF_SIZE constant.\n*/\n\n\n\n// The following is a copy of my personal to-do list for this project\n\n/*\ndata buffer\n- new draw modes for the gates\n\nimage\n- icons for the new draw modes\n\ngate buffer\n- contains an array of logic gates\n- struct LogicGate:\n    type: int GATE_TYPE_AND\n    icoord_bottom_left: ivec2\n- [C] should clear the gates too\n- if draw mode is a gate, add it if mouse is down in this frame but wasnt in prev frame\n\nimage\n- iterate through the gate array from the gate buffer and see if we're inside\n  one, and if so, render that gate.\n- fill the interior of the gates\n\ngate buffer\n- if mouse is on a gate already, don't add anything\n- if mouse is on a gate and draw mode is erase, delete it on mouse press\n\nDLS buffer\n- don't run simulation inside a logic gate (ignore wires under gates)\n- if at the output of a logic gate, do the operation based on the inputs\n\nDLS buffer\n- only draw wires if prev_mouse_down is on, use line segments to avoid the nasty cirlce issue (use prev_imouse)\n\nmake sure all gates can be erased properly\n\ncross shouldnt be rotated\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// simulation buffer. this stores wire states and \"last updated\"\n// values.\n\n#if SHADERTOY\n// iChannel3 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SELF iChannel0\n#define ICHANNEL_GATE_BUF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid dls_fetch(\n    ivec2 icoord,\n    out int wire_state,\n    out int last_updated\n)\n{\n    if (!icoord_in_bounds(\n        icoord,\n        ivec2(iResolution.xy)\n    ))\n    {\n        wire_state = WIRE_STATE_NOT_WIRE;\n        last_updated = -1;\n        return;\n    }\n    \n    vec4 data = texelFetch(ICHANNEL_SELF, icoord, 0);\n    dls_decode(data, wire_state, last_updated);\n}\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out int rotation,\n    out int clock_interval,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_GATE_BUF, icoord, 0);\n    gate_buf_decode(\n        data,\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n}\n\nvoid take_on_neighbor_value_if_needed(\n    inout int my_wire_state,\n    inout int my_last_updated,\n    int neighbor_wire_state,\n    int neighbor_last_updated\n)\n{\n    // return if neighbor is not a wire\n    if (neighbor_wire_state == WIRE_STATE_NOT_WIRE)\n    {\n        return;\n    }\n    \n    // only care about connected neighbors\n    if (neighbor_wire_state == WIRE_STATE_DISCONNECTED)\n    {\n        return;\n    }\n    \n    // if we're disconnected\n    if (my_wire_state == WIRE_STATE_DISCONNECTED)\n    {\n        // change our values to that of the neighbor\n        my_wire_state = neighbor_wire_state;\n        my_last_updated = neighbor_last_updated;\n    }\n    \n    // or if we're connected and neighbor has a more recent value\n    if (neighbor_last_updated > my_last_updated\n        && my_wire_state != WIRE_STATE_DISCONNECTED)\n    {\n        // change our values to that of the neighbor\n        my_wire_state = neighbor_wire_state;\n        my_last_updated = neighbor_last_updated;\n    }\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    int iter;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse,\n        iter\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n\n    // set initial values and return on resolution change or\n    // the first frame, or if C is pressed\n    if (res_changed || first_frame || is_key_pressed(Key_C))\n    {\n        frag_col = dls_encode(\n            WIRE_STATE_NOT_WIRE,\n            -1\n        );\n        return;\n    }\n    \n    // see if mouse is in the toolbar\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    ivec2 icoord = ivec2(frag_coord);\n    \n    // current pixel's values\n    int wire_state;\n    int last_updated;\n    dls_fetch(icoord, wire_state, last_updated);\n    \n    // see if the current pixel is inside a logic gate\n    bool inside_gate = false;\n    for (int i = 0; i < N_GATES; i++)\n    {\n        int gate_type;\n        int gate_rotation;\n        int clock_interval;\n        ivec2 gate_icoord_bl;\n        gate_fetch(i, gate_type, gate_rotation, clock_interval, gate_icoord_bl);\n        \n        if (gate_type == GATE_TYPE_NONE)\n        {\n            continue;\n        }\n        \n        ivec2 gate_icoord_tr = gate_icoord_bl + GATE_SIZE_PX;\n        vec2 block_uv_norot =\n            (frag_coord - vec2(gate_icoord_bl) - .5) / float(GATE_SIZE_PX);\n        vec2 block_uv = rotate_block_uv(block_uv_norot, gate_rotation);\n        \n        if (gate_type == GATE_TYPE_CROSS)\n        {\n            // * we don't set inside_gate to true when we're\n            // on the inputs of a cross, because the cross\n            // acts like a teleport for wires so it\n            // shouldn't ignore the neighbors of the input\n            // pixels.\n            \n            ivec2 icoord_top_left_input = ivec2(\n                vec2(gate_icoord_bl) + .5\n                + CROSS_TOP_LEFT_INPUT_UV * float(GATE_SIZE_PX)\n            );\n            ivec2 icoord_bottom_right_input = ivec2(\n                vec2(gate_icoord_bl) + .5\n                + CROSS_BOTTOM_RIGHT_INPUT_UV * float(GATE_SIZE_PX)\n            );\n            ivec2 icoord_top_right_input = ivec2(\n                vec2(gate_icoord_bl) + .5\n                + CROSS_TOP_RIGHT_INPUT_UV * float(GATE_SIZE_PX)\n            );\n            ivec2 icoord_bottom_left_input = ivec2(\n                vec2(gate_icoord_bl) + .5\n                + CROSS_BOTTOM_LEFT_INPUT_UV * float(GATE_SIZE_PX)\n            );\n            \n            if (icoord == icoord_top_left_input)\n            {\n                // we're on the top left input of the cross, so\n                // we'll read the bottom right input and see if\n                // it has a more recent value.\n                \n                int other_inp_state;\n                int other_inp_last_updated;\n                \n                dls_fetch(\n                    icoord_bottom_right_input,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n                \n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n            }\n            else if (icoord == icoord_bottom_right_input)\n            {\n                // the rest just follows the pattern\n                \n                int other_inp_state;\n                int other_inp_last_updated;\n                \n                dls_fetch(\n                    icoord_top_left_input,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n                \n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n            }\n            else if (icoord == icoord_top_right_input)\n            {\n                int other_inp_state;\n                int other_inp_last_updated;\n                \n                dls_fetch(\n                    icoord_bottom_left_input,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n                \n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n            }\n            else if (icoord == icoord_bottom_left_input)\n            {\n                int other_inp_state;\n                int other_inp_last_updated;\n                \n                dls_fetch(\n                    icoord_top_right_input,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n                \n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    other_inp_state,\n                    other_inp_last_updated\n                );\n            }\n            else if (point_inside_gate(block_uv, gate_type))\n            {\n                // we're inside the cross itself and not on\n                // any of its inputs so we shouldn't run\n                // the simulation.\n                inside_gate = true;\n                break;\n            }\n        }\n        else if (point_inside_gate_output(block_uv))\n        {\n            // we're on the output of a gate so don't run the\n            // simulation, we'll perform the correct logic\n            // operation instead.\n            inside_gate = true;\n            \n            // read the wire states at the inputs\n            \n            vec2 input_uv_unrot = unrotate_block_uv(\n                GATE_TOP_INPUT_UV,\n                gate_rotation\n            );\n            ivec2 icoord_top_input = ivec2(\n                input_uv_unrot * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            \n            input_uv_unrot = unrotate_block_uv(\n                GATE_BOTTOM_INPUT_UV,\n                gate_rotation\n            );\n            ivec2 icoord_bottom_input = ivec2(\n                input_uv_unrot * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            \n            input_uv_unrot = unrotate_block_uv(\n                GATE_CENTER_INPUT_UV,\n                gate_rotation\n            );\n            ivec2 icoord_center_input = ivec2(\n                input_uv_unrot * float(GATE_SIZE_PX)\n                + vec2(gate_icoord_bl) + .5\n            );\n            \n            int top_inp_state;\n            int bottom_inp_state;\n            int center_inp_state;\n            int dont_care_about_last_updated;\n            \n            dls_fetch(\n                icoord_top_input,\n                top_inp_state,\n                dont_care_about_last_updated\n            );\n            dls_fetch(\n                icoord_bottom_input,\n                bottom_inp_state,\n                dont_care_about_last_updated\n            );\n            dls_fetch(\n                icoord_center_input,\n                center_inp_state,\n                dont_care_about_last_updated\n            );\n            \n            // perform logic operations\n            if (gate_type == GATE_TYPE_AND)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_OR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_XOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NOT)\n            {\n                if (center_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (center_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NAND)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_NOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_XNOR)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_SWITCH)\n            {\n                if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    // do nothing\n                }\n                else if (top_inp_state == WIRE_STATE_LOW && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_LOW;\n                    last_updated = iter;\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_LOW)\n                {\n                    // do nothing\n                }\n                else if (top_inp_state == WIRE_STATE_HIGH && bottom_inp_state == WIRE_STATE_HIGH)\n                {\n                    wire_state = WIRE_STATE_HIGH;\n                    last_updated = iter;\n                }\n            }\n            else if (gate_type == GATE_TYPE_CLOCK)\n            {\n                int interval = CLOCK_INTERV[clock_interval % N_CLOCK_INTERV];\n                wire_state =\n                    (iter % (2 * interval)) < interval\n                    ? WIRE_STATE_LOW\n                    : WIRE_STATE_HIGH;\n                last_updated = iter;\n            }\n            \n            break;\n        }\n        else if (point_inside_gate(block_uv, gate_type))\n        {\n            // we're inside a gate so don't run the simulation\n            inside_gate = true;\n            break;\n        }\n    }\n    \n    // only run the simulation for wire pixels, and not inside gates\n    if (wire_state != WIRE_STATE_NOT_WIRE && !inside_gate)\n    {\n        // check neighbors (5x5 window excluding the center)\n        for (int y_offs = -2; y_offs <= 2; y_offs++)\n        {\n            for (int x_offs = -2; x_offs <= 2; x_offs++)\n            {\n                // skip self (offset=0)\n                ivec2 offs = ivec2(x_offs, y_offs);\n                if (offs == ivec2(0))\n                {\n                    continue;\n                }\n                \n                // fetch neighbor's values\n                int neighbor_wire_state;\n                int neighbor_last_updated;\n                dls_fetch(\n                    icoord + offs,\n                    neighbor_wire_state,\n                    neighbor_last_updated\n                );\n                \n                // function name says everything\n                take_on_neighbor_value_if_needed(\n                    wire_state,\n                    last_updated,\n                    neighbor_wire_state,\n                    neighbor_last_updated\n                );\n            }\n        }\n        \n        // if mouse is down and on this pixel (and it's a wire)\n        if (iMouse.z > .5 && ivec2(iMouse.xy) == icoord && !mouse_in_toolbar)\n        {\n            // draw wire state\n            if (draw_mode == DRAW_MODE_WIRE_LOW)\n            {\n                wire_state = WIRE_STATE_LOW;\n                last_updated = iter;\n            }\n            else if (draw_mode == DRAW_MODE_WIRE_HIGH)\n            {\n                wire_state = WIRE_STATE_HIGH;\n                last_updated = iter;\n            }\n        }\n    }\n    \n    // on mouse down\n    if (iMouse.z > .5 && prev_mouse_down && !mouse_in_toolbar)\n    {\n        float line_segment_dist = sd_segment(\n            frag_coord,\n            vec2(prev_imouse) + .5,\n            iMouse.xy\n        );\n    \n        // draw wires\n        float brush_thick = brush_thickness_px(is_key_down(Key_Shift));\n        if (draw_mode == DRAW_MODE_WIRE\n            && line_segment_dist < brush_thick\n            && wire_state == WIRE_STATE_NOT_WIRE)\n        {\n            wire_state = WIRE_STATE_DISCONNECTED;\n            last_updated = -1;\n        }\n        \n        // erase wires\n        float eraser_thick = eraser_thickness_px(is_key_down(Key_Shift));\n        if (draw_mode == DRAW_MODE_ERASE\n            && line_segment_dist < eraser_thick)\n        {\n            wire_state = WIRE_STATE_NOT_WIRE;\n            last_updated = -1;\n        }\n    }\n    \n    // output the new values\n    frag_col = dls_encode(wire_state, last_updated);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// gate buffer. this stores a fixed array of logic gates. by\n// default, the elements are initialized to represent no gates,\n// but they can change based on user input.\n\n// this buffer operates in the bottom left GATE_BUF_SIZE block\n// of pixels, so it stores a fixed array of\n// (GATE_BUF_SIZE.x * GATE_BUF_SIZE.y) gates. each pixel stores\n// a gate's type and its bottom left coordinates in pixel space.\n// the simulation buffer uses this info to perform boolean\n// operations at the gate outputs, and the image tab uses this\n// buffer to render the gates.\n\n#if SHADERTOY\n// iChannel3 must be set to Keyboard in Shadertoy\n#define SHADERTOY_KEYBOARD_CH iChannel3\n#else\n#iKeyboard\n#endif\n\ndefine_keyboard_utils\n\n#define ICHANNEL_SIM_BUF iChannel0\n#define ICHANNEL_SELF iChannel1\n#define ICHANNEL_DATA_BUF iChannel2\n\nvoid gate_fetch(\n    int idx,\n    out int gate_type,\n    out int rotation,\n    out int clock_interval,\n    out ivec2 icoord_bl\n)\n{\n    if (idx < 0 || idx >= N_GATES)\n    {\n        gate_type = GATE_TYPE_NONE;\n        icoord_bl = ivec2(0);\n        return;\n    }\n    \n    ivec2 icoord = idx_to_icoord(idx, GATE_BUF_SIZE);\n    vec4 data = texelFetch(ICHANNEL_SELF, icoord, 0);\n    gate_buf_decode(\n        data,\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    \n    // only care about the bottom left block\n    if (!icoord_in_bounds(icoord, GATE_BUF_SIZE))\n    {\n        return;\n    }\n    \n    // 1D index of this pixel in the buffer\n    int my_idx = icoord_to_idx(icoord, GATE_BUF_SIZE);\n    \n    // values from the data buffer\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    int iter;\n    data_buf_decode(\n        texelFetch(ICHANNEL_DATA_BUF, ivec2(0), 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse,\n        iter\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n\n    // set initial values and return on resolution change or\n    // the first frame, or if C is pressed\n    if (res_changed || first_frame || is_key_pressed(Key_C))\n    {\n        frag_col = gate_buf_encode(\n            GATE_TYPE_NONE,\n            GATE_ROT_NONE,\n            0,\n            ivec2(0)\n        );\n        return;\n    }\n    \n    // see if mouse is in the toolbar\n    vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy); \n    bool mouse_in_toolbar = point_inside_dls_toolbar(\n        mouse_toolbar_uv,\n        iResolution.xy\n    );\n    \n    // current values\n    int gate_type;\n    int rotation;\n    int clock_interval;\n    ivec2 icoord_bl;\n    gate_buf_decode(\n        texelFetch(ICHANNEL_SELF, icoord, 0),\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n    \n    // on mouse down and in erase mode\n    if (iMouse.z > .5\n        && prev_mouse_down\n        && !mouse_in_toolbar\n        && draw_mode == DRAW_MODE_ERASE)\n    {\n        // find the index of the gate under the mouse\n        int delete_idx = -1;\n        for (int i = 0; i < N_GATES; i++)\n        {\n            int elem_gate_type;\n            int elem_rotation;\n            int elem_clock_interval;\n            ivec2 elem_icoord_bl;\n            gate_fetch(\n                i,\n                elem_gate_type,\n                elem_rotation,\n                elem_clock_interval,\n                elem_icoord_bl\n            );\n            \n            // skip empty slots\n            if (elem_gate_type == GATE_TYPE_NONE)\n            {\n                continue;\n            }\n            \n            // is the gate under the mouse?\n            ivec2 elem_icoord_tr = elem_icoord_bl + GATE_SIZE_PX;\n            ivec2 imouse = ivec2(iMouse.xy);\n            bool under_mouse = false;\n            if (all(greaterThanEqual(imouse, elem_icoord_bl))\n                && all(lessThan(imouse, elem_icoord_tr)))\n            {\n                vec2 block_uv_norot =\n                    (iMouse.xy - vec2(elem_icoord_bl) - .5) / float(GATE_SIZE_PX);\n                vec2 block_uv = rotate_block_uv(block_uv_norot, elem_rotation);\n                under_mouse = point_inside_gate(block_uv, elem_gate_type);\n            }\n\n            if (!under_mouse)\n            {\n                continue;\n            }\n            \n            // found a gate under the mouse\n            delete_idx = i;\n            break;\n        }\n        \n        // if we found a gate to delete and it's exactly this pixel\n        if (delete_idx != -1 && delete_idx == my_idx)\n        {\n            // reset this pixel to delete the gate\n            gate_type = GATE_TYPE_NONE;\n            rotation = GATE_ROT_NONE;\n            clock_interval = 0;\n            icoord_bl = ivec2(0);\n        }\n    }\n    \n    // on mouse press\n    if (iMouse.z > .5\n        && !prev_mouse_down\n        && !mouse_in_toolbar)\n    {\n        // do we need to add a gate? and what type?\n        int gate_to_add = GATE_TYPE_NONE;\n        if (draw_mode == DRAW_MODE_GATE_AND)\n        {\n            gate_to_add = GATE_TYPE_AND;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_OR)\n        {\n            gate_to_add = GATE_TYPE_OR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_XOR)\n        {\n            gate_to_add = GATE_TYPE_XOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NOT)\n        {\n            gate_to_add = GATE_TYPE_NOT;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NAND)\n        {\n            gate_to_add = GATE_TYPE_NAND;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_NOR)\n        {\n            gate_to_add = GATE_TYPE_NOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_XNOR)\n        {\n            gate_to_add = GATE_TYPE_XNOR;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_SWITCH)\n        {\n            gate_to_add = GATE_TYPE_SWITCH;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_CLOCK)\n        {\n            gate_to_add = GATE_TYPE_CLOCK;\n        }\n        else if (draw_mode == DRAW_MODE_GATE_CROSS)\n        {\n            gate_to_add = GATE_TYPE_CROSS;\n        }\n\n        // bounds of the new gate to add\n        ivec2 gate_to_add_bl = ivec2(iMouse.xy) - GATE_SIZE_PX / 2;\n        ivec2 gate_to_add_tr = gate_to_add_bl + GATE_SIZE_PX;\n        \n        // find the index of the first empty slot\n        int empty_idx = -1;\n        for (int i = 0; i < N_GATES; i++)\n        {\n            int elem_gate_type;\n            int elem_rotation;\n            int elem_clock_interval;\n            ivec2 elem_icoord_bl;\n            gate_fetch(\n                i,\n                elem_gate_type,\n                elem_rotation,\n                elem_clock_interval,\n                elem_icoord_bl\n            );\n            \n            // if slot already occupied\n            if (elem_gate_type != GATE_TYPE_NONE)\n            {\n                // does the gate in this slot intersect with the\n                // bounds of the new gate we wanna add?\n                ivec2 elem_icoord_tr = elem_icoord_bl + GATE_SIZE_PX;\n                bool intersects =\n                    elem_icoord_tr.x >= gate_to_add_bl.x\n                    && elem_icoord_bl.x <= gate_to_add_tr.x\n                    && elem_icoord_tr.y - GATE_VERT_PADDING >= gate_to_add_bl.y + GATE_VERT_PADDING\n                    && elem_icoord_bl.y + GATE_VERT_PADDING <= gate_to_add_tr.y - GATE_VERT_PADDING;\n                \n                // if so, just don't add the new gate (break the loop)\n                // actually this is a lie cuz we will replace the\n                // intersecting gate's type with the new one. keep\n                // reading.\n                if (intersects)\n                {\n                    // before we break, though, we'll rotate the gate\n                    // if the Alt key is down.\n                    // don't rotate crosses though!\n                    if (is_key_down(Key_Alt)\n                        && i == my_idx\n                        && gate_type != GATE_TYPE_CROSS\n                        && draw_mode != DRAW_MODE_ERASE)\n                    {\n                        rotation = (rotation + 1) % 4;\n                    }\n                    \n                    // if this is a clock gate, change its interval\n                    // if the Ctrl key is down.\n                    if (is_key_down(Key_Ctrl)\n                        && i == my_idx\n                        && draw_mode != DRAW_MODE_ERASE)\n                    {\n                        clock_interval = (clock_interval + 1) % N_CLOCK_INTERV;\n                    }\n                    \n                    // but wait! if we're in the pixel that represents\n                    // the intersecting gate, we'll update ourselves to\n                    // take the new type!\n                    if (i == my_idx\n                        && gate_to_add != GATE_TYPE_NONE\n                        && gate_type != gate_to_add)\n                    {\n                        gate_type = gate_to_add;\n                        clock_interval = 0;\n                    }\n                    \n                    break;\n                }\n                \n                // otherwise, skip this slot and continue looking\n                // for an empty slot\n                continue;\n            }\n            \n            // found an empty slot\n            empty_idx = i;\n            break;\n        }\n        \n        // if we found an empty slot and it's exactly this pixel,\n        // and we have a gate to add\n        if (empty_idx != -1\n            && empty_idx == my_idx\n            && gate_to_add != GATE_TYPE_NONE)\n        {\n            // update this pixel\n            gate_type = gate_to_add;\n            rotation = GATE_ROT_NONE;\n            clock_interval = 0;\n            icoord_bl = gate_to_add_bl;\n        }\n    }\n    \n    // output the new values\n    frag_col = gate_buf_encode(\n        gate_type,\n        rotation,\n        clock_interval,\n        icoord_bl\n    );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// data buffer. this stores the last frame's resolution, the\n// current draw mode, whether the mouse button was down in\n// the previous frame, and the mouse coordinates in the\n// previous frame.\n\n#define ICHANNEL_SELF iChannel0\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    ivec2 icoord = ivec2(frag_coord);\n    \n    // only care about pixel (0, 0)\n    if (icoord != ivec2(0))\n    {\n        return;\n    }\n    \n    // current values\n    ivec2 res;\n    int draw_mode;\n    bool prev_mouse_down;\n    ivec2 prev_imouse;\n    int iter;\n    data_buf_decode(\n        texelFetch(ICHANNEL_SELF, icoord, 0),\n        res,\n        draw_mode,\n        prev_mouse_down,\n        prev_imouse,\n        iter\n    );\n    \n    // resolution changed since last frame?\n    bool res_changed = imax(\n        iabs(res.x - int(iResolution.x)),\n        iabs(res.y - int(iResolution.y))\n    ) > 0;\n    \n    // set resolution to the current resolution\n    res = ivec2(iResolution.xy);\n\n    // are we in the first frame?\n    bool first_frame = (iFrame < 1) || (iTime < .02);\n    \n    // reset on resolution change or the first frame\n    if (res_changed || first_frame)\n    {\n        frag_col = data_buf_encode(\n            ivec2(iResolution.xy),\n            DRAW_MODE_WIRE,\n            iMouse.z > .5,\n            ivec2(iMouse.xy),\n            0\n        );\n        return;\n    }\n    \n    // change draw mode with mouse\n    {\n        vec2 mouse_toolbar_uv = dls_toolbar_uv(iMouse.xy, iResolution.xy);\n        \n        bool mouse_in_toolbar = point_inside_dls_toolbar(\n            mouse_toolbar_uv,\n            iResolution.xy\n        );\n        \n        if (mouse_in_toolbar && iMouse.z > .5 && !prev_mouse_down)\n        {\n            int block_idx = dls_toolbar_block_idx(mouse_toolbar_uv);\n            draw_mode = block_idx;\n        }\n    }\n    \n    // output the new values\n    frag_col = data_buf_encode(\n        ivec2(iResolution.xy),\n        draw_mode,\n        iMouse.z > .5,\n        ivec2(iMouse.xy),\n        iter + 1\n    );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}