{
    "Shader": {
        "info": {
            "date": "1568994074",
            "description": "approx cos/sin using a mix of euler and symplectic method, red = approximate, cyan = built in",
            "flags": 0,
            "hasliked": 0,
            "id": "Wst3zX",
            "likes": 7,
            "name": "approximate cosine/sine",
            "published": 3,
            "tags": [
                "number",
                "sine",
                "complex",
                "cosine",
                "generation",
                "approximate",
                "euler"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 472
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 uv = (u*2.-iResolution.xy)*1.3/iResolution.y;\n    float time = mod(iTime,6.28);\n    \n    vec2 p = vec2(1,0);\n    \n    #define PRECISION 0.03\n    #define OPTIMIZED\n    \n    //display iterations for testing optimized\n    //#define DISPLAY_ITERATIONS\n    int iterc = 0;\n        \n    //generate cosine(p.x)/sine(p.y) at time\n    #ifdef OPTIMIZED\n    int b = int(time/6.28*8.);\n    for (int i = 0; i < b; i++) p += vec2(-p.y,p.x);\n    iterc += b;\n    \n    int n = int(round((time-float(b)/8.*6.28)/PRECISION));\n    for (int i = 0; i < n; i++) {\n        p.x -= PRECISION*p.y;\n        p.y += PRECISION*p.x;\n    }\n    iterc += n;\n    \n  /*old version using euler method\n\tfloat s = .8, a = 0.;\n    while (true) {\n        s *= .5;\n        while (a < time) {\n            \n            vec2 n = normalize(p+s*vec2(-p.y,p.x));\n            a += length(p-n);\n            p = n;\n            iterc++;\n        }\n        vec2 n = normalize(p-s*vec2(-p.y,p.x));\n        a -= length(p-n);\n        p = n;\n        if (s <= PRECISION) break;\n    }*/\n    #else\n    //thanks to iq for suggesting the symplectic method https://www.shadertoy.com/view/tlBXzd\n    iterc = int(round(time/PRECISION));\n    for(int i = 0; i < iterc; i++)\n    {\n        p.x -= PRECISION*p.y;\n        p.y += PRECISION*p.x; \n    }\n    #endif\n    p = normalize(p);\n    \n    #ifdef DISPLAY_ITERATIONS\n    o = vec4(iterc)/250.;\n    return;\n    #endif\n    \n    //plot approximate(red) vs built in(cyan)\n    #define dp(r) step(length(uv-r)-.05,0.)\n    vec3 c = vec3(0);\n    c.x += dp(p);\n    c.yz += dp(vec2(cos(time),sin(time)));\n    o = vec4(c,1);\n\n    //gradual discard to fade out plot\n    if (dot(c,c) == 0. && mod(dot(floor(u)+vec2(float(iFrame),float(iFrame/2)),vec2(1)),10.) < 9.) discard;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}