{
    "Shader": {
        "info": {
            "date": "1582354017",
            "description": "A variation on an old real-time shader done with my stochastic ray tracer. There's some dead code in this one because I'm doing only ray marching, not ray tracing.",
            "flags": 32,
            "hasliked": 0,
            "id": "3tVSRh",
            "likes": 37,
            "name": "Fractured Protophore",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "stochastic"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 1001
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nThis is the latest iteration of my stochastic ray tracer.\nFor materials, it supports:\n- Proper reflection / refraction, with total internal reflection.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse / specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n- Depth of field\n\nRandom number generation and hashes were cleaned up and now feel pretty good.\n\n-Otavio Good\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec4 c=texture(iChannel0,uv);\n\tfragColor=vec4(sqrt((c.xyz*4096.0) / c.w), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nThis is the latest iteration of my stochastic ray tracer.\nFor materials, it supports:\n- Proper reflection / refraction, with total internal reflection.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse / specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n- Depth of field\n\nRandom number generation and hashes were cleaned up and now feel pretty good.\n\n-Otavio Good\n*/\n\n// --------------------------------------------------------------------------\n// 1 for fast GPUs, 0 for slow.\n#define HIGH_QUALITY 0\n// --------------------------------------------------------------------------\n\n// Number of samples per pixel - bigger takes more compute\n#define NUM_SAMPLES 1\n\n#if HIGH_QUALITY\n// Number of times the ray bounces off things before terminating\n#define NUM_ITERS 17\n// Number of times the fractal repeats\n#define RECURSION_LEVELS 5\n#else\n#define NUM_ITERS 7\n#define RECURSION_LEVELS 4\n#endif\n\n\n// ---- general helper functions / constants ----\n#define saturate(a) clamp(a, 0.0, 1.0)\n// Weird for loop trick so compiler doesn't unroll loop\n// By making the zero a variable instead of a constant, the compiler can't unroll the loop and\n// that speeds up compile times by a lot.\n#define ZERO_TRICK max(0, -iFrame)\nconst int BIG_INT = 2000000000;\nconst float PI = 3.14159265;\nconst float farPlane = 64.0;\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n// Find 2 perpendicular vectors to the input vector.\nmat3 MakeBasis(vec3 normal) {\n\tmat3 result;\n    result[0] = normal;\n    if (abs(normal.y) > 0.5) {\n        result[1] = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    } else {\n        result[1] = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    }\n    result[2] = normalize(cross(normal, result[1]));\n    return result;\n}\n\n\n// ---- Random functions use one 32 bit state var to change things up ----\n// This is the single state variable for the random number generator.\nuint randomState = 4056649889u;\n// 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n// Check with Math.fround(0xffffff) in javascript.\nconst float invMax24Bit = 1.0 / float(0xffffff);\n\n// This is the main hash function that should produce a non-repeating\n// pseudo-random sequence for 2^31 iterations.\nuint SmallHashA(in uint seed) {\n    return (seed ^ 1057926937u) * 3812423987u ^\n            ((seed*seed) * 4000000007u);\n}\n// This is an extra hash function to clean things up a little.\nuint SmallHashB(in uint seed) {\n    return (seed ^ 2156034509u) * 3699529241u;\n}\n\n// Hash the random state to get a random float ranged [0..1]\nfloat RandFloat() {\n    randomState = SmallHashA(randomState);\n    // Add these 2 lines for extra randomness. And change last line to tempState.\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return float((tempState>>8) & 0xffffffu) * invMax24Bit;\n}\n// Hash the random state to get 2 random floats ranged [0..1]\n// Reduced precision to 16 bits per component.\nvec2 RandVec2() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec2(tempState & 0xffffu,\n                (tempState >> 16) & 0xffffu) / float(0xffff);\n}\n// Hash the random state to get 3 random floats ranged [0..1]\n// Reduced precision to 10 bits per component.\nvec3 RandVec3() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec3((tempState >> 2) & 0x3ffu,\n                (tempState >> 12) & 0x3ffu,\n                (tempState >> 22) & 0x3ffu) / float(0x3ffu);\n}\n\n// Returns a random float from [0..1]\nfloat HashFloat(uint seed) {\n    seed = SmallHashA(seed);\n    return float((seed >> 8) & 0xffffffu) * invMax24Bit;\n}\nvec2 HashVec2(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec2(seed & 0xffffu,\n                (seed >> 16) & 0xffffu) / float(0xffff);\n}\nvec3 HashVec3(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec3((seed >> 2) & 0x3ffu,\n                (seed >> 12) & 0x3ffu,\n                (seed >> 22) & 0x3ffu) / float(0x3ffu);\n}\nfloat HashFloatI2(ivec2 seed) {\n    uint seedB = SmallHashA(uint(seed.x ^ (seed.y * 65537)));\n    //seedB ^= SmallHashB(uint(seed.y));\n    return float(seedB & 0xffffffu) * invMax24Bit;\n}\n\nvoid SetRandomSeed(in vec2 fragCoord, in vec2 iResolution,\n                  in int iFrame) {\n    uint primex = max(uint(iResolution.x), 5003u);  // This prime is far from any 2^x\n    randomState = uint(fragCoord.x);\n    randomState += uint(fragCoord.y) * primex;\n    randomState += uint(iFrame) * primex * uint(iResolution.y);\n    RandFloat();\n}\n\n// Returns random number sampled from a circular gaussian distribution\n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\nvec2 RandGaussianCircle() {\n    vec2 u = RandVec2();\n    u.x = max(u.x, 0.00000003); // We don't want log() to fail because it's 0.\n    float a = sqrt(-2.0 * log(u.x));\n    return vec2(a * cos(2.0*PI*u.y), a * sin(2.0 * PI * u.y));\n}\n// Randomly sample the lifetime of a ray moving through particles\n// p = prob. of collision with particle per unit distance traveled\nfloat RayLifetime(float p) {\n    if (p < 0.00000003) return farPlane;  // Lower than this and the math seems to fail.\n    float unif = RandFloat();  // uniform(0, 1)\n    // This random shouldn't be allowed to hit 0 because log() is undefined.\n    unif = max(0.00000000000001, unif);\n    // p can't be 0 because log(1) == 0 and it divides by 0. Can't be 1 because log(0) is undefined.\n    p = min(p, .999999);\n    //float g = math.floor(math.log(unif) / math.log(1 - p))  # natural logs\n    // g = number of successes before failure\n    float g = log(unif) / log(1.0 - p);\n    return g;\n}\n\nvec3 HashPointOnSphere(uint seed) {\n    vec2 uv = HashVec2(seed);\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\n\n// Random point *ON* sphere\nvec3 RandPointOnSphere() {\n    vec2 uv = RandVec2();\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\n// Random point *IN* sphere\n// This is biased!!! About 1/32 of the time, it will return a point in box instead of a sphere.\n/*vec3 RandPointInSphere() {\n    return RandPointOnSphere();\n    vec3 p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    return p;\n}*/\n\n// ---- Environment maps - a few to choose from ----\n// Make a procedural environment map with a giant softbox light and 4 lights around the sides.\nvec3 GetEnvMap3(vec3 rayDir)\n{\n    // Just some basic fades for the background\n    return vec3(rayDir.y*0.5+0.5)*1.25 + vec3(1.0,0.7,0.1)*(rayDir.z*0.5+0.5) + vec3(0.1,0.4,0.61)*(-rayDir.z*0.5+0.5)*0.5;\n\n/*    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(rayDir, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);*/\n}\n\nvec3 GetEnvMap2(vec3 rayDir) {\n    //return vec3(0.0);\n    return vec3(rayDir.y*0.5+0.5);// * vec3(1.0, 0.5, 0.7);\n}\n\n// ---- Ray intersection functions and data structures ----\nstruct Ray\n{\n    vec3 p0, dirNormalized;\n    int outside;  // 1 ray is outside, -1 ray is inside, 0 terminate ray tracing iteration\n};\nstruct SceneHit\n{\n    vec3 hitPos;\n    vec3 hitNormal;\n    float pt;  // parametric t variable - how far along the ray vector is the intersection\n    int objIndex;  // unique index per object - used for material tricks like hashing colors\n    int materialIndex;  // Which material are we using\n};\n\n// As the ray bounces, it records hits in these vars.\nstruct ColorHit {\n    vec3 diffuse;\n    vec3 emission;\n};\nColorHit colorHits[NUM_ITERS];\nint colorHitIndex;\nvoid ResetColorHitList() {\n    colorHitIndex = 0;\n    for (int i = 0; i < NUM_ITERS; i++) {\n        colorHits[i].emission.x = -1.0;\n    }\n}\nvoid SaveHit(in vec3 diffuse, in vec3 emission) {\n    colorHits[colorHitIndex] = ColorHit(diffuse, emission);\n    colorHitIndex++;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// Return value is normal in xyz, t in w.\n// outside is 1 to intersect from the outside of the sphere, -1 to intersect from inside of sphere.\nvec4 SphereIntersect3(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, int outside)\n{\n    vec4 rh = vec4(farPlane);\n    vec3 delta = spherePos - pos;\n    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);\n    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;\n    vec3 bv = proj - delta;\n    float b2 = dot(bv, bv);\n    if (b2 > rad*rad) return rh;  // Ray missed the sphere\n    float x = sqrt(rad*rad - b2);\n    rh.w = projdist - (x * float(outside));\n    vec3 hitPos = pos + dirVecPLZNormalizeMeFirst * rh.w;\n    rh.xyz = normalize(hitPos - spherePos);//*float(outside);//??HACK>>>??  // Normal still points outwards if collision from inside.\n    return rh;\n}\n\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\n// Return value is normal in xyz, t in w.\n// **** rayInv is 1.0 / direction vector ****\nvec4 BoxIntersect(vec3 pos, vec3 rayInv, vec3 boxPos, vec3 rad, int outside)\n{\n    vec3 bmin = boxPos - rad;\n    vec3 bmax = boxPos + rad;\n//    vec3 rayInv = 1.0 / dirVecPLZNormalizeMeFirst;\n\n    vec3 t1 = (bmin - pos) * rayInv;\n    vec3 t2 = (bmax - pos) * rayInv;\n\n    vec3 vmin = min(t1, t2);\n    vec3 vmax = max(t1, t2);\n\n    float tNear = max(vmin.z, max(vmin.x, vmin.y));\n    float tFar = min(vmax.z, min(vmax.x, vmax.y));\n\n    vec4 rh = vec4(0,1,0,farPlane);\n    if ((tFar < tNear)) return rh;\n    if (outside > 0) {\n        if ((tNear <= 0.0)) return rh;\n\t    rh.w = tNear;\n    } else if (outside < 0) {\n        if ((tFar <= 0.0)) return rh;\n\t    rh.w = tFar;\n    }\n\n    // optimize me!\n    if (t1.x == rh.w) rh.xyz = vec3(-1.0, 0.0, 0.0);\n    else if (t2.x == rh.w) rh.xyz = vec3(1.0, 0.0, 0.0);\n    else if (t1.y == rh.w) rh.xyz = vec3(0.0, -1.0, 0.0);\n    else if (t2.y == rh.w) rh.xyz = vec3(0.0, 1.0, 0.0);\n    else if (t1.z == rh.w) rh.xyz = vec3(0.0, 0.0, -1.0);\n    else if (t2.z == rh.w) rh.xyz = vec3(0.0, 0.0, 1.0);\n //\trh.xyz = rh.xyz * float(outside);  // Use this for normal to point inside if hit from inside\n    return rh;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return farPlane;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\n\n// ---- Scattering (fog) vars ----\n// Scattering needs a stack because it's all about what you're moving through.\n// So if you move through fog and then through glass, when you come out of the glass,\n// you're back into the fog.\n\n// This is the scatter var for the outer-most place. RGB fog diffuse, fog density.\n// **** Set fog here ****\nconst vec4 globalScatter = vec4(0.3, 0.4, 0.6, 0.005);//.5\n// Scatter stack\nvec4 scatterStack[NUM_ITERS*2];  // Size correct?\nint scatterStackIndex;\nvec4 PeekScatter() {\n    return scatterStack[scatterStackIndex-1];\n}\nvoid PushScatter(in vec4 s) {\n    if (s != PeekScatter())\n    {\n        scatterStack[scatterStackIndex] = s;\n        scatterStackIndex++;\n    }\n}\nvec4 PopScatter(in vec4 s) {\n    if (s != PeekScatter())\n    {\n        scatterStackIndex--;\n        return scatterStack[scatterStackIndex];\n    }\n}\nvoid InitScatterStack(in vec4 s) {\n    scatterStack[0] = s;\n    scatterStackIndex = 1;\n}\n\n// ---- Materials ----\n\n// List of refraction values for different materials\n// Linear reflectance values from http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf\n// In w, refrective index - https://en.wikipedia.org/wiki/List_of_refractive_indices\n// These can be calculated from each other: https://en.wikipedia.org/wiki/Schlick%27s_approximation\nconst vec4 refDebug = vec4(1.0,1.0,1.0, 1.005);\nconst vec4 refNone = vec4(0.0,0.0,0.0, 1.0);\nconst vec4 refWater = vec4(0.02,0.02,0.02, 1.330);\nconst vec4 refPlasticGlassLow = vec4(0.03,0.03,0.03, 1.42);\nconst vec4 refGlassWindow = vec4(0.043,0.043,0.043,1.52);\nconst vec4 refPlasticHigh = vec4(0.05,0.05,0.05, 1.58);\nconst vec4 refGlassHigh = vec4(0.08,0.08,0.08,1.79);  // Ruby\nconst vec4 refDiamond = vec4(0.172,0.172,0.172,2.417);\n// Metals - refractive index is placeholder and shouldn't be used I guess\nconst vec4 refIron = vec4(0.56,0.57,0.58,1.0);\nconst vec4 refCopper = vec4(0.95,0.64,0.54,1.0);\nconst vec4 refGold = vec4(0.995, 0.71, 0.29,1.0);\nconst vec4 refAluminum = vec4(0.91,0.92,0.92,1.0);\nconst vec4 refSilver = vec4(0.95,0.93,0.88,1.0);\nconst vec4 refSimpleMetal = vec4(0.92,0.92,0.92,1.0);  // rgb is same for better performance\n\nstruct Material {\n\tvec4 reflectRefract;\n    float refMult;\n    bool doRefraction;\n    vec3 diffuse;\n    vec3 emission;\n    vec3 filterDiffuseDensity;  // This is like a cheap scatter. Not sure I like it.\n    vec4 scatter;  // Diffuse in xyz, scatter probability in w.\n};\nconst int defaultMaterialIndex = 3;\nconst int NUM_MATERIALS = 7;\nMaterial materials[NUM_MATERIALS] = Material[NUM_MATERIALS](\n    // water (refraction broken, so just glossy black)\n    Material(refWater, 1.0, true, vec3(1.0), vec3(0.0), vec3(1.0), vec4(0.1, 0.7, 0.99, 0.0)),\n    // (refraction broken, so just glossy black)\n    Material(refGlassWindow, 1.0, true, vec3(0.0), vec3(0.0), vec3(1.0), vec4(0.99, 0.2, 0.05, 0.001)),\n    //Material(refPlasticGlassLow, 1.0, false, vec3(1.0), vec3(0.0), vec3(1.0), vec4(0.0)),\n    // gold\n    Material(refGold, 1.0, false, vec3(0.0), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // colored plastic\n    Material(refPlasticGlassLow, 1.0, false, vec3(0.5,0.8,0.92), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // non-shiny whatever\n    Material(refNone, 1.0, false, vec3(0.5), vec3(0.0), vec3(1.0), vec4(0.0)),\n    // light\n    Material(refNone, 0.0, true, vec3(1.0), vec3(14.0, 12.0, 7.0)*0.1, vec3(0.02), vec4(0.0)),\n    // light\n    Material(refNone, 0.0, false, vec3(1.0), vec3(200.0, 250.0, 300.0), vec3(0.0), vec4(0.0))\n);\n\n// ---- Intersect the ray with the scene, ray-trace style ----\nSceneHit SceneIntersect(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    result.pt = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n\n    /*SceneHit poly;\n    poly.pt = 0.0;\n    for (int i = ZERO_TRICK; i <18; i++) {\n        vec3 normal = vec3(0,1,0);\n        float t = iPlane(ray.p0, ray.dirNormalized, vec2(-200.0, 200.0), normal,\n                  HashPointOnSphere(uint(i)), -1.8);\n        if ((t > 0.0) && (t < farPlane) && (t > poly.pt)) {\n            poly.objIndex = 12399+i;\n            poly.materialIndex = 3;// (i&1)*4+1;\n            //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n            poly.pt = t;\n            poly.hitPos = ray.p0 + ray.dirNormalized * t;\n            poly.hitNormal = normal;\n        }\n    }\n    if ((poly.pt < farPlane) && (poly.pt > 0.0)) result = poly;*/\n\n    vec3 rayInv = 1.0 / ray.dirNormalized;\n    vec4 sA = vec4(0.0, 0.0, 0.75, 1.5);\n    for (int i = ZERO_TRICK; i < 1; i++) {\n        sA.xyz = (HashVec3(uint(i+18)) - 0.5) * 0.0;\n        sA.y *= 0.5;\n        //sA.y += 0.5;\n        //sA.xyz += Randf1i1(uint(float(i)+iTime*60.0)) * sA.xyz * 0.93;\n        sA.w =1.6;// (Hashf1(uint(i+23)) + 0.75) * 1.6;\n        float tall = 1.25;\n        //if ((i & 7) == 0) {\n        //    sA.y += 2.0;\n        //    sA.w *= 0.152;\n        //    tall = 8.0*Hashf1i1(uint(i+23));\n        //}\n        vec4 rh = SphereIntersect3(ray.p0, ray.dirNormalized, sA.xyz, sA.w, ray.outside);\n\t\t//vec4 rh = BoxIntersect(ray.p0, rayInv, sA.xyz, vec3(sA.w, sA.w*tall, sA.w), ray.outside);\n        if ((rh.w > 0.0) && (rh.w < result.pt)) {\n            result.objIndex = i+27;//3;// i&3;\n\t\t    result.materialIndex =0;//i+1;//(i&1)*4+1;\n            //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n            result.pt = rh.w;\n            result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n            result.hitNormal = rh.xyz;\n        }\n    }\n    vec4 rh = BoxIntersect(ray.p0, rayInv, vec3(0,-4.5,0), vec3(1.0, 0.1, 1.0), ray.outside);\n    if ((rh.w > 0.0) && (rh.w < result.pt)) {\n        result.objIndex = 1234;\n        result.materialIndex =3;// (i&1)*4+1;\n        //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n        result.pt = rh.w;\n        result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n        result.hitNormal = rh.xyz;\n    }\n    rh = BoxIntersect(ray.p0, rayInv, vec3(0.0,1.95,0.5), vec3(40.0, 0.05, 0.91), ray.outside);\n    if ((rh.w > 0.0) && (rh.w < result.pt)) {\n        result.objIndex = 1235;\n        result.materialIndex = 5;// (i&1)*4+1;\n        //if ((i & 7) == 0) result.objIndex =4 + ((i/8)&1);\n        result.pt = rh.w;\n        result.hitPos = ray.p0 + ray.dirNormalized * rh.w;\n        result.hitNormal = rh.xyz;\n    }\n//    IntersectBoxes(vec4(0.0,0.0,0.0,1.0), ray.p0, ray.dirNormalized, ray.outside, result, 0);\n\n    return result;\n}\n\n// ---- Also support ray marching, not just ray tracing. ----\n// k should be negative. -4.0 works nicely.\n// smooth blending function\n//float smin(float a, float b, float k)\n//{\n//\treturn log2(exp2(k*a)+exp2(k*b))/k;\n//}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n\nfloat spinTime;\nvec3 diagN = normalize(vec3(-1.0));\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\nvec2 sphereIter(vec3 p, float radius, float subA)\n{\n    finWidth = 0.1;\n    teeth = globalTeeth;\n    float blender = 0.25;\n    vec2 final = vec2(1000000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++)\n    {\n#ifdef SPLIT_ANIM\n        // rotate top and bottom of sphere opposite directions\n        p = RotateY(p, spinTime*sign(p.y)*0.05/blender);\n#endif\n        // main sphere\n        float d = length(p) - radius*outness;\n#ifdef SPLIT_ANIM\n        // subtract out disc at the place where rotation happens so we don't have artifacts\n        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));\n#endif\n\n        // calc new position at 8 vertices of cube, scaled\n        vec3 corners = abs(p) + diagN * radius;\n        float lenCorners = length(corners);\n        // subtract out main sphere hole, mirrored on all axises\n        float subtracter = lenCorners - radius * subA;\n        // make mirrored fins that go through all vertices of the cube\n        vec3 ap = abs(-p) * 0.7071;\t// 1/sqrt(2) to keep distance field normalized\n        float fin = -(abs(ap.x-ap.y) - finWidth);\n        fin = max(fin, -(abs(ap.y-ap.z) - finWidth));\n        fin = max(fin, -(abs(ap.z-ap.x) - finWidth));\n        //subtracter = max(subtracter, fin);\n        // subtract sphere from fins so they don't intersect the inner spheres.\n        // also animate them so they are like teeth\n        subtracter = min(subtracter, lenCorners - radius * subA + teeth);\n        // smoothly subtract out that whole complex shape\n        d = -smin(-d, subtracter, blender);\n        //vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);\t// recurse\n        // do a material-min with the last iteration\n        final = matmin(final, vec2(d, float(i)));\n        final = matmax(final, vec2(fin, 2.0));\n        //float temp = length(p) - radius*0.3*outness;\n        //final = matmin(final, vec2(temp, 5.0));\n\n#ifndef SPLIT_ANIM\n        corners = RotateY(corners, spinTime*0.25/blender);\n#endif\n        // Simple rotate 90 degrees on X axis to keep things fresh\n        p = vec3(corners.x, corners.z, -corners.y);\n        // Scale things for the next iteration / recursion-like-thing\n        radius *= inner;\n        teeth *= inner;\n        finWidth *= inner;\n        blender *= inner;\n    }\n    // Bring in the final smallest-sized sphere\n    float d = length(p) - radius*outness;\n    final = matmin(final, vec2(d, 2.0));\n    return final;\n}\n\n// This is the distance function that defines the ray marched scene's geometry.\n// The input is a position in space.\n// outside is 1 if the ray is intersecting with the outside of objects, -1 for insides (backface)\n// The output is the distance to the nearest surface, and a material index\nvec2 DistanceToObject(vec3 p, int outside)\n{\n\t//float d = length(p) - 4.0;\n    //return vec2(d, 1.0);\n    vec2 distMat = sphereIter(p, 5.2 / outness, cut);\n    return distMat;\n}\n\nSceneHit SceneMarch(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    //result.pt = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n    vec2 distAndMat = vec2(0.0, -1.0);  // Distance and material\n\t// ----------------------------- Ray march the scene ------------------------------\n\tconst float maxDepth = 28.0; // farthest distance rays will travel\n    const float smallVal = 0.0625*0.125*0.0625;\n\tresult.pt = 0.0;\n    const float safety =1.0;// 0.975;\n    // First, escape if we are touching a surface already.\n    // Get the ray out of the negative part of the distance field. (rough hack)\n    float jump = smallVal;\n    for (int i = ZERO_TRICK; i < 16; i++) {  // Weird for loop trick so compiler doesn't unroll loop\n        // Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.pt);\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        if (abs(distAndMat.x) >= smallVal) break;\n        // move down the ray a safe amount\n        result.pt += jump;//safety;//* float(ray.outside);\n        //result.pt += distAndMat.x*2.0;//safety;//* float(ray.outside);\n        jump *= 2.0;  // This is not super good. Fix me eventually.\n        if (result.pt > maxDepth) break;\n    }\n\t// ray marching time\n    for (int i = 300; i >= 0; i--)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.pt);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if (abs(distAndMat.x) < smallVal) break;\n        // move down the ray a safe amount\n        result.pt += distAndMat.x*safety;\n        if (i == 0) result.pt = maxDepth+0.01;\n        if (result.pt > maxDepth) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// If a ray hit an object, calculate the normal and save the hit info.\n    if ((result.pt <= maxDepth) && (result.pt > 0.0))\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        // Normals still point out even if we're on the inside.\n        //float mid = DistanceToObject(result.hitPos, 1).x;\n        //vec3 normalU = vec3(mid - DistanceToObject(result.hitPos - smallVec.xyy, 1).x,\n        //                   mid - DistanceToObject(result.hitPos - smallVec.yxy, 1).x,\n        //                   mid - DistanceToObject(result.hitPos - smallVec.yyx, 1).x);\n        vec3 normalU = vec3(0.0);\n        for( int i=min(0,iFrame); i<4; i++ )\n        {\n            vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n            normalU += e*DistanceToObject(result.hitPos+smallVal*e, 1).x;\n        }\n        result.hitNormal = normalize(normalU);\n        result.objIndex = int(distAndMat.y);\n        result.materialIndex = int(distAndMat.y);\n\t}\n    else\n    {\n        // Our ray trace hit nothing. Set object index to big int.\n        result.hitNormal = vec3(0.0);\n        result.pt = farPlane;\n        result.objIndex = BIG_INT;\n        result.materialIndex = BIG_INT;\n    }\n    return result;\n}\n\n// ---- Main ray trace function ----\n// Trace a ray, hit, apply material, save hit, and return the bounced ray\nRay TraceOneRay(const in Ray ray) {\n    vec3 diffuse = vec3(1.0);\n    vec3 emission = vec3(0.0);\n\n    // Send a ray out into the scene. Combine both ray marching and ray tracing.\n    Ray newRay;\n    newRay.outside = ray.outside;\n    SceneHit resultA = SceneIntersect(ray);\n    SceneHit resultB = SceneMarch(ray);\n    SceneHit result;\n    // Take closest hit.\n    if (resultA.pt < resultB.pt) {\n        result = resultA;\n    } else {\n        result = resultB;\n    }\n    result = resultB;// ***** HACK GOT RID OF RAY TRACING... *****\n\n    vec4 currentScatter = PeekScatter();\n    Material material = materials[result.materialIndex % materials.length()];\n    // Calculate how far the ray goes before hitting a random scattering particle.\n    float lifetime = RayLifetime(currentScatter.w);\n    // If we hit an object instead of a scatter-particle or the far-plane...\n    if (result.pt < min(farPlane, lifetime)) {\n\n        // Debug normal visualization\n        //emission = result.hitNormal * 0.5 + 0.5;\n        //newRay.outside = 0;\n        //SaveHit(diffuse, emission);\n        //return newRay;\n\n        //mat3 basis = MakeBasis(result.hitNormal);\n        newRay.p0 = result.hitPos;\n\n        vec4 refMaterial = material.reflectRefract;\n        float reflectance = material.refMult;\n        float fresnel = refMaterial.z;\n        // If reflectance is different for different wavelengths, then let's change from\n        // rgb to r, g, or b stochastically while not losing energy. So we will end up\n        // tracing a ray representing a single wavelength of light.\n        // This can be done unconditionally because if xyz are the same, it doesn't matter anyway.\n        float choice = RandFloat();\n        if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) {\n            // If we have already split to single wavelength, don't do it again.\n            /*if ( ((refMaterial.x == 0.0) && (refMaterial.y == 0.0)) ||\n                ((refMaterial.y == 0.0) && (refMaterial.z == 0.0)) ||\n                ((refMaterial.z == 0.0) && (refMaterial.x == 0.0)) ) {\n                // Take the non-zero component as the fresnel value.\n                fresnel = dot(refMaterial.xyz, vec3(1.0));\n            } else {\n                // .333 chance of switching to each single channel - r, g, or b.\n                if (choice < 0.33333) {\n                    fresnel = refMaterial.x;\n                    diffuse *= vec3(1.0, 0.0, 0.0);\n                } else if (choice < 0.66666) {\n                    fresnel = refMaterial.y;\n                    diffuse *= vec3(0.0, 1.0, 0.0);\n                } else diffuse *= vec3(0.0, 0.0, 1.0);\n                diffuse *= 3.0;  // To make up for stochastically dropping 2 out of 3 channels\n            }*/\n            fresnel = max(max(refMaterial.x, refMaterial.y), refMaterial.z);\n            diffuse *= refMaterial.xyz / fresnel;\n        }\n        // Figure out if we should reflect, or if the ray should go into the object (diffuse or refraction)\n        // Schlick's approximation\n        float oneMinusCos = 1.0 - saturate(dot(ray.dirNormalized, -result.hitNormal* float(ray.outside)));\n        float reflectProb = fresnel + (1.0-fresnel) * pow(oneMinusCos, 5.0);\n        reflectProb *= reflectance;\n        if (RandFloat() < reflectProb) {\n\t        //if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) diffuse *= refMaterial.xyz * fresnel;\n            // reflect\n\t        vec3 reflection = reflect(ray.dirNormalized, result.hitNormal);// * float(ray.outside));\n            newRay.dirNormalized = normalize(reflection);\n            // Already did the probability of reflection before, so no need to multiply anything.\n            //diffuse *= vec3(1.0);\n        } else {\n            //if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) diffuse *= 1000000.0;\n            if (material.doRefraction) {\n                // refract\n                float refractionIndex = 1.0 / refMaterial.w;  // 1.33 is water, 1.5 is glass.\n                if (ray.outside == -1) refractionIndex = 1.0 / refractionIndex;\n\n                vec3 refraction = refract(ray.dirNormalized, result.hitNormal * float(ray.outside), refractionIndex);\n                if (dot(refraction, refraction) > 0.0) {\n                    // Standard refraction\n\t                newRay.dirNormalized = normalize(refraction);\n                } else {\n                    // Special case - total internal reflection.\n                    // This is where at glancing angles, the surface will act like a mirror.\n                    // It's what makes fiber optics work. :D\n                    vec3 reflection = reflect(ray.dirNormalized, result.hitNormal * float(ray.outside));\n                    newRay.dirNormalized = normalize(reflection);\n                }\n                if (ray.outside == 1) {\n                    PushScatter(material.scatter);\n                } else {\n                    PopScatter(material.scatter);\n                }\n                newRay.outside = -ray.outside;\n            } else {\n                // Diffuse light\n                // Get a random vector in the hemisphere pointing along the normal.\n\t            vec3 rand = RandPointOnSphere();\n                vec3 bounce = rand * sign(dot(result.hitNormal, rand));\n                newRay.dirNormalized = bounce;\n                // Lambert shading model\n                //float intensity = dot(bounce, result.hitNormal);\n                diffuse *= material.diffuse;// * intensity;\n                emission = material.emission;\n            }\n\n        }\n    } else {\n        if (lifetime < farPlane) {\n            // Scattering (fog)\n            newRay.p0 = ray.p0 + ray.dirNormalized * lifetime;\n            newRay.dirNormalized = RandPointOnSphere();\n            diffuse *= currentScatter.xyz;\n            //emission = material.emission;\n        } else {\n            // Hit the background image. Let's be done ray tracing.\n            emission = GetEnvMap3(ray.dirNormalized);\n            newRay.outside = 0;  // This terminates the ray.\n        }\n    }\n    // Filtering\n    // Filter proportional to how long the ray moves inside the object\n    // This can also be done with scattering, but this should converge quicker.\n    if (ray.outside == -1) {\n        vec3 internal = material.filterDiffuseDensity.xyz;\n        diffuse *= pow(internal, vec3(abs(result.pt)));\n        emission = material.emission * pow(internal, vec3(abs(result.pt)));\n    }\n\n    // Save the ray hit in a list so we can calculate color of the pixel later on.\n    SaveHit(diffuse, emission);\n    return newRay;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetRandomSeed(fragCoord.xy, iResolution.xy, iFrame);\n    vec2 position = (gl_FragCoord.xy / iResolution.xy);\n    // read original buffer so we can accumulate pixel values into back it.\n\tvec4 backpixel = texture(iChannel0, position);\n    // If we use the mouse to change the view, reset the pixel accumulation buffer\n    if (iMouse.z > 0.0) backpixel = vec4(0.0);\n\n\t// ----------------------------------- Animate ------------------------------------\n    float localTime = 3.99;// iTime*0.5;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    //globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv_orig = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.4;\n    vec2 uv = uv_orig / zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\n\t//vec3 camLookat=vec3(0,0.91,0);\n\n    // camera orbit with mouse movement\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7;\n\tfloat my=-iMouse.y/iResolution.y*10.0;\n\tvec3 camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(16.0);\n    // If mouse is in bottom left corner, then use pre-set camera angle.\n    //if ((dot(iMouse.xy, vec2(1.0)) <= 64.0)) camPos = vec3(-4.0, 0.1, 7.1);\n    if ((dot(iMouse.xy, vec2(1.0)) <= 64.0)) camPos = vec3(-7.0, 6.6, 7.0)*1.25;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\n    // Depth of field hack... I think the math is all wrong.\n    const float depthOfFieldAmount = 0.0003;\n    vec2 rg = RandGaussianCircle()*depthOfFieldAmount;\n    camPos += sideNorm * rg.x;\n    camPos += upNorm * rg.y;\n    camVec=normalize(camLookat - camPos);\n    sideNorm=normalize(cross(upNorm, camVec));\n    upNorm=cross(camVec, sideNorm);\n\n    // More camera setup\n    vec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// --------------------------------------------------------------------------------\n    vec3 colorSum = vec3(0.0);\n    // Loop through for a few samples and average the pixel colors from ray tracing.\n    for (int s = ZERO_TRICK; s < NUM_SAMPLES; s++) {  // Weird for loop trick so compiler doesn't unroll loop\n        InitScatterStack(globalScatter);\n        ResetColorHitList();\n        Ray ray;\n        ray.outside = 1;\n        ray.p0 = camPos;\n        // Anti-aliasing: Randomly jitter the ray direction by a gaussian distribution.\n        vec2 gauss = RandGaussianCircle();\n        float antialias = dFdx(uv.xy).x/1.5;\n        ray.dirNormalized = normalize(rayVec +\n                                      sideNorm*gauss.x*antialias +\n                                      upNorm * gauss.y*antialias);\n\n        // Trace a ray from the camera outwards, bounce the ray off objects and keep\n        // tracing until NUM_ITERS or until it hits the background.\n        for (int i = ZERO_TRICK; i < NUM_ITERS; i++) {\n            if (i == (NUM_ITERS-1)) break;\n            ray = TraceOneRay(ray);\n            if (ray.outside == 0) break;\n        }\n        /*int i = 0;\n        do {\n            ray = TraceOneRay(ray);\n            i++;\n        } while ((ray.outside != 0) && (i < NUM_ITERS-1));*/\n\n        // Once we're done iterating through rays from the camera outwards, we have a\n        // list of hits. Now we can go from the light source toward the camera and apply\n        // the color filters and emissions as we go.\n\t    vec4 finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n        for (int i = NUM_ITERS-1; i >= ZERO_TRICK; i--) {\n            if (colorHits[i].emission.x != -1.0) {\n                finalColor.xyz *= colorHits[i].diffuse;\n                finalColor.xyz += colorHits[i].emission;\n                //finalColor.xyzw = finalColor.yzwx;  // Debug ray depth\n            }\n        }\n        colorSum += finalColor.xyz;\n    }\n    colorSum /= float(NUM_SAMPLES);\n\n    // output the final color\n\tfragColor = vec4(saturate(colorSum/4096.0),1.0) + backpixel;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}