{
    "Shader": {
        "info": {
            "date": "1683665623",
            "description": "Experimenting with noise functions",
            "flags": 0,
            "hasliked": 0,
            "id": "clV3zD",
            "likes": 0,
            "name": "Noise Blocks",
            "published": 3,
            "tags": [
                "basic",
                "tutorial",
                "boilerplate",
                "workshop"
            ],
            "usePreview": 0,
            "username": "drliquidglitch",
            "viewed": 165
        },
        "renderpass": [
            {
                "code": "//GLOBAL VARIABLES\nfloat time;\n//PRIMITIVE FUNCTIONS\nfloat box(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat sphere(vec3 p,float r){return length(p)-r;}\nfloat torus(vec3 p,vec2 t ){vec2 q=vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\n// Pseudo random number generator. \nfloat hash( vec2 a )\n{\n\n    return fract( sin( a.x * 3433.8 + a.y * 3843.98 ) * 45933.8 );\n\n}\n\n// Value noise courtesy of BigWingz \n// check his youtube channel he has\n// a video of this one.\n// Succint version by FabriceNeyret\nfloat noise( vec2 U )\n{\n    vec2 id = floor( U );\n          U = fract( U );\n    U *= U * ( 3. - 2. * U );  \n\n    vec2 A = vec2( hash(id)            , hash(id + vec2(0,1)) ),  \n         B = vec2( hash(id + vec2(1,0)), hash(id + vec2(1,1)) ),  \n         C = mix( A, B, U.x);\n\n    return mix( C.x, C.y, U.y );\n}\n//MAP / SCENE FUNCTION\nfloat map(vec3 p)\n{ \n  float mainBox=box(p,vec3(.1));\n  float scene = mainBox;\n  float t = clamp(0., 24.0, iTime * 0.2);\n  for (float i=0.; i<(t); i+=0.222){\n      float fx = sin(noise(vec2(i, i*i)))-0.5;\n      float fy = cos(noise(vec2(i*i, i)))-0.5;\n      float fr = cos(noise(vec2(i)))-0.5;\n      float newBox = box(p+vec3(i*fx*fx*cos(i)*i, i * fy * fy * sin(iTime*0.2), i*fr*fr*tan(i*i))*2., vec3(0.2));\n      scene=min(scene,newBox);\n      }\n  //scene=max(scene,rightTorus);\n  return scene;\n}\n//RAY CAST / TRACE LOOP FUNCTION\nfloat raycast( vec3 ro, vec3 rd )\n{\n  float dist,res=0.;\n  for(int i=0;i<128;i++){ \n    dist=map(ro+rd*res); \n    if(dist<.0001||res>128.) break;\n    res+=dist;\n  }\n  if(res>120.) res=0.;\n  return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //UV.y from -.5 to .5 and UV.x from -.88 to .88 (aspect ratio broooh)\n  time=mod(iTime,62.82); //Modulo time to avoid sin glitch noise due to floating point precision\n  // CAMERA  \n  vec3 rayOrigin=vec3(cos(time*.2)*5.,2,sin(time*.2)*5.);\n  vec3 cameraForward=normalize(vec3(0)-rayOrigin);\n  vec3 cameraLeft=normalize(cross(cameraForward,vec3(0,1,0)));\n  vec3 cameraUp=normalize(cross(cameraLeft,cameraForward));\n  vec3 rayDirection=mat3(cameraLeft,cameraUp,cameraForward)*normalize(vec3(uv,.5)); \n  // LIGHT DIRECTION & BACKGROUND SETUP   \n  vec3 lightDirection=normalize(vec3(-.1,.4,-.3));  \n  vec3 backgroundColor=vec3(.1,.1,.1)-length(uv)*.1;\n  vec3 color=backgroundColor;\n  // TRACE AND GET RESULT FOR THIS PIXEL\n  float result=raycast(rayOrigin,rayDirection);\n  // IF WE HIT SOMETHING THEN DO SOME LIGHTING  \n  if(result>0.){ \n    vec3 hitPos=rayOrigin+rayDirection*result; // GET POSITION OF WHERE WE HIT\n    vec2 e=vec2(.00035,-.00035); // e=ESPILON = OFFSET NUMBER FOR NORMALS CALCULATION\n    vec3 normals=normalize(e.xyy*map(hitPos+e.xyy)+e.yyx*map(hitPos+e.yyx)+e.yxy*map(hitPos+e.yxy)+e.xxx*map(hitPos+e.xxx)); //CALCULATE NORMALS FOR WHERE WE HIT\n    vec3 albedo=vec3(.0,.2,.4); // SETUP BASE COLOUR\n    float diffuse=max(0.,dot(normals,lightDirection)); // SIMPLE DIFFUSE LIGHTING\n    float fresnel=pow(1.+dot(normals,rayDirection),4.); // FRESNEL = BACKGROUND REFLECTIONS ADDED TO EDGES OF GEOMETRY TO COMPOSITE IT BETTER IN THE SCENE\n    float specular=pow(max(dot(reflect(-lightDirection,normals),-rayDirection),0.),30.);// SPECULAR LIGHTING = Bright highlights, the shiny white flashy bit especially visible on metallic objects\n    float ao=clamp(map(hitPos+normals*.05)/.05,0.,1.); // AO = AMBIENT OCCLUSION = Small shadows where geometries touch due to ambient lighting\n    float sss=smoothstep(0.,1.,map(hitPos+lightDirection*.4)/.4);// SSS = Sub surface scattering = Light penetrating through edges of a translucent object, especially visible on candle wax or skin. Can be used as backlight too.\n    color=mix(specular+albedo*(ao+.2)*(diffuse+sss*.1),backgroundColor,fresnel); // Final lighting result made of all the above and then mixed with fresnel\n    color=mix(backgroundColor,color,exp(-.002*result*result*result)); // Add fog right at the end\n  }\n  fragColor = vec4(pow(color,vec3(.4545)),1);// RETURN FINAL COLOR WITH GAMMA CORRECTION (pow(color,vec3(.4545)))\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}