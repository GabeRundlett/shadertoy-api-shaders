{
    "Shader": {
        "info": {
            "date": "1584706573",
            "description": "Shader made for the Cookie Collective live stream (2020/03/19) [url]https://www.twitch.tv/videos/570598632[/url]\nAdded dithering and mouse control for the Shadertoy version.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdlyWH",
            "likes": 13,
            "name": "Buildoids",
            "published": 3,
            "tags": [
                "kifs",
                "city",
                "building"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 683
        },
        "renderpass": [
            {
                "code": "// Shader made for the Cookie Collective live stream (2020/03/19)\n// https://www.twitch.tv/videos/570598632\n// Added dithering and mouse control for the Shadertoy version.\n\n// Leon Denise aka ponk from Cookie Collective\n// Made in 2020/03/19 with the work of the Shadertoy community\n\nconst float iterations = 7.;\n\nvec2 mouse;\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nvec3 lookat (vec3 eye, vec3 at, vec2 uv, float fov) {\n  vec3 forward = normalize(at-eye);\n  vec3 right = normalize(cross(forward, vec3(0,1,0)));\n  vec3 up = normalize(cross(right, forward));\n  return normalize(forward * fov + right * uv.x + up * uv.y);\n}\n\nfloat map (vec3 pos) {\n  float scene = 1.0;\n  float range = 2.0;\n  float a = 1.0;\n  float falloff = 1.2 + mouse.x * 0.6;\n  for (float index = iterations; index > 0.; --index) {\n    pos.xz *= rot(iTime*.05);\n    pos = abs(pos)-range*a;\n    scene = min(scene, max(pos.x,max(pos.y,pos.z)));\n    a /= falloff;\n  }\n  scene = max(-scene,0.);\n  return scene;\n}\n\nvec3 getNormal (vec3 p) {\n  vec2 e = vec2(0.0001,0);\n  return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(0,0.,-2);\n    vec3 ray = lookat(eye, vec3(0.,sin(iTime*.2)*.5,0), uv, .5);\n    mouse = (iMouse.xy / iResolution.xy);\n    float total = 0.0;\n    float shade = 0.0;\n    float dither = random(uv);\n    const float count = 100.;\n    for (float index = count; index > 0.; --index) {\n        float dist = map(eye+ray*total);\n        if (dist < 0.001) {\n            shade = index/count;\n            break;\n        }\n        dist *= .9 + 0.1 * dither;\n        total += dist;\n    }\n    vec3 color = vec3(shade);\n    vec3 normal = getNormal(eye+ray*total);\n    color = vec3(.3)*clamp(dot(normal, normalize(vec3(0,1,-1))),0.,1.);\n    color += vec3(.9)*pow(clamp(dot(normal, -ray),0.,1.), 8.);\n    color *= shade;\n    fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}