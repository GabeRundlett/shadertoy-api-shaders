{
    "Shader": {
        "info": {
            "date": "1684585515",
            "description": "Black hole with accretion disk. While I tried to include relativistic effects, it is meant to look good, not be accurate. ",
            "flags": 32,
            "hasliked": 0,
            "id": "clV3Wy",
            "likes": 15,
            "name": "Black hole (volumetric)",
            "published": 3,
            "tags": [
                "raycasting",
                "space",
                "nebula",
                "blackhole"
            ],
            "usePreview": 0,
            "username": "thepinkpanzer",
            "viewed": 556
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 raw   = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bloom = texture(iChannel1, fragCoord/iResolution.xy);\n    vec4 psf   = texture(iChannel2, fragCoord/iResolution.xy);\n    \n    fragColor = tanh(pow(psf*0.8+bloom*2.+0.3*raw,vec4(1.5)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\nfloat Sharp(float v, float n)\n{\n    v = 1.-v;\n    v*= v;\n    return max(0., 1.-n*v);\n}\nvec4 BackgroundColor(vec3 vd)\n{\n    vd = normalize(vd);\n    vec3  a = abs(vd);\n    float m = max(max(a.x, a.y), a.z);\n    vec2 uv;\n    if      (m == a.x)\n    {\n        uv = vec2(vd.z, vd.y);\n    }\n    else if (m == a.y)\n    {\n        uv = vec2(vd.x, vd.z);\n    }\n    else\n    {\n        uv = vec2(vd.x, vd.y);\n    }\n    vec4 col = vec4(0);\n    mat2 rot = mat2(vec2(0.8, 0.6), vec2(-0.6, 0.8));\n    uv *= rot;\n    vec4 r1  = texture(iChannel0, uv/4.);\n    uv *= rot;\n    vec4 r2  = texture(iChannel0, uv/2.);\n    uv *= rot;\n    vec4 r3  = texture(iChannel0, uv/1.);\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r1.r*r1.b, 9.)*3.;\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r1.a)*Sharp(r1.g*r1.r, 9.)*3.;\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r1.a)*Sharp(r1.b*r1.g, 9.)*3.;\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r2.r*r1.a, 4.);\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r2.a)*Sharp(r2.g*r1.b, 4.);\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r2.a)*Sharp(r2.b*r1.g, 4.);\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r3.r*r1.a*r2.a, 2.)*0.5;\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r3.a)*Sharp(r3.g*r1.a*r2.a, 2.)*0.5;\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r3.a)*Sharp(r3.b*r1.g*r2.a, 2.)*0.5;\n    \n    return col;\n}\nfloat SphereDist(float radius, vec3 position, vec3 direction)\n{\n    float d = -dot(position, direction) - sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\nfloat SphereThrough(float radius, vec3 position, vec3 direction)\n{\n    float d = 2.*sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\nfloat Dn(float n, vec3 pos)\n{\n    n   /= ACCDL/BHRAD;\n    pos *= vec3(n, pow(1./((1./n)+N0), NPOW), n) / SCALE;\n    float v = pow(n/ACCDL, 1.4)*SPEED;\n    float p1= 1.1*v*iTime+46.65432*n;\n    float p2= 0.9*v*iTime+54.21345*n;\n    mat3  r1= mat3(vec3( cos(p1), 0, sin(p1)),\n                   vec3(     0  , 1,     0  ),\n                   vec3(-sin(p1), 0, cos(p1)));\n    mat3  r2= mat3(vec3( cos(p2), 0, sin(p2)),\n                   vec3(     0  , 1,     0  ),\n                   vec3(-sin(p2), 0, cos(p2)));\n    vec3 pos1= r1*pos;\n    vec3 pos2= r2*pos;\n    float d1  = texture(iChannel1, pos1/30.).r;\n    float d2  = texture(iChannel1, pos2/20.).g;\n    float d3  = texture(iChannel1, pos1/5. ).b;\n    float d4  = (1./(0.3 + pos.y*pos.y));\n    \n    return exp(7.*d1 + 4.*d2 + 2.*d3 - 8.)*(5./(2. + pos.y*pos.y))*tanh(1./n - 1.) + d3*(2./(1. + pos.y*pos.y)) + d4;\n}\nfloat Density(vec3 pos)\n{\n    float n = ACCDL/length(pos);\n    \n    float n1= floor(n);\n    float n2= ceil(n);\n    \n    float d1= Dn(n1, pos);\n    float d2= Dn(n2, pos);\n    \n    return mix(d1, d2, smoothstep(n1, n2, n));\n}\nvec4 BB(float t)\n{\n    t *= TEMPMULT;\n    vec4 hotblue = vec4(0.25, 0.5, 1, 0);\n    vec4 white   = vec4(1);\n    vec4 red     = vec4(0.8, 0.5, 0.2, 0);\n    return mix(red, mix(hotblue, white, (1./(1.+t*t))), tanh(t));\n}\nfloat Boost(float v)\n{\n    return (sqrt((1.+v)/(1.-v)));\n}\nvec4 Add(vec3 pos, vec3 dir, float density)\n{\n    float temp = 1./dot(pos, pos);\n    float v    = tanh(RVMULT/sqrt(length(pos)))*dot(cross(normalize(pos), vec3(0,1,0)), dir);\n    temp *= Boost(v);\n    return temp*density*BB(temp)*1.;\n}\nvec4 Abs(vec3 pos, float density)\n{\n    return vec4(0.5, 0.6, 0.8, 0)*0.8*density;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse  = iMouse.xy == vec2(0) ? vec2(0.5, 0.45)*iResolution.xy : iMouse.xy;\n    float theta = (mouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (mouse.y - iResolution.y / 2.) / iResolution.y * PI*0.55;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition= -5.*iCameraFwd;\n    \n    float m = 1.0;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    fragColor           = vec4(0);\n    \n    vec3  pos           = iCameraPosition + iViewDirection*SphereDist(5., iCameraPosition, iViewDirection);\n    vec3  dir           = iViewDirection;\n    float dis           = SphereThrough(5., iCameraPosition, iViewDirection)/NJUMPS;\n    \n    pos += dir*dis/2.;\n    bool absorbed = false;\n    \n    vec4 mult = vec4(1);\n    for (float n = 0.; n < NJUMPS+1.; n++)\n    {\n        dir -= C1*dis*normalize(pos)/dot(pos, pos);\n        dir -= C2*dis*(cross(dir, vec3(0,1,0)))/pow(dot(pos,pos),1.5);\n        dir  = normalize(dir);\n        dis  = min(dis, SphereDist(BHRAD, pos, dir));\n        pos += dir*dis;\n        \n        float dens = Density(pos);\n        mult      *= exp(-dis*Abs(pos, dens)    )     ;\n        fragColor +=      dis*Add(pos, dir, dens)*mult;\n        \n        if (length(pos) <= BHRAD*1.001)\n        {\n            absorbed = true;\n            break;\n        }\n        else if (length(pos) > 5.)\n        {\n            break;\n        }\n    }\n    if (!absorbed)\n    {\n        fragColor += BackgroundColor(dir)*mult*6.;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define T(r) pow(texture(iChannel0, r), vec4(2.))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -BLOOMSIZE; i < BLOOMSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(1,0)*i)/iResolution.xy)*exp(-(4.*i*i)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor = tot/(2.*BLOOMSIZE);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define T(r) texture(iChannel0, r)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -BLOOMSIZE; i < BLOOMSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(0,1)*i)/iResolution.xy)*exp(-(4.*i*i)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor = tot/(2.*BLOOMSIZE);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define T(r) pow(texture(iChannel0, r), vec4(1.3))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -PSFSIZE; i < PSFSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(1,0)*i)/iResolution.xy)*(1.-i/PSFSIZE)*(1.+i/PSFSIZE)/sqrt(i*i+1.);\n    }\n    for (float i = -PSFSIZE; i < PSFSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(0,1)*i)/iResolution.xy)*(1.-i/PSFSIZE)*(1.+i/PSFSIZE)/sqrt(i*i+1.);\n    }\n    fragColor = tot/(PSFSIZE);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Post processing\n#define BLOOMSIZE 50.\n#define PSFSIZE   20.\n\n// Number of samples\n#define NJUMPS    200.\n\n// Black hole radius and lensing coefficients\n// C1 is symmetric (normal gravity), C2 is antisymmetric (rotation)\n#define BHRAD     0.3\n#define C1        0.3\n#define C2       -0.07\n\n// Disk thickness (thickness ~ SCALE * pow(r + N0, NPOW))\n#define NPOW      0.5\n#define SCALE     0.03\n#define N0        2.\n\n// Orbit coefficients (number of 'bands' and orbital speed power)\n#define ACCDL     10.\n#define SPEED     150.\n\n// Color coefficients (Doppler strength and temperature)\n#define RVMULT    0.9\n#define TEMPMULT  0.2",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}