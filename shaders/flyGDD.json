{
    "Shader": {
        "info": {
            "date": "1637766748",
            "description": "Just exhibiting my cubic equation solver.\nDevelopment was done [url=http://shadertoy.com/view/Ns2XRd]here[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "flyGDD",
            "likes": 8,
            "name": "Roots Cubic",
            "published": 3,
            "tags": [
                "antialias",
                "graph",
                "plot",
                "cubic",
                "equation",
                "root",
                "solve"
            ],
            "usePreview": 0,
            "username": "spalmer",
            "viewed": 437
        },
        "renderpass": [
            {
                "code": "/*\nCC0 1.0 Universal (CC0 1.0)\nTo the extent possible under law, the author has waived all \ncopyright and related or neighboring rights to this work.\nhttp://creativecommons.org/publicdomain/zero/1.0\n*/\n\n// toy got big, moved bunch fundamental/unused/reference code to Common tab\n\n// used some guidance from Nickalls but really it's a merge of Wikipedia and Bloxard techniques\n// with help from iq as well, hints from James Blinn, and others.\n\n#if 1\n// solve depressed cubic xÂ³ + cx + d = 0\nvec3 CubicSpalmer(float d, float c) // b = 0, a = 1\n{\n    float l = c / 3.\n    , s = l*l*l\n    , m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        float v = cbrt(abs(w.x) < abs(w.y) ? w.y : w.x);\n        return vec3(v - l / v, NaN, NaN); // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    float t = atan(sqrt(-m), -sign(c)*(d));\n    return 2. * ssqrt(l) * cos((t - pi * vec3(0,2,4))/3.);\n}\n#endif\n\n// solve xÂ³ + cx + d = 0\nvec3 CubicDepressed(float d, float c)\n{\n    vec3 k = vec3(d, c, 0.);\n//    return Cubiciq(k);\n//    return CubicBloxard(k);\n//    return Cubiciq(d, c);\n//    return CubicBloxard(d, c);\n//    return Cubicmla(d, c);\n//    return CubicCardano(d, c); // busted WIP\n//    return CubicSpalmerSaved(d, c);\n    return CubicSpalmer(d, c);\n}\n\n// by spalmer\nvec3 CubicDepress(vec3 k)\n{\n    float d = k.x, c = k.y, b = k.z, // a = 1.\n        x = b/-3.; // inflection point\n    return CubicDepressed((c - 2.*x*x)*x + d, c + b*x) + x;\n}\n// depressing the cubic first makes solution much simpler and seems like it's always a good idea\n// Blinn says it's 3*b*b*b-3*b*c+d and (c-b*b) but he already divided by 3 elsewhere, confusingly\n// and I factored a division here some different way\n\n// dispatch wrapper for cubic equation in standard form\n// solve ((x + k.z)*x + k.y)*x + k.x = 0\nvec3 Cubic(vec3 k) // k.w == 1\n{\n    return\n        CubicDepress\n//     CubicWeierstrass\n//     CubicNickalls\n//     Cubiciq\n//     CubicBloxard\n//     CubicOld\n        (k);\n}\n\n// another dispatch wrapper\n// solve ((k.w*x + k.z)*x + k.y)*x + k.x = 0\n// by first dividing through by the highest order coeff,\n// which does not change the roots\nvec3 Cubic(vec4 k)\n{\n//    return CubicSpalmerInlined(k);\n//    return solveCubicReal(k);\n    if (k.w == 0.)\n        return vec3(Quadratic(k.xyz), NaN); // handle malformed eqn\n    return Cubic(k.xyz / k.w);\n}\n\nvec4 coeff = vec4( .5, -2., 1., 1.*1.5) * -1.;\n// or can set up test cases explicitly and disable animation in setup\n//vec4 coeff = vec4(1.572, -.124, -.784, 1.625);\n//vec4 coeff = vec4(-1.130701, 1.8766, .7778, .6291);\n\nfloat sinOSC(float imin, float imax, float T)\n{\n    return .5 * (sin(T) * (imax - imin) + imax + imin); // slightly optimized\n    //float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    //return imin + v * (imax - imin); // map T to [min, max];\n}\n\n/*\nvoid setup()\n{\n    NaN = sqrt(-min(0., iTime) - 1.); // compile time constant NaN is too problematic\n    float t = -2. * iTime;\n    coeff[0] -= 2.   * sin(.4 * t); // wiggle coeffs to see how they affect the result\n    coeff[1] += .125 * sin(.2 * t);\n    coeff[2] *= 1.2  * cos(.1 * t); // when [2] gets small, starts looking an awful lot like a straight line at 45 degrees at which point you cannot tell which way the curve flips because it's way off-screen\n    coeff[3] *= cos(.05 * t);\n}\n*/\nvoid setup()\n{\n    NaN = sqrt(-min(0., iTime) - 1.); // compile time constant NaN is too problematic\n\n    float Time = iTime + 14.; //17.04; //\n    float a = sinOSC(-1.25, 1.25, Time * 0.15), b = sinOSC( -2.0,  2.0, Time * 0.6), \n          c = sinOSC( -1.0,  1.0, Time * 0.45), d = sinOSC( -1.0,  1.0, Time * 0.25);\n    \n    coeff[0] = d; coeff[1] = c; coeff[2] = b; coeff[3] = a;\n\n// Envy24 test case:\n    // this breaks too, but interestingly, it's not the exact same breakage due to double precision\n    //coeff = vec4(-0.899405409685178,0.982755208911199,-1.43362772677276,0.690866734731352);\n    //coeff = vec4(-.8994, .9827, -1.4336, .6908); // obtained by shader printout, not super precise though\n    //coeff = vec4(-.8994, .9845, -1.4336, .6909); // pretty darn close to Envy24's breakage\n    //coeff[0] = coeff[1] = coeff[2] = 0.; coeff[3] = 1.;\n    //coeff[0] = .5; coeff[1] = coeff[2] = 0.; coeff[3] = 1.;\n    //coeff[0] = -1.; coeff[1] = 0.; coeff[2] = 2.; coeff[3] = 1.;\n    //coeff[0] = -.5; coeff[1] = 0.; coeff[2] = 1.; coeff[3] = 0.;\n}\n\n// function to plot\nfloat f(float x)\n{\n    return eval(x, coeff);\n}\n\n// iq line segment distance\nfloat seg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a; return length(p - b *\n        clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\nfloat aa(float e)\n{\n    return clamp(1. - e, 0., 1.);\n}\n\n// must search at least thick pixel units away\n// to avoid missing nearby crossings.\nfloat graphf(vec2 p, vec2 R, float scale, float thick)\n{\n    float d = 9e9\n        , i = p.x-.5-thick, j = i, v = f(i*scale) / scale;\n    while ((i += 1.) <= .51+thick+p.x) {\n        float v1 = f(i*scale) / scale;\n        d = min(d, seg(p, vec2(j, v), vec2(i, v1)));\n        v = v1; j = i;\n    }\n    return aa(d + .5 - thick);\n}\n\nvec3 draw(vec2 p)\n{\n    vec2 R = iResolution.xy\n        , q = p - .5*R;\n    float scale = 2.5/R.y;\n    vec3 c = vec3(1);  // bg\n    c = mix(c, vec3(.7), aa(min(abs(q.x),abs(q.y)) - .5));\t// axis lines\n    // the inflection point is at -1./3.*coeff[2]/coeff[3]\n    float x_i = -1./3.*coeff[2]/coeff[3];\n    c = mix(c, vec3(1,.7,1), aa(abs(q.x - x_i / scale) - .0)); // inflection point\n    // TODO graph the rest of the cubic-solving construction\n    c = mix(c, vec3(0), graphf(q, R, scale, 2.5));  // graph curve\n    vec3 s = Cubic(coeff)\n    , v = vec3(f(s[0]), f(s[1]), f(s[2]));\n    c = mix(c, vec3(.8,0,0), aa(length(q - vec2(s[0], v[0]) / scale) - 5.5)); // disks\n    c = mix(c, vec3(0,.6,0), aa(length(q - vec2(s[1], v[1]) / scale) - 5.5));\n    c = mix(c, vec3(0,0,.9), aa(length(q - vec2(s[2], v[2]) / scale) - 5.5));\n    return c; // linear gamma\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    setup();\n    c.rgb = draw(p);\n    c = vec4(pow(c.rgb, vec3(.4545)), 1); // to sRGB gamut\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//const float NaN = intBitsToFloat(~0);\n/*const*/ float NaN = uintBitsToFloat(0x7f800001u);\n\nconst float pi = acos(-1.);\n\n#define sgn(x) ((x)<0. ? -1. : 1.)\n/* // mla\nfloat sgn(float x) {\n  if (x < 0.0) return -1.0;\n  else return 1.0;\n}*/\n\nfloat ssqrt(float x) { return sign(x) * sqrt(abs(x)); }\nfloat spow(float x, float y) { return sign(x) * pow(abs(x), y); }\nfloat cbrt(float x) { return spow(x, 1./3.); } //sign(x) * pow(abs(x), 1./3.); } //\nvec2 cbrt(vec2 x) { return sign(x) * pow(abs(x), vec2(1./3.)); } // compute 2 cube roots at once\n\n#define complex vec2\nconst complex one = complex(1,0);\ncomplex cmul(complex a, complex b) \n{\n    return complex(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\ncomplex cdiv(complex a, complex b)\n{\n    return cmul(a, complex(b.x, -b.y) / dot(b,b));\n}\n/* // mla\ncomplex cmul(complex z, complex w) {\n  return complex(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\ncomplex cinv(complex z) {\n  return complex(z.x,-z.y)/dot(z,z);\n}\n\ncomplex cdiv(complex z1, complex z2) {\n  return cmul(z1,cinv(z2));\n}\n*/\n\n// evaluate polynomial c(t)\nfloat eval(float t, vec4 c)\n{\n    return ((c.w * t + c.z) * t + c.y) * t + c.x;\n}\ncomplex eval(float t, in complex c[4])\n{\n    return ((c[3] * t + c[2]) * t + c[1]) * t + c[0];\n}\n\n// why have I lettered these this way...\n// I tell ya what, it's maddening to try to use the \"standard\" way\n// which is used here so far... since the meanings of all the coeffs change\n// with every equation order.  But if I reverse them, suddenly\n// everything I do is backwards from all the public literature.\n// To me, the only solution is to avoid these 1-letter names entirely\n// and use indices. And by george, sort them low-order coeffs first.\n// solve a*x + b = 0\nfloat Linear(float b, float a)\n{\n    return -b / a;\n}\n\nfloat Linear(vec2 k)\n{\n    return Linear(k.x, k.y); //k[0], k[1]); //-k[0] / k[1];\n}\n\n// try again, this time try to use methodology that will scale\n// inflection point N is at x_N = -b/(2*a) = -.5*b/a\n// subtracting that gives the reduced quadratic\n// g(z) := f(z + x_N)  := \n// with z = x - x_N\n// substituting seems to give\n// z = (2*a*x_N Â± âˆšï¸(b^2-4*a*c) - b) / (2*a)\n// and simplifying that by hand gives\n// z = x_N Â± (âˆšï¸(b^2-4*a*c) - b) / (2*a)\n// now if we know a is 1 because we already divided it out, gets even simpler\n// z = x_N Â± (âˆšï¸(b^2-4*c) - b) / 2\n// a*z^2 + c - b^2/(4*a) = 0\n// z^2 + c - b^2/4 = 0\n    // at this point we have equation x*x + b/a*x + c/a = 0 or just (x + b)*x + c = 0\n    // now subtract inflection point by substituting z = x - x_N to get\n    // z^2+(2*x_N+b)*z+x_N^2+b*x_N+c=0, subst x_N back out for -b/2 gives\n    // z^2-1/4*b^2+c = 0\n    // solve for z\n    // z = Â±sqrt(b^2-4*c)/2 = Â±sqrt(b^2/4-c) but we need the .5 on the outside anyway\n    // then the full answer for x is just x = x_N + z\n    // Â±sqrt(b^2-4*c)/2\n// solve reduced quadratic (x + b)*x + c = 0\nvec2 Quadratic(float c, float b)\n{\n    float n = b * b - 4. * c; // discriminant\n    return n < 0. ? vec2(NaN) :\n        .5 * (sqrt(n) * vec2(-1, 1) - b); // two solutions, lesser first (may be identical)\n}\n\nvec2 Quadratic(float c, float b, float a)\n{\n    if (a == 0.)\n        return vec2(Linear(c, b), NaN); // handle malformed eqn\n    // else reduce and solve reduced equation\n    return Quadratic(c/a, b/a);\n}\n    // can literally divide by the high coeff and not change the roots, so a can always be 1.0\n    // *although* this might possibly be unwise since it may affect precision prematurely\n    //c /= a; b /= a; //a = 1.; // c only used once more anyway\n    // the inflection point will be at -.5*b\n    //float n = b * b - 4. * c; // discriminant\n    //return n < 0. ? vec2(NaN) :\n    //    .5 * (sqrt(n) * vec2(-1, 1) - b); // two solutions, lesser first (may be identical)\n// I feel like should be able to dispatch back to Linear even in the other case somehow\nvec2 Quadratic(vec3 k)\n{\n    return Quadratic(k.x, k.y, k.z); //k[0], k[1], k[2]);\n}\n\n\n// Ta-da!  spiffy\nvec3 CubicSpalmerInlined(vec4 k)\n{\n    float NaN = uintBitsToFloat(0x7f800001u);\n    float d = k.x, c = k.y, b = k.z, a = k.w;\n    if (a == 0.) { // quadratic inlined\n        if (b == 0.)\n            return vec3(-d/c, NaN, NaN); // handle malformed eqn, let divide handle c == 0 case\n        float n = c * c - 4. * b * d; // discriminant\n        return vec3(n < 0. ? vec2(NaN) :\n            .5 / b * (sign(b) * sqrt(n) * vec2(-1, 1) - c) // two solutions, lesser first (may be identical)\n            , NaN);\n    }\n    d /= a; c /= a; b /= a;\n    float x = b/-3.; // inflection point\n    d += (c - 2.*x*x)*x; c += b*x; // depress cubic\n    float l = c / 3.,\n        s = l*l*l,\n        m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = sqrt(m) * vec2(1,-1) - d;\n        float v = abs(w.x) < abs(w.y) ? w.y : w.x;\n        v = sign(v) * pow(.5*abs(v), 1./3.);\n        return vec3(v - l / v, NaN, NaN) + x; // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    return 2. * sign(c)*sqrt(abs(l)) * cos((atan(sqrt(-m), -sign(c)*d) - acos(-1.) * vec3(0,2,4))/3.) + x;\n}\n\n\n#if 1\n// TODO inline it all back again\n// I am NOT ready to do this because I am still optimizing the depressed solver!\n// solve ((k.w*x + k.z)*x + k.y)*x + k.x = 0\nvec3 CubicSpalmerInlinedWIP(vec4 k)\n{\n    float d = k.x, c = k.y, b = k.z, a = k.w;\n    if (a == 0.) { // quadratic inlined\n        if (b == 0.)\n            return vec3(-d/c, NaN, NaN); // handle malformed eqn, let divide handle c == 0 case\n        float n = c * c - 4. * b * d; // discriminant\n        return vec3(n < 0. ? vec2(NaN) :\n            .5 / b * (sign(b) * sqrt(n) * vec2(-1, 1) - c) // two solutions, lesser first (may be identical)\n            , NaN);\n    }\n    // not 100% sure doing all these divisions early is the absolute wisest plan\n    d /= a; c /= a; b /= a; //k.xyz /= k.w; //k.w = 1.;\n    float x = b/-3.; // inflection point\n    d += (c - 2.*x*x)*x; c += b*x; //b = 0.; // depressed cubic\n    float l = c / 3.,\n        s = l*l*l,\n        m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        float v = cbrt(abs(w.x) < abs(w.y) ? w.y : w.x);\n        return vec3(v - l / v, NaN, NaN) + x; // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    return 2. * ssqrt(l) * cos((atan(sqrt(-m), -sign(c)*d) - pi * vec3(0,2,4))/3.) + x;\n}\n// inlines the depressed solver\n// TODO must still inline all the little helper functions like ssqrt, then golf it all back down\n/*\nvec3 CubicSpalmer(float d, float c) // b = 0, a = 1\n{\n    float l = c / 3.\n    , s = l*l*l\n    , m = d*d + 4.*s;\n    if (m > 0.) { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        float v = cbrt(abs(w.x) < abs(w.y) ? w.y : w.x);\n        return vec3(v - l / v, NaN, NaN); // Blinn single cbrt idea\n    }\n    // 2 or 3 distinct roots\n    \n}\n*/\n#endif\n\n#if 0\n// saved from before I figured out Blinn's single cbrt idea\nvec3 CubicSpalmer(float d, float c) // b = 0, a = 1\n{\n    float l = c / 3.,\n        s = l*l*l,\n        m = d*d + 4.*s;\n    if (m > 0.)\n    { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        if (abs(c) < .004) // what's a good threshold here?\n        { // credit: iq from comment at http://shadertoy.com/view/dsfGWN\n            float k = s/d;  // linear approx\n            //k *= 1. - s/(d*d);  // quadratic approx doesn't seem necessary\n            w = vec2(k, -k-d);\n        }\n        w = cbrt(w);\n        return vec3(w.x + w.y, NaN, NaN);\n    }\n    // 2 or 3 distinct roots\n    float t = atan(sqrt(-m), -sign(c)*d);\n    return 2.*ssqrt(l) * cos((t - pi * vec3(0,2,4))/3.);\n}\n// got rid of some minus signs already        // FIXME in bezier toy you can see this causes a nasty glitch that isn't quite fixed by iq's above fix\n    //    return vec3(w.x - l / w.x, NaN, NaN); // TODO blinn single cbrt idea; not *quite* working, must ensure it's done totally robustly or makes things worse!\n\n// tan = b/c / (a/c) =  b/c*c/a = b/a\n// so we computed the cosine of 3*theta as .5*d/sqrt(abs(s))\n// the sine of that is sqrt(1. - .25*d*d/abs(s))\n// so at the expense of a seemingly wasted sqrt, I can pose the problem in terms of arctangent:\n// ok but the 2 arg form of atan may not in fact be ideal since then must compute the sine fully\n// what if we just pose the problem in terms of the tangent and use 1-argument atan?\n// tangent is just sin/cos so d/sqrt(4.*abs(s)-d*d)\n#endif\n\n#if 0\n// saved working copy\n// solve depressed cubic xÂ³ + cx + d = 0\nvec3 CubicSpalmerSaved(float d, float c) // b = 0, a = 1\n{\n    float l = c / -3.,\n        s = l*l*l,\n        m = d*d - 4.*s;\n    if (m > 0.)\n    { // 1 real root\n        vec2 w = (sqrt(m) * vec2(1,-1) - d) * .5;\n        if (abs(c) < .004)\n        { // credit: iq from comment at http://shadertoy.com/view/dsfGWN\n            float k = -s/d;  // linear approx\n            //k *= 1. + s/(d*d);  // quadratic approx doesn't seem necessary\n            w = vec2(k, -k-d);\n        }\n        w = cbrt(w);\n        return vec3(w.x + w.y, NaN, NaN);\n    }\n    // 2 or 3 distinct roots, imaginary projected back to real\n    return 2.*ssqrt(l) * cos((acos(-.5*d/sqrt(abs(s))) + pi * vec3(2,4,0))/3.);\n}\n\n    //float tc = .5*d / sqrt(abs(s)); // cos(3.*theta)\n    //float ts = sqrt(1. - .25*d*d/abs(s));// * -sign(s); //sin(acos(tc)); // sin(3.*theta) so can use 2-arg atan\n    // btw sign(s) == sign(l) == sign(c)\n    //float t = atan(ts, tc); //acos(tc); // 3.*theta angle in radians\n    //float t = pi+atan(ts/tc); // closest I've gotten so far in terms of sin/cos\n    // I mean if I have to do it like this, the pi offset would get shifted into the vec3(0,2,4) somehow\n    // but am hoping can account for it some other way\n    // anyhows, now that I have a relatively straightforward way to map atan2 to atan, that seems to work,\n    // perhaps now I can simplify some of my tangent-based formulations...\n// NOTE that m = d*d - 4.*s which we already computed and we already know it's < 0.\n//float t = atan(sqrt(-m), abs(d)); //atan(sqrt(4.*abs(s)-d*d), d); // nice! very nice! but it doesn't *quite* work in all circumstances, see Bezier Quadric\n\n    // can someone please tell me why 1-argument atan does not work? it almost works..\n    //float t = pi-atan(-ts/tc); // signs just cancel out I guess\n    //float t = atan((4.*d*abs(s))/sqrt(4.*abs(s)-d*d)); //atan(sqrt(4.*abs(s)-d*d)/(4.*d*abs(s))); //-pi/2.- // broken\n    //float t = pi-atan(-ts/tc); //-pi/2.+atan(tc/ts); //pi-atan(-ts/tc); //\n    //float t = pi + sign(s) * atan(sqrt(4.*abs(s)-d*d)/abs(d)); // pretty good!\n    //float t = pi/2.+atan(d * sign(s), sqrt(abs(s))*sqrt((4.*abs(s)-d*d)/abs(s))); // same as below but uses atan2\n    //float t = pi/2.+atan(d * sign(s) / (sqrt(abs(s))*sqrt((4.*abs(s)-d*d)/abs(s)))); // I guess it's getting there\n    //float t = pi-atan(sign(s) * (sqrt(abs(s))*sqrt((4.*abs(s)-d*d)/abs(s)))/d); // wtf -- it works!  but I don't understand why it's so backwards\n    //float t = pi/2.-atan(d, sqrt(4.*abs(s) - d*d)); //atan(d/sqrt(4.*abs(s) - d*d)); // compute 3.*theta directly using tangent\n\n//float h = 2.*sqrt(abs(s)); //ssqrt(4.*s); // h used only once here\n//return 2.*ssqrt(l) * cos((acos(-d/h) + pi * vec3(2,4,0))/3.);\n// if d/h is a cosine, then h is the hypotenuse and since h*h = d*d + y*y if we want y we get\n// atan(h*h,d*d); // yeah but seems to require another sqrt which I don't want to do\n// I guess we already had the square of it, s, so that's something.\n// TODO use atan - even Blinn says to! handles some edge case precision-related fails\n    \n// FIXME there MUST be some way to do the real root computing only one cbrt\n// surely any equation of the form cbrt(u)+cbrt(v) can be rewritten in the form cbrt(f(u,v))\n// f(u,v) = v+3*u^(1/3)*v^(2/3)+3*u^(2/3)*v^(1/3)+u does not seem too promising though\n// since includes both the cube roots we're trying to eliminate\n// but perhaps if know more about u and v, if they share common factors (and they do)\n// then perhaps more will factor away and combine\n// I just want to do one cbrt here if at all possible\n// AHA! James Blinn's paper mentions this very thing\n// in the section on What could possibly go wrong?/Properly Solving the Embedded Quadratic\n// Blinn's key insight seems to be that, if the answer we seek is \n// p + q, both are cube roots, they're exchangeable because we only need the sum,\n// they only differ by the sign of the sqrt under the cbrt\n// but once you know one (p), the other you can find as simply q = -c/p\n// the only problem is that then you risk another division by zero\n// p+q = q-c/q\n// or q-l/q (remember Blinn factored 3's out)\n\n// TODO there's probably a way to combine the two cases into\n// one case by collapsing the circumcircle radius to zero.\n// I guess no because the 1-real root case is not necessarily at the inflection point.\n#endif\n\n\n\n#if 0\n// see Nickalls paper at http://nickalls.org/dick/papers/maths/cubic1993.pdf\n// \"A new approach to solving the cubic\"\n/*\nN = point of inflection of\ny = axÂ³ + bxÂ² + cx + d\nis root of 2nd derivative\nf(x) := a*x^3+b*x^2+c*x+d\ndiff(f(x),x)  ==>  3*a*x^2+2*b*x+c\ndiff(f(x),x,2) ==>  6*a*x+2*b\nsolve(diff(f(x),x,2), x)  ==>  x_N = -b/(3*a)\nx_N = -b/(3a)\ny_N = f(x_N) = a*(-b/(3a))^3+b*(-b/(3a))^2+c*-b/(3a)+d = d + (-9*a*b*c+2*b^3)/(27*a^2) = d + (2*b^3)/(27*a^2)-(b*c)/(3*a)\nx = z + x_N\nz = x - x_N\nazÂ³ âˆ’ 3ağ›¿Â²z + y_N = 0\nbut since we can easily make a=1 if we so choose,\nzÂ³ âˆ’ 3ğ›¿Â²z + y_N = 0\nrelative to N = (x_N,y_N), the sum of the 3 roots is 0\nz1 = ğ›¼ âˆ’ x_N , z2 = ğ›½ âˆ’ x_N , z3 = ğ›¾ âˆ’ x_N \nz1 + z2 + z3 = 0\nÎ´ = (bÂ² âˆ’ 3ac) / 9aÂ²\nğœ†Â² = 3ğ›¿Â²\nâ„ = 2ağ›¿Â³\nağ›¿ğœ†Â²/â„ = 3/2\nreferencing back to del Ferro's revelation folks seem to always use letters p and q\n(p + q)Â³ âˆ’ 3pq(p + q) âˆ’ (pÂ³ + qÂ³) = 0\npq = ğ›¿Â²\nz = p + q\npÂ³ + qÂ³ = âˆ’y_N/a\npÂ³ = 1/2a (âˆ’y_N Â± âˆšï¸(y_NÂ² âˆ’ 4aÂ²ğ›¿â¶))\npÂ³ = 1/2a (âˆ’y_N Â± âˆšï¸(y_NÂ² âˆ’ â„Â²))\ny_NÂ² <=> â„Â² determines number of solutions\nwhen y_NÂ² > â„Â², ğ›¼ = x_N + cbrt(1/2a (ï¸‚âˆ’y_N + âˆšï¸(y_NÂ² âˆ’ â„Â²))ï¸‚) + cbrt(1/2a (ï¸‚âˆ’y_N âˆ’ âˆšï¸(y_NÂ² âˆ’ â„Â²)ï¸‚))\nwhen y_NÂ² == â„Â²\nwhen y_NÂ² < â„Â²\ndl = delta = Î´ , lm = lambda = Î» , h = planck = â„\n*/\n// I guess mine sort of evolved from my attempt at implementing Nickalls,\n// but borrowed heavily from bloxard's solver I had before.\n#endif\n\n\n\n#if 1\n// spalmer converted Bloxard solver into depressed cubic solver\nvec3 CubicBloxard(float d, float c)\n{\n// x_N = b = 0.; a = 1.;\n\tfloat p = c;\n    float p3 = c*c*c; //p*p*p; // the only place you ever see p3 is in conjunction with this mystical 3Â³ = 27 quantity\n    float s = c*c*c/27.; // so give that thing a name! it's (c/3)Â³\n\tfloat q = d;\n\tfloat e = q*q + 4.*s; //p3/27.;\n\tif (e > 0.)\n\t{ \n\t\tfloat z = sqrt(e);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        if (abs(p) < .004)\n        { // credit: iq\n            float k = s/q; //p3/27./q;              // linear approx\n            //float k = (1.-s/(q*q))*s/q;  //(1.-p3/27./(q*q))*p3/27./q;  // quadratic approx \n            x = vec2(k,-k-q);\n        }\n\t\tvec2 j = cbrt(x); //sign(x) * pow(abs(x), vec2(1./3.));\n\t\treturn vec3(j.x + j.y, NaN, NaN);\n\t}\n\tfloat v = acos(-sqrt(-1./s) * q/2.) / 3.; //acos(-sqrt(-27./p3) * q/2.) / 3.; //\n\tfloat m = cos(v), n = sqrt(3.) * sin(v);\n\treturn vec3(-n - m, n - m, m + m) * sqrt(-p / 3.);\n}\n\n// Per Bloksgaard refactored\n// Find roots using Cardano's method.\n// http://en.wikipedia.org/wiki/Cubic_equation#Cardano%27s_method\n// by bloxard http://shadertoy.com/view/dsX3RM\n// a's and c's reversed vs traditional naming.\n// his a is my b, his b is my c, his c is my d,\n// I had to rename because it was driving me batty\n// also I swapped the argument order because that was also really confusing here\nvec3 CubicBloxard(vec3 K)\n{\n    float d = K.x, c = K.y, b = K.z; //, a = 1.; //\n\tfloat x_N = -b / 3.;\n\tfloat p = c-b*b/3., p3 = p*p*p;\n\tfloat q = b*(2.*b*b-9.*c)/27.+ d;\n\tfloat e = q*q + 4.*p3/27.; // discriminant is like 4x what wikipedia says\n\tif (e > 0.)\n\t{ \n\t\tfloat z = sqrt(e);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n        if (abs(p) < .004)\n        {\n            // When pâ‰ˆ0 and p<0, h-q has catastrophic cancelation. So, we do\n            // h=âˆš(qÂ²+4pÂ³)=qÂ·âˆš(1+4pÂ³/qÂ²)=qÂ·âˆš(1+w) instead. Now we approximate\n            // âˆš by a linear Taylor expansion into hâ‰ˆq(1+Â½w) so that the q's\n            // cancel each other in h-q. Expanding and simplifying further we\n            // get x=vec2(pÂ³/q,-pÂ³/q-q). And using a second degree Taylor\n            // expansion instead: x=vec2(k,-k-q) with k=(1-pÂ³/qÂ²)Â·pÂ³/q\n            //float kx = b/3., ky = c/3., kz = d; //float kx = b/3., ky = c/3., kz = d;\n            float P = c/3. - b*b/9.; //ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = b/3.*(2.*b/3.*b/3. - 3.*c/3.) + d; //kx*(2.*kx*kx - 3.*ky) + kz; // iq's q is scaled differently\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q);\n        }\n\t\tvec2 uv = sign(x) * pow(abs(x), vec2(1./3.));\n\t\treturn vec3(x_N + uv.x + uv.y, NaN, NaN);\n\t}\n\tfloat v = acos(-sqrt(-27./p3) * q/2.) / 3.;\n\tfloat m = cos(v), n = sqrt(3.) * sin(v);\n    // spalmer ordered 3 roots small to large\n\treturn vec3(-n - m, n - m, m + m) * sqrt(-p / 3.) + x_N;\n}\n#endif\n\n// see James Blinn http://courses.cs.washington.edu/courses/cse590b/13au/\n// which may in fact be where iq got the idea to factor out the 3's\n// whoa!  Blinn states that the 3 roots are simply (for the usual p,q)\n// and w = (sqrt(3)*i - 1)/2 a primitive cube root of unity \n// (p + q, w*p + w*w*q, w*w*p + w*q)\n// which must be where the end code of iq/bloxard style solvers comes from\n// anyway we only need the real parts, right?\n\n#if 1\n// convert iq's solver to depressed solver, then totally redo all the variable names\nvec3 Cubiciq(float d, float c)\n{\n    float p  = c / 3.,\n      s = p*p*p, // same name I used for mine I guess\n      h = d*d + 4.*s;\n    if (h >= 0.)  // 1 root\n    {   \n        h = sqrt(h);\n        vec2 u = .5*(vec2(h,-h) - d);\n        if (abs(p) < .001)\n        {\n            float k = s/d;  // linear approx\n        //  k *= 1. - k/d;  // quadratic approx \n            u = vec2(k, -k-d);  \n        }\n        u = sign(u) * pow(abs(u), vec2(1./3.));\n        return vec3(u.x + u.y, NaN, NaN);\n    }\n    float z = sqrt(-p),\n      v = acos(d/(p*z*2.)) / 3.,\n      m = cos(v),\n      n = sqrt(3.) * sin(v);\n    return vec3(-n-m,n-m,m+m) * z;\n}\n// getting real similar to mine now, especially the first part\n\n// convert iq's solver to depressed solver\nvec3 Cubiciq2(float d, float c)\n{\n    float p  = c / 3.;\n    float q  = d;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.*p3;\n    if (h >= 0.)  // 1 root\n    {   \n        h = sqrt(h);\n        vec2 u = .5*(vec2(h,-h)-q);\n        if (abs(p) < 0.001)\n        {\n            float k = p3/q;              // linear approx\n        //  float k = (1.-p3/q2)*p3/q;  // quadratic approx \n            u = vec2(k, -k-q);  \n        }\n        u = sign(u) * pow(abs(u), vec2(1./3.));\n        return vec3(u.x + u.y, NaN, NaN);\n    }\n    float z = sqrt(-p);\n    float v = acos(q/(p*z*2.)) / 3.;\n    float m = cos(v);\n    float n = sqrt(3.) * sin(v);\n    return vec3(-n-m,n-m,m+m) * z;\n}\n\n// spalmer extracted cubic solver from iq's http://shadertoy.com/view/DdlGD8\n//  (a == 1 always here)\n// iq's kx is -x_N compared to most of the rest\n// which means, what, he must have multiplied the whole thing by -3\n// Blinn style eh.\n// I can't stand his kx etc. coeff names, they are so confusing\n// so I'm swapping back to d, c, b, used vec3 coeff interface\n// FIXME c, b internal coeffs also off by a factor of 3\nvec3 Cubiciq(vec3 K)\n{\n    float d = K.x, c = K.y / 3., b = K.z / 3.;\n    float x_N = -b; // I renamed it once I figured out what it was, the inflection point\n    float p  = c - b*b;\n    float q  = b*(2.*b*b - 3.*c) + d;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.*p3;\n    vec3 r;\n    if (h >= 0.)  // 1 root\n    {   \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n      #if 0\n        // When pâ‰ˆ0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=âˆš(qÂ²+4pÂ³)=qÂ·âˆš(1+4pÂ³/qÂ²)=qÂ·âˆš(1+w) instead. Now we approximate\n        // âˆš by a linear Taylor expansion into hâ‰ˆq(1+Â½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(pÂ³/q,-pÂ³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-pÂ³/qÂ²)Â·pÂ³/q\n        if (abs(p) < 0.001)\n        {\n            float k = p3/q;              // linear approx\n        //  float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k, -k-q);  \n        }\n      #endif\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1./3.));\n        float t = uv.x + uv.y + x_N;\n        r = vec3(t, NaN, NaN);\n    } else {          // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.)) / 3.;\n        float m = cos(v);\n        float n = sqrt(3.0) * sin(v);\n        // re-order smallest first HACK by spalmer\n        r = vec3(-n-m,n-m,m+m)*z + x_N;\n    }\n    return r;\n}\n// from here http://shadertoy.com/view/3tsczH\n#endif\n\n#if 1\n// by mla http://shadertoy.com/view/mdsGDX\n// Solve depressed cubic xÂ³+px+q = 0 and return largest real root.\nfloat CubicMla(float p, float q)\n{\n  p /= 3.0;\n  float h = q*q + 4.0*p*p*p;              // Discriminant\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = -0.5*(q+sgn(q)*r);          // Largest magnitude root\n    float t = sgn(u)*pow(abs(u),1.0/3.0); // Cube root\n    return t - p/t;\n  } else {\n    // Find real part of 'principal' cube root of -q+ir\n    float theta = atan(r,-q);               // 0 <= theta < PI since r >= 0 -could use -r\n    return 2.0*sqrt(abs(p))*cos(theta/3.0); // Largest root\n  }\n}\n// it's nice, but only returns one root\n\n// more examples of mla, from http://shadertoy.com/view/cdjXR1\n// I reordered the results\n  // Solve xÂ³ + 3px + q = 0\n// this one uses trig\nint dcubic1mla(float p, float q, out vec3 roots)\n{\n  float h = q*q + 4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = -0.5*(q+sgn(q)*r); // Largest root of quadratic\n    float t = cbrt(u);\n    roots[0] = t - p/t;\n    return 1;\n  } else {\n    float a = atan(r,-q); // 0 <= a < PI\n    float k = 2.0*sqrt(abs(p));\n    roots = k*cos((a+pi*vec3(2,4,0))/3.0);\n    return 3;\n  }\n}\n// complex cuberoot of unity\nconst vec2 omega = 0.5*vec2(-1,sqrt(3.0));\nconst vec2 omega2 = omega*vec2(1,-1);\n// this one is all Newton-Raphson\nint dcubic2mla(float p, float q, out vec3 roots) \n{\n  float h = q*q+4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = 0.5*(-q-sgn(q)*r);\n    float t = cbrt(u);\n    roots[0] = t - p/t;\n    return 1;\n  } else {\n    float k = 2.0*sqrt(abs(p));\n    vec2 t = normalize(vec2(-q,r));\n    vec2 z = (t+vec2(1,0))/6.0;\n    for (int i = 0; i < 3; i++) {\n      z = normalize(z);\n      vec2 z2 = cmul(z,z);\n      z -= cdiv(cmul(z,z2)-t,3.0*z2);\n    }\n    roots = k*vec3(cmul(z,omega).x,cmul(z,omega2).x,z.x);\n    return 3;\n  }\n}\n// definitely need shims\nvec3 Cubicmla(float d, float c)\n{\n    vec3 r;\n    int n;\n    c /= 3.; // off by factor of 3\n    //r.x = CubicMla(d * 3., c); n = 1;\n    //n = dcubic1mla(c, d, r);\n    n = dcubic2mla(c, d, r);\n    if (n == 1) r.y = r.z = NaN;\n    return r;\n}\n// I'm still confused, but perhaps if I study it more, I'll grok better.\n#endif\n\n// by spalmer\n//vec3 CubicDepress(float d, float c, float b)\n//{\n//    float x = b/-3.; // inflection point\n//    return CubicDepressed((c - 2.*x*x)*x + d, c + b*x) + x;\n//}\n// basically just inlined this and factored out x a shorter name for x_N = inflection point\n// convert to depressed cubic strips out the squared factor b by shifting x axis to the inflection point\n// solving that depressed cubic and converting the results seems simpler.  Far simpler!\n/*\n//    return Cubiciq(vec3(d, c, b)); // sanity check.  Still sane here!\n    float x_N = b / -3.; //-1./3.*b; // locate inflection point\n    float y_N = (2./9.*b*b - c)/3. * b + d; //(27.*d-9.*b*c+2.*b*b*b)/27.; //((x_N+b)*x_N+c)*x_N+d; //\n  #if 1\n    // Wikipedia way, I had Maxima substitute t - b/3 for x and got\n    //(27*t^3 + (27*c-9*b^2)*t + 27*d-9*b*c+2*b^3)/27 = 0\n    // in Horner form it's\n    //((27*t*t+27*c-9*b^2)*t+27*d-9*b*c+2*b^3)/27=0\n    float q = y_N //d - 1./3.*b*c + 2./27.*b*b*b //(27.*d-9.*b*c+2.*b*b*b)/27. //\n    , p = c-b*b/3.; //(3.*c-b*b)/3.; //(27.*c-9.*b*b)/27.; // p = âˆ’ 3ğ›¿Â²\n    // seems like p is scaled by -1./3. so q probably is too\n  #else\n    // see Nickalls paper at http://nickalls.org/dick/papers/maths/cubic1993.pdf\n    // \"A new approach to solving the cubic\"\n    // substituting z = x - x_N\n    // results in depressed cubic in z\n    // zÂ³ âˆ’ 3ğ›¿Â²z + y_N = 0\n    float dldl = (b*b / 3. - c) / 3.; // Î´Â² = (bÂ² âˆ’ 3*c) / 9\n    float q = y_N, p = -3.*dldl; // duh, the 3's cancel\n  #endif\n*/\n/*\n(%i)\tratsimp(subst(t - b/(3*a), x, (((a*x + b)*x + c)*x + d) / a = 0));\n(%o)\t(27*a^3*t^3+(27*a^2*c-9*a*b^2)*t+27*a^2*d-9*a*b*c+2*b^3)/(27*a^3)=0\n\n(%i)\tratsimp(subst(t - b/3, x, ((x + b)*x + c)*x + d = 0));\n(%o)\t(27*t^3+(27*c-9*b^2)*t+27*d-9*b*c+2*b^3)/27=0\n*/\n\n// http://en.wikipedia.org/wiki/Cubic_equation \"General cubic formula\"\n// evaluated using complex arithmetic only as much as absolutely required.\n// apparently it has some major issues in certain configurations;\n// when plotted solving SDFs for quadric bezier curves, shows\n// a really really bad discontinuity right where iq's fix for\n// catastrophic cancellation using taylor series expansion there.\n// solve reduced cubic ((x + b)*x + c)*x + d = 0\n//vec3 CubicOld(float d, float c, float b)\nvec3 CubicOld(vec3 k)\n{\n    float d = k.x, c = k.y, b = k.z;\n    float h = 27.\n    , o = -1./3.\n    , p = b*b - 3.*c\n    , j = (2.*b*b - 9.*c) * b\n    , q = j + h*d\n    , g = q*q - 4.*p*p*p // discriminant\n    ;\n    vec3 r;\n    if (g > 0.) { // 1-root case all real arithmetic\n        // FIXME why the f did I pick y as a variable name\n        float y = .5*(q + sqrt(g)), z = sign(y) * pow(abs(y), 1./3.); //scbrt(y);\n        r = vec3((b + z + p/z) * o, NaN, NaN);\n    } else { // 3-root case requires complex arithmetic\n        const vec2 E = vec2(-.5, sqrt(.75)); // primitive cube root of complex unity\n        vec2 u = vec2(q, sqrt(-g)) // q +- sqrt(-g) complex result\n        , C = sin(vec2(acos(0.), 0.) + atan(u.y, u.x) / 3.) \n            * pow(.25 * dot(u, u), 1./6.) // inlined trigonometry\n        , s1 = vec2(E.x * C.x - E.y * C.y\n                  , E.x * C.y + E.y * C.x)\n        , s0 = vec2(E.x * C.x + E.y * C.y\n                  , E.x * C.y - E.y * C.x);\n        r = (vec3(\n            (1. + p / dot(C , C )) * C .x,\n            (1. + p / dot(s0, s0)) * s0.x,\n            (1. + p / dot(s1, s1)) * s1.x\n          ) + b) * o;\n    }\n    return r;\n}\n// developed at http://shadertoy.com/view/Ns2XRd\n\n/*\n// substituting z = x - x_N where x_N = -b/3a gives\n(%i12)\t((x + b)*x + c)*x + d = 0;\n(%o12)\tx*(x*(x+b)+c)+d=0\n(%i13)\tsubst(z + x_N, x, %);\n(%o13)\t(z+x_N)*((z+x_N)*(z+x_N+b)+c)+d=0\n(%i14)\tratsimp(%);\n(%o14)\tz^3+(3*x_N+b)*z^2+(3*x_N^2+2*b*x_N+c)*z+x_N^3+b*x_N^2+c*x_N+d=0\n(%i22)  horner(%, z);\n(%o22)\tz*(z*(z+3*x_N+b)+x_N*(3*x_N+2*b)+c)+x_N*(x_N*(x_N+b)+c)+d=0\n(%i29)\tsubst(-b/3, x_N, %o22);\n(%o29)\tz*(z^2+c-b^2/3)+d-(b*(c-(2*b^2)/9))/3=0\n(%i30)\thorner(%, z);\n(%o30)\t(z*(27*z^2+27*c-9*b^2)+27*d-9*b*c+2*b^3)/27=0\nI think that'll do!\n*/\n    // that's still not an easy nut to crack though\n    // but it's a reduced cubic equation in z (notice no z^2 factor)\n    // at very least at this point I have the interface\n    // to convert a general cubic into a reduced cubic \n    // which many other solvers you see use such form \n    // and require eqn to be posed in such way already.\n/*\n ((27*z^2 + 27*c-9*b^2)*z + 27*d-9*b*c+2*b^3)/27 = 0\n ((27*z^2 + 27*c-9*b^2)*z/27 + (27*d-9*b*c+2*b^3)/27) = 0\n ((z^2 + (27*c-9*b^2)/27)*z + d + (-9*b*c+2*b^3)/27) = 0\n ((z^2 + c + -1/3*b^2)*z + d + (-9*c+2*b^2)*b/27) = 0\n*/\n/*\nsolve(zÂ³ âˆ’ 3*ğ›¿Â²*z + y_N = 0, z);\n  [\n z=((-1)/2-(sqrt(3)*%i)/2)*(sqrt(y_N^2-4*ğ›¿^6)/2-y_N/2)^(1/3)+(((sqrt(3)*%i)/2+(-1)/2)*ğ›¿^2)/(sqrt(y_N^2-4*ğ›¿^6)/2-y_N/2)^(1/3)\n,z=((sqrt(3)*%i)/2+(-1)/2)*(sqrt(y_N^2-4*ğ›¿^6)/2-y_N/2)^(1/3)+(((-1)/2-(sqrt(3)*%i)/2)*ğ›¿^2)/(sqrt(y_N^2-4*ğ›¿^6)/2-y_N/2)^(1/3)\n,z=(sqrt(y_N^2-4*ğ›¿^6)/2-y_N/2)^(1/3)+ğ›¿^2/(sqrt(y_N^2-4*ğ›¿^6)/2-y_N/2)^(1/3)\n]\n// think Nickalls has further tricks for reducing those\n// anyway then just take those 3 results and shift by x_N to obtain the roots of the full equation\n*/\n\n#if 0\n// solving the cubic has a long and sordid history.\n// it's way harder than it looks!\n// Cardano called these q and p though, and instead of x used t\n// actually discovered by del Ferro, rediscovered by Tartagli, \n// later published by Cardano and usually attributed thus.\n// http://en.wikipedia.org/wiki/Cubic_equation#Cardano%27s_method\n// solve tÂ³ + p*t + q = 0\nvec3 CubicCardano(float q, float p)\n{\n// introduce variables u, v such that u + v = t, substitute, giving\n//    uÂ³ + vÂ³ + (3*u*v+p)*(u+v) + q = 0 \n// impose condition 3uv + p = 0, removing third term, leading to\n//    uÂ³ + vÂ³ = âˆ’q\n//    u*v = âˆ’p/3\n// Knowing sum and product of uÂ³ and vÂ³, deduce that they are the solutions\n//    (x-uÂ³)(x-vÂ³) = xÂ²-(uÂ³+vÂ³)x+uÂ³vÂ³ = xÂ²-(uÂ³+vÂ³)x+(uv)Â³ = 0\n// so\n//    xÂ² + q*x âˆ’ pÂ³/27 = 0\n// discriminant is Î” = qÂ² + 4*pÂ³/27, and assuming it is positive,\n// real solutions are:\n//    âˆ’ q/2 Â± sqrt(qÂ²/4 + pÂ³/27)\n// So (without loss of generality in choosing u or v):\n//    u = cbrt(-q/2 + âˆšï¸{qÂ²/4+pÂ³/27))\n//    v = cbrt(-q/2 - âˆšï¸{qÂ²/4+pÂ³/27))\n// As u + v = t, the sum of the cube roots of these solutions is a root of the equation. That is,\n//    t = cbrt(-q/2 + âˆšï¸(qÂ²/4+pÂ³/27))\n//      + cbrt(-q/2 - âˆšï¸(qÂ²/4+pÂ³/27))\n    float qq = q*q;\n    float p3 = p*p*p;\n    float q_n2 = q/-2.;\n    float r = sqrt(qq/4. + p3/27.);\n    float d = 4.*p3 + 27.*qq;\n    if (d > 0.) {\n        float t0 = cbrt(q_n2 + r)\n                 + cbrt(q_n2 - r);\n        return vec3(t0,NaN,NaN);\n    }\n// else need transcendentals or imaginary numbers.\n// Product of the two cube roots must be â€“p / 3. \n// It results that a root of the equation is\n//    C âˆ’ p/(3*C) with C = cbrt(âˆ’q/2 + sqrt(qÂ²/4 + pÂ³/27))\n// In this formula, the symbols sqrt and cbrt\n// denote any square root and any cube root.\n// The other roots of the equation are obtained\n// either by changing of cube root or, equivalently,\n// by multiplying the cube root by a primitive\n// cube root of unity, that is (âˆ’1 Â± âˆšï¸(âˆ’3)) / 2\n// cbrt(âˆ’q/2 + sqrt(qÂ²/4 + pÂ³/27))\n    float t1 = cbrt(q_n2 + r);\n    float t2 = cbrt(q_n2 - r);\n    float t3 = cbrt(q_n2 + q_n2); // so confused here\n    vec3 a = vec3(t1,t2,t3);\n    return a - p / (3.*a);\n}\n// Nickalls mentioned that they used ğº = y_NÂ² and ğ»=-ğ›¿Â² quantities\n// and that they began with equation with b and c divided by 3?!!\n// perhaps that's where Inigo got his method.  It might be more Cardano than the others!\n/*\nğ‘ğ‘¥Â³ + 3ğ‘_1ğ‘¥Â² + 3ğ‘_1ğ‘¥ + ğ‘‘ = 0,\nand then substituting ğ‘¥ = ğ‘§ âˆ’ ğ‘_1/ğ‘ to generate a reduced equation of the form\nğ‘ğ‘§Â³ + 3ğ»/ğ‘*ğ‘§ + ğº/ğ‘Â² = 0,\nwhere\nğ» = ğ‘ğ‘_1 âˆ’ ğ‘_1Â² and ğº = ğ‘Â²ğ‘‘ âˆ’ 3ğ‘ğ‘_1ğ‘_1 + 2ğ‘_1Â³\nSubsequent development yields a discriminant of the form ğºÂ² + 4ğ»Â³\n*/\n// I give up, haven't gotten it working yet, \n// and figure since it's not ideal, am wasting time on it.\n#endif\n\n#if 0\n// should try ViÃ¨te's approach TODO\n// http://en.wikipedia.org/wiki/Cubic_equation#Vieta's_substitution\n// substite t = w - p/3w transforms depressed cubic into\n//    wÂ³ + q - pÂ³/27wÂ³ = 0\n// Multiplying by w3, one gets a quadratic equation in wÂ³:\n//    (wÂ³)Â² + q*wÂ³ - pÂ³/27 = 0\n// Let\n//    W = -q/2 Â± âˆšï¸(pÂ³/27 + qÂ²/4)\n// be any nonzero root... then I get lost how to convert back to actual root\nvec3 CubicVieta(float q, float p)\n{\nreturn vec3(0);\n    //float p_3 = p/3.;\n    // w = t + p_3*(t + p_3);\n    // t = w - p_3*w;\n    //return vec3(w0,w1,w2)\n}\n// meh, all this substitution just confuses me greatly\n// this is the problem with math on Wikipedia and\n// pretty much all published math, that it's basically all\n// just disjointed ramblings throwing letters around willy-nilly\n// introducing variables at a whim and expecting the reader\n// to keep it all straight.  It's like programming in some\n// really terribly ambiguous programming language, where\n// the programmer decides to change the meaning and type of variables\n// and may, if you're lucky, decide to document it in the comments.\n// Implementation left as an exercise to the reader.  Bah.\n#endif\n\n#if 0\n// bunch of solvers salvaged from Bezier Quadric at http://shadertoy.com/view/3tsczH\n\n// spalmer converted Bloxard solver into depressed cubic solver\nvec3 CubicBloxard(float d, float c)\n{\n// x_N = b = 0.; a = 1.;\n\tfloat p = c;\n    float p3 = c*c*c; //p*p*p; // the only place you ever see p3 is in conjunction with this mystical 3Â³ = 27 quantity\n    float s = c*c*c/27.; // so give that thing a name! it's (c/3)Â³\n\tfloat q = d;\n\tfloat e = q*q + 4.*s; //p3/27.;\n\tif (e > 0.)\n\t{ \n\t\tfloat z = sqrt(e);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        if (abs(p) < .004)\n        { // credit: iq\n            float k = s/q; //p3/27./q;              // linear approx\n            //float k = (1.-s/(q*q))*s/q;  //(1.-p3/27./(q*q))*p3/27./q;  // quadratic approx \n            x = vec2(k,-k-q);\n        }\n\t\tvec2 j = cbrt(x); //sign(x) * pow(abs(x), vec2(1./3.));\n\t\treturn vec3(j.x + j.y, NaN, NaN);\n\t}\n\tfloat v = acos(-sqrt(-1./s) * q/2.) / 3.; //acos(-sqrt(-27./p3) * q/2.) / 3.; //\n\tfloat m = cos(v), n = sqrt(3.) * sin(v);\n\treturn vec3(-n - m, n - m, m + m) * sqrt(-p / 3.);\n}\n// cleaned but FIXME now the interface is backwards for this toy, which means this toy is wrong\nvec3 CubicBloxard(vec3 K)\n{\n    float d = K.x, c = K.y, b = K.z; //, a = 1.; //\n\tfloat x_N = -b / 3.;\n\tfloat p = c-b*b/3., p3 = p*p*p;\n\tfloat q = b*(2.*b*b-9.*c)/27.+ d;\n\tfloat e = q*q + 4.*p3/27.; // discriminant is like 4x what wikipedia says\n\tif (e > 0.)\n\t{ \n\t\tfloat z = sqrt(e);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n        if (true && abs(p) < .004)\n        {\n            // When pâ‰ˆ0 and p<0, h-q has catastrophic cancelation. So, we do\n            // h=âˆš(qÂ²+4pÂ³)=qÂ·âˆš(1+4pÂ³/qÂ²)=qÂ·âˆš(1+w) instead. Now we approximate\n            // âˆš by a linear Taylor expansion into hâ‰ˆq(1+Â½w) so that the q's\n            // cancel each other in h-q. Expanding and simplifying further we\n            // get x=vec2(pÂ³/q,-pÂ³/q-q). And using a second degree Taylor\n            // expansion instead: x=vec2(k,-k-q) with k=(1-pÂ³/qÂ²)Â·pÂ³/q\n            //float kx = b/3., ky = c/3., kz = d; //float kx = b/3., ky = c/3., kz = d;\n            float P = c/3. - b*b/9.; //ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = b/3.*(2.*b/3.*b/3. - 3.*c/3.) + d; //kx*(2.*kx*kx - 3.*ky) + kz; // iq's q is scaled differently\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q);\n        }\n\t\tvec2 uv = sign(x) * pow(abs(x), vec2(1./3.));\n\t\treturn vec3(x_N + uv.x + uv.y, NaN, NaN);\n\t}\n\tfloat v = acos(-sqrt(-27./p3) * q/2.) / 3.;\n\tfloat m = cos(v), n = sqrt(3.) * sin(v);\n    // spalmer ordered 3 roots small to large\n\treturn vec3(-n - m, n - m, m + m) * sqrt(-p / 3.) + x_N;\n}\n\n// trigonometric solver by bloxard, golfed by Fabrice, ungolfed & cleaned by spalmer\n// http://shadertoy.com/view/XdB3Ww\nvec2 solveCubicfablox(vec3 v) // 4th coeff is always 1.0, must normalize equation thus\n{\n    float a = v.x, b = v.y, c = v.z\n    , f = -1./3. * a // was called ofs before\n\t, p  = b + a*f\n\t, p3 = p*p*p\n    // TODO p3/27. comes up at least twice, once inverted\n\t, q  = 1./27. * a * (2.*a*a - 9.*b) + c\n\t, d  = q*q + 4./27. * p3;    \n\tif (d > 0.) {\n\t\tvec2 x = (vec2(1,-1) * sqrt(d) - q) * .5;\n\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n        if (abs(p) < .004)\n        {\n            //float p  = ky - kx*kx;\n            //float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n            // When pâ‰ˆ0 and p<0, h-q has catastrophic cancelation. So, we do\n            // h=âˆš(qÂ²+4pÂ³)=qÂ·âˆš(1+4pÂ³/qÂ²)=qÂ·âˆš(1+w) instead. Now we approximate\n            // âˆš by a linear Taylor expansion into hâ‰ˆq(1+Â½w) so that the q's\n            // cancel each other in h-q. Expanding and simplifying further we\n            // get x=vec2(pÂ³/q,-pÂ³/q-q). And using a second degree Taylor\n            // expansion instead: x=vec2(k,-k-q) with k=(1-pÂ³/qÂ²)Â·pÂ³/q\n            float kx = a/3., ky = b/3., kz = c;\n            float P = ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = kx*(2.*kx*kx - 3.*ky) + kz; // iq's q is scaled differently\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q); //-k-Q, k); //\n            //x += .67*f*f*f;\n        }\n\n        x = sign(x) * pow(abs(x), vec2(1./3.));\n        // FIXME now just need to consolidate these two tests on different sides of the cbrt into one codepath\n        if (abs(p) < .004)\n            return vec2(x.x + x.y - a/3., NaN);\n  \t\treturn vec2(x.x + x.y + f, NaN);\n  \t}\n \tfloat w = acos(max(-1., -sqrt(max(0., -27./p3))*q*.5)) / 3.,\n \t      m = cos(w);\n\treturn vec2(m+m, -sqrt(3.)*sin(w)-m) * sqrt(-p/3.) + f;\n}\n// \t      n = sin(w)*sqrt(3.);\n//\treturn vec2(m+m,-n-m) * sqrt(-p/3.) + ofs; // old extra temporary used once\n\n// Finds roots using Cardano's method. http://wikipedia.org/wiki/Cubic_equation#Cardano's_formula\n// Apparently, must have got the idea to solve Cardano's method using trigonometry \n// from Vieta http://wikipedia.org/wiki/Cubic_equation#Trigonometric_and_hyperbolic_solutions\n// due to the presence of 27./p3, but perhaps this precise trig solution came later.\n\n// Per Bloksgaard refactored\n// Find roots using Cardano's method.\n// http://en.wikipedia.org/wiki/Cubic_equation#Cardano%27s_method\n// by bloxard http://shadertoy.com/view/dsX3RM\n// a's and c's reversed vs traditional naming.\nvec2 solveCubic2(float a, float b, float c)\n{\n\tfloat p = b-a*a/3., p3 = p*p*p;\n\tfloat q = a*(2.*a*a-9.*b)/27.+ c;\n\tfloat d = q*q + 4.*p3/27.;\n\tfloat offset = -a / 3.;\n\tif(d>0.)\n\t{ \n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z,-z) - q) * .5;\n        // credit: iq from comment at http://shadertoy.com/view/dsfGWN \n        // led me back to http://shadertoy.com/view/MlKcDD\n        if (abs(p) < .004)\n        {\n            // When pâ‰ˆ0 and p<0, h-q has catastrophic cancelation. So, we do\n            // h=âˆš(qÂ²+4pÂ³)=qÂ·âˆš(1+4pÂ³/qÂ²)=qÂ·âˆš(1+w) instead. Now we approximate\n            // âˆš by a linear Taylor expansion into hâ‰ˆq(1+Â½w) so that the q's\n            // cancel each other in h-q. Expanding and simplifying further we\n            // get x=vec2(pÂ³/q,-pÂ³/q-q). And using a second degree Taylor\n            // expansion instead: x=vec2(k,-k-q) with k=(1-pÂ³/qÂ²)Â·pÂ³/q\n            float kx = a/3., ky = b/3., kz = c;\n            float P = ky - kx*kx;\n            float P3 = P*P*P;\n            float Q = kx*(2.*kx*kx - 3.*ky) + kz; // iq's q is scaled differently\n            float k = P3/Q;              // linear approx\n            //float k = (1.-P3/(Q*Q))*P3/Q;  // quadratic approx \n            x = vec2(k,-k-Q);\n        }\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn vec2(offset + uv.x + uv.y);\n\t}\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*sqrt(3.); //1.732050808;\n\treturn vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\nvec2 solveCubicBloxard(vec3 v)\n{\n    return solveCubic2(v.x, v.y, v.z);\n}\n// same glitch though\n\n// neat.  But doesn't solve the glitch.\n// Kohler  below\n// note that the cos(acos(theta)/3.) stuff is due to \n// the arrangement of the solutions on an equilateral \n// triangle inscribed in a circle centered on the Mid(curve) point!!!\n// a trigonometric solver by JohanKohler at http://shadertoy.com/view/Md3XD4\n// (possibly actually his friend Adrian Stephens) \n// approximates cos,sin of (acos(x)/3.)\nvec2 cossin_third(float x) \n{\n  #if 1 \n    // polynomial aproximation of cos(acos(x)/3)\n    float c = (((.0161423 * x + .431996) * x + 1.25203) * x + .866017)\n        / ((.312933 * x + 1.25325) * x + 1.);\n    // FIXME horner - compiler will optimize anyway\n    //float c = (.866017 + 1.25203 * x + .431996 * x * x + .0161423 * x * x * x)\n    //    / (1. + 1.25325 * x + .312933 * x * x);\n  #else\n    // honestly, the compiler implements acos\n    // using a similar polynomial anyway!\n    float c = cos(acos(x)/3.);\n  #endif\n    float s = sqrt(1. - c * c); // btw sin(x) = sqrt(1.-cos(x)*cos(x))\n    return vec2(c, s);\n} // either way, has same bug :( otherwise I'd consider extracting wrapper for use by others\n// see also iq http://shadertoy.com/view/WltSD7\n// I believe Kohler's spline setup was derived from bloxard's.\n// Solve cubic equation for roots - Kohler involved too?\nvec3 solveCubicStephens(vec3 v)\n{\n    float a = v.x, b = v.y, c = v.z\n    , f = a / -3.\n    , p = b + a*f\n    , p3 = p*p*p\n    , q = a * (2.*a*a - 9.*b) / 27. + c\n    , d = q*q + 4.*p3 / 27.;    \n    if (d >= 0.) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.;\n        x = sign(x)*pow(abs(x), vec2(1./3.));\n        return vec3(f + x.x + x.y);\n    }    \n    vec2 cs = cossin_third(-sqrt(-27. / p3) * q / 2.);\n    float m = cs.x, n = cs.y * sqrt(3.);\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.) + f;\n}\n\n// my stab at it from http://shadertoy.com/view/flyGDD\n// apparently has its own special issues!\n// yeah it has some real problems, all right.  Worse than bloxard's, for sure.\n// TODO wth do these letters mean anyway?  document coeff order!!!\nfloat Linear(float b, float a)\n{\n    return -b / a;\n}\n\nvec2 Quadratic(float c, float b, float a)\n{\n    if (a == 0.)\n        return vec2(Linear(c, b), NaN); // handle malformed eqn\n    float n = b * b - 4. * a * c; // discriminant\n    return n < 0. ? vec2(NaN) :\n        .5 / a * (sign(a) * sqrt(n) * vec2(-1, 1) - b); // two solutions, lesser first (may be identical)\n}\n// http://en.wikipedia.org/wiki/Cubic_equation \"General cubic formula\"\n// evaluated using complex arithmetic only as much as absolutely required.\nvec3 Cubic(float d, float c, float b, float a)\n{\n    if (a == 0.)\n        return vec3(Quadratic(d, c, b), NaN); // handle malformed eqn\n    float h = 27.*a*a\n    , o = -1./3./a\n    , p = b*b - 3.*a*c\n    , j = (2.*b*b - 9.*a*c) * b\n    , q = j + h*d\n    , g = q*q - 4.*p*p*p // discriminant\n    ;\n    vec3 r;\n    if (g > 0.) { // 1-root case all real arithmetic\n        float y = .5*(q + sqrt(g)), z = sign(y) * pow(abs(y), 1./3.); //scbrt(y);\n        r = vec3((b + z + p/z) * o, NaN, NaN);\n    } else { // 3-root case requires complex arithmetic\n        const vec2 E = vec2(-.5, sqrt(.75)); // primitive cube root of complex unity\n        vec2 u = vec2(q, sqrt(-g)) // q +- sqrt(-g) complex result\n        , C = sin(vec2(acos(0.), 0.) + atan(u.y, u.x) / 3.) // cossin_third stuff\n            * pow(.25 * dot(u, u), 1./6.) // inlined trigonometry\n        //; \n        //mat2 M = mat2(E * vec2(1,-1), E.yx); vec2\n        //  s1 = M * C\n        //, s0 = C * M;\n        , s0 = vec2(E.x * C.x - E.y * C.y\n                  , E.x * C.y + E.y * C.x)\n        , s1 = vec2(E.x * C.x + E.y * C.y\n                  , E.x * C.y - E.y * C.x);\n        r = (vec3( // these max did not help btw\n            (1. + p / max(1e-7, dot(C , C ))) * C .x,\n            (1. + p / max(1e-7, dot(s0, s0))) * s0.x,\n            (1. + p / max(1e-7, dot(s1, s1))) * s1.x\n          ) + b) * o;\n        if (a < 0.)\n            r.xz = r.zx; // order 3-root case\n    }\n    return r;\n}\n// well I'll be damned if mine doesn't have an even *worse* glitch at the same damn place!!!\nvec3 solveCubicspalmer(vec3 v)\n{\n    return Cubic(v.z, v.y, v.x, 1.);\n}\n\n// spalmer extracted cubic solver from iq's http://shadertoy.com/view/DdlGD8\n// The MIT License\n// Copyright Â© 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// (cubic coeff == 1 always here)\n// the cubic is a bit different at this point than for the usual cubic solver formulation\n// TODO clean all this up and re-optimize\nvec3 solveCubiciq(vec3 c)\n{\n    float kx = c.z, ky = c.y, kz = c.x;\n    float p  = ky - kx*kx;\n    float q  = (2.0*kx*kx - 3.0*ky)*kx + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n    vec3 r;\n    if (h >= 0.)  // 1 root\n    {\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h) - q)/2.0;\n\n      #if 1\n        // When pâ‰ˆ0 and p<0, h-q has catastrophic cancellation. So, we do\n        // h=âˆš(qÂ²+4pÂ³)=qÂ·âˆš(1+4pÂ³/qÂ²)=qÂ·âˆš(1+w) instead. Now we approximate\n        // âˆš by a linear Taylor expansion into hâ‰ˆq(1+Â½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(pÂ³/q,-pÂ³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-pÂ³/qÂ²)Â·pÂ³/q\n        if (abs(p) < 0.001)\n        {\n            float k = p3/q;              // linear approx\n        //  float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k, -k-q);  \n        }\n      #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x+uv.y-kx;\n        r = vec3(t, NaN, NaN); //t, t, t); //t, 0., 1.); //\n    } else {          // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sqrt(3.0)*sin(v);\n        r = vec3(m+m, -n-m, n-m)*z - kx;\n        // third root can never be closest, though\n    }\n    return r;\n}\n// solve ((t + k.z)*t + k.y)*t + k.x = 0 for t\nvec3 solveCubicspalmeriq(vec3 k)\n{\n    k = vec3(k.x, k.y / 3., k.z / 3.); // convert coeffs for use by iq special solver\n    return solveCubiciq(k);\n}\n// should inline all that\n#endif\n\n// choose cubic equation solver method,\n// specialized to return only the two closer of 3 possible real roots\n// as parametric indices to the equation\n// solve ((t + a.z)*t + a.y)*t + a.x = 0 for t\n// OLD old shim interface, shouldn't need it anymore at all\nvec2 solveCubicReal(vec3 a)\n{\n    return CubicBloxard(a).zx;\n//    return solveCubicspalmeriq(a).xy;\n//    return solveCubicfablox(a.zyx);\n//    return solveCubicStephens(a.zyx).xy;\n//    return solveCubicBloxard(a.zyx);\n//    return solveCubicspalmer(a.zyx).xy;\n}\n// think those all (mostly) work now\n\n\n/*\n// numeric display based on https://shadertoy.com/view/llySRh\n// for debugging the coeffs that break the algo\n#define Font iChannel0\nfloat char(vec2 p, int c)\n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.)\n        return 0.;\n    vec2 q = p/16. + fract(vec2(c, 15-c/16) / 16.);\n    vec4 t = textureLod(Font, q, 0.);\n    // probably not perfect but seems ok\n    float scale = 64./(1.+dot(fwidth(q), vec2(1))); //(abs(dFdx(q.x))+abs(dFdy(q.y))); //length(fwidth(p)); //\n    scale = clamp(scale, 1./1024., 1024.);\n    float g = t.a; // a unorm-encoded signed distance\n    g = .5 - (g - .5) * scale; // antialiasing\n    g = clamp(g, 0., 1.);\n    return g;\n}\n    //float w = scale/16.;// /iResolution.y; //.05; //\n    //g = clamp(.5 - 1./w * (t.w-.5), 0., 1.); //\n    //g = smoothstep(.5+w,.5-w, t.w); // aa sdf - could probably do pixel perfect with a bit more effort\n    //g = clamp(.5 - (t.w - .5) * 8./scale; // yeah but we need scale info, maybe do the scaling here?\n\n// display unsigned int up to 4 digits base 10\nfloat pUint(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n); i > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    if (abs(n) < 1e-7)\n        v += char(p, 48);\n    return v;\n}\n\n// display unsigned int 4 digits base 10\nfloat pUint4(vec2 p, float n)\n{\n    float v = 0.;\n    for (int i = int(n), d = 4; d-- > 0; i /= 10, p.x += .5)\n        v += char(p, 48 + i%10);\n    return v;\n}\n\nfloat pSign(vec2 p, inout float n)\n{\n    float v = 0.;\n    if (n < 0.) v += char(p + vec2(.5,0), 45), n = -n;\n    return v;\n}\n\n// display signed int4\nfloat pInt(vec2 p, float n)\n{\n    float v = 0.;\n    v += pSign(p, n); // p.x -= 2.;\n    v += pUint(p, n);\n    return v;\n}\n\n// display signed float4.4\nfloat pFloat(vec2 p, float n)\n{\n    float v = 0.;\n    v += pSign(p, n); p.x -= 2.;\n    v += pUint(p, floor(n)); p.x -= .5;\n    v += char(p, 46); p.x -= 2.;\n    v += pUint4(p, fract(n)*1e4);\n    return v;\n}\n*/\n\n    /*if (true)\n    {\n        c = vec4(0,0,0,1);\n             if (p.y <  60.) c += pFloat((p - vec2(0,  0))/60., coeff[0]);\n        else if (p.y < 120.) c += pFloat((p - vec2(0, 60))/60., coeff[1]);\n        else if (p.y < 180.) c += pFloat((p - vec2(0,120))/60., coeff[2]);\n        else if (p.y < 240.) c += pFloat((p - vec2(0,180))/60., coeff[3]);\n        return;\n    }*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}