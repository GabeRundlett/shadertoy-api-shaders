{
    "Shader": {
        "info": {
            "date": "1574274998",
            "description": "This adapts my previous self-avoiding random walk to support indexing without any new buffers (https://www.shadertoy.com/view/wdySWm). Texture calls are repeated in this implementation to illustrate how the indexing is separate from the path generation.",
            "flags": 32,
            "hasliked": 0,
            "id": "wdySRy",
            "likes": 20,
            "name": "Indexed Space Fill Random Path",
            "published": 3,
            "tags": [
                "random",
                "curve",
                "saw",
                "walk",
                "avoid",
                "spacefill"
            ],
            "usePreview": 0,
            "username": "mathmasterzach",
            "viewed": 635
        },
        "renderpass": [
            {
                "code": "//Self-Avoiding Random Road\n//Author: @mathmasterzach\n//Feel free to ask any questions about the code or suggest improvements\n//Try changing the GRID_SIZE and GRID_ZOOM in the common tab\n\n//Big thanks to Shane and FabriceNeyret2 for suggestions, optimizations, and bug fixes!\n\nvoid mainImage(out vec4 O,in vec2 U){\n    vec2  R=iResolution.xy,\n          p=GRID_SIZE*(GRID_ZOOM*(2.*U-R)/R.y+.5),\n    \t  q=2.*fract(2.*p)-1.,\n          s=sign(.5-fract(p)); \n    float e=4.*GRID_ZOOM*GRID_SIZE/R.y,\n          c=-1.,\n          m=0.;\n    \n    int flags=int(texelFetch(iChannel0,ivec2(mod(p,GRID_SIZE)),0).x),\n           gx=flags&(s.x>0.?1:4), \n           gy=flags&(s.y>0.?2:8);\n    if(gx>0) if(gy>0) c=1.-length(q+=s),m=fract((3.14+atan(q.y,q.x))/1.57);\n              else    c=q.y,m=fract(-s.y*2.*p.x); \n    else     if(gy>0) c=q.x,m=fract(s.x*2.*p.y); \n              else    c=1.-length(q-=s),m=1.-fract((3.14+atan(q.y,q.x))/1.57);\n \n    c=.5-abs(c);\n        \n    vec2 b=texelFetch(iChannel0,ivec2(mod(p,GRID_SIZE)),0).yz;\n    vec4 eb=vec4(mod(b.x,TOTAL_INDEX),floor(b.x/TOTAL_INDEX),floor(b.y/TOTAL_INDEX),mod(b.y,TOTAL_INDEX));\n    s=round(fract(p));\n    m+=mod(float(iFrame)/2.,TOTAL_INDEX)-eb[int(s.x+2.*s.y)];\n    O=vec4(1.,0.,1.,0.)*(smoothstep(-e,e,min(c+.2,m))-.5*float(p.x<0.||p.x>GRID_SIZE||p.y<0.||p.y>GRID_SIZE));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Maze Generation Tab\n//Uses the lowest 4 bits to represent the 4 directions\n//Use the next two channels to hold the 4 corner indexes\n\n#define P(x,y) ivec2(mod(vec2(x,y)+U,GRID_SIZE))\n#define g(x,y) texelFetch(iChannel0,P(x,y),0).r\n#define r(x,y) int(4.*hash13(vec3(P(x,y),iTime+iDate.a)))\n#define V(i) g((1-i&1)*(i-1),(i&1)*(i-2))\n#define W(i) int(r((1-i&1)*(i-1),(i&1)*(i-2)))\n\n#define Q(e) vec4(mod(e.x,TOTAL_INDEX),floor(e.x/TOTAL_INDEX),\\\n                  mod(e.y,TOTAL_INDEX),floor(e.y/TOTAL_INDEX))\n\n//Thanks to Dave_Hoskins for the fantastic hash functions!\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3){\n    p3=fract(p3*.1031);\n    p3+=dot(p3,p3.yzx+19.19);\n    return fract((p3.x+p3.y)*p3.z);\n}\nvec2 hash21(float p){\n    vec3 p3=fract(vec3(p)*vec3(.1031,.1030,.0973));\n    p3+=dot(p3,p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//Proper Looping Maze Generation (on a torus)\n//Based on an older project of mine, but now much faster and with guaranteed correctness\n//With optimizations and simplifications by FabriceNeyret2\nvoid mainImage(out vec4 O,in vec2 U){\n    if(iFrame%int(TOTAL_INDEX*2.)==0){\n        O.x=.1*float(U-.5==ceil(hash21(iTime)*(GRID_SIZE-2.)));\n        O.yz=vec2(0.);\n        return; \n    }\n    vec2 R=iResolution.xy;\n    float a=g(0,0);\n    vec2 b=texelFetch(iChannel0,ivec2(U),0).yz;\n    vec4 eb=Q(b);\n    if(a==0.){\n        int i=(r(0,0)+2)%4;\n        if(V(i)>0.){a=float(1<<i);}\n    }else{\n        for(int i=0;i<4;i++){\n            if(V(i)==0.&&W(i)==i){a+=float(1<<i);}\n            if(ceil(a)-a<.5||i>0){\n                if((int(a)&(1<<i))==0){\n                    eb[i]=eb[(i+3)%4]+1.;\n                }else{\n                    vec2 tb=texelFetch(iChannel0,ivec2(mod(U+vec2(i==2,i==3)-vec2(i==0,i==1),GRID_SIZE)),0).yz;\n                    vec4 teb=Q(tb);\n                    eb[i]=teb[(i+1)%4]+1.;\n                }\n            }\n        }\n    }\n    b=TOTAL_INDEX*eb.yw+eb.xz;\n    O.x=a;\n    O.yz=b;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GRID_SIZE 15.\n#define GRID_ZOOM .6\n#define TOTAL_INDEX (4.*GRID_SIZE*GRID_SIZE)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}