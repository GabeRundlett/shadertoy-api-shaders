{
    "Shader": {
        "info": {
            "date": "1539230066",
            "description": "learning ray marching",
            "flags": 8,
            "hasliked": 0,
            "id": "4ltfDr",
            "likes": 73,
            "name": "traveler.",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "sound"
            ],
            "usePreview": 1,
            "username": "kaneta",
            "viewed": 7490
        },
        "renderpass": [
            {
                "code": "#define TAU 6.283185307\n#define PI 3.141592654\nconst int Iterations = 3;\n\nstruct Surface {\n    float dist;\n    float depth;\n\n    vec3 diffuse;\n    vec3 specular;\n    vec4 emission;\n    float roughness;\n    vec3 pattern;\n};\n\nmat3 rotateMat(float roll, float pitch, float yaw)\n{\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n\n    return mat3(cp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n                cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n                -sp, sr * cp, cr * cp);\n}\n\nfloat lerpStep(float t, float a, float b)\n{\n    return floor(t/b) + mix(0.0, 1.0, clamp(mod(t, b)/a, 0.0, 1.0));\n}\n\nfloat pingPong(float t, float len, float smth)\n{\n    float tt = mod(t, len);\n    tt = min(1.0, tt * smth);\n    float cond = step(mod(t, len*2.0), len);\n    return mix(1.0 - tt, tt, cond);\n}\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat de(vec3 p, mat3 rot, float scale, out vec3 e) {\n\tvec3 offset = vec3(1,1,1);\n\n    p*=transpose(rot);\n    float beat = iTime * 120.0 / 60.0;\n\tfor (int i=0; i<Iterations; i++) {\n        \n\t\tp*=rot;\n\t\tp = abs(p);\n\n\t\tif (p.x < p.y) {p.yx = mix(p.yx, p.xy, pingPong(beat, 63.5 * 0.5, 1.0));}\n\t\tif (p.x < p.z) {p.xz = mix(p.xz, p.zx, pingPong(beat, 63.5, 1.0));}\n\t\tif (p.y < p.z) {p.yz = mix(p.yz, p.zy, pingPong(beat, 63.5 * 0.25, 1.0));}\n\n\t\tp.z -= 0.5*offset.z*(scale-1.)/scale;\n\t\tp.z = -abs(-p.z);\n\t\tp.z += 0.5*offset.z*(scale-1.)/scale;\n\n\t\tp.xy = scale*p.xy - offset.xy*(scale-1.);\n\t\tp.z = scale*p.z;\n\t}\n\n    vec3 d = abs(p) - vec3(1.,1.,1.);\n    float distance = length(vec3(max(d, vec3(0.0))));\n    distance *= pow(scale, -float(Iterations));\n    \n    return distance;\n}\n\nvoid intersectStage(inout Surface surface, vec3 p, mat3 rot, float scale)\n{\n    vec3 e;\n    float d = de(p, rot, scale, e);\n    if (d < surface.dist) {\n        surface.dist = d;\n        surface.diffuse = vec3(1.);\n        surface.specular = vec3(1.);\n        surface.roughness = 25.0;\n        surface.emission = vec4(e, 1.0);\n        surface.pattern = vec3(0.0);\n    }\n}\n\nvoid intersectSphere(inout Surface surface, vec3 p)\n{\n    float d = sphere(p, 0.1);\n    float b1 = sdBox(p, vec3(10.0, 0.02, 10.0));\n    float b2 = sdBox(p, vec3(0.02, 10.0, 10.0));\n    float b3 = sdBox(p, vec3(10.0, 10.0, 0.02));\n    float s = sphere(p, 0.098);\n    d = max(-b1, d);\n    d = max(-b2, d);\n    d = max(-b3, d);\n    d = max(-s, d);\n    \n    \n    if (d < surface.dist) {\n        surface.dist = d;\n        surface.diffuse = vec3(0.25);\n        surface.specular = vec3(0.15);\n        surface.roughness = 10.0;\n        surface.emission = vec4(1.0, 0.25, 0.35, 1.0);\n        surface.pattern = normalize(p);\n    }\n    \n    float dd = sphere(p, 0.08);\n    if (dd < d) {\n        surface.dist = dd;\n        surface.diffuse = vec3(0.25);\n        surface.specular = vec3(0.15);\n        surface.roughness = 5.0;\n        surface.emission = vec4(1.0, 0.25, 0.35, 1.0);\n        surface.pattern = vec3(0.0);\n    }\n}\n\nvec3 ro, ta, sp;\n\nSurface map(vec3 p, float time)\n{\n    vec3 pp = mod(p, 1.5) - 0.75;\n    \n    float beat = time * 120.0 / 60.0;\n    beat = mod(beat, 64.0);\n    \n    //kick\n    float kick = mod(beat,1.);\n    float scale = 3.4 - mix(0.00, 0.25, clamp(kick, 0.0, 1.0));\n    \n    // hihat\n    float pinpon = beat < 16.0 ? 0.0 : pingPong(beat + 0.5, 1.0, 10.0) * 0.1;\n    mat3 rot = rotateMat(0.1-pinpon,-pinpon, 0.4-pinpon);\n    \n    //snare\n    float snare = beat < 32.0 ? 0.0 : lerpStep(beat - 32.0 - 1.0, 0.5, 2.0);\n    vec3 angle = mod(vec3(snare * 1.3, snare * 0.27, snare * 0.69), vec3(TAU) * 0.5);\n    if (beat > 63.5) {\n        angle = mix(angle, vec3(0.0), (beat - 63.5) * 2.0);\n    }\n    \n    Surface surface;\n    surface.dist = 99999.9;\n    \n    intersectStage(surface, pp, rot, scale);\n    intersectStage(surface, pp, rotateMat(angle.x, angle.y, angle.z) * rot, scale);\n    \n    rot = rotateMat(sin(time),cos(time), sin(time * .33));\n    intersectSphere(surface, (p - sp) * rot);\n\n    return surface;\n}\n\nSurface intersect(vec3 ro, vec3 ray, float time)\n{\n    float t = 0.0;\n    Surface res;\n    for (int i = 0; i < 128; i++) {\n        res = map(ro+ray*t, time);\n        if( res.dist < 0.001 ) {\n            res.depth = t;\n            return res;\n        }\n        t += res.dist;\n    }\n\tres.dist = -1.0;\n    return res;\n}\n\nvec3 normal(vec3 pos, float e ,float time)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy, time).dist - map(pos-eps.xyy, time).dist,\n           map(pos+eps.yxy, time).dist - map(pos-eps.yxy, time).dist,\n           map(pos+eps.yyx, time).dist - map(pos-eps.yyx, time).dist ) );\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k, float time)\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, time).dist;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.05, 0.2 );\n        if( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 tex(vec2 p, float z)\n{\n    vec2 q = (fract(p / 10.0) - 0.5) * 10.0;\n    float d = 9999.0;\n    for (int i = 0; i < 3; ++i) {\n        q = abs(q) - 0.5;\n        q *= rot(0.785398);\n        q = abs(q) - 0.5;\n        q *= rot(z * 0.5);\n        float k = sdRect(q, vec2(1.0, 0.55 + q.x));\n        d = min(d, k);\n    }\n    float f = 1.0 / (1.0 + abs(d));\n    return vec3(pow(f, 16.0) + step(0.935, f));\n}\n\nvec3 light(Surface surface, vec3 pos, vec3 normal, vec3 ray, vec3 col, vec3 lpos, float time)\n{\n    vec3 lvec = normalize(lpos - pos);\n    vec3 hvec = normalize(lvec - ray);\n    float llen = length(lpos - pos);\n    float sha = (softshadow(pos, lvec, 0.01, length(lpos - pos), 4.0, time) + 0.25) / 1.25;\n    vec3 diffuse = surface.diffuse * col  * (1.0 / PI);\n    \n    float rough = surface.roughness;\n    float bpnorm = ( rough + 2.0 ) / ( 2.0 * PI );\n\tvec3 spec = surface.specular * col * bpnorm * pow( max( 0.0, dot( normal, hvec ) ), rough );\n    \n    vec3 nor = 19.3602379925 * surface.pattern;\n    vec3 emission = surface.emission.rgb;\n    if (length(surface.pattern.rgb) > 0.0) {\n    \temission *= min(vec3(1.0),  tex(nor.zy, 113.09) + tex(nor.xz, 113.09) + tex(nor.xy, 113.09));\n    }\n    \n    diffuse *= sha;\n    spec *= sha;\n    return vec3(diffuse + spec) / (llen * llen) + emission * (sin(time) * 0.5 + 0.5 + 0.2);\n    //return vec3(sha);\n}\n\nvec3 ray;\n\nvec3 getColor(vec2 p, float time)\n{\n    // camera\n\tro = (vec3(.75 + sin(time * 0.4) * 0.15, .8 + cos(time * 0.8) * 0.05, sin(time*0.3) * 0.05 + time * 0.5));\n\tta = (vec3(0.75, 0.75,  (sin(time * 0.1) * 0.5 + 0.5) * 3.0 + 0.2 + time * 0.5));\n\tsp = (vec3(0.75, 0.75, 0.2 + time * 0.5));\n    mat3 cm = createCamera(ro, ta, sin(time) * 0.1);\n    ray = cm * normalize(vec3(p, 1.0));\n    \n    // marching loop\n    Surface res = intersect(ro, ray, time);\n    \n    // hit check\n    if(res.dist > -0.5) {\n        vec3 pos = ro + ray * res.depth;\n        vec3 nor = normal(pos, 0.0025, time);\n        vec3 col = light(res, pos, nor, ray, vec3(0.01), ro, time);\n        col += light(res, pos, nor, ray, vec3(0.2, 0.4, 0.8), ro + vec3(0.0, 0.0, 2.0), time);\n        return col + vec3(0.01, 0.02, 0.04) * res.depth;\n    }else{\n        return vec3(1.0);\n    }\n}\n\nvec3 aaGetColor(vec2 p, float time) {\n    vec3 col = vec3(0.0);\n    const int num = 4;\n    \n    for (int i = 0; i < num; i++) {\n        float fi = float(i + 1);\n    \tcol += getColor(p + vec2(step(fi, 2.001), mod(fi, 2.001)) * 0.0015, time - float(i) * 0.01);\n    }\n    return col / float(num);\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453) * 2.0 - 1.0;\n}\n\nfloat Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)\n{\n    float d = length(p - sp);\n    float c = smoothstep(size, size*(1.-blur), d);\n    c *= mix(mi, 1., smoothstep(size*.8, size, d));\n    return c;\n}\n\nvec3 dirt(vec2 uv, float n)\n{\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) / n;\n    vec2 rnd = hash(st);\n    float c = Bokeh(p, vec2(0.5, 0.5) + vec2(0.3) * rnd, 0.2, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);\n    \n    return vec3(c) * exp(rnd.x * 4.0);\n}\n\nvec3 postProcess(vec2 uv, vec3 col, float time)\n{   \n    uv *= 0.5;\n    \n    vec3 di = dirt(uv, 3.5);\n    di += dirt(uv - vec2(0.17), 3.0);\n    di += dirt(uv- vec2(0.41), 2.75);\n    di += dirt(uv- vec2(0.3), 2.5);\n\n    float flare = pow(max(0.0, dot(vec3(0.0, 0.0, 1.0), ray)), 10.0);\n    float flare2 = pow(max(0.0, dot(vec3(0.0, 0.0, 1.0), ray)), 8.0);\n    vec3 f = flare * vec3(0.1, 0.2, 0.4) * 3.5 + flare2 * di * vec3(0.1, 0.2, 0.4) * 0.1;\n    \n    float sflare = pow(max(0.0, dot(normalize(sp - ro), ray)), 10.0);\n    float sflare2 = pow(max(0.0, dot(normalize(sp - ro), ray)), 8.0);\n    vec3 s = sflare * vec3(1.0, 0.25, 0.35) * 1.0 + sflare2 * di * vec3(1.0, 0.25, 0.35) * 0.01;\n    \n    return col + f + s * max(0.2, sin(time) * 0.5 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float t = iTime;\n    vec3 col =  getColor(p, t);\n    vec2 pp = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*pp.x*pp.y*(1.0-pp.x)*(1.0-pp.y), 0.05 );\n    col = postProcess(p, col, t);\n\tfragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592654\n#define TAU 6.283185307\n\n#define BPM 120.0\n\n#define C3  60\n#define Cs3 61\n#define D3  62\n#define Ds3 63\n#define E3  64\n#define F3  65\n#define Fs3 66\n#define G3  67\n#define Gs3 68\n#define A3  69\n#define As3 70\n#define B3  71\n#define UP + 12\n#define DN - 12\n#define CHO(a,b,c) ivec3(a,b,c)\n\n#define INIT(t) float tmp = t, nTime = t, p = 0.0; int , num; ivec3 chord;\n#define R(v) tmp -= 240.0 / BPM / float(v);\n#define D(v)if (tmp >= 0.0 ) {nTime = tmp; p = 1.0;} R(v)\n#define N(v, n) if (tmp >= 0.0) {nTime = tmp; num = n; p = 1.0;}  R(v)\n#define C(v, c) if (tmp >= 0.0) {nTime = tmp; chord = c; p = 1.0;}  R(v)\n#define S(v) if (tmp >= 0.0) {p = v;}\n#define LOOP(b) if(tmp>0.0) tmp = mod(tmp, float(b) * 240.0 / BPM);\n#define FOR(b, n) if(tmp>0.0) {float a = float(b) * 240.0 / BPM; for(int i = 0; i < n-1; i++){if (tmp> a) tmp -= a;}}\n\nfloat sine( float phase ) {\n    return sin( TAU * phase );\n}\n\nfloat saw( float phase ) {\n    return 2.0 * fract( phase ) - 1.0;\n}\n\nfloat square( float phase ) {\n    return fract( phase ) < 0.5 ? -1.0 : 1.0;\n}\n\nfloat n2f(in float t, in int n)\n{\n    return fract(440.0 * exp2((float(n)-69.0) / 12.0) * t);    \n}\n\nfloat kick(float t)\n{\n    INIT(t)\n    LOOP(1)\n        D(4)\n        D(4)\n        D(4)\n        D(4)\n        \n    return sin( nTime * 250.0 - exp( -nTime * 100.0 ) * 30.0 ) * exp( -nTime * 5.0 ) * p;\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nvec2 hihat( float t ) {\n    INIT(t)\n    LOOP(16.0)\n    FOR(0.25, 16)\n    \tR(4)\n    FOR(0.5, 24)\n        R(8)\n        D(8)\n        R(8)\n        D(8)\n  return sin(hash(vec2(nTime))) * exp( -nTime * 20.0 ) * 0.2 * p;\n}\n\n\nvec2 snare(float t) {\n    INIT(t)\n    LOOP(16.0)\n    FOR(0.25, 32)\n    \tR(4)\n    FOR(1.0, 8)\n        R(4)\n        D(4)\n        R(4)\n        D(4)\n\treturn clamp(vec2(0.0), vec2(1.0), (\n\t\thash( vec2(nTime) ).xy * 1.5 +\n\t\tsine( nTime * 300.0 - exp( -nTime * 400.0 ) * 30.0 ) * 0.1 +\n\t\tsaw( nTime - exp( -nTime * 400.0 ) * 30.0 ) * 0.3\n\t\t) * 2.0 * exp( -nTime * 23.0 ) ) * 0.3 * p;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return  kick(time) + hihat(time) + snare(time);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}