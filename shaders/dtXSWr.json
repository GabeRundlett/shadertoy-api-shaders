{
    "Shader": {
        "info": {
            "date": "1674562616",
            "description": "An inverse kaleidoscope - instead of moving the background, the viewer moves instead! You can also manually change the position of the viewer using your mouse / touch screen.\n\nTweakpane version here: https://sketchbook-2.macr.ae/inverted-kaleidoscope",
            "flags": 0,
            "hasliked": 0,
            "id": "dtXSWr",
            "likes": 5,
            "name": "Inverse kaleidoscope",
            "published": 3,
            "tags": [
                "2d",
                "interactive",
                "animated",
                "kaleidoscope"
            ],
            "usePreview": 0,
            "username": "callumacrae",
            "viewed": 237
        },
        "renderpass": [
            {
                "code": "// Background config\n#define SQUARE_SIZE 0.01 // 0.001 - 0.05\n#define RAND_REPEAT_CHANCE 0.3 // 0.0 - 0.5\n#define BG_NOISE_FACTOR 3.8 // 0.0 - 10.0\n#define BG_RAND_TO_NOISE_RATIO 0.4 // 0.0 - 1.0\n#define BG_BLEND_MODE 3 // normal:0, multiply:1, screen:2, overlay:3, hard light:4, soft light:5\n#define COLOR_SATURATION 0.5 // 0.0 - 1.0\n#define COLOR_VALUE 0.75 // 0.0 - 1.0\n#define DEBUG_BACKGROUND false\n\n// Viewer config\n#define BASE_TRIANGLE_SIZE 0.1 // 0.01 - 0.4\n#define POSITION_NOISE_FACTOR 2.0 // 0.0 - 10.0\n#define ANGLE_NOISE_IN_FACTOR 2.5 // 0.0 - 10.0\n#define ANGLE_NOISE_OUT_FACTOR 0.25 // 0.0 - 10.0\n\n#define PI 3.1415926535897932384626433832795 // no-config\n\n/** VENDOR START **/\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(int n) { return rand(float(n)) * 1000.0; }\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){ const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod(i, 289.0); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); }\n\n// https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\n\n/** VENDOR END **/\n\nmat3 translationMatrix(float x, float y) {\n  return mat3(1, 0, 0, 0, 1, 0, x, y, 1);\n}\nmat3 rotationMatrix(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n}\nmat3 scaleMatrix(float x, float y) {\n  return mat3(x, 0, 0, 0, y, 0, 0, 0, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n\n  // Means that a 1x1 square in UV units is always a square\n  // Be careful, this means that u and v can now be outside of [0, 1]\n  if (iResolution.x > iResolution.y) {\n    uv.x *= iResolution.x / iResolution.y;\n  } else {\n    uv.y *= iResolution.y / iResolution.x;\n  }\n\n  float triangleSize = BASE_TRIANGLE_SIZE;\n  float triangleHeight = triangleSize / 2.0 / tan(PI / 6.0);\n  vec2 triangleFrom;\n  if (iMouse.z > 0.0) {\n    triangleFrom = iMouse.xy / iResolution.xy;\n  } else {\n    triangleFrom = vec2(\n      snoise(vec2(iTime * POSITION_NOISE_FACTOR / 100.0 + rand(3), 0.0)),\n      snoise(vec2(iTime * POSITION_NOISE_FACTOR / 100.0 + rand(4), 0.0))\n    ) * 0.2 + 0.5;\n  }\n  float triangleAngle = snoise(\n    vec2(iTime * ANGLE_NOISE_IN_FACTOR / 100.0 + rand(8), 0.0)\n  ) * PI * 2.0 * ANGLE_NOISE_OUT_FACTOR;\n\n  // TS = triangle space\n  vec2 uvTS = (rotationMatrix(triangleAngle) * vec3(uv - triangleFrom, 1.0)).xy;\n\n  if (!DEBUG_BACKGROUND) {\n    uvTS.y = mod(uvTS.y, triangleHeight * 2.0);\n    if (uvTS.y > triangleHeight) {\n      uvTS.y = 2.0 * triangleHeight - uvTS.y;\n    }\n\n    float modX = mod((uvTS.x + triangleSize / 2.0), triangleSize);\n    float maxWidthAtX = uvTS.y / triangleHeight * triangleSize;\n    // Inverted = point side up (the origin triangle is point side down)\n    bool isInverted = abs(modX - triangleSize / 2.0) > maxWidthAtX / 2.0;\n\n    float offsetX = floor((uvTS.x + (isInverted ? 0.0 : triangleSize / 2.0)) / triangleSize);\n    uvTS.x -= offsetX * triangleSize;\n\n    if (isInverted) {\n      mat3 reflect = rotationMatrix(radians(-60.0)) * scaleMatrix(-1.0, 1.0);\n      uvTS = (reflect * vec3(uvTS, 1.0)).xy;\n    }\n\n    float originY = triangleSize * sqrt(3.0) / 3.0;\n    mat3 rotation = translationMatrix(0.0, originY) * rotationMatrix(radians(-120.0) * offsetX) * translationMatrix(0.0, -originY);\n    uvTS = (rotation * vec3(uvTS, 1.0)).xy;\n  }\n\n  float size = SQUARE_SIZE * max(iResolution.x, iResolution.y);\n  uv = (rotationMatrix(-triangleAngle) * vec3(uvTS, 1.0)).xy + triangleFrom;\n  vec2 xy = uv * iResolution.xy / size;\n  xy.x = floor(xy.x);\n  xy.y = floor(xy.y);\n\n  float randIndex = xy.x + xy.y * (1.0 / SQUARE_SIZE);\n\n  // Make it so there's two or three in a row sometimes\n  if (rand(randIndex - 1.0) > (1.0 - RAND_REPEAT_CHANCE / 2.0)) {\n    randIndex -= 2.0;\n  } else if (rand(randIndex) > (1.0 - RAND_REPEAT_CHANCE)) {\n    randIndex -= 1.0;\n  }\n\n  float hRand = rand(randIndex);\n  float hNoise = snoise(xy * BG_NOISE_FACTOR / 100.0) * 0.5 + 0.5;\n\n#if BG_BLEND_MODE == 0\n  // Normal blend mode\n  float hBlend = (hRand + hNoise) / 2.0;\n#elif BG_BLEND_MODE == 1\n  // Multiply blend mode\n  float hBlend = hRand * hNoise;\n#elif BG_BLEND_MODE == 2\n  // Screen blend mode\n  float hBlend = 1.0 - (1.0 - hRand) * (1.0 - hNoise);\n#elif BG_BLEND_MODE == 3\n  // Overlay blend mode\n  float hBlend = hRand < 0.5\n    ? 2.0 * hRand * hNoise\n    : 1.0 - 2.0 * (1.0 - hRand) * (1.0 - hNoise);\n#elif BG_BLEND_MODE == 4\n  // Hard light blend mode\n  float hBlend = hNoise < 0.5\n    ? 2.0 * hRand * hNoise\n    : 1.0 - 2.0 * (1.0 - hRand) * (1.0 - hNoise);\n#elif BG_BLEND_MODE == 5\n  // Soft light blend mode\n  float hBlend = hNoise < 0.5\n    ? hRand - (1.0 - 2.0 * hNoise) * hRand * (1.0 - hRand)\n    : hRand + (2.0 * hNoise - 1.0) * (sqrt(hRand) - hRand);\n#endif\n\n  float h;\n  if (BG_RAND_TO_NOISE_RATIO > 0.5) {\n    h = mix(hBlend, hRand, BG_RAND_TO_NOISE_RATIO * 2.0 - 1.0);\n  } else {\n    h = mix(hNoise, hBlend, BG_RAND_TO_NOISE_RATIO * 2.0);\n  }\n\n  /* h = h < 0.75 && h > 0.25 ? 0.0 : 0.5; */\n\n  fragColor = vec4(hsv2rgb(vec3(h, COLOR_SATURATION, COLOR_VALUE)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}