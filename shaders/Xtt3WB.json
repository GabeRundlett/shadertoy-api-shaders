{
    "Shader": {
        "info": {
            "date": "1471353140",
            "description": "Debugging and visualizing some glitches in latest (2016-08-16) Microsoft Edge 39.14901.1000.0",
            "flags": 0,
            "hasliked": 0,
            "id": "Xtt3WB",
            "likes": 4,
            "name": " Swizzle Glitches in Edge",
            "published": 3,
            "tags": [
                "glitch",
                "edge",
                "error",
                "microsoft",
                "swizzle"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 850
        },
        "renderpass": [
            {
                "code": "/////////////////////////////////////////////////////////\n// Swizzle Glitches in Edge\n//\n// It seems that swizzling in a particular way causes \n// another variable's value to change, mirroring the \n// scene. With some jiggling of order of calculations,\n// the boxes in the scene can be made to appear at the\n// wrong and the correct positions \"at the same time\".\n//\n//\n//\n// Uncomment NO_GLITCH for how it should look like.\n//\n//\n// Based on SDF shape blending by tiusic:\n// https://www.shadertoy.com/view/ll3GDS\n\n\n//#define NO_GLITCH\n\n\nfloat intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\nvec3 intersectionColor = vec3(1, 0, 1);\n\nvec3 colorA = vec3(0, 1, 0);\nvec3 colorB = vec3(0, 0, 1);\n\nvec4 blend(float a, float b, float m) {\n    return vec4(min(min(a, b), a * b - m), (a * colorA + b * colorB) / (a + b));\n}\n\nfloat dSphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat dBox(vec3 p, vec3 c, vec3 dimensions, mat3 rot) {\n\tvec3 d = abs((p - c) * rot) - dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvoid test(inout vec2 distMat, float newDist, int newMat) {\n    if (newDist < distMat.x) {\n        distMat = vec2(newDist, float(newMat));\n    }\n}\n\n#ifdef NO_GLITCH\nvec4 sp = vec4(0);\nvec4 sc1 = vec4(0);\n#endif\n\nfloat shapeSpacing;\nvec2 boxRotor;\nmat3 boxRotation;\nmat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\nvec4 dc = vec4(0);\nvec4 d(vec3 p) {\n    bool first = true;\n    vec4 mindd;\n    for (float i = 0.0; i <= 1.01; i += 0.1) {\n        vec3 c0 = vec3(30.0 * i, 10, shapeSpacing);\n        vec3 c1 = vec3(30.0 * i, 10, -shapeSpacing);\n\n#ifdef NO_GLITCH\n        sp.xzy=p;\n        sc1.xzy=c1;\n        dc += sp-sc1;\n#else\n        dc.x += p.x;\n        dc.x -= c1.x;\n        dc.y += (p - c1).z;\n        dc.z += (p - c1).y;\n#endif\n        vec3 pRot21 = (p - c1);\n        vec3 pRot212 = vec3(p.xyz - c1.xyz);\n        vec3 pRot22;\n        if(floor(mod(gl_FragCoord.x, 20.0)/10.0)==0.0){\n#ifdef NO_GLITCH\n            pRot22 = pRot21.xzy;\n            pRot22.yz *= rot2(iTime);\n            pRot22 = pRot22.xzy;\n#else\n            pRot22 = vec3(pRot21.x, (pRot212.zy * (rot2(iTime)))).xzy;\n#endif\n        } else {\n            pRot22 = vec3(dc.x, (pRot212.zy * (rot2(iTime)))).xzy;\n        }\n        dc.rgb += max(vec3(0),floor(sign(pRot22)-1.0));\n        vec3 pRot = pRot22 + c1;\n        vec4 dd = blend(dSphere(p, c0, 1.0), dBox(pRot, c1, vec3(1.0), mat3(1)), i); \n        //vec4 dd = blend(dSphere(p, c0, 1.0), dBox(p, c1, vec3(1.0, 1.0, 1.0), boxRotation), i);// Original rotation\n        if (first || dd.x < mindd.x) {\n            mindd = dd;\n        }\n        first = false;\n        vec3 pRot30 = p;\n        vec3 pRot31 = (p - c1);\n#ifdef NO_GLITCH\n        dc -= sp-sc1;\n#else\n        dc.x -= p.x;\n        dc.z -= vec3(pRot31).y;\n        dc.y -= vec3(pRot31).z;\n        dc.x += c1.x;\n#endif\n        \n    }\n    return mindd;\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    d(pos+eps.xyy).x - d(pos-eps.xyy).x,\n\t    d(pos+eps.yxy).x - d(pos-eps.yxy).x,\n\t    d(pos+eps.yyx).x - d(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n#define MAX_STEPS 100\n#define MARCH_EPSILON .001\n#define MAX_T 1000.\n\nvoid IntersectScene(vec3 origin, vec3 direction) {\n    float t = 0.;\n    for (int ii = 0; ii < MAX_STEPS; ++ii) {\n        vec3 pos = origin + direction * t;\n        vec4 dd = d(pos);\n        if (dd.x < MARCH_EPSILON) {\n            if (t < MAX_T) {\n\t\t\t\tintersectionNormal = calcNormal(pos);\n            \tintersectionPoint = pos;\n                intersectionT = t;\n                intersectionColor = dd.yzw;\n            }\n            break;\n        }\n        t += dd.x;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tshapeSpacing = 3.0 * sin(0.1 * iTime);\n\tboxRotor = vec2(cos(iTime), sin(iTime));\n\tboxRotation = mat3(1, 0, 0, 0, boxRotor.x, -boxRotor.y, 0, boxRotor.y, boxRotor.x);    \n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\tvec3 origin = vec3(15.0, -15.0, 0.0);\n\tvec3 direction = vec3(uv.x, 1, uv.y);\n\tdirection.xz *= .8;\n\tdirection = normalize(direction);\n\tvec3 color = vec3(0);\n    intersectionT = 1e37;\n    IntersectScene(origin, direction);\n    if (intersectionT < MAX_T) {\n        float lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n        if (lightDot > 0.0) {\n        \tcolor = mix(intersectionColor, vec3(1, 1, 1), 0.3 * lightDot);\n        } else {\n        \tcolor = mix(intersectionColor, vec3(0, 0, 0), -lightDot);\n        }\n    }\n    if(floor(mod(gl_FragCoord.y, 2.0))==0.0) {\n        color=mix(color,clamp(dc.rgb*0.5,0.0,1.0),0.5+0.5*sin(iTime*2.0));\n    }\n\tfragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}