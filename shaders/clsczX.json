{
    "Shader": {
        "info": {
            "date": "1691007927",
            "description": "it's a better hex grid, you dolt!",
            "flags": 0,
            "hasliked": 0,
            "id": "clsczX",
            "likes": 0,
            "name": "eindacor_im_too_hexy",
            "published": 3,
            "tags": [
                "hexagons"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 27
        },
        "renderpass": [
            {
                "code": "#define TWOPI 6.28318530718f\n#define AA 0.001f\n#define SIXTY_DEGREES 1.0471975512f\n\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nvec2 rotateAroundAxis(vec2 point, vec2 axis, float angle) \n{\n    point -= axis;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.y * cos(angle) + point.x * sin(angle);\n    return vec2(x, y) + axis;\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nstruct AspectRatioData {\n    mat2x2 scaleMatrix;\n    mat2x2 inverseScaleMatrix;\n    float aspectRatio;\n};\n\nAspectRatioData getAspectRatioData(vec2 uvSize) {\n    float aspectRatio = uvSize.x / uvSize.y;\n    AspectRatioData aspectRatioData;\n    aspectRatioData.aspectRatio = aspectRatio;\n    aspectRatioData.scaleMatrix = mat2x2(\n        aspectRatio, 0.f,\n        0.f, 1.f\n    );\n    \n    aspectRatioData.inverseScaleMatrix = mat2x2(\n        1.f / aspectRatio, 0.f,\n        0.f, 1.f\n    );\n\n    return aspectRatioData;\n}\n\nvec3 getLocalHexCenter(vec2 uv, float hexRadius) {\n    float shortRadius = hexRadius * sin(SIXTY_DEGREES);\n    vec2 hexCenter = vec2(uv.x - mod(uv.x, 2. * shortRadius) + shortRadius,\n                            uv.y - mod(uv.y, 3. * hexRadius) + 1.5 * hexRadius);\n         \n    return vec3(hexCenter.x, hexCenter.y, distance(hexCenter, uv));\n}\n\nvec2 getHexCenter(vec2 uv, float hexRadius)\n{\n    float shortRadius = hexRadius * sin(SIXTY_DEGREES);\n    vec3 hexCenter1 = getLocalHexCenter(uv, hexRadius);\n         \n    vec2 altOffset = vec2(shortRadius, 1.5 * hexRadius);\n                            \n    vec3 hexCenter2 = getLocalHexCenter(uv + altOffset, hexRadius);\n                            \n    if (hexCenter1.z < hexCenter2.z) {\n        return hexCenter1.xy;\n    } else {\n        return hexCenter2.xy - altOffset;\n    }\n}\n\nstruct HexData {\n    // value (0 -> 1) representing the uv's value in radial space, origin is (1, 0)\n    float radialVal; \n    \n    // value (0 -> 1) representing approximity to center compared to hex radius\n    float distFromCenter;  \n    \n    // center vertex of the hexagon\n    vec2 center;           \n    \n    // locations of each vertex of the hex\n    vec2[6] vertices;  \n    \n    // locations of hex midpoints\n    vec2[6] midpoints; \n    \n    // value (0 -> 1) representing approximity to center compared to hexagon's edge\n    float edgeCoefficient;  \n    \n    // value (0 -> 1) representinglinear interpolation of radians between local triangle vertices\n    float radialLerp;      \n};\n\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec2[6] getHexMidpoints(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = hexCenter + vec2(hexRadius * sin(SIXTY_DEGREES), 0.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = rotateAroundAxis(firstVertex, hexCenter, rotationIncrement * float(i));\n    }\n    \n    return hexVertices;\n}\n\nvec2[6] getHexVertices(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = rotateAroundAxis(hexCenter + vec2(hexRadius, 0.), hexCenter, TWOPI / 12.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = rotateAroundAxis(firstVertex, hexCenter, rotationIncrement * float(i));\n    }\n    \n    return hexVertices;\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nfloat getRadialVal(vec2 hexCenter, vec2 p) {\n    float offsetAngle = getOffsetAngle(hexCenter, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nHexData getHexData(\n    vec2 uv, \n    float hexRadius) \n{\n    float aspectHexRadius = hexRadius;\n    vec2 hexCenter = getHexCenter(uv, hexRadius);\n    \n    HexData hexData;\n    hexData.radialVal = getRadialVal(hexCenter, uv);\n    hexData.center = hexCenter;\n    hexData.distFromCenter = distance(uv, hexCenter) / hexRadius;\n    hexData.vertices = getHexVertices(hexCenter, hexRadius);\n    hexData.midpoints = getHexMidpoints(hexCenter, hexRadius);\n    hexData.radialLerp = mod(hexData.radialVal, 1./6.) / (1./6.);\n     \n    return hexData;\n}\n\nfloat getLineValFromVertices(vec2 uv, vec2[6] vertices, float lineThickness) {\n    float lineVal = 0.;\n    for (int i=0; i<6; i++) {\n        vec2 first = vertices[i];\n\n        vec2 second;\n        if (i == 0) {\n            second = vertices[5];\n        } else {\n            second = vertices[i-1];\n        }\n        lineVal = max(lineVal, lineSegmentSmoothStep(first, second, uv, lineThickness, AA, true));\n    }\n    \n    return lineVal;\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat getHoldTransitionValue(float holdTime, float transitionTime, float time) {\n    return getHoldTransitionValue(0., 1., holdTime, transitionTime, time);\n}\n\nfloat getPointVal(vec2 uv, vec2 point, float radius, float antialias) {\n    float dist = distance(uv, point);\n    return smoothstep(radius + antialias, radius - antialias, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    AspectRatioData aspectRatioData = getAspectRatioData(iResolution.xy);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * aspectRatioData.scaleMatrix;\n    uv += vec2(iTime * .02, getHoldTransitionValue(0., 1., 2., 4., iTime * .2));\n\n    float hexRadius = .2;\n    vec2 hexCenter = getHexCenter(uv, hexRadius);\n    \n    HexData hexData = getHexData(uv, hexRadius);\n    \n    hexData.radialVal = mod(hexData.radialVal + iTime * .1 + hash(hexData.center), 1.);\n    //uv = rotateAroundAxis(uv, hexData.center, sin(iTime));\n    \n    float val = getHoldTransitionValue(2., 4., iTime);\n    \n    vec3 hexColor = vec3(mix(0.25, 1., abs(.5 - hexData.radialLerp) / .5),\n        mix(0.5, 1., abs(.5 - hexData.radialVal) / .5),\n        mix(0.25, .8, hexData.distFromCenter));\n   \n    float distVal = 1. - hexData.distFromCenter;\n    \n    float lineThickness = hexRadius * .02;\n    float lineVal = getLineValFromVertices(uv, hexData.vertices, lineThickness);\n    vec3 lineColor = vec3(1.);\n    \n    vec3 outColor = mix(hexColor, lineColor, lineVal);\n    \n    float timeVal = getHoldTransitionValue(1., 4., iTime * .2);\n    fragColor = vec4(outColor * mix(.25, 1., 1. - pow(distVal, timeVal + hexData.radialLerp)), 1.0);\n    \n    fragColor = mix(fragColor, vec4(lineColor, 1.), lineVal);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}