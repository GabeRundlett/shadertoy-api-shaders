{
    "Shader": {
        "info": {
            "date": "1652820308",
            "description": "Using a simple fluid simulator to advect the rainbow. Spacebar to reset. Mouse to interact. \n\nUsing a fluid solver based on \"Simple and Fast Fluids\" https://www.researchgate.net/publication/229039366_Simple_and_Fast_Fluids",
            "flags": 48,
            "hasliked": 0,
            "id": "st2BzK",
            "likes": 3,
            "name": "Fluid Spectrum",
            "published": 3,
            "tags": [
                "spectrum",
                "fluid",
                "rainbow",
                "liquid"
            ],
            "usePreview": 0,
            "username": "theschwa",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texel = 1./iResolution.xy;\n    vec2 uv = fragCoord * texel;\n    //vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 st = uv;\n    uv = move(uv, iTime*.05);\n    vec3 col;\n    col = texture(iChannel0, uv ).rgb;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Velocity Field\n\nvec2 initialVel( vec2 uv ) {\n    //uv += vec2( iTime*.029, iTime*.017 );\n    // Start with a nice looking flow field and switch to noise after 1min\n    vec2 noise = vec2( fbm(uv), fbm(uv + vec2(31., 70.) ) );\n    vec2 field = vec2( cos( 2. * 3.14159 * uv.y ), cos( 2. * 3.14159 * uv.x) );\n    return step(-60., -iTime)*field + step(60., iTime)*noise;\n}\n\nfloat window( float t, float width ) {\n    return step(-width, -t)*step(0., t);\n}\n\nfloat sawWave( float t, float width ) {\n    return mod(-t, width)/width;\n}\n\nfloat impulse( float t, float width ) {\n    return sawWave(t, width)*window(t, width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texel = 1./iResolution.xy;\n    vec2 uv = fragCoord * texel;\n    bool spaceBar = texelFetch(iChannel1,ivec2(32,1),0).x > 0.;\n    if( iFrame < 10 || spaceBar ) {\n        vec3 col = vec3( initialVel(uv) , 0.5 );\n        fragColor = vec4(col, 1.);\n        return;\n    }\n    \n    // Adapted from https://www.researchgate.net/publication/229039366_Simple_and_Fast_Fluids\n    \n    float dt = iTimeDelta;\n    dt = 0.15;\n    float v = 0.5; // viscosity \n    vec2 ExternalForces = vec2( 0. );\n    vec3 CScale = vec3(.5);\n    float K = .2;\n    float S = K/dt;\n    \n    vec4 FC = texture( iChannel0, uv );\n    vec3 FR = texture( iChannel0, uv + vec2(1., 0.)*texel ).xyz;\n    vec3 FL = texture( iChannel0, uv - vec2(1., 0.)*texel ).xyz;\n    vec3 FT = texture( iChannel0, uv + vec2(0., 1.)*texel ).xyz;\n    vec3 FD = texture( iChannel0, uv - vec2(0., 1.)*texel ).xyz;\n    \n    // du/dx , du/dy\n    vec3 UdX = (FR - FL) * CScale;\n    vec3 UdY = (FT - FD) * CScale;\n    \n    float Udiv = UdX.x + UdY.y;\n    vec2 DdX = vec2( UdX.z, UdY.z );\n    \n    \n    //\n    // Solve for density\n    //\n    FC.z -= dt * dot( vec3(DdX, Udiv) , FC.xyz );\n    //FC.z -= dt*( UdX.z * FC.x + UdY.z * FC.y + Udiv * FC.z );\n    \n    // Related to stability\n    FC.z = clamp( FC.z, 0.5, 3.0 );\n    \n    //\n    // Solve for Velocity\n    //\n    vec2 PdX = S * DdX;\n    vec2 Laplacian = ( FR + FL + FT + FD - 4.*FC.xyz ).xy;\n    \n\n    vec2 ViscosityForce = v*Laplacian;\n    \n    // Semi-lagrangian advection\n    vec2 Was = uv - dt*FC.xy*texel;\n    FC.xy = texture( iChannel0, Was ).xy;    \n    \n    if(iMouse.z>0.) {\n        vec2 offset = move(uv, iTime*.05) -uv;\n        vec2 corrected = mod( uv - offset, 1.);\n        vec2 m = 22.* (corrected -iMouse.xy*texel );\n        ExternalForces += normalize(m)*exp(-dot(m,m));\n    }\n    \n    // Periodically re-add inital forces\n    float period = 60.;\n    ExternalForces += impulse( mod(iTime, period), 1.)*initialVel(uv)*step(period,iTime)*.1;\n    \n    FC.xy += dt*( ViscosityForce - PdX + ExternalForces );\n    \n    FC = clamp(FC, vec4(-5.,-5.,0.5,0.), vec4(5.,5.,3.,5.));\n    \n    fragColor = FC;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Rainbow \n\nfloat isin( float ang ) {\n    return sin(ang)*.5 + .5;\n}\n\nfloat icos( float ang ) {\n    return cos(ang)*.5 + .5;\n}\n\n// Starting Color Field\nvec3 randColInit( vec2 uv ) {\n    uv += vec2(.157, .293);\n    // Slowly move to add some color variety when zoomed in\n    uv += vec2( sin(iTime*.0607 + 563.), -cos(iTime*.0613 + 857.) );\n    float val = fbm( uv * 5. )*.5 + .5 ;\n    // Change the gain with the zoom to prevent it from getting too dark\n    val = gain(val, mix(2.,7., isin(iTime*.223)) ); \n    return spectral_zucconi( val );\n}\n\n// Color Field to Add\nvec4 randCol( vec2 uv ) {\n    uv = (uv-.5)*isin(iTime*.223);\n    return vec4(randColInit( uv ), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n    vec2 texel = 1./iResolution.xy;\n    \n    vec2 uv = fragCoord * texel;\n    bool spaceBar = texelFetch(iChannel2,ivec2(32,1),0).x > 0.;\n    if( iFrame < 10 || spaceBar ) {\n        vec3 col;\n        col = randColInit(uv);\n        fragColor = vec4(col, 1.);\n        return;\n    }\n    vec2 vel  = texture(iChannel0, uv).xy;    \n    vec4 new  = texture(iChannel1, uv - vel*texel ); // Advection\n    \n    // Acount for the \"camera\" movement in the Image tab\n    vec2 offset = move(uv, iTime*.05) -uv;\n    vec2 corrected = mod( uv - offset, 1.);\n    \n    // Vary the scale and position of the color noise field\n    vec4 orig = randCol(corrected);\n    orig = 1.5*(orig - .5) + .5; // Incrase contrast\n    \n    //fragColor = orig;\n    //return;\n    \n    // Continually add new colors varying the amount added\n    fragColor = mix( new, orig, mix(0.0001,.003, icos(iTime*.053) ) );\n    \n    if(iMouse.z>0.) {\n        vec2 m = 22.* (corrected -iMouse.xy*texel );\n        float alpha = exp(-dot(m,m));\n        fragColor = mix(fragColor, orig, alpha);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float to01( float num ) {\n    return num*.5 + .5;\n}\n\nvec2 move( vec2 uv, float t ) {\n    t *= .997;\n    return vec2( uv.x + cos(t), uv.y + sin(t) );\n}\n//----- From: https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 bump3y (vec3 x, vec3 yoffset) {\n    vec3 y = 1. - x * x;\n    y = clamp(y-yoffset, 0., 1.);\n    return y;\n}\nvec3 spectral_zucconi(float x) {\n    // x: [0,   1]\n    vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n    vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n    vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n    return bump3y (    cs * (x - xs), ys);\n}\n\n//----- END\n\n// By IQ: https://www.shadertoy.com/view/XdXBRH\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nfloat noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 0\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va  + u.x*(vb-va) \n               + u.y*(vc-va) \n               + u.x*u.y*(va-vb-vc+vd);\n}\n\nfloat fbm( vec2 x )\n{    \n    float G = .5;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    int numOctaves = 4;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/warp/\nvec2 warp( vec2 p ) {\n    p *= 2.;\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                   fbm( p + vec2(5.2,1.3) ) );\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ),\n                   fbm( p + 4.0*q + vec2(8.3,2.8) ) );\n    return p + 4.*q;\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvec3 colGain(vec3 c, float k ) {\n    float r = gain(c.r, k);\n    float g = gain(c.g, k);\n    float b = gain(c.b, k);\n    return vec3(r, g, b);\n}\n\nvec3 colorNoise ( vec2 uv ) {\n    uv *= 40.;\n    vec3 col = vec3(0., 0., 0.);\n    col.x = noised( uv );\n    col.y = noised( uv + vec2(10., 13.) );\n    col.z = noised( uv + vec2(-17., -15.) );\n    \n    col = .5 + .5*col;\n    return colGain(col, 3.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}