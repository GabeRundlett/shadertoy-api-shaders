{
    "Shader": {
        "info": {
            "date": "1596900332",
            "description": "An offset triangle pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tlfDN",
            "likes": 34,
            "name": "Offset Triangle Pattern",
            "published": 3,
            "tags": [
                "triangle",
                "pattern",
                "offset",
                "zentangle"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 598
        },
        "renderpass": [
            {
                "code": "/*\n\n\tOffset Triangle Pattern\n\t-----------------------\n\n    Just something I coded for fun. It's an offset triangle pattern in the form \n    of an instant algorithmic Zentangle work, which completely defeats the purpose \n    of the Zentangle methodology, but here it is anyway. :)\n\t\n    The idea is pretty simple. Render an offset triangle grid, then with the minimum \n    returned triangle information, render a pattern inside it. I see this particular \n    arrangement a lot. The Zentangle crowd make things like this all the time... \n    Although, they have the benefit of hand drawing, whereas I had to make do with \n    time constraints, some rushed math and half the artistic talent. :D\n\n    You can happily ignore most of the code and just use the \"blocks\" function to\n\tobtain the required triangle information, then take it from there. I'm going\n\tto put up a few more examples along these lines. I might also put together an \n    offset triangle jigsaw pattern at some stage.\n\n\n\n\tRelated examples:\n\n\n\t// Mattz put one of these together ages ago.\n\tice and fire - mattz\n\thttps://www.shadertoy.com/view/MdfBzl\n\n\t// An offset triangle heightfield -- Very cool. I have one of these coming\n\t// that takes a different approach.\n\tTriangulated Heightfield Trick 3 - fizzer\n\thttps://www.shadertoy.com/view/ttsSzX\n\n    // An extruded offset triangle grid.\n\tExtruded Offset Triangle Grid - Shane\n\thttps://www.shadertoy.com/view/WtsfzM\n\n\n*/\n\n\n// Offsetting the triangle coordinates. The look is a lot cleaner without it.\n#define OFFSET_TRIS\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    return sin(p*6.2831853 + iTime/2.); \n}\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(289, 41)));\n    p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    return sin(p*6.2831853 + iTime); \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    // Cell ID and local coordinates.\n    vec2 i = floor(p); p -= i;\n    \n    // Four corner samples.\n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n    \n    // Bilinear interpolation -- Along X, along Y, then mix.\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n// Two layers of noise.\nfloat fBm(vec2 p){ return n2D3G(p)*.57 + n2D3G(p*2.)*.28 + n2D3G(p*4.)*.15; }\n\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n    \n    //float idm = 1. - s.x*s.y;\n    //if(idm == 0.) idm += 1e-6;\n    //mat2 inM = 1./(idm)*mat2(1, s.y, s.x, 1);\n    //return inM*p;\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n/*\n\n\n// Rounded triangle routine. Not used here, but handy.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2){\n     \n    vec3 inC = inCentRad(v0, v1, v2);\n    float ndg = .0002/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .0002;      \n        \n}  \n\n// Rectangle dimentions, and consequently, the grid dimensions.\n//const vec2 rect = vec2(1.25, .8)*scale;\n//const vec2 rect = vec2(1., 1.5)*scale;\n// Equilateral dimensions: Basically, the base needs to be lengthened by\n// a factor involving sqrt(3), which easily relates back to equilateral geometry.\n//const vec2 rect = (vec2(1./.8660254, 1))*scale; // \"1/.8660254 = 2*sqrt(3)/3\". \n\n// Skewing half way along X, and not skewing in the Y direction. Skewing is \n// inversely effected by scale.\n//const vec2 sk = vec2(rect.x*.5, 0)/scale;\n// Irregular skewing is possible too, since it's all just math.\n//const vec2 sk = vec2(rect.x*.5, -rect.y*.25)/scale;\n\n// From the the following example:\n// Random Delaunay Triangulation - Tomkh\n// https://www.shadertoy.com/view/4sKyRD\n//\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3){\n\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1, h1));\n   vec3 g2 = vec3(h2, dot(h2, h2));\n   vec3 g3 = vec3(h3, dot(h3, h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   //#if FLIP_ANIMATION\n    // return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   //#else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   //#endif\n}\n*/\n\n// Global vertices, local coordinates, etc, of the triangle cell.\nstruct triS{\n    \n    vec2[3] v; // Outer vertices.\n    vec2 p; // Local coordinate.\n    vec2 id; // Position based ID.\n    float dist; // Distance field value.\n    float triID; // Triangle ID.\n};\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\ntriS blocks(vec2 q){\n    \n\n    const float tf = 2./sqrt(3.);\n    // Scale.\n\tconst vec2 scale = vec2(tf, 1)*vec2(1./4.);\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n     // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(tf/2., 0);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID and block center.\n    vec2 id = vec2(0), cntr;\n    \n    // For block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n\n\n    // Height scale.\n    const float hs = .5;\n\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    triS gT, tri1, tri2;\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0];\n        // Skewed local coordinates.\n        p = skewXY(q.xy, sk);// - cntr*s;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Skewed rectangle vertices. \n        vec2[4] vert = ps4;  \n     \n        #ifdef OFFSET_TRIS\n        // Offsetting the vertices.\n        vert[0] += hash22B((idi + vert[0]/2.))*.2;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*.2;\n        vert[2] += hash22B((idi + vert[2]/2.))*.2; \n        vert[3] += hash22B((idi + vert[3]/2.))*.2;\n        #endif\n        \n        \n        // Unskewing to enable rendering back in normal space.\n        vert[0] = unskewXY(vert[0]*dim, sk);\n        vert[1] = unskewXY(vert[1]*dim, sk);\n        vert[2] = unskewXY(vert[2]*dim, sk);\n        vert[3] = unskewXY(vert[3]*dim, sk); \n        \n         \n        // Unskewing the rectangular cell ID.\n\t\tidi = unskewXY(idi*s, sk);  \n  \n      \n        // Some triangle flipping to ensure a Delaunay triangulation... Further non-Delaunay\n        // subdivisions will occur, so it's probably redundant, but it's here for completeness.\n        //float f = flipDistance(vert[0] - vert[2], vert[1] - vert[2], vert[3] - vert[2])<0.? 1. : -1.;\n \n        \n        // Partioning the rectangle into two triangles.\n        \n        \n        // Triangle one.\n        tri1.v = vec2[3](vert[0], vert[1], vert[2]); \n         //if(f>.5) tri1.v = vec2[3](vert[0], vert[1], vert[3]); // Delaunay flipping.\n        tri1.id = idi + inCentRad(tri1.v[0], tri1.v[1], tri1.v[2]).xy; // Position Id.\n        tri1.triID = float(i); // Triangle ID. Not used here.\n        tri1.dist = sdTri(p, tri1.v[0], tri1.v[1], tri1.v[2]); // Field distance.\n        tri1.p = p; // 2D coordinates.\n         \n        // Triangle two.\n        tri2.v = vec2[3](vert[0], vert[2], vert[3]);\n        //if(f>.5) tri2.v = vec2[3](vert[1], vert[2], vert[3]);  // Delaunay flipping.\n        tri2.id = idi + inCentRad(tri2.v[0], tri2.v[1], tri2.v[2]).xy; // Position Id.\n        tri1.triID = float(i + 4); // Triangle ID. Not used here.\n        tri2.dist = sdTri(p, tri2.v[0], tri2.v[1], tri2.v[2]); // Field distance.\n        tri2.p = p; // 2D coordinates.\n         \n        // Doesn't work, unfortunately, so I need to write an ugly \"if\" statement.\n        //triS gTi = tri1.dist<tri2.dist? tri1 : tri2;\n        triS gTi; \n        // Obtain the closest triangle information.\n        if(tri1.dist<tri2.dist) gTi = tri1; \n        else gTi = tri2;\n        \n        \n        // If applicable, update the overall minimum distance value,\n        // then return the correct triangle information.\n        if(gTi.dist<d){\n            d = gTi.dist;\n            gT = gTi;\n            //gT.id = idi + inCentRad(gT.v[0], gT.v[1], gT.v[2]).xy;\n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return gT;\n}\n\n/*\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\n*/\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*24.;\n    q += vec2(n2D3G(p*1.5), n2D3G(p*1.5 + 7.3))*.1;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .6); // Rough pencil sketch layer.\n    //\n    // Mix in a small portion of the pencil sketch layer with the clean colored one.\n    //col = mix(col, col*(ns + .3), .5);\n    // Has more of a colored pencil feel. \n    //col *= vec3(.8)*ns + .4;    \n    // Using Photoshop mixes, like screen, overlay, etc, gives more visual options. Here's \n    // an example, but there's plenty more. Be sure to uncomment the \"softLight\" function.\n    //col = softLight(col, vec3(ns)*.75);\n    // Uncomment this to see the pencil sketch layer only.\n    //if(mod(ip.x + ip.y, 2.)<.5) \n    // Grayscale override.\n    \n    col = vec3(ns); \n    \n \n    \n    return col;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes; \n    \n    // Warping the background ever so slightly. The idea is that\n    // pencil drawings don't have perfectly straight lines.\n    uv += vec2(fBm(uv*12.), fBm(uv*12. + .5))*.005;\n    \n    \n    // Unit direction vector. Used for some mock lighting.\n    vec3 rd = normalize(vec3(uv, .5));\n    \n    // Scaling and translation.\n    const float gSc = 1.;\n    vec2 p = uv*gSc;// + vec2(0, iTime/24.);\n    vec2 oP = p; // Saving a copy for later.\n    \n    // Resolution and scale based smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    \n    // Take a function sample. \n    triS gT = blocks(p);\n    \n \n    // Triangle vertices, local coordinates and position-based ID.\n    // With these three things, you can render anything you want.\n    vec2[3] svV = gT.v;\n    vec2 svP = gT.p;\n    vec2 svID = gT.id;\n\n    \n    // Initializing the scene color to black.\n    vec3 col = vec3(0);  \n     \n    // Triangle color.\n    vec3 tCol = vec3(0);\n    \n    \n  \n    // Bottom layer color, or shade.\n    vec3 lCol = vec3(.05);\n     \n    \n    \n    // The triangle pattern: Render three wedged triangles with vertex points\n    // at each line edge extreme and a third point on the adjacent tangential\n    // edge (look at the top layer for a visual). Slide the adjacent edge\n    // point back a bit, then render another layer. If you do this a few times,\n    // a triangular spiral pattern will appear. You can add to the effect by\n    // coloring and shading according to layer depth.\n    //\n    // The following is just the way I chose to effect the aforementioned, but \n    // there'd no doubt be better ways to go about it, so how you achieve the \n    // same is up to you.\n    //  \n    vec3 triPat = vec3(1e5);\n    \n    vec2[3] v = svV;\n    \n    vec2 rp = svP;\n    //rp = rot2(iTime)*rp;\n  \n    // Start and end nudge factors. The third point needs to be moved along\n    // a tangent edge. The further out it is, the more the triangles \n    // appear to rotate.\n    \n  \n    float nfs = .45, nff = .07;\n    const int iter = 4; // Iterations.\n    for(int i = 0; i<iter; i++){\n        \n        // Normalized edge tangent vectors.\n        vec2[3] tng = vec2[3](normalize(v[1] - v[0]), normalize(v[2] - v[1]),\n                           normalize(v[0] - v[2])); \n        \n        lCol *= 1.8; // Increase the color for each layer.\n        \n        // Interpolate the nudge point factor.\n        float nf = mix(nfs, nff, float(i)/float(iter));\n\n        // Three side triangles for this particular layer, which consist of \n        // two vertices and a third point that slides out from the adjoining\n        // side... Just refer to the outer layer for a visual reference.\n        \n        vec2 atp; // Third, adjacent tangential edge point.\n        float ndg;\n        \n        // Edge one triangle.\n        ndg = length(v[2] - v[1])*nf; // Nudge length (decreasing each iteration).\n        atp = v[1] + tng[1]*ndg; // Adjacent tangential edge point.\n        triPat[0] = sdTri(rp, v[0], v[1], atp); // Wedge triangle for this edge.\n \n        // Edge two triangle.\n        ndg = length(v[0] - v[2])*nf;\n        atp = v[2] + tng[2]*ndg;\n        triPat[1] = sdTri(rp, v[1], v[2], atp);\n        //vec2 nw1 = p2;\n\n        // Edge three triangle.\n        ndg = length(v[1] - v[0])*nf;\n        atp = v[0] + tng[0]*ndg;\n        triPat[2] = sdTri(rp, v[2], v[0], atp);\n       \n        // Rotated sprinkled noise for this layer.\n        mat2 r2 = rot2(3.14159*float(i)/float(iter));\n        float nsl = fBm((r2*(svP - svID.xy))*64.)*.5 + .5;//mix(tx, tx2, .8);\n    \n        // Fake shading and noise application.\n        float sh = float(iter - i - 1)/float(iter);\n        lCol = vec3(1)*1./(1. + sh*sh*2.5);\n        lCol *= nsl*.5 + .5;\n        \n        // Failed experiment with color.\n        //if((i&1)==0) lCol *= vec3(2, 0, 0);\n        \n        // Rendering the three triangle wedges to each side.\n        for(int j = 0; j<3; j++){\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., triPat[j] - .002))*.5);\n            col = mix(col, vec3(0), 1. - smoothstep(0., sf*2., triPat[j]));// + .005/3.\n            col = mix(col, lCol, 1. - smoothstep(0., sf*2., triPat[j] + .0035));// .005*2./3.\n        }\n        \n    }\n    \n    // Outer layer noise. This is applied to the border cords and points.\n    float ns = fBm((svP - svID.xy)*64.)*.5 + .5;\n \n    // Outside lines.\n    float ln = 1e5;\n    ln = min(ln, lBox(svP, svV[0], svV[1], 0.));\n    ln = min(ln, lBox(svP, svV[1], svV[2], 0.));\n    ln = min(ln, lBox(svP, svV[2], svV[0], 0.));\n    ln -= .0055; \n     \n    \n    lCol = vec3(ns*.5 + .5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4.*iRes/450., ln - .002))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., ln)));\n    col = mix(col, lCol*clamp(-ln/.005, 0., 1.), (1. - smoothstep(0., sf, ln + .0035)));  \n     \n    \n    // Vertices.\n    vec3 cir = vec3(length(svP - svV[0]), length(svP - svV[1]), length(svP - svV[2]));\n    float verts = min(min(cir.x, cir.y), cir.z);\n    verts -= .016;\n \n    vec3 vCol = lCol*.7;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5.*iRes/450., verts))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .005, verts)));  \n    col = mix(col, vCol, (1. - smoothstep(0., sf, verts + .0035))); \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, verts + .011))); // Pin staple hole. \n    \n    \n    // Slight pencil effect: Based on Flockaroo's pencil effect, which is far superior, so\n    // I'd definitely refer to that one, if you're interested in that kind of thing.\n    col = mix(col, pencil(col, oP), .5);\n    \n    // Applying a touch of color. It's a design cliche, but it works.\n    col = mix(col, col*vec3(1, .05, .1)/.7, (1. - smoothstep(0., sf, verts)));\n   \n  \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*1.05;\n    // Colored variation.\n    //col = mix(col*vec3(.25, .5, 1)/8., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}