{
    "Shader": {
        "info": {
            "date": "1695325852",
            "description": "Toroidal coil",
            "flags": 0,
            "hasliked": 0,
            "id": "mddyzj",
            "likes": 17,
            "name": "Toroidal Coil",
            "published": 3,
            "tags": [
                "sdf",
                "coil"
            ],
            "usePreview": 1,
            "username": "wyatt",
            "viewed": 481
        },
        "renderpass": [
            {
                "code": "float toroid (vec3 p, float r0, vec2 wh1, float r1) {\n    return roundbox(vec2(length(p.xy)-r0,p.z),wh1,r1);\n}\nvec3 normal_toroid(vec3 p,float r0, vec2 wh1, float r1) {\n    vec2 e = vec2(1e-5,0);\n    return normalize(vec3(\n        toroid(p+e.xyy,r0,wh1,r1)-toroid(p-e.xyy,r0,wh1,r1),\n        toroid(p+e.yxy,r0,wh1,r1)-toroid(p-e.yxy,r0,wh1,r1),\n        toroid(p+e.yyx,r0,wh1,r1)-toroid(p-e.yyx,r0,wh1,r1)\n    ));\n\n}\nfloat angleDiff(float a1, float a2) {\n    float diff = mod(a1 - a2, 2.0 * 3.14159265359);\n    return (diff > 3.14159265359) ? (diff - 2.0 * 3.14159265359) : diff;\n}\nfloat toroid_coil (vec3 p, float r0, vec2 wh1, float r1, float ta, float tb, float n, vec2 wh2, float r2) \n{\n    float b = wh2.x+r2;\nfloat a0 = atan(p.y,p.x);\n    float a1 = a0*n;\n    if (length(p.xy) == 0.) return p.z - wh1.y;\n    vec3 p0 = r0*vec3(cos(a0),sin(a0),0);\n    vec3 q = p-p0;\n    float a2 = atan(q.z,(dot(normalize(vec3(p.xy,0)),q)));\n    a0 += angleDiff (a2,a1)/n;\n    a1 = a0*n;\n    p0 = r0*vec3(cos(a0),sin(a0),0);\n    q = p-p0;\n    vec2 v = length(q)*vec2(cos(a1),sin(a1));\n    vec4 sq = squircle(v,wh1.x+b,wh1.y+b,r1+.5*b);\n    vec3 p1 = p0 + sq.z*vec3(normalize(p.xy),0) + abs(sq.w)*sin(a1)*vec3(0,0,1) ;\n\n    vec3 x = -sq.x*normalize(vec3(0,0,1))+sq.y*vec3(normalize(p.xy),0);\n    vec3 z = sq.y*normalize(vec3(0,0,1))+sq.x*vec3(normalize(p.xy),0);\n    vec3 y = cross(x,z);\n    vec2 u = vec2(\n        dot(p-p1,x),\n        dot(p-p1,y)\n    )*length(p1.xy)/r0;\n    return roundbox(u,wh2,r2);\n\n}\n\nfloat map (vec3 p, out vec3 q) {\n\n    float n = 3.+round(mod(iTime*123.,5.));\n    \n    float r0 = .6;\n    vec2 wh1 = vec2(.2,.5);\n    float r1 = .0;\n\n    vec2 wh2 = vec2(.1,.2);\n    float r2 = .01;\n    \n   float d = toroid_coil(p,r0,wh1,r1, 0.,360.,  n, wh2, r2);\n    float d1 = toroid(p,r0,wh1-.022,.5*r1);\n    q = (.5+max(sin(10.*iTime+vec3(3,2,1)),-.5));\n    float d2 = min(d,d1);\n    float d3 = abs(p.y+.7+.1*sin(.78*iTime)+.002*exp(-3.*d2)*sin(80.*(d2*exp(-.5*d2))))-.1;\n    if (d3 < d1 && d3 < d) {\n        q = vec3(.0);\n        return (d3);\n    }\n    if (d < d1) {\n        q *= 2.;\n        return d;\n    } \n    q = 1.-q;\n    return d1;\n    \n}\nfloat map (vec3 p) {\n    vec3 q ;\n    return map(p,q);\n}\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-3,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n    ));\n}\nfloat smooth_map (vec3 p) {\n    return smoothstep(-.01,+.01,map(p));\n}\nvec3 grad (vec3 p) {\n    vec2 e = vec2(.005,0);\n    float o = smooth_map(p-e.xyy);\n    return vec3(\n        smooth_map(p+e.xyy)-o,\n        smooth_map(p+e.yxy)-o,\n        smooth_map(p+e.yyx)-o\n    )/e.x;\n}\n#define AA 1\nMain {\n    if ((iFrame)%160>0) discard;\n    Q = vec4(0);\n    for (int x = -AA; x <= AA; x++)\n    for (int y = -AA; y <= AA; y++) {\n    vec3 p = vec3(0,-.2,-1.5);\n    vec2 u = 2.*(U+.5*vec2(x,y)/float(AA*2-1)-.5*R)/R.y;\n    vec3 d = normalize(vec3(u,1));\n    float t = .4+.5*sin(2.*iTime);\n    p.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    \n    vec3 \n        p_refract = p, p_reflect = p,\n        d_refract = d, d_reflect = d,\n        q_reflect = vec3(0),\n        q_refract = vec3(0);\n    for (float i = min(iTime,0.0); i < 400.; i++) {\n        if( p_refract.x>1000.0 ) break;\n        vec3 q;\n        {\n            float m = min(abs(map(p_reflect,q)),1.);\n            m = .5*m;\n            if (m < .01) {\n                m = .002;\n                d_reflect = normalize(d_reflect+.001*grad(p_reflect));\n                q_reflect += .1*q;\n            }\n            p_reflect += m*d_reflect;\n        }\n        {\n            float m = min(abs(map(p_refract,q)),1.);\n            m = .5*m;\n            if (m < .01) {\n                d_refract = normalize(d_refract-.001*grad(p_refract));\n                q_refract += .01*q;\n                m = .003;\n            }\n            p_refract += m*d_refract;\n        }\n    }\n    Q += (.2*vec4(.6+.4*q_reflect,1)*texture(iChannel0,p_reflect)+\n        0.3*vec4(.3+.7*q_refract,1)*texture(iChannel0,p_refract))/float((AA*2+1)*(AA*2+1));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\nfloat segment (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment(vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float line (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float smin( float a, float b, float k )\n        {\n            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n            return mix( b, a, h ) - k*h*(1.0-h);\n        }\n        float add (float a, float b) {\n            return min(a,b);\n        }\n\t\tfloat subtract(float a, float b) {\n\t\t    return max(a,-b+1e-6);\n\t\t}\n\t    float cylinder( vec3 p, vec2 h )\n\t\t{\n\t\t    h.y *= 0.5;\n\t\t    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat cylinder( vec3 p, float r, float h )\n\t\t{\n\t\t    return cylinder(p,vec2(r,h));\n\t\t}\n\t\tfloat sign_side (vec2 p1, vec2 p2, vec2 p3)\n        {\n            return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n        }\n        float PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n        {\n            float d1, d2, d3;\n            bool has_neg, has_pos;\n        \n            d1 = sign_side(pt, v1, v2);\n            d2 = sign_side(pt, v2, v3);\n            d3 = sign_side(pt, v3, v1);\n        \n            has_neg = (d1 < 0.) || (d2 < 0.) || (d3 < 0.);\n            has_pos = (d1 > 0.) || (d2 > 0.) || (d3 > 0.);\n        \n            return float((has_neg && has_pos))*2.-1.;\n        }\n        float triangle (vec2 p, vec2 a, vec2 b, vec2 c) {\n            return PointInTriangle(p.xy,a,b,c)*min(segment(p,a,b),min(segment(p,b,c),segment(p,c,a)));\n        }\n        float triPrism(vec3 p, vec2 a, vec2 b, vec2 c, float h) {\n          vec2 d = vec2(triangle(p.xy,a,b,c),abs(p.z)-.5*h);\n          \n          return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n        }\n\t\tfloat triPrism( vec3 p, vec2 h )\n        {\n          vec3 q = abs(p);\n          return max(q.z-.5*h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n        }\n        float segment ( vec3 p, vec3 a, vec3 b, float r )\n        {\n          vec3 pa = p - a, ba = b - a;\n          float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n          return length( pa - ba*h ) - r;\n        }\n\t\tfloat box(vec2 p, vec2 b) {\n\t\t\tvec2 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box( vec3 p, vec3 b )\n\t\t{\n\t\t    vec3 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box(vec3 p, float w, float h, float l) {return box(p,vec3(w,h,l));}\n\t\tfloat box(vec2 p, float w, float h) {return box(p,vec2(w,h));}\n\t\tfloat roundBox ( vec3 p, vec3 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return cylinder(p,vec2(r,b.z));\n\t\t}\n\t\tfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return length(p)-r;\n\t\t}\n\t\tfloat roundBox(vec3 p, float w, float h, float l, float r) {return roundBox(p,vec3(w,h,l),r);}\n\t\tfloat roundBox(vec2 p, float w, float h, float r) {return roundBox(p,vec2(w,h),r);}\n\t\t\n\t\t#define roundbox roundBox\n\t\t#define round_box roundBox\n        \n        \n        \n        float circle(float theta, vec2 u, float r) {\n            float b = -2.*u.x*cos(theta)-2.*u.y*sin(theta);\n            float c = u.x*u.x+u.y*u.y-r*r;\n            float det = b*b-4.*c;\n            if (det>=0.)\n                return  .5*(-b + sqrt(det));\n            else return 1e9;\n        }\n        vec3 circle3(float theta, vec2 u, float r) {\n            vec2 d = vec2(cos(theta),sin(theta));\n            float b = -2.*u.x*d.x-2.*u.y*d.y;\n            float c = u.x*u.x+u.y*u.y-r*r;\n            float det = b*b-4.*c;\n            if (det>=0.) {\n                float i = .5*(-b + sqrt(det));\n                vec2 v = normalize(d*i-u);\n                return vec3(-v.y,v.x,i);\n            }\n            else return vec3(0,0,1e9);\n        }\n        float line(float theta, float r, float a) {\n            return r/float(cos(a-theta));\n        } \n        #define pi 3.14159265359\n        float arctan(float y, float x) {\n            float a = atan(y,x);\n            if (a < 0.) a = 2.*pi+a;\n            return a;\n        }\n        vec4 squircle (vec2 p, float w, float h, float r) {\n            float theta = arctan(p.y,p.x);\n            h = max(h,1e-9), w = max(w,1e-9);\n            h *= .5; w *= .5;\n            h -= r; w-= r;\n            if (p.x>=w&&p.y>=h){\n                return vec4(normalize(vec2(-p.y+h,p.x-w)),vec2(w,h)+r*normalize(p-vec2(w,h)));\n            }\n            if (p.x<=-w&&p.y>=h) {\n                return vec4(normalize(vec2(-p.y+h,p.x+w)),vec2(-w,h)+r*normalize(p-vec2(-w,h)));\n            }\n            if (p.x<=-w&&p.y<=-h) {\n                return vec4(normalize(vec2(-p.y-h,p.x+w)),vec2(-w,-h)+r*normalize(p-vec2(-w,-h)));\n            }\n            if (p.x>=w&&p.y<-h) {\n                return vec4(normalize(vec2(-p.y-h,p.x-w)),vec2(w,-h)+r*normalize(p-vec2(w,-h)));\n            }\n            \n            vec2 i = vec2(max(w-h,0.),max(h-w,0.));\n            if (p.x>+i.x&&abs(p.x)-i.x>abs(p.y)-i.y) return vec4(0,1,w+r,p.y);\n            if (p.y>+i.y&&abs(p.x)-i.x<abs(p.y)-i.y) return vec4(-1,0,p.x,h+r);\n            if (p.x<-i.x&&abs(p.x)-i.x>abs(p.y)-i.y) return vec4(0,-1,-w-r,p.y);\n            if (p.y<-i.y&&abs(p.x)-i.x<abs(p.y)-i.y) return vec4(1,0,p.x,-h-r);\n            \n            \n        }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}