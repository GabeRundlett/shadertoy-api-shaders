{
    "Shader": {
        "info": {
            "date": "1537897888",
            "description": "fork of \nhttps://www.shadertoy.com/view/ldsBz8\noh right i forgot that in blackmidi, with CSG, you can just draw distance functions on the music sheet.\nand even animate them in play-time",
            "flags": 8,
            "hasliked": 0,
            "id": "XtGyW3",
            "likes": 3,
            "name": "SDF 2audiovisual 2blackmidi",
            "published": 3,
            "tags": [
                "music",
                "pony",
                "sequence",
                "audiovisual",
                "hall",
                "earthbound",
                "inside",
                "sheet",
                "cutiemark",
                "blackmidi",
                "starguitar",
                "mother2"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 970
        },
        "renderpass": [
            {
                "code": "//oh yes, i forgot how easy blackmidi is.\n//you can basically paint an sdf within the function\n//sheet(vec2 u)\n//at the bottom of the [Common] tab\n\n//This shader\n//https://www.shadertoy.com/view/ldsBz8\n//has the parent:\n//https://www.shadertoy.com/view/MdXfW4\n//[ldsBz8] uses the [common] tab feature, that was added netween the 2 above links\n//while [MdXfW4] has the sequence-functions of sheet() duped.\n\n//all comments about how the same functions \n//are used to show a sequence and how to make it audible are in the\n//[common] tab\n\n//please have the common tap support iResolution.xy and iMouse, and whatnot.\n\n//iResolution is read by frame(), therefore it can not move to the common tab:\n#define zoom 50.\n//#define frame(u) zoom*(u-.5*iResolution.xy)/iResolution.y\nvec2 frame(vec2 u){u/=iResolution.xy;u.x*=iResolution.x/iResolution.y;return u*zoom;}\n\n\n\n//this block adds a cutiemark mouse cursor\n//\n//with  ;O=pdOver(cuteCursor(U,iMouse.xy),O);}// at the end of MainImage()\n#define vec1 float\n//porter duff alpha compositing:\n//i do not define ut ..., because its a too short namespace to be spent on a define.\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}//#define ut(a,b) (a*(1.-b))\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\n//self:https://www.shadertoy.com/view/MsffWr\n//https://www.reddit.com/r/mylittlepony/comments/6d3kqb/cutiemark_shader_texture_cheerilee/\n//cheerilee cutie mark flowers\n//cartoon pony butt for reference:\n//https://vignette3.wikia.nocookie.net/mlp/images/3/3f/Cheerilee%27s_cutie_mark_S1E12.png/revision/latest?cb=20121118163857&format=original\n#define tau 6.28318530718\n//return distance of(p)to ray that starts at(0,0)and has direction(0,-1);\nfloat ils(vec2 p){return mix(abs(p.y),length(p),step(0.,p.x));}\n//return cathesian of polar_modulo http://mercury.sexy/hg_sdf\nfloat pModPolar(inout vec2 p,float t){float g=tau/t,a=atan(p.y,p.x)+g*.5,r=length(p),\n c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\n//return polar of carthesian input\nvec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//return carthesian of polar input\nvec2 p2c(vec2 u){return vec2(u.x*cos(u.y),u.x*sin(u.y));}\n//#define r2(r)mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r:p=r(p,r);\n#define r(p,r)(cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//rotate around offset point\n//vec2 rOffset(vec2 p,float r,vec2 o){p-=o;return(cos(r)*p+sin(r)*vec2(-p.y,p.x))+o;}\n//8bit color picker values to [0..1]\nvec3 bit82vec3(int r,int g,int b){return vec3(r,g,b)/255.;}\n//return brightness of eyes and mouth\nfloat eyes(vec2 w,float n){\n w=c2p(w);//we branch modify for one polar coordinate,therefore we must transform.\n if(n!=0.)w.y+=2.*n; w.y+=.5*sin(iTime+n); w=p2c(w); w.x*=1.2;\n n=pModPolar(w,3.);//eyesand mouth are a 3fold ,within 3fold flowers.\n w.x-=.14; w=c2p(w); w.y+=4.7; if(n==1.)w.y+=1.;if(n==0.)w.y-=1.; w=p2c(w);\n const float blur=.01;\n//return smoothstep(blur,-blur,max(length(w)-.1,0.));//debug Ooooooo-face\n return smoothstep(blur,-blur,max(length(w)-.08,-length(w-vec2(0,.04))+.1));}\nvec2 fra(vec2 u){u/=iResolution.xy;u-=.5\n ;u.x*=iResolution.x/iResolution.y;u*=2.;return u;}\nvec4 cuteCursor(vec2 u,vec2 m\n){float scale=6.+cos(iTime)*4.//reciprocal=inverse scalingFactor of the image\n ;u*=scale;u=fra(u)\n ;m*=scale;m=fra(m);u-=m//center at mouse position\n ;float w=length(u)\n ;float aas=4.*scale/min(iResolution.x,iResolution.y)\n ;w=smoothstep(aas,-aas,w-1.2)\n ;const float blur=.01;\n float n;\n u=r(u,3.);\n u.y+=.07;\n n=pModPolar(u,3.);//3 fold symmetry for 3 dflowers\n u+=vec2(-.55-n*.055,.1+n*.1);//offset within 3fold\n float d=smoothstep(blur,-blur,length(u)-.25);//yellow flower circle.\n u=r(u,.5*cos(iTime+n));//rotate whole flower\n float e=eyes(u,n);\n n=pModPolar(u,8.);//8fold symmetry for pebbles.\n float p=ils(u-vec2(.31,0));//flower pebbles=distance to ray==infiniteLineSegment\n p=smoothstep(blur,-blur,p-.11);//pink flower pebbles \n vec3 cBG=bit82vec3(195,111,160);//color background cheerilee cutiemark eye&&mouth&&body\n vec3 cYe=bit82vec3(247,244,177);//color yellow  cheerilee cutiemark circles\n vec3 cPi=bit82vec3(244,215,227);//color pink    cheerilee cutiemark pebbles\n vec3 r;\n r=mix(cBG,cPi,p);//mix background with pink pebbles\n r=mix(r,cYe,d);//add yellow circles to mix\n r=mix(r,cBG,e);//add eyes and mouth to mix \n return vec4(r*w,w);}\n\n\n\n//if only webaudio could be synchronized to anything, even webgl.\nfloat dirigent(vec2 U\n){U+=iResolution.xy/2.\n     //when hitting the reverse key, \n     //the white bar shoulc be at the left end of the screen.\n //i failed to sync thois to any resolution. why!!!\n ;vec2 u=fra(U)\n ;vec2 m=fra(U)    \n ;u.x+=.17//fiddly sync button,start offset, start must be left end side!\n ;u.x-=iTime*tempo*.039//fiddly tempo, should be easier to sync\n ;u.x=abs(u.x)\n ;float aas=16./min(iResolution.x,iResolution.y)\n ;u.x=smoothstep(aas,-aas,u.x-aas/8.)\n ;return u.x\n ;}\n\n\n\n//main purpose is to paint sheet(uv)   \n//if(a==black_piano_key)return 1.;return 0.;\nfloat keyShade(float a){a=mod(a,12.);return (mod(a+step(5.,a),2.));}\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec2 M=iMouse.xy\n //;U=U*2.-iResolution.xy*.5\n //;M=M*2.-iResolution.xy*.5\n ;vec2 u=frame(U)//sheetMusicFraming have .x==0 at left border, not centered\n ;u.y-=30.//transpose by 1 octave.\n ;float d=sheet(u,iTime)\n ;u.y=keyShade(floor(u.y))*1.2//blue==black piano keys.\n ;u.x=fract(u.x)\n ;u*=.5;//to make red more visible.\n ;O=vec4(d,u,.1)\n ;O.xyz+=vec3(dirigent(U))\n ;//O.xyz*=O.w//if(O.w==1){no premultiply by *=1. needed, duuh!}else{pdOver needs O.xyz*=O.w;}\n ;O=pdOver(cuteCursor(U,M),O)\n ;//O=mainImage2(U,iMouse.xy);//debug()\n ;}\n/*\n//todo, add a remap() function to zoom and scroll with mouse.xyzw\n//something like:\n//\n//https://www.shadertoy.com/view/4l2BRD\n// remap v from range [min1,max1] to range [min2,max2]// this is unlerp+lerp combined\nfloat remap(float v,float min1,float max1,float min2,float max2\n){return min2+(max2-min2)*(v-min1)/(max1-min1);}\nfloat bias(float x,float b){return pow(x,log(b)/log(0.5));}\nfloat gain(float x,float g){return (x<0.5) ? bias(2.*x,1.-g)/2. : 1. - bias(2.-2.*x,1.-g)/2.;}\n// aaFloor is similar to floor() but has a 2-pixel wide gradient between clamped steps\n// to allow the edges in the result to be anti-aliased.\nfloat aaFloor(float x\n){float dx=2.*length(vec2(dFdx(x),dFdy(x)))\n ;float fx=fract(x),idx=1.-dx\n ;return (fx < idx) ? x - fx : remap(fx,idx,1.,x-fx,x);}\n// Same as aaFloor;clamp except for a 2-pixel wide gradient along the edge\nfloat aaFract(float x\n){float dx=2.*length(vec2(dFdx(x),dFdy(x)))\n ;float fx=fract(x),idx=1.-dx\n ;return (fx<idx) ? fx : remap(fx,idx,1.,fx,0.);}\n// escalator() is similar to aaFloor(),but takes a phase offset for animating\nfloat escalator(float x,float steps,float o\n){float dx=1./steps\n ;x=remap(x,0.,1.,-dx/2.,1.+dx/2.)+dx/2.\n ;float ex=(x - o*dx)*steps\n ;float ey=(aaFloor(ex)+o)*dx\n ;return clamp(ey,0.,1.);}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//the [children of Nancarrow] insist on an [irrational tempo]\n// in spite of planck scales and quantum physics (and other audio quality modifiers)\n// apparently insisting on quantizing all the music.\n//#define tempo sqrt(5.)*2.\n\n\n\n//the sheet() function is used by [image] and [sound] to become audiovisual\n\n//this is old code that is still bad, for the sake of simplicity.\n//- main issue is that the end of a note is always hard, there is null transitioning\n//- which generates popping-noise at the end of each note.\n\n//parent: https://www.shadertoy.com/view/ldsBz8\n//parent should have less sequences or more bugs.\n\n\n/*\nmelody is \nhttps://www.youtube.com/watch?v=W5Z35jk1E4w\nis\n[The Magic Inside] by [Daniel Ingram and Lena Hall]\nis ponies:\nhttps://www.youtube.com/watch?v=buuYIBejsuM\n*/\n\n\n#define vec1 float\n\nfloat mi(vec1 a){return a;}\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec3 a){return min(mi(a.xy),a.z);}\nfloat mi(vec4 a){return min(mi(a.xy),mi(a.zw));}\n//filtering functions are named by what still needs to be filtered by the function.\n//T filters time\n//F filters frequency //stored as integer addresing piano keys, to avoid any precision errors within range [-300,300] and to floor() and <>1.\n//- - for type int compatibility and tiny pixelperfect music sheets\n//- - u.y is (already) scaled to a scale, where 0=C220Hz ; 1=C# , 2=D 3=D# ...\n//I filters instrument //irder undecided, is likely a top level filter)\n//input [d] should vary for each function call, to flavor functions, for debugging visualization (with patterns)\n#define cMiss(d) vec4(-300,-300,d,0)\n//chord* plays multiple notes of keys [f] in timespan [t.x ... t.y],  fun here is that chordT() is implied by a mod(time,n) fold\n//because all 4 notes are the same (besides frequency input) (after time-folding)\n//chordF() assumes that time is already filtered by chord() or by the timeFilter of chord() of a higher mod() or floor() function.\nvec4 chordF (       vec4 f,vec2 t,float d){if(mi(f)<1.)return vec4(t.xy,d,1);return cMiss(d);}\nvec4 chordFT(vec2 u,vec4 f,vec2 t,float d){if(u.x>=t.y||u.x<=t.y){return chordF(abs(f-u.y),t,d);}\n \n    return cMiss(d);}\nvec4 chordF (       vec3 f,vec2 t,float d){if(mi(f)<1.)return vec4(t.xy,d,1);return cMiss(d);}\nvec4 chordFT(vec2 u,vec3 f,vec2 t,float d){if(u.x>=t.y||u.x<=t.y){return chordF(abs(f-u.y),t,d);}return cMiss(d);}\nvec4 chordF (       vec2 f,vec2 t,float d){if(mi(f)<1.)return vec4(t.xy,d,1);return cMiss(d);}\nvec4 chordFT(vec2 u,vec2 f,vec2 t,float d){if(u.x>=t.y||u.x<=t.y){return chordF(abs(f-u.y),t,d);}return cMiss(d);}\nvec4 chordF (       vec1 f,vec2 t,float d){if(mi(f)<1.)return vec4(t.xy,d,1);return cMiss(d);}\nvec4 chordFT(vec2 u,vec1 f,vec2 t,float d){if(u.x>=t.y||u.x<=t.y){return chordF(abs(f-u.y),t,d);}return cMiss(d);}\n//chordF() assumes that f is already differentialed but not framed AND that time is framed, \n//chordFT() explicitly prepares for chordF(), likely overly explicit, for early development.\n\n\n//the trick with chordF is to fold linear space over linear time and over linear frequency ranges.\n\n//up to 4 [laddering] notes are trickier, because a nonlinear frequency domain resolves by a loop or tree:\n//a sequence of 4 notes of keys s.xyzw (in sucession) from time t.x till time t.y\n//tree is primarily by time, because time is linear, while frequencies may not be linear.\n//f=frequencies//t=timeStartEnd, d=noteGroupId\nvec4 sequeT (vec1 u,vec1 f,vec2 t,float d){return chordF(f,t,d);return cMiss(d);}\nvec4 sequeT (vec1 u,vec2 f,vec2 t,float d){vec1 T=mix(t.x,t.y,.5);if(u>T)return chordF(f,vec2(T,t.y),d);return chordF(f,vec2(t.x,T),d);}\n//vec4 sequeT (vec1 u,vec3 f,vec2 t,float d){vec1 T=t.x+(t.x-t.y)/3.;if(u>T)return sequeT(f,vec2(T,t.y),d);return chordF(f,vec2(t.x,T),d);}\nvec4 sequeT (vec2 u,vec1 f,vec2 t,float d){return sequeT(u.x,abs(f-u.y),t,d);}\nvec4 sequeT (vec2 u,vec2 f,vec2 t,float d){return sequeT(u.x,abs(f-u.y),t,d);}\n//vec4 sequeT (vec2 u,vec3 f,vec2 t,float d){return sequeT(u.x,abs(f-u.y),t,d);}\n//vec4 sequeT (vec2 u,vec4 f,vec2 t,float d){return sequeT(u.x,abs(f-u.y),t,d);}\n//vec4 sequeFT(vec2 u,vec2 f,vec2 t,float d){f=abs(f-u.y);vec2 T=mix(t.x,t.y,.5)             \n//    ;if(u.x>T  )return sequeT(u,f.x ,t,d);return sequeT(u,f.y,t,d)\nvec4 sequeFT(vec2 u,vec3 f,vec2 t,float d){\n     f=abs(f-u.y);vec2 T=t.x+(t.y-t.x)*vec2(1,2)/3.  ;if(u.x>T.y)return sequeT(u,f.z ,t,d);return sequeT(u,f.xy,t,d);}\nvec4 sequeFT(vec2 u,vec4 f,vec2 t,float d){f=abs(f-u.y)\n     ;vec3 T=t.x+(t.y-t.x)*vec3(1,2,3)/4.;if(u.x>T.y)return sequeT(u,f.zw,t,d)\n         ;return sequeT(u,f.xy,t,d);}\nvec4 sequeFT(vec2 u,mat4 f,vec2 t,float d){vec3 T=t.x+(t.y-t.x)*vec3(1,2,3)/4.\n ;if(u.x>T.z)return sequeFT(u,abs(f[3]-u.y),t,d)\n ;if(u.x>T.y)return sequeFT(u,abs(f[2]-u.y),t,d)\n ;if(u.x>T.x)return sequeFT(u,abs(f[1]-u.y),t,d)\n ;           return sequeFT(u,abs(f[0]-u.y),t,d);}//8 notes with equal lengths.\n\n//naive sequence, while i debug the above\nvec4 seqN(vec2 u,vec4 s,vec2 t,float d\n){\n ;if(u.x<t.x)return vec4(-300,-300,d,0)\n ;if(u.x>t.y)return vec4(-300,-300,d,0)\n ;s=abs(s-u.y)\n ;s.x=mi(s)\n ;if(s.x<1.)return vec4(300,300,d,0)\n ;return  vec4(300,300,d,0)\n ;//s=abs(s-u.y)\n ;//if(s.x==u.x&&)  \n //;float i=(t.y-t.x)*.25//4 notes in interval (t.y-t.x), i is now note length\n// ;float j=0.;for(int l=0;l<4;i++){if((s[l])>0.)\n         \n         \n //        return vec4(t.x+j*i+vec2(0,i),d,1);j++;}\n ;}\nfloat seqn(vec2 u,vec4 s,vec2 t,float d\n){vec4 e=seqN(u,s,t,d);if(t.x<u.x&&t.y>u.x)return 1.;return 0.;}\n\nfloat BadAppleA(vec2 u){\n //;u.x=mod(u.x,3.)\n ;return seqn(u,vec4(2,3,6,4),vec2(5,10),4.)\n ;//vec4 a=seqn(u,vec2(1,4),vec2(0,5),1.)\n ;//if(a.x<u.x)return 0.;return 1.;\n ;   //2.3 4.5 6-6 7.9   /6-6 2-2 6.5 4.3\n ;return .5\n ;}\n\n\n//melody to \"i am just a pony\"\nfloat BadApple(vec2 u){\n ;return BadAppleA(u)\n ;u.x=mod(u.x,64.);\n //if(u.x<0.) return 0.;//left end is 0;\n //if(u.x<64.)//stop or keep looping?\n return 0.;}\n\n//#define modPackFilter\n//the thing i wanted to include via [modPackFilter] is\n//  https://www.shadertoy.com/view/XsXfD4\n//but without offset-welding it sounds bad on longer notes.\n\n/*\nyour waveform editor may have an y=f(x) function to synthesize a sample.\nYou would not think to define a full midi track with all instromends as single function.\nBut it is pretty easy, and with Rasterisation it is pretty efficient.\n\nMany concepts that aid encoding music are usually not associated with music, \n...unless you insist on quantizing a midi, this shader goes down this path:\nhttps://en.wikipedia.org/wiki/Quantization_(signal_processing)\nhttps://en.wikipedia.org/wiki/Rasterisation\nhttps://en.wikipedia.org/wiki/Tessellation\nhttps://en.wikipedia.org/wiki/Wallpaper_group\nhttps://en.wikipedia.org/wiki/Glide_reflection\n*/\n\n\n/*\nxAxis=time\nyAxis=pitch\ndefining a bitmap to be used as:\n- a bitmap factor (for the below 2)\n- - a 3d distance field modifier\n- - a Webaudio input \"Sound\" buffer\n\nThe tricky part is to define it procedurally, with subroutines\n...instead of defining an array of notes.\nProcedurally, I get a lot of repeating sequences that can be transformed in many ways.\nThat creates an associative sequence library.\n\nThis is my first attempt at this. first steps are the hardest, building a function library\n... learning what works best, pioneering through all the useless deserts.\n\ni did an abc parser    in second-life-script, so this should be simple.\ni did ChordName2Cord() in second-life-script, so this should be simple.\nbut the wide namespace of valid chord names made the parser 55k in size, \n...able to parse ALL jazz chords. this will likey get inside here, too, soon.\n*/\n\n\n//a sequence of 4 notes, set by [a], is checked for a match with u.\nfloat seq4(vec2 u,vec4 a){\n u.x=mod(u.x,4.);\n for (int i=0;i<5;i++){if(float(i)==u.x&&a[i]==u.y)return 1.;}return 0.;}\n//LeadTail() is one of 2 sequences\nfloat LeadTail(vec2 u,float c){\n if(c==0.)return seq4(u,vec4(9,11,9,7));\n if(c==1.)return seq4(u,vec4(8,7,5,3));\n return 0.;}\n//initael Lead has 2 main sections, in 2 variants each.\n//first  section repeats more, and is less \"sequential\"\n//second section is labeled LeadTail(), is one of 2 simple 4_key_sequences.\nfloat Lead(vec2 u){\n float c=floor(u.x/16.);\n c=mod(c,2.);\n u.x=mod(u.x,16.);\n if(u.x>4.*3.-1.)return LeadTail(u,c);\n float l=3.+c*2.;//the lower note of the period varies.\n u.x=mod(u.x,3.);//a 3*periodic (1*low 2*high) interval is \"LadHead()\":\n if(u.x>0.&&u.y==8.)return .7+.3*step(u.x,1.);//the higher note has 2*length, second part has less color.\n else if(u.x<1.&&u.y==l)return 1.;//else lower note of the period\n return 0.;}\n \n//sequence for baselines, tend to be held down for longer;\n//....x got divided by something to make notes longer. \nfloat seq4b(vec2 u,vec4 a){\n u.x=mod(u.x,4.);\n for (int i=0;i<5;i++){\n  float j=float(i);\n  if(a[i]==u.y){\n   if(j<u.x&&j>u.x-1.)return .7;\n   if(float(i)==u.x)return 1.;}\n }return 0.;}\n//single long note with pitch [a.x], from [a.y] to [a.z] \nfloat lon(vec2 u,vec3 a){\n if(u.y==a.x){\n  if(u.x==a.y)return 1.;\n  return step(a.y,u.x)*step(u.x,a.z)*.7;\n }return 0.;} \n//pmodN() folds y to create one overtone.\nfloat pmodN(float y){float c=floor(y/12.);\n if(y>0.||y<-24.)return -99.;//if (out of bounds) become -99, outside of other iteration loops, would be inaudible.\n return mod(y,12.);}//else if(within bouns), modulo fold.\n//initial baseline has an oddly long note, pitch 1, from 15 to 25, played 2x.\nfloat BaseMainOdd(vec2 u){u.x=mod(u.x,32.);return lon(u,vec3(1,16,27));}\n//initial baseline  has one \"overwrite\" sequence.\nfloat BaseMainO1(vec2 u){return seq4b(u,vec4(1,8,14,8)-24.);}\n//initial baseline sequence with one overwrite.\nfloat BaseMain(vec2 u){\n if(u.x>15.&&u.x<16.+8.){\n  if(u.x>21.)return lon(u,vec3(-16,22.,24.));\n  if(u.x>19.)return lon(u,vec3(-23,20.,22.));\n  return BaseMainO1(u);}//end of the overwrite.\n //start of the initial main baseline.\n u.y=pmodN(u.y);//pmodN() creates one overtone.\n u.x/=8.;//8* longer note durations\n u.x=mod(u.x,4.);return seq4b(u,vec4(8,6,1,3));}//main base sequence.\n//initial baseline has one specific (longer) lote near the end\nfloat long2(vec2 u){return lon(u,vec3(-16,52,55));}\n\nfloat BaseMix(vec2 u){return max(long2(u),max(BaseMainOdd(u),BaseMain(u)));}\n\n\n//melody to \"i am just a pony\"\nfloat IAmJustAPony(vec2 u){\n u.x=mod(u.x,64.);\n //if(u.x<0.) return 0.;//left end is 0;\n //if(u.x<64.)//stop or keep looping?\n return max(BaseMix(u),Lead(u));}\n\n\n#define tempo 4.5\n#define volume .05\n\n\n#define sat(a) clamp(a,0.,1.)\n\n//return 1 on some tiles, 0 on others.\n//this is a wrapper function, indented to switch and mix sheets.\nfloat sheet(vec2 u,float t){u=floor(u); //u is tileID positions\n                            \n                            \n                            \n                            \n   ;//return BadApple(u)\n           ;t=u.x*.1-u.y*.1 //how about playing sheet music while it changes over time by uncommentign this line\n         \n //u.x=mod(u.x,64.)\n ;float a=1.-max(u.x,u.y)\n ;vec2 b=u\n ;vec2 c=u\n ;u.y+=cos(u.x/7.+t)*5.\n ;if(u.x>30.){\n  ;u.x+=(abs(u.y*.3)-2.)\n  ;u.x-=15.\n   ;u=abs(u)-6.\n  ;u.y-=mod(u.x-4.,8.)+4.\n  ;u.x=mod(u.x+4.,8.)-4.     \n  ;u.y=abs(u.y)-4.\n  ;u.x=length(u)-5.\n\n ;}else{\n  ;u.x+=u.y\n  ;u.x=min(u.x,length(u-vec2(14.,-5))-4.)\n  ;}\n ;u.x=abs(u.x)\n ;u.x=floor(u.x+cos(t)*.5-.002*b.x)\n //optional reduction of some frequencies, by using b and c\n ;b.y-=cos(u.y)*.4\n ;b.y=min(mod(b.y,21.),mod(b.y,13.))\n ;b.y+=cos(c.x)*4.\n ;if(b.y<2.)b.y=0.\n ;b.y=min(b.y,mod(b.y,3.))\n ;if(b.y<2.)b.y=0.\n //;b.y=mod(b.y,2.)\n //;b.y=floor(b.y)\n ;u.x=max(u.x,1.-b.y-.4)//the -.4 makes gradients visible\n     //, but they are below a threshold of being audible.\n\n ;return 1.-u.x//you want to invert here for intuitive distance function logic. my bad!\n ;//return mod(u.x-u.y,2.)\n ;//return IAmJustAPony(u)\n ;}//if(IAmJustAPony(u))return 1.;return 0.;}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define tau acos(-1.)*2.\n\n//return wavelength of piano key, [a] is relative to C4\nfloat wkey(float a){return 440.*pow(2.,a/12.);}\n//return 12th root of [a]\n//float troot(float a){a=max(.001,abs(a));return pow(a,12./a);}\n\n//this implements an attempt of cutting off a period only at its end.\n// It lacks offset calculations [offset-welding] for longer notes\n// ,therefore sounds bad for longer notes, you can hear the gaps.\n//it is a relatively simple bug, easy to fix, but i am bored of it.\n\n//this lacks [offset-welding], all else is \"fine\", as in , max volume till the end.\n//return how many times period [a] fits into period [b].\nfloat howManyAfitInB(float a, float b){if(a==0.)return 0.;return floor(b/a);}\nfloat howManyFitIn(float a){if(a==0.)return 0.;return floor(1./a);}\n//if (x < largest_possible_stack_of_interval_p ) return 1; return 0; //[p]PeriodLength (wavelength)\nfloat packsin(float x,float p){return step(abs(x),p*howManyFitIn(p));}\n//is oblivious about negative input ranges. see\n// https://www.shadertoy.com/view/MsXfWN\n//or its parent \n// https://www.shadertoy.com/view/XsXfD4\n\n//MsXfWN actually seems to almost solve [offset-welding]\n\n//if(a==black_piano_key)return 1.;return 0.;\n//float keyShade(float a){a=mod(a,12.);return (mod(a+step(5.,a),2.));}\n//for the above, it is likely simple to instead...\n// define \"not white\" piano keys, than to define \"black\" piano keys.\n//the piano by iq uses the \"not white\" keys approach to remove some black keys.\n//this likely saves some divisions, but adds one max(a,-b), better overall?\n\n//very often you parse a sequence of 4 notes of the same length per note.\n//thsis checks a single freuency_band==key for a match with such a sequence\n//for a set slice of time.\n//a is 4 numbers, representing a seuence of 4 different enumerated piano keys==pitches.\n//u.xy is a sqare on the sheed as you see it in the shader.\n//it retuens if there is a note played on that square or not. later on, notes tint the sheet red.\n//a sequence of 4 notes, set by [a], is checked for a match with u.\n\n//return average speaker position, assuming that range [0..[k]] keys on a sheet play at once, within key[l] till key[l+r] (inclusively)\nfloat sheetAcc(float x){ \n //midi poano has keys range [1..128], with middle C4 = key #40 ?\n float a=0.;\n for(float i=-41.;i<89.;i++){//is a bit larger than full midi piano range\n  if((sheet(vec2(x,i),x/tempo)>.45)){\n   float w=wkey(i-12.*log2(tempo));//w==frequency in Hz; if(i==40)w=440. ish ?\n   #ifdef modPackFilter\n    float d=packsin(fract(x),1./w);//an incomplete filter, uses wavelength.\n    a+=d*sin(w*fract(x)*tau);//periodic waveform, better for single short notes.\n   #else\n    a+=sin(tau*x*w);//waveform, cut off by tiles\n   #endif\n }}\n a/=4.;//average of [k] sinusoids. if (more sinusoids play at the same time) you fucked up\n //a=clamp(a,-1.,1.);//range clamping, the lazy solution.\n //a=atan(a)/(acos(-0.));//range atanIng: a=atan(a)*.5/pi//evenly distort frequencies over time in favor of keeping ampllitude sums within range [-1..1]\n //a=log(a)-log(1.);//naaah, not worth it!\n //a=fract(abs(a))*sign(a);//physically a horrible idea. it tortures the speaker!\n return a;\n}\n\nvec2 mainSound( in int samp,float t){\n return vec2(sheetAcc(t*tempo))*volume;\n //float w=wkey(0.);//w=440.;\n //return vec2(sin(tau*t*w));\n}\n\n//float fade(float t){return exp(-3.0*t);}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}