{
    "Shader": {
        "info": {
            "date": "1675693155",
            "description": "Trajectory of a gradient descent (red) towards a conic section (blue) compared to the \"lagrange curve\" (yellow) and a\n\"corrected\" gradient descent for finding the nearest point (aka the intersection of the conic and its lagrange curve) (green).",
            "flags": 0,
            "hasliked": 0,
            "id": "Dl2Xz1",
            "likes": 3,
            "name": "Gradient descent visualization",
            "published": 3,
            "tags": [
                "2d",
                "lagrange",
                "gradientdescent"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "/*\nSee https://www.shadertoy.com/view/mlB3RD and the linked shaders for some background.\nWhat i call \"lagrange curve\" is probably called totally different in literature,\nbut i didn't really bother to find out the real name yet ^^\n*/\n\n//#define CORRECTION_VARIANT\n\nconst float pi = 3.1415925;\n\nconst int num_segments1 = 32; //number of segments moving forward\nconst int num_segments2 = 128; //number of segments moving backward\nconst float step_size = .07; //segment size\n\nconst float zoom = 3.;\n\nconst float random_offset_factor=.2;\n\nconst float line_width = .004;\nconst float dot_size = .02;\n\nconst vec3 bg_col = vec3(1);\nconst vec3 raster_col = vec3(0);\nconst vec3 traj_col = vec3(0,1,0);\nconst vec3 corr_col = vec3(1,0,0);\nconst vec3 conic_col = vec3(0,0,1);\nconst vec3 lagrange_col = vec3(1,1,0);\nconst vec3 dot_col = vec3(0);\n\nconst float a_param = 5.;\nconst float b_param = -5.;\nconst float c_param = 0.;\nconst float d_param = 0.;\n\nfloat conic_curve(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x*a_param + c_param, 2.*p.y*b_param + d_param);\n\treturn p.x*(p.x*a_param + c_param) + p.y*(p.y*b_param + d_param) + 1.;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n    grad = vec2(2.*(a_param*(p.y-p2.y)-p.y*b_param) - d_param,\n                2.*(b_param*(p2.x-p.x)+p.x*a_param) + c_param);\n    return 2.*(p.x*a_param*(p.y-p2.y)-p.y*b_param*(p.x-p2.x)) + c_param*(p.y-p2.y) - d_param*(p.x-p2.x);\n}\n\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat trajectory_segments_dis_sq(vec2 uv, vec2 p, bool corr){\n    float d0 = 1e38;\n    vec2 a = p;\n    for( int i=1; i<num_segments1; i++ )\n    {\n\t\tvec2 b = a;\n        vec2 nor;\n        float val = conic_curve(a, nor);\n        vec2 tang = vec2(nor.y,-nor.x);      \n        \n        if(!corr){\n            b += step_size*val*nor/dot(nor,nor);\n        }\n        else{\n            b += step_size*val*nor/dot(nor,nor);\n            vec2 nor2;\n            #ifdef CORRECTION_VARIANT\n            float val2 = conic_curve(b,nor2);\n            vec2 tang = vec2(nor2.y, -nor2.x);\n            b += step_size*dot(b-p,tang)/dot(tang,tang) * tang;\n            #else\n            float val2 = lagrange_curve(b, p, nor2);\n            b += step_size*val2*nor2/dot(nor2,nor2);\n            #endif\n        }\n        d0 = min(d0,segment_dis_sq(uv, a, b ));\n        a = b;\n    }\n\n\ta = p;\n\n    for( int i=1; i<num_segments2; i++ )\n    {\n\t\tvec2 b = a;\n        vec2 nor;\n        float val = conic_curve(a, nor);\n        vec2 tang = vec2(nor.y,-nor.x);\n        if(!corr){\n            b -= step_size*val*nor/dot(nor,nor);\n        }\n        else{\n            b -= step_size*val*nor/dot(nor,nor);\n            vec2 nor2;\n            #ifdef CORRECTION_VARIANT\n            float val2 = conic_curve(b,nor2);\n            vec2 tang = vec2(nor2.y, -nor2.x);\n            b -= step_size*dot(b-p,tang)/dot(tang,tang) * tang;\n            #else\n            float val2 = lagrange_curve(b, p, nor2);\n            b -= step_size*val2*nor2/dot(nor2,nor2);\n            #endif\n        }\n        d0 = min(d0,segment_dis_sq(uv, a, b ));\n        a = b;\n    }\n    \n    return d0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n\tmouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 1./iResolution.y;\n\n\tfloat dis = 1e38;\n\n\tuv *= zoom;\n\tborder *= zoom;\n\tmouse *= zoom;\n    \n    vec3 col = bg_col;\n    \n    vec2 nor1;\n    float val1 = conic_curve(uv, nor1);\n    col = vec3(mix(clamp(pow(cos(abs(val1)*3.),10.),0.,1.),1.,.8));\n    dis = abs(val1) / length(nor1) - line_width;\n    col = mix(conic_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n    vec2 nor2;\n    float val2 = lagrange_curve(uv, mouse, nor2);\n    dis = abs(val2) / length(nor2) - line_width;\n    col = mix(lagrange_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n\tdis = sqrt(trajectory_segments_dis_sq(uv,mouse,true))-line_width;\n    col = mix(traj_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n    dis = sqrt(trajectory_segments_dis_sq(uv,mouse,false))-line_width;\n    col = mix(corr_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n    dis = distance(uv,mouse)-dot_size;\n    col = mix(dot_col,col,clamp(sqrt(dis/border),0.,1.));\n\n    fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}