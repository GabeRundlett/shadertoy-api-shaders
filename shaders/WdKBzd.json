{
    "Shader": {
        "info": {
            "date": "1607747481",
            "description": "New approach to curvature modelling using smoothstep style interpolation over a plane. It is faster than using sin() which is nice but it is not directly useful for terrain. The same concept can be used though.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdKBzd",
            "likes": 9,
            "name": "Curvature Modeling II (3D)",
            "published": 3,
            "tags": [
                "bicubic",
                "heightmap",
                "modelling",
                "curvature"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\n// Curved surface distance function (not exact):\nfloat Curve3D(in vec3 p, in vec2 wh, in vec4 abcd) {\n    vec2 uv = (p.xz + 0.5 * wh) / wh;\n    uv *= uv * (3.0 - 2.0 * uv);\n    float height = mix(mix(abcd.x, abcd.y, uv.x), mix(abcd.z, abcd.w, uv.x), uv.y);\n    return max(abs(p.y - height), max(abs(p.x) - 0.5 * wh.x, abs(p.z) - 0.5 * wh.y));\n}\n\nfloat mapScene(in vec3 p) {\n    // Surface control points:\n    float v1 = 1.0 + sin(iTime);\n    float v2 = 1.0 + sin(iTime + 1.57);\n    float v3 = 1.0 + sin(iTime + 3.14);\n    float v4 = 1.0 + sin(iTime + 4.71);\n\n    float surface = Curve3D(p + vec3(0.0, 1.0, 0.0), vec2(4.0, 4.0), vec4(v1, v2, v3, v4)) - 0.05;\n    return surface * 0.6;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float dt = 0.0;\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            fragColor.rgb += 0.4;\n            if (abs(p.x) < 2.0 && abs(p.z) < 2.0) {\n                fragColor.rgb = hue2rgb(p.y);\n                fragColor.rgb -= smoothstep(0.05, 0.0, abs(fract(p.x) - 0.05)) + smoothstep(0.05, 0.0, abs(fract(p.z) - 0.05));\n            }\n\n            break;\n        }\n\n        if (d > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}