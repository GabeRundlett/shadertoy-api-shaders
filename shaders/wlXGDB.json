{
    "Shader": {
        "info": {
            "date": "1557467790",
            "description": "Move the mouse to change the branching complexity and ring offset.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlXGDB",
            "likes": 13,
            "name": "Toroidal Sea",
            "published": 3,
            "tags": [
                "fractal",
                "interactive",
                "torus",
                "mouseable"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 1382
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define fdist 0.3\n#define iters 30\n#define tol 0.005\n#define maxdist 10.\n#define gradient_eps 0.01\n\n//shape parameters\n#define displacement 0.05\n#define texturescale 3.\n#define texture_start_x 0.\n#define texture_start_y 0.\n#define texture_end_x 1.\n#define texture_end_y 1.\n#define ring_count 7\n#define levels 5\n#define ratio 0.4\n#define ring_offset 1.5\n#define offsetdiff 0.8\n#define indent 0.2\n#define ringdiff 3.\n#define base_radius 2.\n#define ao_radius 0.1\n#define ao_min 0.2\n#define repeat_offset 8.\n#define laplace_factor 100.\nvec3 viridis_quintic( float x )\n{\n\tx = clamp( x, 0.,1. );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nvec3 sdTorus( vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    \n    float phi = atan(q.y, q.x); //inner angle\n    float theta = atan(p.x, p.z); //outer angle\n    return vec3(d, phi, theta);\n}\n\n//p.x: distance in toroidal coordinates\n//p.y: inner angle\n//p.z: outer angle\n//t.x: outer radius\n//t.y: inner radius\n//t.z: parent outer radius\nvec3 innerTorus(vec3 p, vec3 t) {\n    //outer torus' inner angle becomes inner torus' outer angle\n    float rxy = t.z + p.x*cos(p.y);\n    vec3 pos = vec3(rxy*cos(p.z),\n                    rxy*sin(p.z),\n                    p.x*sin(p.y));\n    return sdTorus(pos-vec3(t.z, 0., 0.), t.xy);\n    \n}\nvec3 map(vec3 p) {\n    p = mod(p+0.5*repeat_offset,repeat_offset)-0.5*repeat_offset;\n    //time-varying parameters (maybe replace with some inputs, or remove)\n    float textureoffset = iTime*0.25;\n    float final_offset;\n    if (iMouse.z < 1.)\n        final_offset = final_offset = offsetdiff*cos(PI*((abs(mod(iTime*0.5+1., 2.)-1.)+iTime*0.5+1.)*0.5-0.5)) + ring_offset;\n    else\n        final_offset = (iMouse.y/iResolution.y-0.5)*3.+2.;\n    float final_ratio = ratio/final_offset;\n    float final_ringcount;\n    if (iMouse.z < 1.)\n    \tfinal_ringcount = ringdiff*cos(PI*((abs(mod(iTime*0.5, 2.)-1.)+iTime*0.5)*0.5-0.5))+float(ring_count);\n    else\n    \tfinal_ringcount = float(ring_count) + (iMouse.x/iResolution.x-0.5)*2.*ringdiff;\n    float sector = 2.*PI/(final_ringcount);\n    float outerrad = base_radius;\n    float innerrad = outerrad*final_ratio;\n    vec3 h = sdTorus(p, vec2(outerrad, innerrad));\n    \n    int i;\n    float mag = displacement;\n    float currindent = indent;\n    float disp = texture(iChannel0, vec2(final_ratio*h.y/(2.*PI)*texturescale+textureoffset, h.z/(2.*PI)*texturescale)).x;\n    h.x -= (disp-0.5)*mag;\n    vec3 minh = h;\n    \n    for (i=0; i<levels; i++) {\n        float theta = mod(abs(h.z), sector)-sector/2.;\n        float newouterrad = innerrad*final_offset;\n        float newinnerrad = newouterrad*final_ratio;\n        h = innerTorus(vec3(h.x+innerrad, h.y, theta), vec3(newouterrad, newinnerrad, outerrad));\n        outerrad = newouterrad;        \n        innerrad = newinnerrad;\n        disp = texture(iChannel0, vec2(final_ratio*h.y/(2.*PI)*texturescale+textureoffset, h.z/(2.*PI)*texturescale)).x;\n\t\th.x -= (disp-0.5)*mag;\n        minh.x = max(minh.x, currindent-h.x);\n        if (h.x < minh.x) {\n            minh = h;\n        }\n        mag = mag * final_ratio * final_offset;\n        currindent = currindent * final_ratio * final_offset;\n    }\n    return minh;\n}\n\nvec4 gradient(in vec3 pos) {\n    vec3 offset = vec3(-gradient_eps, 0.0, gradient_eps);\n    float dx0 = map(pos+offset.xyy).x;\n    float dxf = map(pos+offset.zyy).x;\n    float dy0 = map(pos+offset.yxy).x;\n    float dyf = map(pos+offset.yzy).x;\n    float dz0 = map(pos+offset.yyx).x;\n    float dzf = map(pos+offset.yyz).x;\n    float ddd = map(pos).x;\n    return vec4(normalize(vec3(dxf - dx0, dyf - dy0, dzf - dz0)), dx0+dxf+dy0+dyf+dz0+dzf-6.*ddd);\n}\n\nvec4 raymarch(vec3 pos, vec3 dir) {\n    vec4 fac = vec4(maxdist);\n    int i;\n    float d = 0.;\n    for (i=0; i<iters; i++) {\n        vec3 dist = map(pos+d*dir);\n        d += dist.x;\n        fac.x = dist.x;\n        if (fac.y < fac.x && fac.y <= fac.z && fac.y < fac.w) {\n            fac.w = fac.y;\n        }\n        fac.zy = fac.yx;\n        if (dist.x > maxdist || dist.x < tol) {\n            return vec4(d, dist.y, dist.z, fac.w);\n            break;\n        }\n    }\n\treturn vec4(d, 0.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //time varying camera parameters\n    float h = PI+iTime*0.3;\n    float ww = iTime*0.2;\n    \n    //camera position\n    vec3 ro = 4.*(0.4*cos(2.*h)+0.7)*vec3(sin(ww)*cos(h), sin(h), cos(ww)*cos(h));\n    vec3 w = -normalize(ro);\n    vec3 u = normalize(cross(w, vec3(10., 0., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*fdist+(fragCoord.x/iResolution.x-0.5)*v+(fragCoord.y-iResolution.y/2.0)/iResolution.x*u);\n\t\n    vec4 record = raymarch(ro, rd);\n    //float disp = texture(iChannel0, vec2(record.y/(2.*PI)+0.5, record.z/(2.*PI)+0.5)).x;\n    //if (record.w > 0.5) {\n    vec4 n = gradient(ro+record.x*rd);\n    //\tfragColor = vec4(0.5+0.5*n, 1.);\n    //} else {\n    //    fragColor = vec4(vec3(0.5), 1.);\n    //}\n    float edgefac = n.w*laplace_factor;\n    //vec3 color = clamp(vec3(edgefac, 1.-edgefac, 0.6), 0.,1.5);\n    vec3 color = viridis_quintic(edgefac);\n    float fogfac = record.x/40.;\n    vec3 shadedcolor = min(1.,ao_min+(record.w > ao_radius ? 1. : record.w/(ao_radius)))*dot(n.xyz,-w)*color;\n    vec3 ambient = mix(vec3(0.0, 0.0, 0.1), vec3(0.0, 0.5, 1.0), pow(1.0-abs(rd.y), 7.0));\n    shadedcolor += ambient*fogfac;\n    fragColor = vec4(shadedcolor, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}