{
    "Shader": {
        "info": {
            "date": "1558331034",
            "description": "Inspired by https://www.shadertoy.com/view/4dGSDR, Grid-based particle system with spatial hashing to prevent particles from vanishing when they occupy the same cell. The more bins per cell, the smaller the probability of decay. The bins are highlighted.",
            "flags": 32,
            "hasliked": 0,
            "id": "Wtj3zz",
            "likes": 7,
            "name": "particle hashing",
            "published": 3,
            "tags": [
                "particles",
                "physics"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 814
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/diameter;\n    ivec2 id = ivec2(floor(uv));\n    ivec2 stripes = id % 2;\n    fragColor = vec4(vec3(0.1*float(abs(stripes.x-stripes.y))), 1.);\n    ivec2 ind = ivec2(floor(uv*float(hashEdge)));\n    fragColor += vec4(vec3(0.,0.5,0.7) * (1.-step(0.,-texelFetch(iChannel0, ind, 0).x)), 1.);\n    vec3 col=vec3(0.);\n    for (int i=-1; i<=1; i++) {\n        for (int j=-1; j<=1; j++) {\n            ivec2 disp = ivec2(i, j);\n            ivec2 otherid = id+disp;\n            if (otherid.x < 0 || otherid.y < 0 || otherid.x >= particleEdge.x || otherid.y >= particleEdge.y) continue;\n            for (int k=0; k<hashEdge; k++) {\n                for (int l=0; l<hashEdge; l++) {\n                    ivec2 offset = ivec2(k, l);\n                    vec4 state = texelFetch(iChannel0, otherid*hashEdge+offset,0);\n                    if (state.xy == vec2(-1.)) continue;\n                    float opacity = step(length(state.xy-fragCoord), diameter*.5);\n                    col = mix(col, vec3(0.3/maxspeed*state.zw+.5, 0.0), opacity);\n                }\n            }\n        }\n    }\n    fragColor.xyz+=col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//grid hashing\n\nvoid mainImage( out vec4 state, in vec2 fragCoord )\n{\n    ivec2 maxIndex = particleEdge * hashEdge;\n    ivec2 ind = ivec2(floor(fragCoord.xy));\n    \n    if (ind.x >= maxIndex.x || ind.y >= maxIndex.y) discard;\n    \n    ivec2 id = ind/hashEdge; //cell id\n    if (iMouse.z > 1. && length(iMouse.xy*float(hashEdge)/diameter-fragCoord)<float(hashEdge*2)) {\n        state = vec4(vec2(id)*diameter+diameter*.5, (noise2D(fragCoord)*2.-1.)*maxspeed);\n    } else\n    if (iFrame == 0) {\n        //initialization\n        //if (ind.x % hashEdge == 0 && ind.y % hashEdge == 0) {\n            state = vec4(vec2(id)*diameter+diameter*.5, (noise2D(fragCoord)*2.-1.)*maxspeed);\n        //} else {\n\t\t//    state = vec4(-1., -1., 0., 0.);\n        //}\n    } else {\n        //update\n        \n        //particle leaving the cell\n    \tstate = texelFetch(iChannel0, ind, 0);\n        if (ivec2(floor(state.xy/diameter)) != id) state = vec4(-1., -1., 0., 0.);\n        \n        //particle entering the cell\n        for (int i=-1; i<=1; i++) {\n            for (int j=-1; j<=1; j++) {\n                ivec2 disp = ivec2(i, j);\n                if (disp == ivec2(0)) continue;\n                ivec2 otherid = id + disp;\n                if (otherid.x < 0 || otherid.y < 0 || otherid.x >= particleEdge.x || otherid.y >= particleEdge.y) continue;\n                //check every bin inside the other cell for particles entering this cell\n                for (int k=0; k<hashEdge; k++) {\n                    for (int l=0; l<hashEdge; l++) {\n                        ivec2 offset = ivec2(k, l);\n                        vec4 otherstate = texelFetch(iChannel0, otherid*hashEdge + offset, 0);\n                        ivec2 id2 = ivec2(floor(otherstate.xy/diameter));\n                        if (id2 == id) {\n                            for (int h=0; h<numHashes; h++) {\n                                //receive the particle if this is the right bin\n                                ivec2 hashOffset = hash2D(otherstate.xy+float(h)*12345.);\n                                ivec2 hashInd = id*hashEdge+hashOffset;\n                                vec2 state0 = texelFetch(iChannel0, hashInd, 0).xy;\n                                if (state0 == vec2(-1.)) {\n                                    if (hashInd == ind) {\n                                        state = otherstate;\n                                        return;\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//number of bins per cell is hashEdge * hashEdge\n#define hashEdge 3\n\n//maximum number of times to try binning a particle\n#define numHashes 2\n\n//real world scale of the cells (and particles)\n//must be bigger than  hashEdge due to maximum buffer size\n#define diameter 12.\n\n//number of particles is particleEdge.x * particleEdge.y\n#define particleEdge ivec2(floor(iResolution.xy/diameter))\n\n//max speed must be smaller than diameter\n#define maxspeed 2.8\n\nvec2 noise2D(vec2 uv) {\n    return fract(3e4*sin((uv)*mat2(1,13.51,73.37,-57.17)));\n}\n\nivec2 hash2D(vec2 uv) {\n    return ivec2(floor(clamp(mod(3e4*sin((uv)*mat2(1,13.51,73.37,-57.17)), float(hashEdge)), 0., float(hashEdge))));\n}\n\nfloat noise1D(float t) {\n    return fract(14950.5*sin(1905.1*t));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//state update\n\n//x,y = position\n//z,w = velocity\n//x,y are negative if unoccupied\n#define hardstep(h) (step(0., h)*2.-1.)\n\nvoid mainImage( out vec4 state, in vec2 fragCoord )\n{\n    ivec2 maxIndex = particleEdge * hashEdge;\n    ivec2 ind = ivec2(floor(fragCoord.xy));\n    \n    if (ind.x >= maxIndex.x || ind.y >= maxIndex.y) discard;\n    \n    state = texelFetch(iChannel0, ind, 0);\n    state.xy += state.zw;\n    //bounce off walls\n    vec2 bounds = diameter*vec2(particleEdge)-1.;\n    if (state.xy != vec2(-1.)) {\n        state.zw *= hardstep(state.xy)*hardstep(bounds-state.xy);\n        state.xy = min(state.xy, bounds);\n        state.xy = max(state.xy, 0.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}