{
    "Shader": {
        "info": {
            "date": "1555608849",
            "description": "safer version of this project. buffers a and b are swapped in contrast with the \"big brother\" of this project.",
            "flags": 48,
            "hasliked": 0,
            "id": "WtsGRr",
            "likes": 1,
            "name": "safe increase res",
            "published": 3,
            "tags": [
                "resolution"
            ],
            "usePreview": 0,
            "username": "bfazekas",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    if((fragCoord.x < iResolution.x / 2. && fragCoord.y < iResolution.y /2.))\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0) / 100.;\n    else\n    \n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\t*/\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n// SHAPE FORMULAS\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n    \nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n    \n    \nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n    //return length(max(d, 0.0));\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdTorus( vec3 p, vec2 t, bool _switch )\n{\n    if(_switch)\n    \tp.xyz = p.yxz;\n    \n    vec3 temp = p;\n    p.x = p.y;\n    p.y = temp.x;\n  \tvec2 q = vec2(length(p.xz)-t.x, p.y);\n   \treturn length(q)-t.y;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdfAxis(vec3 p)\n{\n    return sqrt(p.x*p.x + p.z*p.z);\n}\n\n// ROTATION MATRICES\nmat3 rotateXY(float angle)\n{\n \treturn mat3(cos(angle), -sin(angle), 0, \n                sin(angle), cos(angle), 0,\n                0, 0, 1);\n}\n\nmat3 rotateXZ(float angle)\n{\n \treturn mat3(cos(angle), 0, -sin(angle), \n                0, 1,0,\n                sin(angle), 0, cos(angle));\n}\n\nmat3 rotateYZ(float angle)\n{\n \treturn mat3(1, 0, 0, \n                0, cos(angle), -sin(angle),\n                0, sin(angle), cos(angle));\n}\n\n// signed distance functions\n\nfloat sdf(in vec3 p, float t)\n{\n    p-=vec3(0,0,5);\n    vec3 originalP = p;\n    \n    float surface = p.y+3.;\n    \n    float sphere = sdSphere(p, 1.);\n    float g = sdBox(p-vec3(2,0,0),vec3(1,1,1));\n    \n    // first torus\n    p *= rotateXY(3.*t);\n    float t1 = sdTorus(p, vec2(2.0, 0.3), false);\n    // second torus\n    p = originalP;\n    p *= rotateYZ(2.*t)*rotateXY(3.*t);\n    float t2 = sdTorus(p, vec2(5.0, 0.5), false);\n    // third torus\n    p = originalP;\n    p *= rotateXZ(t)*rotateYZ(2.*t)*rotateXY(1.*t);\n    float t3 = sdTorus(p, vec2(9.0, 1.0), true);\n    p = originalP;\n    p *= rotateYZ(pi/2.);\n    float cone = sdCone(p, normalize(vec2(1.0, 0.5)));\n    \n    p = originalP;\n    float k = sdfAxis(p);\n    \n    return min(min(sphere,min(g, k)), min(min(t1, t2), min(t3, min(surface, cone))));\n    //return min(min(g, sphere), surface);\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n \tvec2 env = vec2(0.01, 0.0);\n    float d = sdf(p, t);\n    vec3 n = d - vec3(sdf(p - env.xyy, t), \n                      sdf(p - env.yxy, t),\n                      sdf(p - env.yyx, t));\n    return normalize(n);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V, iTime);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n*/\n\nTraceResult cone_trace(in Ray ray, in SphereTraceDesc params, float tana)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; \n    do\n    {\n        d = sdf(ray.P+ret.T*ray.V, iTime);\n        ret.T+=d;\n        ++i;\n    } while ( \n        \n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td > ret.T * tana &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= ret.T * tana)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nTraceResult cone_trace_safe(in Ray ray, in SphereTraceDesc params, float tana)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; \n    do\n    {\n        d = (sdf(ray.P+ret.T*ray.V, iTime)- ret.T*tana) / (1. + abs(tana));\n        ret.T+=d;\n        ++i;\n    } while ( \n        \n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td > params.epsilon* ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    //fragCoord *= 2.;\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\n    if (isKeyHeld(KeyLeft )) eye -= u;\n    if (isKeyHeld(KeyRight)) eye += u;\n    if (isKeyHeld(KeyUp   )) eye += w;\n    if (isKeyHeld(KeyDown )) eye -= w;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord = fragCoord / 2.;\n    \n    if(!(fragCoord.x < iResolution.x / 2. && fragCoord.y < iResolution.y /2.))\n        discard;\n    \n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord*2., eye, data);\n    SphereTraceDesc params = SphereTraceDesc(0.001, 128);\n    \n    float angle = 45.0;\n    angle *= 3.14159 / 180.;\n    float tana = sqrt(2.) * tan(angle) / length(iResolution);\n    TraceResult result = cone_trace_safe(ray, params, tana*2.);\n    \n    \n    \n    fragColor = vec4(result.T,result.T,result.T,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This file contains the \n\n// ---- SPHERE TRACING ----\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V, iTime);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nTraceResult cone_trace_safe(in Ray ray, in SphereTraceDesc params, float tana)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; \n    do\n    {\n        d = (sdf(ray.P+ret.T*ray.V, iTime)- ret.T*tana) / (1. + abs(tana));\n        ret.T+=d;\n        ++i;\n    } while ( \n        \n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td > params.epsilon* ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0), iTime),sdf(p+vec3(0,eps,0), iTime),sdf(p+vec3(0,0,eps), iTime));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0), iTime),sdf(p-vec3(0,eps,0), iTime),sdf(p-vec3(0,0,eps), iTime));\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 n = normal(ray.P+ray.V*t);\n    \n\n    vec3 lightPos=vec3(10.,-10.,10.);\n    \n    vec3 p = ray.P + ray.V*t;\n    vec3 v = -ray.V;\n    vec3 l = normalize(p -lightPos);\n    \n    Ray shadowRay = Ray(p+n,0.05,l,distance(p,lightPos));\n    SphereTraceDesc params = SphereTraceDesc(0.001, 128);\n    TraceResult result = sphere_trace(shadowRay, params);\n    \n    vec3 col;\n    if(bool(result.flags & 1))\n        col = vec3(1,1,1)*max(dot(n,l),0.0);\n    else if(bool(result.flags & 2))\n        col=vec3(0,0,0);\n    else\n    \tcol =vec3(1,0,0);\n    \n    return vec4(col,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n\n// Common codes (WASD instead of arrows)\n\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\n    if (isKeyHeld(KeyLeft )) eye -= u;\n    if (isKeyHeld(KeyRight)) eye += u;\n    if (isKeyHeld(KeyUp   )) eye += w;\n    if (isKeyHeld(KeyDown )) eye -= w;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    /*\n    int options; // 0 -> Sphere tracing\n    \t\t\t // 1 -> Relaxed Sphere tracing\n    \t\t\t // 2 -> Enhanced Sphere tracing\n    options = 0;\n\t*/\n    \n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.005, 128);\n    \n    // Raytrace\n        \n    float angle = 45.0;\n    angle *= 180. / pi;\n    float tana = sqrt(2.) * tan(angle) / length(iResolution);\n    \n    float dStart = texelFetch(iChannel3, ivec2(fragCoord / 2.), 0).x;\n    \n    ray.Tmin = dStart;\n    TraceResult result = cone_trace_safe(ray, params, tana);\n    \n     //Debug\n    /*\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T/*, options*/);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.0*prev + 1.0*fragColor;\n        fragColor.w = result.T;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}