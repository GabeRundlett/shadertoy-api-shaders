{
    "Shader": {
        "info": {
            "date": "1666244310",
            "description": "Hope you are having a great day :)",
            "flags": 0,
            "hasliked": 0,
            "id": "dslGWM",
            "likes": 6,
            "name": "Perlin noise Kaleidoscope ",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "kaleidoscope",
                "hue",
                "psy"
            ],
            "usePreview": 0,
            "username": "fyisic123",
            "viewed": 232
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec2 uv = (fragCoord.xy -.5 * iResolution.xy) / iResolution.y;        \n    float ogLen = length(uv); \n    \n    uv *= Rot(iTime * .1);  // slowly rotate all\n    \n    \n    // Credit to this shader for Kaleidoscope , i pretty much just copied and changed some numbers\n    //  https://www.shadertoy.com/view/4lsGWj\n    float r = 2. + (.25  * sin(iTime*0.1));\n    float a = iTime*.1;\n    float c = cos(a)*r;\n    float s = sin(a)*r;        \n    for ( int i=0; i < 5; i++ )\n    {\n    \tuv = abs(uv);\n        uv -= .25;\n        uv = uv*c + s*uv.yx*vec2(1,-1);\n    }\n    \n    \n    \n    uv *= (1.0 - ogLen) * .5 ; // making it bubble out at the sides\n    \n    \n    float p = perlin(uv + vec2(iTime, -iTime) * 0.45); // getting perlin value\n     \n\n    // Output to screen\n    vec3 h = hue(p * 40.);\n    fragColor = vec4(h , 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n#define PI 3.14159265359\n\nfloat interpolate(float a0, float a1, float w) {\n    \n     if (0.0 > w) return a0;\n     if (1.0 < w) return a1;        \n    return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;\n    \n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\nfloat dotGridGradient(float ix, float iy, float x, float y) {\n    \n    vec2 gradient = hash22(vec2(ix, iy));    \n    float dx = x - ix;\n    float dy = y - iy;    \n    return (dx*gradient.x + dy*gradient.y);\n}\n\nfloat perlin(vec2 p) {\n    \n    float x0 = floor(p.x);\n    float x1 = x0 + 1.;\n    float y0 = floor(p.y);\n    float y1 = y0 + 1.;\n\n    \n    float sx = p.x - x0;\n    float sy = p.y - y0;\n\n    \n    float n0, n1, ix0, ix1, value;\n\n    n0 = dotGridGradient(x0, y0, p.x, p.y);\n    n1 = dotGridGradient(x1, y0, p.x, p.y);\n    ix0 = interpolate(n0, n1, sx);\n\n    n0 = dotGridGradient(x0, y1, p.x, p.y);\n    n1 = dotGridGradient(x1, y1, p.x, p.y);\n    ix1 = interpolate(n0, n1, sx);\n\n    value = interpolate(ix0, ix1, sy);\n    return value * 0.5 + 0.5; \n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}