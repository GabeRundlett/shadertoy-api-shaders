{
    "Shader": {
        "info": {
            "date": "1582303821",
            "description": "yo, code is pretty messy",
            "flags": 32,
            "hasliked": 0,
            "id": "WlKXRW",
            "likes": 25,
            "name": "Day 64",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 804
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 10.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,5.)*0.4;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*3.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.2;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.2);\n    \n    fragColor = max(fragColor, 0.);\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.5,1. + sin(iTime)*0.2,1. - cos(iTime)*0.4));\n\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of \"Day 62\" by jeyko. https://shadertoy.com/view/wtySRh\n// 2020-02-21 08:51:00\n\n\nvec3 glow = vec3(0);\nvec3 glowG = vec3(0);\nvec3 glowB = vec3(0);\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define pi acos(-1.)\n#define tau (2.*pi)\n//#define mx (iTime*(0.8 )+ sin(iTime*2.)*0.4 + 20.*iMouse.x/iResolution.x)\n//#define mx (iTime*(0.6 )+ sin(iTime*2.)*0.3 + 20.*iMouse.x/iResolution.x)\n\n#define mx (   iTime*(0.6 )+ sin(iTime*1.)*0.2 + 20.*iMouse.x/iResolution.x)\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    uv *= 0.8;\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define modD  (1.)\n#define dmin(a,b) a.x < b.x ? a : b\n\nfloat zid = 0.;\nvec3 pp = vec3(0);\n\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    \n    p.xz = pmod(p.xz, modD);\n    \n    vec3 q = p;\n    \n    #define ceilH 0.5\n    float ceils = p.y + ceilH;\n    ceils = min(ceils, -p.y + ceilH);\n    d.x = min(d.x, ceils );\n    #define colW 0.0328\n    //float cols = length(p.xz) - 0.06;\n    float cols = max(abs(p.x) - colW, abs(p.z) - colW);\n    #define floors 8.\n    \n    d = dmin(d, vec2(fOpUnionStairs(d.x, cols, 2.*ceilH/2., floors), 0.));\n    \n    // outer\n    p = q;\n    for(int i = 0; i < 4; i++){\n    \tp = abs(p);\n        p.xz *= rot(0.125*pi);\n        //q.x += 0.03;\n    }\n    p = abs(p);\n    //p.xy *= rot(0.4);\n    //p.y -= 0.2;\n    q = p;\n    p = abs(p);\n    p.z -= 0.25;\n    p.xz *= rot(pi*0.25);\n    p.yz = abs(p.yz) - 0.02;\n\tfloat outer = max(p.y,p.z);  \n    \n    //q.xz *= rot(0.1);\n    q.xz *= rot(0.25*pi);\n    q = abs(q);\n    q.xz *= rot(0.25*pi);\n    q = abs(q);\n    q -= 0.02;\n    pp = q;\n    d = dmin(d, vec2(outer, 1.));\n    //d.x = min(d.x, outer);\n    \n    q = abs(q);\n\touter = max(q.y,q.x);\n    \n    outer = max(outer, -q.z + 0.23) + 0.001;\n    \n    d = dmin(d, vec2(outer, 2.));\n    //d.x = min(d.x, outer);\n\t//outer = max(outer,max(q.y,q.x));\n    //glowB += exp(-outer*20.)*1.;\n    float gBsc = 0.05/(0.01 + outer*outer*200.);\n    glowB += gBsc*pal(0.0, 0.9, vec3(4.,2.,3.), vec3(1.,3.,1.6),5.9)*1.3;\n    \n    glowB += pow(abs(sin(p.x*4.+ iTime) ), 200.)*gBsc*pal(0.9, 0.9, vec3(4.,9.,3.), vec3(1.,3.,2.6),5.9)*2.;\n    \n    \n    glowG += exp(-d.x*200. )*pal(0.88, 0.2, vec3(4.,2.,3.), vec3(1.,2.3,1.6),5.9)*0.7;\n\n    d.x *= 0.7;\n    glow += exp(-d.x*150. );\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e6);\n\tp = ro;\n    hit = false; t = 0.;\n    \n    for(int i = 0; i < 250  ; i++){\n    \td = map(p);\n        if(d.x < 0.0005){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\nvec3 getNormal(vec3 p){\n\tvec2 u = vec2(0.001,0.);\n    return normalize(map(p).x - vec3(\n    \tmap(p - u.xyy).x,\n    \tmap(p - u.yxy).x,\n    \tmap(p - u.yyx).x\n    ));\n}\n\nvec3 text(vec2 t, vec3 p){\n\tvec3 o = vec3(0);\n\t\n    float d = 10e6;\n    t = pmod(t,1./16.);\n    \n    t *= 16.;\n    float yid = (floor( (p.y + 1.)*16. ) );\n    //t *= rot(0.25*pi);\n    //t *= rot(0.5*pi);\n    float W = 0.02;\n    \n    float modd = 0.15;\n    //t = abs(mod(t,modd)/modd - 0.5);\n    #define lmod(d, x) (mod(d,x)/x - 0.5)\n    float sqD = max(abs(t.x), abs(t.y));\n    sqD += iTime*0.2 + yid*0.04;\n    float sqid = floor(sqD/modd);\n    sqD = lmod(sqD, modd);\n    \n    d = min(d, sqD);\n    //d = min(d, length(t.x) - W );\n    //d = min(d, length(t.y) - W );\n\n    \n    o +=  pal(0.6, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n    o *= step(sin(sqid*40.), -0.3);\n\n    \n    float aa = 20.;\n    //sqD -= modd*0.25;\n    sqD -= 0.5;\n    sqD = abs(sqD*1.);\n    o -= exp(-sqD*aa)*4.;\n    sqD -= 1.;\n    sqD = abs(sqD*1.);\n    o -= exp(-sqD*aa)*4.;\n    //o += smoothstep(0.001,0., d);\n    \n    return o;\n}\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(  in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 q = (text(p.yz, p)*n.x + text(p.zx,p)*n.y + text(p.xy,p)*n.z).xyz;\n    \n    return q;\n}\nvec4 nint(float t){\n\tvec4 a = texture(iChannel0, vec2(floor(t)*0.02));\n\tvec4 b = texture(iChannel0, vec2(floor(t+ 1.)*0.02));\n    return mix(a,b, pow(smoothstep(0.,1.,fract(t)),1.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - length(uv)*0.2;\n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    ro.y -= 0. + sin(iTime*0.25)*0.4;\n    ro.z += mx;\n    vec3 lookAt = vec3(0,0,ro.z + 2.);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n   \n    float r = nint(iTime/tau).x;\n    rd.xy *= rot(sin(nint(0.5*iTime/tau).x*tau)*0.2);\n    \n    rd.xz *= rot(sin(nint(0.5*iTime/tau).y\n                     *tau)*0.3);\n    \n    bool hit; float t; vec3 p;\n    vec2 d = march(ro, rd, p, t, hit);\n    vec3 n = getNormal(p);\n\n    float fogD = smoothstep(0.,1.,t*0.18);\n    if(hit){\n        //col += pal(0.5, 0.4, vec3(3.,1.,1.), vec3(1.,1.,2.),2.6 - did*2.3 )*0.09;\n        //col += pal(0.5, 0.6, vec3(3.,1.1,1.), vec3(1.,1.,2.),0.4 - did*0.6 )*0.09;\n        //p.y -= 0.03;\n        p.x -= 0.03;\n        p.z -= 0.03;\n    } \n    \n    if(d.y == 1.){\n\n        vec3 tt = tex3D(pp*0.1,n)*1.;\n        \n\t\tcol += 0.1*length(tt)* pal(0.7, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4), vec3(4.,7.,3.),-1. + iTime);; \n    } \n    if(d.y == 2.){\n        \n        col = clamp(col, 0., 1.);\n        col -= col;\n\t\tcol += 0.2*pal(0.3, vec3(1.,1.,0.6)*0.5, vec3(8.4 ,4.19,7.4), vec3(4.,7.,3.),-1. + iTime);; \n    }\n    col -= glowG*0.1;\n    col += glow*0.03;\n    col += glowB*0.03;\n    if(d.y == 0.){\n    \tcol += tex3D(p,n)*1.;\n    }\n    col = clamp(col, 0., 1.);\n\n    col = mix(col,vec3(0.2,0.014,0.1)*0.2,fogD);\n    //fogD = smoothstep(0.,1.,t*0.98);\n    col += glow*0.003*fogD*vec3(0.2,0.064,0.1);\n    //col += pal(0.5, 0.5, vec3(4.,2.,1.), vec3(1.,1.,1.),2.9 + pid.x + did*2.);\n    col = pow(col, vec3(0.45));\n    \n    col = mix(col, vec3(0), dot(uv*0.55,uv*0.55)*2.);\n    //col = mix(col, smoothstep(0.,1., col), 0.6);\n//    col *= 1. - pow(abs(uv.x) - 0.25,6. )*50.;\n//    col *= 1. - pow(abs(uv.y) - 0.3,3. )*50.;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}