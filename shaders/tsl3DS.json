{
    "Shader": {
        "info": {
            "date": "1547426754",
            "description": "This is a simple 2d path tracer implemented using a signed distance field. Instead of using some form of acceleration structure or brute force raytracing, it raymarches the SDF. I don't think this actually turns out to by faster than raytracing though.",
            "flags": 32,
            "hasliked": 0,
            "id": "tsl3DS",
            "likes": 10,
            "name": "2d path tracer",
            "published": 3,
            "tags": [
                "2d",
                "raymarching",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "BenjaminL",
            "viewed": 1041
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 hdr = texture(iChannel0, uv).rgb;\n    // Tonemapping\n    vec3 color = hdr / (1.0 + hdr);\n   \t// Gamma correction\n    fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float SEED = 0.2;\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat circle(vec2 center, float radius, vec2 uv) {\n    return distance(center, uv) - radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    float dist = 0.5 - uv.x;//circle(vec2(0.0, 0.0), 0.1, uv);\n    // Walls\n    //dist = min(dist, 0.5 - uv.x);\n    dist = min(dist, 0.5 + uv.x);\n    dist = min(dist, 0.5 - uv.y);\n    dist = min(dist, 0.5 + uv.y);\n    for(int i = 0; i < 32; i++) {\n        vec2 center = texture(iChannel0, vec2(i, SEED) / iChannelResolution[0].xy).xy;\n        dist = sminCubic(dist, circle(center * 2.0 - 1.0, 0.05, uv), 0.15);\n    }\n    vec2 normal = normalize(vec2(dFdx(dist), dFdy(dist)));\n    fragColor = vec4(dist,normal,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int STEPS = 128;\nconst int SAMPLES = 8;\nconst int BOUNCES = 5;\nconst float EPSILON = 1e-4;\nconst float PI = 3.1415926535897932384626433832795;\nconst vec3 objectColors = vec3(0.4, 0.8, 0.5);\n\nfloat rand(in vec2 coordinate, in float seed){\n\tconst float PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \n\tconst float PI  = 3.14159265358979323846264 * 00000.1; // PI\n\tconst float SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\nvec4 lookup(in vec2 position) {\n    return texture(iChannel0, position * iResolution.y / iResolution.xy);\n}\n\nbool trace(in vec2 origin, in vec2 direction, out vec2 hit, out vec2 normal) {\n    vec3 tex;\n    for(int i = 0; i < STEPS; i++) {\n        tex = lookup(origin).xyz;\n        float dist = tex.x;\n        if(dist < EPSILON) {\n            break;\n        }\n        origin += direction * dist;\n        /*if(dot(origin, origin) > 10.0) {\n            return false;\n        }*/\n    }\n    hit = origin;\n    normal = tex.yz;\n    return true;\n}\n\nbool traceShadow(in vec2 origin, in vec2 toLight) {\n    float maxDist = length(toLight);\n    vec2 direction = toLight / maxDist;\n    float totalDist = 0.0;\n    for(int i = 0; i < STEPS; i++) {\n        float dist = lookup(origin).x;\n        if(dist < EPSILON) {\n            return true;\n        }\n        origin += direction * dist;\n        totalDist += dist;\n        if(totalDist >= maxDist) {\n            return false;\n        }\n        /*if(dot(origin, origin) > 10.0) {\n            return false;\n        }*/\n    }\n    return true;\n}\n\nvec2 sampleLight() {\n    if(iMouse.xy == vec2(0.0)) {\n        float angle = iTime * 2.0;\n        return (0.15 * vec2(sin(angle), cos(angle)) + 0.5) * iResolution.xy / iResolution.y;\n    }\n    return iMouse.xy / iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = fragCoord / iResolution.y;\n    //vec2 origin = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    float dist = lookup(coord).x;\n    if(dist < 0.0) {\n        float alpha = 1.0 - 200.0 * dist;\n        fragColor = vec4(2.0 * objectColors / alpha, 1.0);\n        return;\n    }\n    \n    vec3 sampleColor = vec3(0.0);\n    for(int s = 0; s < SAMPLES; s++) {\n        vec2 origin = coord;\n        vec2 hit;\n        vec2 normal;\n        vec3 reflIntensity = vec3(1.0);\n        float angle = rand(uv, iTime + float(s)) * 2.0 * PI;\n        vec2 direction = vec2(cos(angle), sin(angle));\n        for(int i = 0; i < BOUNCES; i++) {\n            // Sample light directly\n            vec2 toLight = sampleLight() - origin;\n            if(!traceShadow(origin, toLight)) {\n                float atten = 1.0 / dot(toLight, toLight);\n                sampleColor += reflIntensity * atten * vec3(0.03);\n            }\n            if(trace(origin, direction, hit, normal)) {\n                origin = hit + normal * EPSILON;\n                // Cosine weighted direction\n                float x = rand(uv, iTime + float(s ^ (i + 1))) * 2.0 - 1.0;\n                vec2 tangent = vec2(-normal.y, normal.x);\n                direction = tangent * x + normal * sqrt(1.0 - x * x);\n                reflIntensity *= objectColors;\n                // Russian Roulette\n                /*if(rand(uv, iTime + float(s ^ ~(i + 1))) > 0.5) {\n                    break;\n                }\n                else {\n                    reflIntensity *= 2.0;\n                }*/\n            }\n            else {\n                break;\n            }\n        }\n    }\n    \n    float alpha = 0.1;//1.0 / float(iFrame + 1);\n    //fragColor.rgb = mix(texture(iChannel1, uv).rgb, sampleColor / float(SAMPLES), alpha);\n    //fragColor.a = 1.0;\n    fragColor = vec4(sampleColor / float(SAMPLES), 1.0);\n    //fragColor = vec4(lookup(coord).yz * 0.5 + 0.5, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}