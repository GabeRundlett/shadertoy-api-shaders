{
    "Shader": {
        "info": {
            "date": "1582727125",
            "description": "Small test of a tree with dawn-colored leaves",
            "flags": 0,
            "hasliked": 0,
            "id": "tlGXDD",
            "likes": 2,
            "name": "Dawn Tree",
            "published": 3,
            "tags": [
                "sdf",
                "npr"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 345
        },
        "renderpass": [
            {
                "code": "vec3 bodyStart = vec3(.0,-.5,.0), bodyEnd = vec3(.0,.2,.0);\n#define branchEnd bodyEnd + vec3(.4,.2,.0)\n#define otherBranchEnd bodyEnd + vec3(-.2,.3,.0)\n#define thirdBranchEnd bodyEnd + vec3(.0,.2,.2)\nbox boundingBox = box(vec3(-.5,-.4,-.5), vec3(.8, 1.0, .6));\n\n//#define DEBUG_BOX\n\nsdfRet tree(vec3 point)\n{\n    sdfRet returnVal;\n    \n    float body = lineSegment(\n            point,\n            bodyEnd,\n            bodyStart,\n            .04\n        );\n    \n    float branch = lineSegment(\n    \tpoint,\n        branchEnd,\n        bodyEnd,\n        .03\n    );\n    \n    float otherBranch = lineSegment(\n    \tpoint,\n        otherBranchEnd,\n        bodyEnd,\n        .02\n    );\n    \n    float thirdBranch = lineSegment(\n    \tpoint,\n        thirdBranchEnd,\n        bodyEnd,\n        .02\n    );\n    \n    float smoothing = .05;\n    float ret = opSmoothUnion(branch, body, smoothing);\n    ret = opSmoothUnion(otherBranch, ret, smoothing);\n    ret = opSmoothUnion(thirdBranch, ret, smoothing);\n    returnVal.dist = ret;\n    \n    return returnVal;\n}\n\nsdfRet leaves(vec3 point)\n{\n\t sdfRet returnVal;\n    \n    float body = sphere(\n            point,\n            bodyEnd,\n            .2\n    );\n    \n    float branch = sphere(\n            point,\n            branchEnd,\n            .4\n    );\n    \n    float otherBranch = sphere(\n            point,\n            otherBranchEnd,\n            .3\n    );\n    \n    float thirdBranch = sphere(\n    \tpoint,\n        thirdBranchEnd,\n        .3\n    );\n    \n    float smoothing = .1;\n    float ret = opSmoothUnion(branch, body, smoothing);\n    ret = opSmoothUnion(otherBranch, ret, smoothing);\n    ret = opSmoothUnion(thirdBranch, ret, smoothing);\n    returnVal.dist = ret;\n    \n    return returnVal;\n}\n\nray getCurrentRay(vec2 uv)\n{\n\tfloat mousex = 9.0*iMouse.x/iResolution.x;\n    \n       //camera calculations\n    vec3 target = bodyEnd;\n    float mousey = 2.0;\n    vec3 rayOrigin = target + vec3(1.5*sin(mousex),.2,1.5*cos(mousex))*mousey;\n    vec3 front = normalize(target - rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    vec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \n    return ray(rayOrigin, rayDir);\n}\n\nvec3 sky(ray currentRay)\n{\n    return mix(WHITE, BLUE, .5*(currentRay.direction.y+1.0));\n}\n\nvec3 marchLeaves(ray currentRay)\n{\n    vec3 col = vec3(.0);\n    float currentDistance = .0;\n    float closestDistance = 1000000.0;\n    bool hit = false;\n\tfor(int i = 0; i < 100; i++)\n    {\n        vec3 samplePoint = currentRay.origin + currentRay.direction*currentDistance;\n        sdfRet ret = leaves(samplePoint);\n        closestDistance = min(closestDistance, ret.dist);\n        if(ret.dist < CLOSE_ENOUGH)\n        {\n            hit = true;\n            col = mix(vec3(1.0, .5, .5), BLUE, currentRay.direction.y * 4.5);\n            break;\n        }\n        currentDistance += ret.dist;\n    }\n    \n    if(!hit)\n    {\n        \n        col = mix(sky(currentRay), vec3(.0), step(closestDistance, .01));\n    }\n    \n    return col;\n}\n\nvec3 march(ray currentRay)\n{\n    #ifdef DEBUG_BOX\n    if(inBox(currentRay, boundingBox)) return vec3(.0);\n    #endif\n    if(!inBox(currentRay, boundingBox)) return sky(currentRay);\n        \n    vec3 col = vec3(.0);\n\tfloat currentDistance = .0;\n    float closestDistance = 1000000.0;\n    bool hit = false;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 samplePoint = currentRay.origin + currentRay.direction*currentDistance;\n        sdfRet ret = tree(samplePoint);\n        closestDistance = min(closestDistance, ret.dist);\n        if(ret.dist < CLOSE_ENOUGH)\n        {\n            hit = true;\n            col = BROWN;\n            break;\n        }\n        currentDistance += ret.dist;\n    }\n    \n    if(!hit)\n    {\n        if(closestDistance > .01)\n        \tcol = marchLeaves(currentRay);\n    }\n    \n    return col;\n}\n\nconst int aa = 2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 total = vec3(.0);\n    //MSAA\n    for(int i = 0; i <aa;i++)\n    for(int j = 0; j <aa;j++)\n    {\n    \t//offset the uv for MSAA\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\n    \tuv.x *= iResolution.x/iResolution.y;\n\n    \tray currentRay = getCurrentRay(uv);\n    \n    \ttotal += march(currentRay);\n    }\n\ttotal /= float(aa*aa);\n    fragColor = vec4(pow(total, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define CLOSE_ENOUGH 0.001\n#define WHITE vec3(1.0,1.0,1.0)\n#define BLUE vec3(.5,.7,1.0)\n#define BROWN vec3(139.,69.,19.)/255.0\n\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct sdfRet\n{\n    float dist;\n};\n    \nfloat lineSegment(vec3 samplePoint, vec3 pointA, vec3 pointB, float radius)\n{\n    vec3 baDifference = pointB-pointA;\n    float h = min(1.0, max(.0, dot(samplePoint-pointA, baDifference)/dot(baDifference, baDifference)));\n    \n    return length(samplePoint - pointA-(baDifference)*h)-radius;\n}\n\nfloat sphere(vec3 samplePoint, vec3 origin, float radius)\n{\n\treturn distance(samplePoint,origin)-radius;\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nstruct box\n{\n    vec3 leftBottom, rightTop;\n};\n\nbool inBox(ray currentRay, box givenBox){\n\n    vec3 dirfrac = vec3(\n    \t1.0 / currentRay.direction.x,\n\t\t1.0 / currentRay.direction.y,\n\t\t1.0 / currentRay.direction.z\n    );\n    \n    vec3 lb = givenBox.leftBottom;\n    vec3 rt = givenBox.rightTop;\n    \n\t// lb is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n\t// r.org is origin of ray\n\tfloat t1 = (lb.x - currentRay.origin.x)*dirfrac.x;\n\tfloat t2 = (rt.x - currentRay.origin.x)*dirfrac.x;\n\tfloat t3 = (lb.y - currentRay.origin.y)*dirfrac.y;\n\tfloat t4 = (rt.y - currentRay.origin.y)*dirfrac.y;\n\tfloat t5 = (lb.z - currentRay.origin.z)*dirfrac.z;\n\tfloat t6 = (rt.z - currentRay.origin.z)*dirfrac.z;\n\t\n\tfloat tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n\tfloat tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\t\n\treturn (tmax > 0.) && (tmin < tmax);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}