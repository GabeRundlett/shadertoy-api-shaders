{
    "Shader": {
        "info": {
            "date": "1629999915",
            "description": "WIP.   bug chasing by simplifying https://shadertoy.com/view/fdt3Rn (with its bug reintroduced line 39).\nOn windows/Angle + nvidia , the right part is plain white ( spiral shape missing ), \n+ red where assert find mod(x,1) != fract().\nCorrect = bi-spiral",
            "flags": 0,
            "hasliked": 0,
            "id": "fdcGRS",
            "likes": 2,
            "name": "GLSL bug #61 ( Windows )",
            "published": 3,
            "tags": [
                "spiral",
                "logarithm",
                "project"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "// bug chasing by simplifying https://shadertoy.com/view/fdt3Rn ( pb not only line39, after all )\n// bug report: https://bugs.chromium.org/p/chromium/issues/detail?id=1245259\n\n#define rot(a)     mat2(cos(a + vec4(0,11,33,0))) // 2D rotation\n\nfloat  pi = 3.141592653;\n\nfloat ObjDf (vec3 p)  // --- define the spiral shape\n{\n  float dMin=100., wSep=5.77, d, r, a, dc;\n\n// float k = -1.; {  // <<< left (only) = bug\n// float k =  1.; {  // <<< right (only) = nobug \n// <<< no bug if loop content moved in a function and called with k = -1. then 1.\n  for (float k = -1.; k <= 1.; k += 2.) { // 2 symmetric spirals\n    vec3 q = p;\n    q.x -= k * wSep;\n    r = length (q.xz);\n    if (r > -.01) // <<< always true but everything bugguy if commented\n    {\n      q.xz *= k;\n      dc = max (r - wSep - .45, min (r - wSep + .55, - q.z)); \n      \n      a = atan (q.z, q.x) / pi;\n      vec2 v = vec2 ( pi * log(r) - .5*a, -5.*a) + .5 ; // <<< only .x used, but bug only shows if vec \n      q.xz = mod  (v, 1.) - .5;  // <<< bug\n   // q.xz = fract(v) - .5;      // <<< equivalent, but nobug\n   // q.x = mod  (v.x, 1.) - .5; // <<< q.z unused, but vec op bug while nobug without q.z\n   \n      st_assert( abs( fract(a+.5) - mod(a+.5,1.) ) < .95, 0 ); // <<< red if fract != mod(x,1).\n                                //  unrelated ? at least correlated as side effect\n      \n      d = max ( r * length (max (abs (q.xy) -.1, .0)), dc );\n      dMin = min(d,dMin); \n    }\n  }\n  return 0.1 * dMin;\n}\n\nvec4 ShowScene (vec3 ro, vec3 rd) // --- ray marching\n{\n  vec3 p;\n  float dHit=0., d=9.;\n  for (int j = 0; j < 300 && d > .01; j ++) { \n    p = ro + dHit * rd;\n    dHit += d = ObjDf (p);\n  }\n  return vec4(dHit/100.);\n}\n\nvoid mainImage (out vec4 O, vec2 u) // --------------------------------\n{\n    vec2 R = iResolution.xy, \n    uv = ( 2.*u - R ) / R.y;\n\n    vec3 ro = vec3 (0, 0, -30),  // setup camera for ray marching\n         rd = normalize (vec3 (uv , 4));\n    ro.yz *= rot(-pi/4.); \n    rd.yz *= rot(-pi/4.); \n\n    float sr =  mod ( mod (floor(R), 2.).x  , 2.) ; // <<< unused, but commenting it fixes the bug !\n      // <<< only use mod().x . still, using R.x, or deleting one mod(), fixes the bug\n                    \n    float a = min(0.,iTime);  // <<< is indeed 0, but as uniform.       \n // float  a = 0.;            // <<< otherwise  left = bug as well\n              // <<< loop does 1 step, but bug without it\n    if (uv.x<0.) for (; a < 1.; a++ ) O = ShowScene(ro,rd); // left = nobug\n    else                              O = ShowScene(ro,rd); // right = bug\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}