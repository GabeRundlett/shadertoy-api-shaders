{
    "Shader": {
        "info": {
            "date": "1562086049",
            "description": "wow 3D",
            "flags": 0,
            "hasliked": 0,
            "id": "WlsSRH",
            "likes": 1,
            "name": "Raymarching practice numero uno",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "zikbakguru",
            "viewed": 390
        },
        "renderpass": [
            {
                "code": "/*\n\tZik's horryfiying SDF lab\n\tWarning : contains disgusting unorganized dirty code!\n\n\tMaterial system heavily inspired from\n\thttps://www.shadertoy.com/view/ld3Gz2\n*/\n#define DIST_MAX 999999999.9\n#define MAX_STEPS 128\n#define MIN_MARCH_DIST 0.001\n\n/*\n\tSDF functions\n*/\nfloat sdfSphere (vec3 p, float r)\n{\n    return length(p) - r;\n}\n// TODO : add n-gon prism sdf\n/*===================================================*/\n\n/*\n\tScene functions\n*/\n// determinator\n/*\nvec4 sceneDet (vec4 a, vec4 b)\n{\n    return (a.w < b.w) ? a : b;\n}*/\n\n// Main bouncy sphere\n// returns distance\nfloat mainSphere (vec3 p, out vec3 mat)\n{\n    const float radius = 120.0;\n    float timeFract = mod(iTime * 64.0, 64.0);\n    float timePercent = pow(1.0 - (timeFract / 64.0), 5.0);\n    float squish = sin(timeFract * 0.5) * timePercent * 0.5;\n    \n    vec3 dp = p;\n    dp.x *= 1.0 + squish;\n    dp.y *= 1.0 - squish;\n    \n    mat = vec3(0.95, 0.65, 0.0);\n    \n    /// face???\n    // eye 1\n    vec2 epos = vec2(-64.0, -20.0);\n    float delta = smoothstep(10.0, 9.0, length(epos - p.xy));\n    mat = mix(mat, vec3(0.12, 0.04, 0.02), delta);\n    \n    // eye 2\n    epos = vec2(64.0, 40.0);\n    delta = smoothstep(10.0, 9.0, length(epos - p.xy));\n    mat = mix(mat, vec3(0.12, 0.04, 0.02), delta);\n    \n    // mouth\n    float mouthRad = 60.0;\n    delta = smoothstep(mouthRad, mouthRad - 1.0, length(p.xy + vec2(-10.0, 30.0))) * clamp(-p.y - 15.0, 0.0, 1.0);\n    mat = mix(mat, vec3(0.12, 0.04, 0.02), delta);\n    ///\n    \n    return sdfSphere(dp, radius);\n}\n\n// Filler sphere(s)\n// returns distance\nfloat sphereFiller (vec3 p, out vec3 mat)\n{\n    const float radius = 42.0;\n    \n    mat = vec3(1.0, 1.0, 1.0);\n    float dist1 = sdfSphere(p + vec3(220.0, -42.0 + cos(iTime * 42.0) * 42.0, 50.0), radius);\n    float dist2 = sdfSphere(p + vec3(-220.0, -42.0 + sin(iTime * 42.0) * 42.0, 50.0), radius);\n    return min(dist1, dist2);\n}\n\n// Light debug\n// returns vec4(colour.xyz, distance)\n/*\nvec4 mainLight (vec3 p)\n{\n    vec4 data = vec4(vec3(1.0, 1.0, 1.0), sdfSphere(p, 32.0));\n    return data;\n}\n*/\n\n// returns distance, [out] vec4 mat\nfloat getSceneInfo (vec3 p, out vec3 mat)\n{\n    vec3 tmpMat;\n    mat = vec3(0.5);\n    float dist = DIST_MAX;\n    float tmpDist;\n    \n    // main sphere\n    tmpDist = mainSphere(p, tmpMat);\n    if (tmpDist < dist)\n    {\n        mat = tmpMat;\n        dist = tmpDist;\n    }\n    \n    // filler shhsh\n    tmpDist = sphereFiller(p, tmpMat);\n    if (tmpDist < dist)\n    {\n        mat = tmpMat;\n        dist = tmpDist;\n    }\n    \n    // light\n    //vec3 lightPos = vec3(cos(iTime) * 128.0, sin(iTime * 2.0) * 42.0, sin(iTime) * 128.0);\n    //data = sceneDet(mainSphereData, data);\n    \n    return dist;\n}\n\nfloat getSceneDist (vec3 p)\n{\n    vec3 trash;\n    return getSceneInfo(p, trash);\n}\n\nvec3 getSceneNormal (vec3 p, vec3 lightPos)\n{\n    vec3 md = vec3(MIN_MARCH_DIST * 10.0, 0.0, 0.0);\n    vec3 delta = vec3(\n        getSceneDist(p + md.xyy) - getSceneDist(p - md.xyy), // = getScene(p + vec3(MIN_MARCH_DIST, 0, 0)) - getScene(p - vec3(MIN_MARCH_DIST, 0, 0)\n        getSceneDist(p + md.yxy) - getSceneDist(p - md.yxy),\n        getSceneDist(p + md.yyx) - getSceneDist(p - md.yyx)\n    );\n    \n    vec3 normal = normalize(delta);\n    return normal;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // c64 stuff\n    vec3 col = fract(vec3(80.0/255.0 + iTime, 69.0/255.0 - iTime * 0.42, 155.0/255.0 + sin(iTime) * 0.2));\n    float jort = fract((uv.y + iTime * 0.5) * 8.0 + uv.x * sin(iTime) * 0.6);\n    vec3 final = mix(col, vec3(1.0), smoothstep(0.49, 0.51, jort));\n\t\n    // World info / camera settings\n    float time = iTime;\n    ivec2 intRes = ivec2(iResolution.xy);\n    vec3 camPos = vec3(0.0, 0.0, -256.0);\n    vec3 lightPos = vec3(cos(time) * DIST_MAX, sin(time * 2.0) * DIST_MAX, sin(time) * DIST_MAX);\n    \n    // We're doing some ortho camera in this shader so\n    // We don't have to worry about spooky projection math\n    vec2 screenPos = uv * iResolution.xy;\n    vec3 rayOrigin = camPos + vec3(screenPos.x - (iResolution.x * 0.5), screenPos.y - (iResolution.y * 0.5), 0.0);\n    vec3 rayPos = rayOrigin;\n    vec3 rayDir = vec3(0.0, 0.0, 1.0);\n\tvec3 mat;\n    \n    for (int rs=0; rs<=MAX_STEPS; rs++)\n    {\n        float dist = getSceneInfo(rayPos, mat);\n\n        if (dist < MIN_MARCH_DIST) // We hit something\n        {\n            vec3 normal = getSceneNormal(rayPos, lightPos);\n            \n            // Diffuse lighting\n            vec3 lightDelta = normalize(rayPos - lightPos);\n            float lightDot = dot(normal, lightDelta);\n            float diffLt = max(lightDot, 0.0) * 0.6 + 0.4;\n            \n            final.xyz = mat.xyz * diffLt;\n        }\n        else // Nope. Keep moving\n        {\n            rayPos += rayDir * dist;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(final,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}