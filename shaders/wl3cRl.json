{
    "Shader": {
        "info": {
            "date": "1609696163",
            "description": "I came up with the idea of creating a spotlight by masking the directional light, so I gave it a try.\nmouse enabled.",
            "flags": 0,
            "hasliked": 0,
            "id": "wl3cRl",
            "likes": 9,
            "name": "Spot light",
            "published": 3,
            "tags": [
                "light",
                "spotlight",
                "spot"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 517
        },
        "renderpass": [
            {
                "code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\ncam0.position = vec3(-63.9759, 73.6247, 30.6849);\n\tcam0.quaternion = vec4(0.2018, -0.3114, -0.7792, 0.5051);\n\tcam0.fov = 0.1622;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = normalize(vec3(0.0, 0.3695, 0.9292));\n    R(lit0.direction.xz, iTime*.5);\n\tlit0.color = vec3(0.9372, 0.9335, 1.0);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(0.0, -0.3695, -0.9292));\n\tlit1.color = vec3(0.0066, 0.0193, 0.0254);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid perspectiveCam(vec2 uv){\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(42,64,42)*3.;\n    if(iMouse.z>0.)\n\tpos = vec3(42.*sin(iMouse.x/iResolution.x*TAU), 64.*iMouse.y/iResolution.y, 42.*cos(iMouse.x/iResolution.x*TAU))*8.;\n\tvec3 target = vec3(0,0,0);\n    vec3 dir = normalize(pos-target);\n    float fov = cam0.fov;\n\n    vec3 cw = normalize(dir);\t\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));;\n}\nvoid camera(vec2 uv){\n\n\tperspectiveCam(uv);\n\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sdScene(vec3 p, bool sha){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp000 = p;\n\tcp000.xyz += vec3(-1.5, -1.0, -1.5);\n\tpRepLimited(cp000.z, 6.0, 25.);\n\tpRepLimited(cp000.x, 6.0, 25.);\n\n\td = sdPlane(p);\n    \n    // sdFakeCapsule\n\t{\n\t\tvec3 tp = cp000+vec3(0.5, -0.5154, 0.0);\n\t\tvec3 trp = cp000+vec3(0.5, -0.5154, 0.0);\n\t\tvec3 dim = vec3(0.007, 3.4345, 0.9421);\n\t\tfloat td = MAX_DIST;\n\n\t\tfloat r = max(dim.x, dim.z);\n\t\tfloat c = dim.y*.5;\n\t\tfloat elg = c-min(.5,c);\n\t\ttrp.y -= clamp(trp.y,-elg,elg);\n\t\t\n\t\tfloat a = .5*trp.y*trp.y+.5;\n\t\tfloat b = abs(trp.y);\n\t\ttrp.y = b<1. ? a : b;\n\t\t\n\t\ttrp.y -= min(.5,c);\n\t\ttd = length(trp)-r;\n\t\td=fOpUnionSmooth(td, d, 0.087);\n\t}\n\tres = v4OpUnion(vec4(d, MAT_ERNST1), res);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST1), res, 0.01);\n    \n    if(!sha){\n        vec3 lightTarget=vec3(0.,1.,0.);\n        float lightDistance = s2u(sin(iTime))*30.;\n        vec3 lightPos=lightTarget+lit0.direction*lightDistance;\n        vec3 q = p-lightPos;\n        \n        R(q.xz, -atan(lit0.direction.x, lit0.direction.z)-HALF_PI);\n        res = v4OpUnion(vec4(max(length(q)-1.5, (q).x), vec3(1)), res);\n    }\n\treturn res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p, false);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p){\n\tfloat c=sdScene(p, false).x;\n\tfloat e=MIN_DIST*.1;\n\treturn normalize(vec3(\n\t\tsdScene(p+vec3(e,0.,0.), false).x-c,\n\t\tsdScene(p+vec3(0.,e,0.), false).x-c,\n\t\tsdScene(p+vec3(0.,0.,e), false).x-c)\n\t);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; // big, such that y = 0 on the first iteration\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t, true).x;\n#if 1\n\t\tres = min( res, k*h/t);\n#else\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// Phong specular\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+1.) / (2.*PI);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    return 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+1.) / (2.*PI);\n    vec3 h  = normalize(-vd+ld);\n    return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    vec3 h  = normalize(-vd+ld);\n    return 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0f-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n#define ggx(roughness, N, V, L) ggx(N, -V, L, roughness, .6)\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n    else if(distance(res.yzw,vec3(1))<.2){\n        renDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = vec3(1);\n    }\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n\n        // Spot light\n        // *********************************************************************\n        vec3 lightTarget=vec3(0.,1.,0.);\n        float lightDistance = s2u(sin(iTime))*30.;\n\t\tvec3 lightPos=lightTarget+lit0.direction*lightDistance;\n        float falloff=max(0., dot(normalize(p-lightPos), -lit0.direction));\n        \n        // attenuation calc from:\n        // https://learnopengl.com/Lighting/Light-casters\n        float d = distance(lightPos, p);\n        const float KL = .0005;\n        const float KQ = .01;\n\t\tfloat attenuation = 1./(1.+KL*d+KQ*(d*d));\n        \n        float power = 2.;\n        falloff = pow(smoothstep(0.9, 1., falloff), power) * attenuation * 15.;\n\t\tfalloff = sms(0.,1.,falloff);\n        // *********************************************************************\n        \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n        lamb1*=falloff;\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\tfloat shininess = .2;\n\t\tfloat intensity = .75;\n\t\trenDat.result*= renDat.albedo;\n\n\t\tfloat spec = ggx(shininess, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.specular = spec*intensity*step(0.1,p.y)*falloff;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow*1.);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t}\n}\n\nvec3 ACESFilm(vec3 x){\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE) return;\n\n\tuv*=ERNST_RENDER_SCALE;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    renDat.result = ACESFilm(renDat.result);\n\trenDat.result = pow(renDat.result, vec3(.9));\n\tfragColor = vec4(renDat.result, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.0)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.0\n#define ITERATION 100\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(0.8, 0.8, 0.8)\n#define MAT_ERNST1 vec3(0.6921)\n\n#define AMB_COL vec3(.5)\n#define AMB_STRENGTH 0.3\n#define FOG_COL vec3(0.0, 0.0, 0.0)\n#define FOG_START -0.63\n#define FOG_POW 1.0\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}