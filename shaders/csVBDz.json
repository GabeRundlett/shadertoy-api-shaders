{
    "Shader": {
        "info": {
            "date": "1698137810",
            "description": "Simulation of a vertically vibrated granular layer - extended to 3D",
            "flags": 32,
            "hasliked": 0,
            "id": "csVBDz",
            "likes": 17,
            "name": "Granular Vibration 2",
            "published": 3,
            "tags": [
                "collision",
                "dynamics",
                "physics",
                "grain"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 298
        },
        "renderpass": [
            {
                "code": "// \"Granular Vibration 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n For further information refer to the scientific and technical\n literature on granular media and flow (note that the rotational\n motion is not really necessary but is included to enhance the\n imagery); also see comments in \"Granular Vibration\".\n*/\n\n#define AA  0  // (= 0/1) optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nvec3 ltPos, vnBall, hbSize, hbPos, vnBlk;\nfloat dstFar, hbMarg, baseUp;\nint nFrame, nBall, idObj, idBall, txOff;\nconst int idFrm = 1, idSup = 2, idFlr = 3, idWal = 4;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d, tr, f, b;\n  dMin = dstFar;\n  q = p;\n  d = q.y;\n  DMIN (idFlr);\n  d = 10. - q.z;\n  DMIN (idWal);\n  q.x = abs (q.x) - hbSize.x - 2.;\n  d = min (PrCylDf (vec3 (q.xz, q.y - baseUp), 0.2, hbSize.y + 2.),\n     PrCylDf (vec3 (q.xz, q.y - 0.1), 1.5, 0.1));\n  DMIN (idSup);\n  q = p;\n  q.y -= baseUp;\n  q = abs (q - hbPos);\n  sLen = vec4 (hbSize - hbMarg - 0.1, 0.);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + 0.05, 0.1),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + 0.05, 0.1)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + 0.05, 0.1));\n  DMIN (idFrm);\n  d = PrCylDf (vec3 (abs (q.xy) - hbSize.xy - vec2 (1., - hbMarg - 0.1), q.z).yzx, 0.2, 1.2);\n  DMIN (idSup);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.46 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.49 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  u = vnBall * QtToRMat (Loadv4 (txOff + 4 * idBall + 2));\n  return step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02, 0.03, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.07 * pi * smoothstep (0.4, 0.47, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rg, ltDir;\n  float dstBall, dstObj, db, att, sh;\n  db = BlkHit (ro - hbPos - vec3 (0., baseUp, 0.), rd);\n  dstBall = (db < dstFar) ? BallHit (ro - vec3 (0., baseUp, 0.), rd) : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idFrm) {\n        col4 = vec4 (0.85, 0.8, 0.8, 0.1);\n      } else if (idObj == idSup) {\n        col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n      } else if (idObj == idFlr) {\n        col4 = vec4 (0.3, 0.3, 1., 0.05);\n        rg = ShGrid (ro.xz, vec2 (0.2), 0);\n        col4.rgb *= rg.y;\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n        else vn.yx = Rot2D (vn.yx, rg.x);\n      } else if (idObj == idWal) {\n        col4 = vec4 (0.4, 0.4, 0.3, 0.05);\n        rg = ShGrid (ro.xy, vec2 (0.2, 0.3), 1);\n        col4 *= rg.y;\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      }\n    } else {\n      ro += dstBall * rd;\n      vn = vnBall;\n      col4 = vec4 (HsvToRgb (vec3 (fract (33. * float (idBall) / float (nBall) +\n         0.5 * BallChqr (idBall, vnBall)), 1., 1.)), 0.2);\n    }\n    ltDir = normalize (ltPos - ro);\n    att = smoothstep (0., 0.02, dot (ltDir, normalize (ltPos)) - 0.9);\n    sh = min (ObjSShadow (ro + 0.01 * vn, ltDir, dstFar),\n       0.5 + 0.5 * BallHitSh (ro - vec3 (0., baseUp, 0.), ltDir, 60.));\n    col = att * (col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n  } else {\n    col = vec3 (0.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 col, ro, rd;\n  vec2 canvas, uv;\n  float el, az, asp, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  asp = canvas.x / canvas.y;\n  txOff = 2;\n  stDat = Loadv4 (0);\n  hbSize = stDat.xyz;\n  stDat = Loadv4 (1);\n  hbPos = stDat.xyz;\n  nBall = int (stDat.w);\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = pi * mPtr.y;\n  } else {\n    az = 0.;\n    el = 0.;\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  az = clamp (az, -0.45 * pi, 0.45 * pi);\n  zmFac = 4.5;\n  vuMat = StdVuMat (el, az);\n  hbMarg = 0.4;\n  baseUp = hbSize.y + 2.;\n  ro = vuMat * vec3 (0., baseUp + 6., -3. * hbSize.x);\n  dstFar = 1000.;\n  ltPos = 200. * vec3 (-0.3, 0.3, -1.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Granular Vibration 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 hbSize, hbPos;\nivec3 nbEdge;\nfloat nStep, fOvlap, fricN, fricS, fricT, dt;\nint nFrame, nBall, txOff;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n// (dynamics from \"Balls In Motion 2\")\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rm -= hbPos;\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricT = 10.;\n  fricS = 1.;\n  fDamp = 0.005;\n  grav = 5.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am.y -= grav;\n  am -= fDamp * vm;\n  wam -= fDamp * wm;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  vec2 w;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf + 0.1), Hashff (mIdf + 0.4), Hashff (mIdf + 0.7)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf + 0.2), Hashff (mIdf + 0.5), Hashff (mIdf + 0.8)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp, diam, amp, freq;\n  int mId, pxId, nbMax;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nbEdge = ivec3 (64, 4, 2);\n  txOff = 2;\n  nbMax = nbEdge.x * nbEdge.y * nbEdge.z;\n  if (iFrag.x >= txRow || pxId >= 4 * nbMax + txOff) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  asp = canvas.x / canvas.y;\n  doInit = false;\n  if (nFrame <= 1) doInit = true;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    hbSize.y *= 4.;\n    hbSize.z *= 0.9;\n    hbPos = vec3 (0.);\n    nStep = 0.;\n    nBall = nbMax;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (1);\n    hbPos = stDat.xyz;\n    nBall = int (stDat.w);\n  }\n  dt = 0.01;\n  freq = 0.5;\n  amp = 2.;\n  hbPos.y = amp * sin (2. * pi * freq * nStep * dt);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (hbPos, float (nBall));\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = m1[0][0];\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (mod (p, 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Granular Vibration 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 hbSize, hbPos;\nivec3 nbEdge;\nfloat nStep, fOvlap, fricN, fricS, fricT, dt;\nint nFrame, nBall, txOff;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n// (dynamics from \"Balls In Motion 2\")\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rm -= hbPos;\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricT = 10.;\n  fricS = 1.;\n  fDamp = 0.005;\n  grav = 5.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am.y -= grav;\n  am -= fDamp * vm;\n  wam -= fDamp * wm;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  vec2 w;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf + 0.1), Hashff (mIdf + 0.4), Hashff (mIdf + 0.7)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf + 0.2), Hashff (mIdf + 0.5), Hashff (mIdf + 0.8)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp, diam, amp, freq;\n  int mId, pxId, nbMax;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nbEdge = ivec3 (64, 4, 2);\n  txOff = 2;\n  nbMax = nbEdge.x * nbEdge.y * nbEdge.z;\n  if (iFrag.x >= txRow || pxId >= 4 * nbMax + txOff) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  asp = canvas.x / canvas.y;\n  doInit = false;\n  if (nFrame <= 1) doInit = true;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    hbSize.y *= 4.;\n    hbSize.z *= 0.9;\n    hbPos = vec3 (0.);\n    nStep = 0.;\n    nBall = nbMax;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (1);\n    hbPos = stDat.xyz;\n    nBall = int (stDat.w);\n  }\n  dt = 0.01;\n  freq = 0.5;\n  amp = 2.;\n  hbPos.y = amp * sin (2. * pi * freq * nStep * dt);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (hbPos, float (nBall));\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = m1[0][0];\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (mod (p, 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}