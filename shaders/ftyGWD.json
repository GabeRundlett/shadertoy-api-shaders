{
    "Shader": {
        "info": {
            "date": "1637678815",
            "description": "Flipping prisms on an extruded grid.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftyGWD",
            "likes": 86,
            "name": "Hexagonal Prism Flip",
            "published": 3,
            "tags": [
                "hexagon",
                "motion",
                "physics",
                "flip",
                "design",
                "extrude"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1097
        },
        "renderpass": [
            {
                "code": "/*\n\n    Hexagonal Prism Flip\n    --------------------\n\n\tFlipping boxes and so forth from their standing cell position within\n    a grid is a video loop standard. There are infinite variations, and \n    this is one of the simpler ones.\n    \n    Other than a bit of basic physics in the form of vector and matrix \n    manipulation, there's not a lot to it: Start off with an extruded grid\n    of objects of some kind, animate the individual cell heights and \n    rotate... That can get a bit fiddly, but it's not too bad.\n    \n    Not a lot of effort was put into this. I used a recent extruded grid \n    shader as a template, manipulated the height routine, then colored the \n    objects a little. I kept the rendering style simple. \n    \n\n\n\tPhysics shaders:\n    \n\t// If you search \"physics\" on Shadertoy, Dr2's name will feature\n    // a lot. Here's a fun motion and collision example.\n    Rolling Stones - Dr2 \n\thttps://www.shadertoy.com/view/MdsfD7\n    \n    // I love this.\n    Loop Ramp - glk7 \n    https://www.shadertoy.com/view/wtfXD4\n    \n    // A bouncing motion example with a really elegant solution.\n    Bouncing Balls Example - blackle\n    https://www.shadertoy.com/view/sss3W8\n\n\n*/\n\n\n// Global tile scale.\nvec2 scale = vec2(1./5., 1./5.);\n\n// Off the rows by half a cell to produce a brickwork feel. The staggered \n// effect can also make a quantized image look smoother.\n#define ROW_OFFSET\n\n// Use hexagon pylons instead of squares.\n#define HEXAGON\n\n// Boring out holes on alternate blocks to give it more of a tech feel and\n// to provide a little extra visual stimuli. Without the holes, the image\n// looks cleaner, but less interesting, I feel.\n#define HOLES\n\n// Raising the faces of the pylon tops. I find it can help bounce the light \n// off the surface in a more reflective way.\n//#define RAISED\n\n// Putting a ridge decoraction on the pylon tops.        \n#define RIDGES\n\n\n// The hexagons must use offset rows.\n#ifdef HEXAGON\n#ifndef ROW_OFFSET\n#define ROW_OFFSET\n#endif\n#endif\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\nfloat hash21(vec2 p){  \n    \n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskin's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y)*p3.z);\n    \n    //p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    //return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n    \n    // IQ's vec2 to float hash.\n    //return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); \n}\n\n\n// Height map value. A keyframe time variable is also passed in for usage\n// inside the block function.\nfloat hm(in vec2 p, inout float tm){ \n\n    \n    // Unique random number for this grid cell.\n    float rnd = hash21(p + .13);\n     \n    // Time variable: Manipulated to periodically fit into transcendental functions.\n    // Modulo 8, in this case, means 8 keyframes. The random variable ensures that\n    // the cell object moves at random times compared to its neighbors.\n    tm = mod(rnd*8. + iTime*4./6.2831, 8.);\n    \n    // Keep the time variable (and as such, height) static for all but the first keyframe.\n    tm = (tm<1.)? tm : 0.;\n\n    // A cheap function to create an undulating wave below the flipping object.\n    //p *= 2.;\n    float waveHeight = dot(sin(p*1.4 - cos(p.yx*2.2 + mod(iTime, 6.2831))*2.), vec2(.25)) + .5;\n\n    // Object height. Just a periodic function that goes up and down within\n    // the first keyframe and remains at zero height for the other keyframes.\n    float h = .5 - cos(tm*6.2831)*.5;\n    \n    // The total height is a mixture of the wave and periodic up-down function.\n    // It's range is roughly zero to one, but not quite.\n    return (h/4. + .25)*waveHeight + h;\n    \n    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n}\n\n/*\n// IQ's extrusion formula with smoothing.\nfloat opExtrusionS(in float sdf, in float pz, in float h, in float sf){\n   \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2(sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n*/\n\n#ifdef HEXAGON\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n      // Flat top.\n      //const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n      // Pointed top.\n      const vec3 k = vec3(.5, -.8660254, .57735); // pi/6: cos, sin, tan.\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      // Flat top.\n      //return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n      // Pointed top.\n      return length(p - vec2(r, clamp(p.y, -k.z*r, k.z*r)))*sign(p.x - r) - sf;\n    \n}\n#endif\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n// Hack to obtain a couple of the static ground shape to create\n// the floor honeycomb.\nfloat shape;\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n    vec2 l = scale;\n\tvec2 s = scale*2.;\n    #ifdef HEXAGON\n    vec2 hSc = vec2(1, scale.y/scale.x*2./1.732);\n    #endif\n    \n    float minSc = min(scale.x, scale.y);\n    \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0); \n    \n    // Four block corner postions.\n    #ifdef ROW_OFFSET\n    // Offset rows.\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.5, -.25), vec2(0, -.25)); \n    #else\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.25, -.25), vec2(-.25)); \n    #endif\n    \n    float data = 0.; // Extra data.\n    \n    shape = 1e5;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - ps4[i]) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + ps4[i])*s;\n        \n        p -= idi; // New local position.\n\n\n        // The extruded block height. See the height map function, above.\n        \n        /// Keyframe time variable.\n        float tm;\n\n        float h = hm(idi, tm);\n        \n        // Flip direction.\n        float dir = (hash21(idi +.07)<.5)? 1. : -1.;\n        // Randomly doubling the flip magnitude... Number of airborn flips.\n        dir *= (hash21(idi +.05)<.5)? 2. : 1.;\n        \n        // It's necessary to let the object clear the ground before rotating, and \n        // for it to finish its rotation upon arrival, so a delay in the rotation \n        // process is necessary. How you arrange that is up to you, but this is how\n        // I did it. It works, but I feel there'd be more elegant solutions.\n        float delay = .175; // Spinning delay - Range: [0, 1].\n        const float totRot = 3.14159; // Total rotation.\n        mat2 cR = (abs(tm - .5)<.5 - delay)? \n                   rot2(dir*(tm - delay)/(1. - delay*2.)*totRot) : mat2(1, 0, 0, 1);\n        \n        // Move the object off the ground.\n        vec3 p3 = vec3(p, q3.z + (h*scale.y*2. - (l.y/2. - .02)*1.));\n        \n        // Rotate.\n        //p3.xy *= cR; // Rotating more than one axis... Probably a bit much.\n        p3.yz *= cR;\n               \n            \n        const float ew = .0125;\n        #ifdef HEXAGON\n        // Hexagon option. ROW_OFFSET is automatically turned on.\n        float di2D = sHexS(p3.xy, minSc/1.732 - ew, .01);\n        //float di2D = length(p3.xy) - (minSc/1.732 - ew); // Cylinder option.\n        \n        // Unrotated shape to carve out the floor.\n        float shp = sHexS(p, minSc/1.732 - ew, .01);\n        //float shp = length(p.xy) - (minSc/1.732 - ew); // Cylinder option.\n        #else\n        \n        float di2D = sBoxS(p3.xy, l/2. - ew, .01);  \n        //float di2D = length(p3.xy) - (minSc/2. - ew); // Cylinder option.\n        // Unrotated shape to carve out the floor.\n        float shp = sBoxS(p.xy, l/2. - ew, .01);\n        //float shp = length(p.xy) - (minSc/2. - ew); // Cylinder option.\n        #endif\n        \n        \n        \n        \n        \n        #ifdef HOLES\n        // Boring out some of the boxes.\n        if((i&1)==0)\n        {\n            di2D = max(di2D, -(di2D + minSc/3.5));\n            //shp = max(shp, -(shp + minSc/4.));\n        }\n        #endif\n        \n        shape = min(shape, shp);\n        \n        \n        // The extruded distance function value.\n        float di = opExtrusion(di2D, p3.z, l.y/2.*(1. - h*.0) - ew);\n\n        \n        #ifdef RAISED\n        // Raised tops.\n        di += di2D*.25;//min(di2D, di2DB)*.5;\n        #endif\n        \n        #ifdef RIDGES\n        // Putting ridges on the faces.\n        di += smoothstep(-.5, .5, sin(di2D/minSc*6.2831*5.))*.005;\n        #endif\n        \n        /*\n        // Lego.\n        float cap = length(p3.xy) - minSc/6.;\n        cap = opExtrusion(cap, p3.z, l.y/2.*(1. - h*.0) - ew + .035);\n        di = min(di, cap); //di = max(di, -cap)\n        */\n        \n        \n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Extra data. In this case, the 2D distance field.\n            data = di2D;\n            \n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, data);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = (-p.z + .02);\n    //float fl = (-p.z + .02) + scale.y/2.;\n    \n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n    \n    // Cutting out prism shapes from the floor to create the honeycomb mold\n    // for the prism block objects to sit in.\n    fl = max(fl, -max(shape, abs(p.z) - scale.y));\n    \n    #ifdef RIDGES\n    // Hollowing ridge grooves into the floor.\n    float minSc = min(scale.x, scale.y);\n    fl -= smoothstep(-.5, .5, sin(shape/minSc*6.2831*5.))*.005;\n    #endif\n    \n    #ifdef RAISED\n    // Hollowing out the floor to match the raised tops on the objects.\n    fl -= shape*.25;//min(di2D, di2DB)*.5;\n    #endif\n\n    // Debug to see the honeycomb floor only.\n    //d4.x += 1e5;\n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded object.\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<64; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.4 : d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    #ifdef HEXAGON\n    scale *= vec2(2./1.732, 1);\n\t#endif\n    \n\t// Camera Setup.\n    // Tilted camera, just to prove it's 3D. :)\n\t//vec3 ro = vec3(0, -1.3, -2.2); // Camera position, doubling as the ray origin.\n\t//vec3 lk = ro + vec3(0, .12, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n\t// Front on camera.\n    vec3 ro = vec3(0, iTime/16., -1.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .05, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.25, .5, .5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2( sin(iTime)/32. );\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block field value, block ID and 2D data field value.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n    \n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n      \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Scene object color. \n\t    vec3 texCol;   \n\n        \n        if(svObjID<.5){\n            \n            // The flipping prisms.\n            \n            // Manipulating IQ's cosine palette for golden hues.\n            vec3 cCol = (.5 + .45*cos(6.2831*hash21(svGID.yz)/5. + vec3(0, 1, 2) - .1));\n            \n            // Turning it into a pink palette.\n            texCol = mix(min(cCol.xzy*1.65, 1.), vec3(1), .05);\n            \n            // Light based gradient mix.\n            texCol = mix(texCol, texCol.zyx, smoothstep(-.25, .5, ld.y));\n            //texCol = texCol.yxz; // Color swizzle.\n            \n            // Plain white.\n            //texCol = vec3(.75);\n            // Greyscale.\n            //texCol = vec3(hash21(svGID.yz + .15)*.5 + .35);\n \n        }\n        else {\n            \n            // The floor with the bored out honeycomb.\n            texCol = (sp.z>scale.y - .01)? vec3(.2, .4, 1) : vec3(.05);\n            \n            texCol = mix(texCol, texCol.yzx, smoothstep(-.25, .5, -ld.y)*.25);\n            \n            //texCol = mix(texCol.yxz, texCol, .75);\n        }\n       \n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n        \n          \n\t\n\t}\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}