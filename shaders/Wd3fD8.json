{
    "Shader": {
        "info": {
            "date": "1606297772",
            "description": "Simple scrolling scene",
            "flags": 96,
            "hasliked": 0,
            "id": "Wd3fD8",
            "likes": 21,
            "name": "Vapor buildings",
            "published": 3,
            "tags": [
                "vhs",
                "vapor",
                "retrowave"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 966
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 postFX(vec2 uv, float blur)\n{\n    vec3 col;\n    int cnt = 20;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = fi/fcnt;\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 2.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n    \tcol += texture(iChannel0, p).xyz;\n    }\n    \n    return col/float(cnt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = postFX(uv,.008);\n    \n\tcol += pow(postFX(uv,.02), vec3(.45));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 24694,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/set_reload/yu-utsu-sun?in=el-jorge-4/sets/vapor"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 getCam(vec3 dir, vec2 uv)\n{\n    vec3 r = normalize(cross(dir, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(dir, r));\n    return dir + uv.x*r+uv.y*u;\n}\n\nfloat map(vec3 p)\n{\n    float rep = 5.5;\n    float idx = float(int((p.x+rep*.5)/rep))*15.;\n    float rep2 = 5.;\n    float ht = sin(float(int((p.z+iTime*15.+rep2*.5)/rep2))*15.);\n    p.z = mod(p.z+iTime*15.+rep2*.5,rep2)-rep2*.5;\n    p.x = mod(p.x+rep*.5, rep)-rep*.5;\n    \n    return sdBox(p-vec3(0.,.5+0.8*sin(idx+3.8), 0.), vec3(.4, 2.+ht*.5+.5, .3), idx);\n}\n\nvec4 layer3D(vec2 uv)\n{\n    vec3 col;\n    float opa;\n    \n    float dis = 5.;\n    vec3 ro = vec3(sin(iTime*.5)*.3+2.,1.+sin(iTime*.25)*.2,-5.);\n    vec3 ta = vec3(0.,-4.,15.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    \n    float t = 0.001;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd*t;\n        float d = map(p);\n        if (abs(d) < t*0.001)\n        {\n            vec3 win = vec3(255, 188, 87)/255. * sat((sin(p.y*15.+1.)-.8)*10.);\n\t\t\twin *= sat((sin(p.x*4.)-.8)*10.);\n            vec3 win2 = vec3(255, 188, 87)/255. * sat((sin(p.y*15.+1.)-.8)*4.);\n\t\t\twin2 *= sat((sin(p.x*4.)-.8)*4.);\n            col += win+win2;\n            opa = 1.0;\n            break;\n        }\n        t += d*.5;\n    }\n    \n    return vec4(col, opa);\n}\n\nvec2 myPixel(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    \n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\nvec3 rdrr(vec2 uv)\n{\n    vec3 col;\n    \n    col = mix(vec3(88, 88, 232)/255., vec3(247, 102, 158)/255., pow(sat(-uv.y*2.+.2),.7));\n    vec3 sun = (vec3(207, 142, 4)/255.)*(1.-sat((length(uv)-.1)*5.))*.5;\n    col += sun;\n    vec4 layer3d = layer3D(uv);\n    col = mix(col, layer3d.xyz, layer3d.w);\n    \n    col *= pow(1.-sat(length((uv-vec2(-.2,.2))*.2)), 3.);\n    uv = myPixel(uv+5., 0.005)-5.;\n    \tcol *= sat(.5+.8*rand(uv*sin(iTime)));\n    \n    col *= 1.-sat((sin(uv.x*70.)-.99)*iResolution.x);\n    col *= 1.-sat((sin(uv.y*70.)-.99)*iResolution.x);\n\tcol += sun*(col+.5);\n    col *= pow(1.-sat(lenny(uv)),2.);\n    return col;\n}\n\n\nvec3 rdr(vec2 uv)\n{\n    uv *= pow(1.+length(uv),.5);\n    vec3 col;\n    vec2 dir = vec2(1.);\n    float strength = 0.003+0.003*length(uv*2.);\n    col.r = rdrr(uv+dir*strength).r;\n    col.g = rdrr(uv).g;\n    col.b = rdrr(uv-dir*strength).b;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n\tuv.x += sat(sin((uv.y+mod(iTime*10.0,3.5))*55.)-.9)*.08;\n    vec3 col = rdr(uv);\n    if (uv.x < -.49)\n        col = col.xxx*.3;\n    fragColor = vec4(mix(col, texture(iChannel0, ouv).xyz, 1.-1./2.),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float ca = cos(a), sa = sin(a); return mat2(ca, -sa, sa, ca); }\n// Stolen on stackoverflow\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat lenny(vec2 uv)\n{\n    return abs(uv.x)+abs(uv.y);\n}\n// My version =D, Happy that I came up with this one\n// still have to test it but the shape is good\nfloat sdBox(vec3 p, vec3 b, float idx)\n{\n    p.xz *= r2d(PI/4.0+idx*25.);\n    vec3 a = abs(p)-b;\n    return max(a.x, max(a.y, a.z));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}