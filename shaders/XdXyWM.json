{
    "Shader": {
        "info": {
            "date": "1488365812",
            "description": "Fork from https://www.shadertoy.com/view/lld3z8 using the same vortex pair warp as in https://www.shadertoy.com/view/MsscD4#\n\nKeep the mouse button pressed and stir the pot. Big Kudos to Cornus Ammonis!",
            "flags": 48,
            "hasliked": 0,
            "id": "XdXyWM",
            "likes": 53,
            "name": "Dynamical Flame vs Dual Vortex",
            "published": 3,
            "tags": [
                "flame",
                "diffusion",
                "advection",
                "reaction"
            ],
            "usePreview": 0,
            "username": "Flexi",
            "viewed": 3152
        },
        "renderpass": [
            {
                "code": "// Visualization of the system in Buffer A\n\n// uncomment to just render the normals\n//define NORMAL\n\n// displacement\n#define DISP -0.015\n\n// contrast\n#define SIGMOID_CONTRAST 8.0\n\n// mip level\n#define MIP 1.0\n\nvec4 contrast(vec4 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    #ifdef NORMAL\n    \tvec2 d = texture(iChannel1, uv).xy;\n   \t\tvec3 nr = 0.5 + 0.5 * normalize(vec3(d.x,d.y,sqrt(clamp(1.0-length(d.xy),0.0,1.0))));\n    \tfragColor = vec4(nr, 1.0);\n    #else\n        vec2 n  = vec2(0.0, texel.y);\n        vec2 e  = vec2(texel.x, 0.0);\n        vec2 s  = vec2(0.0, -texel.y);\n        vec2 w  = vec2(-texel.x, 0.0);\n\n        vec2 d   = texture(iChannel1, uv).xy;\n        vec2 d_n = texture(iChannel1, fract(uv+n)).xy;\n        vec2 d_e = texture(iChannel1, fract(uv+e)).xy;\n        vec2 d_s = texture(iChannel1, fract(uv+s)).xy;\n        vec2 d_w = texture(iChannel1, fract(uv+w)).xy;    \n\n        vec3 i   = texture(iChannel0, fract(uv + DISP * d  ), MIP).xyz;\n        vec3 i_n = texture(iChannel0, fract(uv + DISP * d_n), MIP).xyz;\n        vec3 i_e = texture(iChannel0, fract(uv + DISP * d_e), MIP).xyz;\n        vec3 i_s = texture(iChannel0, fract(uv + DISP * d_s), MIP).xyz;\n        vec3 i_w = texture(iChannel0, fract(uv + DISP * d_w), MIP).xyz;\n\n    \tvec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n    \tfloat dd = exp(-0.02 * length(abs(d_n-d_s) + abs(d_e-d_w)));\n        vec3 ib = 0.4 * i + 0.15 * (i_n+i_e+i_s+i_w);\n\n        //vec3 nr = normalize(vec3(db.x,db.y,sqrt(clamp(1.0-length(db.xy),0.0,1.0))));\n        //vec3 l = normalize(vec3(cos(TIME), sin(TIME), 0.1)); \n        //vec3 sh = pow(vec3(clamp(dot(nr,l),0.0,1.0)), vec3(1.0));\n    \tfloat shl = 1.0 * exp(-0.13 * length(db.xy)) * dd;\n\n    \tvec3 m = shl * mix(vec3(1.2, 0.0, 0.0), vec3(0.9, 0.7, 0.3), shl);\n        fragColor = contrast(vec4(0.7*ib + m,1.0));\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi2_inv 0.159154943091895335768883763372\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 16.;\n\n    float d = 0.125;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) / 2.;\n}\n\nvec2 mouseDelta(){\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    vec4 oldMouse = texture(iChannel2, vec2(7.5 * eighth, 2.5 * eighth));\n    vec4 nowMouse = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\n//begin original shader by user/cornusammonis\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 24.0\n#define W1 0.3\n#define TIMESTEP 0.2\n#define ADVECT_DIST 0.2\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    const float xd = sqrt(3.0) / 2.0;\n    const float xi = 1.0 - xd;\n    return 0.5 * ((x + x_v) * xi + (x_h + x_d) * xd);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    const float xd = sqrt(3.0) / 2.0;\n    const float xi = 1.0 - xd;\n    return 0.5 * ((x + x_h) * xi + (x_v + x_d) * xd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n\n// begin Felix' edit to the original by Cornus Ammonis\n    vec2 mouseV = mouseDelta();\n    if(length(mouseV)==0. && iFrame > 48){\n        fragColor = texture(iChannel0, vUv);\n        return;\n    }\n    vec2 aspect = vec2(1.,texel.x/texel.y);\n    vUv = vortex_pair_warp(vUv, iMouse.xy*texel, mouseV*aspect*1.4);\n// end    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = sqrt(3.0) / 2.0;\n    const float hx = vy;\n    const float hy = vx;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    vec2 d_nne = diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy);\n    vec2 d_ene = diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy);\n    vec2 d_ese = diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy);\n    vec2 d_sse = diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy);\n    vec2 d_ssw = diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy);\n    vec2 d_wsw = diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy);\n    vec2 d_wnw = diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy);\n    vec2 d_nnw = diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy);\n    \n    float di_nne = nl(distance(d_nne, u.xy));\n    float di_ene = nl(distance(d_ene, u.xy));\n    float di_ese = nl(distance(d_ese, u.xy));\n    float di_sse = nl(distance(d_sse, u.xy));    \n    float di_ssw = nl(distance(d_ssw, u.xy));\n    float di_wsw = nl(distance(d_wsw, u.xy));\n    float di_wnw = nl(distance(d_wnw, u.xy));\n    float di_nnw = nl(distance(d_nnw, u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = d_nne - u.xy;\n    vec2 xy_ene = d_ene - u.xy;\n    vec2 xy_ese = d_ese - u.xy;\n    vec2 xy_sse = d_sse - u.xy;\n    vec2 xy_ssw = d_ssw - u.xy;\n    vec2 xy_wsw = d_wsw - u.xy;\n    vec2 xy_wnw = d_wnw - u.xy;\n    vec2 xy_nnw = d_nnw - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec2 du = u_blur.xy;\n    vec2 dv = u_blur.zw;\n    \n    for (int i = 0; i < 5; i++ ) {\n        vec4 auv = advect(du, vUv, texel);        \n        dv = auv.zw + 1.0 * ma;\n        du = auv.xy + 0.4 * dv;\n    }\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = 2.0 * exp(-length(d) / 100.0);\n// begin Felix' edit: just deactivated the original mouse interaction\n//        du.xy += m * normz(d);\n// end\n    }\n    \n    vec3 init = texture(iChannel1, vUv).xyz;\n    // initialize with noise\n    if((length(u) <= 0.001 && init != vec3(0.0)) || reset()) {\n        fragColor = vec4(-0.5 + init.xy, 0.0, 0.0);\n    } else {\n        fragColor = vec4(du, dv);\n    }\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}