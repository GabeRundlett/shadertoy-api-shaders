{
    "Shader": {
        "info": {
            "date": "1634441419",
            "description": "Implicit trace using a second order approximation for the distance. \nExact gradient/hessian is generated using a forward autodiff scheme. \nMove the camera by holding down the left mouse button and drag. ",
            "flags": 48,
            "hasliked": 0,
            "id": "7dVXzw",
            "likes": 26,
            "name": "MetaTorus autodiff 2O",
            "published": 3,
            "tags": [
                "distancefield",
                "spheretracing",
                "implicit",
                "curvature",
                "hessian",
                "autodiff",
                "automaticdifferentiation"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 839
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"MetaTorus autodiff 2O\" created by Colling Patrik (cyperus) in 2021\n//\n// BASED ON\n// - sibaku https://www.shadertoy.com/view/MdtXWM\n//          https://www.shadertoy.com/view/Nd3GRS\n//          https://github.com/sibaku/glsl-autodiff\n//\n// - iq     https://iquilezles.org/articles/intersectors\n//          iq https://www.shadertoy.com/view/3s33zj // adjugate matrix\n//\n// - cyperus https://www.shadertoy.com/view/wlBfzW\n//\n// DESCRIPTION:\n// - Testing implicit trace using a 2nd order approximation for the distance\n//   estimation.\n// - Exact gradient/hessian is generated using a forward autodiff scheme.\n// - Display surface normal and curvatures.\n//\n// TODO:\n//  (0) Fix correct shading of the near-slicing-face. \n//\n// CONTROLS:\n// <mouse>: change view direction\n// <up/down>: move camera to center\n// <page_up/page_down>: cycle through colormodes.\n//   0 cubemap\n//   1 ray march step iterations exp    [i<10, i ,i<i_max-10] -> [blue, gray, red]\n//   2 ray march step iterations linear [i<10, i ,i<i_max-10] -> [blue, gray, red]\n//   3 surface gradient length    [-inf, 0., +inf] -> [blue, white, red]\n//   4 surface normal orientation incoded as rgb-color \n//   5 gaussian curvature         [-inf, 0., +inf] -> [blue, white, red]\n//   6 mean curvature             [-inf, 0., +inf] -> [blue, white, red]\n//   7 principal_curvature-u      [-inf, 0., +inf] -> [cayen, black, yellow]\n//   8 principal_curvature-v      [-inf, 0., +inf] -> [cayen, black, yellow]\n// 's': toggle on/off shading\n// 'b': toggle on/off bounding sphere contour\n// 'f': toggle second/first order approximation\n// 'p': toggle eigenvalue estimate/frobenius norm\n//\n//********************************************************************\n//\n// Global defines\n//\n//********************************************************************\n\n// consts\n#define AUTO_INFINITY 3.402823e+38\n#define PI 3.14159265\n\n// application state defined by keyboard texture.\n#define useShading     ( !keytoggle(CHAR_S) )\n#define showBB         (  keytoggle(CHAR_B) )\n#define useFirstOrder  (  keytoggle(CHAR_F) )\n#define usePowerMethod (  keytoggle(CHAR_P) )\n\n// application state defined by buffered key values.\n#define subKeycount_DOWN_UP       ( keycount(KEY_DOWN)-keycount(KEY_UP) )\n#define subKeycount_PAGE_DOWN_UP  ( keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP) )\n\n// mouse state\n#define mouseInit ( iMouse == vec4(0.) )\n\n// animation\nconst float anim_velocity = 0.5;\n\n// camera\nconst float cam_dist = 10.0;\nconst float cam_fle  = 4.;\nconst float cam_tmin = 2.0;\nconst float cam_tmax = 1000.;\n\n// rayintersection\nconst float bb_size = 3.;\n\n// raymarch SDF\nconst float eps = 0.0005;\nconst int maxSteps = 150;\nconst float sl_mul = 1./sqrt(3.); // step length multiplier\n// color\nconst int num_colormode = 9;\n\n// SDF transformation level activation (comment in out)\n#define level1\n#define level2\n#define level3\n\n// SDF \nstruct surface {\n  //\n  float r0;     // float\n  #ifdef level1\n  float au10;   // float\n  float au11;   // float\n  float fracu1; // int in [1,2,3,..]\n  float pu1;\n\n  float twist1; // int in [...,-1,0,+1,...]\n  float fracv1; // int in [1,2,3,..]\n  float pv1;    // float\n  #endif\n  #ifdef level2\n  float au20;   // float\n  float au21;   // float\n  float fracu2; // int in [1,2,3,..]\n  float pu2;\n\n  float twist2; // int in [...,-1,0,+1,...]\n  float fracv2; // int in [1,2,3,..]\n  float pv2;    // float\n  #endif\n  \n  float au30;\n  #ifdef level3  \n  float au31;\n  float fracu3;\n  #endif\n};\n\n// SDF parametrisation\nvoid getsurface(out surface paras, in float time) {\n  // level0\n  paras.r0 = 4.; //paras.r0 *= sin( 0.5*iTime );\n  // level1\n  #ifdef level1\n  paras.au10 = 2.;  // float\n  paras.au11 = 1.;  // float\n  paras.fracu1 = 1.; // int in [1,2,3,..]\n  paras.pu1 = 0.5*time;\n \n  paras.twist1 = 1.; // int in [...,-1,0,+1,...]\n  paras.fracv1 = 2.; // int in [1,2,3,..]\n  paras.pv1 = 0.2*time;  // float\n  #endif\n  // level2\n  #ifdef level2\n  paras.au20 = -4.;  // float\n  paras.au21 =  4.;  // float\n  paras.fracu2 = 5.; // int in [1,2,3,..]\n  paras.pu2 = 0.5*time;\n  \n  paras.twist2 = 4.;   // int in [...,-1,0,+1,...]\n  paras.fracv2 = 2.;   // int in [1,2,3,..]\n  paras.pv2 = 0.*time; // float\n  #endif\n  // level3\n  paras.au30 = 3.;\n  #ifdef level3  \n  paras.au31 = cos(time);\n  paras.fracu3 = 3.;\n  #endif\n}\n\n// SDF implicit function f(x,y,z,paras)\nHNum3 implicit(in HNum3 x, in HNum3 y, in HNum3 z, in surface pa) {\n  /// level-0:\n  // torus\n  HNum3 au = a_atan2(x,z);\n  c_HNum3 z0 = c_HNum3( a_length(z, x), y);  \n  z0 = csub(cmul(z0, z0), c_HNum3(constH3(pa.r0), constH3(0.)));\n  \n  /// level-1:\n  #ifdef level1\n  HNum3 shift1   = add(pa.au10, mult(pa.au11, a_cos(add(mult(pa.fracu1, au), constH3(pa.pu1)))) );\n  HNum3 torsion1 = sub(mult(au, constH3(pa.twist1/pa.fracv1)), constH3(pa.pv1));\n  z0 = crpt(z0,torsion1, int(pa.fracv1), shift1);\n  #endif\n  \n  /// level-2:\n  #ifdef level2\n  HNum3 shift2   = add(pa.au20, mult(pa.au21, a_cos(add(mult(pa.fracu2, au), constH3(pa.pu2)))) );\n  HNum3 torsion2 = sub(mult(au, constH3(pa.twist2/pa.fracv2)), constH3(pa.pv2));\n  z0 = crpt(z0,torsion2, int(pa.fracv2), shift2);\n  #endif\n  \n  /// level-3:\n  #ifdef level3\n  HNum3 r3 = add( pa.au30, mult( pa.au31, a_cos(mult(pa.fracu3, au))));\n  #else\n  HNum3 r3 = constH3(pa.au30);\n  #endif\n  \n  return sub(a_length(z0.x , z0.y) ,r3);\n}\n\n// distance estimation\nfloat DE(in vec3 p, in surface paras) {\n  HNum3 result;\n  HESSIAN3(implicit, p.x, p.y, p.z, paras, result);\n\n  float g2 = dot(result.g, result.g);\n  float g = sqrt(g2);\n  float v = sl_mul * result.val;\n\n  // First order distance estimation\n  if (useFirstOrder) {\n    if (g < eps) return v;\n    else         return v / g;\n  } else {\n  // Second order uses any compatible matrix norm\n    // Default here is frobenius ->  fast and simple\n    // power method assumes the hessian to be symmetric to calculate spectral\n    // norm (should be for functions with continuous second order partials)\n    float m = usePowerMethod ? powerNorm(result.h): frobenius(result.h);\n\n    // Special cases for zero values\n    if (m < eps) {\n        if (g < eps) return v;\n        else              return v / g; }     \n    else\n        if (g < eps) return sqrt(2. * abs(v) / m) * sign(v);\n        else              return (sqrt(g2 / m / m + 2. * abs(v) / m) - g / m) * sign(v);\n  }\n}\n\n// ray march \nbool raymarch(in vec3 ro, in vec3 rd,\n              inout float t, in float tmax, in surface paras,\n              out float dist, out int steps) {      \n      steps = 0;\n      dist = 10.0;\n      vec3 pos;\n      float lastT = 0.;  \n      for (int i = 0; i < maxSteps; i++) {\n        pos = ro + t * rd;\n        float d = DE(pos, paras);\n        // hit surface\n        if (d < eps)        \n        {                              \n          dist = 0.;\n          t = lastT;\n          return true;\n        }\n        // update step\n        lastT = t;\n        t += d;\n        steps++;\n        // ray outside rang\n        if (t > tmax)\n          return false;\n      }\n      return false; // i >= maxSteps      \n}\n\n// normalized centered uv coordinates\nvec2 centerUV(in vec2 uv) {\n    return (2.0*uv-iResolution.xy)/iResolution.y;}\n\n// world => came coords\nvec3 transform(in vec3 p, in vec2 uv) {\n    if (mouseInit) uv = vec2(0.5, -0.3);\n    p.yz = crot(p.yz,  PI * uv.y);\n    p.zx = crot(p.zx, -PI * uv.x);\n\treturn p;}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  // global time\n  float time = anim_velocity*iTime;\n  \n  // animation parameters\n  surface paras;\n  getsurface(paras,time);\n  \n  //camera\n  float moveCame = 1.- 0.0666*float(subKeycount_DOWN_UP);\n  moveCame *= sign(moveCame)*moveCame; // 1/rÂ²\n  vec2 uv_mouse = centerUV(iMouse.xy);\n  vec2 uv_pix   = centerUV(fragCoord);\n  vec3 ro = moveCame * transform(vec3(0.,0.,-cam_dist), uv_mouse);\n  vec3 rd = normalize(transform(vec3(uv_pix, cam_fle), uv_mouse));\n\n  // light\n  vec3 LPos = vec3(-2., -2., -cam_dist);\n  LPos = transform(LPos, uv_mouse);\n  \n  // ray\n  vec3 col ;      \n  float tmin = cam_tmin;\n  float tmax = cam_tmax;\n  // TODO_0:\n  //  - get camera-view-range near-surface-normal.\n  //  - initialize near-slicing-face-normal.\n  \n  // get bb-ray-range (bb boundingbox)\n  vec2 bb_t = isphere( ro, rd ,abs(bb_size));\n  // TODO 0: (for correct shading of the near-slicing-face)\n  //  - get BB near-surface-normal.\n \n  // check ray-range for raymarching\n  if( (bb_t.y > tmin) && (bb_t.x < tmax) ) {\n      // get new ray-range\n      tmin = max(tmin, bb_t.x);\n      tmax = min(tmax, bb_t.y);\n      // TODO_0:\n      //  - update near-slicing-face-normal;\n      \n      // raymarch inside bb\n      int steps;\n      float d;\n      float t = tmin; // ray length\n      if (raymarch(ro, rd, t, tmax, paras, d, steps)) {\n        // surface geometric properties\n        vec3 P = ro + t * rd;\n        HNum3 result = implicit(varH3x(P.x), varH3y(P.y), varH3z(P.z), paras);\n        vec3 N =  normalize(result.g);\n        // surface color\n        int iColorMode = abs(subKeycount_PAGE_DOWN_UP) % num_colormode;\n        col = (iColorMode == 0)? texture(iChannel1, reflect(rd,N)).xyz // reflection cubemap //  TODO 0: - use the near-slicing-face-normal.\n            : (iColorMode == 1)? colormapstep(steps, maxSteps, BLUE, RED, true)\n            : (iColorMode == 2)? colormapstep(steps, maxSteps, BLUE, RED, false)\n            : (iColorMode == 3)? colormap3(-sign(dot(rd, N)) * length(result.g) * 0.04, BLUE, WHITE, RED) // gradient length\n            : (iColorMode == 4)? 0.5*N +0.5 // normal orientation \n            : (iColorMode == 5)? colormap3(gaussian_curvature(result) * 4., BLUE, WHITE, RED)\n            : (iColorMode == 6)? colormap3(mean_curvature(result) * 4., BLUE, WHITE, RED)\n            : (iColorMode == 7)? colormap2(principal_curvature(result).x, CAYEN, YELLOW)\n            :                    colormap2(principal_curvature(result).y, CAYEN, YELLOW);\n        // shade\n        if (useShading) {\n            vec3 L = normalize(LPos - P);\n            // TODO_0:\n            //  - use the near-slicing-face-normal.\n            col *= max(dot(L, N), 0.) + 0.2;} }\n      else {\n         // background color inside bb\n         col = texture(iChannel1, rd).xyz; col *= col;// cubemap, gamma\n         if (showBB) col += vec3(smoothpuls(abs(bb_t.x - bb_t.y) -1.,0.25),0.,0.);}}\n  else{\n       // background color outside bb\n       col = texture(iChannel1, rd).xyz; col *= col;}// cubemap, gamma\n  // gamma\n  fragColor = vec4(sqrt(col), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// sibaku: forward-autodiff code from https://github.com/sibaku/glsl-autodiff\n#ifndef HESSNUM_3_H_\n#define HESSNUM_3_H_\n\n// This file contains methods to compute the gradient and hessian \n// of a scalar valued 3 dimensional function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 3 dimensional function\n// These should be created by the constH3 (for constants) and varH3 (for variables) helpers\nstruct HNum3\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec3 g;\n    // The current hessian\n    mat3 h;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant HNum3\n* @param val The current value of the constant\n*/\nHNum3 constH3(in float val);\n/**\n* Creates a HNum3 corresponding to the variable with the given index\n* @param val The current value of the variable\n* @param index The variable's index\n*/\nHNum3 varH3(in float val, in int index);\n/**\n* Creates a HNum3 corresponding to the variable x (index = 0)\n* @param val The current value of the variable\n*/\nHNum3 varH3x(in float val);\n/**\n* Creates a HNum3 corresponding to the variable y (index = 1)\n* @param val The current value of the variable\n*/\nHNum3 varH3y(in float val);\n/**\n* Creates a HNum3 corresponding to the variable z (index = 2)\n* @param val The current value of the variable\n*/\nHNum3 varH3z(in float val);\n\nHNum3 add(in HNum3 a, in HNum3 b);\nHNum3 add(in HNum3 a, in float b);\nHNum3 add(in float a, in HNum3 b);\n\nHNum3 sub(in HNum3 a, in HNum3 b);\nHNum3 sub(in HNum3 a, in float b);\nHNum3 sub(in float a, in HNum3 b);\n\nHNum3 mult(in HNum3 a, in HNum3 b);\nHNum3 mult(in HNum3 a, in float b);\nHNum3 mult(in float a, in HNum3 b);\n\nHNum3 inv(in HNum3 a);\nHNum3 div(in HNum3 a, in HNum3 b);\nHNum3 div(in HNum3 a, in float b);\nHNum3 div(in float a, in HNum3 b);\n\n//HNum3 a_pow(in HNum3 a, in HNum3 b);\n//HNum3 a_pow(in HNum3 a, in float b);\n//HNum3 a_pow(in float a, in HNum3 b);\nHNum3 a_ipow(in HNum3 x, in int n);\n\nHNum3 a_sqrt(in HNum3 a);\n//HNum3 a_inversesqrt(in HNum3 a);\n\nHNum3 a_exp(in HNum3 a);\nHNum3 a_exp2(in HNum3 a);\nHNum3 a_log(in HNum3 a);\nHNum3 a_log2(in HNum3 a);\n\nHNum3 neg(in HNum3 a);\nHNum3 a_abs(in HNum3 a);\n/*\nHNum3 a_floor(in HNum3 a);\nHNum3 a_ceil(in HNum3 a);\n\nHNum3 a_min(in HNum3 a, in HNum3 b);\nHNum3 a_max(in HNum3 a, in HNum3 b);\n*/\nHNum3 a_cos(in HNum3 a);\nHNum3 a_sin(in HNum3 a);\nHNum3 a_tan(in HNum3 a);\n//HNum3 a_acos(in HNum3 a);\n//HNum3 a_asin(in HNum3 a);\nHNum3 a_atan(in HNum3 a);\nHNum3 a_atan2(in HNum3 y, in HNum3 x);\nHNum3 a_atan2(in HNum3 y, in float x);\nHNum3 a_atan2(in float y, in HNum3 x);\n/*\nHNum3 a_cosh(in HNum3 a);\nHNum3 a_sinh(in HNum3 a);\nHNum3 a_tanh(in HNum3 a);\nHNum3 a_acosh(in HNum3 a);\nHNum3 a_asinh(in HNum3 a);\nHNum3 a_atanh(in HNum3 a);\n*/\n/*\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t);\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in float b, in float t);\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in float a, in HNum3 b, in float t);\nHNum3 a_mix(in float a, in float b, in HNum3 t);\n*/\nHNum3 a_length2(in HNum3 x, in HNum3 y);\nHNum3 a_length2(in HNum3 x, in HNum3 y, in HNum3 z);\nHNum3 a_length(in HNum3 x, in HNum3 y);\nHNum3 a_length(in HNum3 x, in HNum3 y, in HNum3 z);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define HESSIAN3(f,x, y, z, paras, result)  {\\\n    result = f(varH3x(x), varH3y(y), varH3z(z), paras);\\\n    }\n\n//--------------------------------\n// Utilities prototypes\n//--------------------------------\n\n\n//----------------------------------------------------------------\n// Implementation\n//----------------------------------------------------------------\nHNum3 constH3(in float val)\n{\n    return HNum3(val, vec3(0.0), mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3(in float val, in int index)\n{   \n    vec3 g = vec3(0.0);\n    g[index] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3x(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[0] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3y(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[1] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3z(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[2] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//----------------------------------------------------------------\nHNum3 add(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val + b.val , a.g + b.g, a.h + b.h);\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in float b)\n{\n    return HNum3(a.val + b , a.g, a.h);\n}\n//--------------------------------\nHNum3 add(in float a, in HNum3 b)\n{\n    return HNum3(a + b.val , b.g, b.h);\n}\n//----------------------------------------------------------------\nHNum3 sub(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val - b.val , a.g - b.g, a.h - b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in float b)\n{\n    return HNum3(a.val - b , a.g, a.h);\n}\n//--------------------------------\nHNum3 sub(in float a, in HNum3 b)\n{\n    return HNum3(a - b.val , - b.g, - b.h);\n}\n//----------------------------------------------------------------\nHNum3 mult(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val * b.val, \n        a.val*b.g + b.val*a.g, \n        a.val*b.h + b.val*a.h + outerProduct(b.g,a.g) + outerProduct(a.g,b.g)\n    );\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in float b)\n{\n    return HNum3(a.val * b, b*a.g, b*a.h);\n}\n//--------------------------------\nHNum3 mult(in float a, in HNum3 b)\n{\n    return HNum3(a * b.val, a*b.g, a*b.h);\n}\n//----------------------------------------------------------------\nHNum3 inv(in HNum3 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2, \n        2.0*a.val/b3*outerProduct(b.g,b.g) \n        - a.val/b2*b.h\n        + a.h/b1 \n        - outerProduct(b.g/b2, a.g)\n        - outerProduct(a.g/b2, b.g)\n    );\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in float b)\n{\n    return HNum3(a.val / b, a.g/b, a.h/b);\n}\n//--------------------------------\nHNum3 div(in float a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a / b.val, \n        -a*b.g/b2, \n        2.0*a/b3*outerProduct(b.g,b.g) - a/b2*b.h\n    );\n}\n//----------------------------------------------------------------\n/*\nHNum3 a_pow(in HNum3 a, in HNum3 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    float dda = b*(b-1.0)*pow(a.val,b-2.0); // second derivative f''(a(x))\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_pow(in float a, in HNum3 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n*/\n//--------------------------------\nHNum3 a_ipow(in HNum3 x, in int n)\n{\n    // based on https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    if (n < 0)\n    {   \n        x = div(1.0,x);\n        n = -n;\n    }\n    if (n == 0) \n    {\n        return constH3(1.0);\n    }\n    HNum3 y = constH3(1.0);\n    while (n > 1)\n    {\n        if (n % 2 == 0)\n        {   \n            x = mult(x,x);\n            \n        }\n        else\n        {    \n            y = mult(x, y);\n            x = mult(x, x);\n        }\n\n        n = n / 2;\n    }\n    \n    return mult(x, y);\n}\n//----------------------------------------------------------------\nHNum3 a_sqrt(in HNum3 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n    float dda = -0.25/pow(sqrt(a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\n/*\nHNum3 a_inversesqrt(in HNum3 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n    float dda = 0.75/pow(sqrt(a.val),5.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n*/\n//----------------------------------------------------------------\nHNum3 a_exp(in HNum3 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n    float dda = exp(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_exp2(in HNum3 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n    float dda = log(2.0)*log(2.0)*exp2(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log(in HNum3 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log2(in HNum3 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val * log(2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//----------------------------------------------------------------\nHNum3 neg(in HNum3 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nHNum3 a_abs(in HNum3 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//----------------------------------------------------------------\n/*\nHNum3 a_floor(in HNum3 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_ceil(in HNum3 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//----------------------------------------------------------------\nHNum3 a_min(in HNum3 a, in HNum3 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_max(in HNum3 a, in HNum3 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n*/\n//----------------------------------------------------------------\nHNum3 a_cos(in HNum3 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n    float dda = -cos(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sin(in HNum3 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n    float dda = -sin(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tan(in HNum3 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n    float dda = 2.0*tan(a.val)*(1.0 + pow(tan(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));       \n}\n//--------------------------------\n/*\nHNum3 a_acos(in HNum3 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asin(in HNum3 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n*/\n//--------------------------------\nHNum3 a_atan(in HNum3 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -2.0*a.val/pow(1.0 + a.val * a.val, 2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in HNum3 x)\n{\n    const float pi = 3.14159265;\n    \n    #if 0\n    // orginal version by sibaku \n    // tangent_half-angle_formula\n    // https://en.wikipedia.org/wiki/Atan2\n    const float epsi = 1E-6;\n    if(x.val > 0.0)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(y, add(n,x));     \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > epsi)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(sub(n,x),y);\n        return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= epsi)\n    {\n        return constH3(pi);\n    }\n    // return 0 for undefined\n    return constH3(0.0);\n    #else        \n    // version by ollj\n    // A compact expression with four overlapping half-planes\n    // https://en.wikipedia.org/wiki/Atan2#Definition_and_computation\n    if(x.val >0.) return a_atan(div(y,x));\n    if(y.val >0.) return  sub( constH3( pi*.5), a_atan(div(x,y)) );\n    if(0.>y.val ) return  sub( constH3(-pi*.5), a_atan(div(x,y)) );\n    if(0.>x.val ) return  add( pi   ,a_atan(div(y,x)));\n    return constH3(0.);\n    # endif\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in float x)\n{\n    return a_atan2(y,constH3(x));\n}\n//--------------------------------\nHNum3 a_atan2(in float y, in HNum3 x)\n{\n    return a_atan2(constH3(y),x);\n}\n//----------------------------------------------------------------\n/*\nHNum3 a_cosh(in HNum3 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n    float dda = cosh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sinh(in HNum3 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n    float dda = sinh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tanh(in HNum3 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n    float dda = -2.0*tanh(a.val)*(1.0 - pow(tanh(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acosh(in HNum3 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(-1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asinh(in HNum3 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atanh(in HNum3 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = 2.0*a.val/pow(1.0 - a.val * a.val,2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n*/\n//----------------------------------------------------------------\n/*\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in float a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n*/\n//----------------------------------------------------------------\nHNum3 a_length2(in HNum3 x, in HNum3 y)\n{\n  return add(mult(x, x), mult(y, y));\n}\n//--------------------------------\nHNum3 a_length2(in HNum3 x, in HNum3 y, in HNum3 z)\n{\n  return add(add(mult(x, x), mult(y, y)), mult(z, z));\n}\n//----------------------------------------------------------------\nHNum3 a_length(in HNum3 x, in HNum3 y)\n{\n  return a_sqrt(a_length2(x, y));\n}\n//--------------------------------\nHNum3 a_length(in HNum3 x, in HNum3 y, in HNum3 z)\n{\n  return a_sqrt(a_length2(x, y, z));\n}\n//----------------------------------------------------------------\n// Implementation prototypes\n//----------------------------------------------------------------\n#if __VERSION__<300\nmat3 outerProduct(in vec3 a, in vec3 b) {\n  return mat3(a * b[0], a * b[1], a * b[2]);\n}\n#endif\n\n//--------------------------------\n// complex Hessian Number in 3D-Space (added by cyperus)\n//--------------------------------\n// complex number operations in 3D-space :)\n\nstruct c_HNum3  {  // z = x + iy\n  HNum3 x; //real-part\n  HNum3 y; //complex-part\n};\n\n//--------------------------------\n\nc_HNum3 cadd(in c_HNum3 za, in c_HNum3 zb);\nc_HNum3 csub(in c_HNum3 za, in c_HNum3 zb);\nc_HNum3 cmul(in c_HNum3 za, in c_HNum3 zb);\nc_HNum3 cinv(in c_HNum3 z);\nc_HNum3 cdiv(in c_HNum3 za, in c_HNum3 zb);\nc_HNum3 cipow(in c_HNum3 z, in int n);\nc_HNum3 crot(in c_HNum3 z, in HNum3 a);\nc_HNum3 crpt(in c_HNum3 z, in HNum3 a, in int n, in HNum3 x0);\n\n//--------------------------------\n\nc_HNum3 cadd(in c_HNum3 za, in c_HNum3 zb) { // za + zb\n  return c_HNum3(add(za.x ,zb.x), add(za.y ,zb.y));\n}\n\nc_HNum3 csub(in c_HNum3 za, in c_HNum3 zb) {  // za - zb\n  return c_HNum3(sub(za.x ,zb.x), sub(za.y ,zb.y));\n}\n\nc_HNum3 cmul(in c_HNum3 za, in c_HNum3 zb) {  // za * zb\n  return c_HNum3(sub(mult(za.x ,zb.x), mult(za.y ,zb.y)),\n                add(mult(za.x ,zb.y), mult(za.y ,zb.x)));\n}\n\nc_HNum3 cinv(in c_HNum3 z) {  // 1/z\n  HNum3 denom = add(mult(z.x, z.x), mult(z.y, z.y));  \n  return c_HNum3(div(z.x, denom), div(neg(z.y), denom));\n}\n\nc_HNum3 cdiv(in c_HNum3 za, in c_HNum3 zb) {  // za/zb\n  return cmul(za,cinv(zb));\n}\n\nc_HNum3 cipow(in c_HNum3 z, in int n) { // z^n\n  c_HNum3 w = c_HNum3(constH3(1.), constH3(0.));\n  if ( n == 0) {\n    return w;}\n  if ( n < 0) {\n    z = cinv(z);\n    n = -n;}\n  for (int i = 0; i < n; i++) {\n    w = cmul(w,z);}\n  return w;\n}\n\nc_HNum3 crot(in c_HNum3 z, in HNum3 a) {  // z*e^(i*a)\n  return cmul(z, c_HNum3(a_cos(a), a_sin(a)));\n}\n\nc_HNum3 crpt(in c_HNum3 z, in HNum3 a, in int n, in HNum3 x0) { // (z*e^ia)^n-x0\n  return csub( cipow(crot(z, a), n), c_HNum3(neg(x0), constH3(0.)) );\n}\n//--------------------------------\n\nfloat frobenius(in mat3 m) {\n  return sqrt(dot(m[0], m[0]) + dot(m[1], m[1]) + dot(m[2], m[2]));\n}\n\n// Simple power iteration to find the eigenvalue with largest absolute value\nfloat powerNorm(in mat3 m) {\n  vec3 bk = vec3(1.);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  return length(m * bk);\n}\n#endif // HESSNUM_3_H_\n\n// -----------------------------------\n// https://en.wikipedia.org/wiki/adjugate_matrix\nmat3 adjugate_m3(in mat3 m) {\n    #if 0\n    return mat3(\n    // c0\n     m[1][1]*m[2][2]-m[2][1]*m[1][2],\n     m[2][0]*m[1][2]-m[1][0]*m[2][2],\n     m[1][0]*m[2][1]-m[2][0]*m[1][1],\n    // c1 \n     m[2][1]*m[0][2]-m[0][1]*m[2][2],\n     m[0][0]*m[2][2]-m[2][0]*m[0][2],\n     m[0][1]*m[2][0]-m[0][0]*m[2][1],\n    // c2 \n     m[0][1]*m[1][2]-m[1][1]*m[0][2],\n     m[1][0]*m[0][2]-m[0][0]*m[1][2],\n     m[0][0]*m[1][1]-m[1][0]*m[0][1] );\n    #endif\n    #if 1\n    return mat3(\n    // by iq https://www.shadertoy.com/view/3s33zj\n     cross(m[1].xyz, m[2].xyz), \n     cross(m[2].xyz, m[0].xyz), \n     cross(m[0].xyz, m[1].xyz) );\n    #endif \n}\n\n// -----------------------------------\n// https://en.wikipedia.org/wiki/Gaussian_curvature\nfloat gaussian_curvature(HNum3 fx) {\n  // numerator of gaussian curvature for implicit surfaces\n  #if 0\n  // calculation with determinante\n  mat4 G = mat4(fx.h);\n  G[3].xyz = fx.g;\n  G[0][3] = fx.g[0];\n  G[1][3] = fx.g[1];\n  G[2][3] = fx.g[2];\n\n  G[3][3] = 0.0;\n\n  float gl2 = dot(fx.g, fx.g);\n\n  return -determinant(G) / (gl2 * gl2);\n  #else\n  // calculation with adjugate\n  float gl2 = dot(fx.g, fx.g);\n  return  dot(fx.g, adjugate_m3(fx.h) * fx.g) / (gl2 * gl2);\n  #endif\n}\n\n//--------------------------------\n// https://en.wikipedia.org/wiki/Mean_curvature\nfloat mean_curvature(HNum3 fx) {\n  float gl2 = dot(fx.g, fx.g);\n  float gl3 = gl2 * sqrt(gl2);\n  return ( dot(fx.g, fx.h * fx.g) - gl2 \n           * (fx.h[0][0]+fx.h[1][1]+fx.h[2][2]) ) / (2. * gl3);\n}\n\n//--------------------------------\n// TEST:\nvec2 principal_curvature(HNum3 fx) {\n  float km = mean_curvature(fx);\n  float kg = gaussian_curvature(fx);\n  float k = sqrt(km*km-kg);\n  return vec2(km+k, km-k); \n}\n\n//--------------------------------\nfloat smoothpuls(float x,float b){\n    return smoothstep(abs(b),0.,abs(x));\n    }\n//--------------------------------\nvec2 crot(vec2 z,float a){\n    float si = sin(a), co = cos(a); // z*e^(j*a)\n    return mat2(co,-si,si,co)*z;\n}\n\n//--------------------------------\nvec2 isphere(in vec3 ro, in vec3 rd, in float r ) {\n  // sphere centered at the origin, with size rd\n  float b = dot(ro,rd);\n  float c = dot(ro,ro) - r*r;\n  float h = b*b - c;\n\n  if( h<0.0 ) return vec2(-1.0);  \n  h = sqrt( h );  \n  return -b + vec2(-h,h);\n}\n\n//--------------------------------\nconst float PI_2 = acos(0.);\n    \nconst vec3 \n     BLUE = vec3(0.0, 66.0, 157.0)/ 255.0,\n     RED = vec3(147.0, 0.0, 58.0)/ 255.0,\n     CAYEN = vec3( 66.,245.,242.)/ 255.0,\n     YELLOW = vec3(245.,242., 66.)/ 255.0,\n     WHITE = vec3(200.0, 200.0, 200.0) / 255.0;\n\n    \nvec3 hsv2rgb (float h, float s, float v )\n{\n    return mix(vec3(1.), 0.5*(1.+cos(4.*PI_2*(h + vec3(0,1,2)/3. ))), s)*v;\n}    \n\nvec3 colormapBRG(float k) {\n    // k in [-inf, 0., +inf] => [blue, red, green]\n    k = atan(k)/PI_2;    \n    return hsv2rgb(-k/3., 0., 1.);\n}\n\nvec3 colormap2(float k, vec3 c0, vec3 c1) {\n    // k in [-inf, 0., +inf] => [c0, black, c1]\n    vec3 col = (k<0.)? c0:c1;\n    col *= abs(atan(k)/PI_2);\n    return col;\n}\n\nvec3 colormap3(float k, vec3 c0, vec3 c1, vec3 c2) {\n    // k in [-inf, 0., +inf] => [c0, c1, c2]\n    k = atan(k)/PI_2;\n    vec3 col;\n    if (k < 0.0) {\n      col = mix(c0, c1, smoothstep(-1., 0., k));\n    } else {\n      col = mix(c1, c2, smoothstep(0., +1., k));}\n    return col;\n}\n\nvec3 colormapstep(int i, int i_max, vec3 c0, vec3 c1, bool EXP) {\n    int b = 10; //\n    float k_dist = 10.;\n    float r = float(i)/float(i_max);    \n    if (EXP) r = 1.-exp(-k_dist * pow(r,2.));\n    \n    return (i <= b)       ? c0       // no step \n         : (i <= i_max-b) ? vec3(r)  // gray\n         :                  c1;      // max steps  \n}\n//--------------------------------\n\n#define store(i,j) ( texelFetch(iChannel2, ivec2((i),(j)),0) )\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n#define keytoggle(key) ( texelFetch(iChannel3, ivec2((key),2),0).x != 0.0 )\n#define keycount(key) ( int(store(0,(key)).x) )\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = store(i,j);\n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}