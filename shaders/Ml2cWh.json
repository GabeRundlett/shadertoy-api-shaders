{
    "Shader": {
        "info": {
            "date": "1508428270",
            "description": "This is an attempt to simulate a simplified rendering pipeline (blending states,stencil,depth). This becomes useful when you want to try out more complex rendering strategies regarding depth, blending and stencil. More info at the beginning of the shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml2cWh",
            "likes": 3,
            "name": "gpu pipeline toy",
            "published": 3,
            "tags": [
                "3d",
                "pipeline"
            ],
            "usePreview": 0,
            "username": "Raxvan",
            "viewed": 686
        },
        "renderpass": [
            {
                "code": "\n//There are a ton of \"features\" missing such as: no backfaces, blending operations, functions, etc. Write in the comments if you\n//want me to add more.\n//This is an example of a simple technique using \"stencil buffer\".\n\n\n//------------------------------------------------------------------------------------------\n\n//#define DEBUG_SHOW_ALPHA\n//#define DEBUG_SHOW_STENCIL_VALUE 0\n//#define DEBUG_SHOW_DEPTH_RANGE vec2(10.0,150.0);\n\n//Z is up\n#define NEAR 1.0 \n#define FAR 10000.0\n\n//depth stuff\n#define DEPTH_TEST_DISABLED 0 //equivalent to glDisable(GL_DEPTH_TEST) \n#define DEPTH_TEST_ENABLED_NO_WRITE 1\n#define DEPTH_TEST_ENABLED 2\n\n#define DEPTH_FUNC_LESS  0\n#define DEPTH_FUNC_EQUAL 1\n\n//blend stuff\n#define BLEND_FUNC_OFF 0\n#define BLEND_FUNC_ADD 1\n\n#define BLEND_ONE 0\n#define BLEND_SRC_ALPHA 1\n#define BLEND_ONE_MINUS_SRC_ALPHA 2\n\n//stencil stuff\n#define STENCIL_FUNC_NONE 0 // same as glDisable(GL_STENCIL_TEST)\n#define STENCIL_FUNC_NEVER 1\n#define STENCIL_FUNC_ALWAYS 2\n#define STENCIL_FUNC_LESS 3\n#define STENCIL_FUNC_EQUAL 4\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml\n\n#define STENCIL_OP_KEEP 0\n#define STENCIL_OP_ZERO 1\n#define STENCIL_OP_REPLACE 2\n#define STENCIL_OP_INCR 3\n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glStencilOp.xml\n\n//------------------------------------------------------------------------------------------\n\nstruct pipeline_state\n{\n    vec4 color_mask;\n    int depth_test;\n    int depth_func;\n    \n    int blend_func;\n    int src_blend;\n    int dst_blend;\n    \n\tint stencil_ref_value;\n    int stencil_func;\n    int sfunc_sfail; //stencil fail\n    int sfunc_dpfail; //depth fail\n    int sfunc_dppass; //depth pass\n};\n    \nstruct framebuffer\n{\n    float   valid; //0 or 1\n    vec4    color; //output color\n    float   depth; //depth buffer\n    int     stencil; //stencil buffer\n};\n\nstruct vs_output_data\n{\n    vec3    pos_ws;\n    vec3    normal_ws;\n    float   depth;\n    float   valid; //0 or 1  \n};\n\nframebuffer invalid_framebuffer()\n{\n    framebuffer r;\n    r.valid = 0.0;\n    r.color = vec4(0.0);\n    r.depth = 0.0;\n    r.stencil = 0;\n    \n    return r;\n}\n\nvec4 flush(framebuffer f,vec2 uv)\n{\n#ifdef DEBUG_SHOW_ALPHA\n    if(f.valid > 0.5)\n    {\n        return f.color.aaaa;\n    }\n#elif defined(DEBUG_SHOW_STENCIL_VALUE)\n    if(f.valid > 0.5)\n    {\n        if(f.stencil == DEBUG_SHOW_STENCIL_VALUE)\n            return vec4(1.0);\n        return vec4(0.0);\n    }\n#elif defined(DEBUG_SHOW_DEPTH_RANGE)\n    if(f.valid > 0.5)\n    {\n        vec2 range = DEBUG_SHOW_DEPTH_RANGE;\n        return vec4(smoothstep(range.x,range.y,f.depth));\n    }\n#else\n    if(f.valid > 0.5)\n    {\n        return f.color;\n    }\n#endif\n    return vec4(sin(texture(iChannel0,uv).r * iTime * 1000.0) * 0.5 + 0.5);\n}\n\nvec4 evaluate_blend_operation(int blend_state,vec4 color, vec4 src, vec4 dst)\n{\n    if(blend_state == BLEND_ONE)\n        return color;\n    else if(blend_state == BLEND_SRC_ALPHA)\n        return color * src.a;\n    else if(blend_state == BLEND_ONE_MINUS_SRC_ALPHA)\n        return color * (1.0 - src.a);\n        \n    return vec4(-1.0);//invalid state\n}\n\nint evaluate_stencil_operation(int s_op,int fb_stencil, int ref)\n{\n    if(s_op == STENCIL_OP_KEEP)\n    {\n\t\treturn fb_stencil;\n    }\n    else if(s_op == STENCIL_OP_ZERO)\n    {\n\t\treturn 0;\n    }\n    else if(s_op == STENCIL_OP_REPLACE)\n    {\n\t\treturn ref;\n    }\n    else if(s_op == STENCIL_OP_INCR)\n    {\n        return fb_stencil + 1;\n    }\n    \n    return -1;//invalid state\n}\nframebuffer drawcall(framebuffer f, pipeline_state state, vs_output_data vs_output, vec4 fs_output)\n{\n    //pipeline is in invalid state or object does not draw in this \"fragment\"\n    if(vs_output.valid < 0.5 || f.valid < 0.5)\n        return f;\n    \n    framebuffer final = f;\n\n    //stencil test\n    if(state.stencil_func != STENCIL_FUNC_NONE)\n    {\n        final.stencil = evaluate_stencil_operation(state.sfunc_sfail,f.stencil,state.stencil_ref_value);\n        \n        if(state.stencil_func == STENCIL_FUNC_NEVER)\n        {\n            return final;\n        }\n        else if(state.stencil_func == STENCIL_FUNC_LESS)\n        {\n            if(!(state.stencil_ref_value < f.stencil))\n            \treturn final;\n        }\n        else if(state.stencil_func == STENCIL_FUNC_EQUAL)\n        {\n            if(!(state.stencil_ref_value == f.stencil))\n                return final;\n        }\n        else if(state.stencil_func == STENCIL_FUNC_ALWAYS)\n        {\n            //no stencil fail\n        }\n        else\n        {\n            final.valid = 0.0;\n        }\n        final.stencil = f.stencil; //passed stencil, revert to value from framebuffer\n    }\n    \n    \n    //depth test\n    if (state.depth_test != DEPTH_TEST_DISABLED)\n    {\n\n        //actual depth testing\n        if(state.stencil_func != STENCIL_FUNC_NONE)\n        {\n            //in case depth fails, write stencil value\n        \tfinal.stencil = evaluate_stencil_operation(state.sfunc_dpfail,f.stencil,state.stencil_ref_value);\n        }\n        \n        if(state.depth_func == DEPTH_FUNC_LESS)\n        {\n            if(vs_output.depth > f.depth)\n                return final;//depth test failed, return original framebuffer\n        }\n        else if(state.depth_func == DEPTH_FUNC_EQUAL)\n        {\n            if(abs(vs_output.depth - f.depth) > 0.001)\n                return final;//depth test failed, return original framebuffer\n        }\n        else\n        {\n            final.valid = 0.0;//invalid state\n        }\n        \n        //depth test passed, write stencil value\n        if(state.stencil_func != STENCIL_FUNC_NONE)\n        \tfinal.stencil = evaluate_stencil_operation(state.sfunc_dppass,f.stencil,state.stencil_ref_value);\n        \n        //write depth \n        if(state.depth_test == DEPTH_TEST_ENABLED_NO_WRITE)\n        {\n            //no need wo rite it again\n            //final.depth = f.depth;\n        }\n        else if(state.depth_test == DEPTH_TEST_ENABLED)\n        {\n            final.depth = vs_output.depth;\n        }\n        else\n        {\n            final.valid = 0.0;//invalid state\n        }\n    }\n    \n    //move on to blending\n    if(state.blend_func == BLEND_FUNC_OFF)\n    {\n        final.color = mix(f.color,fs_output,state.color_mask);\n    }\n    else if(state.blend_func == BLEND_FUNC_ADD)\n    {\n        vec4 src_base = evaluate_blend_operation(state.src_blend,fs_output,fs_output,f.color);\n        vec4 dst_base = evaluate_blend_operation(state.dst_blend,f.color,fs_output,f.color);\n        \n        final.color = mix(f.color,dst_base + src_base,state.color_mask);\n    }\n    else\n    {\n         final.valid = 0.0;//invalid state\n    }\n        \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n\nstruct ray\n{\n    vec3 point;\n    vec3 dir;\n};\n    \nray screen_space_to_world_space(vec3 camera_position,vec3 camera_target,vec2 uv)\n{\n    vec3 camera_dir = normalize(camera_target - camera_position);\n    vec3 view_right = normalize(cross(vec3(0.0,0.0,1.0),camera_dir));\n    vec3 view_up = cross(camera_dir,view_right);\n    \n    ray r;\n    r.point = camera_position;\n    r.dir = normalize(camera_dir * NEAR + view_right * uv.x + view_up * uv.y);\n    \n    return r;\n}\nvec2 intersect_box(vec3 ro, vec3 rd,vec3 _min,vec3 _max)\n{\n    vec3 start = (_min - ro) / rd;\n    vec3 end = (_max - ro) / rd;\n    \n    vec3 a = min(start,end);\n    vec3 b = max(start,end);\n    \n    return vec2(\n            max(a.x,max(a.y,a.z)),\n            min(b.x,min(b.y,b.z))\n        );\n}\nvec3 box_normal_from_point(vec3 point,vec3 box_extents)\n{\n    vec3 normal = vec3(0.0);\n    float m = FAR;\n    float d;\n\n    d = abs(box_extents.x - abs(point.x));\n    if (d < m)\n    {\n        m = d;\n        normal = vec3(1.0,0.0,0.0) * sign(point.x);    // Cardinal axis for X\n    }\n\n    d = abs(box_extents.y - abs(point.y));\n    if (d < m)\n    {\n        m = d;\n        normal = vec3(0.0,1.0,0.0) * sign(point.y);    // Cardinal axis for Y\n    }\n\n    d = abs(box_extents.z - abs(point.z));\n    if (d < m)\n    {\n        m = d;\n        normal = vec3(0.0,0.0,1.0) * sign(point.z);    // Cardinal axis for Z\n    }\n\n    return normal;\n}\n\nvs_output_data      vs_box(ray r,vec3 _min,vec3 _max)\n{\n    vs_output_data vs_out;\n    vs_out.valid = 0.0;\n    vs_out.depth = FAR;\n    vs_out.pos_ws = vec3(0.0);\n    vs_out.normal_ws = vec3(0.0);\n    \n    vec2 d = intersect_box(r.point,r.dir,_min,_max);\n    if(d.x < d.y && d.x > 0.0) //should do more checking for near/far\n    {\n        vec3 center = (_max + _min) / 2.0;\n        vec3 pos_ws = r.point + r.dir * d.x;\n        vec3 normal_ws = box_normal_from_point(pos_ws - center,_max - center);\n        vs_out.valid = 1.0;\n        vs_out.depth = d.x;\n        vs_out.pos_ws = pos_ws;\n        vs_out.normal_ws = normal_ws;\n    }\n    \n    return vs_out;\n}\n\nvec4 fs_default(ray r, vs_output_data obj,vec4 color)\n{\n    float t = iTime * 0.4 + 0.3;\n    vec3 light_pos = vec3(cos(t),sin(t),5.0) * vec3(150.0,150.0,150.0);\n    vec3 light_dir = normalize(light_pos - obj.pos_ws);\n    \n    float df = max(dot(light_dir,obj.normal_ws),0.0);\n    \n    vec4 fc = color * 0.3 + color * df * 0.7;\n    \n    float l = -obj.pos_ws.z / 130.0;\n    float c = length(r.point - obj.pos_ws);\n    c = c / 500.0;\n        \n    l = clamp(max(l,c),0.0,1.0);\n    fc.rgb = mix(fc.rgb,vec3(0.6078431372549019,0.8,0.6980392156862745),l);\n    \n    return vec4(fc.rgb,color.a);\n}\nvec4 fs_color(vec4 color)\n{\n    return color;\n}\n\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //init stuff\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    //camera setup\n    float dt = iTime * 0.4;\n    float sz = 20.0;\n    ray r = screen_space_to_world_space(vec3(cos(dt) * sz,sin(dt) * sz,18.0),vec3(0.0),uv);\n    \n    \n    //setup context :P\n    framebuffer fb = invalid_framebuffer();\n\n    vs_output_data obj;\n    vs_output_data ybox;\n    pipeline_state state;\n    \n    //setup default states\n    state.color_mask = vec4(1.0);\n    state.depth_test = DEPTH_TEST_ENABLED;\n    state.depth_func = DEPTH_FUNC_LESS;\n\n    state.blend_func = BLEND_FUNC_OFF;\n    state.src_blend = BLEND_ONE;\n    state.dst_blend = BLEND_ONE;\n    \n    state.stencil_ref_value = 0;\n    state.stencil_func = STENCIL_FUNC_NONE;\n    state.sfunc_sfail = STENCIL_OP_KEEP;\n    state.sfunc_dpfail = STENCIL_OP_KEEP;\n    state.sfunc_dppass = STENCIL_OP_KEEP;\n    \n\n    //clear buffer\n    fb.valid = 1.0;\n    fb.color = vec4(0.6078431372549019,0.8,0.6980392156862745,1.0);\n    fb.depth = FAR;\n    fb.stencil = 0;\n    \n    //background stuff\n    obj = vs_box(r,vec3(-7.0,-10.0,-5.0),vec3(7.0,10.0,0.0));\n    fb = drawcall(fb,state,obj, fs_default(r,obj,vec4(1.0,0.466,0.39,1.0) * 1.2));\n    \n    obj = vs_box(r,vec3(-10.0,-7.0,-3.0),vec3(10.0,7.0,2.0));\n    fb = drawcall(fb,state,obj, fs_default(r,obj,vec4(1.0,0.466,0.392,1.0) * 1.0));\n    \n    obj = vs_box(r,vec3(-5.0,-9.0,-2.0),vec3(9.0,8.0,2.3));\n    fb = drawcall(fb,state,obj, fs_default(r,obj,vec4(1.0,0.466,0.392,1.0) * 0.8));\n    \n    obj = vs_box(r,vec3(10.0,-3000.0,-200.0),vec3(30.0,3000.0,-50.0));\n    fb = drawcall(fb,state,obj, fs_default(r,obj,vec4(1.0,0.466,0.39,1.0) * 0.8));\n    \n    obj = vs_box(r,vec3(-30.0,-3000.0,-200.0),vec3(-10.0,3000.0,-50.0));\n    fb = drawcall(fb,state,obj, fs_default(r,obj,vec4(1.0,0.466,0.392,1.0) * 0.8));\n    \n    obj = vs_box(r,vec3(-500.0,-3000.0,-200.0),vec3(-150.0,3000.0,-30.0));\n    fb = drawcall(fb,state,obj, fs_default(r,obj,vec4(1.0,0.466,0.392,1.0) * 0.8));\n\n    //center box\n    obj = vs_box(r,vec3(-1.0,-1.0,-350.0),vec3(1.0,1.0,14.0));\n    state.stencil_ref_value = 1;\n    state.stencil_func = STENCIL_FUNC_ALWAYS;\n    state.sfunc_dppass = STENCIL_OP_REPLACE;\n    fb = drawcall(fb,state,obj, fs_default(r,obj,vec4(0.0823,0.56078,0.6,1.0) * 1.5));\n    \n    //draw yello box\n    ybox = vs_box(r,vec3(3.0,-2.0,-100.0),vec3(5.0,2.0,7.0));\n    state.stencil_func = STENCIL_FUNC_ALWAYS;\n    state.sfunc_dpfail = STENCIL_OP_INCR;\n    fb = drawcall(fb,state,ybox, fs_default(r,ybox,vec4(0.937,0.7882,0.0862,1.0) * 1.4));\n    \n\t//draw yellow box again but make it \"transparent\" trough center box only\n    \n    state.depth_test = DEPTH_TEST_DISABLED;\n    \n    state.stencil_ref_value = 2;\n    state.stencil_func = STENCIL_FUNC_EQUAL;\n    \n    state.blend_func = BLEND_FUNC_ADD;\n    state.src_blend = BLEND_SRC_ALPHA;\n    state.dst_blend = BLEND_ONE_MINUS_SRC_ALPHA;\n    \n    fb = drawcall(fb,state,ybox, fs_default(r,ybox,vec4(0.737,0.9882,0.08627,1.0)));\n  \n    \n    fragColor = flush(fb,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}