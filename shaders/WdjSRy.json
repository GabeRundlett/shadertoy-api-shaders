{
    "Shader": {
        "info": {
            "date": "1554225413",
            "description": "A bit better than my first attempt, which I never published. I wish I could use a perlin-noise texture to create the landscape, but one has to live with what is provided. Still need to figure out waves, sun and... clouds... volumetric clouds... *sigh*",
            "flags": 64,
            "hasliked": 0,
            "id": "WdjSRy",
            "likes": 3,
            "name": "Terrain attempt, second try",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "terrain",
                "soundcloud"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 761
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"Flight of the navigator\" ;) - A second attempt at creating a flight over a\n// procedurally generated landscape\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 48;\nconst float EPSILON = .001;\nconst float STEP_BIAS = .65;\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c, s, -s, c);\n}\n\n// hash() & noise3d() are from an example by iq or shane... I can't remember \nfloat hash (float f)\n{\n\treturn fract (sin (f) * 45785.5453);\n}\n\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    \n    v = v * v * (3. - 2. * v);\n\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n\n    float result = mix (mix (mix (a, b, v.x),\n                             mix (c, d, v.x),\n                             v.y),\n                        mix (mix (e, f, v.x),\n                             mix (g, h, v.x),\n                             v.y),\n                        v.z);\n\n    return result;\n}\n\n// cheap-ass material-system with call-by-ref id & pout\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n\tvec3 tp = p;\n\ttp.z -= 6.*iTime;\n\tfloat lf = 2.*noise3d (.25*tp.xzy);\n    tp.xz *= r2d (34.);\n\tfloat mf = 1.25*noise3d (.5*tp.xzy);\n    tp.xz *= r2d (57.);\n    float hf = .5*noise3d (2.*tp.xzy);\n\tfloat g = tp.y + 1.5 + lf + mf + hf;\n\tfloat w = tp.y + 3.5;\n    pout = tp;\n\tvec3 bp = p;\n\tbp.x += 2.*cos (iTime)*sin(2.*iTime);\n    bp.y += .75*cos (.75*iTime);\n    float r = .5 + .2*(cos(5.*iTime - 7.*bp.z));\n\tfloat b = length (bp) - r;\n\tfloat d = min (b, min (g, w));\n\tif (d == g) id = 1;\n\tif (d == w) id = 2;\n\tif (d == b) id = 3;\n\treturn d;\n}\n\nfloat march (vec3 ro, vec3 rd, float tmax, inout int id, inout int iters, inout vec3 pout) {\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i < MAX_ITER; ++i) {\n\t\titers = i;\n\t\tvec3 p = ro + d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < EPSILON*(1. + .125*t) || d > tmax) break;\n\t\td += t*STEP_BIAS;\n\t}\n\treturn d > tmax ? tmax : d;\n}\n\nvec3 norm (vec3 p) {\n\tint foo;\n    vec3 bar;\n\tfloat d = map (p, foo, bar);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p + e.xyy, foo, bar),\n                            map (p + e.yxy, foo, bar),\n                            map (p + e.yyx, foo, bar)) - d);\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 ldir, float ldist) {\n\tfloat tmax = 20.;\n\tint foo;\n\tint bar;\n    vec3 bla;\n\tfloat d2w = march (p + .01*n, ldir, tmax, foo, bar, bla);\n\treturn ldist < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, int iters, float intensity) {\n\tfloat dist = .0;\n\tint foo;\n    vec3 bla;\n\tfloat ao = .0;\n\tfor (int i = 1; i <= iters; ++i) {\n\t\tdist = float (i)*stepsize;\n\t\tao += max (.0, (dist - map(p + dist*n, foo, bla))/dist);\n\t}\n\treturn 1. - ao*intensity;\n}\n\n// id 1: terrain\n// id 2: water\n// id 3: sphere/'spaceship'\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 p, vec3 n, int id, vec3 pout) {\n\tvec3 amb = vec3 (.05);\n\tvec3 lp = vec3 (-1., 2., 2.);\n\tvec3 ldir = normalize (lp - p);\n\tfloat li = 3.;\n\tvec3 lc = vec3 (.9, .8, .7);\n\tvec3 mat = vec3 (.2);\n\tif (id == 1) mat = texture (iChannel0, pout.xz).rgb+vec3 (.05, .15, .1);\n\tif (id == 2) mat = vec3 (.0, .0, .9);\n\tif (id == 3) mat = vec3 (.2, .1, .0);\n\tfloat ldist = distance (lp, p);\n\tfloat s = shadow (p, n, ldir, ldist);\n\tfloat att = 44. / (ldist*ldist);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\tfloat shiny = 100.;\n\tif (id == 1) shiny = 10.;\n\tif (id == 2) shiny = 100.;\n\tif (id == 3) shiny = 50.;\n\tfloat sp = pow (max (.0, dot (n, h)), shiny);\n\tfloat ao = 1.;//ao (p, n, .02, 8, .2); // ao has no visual impact currently\n\treturn ao*att*s*(amb + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 background (vec2 uv) {\n\tfloat m = smoothstep (.0, 1.125, clamp (uv.y, .0, 1.));\n\treturn 5.*mix (vec3 (.9, .85, .5), vec3 (.2, .1, .9), m);\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f = normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross(wu, f));\n\tvec3 u = normalize (cross(f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvRaw = uv;\n\tuv = uv*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .35*length(uv);\n\n    float heightOffset = +.4*cos(iTime);\n\tvec3 ro = vec3 (1., 2. + heightOffset, 7.);\n\tvec3 aim = vec3 (.0, 1.5 + heightOffset, .0);\n\tfloat zoom = 2.;\n\tvec3 rd = cam (uv, ro, aim, zoom);\n\trd.xy *= r2d (15.*cos (iTime));\n\n\tfloat tmax = 90.;\n\tint id = 0;\n\tint iters = 0;\n    vec3 pout = vec3 (.0);\n\tfloat d = march (ro, rd, tmax, id, iters, pout);\n\tfloat d2 = d;\n\tvec3 col = vec3 (.0);\n\tfloat fog = 1. / (1. + d*d*.025);\n\n\tif (d == tmax) {\n\t\tuv *= r2d (-15.*cos (iTime));\n\t\tcol = 10.*background (uv);\n\t} else {\n\t\tvec3 p = ro + d*rd;\n\t\tvec3 n = norm (p);\n\t\tcol = shade (ro, rd, d, p, n, id, pout);\n\t\tif (id == 2 || id == 3) {\n\t\t\tro = p + .01*n;\n\t\t\trd = normalize (reflect (rd, n));\n\t\t\td = march (ro, rd, tmax, id, iters, pout);\n\t\t\tp = ro + d*rd;\n\t\t\tn = norm (p);\n\t\t\tcol += shade (ro, rd, d, p, n, id, pout);\n\t\t}\n\t}\n\n\tcol *= fog; // fog\n    col = mix (col, 1.5*vec3 (.95, .9, .8), pow (1. - 1. / d2, 130.)); // horizon-mist\n\tcol = col / (1. + col); // tone-mapping\n\tcol *= 1. - .5*length (uvRaw*2. - 1.); // vignette\n    col = pow (col, vec3 (1./2.2)); // gamma-correction\n\n\tfragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 18259,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/brenticus/ambient-house"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}