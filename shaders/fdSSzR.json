{
    "Shader": {
        "info": {
            "date": "1619503875",
            "description": "This fractal forms a mosaic pattern.",
            "flags": 8,
            "hasliked": 0,
            "id": "fdSSzR",
            "likes": 2,
            "name": "Fractal mosaic",
            "published": 3,
            "tags": [
                "fractal",
                "spiral",
                "mosaic"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "#define ITERS 9\nconst float scale = 2.7;\nconst float scale1 =-1.175;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/15.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy*8./15.;\n    for(int c=0;c<ITERS;c++){\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            //uv += uv1/s1;\n            //uv *= -1.;\n            uv = fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale+uv.x/scale1)/(scale))))/scale1;\n            \n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n            //uv = uv1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float fmod(float a, float b){\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n#define fmod0(x,y) mod(floor(x)+1.5*floor(mod(x,y/2.)),y)\n#define fmod1(x,y) floor(mod(floor(x+floor((x)/y)/y),y))\n#define fmod2(x,y) mod(floor(x+floor(x)*y)/y,y)\n#define fmod3(x,y) mod(floor(x)*floor(x)+floor(x)*floor((x)/y),y)\n#define fmod4(x,y) mod(floor(x-floor((x)/y)/y),y)\n#define sqmod(x,y) floor(mod(floor(1.+x/2.)*floor(1.+x*2.),y))\n\nvec2 mainSound(int samp, float t){\n  t /= 1.5;\n  \n  float s1 =\n      8.;\n  //t = t + floor(t/s1+floor(t/2.));\n\n  float\n  m1 =\n      fmod(t,s1)\n\n  ,\n  z1 =\n      (1.+fmod(t/s1+floor(t/2.),2.))\n\n  ;\n\n  t /=\n      1.+fmod(floor(t*s1+floor(t*2.))*floor(t/s1+floor(t/2.)+z1),2.)\n     \n  ;\n  float m3 =\n      fmod((t*8.+floor(t*2.))/(m1+.5),s1*z1)\n\n  ;\n  \n  t *=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n  ;\n      \n      \n  float a= (1.-sqrt(fract(t*s1)))*.2,\n\n  nb = pow(2.,(m3+z1)/5.+7.);\n\n  return vec2(fract(t*nb*.998)\n   ,fract(t*nb))*a;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}