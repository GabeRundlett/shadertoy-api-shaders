{
    "Shader": {
        "info": {
            "date": "1540385520",
            "description": "A tri-scale Truchet pattern, constructed with non-overlapping tiles.",
            "flags": 0,
            "hasliked": 0,
            "id": "XttBW7",
            "likes": 39,
            "name": "Tri Scale Truchet",
            "published": 3,
            "tags": [
                "truchet",
                "pattern",
                "multiscale",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1344
        },
        "renderpass": [
            {
                "code": "/*\n\t\n\tTri Scale Truchet\n\t-----------------\n\n\tThis is just a demonstration to show that it's possible to produce a\n\tmultiscale Truchet pattern with non-overlapping tiles. The reason \n\tthat is of interest is that it's faster and can be more easily \n\tadapted to a 3D situation. By the way, I'll put one of those together\n\tpretty soon.\n\n\tThis was a pretty easy example to understand... before I kind of went \n    overboard and filled it with defines and esoteric aesthetic code.\n\n\tThankfully, I quickly put together a minimal dual level Truchet example\n\tto accompany it, which is much easier to digest -- The link is below,\n    for anyone interested.\n\n    \n    // Far less code, and much easier to understand.\n\tMinimal Dual-Level Truchet - Shane\n    https://www.shadertoy.com/view/ltcfz2\n\n\t// More elaborate quadtree example.\n\tQuadtree Truchet - Shane\n\thttps://www.shadertoy.com/view/4t3BW4\n\n\t// Abje always has an interesting way of coding things. :)\n\tblack and white truchet quadtree - abje\n\thttps://www.shadertoy.com/view/MtcBDM\n\n\n*/\n\n\n// Display the background grid lines.\n#define SHOW_GRID\n\n// Three levels or two. Comment it out for two.\n#define TRI_LEVEL\n\n// Various curve shapes, for anyone curious.\n// Circle: 0, Octagon: 1, Dodecahedron: 2, Hexadecagon: 3\n#define SHAPE 0\n\n// Just the arcs.\n//#define ARCS_ONLY\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p){ \n\n    // Faster, but doesn't disperse things quite as nicely.\n    return fract(vec2(262144, 32768)*sin(dot(p, vec2(57, 27))));\n    \n}\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values, but that's not an issue here.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 27, 57, 84) + dot(i, vec2(27, 57)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// Distance formula with various shape metrics.\n// See the \"SHAPE\" define above.\nfloat dist(vec2 p){\n    \n    #if SHAPE == 0\n    // Standard circular shaped curves.\n    return length(p);\n    #else\n        p = abs(p);\n        #if SHAPE == 1\n        \t// Octagon.\n        \treturn max(max(p.x, p.y), (p.x + p.y)*.7071);\n        #elif SHAPE == 2\n        \t// Dodecahedron.\n        \tvec2 p2 = p*.8660254 + p.yx*.5;\n        \treturn max(max(p2.x, p2.y), max(p.x, p.y));\n        #else\n        \t// Hexadecagon (regular, 16 sideds) -- There'd be a better formula for this.\n        \tvec2 p2 = r2(3.14159/8.)*p;\n        \tfloat c = max(max(p2.x, p2.y), (p2.x + p2.y)*.7071);\n        \treturn max(c, max(max(p.x, p.y), (p.x + p.y)*.7071));\n        #endif\n    #endif\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Resolution restriction to avoid a blurry, bloated looking image in fullscreen,\n    // This doesn't account for varying PPI, so if you went fullscreen on a high resolution\n    // cell phone, you'd want a higher restriction number. Generally speaking, it's \n    // impossible to make a pixel-precise image look even roughly the same on all systems.\n    // By the way, this was coded on a 17 inch laptop with a 1920 x 1080 resolution on the\n    // 800 x 450 canvas.\n    float iRy = min(iResolution.y, 800.); \n    \n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRy;\n    \n    // Scaling and translation.\n    vec2 oP = uv*4. + vec2(.5, iTime/2.);\n    \n    // Distance file values.\n    vec4 d = vec4(1e5);\n    \n    // Initial cell dimension.\n    float dim = 1.;\n    \n    // Random entries -- One for each layer. The X values represent the chance that\n    // a tile for that particular layer will be rendered. For instance, the large\n    // tile will have a 35% chance, the middle tiles, 70%, and the remaining smaller\n    // tiles will have a 100% chance. I.e., they'll fill in the rest of the squares.\n    \n    vec2 rndTh[3] = vec2[3]( vec2(.35, .5), vec2(.7, .5), vec2(1, .5));\n    \n    // Set the second level random X value to \"1.\" to ensure that the loop breaks on \n    // the second iteration... which is a long way to say, \"Two levels only.\" :)\n    #ifndef TRI_LEVEL\n    rndTh[0].x = .5; rndTh[1].x = 1.;\n    #endif\n    \n    \n    // Grid line width, and a global diagonal-side variable.\n    const float lwg = .015;\n    float side = 1e5;\n    \n    // Random variable.\n    vec2 rnd = vec2(0);\n    \n    \n    for(int k=0; k<3; k++){\n    \t\n        // Base cell ID.\n\t\tvec2 ip = floor(oP*dim);\n        \n        // Unique random ID for the cell.\n        rnd = hash22(ip);\n\n        \n\t\t// If the random cell ID at this particular scale is below a certain threshold, \n        // render the tile.         \n        if(rnd.x<rndTh[k].x){\n            \n            // Tile construction: By the way, the tile designs you use are limited by your imagination. \n        \t// I chose the ones that seemed most logical at the time -- Arcs and grid vertice circles.\n      \n            // Local cell coordinate.\n            vec2 p = oP - (ip + .5)/dim; // Equivalent to: mod(oP, 1./dim) - .5/dim;\n            \n            // Reusing \"rnd\" to calculate a new random number. Not absolutely necessary,\n            // but I wanted to mix things up a bit more.\n            rnd = fract(rnd*27.63 + float(k*57 + 1));\n           \n            // Grid lines.\n \t        d.y = abs(max(abs(p.x), abs(p.y)) - .5/dim) - lwg/2.;\n\n            \n            // Use the unique random cell number to flip half the tiles vertically, which,\n            // in this case, has the same effect as rotating by 90 degrees.\n            p.y *= rnd.y<.5? 1. : -1.;\n           \n            \n            // Arc width: Arranged to be one third of the cell side length. This is half that\n            // length, but it gets doubled below.\n            float aw = .5/3./dim;\n\n            // Tile rendering: The arcs, circles, etc. I made the tiles up as I went along,\n            // but it's just a positioning of arcs and circles, so I'm hoping it's pretty \n            // straight forward. \n            float c1 = abs(dist(p - vec2(.5)/dim) - .5/dim) - aw;\n            \n            // Arcs only, or a mixture of arcs and circles.\n            #ifdef ARCS_ONLY\n            float c2 = abs(dist(p - vec2(-.5)/dim) - .5/dim) - aw;\n            #else\n            float c2;\n            if(fract(rnd.y*57.53 +.47)<.35) {\n                c2 = dist(p - vec2(-.5, 0)/dim) - aw;\n                c2 = min(c2, dist(p - vec2(0, -.5)/dim) - aw);\n            }\n            else c2 = abs(dist(p - vec2(-.5)/dim) - .5/dim) - aw;\n            #endif\n            \n            // Combining the arc and\\or circle elements.\n            d.x = min(c1, c2);\n            \n            // Determining which side of the diagonal the blue neon tri-level lines are on.\n            // That way, you can blink them individually.\n            side = c1>c2? 0. : 1.57*(rnd.y*.5 + 1.);\n            \n            \n            // Negate the arc distance field values on the second tile.\n            d.x *= k==1? -1. : 1.;\n            \n             \n            // Four mid border circles. There's some 90 degree rotation and repeat\n            // trickery hidden in amongst this. If you're not familiar with it, it's\n            // not that hard, and gets easier with practice.\n            vec2 p2 = abs(vec2(p.y - p.x, p.x + p.y)*.7071) - .5*.7071/dim;\n            p2 = vec2(p2.y - p2.x, p2.x + p2.y)*.7071;\n            float c3 = dist(p2) - aw/2.; \n             \n            \n            \n            // Placing circles at the four corner grid vertices. If you're only rendering\n            // one level (rndTh[0].x=1.), you won't need them... unless you like them, I guess. :)\n            p = abs(p) - .5/dim;\n            if(k<2 && rndTh[0].x<.99) d.x = min(d.x, (dist(p) - aw));\n            \n            // Depending upon which tile scale we're rendering at, draw some circles,\n            // or cut some holes. If you look at the individual tiles in the example,\n            // you can see why.\n            if(rndTh[1].x<.99){\n                \n                // Cut out some mid border holes on the first iteration. \n                if(k==0) d.x = max(d.x, -c3); \n                \n                // On the middle iteration, cut out vertice corner holes.\n                // On the other iterations, add smaller vertice holes.\n                // I made this up as I went along, so there's probably a\n                // more elegant way to go about it.\n                if(k==1) d.x = max(d.x, -(dist(p) - aw));\n            \telse d.x = max(d.x, -(dist(p) - aw/2.));\n                \n            \t\n            }\n            \n            \n            // Increasing the overall width of the pattern slightly.\n            d.x -= .01;\n\n            // Since we don't need to worry about neighbors\n            break;\n\n        }\n        \n        // Subdividing. I.e., decrease the cell size by doubling the frequency.\n        dim *= 2.;\n        \n    }\n    \n   \n    \n    // RENDERING.\n    //\n    // More complicated than you need to make it. Most of the following lines were \n    // coded on the fly for decorative purposes.\n    \n    // Background.\n    vec3 bg = vec3(.1);//*vec3(1, .9, .95);\n    //float pat =  clamp(sin((oP.x - oP.y)*6.283*iResolution.y/22.5) + .75, 0., 1.);\n    //bg *= (pat*.35 + .65);\n    float ns = fbm(oP*32.); // Noise.\n    bg *= ns*.5 + .5; // Apply some noise to the background.\n    \n    // Scene color. Initiated to the background.\n    vec3 col = bg;\n\n    // Falloff variable.\n    float fo;\n  \n    // Render the grid lines.\n    fo = 4./iRy;\n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.y - .01))*.5); // Shadow.\n    col = mix(col, vec3(1), (1. - smoothstep(0., fo, d.y))*.15); // Overlay.\n    #endif\n\n\n    // Pattern falloff, overlay color, shade and electronic looking overlay.\n    fo = 10./iRy/sqrt(dim);\n    // Distance field color: I couldn't seem to make vibrant color work, so fell\n    // back go greyscale with a dash of color. It's a cliche, but it often works. :)\n    vec3 pCol = vec3(.3, .25, .275);\n    float sh = max(.75 - d.x*10., 0.); // Distance field-based shading.\n    sh *= clamp(-sin(d.x*6.283*18.) + .75, -.25, 1.) + .25; // Overlay pattern.\n\n\n    // Drop shadow, edges and overlay.\n    col = mix(col, vec3(0), (1. - smoothstep(0., fo*5., d.x))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., fo, d.x));\n    col = mix(col, pCol*sh, 1. - smoothstep(0., fo, d.x + .015));\n\n    // Darkening the rounded quads around the lit centers.\n    col = mix(col, bg*sh, 1. - smoothstep(0., fo, max(d.x + .1, -(d.x + .14))));\n   \n    #ifdef TRI_LEVEL\n        // Apply some blue blinking neon to the tri level pattern.\n    \tvec3 neon = mix(col, col*vec3(1.5, .1, .3).yxz*2., 1. - smoothstep(.7, .9, sin(rnd.y*6.283 + iTime*4. + side)));\n    \tcol = mix(col, col*neon, 1. - smoothstep(0., fo, d.x + .16));\n    #else\n        // Apply some animated noisy reddish neon to the dual level pattern. \n    \tvec3 neon = mix(bg, col*vec3(1.5, .1, .3)*2., smoothstep(-.5, .5, n2D(oP*3. + vec2(iTime*2.))*2. - 1.));\n    \tcol = mix(col, neon, 1. - smoothstep(0., fo, d.x + .16));// + .125\n    #endif\n            \n   \n      \n    // Add some subtle noise.        \n    col *= ns*.25 + .75;\n    \n    \n    // A bit of gradential color mixing.\n    col = mix(col.xzy, col, sign(uv.y)*uv.y*uv.y*2. + .5);\n    col = mix(col.xzy, col, (-uv.y*.66 - uv.x*.33) + .5);\n    \n    // Mild spotlight.\n    col *= max(1.25 - length(uv)*.25, 0.);\n      \n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}