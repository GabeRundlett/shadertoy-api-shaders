{
    "Shader": {
        "info": {
            "date": "1649523476",
            "description": "4-dimensional version of Mandelbrot set\nThis shader shows the 3d \"slices\" (real-i-j components) of the 4D quaternion Mandelbrot while rotating XY.",
            "flags": 0,
            "hasliked": 0,
            "id": "7l2yWR",
            "likes": 1,
            "name": "Raymarched Quaternion Mandelbrot",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "mandelbrot",
                "quaternion"
            ],
            "usePreview": 0,
            "username": "Fraktoler",
            "viewed": 385
        },
        "renderpass": [
            {
                "code": "#define MAX_ITER 10\n#define MAX_STEPS 100\n#define MAX_DIST 8.\n#define MIN_DIST .001\n#define EPSILON .0001\n\n//3 dimensional rotations\n\nvec3 rotate(vec3 p, vec3 rot) {\n    vec2 v = mulComplex(p.yz, cis(rot.x));\n    vec3 p_prime = vec3(p.x, v.xy);\n    v = mulComplex(p_prime.xz, cis(rot.y));\n    p_prime = vec3(v.x, p_prime.y, v.y);\n    v = mulComplex(p_prime.xy, cis(rot.z));\n    p_prime = vec3(v.xy, p_prime.z);\n    return p_prime;\n}\n\n//4 dimensional rotations\n\nvec4 rotateXY(vec4 p, float rot) {\n    mat4 rotXY = mat4(\n    cos(rot), -sin(rot), 0.0, 0.0,\n    sin(rot), cos(rot), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n    );\n    return rotXY * p;\n}\n\nvec4 rotateXZ(vec4 p, float rot) {\n    mat4 rotXZ = mat4(\n    cos(rot), 0.0, -sin(rot), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    sin(rot), 0.0, cos(rot), 0.0,\n    0.0, 0.0, 0.0, 1.0\n    );\n    return rotXZ * p;\n}\n\nvec4 rotateZW(vec4 p, float rot) {\n    mat4 rotZW = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, cos(rot), -sin(rot),\n    0.0, 0.0, sin(rot), cos(rot)\n    );\n    return rotZW * p;\n}\n\nfloat DE(vec3 v) {\n    vec4 c = vec4(v, sin(iTime * 0.2) * 1.25);\n    vec4 q = c;\n    float power = 2.0;\n    float bailout = 2.0;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int k = 0; k < MAX_ITER; k++) {\n        r = length(q);\n\t\tif (r > bailout) break;\n\t\tdr = power * pow(r, power - 1.0) * dr + 1.0;\t\t\n\t\tq = powQuat(q, power) + c;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.0;    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = DE(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<MIN_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 normalVector(vec3 p) {\n\tfloat d = DE(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat lighting(vec3 p) {\n    vec3 lightPos = rotate(vec3(0.0, -5.0, 5.0), vec3(-0.5, 0., -iTime / 5.));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normalVector(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p + n * MIN_DIST * 2.0, l);\n    if(d < length(lightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 2.0;\n    vec2 uv = zoom * (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n    vec3 rot = vec3(-0.5, 0.0, -iTime / 5.);\n    vec3 ro = rotate(vec3(0.0, -3.0, 0.0), rot);\n    vec3 rd = normalize(rotate(vec3(uv.x, 1.0, uv.y), rot));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = lighting(p);\n    vec3 col = vec3(dif);\n    \n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Complex (C) functions\nvec2 cis(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\nvec2 mulComplex(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\n//Quaternion (H) functions\n//https://en.wikipedia.org/wiki/Quaternion\nvec4 conjQuat(vec4 q) {\n    return vec4(q.x, -q.yzw);\n}\n\nvec4 mulQuat(vec4 p, vec4 q) {\n    //Quaternion multiplication (Order matters)\n    return vec4(p.x * q.x - dot(p.yzw, q.yzw), p.x * q.yzw + q.x * p.yzw + cross(p.yzw, q.yzw));\n}\n\nvec4 sqrQuat(vec4 q) {\n    return vec4(q.x * q.x - dot(q.yzw, q.yzw), (q.x + q.x) * q.yzw);\n}\n\nvec4 cubeQuat(vec4 q) {\n    float r2 = q.x * q.x;\n    float v2 = dot(q.yzw, q.yzw);\n    return q * vec4(r2 - 3. * v2, vec3(3. * r2 - v2));\n}\n\nvec4 recipQuat(vec4 q) {\n    //Quaternion reciprocal\n    return vec4(q.x, -q.yzw) / dot(q, q);\n}\n\nvec4 sqrtQuat(vec4 q) {\n    return vec4(sqrt(0.5 * (length(q) + q.x)), normalize(q.yzw) * sqrt(0.5 * (length(q) - q.x)));\n}\n\nvec4 expQuat(vec4 q) {\n    float r = length(q.yzw);\n    return exp(q.x) * vec4(cos(r), normalize(q.yzw) * sin(r));\n}\n\nvec4 logQuat(vec4 q) {\n    return vec4(0.5 * log(dot(q, q)), normalize(q.yzw) * acos(q.x / length(q)));\n}\n\nvec4 powQuat(vec4 q, float x) {\n    float r = length(q);\n    float phi = acos(q.x / r);\n    return pow(r, x) * vec4(cos(x * phi), normalize(q.yzw) * sin(x * phi));\n}\n\nvec4 powerQuat(vec4 p, vec4 q) {\n    return expQuat(mulQuat(logQuat(p), q));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}