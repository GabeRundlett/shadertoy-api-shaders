{
    "Shader": {
        "info": {
            "date": "1590015331",
            "description": "Or some sort of evil structure maybe",
            "flags": 32,
            "hasliked": 0,
            "id": "WsBfWD",
            "likes": 25,
            "name": "Geological phenomenon",
            "published": 3,
            "tags": [
                "fractal",
                "dof",
                "bloom",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 891
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x) {\n    \n    // ACES system tone scale (RTT+ODT)\n    const float a = .0245786;\n    const float b = -.000090537;\n    const float c = .983729;\n    const float d = .4329510;\n    const float e = .238081;\n    x = (x*(x+a)+b) / (x*(x*c+d)+e);\n    \n    return x;\n}\n\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n\nvec3 bloom(float scale, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel0, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    \n    return bloom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec3 bloomSum = vec3(0.);\n    bloomSum += bloom(.15 * iResolution.y, fragCoord) * .15;\n    bloomSum += bloom(.05 * iResolution.y, fragCoord) * .07;\n    bloomSum += bloom(.02 * iResolution.y, fragCoord) * .03;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = clamp(ACESFilm(fragColor.rgb + bloomSum), vec3(0.), vec3(1.));\n    fragColor.rgb = pow(fragColor.rgb, vec3(.8));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Bounces 4\n#define MaxSteps 256\n#define SceneRadius 2.\n#define DetailLevel 2.\n#define StepFactor 1.\n\n#define Pi 3.14159265359\n#define ORTHO( v ) abs(v.x)>abs(v.z)?vec3(-v.y,v.x,0.):vec3(0.,-v.z,v.y)\n#define HASH( seed ) fract(cos(seed)*43758.5453)\n#define RANDOM HASH(seed++)\n#define RANDOM2D vec2(RANDOM, RANDOM)\n#define HITDIST( p ) length(p-Cam.pos)/iResolution.y/Cam.focalLength/DetailLevel\n\nstruct Surface {\n    bool metallic;\n    float ior, roughness;\n    vec3 emission, diffuse;\n};\n\nstruct Camera {\n\tvec3 pos, rot;\n\tfloat focalLength, focalDistance, aperture;\n} Cam;\n\nfloat seed;\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nfloat fresnel(vec3 dir, vec3 n, float ior) {\n    float cosi = dot(dir, n);\n    float etai = 1.0;\n  \tfloat etat = ior;\n    if (cosi > 0.0) {\n         float tmp = etai;\n         etai = etat;\n         etat = tmp;\n     }\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if (sint >= 1.0) return 1.0;\n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ORTHO(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = RANDOM2D;\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n// n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation) {\n    \n    float side = sin(Pi / float(nbBlades));\n    vec2 tri = RANDOM2D;\n    if(tri.x-tri.y > 0.0) tri = vec2(tri.x-1.0, 1.0-tri.y);\n    tri *= vec2(side, -sqrt(1.0-side*side));\n    float angle = rotation + 2.*Pi*floor(RANDOM * float(nbBlades))/float(nbBlades);\n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\nvec2 sphereIntersect(vec3 pos, vec3 dir, float radius) {\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - radius * radius;\n    float discriminant = b * b - c;\n    if (discriminant < 0.) return vec2(-1.);\n\tfloat s = sqrt(discriminant);\n    return vec2(-b - s, -b + s);\n}\n\nvoid fold(inout vec3 z, vec3 o, vec3 n) {\n    z -= 2.*n*min(dot(z-o, n), 0.);\n}\n\nfloat sdfIFS(vec3 z, out Surface surf){\n    \n\tfloat scale = 2.;\n    int Iterations = 16;\n    mat3 rot = rotationMatrix(vec3(.5)*Pi);\n    \n    vec3 n1 = normalize(vec3(1., 1., -1.));\n    vec3 n2 = normalize(vec3(1., -1., -1.));\n    //vec3 n3 = normalize(vec3(1., -1., 1.));\n    \n    vec3 ot = vec3(1.);\n    for(int i = 0; i < Iterations; i++) {\n        fold(z, vec3(-.0), n1);\n        fold(z, vec3(-.25), n2);\n        //fold(z, vec3(-.25), n3);\n        n1 *= rot;\n        z = z*scale - sign(z)*(scale-1.0);\n        ot = min(abs(z), ot);\n    }\n    surf = Surface(true, 1.0, .1, vec3(0.), vec3(.8));\n    if(ot.r >= .75) surf = Surface(false, 1., .0, ot.ggb*30.*vec3(12., 2., .5), vec3(0.1));\n    return length(z) * pow(scale, float(-Iterations));\n}\n\n\nfloat sdf(in vec3 pos, out Surface surf) {\n    float sSc = length(pos)-SceneRadius;\n    float s = sdfIFS(pos * rotationMatrix(vec3(.5, .0, .0)*Pi), surf);\n    return abs(sSc) > abs(s) || s > 0. ? s : sSc;\n    \n}\n\nfloat sdf(vec3 pos){\n    Surface surf;\n    return sdf(pos, surf);\n}\n\n\nvec3 normalEstimation(vec3 pos, float hd){\n  vec2 k = vec2(hd, 0);\n  return normalize(vec3(sdf(pos + k.xyy) - sdf(pos - k.xyy),\n\t  \t\t\t\t\tsdf(pos + k.yxy) - sdf(pos - k.yxy),\n  \t\t\t\t\t\tsdf(pos + k.yyx) - sdf(pos - k.yyx)));\n}\n\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 normal, out Surface surf) {\n    vec2 ts = sphereIntersect(pos, dir, SceneRadius);\n    if(sign(ts) != vec2(-1.)) {\n        float t = max(ts.x, 0.);\n        for(int i = 0; i < MaxSteps; i++) {\n            if(t >= ts.y) break;\n            vec3 p = pos+t*dir;\n            float dist = sdf(p, surf);\n            float hd = HITDIST(p);\n            if(dist < hd) {\n                pos += (t-hd*2.) * dir;\n                normal = normalEstimation(pos, hd);\n                return true;\n            }\n            t += dist*StepFactor*(RANDOM*.5+.5);\n        }\n    }\n    pos += ts.y*dir;\n    return false;\n}\n\nvec3 background(vec3 dir) {\n    return vec3(.8, .9, .9);\n}\n\nvec3 pathTrace(vec3 pos, vec3 dir) {\n    Surface surf;\n    vec3 normal, col = vec3(0.), abso = vec3(1.);\n    for(int i = 0; i <= Bounces; i++) {\n        bool t = trace(pos, dir, normal, surf);\n        if(!t) return col + abso * background(dir);\n        vec3 difuseDir = getCosineWeightedSample(normal);\n        vec3 reflectDir = normalize(mix(reflect(dir, normal), difuseDir, surf.roughness));\n        if(surf.metallic){\n            dir = reflectDir;\n            col += abso * surf.emission;\n            abso *= surf.diffuse;\n        } else {\n            float f = fresnel(dir, normal, surf.ior);\n            col += abso * surf.emission * (1.-f);\n            if(RANDOM < f-.1e-7) {\n                dir = reflectDir;\n            } else {\n                dir = difuseDir;\n                abso *= surf.diffuse;;\n            }\n        }\n        if(abso == vec3(0.)) break;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    fragColor = iFrame == 0 ? vec4(0.) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iMouse.z > 0.) fragColor.a = 0.;\n    \n    //comment these lines if you have a good GPU, this is just to avoid timeout on my PC\n    if(sign(fragCoord.x-iResolution.x/2.) != ((iFrame&1)==0?-1.:1.)) return;\n    if(sign(fragCoord.y-iResolution.y/2.) != ((iFrame&2)==0?-1.:1.)) return;\n    \n    seed = sin(float(iFrame)) + cos(fragCoord.x) + sin(fragCoord.y);\n    \n    Cam = Camera(vec3(.0, .0, -.2), vec3(.1, -2.2, 0.), 1.5, .3, .002);\n    Cam.pos *= rotationMatrix(Cam.rot);\n    Cam.pos += vec3(-.5, 1.1, 0.5);\n    \n    vec2 uv = (fragCoord+RANDOM2D-iResolution.xy/2.) / iResolution.y;\n\n    vec3 focalPoint = vec3(uv * Cam.focalDistance / Cam.focalLength, Cam.focalDistance);\n    vec3 aperture = Cam.aperture * vec3(sampleAperture(5, 1.0), 0.0);\n    vec3 dir = normalize(focalPoint-aperture);\n    vec3 pos = aperture;\n    vec3 cdir = vec3(0., 0., 1.);\n\n    mat3 CamMatrix = rotationMatrix(Cam.rot);\n    dir *= CamMatrix;\n    cdir *= CamMatrix;\n    pos = pos*CamMatrix + Cam.pos;\n    \n    vec3 col = max(vec3(0.), pathTrace(pos, dir) * dot(dir, cdir));\n    \n    fragColor.a++;\n    fragColor.rgb = mix(fragColor.rgb, col, 1./fragColor.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}