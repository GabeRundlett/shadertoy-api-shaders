{
    "Shader": {
        "info": {
            "date": "1478601759",
            "description": "First shader, there must be a more procedural way of doing this, suggestions welcome!",
            "flags": 0,
            "hasliked": 0,
            "id": "4tcXRM",
            "likes": 2,
            "name": "Colour Hexagon",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "fplain",
            "viewed": 491
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define TAU 6.28318530718\n\nbool IsBelowLine(vec2 p0, vec2 p1, vec2 point) {\n\tvec2 norm = vec2(p1.y - p0.y, -(p1.x - p0.x));\n\tvec2 p = point - p0;\n\treturn dot(norm, p) > 0.0;\n}\n\nfloat IntensityToTriCorner(vec2 corner, vec2 uv, vec2 p1, vec2 p2) {\n\tfloat l1Grad = (uv.y - corner.y) / (uv.x - corner.x);\n\tfloat l1YIntercept = corner.y - l1Grad * corner.x;\n\tfloat l2Grad = (p1.y - p2.y) / (p1.x - p2.x);\n\tfloat l2YIntercept = p2.y - l2Grad * p2.x;\n    \n\tfloat distanceRatio = -1.0;\n\tvec2 intersect;\n\tif (p2.x != p1.x && corner.x != uv.x) {\n\t\tintersect.x = (l2YIntercept - l1YIntercept) / (l1Grad - l2Grad);\n\t} else if (corner.x != uv.x) {\n\t\tintersect.x  = p2.x;\n\t}\n\tintersect.y = l1Grad * intersect.x + l1YIntercept;\n\n\tfloat dPoint = distance(corner, uv);\n\tfloat dIntersect = distance(corner, intersect);\n\treturn 1.0 - abs(dPoint / dIntersect);\n}\n\nvoid HexTri(vec2 p0, vec2 p1, vec2 p2, vec4 c0, vec4 c1, vec4 c2, vec2 coord, out vec4 resultCol) {\n\tif (IsBelowLine(p0, p1, coord) && \n\t    IsBelowLine(p1, p2, coord) && \n\t    IsBelowLine(p2, p0, coord)) {\n\t\tfloat d1 = IntensityToTriCorner(p0, coord, p1, p2);\n\t\tfloat d2 = IntensityToTriCorner(p1, coord, p2, p0);\n\t\tfloat d3 = IntensityToTriCorner(p2, coord, p0, p1);\n\t\tresultCol = resultCol + (d1 * c0) + (d2 * c1) + (d3 * c2);\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 coord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    coord *= 1.5;\n\n\tfloat sqrt3Ovr4 = sqrt(0.75);\n\tvec2 hexVerts[6];\n\thexVerts[0] = vec2(0.0, 1.0);\n\thexVerts[1] = vec2(sqrt3Ovr4, 0.5);\n\thexVerts[2] = vec2(sqrt3Ovr4, -0.5);\n\thexVerts[3] = vec2(0.0, -1.0); \n\thexVerts[4] = vec2(-sqrt3Ovr4, -0.5);\n\thexVerts[5] = vec2(-sqrt3Ovr4, 0.5);\n\tvec2 centre = vec2(0.0, 0.0);\n\n\tvec4 hexCols[6];\n\thexCols[0] = vec4(1.0, 0.0, 0.0, 1.0);\n\thexCols[1] = vec4(1.0, 1.0, 0.0, 1.0);\n\thexCols[2] = vec4(0.0, 1.0, 0.0, 1.0);\n\thexCols[3] = vec4(0.0, 1.0, 1.0, 1.0);\n\thexCols[4] = vec4(0.0, 0.0, 1.0, 1.0);\n\thexCols[5] = vec4(1.0, 0.0, 1.0, 1.0);\n\tvec4 centreCol = vec4(1.0, 1.0, 1.0, 1.0);\n\n\tfloat grey = 0.2 - 0.1 * (1.0 - coord.y);\n    vec4 background = vec4(grey, grey, grey, 1.0);        \n    vec4 hex = vec4(0.0, 0.0, 0.0, 1.0);\n\tHexTri(hexVerts[0], hexVerts[1], centre, hexCols[0], hexCols[1], centreCol, coord, hex);\n\tHexTri(hexVerts[1], hexVerts[2], centre, hexCols[1], hexCols[2], centreCol, coord, hex);\n\tHexTri(hexVerts[2], hexVerts[3], centre, hexCols[2], hexCols[3], centreCol, coord, hex);\n\tHexTri(hexVerts[3], hexVerts[4], centre, hexCols[3], hexCols[4], centreCol, coord, hex);\n\tHexTri(hexVerts[4], hexVerts[5], centre, hexCols[4], hexCols[5], centreCol, coord, hex);\n\tHexTri(hexVerts[5], hexVerts[0], centre, hexCols[5], hexCols[0], centreCol, coord, hex);\n    if (hex.r == 0.0 && hex.g == 0.0 && hex.g == 0.0) {\n        fragColor = background;\n    } else {\n        fragColor = hex;\n    }\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}