{
    "Shader": {
        "info": {
            "date": "1662844939",
            "description": "An experiment that I modeled with https://bauble.studio and then ported into Shadertoy.",
            "flags": 0,
            "hasliked": 0,
            "id": "7ttBRM",
            "likes": 17,
            "name": "Survey Results",
            "published": 3,
            "tags": [
                "3d",
                "landscape",
                "topography",
                "diorama",
                "bauble"
            ],
            "usePreview": 0,
            "username": "ianthehenry",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\nconst int MAX_STEPS = 256;\nconst float MINIMUM_HIT_DISTANCE = 0.1;\nconst float NORMAL_OFFSET = 0.005;\nconst float MAXIMUM_TRACE_DISTANCE = 1024.0;\n\n/*\n\nThis shader was originally generated with https://bauble.studio, but\nI optimized the shader by hand and colorized it inside Shadertoy.\n\nThe original Bauble source that I used to iterate on shapes and values:\n\n    (defn quantize [x y]\n      (x * y | round / y))\n\n    (defn wave [angle period phase magnitude]\n      (sin ((~(. (* ,p (rotate_y (* ,angle ,tau))) :x) / 100 * period) + (tau * phase)) * magnitude))\n\n    (half-space :-y\n      (+ (wave 0.10 1.93 0.45 1.0)\n         (wave 0.10 5.33 1.27 1.0)\n         (wave 0.54 4.50 0.76 1.29)\n         (wave 2.43 4.72 -1.87 0.94)\n         (wave 2.38 6.74 -1.87 0.94)\n         (p.z / -50)\n         ((/ (length p.xz / 100)) * -4.5)\n      | remap+\n      | quantize 2\n      * 10\n      )\n    | union\n      (half-space :-y -36.6\n      | bounded-offset 1 (perlin (vec3 (~(. (* (rotate_y -0.33) ,p) :xz) / [2 14]) t))\n      | color [0 0 1]\n      | fresnel)\n    | intersect :r 5 (line [0 86 0] [0 100 0] 197)\n    | slow 0.5)\n\nI was planning to shade it normally, but I really liked the look of Bauble's\ndebug convergence view for this scene, so I decided to port it to Shadertoy\nand use the raymarching steps as an input for the shading. This gives the shader\na nice, free \"glow\" effect. But because of this, it only looks good from a few\nangles -- if you look straight down at the model, it's far too dark.\n\n*/\n\nmat3 rotate_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    c, 0.0, s,\n    0.0, 1.0, 0.0,\n    -s, 0.0, c);\n}\n\n// Perlin noise functions by Stefan Gustavson\n// https://github.com/stegu/webgl-noise\nvec3 fade3(vec3 t) {\n  return t*t*t*(t * (t * 6.0 - 15.0) + 10.0);\n}\nvec4 taylor_inv_sqrt4(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 mod289_3(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289_4(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute4(vec4 x) {\n  return mod289_4(((x * 34.0) + 10.0) * x);\n}\nfloat perlin3(vec3 P) {\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3(Pi0);\n  Pi1 = mod289_3(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute4(permute4(ix) + iy);\n  vec4 ixy0 = permute4(ixy + iz0);\n  vec4 ixy1 = permute4(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylor_inv_sqrt4(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylor_inv_sqrt4(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat lake(vec3 p) {\n  float mag = 0.2;\n  float threshold = 1.0;\n  vec3 p1 = (p - vec3(0.0, -36.60, 0.0));\n  float boundary_distance = (p1.y - mag);\n  if (boundary_distance < threshold) {\n    vec3 p1 = (p - vec3(0.0, -36.6, 0.0));\n    vec3 rotated = rotate_y(-0.33) * p;\n    return p1.y - mag * (\n      perlin3(vec3(\n        (rotated - vec3(0.0, 0.0, 10.0 * iTime)).xz / vec2(2.0, 14.0),\n        sin(iTime)))\n      + 0.25 * perlin3(vec3(4.0 * (rotated - vec3(0.0, 0.0, 10.0 * iTime)).xz / vec2(2.0, 14.0), iTime))\n      );\n  } else {\n    return boundary_distance;\n  }\n}\n\nconst float TAU = 6.283185;\n\nfloat quantize(float x, float y) {\n  return round(x * y) / x;\n}\n\nfloat remap(float x) {\n  return 0.5 * (x + 1.0);\n}\n\nfloat wave(vec3 p, float angle, float period, float phase, float magnitude) {\n  float x = (p * rotate_y(angle * TAU)).x;\n  return sin(x * 0.01 * period + TAU * phase) * magnitude;\n}\n\nfloat landscape(vec3 p) {\n  float elevation = 10.0 * quantize(2.0, remap(\n      wave(p, 0.10, 1.93, 0.45, 1.0)\n    + wave(p, 0.10, 5.33, 1.27, 1.0)\n    + wave(p, 0.54, 4.50, 0.76, 1.29)\n    + wave(p, 2.43, 4.72, -1.87, 0.94)\n    + wave(p, 2.38, 6.74, -1.87, 0.94)\n    - (p.z / 50.0)\n    - (450.0 / length(p.xz))\n    ));\n\n  return 0.4 * (p.y - elevation);\n}\n\nfloat union_0(vec3 p) {\n  return min(landscape(p), lake(p));\n}\n\nfloat s3d_line(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nvec3 fresnel(vec3 normal, vec3 P, vec3 camera_origin, vec3 color, float strength, float exponent) {\n  vec3 view_dir = normalize(camera_origin - P);\n  float fresnel = pow(1.0 - dot(normal, view_dir), exponent);\n  return color * strength * fresnel;\n}\n\nvec3 union_color_0(int steps, vec3 normal, vec3 camera_origin, vec3 p) {\n  if (landscape(p) < lake(p)) {\n    return vec3(0.0, 0.5*smoothstep(0.0, 0.5, float(steps) / float(MAX_STEPS)), 0.0);\n  } else {\n    float glow = smoothstep(0.0, 0.4, float(steps) / float(MAX_STEPS));\n    float sun = clamp(dot(normalize(reflect(p - camera_origin, normal)), normalize(vec3(0.5, 1.0, -5))), 0.0, 1.0);\n    sun = smoothstep(0.99, 1.0, sun);\n    return\n      vec3(0.0, 0.0, glow * 1.0)\n      + vec3(1.0, 0.5, 0.0) * sun\n      + fresnel(normal, p, camera_origin, vec3(0.8, 0.3, 1.0), 0.5, 3.0);\n  }\n}\n\nvec3 intersect_color_1(int steps, vec3 normal, vec3 camera_origin, vec3 p) {\n  float d = union_0(p);\n  float d2;\n  int surface = 0;\n  vec3 color;\n  d2 = (s3d_line(p, vec3(0.0, 86.0, 0.0), vec3(0.0, 100.0, 0.0)) - 197.0);\n  if (d2 > d) { d = d2; surface = 1; }\n\n  switch (surface) {\n    case 0:\n      return union_color_0(steps, normal, camera_origin, p);\n      break;\n    case 1:\n      // underside\n      return vec3(0.0, 0.25*smoothstep(0.0, 0.5, float(steps) / float(MAX_STEPS)), 0.0);\n      break;\n  }\n  return color;\n}\n\nfloat nearest_distance(vec3 p) {\n  float b, h = 0.0;\n  float r = 10.0;\n  float a = union_0(p);\n  b = s3d_line(p, vec3(0.0, 86.0, 0.0), vec3(0.0, 100.0, 0.0)) - 197.0;\n  h = clamp(0.5 - 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) + r * h * (1.0 - h);\n  return a;\n}\n\nvec3 calculate_normal(vec3 p) {\n  const vec3 step = vec3(NORMAL_OFFSET, 0.0, 0.0);\n\n  return normalize(vec3(\n    nearest_distance(p + step.xyy) - nearest_distance(p - step.xyy),\n    nearest_distance(p + step.yxy) - nearest_distance(p - step.yxy),\n    nearest_distance(p + step.yyx) - nearest_distance(p - step.yyx)\n  ));\n}\n\nvec3 march(vec3 ray_origin, vec3 ray_direction, out int steps) {\n  float distance = 0.0;\n\n  for (steps = 0; steps < MAX_STEPS; steps++) {\n    vec3 p = ray_origin + distance * ray_direction;\n\n    float nearest = nearest_distance(p);\n\n    // TODO: this attenuation only works when we're\n    // using march to render from the camera's point\n    // of view, so we can't use the march function\n    // as-is to render reflections. I don't know if\n    // it's worth having.\n    // if (nearest < distance * MINIMUM_HIT_DISTANCE * 0.01) {\n    if (nearest < MINIMUM_HIT_DISTANCE || distance > MAXIMUM_TRACE_DISTANCE) {\n      return p + nearest * ray_direction;\n    }\n\n    distance += nearest;\n  }\n  return ray_origin + distance * ray_direction;\n}\n\nvec3 nearest_color(vec3 p, vec3 camera_origin, int steps) {\n  return intersect_color_1(steps, calculate_normal(p), camera_origin, p);\n}\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 ray_dir(float fov, vec2 size, vec2 pos) {\n  vec2 xy = pos - size * 0.5;\n\n  float cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\n  float z = size.y * 0.5 * cot_half_fov;\n\n  return normalize(vec3(xy, -z));\n}\n\nmat3 rotate_xy(vec2 angle) {\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n\n  return mat3(\n    c.y      ,  0.0, -s.y,\n    s.y * s.x,  c.x,  c.y * s.x,\n    s.y * c.x, -s.x,  c.y * c.x\n  );\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float gamma = 2.2;\n  vec2 resolution = iResolution.xy;\n\n  vec3 camera_origin = vec3(0.0, 0.0, 350.0);\n  vec2 rotation = vec2(-0.125, -0.25);\n  if (iMouse.z > 0.0) {\n    vec2 mouse_offset = (iMouse.xy / resolution) - 0.5;\n    mouse_offset *= vec2(-1.0, 0.5);\n    rotation += mouse_offset;\n  }\n  mat3 camera_matrix = rotate_xy(rotation.yx);\n\n  camera_origin = camera_matrix * camera_origin + vec3(0.0, -32.0, 0.0);\n\n  int view_type = 1;\n\n  vec3 dir = camera_matrix * ray_dir(45.0, resolution, gl_FragCoord.xy);\n\n  const vec3 fog_color = vec3(0.15);\n\n  int steps;\n  vec3 hit = march(camera_origin, dir, steps);\n\n  vec3 color;\n  float depth = distance(camera_origin, hit);\n  if (depth >= MAXIMUM_TRACE_DISTANCE) {\n    float glow = float(steps) / float(MAX_STEPS);\n    color = mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.2), gl_FragCoord.y / resolution.y);\n    color += vec3(0.0, glow, glow);\n  } else {\n    color = nearest_color(hit, camera_origin, steps);\n  }\n\n\n  fragColor = vec4(pow(color, vec3(1.0 / gamma)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}