{
    "Shader": {
        "info": {
            "date": "1551867339",
            "description": "drag left mouse mouse to stop the camera from spinning\n\nhttps://www.shadertoy.com/view/WdfXz2\nwith better performance*precision, by using logEps()",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXXzl",
            "likes": 11,
            "name": "2x spinor rotation logEps twist",
            "published": 3,
            "tags": [
                "deform",
                "quaternion",
                "rotation",
                "twist",
                "logeps",
                "dirac",
                "spinor",
                "spinor",
                "720degperiod",
                "antitwister"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 761
        },
        "renderpass": [
            {
                "code": "//this logepsdemo still fails on a very convex and very twisted surface\n//where linear marching still outperforms it mostly.\n//a better+simppler logeps demo is https://www.shadertoy.com/view/dlXyzs#\n\n//parent: is: https://www.shadertoy.com/view/WdfXz2\n//-  created by florian berger (flockaroo) - 2019\n//-  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//...saw this on twitter and had to give it a try on shadertoy.\n// https://twitter.com/lexfridman/status/1101871948664049664\n// original author of the above video seems to be Jason Hise\n// https://en.wikipedia.org/wiki/File:Belt_Trick.ogv\n\n//a twisting deformation around rotating space, without tangling up.\n//dirac invented it to describe electron spin\n//it needs 720 degrees for one full period\n//as it oscillates between (over and under) over time (otrhogonal to a rotation axis)\n//while avoiding accumulation of twists over time.\n//and that needs some getting used to\n\n//this adds more geometry and\n//logEps() performs better in twisted space (larger local lipschitz)\n//gets closer to surfaces, no matter how deformed space is\n//and passes further trough voids and alon near-parallel surfaces.\n//logeps() disadvantage is that its not too  good for reflections.\n//logEps mainly allows for larger zFar (while there are large voids) and for more twist deformation, without overstepping (as much)\n\n#define zFar 2000.\n\n#define doLogEps\n//the core idea of logeps lies within how calculus and logstar() work\n//and it uses that to care less for lipschitz continuity and space deformations.\n\n//doLogEps has much better precision within deformed fields.\n//- ideal within a Dirac-context ?\n//gets closer to surfaces, where it gets better normals\n//better at long distances (epsilon increases logarythmically over log(eps*distance*distance/pow(numberOfSteps,1.+n)))<0 ???\n//, where n is roughly equal to 1/maxLipschitzConstant\n//, where n is the value that you normally multiply d by foreach step, if you have twisted space.\n//Stepcount or n can easily be made smaller, on a log scale this is less intuitive and more forgivable.\n//Is slower while the camera is close to a surface (might want  to avoid looking along  walls)\n//otherwise significantly faster AND more precise\n//can traverse further with less steps (especially in deformed space)\n//,due to log(eps) scaling AND accumulative overstepping over distance\n//that is, in the distance precision does VERY BAD, but that barely matters, due to inverseSquare laws.\n//so we like it rough in the distance, in favor of a larger zFar.\n\n//this optionally adds a second tensor around a different axis, with a different speed\n//but really, it just needs a quaternion rotation instead!\n//and a double buffer to have that quaternion be changed by keyboard input over time.\n\n#define doDobleTension\n//rotate around 2 axis  insuccession (this really lacks quaternion rotatiob, theres no excuse!\n//i add a second tensor to illustrate how far we can push logeps() here.\n\n//a lot of code in this shader is copied from [blackhole canvas]\n//and this could use its quaternion camera \n//to set the rotation within ROT()\n\n#define PI2 (acos(-1.)*2.)\n\n//box distance\nfloat sdBox( vec3 p, vec3 b\n){vec3 d = abs(p) - b\n ;return length(max(d,0.0))\n        // + min(max(d.x,max(d.y,d.z)),0.0); // +fully signed box (negative inside)\n;}\n\n\n//this REALLY should be quaterion rotation in this context!\n//but it only rotates around a static axis\nvoid ROT(float ang,inout vec2 v) { \n    vec2 cs=sin(vec2(1.6,0)+ang); \n    v=mat2(cs,cs.yx*vec2(-1,1))*v;\n}\n\n\n//float sd4chords(vec2 u){ return length(abs(u)-1.)-.2;}\n\n\nfloat sd4chords(vec3 u){\n          ;float t=iTime*2.1\n     //;u.xy=mix(u.xy,vec2(-u.y,u.x),step(abs(u.y),abs(u.x)))\n     //;u.x=abs(u.x);\n    ;if(   (u.x)<abs(u.y))u.xy=vec2(-u.y,u.x)\n  ;if(abs(u.x)<abs(u.y))u.xy=vec2(-u.y,u.x)\n    ;if(   (u.x)<abs(u.z))u.xz=vec2(-u.z,u.x)\n  //;if(   (u.x)<abs(u.z))u.xz=vec2(-u.z,u.x)\n    ;u.y=abs(u.y)//-2.//+.5*(sin(t)*.5+.5)\n    ;u.z=abs(u.z)-2.//-(cos(t)*.5+.5)\n //above 4 lines are diagonal folds AND chord mirrors\n//swap [<] for [>], remove ONE [abs] in any line, change oders\n//,swivel values, change signs, change oder of lines\n //, to get an intuition for too much symmetry to explain.\n    //;u.z=abs(u.z)-2.\n     //u.y=abs(u.y)-2.\n  \n    //; u.yz=abs(u.yz)-(vec2(cos(t),sin(t*1.61))*.5+.5)\n   ;return length(u.zy)-.1\n       //there are ways to turn athese if() branches into a linear interpolation.\n;}\n\n\nfloat getDist(vec3 p){\n    float d=10000.;\n    //float falloff=clamp(1./(1.+.025*max(0.,dot(p,p))),0.,1.);\n    float falloff=1.-(smoothstep(2.,20.,length(p)));\n    \n    \n\n    //float ang=(iMouse.xy/iResolution.xy*PI2).x;\n    float ang=iTime;\n\n    // those 3 lines are the core part\n    // ...remove them and you'll just have 3 boring sticks and a cube ;-)\n    ROT(-ang,p.xy);             // globally rotate around z\n    ROT(PI2*.50*falloff,p.yz);   // locally rotate around x by 180 degrees\n    ROT(ang,p.xy);              // globally rotate back around z \n    \n    #ifdef doDobleTension\n    ROT(-ang*.61,p.xz);             // globally rotate around z\n    ROT(PI2*.5*falloff,p.zy);   // locally rotate around x by 180 degrees\n    ROT(ang*.61,p.xz);              // globally rotate back around z \n#endif\n    ;d=min(d,sdBox(p,vec3(2)))//box\n        \n    ;d=min(d,sd4chords(p))//strings\n ;vec4 t=.1*(vec4(0,1,2,3)+.61)\n ;vec4 e=mix(vec4(2),vec4(0),sin(iTime*t)*.5+.5)\n    ;d=min(d,sdBox(p,vec3(0.,e.x,zFar)));//vertical1\n    ;d=min(d,sdBox(p,vec3(e.y,.1,zFar)));//vertical2\n    //get special cross-treatment for a gravity bias.\n    ;d=min(d,sdBox(p,vec3(zFar,.1,e.z)));\n    ;d=min(d,sdBox(p,vec3(.1,zFar,e.w)));\n    \n   ; return d;\n}\n\nvec3 getDerivative(vec3 pos,float eps\n){vec3 d=vec3(eps,0,0)\n ;return vec3(\n       getDist(pos+d.xyz)-getDist(pos-d.xyz),\n        getDist(pos+d.zxy)-getDist(pos-d.zxy),\n        getDist(pos+d.yzx)-getDist(pos-d.yzx)\n        )/eps/2.;\n}\n\n//logEps() put into subroutine\n//, to toggle between various LOD-scales (distance field zoom levels)\n//, to make it toggleAble (sometimes a simpler end condition is better)\nbool logEps(float c,float s//s=distanceToSurface c=DistanceToCamera\n){\n // if(s<0.01)return true;return false;//basic raymarching with epsilon=0.01\n  //if(1./exp(d)<.01)return s<.001;//better for short distance reflections\n    //well, the above line fails within a tensor-distorted gradient...\n  //return log(c*c/s/1e5)>0. //FAST long-distance logeps for spinor /tdXXzl\n  //goes VERY bloated beyond d>2000, just set zFar<2000\n  \n  //other logebs work better (for less distorted fields)\n  //, but they tend to be slower by multiplying/dividing more\n  //, allowing for near-infinite-zfar within 10000 steps\n  //, because log() is fun like that:\n  \n  //the more common logeps looks something like below\n  //and it also works for this spilor-set:\n \n  return log(c*c/s/s/1000000.)>0.5  \n  //something like this one\n  //it is NOT used HERE, because it requires +1 division, and thats not needed for spinor\n  //and the 2 constants are more arbitiary than it seems.\n  \n  //I generally propose a logeps-exit-condition like\n  //return log(c*c*c/s/s/100000000000.)>0.\n  //at the cost of quite a LOT of divisions and being cubic-by-distance , and dividing by a large number, this may fail in 16bit.\n  //but it keeps gettign more exponential within the log() and larger numbers tend to be bad for nearby precision\n \n  //in summary, the later 2 are better for VERY large zFar (almost-to-scale planetary systems fit in this)\n  //and much less distorted fields.\n  //and the upper ones are better for more distorted fields, but lower zFar max distances.\n  //the lower-distance-ones generally need less divisions (and mults) to work, so they tend to perform better \n  //(also for having a lower zFar bound, like its 90s gaming with a close fog)\n ;}\n//some very-long-distance-logeps variants dared to also log(NumberOfSteps), but this had very few use cases (solar systems too scale)\n//, and other issues of precision long before overstepping.\n\n//logeps() marching trough a tensor\n//this gets trickier to eak, as the strong tensor twist really pushes\n//lipschitz continuity to its limits\n//my assertion, that lobeps() is a better choice within high lipschitz values\n//parely passes, but it passes.\nfloat march(inout vec3 pos, inout vec3 dir       \n){\n #ifdef doLogEps\n ;float s=getDist(pos)//distance to surface (with backwards compatibility\n //;float s=0.          //distance to surface (logeps only, no linear-marching-compatibility)\n ;float c=0.          //distance to camera\n ;vec3 p=pos//+1.*dir\n //pos//+1.*dir is optional zNear, logeps is a bit bad when camera is close to a wall\n //, this is easily avoided\n //logeps() shines in LONG distances, not as much in short distances (within large lipschitz)\n //i have plans for a [logNeps], which should be better ingeneral average fractals\n ;for(float i=0.;i<1000.;i++ //logeps is fine with 4x as many iterations, it unlikely needs half of them.\n ){if(logEps(c,s))return c\n //this replaces the exit condition of raymarching that is if(distanceToSurface <0.01)...)\n //and more modern versions also care for how long the most recent marched distance is\n ;s=getDist(p)\n  ;c+=s*.15 //due to EXTREME distortions, we need lots of understepping\n  //this is fine, logeps is fine with this, lobeps only oversteps with larger distance2camera.\n  ;p=pos+dir*c\n  \n #else\n ;float eps = .0001\n ;float mat=-1.\n ;for(int i=0;i<250;i++\n ){float d=getDist(pos)\n  ;pos+=dir*d*.25 \n   ;if(d<eps)return d\n #endif\n ;}return 0.;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){float camDist=60.\n ;vec3 camDir = vec3(0,1,0)\n ;vec3 dir = normalize(camDir+vec3((fragCoord-.5*iResolution.xy)/iResolution.x,0).xzy)\n ;vec2 ang = vec2(.4,-.2)\n ;if(iMouse.x<.5) ang += vec2(iTime,iTime*.3);\n    ang += iMouse.xy/iResolution.xy*PI2;\n    ROT(ang.y,camDir.yz);\n    ROT(ang.x,camDir.xy);\n    ROT(ang.y,dir.yz);\n    ROT(ang.x,dir.xy);\n    vec3 pos=-camDir*camDist;\n    vec3 camPos = -camDir*10.;\n    float d=march(pos,dir);\n  \n    vec3 n = getDerivative(pos+dir*d,.0001)\n   ;\n    fragColor=vec4(n*.5+.5,1);\n  ;if(d>zFar*.5) fragColor=vec4(.1,.3,.7,1);\n  //logeps() allows for a larger zFar horizon!\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}