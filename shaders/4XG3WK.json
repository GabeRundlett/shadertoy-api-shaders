{
    "Shader": {
        "info": {
            "date": "1718202387",
            "description": "way",
            "flags": 1,
            "hasliked": 0,
            "id": "4XG3WK",
            "likes": 2,
            "name": "cosmic warp tunnel",
            "published": 3,
            "tags": [
                "star",
                "cosmos"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 170
        },
        "renderpass": [
            {
                "code": "/*original https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/tll3zB*/\n\n/*\nwhoever tries to pay off his demons with me, all nations will pay; they will not let him die, \nbut will gnaw at him forever.\nalong with the same demons. \nI will always be glad as God is omnipotent, but not me \n\nas soon as anyone writes something here, let it be so\n\n*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nconst float pi = acos(-1.);\nconst float innerR = 1.;\nconst float outerR = 12.;\n\nfloat globalTime = 0.;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Adapted from IQ's iCappedCone: https://www.shadertoy.com/view/llcfRf\n// Simplified with the assumption that the cone's axis is always the Z axis, and\n// that the caps are not needed.\n// Also, it automatically returns either the near or far intersection depending on\n// the Z order of the endpoints.\nfloat intersectCone( in vec3  ro, in vec3  rd,\n                    in float ra, in float rb,\n                    in float  paz, in float pbz)\n{\n    float ba = pbz - paz;\n    vec3  oa = ro - vec3(0, 0, paz);\n    vec3  ob = ro - vec3(0, 0, pbz);\n\n    float m0 = ba * ba;\n    float m1 = oa.z * ba;\n    float m2 = ob.z * ba;\n    float m3 = rd.z * ba;\n\n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n\n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n\n    float t0 = (-k1-sqrt(h))/k2;\n    float t1 = (-k1+sqrt(h))/k2;\n\n    float y0 = m1 + t0*m3;\n    float y1 = m1 + t1*m3;\n\n    if(paz>pbz)\n        return ( y0>0.0 && y0<m0 ) ? (-k1-sqrt(h))/k2 : -1.;\n    else\n        return ( y1>0.0 && y1<m0 ) ? (-k1+sqrt(h))/k2 : -1.;\n}\n\n\nfloat trace(vec3 ro, vec3 rd, out vec3 nearN, out vec2 nearUV)\n{\n    const int N = 5;\n\n    float minT = 1e4;\n    float outTh0 = 0., outTh1 = 0.;\n\n    float twist = -globalTime / 100.1;\n\n    // Make a torus from cones\n   \n    for(int i = 0; i < N; ++i)\n    {\n        float th0 = pi * 2. / float(N) * float(i + 0) + twist;\n        float th1 = pi * 2. / float(N) * float(i + 1) + twist;\n\n        float z0 = sin(th0) * innerR;\n        float z1 = sin(th1) * innerR;\n\n        float r0 = outerR + cos(th0) * innerR;\n        float r1 = outerR + cos(th1) * innerR;\n\n        float t = intersectCone(ro, rd, r0, r1, z0, z1);\n\n        if(t > 0. && t < minT)\n        {\n            // Save only the pertinent data for later construction\n            // of shading inputs.\n            outTh0 = th0;\n            outTh1 = th1;\n            minT = t;\n        }\n    }\n\n    if(minT > 1e3)\n        return -1.;\n\n    float th0 = outTh0;\n    float th1 = outTh1;\n    float th2 = (th0 + th1) / 2.;\n\n    vec3 rp = ro + rd * minT;\n\n    float phi = atan(rp.y, rp.x);\n\n    // Get the surface differentials and a reference point for texturing\n   \n    vec3 tangent = normalize(vec3(cos(phi) * cos(th1), sin(phi) * cos(th1), sin(th1)) -\n                              vec3(cos(phi) * cos(th0), sin(phi) * cos(th0), sin(th0)));\n\n    float incircleRadius = innerR * cos(pi / float(N));\n\n    vec3 midPoint = vec3(cos(phi) * (outerR + cos(th2) * incircleRadius),\n                         sin(phi) * (outerR + cos(th2) * incircleRadius), sin(th2) * incircleRadius);\n\n    nearUV.x = (phi + pi) / pi * 16.;\n    nearUV.y = dot(rp - midPoint, tangent);\n\n    nearN = vec3(cos(phi) * cos(th2), sin(phi) * cos(th2), sin(th2));\n\n    return minT;\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\n\nvec4 render(vec2 fragCoord)\n{    \n    vec4 jitter = texelFetch(iChannel0, ivec2(fragCoord * 2.) & 1023, 0);\n\n    // Motion blur jitter\n    globalTime = -iTime + jitter.x * 1. / 50.;\n   \n    jitter = jitter.yzxw;\n\n    // Set up primary ray, including ray differentials\n\n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\np.xy*=mat2(cos(iTime*5.), sin(iTime*5.), - sin(iTime*5.),cos(iTime*5.));\n    vec3 ro = vec3(outerR, sin(globalTime *10.) * .3, cos(globalTime *10.) * .3);\n    vec3 rd = normalize(vec3(p, -1.5));\n     \n    // Rotation transformation. There is no translation here, because the tunnel\n    // motion is faked with texture scrolling.\n\n    mat3 m = rotZ(globalTime / 2.) * rotX(cos(globalTime / 4.) * .2) * rotY(sin(globalTime / 3.) * .2);\n\n    m = rotX(pi/2.)*m;\n\n    rd = m * rd;\n\n    vec3 nearN = vec3(0);\n    vec2 nearUV = vec2(0);\n\n    vec3 transfer = vec3(1);    \n    vec4 fragColor = vec4(0);\n\n    // Trace ray bounces\n    for(int j = 0; j < 3; ++j)\n    {\n        float t0 = trace(ro, rd, nearN, nearUV);\n\n        if(t0 < 0.)\n            break;\n\n        vec3 rp = ro + rd * t0;\n\n        vec3 c = vec3(0);\n\n        // Fake motion-blurred camera motion by blurring the\n        // surface shading. Note that the non-jittered time value\n        // is used here as a base time for the blur offset.\n       \n        const int motionBlurSamples = 5;\n\n        for(int i = 0; i < motionBlurSamples; ++i)\n        {\n            // Tunnel surface shading\n            float time = iTime*1.05 + (float(i) + jitter.x) / float(motionBlurSamples) * (1. / 60.);\n            vec2 uv = nearUV;\n           \n             uv.x += time * 15.1;\n            c += vec3(pow(1. - smoothstep(0.1, .4, length(fract(uv + vec2(.25, .5)) - .5)),8.)) * vec3(.3, .5, 1.) * 2.;\n            c += vec3(1. - smoothstep(0.1, .11, length(fract(uv + vec2(.25, .5)) - .5))) * vec3(.3, .5, 1.) * 4.;\n            c += vec3(step(.9, fract(uv.x - .3))) / 2. * vec3(.4, .4, 1.) * 3.;\n            c += vec3(step(.95, fract(uv.x - .3))) / 2. * vec3(.4, .4, 1.) * 6.;\n           \n            c += step(abs(uv.x), .01) * 1.5;\n            c += step(abs(uv.x - .5), .01) * 1.5;\n        }\n\n        c /= float(motionBlurSamples);\n\n        // Fog\n        c = mix(vec3(1) * vec3(.5,.5,1), c, exp2(-t0 / 13.));\n\n        // Tint\n        c *= vec3(.6, .6, 1) / 1.3;\n\n        // Accumulate\n        fragColor.rgb += c * transfer;\n       \n        // Reflection amount\n        transfer *= .8 * pow(clamp(1. - dot(-nearN, -rd), 0., 1.), 4.);\n\n        if(max(max(transfer.x, transfer.y), transfer.z) < 1e-3)\n            break;\n       \n        // Reflect\n        ro = rp + nearN * 1e-4;\n        rd = reflect(rd, nearN);\n\n        jitter = jitter.yzxw;\n    }\n\n    fragColor.a = 1.;\n\n    return fragColor;\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01));// the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\n\na*=a*a; // add contrast\nif (r>6) fade*=1.1; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\n\nvec4 fragColor2 = vec4(0);\n\n    vec3 backg = vec3(.07);\n\n    // Anti-aliasing loop\n\n    for(int y = 0; y < 2; ++y)\n        for(int x = 0; x < 2; ++x)\n        {\n            vec4 r = render(fragCoord + vec2(x,y) / 2.);\n            r.rgb = mix(backg, r.rgb, r.a);\n            fragColor2.rgb += clamp(r.rgb, 0., 1.);\n        }\n\n    fragColor2 /= 4.;\n\n// Tonemap and \"colourgrade\"\n   \n    fragColor /= (fragColor + .4) / 1.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1,1.4,1.8));\n\n    // Gamma correction\n   \n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n    fragColor.a = 1.;\nvec3 from=vec3(1.,.5,0.5)*fragColor2.xyz ;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=fragColor2;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}