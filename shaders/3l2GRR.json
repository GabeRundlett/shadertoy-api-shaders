{
    "Shader": {
        "info": {
            "date": "1558782838",
            "description": "Click on the images to change the focus location.\nFrom left to right, top to bottom: source frame, blurred + distorted image (ready for encoding + transfer), undistorted image, sharpened image (ready to be displayed).",
            "flags": 32,
            "hasliked": 0,
            "id": "3l2GRR",
            "likes": 4,
            "name": "Foveated rendering for VR",
            "published": 3,
            "tags": [
                "rendering",
                "vr",
                "foveated"
            ],
            "usePreview": 0,
            "username": "zarik5",
            "viewed": 1637
        },
        "renderpass": [
            {
                "code": "// MIT License\n//\n// Copyright (c) 2019 Riccardo Zaglia\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\n// Image: Composition for demonstraton\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv3 = 2. * fragCoord / iResolution.xy;\n    vec2 uv4 = uv3 - vec2(1,0);\n    vec2 uv1 = uv3 - vec2(0,1);\n    vec2 uv2 = (uv3 - vec2(1,1)) / \n        (GetOptimalDistortedResolution(focusPosition, iResolution.xy) / iResolution.xy);\n    \n    if (uv3.x < 1. && uv3.y < 1.) {\n        fragColor = texture(iChannel2, uv3);\n    } else if (uv4.y < 1.) {\n        fragColor = texture(iChannel3, uv4);\n    } else if (uv1.x < 1.) {\n        fragColor = texture(iChannel0, uv1);\n    } else {\n        if (uv2.x < 1. && uv2.y < 1.) {\n            fragColor = texture(iChannel1, uv2);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// MIT License\n//\n// Copyright (c) 2019 Riccardo Zaglia\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\n// Buffer A: Gaussian blur X axis\n\n#define uv (fragCoord/iResolution.xy)\n#define sourceSampler iChannel0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float MIN_OFFSET_X = 1. / UNDISTORTED_WIDTH;\n    \n    float blurWeight = GetFilteringWeight(uv, focusPosition, UNDISTORTED_WIDTH, DISTORTED_WIDTH);\n    \n    vec3 colorSum = vec3(0);\n    float weightSum = 0.;\n    for (int x = -KERNEL_HALF_SIZE; x <= KERNEL_HALF_SIZE; x++) {\n        float dX = float(x);\n        float weight = UnscaledGaussian(dX, BLUR_STRENGTH * blurWeight);\n        weightSum += weight;\n        colorSum += weight * texture(sourceSampler, uv + vec2(dX * MIN_OFFSET_X, 0.)).rgb;\n    }\n    vec3 finalColor = colorSum / weightSum;\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// MIT License\n//\n// Copyright (c) 2019 Riccardo Zaglia\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\n// Buffer B: Gaussian blur Y axis + distort\n\n#define uv (fragCoord/iResolution.xy)\n#define blurredSampler iChannel0\n//IMPORTANT: Use trilinear (not anisotropic) mipmaps for blurredSampler.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float MIN_OFFSET_Y = 1. / UNDISTORTED_HEIGHT;\n    \n    vec2 dUV = Distort(uv, focusPosition);\n    \n    float blurWeight = GetFilteringWeight(dUV, focusPosition, UNDISTORTED_HEIGHT, DISTORTED_HEIGHT);\n    \n    vec3 colorSum = vec3(0);\n    float weightSum = 0.;\n    for (int y = -KERNEL_HALF_SIZE; y <= KERNEL_HALF_SIZE; y++) {\n        float dY = float(y);\n        float weight = UnscaledGaussian(dY, BLUR_STRENGTH * blurWeight);\n        weightSum += weight;\n        colorSum += weight * texture(blurredSampler, dUV + vec2(0., dY * MIN_OFFSET_Y)).rgb;\n    }\n    vec3 finalColor = colorSum / weightSum;\n    \n    // uncomment the bound check to show the distorted image bounds:\n    \n    //if (dUV.x > 0. && dUV.x < 1. && dUV.y > 0. && dUV.y < 1.)\n        fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// MIT License\n//\n// Copyright (c) 2019 Riccardo Zaglia\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\n// Define the aspect ratio of the foveated region. Values > 1 means less distortion.\n// Given R=width/height of the source frame, use (1. / R, 1.) for tracked foveated rendering.\n// For fixed foveated rendering, since the eye tend to move more horizontally than vertically,\n// use values around (2. / R, 1.) to give more resolution along x axis.\nconst vec2 FOV_REGION_SCALE = vec2(1.5 / (16. / 9.), 1.);\n\n\nfloat atanDerivative(float a) {\n    return 1. / (a * a + 1.);\n}\n\nfloat tanhDerivative(float a) {\n    float tanh_a = tanh(a);\n    return 1. - tanh_a * tanh_a;\n}\n\n// stddev: square root of diagonal of covariance matrix\n//float UnscaledBivariateGaussian(vec2 x, vec2 stddev) {\n//    return exp(-dot(x / (2. * stddev * stddev), x));\n//}\n\nfloat UnscaledGaussian(float a, float stddev) {\n    return exp(-a * a / (2. * stddev * stddev));\n}\n\n//Choose one distortion function:\n\n// ARCTANGENT: good for fixed foveated rendering\nconst float EPS = 0.0001;\n#define distortion_fn(a)           tan(a)\n#define inverse_distortion_fn(a)   atan(a)\n#define inv_dist_derivative(a)     atanDerivative(a)\n#define DISTORTION_STRENGTH        5.\n\n// HYPERBOLIC TANGENT: good compression but the periphery is too squished\n//const float EPS = 0.0001;\n//#define distortion_fn(a)           atanh(a)\n//#define inverse_distortion_fn(a)   tanh(a)\n//#define inv_dist_derivative(a)     tanhDerivative(a)\n//#define DISTORTION_STRENGTH        3.\n\n// POW: good for tracked foveated rendering\nconst float POWER = 4.;\n//const float EPS = 0.01;\n//#define distortion_fn(a)           pow(a, POWER)\n//#define inverse_distortion_fn(a)   pow(a, 1. / POWER)\n//#define inv_dist_derivative(a)     (pow(a, 1. / POWER - 1.) / POWER)\n//#define DISTORTION_STRENGTH        1.\n// for pow(), DISTORTION_STRENGTH does not have any effect, use POWER to change the distortion strength\n\n// Other functions for distortion:\n// https://en.wikipedia.org/wiki/Sigmoid_function\n\n\nvec2 RadialDistortion(vec2 xy) {\n    float radius = length(xy);\n    return (distortion_fn(radius) * xy / radius) * FOV_REGION_SCALE / DISTORTION_STRENGTH;\n}\n\nvec2 InverseRadialDistortion(vec2 xy) {\n    vec2 scaledXY = xy * DISTORTION_STRENGTH / FOV_REGION_SCALE;\n    float scaledRadius = length(scaledXY);\n    return inverse_distortion_fn(scaledRadius) * scaledXY / scaledRadius;\n}\n\n// Inverse radial distortion derivative wrt length(xy)\nvec2 InverseRadialDistortionDerivative(vec2 xy) {\n    vec2 scaledXY = xy * DISTORTION_STRENGTH / FOV_REGION_SCALE;\n    float scaledRadius = length(scaledXY);\n    return (inv_dist_derivative(scaledRadius) * DISTORTION_STRENGTH / FOV_REGION_SCALE) * \n        scaledXY / scaledRadius;\n}\n\nvec2 GetBoundStart(vec2 focusPos) {\n    vec2 scaledCenter = -focusPos;\n    return vec2(InverseRadialDistortion(vec2(scaledCenter.x, 0.)).x,\n                InverseRadialDistortion(vec2(0., scaledCenter.y)).y);\n}\n\nvec2 GetBoundEnd(vec2 focusPos) {\n    vec2 scaledCenter = 1. - focusPos;\n    return vec2(InverseRadialDistortion(vec2(scaledCenter.x, 0.)).x,\n                InverseRadialDistortion(vec2(0., scaledCenter.y)).y);\n}\n\nvec2 GetDistortedSize(vec2 focusPos) {\n    return GetBoundEnd(focusPos) - GetBoundStart(focusPos);\n}\n\nvec2 Distort(vec2 uv, vec2 focusPos) {\n    // the bounds can be calculated on the CPU\n    vec2 boundStart = GetBoundStart(focusPos);\n    vec2 distortedSize = GetDistortedSize(focusPos);\n    \n    return (RadialDistortion(uv * distortedSize + boundStart)) + focusPos;\n}\n\nvec2 Undistort(vec2 uv, vec2 focusPos) {\n    vec2 boundStart = GetBoundStart(focusPos);\n    vec2 distortedSize = GetDistortedSize(focusPos);\n\n    return (InverseRadialDistortion(uv - focusPos) - boundStart) / distortedSize;\n}\n\n// Undistort radial derivative\nvec2 UndistortDerivative(vec2 uv, vec2 focusPos) {\n    vec2 distortedSize = GetDistortedSize(focusPos);\n    \n    return InverseRadialDistortionDerivative(uv - focusPos) / distortedSize;\n}\n\nfloat GetFilteringWeight(vec2 uv, vec2 focusPos, float targetDimension, float optimizedDimension) {\n    float radialExpansion = length(UndistortDerivative(uv, focusPos));\n    float resScale = targetDimension / optimizedDimension;\n    float contraction = 1. / (radialExpansion * resScale);\n    \n    float modifiedContraction = contraction - 1. / contraction; // -> ?\n    \n    return max(modifiedContraction, EPS);\n}\n\nvec2 GetFilteringWeight2D(vec2 uv, vec2 focusPos, vec2 targetResolution, vec2 optimizedResolution) {\n    float radialExpansion = length(UndistortDerivative(uv, focusPos));\n    vec2 resScale = targetResolution / optimizedResolution;\n    vec2 contraction = 1. / (radialExpansion * resScale);\n    \n    vec2 modifiedContraction = contraction - 1. / contraction; // -> ?\n    \n    return max(modifiedContraction, EPS);\n}\n\n// Use this method (on the CPU) to compute the optimal render target resolution for the distorted image.\n// With optimal I mean that the foveated region remains non compressed and non distorted.\n// If the render target resolution cannot be modified at runtime, always use (0.5, 0.5) for focusPos.\nvec2 GetOptimalDistortedResolution(vec2 focusPos, vec2 sourceResolution) {\n    vec2 gradientOnFocus = vec2(UndistortDerivative(focusPos + vec2(EPS, 0.), focusPos).x,\n                                UndistortDerivative(focusPos + vec2(0., EPS), focusPos).y);\n    return sourceResolution / gradientOnFocus;\n}\n\n\n// Please convert these to uniform or constants:\n#define focusPosition mod(2. * (iMouse.xy + 1.) / iResolution.xy, 1.)\n#define UNDISTORTED_WIDTH (iResolution.x / 2.)\n#define UNDISTORTED_HEIGHT (iResolution.y / 2.)\n#define DISTORTED_WIDTH (iResolution.x / 2.)\n#define DISTORTED_HEIGHT (iResolution.y / 2.)\n\nconst float BLUR_STRENGTH = 0.4; // should be small, mipmaps already create blur\nconst int KERNEL_HALF_SIZE = 4;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// MIT License\n//\n// Copyright (c) 2019 Riccardo Zaglia\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\n// Buffer C: Undistort\n\n#define uv (fragCoord/iResolution.xy)\n#define distortedSampler iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 dUV = Undistort(uv, focusPosition);\n    fragColor = texture(distortedSampler, dUV);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// MIT License\n//\n// Copyright (c) 2019 Riccardo Zaglia\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\n// Buffer D: Sharpening\n\n#define uv (fragCoord/iResolution.xy)\n#define blurredSampler iChannel0\n\nconst float SHARPEN_STRENGTH = 0.5;\n//                    [ 0 -1  0 ]\n// sharpening kernel: [-1  5 -1 ]\n//                    [ 0 -1  0 ]\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sharpenWeight = GetFilteringWeight2D(uv, focusPosition, vec2(UNDISTORTED_WIDTH, UNDISTORTED_HEIGHT),\n                                            vec2(DISTORTED_WIDTH, DISTORTED_HEIGHT));\n    float deltaX = 1. / UNDISTORTED_WIDTH * sharpenWeight.x * SHARPEN_STRENGTH;\n    float deltaY = 1. / UNDISTORTED_HEIGHT * sharpenWeight.y * SHARPEN_STRENGTH;\n    \n    vec3 currentColor = texture(blurredSampler, uv).rgb;\n    vec3 leftColor = texture(blurredSampler, uv - vec2(deltaX, 0.)).rgb;\n    vec3 rightColor = texture(blurredSampler, uv + vec2(deltaX, 0.)).rgb;\n    vec3 downColor = texture(blurredSampler, uv - vec2(0., deltaY)).rgb;\n    vec3 upColor = texture(blurredSampler, uv + vec2(0., deltaY)).rgb;\n    \n    vec3 finalColor = 5. * currentColor + -1. * (leftColor + rightColor + downColor + upColor);\n    \n    fragColor = vec4(finalColor,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}