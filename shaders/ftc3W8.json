{
    "Shader": {
        "info": {
            "date": "1636040879",
            "description": "My second ever shader! Recreating an old project I made with DOS graphics when I was learning about matrices and orthographic projection.\nTips on how to improve it very much appreciated",
            "flags": 0,
            "hasliked": 0,
            "id": "ftc3W8",
            "likes": 4,
            "name": "Spinning Cube",
            "published": 3,
            "tags": [
                "cube",
                "beginner",
                "orthographic"
            ],
            "usePreview": 0,
            "username": "LargeBee",
            "viewed": 357
        },
        "renderpass": [
            {
                "code": "/*\n    Borrowed from https://www.shadertoy.com/view/MlcGDB\n    uv Normalized coordinates from main func\n    p1 Position 1 to draw the line from\n    p2 Position 2 to draw the line to\n    t  Thickness of the line\n*/\nfloat line(vec2 uv, vec2 p1, vec2 p2, float t) \n{\n    vec2 g = p2 - p1;\n    vec2 h = uv - p1;\n    t /= iResolution.y;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(t, 0.5*t, d);\n}\n\nmat3 rotationZ(float angle)\n{\n    return mat3(\n        cos(angle),-sin(angle),0,\n        sin(angle),cos(angle),0,\n        0,0,0\n    );\n}\n\nmat3 rotationY(float angle)\n{\n    return mat3(\n        cos(angle),0,sin(angle),\n        0,1,0,\n        -sin(angle),0,cos(angle)\n    );\n}\n\nmat3 rotationX(float angle)\n{\n    return mat3(\n        1,0,0,\n        0,cos(angle),sin(angle),\n        0,-sin(angle),cos(angle)\n    );\n}\n\nmat3 scaler(float scale)\n{\n    return mat3(\n        scale,0,0,\n        0,scale,0,\n        0,0,scale\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    //Define set of points\n    vec3 points[] = vec3[](\n    vec3(-1.0,-1.0,-1.0),   //Corner 0\n    vec3(1.0,-1.0,-1.0),    //Corner 1\n\n    vec3(1.0,1.0,-1.0),     //Corner 2\n    vec3(-1.0,1.0,-1.0),    //Corner 3\n\n    vec3(-1.0,-1.0,1.0),    //Corner 4\n    vec3(1.0,-1.0,1.0),     //Corner 5\n    \n    vec3(1.0,1.0,1.0),      //Corner 6\n    vec3(-1.0,1.0,1.0)      //Corner 7\n    );\n\n    ivec2 edges[] = ivec2[](\n        ivec2(0, 1),\n        ivec2(0, 3),\n        ivec2(0, 4),\n        ivec2(1, 2),\n        ivec2(1, 5),\n        ivec2(2, 3),\n        ivec2(2, 6),\n        ivec2(3, 7),\n        ivec2(4, 5),\n        ivec2(4, 7),\n        ivec2(5, 6),\n        ivec2(6, 7)\n    );\n\n    float angle = iTime; //Modify?\n    float scale = 0.5;\n\n    //rotate and project points with matrix maths and use time as angle\n    vec3 outPoints;\n    vec2 projectedPoints[points.length()];\n    for (int i = 0; i < points.length(); ++i)\n    {\n        outPoints = points[i];\n        outPoints *= rotationY(angle)\n                * rotationX(angle)\n                * scaler(scale);\n        \n        projectedPoints[i] = vec2(outPoints.xy);\n    }\n    \n    float colOut = 0.0;\n    bool valid;\n    //Add lines to output value\n    for (int i = 0; i < edges.length(); ++i)\n    {\n        colOut += line(\n            uv, \n            projectedPoints[edges[i].x].xy, \n            projectedPoints[edges[i].y].xy, \n            4.0\n        );\n    }\n\n    const vec3 backColour  = vec3(0.3);\n    const vec3 lineColour = vec3(0.35,0.95,0.51);\n    \n    vec3 colour = mix(backColour, lineColour, colOut);\n    //Output colour per pixel\n    fragColor = vec4(colour, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}