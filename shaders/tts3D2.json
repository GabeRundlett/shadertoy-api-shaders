{
    "Shader": {
        "info": {
            "date": "1557784035",
            "description": "commontab lets you set the WallpaperGroup entry with an enum. \n\nmouse.xy sets rectangle size of  P3m1 wallpaper with barycentzric TileID\n\nIt oscilaltes  over time between hex and rect\niMouse.xy sets cectangle size.\ncolors arebarycentricTileIDs, ...",
            "flags": 0,
            "hasliked": 0,
            "id": "tts3D2",
            "likes": 5,
            "name": "Wallpaper Group 17 enumerated",
            "published": 3,
            "tags": [
                "barycentric",
                "wallpapergroup",
                "wallpapergroup",
                "p3m1"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "//[WallpalerType] in the commontab has the constant\n//sets the type of the wallpapergroup-entry\n\n//this uses barycentric coordinates for 2 reasons\n//- some tilings only work in carthesian-triangles, some only in carthesian-rectangles, most work in both.\n//  ... and barycentric almost unifies all of them.\n//- free skew (adds confusing carthesian-transformation to those that dont work in triangles AND rectangles)\n\n//craziest subroutine i wrote so far! (likely for no good reason, theres other shaders that did this better, (by not doing this in barycentric coordinates?))\nfloat subWeabeBarycentricToHex(vec3 b){\n ;vec3 m=fract(floor(b)/2.)*2.\n ;vec3 v=floor(2.-mod(b+1.,3.))\n ;vec3 w=floor(2.-mod(b+2.,3.))\n ;vec3 mimaX=vec3( mi(w.yz)\n                 ,-ma(v.yz)\n                 ,-ma(w.yz))\n ;float x0=1.-m.x \n ;b=mod(floor(b),3.)\n ;vec2 x14=mix(vec2(m.x,1.-m.x),vec2(0),float(b.x!=2.||mimaX.x<0.))\n ;vec2 x52=mix(vec2(m.x,1.-m.x),vec2(0),float(b.x!=1.||mimaX.y<0.))\n ;vec2 x36=mix(vec2(m.x,1.-m.x),vec2(0),float(b.x!=0.||mimaX.z<0.))\n ;x0=ad(x14)+ad(x52)+ad(x36)\n ;return x0;}\n\nvec3 TileIdMod6(vec3 b//input is barycentric TileID\n){float x0=subWeabeBarycentricToHex(b) \n ;float y0=subWeabeBarycentricToHex(b+vec3(0,1,0))\n ;float z0=subWeabeBarycentricToHex(b+vec3(0,0,1))//i guessed right for once!\n ;return vec3(x0,y0,z0);}\n\nfloat tileRot(vec3 a\n){float r=0.\n ;r=dot(a,vec3(3,2,1))\n ;if(abs(r-3.)==1.\n ){return (8.-1.5*r)/6.;}\n ;return mix(r,4.,step(5.,r))/6.;}\n\n//p1base shape is a subroutine to 11 wallpaper-group-entries.\n//its inputs are likely barycentric, allowing for the skew.\nvec3 p1base(vec3 c,vec2 n0,vec2 n1,vec2 n2,vec3 tU){\n ;c.xz=b2c(tU,n2,n1,n0)-(n0+n1+n2)*.5 //b2c == barycentricToCartesian()\n ;return c;}\n\n//this function seens uite convoluted, not just from its compression.\n//as it finishes 7 different wallpaper-grup entries, AFTER having called p1base()\nvec3 p1sets(float a,vec3 m,vec3 c\n){/* \np1   0  //2d modulo\npggF 1  //half rotation along .y\np4   2  //quater rotation along .y + .x\npg   3  //mirror at .y  is NOT pg\npmm  4  //mirror at .y  + .x\ncm   5  //mirror .y at .y and .x\npmg  6  //mirror at .y, half rotate at .x \n */\n ;if(a==1.)return c  //do nothing \n ;if(a==0.\n ){if(m.y>0.)c.x=-c.x;\n  }else{\n   ;if(a>3.\n   ){if(a<6.\n    ){if(m.y>0.)c.z=-c.z\n   ;}else{ if(m.y!=m.z)c.z=-c.z;} \n   ;if(mod(a,2.)>0.&&m.z>0.)c.x=-c.x   \n   ;return c\n   ;\n  ;}else{ \n   ;if(a>1. \n   ){if(m.y>0.)c.xz=-c.xz;}   // ,half rotation  .y==half rotation  .x\n   ;if(mod(a,2.)>0.){if(m.y+m.z==1.)c.xz=c.zx*vec2(-1,1)\n ;}}};return c;}\n\n\n//skewable walpaper with barycentric tileId \n//a; 0=cmm 1=pgg 2=p4g 3=p4m\nvec3 crosseds(float a,vec3 m,vec3 c,float split\n){//4 wallpaperGroup patters with a diagonal cross (and 1 carthrsian) in them\n  //that only make sense in rectangular tiling\n    ;if(a>1.){\n        if(a>2.){\n            ;if(m.y+m.z==1.){c.x=-c.x;if(split>0.)c.xz=-c.zx;}//is p4m\n            ;if(m.y>0.)c.xz=c.zx \n            ;if(m.z>0.)c.z=c.z//end of p4m  */   \n   ;}else{            \n            ;if(m.y+m.z==1.//is p4g\n            ){c.xz=c.zx*vec2(1,-1)\n             ;if(split>0.)c.xz=-c.zx;}\n            ;if(m.y>0.)c.xz=c.zx \n            ;if(m.z>0.)c.z=c.z//end of p4g  */\n  ;}}else if(a>0.){\n            ;if(m.y+m.z==1.  //is pgg  (uv coords and tileID are NOT merged)\n            ){if(m.y>0.\n            ){c.xz=c.zx\n             ;if(split>0.)c.xz=-c.zx\n             ;else        c.xz= c.zx\n            ;}else{;if(split>0.)c.xz=-c.xz ;}\n              ;}else if(m.x>0.)c.xz=c.zx//end of pgg \n   ;}else{           \n            ;if (m.y+m.z==1. //is cmm   \n            ){if(m.y>0.\n             ){if(split<1.) c.xz=c.zx\n              ;}else{\n                ;if(split>0.)c.xz=-c.zx  \n                ;else        c.xz=-c.xz;}\n            ;}else if(m.y>0.)c.xz=c.zx//end of cmm\n     ;}return c;}\n\nfloat crossprecalc(vec3 b\n                   ,inout vec3 c\n                   ,vec2 n0,vec2 n1,vec2 n2\n                   ,float od\n                   ,vec3 tU\n                   ,vec3 m\n               ,inout vec3 ciD){\n ;float split=(float((c.z*n0.x/n1.y>=c.x)))\n ;if(m.y+m.z==1.\n ){split=floor(split)\n  ;if(split>0.)  b.x-=m.x   \n  ;else          b.x-=m.x+1.\n  ;if(split>0.)  c.xz+=(n0-n1)/6.\n  ;else          c.xz-=(n0-n1)/6.\n ;}else{\n  ;c.xz=b2c(tU-1./3.,n2,n1,n0)//p2 base shape (step1 of 1)\n  ;if(od>0.)c.xz=c.zx;}\n    ;ciD=fract(floor(b)*mix(2./1.,1./32.,cos(iTime*.2)*.5+.5))//https://www.shadertoy.com/view/ttlGDj\n      \n    ;return split   ;}\n\n\n\n//this function returns wallaper groups  p1, p3m1 p3 p6 p31m p6m\n//note to self, p2eds() serems to be incompletely implemented.\nvec3 p2eds(float a,vec3 c,inout vec2 n0\n           ,inout vec2 n1\n           ,inout vec2 n2,inout vec3 tU,bool odd,float tIR\n){    \n      ;if(odd)tU=1.-tU            //p2 base shape (step0 of 1)\n  ;c.xz=b2c(tU-1./3.,n2,n1,n0)//p2 base shape (step1 of 1)\n  ;if(odd)c.xz=-c.xz\n  ;c.xz*=-r2(-tIR*pi*2.)//toggle from p2 to p3m1 (should be hex)\n  ;//if(odd)c.xz=-c.xz    //toggle from p2 to p1 (sliced) \n  ;//if(odd)c.x=-c.x      //toggle from p2 to pm (diagonal) \n  ;//if(odd)c.z=-c.z      //toggle from p2 to pm (horizontal) \n  ;//if(odd)c.xz=c.zx     //toggle from p2 to cm \n     //p2\n     //\n    /*\n ;if(a==0.)p2\n ;if(a==1.)p3m1\n ;if(a==2.)p3\n ;if(a==3.)p6\n ;if(a==4.)p31m\n ;if(a==5.)p6m   */\n ;return c;}\n\nvoid mainImage( out vec4 o, vec2 u\n){float t=iTime\n ;vec3 r=iResolution\n ;vec4 m=iMouse\n ;m.xy=fra(t,m.xy,r,m) \n\n ;vec3 c=vec3(0,1,0)\n ;if(iMouse.z<=0.)m.xy=(cs(iTime*vec2(sqrt(2.),.61))+1.)*2. //cs(iTime)*2.-.5\n #if 0\n ;m.y=.5\n #endif\n ;m=abs(m)\n ;u=fra(t,u,r,m) //(u-r.xy/2.)/r.y\n ;vec4 co=alienGlyph(u,r,m)\n ;//[co] is a a white-rectangle frame \n //for direct feedback frameOfReference for mouse input\n ;co=ss(r,1.,co)\n ;co.x=max(co.x,co.z)\n ;co=co.xxxx*2.\n ;float s=0.\n #ifdef Oscillate\n ;s   =mix(1.    ,0.  ,-cos(iTime)*.5+.5)\n ;//m.xy=mix(m.xy,m.yx,.5)//square of averaging rectangle lengths\n ;//m.xy=m.yy//square of averaging rectangle height\n ;m.xy=mix(m.yy,m.xy,-cos(iTime)*.5+.5)\n #endif\n ;//below 2 lines override UI input to simpler and more symmetric cases.\n ;//m.xy=vec2(1)//override to square (or hex)  \n ;//s=-.5//skew square to hex\n #ifdef overrideSkew\n ;s=overrideSkew\n ;//m.xy=mix(m.xy,m.yx,.5)//square of averaging rectangle lengths\n ;m.xy=m.yy//square of averaging rectangle height\n #endif\n  \n ;vec2 n0=vec2(m.x,0  )//n0,n1,n2 are triangle corners\n ;vec2 n1=vec2(0  ,m.y)\n ;vec2 n2=vec2(0  ,  0)\n ;n0=mix(n0,skew(n0),s)//skew by [s]\n ;n1=mix(n1,skew(n1),s)\n ;n2=mix(n2,skew(n2),s)//multiplies by vec2(0)\n ;vec3 b=c2b(u,n2,n1,n0)//carthesian to barycentric coordinates.\n ;vec3 tID=floor(b)//triangleID (barycentric)\n ;bool odd=(dd(fract(b))>1.)//common property\n ;tID=vec3(TileIdMod6(b))//fract(tID/2.)*2.                  //only for hex-exclusives\n ;float tIR=tileRot(tID)//i made this one way too complicated//only for hex-exclusives\n ;vec3 ciD=fract(floor(b)*mix(2./1.,1./32.,cos(iTime*.2)*.5+.5))//https://www.shadertoy.com/view/ttlGDj\n //;tID=fract(tID*mix(2./1.,1./32.,cos(iTime*.2)*.5+.5))\n ;if(true//u.y<.2*ViewZoom\n ){//lower screen shows UV space\n  ;vec3 tU=fract(b)\n  ;//if(odd){tU=1.-tU;}\n  ;c=tU\n  ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.)))//wiggly j-shape proportions\n  ;float a=float(WallpalerType)     \n  ;bool bo=(3.<a\n      //BoundOr((a-4.),8.,>) //             )\n      &&odd)\n  ;if(odd)tU=1.-tU  \n      \n  ;if(a>11.){ \n          ;if(odd)tU=1.-tU  \n          ;c=p2eds(a-11.,c,n0,n1,n2,tU,odd,tIR)   \n          //p2eds() returns wallaper groups; p1, p3m1 p3 p6 p31m p6m\n ;}else if (a<12.\n  ){if(a>3.&&odd)tU=1.-tU  \n   ;c=p1base(c,n0,n1,n2,tU)//p1base() is a subroutine, shared by a lot of wallpaper-group-entries.\n   ;vec3 mm=mod(floor(b),vec3(2.))\n   ;if(a<4.\n   ){//4 cross shapes need to flip IDS in each odd tile.\n    ;float od=float(odd)\n    ;c.xz=mix(-c.xz,c.xz,step(od,.0))  //;if(odd)c.xz=-c.xz\n\n    ;float split=crossprecalc(b,c,n0,n1,n2,od,tU,mm,ciD)\n    ;c=crosseds(a,mm,c,split)\n      //0=cmm \n      //1=pgg \n      //2=p4g  \n      //3=p4m\n  ;}else{\n   //;vec3 m=mod(floor(b),vec3(2.))\n   ;c=p1sets(a-4.,mm,c)\n   ;//0+4=p1           //cmVertical\n   ;//1+4=NAMELESS1 == pggF\n   ;//2+4=pg 3+4=p4 4+4=pm 5+4=pmm 6+4=cm 7+4=pmg\n    \n  ;}\n  }      \n  ;c.y=0.\n  ;//c.xz=c.zx*vec2(1,-1)//quater rotation , rotating ALL tiles does not change any pattern property.\n  ;\n  ;vec4 p=pdAtop(vec4(sat(ciD),1),vec4(sat(smoothFfb(t,c.xz,r,K))))\n  ;c.xyz=mix(vec3(.1),fract(c.xyz),.2)//fract+desaturate+darken uv coords to be less distracting\n  ;c.xyz=pdOver(p,vec4(c.xyz,1)).xyz\n  //;c.xy=mix(c.xy,ciD.xy,smoothFfb(,tc.xz,r,K)) //this sure is no pdOver()\n  //;c.z=max(c.z,(ciD*smoothFfb(c.xz,r,K)).z\n              // ) //this sure is no pdOver()\n    \n      \n\n      \n  ;c.xz=mix(c.xz,fract(c.xz),.7)\n  ;//c.y=smoothFf(c.xz,K)\n  ;//c.xz=(c.xz*.5+.5)\n  \n ;}else{\n   //upper screen shows tileTD \n  ;float f=13.\n  ;c=ciD\n  ;}\n ;o=vec4(c*2.,1)\n\n  //overlay white rectangle\n  ;float wallpaperhue=floor(WallpalerType*.61)/18.\n  //every wallpaper gets its onw hue associated with it.\n  //the NEXT wallpaper in the list is \n  //hue-wheel rotates by the goldenAngle == .61* fullRotation \n  //to makke it less smooth ofer time.\n  ;o=pdOver(vec4(co.x*hsv2rgb(vec3(wallpaperhue,1.,1.)),1.)*.5,o)\n  ;o=pdOver(co*.5,o)\n ;}\n      //this interpolates incorrectly, but possibly only for rectangles!\n   //<-minor ERROR case to fix later\n  //sr also causes [split] to be low precision, even if its a square.\n    //all beflow spthe definition of [split] shows that the precision error is alreaty roo much from components of split\n    //its likely the division\n    //nope, even if i simplify [rs] to nonsense, the DIAGONAL flickers as low precision.\n   //i assert that the c.z is already low precision, and that may get too visible\n    //when we flip it.\n    //unless we keep the shit and rotate locally instead\n    //, which seems to be the long run to do shit\n    //welp, i tried, and failed, this one is for the history gooks.\n    //i managed to get the error on both sides, and only on one of both sides.\n    //but of course thats all the useless cases\n    //the non error case is always the last you detect.\n    //let me fin ish this and add moee patterns\n      \n  //     ;c.xz=c.zx*vec2(1,-1) //rotating all should not change the patterntype\n  //;c.z=-c.z\n  // ;c.xz=c.zx*vec2(1,-1) //rotating all should not change the patterntype\n  //   ;c.xz=c.zx*vec2(1,-1) //rotating all should not change the patterntype\n  /**/\n\n\n    /*\n\n\n//resolved issue[pggF] used to be named [NAMELESS1]\n//, because pggF is a different way to to pgg\n//in barycentroic coordinates\n//it confues me a lot for 1 month, because in cartheisian coordinates they look different.\n//ONE     frieze-group-pattern in carthesian coordinates   (p1f1)\n//is a wallpaper-Group-pattern in barycentroic coordinates (pggF)\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//set wallpaper type, see list below\n//#define WallpalerType p31m\n//#define WallpalerType 6\n\n//optionally cycle trough them over time\n#define WallpalerType  mod(iTime*.2,18.)\n\n//    there are [1..17] wallpapergroup-entries\n//this one has  [0..17] options, because pggF is identical to pgg\n//                             , just on a 2*larger BARYCENTRIC-lattice\n//#1 pgg + #6 pggF LOOK different in carthesian  coordinates\n//#1 pgg + #6 pggF ARE identical in barycentric coordinates\n\n//compressing all the code puts them into 3 compatibility-groups\n//[ 0.. 3] have a  diagonal mirror & are on a square               lattice\n//[ 4..11] have no diagonal mirror & are on a square OR a triangle lattices\n//[12..17] have no diagonal mirror & are on               triangle lattice\n//because the diagonal mirror of [ 0.. 3] is incompatible with a triangle-lattice (1/6th rotations)\n//because the hexagonal ones     [12..17] only work on         a triangle-lattice (1/6th rotations)\n//\n//the diagonal mirror of cmm+pgg+p4g+p4m is trickyer to address\n//in terms of barycentric coordinates (colors)\n#define cmm   0\n#define pgg   1\n#define p4g   2\n#define p4m   3\n//#6 pggF is pgg, on a larger lattice, I chose to keep this variant\n//#6 is an emergent result of unifying multiple wallpaperTilings\n//#6 is 1/2 ways to produce the same tiling, slightly differently\n//#6 pggF just happens to be a basis transformation function for # [4..11]\n//ideally the pattern for BUT p1 sould be that basis\n//, but my naice crunching resulted in havign 2 variants of pgg here\n#define pm    4  //mirror  .x at .x ???\n#define p1    5  //2d modulo\n#define pggF  6  //half rotate at .y\n#define p4    7  //quater rotation along .y + .x\n#define pg    8  //mirror .y at .y     is NOT pg ,  pg is Glide along .y\n#define pmm   9  //mirror .y at .y and .x at .x\n#define cm   10  //mirror .y at .y and .y at .x\n#define pmg  11  //mirror .y at .y, half rotate at .x \n//above is rectangular latticed , below is hex latticed\n//entries smaller than 12 make more sense in a rectanglular lattice \n//than in a hex lattice\n//entries of 12 and higher have p2() as basis function...\n//...because  [12..17] make  more sense in a hexagonal lattice (third-rotation or sixth-rotation symmetry)\n#define p2   12 \n#define p3m1 13 \n#define p3   14\n#define p6   15\n#define p31m 16\n#define p6m  17\n\n/*\niMouse.xy set rectangle-size\nimouse.y sets equilateral Triangle size.\n\n\n//side node [p2] and [pgg] are identical in every way!\n\nA lot of things change in this shader\nFocus on the few things that are invariant:\n- there is always a black triangle in the center\n- - the black triangle has its f-shape never rotated and never mirrored.\n- every triangle has the same image inside it, never scaled, but mirrored or moved.\n- all triangles always have one backslash diagonal at -45degangle\n- - that diagonal length varies, but all triangles habvve one of those\n- - the other 2 sides of the triangle are ALWAYS the same length.\n\nstep1) pause time (and maybe reset time to 0) and study the symmetry\n- you may want to set ViewZoom() larger to see larger patterns.\n\n\nmouse.xy sets rectangle size of \nP3m1 wallpaper with barycentzric TileID\n\niMouse.xy sets rectangle size.\n, but It oscilaltes over time between hex and rect\ncolors arebarycentricTileIDs\n,they show that triangles can be addressed by \n- 3 coordinates.xyz (barycentric) or by \n- 2 coordinates.xy and 1 boolean (parity)\n- - the black tile in the center has all coordinate values set to 0.\n- - all other tile coordinates are relative to that.\n- - it has one corner that is always at position vec2(0)\n- - showing coordinates in fract(color*cos(time)) is faster than showing them in digits.\n\nself P31m: https://www.shadertoy.com/view/tts3D2\nroot     : https://www.shadertoy.com/view/ttX3Dj  (all wallpapers)\nparent   : https://www.shadertoy.com/view/4ldyWN  (euler spiral)\nparent   : https://www.shadertoy.com/view/tlsGD2  (beta version)\nparent   : https://www.shadertoy.com/view/Wts3DX  (UI frame)\n*/\n\n//#define doP2\n//#define doP1\n\n//over time oscillate inputs between InputRectangle and UnitSquare\n#define Oscillate\n\n//maybe always skew by .0 or by 1. //undefine oscillate between .0 and .5 \n//#define overrideSkew 1.\n//#define overrideSkew 0.\n\n\n//#define ViewZoom mix(.3,64.,iMouse.x/iResolution.x)\n#define ViewZoom          8.\n\n\n\n\n#define viewZoom(t,u,r,m) ViewZoom\n\n\n//for any check if a is inside or outside of a range, you just need \n#define BoundOr(a,b,c) (abs(b-.5*a)*2. c a)\n#define BoundAnd(a,b,c) (a c abs(b-.5*a)*2. ) \n//with usecase examples:\n//(0.<a&&a<b) === boundAnd(a,b,<) === boundOr (a,b,>=) \n//(0.>a||a>b) === boundOr (a,b,>) === boundAnd(a,b,<=) \n\n/*\nif(0.>a-4.||a-4.>8)\nif(a-4.<0.||a-4.>12.-4.)\nif(a-4.<0.||a-4.>12.-4.)\n*/\n\n\n#define pi acos(-1.)\n//float TAU=6.28318530718;\n//vec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//vec2 p2c(vec2 u){return cs(u.y)*u.x;}\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nmat2 r2(float a){vec2 s=cs(a);return mat2(s,-s.y,s.x);}\n\n\n#define dd(a) dot(a,a)\n\n//#define aA(z) (z/min(iResolution.x,iResolution.y))\n\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n#define aA(t,u,r,m) (1./Aa(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n#define dd(a) dot(a,a)\n\n#define aV(a) aA(a)*ViewZoom*.5\n\n#define oz vec3(1,0,-1)\n#define r2s(r)mat2(sin(r+oz.xyyz*asin(1.)))\n//testable in https://www.shadertoy.com/view/MtKGWD\n\n\n#define ss(r,a,b) smoothstep(a*aA(0,vec2(0),r,vec4(0)),-a*aA(0,vec2(0),r,vec4(0)),b)\n\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n//#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 ad(v3 a){return dot(v3(1),a);}\nv0 ad(v2 a){return dot(v2(1),a);}\nv0 ad(v1 a){return a.x+a.y;}//aka suv()\nv0 ma(v1 a){return max(a.y,a.x);}\nv0 ma(v2 a){return max(a.z,ma(a.xy));}\nv0 ma(v3 a){return max(ma(a.zw),ma(a.xy));}\nv0 mu(v1 a){return a.x*a.y;}\nv0 su(v1 a){return a.x-a.y;}\nv0 sq2(v0 a){return a*a;}\n#define mi(a)-ma(-a)\n\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n\n//vec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//vec2 p2c(vec2 u){return cs(u.y)*u.x;}\n\n#define mad(a,b,c)((a)*(b)+(c))\n#define ab012(a,b)mad(vec3(0,1,2),b,a)\n#define c11(a,b)clamp(a/b,-1.,1.)*b\n\n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define u2(a)((a)*2.-1.)\n#define u3(a)((a)*2.+1.)\n#define u4(a)((a)*.5-.5)\n#define u5(a)((a)*.5+.5)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\nvec2   skew(vec2 u){return u+ad(u)*ske;}\nvec2 unskew(vec2 u){return u-ad(u)*reSke;}\n\nstruct v00{v0 a;v0 b;};//for MAT arithmetic\nstruct v10{v1 a;v0 b;};//...currently only for alpha compositing plans\nstruct v20{vec3 a;v0 b;};\nstruct v30{vec4 a;v0 b;};\nv00 ad(v00 a,v00 b){return v00(a.a+b.a,a.b+b.b);}//for MAT arithmetic\nv00 mu(v00 a,v00 b){return v00(a.a*b.a,a.b*b.b);}\nv00 mu(v00 a,v0  b){return v00(a.a*b,a.b*b);}\nv10 ad(v10 a,v10 b){return v10(a.a+b.a,a.b+b.b);}\nv10 mu(v10 a,v10 b){return v10(a.a*b.a,a.b*b.b);}\nv10 mu(v10 a,v0  b){return v10(a.a*b,a.b*b);}\nv20 ad(v20 a,v20 b){return v20(a.a+b.a,a.b+b.b);}\nv20 mu(v20 a,v20 b){return v20(a.a*b.a,a.b*b.b);}\nv20 mu(v20 a,v0  b){return v20(a.a*b,a.b*b);}\nv30 ad(v30 a,v30 b){return v30(a.a+b.a,a.b+b.b);}\nv30 mu(v30 a,v30 b){return v30(a.a*b.a,a.b*b.b);}\nv30 mu(v30 a,v0  b){return v30(a.a*b,a.b*b);}\nv0  mu(v0  a,v0  b){return a*b;}\n\n//carthesian to barycentric\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c//there are more elegant versions of this with inverse() of the right matrix.\n){u-=c;b.y-=c.y;a.x-=c.x;c.x-=b.x;b.x=b.y*a.x+c.x*(a.y-c.y)//determinant\n ;vec3 r=vec3(ad(u*vec2(b.y,c.x)),ad(u*vec2(c.y-a.y,a.x)),0);r.z=ad(r.xy);r/=b.x;r.z=1.-r.z ;return r;}\n//barycentric to carthesian, carthesian is weighted average of barycentrics. \nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){//Barycentric2Carthesian\n ;return vec2(ad(vec3(a.x,b.x,c.x)*l),ad(vec3(a.y,b.y,c.y)*l))\n //;mat3 m=matrixCompMult(transpose(mat3(a,0,b,0,c,0)),mat3(l,l,0,0,0));return vec2(suv(m[0]),suv(m[1]))\n ;} \n\n//generalizing alpha-compositing functions, named after porterDuff\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent, .W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs with their alpha;\n// a.xyz*=a.w ; b.xyz*=b.w\n//.x inputs (ant interpolants) should be sat()ed, or you likely get [color inverted hazes], this version si still not haze-free?\n//ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//ommits 2 functions, that return a or b, for simplicity\nvec4 ut(vec4 a,v0 b){return a*(1.-b);}v30 ut(v30 a,v0 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,v0 b){return a*(1.-b);}v20 ut(v20 a,v0 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,v0 b){return a*(1.-b);}v10 ut(v10 a,v0 b){return mu(a,(1.-b));}\n//v1 ut(v1 a,v0 b){return a*(1.-b);}\n//v00 ut(v00 a,v1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note, that atop may returns the alpha of a, and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication, note swapped AB case here\n//#define pd5(z)z pdOut(z a,z b){return ut(b,a.b);}z pdOver(z a,z b){return ad(ut(b,a.b),a);}z pdAtop(z a,z b){return ad(ut(b,a.b),mu(a,b.b));}z pdXor(z a,z b){return ad(ut(b,a.b),ut(a,b.b));}\n//pd5(v11)pd5(v21)pd5(v31)pd5(v41)//if you want alpha seperated in a struct\n//making tweening/unifying functionms of alpha compositing is silly fun. c is best range [0..1]\n//this reduces it to 5. within pd() unifying function, because 4/5 include ut(a,b), i segregate 1/5_pdIn()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\nvec3 pf(vec4 a,float c,vec4 b//c sets a mix type of this generalized function\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//c sets a mix type.makes little sense to bilinn 4 functions on a plane,done anyways\n ;a=mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w)\n ;return a;}//you likely want to a=sat(a) the c.x input, or have some negative-outlineglow-colors on -1>c>1\n\n\n#define doublestretch\nfloat jj(vec2 u,vec2 m){u+=m*.5//parametric j-shape m sets limb lengths.\n ;if(!(u.y-1.>0.||u.x+1.<0.))return abs(length(u-vec2(-1,1))-2.)//<-bottom right curve;\n ;m=abs(m)\n ;vec2 b=vec2(u.x-1.,mStretch((u.y-1.),m.y))//<-top right straight has priority\n ;u.y+=1.\n #ifdef doublestretch\n  ;u.x=mStretch(u.x,(m.x+1.));//bottom left straight STRETCH is optional here\n #else\n  ;u.x+=1.\n #endif \n ;vec2 c=u*sign(u.x+u.y+2.001)//<-bottom left straight,includes uncanny reflection\n ;u.y=sign(u.y-1.)+1.\n ;c=.5*u.y*(b+c)-c//c=mix(c,b,sign(u.y-1.)*.5+.5)\n ;return length(c);}\n\nfloat ff(vec2 u,vec2 m//parametric f-shape m sets limb lengths.\n){vec2 v=u\n ;v.x=abs(abs(v.x-.75)-1.)+1.//-.2\n ;//v.x/=2.\n ;//u.x=abs(u.x+2.)\n ;float a=length(v-m+vec2(0,4))\n ;return min(a,jj(-u,m))\n ;}\n\n\nfloat smoothFf(vec2 U,vec2 K){\n ;return sat(smoothstep(.1,-.1,abs(ff(U*19.,K)-.6)-.4));}\n\n#define aaa(r) (1./min(r.x,r.y))\n\n//carthesian coords in polar coords out\nvec2 c2p(vec2 uv){ return vec2(atan(uv.x,uv.y),length(uv));}\n\n//polar 2 spiralEuclidean\nvec2 p2se(float t,vec2 u,float turns\n){u.x=u.x*turns/pi\n ;u-=mod(turns+1.,2.)*2.//optionally fix oddChiraliyOffset (blue lines become asymptotic to blue lines towards the center)\n ;u.x+=t            //optionally GrowSpin over time\n ;float s=u.y-u.x\n ;return (vec2(floor(s)-u.x,s));}\n\n//carthesian 2 spiralEuclidean\nvec2 c2se(float t,vec2 u,float turns){return p2se(t,c2p(u),turns);}\n\nfloat c2sep(float t, vec2 u,vec3 r,vec4 m\n){vec2 v=c2se(t,u,m.y)\n ;v=fract(v)    \n ;float bokeh=4.*ViewZoom/min(r.x,r.y)\n ;vec3 c=v.xyy\n //m.x sets thickness of red\n ;m.x=m.x/r.x\n ;//m.x=1.-m.x\n ;m.x=clamp(m.x,bokeh,1.-bokeh)\n ;m.x=abs(v.y-.5)-.5*m.x\n ;m.x=smoothstep(bokeh,-bokeh,m.x)\n ;return m.x//only return somplearms\n ;c.y=mix(v.y,m.x,u.y/ViewZoom*2.+1.)//mix with fract() over screenspace\n ;c=c.yzx\n ;c.y*=.0\n ;return c.x;}//original context returned 3 layers, but we only care for one of 3.\n    \n//we have 3 contour-shapes to tell uv easily\n//they get tinted to tell TileId\n//some of their parameters (shape, not color) also tell sub-tile-id==parity\n//an upright  wiggling f-shape is placed at vec2(0)\n//an array of hollow dots with more space along .x than along .y shows carthesian\n//a carthesian spiral of parametric thickness and turnCount may tell parity (and direction to center)\n\n\n//    a spinning spiral pattern\n// to show if numbner-of-reflections is even or odd (chirality)\n//and\n//    a carthesian-grid of hollow circles\n// to show the amount-of-skew\n//\n//mostly to fill the tile for more contrast at tile-borders.\nfloat smoothFfb(float t,vec2 u,vec3 r,vec2 K             \n){vec2 v=u\n ;v.x=(fract((v.x*4.-.5)   )-.5)  \n ;v.y=(fract((v.y*4.-.25)*2.)-.5)/2.\n ;float thickness=.5 //thicklness of colored spiral\n ;float chirality=7. //chirality is a signed number of spiral arms\n ;float zoom=4.      //zoom out more\n ;float s=c2sep(t,u*zoom,r,vec4(thickness*r.x,chirality*.5,0,0))\n ;float dots=.61*sat(smoothstep(aaa(r),-aaa(r),abs(length(v)-.1)-.03))\n ;return max(dots\n             ,max(s*.61*.61,smoothFf(u,K)-.2));}\n\nfloat ray(vec2 u\n){return mix(abs(u.y*u.y),dd(u),step(0.,u.x));}\n\n\n//an outlined f-shape that ungulates over time\n//to more quickly show rotation + reflection in the tile-center\nvec4 alienGlyph(vec2 u,vec3 r,vec4 m//this function does not scale too well\n){//as in, it needs fixing\n ;vec3 c= vec3(1);//0.5 + 0.5*cos(iTime+u.xyx+vec3(0,2,4))\n ;float h=max(.04,.0)//thickness (WITHOUT bokeh)\n ;m.xy=max(abs(m.xy),.1)+h\n ;vec2 v=abs(u);\n ;c.x=ray(v.yx-m.yx+h*2.)//red hoorizontal bound\n ;c.z=ray(v-m.xy+h*2.)//blue vertical bound\n ;c.xz=sqrt(c.xz)\n ;c.xz=abs (c.xz-h*.5)\n ;if(sign(u.x)==sign(u.y))c.xz=vec2(min(c.x,c.z))\n ;c.xz-=h*.5\n ;return vec4(c.xyz,1) \n ;}\n\n\n//color space\nvec3 hsv2rgb(in vec3 c){//iq's smooth hsv to rgb\n vec3 rgb=clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n rgb=rgb*rgb*(3.0-2.0*rgb);return c.z*mix(vec3(1),rgb,c.y);}\n\n//#define mad(a,b,c) ((a)*(b)+(c))\n//#define ab012(a,b) mad(vec3(0,1,2),b,a)\n//vec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets\n//vec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets\n\n\n\n//self: https://www.shadertoy.com/view/tts3D2\n//backup: https://www.shadertoy.com/view/tts3D2",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}