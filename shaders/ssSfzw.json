{
    "Shader": {
        "info": {
            "date": "1646336723",
            "description": "a cool terrain to test camera lighting and stuff",
            "flags": 0,
            "hasliked": 0,
            "id": "ssSfzw",
            "likes": 8,
            "name": "Cartoon landscape",
            "published": 3,
            "tags": [
                "landscape"
            ],
            "usePreview": 0,
            "username": "loryruta",
            "viewed": 357
        },
        "renderpass": [
            {
                "code": "#define CAM_FLOATING_HEIGHT 1.0\n\n#define PI 3.14\n#define EPSILON 0.00001\n\n#define RAY_MARCH_MAX_ITER 256\n#define RAY_MARCH_INIT_STEP 0.1\n#define RAY_MARCH_STOP_APPROX 0.001\n\n#define ERR_COLOR vec3(1, 0, 0)\n\n#define SKY_COLOR vec3(0.27, 0.55, 1.0)\n\n#define TERRAIN_GRASS_METALLIC_ROUGHNESS vec2(0.1, 0.8)\n\n#define TERRAIN_ROCK_ALBEDO vec3(0.46, 0.29, 0.09)\n#define TERRAIN_ROCK_MATERIAL vec2(0.1, 0.2)\n\n#define TREE_AABB_SIZE vec3(3.5, 4.0, 3.5)\n\n#define TREE_TRUNK_HEIGHT 1.5\n#define TREE_TRUNK_RADIUS 0.2\n#define TREE_TRUNK_ALBEDO vec3(0.46, 0.29, 0.09)\n#define TREE_TRUNK_METALLIC_ROUGHNESS vec2(0.7, 0.3)\n\n#define TREE_FOLIAGE_HEIGHT 1.6\n#define TREE_FOLIAGE_RADIUS 1.0\n#define TREE_FOLIAGE_ALBEDO vec3(0.17, 0.6, 0.23)\n#define TREE_DARK_FOLIAGE_ALBEDO vec3(0.11, 0.27, 0.14)\n#define TREE_FOLIAGE_METALLIC_ROUGHNESS vec2(0.1, 0.9)\n\n#define SUNLIGHT_COLOR vec3(1.0, 1.0, 0.4)\n#define SUNLIGHT_DIR normalize(vec3(0, -1, 1))\n\n#define NO_HIT -1\n#define HIT_TERRAIN 0x00\n#define HIT_TREE_BB 0x10\n#define HIT_TREE_TRUNK 0x11\n#define HIT_TREE_FOLIAGE 0x12\n// ...\n\nfloat rand(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\nvec2 sphere_uv(vec3 n)\n{\n    return vec2(\n        atan(n.x, n.z) / (2.0 * PI) + 0.5,\n        n.y * 0.5 + 0.5\n    );\n}\n\nfloat snake_pattern(vec2 repeat_each, float curve_strength, vec2 uv)\n{\n    float li = mod(floor(uv.y / repeat_each.y), 2.0);\n   \n    float re = abs(mod(floor(uv.x / repeat_each.x), 2.0) - li);\n    float le = 1.0 - re;\n   \n    float lv = exp(-curve_strength * mod(uv.x, repeat_each.x) / repeat_each.x) * repeat_each.y;\n    float rv = exp(curve_strength * (mod(uv.x, repeat_each.x) / repeat_each.x - 1.0)) * repeat_each.y;\n   \n    float d = mod(uv.y, repeat_each.y) - (lv * le + rv * re);\n    float dw = d / repeat_each.y;\n    \n    return dw;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Terrain\n// ------------------------------------------------------------------------------------------------\n\nfloat get_terrain_height_norm(vec2 p)\n{\n    return noise(p * 0.3);\n}\n\nfloat get_terrain_height(vec2 p)\n{\n    return get_terrain_height_norm(p) * 3.0;\n}\n\nvec3 get_terrain_norm(vec2 p)\n{\n    float cur_h = get_terrain_height(p);\n   \n    vec3 d1 = vec3(0, get_terrain_height(p + vec2(0, EPSILON)) - cur_h, EPSILON);\n    vec3 d2 = vec3(EPSILON, get_terrain_height(p + vec2(EPSILON, 0)) - cur_h, 0);\n    \n    return normalize(cross(d1, d2));\n}\n\nvec2 get_terrain_uv(vec2 p)\n{\n    return mod(p, vec2(1.0));\n}\n\nvoid get_terrain_material(vec2 p, out vec3 mat_albedo, out vec2 mat_metallic_roughness)\n{\n    const float k_line_width = 0.04;\n    const vec2 k_repeat_each = vec2(0.6);\n    const vec3 k_grass_color = vec3(0.17, 0.6, 0.23);\n    const vec3 k_darker_grass_color = vec3(0.11, 0.27, 0.14);\n\n    float h = get_terrain_height_norm(p);\n    float tm = 0.5 + (noise(p) * 2.0 - 1.0) * 0.15;\n    float bm = 0.2 + (noise(p) * 2.0 - 1.0) * 0.15;\n\n    float grass_enable = clamp(ceil(h - tm), 0.0, 1.0) + clamp(ceil(bm - h), 0.0, 1.0);\n    float rock_enable = 1.0 - grass_enable;\n    \n    vec2 uv = get_terrain_uv(p);\n    \n    float grass_border_enable = clamp(ceil(0.05 - abs(h - tm)) + ceil(0.05 - abs(h - bm)), 0.0, 1.0);\n    \n    vec3 grass_color =\n        k_grass_color * (1.0 - grass_border_enable) + k_darker_grass_color * grass_border_enable;\n    \n    mat_albedo = mix(TERRAIN_ROCK_ALBEDO, grass_color, grass_enable);\n    mat_metallic_roughness = grass_enable * vec2(0.2, 0.8) + rock_enable * vec2(0.2, 0.8);\n}\n\n\n// ------------------------------------------------------------------------------------------------\n// Tree\n// ------------------------------------------------------------------------------------------------\n\nbool hasTreeAt(vec2 p)\n{\n    return rand(floor(p / TREE_AABB_SIZE.xz)) >= 0.7;\n}\n\nvec3 get_tree_pos(vec3 p)\n{\n    vec3 tree_pos;\n    tree_pos.xz = floor(p.xz / TREE_AABB_SIZE.xz) * TREE_AABB_SIZE.xz + TREE_AABB_SIZE.xz / 2.0;\n    tree_pos.y = get_terrain_height(tree_pos.xz);\n    return tree_pos;\n}\n\nbool ray_hit_tree_aabb(vec3 p)\n{\n    float baseY = get_terrain_height(p.xz);\n    return hasTreeAt(p.xz) && p.y - baseY <= TREE_AABB_SIZE.y;\n}\n\nint ray_hit_tree_test(vec3 ro, vec3 rd, vec3 tree_pos, out float hit_t, out vec3 hit_norm)\n{\n    vec3 foliage_center = tree_pos + vec3(0, TREE_FOLIAGE_HEIGHT, 0);\n    vec3 trunk_from = tree_pos;\n    vec3 trunk_to = tree_pos + vec3(0, TREE_TRUNK_HEIGHT, 0);\n   \n    hit_t = sphIntersect(ro, rd, foliage_center, TREE_FOLIAGE_RADIUS).x;\n    if (hit_t >= 0.0)\n    {\n        hit_norm = normalize((ro + rd * hit_t) - foliage_center);\n        return HIT_TREE_FOLIAGE;\n    }\n    \n    hit_t = cylIntersect(ro, rd, trunk_from, trunk_to, TREE_TRUNK_RADIUS).x;\n    if (hit_t >= 0.0)\n    {\n        return HIT_TREE_TRUNK;\n    }\n    \n    return NO_HIT;  \n}\n\nvec3 get_foliage_color(vec3 n)\n{\n    vec2 uv = sphere_uv(n);\n    \n    const vec2 repeat_each = vec2(0.025, 0.1);\n    const float line_width = 3.0;\n    \n    float d = snake_pattern(repeat_each, line_width / 2.0, uv);\n    float be = 1.0 - clamp(ceil(abs(d / 0.07) - 2.0), 0.0, 1.0);\n    \n    return mix(TREE_FOLIAGE_ALBEDO, TREE_DARK_FOLIAGE_ALBEDO, be);\n}\n\n// ------------------------------------------------------------------------------------------------\n// Camera\n// ------------------------------------------------------------------------------------------------\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1, 0, 0,\n        0, cos(a), -sin(a),\n        0, sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0, sin(a),\n        0, 1, 0,\n        -sin(a), 0, cos(a)\n    );\n}\n\nmat3 rotAroundAxis(vec3 axis, float a)\n{\n    axis = normalize(axis);\n    float s = sin(a);\n    float c = cos(a);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\nvec3 getCameraPos(float t)\n{\n    vec3 p;\n    p.xz = vec2(0, t);\n    p.y = get_terrain_height(p.xz) + CAM_FLOATING_HEIGHT;\n    return p;\n}\n\nmat3 getCameraDir(float t)\n{\n    float yaw = 0.0;\n    float pitch = 0.0;\n    return rotY(yaw) * rotX(pitch);\n}\n\n// ------------------------------------------------------------------------------------------------\n// Ray marching\n// ------------------------------------------------------------------------------------------------\n\n/** This function is used to enhance the ray marched position of the terrain collision. */\nvoid ray_march_terrain(vec3 ro, vec3 rd, inout float hit_t, out vec3 hit_norm)\n{\n    float curStep = RAY_MARCH_INIT_STEP;\n    \n    float t = hit_t;\n    \n    int iter = 0;\n    while (curStep > RAY_MARCH_STOP_APPROX && iter < RAY_MARCH_MAX_ITER)\n    {\n        vec3 ray_pos = ro + rd * t;\n        \n        if (ray_pos.y < get_terrain_height(ray_pos.xz))\n        {\n            hit_t = t;\n            hit_norm = get_terrain_norm(ray_pos.xz);\n        \n            t -= curStep;\n            curStep /= 2.0;\n\n            if (t < 0.0) {\n                return;\n            }\n        }\n\n        t += curStep;\n        iter++;\n    }\n}\n\nint ray_march(vec3 ro, vec3 rd, out float hit_t, out vec3 hit_norm)\n{\n    float t = 0.0;\n\n    int hit = NO_HIT;\n    \n    int iter = 0;\n    while (iter < RAY_MARCH_MAX_ITER)\n    {\n        vec3 ray_pos = ro + rd * t;\n        hit_t = t;\n\n        if (ray_pos.y < get_terrain_height(ray_pos.xz))\n        {\n            ray_march_terrain(ro, rd, hit_t, hit_norm);\n            return HIT_TERRAIN;\n        }\n\n        // If the intersection happens between the ray and the tree's AABB,\n        // then we have to check whether the collision actually happened with the tree\n        // if so we can return the exact hit position.\n        if (ray_hit_tree_aabb(ray_pos))\n        {\n            int hit = ray_hit_tree_test(ro, rd, get_tree_pos(ray_pos), hit_t, hit_norm);\n            if (hit != NO_HIT) {\n                return hit;\n            }\n        }\n        \n        t += RAY_MARCH_INIT_STEP; // always increment of a fixed step here\n   \n        iter++;\n    }\n    \n    return hit;\n}\n\n// ------------------------------------------------------------------------------------------------\n// PBR\n// ------------------------------------------------------------------------------------------------\n\n// https://learnopengl.com/PBR/Theory\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n  \nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 F_r(vec3 V, vec3 L, vec3 N, vec3 mat_albedo, vec2 mat_metallic_roughness)\n{\n    vec3 H = normalize(V + L);\n    \n    // cook-torrance brdf\n    float NDF = DistributionGGX(N, H, mat_metallic_roughness.y);        \n    float G   = GeometrySmith(N, V, L, mat_metallic_roughness.y);\n    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, mat_albedo, mat_metallic_roughness.x);\n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - mat_metallic_roughness.x;\t \n    \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001);  \n    \n    // lambert bdrf\n    vec3 diffuse = kD * mat_albedo / PI;\n    return diffuse + specular;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Lighting\n// ------------------------------------------------------------------------------------------------\n\nint is_sun_occluded(vec3 p, out float occ_hit_t, out vec3 occ_hit_norm)\n{\n    return ray_march(p, -SUNLIGHT_DIR, occ_hit_t, occ_hit_norm);\n}\n\nvec3 shade(int hit, vec3 ro, vec3 rd, float hit_t, vec3 hit_norm)\n{\n    vec3 hit_pos = ro + rd * hit_t;\n\n    vec3 hit_albedo;\n    vec2 hit_metallic_roughness;\n    \n    if (hit == HIT_TERRAIN)\n    {\n        get_terrain_material(hit_pos.xz, hit_albedo, hit_metallic_roughness);\n    }\n    else if (hit == HIT_TREE_TRUNK)\n    {\n        hit_albedo = TREE_TRUNK_ALBEDO;\n        hit_metallic_roughness = TREE_TRUNK_METALLIC_ROUGHNESS;\n    }\n    else if (hit == HIT_TREE_FOLIAGE)\n    {\n        hit_albedo = get_foliage_color(hit_norm);\n        hit_metallic_roughness = TREE_FOLIAGE_METALLIC_ROUGHNESS;\n    }\n    else\n    {\n        hit_albedo = ERR_COLOR;\n        hit_metallic_roughness = vec2(0, 1);\n    }\n\n    // Shadowing\n    float occ_hit_t;\n    vec3 occ_hit_norm;\n    \n    bool occluded = false;\n    occluded = occluded || (is_sun_occluded(ro + rd * (hit_t - 0.01), occ_hit_t, occ_hit_norm) != NO_HIT);\n\n    // Lighting\n    //vec3 hit_albedo = TERRAIN_GRASS_ALBEDO;\n    //vec2 hit_metallic_roughness = TERRAIN_GRASS_METALLIC_ROUGHNESS;\n    \n    vec3 light_dir = SUNLIGHT_DIR;\n    vec3 light_col = SUNLIGHT_COLOR;\n    \n    vec3 tot_light = vec3(0);\n    \n    if (!occluded)\n    {\n        tot_light +=\n            F_r(-rd, -light_dir, hit_norm, hit_albedo, hit_metallic_roughness) *\n            light_col *\n            max(dot(hit_norm, -light_dir), 0.0);\n    }\n\n    vec3 ambient = vec3(0.03) * hit_albedo;\n    vec3 color = ambient + tot_light;\n\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0 / 2.2));\n\n    return color;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Main\n// ------------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_pos = (fragCoord / iResolution.xy * 2.0) - 1.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    \n    const float fov = PI / 4.0; // 45°\n    \n    vec3 camPos = getCameraPos(iTime);\n    mat3 camDir = getCameraDir(iTime);\n    \n    vec3 camForward = camDir[2];\n    vec3 camUp = camDir[1];\n    vec3 camRight = camDir[0];\n    \n    vec3 camRay = camForward;\n    camRay = rotAroundAxis(camUp, screen_pos.x * fov) * camRay;\n    camRay = rotAroundAxis(camRight, screen_pos.y * (fov / aspect_ratio)) * camRay;\n    \n    float hit_t;\n    vec3 hit_norm;\n    int hit = ray_march(camPos, camRay, hit_t, hit_norm);\n    if (hit == NO_HIT) {\n        fragColor = vec4(SKY_COLOR, 1.0);\n    } else {\n        fragColor = vec4(shade(hit, camPos, camRay, hit_t, hit_norm), 1.0);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}