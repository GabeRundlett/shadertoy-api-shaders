{
    "Shader": {
        "info": {
            "date": "1479586075",
            "description": "A quick combination of [url=https://www.shadertoy.com/view/MtsXWj]triclops200's CIELAB Gamut Test[/url] with [url=https://www.shadertoy.com/view/Ml3SD4]Flyguy's Volumetric Sandbox[/url] to illustrate the sRGB slice of the CIELab color space.",
            "flags": 32,
            "hasliked": 0,
            "id": "llcXDN",
            "likes": 12,
            "name": "Volumetric sRGB Color Gamut",
            "published": 3,
            "tags": [
                "volumetric",
                "colorspace",
                "cielab",
                "gamut"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 1140
        },
        "renderpass": [
            {
                "code": "// Volumetric Sandbox code from Flyguy: https://www.shadertoy.com/view/Ml3SD4\n\n#define LINEAR_SAMPLE 1\n#define MAX_VOLUME_STEPS 290\n#define VOLUME_STEP_SIZE 0.02\n#define MAX_ALPHA 1.\n#define DENSITY_SCALE 1.0\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nvec3 vres = vec3(0);\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec4 texture3D(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    uvw = mod(floor(uvw * vres), vres);\n    \n    //XYZ -> Pixel index\n    float idx = (uvw.z * (vres.x*vres.y)) + (uvw.y * vres.x) + uvw.x;\n    \n    //Pixel index -> Buffer uv coords\n    vec2 uv = vec2(mod(idx, iResolution.x), floor(idx / iResolution.x));\n    \n    return texture(tex, (uv + 0.5) / iResolution.xy);\n}\n\nvec4 texture3DLinear(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    vec3 blend = fract(uvw*vres);\n    vec4 off = vec4(1.0/vres, 0.0);\n    \n    //2x2x2 sample blending\n    vec4 b000 = texture3D(tex, uvw + off.www, vres);\n    vec4 b100 = texture3D(tex, uvw + off.xww, vres);\n    \n    vec4 b010 = texture3D(tex, uvw + off.wyw, vres);\n    vec4 b110 = texture3D(tex, uvw + off.xyw, vres);\n    \n    vec4 b001 = texture3D(tex, uvw + off.wwz, vres);\n    vec4 b101 = texture3D(tex, uvw + off.xwz, vres);\n    \n    vec4 b011 = texture3D(tex, uvw + off.wyz, vres);\n    vec4 b111 = texture3D(tex, uvw + off.xyz, vres);\n    \n    return mix(mix(mix(b000,b100,blend.x), mix(b010,b110,blend.x), blend.y), \n               mix(mix(b001,b101,blend.x), mix(b011,b111,blend.x), blend.y),\n               blend.z);\n}\n\n//Ray-Cube intersection. x = tmin, y = tmax, hit = tmin < tmax \nvec2 IntersectBox(vec3 orig, vec3 dir, vec3 pos, vec3 size)\n{\n    size /= 2.0;\n    \n    vec3 mins = pos - size;\n    vec3 maxs = pos + size;\n\n    vec3 t0 = (mins - orig) / dir;\n    vec3 t1 = (maxs - orig) / dir;\n    \n    vec3 tmp = t0;\n    if(dir.x < 0.0){ t0.x = t1.x; t1.x = tmp.x; }\n    if(dir.y < 0.0){ t0.y = t1.y; t1.y = tmp.y; }\n    if(dir.z < 0.0){ t0.z = t1.z; t1.z = tmp.z; }\n    \n    float tmin = max(max(t0.x, t0.y), t0.z);\n    float tmax = min(min(t1.x, t1.y), t1.z);\n    \n\treturn vec2(tmin, tmax);\n}\n\nvec4 MarchVolume(vec3 orig, vec3 dir)\n{\n    vec2 hit = IntersectBox(orig, dir, vec3(0), vec3(2));\n    \n    if(hit.x > hit.y){ return vec4(0); }\n    \n    //Step though the volume and add up the opacity.\n    float t = hit.x;   \n    vec4 dst = vec4(0);\n    vec4 src = vec4(0);\n    \n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n        t += VOLUME_STEP_SIZE;\n        \n        //Stop marching if the ray leaves the cube.\n        if(t > hit.y){break;}\n        \n    \tvec3 pos = orig + dir * t;\n        \n        vec3 uvw = 1.0 - (pos * 0.5 + 0.5);\n        \n        #if(LINEAR_SAMPLE == 1)\n            src = texture3DLinear(iChannel0, uvw, vres);\n        #else\n            src = texture3D(iChannel0, uvw, vres);\n        #endif\n        \n        src = clamp(src, 0.0, 1.0);\n        \n        src.a *= DENSITY_SCALE;\n        src.rgb *= src.a;\n        \n        dst = (1.0 - dst.a)*src + dst;\n        \n        //Stop marching if the color is nearly opaque.\n        if(dst.a > MAX_ALPHA){break;}\n    }\n    \n    return vec4(dst);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vres = vec3(floor(pow(iResolution.x*iResolution.y, 1.0/3.0)));\n    \n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec4 color = vec4(0);\n    \n    //Checkerboard background\n    vec2 bguv = uv - res/2.0;\n    float back = sin(bguv.x*pi*8.0) * sin(bguv.y*pi*8.0);\n    back = step(0.0,back);\n    back = back * 0.05 + 0.2;\n    color.rgb = vec3(back);\n    \n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-3.5);\n\t\n    vec2 angles = vec2(0);\n    \n    if(iMouse.xy == vec2(0))\n    {\n        angles = vec2(iTime * 0.5, -tau/16.0); \n    }\n    else\n    {\n    \tangles = (iMouse.xy / iResolution.xy)*2.0 - 1.0;\n    \tangles *= vec2(tau, tau/2.0);\n    }\n    \n    mat2 rX = rotate( angles.y);\n    mat2 rY = rotate(angles.x);\n    \n    dir.yz *= rX;\n    orig.yz *= rX;\n    \n    dir.xz *= rY;\n    orig.xz *= rY;\n    \n    vec4 volume = MarchVolume(orig,dir);\n    \n    color = mix(color, volume, volume.a);\n    \n\tfragColor = vec4(color);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// CIELab to rgb conversion from triclops200: https://www.shadertoy.com/view/MtsXWj\n\nfloat ref_X = 95.047;\nfloat ref_Y = 100.000;\nfloat ref_Z = 108.883;\n\nvec3 xyz2rgb(vec3 xyz) {\n    float var_X = xyz[0] * 0.01;\n    float var_Y = xyz[1] * 0.01;\n    float var_Z = xyz[2] * 0.01;\n    \n    float var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;\n    float var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;\n    float var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;\n    \n    if (var_R > 0.0031308) var_R = 1.055 * pow(var_R, 1.0/2.4) - 0.055;\n    else var_R = 12.92 * var_R;\n    if (var_G > 0.0031308) var_G = 1.055 * pow(var_G, 1.0/2.4) - 0.055;\n    else var_G = 12.92 * var_G;\n    if (var_B > 0.0031308) var_B = 1.055 * pow(var_B, 1.0/2.4) - 0.055;\n    else var_B = 12.92 * var_B;\n    \n    return vec3(var_R,var_G,var_B);\n}\n\nvec3 cielab2xyz(vec3 lab) {\n    float var_Y = (lab[0] + 16.0) / 116.0;\n    float var_X = lab[1] / 500.0 + var_Y;\n    float var_Z = var_Y - lab[2] / 200.0;\n    \n    \n\tfloat py = var_Y*var_Y*var_Y;\n    float px = var_X*var_X*var_X;\n    float pz = var_Z*var_Z*var_Z;\n\n    if (py > 0.008856) var_Y = py;\n    else var_Y = (var_Y - 16.0 / 116.0) / 7.787;\n    if (px > 0.008856) var_X = px;\n    else var_X = (var_X - 16.0 / 116.0) / 7.787;\n    if (pz > 0.008856) var_Z = pz;\n    else var_Z = (var_Z - 16.0 / 116.0) / 7.787;\n    \n    float X = ref_X * var_X;\n    float Y = ref_Y * var_Y;\n    float Z = ref_Z * var_Z;\n    return vec3(X, Y, Z);\n}\n\nvec3 cielab2rgb(vec3 lab) {\n    return xyz2rgb(cielab2xyz(lab));\n}\n\nbool isValid(vec3 c) {\n    return c.r >= 0. && c.g >= 0. && c.b >= 0. &&  c.r <= 1. && c.g <= 1. && c.b <= 1.;\n}\n\n// Volumetric Sandbox code from Flyguy: https://www.shadertoy.com/view/Ml3SD4\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nvec3 iVResolution = vec3(0);\n\nvoid mainVolume( out vec4 voxColor, in vec3 voxCoord);\n\nvec4 texture3D(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    uvw = mod(floor(uvw * vres), vres);\n    float idx = (uvw.z * (vres.x*vres.y)) + (uvw.y * vres.x) + uvw.x;\n    vec2 uv = vec2(mod(idx, iResolution.x), floor(idx / iResolution.x));\n    \n    return texture(tex, (uv + 0.5) / iResolution.xy);\n}\n\nvec4 texture3DLinear(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    vec3 blend = fract(uvw*vres);\n    vec4 off = vec4(1.0/vres, 0.0);\n    \n    vec4 b000 = texture3D(tex, uvw + off.www, vres);\n    vec4 b100 = texture3D(tex, uvw + off.xww, vres);\n    \n    vec4 b010 = texture3D(tex, uvw + off.wyw, vres);\n    vec4 b110 = texture3D(tex, uvw + off.xyw, vres);\n    \n    vec4 b001 = texture3D(tex, uvw + off.wwz, vres);\n    vec4 b101 = texture3D(tex, uvw + off.xwz, vres);\n    \n    vec4 b011 = texture3D(tex, uvw + off.wyz, vres);\n    vec4 b111 = texture3D(tex, uvw + off.xyz, vres);\n    \n    return mix(mix(mix(b000,b100,blend.x), mix(b010,b110,blend.x), blend.y), \n               mix(mix(b001,b101,blend.x), mix(b011,b111,blend.x), blend.y),\n               blend.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 vres = vec3(floor(pow(iResolution.x*iResolution.y, 1.0/3.0)));    \n    vec2 uv = floor(fragCoord - 0.5);\n    \n    float idx = (uv.y * iResolution.x) + uv.x;\n    \n    vec3 uvw = mod(floor(vec3(idx) / vec3(1.0, vres.x, vres.x*vres.y)), vres);\n    \n    iVResolution = vres;\n    mainVolume(fragColor, uvw);\n}\n\n//Write your shader here.\n//3D plasma thing.\nvoid mainVolume( out vec4 voxColor, in vec3 voxCoord)\n{\n    vec3 lab = voxCoord / iVResolution;\n    \n    lab.x = lab.x * 110. - 5.;\n\tlab.yz = lab.yz * 256. - 128.;\n\n    vec3 color = cielab2rgb(lab);\n    \n    voxColor = vec4(color, isValid(color));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}