{
    "Shader": {
        "info": {
            "date": "1617915780",
            "description": "First try at casting sphere with lighting. Used another shader for help but can't find the link to it anymore.",
            "flags": 0,
            "hasliked": 0,
            "id": "7sj3Wy",
            "likes": 0,
            "name": "BasicSphere",
            "published": 3,
            "tags": [
                "raycast",
                "sphere",
                "raytrace"
            ],
            "usePreview": 0,
            "username": "nialred",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Circle\n{\n    vec2 center;\n    float radius;\n};\n    \nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n\nint intersect_circle(in vec2 uv, in Circle circle)\n{    \n    vec2 distance = abs(uv - circle.center);\n    \n    float radius_check = length(distance);\n    \n    /*\n    // Could use this instead to get smooth edges between sphere and background\n    float difference = radius - radius_check;\n    float color = clamp(difference / fwidth(difference), 0., 1.);\n    fragColor = vec4(color, 0.0, 1.0 - color, 1.0);\n    */\n    \n    if (radius_check < circle.radius)\n    {\n        // Inside circle\n        return 1;\n    } \n    else\n    {\n        // Outside circle\n        return 0;\n    } \n}\n\nvec4 diffuse(in vec3 surface, in vec3 center, in vec4 color, in vec3 light_pos) {\n\t// Surface normal\n\tvec3 n = normalize(surface - center);\n\t\n\t// Light direction from surface\n\tvec3 l = normalize(light_pos - surface);\n\n\t// The diffuse equation\n\treturn color * max(0.0, dot(n, l));\n}\n\nfloat intersect_sphere(in Ray ray, in Sphere sphere)\n{\n    // Sphere center to ray origin\n    vec3 co = (ray.origin - sphere.center);\n    \n    // The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance\n\tfloat discrim = dot(co, ray.direction) * dot(co, ray.direction) - \n                         (dot(co, co) - (sphere.radius * sphere.radius));\n    \n    if (discrim >= 0.0)\n    {\n        return -dot(ray.direction, co) - sqrt(discrim);\n    }\n    else\n    {\n        return -1.0;\n    }\n\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = fragCoord.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_norm = uv / iResolution.xy;\n    \n    // Initialize circle object\n    Circle circle = Circle(vec2(iResolution.x / 2.0, iResolution.y / 2.0), 200.0);\n    \n    // Check if current pixel position is inside the circle\n    int hit_circle = intersect_circle(uv, circle);\n    \n    // Color the pixel accordingly\n    if (hit_circle == 1)\n    {\n        fragColor = vec4(uv_norm.x, uv_norm.y, 1.0, 1.0);\n    }\n    else \n    {\n        fragColor = vec4(0.25 * uv_norm.x, 0.25 * uv_norm.y, 0.25, 1.0);\n    }\n    \n    \n    // Shift the range from [0 1] to [-1 1]\n    vec2 uv_norm_shift = uv_norm * 2.0 - 1.0;\n    \n    // Pixel position in 3D space (screen is at a z value of 0)\n    vec3 pixel_pos = vec3(uv_norm_shift.x / (iResolution.y/iResolution.x), uv_norm_shift.y, 0.0);\n    \n    // Eye position is behind the screen somewhere (hence the -4 z value)\n    vec3 eye_pos = vec3(0.0, 0.0, -4.0);\n    \n    // Ray used to see if it intersects with sphere\n    vec3 ray_dir = normalize(pixel_pos - eye_pos);\n    \n    // Define sphere with 3D center and radius values\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 7.0), 1.0);\n    \n    // Define ray\n    Ray ray = Ray(eye_pos, ray_dir);\n    \n    float surf_dist = intersect_sphere(ray, sphere);\n    \n    // If positive, then we draw a pixel of the sphere\n\tif (surf_dist >= 0.0)\n\t{\n\t\t// Choose a diffuse color\n\t\tvec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n\t\t// Choose an ambient color\n\t\tvec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n        // Position of a white light\n        vec3 light_pos = vec3(20.0, 5.0, -10.0);\n        \n\t\tfragColor = ambient_col + diffuse(eye_pos + surf_dist * ray_dir, sphere.center, diffuse_col, light_pos);\n\n\t} \n    else\n    {\n        // Otherwise we draw the color of the background\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}