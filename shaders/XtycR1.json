{
    "Shader": {
        "info": {
            "date": "1535115755",
            "description": "A triangulated grid with slope based diagonal orientation. Coded for fun, so not to be taken too seriously. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "XtycR1",
            "likes": 37,
            "name": "Perturbed Grid",
            "published": 3,
            "tags": [
                "grid",
                "terrain",
                "lines",
                "barycentric",
                "polygon",
                "mesh"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2122
        },
        "renderpass": [
            {
                "code": "/*\n\n    Perturbed Grid\n    --------------\n\n\tI made this a while back when constructing my \"Terrain Lattice\" example. I thought the \n    rendering style was interesting, but overall, found it a little bland. Anyway, I\n\ttweaked it a little and put in some options... and it's still a little boring, but I\n\tfigured I'd put it up anyway. :) As you can see, it's a standard triangulated perturbed \n    grid, or to be more specific, a raymarched heightmap subdivided into grid squares, \n    which are each subdivided into two triangles to produce a flat shaded look.\n\n    Normally, when you see one of these, the square grid cells are subdivided into triangles \n    via a diagonal partitioning with fixed orientation. However, it's possible to partition\n\tthe cells in all kinds of ways, like patterns, randomness and slope -- Playing around \n    with the \"SHOW_DIAGONAL\" define will illustrate that. The default is a partitioning \n\tbased on the slope -- Basically, it favors a partitioning that cuts the higher slopes \n\tin half. I believe it gives the underlying height map just a touch more definition.\n\n    There are two ways to render flat grid squares. One is to linearly interpolate between\n\tthe height values of all four vertices to produce a quad that looks flat on account of\n    its straight edge joins. The other is to split the quad into two triangles and linearly \n\tinterpolate between the three verticies of each of those. I tried both methods, but \n\tliked the look of the genuinely flat-planed triangles more. For the smooth quad look,\n\tuncomment the \"SMOOTH_QUAD\" define. By the way, there are a heap of compiler directives\n\tin there for anyone who wants to play around with different looks before making one\n\tof these.\n\n    A flat shaded triangle render usually requires a barycentric approach, but since the\n\tgrid triangles are essentially half squares, it's possible to use, vector \n\tperpendicularity, symmetry, etc, to cut down on the calculations considerably.\n    \n\n\tOther examples:\n    \n\t// Simple, and really nicely lit.\n    Triangulator - nimitz\n\thttps://www.shadertoy.com/view/lllGRr\n\n\t// Nice example that takes an intuitive vectorized approach.\n\tRay Marched Mesh Terrain - Flyguy\n\thttps://www.shadertoy.com/view/ltjSRD\n    \n\tTerrain Lattice - Shane\n\thttps://www.shadertoy.com/view/XslyRH\n\n*/\n\n\n\n// OPTIONAL COMPILER DIRECTIVES\n\n// The point of the exercise was to polygonize the terrain and give it a flat shaded triangulated\n// appearance, but if you'd prefer to see smooth quads, just uncomment the following:\n//#define SMOOTH_QUAD\n\n// Animate the surface: The default setting, \"DIAGONAL_MODE 4,\" will flip diagonals according to \n// changine slope, so this would look better with a fixed diagonal orientation, like \n// \"DIAGONAL_MODE 3\" for instance.\n//#define ANIMATE_SURFACE\n\n// Turn the blinking squares on or off.\n#define BLINKING_LIGHTS \n\n// Diagonal orientation (0 - 4) -- Not applicable when the SMOOTH_QUAD directive is on.\n//\n// The orientation of the diagonal can effect the look of the surface. The default is a diagonal \n// orientation based on the slope. The idea being that you favor cutting the largest quad slope\n// in half, which means running a diagonal line between diagonal points with the smallest slope. \n// It's a matter of opinion, but I think it enhances the terrain shape a little more. In order to \n// more clearly see the joins, set the SHOW_DIAGONAL directive to something other than zero.\n//\n// Left: 0, Right: 1, Random: 2, Pattern: 3, Slope: 4.\n#define DIAGONAL_MODE 4\n\n// Horizontal, vertical and diagonal lines. I like it with the horizonal lines only, but wanted\n// to show the square grid by default to emulate a lot of the online imagery I see.\n#define SHOW_HORIZONTAL\n#define SHOW_VERTICAL\n// I find the diagonal joins too busy, so have left it off by default. Also, it's not \n// applicable when the SMOOTH_QUAD directive is on.\n// No lines: 0, Metalic: 1, Timber Grooves: 2.\n#define SHOW_DIAGONAL 0\n\n// Ball joins. The grid looks cleaner without the ball bearing joins, but less interesting.\n#define SHOW_BALL_JOINS\n\n\n/////////\n\n\n// Max ray distance.\n#define FAR 40.\n\n// Scene object ID container to separate the ball joint mesh object from the terrain.\nvec3 vObjID; // Terrain: 0, Join: 1, Ball, 2.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// vec3 to float hash.\nfloat hash21(vec2 p){\n   \n    float n = dot(p, vec2(13.163, 157.247)); \n    return fract(sin(n)*43758.5453); \n}\n\n\n/*\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n \n\n// A line segment formula that orients via an orthanormal basis. It'd be faster to use\n// IQ's 3D line segment formula, but this one allows for more interesting cross sections,\n// like hexagons and so forth.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, float lf){ // Length factor on the end.\n\n\n    b -= a;\n    float l = length(b);\n    \n    p = basis(normalize(b))*(p - a - b*.5);\n    \n    p = abs(p);\n    //p.x = abs(p.x - .03);\n    //return max(length(p.xy) - r, p.z - l*lf);\n    //return max((p.x + p.y)*.7071 - r, p.z - l*lf);\n    //return max(max(p.x, p.y) - r, p.z - l*lf);\n    //return max(max(max(p.x, p.y), (p.y + p.x)*.7071) - r, p.z - l*lf);\n    return max(max(p.x*.866025 + p.y*.5, p.y) - r, p.z - l*lf);\n}\n*/\n\n\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n\n\n\n// Height map values. Just a couple of animated sinusoidal layers, but you could put anything\n// here... so long as it's cheap. :)\nfloat hm(in vec2 p){\n    \n    #ifdef ANIMATE_SURFACE\n    // Scaling, plus some movement.\n    p = p/4. + iTime/8.;\n    #else\n    // Scaling only.\n    p /= 4.;\n    #endif\n    \n    // Layer one.\n    float n = dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159/2.), vec2(0.25) + .5)*.66;\n    p = p*1.5;  // Increase frequency.\n  \n    p.xy = mat2(.866025, .5, -.5, .866025)*p.xy; // Rotate.\n    \n    // Add another layer.\n    n += dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159/2.), vec2(0.25) + .5)*.34;\n    \n    return n; // Range [0, 1]... hopefully. :)\n\n}\n\n// Used to scale the grid without having to move the camera.\n#define scale 1.5 \nvec3 hVal; // Global variable to hold the three height values for reuse.\n\nfloat diag;\n\n// The terrain - tesselated in a flat-grid triangle-pair fashion... Needs rewording. :D\nfloat triTerrain(vec2 p){ \n\n    \n    \n    vec2 ip = floor(p); // Integer value. Used for the unique corner height values.\n    p -= ip; // Fractional grid value.\n   \n    // The height values -- One for each grid vertex. If it were not for the slope\n    // comparisons, only three values would be required. It's a cheap distance field,\n    // so it shouldn't really matter anyway.\n    float h00 = hm(ip);\n    float h01 = hm(ip + vec2(0, 1));\n    float h10 = hm(ip + vec2(1, 0));\n    float h11 = hm(ip + 1.);\n    \n    #ifdef SMOOTH_QUAD\n    \t// Smoothing: Mainly here for reference. To use it with joins, you need to smoothen\n        // the line joins themselves, which doesn't look that great.\n    \t//p *= p*(3. - 2.*p); \n    \t//p *= p*p*(p*(p*6. - 15.) + 10.); \n    \tdiag = 0.;\n    #else \n        #if DIAGONAL_MODE == 0 // Left diagonal.\n        diag = 0.;\n        #elif DIAGONAL_MODE == 1 // Right diagonal.\n        diag = 1.;\n        #elif DIAGONAL_MODE == 2 // Random diagonal orientation.\n        diag = hash21(ip)<.5? 0. : 1.;\n        #elif DIAGONAL_MODE == 3 // Pattern diagonal\n        diag = mod(ip.x + ip.y, 2.)>.5? 0. : 1.;\n        #else\n        float l1 = abs(h00 - h11);\n        float l2 = abs(h01 - h10);\n        diag = l1>l2? 0. : 1.;\n    #endif\n    \n    #endif\n     \n    // The barycentric coordinates, so to speak, and the corresponding height value.\n    // For those of you familiar with the process, you may note that there are far \n    // fewer operations than usual.\n    float s;\n    \n    if(diag<.5){\n        s = step(1., p.x + p.y); // Determines which side of the diagonal we're on.\n\n        // Storing the heights at the three triangle vertices. Normally, it wouldn't be\n        // necessary, but we're reusing them to render the mesh.\n        //hVal = vec3(hm(ip + s), hm(ip + vec2(1, 0)), hm(ip + vec2(0, 1)));\n        float hs = s<.5? h00 : h11;\n        hVal = vec3(hs, h10, h01);\n    }\n    else {\n        // Triangulating across the other diagonal. Handy, if you want to make patterns.\n        s = step(p.x, p.y);\n        //hVal = vec3(hm(ip), hm(ip + vec2(1. - s, s)), hm(ip + 1.));\n        float hs = s<.5? h10 : h01;\n        hVal = vec3(h00, hs, h11);\n    }    \n\n    \n    #ifdef SMOOTH_QUAD\n        // A simple, interpolated quad. It's not really flat, but the edge-joins are straight,\n        // so it looks that way. Because the mesh is set up on triangle logic, there two\n        // extra height values. Normally, you'd only need one extra.\n        return mix(mix(hm(ip), hVal.y, p.x), mix(hVal.z, hm(ip+1.), p.x), p.y);\n    #else\n    \n\n    \n    // Barycentric setup: This is a very trimmed down version of the generalized barycentric\n    // calculations that involve cross-products, and so forth. Without going into detail, I'm\n    // sure you could imagine that three points in space can be used to generate a plane \n    // equation via cross products and such, and the fractional grid points could be used in\n    // unison with the vertice coordinates to determine the exact coordinate on the plane, or\n    // the height value at that coordinate.\n    //\n    // Anyway, the grid triangles are shaped in such a way that a lot of the operations cancel \n    // out, and the lines below are the result. You could just use them. However, if you require\n    // more information, look up a few barycentric coordinate examples.\n    //\n    if(diag<.5){\n        vec3 b = abs(vec3(1.0 - p.x - p.y, p.x - (p.x - p.y + 1.)*s, p.y - (p.y - p.x + 1.)*s));\n\n        // The linearly interpolated triangle height.\n        return dot(b, hVal);\n    }\n    else {\n        //return mix(mix(hVal.x, hm(ip+vec2(1, 0)), f.x), mix(hm(ip+vec2(0, 1)), hVal.z, f.x),f.y);\n        vec3 b = abs(vec3(1. - (1. - s)*p.x - p.y*s, (1. - 2.*s)*(p.x - p.y), p.x*s + p.y*(1. - s)));\n        return dot(b, hVal);\n    }\n    \n    #endif\n    \n\n   \n \n}\n\nfloat tObjID;\n\n// The flat shaded terrain and the mesh.\nfloat map(vec3 p){\n    \n    // The terrain. By the way, when you scale coordinates, you have to scale back\n    // the distance value to keep things in check. I often forget this.\n    float ter = triTerrain(p.xz*scale)/scale; // The terrain.\n \n    const float hPert = .4; // Terrain height perturbation.\n    float fl = p.y  + (.5 - ter)*hPert;//*.25; // Adding it to a flat plane.\n\n    \n    hVal = (hVal - .5*scale)*hPert + .04;///scale; // Rescaling the height values to match the terrain perturbation.\n    \n    // The grid cell boundaries. As usual, the code looks more complicated than it is, but it's\n    // just grid vextex to grid vertex tubes.\n    vec3 q = p*scale;\n    q.xz = fract(q.xz); // Break space into squares along the XZ plane.\n        \n    // Grid line thickness.\n    const float lw = .04;\n \n    float ln = 1e5;\n    float ln2 = 1e5;\n    \n      if(diag<.5){\n        \n        #ifdef SHOW_HORIZONTAL\n        ln = min(ln, sdCapsule(q, vec3(0, hVal.x, 0), vec3(1, hVal.y, 0)));\n        ln = min(ln, sdCapsule(q, vec3(0, hVal.z, 1), vec3(1, hVal.x, 1)));\n        #endif\n        #ifdef SHOW_VERTICAL\n        ln =  min(ln, sdCapsule(q, vec3(0, hVal.x, 0), vec3(0, hVal.z, 1)));\n        ln = min(ln, sdCapsule(q, vec3(1, hVal.y, 0), vec3(1, hVal.x, 1)));\n        #endif\n        ln -= lw; // Line thickness.\n        #if SHOW_DIAGONAL > 0\n        // Diagonal.\n        ln2 = min(ln2, sdCapsule(q, vec3(0, hVal.z, 1), vec3(1, hVal.y, 0)) - lw);\n        #endif\n\n    }\n    else {\n        #ifdef SHOW_HORIZONTAL\n        ln = min(ln, sdCapsule(q, vec3(0, hVal.x, 0), vec3(1, hVal.y, 0)));\n        ln = min(ln, sdCapsule(q, vec3(0, hVal.y, 1), vec3(1, hVal.z , 1)));\n        #endif\n        #ifdef SHOW_VERTICAL\n    \tln = min(ln, sdCapsule(q, vec3(0, hVal.x, 0), vec3(0, hVal.y, 1)));\n        ln = min(ln, sdCapsule(q, vec3(1, hVal.y, 0), vec3(1, hVal.z, 1)));\n      \t#endif\n        ln -= lw; // Line thickness.\n        #if SHOW_DIAGONAL > 0\n        // Diagonal.\n        ln2 = min(ln2, sdCapsule(q, vec3(0, hVal.x, 0), vec3(1, hVal.z, 1)) - lw);\n        #endif\n    }\n    \n\n    \n    #ifdef SHOW_BALL_JOINS\n    // Ball joins. We've calculated another height value offset by half the grid in order to \n    // draw just one each - instead of four. It's a little hard to explain why but it has to\n    // do with repetitive cell boundaries.\n    float hgt = (hm(floor(p.xz*scale + .5)) - .5*scale)*hPert + .04;\n    vec2 offXZ = fract(p.xz*scale + .5) - .5;\n    // The metallic balls.\n    float sp = length(vec3(offXZ.x, abs(q.y - hgt), offXZ.y)) - .09; // Ball join size.\n    #else\n    float sp = 1e5;\n    #endif\n    \n    // Scaling the variables back.\n    ln /= scale;\n    ln2 /= scale;\n    sp /= scale;\n    \n     \n    #ifndef SMOOTH_QUAD\n    #if SHOW_DIAGONAL == 1\n    ln = min(ln, ln2); // Thinner.\n    //ln = min(ln, ln2 + .01); // Thinner.\n    #elif SHOW_DIAGONAL == 2\n    fl = max(fl, -ln2 + .004); // Innner grooves.\n    //fl = min(fl, ln2 + .01); // Outer join.\n    #endif\n    #endif\n    \n    \n    // Save the individual object IDs: With larger object numbers, Identifying inside the raymarching\n    // equation can add a lot of extra calls, so it's best to store them, then identify them outside.\n    // It's possible to do the vec2(dist, objID), but that can complicate things also.\n    vObjID = vec3(fl, ln, sp); // terrain, joiner lines, ball joints.\n    \n    \n    // Combining the mesh with the terrain.\n    return min(min(fl, ln), sp)*.75; //smin(fl, ln, .025);\n \n}\n\n \n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.; //fract(sin(dot(rd, vec3(57, 111, 27)))*45758.5453)*.1; // Jitter.\n   \n    for (int i=0; i<96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;  // Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 getNormal(in vec3 p, float t)\n{  \n    vec2 e = vec2(-1., 1.)*0.001*min(1. + t, 5.);   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.002, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Basic soft shadows.\nfloat getShad(in vec3 ro, in vec3 n, in vec3 lp){\n\n    const float eps = .001;\n    \n\tfloat t = 0., sh = 1., dt;\n    \n    ro += n*eps*1.1;\n    \n    vec3 ld = (lp - ro);\n    float lDist = length(ld);\n    ld /= lDist;\n    \n    //t += hash31(ro + ld)*.005;\n    \n\tfor(int i=0; i<16; i++){\n        \n    \tdt = map(ro + ld*t);\n        \n        sh = min(sh, 12.*dt/t);\n         \n \t\tt += clamp(dt, .01, .5);\n        if(dt<0. || t>lDist){ break; } \n\t}\n\n    return min(max(sh, 0.) + 0.2, 1.0); \n}\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(57, 113, 27);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 2.;\n    p.xz += iTime*.5;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*.8, c*.9, c);//vec3(c*c, c*sqrt(c), c); // Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665); // Mixing in a bit of purple.\n\n}\n\n// Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n \n// Recreating part of the distance function to obtain the segment IDs, which in turn is used\n// to create the blink effect.\nfloat lightBlink(vec2 p){\n    \n    // Unique identifier for the grid cell.\n    float rnd = hash21(floor(p));\n    \n    // Blink at random.\n    return smoothstep(.9, 1., sin(rnd*6.283 + iTime*2.)*.5 + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(iResolution.y, 800.);\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, iTime*1.5);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(0, 2.5, -2); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, 0, 3);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + (uv.x*rgt + uv.y*up)*FOV);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= r2( path(lk.z).x/128.);\n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    //float svObjID = vObjID.x<vObjID.y && vObjID.x<vObjID.z? 0. : vObjID.y<vObjID.z? 1. : 2.;\n    float svObjID = vObjID.x < vObjID.y ? (vObjID.x < vObjID.z ? 0. : 2.) : (vObjID.y < vObjID.z ? 1. : 2.);\n   \t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n         \n        // Texture scale factor.\n        float tSize0 = 1.;\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n        // Texture-based bump mapping. I've left it out for this.\n        //if(svObjID>.5) sn = texBump(iChannel0, sp*tSize0, sn, .005);\n\n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = getShad(sp, sn, lp);\n    \tfloat ao = cAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1.2/(1. + lDist*lDist*0.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        diff = pow(diff, 4.)*1.5; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n        \n        \n        // I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        // to produce a hint of reflectivity than an actual reflective pass. :) \n        vec3 ref = reflect(rd, sn);\n        vec3 env = envMap(ref);\n        vec3 specCol = vec3(1, .95, .8);\n        \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        \n        if(svObjID<.5) { // Terrain texturing.\n            \n            // Tri-planar texturing - A little better than the 2D method below.\n            texCol = tex3D(iChannel0, sp*tSize0, sn);\n            //texCol = mix(texCol, tex3D(iChannel0, sp*tSize0*2. + .5, sn), .25);\n            // Just 2D XZ texturing. It works, but lacks a touch of depth.\n            //texCol = texture(iChannel0, sp.xz*tSize0).xyz; texCol *= texCol;\n            // Ramping up the saturation (hue intensity) a bit.\n            texCol = smoothstep(-.07, .7, texCol);\n            \n            /*\n            // A quick attempt to emulate the timber texture. Some of the nice\n            // patterns and hues are missing, so it needs more work, but it \n            // could definitely be done.\n            vec3 tsp = sp*vec3(1, 1, 6);\n            float ns = n3D(tsp*6.)*.57 + n3D(tsp*12.)*.28 + n3D(tsp*24.)*.15;\n            float ns2 = n3D(tsp*6.)*.66 + n3D(tsp*12.)*.34;\n            ns2 = mix(ns2, smoothstep(0., 1., ns2), .5);\n            float ns3 = clamp(sin(ns*6.2831) + .5, 0., 1.);\n            texCol = mix(vec3(1.3, .175, .0)/1.3, vec3(0), 1. - ns);\n            texCol = mix(texCol, vec3(.5, .05, .02), mix(ns, ns3, .5));\n            tsp = (sp + .5)*vec3(1, 1, 4);\n            float ns4 = n3D(tsp*6.)*.66 + n3D(tsp*18.)*.34;\n            texCol *= mix(ns4, smoothstep(0., .25, ns4 - .35), .5)*.7 + .65;\n            texCol *= n3D(sp*128.)*.8 + .6;//*.4 + .8;\n            //texCol = max(texCol, 0.);\n            */\n            \n            \n            //texCol *= max(triTerrain(sp.xz*scale)*.25 + .75, 0.); // Fake terrain shadowing.\n            //texCol = mix(texCol.xzy, texCol, max(triTerrain(sp.xz*scale)*.3 + .7, 0.)); // Hue shadowing.\n \n            \n            #ifdef BLINKING_LIGHTS\n            texCol = mix(texCol, mix(texCol, texCol.yyz, .35)*3.5, lightBlink(sp.xz*scale));\n            #endif\n            \n            // Lowering the terrain settings a bit.\n            \n            //specCol *= .5; \n            // Add some very subtle, almost imperceptible noise to the specular color. I wanted the\n            // surface to have a laminated sheen, but not completely smooth. I guess you could very\n            // subtly bump the surface, but this is much easier and more suited to the example.\n            specCol *= (n3D(sp*96.)*.66 + n3D(sp*192.)*.34)*.3 + .35;\n            \n            // Toning down the fake environment lighting on the terrain.\n            env *= texCol/1.5;\n            \n            // Subtle reflective hint of cherry.\n            texCol = mix(texCol, texCol.xzy, dot(ref, vec3(.15)));\n            \n        }\n        else { // The chrome lattice.\n            \n            // Tri-planar texturing\n            texCol = tex3D(iChannel0, sp*tSize0*2., sn);\n            // Taking out a lot of the red and darkening. Shiny chrome looking stuff tends\n            // to require less diffuse but higher reflectivity.\n            texCol = mix(texCol, texCol.xxx, .75)*.35;\n           \n            // Add some golden reflectivity to the ball joins.\n            if(svObjID==2.) env *= vec3(2.2, 1.7, .5);\n            \n            // Alternative gold lattice -- A bit gaudy. :)\n            //texCol *= vec3(8, 6, 4)/4.;\n            //env *= vec3(8, 6, 2)/4.;\n\n \n        } \n        \n\n        // Combining the above terms to procude the final color.\n        sceneCol += (texCol*(diff +  ao*.3 + vec3(1, .9, .7)*fre) + env*1.5 + specCol*spec*2.);\n        \n\n        // Shading. The shadows have minimal effect in this example, but I've cut down on \n        // shadow iterations and left them in.\n        sceneCol *= ao*atten*sh;\n        \n        \n\t\n\t}\n    \n    // Simple dark fog. It's almost black, but I left a speck of color in there to account for \n    // the reflective glow... Although, it still doesn't explain where it's coming from. :)\n    vec3 bg = mix(vec3(1, .5, .6), vec3(.1, .05, .025), clamp(rd.y + .75, 0., 1.));\n    bg = mix(bg, bg.xzy, rd.y*.5 + .5);\n    sceneCol = mix(sceneCol, bg, smoothstep(0., .95, t/FAR));\n\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}