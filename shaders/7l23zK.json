{
    "Shader": {
        "info": {
            "date": "1624368925",
            "description": "Hydrogen orbits. Implicit surface shows surface with probability density = const. Meant to see the shapes, not quantitative. m=0 Shapes are cut open. Use mouse to select a shape from a grid with n growing from the bottom.",
            "flags": 0,
            "hasliked": 0,
            "id": "7l23zK",
            "likes": 18,
            "name": "Hydrogen - Orbits",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "physics"
            ],
            "usePreview": 0,
            "username": "weasel",
            "viewed": 390
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}