{
    "Shader": {
        "info": {
            "date": "1622713966",
            "description": "a simple effect for Ph.D. application in Lund University",
            "flags": 0,
            "hasliked": 0,
            "id": "stf3WS",
            "likes": 0,
            "name": "Ray_baichuan",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "baichuan",
            "viewed": 217
        },
        "renderpass": [
            {
                "code": "\n\n\nfloat Calculate_distance(vec3 point){\n\n    vec4 ball=vec4(1.,1.,5.,1.);\n    float distance_to_ball = length(point-ball.xyz)-ball.w;\n    float distance_to_plane = point.y;\n    float min_distance = min(distance_to_ball,distance_to_plane);\n    return min_distance;\n}\n\nvec3 Calculate_Normal(vec3 point){\nfloat distance_ = Calculate_distance(point);\n    vec2 disturb = vec2(.01,0.);\n    vec3 normal_point = vec3(distance_)-vec3(Calculate_distance(point-disturb.xyy),\n                                            Calculate_distance(point-disturb.yxy),\n                                            Calculate_distance(point-disturb.yyx)); \n    return normalize(normal_point);\n}\n\nfloat Raytrack(vec3 camera_center, vec3 ray_direction){\n    float distance_from_camera = 0.;\n    for(int i=0;i<100;i++){\n        vec3 point = camera_center+ray_direction*distance_from_camera;\n        float distance_to_ball = Calculate_distance(point);\n        distance_from_camera = distance_from_camera + distance_to_ball;\n        if(distance_from_camera>100.) break;\n    }\n    return distance_from_camera;\n}\n\n\nfloat Calculate_Light(vec3 point){\n    vec3 light_position = vec3(2.+4.0*sin(iTime),2.+1.0*sin(iTime),3.+3.0*cos(iTime));\n    vec3 light_to_point = normalize(light_position-point);\n    vec3 normal_point = Calculate_Normal(point);\n    float light_strength = clamp (dot(normal_point,light_to_point),0.,1.);\n    float point_to_light = Raytrack(point+normal_point*0.01*2.,light_to_point);\n    if(point_to_light<length(light_position-point)) light_strength=0.;\n    return light_strength;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    vec3 ball_center = vec3(0.,1.,0.);\n    vec3 ray_direction = normalize(vec3(uv.x,uv.y,1.));\n    float distance_from_camera = Raytrack(ball_center,ray_direction);\n    \n    vec3 point =  ball_center + distance_from_camera*ray_direction;\n    float light = Calculate_Light(point);\n\tvec3 col = vec3(light);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}