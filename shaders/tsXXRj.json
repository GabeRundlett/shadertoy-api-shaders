{
    "Shader": {
        "info": {
            "date": "1551667991",
            "description": "3d audio of a sphere bouncing inside a cube, try with headphones or something with stereo audio",
            "flags": 8,
            "hasliked": 0,
            "id": "tsXXRj",
            "likes": 18,
            "name": "3d audio of sphere bouncing",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "sphere",
                "audio",
                "bounce",
                "march",
                "trace"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 1009
        },
        "renderpass": [
            {
                "code": "\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return WALLS_SIZE-max(ap.x,max(ap.y,ap.z));\n}\nfloat sphere(vec3 p) {\n    SPHERE_POS(iTime);\n    return length(p-b)-SPHERE_RADIUS;\n}\n\n//normal from distance function\n#define nf(p,df) \\\nnormalize(vec3(df(p+vec3(NORMAL_PRECISION,0,0))-df(p+vec3(-NORMAL_PRECISION,0,0)),\\\ndf(p+vec3(0,NORMAL_PRECISION,0))-df(p+vec3(0,-NORMAL_PRECISION,0)),\\\ndf(p+vec3(0,0,NORMAL_PRECISION))-df(p+vec3(0,0,-NORMAL_PRECISION))))\n    \n//ray march distance function\n#define trace(df,trp,trd,iter,eps) \\\nfor (i = 0; i < iter; i++) {\\\n    float d = df(trp)+eps;\\\n    if (d < eps) {break;}\\\n    trp += trd*d;\\\n}\n    \nvoid mainImage( out vec4 o, in vec2 u)\n{\n    //initial ray\n\tvec3 rp = CAMERA_POS,\n        rd = vec3(normalize(vec3((u*2.-iResolution.xy)/iResolution.x,.5)));\n    \n    //trace scene\n    int i;\n    #define dm(df,crp,dd,iter,eps) vec3 crp = rp;\\\n    trace(df,crp,rd,iter,eps);\\\n    float dd = i<iter?length(crp-rp):VIEW_DISTANCE\n\n    dm(walls,wrp,wd,32,0.2);\n    dm(sphere,srp,sd,4,0.2);\n        \n    //light flashing orange when sphere hits wall\n    SPHERE_POS(iTime);\n    vec3 a = abs(b)-(WALLS_SIZE-SPHERE_RADIUS),\n        cc = mix(vec3(.1,.2,1),vec3(1.,.5,.1),max(0.,5.+max(a.x,max(a.y,a.z)))/5.);\n    if (sd < wd) {\n        o = vec4(cc*4.*(.5+.5*dot(rd,normalize(b-srp))),1);\n    } else {\n        //light wall with sphere\n        vec3 nrm = nf(wrp,walls), ld = b-wrp;\n        o = vec4(cc*10.*(.5+.5*dot(nrm,normalize(ld)))/(1.+length(ld)),1);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define WALLS_SIZE 40.\n#define SPHERE_RADIUS 1.\n#define SPHERE_VELOCITY vec3(.543,0.57,0.236)\n#define SPHERE_POS(tim) vec3 t = fract(tim*SPHERE_VELOCITY), b = (t*4.-max(t*8.-4.,0.)-1.)*(WALLS_SIZE-SPHERE_RADIUS)\n#define CAMERA_POS vec3(0,0,-39)\n#define NORMAL_PRECISION 1e-4\n#define VIEW_DISTANCE 1e7\n#define EAR_DISTANCE .5",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 mainSound( in int samp,float time)\n{\n    SPHERE_POS(time);\n    vec3 d = b-CAMERA_POS, n = normalize(d), a = abs(b)-(WALLS_SIZE-SPHERE_RADIUS);\n    float wv = sin(time*1000.)*10.*max(0.,.1+max(a.x,max(a.y,a.z)));//ball bounce sound\n    \n    //3d audio using position and ear direction\n    #define ev(o) pow(.5+.5*dot(n,normalize(vec3(o,0,.5))),2.)*\\\n    min(1.,1000.*exp(length(d-vec3(o,0,0)*EAR_DISTANCE)*-.1))\n    \n    return vec2(ev(-1),ev(1))*wv;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}