{
    "Shader": {
        "info": {
            "date": "1718049243",
            "description": "ADMINS PLS view mail.. \n\n\n/*originals \ncopy-paste from many sources Iâ€™m just learning myself\n\nMIT LICENSE\n*/\n\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4XV3R3",
            "likes": 3,
            "name": "self logo",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 113
        },
        "renderpass": [
            {
                "code": "/*\nADMINS PLS view mail.. very need\n\n\noriginals reads like a spider, but like a candidate of sciences, the best of the best in 1.6 = D*/\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI      3.141592653\n#define PI2     6.283185307\n\n#define MAX_DIST    25.\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform vec2 channel0;\n#define  time iTime\n#define  resolution iResolution.xy\n\n#define texture(s, uv) vec4(0.0)\n\n#define F2 float\n#define V vec2\n#define W vec3\n#define N normalize\n#define L length\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define S(x) sin(x+2.*sin(x))\n#define col(x) (cos((x+W(0,.3,.4))*6.28)*.5+.5)\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nmat2 rot2(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nvec3 hit, hitpt;\nmat2 rx,ry,r56,r56n;\n\n//@iq box and extrude\nfloat opx( in vec3 p, float d, in float h )\n{\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat text_(vec2 p){\n    return box(p,vec2(.275,.275));\n}\n\nfloat text_n(vec2 p){\n    float d = box(vec2(abs(p.x)-.17,p.y),vec2(.08,.275));\n    vec2 pv = p*r56;\n    float e = box(pv,vec2(.075,.225));\n\n    return max(min(d, e),text_(p));\n}\nmat2 rotate2D( float t ) {\n    float c = cos( t );\n    float s = sin( t );\n    return mat2( c, s, -s, c );\n}\n\nfloat text_z(vec2 uv){\n    uv.y=abs(uv.y);\n    float lete = box(uv-vec2(.0, .0),vec2(.05,.3));\n    lete = min(box(uv-vec2(.1, .0),vec2(.10,.05)),lete);\n    lete = min(box(uv-vec2(.1, .25),vec2(.15,.05)),lete);\n    return lete;\n}\nfloat text_Y( vec2 p ) {\n    float s = max(\n        min(\n            box( ( p - vec2( -0.12, 0.0 ) ) * rotate2D( PI * 0.14 ), vec2( 0.05, 0.5 ) ),\n            box( ( p - vec2( 0.12, .0 ) ) * rotate2D( -PI * 0.14 ), vec2( 0.050, 0.5 ) )\n           \n        ),\n       \n        box( p, vec2( 0.2, 0.25 ) )\n    );\nfloat e = box(p-vec2(0,-0.35),vec2(0.05,0.121));\n    return s*e;\n}\nfloat textA( vec2 p ) {\n    float s = max(\n        min(\n            box( ( p - vec2( -0.12, 0.0 ) ) * rotate2D( -PI * 0.14 ), vec2( 0.06, 0.5 ) ),\n            box( ( p - vec2( 0.12, 0.0 ) ) * rotate2D( PI * 0.14 ), vec2( 0.06, 0.5 ) )\n           \n        ),\n       \n        box( p, vec2( 0.3, 0.25 ) )\n    );\nfloat e = box(p-vec2(0,-0.1),vec2(.1,.025));\n    return s*e;\n}\n\nfloat textK( vec2 p ) {\n\n    float s = box( p - vec2( -0.25, 0.0 ), vec2( 0.05, 0.35 ) );\n   \n    s = min( s, max(\n        abs( box( p - vec2( -0.42, 0.08 )* rotate2D( PI * 10.34 ), vec2( 0.55, 0.0 ) )  ) - 0.05,\n        box( p, vec2( 0.3, 0.25 ) )\n    ) );\n   \n    s = min( s, max(\n        box( ( p - vec2( -0.2, 0.0 ) ) * rotate2D( PI * 1.24 ), vec2( 0.05, 0.5 ) ),\n        box( p - vec2( 0.0, -0.25 ), vec2( 0.3, 0.3 ) )\n    ) );\n       s = min( s, max(\n        box( ( p*rotate2D( -45. )  ) , vec2( 0.05, 0.5 ) ),\n        box( p - vec2( 0.0,0.1 ), vec2( 0.2, 0.3 ) )\n    ) );\n     \n     \n\n    return s;\n}\n\nfloat swtch;\n\nvec2 map (in vec3 p) {\n    vec2 res = vec2(1e5,-1.);\n\n    vec3 q = p;\n\n    float tt,id;\n\n   \n\n    float d = text_n(q.xy+vec2(.90,0));\n    d = min(d,textA(q.xy+vec2(.30,0)));\n \n    d = min(d,text_Y(q.xy-vec2(.30,0)));\n    d = min(d,textK(q.xy-vec2(.90,0)));\n \n   \n    float fd = opx(q,d,.18);\n   \n    float e = opx(q,abs(d-.02)-.0085,.15);\n   \n    if(fd<res.x) {\n        res=vec2(fd*.8,1);\n        hit=p;\n    }\n    if(e<res.x&&mod(id,1.)==0.) {\n        res=vec2(e*.75,2);\n        hit=p;\n    }\nreturn res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x +\n h.yyx*map( p + h.yyx*e ).x +\n h.yxy*map( p + h.yxy*e ).x +\n h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n)\n{\n    vec3 clr;\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(.1,3,2);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.5);\n    fresnel = mix(.01, .7, fresnel);\n\n    float cpx = swtch<1. ? hit.x : hit.y;\n    if(m==1.) clr = .5 + .4 *sin(cpx*.75+ vec3(2.5,1.,.5));\n    if(m==2.) clr = .5 + .4 *sin((cpx+15.25)*1.+ vec3(2.5,1.,.5));\n   \n    vec3 h = mix(vec3(0),clr,diff);\n\n    return h;\n}\n\n\nvec3 renderAll( in vec2 F )\n{  \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 C=vec3(.0);\n\n    uv*=rot(.48);\n    vec3 ro = vec3(0,0,2),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) || M.z <0. ? 0. :  (M.y/R.y * .3 - .15) * PI;\n    float y = M.xy == vec2(0) || M.z <0. ? 0. : -(M.x/R.x * .3 - .15) * PI;\n\n    rx = rot(-.48+x);\n    ry = rot(y);\n   \n  \n   \n    vec3  p = ro + rd * .1;\n    float atten = .75;\n    float k = 1.;\n    float b = 5.;\n    float iv = 1.;\n   \n    // loop inspired/adapted from @blackle's\n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<132;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float fresnel=0.;\n        float d = ray.x;\n        float m = ray.y;\n\n        p += rd * d *k;\n       \n        if (d*d < 1e-9) {\n\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(b<0.)break;\n           \n            atten *= .65;\n            p += rd*.0001;\n            k = sign(map(p).x);\n           \n            b--;\n\n            p += rd*.005;\n            k = sign(map(p).x);\n       \n            vec3 rf=refract(rd,n,iv > 0. ? 1./1.1 : 1.075);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.001;\n           \n        }  \n       \n       \n        if(distance(p,rd)>50.) { break; }\n    }\n    return C;\n   \n}\n\n\nvoid mainImage( out vec4 O, in vec2 F )\n{  \n vec2 uv = (F - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Synergy shader by @kishimisu\n    vec2 g = iResolution.xy;\n    vec2 o = (F + F - g) / g.y / 0.5;\n    float f = iTime * 0.05 - 2.0;\n     O = vec4(0.0);\n   \n    O.xyz = vec3(0.2, 0.05, 0.15);\n    for (float l = 0.0; l < 55.0; l++) {\n        float group = mod(l, 10.0) / 10.0;\n        float transition = fract(-iTime * 0.2 + group);\n        float depth = pow(transition, 0.5);\n        vec2 offset = vec2(cos(l * f * 0.2), sin(l + f));\n        float fade = smoothstep(0.5, 0.3, abs(0.5 - transition));\n        vec2 p = o * (mod(l, 5.0) + 1.0) * depth + offset;\n        float s = 0.08 + (1.0 - transition) * 0.4 * step(1.0, 1.0 / abs(mod(l, 40.0)));\n        float a = mod(atan(p.y, p.x) + iTime*0.01 * (step(20.0, l) - 0.5), 3.14);\n        float d = length(p) + 0.005 * sin(10.0 * a + iTime + l);\n        O += clamp(fade * pow(0.005, 1.0 - 0.2 * (sin(iTime + l) * 0.5 + 0.5)) * transition / abs(d - s) * (cos(l + length(o) * 3.0 + vec4(0, 1, 2, 0)) + 1.0), 0.0, 1.0);\n    }\n   \n    // Custom fractal shader\n    F2 i = 0.0, d = 0.0, e = 1.0;\n    W p, pI, rd = N(W(0, 0, 1));\n    rd.zy *= rot(uv.y * 2.0);\n    rd.xz *= rot(-uv.x * 2.5 + S(iTime * 0.0) * 4.0 + 0.03 * S(iTime + uv.x * 0.0));\n   rd.z+=cos(iTime);\n    F2 c;\n    for (F2 ii = 1.0; ii <= 99.0; ii++) {\n        if (e <= 0.0001)\n            break;\n        pI = p = d * rd;\n        F2 sz = 0.25 *rd.x;\n        sz = max(sz, 0.1);\n        p.z += (iTime * 0.05) + rd.x * 0.01;\n        p.zy = p.yz;\n        F2 s, ss = 1.5;\n        p.xz *= s = 1.0 + 0.5 * S(pI.y * 2.0 - iTime*0.01);\n        ss *= s;\n \n        c = 0.0;\n        for (F2 j = 1.0; j <= 2.0; j++) {\n            p.xz *= rot(iTime*2.1 + S(iTime*0.1 * 0.4 * 1.61 + pI.z * 1.0 + j));\n            ss *= s = 3.0;\n            p *= s;\n           \n            p.y += 0.5 + j / 10.0;\n            p.y = fract(p.y) - 0.5;\n            p = abs(p) - 0.5 +rd.x * 0.1 + 0.2 * S(pI.z * 0.1 + iTime * 0.0);\n            if (p.z < p.x)\n                p.xz = p.zx;\n               \n            if (p.y > p.x)\n                p.xy = p.yx;\n            c += L(p) * 0.01;\n        }\n\n        p -= clamp(p, -sz, sz);\n        d += e = (L(p.xy) - 0.0001) / ss;\n         d += e = (L(p.xz) - 0.0001) / ss;\n        i++;\n    }\n\n    vec3 color = 15.0 / i * col(log(d) * 1.1 + c * 5.0 + iTime * 1.0);\n \n   \n    swtch = mod(T*.08,2.)*color.z;\n    r56 = rot(2.56);\n    r56n = rot(-.56);\n   \n    vec3 C = renderAll(F);\n    C +=renderAll(F+vec2(.5,.5));\n      \n\n    O = vec4(sqrt(smoothstep(0.,1.,C)),1.0);\n  \n}\n//end\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}