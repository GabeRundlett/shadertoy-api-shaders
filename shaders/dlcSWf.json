{
    "Shader": {
        "info": {
            "date": "1686174962",
            "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "dlcSWf",
            "likes": 31,
            "name": "Year of Truchets #032",
            "published": 3,
            "tags": [
                "raymarching",
                "hexagon",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 454
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #032\n    06/07/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265\n#define PI2         6.28318530\n#define SQ3         1.732\n\n#define MIN_DIST 1e-3\n#define MAX_DIST 55.\n\n// globals and constants\nmat2 r60;\nvec2 speed=vec2(0);  \nvec3 hp=vec3(0),hit=vec3(0);\nvec4 hexTiles=vec4(0);\nfloat trigger=0.,stored=0.,tspeed=0.;\n\n// precal for speed\nconst float scale = .075;\nconst float sx = 23.0933;//SQ3/scale;\nconst float s4 = .577350;\nconst float s3 = .288683;\n\nconst float rep = 14.;\nconst float hrep = 7.;//rep/2.;\nconst float angle = .44879;//2.*PI/rep;\nconst float angfl = .22439;//angle/2.;\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\n\n// @iq.\nfloat ext(in float sdf, in float pz, in float h){vec2 w = vec2( sdf, abs(pz) - h );return min(max(w.x, w.y), 0.) + length(max(w, 0.));}\nfloat box( vec3 p, vec3 b ) {vec3 q=abs(p)-b;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat torus( vec3 p, vec2 t ) {vec2 q = vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\nfloat cap( vec3 p, float r, float h ) {vec2 d = abs(vec2(length(p.xz),p.y))-vec2(h,r);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat vcap( vec3 p, float h, float r ) {p.y -= clamp(p.y,0.,h);return length(p) - r;}\n\n// @Mercury_sexy\nfloat polar(inout vec2 p)  {\n    float a = atan(p.y, p.x) + angfl;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angfl;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (hrep)) ? abs(c) : c;\n} \n\nfloat column(vec3 q) {\n    float b = cap(q,.15,.05);\n    float c = box(vec3(q.x,abs(q.y)-.15,q.z),vec3(.065,.0125,.065))-.0005;\n    polar(q.xz);\n    float g = vcap(q-vec3(.07,-.1,0),.2,.025);\n    return min(c,max(b,-g));\n}\n// @Shane\nvec4 hexGrid(vec2 uv) {\n    const vec2 s = vec2(SQ3, 1.);\n    vec4 hC = floor(vec4(uv, uv - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h4 = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n    return dot(h4.xy, h4.xy) < dot(h4.zw, h4.zw) ? vec4(h4.xy, hC.xy) : vec4(h4.zw, hC.zw + .5);\n}\nfloat hex( in vec2 p, in float r ) {\n    const vec3 k = vec3(-.8660254,.5,.5773502);\n    p = abs(p);\n    p -= 2.*min(dot(k.xy,p),0.)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvec2 map(vec3 pos) {\n    vec2 res =vec2(1e5,0.);\n    pos *= scale;\n\n    hexTiles=hexGrid(pos.xz);\n    vec2 p  = hexTiles.xy;\n    vec2 id = hexTiles.zw;\n\n    float rnd = hash21(id);\n    float dir = 1.;\n\n    if (rnd>.5) {p *= r60; p.y=-p.y; dir = -1.;} \n    \n    // set vectors\n    vec2 p0 = p - vec2(-s3,.5);\n    vec2 p1 = p - vec2(s4,0);\n    vec2 p2 = p - vec2(-s3,-.5);\n\n    vec3 pp1 = vec3(p1.x,pos.y,p1.y);\n    vec3 pp2 = vec3(p2.x,pos.y,p2.y);\n    vec3 pp3 = vec3(p0.x,pos.y,p0.y); \n\n    float tk = .115+.05*sin(pos.z*1.5);\n    float tp = min(min(torus(pp1,vec2(s3,tk)),torus(pp2,vec2(s3,tk))),torus(pp3,vec2(s3,tk)));\n\n    float f= max(ext(hex(p,.49),pos.y+.1,.1),-tp)-.0035;\n    if(f<res.x) {\n        res=vec2(f,1.);\n        hp=vec3(p.x,pos.y+.1,p.y);\n    }\n\n    vec3 cp=vec3(p.x,pos.y-.165,p.y);\n    float c = column(cp);\n    if (c<res.x) {\n        res = vec2(c,5.);\n        hp = cp;\n    } \n\n    vec3 pm = pos*1.75+vec3(tspeed);\n    float fm = fbm(pm.xz)*.08;\n\n    float g = pos.y-.01+fm;\n    if (g<res.x) {\n        res = vec2(g,2.);\n        hp = pos;\n    } \n\n    // rescale\n    res.x *= 1./scale;\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<90;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<28?ray.x*.25:ray.x*.9;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec4 FC = vec4(0.169,0.263,0.271,.075);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    hit = hp;  \n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-12.*sin(T*.08),15.,12.*cos(T*.08));\n        vec3 l = normalize(lpos);\n        \n        vec3 h = vec3(.5);\n        float diff = clamp(dot(n,l),.01,.95);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 10.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 10.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        \n        if(m==1.) { \n            h=tex3D(iChannel0,hit*2.,n).rgb; \n            h=mix(h,vec3(.5),.25);\n            ref=h;\n        }\n        if(m==2.) { \n            h=vec3(.1,.22,.24); \n            ref=h;\n        }\n        if(m==5.) { \n            h=vec3(.5); \n            ref=h*.1;\n        }\n           \n        C = (diff*h);\n\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r60 = rot(1.047197);\n    tspeed = T*.45;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(18,0,10);\n    vec3 rd = normalize(vec3(uv,-1));\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*1.-.5)*PI;\n\n    mat2 rx = rot(x-.525), ry = rot(y+T*.02);\n      // mouse //\n    ro.zy*=rx;ro.xz*=ry;\n    rd.zy*=rx;rd.xz*=ry; \n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref=vec3(0), fil=vec3(.95);\n    float d = 0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00006*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float random (in vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n// this works on OSX/PC without fracture lines.\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1, 0));\n    float c = random(i + vec2(0, 1));\n    float d = random(i + vec2(1, 1));\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 uv) {\n    float v = .0;\n    float a = .5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(.5), sin(.5),-sin(.5), cos(.5));\n    for (float i = 0.; i < 4.; ++i) {\n        v += a * noise(uv);\n        uv = rot * uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}