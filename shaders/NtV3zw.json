{
    "Shader": {
        "info": {
            "date": "1637402033",
            "description": "A minimal abstract geometric representation of a molecular structure, but basically just a simple hexagonal grid pattern. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "NtV3zw",
            "likes": 36,
            "name": "Hexagon Molecule Pattern",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "hexagon",
                "vector",
                "pattern",
                "art",
                "molecule"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 714
        },
        "renderpass": [
            {
                "code": "/*\n\n\tHexagon Molecule Pattern\n\t------------------------\n    \n    This is a minimal abstract geometric representation of a molecular structure, \n    or to put it another way, it's another typical hexagon grid based pattern. :)\n    \n    Sometimes, I like to take a break from coding things that require thinking and\n    do something easy. Variations on this particular pattern are everywhere, \n    especially in the world of stock imagery. The basic vector style I've chosen is \n    even more of a cliche, but it's simple and effective.\n\n\tThere are several ways to produce a pattern like this, but since it's just a\n    basic 2D overlay example that isn't taxing on the GPU, I've chosen the most direct \n    one, which is to produce a hexagonal grid, then iterate through all six sides and \n    vertices of the cells that have been flagged for rendering. There's definitely \n    better ways to go about it, like using polar coordinates, etc. If you only wanted \n    to render random sides, then a triangle grid would probably make things easier.\n    \n    I almost rendered this in offset vertex form, but decided to keep things simple.\n    However, that's always an option at a later date. By the way, I've put in some\n    \"defines\" to change the overall color scheme if green's not your thing. :)\n\n\t\n    Other Hexagonal Pattern Examples:\n\n\n\tdemocapsid -- remaindeer \n\thttps://www.shadertoy.com/view/sltGDj\n\n    sci-fi hexagons  -- laserdog \n\thttps://www.shadertoy.com/view/Mlcczr\n\n    Hexagons - distance -- iq \n    https://www.shadertoy.com/view/Xd2GR3\n    \n    Berry stairs - duvengar\n    https://www.shadertoy.com/view/Ns2GRz\n    \n\n*/\n\n\n// Color scheme - Blue: 0, Red: 1, Green 2.\n#define COLOR 2\n\n// Greyscale background.\n//#define GREYSCALE\n\n// Show the hexagon grid that the pattern is based on...\n// Probably a little redundant in this case, but it's there.\n//#define SHOW_GRID\n\n#define FLAT_TOP\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\nfloat hash21(vec2 p){ \n    \n    return fract(sin(dot(p, vec2(27.619, 57.643)))*43758.5453); \n    \n    /*\n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskins's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y)*p3.z);\n    */\n    \n    /*\n    // IQ's vec2 to float hash.\n    // An accuracy hack for this particular example. Unfortunately, \n    // \"1. - 1./3.\" is not always the same as \"2./3.\" on a GPU.\n    p = floor(p*32768.)/32768.;\n    return fract(sin(dot(p, vec2(27.617, 57.743)))*43758.5453); \n    */\n}\n\n\n// IQ's box formula.\nfloat sBox(in vec2 p, in vec2 b){\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// A box between points. Here's it's used to draw lines, but it has\n// other uses.\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    //p = rot2(3.14159/6.)*(p - mix(a, b, .5));\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n    \n   //vec2 l = abs(b - a) + ew/2.;\n   //return sBox(p - vec2(mix(a.x, b.x, .5), mix(a.y, b.y, .5)), (l + ew)/2.) ;\n}\n\n\n// Flat top hexagon, or pointed top.\n#ifdef FLAT_TOP\nconst vec2 s = vec2(1.732, 1);\n#else\nconst vec2 s = vec2(1, 1.732);\n#endif\n\n// Hexagon vertex IDs. They're useful for neighboring edge comparisons, etc.\n// Multiplying them by \"s\" gives the actual vertex postion.\n#ifdef FLAT_TOP\n// Vertices: Clockwise from the left.\n                     \n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n\n#else\n// Vertices: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\n\n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-6, -2), vec2(-6, 2), vec2(0, 4), \n                      vec2(6, 2), vec2(6, -2), vec2(0, -4));\n\nconst vec2[6] eID = vec2[6](vec2(-6, 0), vec2(-3, 3), vec2(3, 3), vec2(6, 0), \n                      vec2(3, -3), vec2(-3, -3));\n\n#endif\n\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top and pointed top hexagons.\n    #ifdef FLAT_TOP\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n    #else   \n    return max(dot(abs(p.xy), s/2.), abs(p.x*s.x));\n    #endif\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    // The ID is multiplied by 12 to account for the inflated neighbor IDs above.\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy*12.) : vec4(q.zw, ip.zw*12. + 6.);\n    //return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n\n// Using random vertex IDs to produce animated variable sized vertices.\nvec4 getSz(vec4 p, int i){\n\n    // Sizes for each side of the edge.\n    vec2 sz = vec2(hash21(p.zw + vID[i]), hash21(p.zw + vID[(i + 1)%6]))*.4 + .6;\n    \n    // Blinking animation variables.\n    vec2 szB = vec2(hash21(p.zw + vID[i] + .1), hash21(p.zw + vID[(i + 1)%6] + .1));\n    szB = smoothstep(.9, .98, sin(6.2831*szB + iTime*1.)*.5 + .5);\n \n    // Final sizes.\n    sz *= 1. + szB*.1;\n    \n    // Returning the two sizes and two blinking factors.\n    return vec4(sz, szB);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Global scale factor.\n    const float sc = 5.;\n    // Smoothing factor.\n    float sf = sc/res;\n    \n    // Scene rotation, scaling and translation.\n    mat2 sRot = rot2(3.14159/12.); // Scene rotation.\n    vec2 camDir = sRot*normalize(s); // Camera movement direction.\n    vec2 ld = sRot*normalize(vec2(1, -1)); // Light direction.\n    vec2 p = sRot*uv*sc + camDir*iTime/3.;\n    \n    \n    \n    \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p);\n    // Hexagonal grid coordinates for the shadow.\n    vec4 p4Sh = getGrid((p - ld*.15));\n\n   \n    \n        \n    // Rendering the grid boundaries, or just some black hexagons in the center.\n    float gHx = getHex(p4.xy);\n    \n    \n    float edge = 1e5, vert = 1e5;\n    float shad = 1e5;\n    \n    // Edge width.\n    float ew = .025;\n    \n    // Random threshold.\n    float rndTh = .4;\n    #ifdef SHOW_GRID \n    // Increase the threshold so that all hexagons are rendered.\n    rndTh = 1.;\n    #endif\n    \n    float gSz = 1e5;\n    \n    // Random value for the top layer cell and the shadow cell.\n    float rnd = hash21(p4.zw);\n    float rndSh = hash21(p4Sh.zw);\n    \n    vec2 sDiv12 = s/12.;\n     \n    // Iterate through all six sides of the hexagon cell.\n    for(int i = min(0, iFrame); i<6; i++){\n   \n\n        // If the random cell ID is under a certain threshold, render\n        // from both the cell and it's neighbor's perspective.\n        \n        float rndN = hash21((p4.zw + eID[i]*2.));\n        if(rnd<rndTh || rndN<rndTh){\n        \n            // Produce the edge for this particular side.\n            edge = min(edge, lBox(p4.xy, vID[i]*sDiv12, vID[(i + 1)%6]*sDiv12, ew));\n            \n            // Edge sizes and associated animation factors.\n            vec4 sz = getSz(p4, i);\n            \n            // Vertices at the ends of this edge.\n            float v1 = length(p4.xy - vID[i]*sDiv12) - ew*6.*sz.x;\n            float v2 = length(p4.xy - vID[(i + 1)%6]*sDiv12) - ew*6.*sz.y;\n            \n            // Save the blinking factor for vertex colorization.\n            if(min(v1, v2)<vert) gSz = v1<v2? sz.z : sz.w;\n            \n            // Vertices for this edge.\n            vert = min(vert, min(v1, v2));                                                 \n            \n        }\n        \n       \n        // Doing the same for the shadow.        \n        rndN = hash21((p4Sh.zw + eID[i]*2.));\n        if(rndSh<rndTh || rndN<rndTh){\n        \n            // Shadow edge.\n            shad = min(shad, lBox(p4Sh.xy, vID[i]*sDiv12, vID[(i + 1)%6]*sDiv12, ew));\n            \n            vec4 sz = getSz(p4Sh, i);\n            \n            shad = min(shad, min(length(p4Sh.xy - vID[i]*sDiv12) - ew*6.*sz.x, \n                                 length(p4Sh.xy - vID[(i + 1)%6]*sDiv12) - ew*6.*sz.y));\n            \n        }\n\n    }\n    \n    // The scene color.\n    // Rotating the gradient to coincide with the light direction angle.\n    vec2 ruv = rot2(atan(ld.y, ld.x) + 3.14159/2.)*uv;\n    //\n    // Blue gradient background.\n    vec3 bg = mix(vec3(.7, .8, 1), vec3(.7, .9, 1), smoothstep(.3, .7, ruv.y*.5 + .5));\n    //\n    #if COLOR == 1\n    bg = bg.zyx; // Redish background.\n    #elif COLOR == 2\n    bg = bg.yzx; // Powder lime background.\n    #endif\n    \n    // Saving the background gradient color sans pattern overlay.\n    vec3 bgColor = bg;\n    \n    \n    /*\n    // Line pattern. Not used.\n    ruv = rot2(-3.14159/6.)*p;\n    float lSc = (30.*1.732/sc);\n    float pat = (abs(fract(ruv.y*lSc) - .5) - .25)/lSc;\n    //pat = max(pat, -(pat + .25/lSc));\n    */\n    \n    // A higher frequency hexagon pattern for the background.\n    vec4 pat4 = getGrid(p*3.);\n    float patHx = (getHex(pat4.xy) - .4)/3.;\n    \n    // Subtly blend the hexagon pattern with the background.\n    bg = mix(bg, mix(bgColor, bgColor*bgColor*.85, .35), (1. - smoothstep(0., sf, patHx)));\n    //bg = mix(bg, bg*.95, (1. - smoothstep(0., sf, abs(patHx + .005) - .01))); // Borders.\n    //bg = mix(bg, vec3(0), (1. - smoothstep(0., sf, pat))*.07);\n    \n    \n    // Greyscale background, if desired.\n    #ifdef GREYSCALE\n    bg = vec3(1)*dot(bg, vec3(.299, .587, .114));\n    #endif\n    \n    \n    // Render the shadows onto the background.\n    //shad = max(shad, -(shad + .04));\n    vec3 col = mix(bg, vec3(0), (1. - smoothstep(0., sf, shad))*.25);\n    \n    // Rendering the edges.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, edge)));\n    \n    // Rendering the vertices.\n    vec3 svBg = bgColor;\n    svBg = mix(svBg, vec3(1), .75);\n    svBg = mix(svBg, min(pow(bgColor, vec3(6))*3., 1.), gSz*.65);\n    // Vertex stroke and centers.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert)));\n    col = mix(col, svBg, (1. - smoothstep(0., sf, vert + .04)));\n    \n    \n    // Vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}