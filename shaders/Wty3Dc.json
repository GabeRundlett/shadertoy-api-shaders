{
    "Shader": {
        "info": {
            "date": "1580024458",
            "description": "I'm not sure how exactly this is related to \"Torus knot\" since my construction is more like \"Depth modulated hypertrochoid/epitrochoid with thickness\".\nWhat I mean by \"Knotted Hyper/Epitrochoid\" can be seen here https://www.shadertoy.com/view/wlGGW3.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wty3Dc",
            "likes": 3,
            "name": "Hyper/Epitrochoid 2D Section",
            "published": 3,
            "tags": [
                "2d",
                "torus",
                "epitrochoid",
                "hypertrochoid"
            ],
            "usePreview": 0,
            "username": "hiogawa",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "//\n// 2D Section of Rotating Knotted Hyper/Epi-Trochoid\n//\n// NOTE:\n// - \"ROT_VELOCITY\" here doesn't necessarily give angular velocity around any axis\n//   since this is a derivative of extrinsic rotation angles xyz in this order.\n//   This might be the reason why \"vec3(M_PI, M_PI, M_PI)\" already does crazy stuff.\n// - Surprisingly \"Hyper\" and \"Epi\" give visually similar results.\n//   But, \"Epi\" requires more points to approximate curve since \"Epi\" curve is longer thant \"Hyper\".\n//   So \"Hyper\" might be the ones should be used.\n// - \"KNOTNESS > 1.0\" and \"KNOTNESS < 1.0\" give quite different results as expected.\n//\n\n#define M_PI 3.14159\n\nfloat AA = 2.0;\nfloat SCALE_TIME = 0.5;\nvec2  UV_CENTER = vec2(0.0, 0.0);\nfloat UV_HEIGHT = 3.0;\n\nfloat CHECKER_SCALE = 1.0;\nvec3  CHECKER_COLOR0 = vec3(0.1);\nvec3  CHECKER_COLOR1 = vec3(0.2);\nvec4  SECTION_COLOR = vec4(0.8, 1.0, 1.0, 0.9);\n\nconst float kEpi = 0.0;\nconst float kHyper = 1.0;\n\n// == Curve parameter ==\n// [ KNOTNESS > 1.0 ]\nconst float EPI_OR_HYPER = kHyper;\nfloat NUM_SYMMETRY = 4.0;\nfloat KNOTNESS = 2.5;\nfloat NUM_SEGMENTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\nfloat BEBEL_WIDTH = 0.15;\n\n// [ KNOTNESS < 1.0 ]\n// const float EPI_OR_HYPER = kHyper;\n// float NUM_SYMMETRY = 3.0;\n// float KNOTNESS = 0.2;\n// float NUM_SEGMENTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\n// float BEBEL_WIDTH = 0.15;\n\n// == Rotation ==\n// vec3  ROT_VELOCITY = vec3(M_PI, 0.0,  0.0);\n// vec3  ROT_VELOCITY = vec3(M_PI, 0.0,  M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI, 0.0);\nvec3  ROT_VELOCITY = vec3(M_PI, M_PI, M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI, 0.5 * M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI * 4.0 / 3.0, M_PI * 5.0/ 4.0);\n\n\nfloat distance_Point_LineSegment(vec3 p, vec3 q1, vec3 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n  vec3 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0000001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\nvec3 knottedTrochoidPoint(float t, float r1, float r2, float r3, float type) {\n  float n = r1 / r2;\n  vec3 q;\n  if (type == kHyper) {\n    q = vec3(\n      // usual hyper-trochoid formula\n      (r1 - r2) * cos(t) + r3 * cos((1.0 - n) * t),\n      (r1 - r2) * sin(t) + r3 * sin((1.0 - n) * t),\n      // knot by waving z coord along symmetry\n      sin(n * t));\n  }\n  if (type == kEpi) {\n    q = vec3(\n      // usual epi-trochoid formula\n      (r1 + r2) * cos(t) + r3 * cos((1.0 + n) * t - M_PI),\n      (r1 + r2) * sin(t) + r3 * sin((1.0 + n) * t - M_PI),\n      // knot by waving z coord along symmetry\n      sin(n * t));\n  }\n  return q;\n}\n\n//\n// Re-parameterize hyper/epi-trochoid for easier visual control\n//\n//   \"num_symmetry\"\n//     n = r1 / r2 = 1 / r2 \\in N\n//\n//   \"knotness\" (knot (a > 1), intersecton (1 > a > 0), no-intersection (0 > a))\n//     r3 = (1 - a) r2 + a * (r1 - r2)  (for hyper-trochoid)\n//     r3 = (1 - a) r2 + a * (r1 + r2)  (for epi-trochoid)\n//\nfloat signedDistanceToKnottedTrochoid(\n    vec3 p, float type, float knotness, float num_symmetry,\n    float num_segments, float bebel_width) {\n\n  // Take care reparameterization and normalize overall size to about [-1, 1]^2\n  float r1 = 1.0;\n  float r2 = 1.0 / num_symmetry;\n  float r3, size; {\n    if (type == kHyper) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 - r2);\n      size = r1 - r2 + r3;\n    }\n    if (type == kEpi) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 + r2);\n      size = r1 + r2 + r3;\n    }\n  }\n  r1 /= size; r2 /= size; r3 /= size;\n\n  // Approximate distance by straight lines\n  float min_distance = 1000.0;\n\n  vec3 q1, q2;\n  q1 = knottedTrochoidPoint(0.0, r1, r2, r3, type);\n\n  bool OPTIM_LOOP_WITH_SYMMETRY = true;\n  if (OPTIM_LOOP_WITH_SYMMETRY) {\n    // NOTE: It seems this approach is a bit faster.\n    for (float i = 1.0; i < num_segments / num_symmetry + 1.0; i++) {\n      float t = 2.0 * M_PI * i / num_segments;\n      q2 = knottedTrochoidPoint(t, r1, r2, r3, type);\n      for (float j = 0.0; j < num_symmetry; j++) {\n        float s = 2.0 * M_PI * j / num_symmetry;\n        mat2 rot = mat2(cos(s), sin(s), -sin(s), cos(s));\n        vec3 v1 = vec3(rot * q1.xy, q1.z);\n        vec3 v2 = vec3(rot * q2.xy, q2.z);\n        float sd = distance_Point_LineSegment(p, v1, v2) - bebel_width;\n        min_distance = min(min_distance, sd);\n      }\n      q1 = q2;\n    }\n\n  } else {\n    vec3 q1, q2;\n    q1 = knottedTrochoidPoint(0.0, r1, r2, r3, type);\n    for (float i = 1.0; i < num_segments + 1.0; i++) {\n      float t = 2.0 * M_PI * i / num_segments;\n      q2 = knottedTrochoidPoint(t, r1, r2, r3, type);\n      float sd = distance_Point_LineSegment(p, q1, q2) - bebel_width;\n      min_distance = min(min_distance, sd);\n      q1 = q2;\n    }\n  }\n  return min_distance;\n}\n\n\n//\n// Misc\n//\n\nmat2 rot2(float t) {\n  return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nmat3 rot3(vec3 r) {\n  mat2 x = rot2(r.x);\n  mat2 y = rot2(r.y);\n  mat2 z = rot2(r.z);\n  mat3 X = mat3(\n      1.0,     0.0,     0.0,\n      0.0, x[0][0], x[0][1],\n      0.0, x[1][0], x[1][1]);\n  mat3 Y = mat3(\n    y[1][1],   0.0, y[0][1],\n        0.0,   1.0,     0.0,\n    y[1][0],   0.0, y[0][0]);\n  mat3 Z = mat3(\n    z[0][0], z[0][1],   0.0,\n    z[1][0], z[1][1],   0.0,\n        0.0,     0.0,   1.0);\n  return Z * Y * X;\n}\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nmat3 invViewTransform(vec2 center, float height) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(height * Res.x / Res.y, height);\n  vec2 a = center - size / 2.0;\n  float Sy = height / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0);\n  return xform;\n}\n\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(UV_CENTER, UV_HEIGHT);\n  float inv_view_scale = inv_view_xform[0][0];\n  vec2 uv =  vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Animate transform and coordinate\n    mat4 obj_xform = mat4(rot3(ROT_VELOCITY * t));\n    vec3 p = vec3(uv, 0.0);\n    vec3 p_in_obj = vec3(inverse(obj_xform) * vec4(p, 1.0));\n\n    // Approximate 2d section distance by 3d distance\n    float sd = signedDistanceToKnottedTrochoid(\n        p_in_obj, EPI_OR_HYPER, KNOTNESS, NUM_SYMMETRY, NUM_SEGMENTS, BEBEL_WIDTH);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(color, SECTION_COLOR.xyz, SECTION_COLOR.w * coverage);\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}