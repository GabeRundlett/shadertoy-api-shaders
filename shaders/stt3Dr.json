{
    "Shader": {
        "info": {
            "date": "1636242260",
            "description": "Multiscale Truchet built off the quadtree shaders I've previously been working on - with help from @Shane's Quadtree Truchet example. https://www.shadertoy.com/view/4t3BW4",
            "flags": 0,
            "hasliked": 0,
            "id": "stt3Dr",
            "likes": 23,
            "name": "Multiscale Truchet Tiles",
            "published": 3,
            "tags": [
                "truchet",
                "tile",
                "multiscale",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    MultiScale Truchet [learning]\n    11/6/21 @byt3_m3chanic\n\n    https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n    \n    My original attempt at this >> https://www.shadertoy.com/view/fl33zn \n\n    I had some gaps I couldn't figure out so I turned to @Shane's example \n    to understand how to create layered trickery required for this. \n    \n    @Shane >> Quadtree Truchet ::  https://www.shadertoy.com/view/4t3BW4\n\n    As the pattern scales down the colors alternate, add in that each \n    tile can have \"wings\" that overlap to create the solid positive\n    and negative spaces around the scaling neighbors.\n    \n    I added an extra depth dimension to the quadtree and figured out\n    how to layer that in (i think?). I kept the patterns mostly simple\n    just to figure things out.\n\n    You should also look at this to get an idea of quadtrees in general.\n    @Shane >> Random Quadtree  ::  https://www.shadertoy.com/view/llcBD7\n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n\n// @Shane 2/2 hash.\nvec2 hash22(vec2 p) { \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(57, 27)));\n    return fract(vec2(262144, 32768)*n);\n}\n\nfloat bkptrn(vec2 p, float res) {\n    p *= res/10.;\n    vec2 id = floor(p*.5)-.5;\n    float hatch = clamp(sin((p.x - p.y)*PI*3.)*3. + 0.25, 0., 1.);\n    return clamp(hatch,.3,.7);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 suv = uv;\n\n    uv += T*.040; \n\n    // change scale if window is bigger?\n    // for pattern things you can get a\n    // better - detailed view\n    vec2 vuv= uv*4.;\n  \n    float px = 4./R.x;\n\n    // threshold values\n    const vec2 rndX[4]=vec2[4]( vec2(.5, .25), vec2(.5, .25), vec2(.5, .75), vec2(.5, 1));\n    // Distance field values.\n    vec4 d=vec4(1e5), d2=vec4(1e5), d3=vec4(1e5);\n    float level=1.;\n         \n    // Main loop and neighbor checking from @Shane's shader.\n    // Comments are reduced to the main points I wanted to\n    // remember - please see his shader for full comments and\n    // explanations https://www.shadertoy.com/view/4t3BW4\n        \n    for(int k=0; k<4; k++){\n    \n        vec2 id = floor(vuv*level);\n\n        for(int j=-1; j<=1; j++){\n            for(int i=-1; i<=1; i++){\n\n                // neighboring cell ID.\n                vec2 neighbors = vec2(i,j);\n                vec2 rnd = hash22(id+neighbors);\n                \n                // tiles need to be laid down from largest to smallest. \n                // If a large tile has taken up the space, you need to\n                // check on the next iterations and skip.\n                \n                vec2 rnd2 = hash22(floor((id+neighbors)/2.));\n                vec2 rnd4 = hash22(floor((id+neighbors)/4.));\n                vec2 rnd8 = hash22(floor((id+neighbors)/8.));\n                \n                // If the previous large tile has been rendered, continue.\n                if(k==1 && rnd2.y<rndX[0].y) continue;\n                // If any of the two previous larger tiles have been rendered, continue.\n                if(k==2 && (rnd2.y<rndX[1].y || rnd4.y<rndX[0].y)) continue;\n                // If any of the three previous larger tiles have been rendered, continue.\n                if(k==3 && (rnd2.y<rndX[2].y || rnd4.y<rndX[1].y  || rnd8.y<rndX[0].y )) continue;\n\n                // threshold\n                if(rnd.y<rndX[k].y) {\n\n                    vec2 p = vuv -(id+.5+neighbors)/level;\n                   \n                    // square to mask off tiles.\n                    float square = max(abs(p.x), abs(p.y)) - .5/level;\n\n                    // TILE COLOR ONE.\n                    // Standard Truchet rotation and flipping.\n                    if(rnd.x<rndX[k].x) p.xy = p.yx;\n                    if(fract(rnd.x*57.5 + .35)<rndX[k].x) p.x = -p.x;\n                    \n                    // Four circles on the midway points of the grid boundary\n                    vec2 p2 = abs(vec2(p.y - p.x, p.x + p.y)*.7071) - vec2(.5, .5)*.7071/level;\n                    float c3 = length(p2) - .5/3./level;\n  \n                    // Truchet arc one.\n                    float c = abs(length(p - vec2(-.5, .5)/level) - .5/level) - .5/3./level;\n                    float c2 = abs(length(p - vec2(.5, -.5)/level) - .5/level) - .5/3./level;\n          \n                    // Line variant @Shane\n                    if(fract(rnd.x*113.467 + .51)<.15) c = abs(p.x) - .5/3./level;\n                    if(fract(rnd.x*123.853 + .49)<.15) c2 = abs(p.y) - .5/3./level;\n\n                    float truchet = min(c, c2);\n\n                    c = min(c3, max(square, truchet));\n                    // Tile color one.\n                    d[k] = min(d[k], c);\n                    // for extra decoration\n                    d3[k] = min(d3[k], c);\n\n                    // TILE COLOR TWO.\n                    p = abs(p) - .5/level;\n                    float l = length(p);\n                    \n                    // Four circles at the grid vertices and the square.\n                    c = min(l - 1./3./level, square);\n                    //c = max(c, -truchet);\n                    //c = max(c, -c3);\n                    \n                    // Tile color two.\n                    d2[k] = min(d2[k], c); \n\n                }\n            }\n        }    \n        \n        level*=2.;\n    }\n    \n    // layerd mixdown as each iteration is stored in xyzw\n    d.x = max(d2.x, -d.x);\n\n    float dz = abs(abs(abs(min(d3.w,d3.z))-.05)-.02)-.01;\n    d.x = min(max(d.x, -d2.y),  d.y);\n    d.x = max(min(d.x,  d2.z), -d.z);\n    d.x = min(max(d.x, -d2.w),  d.w);\n    // reuse of d.w - making border\n    d.w=abs(d.x)-.0025;\n\n    float dm = smoothstep(px, -px,d.x);\n    float dn = smoothstep(-px, px,d.x);\n    dz = smoothstep(px, -px, abs(dz)-.0025);\n\n    float ptrn = max(dn,bkptrn(vuv,125.));\n    vec3 C = mix(vec3(.045),vec3(.6),clamp((suv.y+.25)*.5,0.,1.))*ptrn;\n    \n    // color gradient \n    vec3 clrA = mix(vec3(0.902,0.380,0.098),vec3(0.137,0.580,0.804),clamp((suv.y+.45)*1.25,0.,1.));\n    vec3 clrB = vec3(0.706,0.659,0.941);\n    vec3 clrC = vec3(0.031,0.541,0.608);\n\n    // extra decoration\n    C = mix(C, clrA, clamp(dz-dm,0.,1.));\n    C = mix(C, clrC, smoothstep(px, -px, abs(d.y+.075)-.002));\n    // background\n    C = mix(C, C*clrA, smoothstep(.05+px, -px, d.x));\n    // outlines\n    C = mix(C, clrB, smoothstep(px, -px, d.w));\n\n    // Gamma and output\n    C = pow(C, vec3(.4545));        \n    O = vec4(C,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}