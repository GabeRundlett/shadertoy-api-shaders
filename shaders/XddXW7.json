{
    "Shader": {
        "info": {
            "date": "1459815547",
            "description": "Instead of raymarching a distance field described by an equation, we raymarch a propagating L1 distance field derived from the level set of a 3D reaction-diffusion system. Mouse controls the camera.",
            "flags": 32,
            "hasliked": 0,
            "id": "XddXW7",
            "likes": 39,
            "name": "Raymarching a 3D Texture",
            "published": 3,
            "tags": [
                "raymarching",
                "texture",
                "voxel",
                "diffusion",
                "reaction"
            ],
            "usePreview": 0,
            "username": "cornusammonis",
            "viewed": 5501
        },
        "renderpass": [
            {
                "code": "/*\n\n\tVisualization is based on Paniq's Light Propagation Volume shadertoy here:\n\n\thttps://www.shadertoy.com/view/XdtSRn\n\n\tBuffer A contains a 3D reaction-diffusion system, and Buffer B contains\n    a propagating distance field derived from a 3D level set (3D contours) on the\n    voxel data in Buffer A. The packing and unpacking scheme used is also due to Paniq.\n\n    Try changing the texture size to 64^3 below and in the first line in \n    Buffer A and B. You'll probably need to be in fullscreen for it to work.\n    \n\n*/\n\nconst vec3 size = vec3(48.0);\n\nfloat packfragcoord2 (vec2 p, vec2 s) {\n    return floor(p.y) * s.x + p.x;\n}\nvec2 unpackfragcoord2 (float p, vec2 s) {\n    float x = mod(p, s.x);\n    float y = (p - x) / s.x + 0.5;\n    return vec2(x,y);\n}\nfloat packfragcoord3 (vec3 p, vec3 s) {\n    return floor(p.z) * s.x * s.y + floor(p.y) * s.x + p.x;\n}\nvec3 unpackfragcoord3 (float p, vec3 s) {\n    float x = mod(p, s.x);\n    float y = mod((p - x) / s.x, s.y);\n    float z = (p - x - floor(y) * s.x) / (s.x * s.y);\n    return vec3(x,y+0.5,z+0.5);\n}\n\nvec4 fetch_lpv(vec3 p) {\n    p = clamp(p, vec3(0.5), size - 0.5);\n    float posidx = packfragcoord3(p, size);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);    \n}\n\n// branchless range check\nfloat inrange(float x, float min, float max) {\n    return abs(0.5 * (sign(max - x)  + sign(x - min)));   \n}\n\nfloat inrange(vec3 x, vec3 min, vec3 max) {\n    return inrange(x.x, min.x, max.x) * inrange(x.y, min.y, max.y) * inrange(x.z, min.z, max.z);  \n}\n\n/* \n   The tricky part here is how to approach raymarching the area outside of the 3D texture,\n   which has no defined distance field. We could clamp, but the resulting distance field\n   interferes with visibility from the camera's POV. The solution I use here is to raymarch\n   the bounding cube until we hit the boundary, then switch to raymarching the 3D texture.\n   There are artifacting issues on surfaces up against the boundary, there's probably\n   a better way to handle that...\n*/\nvec2 sample_lpv_trilin(vec3 p) {\n    p = p * size;\n    float inr = inrange(p, vec3(0.0), size);\n    vec3 pc = clamp(p, vec3(0.0), size);\n    float cubedist = distance(p, pc);\n    vec2 e = vec2(0.0,1.0);\n    vec4 p000 = fetch_lpv(pc + e.xxx);\n    vec4 p001 = fetch_lpv(pc + e.xxy);\n    vec4 p010 = fetch_lpv(pc + e.xyx);\n    vec4 p011 = fetch_lpv(pc + e.xyy);\n    vec4 p100 = fetch_lpv(pc + e.yxx);\n    vec4 p101 = fetch_lpv(pc + e.yxy);\n    vec4 p110 = fetch_lpv(pc + e.yyx);\n    vec4 p111 = fetch_lpv(pc + e.yyy);\n\n    vec3 w = fract(pc);\n\n    vec3 q = 1.0 - w;\n\n    vec2 h = vec2(q.x,w.x);\n    vec4 k = vec4(h*q.y, h*w.y);\n    vec4 s = k * q.z;\n    vec4 t = k * w.z;\n        \n    vec4 tril = \n          p000*s.x + p100*s.y + p010*s.z + p110*s.w\n        + p001*t.x + p101*t.y + p011*t.z + p111*t.w;\n    \n    //return vec2(inr * tril.x, (1.0 - inr) * cubedist);\n    return vec2(tril.x, (1.0 - inr) * cubedist);\n\n}\n\nvec4 sh_project(vec3 n) {\n    return vec4(\n        n,\n        0.57735026918963);\n}\n\nfloat sh_dot(vec4 a, vec4 b) {\n    return max(dot(a,b),0.0);\n}\n\n// 3 / (4 * pi)\nconst float m3div4pi = 0.23873241463784;\nfloat sh_flux(float d) {\n\treturn d * m3div4pi;\n}\n\n#ifndef M_DIVPI\n#define M_DIVPI 0.3183098861837907\n#endif\n\nfloat sh_shade(vec4 vL, vec4 vN) {\n    return sh_flux(sh_dot(vL, vN)) * M_DIVPI;\n}\n\n#define SHSharpness 1.0 // 2.0\nvec4 sh_irradiance_probe(vec4 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 / 3.0;\n    return vec4(v.xyz * sh_c1, v.w * sh_c0);\n}\n\nfloat shade_probe(vec4 sh, vec4 shn) {\n    return sh_shade(sh_irradiance_probe(sh), shn);\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec4 m ) {\n    if (max(m.z, m.w) <= 0.0) {\n    \tfloat an = 1.5 + sin(time * 0.1) * 3.0;\n\t\tcamPos = vec3(6.5*sin(an), 1.0 ,6.5*cos(an));\n    \tcamTar = vec3(0.5,0.5,0.5);        \n    } else {\n    \tfloat an = 10.0 * m.x - 5.0;\n\t\tcamPos = vec3(6.5*sin(an),10.0 * m.y - 5.0,6.5*cos(an));\n    \tcamTar = vec3(0.5,0.5,0.5);\n    }\n}\n\nvec3 doBackground( void ) {\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec3 rayToTexture( vec3 p ) {\n    return (p - vec3(0.0,0.5,0.0)) * 0.2 + 0.5;\n}\n\nvec2 doModel( vec3 p ) {\n    p = rayToTexture(p);\n    return sample_lpv_trilin(p);\n    \n}\n\nvec4 doMaterial( in vec3 pos, in vec3 nor ) {\n    return vec4(1.0,1.0,1.0,0.0);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 col = mal.rgb;\n    vec4 shr = vec4(1.0);\n    \n    // cross with ray dir for a velvety sort of effect\n    vec4 shn = sh_project(cross(nor,rd));\n    \n    col *= 10.0 * vec3(shade_probe(shr, shn)); \n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;           // max trace distance\n\tconst float precis = 1.0;          // precision of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 d = doModel(ro+rd*t);\n        if (d.y > 0.0) {\n            t += 0.1 * d.y + 0.06;\n            // we don't update h when raymarching the bounding cube, because\n            // we want to continue marching once we intersect it.\n        } else {\n            t += 0.01 * d.x;\n            h = d.x;\n        }\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    // a large epsilon is used here because the underlying data is coarse\n    const float eps = 0.01;             // precision of the normal computation\n\n    //const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec4 m = vec4(iMouse.xy/iResolution.xy, iMouse.zw);\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n    float dh = (0.666 / iResolution.y);\n    \n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 colmin = doBackground();\n    vec3 colmax = colmin;\n    vec3 colavg = colmin;\n    vec3 colavg2 = colmin;\n    vec3 col = colmin;\n    \n    const int samps = 8;\n    \n    vec3 cols[samps];\n    \n    const float rads = 6.283185 / float(samps);\n    \n    for (int i = 0; i < samps; i++) {\n        // create view ray\n        vec2 dxy = dh * vec2(cos(float(i) * rads), sin(float(i) * rads));\n        vec3 rd = normalize( camMat * vec3(p.xy + dxy,2.0) ); // 2.0 is the lens length\n\n        // raymarch\n        float t = calcIntersection( ro, rd );\n        if( t>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n\n            // materials\n            vec4 mal = doMaterial( pos, nor );\n            vec3 tc = doLighting( pos, nor, rd, t, mal );\n\n            if (i == 0) {\n            \tcolmin = tc;   \n                colmax = tc; \n            }\n\t\t\t\n            colmin = min(colmin, tc);\n            colmax = max(colmax, tc);\n            colavg += tc;\n            cols[i] = tc;\n\n        }\n    }\n    \n    colavg /= float(samps);\n    \n    // outlier rejection, cleans up some artifacts\n    float sum = 0.0;\n    for (int i = 0; i < samps; i++) {\n    \tvec3 x = cols[i];\n        float w = exp(-length(x - colavg) / 0.2);\n        colavg2 += w * x;\n        sum += w;\n    }\n    \n    colavg2 /= sum;\n    \n    float sum2 = 0.0;\n    for (int i = 0; i < samps; i++) {\n    \tvec3 x = cols[i];\n        float w = exp(-length(x - colavg2) / 0.2);\n        col += w * x;\n        sum2 += w;\n    }\n    \n    col /= sum2;\n    \n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = ff_filmic_gamma3(col); //pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 size = vec3(48.0);\n\nconst float timestep = 0.7;\nconst float a0 = -0.1;\nconst float a1 = 2.0;\nconst float epsilon = 0.05;\nconst float delta = 4.0;\nconst float k1 = 1.0;\nconst float k2 = 0.0;\nconst float k3 = 1.0;\nconst float tc = 0.8;\nconst float ls = 0.3;\n\nfloat packfragcoord2 (vec2 p, vec2 s) {\n    return floor(p.y) * s.x + p.x;\n}\nvec2 unpackfragcoord2 (float p, vec2 s) {\n    float x = mod(p, s.x);\n    float y = (p - x) / s.x + 0.5;\n    return vec2(x,y);\n}\nfloat packfragcoord3 (vec3 p, vec3 s) {\n    return floor(p.z) * s.x * s.y + floor(p.y) * s.x + p.x;\n}\nvec3 unpackfragcoord3 (float p, vec3 s) {\n    float x = mod(p, s.x);\n    float y = mod((p - x) / s.x, s.y);\n    float z = (p - x - floor(y) * s.x) / (s.x * s.y);\n    return vec3(x,y+0.5,z+0.5);\n}\n\nvec4 fetch(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (size.x - 0.5))) {\n        // boundary condition for the RD system, semi-arbitrary\n        return vec4(-0.01, 0.0, 0.0, 0.0);\n    }\n    float posidx = packfragcoord3(p, size);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);\n}\n\nvec4 n[6];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n    vec3 pos = unpackfragcoord3(posidx, size);\n    vec3 e = vec3(-1.0,0.0,1.0);\n    vec4 x = fetch(pos);\n    n[0] = fetch(pos + e.xyy);\n    n[1] = fetch(pos + e.zyy);\n    n[2] = fetch(pos + e.yxy);\n    n[3] = fetch(pos + e.yzy);\n    n[4] = fetch(pos + e.yyx);\n    n[5] = fetch(pos + e.yyz);\n    \n    // 7-point 3D laplacian\n    // If we used the 27-point laplacian we'd get better isotropy...\n    vec4 lapl = -6.0 * x + n[0] + n[1] + n[2] + n[3] + n[4] + n[5];\n    \n    float a = x.x;\n    float b = x.y;\n    float c = x.z;\n    float d = x.w;\n    \n    // update/integration rule\n    float d_a = k1*a - k2*a*a - a*a*a - b + ls*lapl.x;\n    float d_b = epsilon*(k3*a - a1*b - a0) + ls*delta*lapl.y;\n\tc = tc * c + (1.0 - tc) * d_a;\n\td = tc * d + (1.0 - tc) * d_b;\n\n    a = a + timestep * c;\n    b = b + timestep * d;\n    \n    \n    // initialize with noise\n    if(iFrame<10) {\n        fragColor = -0.5 + texture(iChannel1, uv);\n    } else {\n        fragColor = clamp(vec4(a, b, c, d), -1., 1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec3 size = vec3(48.0);\n\nfloat packfragcoord2 (vec2 p, vec2 s) {\n    return floor(p.y) * s.x + p.x;\n}\nvec2 unpackfragcoord2 (float p, vec2 s) {\n    float x = mod(p, s.x);\n    float y = (p - x) / s.x + 0.5;\n    return vec2(x,y);\n}\nfloat packfragcoord3 (vec3 p, vec3 s) {\n    return floor(p.z) * s.x * s.y + floor(p.y) * s.x + p.x;\n}\nvec3 unpackfragcoord3 (float p, vec3 s) {\n    float x = mod(p, s.x);\n    float y = mod((p - x) / s.x, s.y);\n    float z = (p - x - floor(y) * s.x) / (s.x * s.y);\n    return vec3(x,y+0.5,z+0.5);\n}\n\nvec4 fetch_rd(vec3 p) {\n    p = clamp(p, vec3(0.5), size - 0.5);\n    float posidx = packfragcoord3(p, size);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);\n}\n\nvec4 fetch_df(vec3 p) {\n    p = clamp(p, vec3(0.5), size - 0.5);\n    float posidx = packfragcoord3(p, size);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) / iChannelResolution[0].xy;\n    return texture(iChannel1, uv);    \n}\n\nfloat inrange(float x, float min, float max) {\n    return abs(0.5 * (sign(max - x)  + sign(x - min)));   \n}\n\nvec4 max6(vec4 n[6]) {\n    vec4 m0 = max(n[0], n[1]);\n    vec4 m1 = max(n[2], n[3]); \n    vec4 m2 = max(n[4], n[5]);\n    return max(m0, max(m1, m2));\n}\n\nvec4 min6(vec4 n[6]) {\n    vec4 m0 = min(n[0], n[1]);\n    vec4 m1 = min(n[2], n[3]); \n    vec4 m2 = min(n[4], n[5]);\n    return min(m0, min(m1, m2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 n[6];\n    vec4 d[6];\n    \n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n    vec3 pos = unpackfragcoord3(posidx, size);\n    vec3 e = vec3(-1.0,0.0,1.0);\n    vec4 x = fetch_rd(pos);\n    n[0] = fetch_rd(pos + e.xyy);\n    n[1] = fetch_rd(pos + e.zyy);\n    n[2] = fetch_rd(pos + e.yxy);\n    n[3] = fetch_rd(pos + e.yzy);\n    n[4] = fetch_rd(pos + e.yyx);\n    n[5] = fetch_rd(pos + e.yyz);\n    \n    d[0] = fetch_df(pos + e.xyy);\n    d[1] = fetch_df(pos + e.zyy);\n    d[2] = fetch_df(pos + e.yxy);\n    d[3] = fetch_df(pos + e.yzy);\n    d[4] = fetch_df(pos + e.yyx);\n    d[5] = fetch_df(pos + e.yyz);\n    \n    vec4 rd_max = max6(n);\n    vec4 rd_min = min6(n);\n    \n    vec4 df_min = min6(d);\n    \n    float contour = 0.5;\n    \n    // check if the contour line lies between this voxel and its neighbors\n    float r0 = inrange(contour, x.x, rd_min.x); \n    float r1 = inrange(contour, x.x, rd_max.x);\n    \n    float xminmin = min(x.x, rd_min.x);\n    float xminmax = max(x.x, rd_min.x);\n    float xmaxmin = min(x.x, rd_max.x);\n    float xmaxmax = max(x.x, rd_max.x);\n    \n    float d0 = xminmax - xminmin;\n    float d1 = xmaxmax - xmaxmin;\n    \n    const float s = 1.0;\n    \n    // anti-alias the distance field by computing distance from the center point to the contour\n    float dist = \n    \t(d0 == 0.0 ? 0.0 : r0 * abs(contour - x.x) / d0) + \n        (d1 == 0.0 ? 0.0 : r1 * abs(contour - x.x) / d1);\n    \n    float distance = s * dist + (1.0 - (r0 + r1)) * (df_min.x + s);\n    \n    fragColor = vec4(distance);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}