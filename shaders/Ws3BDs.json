{
    "Shader": {
        "info": {
            "date": "1606217122",
            "description": "Extrapolation of \"Lockdown\" shader, https://www.shadertoy.com/view/wsSczz\n\nMusic: Philip Glass, Metamorphosis 2.\n\nInfos in Image tab header",
            "flags": 96,
            "hasliked": 0,
            "id": "Ws3BDs",
            "likes": 50,
            "name": "Terraforming Timelapse",
            "published": 3,
            "tags": [
                "space",
                "planet",
                "tree",
                "timelapse",
                "crater"
            ],
            "usePreview": 1,
            "username": "ocb",
            "viewed": 892
        },
        "renderpass": [
            {
                "code": "// Author: \t\tocb\n// Title: \t\tTerraforming Timelapse\n\n// Having fun with my preceding shader:\n// \"Lockdown\" https://www.shadertoy.com/view/wsSczz\n//\n// Built by adding code here and there.\n// Sorry for the code not optimized and really unreadable.\n// Too much details, too slow...\n//\n// Things to know:\n// Some camera vews are set on interesting point, depending on the landscape.\n// BUT, as random result depends on each GPU, you may change the FBM Offset (line 34) in Common tab,\n// in order to obtain more suitable landscape for the pre-defined camera position.\n//\n// Moreover, you can set cam free, line 53.\n// RAU value (line 55) is the distance to the camera target, crater center by default.\n//\n/*********************** Global *************************************/\nfloat TimeHsh;\n\n/*********************** pre-declared *******************************/\nvec3 tree(vec3 pos, vec3 ray, float tg);\n\nfloat structure(vec3 p, float scale, float startime);\n\n\n/******************** Raycasting base function ***********************/\n\nfloat plan(float p, float r, float d){\n    float t = (d-p)/r;\n    if(t<=0.) t = INFINI;\n    return t;\n}\n\nvec2 sphere(in vec3 p, in vec3 O, in float r, in vec3 ray){\n    vec2 t = vec2(INFINI);\n    vec3 d = O - p;\n    float b = dot(d, ray);\n    \n    float c = dot(d,d) - r*r;\n    float D = b*b - c;\n    if (D >= 0.){\n        float VD = sqrt(D);\n        t.x= b - VD;\n        t.y= b + VD;\n        t += (INFINI-t)*step(t,vec2(0.));\n    }\n    return t;\n}\n\nvec2 cylinder(in vec2 pos, in vec2 cylO, in float cylR, in vec2 ray){\n    float t1 = INFINI, t2 = INFINI;\n    vec2 delta = pos - cylO;\n\n    float a = dot(ray,ray);\n    float b = dot(delta, ray);\n    float c = dot(delta,delta) - cylR*cylR;\n    float d = b*b - a*c;\n    \n    if (d >= 0.){\n        float Vd = sqrt(d);\n        t1 = (-b - Vd)/a;\n        t2 = (-b + Vd)/a;\n    }\n    \n\treturn vec2(t1,t2);\n}\n\n\n/*****************************    Sky   *****************************/\n\nvec3 skyCol(vec3 ray){\n    float lit = dot(ray,LIGHT);\n\tvec3 col = (.05*TimeHsh+.95)*vec3(1.,.5,0.)*max(.6-ray.y,0.)*(.7+.3*lit) + .002/(1.002-lit);\n    col = mix(col, vec3(.2,.1,0.)+.05*texture(iChannel2,ray.xz*vec2(.001,.01)+TIME).r, smoothstep(-4.,0.,-abs(TIME-40.))*(.7+.3*TimeHsh) );\n    float storm = abs(TIME-72.);\n    if(storm<=7.) col *= .2+.1*storm-.05*TimeHsh;\n    return col;\n}\n  \n/************************************************************************/\n/*\t\t\t\t\t\t\tGround fct\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\n// mapping global crater shape\nfloat shape(vec2 g){\n\tfloat a = .000001*(g.x*g.x + g.y*g.y);\n    float h = smin(a*a,abs(1./a),.2)+.8/(50.*a+1.);\n    return h;\n}\n\n// mapping accurate ground, adding shape + fbm + texture\nfloat ground(vec2 g, float t){\n\tfloat len = max(abs(g.x),abs(g.y));\n    if(len>5000.) return .5; \n    float h = shape(g);\n    float m = fbm(vec3(g.x,maxHill*h,g.y));\n    m *= 1.-linstep(3000.,5000.,len);\n    \n    // scaling texture\n    float tex,trans,dump;\n    if(t>300.){\n    \tfloat dump = 1.-linstep(300.,2000.,t);\n        tex = dump*1.5*texture(iChannel0,.00125*g.xy+.5).r;\n    }\n    else if(t>100.){\n    \ttrans = linstep(100.,300.,t);\n        tex = trans*1.5*texture(iChannel0,.00125*g.xy+.5).r+(1.-trans)*.3*texture(iChannel0,.01*g.xy+.5).r;\n    }\n    else if(t>50.){\n        tex = .3*texture(iChannel0,.01*g.xy+.5).r;\n    }\n    else{\n    \ttrans = linstep(20.,50.,t);\n        tex = trans*.3*texture(iChannel0,.01*g.xy+.5).r+(1.-trans)*.05*texture(iChannel0,.05*g.xy+.5).r;\n    }\n    \n    return maxHill*(.4*h*m+.2*m+.4*h)+ tex;\n}\n\n\nvec3 getGndNormal(vec3 p, float t){\n    vec2 e = vec2(.1-.075*step(t,50.),0.);\t// step() to adjust accuracy to the scale\n\tfloat dx = ground(p.xz+e.xy,t) - p.y;\n    float dy = ground(p.xz+e.yx,t) - p.y;\n    return normalize(vec3(dx,-e.x,dy));    \n}\n\n\n// Fast marching to the global shape\nfloat traceShape(in vec3 pos, in vec3 ray){\n    float t = 0., dh;\n    vec3 p = pos;\n    for(int i=0;i<60;i++){\n        dh = p.y-maxHill*shape(p.xz)*1.15;\n        if(abs(dh)<10.)break;\n        t += dh;\n        p = pos+t*ray;\n        if(p.y > 1.5*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n    }\n    return t;\n}\n\n// Marching:\n// step 1 = fast marching to the shape\n// step 2 = fine tunning on the ground\nfloat traceGround(in vec3 pos, in vec3 ray){\n    float t = 0.,dh;\n    \n    if(pos.y > maxHill*shape(pos.xz)*1.15) t = traceShape(pos, ray);    \n   \tif(t == INFINI) return INFINI;\n    \n    vec3 p = pos + t*ray;\n    for(int i=0; i<70;i++){\n        dh = p.y-ground(p.xz,t);\n        if(abs(dh)<.01) break;\n        t += .9*dh;\n        p = pos+t*ray;\n        if(p.y > 1.5*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n    }\n    return t;\n}\n\nfloat groundShadows(vec2 p){\n    float txg;\n    // Ground shadow\n    vec2 g = abs(p.xy)/2000.;\n    if(sign(p.x)>0.){\n        if(sign(p.y)>0.){ txg = texture(iChannel1,g).x - iResolution.x;}\t// removing resolution info (stored in buffer A)\n        else{ txg = texture(iChannel1,g).y;}\n    }\n    else{\n        if(sign(p.y)>0.){txg = texture(iChannel1,g).w;}\n        else{txg = texture(iChannel1,g).z;}\n    }\n    \n    // Dome structure shadow\n    vec3 px = vec3(p.x, max(min(lakeH,TIME-15.),ground(p.xy,51.)), p.y);\n    float txs = sphere(px,C,R,LIGHT).y;\n    float c = 0.;\n    if(txs<INFINI){\n        vec3 pxs = px+txs*LIGHT - C;\n        float d = structure(pxs,2.,3.);\n        c = smoothstep(-.15,.12,-abs(d));\n        d = structure(pxs,4.,8.);\n        c = max(c,smoothstep(-.12,.12,-abs(d)));\n    }\n    return min(txg,1.-c);\n}\n\nvec3 PaintCrater(vec3 p, vec3 ray, float tg, vec3 norm){\n    \n    vec3 col;\n    float dist = length(p.xz);\n    // scaling texture\n    float trans;\n    vec3 tex;\n    if(dist>3000.){\n        tex = texture(iChannel0,.0000625*p.xz+.5).rgb;\n    }\n    else if(tg>100.){\n        trans = linstep(100.,300.,tg);\n        tex = trans*texture(iChannel0,.00125*p.xz+.5).rgb+(1.-trans)*texture(iChannel0,.01*p.xz+.5).rgb;\n    }\n    else if(tg>50.){\n        tex = texture(iChannel0,.01*p.xz+.5).rgb;\n    }\n    else{\n        trans = linstep(20.,50.,tg);\n        tex = trans*texture(iChannel0,.01*p.xz+.5).rgb+(1.-trans)*texture(iChannel0,.05*p.xz+.5).rgb;\n    }\n\n    // setting color\n    col = vec3(.5,.25,.0) + tex;\n    \n    // shade\n    col *= dot(-norm,LIGHT);\n\n    // fog\n    float tt = 3000./tg;\n    col *= min(1.,tt);\n    col = mix(skyCol(ray), col, min(.7,tt));\n\t\n    // grass\n    float level = min(lakeH,TIME-18.);\n    if(dist<1000. && p.y>level){\n        float h = smoothstep(30.,40.,TIME)*6.*tex.g*max(0.,(1.-.002*(p.y-level)));\n        float frz = abs(TIME-80.);\n\t\tif(frz>=8.) h *= step(.8,-norm.y);\n        col += vec3(-.1,-.06,-.1)*h;\n        if(frz<8.) col = mix(col,vec3(.7),step(h,(3.-.375*frz)));\n    }\n            \n    // shadow\n    if(dist<2000.){\n        float shad;\n    \tif( tree(p, LIGHT, 50.).x < INFINI) shad = .2;\n        else shad = groundShadows(p.xz);\n        col *= shad;\n    }\n\n    return col;\n}\n\n\n/************************************************************************/\n/*\t\t\t\t\t\t\tDome fct\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\n// coord. change\nvec2 polar(vec3 p){ return vec2(atan(p.z/p.x)+PI*step(p.x,0.),atan(length(p.xz)/p.y)); }\n\nvec3 cartesian(vec2 i){float s = sin(i.y); return vec3(s*cos(i.x),cos(i.y),s*sin(i.x));}\n\n// Black structure on sphere, depending on scale\nfloat structure(vec3 p, float scale, float startime){\n    float d = 1.;\n    vec2 a = polar(p)/PIdiv2;\n    if( .5*(1.-a.y)+mod(.1-a.x,2.) < .05*floor(10.*(TIME-startime))){\n        a.y *= 4.;\n        float iy = floor(a.y);\n        a.x *= 2.*scale;\n        a.x += 1./pow(scale,scale);\n        a.x += mod(iy,2.)*.5;\n        a = fract(a)-vec2(.5,0.);\n        d = 2.*abs(a.x);\n        /*if(iy<scale-3.) d = 1.;\n        else*/ if(iy<scale-2.) d -= smoothstep(-.02,.1,a.y)-.05;\n        else d -= smoothstep(-0.12,.5,a.y)-.05;\n    }\n    return d;\n}\n\n// Black structure on sphere.\n// Call twice at 2 different scales (thick and thin) \nfloat frame(vec3 p){\n\n    float d = structure(p,2.,3.);\n    float c = smoothstep(-.04,-.02,-abs(d));\n\n    d = structure(p,4.,8.);\n    c = max(c,smoothstep(-.03,-.01,-abs(d)));\n    \n    return c;\n}\n\nvec3 DrawStruct(vec3 p, vec3 ray){\n    vec3 col = vec3(.0);\n\n    p -= C;\t\t\t\t// origin of the coord set on the center of sphere\n    col -= frame(p);\t// blacken the frame\n\n    vec2 tile = WINTILE/PIdiv2;\t\t// number of window glass\n    vec2 a = tile*polar(p);\t\t\t// tiling polar coordinates\n    vec2 i = floor(a)/tile;\n    vec2 f = abs(fract(a)-.5);\n    \n    float prog = 8.-10.*i.y + .5*i.x;\n\n    if(prog < TIME-15.5 && prog > TIME-16.){\n        float d = smoothstep(.45,.5,max(f.x,f.y));\t\t\t// draw thin contour of each window\n\t\tcol += .2*d;\n    }\n\n    if(prog < TIME-16.){\n        float d = smoothstep(.47,.5,max(f.x,f.y));\t\t\t// draw thin contour of each window\n        vec3 norm = cartesian(i);\t\t// back to cartesian. Same normal for the whole window (i = floor)\n        vec3 refl = reflect(ray,norm);\t\n\n        float spec = .015/(1.01-dot(LIGHT,refl));\t\t// calculating sky reflection\n        col += spec;//*skyCol(refl);\t\t\t\t\t// and specular light\n        col += .3*spec*d;\t\t\t\t\t\t\t\t// sky reflection is used on the whole surface to set the golden color of the dome\n\n        p += C;\n        float t = traceGround(p,refl);\t\t\t\t// Adding ground reflection using the window normal\n        if(t<INFINI){\n            vec3 pr = p + t*refl;\n            pr.y = ground(pr.xz,t);\n\n            vec3 n = getGndNormal(pr,t);\n            col += .5*PaintCrater(p,refl,t,n)*groundShadows(p.xz);\n        }\n        else col += skyCol(refl);\n    }\n    return col;\n}\n\n/************************************************************************/\n/*\t\t\t\t\t\t\ttree fct\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\nvec4 getNextPlan(in vec2 xz, in vec2 v){\n    vec2 s = sign(v);\n    vec2 d = step(0.,s);\n\tvec2 dtp = (d-fract(xz/cellD))*cellD/v;\n    float tmin = min(dtp.x, dtp.y);\n    s *= -step(dtp,vec2(tmin));\n    return vec4(s.x,0.,s.y,tmin);\n}\n\nvec3 tree(vec3 pos, vec3 ray, float tg){\n    if(TIME<40.) return vec3(INFINI,0.,0.);\n    // trees\n    vec3 pe = pos;\n    vec2 tc = cylinder(pos.xz, vec2(0.), 900., ray.xz);\n    float te = INFINI, tx = 0.;\n\n    // Entry and exit point of the voxel run(te and tx)\n    float th = plan(pos.y,ray.y,cellH);\n    \n    if(pos.y>=cellH){\n        te = min(max(tc.x,th),tc.y);\n        tx = min(tg,tc.y);\n    }\n    else{\n        te = tc.x*step(0.,tc.x)+INFINI*step(th,tc.x);\n        tx = min(min(tg,tc.y),th);\n    }\n    \n    \n    pe += te*ray;\n    vec4 wall;\n    for(int k=0;k<maxCell;k++){\n        wall = getNextPlan(pe.xz, ray.xz);\n        te += wall.w+.01;\n        if(te>=tx) break;\n\n        pe = pos + te*ray;\n        vec2 id = floor(pe.xz/cellD+.5);\n        float proba = H2(id);\n        if(proba > PINE){\n        \tfloat gnd = ground(id*cellD,1.);\n        \tif(gnd > lakeH){\n                // pines\n                vec2 ft = 2.*(fract(pe.xz/cellD)-.5);\n                float ti = .002*H2(id+vec2(floor(40.*TIME)));\n                float H = treeH*(proba-.6)*smoothstep(50.,70.,TIME)+10.*ti;\n                float hh = H*(abs(ft.x)+abs(ft.y));\n                float tex = texture(iChannel0,.05*vec2(pe.x-pe.z, pe.y)+ti).r\n                    \t\t*texture(iChannel0,.2*vec2(pe.x+pe.z, pe.y)-ti).r;\n                tex *= smoothstep(0.,20.,hh-pe.y+gnd-H+5.);\n\n                if(tex>.03)return vec3(te,proba,tex);\n            }\n        }\n\t\telse if(proba > BUSH){\n        \tfloat gnd = ground(id*cellD,1.);\n        \tif(gnd > lakeH){\n                // bush\n                vec2 ft = abs(fract(pe.xz/cellD-.5)-.5);\n                float len = length(vec2(ft.x+ft.y,(pe.y-gnd+2.*(1.-proba)/(1.-BUSH))/cellD));\n                float ti = .001*H2(id+vec2(floor(40.*TIME)));\n                float tex = texture(iChannel2,.05*vec2(pe.x-pe.z, pe.y)+ti).r\n                    \t\t*texture(iChannel0,.01*vec2(pe.x+pe.z, pe.y)-ti).r;\n                float grow = .5*smoothstep(35.,60.,TIME)+5.*ti;\n                \n                tex *= smoothstep(-1.2*grow,-grow,-len);\n\n                if(tex>.125) return vec3(te,proba,tex);\n            }\n        }\n    }\n\n\treturn vec3(INFINI,0.,0.);\n}\n\n\nvec3 treeColor(in vec3 pos, in vec3 ray, in vec3 tt){\t// tt.x = t // tt.y = proba // tt.z = tex //\n    vec3 col;\n    vec3 pe = pos+tt.x*ray;\n    vec2 ft = 2.*(fract(pe.xz/cellD+.5)-.5);\n    if(tt.y > PINE){\n        float H = treeH*(tt.y-.6);\n        vec2 nt = normalize(ft*(H-pe.y+300.)/H -ray.xz);\n        float shad = max(0.,dot(nt,LIGHT.xz));\n        col = vec3(tt.y-.7,.25,.1)*(1.-min(1.,10.*tt.z))*shad;\n        float frz = abs(TIME-78.);\n        if(frz<8.) col = mix(col,vec3(3.)*(.25-tt.z),(1.-.125*frz));\n        //if(frz<8.) col = mix(col,vec3(.8),step(tt.z,.1-.020*frz));\n    }\n    else{\t// bush\n        vec3 nt = normalize(vec3(ft.x-ray.x,-ray.y,ft.y-ray.z));\n        float shad = max(0.,.3+.7*dot(nt,LIGHT));\n        col = vec3(.45-.25*tt.y,.4,.15)*(1.4-5.*tt.z)*shad;\n        float frz = abs(TIME-78.);\n        if(frz<8.) col = mix(col,vec3(8.)*(.24-tt.z),(1.-.125*frz));\n        //if(frz<8.) col = mix(col,vec3(.8),step(tt.z,.2-.025*frz));\n    }\n    col *= groundShadows(pe.xz);\n\treturn col;    \n}\n\n\n/************************************************************************/\n/*\t\t\t\t\t\t\tCamera\t\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\nvec3 getCamPos(inout vec3 camTarget){\n    \n #ifdef FREE_CAM\n    float \trau = RAU,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = (iMouse.y+.001)/iResolution.y*PI+ (PI/2.0001);\t// +0.001 to avoid black horizontal line\n #else\n\n    float ti = TIME;\n    \n    float rau,\n    \t  alpha,\n    \t  theta;\n    \n    if(ti<9.){\t\t\t\t\t\t\t\t// Main struct, outside\n    \tcamTarget = vec3(0.,150.,0.);\n        rau = 2000.;\n        alpha = -1.5-.1*ti;\n        theta = .2;\n    }\n    else if(ti<18.){\t\t\t\t\t\t// fine struct, inside\n    \tcamTarget = vec3(0.,150.,0.);\n        rau = 800.;\n        alpha = 1.5-.2*ti;\n        theta = .05;\n    }\n    else if(ti<29.){\t\t\t\t\t\t// Glass cover\n    \tcamTarget = vec3(0.,150.,0.);\n        rau = 1900.-20.*ti;\n        alpha = 3.9-.2*ti;\n        theta = .1+1.*smoothstep(18.,26.,ti);\n    }\n    else if(ti<33.){\t\t\t\t\t\t// Water start\n    \tcamTarget = vec3(-100.,25.,-400.);\n        rau = 200.;\n        alpha = -1.;\n        theta = .1;\n    }\n    else if(ti<45.){\t\t\t\t\t\t// Main view, water uplifting\n    \tcamTarget = vec3(0.,100.,0.);\n        rau = 900.;\n        alpha = -.5+.025*(ti-33.);\n        theta = .1;\n    }\n    else if(ti<55.){\t\t\t\t\t\t// Growth\n    \tcamTarget = vec3(0.,50.,0.);\n        rau = 800.;\n        alpha = -1.75;\n        theta = .0;\n    }\n    else if(ti<63.){\n    \tcamTarget = vec3(-150.,45.,460.);\t// Spirit Island\n        rau = 100.;\n        alpha = 1.+.025*(ti-55.);\n        theta = .1;\n    }\n    else if(ti<70.){\n    \tcamTarget = vec3(450.,50.,-300.);\t\t// little sound\n        rau = 150.;\n        alpha = -2.5+.025*(ti-63.);\n        theta = .2;\n    }else if(ti<80.){\n    \tcamTarget = vec3(0.,50.,0.);\t\t// Storm, outside\n        rau = 2000.;\n        alpha = -1.;\n        theta = .25;\n    }\n    else if(ti<88.){\n    \tcamTarget = vec3(0.,50.,0.);\t\t// winter, inside\n        //rau = 750.-10.*(ti-77.);\n        rau = 740.;\n        //alpha = -2.4;\n        alpha = -2.4-.015*(ti-77.);\n        theta = .025;\n    }\n    else if(ti<100.){\n    \tcamTarget = vec3(0.,50.,0.);\t\t// Traveling, inside\n        rau = 900.-10.*(ti-86.);\n        alpha = .3;\n        theta = .08;\n    }\n    else if(ti<110.){\n    \tcamTarget = vec3(-400.,50.,-400.);\t\t// scrolling, inside\n        rau = 200.;\n        alpha = .1*ti+4.;\n        theta = .1;\n    }\n    else {\n    \tcamTarget = vec3(0.,150.,0.);\t\t// end\n        rau = 1000.+30.*(max(0.,ti-105.));\n        alpha = .1*ti;\n        theta = .2;\n    }\n\n    \n    \n #endif\n            \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n\n/************************************************************************/\n/*\t\t\t\t\t\t\t\tMain\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    TimeHsh = H2(vec2(floor(40.*TIME)))*step(TIME,86.);\n    vec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 camTarget = TARGET;\n    vec3 pos = getCamPos(camTarget);\n    pos.y = max(pos.y, 10.+max(lakeH, ground(pos.xz,1.)));\n    vec3 ray = getRay(st, pos,camTarget);\n\t\t\n    vec3 col = vec3(.0);\n        \n    float tg = INFINI;    \n    tg = traceGround(pos,ray);\n    float tw = plan(pos.y,ray.y,min(lakeH,TIME-18.));\n    vec3 tt = tree(pos, ray,tg);\n    vec2  ts = sphere(pos,C,R,ray);\n    \n    float dist = max(abs(pos.x+tw*ray.x),abs(pos.z+tw*ray.z));        \n\tif(dist>1000.) tw = INFINI;\n    \n    float t = min(min(min(tg,INFINI),tw),tt.x);\n    \n\n    if(t >= INFINI){\t\t// Sky\n        col += skyCol(ray);\n    }\n        \n    else if(t == tt.x){\t\t// Tree      // tt.x = t // tt.y = proba // tt.z = tex //\n        col = treeColor(pos, ray, tt);\n    }\n    \n    else if(t == tw){\t// Lake\n        \n        float frz = abs(TIME-78.);\t// frozen time (used below)\n\n        vec3 pg = pos + tg*ray;\t\t// ground infos. used for lake bottom\n        pg.y = ground(pg.xz,tg);\n\t\t\t\t\t\t\t\t\t\t\n        vec3 nw = vec3(0.,1.,0.);\t// water infos\n        vec3 pw = pos + tw*ray;\n        float depth = max(0.,pw.y - pg.y);\n        depth = 15./(depth*depth+15.);\n        vec3 ng = getGndNormal(pg,tg);\n        col += PaintCrater(pg,ray,tg, ng);        \n        \n\n        col = mix( vec3(.0,.03,.05), col , min(depth,.5)*max(0.4,dot(nw,-ray)) );\n\t\t\n        if(frz>=10.) nw = normalize(nw+.025*texture(iChannel2,.005*pw.xz+.3*TimeHsh).rrr-.0125);\n        vec3 refl = reflect(ray,nw);\n        float spec = .1/(1.1-dot(refl,LIGHT));\n        \n        float tgr = traceGround(pw+.1,refl);\n        vec3 ttr = tree(pw, refl,tgr);\n        if(ttr.x<tgr) col = mix(col,treeColor(pos, ray, ttr),.4);\n        else if(tgr<INFINI){\t\t\t\t\t\t\n            vec3 pr = pw + tgr*refl;\n            pr.y = ground(pr.xz,tg+tgr);\n            vec3 nr = getGndNormal(pr,tg+tgr);\n            col = mix(col,PaintCrater(pr,refl,tgr,nr),.4);\n        }\n        \n        float shad;\n        if( tree(pw, LIGHT, 100.).x < INFINI) shad = .2;\n        else shad = groundShadows(pw.xz);\n\n        col += (.5*spec+.4)*skyCol(refl)*smoothstep(.2,.8,shad);\n        \n        if(frz<8.) col += vec3(.4,.45,.5)*(depth+.5)*shad*(1.-.125*frz);\n\n        \n    }\n    \n    else{ // if(t == tg){\t// Ground\n        vec3 pg = pos + tg*ray;\n        pg.y = ground(pg.xz,tg);\t\t// recalculating p.y (vertical) to be more accurate on position\n\t\t\t\t\t\t\t\t\t\t// needed due to the fine details\n        vec3 ng = getGndNormal(pg,tg);\n        col += PaintCrater(pg,ray,tg, ng); \n    }\n        \n                     \n\tif(ts.x < t){\t\t\t// Dome outside     \n        vec3 pd = pos + ts.x*ray;\n        vec3 coldom = DrawStruct(pd,ray);\t// draw frame and color\n    \tif(coldom != vec3(0.)) col = mix(col,coldom,0.5);\t\t// mixing sphere and color behind for the partial transparency\n    }\n  \t\n    if(ts.y < t){\t\t\t// Dome inside\n        vec3 pd = pos + ts.y*ray;\n        pd-=C;\n        col -= .4*frame(pd);\n        if(ts.y < ts.x){\n            vec2 tile = WINTILE/PIdiv2;\t\t// number of window glass\n            vec2 a = tile*polar(pd);\t\t\t// tiling polar coordinates\n            vec2 i = floor(a)/tile;\n            vec2 f = abs(fract(a)-.5);\n    \n    \t\tfloat prog = 8.-10.*i.y + .5*i.x;\n\n            if(prog < TIME-14. && prog > TIME-16.){\n                float d = smoothstep(.4,.5,max(f.x,f.y));\t\t\t// draw thin contour of each window\n                col -= .05*d;\n            }\n\n    \t\tif(prog < TIME-16.){\n            \tvec3 norm = cartesian(i);\t\t// back to cartesian. Same normal for the whole window (i = floor)\n            \tvec3 refl = reflect(ray,norm);\t\n            \tfloat spec = .7/(1.1-dot(LIGHT,refl));\n            \tcol *= spec;\n            }\n        }\n    }\n\n    float storm = abs(TIME-75.);\n    if(storm<=7.) col *= (.3+.1*storm)-.05*TimeHsh;\n    fragColor = vec4(.05+1.7*col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 24675,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/austinpiano/philip-glass-cover"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n\n// Ground def\n#define STEP 6.\n#define maxHill 200.\n\n#define lakeH 35.\n\n// Dome def\n#define R 1500.\n#define C vec3(0.,-970.,0.)\n#define WINTILE vec2(32.,64.)\n\n// Tree def\n#define treeH 80.\n#define cellD 10.\n#define maxCell 250\n#define cellH 150.\n\n// random threshold\n#define PINE .9\n#define BUSH .6\n\n/*************************************/\n/*          GROUND CONTROL           */\n/*************************************/\n\t\t\t\t\t\t\t\t\t\t// if terrain is inappropriate, ie center hill too high\n\t\t\t\t\t\t\t\t\t\t// or dome on the back-side, or too much collisions cam-terrain\n\t\t\t\t\t\t\t\t\t\t// change the offset of the fbm, as random result depends on each\n\t\t\t\t\t\t\t\t\t\t// GPU.\n#define FBM_OFFSET vec2(-.5,.5)\t\t\n\n\n\n/*************************************/\n/*            CAM CONTROL            */\n/*************************************/\n\t\t\t\t\t\t\t\t\t\t\t\t// Select one of the time set below.\n\t\t\t\t\t\t\t\t\t\t\t\t// time depending on iTime\n\t\t\t\t\t\t\t\t\t\t\t\t// or time depending on mouse \n//#define TIME iMouse.x/iResolution.x*120.\n\n#define TIME iTime\n\n\n\n\t\t\t\t\t\t\t// Uncomment FREE_CAM to have mouse controle\n\t\t\t\t\t\t\t// Change RAU value to set the distance to the visual center (target)\n//#define FREE_CAM\n\n#define RAU 800.\n\n\n\n/* centered on dome */\n#define TARGET vec3(0.,150.,0.);\n\n/* centered on Spirit Island */\n//#define TARGET vec3(-150.,50.,480.);\n\n/* following crater cliff (in) */\n//#define TARGET vec3(500.*cos(.1*iTime)+100.,60.,500.*sin(.1*iTime));\n// * following crater cliff (out) */\n//#define TARGET vec3(1200.*cos(.1*iTime)+300.,250.,1200.*sin(.1*iTime));\n\n\n/********************************************************************/\n/********************************************************************/\n\n\n#define LIGHT vec3(-0.691714463866075,0.207514339159822+.002*H2(vec2(floor(40.*TIME))),-0.691714463866075)\n//#define LIGHT normalize(vec3(-0.691714463866075,0.207514339159822+.002*H2(vec2(floor(40.*TIME))),-0.691714463866075))\n\n\nfloat H2(in vec2 st) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/* linear step = poor smoothstep but faster */\nfloat linstep(float a, float b, float x){\n    return clamp((x-a)/(b-a),0.,1.);\n}\n\nfloat fbm(vec3 p){\n    p*= .0035;\n    vec2 uv = p.xz+FBM_OFFSET;\n\tfloat a = 1., Hz = 1., m = 1., h= p.y;\t\t\t\t\t\n    vec2 d = vec2(1.,0.);\n    for(float i=1.;i<=STEP; i++){\n        vec2 e = floor(uv*Hz), f = fract(uv*Hz);\n        f = smoothstep(0.,1.,f);\n        h += mix(\n            \tmix(H2(e),H2(e+d.xy),f.x)*a,\n            \tmix(H2(e+d.yx),H2(e+d.xx),f.x)*a,\n            \tf.y);\n        \n        a *= .2+.1*h+.05*i;\n        //a *= .5;\n        Hz *= 2.+.2*p.y;\n        m += a;\n    }\n    h/=m;\n    \n    h *= h;\n    \n    return h;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*******************    buffer A    *********************/\n/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*               Shadows pre-calculation                */\n/* The 4 channels are used to increase map resolution   */\n/* \t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/********************************************************/\n\n\nfloat ground(vec2 p){\n    \n    float a = .000001*(p.x*p.x + p.y*p.y);\n    float h =smin(a*a,abs(1./a),.2)+.8/(50.*a+1.);\n    float m = fbm(vec3(p.x,maxHill*h,p.y));\n    return max(lakeH, maxHill*(.4*h*m+.2*m+.4*h)+ texture(iChannel0,.00125*p.xy+.5).r);\n}\n\nvec3 getGndNormal(vec3 p){\n    vec2 e = vec2(.1,0.);\n\tfloat dx = ground(p.xz+e.xy) - p.y;\n    float dy = ground(p.xz+e.yx) - p.y;\n    return normalize(vec3(dx,-e.x,dy));    \n}\n\n\nfloat traceGround(in vec3 pos, in vec3 ray){\n    float t = 0.;\n    float dh = pos.y-ground(pos.xz);\n    if(dh<.1) return .0001;\n    for(int i=0; i<75;i++){\n        vec3 p = pos;\n        t += .9*dh;\n        p = pos+t*ray;\n        if(p.y > 1.6*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n        dh = p.y-ground(p.xz);\n        if(abs(dh)<.1)break;\n    }\n    return t;\n}\n\n\nfloat shad(vec3 p){\n    \n        p.y = ground(p.xz);\n        vec3 norm = getGndNormal(p);\n        p -= .2*norm;\n        float t = traceGround(p,LIGHT);\n        if(t<INFINI) return .2;    \n        else return 1.;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float check = floor(texelFetch(iChannel1,ivec2(fragCoord),0).x -.1);\t// checking if resolution has changed\n    if(check == iResolution.x){\t\t\t\t\t\t\t\t\t\t\t\t// in order to manage screen size change.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if no change, just reading pre-calculated shadows\n        fragColor = texture(iChannel1,fragCoord/iResolution.xy);\t\t\t// stored in Buffer A\n    }\n\n    else{   \n        vec2 st = 2000.*fragCoord.xy/iResolution.xy;\t\t\t\t// if screen size has changed, bufferA size changed too \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// shadows must be recalculated.\n        vec3 p = vec3(st.x,0.,st.y);\n        fragColor.x = shad(p)+iResolution.x;\t\t\t\t\t\t// storing new resolution info\n\n        p.z = -p.z;\n        fragColor.y = shad(p);\n\n        p.x = -p.x;\n        fragColor.z = shad(p);\n\n        p.z = -p.z;\n        fragColor.w = shad(p);\n    } \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}