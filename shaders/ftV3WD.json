{
    "Shader": {
        "info": {
            "date": "1697264557",
            "description": "Idk this is from a while ago, don't trust the code style too much",
            "flags": 0,
            "hasliked": 0,
            "id": "ftV3WD",
            "likes": 14,
            "name": "Voronoi Night Sky",
            "published": 3,
            "tags": [
                "sky",
                "night"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 275
        },
        "renderpass": [
            {
                "code": "#define fov 1.0\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi = 3.141592653589793;\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n    p4 *= vec4(0.1031, 0.1030, 0.0973, 0.1099);\n    p4  = fract(p4);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    p4  = (p4.xxyz + p4.yzzw) * p4.zywx;\n    p4  = fract(p4);\n    return p4;\n}\n\n//\nfloat voronoi(in vec3 p, out vec3 c)\n{\n    float d = 10.0;\n\n    for(int pos_x = -1; pos_x <= 1; pos_x++) {\n    for(int pos_y = -1; pos_y <= 1; pos_y++) {\n    for(int pos_z = -1; pos_z <= 1; pos_z++) {\n        vec4 h = hash44( vec4(vec3(pos_x, pos_y, pos_z) + floor(p), 0.0) );\n\n        vec3 point = vec3(pos_x, pos_y, pos_z) + h.xyz;\n\n        float t = dot( point - fract(p), point - fract(p) );\n\n        if(t < d)\n        {\n            c = hash44(h.xyzw).rgb;\n        }\n\n        d = min(t, d);\n    }\n    }\n    }\n\n    return d;\n}\n\n//\nfloat gradient_noise(vec3 p, float t)\n{\n    vec3 f = smoothstep( 0.0, 1.0, fract(p) );\n    vec3 i = floor(p);\n\n    float h0 = hash44( vec4(i + vec3(0.0, 0.0, 0.0), t) ).x;\n    float h1 = hash44( vec4(i + vec3(1.0, 0.0, 0.0), t) ).x;\n    float h2 = hash44( vec4(i + vec3(0.0, 1.0, 0.0), t) ).x;\n    float h3 = hash44( vec4(i + vec3(1.0, 1.0, 0.0), t) ).x;\n    float h4 = hash44( vec4(i + vec3(0.0, 0.0, 1.0), t) ).x;\n    float h5 = hash44( vec4(i + vec3(1.0, 0.0, 1.0), t) ).x;\n    float h6 = hash44( vec4(i + vec3(0.0, 1.0, 1.0), t) ).x;\n    float h7 = hash44( vec4(i + vec3(1.0, 1.0, 1.0), t) ).x;\n\n    return mix(mix(mix(h0, h1, f.x), mix(h2, h3, f.x), f.y), mix(mix(h4, h5, f.x), mix(h6, h7, f.x), f.y), f.z);\n}\n\n//\nfloat fbm(vec3 p)\n{\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        value += atten * gradient_noise( scale * p, float(i) );\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.0;\n    }\n\n    return value / accum;\n}\n\n// https://www.shadertoy.com/view/llSyRD\nvec3 blackbody( float t )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8; // Speed of light\n\n    vec3 w = vec3(610.0, 549.0, 468.0) / 1e9; // sRGB approximate wavelength of primaries\n\n    // This would be more accurate if we integrate over a range of wavelengths\n    // rather than a single wavelength for r, g, b\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n\n    vec3 w5 = w * w * w * w * w;    \n    vec3 o = 2.0 * h * (c * c) / ( w5 * ( exp(h * c / (w * k * t) ) - 1.0) );\n\n    return o;\n}\n\n//\nvec3 sky_color(vec3 dir)\n{\n    const float t = 0.05;\n\n    vec3 c;\n\n    float v = (1.0 / t) * clamp(t - voronoi(80.0 * dir, c), 0.0, 1.0);\n\n    // https://www.shadertoy.com/view/llSyRD\n    vec3 b = 0.4 * clamp(1.0 - exp(-max(blackbody( (300.0 * c.x) + 600.0), 0.0) * 1.0), 0.0, 1.0) + 0.6;\n\n    float n0 = fbm( 3.0 *  dir        );\n    float n1 = fbm( 4.0 * (dir + 1.0) );\n\n    float d0 = 3.0 * (max(n0 - 0.4, 0.0) + 0.07);\n    float d1 = smoothstep( 0.0, 1.0, max(n1 - (4.0 * dir.y * dir.y), 0.0) );\n\n    return ( b * v * d0 * (1.0 - d1) ) + d1;\n}\n\n//\nvec2 rotate(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(\n    vec.x * c - vec.y * s,\n    vec.x * s + vec.y * c\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec3 rd = normalize( vec3(rotate(vec2(fov * uv.x, -1.0), 0.03 * pi * iTime), fov * uv.y).xzy );\n\n    fragColor.rgb = sky_color(rd);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}