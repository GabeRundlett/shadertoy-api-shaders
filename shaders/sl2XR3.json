{
    "Shader": {
        "info": {
            "date": "1628285363",
            "description": "Definitely longer than the golf code, with better edges.",
            "flags": 0,
            "hasliked": 0,
            "id": "sl2XR3",
            "likes": 8,
            "name": "Sharp Paper Cut",
            "published": 3,
            "tags": [
                "sharp",
                "ungolf"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 315
        },
        "renderpass": [
            {
                "code": "const float pi = acos(0.00000000);\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sign1(float x)\n{\n    return x < 0. ? -1. : 1.;\n}\n\nfloat smoothramp(float x, float size)\n{\n    return x < size ? .5 / size * x * x : x - .5 * size;\n}\n\nfloat wave(vec2 q)\n{\n    float r = length(q) / 8.;\n\n    float a = 0.;\n    //a += r;\n    a += smoothramp(r, 3.);\n    //a += (q.x + q.y) / 8.;\n    a += iTime;\n\n    return .6 * sin(a);\n}\n\nfloat exclude(float x, float w)\n{\n    return sign1(x) * max(w, abs(x));\n}\n\nvec3 paper(vec2 q)\n{\n    float height = 0.;\n\n    float w = 3.;\n    if (abs(q.y) < abs(q.x))\n        q.x = exclude(q.x, w);\n    else\n        q.y = exclude(q.y, w);\n\n    return vec3(q.x, height, q.y);\n}\n\nvec3 flap(vec2 q, vec2 Q)\n{\n    float qs = mod(Q.x + 4., 16.) < 8. ? q.x : -q.x;\n\n    float s;\n    //s = 12. * smoothstep(-3., 9., q.x);\n    //s = 12. * smoothstep(-3., 9., qs);\n    s = qs + 3.;\n\n    float height = wave(Q) * s;\n\n    float w = 3.;\n    q.x = clamp(q.x, -w, w);\n    q.y = clamp(q.y, -w, w);\n\n    return vec3(q.x, height, q.y);\n}\n\nvec3 M;\n\nfloat map(vec3 q)\n{\n    q.yz *= rot(.5 + 6. * M.y);\n    q.xz *= rot(2. - 6. * M.x);\n\n    // Also distorts wave sampling position. Only distorting\n    // cut position requires some more thoughts, As the closest-point\n    // queries have to be adapted to give a good enough sdf.\n    q.xz += .5*sin(q.zx/2.) + 2.*cos(q.zx/8.);\n\n    vec3 qq = q;\n    qq.xz = mod(qq.xz+4., 8.) - 4.;\n    \n    vec3 x_paper = paper(qq.xz);\n    float t_paper = length(x_paper - qq);\n\n    vec3 x_flap1 = flap(qq.xz, q.xz);\n    float t_flap1 = length(x_flap1 - qq);\n\n    float t = 9.;\n    t = min(t, t_flap1);\n    t = min(t, t_paper);\n    t -= .05;\n\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{    \n    vec3 R = iResolution;\n    vec3 D = normalize(vec3(2. * U, -3.5 * R.y) - R);\n    vec3 p = 90. / R;\n\n    //M =  iMouse.xyz/R -.5;\n    M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n\n    float tsum = 0.;\n    for (int i=0 ; i<100 ; ++i)\n    {\n        vec3 q = p + tsum * D;\n        float t = 9.;\n        t = min(t, map(q));\n        t = min(t, map(q + .5*t*D));\n\n        tsum += t;\n        //p += t * D;\n    }\n\n    vec3 q = p + tsum * D;\n    float eps = 2e-2;\n    float dx = map(q + vec3(eps, 0, 0)) - map(q);\n    float dy = map(q + vec3(0, eps, 0)) - map(q);\n    float dz = map(q + vec3(0, 0, eps)) - map(q);\n    vec3 normal = normalize(vec3(dx, dy, dz));\n    float light = dot(normal, -D);\n    float fog = smoothstep(300., 0., tsum - 50.);\n    O = vec4(1.5 * light * fog);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}