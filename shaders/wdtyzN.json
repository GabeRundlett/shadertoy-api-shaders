{
    "Shader": {
        "info": {
            "date": "1600709263",
            "description": "This is a path traced sceen with real indirect ligthing",
            "flags": 32,
            "hasliked": 0,
            "id": "wdtyzN",
            "likes": 15,
            "name": "global illumination test",
            "published": 3,
            "tags": [
                "raymarching",
                "gi",
                "globalillumination",
                "volumetric",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "Cewein",
            "viewed": 1503
        },
        "renderpass": [
            {
                "code": "// Shader made by Maximilien \"cewein\" Nowak, september 2020\n//\n// This is a path traced sceen with real indirect ligthing\n// the sceen is render with ray marching and then the color\n// found for the given pixel is accumuleted in the texture buffer\n//\n// THERE IS STILL SOME BIG ERROR :\n// \t\t- Wall corner are to bright\n//\t\t- turn of the sky light and one the back of the corridor will get GI\n//\t\t- the color change in the front and in the back\n//\n// main help came from here : \n// https://iquilezles.org/articles/simplepathtracing\n//\n//\n// \tCHECK BUFFER A FOR MOR INFORMATION AND THE CODE\n//\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col /= texture( iChannel0, uv ).w;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    // color grading and vigneting    \n    col = pow( col, vec3(0.8,0.85,0.9) );\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Shader made by Maximilien \"cewein\" Nowak, september 2020\n//\n// This is a path traced sceen with real indirect ligthing\n// the sceen is render with ray marching and then the color\n// found for the given pixel is accumuleted in the texture buffer\n//\n// THERE IS STILL SOME BIG ERROR :\n// \t\t- Wall corner are to bright\n//\t\t- turn of the sky light and one the back of the corridor will get GI\n//\t\t- the color change in the front and in the back\n//\n// main help came from here : \n// https://iquilezles.org/articles/simplepathtracing\n\n\n//global macro\n#define MAXSTEP 128\n#define EPSILON 0.0001\n\nfloat spp = 0.0;\n\nfloat hash(vec2 st)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(st.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 cosineDirection( in vec2 st, in vec3 nor)\n{\n    float a = 1.0 - 2.0*hash(st.xy * iTimeDelta);\n    float b = sqrt(1.0 - a*a);\n    float phi = 2.0*acos(-1.0)*hash(-st.yx * iTimeDelta);\n    \n    vec3 dir = vec3(0.0);\n    \n    dir.x = nor.x + b*cos(phi);\n    dir.y = nor.y + b*sin(phi);\n    dir.z = nor.z + a;\n    \n    dir = normalize(dir);\n    \n    return dir;\n}\n\n//signed distance function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//rotate for a given radian\nmat2 rot(float angle)\n{\n    angle *= 0.0174533;\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n//inifite geometry\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n//compute the distance between all sdf for a given pos and get the propor distance and id mat\nvec2 map(vec3 pos)\n{\n    //id is the material identificator (or in short the surface color)\n    float id = 0.0;\n    \n    //floor\n    float flr = pos.y + 1.0;\n    \n    pos = opRep(pos, vec3(2.0,1000.0,1000.0));\n    \n    //hollow cube with hole in a roof\n    float cube = sdBox(pos, vec3(4.0, .5,0.5));\n    float bigCube = sdBox(pos + vec3(0.0,49.4,0.0), vec3(50.0));\n    \n    vec3 rotPos = pos;\n    rotPos.y -= .5;\n    rotPos.yz *= rot(90.0);\n    float roofHole = sdBox(rotPos, vec3(0.2,0.2,0.5));\n    \n    cube = max(-cube, bigCube);\n    cube = max(-roofHole, cube);\n    \n    return vec2(cube, id);\n}\n\n//compute the normal for a given point\nvec3 getNormal(vec3 pos)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy ).x - map( pos-eps.xyy ).x,\n      map( pos+eps.yxy ).x - map( pos-eps.yxy ).x,\n      map( pos+eps.yyx ).x - map( pos-eps.yyx ).x ) );\n}\n\n\n//marching function, it send ray into the world and get the proper mat and distance\nvec2 getDistance(vec3 ro, vec3 rd, float dmax)\n{\n    //distance for the origine is x and y is the mat id\n    vec2 dmat = vec2(0.0);\n    \n    for(int i = 0; i < MAXSTEP; i++)\n    {\n        //position along the ray\n        vec3 pos = ro + dmat.x*rd;\n        \n        //get the distance to the nearest sdf surface\n        vec2 eval = map(pos);\n        \n        //if true it mean we are inside a sdf\n        if(eval.x < 0.0) return dmat;\n        \n        dmat.x += max(eval.x,0.00001);\n        dmat.y = eval.y;\n        \n        //true if out of range and set -1.0 for sky id\n        if(dmat.x > dmax) return vec2(dmat.x, -1.0);\n    }\n    return dmat;\n}\n\n//it is the same as the \"getDistance\" function but it's return 1.0 if no hit and 0.0 if hit\nfloat getShadow(vec3 ro, vec3 rd)\n{\n   float d = 0.001; \n   \n   for(int i = 0; i < MAXSTEP; i++)\n   {\n       vec3 pos = ro + d*rd;\n       \n       float eval = map(pos).x;\n       \n       if(eval < 0.0) return 0.0;\n       d += max(eval,0.04);\n       \n       if(d > 20.0) return 1.0;\n   }\n    \n   return 1.0;\n}\n\n//colorization function based on the id\nvec3 getSurfaceColor(float id)\n{\n    if(id < -0.5)\n        return vec3(0.5,0.4,0.6);\n    else\n        return vec3(0.5);\n}\n\nvec3 sunDir = vec3(0.0,1.0,-0.1);\n\nvec3 sunCol =  10.0*vec3(1.0,0.8,0.6);\nvec3 skyCol =  10.0*vec3(0.2,0.35,0.5);\n\nvec3 renderPixel(vec3 ro,vec3 rd, float sa, vec2 uv)\n{\n    vec3 colorStrengh = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n    \n    float fdis = 0.0;\n    \n    //GI bounce\n    for(int nbBounce = 0; nbBounce < 5; nbBounce++)\n    {\n        rd = normalize(rd);\n        //evaluation of distance to the sdf agregate and get the id mat in the same time\n        vec2 dist = getDistance(ro, rd, 100.0);\n        \n        if( nbBounce==0 ) fdis = dist.x;\n\n        //get the intersection position and the normal at this point\n        vec3 pos = ro + dist.x*rd;\n        vec3 norm = getNormal(pos);\n        \n        if(dist.y < 0.0)\n        {\n            if( nbBounce==0 ) { fdis=16.0; accumulatedColor = mix( 0.05*vec3(0.9,1.0,1.0), skyCol, smoothstep(0.1,0.25,rd.y) ); break; }\n            break;\n        }\n        \n        if( nbBounce==0 ) fdis = dist.x;\n\n        //surface color\n        colorStrengh *= getSurfaceColor(dist.y);\n        \n        vec3 col = vec3(0.0);\n\n        //lighting\n        //sun\n        float sunSha = getShadow(pos + norm * EPSILON, sunDir);\n\n        //sky\n        vec3 skyPoint = cosineDirection( sa + 7.1*float(iFrame) + 5681.123 + float(nbBounce)*92.13 + uv.yx, norm);\n        float skySha = getShadow(pos + norm*EPSILON, skyPoint);\n\t\t\n        //perform bounce accumulation\n        col = sunCol * sunSha + skySha * skyCol;\n\t\taccumulatedColor += colorStrengh * col;\n        \n        //perfom the bounce\n        rd = cosineDirection(float(iTime) + uv.xy, norm);\n        ro = pos;\n        \n    }\n    \n    float ff = exp(-0.01*fdis*fdis);\n   \taccumulatedColor *= ff; \n   \taccumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n    \n    // volumetrics\n    float dt = 0.53;\n    float acc = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        float t = fdis*hash(sa+1.31+13.731*float(i)+float(iFrame)*7.773 + uv.yx);\n        vec3 pos = oro + ord*t;\n        acc += dt*getShadow( pos, sunDir )*exp(-0.25*t);\n    }\n    accumulatedColor += vec3(0.2)*pow(acc,0.4545)*sunCol*0.4;\n\n\n    return accumulatedColor;\n}\n\n\n//Ray function\nvec3 getDirection(vec3 ro, vec3 target, vec2 uv, float fov)\n{\n    vec3 ww = normalize(target - ro); //front\n    vec3 uu = normalize(cross(ww,vec3(0.,1.,0.))); //right\n\tvec3 vv = normalize(cross(uu,ww)); //up\n    \n    return normalize(uv.x * uu + uv.y*vv + fov*ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) +  uv);\n    \n    vec2 of = -0.5 + vec2( hash(sa+13.271+uv), hash(sa+63.216+uv) );\n    \n    \n    //ray generation\n    vec3 target = vec3(-15.0,0.5,2.0);\n   \tvec3 ro = vec3(-2.5,.0,-0.4);\n    vec3 rd = getDirection(ro,target, uv, 1.5);\n    \n    //get the texture pixel color\n    vec3 col = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n    float spp = texture( iChannel0, fragCoord/iResolution.xy ).w;\n    if( iFrame==0 || iMouse.z > 0.0) \n    {\n        col = vec3(0.0);\n        spp = 0.0;\n    }\n    \n    //accumulate the rendered pixel into the color\n    col += renderPixel(ro, rd, sa, uv);\n    spp += 1.0;\n    //output the color to the screen\n    fragColor = vec4(col,spp);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}