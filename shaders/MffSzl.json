{
    "Shader": {
        "info": {
            "date": "1705581407",
            "description": "Varying B-splines and their control points",
            "flags": 0,
            "hasliked": 0,
            "id": "MffSzl",
            "likes": 31,
            "name": "Spline Waltz",
            "published": 3,
            "tags": [
                "spline"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 366
        },
        "renderpass": [
            {
                "code": "// \"Spline Waltz\" by dr2 - 2024\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrEECaps2Df (vec2 p, vec2 v1, vec2 v2, float rc);\nvec4 SphHit (vec3 ro, vec3 rd, float rad);\nvec4 CylHit (vec3 ro, vec3 rd, float rad, float len);\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len);\nfloat Maxv2 (vec2 p);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nvec2 Rot2D (vec2 q, float aa);\nmat3 StdVuMat (float el, float az);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nint nFrame, idObj, nSubdiv, nCPoint;\nconst int idTrSeg = 1, idCPoint = 2, idVCol = 3, idCon = 4, idBas = 5;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec3 GetCnPoint (int n)\n{\n  vec3 p;\n  float fn;\n  fn = float (n) / float (nCPoint);\n  p.xz = Rot2D (vec2 (4. + 2. * sin (10. * pi * fn), 0.), 2. * pi * fn);\n  p.xz += Rot2D (vec2 (1., 0.), 2. * pi * (11. * fn + 0.2 * tCur));\n  p.y = 1.6 + 0.4 * sin (8. * pi * float (n) / float (nCPoint)) +\n     1. * sin (2. * pi * (13. * fn + 0.3 * tCur));\n  return p;\n}\n\nvec3 GetTrkPt (int n)\n{ // (B-spline, from an old C/OpenGL editable roller-coaster sim)\n  vec3 w[4];\n  float d, s;\n  int ik;\n  ik = n / nSubdiv;\n  d = float (n - ik * nSubdiv) / float (nSubdiv);\n  for (int k = 0; k <= 3; k ++) {\n    w[k] = GetCnPoint (ik);\n    if (++ ik == nCPoint) ik = 0;\n  }\n  for (int np = 0; np < 3; np ++) {\n    s = 1. / float (3 - np);\n    for (int k = 0; k < 3 - np; k ++) w[k] = mix (w[k + 1], w[k], (float (k + 1) - d) * s);\n  }\n  return w[0];\n}\n\nvec4 ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 rMat;\n  vec4 db4;\n  vec3 vn, vnn, rc, rt;\n  float dMin, dm, len;\n  int nTrSeg, kk;\n  nTrSeg = nCPoint * nSubdiv;\n  dMin = dstFar;\n  dm = dstFar;\n  rc = GetTrkPt (nTrSeg - 1);\n  for (int k = VAR_ZERO; k < nTrSeg; k ++) {\n    rt = rc;\n    rc = GetTrkPt (k);\n    len = length (rc - rt);\n    rMat = DirToRMatT ((rc - rt) / len, vec3 (0., 0., 1.));\n    db4 = CapsHit ((ro - 0.5 * (rc + rt)) * rMat, rd * rMat, 0.07, 0.5 * len);\n    if (db4.x < dm) {\n      dm = db4.x;\n      vnn = rMat * normalize (db4.yzw);\n    }\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vnn;\n    idObj = idTrSeg;\n  }\n  dm = dstFar;\n  for (int k = VAR_ZERO; k < nCPoint; k ++) {\n    db4 = SphHit (ro - GetCnPoint (k), rd, 0.06);\n    if (db4.x < dm) {\n      dm = db4.x;\n      vnn = db4.yzw;\n    }\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vnn;\n    idObj = idCPoint;\n  }\n  dm = dstFar;\n  for (int k = VAR_ZERO; k < nCPoint; k ++) {\n    rc = GetCnPoint (k);\n    db4 = CylHit ((ro - rc * vec3 (1., 0.5, 1.)).xzy, rd.xzy, 0.03, 0.5 * rc.y);\n    if (db4.x < dm) {\n      dm = db4.x;\n      vnn = db4.ywz;\n    }\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vnn;\n    idObj = idVCol;\n  }\n  dm = dstFar;\n  for (int k = VAR_ZERO; k < nCPoint; k ++) {\n    rc = GetCnPoint (k);\n    kk = nSubdiv * (k - 1);\n    if (kk < 0) kk += nTrSeg;\n    rt = GetTrkPt (kk);\n    len = length (rc - rt);\n    rMat = DirToRMatT ((rc - rt) / len, vec3 (0., 0., 1.));\n    db4 = CapsHit ((ro - 0.5 * (rc + rt)) * rMat, rd * rMat, 0.02, 0.5 * len);\n    if (db4.x < dm) {\n      dm = db4.x;\n      vnn = rMat * normalize (db4.yzw);\n    }\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vnn;\n    idObj = idCon;\n  }\n  dm = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vec3 (0., 1., 0.);\n    idObj = idBas;\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 db4;\n  vec3 col, vn;\n  vec2 sc, sp;\n  float t;\n  int nTrSeg;\n  nSubdiv = 6;\n  nCPoint = 50;\n  nTrSeg = nCPoint * nSubdiv;\n  db4 = ObjHit (ro, rd);\n  if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    if (idObj == idTrSeg) {\n      col = vec3 (0.2, 1., 0.2);\n    } else if (idObj == idCPoint) {\n      col = vec3 (1., 0.2, 0.2);\n    } else if (idObj == idVCol) {\n      col = vec3 (0.4, 0.4, 1.);\n    } else if (idObj == idCon) {\n      col = vec3 (1., 1., 0.2);\n    } else if (idObj == idBas) {\n      col = vec3 (0.7, 0.4, 0.4) * (1. - smoothstep (9.5, 10., length (ro.xz))) *\n         (1. - 0.1 * step (0.47, Maxv2 (abs (fract (2. * ro.xz) - 0.5))));\n      t = 1.;\n      for (int k = VAR_ZERO; k < nCPoint; k ++) t = min (t, length (ro.xz - GetCnPoint (k).xz));\n      col *= 0.7 + 0.3 * smoothstep (0.08, 0.1, t);\n      t = 1.;\n      sc = GetTrkPt (nTrSeg - 1).xz;\n      for (int k = VAR_ZERO; k < nTrSeg; k ++) {\n        sp = sc;\n        sc = GetTrkPt (k).xz;\n        t = min (t, PrEECaps2Df (ro.xz, sp, sc, 0.02));\n      }\n      col *= 0.5 + 0.5 * smoothstep (0., 0.02, t);\n    }\n    col *= (0.4 + 0.6 * max (dot (vn, ltDir), 0.));\n  } else {\n    col = vec3 (0.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  zmFac = 4.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 4. * smoothstep (0.5, 1.5, abs (az));\n  } else {\n    az -= 0.01 * pi * tCur;\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.2, -20.);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float aa = float (VAR_ZERO); aa < naa; aa ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * aa + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrEVCaps2Df (vec2 p, vec3 u, float rc)\n{\n  return length (p - clamp (dot (p, u.xy), 0., u.z) * u.xy) - rc;\n}\n\nfloat PrEECaps2Df (vec2 p, vec2 v1, vec2 v2, float rc)\n{\n  return PrEVCaps2Df (p - v1, vec3 (normalize (v2 - v1), length (v2 - v1)), rc);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float c, d, t;\n  c = dot (rd, ro);\n  t = c * c + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (t > 0.) {\n    d = - c - sqrt (t);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, vn;\n  float dMin, d, c1, c2, t, srdz;\n  dMin = dstFar;\n  c1 = dot (rd.xy, rd.xy);\n  c2 = dot (rd.xy, ro.xy);\n  t = c2 * c2 - c1 * (dot (ro.xy, ro.xy) - rad * rad);\n  if (t > 0.) {\n    srdz = sign (rd.z);\n    if (c1 > 0.) {\n      d = - c2 - sqrt (t);\n      if (d > 0.) {\n        d /= c1;\n        s = ro + d * rd;\n      } else s.z = len;\n    } else s.z = len;\n    if (abs (s.z) < len) {\n      dMin = d;\n      vn = vec3 (s.xy / rad, 0.);\n    } else if (srdz * ro.z < - len) {\n      d = - (srdz * ro.z + len) / abs (rd.z);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xy) < rad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdz);\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, vn;\n  float dd, d, c1, c2, t;\n  dd = dstFar;\n  c1 = dot (rd.xy, rd.xy);\n  c2 = dot (rd.xy, ro.xy);\n  t = c2 * c2 - c1 * (dot (ro.xy, ro.xy) - rad * rad);\n  if (t > 0. && c1 > 0.) {\n    d = - c2 - sqrt (t);\n    d /= c1;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dd = d;\n      vn = vec3 (s.xy, 0.);\n    } else {\n      ro.z -= len * sign (s.z);\n      c2 = dot (rd, ro);\n      t = c2 * c2 - (dot (ro, ro) - rad * rad);\n      if (t > 0.) {\n        d = - c2 - sqrt (t);\n        if (d > 0.) {\n          dd = d;\n          vn = ro + d * rd;\n        }\n      }\n    }\n  }\n  return vec4 (dd, vn);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = normalize (cross (vu, vd));\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nvec2 Rot2D (vec2 q, float aa)\n{\n  vec2 cs;\n  cs = sin (aa + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}