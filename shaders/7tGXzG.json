{
    "Shader": {
        "info": {
            "date": "1640965001",
            "description": "Raymarching with Refractance",
            "flags": 16,
            "hasliked": 0,
            "id": "7tGXzG",
            "likes": 4,
            "name": "ReFractance",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "PsyPhi",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 50\n#define MAX_DIST 25.\n#define SURF_DIST .001\n#define FRACT_STEPS 1\n#define PI 3.14159\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 MOD3 = vec3(443.8975, 397.2973, 491.1871);\n    vec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a) {\n\tfloat c = cos(a),\n\ts = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ){  //smooth merges two objects\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//DIST\nfloat GetDist(vec3 p) {\n    vec3 pUnaltered = p;\n\nfor (int i = 0; i < FRACT_STEPS ; i++){\n\n    int mirrorX = 1;\n    int mirrorY = 1;\n    int mirrorZ = 0;\n    vec3 trans = vec3(1,0.001,0.);\n    vec3 rot = vec3(0.5,0.5,0.5);\n    float twist = 0.1;\n    float range = 0.1;\n    float stepAmt = 0.01;\n    float even = -1.+floor(mod(float(i),2.))*2.;\n    float fifth = 1.+floor(mod(float(i),2.))*-2.;\n\n    if(mirrorX == 1) p.x = abs(p.x); //Mirror X\n    if(mirrorY == 1 && fifth == -1.) p.y = abs(p.y); //Mirror Y\n    if(mirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\n    //TRANSFORM\n    //Transform X\n    p.x -= trans.x;\n    +(iMouse.x/iResolution.x)*range\n    +sin(iTime*0.2)\n    +((float(FRACT_STEPS)-float(i))*stepAmt)\n    ;\n    //Transform Y\n    p.y -= trans.y+(iMouse.x/iResolution.x)*range\n    +(iMouse.x/iResolution.x)*range\n    +cos(iTime*0.1)\n    +((float(FRACT_STEPS)-float(i))*stepAmt)\n    ;\n    //Transform Z\n    p.z -= trans.z;\n\n\n    //ROTATE\n    p.xy *= rotate(rot.x+sin(iTime*0.02)*p.z*0.001);\n    p.xz *= rotate(rot.y+cos(iTime*0.01))*even;\n    p.yz *= rotate(rot.z\n    +(float(FRACT_STEPS)-float(i))*stepAmt\n    );\n    \n    //SCALE\n    //p * vec3(20.);\n\n    //Twist\n    p.xz *= rotate(twist);\n}\n\n    //Rotate object w mouse\n    p.xz *= rotate(1.-(iMouse.x/iResolution.x)*5.);\n    p.yz *= rotate((iMouse.y/iResolution.y)*5.);\n\n\tfloat d = 1.; //Just to have the d var declaired\n\tvec4 rec = vec4(0.0, 0.0, 0.0, 5.*abs(sin(iTime*0.25))+2.);\n\tfloat recDist = length(max(abs(p) - rec.w, 0.));\n\n    //Dimond\n    float dimond = sdOctahedron(p+vec3(0.,0.,0.),10.);\n    float boxFrame = sdBoxFrame(p, vec3(5.,5.,5.), 0.5);\n    \n    //Sphere\n    //float sphere = sdSphere( pUnaltered, 5.);\n    \n    d = dimond;\n    d = opSmoothUnion( dimond,boxFrame, 1.);\n    d = fOpUnionStairs(dimond,boxFrame, 1., 4.);\n    //d = opIntersection( recDist, dimond );\n    //d = opSubtraction( dimond, recDist);\n    //d = opSmoothUnion( d,sphere, 1.);\n\n\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, float side) {//Side 1 = outside -1 = inside\n\tvec3 dO = vec3(0.,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p)*side;\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.1, 0);//Set to .001 for relistic, increase to soften edges.\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l,1.).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = texture(iChannel0, rd).rgb;\n    float IOR = 1.45;\n    \n    vec3 d = RayMarch(ro, rd, 1.);//raymarch outside\n    \n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;//get closest point?\n        vec3 n = GetNormal(p)\n            //+hash12(p.xy)*0.005//Texture on normals\n            ;\n            \n        vec3 r = reflect(rd,n);//reflected ray direction\n        vec3 reflTex = texture(iChannel0, r).rgb;//reflected Texture\n        vec3 refCol = vec3(0.0,1.,1.0);\n        \n        vec3 rdIn = refract(rd, n, 1./IOR);//Ray direction after being refracted into the object\n       \n        vec3 pEnter = p- n*SURF_DIST*3.;//Point that enters the object\n        vec3 dIn = RayMarch(pEnter, rdIn, -1.);//raymarch inside\n        \n        vec3 pExit = pEnter + rdIn * dIn.x;//get closest point?\n        vec3 nExit = -GetNormal(pExit);\n        \n        vec3 refraTex = vec3(0.);//refracted Texture\n        vec3 rdExit = vec3(0.);\n        \n        float chromaticAbberation = 0.01;\n        float dens = 0.07; //Density of the object\n        vec3 densCol = vec3(1.0,0.5,0.9); // color of the object\n      \n        //red\n        rdExit = refract(rdIn, nExit, IOR-chromaticAbberation);//Ray direction after being refracted out of the object\n        if(dot(rdExit,rdExit) == 0.) rdExit = reflect(rdIn, nExit);\n        refraTex.r = texture(iChannel0, rdExit).r;\n        \n        //green\n        rdExit = refract(rdIn, nExit, IOR);//Ray direction after being refracted out of the object\n        if(dot(rdExit,rdExit) == 0.) rdExit = reflect(rdIn, nExit);\n        refraTex.g = texture(iChannel0, rdExit).g;\n        \n        //blue\n        rdExit = refract(rdIn, nExit, IOR+chromaticAbberation);//Ray direction after being refracted out of the object\n        if(dot(rdExit,rdExit) == 0.) rdExit = reflect(rdIn, nExit);\n        refraTex.b = texture(iChannel0, rdExit).b;\n        \n        float fresnel = pow(1.+dot(rd,n), 5.);\n        \n        float optDist = exp(-dIn.x*dens); \n\n        float light = GetLight(p); //lighting\n        float diffuse = dot(n,normalize(vec3(1,2,3)))*.5+.5;//diffuse Mat\n        \n\n        refraTex = refraTex*optDist*densCol;//absorbs light and colors it as it passed through the object.\n        //col = vec3(fresnel);p[\n        //col = n*0.5+0.5;\n        //col = vec3(1.-d.x*0.04);\n        \n        col = mix(refraTex, reflTex*refCol, fresnel);\n        col = mix(col,n*0.5+0.5,floor(mod(d.x,2.0)));\n    }\n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n\n{\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    vec3 color = vec3(0);\n    vec3 iterationsColor;\n\tvec3 proxColor;\n    vec3 distColor;\n    vec3 normalColor = vec3(0.);\n\n    vec3 ro = vec3(0, 0, -30);\n     //rd.xz *= rotate((iMouse.x/iResolution.x)*5.);\n    //rd.yz *= rotate((iMouse.y/iResolution.y)*5.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n\n    \n    //color = texture(iChannel0,rd).rgb;\n    \n    color = render(ro,rd);\n\n    color = pow(color, vec3(0.454));\n    fragColor = vec4(color,1.0);\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}