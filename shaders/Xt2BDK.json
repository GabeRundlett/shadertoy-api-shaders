{
    "Shader": {
        "info": {
            "date": "1517331374",
            "description": "Triangles spinning over a grid of Porter-Duff compositing operators.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt2BDK",
            "likes": 0,
            "name": "Compositing 101",
            "published": 3,
            "tags": [
                "2d",
                "triangle",
                "blending",
                "distance",
                "compositing",
                "porterduff"
            ],
            "usePreview": 0,
            "username": "loicm",
            "viewed": 586
        },
        "renderpass": [
            {
                "code": "// ┌──────────────────┬──────────────────┐\n// │     A            │     B            │\n// ├──────────────────┼──────────────────┤\n// │     A over B     │     B over A     │\n// ├──────────────────┼──────────────────┤\n// │     A in   B     │     B in   A     │\n// ├──────────────────┼──────────────────┤\n// │     A out  B     │     B out  A     │\n// ├──────────────────┼──────────────────┤\n// │     A atop B     │     B atop A     │\n// ├──────────────────┼──────────────────┤\n// │     A xor  B     │     A plus B     │\n// └──────────────────┴──────────────────┘\n//\n// http://graphics.pixar.com/library/Compositing/paper.pdf.\n\n#define sat(x) clamp(x, 0.0, 1.0)\n\nconst vec3 kColorA = vec3(0.5, 0.9, 0.1);  // sRGB.\nconst vec3 kColorB = vec3(0.9, 0.5, 0.1);  // sRGB.\nconst float kAlpha = 0.8;\nconst float kGamma = 2.2;\nconst float kSpeed = 1.0;\n\nvec4 SRGBToPremultRGBA(vec3 color, float alpha) {\n    return vec4(pow(color, vec3(kGamma)) * alpha, alpha);\n}\n\nvec3 PremultRGBAToSRGB(vec4 color) {\n    return pow(color.xyz / color.w, vec3(1.0 / kGamma));\n}\n\nfloat Triangle(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p) {\n    // Signed distance to 2D triangle by iq (https://www.shadertoy.com/view/XsXSz4).\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n    vec2 pq0 = v0 - e0 * sat(dot(v0, e0) / dot(e0, e0));\n    vec2 pq1 = v1 - e1 * sat(dot(v1, e1) / dot(e1, e1));\n    vec2 pq2 = v2 - e2 * sat(dot(v2, e2) / dot(e2, e2));\n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(min(\n        vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n        vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),\n        vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n    float distance = sqrt(d.x) * sign(d.y);\n\n    // Anisotropic analytic anti-aliasing.\n    float aa = 0.7 * length(vec2(dFdx(p.x), dFdy(p.y)));\n\treturn smoothstep(-aa, aa, distance);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 area = iResolution.xy / vec2(2.0, 6.0);\n    vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0) - 1.0;\n\n    // Create spinning triangles.\n    vec2 v1 = vec2(sin(0.91 * iTime * kSpeed), sin(0.69 * iTime * kSpeed) * 0.2 - 0.8);\n    vec2 v2 = vec2(sin(0.73 * iTime * kSpeed), sin(0.51 * iTime * kSpeed) * 0.8);\n    vec2 v3 = vec2(sin(0.81 * iTime * kSpeed), sin(0.62 * iTime * kSpeed) * 0.2 + 0.8);\n    float coverage = Triangle(v1, v2, v3, uv);\n    vec4 a = SRGBToPremultRGBA(kColorA * vec3(coverage), coverage * kAlpha);\n    coverage = Triangle(-v1.yx, v2.yx, -v3.yx, uv);\n    vec4 b = SRGBToPremultRGBA(kColorB * vec3(coverage), coverage * kAlpha);\n\n    // Blend them.\n    vec4 blend;\n    if (fragCoord.y > 5.0 * area.y) {  // A, B\n        blend = fragCoord.x < area.x ? a : b;\n    } else if (fragCoord.y > 4.0 * area.y) {  // A over B, B over A\n        blend = fragCoord.x < area.x ? a + b * (1.0 - a.a) : a * (1.0 - b.a) + b;\n    } else if (fragCoord.y > 3.0 * area.y) {  // A in B, B in A\n        blend = fragCoord.x < area.x ? a * b.a : b * a.a;\n    } else if (fragCoord.y > 2.0 * area.y) {  // A out B, B out A\n        blend = fragCoord.x < area.x ? a * (1.0 - b.a) : b * (1.0 - a.a);\n    } else if (fragCoord.y > area.y) {  // A atop B, B atop A\n        blend = fragCoord.x < area.x ? a * b.a + b * (1.0 - a.a) : a * (1.0 - b.a) + b * a.a;\n    } else {  // A xor B, A plus B\n        blend = sat(fragCoord.x < area.x ? a * (1.0 - b.a) + b * (1.0 - a.a) : a + b);\n    }\n\n    // Cut out with a grid to emphasize the areas.\n    vec2 p = sat(floor(mod(fragCoord, area)));\n    blend *= vec4(p.x * p.y);\n\n    // Blend over a dark checker board.\n    p = floor(0.1 * fragCoord);\n    vec4 c = vec4(mod(p.x + p.y, 2.0) * vec3(0.015) + vec3(0.015), 1.0);\n    blend += c * (1.0 - blend.a);\n\n    fragColor = vec4(PremultRGBAToSRGB(blend), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}