{
    "Shader": {
        "info": {
            "date": "1551090449",
            "description": "mouse x for cam rotation\nmouse y for change count slices",
            "flags": 0,
            "hasliked": 0,
            "id": "WslXWr",
            "likes": 30,
            "name": "Julia Revolute Sliced",
            "published": 3,
            "tags": [
                "julia",
                "revolute",
                "sliced"
            ],
            "usePreview": 1,
            "username": "aiekick",
            "viewed": 1051
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - @Aiekick/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// mouse x for cam rotation\n// mouse y for change count slices\n    \n#define ANGLE_CUTTER\n//#define RADIUS_CUTTER\n\n// a bit noisy\n//#define HEIGHT_CUTTER\n\nfloat countSlices;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.14159 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat julia(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    for (int i=0;i<5;i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);\n}\n\nfloat fractusSliced(vec3 p, float a, float n, float oa)\n{\n#ifdef HEIGHT_CUTTER\n    p.y += oa/n;\n\tfloat cutterHeight = abs(abs(fract(p.y*n)-0.5) - 0.225)-0.225;\n\tp.y = floor(p.y*n)/n;\t\n#endif\n#ifdef ANGLE_CUTTER\n    a += oa/n;\n\tfloat cutterAngle = abs(abs(fract(a*n)-0.5) - 0.225)-0.225;\n\ta = floor(a*n)/n;\t\n#endif\n    vec2 c = vec2(mix(0.2, -0.5, sin(a * 2.)), mix(0.5, 0.0, sin(a * 3.)));   \n    float path = length(p.xz) - 3.;\n#ifdef RADIUS_CUTTER\n    path += oa/n;\n\tfloat cutterRadius = abs(abs(fract(path*n)-0.5) - 0.225)-0.225;\n\tpath = floor(path*n)/n;\t\n#endif\n    vec2 rev = vec2(path, p.y);\n    float aa = a + iTime;\n    rev *= mat2(cos(aa),-sin(aa),sin(aa),cos(aa)); // rot near axis y\n    float d = julia(rev, c);\n#ifdef HEIGHT_CUTTER\n    d = max(cutterHeight,d);\n#endif\n#ifdef ANGLE_CUTTER\n    d = max(cutterAngle,d);\n#endif\n#ifdef RADIUS_CUTTER\n    d = max(cutterRadius,d);\n#endif\n\treturn d;\n}\n\nfloat dfFractus(vec3 p)\n{\n\tfloat a = fullAtan(p.xz);\n\treturn min(\n        fractusSliced(p,a,countSlices,0.), \n        fractusSliced(p,a,countSlices,0.5));\n}\n\nfloat map(vec3 p)\n{\n\treturn min(\n        p.y + 2.5 - sin(dot(p.xz,p.xz)*0.25 - iTime)*0.5, \n        dfFractus(p));\n}\n\nfloat march( in vec3 ro, in vec3 rd )\n{\n\tfloat s = 1.;\n    float d = 0.;\n\tfor( int i=min(iFrame,0); i<200; i++ )\n    {\n        if( \n\t\t\t//d*d/s>1e6||\n\t\t\tabs(s)<0.0025*(d*.125 + 1.)|| // shane formula\n\t\t\td>100. ) break;\n\t    s = map( ro+rd*d );\n        d += s * 0.1;\n    }\n    return d;\n}\n\nvec3 getNor( vec3 p, float k )\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(p+eps.xyy) - map(p-eps.xyy),\n\t    map(p+eps.yxy) - map(p-eps.yxy),\n\t    map(p+eps.yyx) - map(p-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// iq code\nfloat getSha( in vec3 ro, in vec3 rd, in float hn)\n{\n    float res = 1.0;\n    float t = 0.0005;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, hn*h/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n// iq code\nfloat getAO( in vec3 p, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float(i)/4.0;\n        vec3 aopos =  nor * hr + p;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// shane code\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// shane code\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec3 light( in vec3 ld, in vec3 lc, in vec3 tex, in vec3 n, in vec3 rd )\n{    \n    float diff = pow(dot(n, -ld) * .5 + .5,2.0);\n    float spe = pow(max(dot(-rd, reflect(ld, n)), 0.0), 32.0);\n    \n    return (tex * diff + spe) * lc * 1.5;\n}\n\nvec3 shade( in vec3 ro , in vec3 rd, in float d )\n{    \n\tvec3 p = ro + rd * d;\n\t\n\tvec3 n = getNor(p, 0.0001);\n    \n    vec3 d1 = -normalize(vec3(1,2.5,3));\n    vec3 d2 = -normalize(vec3(5,3.5,0.5));\n    \n\tconst float tSize0 = 0.5;\n\tvec3 sn = texBump(iChannel0, p * tSize0, n, 0.01);\n\tvec3 texCol = tex3D(iChannel0, p * tSize0, sn);\n\n    float sha = 0.5 + 0.5 * getSha(p, sn, 2.0);\n    float ao = getAO(p, sn);\n    \n    vec3 l1 = light(d1, vec3(1,1,1), texCol, sn, rd);\n    vec3 l2 = light(d2, vec3(1.2), texCol, sn, rd);\n    \n\tvec3 col = texCol * 0.2 * ao + (l1 + l2) * sha;\n\t\n    // cold\n    //float b = dot(sn,normalize(ro-p)) * 0.9;\n    //col /= (b * vec3(0.9,0.8,0.4) + pow(b, 0.2)) * (1.0 - d * .01);\n    \n\treturn mix(col, vec3(0), 1.0-exp(-0.005*d*d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    countSlices = 30.;\n    float ca = 3.6;\n    \n    if (iMouse.z>0.0)\n    {\n        countSlices = floor(iMouse.y / iResolution.y * 29.) + 1.;\n        ca = iMouse.x / iResolution.x * -6.28318;\n    }\n    \n\tvec2 uv = (fragCoord*2. - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 ro = vec3(cos(ca), 8., sin(ca)); ro.xz *= 8.;\n    vec3 rov = normalize(-ro);\n    vec3 u = normalize(cross(vec3(0,1,0),rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + 0.5*uv.x*u + 0.5*uv.y*v);\n    \n\tfloat d = march(ro, rd);\n    \n\tvec3 col = shade(ro, rd, d);\n \n\tfragColor = vec4(sqrt(col*col*1.2),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}