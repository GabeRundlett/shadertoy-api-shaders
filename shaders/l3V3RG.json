{
    "Shader": {
        "info": {
            "date": "1717847354",
            "description": "my account was delete with all shaders=(((( admin pls answer on mail( why this happend(",
            "flags": 0,
            "hasliked": 0,
            "id": "l3V3RG",
            "likes": 1,
            "name": "star around the galaxy",
            "published": 3,
            "tags": [
                "space",
                "stars"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 124
        },
        "renderpass": [
            {
                "code": "#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define time iTime\n#define resolution iResolution.xy\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n #define MAX_ITER 32\n float hash11(float p) {\nvec3 p3  = fract(vec3(p) * vec3(.1031, .11369, .13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 1d smooth noise\nfloat snoise1d(float f) {\n    return\n        mix(\n            hash11(floor(f)),\n            hash11(floor(f+1.)),\n            smoothstep(0., 1., fract(f))\n        );\n}\n\n/* star shape (2d distance estimate)\n   p = input coordinate\n   n = number of sides\n   r = radius\n   i = inset amount (0.0=basic polygon, 1.0=typical star\n*/\nfloat StarDE(vec2 p, float n, float r, float i) {\n    float rep = floor(-atan(p.x, p.y)*(n/6.28)+.5) / (n/6.28);\n    float s, c;\n    p = mat2(c=cos(rep), s=-sin(rep), -s, c) * p;\n    float a = (i+1.) * 3.14 / n;\n    p = mat2(c=cos(a), s=-sin(a), -s, c) * vec2(-abs(p.x), p.y-r);\n    return length(max(vec2(0.), p));\n}\n\n// StarDE, but with eyes\nfloat Starguy(vec2 p, float n, float r, float i, vec2 l) {\n\n    // blink\n    float b = pow(abs(fract(.087*time+.1)-.5)*2., 72.);\n   \n    // eye look\n    vec2 p2 = p + l;\n   \n    return\n        max(\n            StarDE(p, n, r, i),\n            // eyes\n            //-length(vec2(abs(p.x)-r*.18, min(0., -abs(p.y)+r*.1)))+r*.11\n            -length(\n                vec2(\n                    min(0., -abs(abs(p2.x)-r*.2)+r*b*.1),\n                    min(0., -abs(p2.y)+r*(1.-b)*.1)\n                )\n            )+r*.11\n           \n        );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\n     vec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n     vec4 O=fragColor;\n     vec2 C =fragCoord;\n     \nvec2 p = (gl_FragCoord.xy-resolution.xy/2.) / resolution.y;\n\n// time\nfloat t = .7 * time;\n\n// bob up and down\nvec2 p2 = p;\np2.y += .025 * sin(4.*t);\np2.y+=0.5*cos(iTime);\n    p2.x+=0.5*sin(iTime);\n// warping (pinned inversion)\np2 = p2 / dot(p2, p2) - .17 * vec2(sin(t), cos(4.*t));\np2 = p2 / dot(p2, p2);\n\nvec2 look = .02 * vec2(cos(.71*t), sin(.24*t));\n\n// Starguy\nfloat star = Starguy(p2, 5., .27, .7, look);\n\n// radiation base\nfloat rad = pow(Starguy(p, 5., .27, .7, look), .5);\n\n// radiating waves\nrad = snoise1d(24.*rad-2.*time) + .5*snoise1d(48.*rad-4.*time);\n\n// Starguy + radiation\nvec3 col =\nmix(\n   vec3(1.),\n   vec3(-.1, .0, .2),\n   clamp(star/.01, 0., 1.)\n) + 4.5 * vec3(1., .5, .23) * (1.05 - pow(star, .1) ) * (1.-.04*rad);\n     O=vec4(0);\n    vec3 n1,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        n1=g*d;\n       \n        a=30.;\n        n1=mod(n1-a,a*2.)-a;\n        s=3.;\n        for(int i=0;i++<8;){\n            n1=.3-abs(n1);\n           \n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            n1.y<n1.x?n1=n1.zyx:n1;\n           \n            s*=e=1.4+sin(iTime*.234)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n       //  g+=e=length(p.yz)/s;\n         g+=e=length(n1.yx)/s;\n    }\n    // distance of current pixel from center\nfloat cLength = length(cPos);\n\nfloat t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 0.2;\nfloat si = sin(t2);\nfloat co = cos(t2);\nmat2 ma = mat2(co, si, -si, co);\n   \n\nvec3 dir=vec3(uv*zoom,1.);\n;\n\nvec3 from=vec3(1.,.5,0.5);\n\nvec2 p3 = uv*8.0;\nvec2 i = p3;\nfloat c = 2.0;\nfloat inten = 1.0;\n\nfor (int n = 0; n < MAX_ITER; n++) {\nfloat t = time * (1.0 - (7. / float(n+1)));\ni = p2 + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n        p3.xy*=ma;\nc += 1.0/length(vec2(p3.x / (sin(i.x+t)/inten),p3.y / (cos(i.y+t)/inten)));\n}\nc /= float(MAX_ITER);\nfloat pulse = abs(fract(time*5.));\nfloat pulse2 = pow(sin(time*3.),.25);\nfloat pulse3 = pow(sin(time*2.),2.);\n\n\n   \nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.)));\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05), cos(iTime*0.05));// the magic formula\na+=abs(length(p)-pa);\n}\nfloat dm=max(0.,darkmatter-a*a*.001);\na*=a*a;\nif (r>6) fade*=1.1-dm;\n\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade;\nfade*=distfading;\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation);\nfragColor = vec4(v*.103,1.);\n\n\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n\n\nfragColor*= vec4(vec3(pow(c,1.5+pulse/2.))*(vec3(2.0+pulse2, 2.0-pulse, 1.5+pulse3)*(3.+pulse)/2.), 1.0);\nfragColor*=vec4(col,1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}