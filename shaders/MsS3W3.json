{
    "Shader": {
        "info": {
            "date": "1396932377",
            "description": "We finally found the last of the legendary temples, the temple of the sun. On the day of the summer solstice, we placed the sun stone in its place on the pedestal. The skies cleared and we finally understood why it's called a sun stone.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsS3W3",
            "likes": 100,
            "name": "Solstice",
            "published": 3,
            "tags": [
                "raymarching",
                "ambientocclusion",
                "runes",
                "architecture",
                "dome"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 4913
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n\nI tried to do lots of different lighting features with this. It has ambient occlusion.\nI did a traced shadow for sky light, but it took too much code space, so I faked it. (#define)\nThere is bounced light from where the sun rays hit.\nThere is light from the stained glass dome.\nThere are glowy rays and god rays.\nI kept running into code size limits on this one. I probably would have gone forever\nif it wasn't for those damn \"unknown error\" things when the code gets too big.\nI tried to do refraction in the crystal, but hit code size limits.\n-Otavio Good\n*/\n#define MANUAL_CAMERA 0\n#define TRACED_SKY_SHADOWS 0\n\nfloat PI=3.14159265;\nvec3 sunColOrig = vec3(255.0, 208.0, 100.0) / 255.0;\nvec3 environmentSphereColor = vec3(0.3001, 0.501, 0.901);\nvec3 environmentGroundColor = vec3(0.4001, 0.25, 0.1) * 0.25;\n\nfloat sparkle;\nfloat sinking;\nfloat marchingMultplier = 1.0;\nfloat glowDist;\nfloat globalRadial;\nfloat shadow;\nfloat localTime;\nvec3 sunCol;\nfloat rotateGem;\n\nfloat distFromSphere;\nvec3 normal;\nvec3 texBlurry;\n\nfloat material;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nfloat SmoothMix(float a, float b, float x)\n{\n\tfloat t = x*x*(3.0 - 2.0*x);\n\treturn mix(a, b, t);\n}\nvec3 RotateX(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n\t//else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n\t//else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// makes a thick line and passes back gray in x and derivates for lighting in yz\nvec3 ThickLine(vec2 uv, vec2 posA, vec2 posB, float radiusInv)\n{\n\tvec2 dir = posA - posB;\n\tfloat dirLen = length(dir);\n\tvec2 dirN = normalize(dir);\n\tfloat dotTemp = clamp(dot(uv - posB, dirN), 0.0, dirLen);\n\tvec2 proj = dotTemp * dirN + posB;\n\tfloat d1 = distance(uv, proj);\n\tvec2 derivative = (uv - proj);\n\n\tfloat finalGray = saturate(1.0 - d1 * radiusInv);\n\t// multiply derivative by gray so it smoothly fades out at the edges.\n\treturn vec3(finalGray, derivative * finalGray);\n}\n\n// makes a rune in the 0..1 uv space. Seed is which rune to draw.\n// passes back gray in x and derivates for lighting in yz\nvec3 Rune(vec2 uv, vec2 seed)\n{\n\tvec3 finalLine = vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n\t\t// generate seeded random line endPoints - just about any texture should work.\n\t\t// Hopefully this randomness will work the same on all GPUs (had some trouble with that)\n\t\tvec2 posA = texture(iChannel1, floor(seed+0.5) / iChannelResolution[1].xy).xy;\n\t\tvec2 posB = texture(iChannel1, floor(seed+1.5) / iChannelResolution[1].xy).xy;\n\t\tseed += 2.0;\n\t\t// expand the range and mod it to get a nicely distributed random number - hopefully. :)\n\t\tposA = fract(posA * 128.0);\n\t\tposB = fract(posB * 128.0);\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) posA.y = 0.0;\n\t\tif (i == 1) posA.x = 0.999;\n\t\tif (i == 2) posA.x = 0.0;\n\t\tif (i == 3) posA.y = 0.999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec2 snaps = vec2(2.0, 3.0);\n\t\tposA = (floor(posA * snaps) + 0.5) / snaps;\t// + 0.5 to center it in a grid cell\n\t\tposB = (floor(posB * snaps) + 0.5) / snaps;\n\t\t//if (distance(posA, posB) < 0.0001) continue;\t// eliminate dots.\n\n\t\t// Dots (degenerate lines) are not cross-GPU safe without adding 0.001 - divide by 0 error.\n\t\tvec3 tl = ThickLine(uv, posA, posB + 0.001, 10.0);\n\t\tif (tl.x > finalLine.x) finalLine = tl;\n\t}\n\treturn finalLine.xyz;\n}\n\n// k should be negative. -4.0 works nicely.\nfloat smin(float a, float b, float k)\n{\n\t// I'm guessing that base 2 operations are the fastest.\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = max(0.0, 0.01 / sunIntensity - 0.025);\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tvec3 ground = mix(environmentGroundColor, environmentSphereColor,\n\t\t\t\t\t  pow(abs(localRay.y), 0.35)*sign(localRay.y) * 0.5 + 0.5);\n\treturn ground + sunCol * sunIntensity;\n}\n\nfloat dSphere(vec3 p, float rad)\n{\n\treturn length(p) - rad;\n}\n\nfloat dBox(vec3 pos, vec3 b)\n{\n\treturn length(max(abs(pos)-(b),0.0));\n}\n\nfloat dBoxSlant(vec3 p, vec3 b)\n{\n\tfloat size = b.x;\n\tfloat f = length(max(abs(p)-(b),0.0));\n\t//float f = length(max(abs(p.x)+abs(p.z)-(b),0.0));\n\t//f = max(f, p.y*0.5 + abs(p.x) + abs(p.z) - size * 0.995);\n\treturn f;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat dBoxSigned(vec3 p)\n{\n\tfloat b = 1.0;\n\tvec3 b2 = vec3(6.0, 2.0, 2.0);\n\tvec3 center = vec3(0, -2.0, 0.0);\n\tvec3 d = abs(p - center) - b2;//*abs(cos(p.y + 0.5));\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dFloor(vec3 p)\n{\n\treturn p.y + 1.0;\n}\n\nfloat sdColumn( vec3 p, vec3 c )\n{\n\tfloat cyl = length(p.xz-c.xy)-c.z;// + abs(p.y);\n\tcyl -= cos(p.y*2.0)*0.045;\n\tfloat a = atan(p.x - c.x, p.z - c.y);\n\ta /= 2.0*PI;\n\tfloat subs = 48.0;\n\ta *= subs;\n\t//cyl *= pow(sin(a), 0.5) * 0.925 + 1.0;\n\tcyl += abs(sin(a)) * 0.015;\n\n\tcyl = max(cyl, p.y - 2.4);\n\tcyl = min(cyl, dBox(p + vec3(0.0, 1.0, 0.0), vec3(0.3, 0.2, 0.3)));\n\tcyl = smin(cyl, dBoxSlant(RotateY(p, PI/4.0) + vec3(0.0, -2.3, 0.0), vec3(0.3, 0.15, 0.3)), -24.0);\n\t//cyl = min(cyl, dBox(RotateY(p, PI/4.0) + vec3(0.0, -2.3, 0.0), vec3(0.3, 0.15, 0.3)));\n\treturn cyl;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat length16(vec2 v)\n{\n\treturn pow(pow(abs(v.x),16.0) + pow(abs(v.y), 16.0), 1.0/16.0);\n\t//return pow((pow(v.x,16.0) + pow(v.y, 16.0)), (1.0/16.0));\n}\nfloat sdTorusBricks( vec3 p, vec2 t, vec3 center, float subs )\n{\n\tp -= center;\n\tfloat a = globalRadial;// + PI/6.0;// atan(p.x, p.z);\n\ta = pow(abs(sin(a*subs)), 0.25);\n\t//a = mod(a,PI*2.0) - 0.5;\n\t//a = a *0.025 + 0.975;\n\ta = a *0.2 + 0.8;\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length16(q)-t.y*a;\n}\nfloat sdTorusArch( vec3 p, vec2 t, vec3 center, float subs )\n{\n\tp -= center;\n\tfloat a = atan(p.y, p.z);\n\ta = pow(abs(sin(a*subs)), 0.25);\n\t//a = mod(a,PI*2.0) - 0.5;\n\t//a = a *0.025 + 0.975;\n\ta = a *0.25 + 0.75;\n\tp.y -= cos(p.y)*0.4;\n\tvec2 q = vec2(length(p.yz)-t.x,p.x);\n\treturn length16(q)-t.y*a;\n}\n\nfloat sdPedestal( vec3 p, vec2 h )\n{\n\tp.y += 0.5 + sinking*0.2;\n    vec3 q = abs(p);\n    return max(q.y-h.y,max(q.z+q.x*0.57735,q.x*1.1547)-(h.x*(2.35 - p.y)));\n}\n\nfloat matMin(float a, float b, float matNum)\n{\n\tif (a < b)\n\t{\n\t\t//material = 0.0;\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\tmaterial = matNum;\n\t\treturn b;\n\t}\n}\n\n// This makes the stained glass windows in the dome.\nfloat dTiles(vec3 p)\n{\n\tfloat subs = 16.0;\n\tfloat final = length(p) - 2.2;\n\tfloat a = globalRadial;// atan(p.x, p.z);\n\ta /= 2.0*PI;\n\ta *= subs;\n\ta = abs((fract(a) - 0.5))*2.0;\t// triangle wave from 0.0 to 1.0\n\ta -= 0.15;\n\ta *= 6.0;\n\ta = max(0.0, a);\n\ta = min(0.75, a);\n\n\tfloat b = atan(length(p.xz), p.y);\n\tb /= 2.0*PI;\n\tb *= subs;\n\tb = abs((fract(b) - 0.5))*2.0;\t// triangle wave from 0.0 to 1.0\n\tb -= 0.15;\n\tb *= 6.0;\n\tb = max(0.0, b);\n\tb = min(0.75, b);\n\t\n\ta = a*b;\n\n\ta = a *0.2 + 0.8;\n\tb = b *0.2 + 0.8;\n\t\n\tfinal = final - a;\n\tfinal = max(final, 0.5-p.y);\n\tfinal = min(final, length(p.xz) - 0.5);\t// oculus - cylinder in middle\n\treturn final/1.414;\n}\n\nfloat GemCut(vec3 p)\n{\n\tfloat size = 0.5;\n\tfloat f = length(p) - size;\n\tif (f <= 1.0)\n\t{\n\t\tmarchingMultplier = 0.65;\n\t\tf = max(f, p.y - size * 0.25);\n\t\t\n\t\tf = max(f, p.y + max(abs(p.x), abs(p.z)) - size * 0.7);\n\t\t\n\t\tf = max(f, -p.y + max(abs(p.x), abs(p.z)) - size * 0.6);\n\t\t//f = max(f, -p.y + p.x - size * 0.6);\n\t\t//f = max(f, -p.y - p.x - size * 0.6);\n\t\t//f = max(f, -p.y + p.z - size * 0.6);\n\t\t//f = max(f, -p.y - p.z - size * 0.6);\n\n\t\tf = max(f, p.y + abs(p.x) + abs(p.z) - size * 0.95);\n\t\t//f = max(f, p.y + p.x + p.z - size * 0.95);\n\t\t//f = max(f, p.y - p.x + p.z - size * 0.95);\n\t\t//f = max(f, p.y - p.x - p.z - size * 0.95);\n\t\t//f = max(f, p.y + p.x - p.z - size * 0.95);\n\n\t\tf = max(f, -p.y + abs(p.x) + abs(p.z) - size * 0.85);\n\t\t//f = max(f, -p.y + p.x + p.z - size * 0.85);\n\t\t//f = max(f, -p.y - p.x + p.z - size * 0.85);\n\t\t//f = max(f, -p.y - p.x - p.z - size * 0.85);\n\t\t//f = max(f, -p.y + p.x - p.z - size * 0.85);\n\t} else marchingMultplier = 1.0;\n\treturn f;\n}\n\nfloat GenSwirl(vec3 p, float anim)\n{\n\tvec2 spin = vec2(sin(p.y*1.75-anim), cos(p.y*1.75 - anim));\n\tfloat swirl = length(p.xz + spin*0.2) - 0.05;\n\tswirl = max(swirl, p.y - 5.25);\n\tswirl = max(swirl, p.y - fract(anim)*10.0 + 2.0);\n\tswirl = max(swirl, -(p.y - fract(anim)*10.0 + 5.0));\n\treturn swirl;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tglobalRadial = atan(p.x, p.z);\n\t// set up repeating spaces for pillars and arches\n\tvec3 c = vec3(1.0, 1.0, 1.0)* 4.0;\n\tfloat c2 = 5.2;\n\tvec3 q = mod(p,c)-0.5*c;\n\tfloat q2 = mod(p.x,c2)-0.5*c2;\n\tvec3 p2 = vec3(q.x, p.y, q.z);\n\tvec3 p3 = vec3(q2, p.y, p.z);\n\n\tfloat final = -sdCapsule(p, vec3(0.0,-0.5,0.0), vec3(0.0,2.25,0.0), 3.0);\n\t// This if condition is for a culling speedup and a cool bevel effect on the ceiling tiles.\n\tif (final < 0.01) final = max(final, -dTiles(p + vec3(0.0, -2.25, 0.0)));\n\tfinal = min(final, sdTorusBricks(p, vec2(2.75, 0.25), vec3(0.0, -0.795, 0.0), 12.0));\n\tfinal = max(final, -sdCapsule(p, vec3(-6.0,0.0,0.0), vec3(6.0,0.0,0.0), 2.0));\n\t//final = max(final, -sdCapsule(p, vec3(0.0,0.0,-16.0), vec3(0.0,0.0,16.0), 2.0));\n\tfinal = max(final, -dBoxSigned(p));\n\t//final = max(final, -sdCapsule(p, vec3(0.0,0.0,0.0), vec3(0.0,5.5,0.0), 0.5));//oculus\n\tfinal = max(final, p.y - 5.3);\t// open the sky\n\t//final = max(final, sdCapsule(p, vec3(0.0,-0.5,0.0), vec3(0.0,0.5,0.0), 3.05));\n\t//final = max(final, -dSphere(p2, 0.08));\n\tfinal = min(final, sdColumn(p2, vec3(0.0, 0.0, 0.25)));\n\t//final = max(final, -sdBox(p - vec3(0.0,0.5,0.0), vec3(0.5, 1.0, 3.5)));\n\n\tfinal = min(final, sdTorusBricks(p, vec2(2.75, 0.25), vec3(0.0, 2.7, 0.0), 8.0));\n\tfinal = min(final, sdTorusBricks(p, vec2(0.75, 0.25), vec3(0.0, -1.0, 0.0), 3.0));\n\tfinal = min(final, sdTorusArch(p3, vec2(2.125, 0.3), vec3(0.0, 0.1, 0.0), 12.0));\n\t//final = min(final, sdTorusArch(p, vec2(2.125, 0.3), vec3(2.6, -0.1, 0.0), 6.0));\n\t//final = min(final, sdTorusArch(p, vec2(2.125, 0.3), vec3(-2.6, -0.1, 0.0), 6.0));\n\tfinal = min(final, dFloor(p));\n\tmaterial = 0.0;\n\n\t// rotate the gem and light rays.\n\tvec3 pr = RotateY(p, rotateGem);\n\t// mirror light rays in each axis.\n\tif (pr.x < 0.0) pr.xz = -pr.xz;\n\tvec3 pr2 = pr;\n\tif (pr2.z < 0.0) pr2.xz = -pr2.xz;\n\t// glow rays\n\tif ((sparkle > 0.0) && (shadow != 1000000.0))\n\t{\n\t\tvec2 dir = vec2(1.0, 0.0);\n\t\tfloat rad = 0.04*max(0.0, sparkle - 0.2);\n\t\tfloat tempGlow = sdCapsule(pr, vec3(dir.x*0.25, 0.9 + sparkle, dir.y*0.25),\n\t\t\t\t\t\t\t   vec3(dir.x*3.0, 1.8 + sparkle, dir.y*3.0), rad)+saturate(0.6-sparkle);\n\t\tdir = vec2(0.0, 1.0);\n\t\ttempGlow = min(tempGlow, sdCapsule(pr2, vec3(dir.x*0.25, 0.9 + sparkle, dir.y*0.25),\n\t\t\t\t\t\t\t   vec3(dir.x*3.0, 1.8 + sparkle, dir.y*3.0), rad)+saturate(0.25-sparkle) );\n\t\t//dir = vec2(-1.0, 0.0);\n\t\t//tempGlow = min(tempGlow, sdCapsule(pr, vec3(dir.x*0.25, 0.9 + sparkle, dir.y*0.25),\n\t\t//\t\t\t\t\t   vec3(dir.x*2.65, 1.7 + sparkle, dir.y*2.65), rad)+saturate(0.8-sparkle));\n\t\t//dir = vec2(0.0, -1.0);\n\t\t//tempGlow = min(tempGlow, sdCapsule(pr, vec3(dir.x*0.25, 0.9 + sparkle, dir.y*0.25),\n\t\t//\t\t\t\t\t   vec3(dir.x*2.65, 1.7 + sparkle, dir.y*2.65), rad));\n\t\t//float len = length(p.xz)*0.5+0.5;\n\t\t//tempGlow = min(tempGlow, sdCapsule(pr, vec3(0.0, 1.0 + sparkle, 0.0),\n\t\t//\t\t\t\t\t   vec3(0.0, -12.7, 0.0), rad*2.0)+saturate(0.25-sparkle) );\n\t\t// vertical glow from the pedestal to the crystal. capped cylinder.\n\t\ttempGlow = min(tempGlow, max(length(p.xz) - rad*2.0, p.y - 0.6 - sparkle));\n\t\tglowDist += 1.5*sparkle / max(0.1, tempGlow*tempGlow);\n\t\tfinal = matMin(final, tempGlow, 3.0);\n\t}\n\tfloat spirits = max(0.0, sinking - 7.0);\n\tfloat tempGlow2 = length(p.xyz - vec3(0.0,-0.95,0.0)) - 0.015 - pow(spirits, 1.5)*0.1;\n\tif ((spirits > 0.0) && (shadow != 1000000.0))\n\t{\n\t\tfloat anim = spirits - 2.0;\n\t\tfloat swirl = GenSwirl(p, anim);\n\t\tswirl = min(swirl, GenSwirl(p, anim+1.4));\n\t\tswirl = min(swirl, GenSwirl(p, anim+2.8));\n\t\tswirl = min(swirl, GenSwirl(p, anim+4.6));\n\t\tswirl = max(swirl, p.y-anim*3.0);\n\t\ttempGlow2 = smin(tempGlow2, swirl, -4.0);\n\t\tfinal = matMin(final, swirl, 3.0);\n\n\t\tglowDist += 1.5*sinking*0.1 / max(0.1, tempGlow2 * tempGlow2);\n\t\tglowDist *= min(1.0, spirits);\n\t\tfinal = matMin(final, tempGlow2, 3.0);\n\t}\n\n\tfinal = matMin(final, sdPedestal(p, vec2(0.25, 1.0)), 2.0);\t// pedestal\n\n\tfinal = matMin(final, GemCut(pr - vec3(0, 0.8 + sparkle - sinking*0.2, 0)), 1.0);\t// Gem\n\n\treturn final;\n}\n\nvec4 tex3d(vec3 pos, vec3 normal)\n{\n\t// loook up brick texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel0, pos.yz);\n\tvec4 texY = texture(iChannel0, pos.xz);\n\tvec4 texZ = texture(iChannel0, pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\treturn tex;\n}\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tlocalTime = fract((iTime)/54.0)*54.0;//mod(iTime+30.0, 55.0);\t// repeat anim after this many seconds.\n\tsinking = localTime - 30.0;//clamp(localTime - 30.0, 0.0, 16.5);\t// start and end the sinking of the pedestal\n\tif (sinking < 0.0) sinking = 0.0;// mac/chrome/nvidia bug didn't let me use max. :(\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\tvec3 shake = texture(iChannel3, vec2(localTime * 1.372, 0.0)).xyz*0.04 * saturate(sinking);\n\t// Camera lookat.\n#if MANUAL_CAMERA\n\tvec3 camLookat=vec3(0,1.0,0);\t// vrp\n\tvec3 camPos=vec3(2.7, 2.7, 2.7);\n\n\tif (localTime < 5.0)\n\t{\n\t\t//camLookat.y = mix(3.0, 1.0, saturate(localTime*0.2));\n\t\t//camPos.x = smoothstep(0.0, 2.75, saturate(localTime*0.2));\n\t}\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*camPos; \t// prp\n#else\n\tvec3 camLookat=vec3(0,1.0,0);\t// vrp\n\tvec3 camPos=vec3(0.0, 0.0, 0.0);\n\tfloat firstTimer = saturate(localTime * 0.09);\n\tcamPos.x = SmoothMix(-3.5, 2.6, firstTimer);\n\tcamPos.z = pow(abs(sin(firstTimer*PI)), 3.0)*2.0;\n\tcamPos.z -= firstTimer;\n\n#endif\n\n\tcamLookat += shake;\n\tcamPos += shake;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// -------------------------- Animate some things -----------------------------\n\tfloat sunSpeed = 0.045;\n\tvec3 sunDir;// = normalize(vec3(sin(iTime*sunSpeed), -3.0, sin(iTime*sunSpeed)));\n\tsunDir = normalize(vec3(localTime*sunSpeed - 0.95, -3.0, localTime*sunSpeed - 0.95));\n\t//sparkle = saturate((1.0 - abs(sin(iTime*sunSpeed))) - 0.8) * 5.0;\n\tsparkle = min(1.0, saturate(-sunDir.y - 0.988) * 200.0);\n\tsparkle = smoothstep(0.0, 1.0, sparkle);\n\tfloat sparkleLasting = max(sparkle, saturate(localTime - 20.0));\n\tglowDist = 0.0;\n\tsunCol = min(sunColOrig, (sunColOrig * 0.00025)*pow(2.5, localTime));\n\trotateGem = SmoothMix(0.0, 3.0*PI, saturate((localTime - 14.0)/15.0));\n\n\t// ------------------------------ Ray march -----------------------------------\n\tfloat dist = 0.02;\n\tfloat t = 0.1;\n\tfloat maxDepth = 40.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n\tfor (int i = 0; i < 120; i++)\n\t{\n\t\tif ((t > maxDepth) || (abs(dist) < 0.001))\n\t\t{\n\t\t\tbreak;\t// break doesn't work on some machines\n\t\t\tcontinue;\t// so do a continue for those\n\t\t}\n\t\tpos = camPos + relVec * t;\n\t\tdist = DistanceToObject(pos);\n\t\tt += dist * marchingMultplier;\t// because deformations mess up distance function.\n\t}\n\tfloat finalMaterial = material;\n\tmarchingMultplier = 1.0;\n\n\t// ----------------------------------------------------------------------------\n\n\t// oculus is the word for the hole in the roof of the dome.\n\tvec3 oculus = vec3(0.0, 5.3, 0.0);\n\tvec3 floorHit = (oculus) + sunDir * 6.3 / abs(sunDir.y);\n\n\tvec3 cr = normalize(cross(-sunDir, relVec));\n\tfloat d1 = dot(oculus, cr);\n\tfloat d2 = dot(pos, cr);\n\tfloat haze = pow(saturate(1.0 - abs(d1 - d2) * 2.0), 0.6);\n\n\tvec3 finalColor = vec3(1.0,1.0,1.0);// GetSunColorReflection(relVec, -sunDir) + vec3(0.1, 0.1, 0.1);\n\n\t// calculate normal from distance field\n\tvec3 smallVec = vec3(0.005, 0, 0);\n\tvec3 dx = pos - smallVec.xyy;\n\tvec3 dy = pos - smallVec.yxy;\n\tvec3 dz = pos - smallVec.yyx;\n\tvec3 normal = vec3(dist - DistanceToObject(dx),\n\t\t\t\t\t   dist - DistanceToObject(dy),\n\t\t\t\t\t   dist - DistanceToObject(dz));\n\tnormal = normalize(normal);\n\t\n\t// -------------------------- Shadow trace to oculus --------------------------\n\tfloat origGlowDist = glowDist;\n\tshadow = 1000000.0;\n\t//for (int i = 1; i < 8; i++)\n\t//{\n\t//\tvec3 midPos = mix(pos, oculus, float(i) / 64.0);\n\t//\tfloat shadow0 = max(0.0, DistanceToObject(midPos));\n\t//\tshadow = min(shadow, shadow0);\n\t//}\n#if TRACED_SKY_SHADOWS\n\tfloat dist2 = 0.02;\n\tfloat t2 = 0.1;\n\tfloat maxDepth2 = 40.0;\n\tvec3 pos2 = vec3(0,0,0);\n\t// ray marching time\n\tfloat mCount = 0.0;\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\tif ((t2 > maxDepth2) || (abs(dist2) < 0.001)) continue;\t// break DOESN'T WORK!!! ARRRGGG!\n\t\tpos2 = (pos + normal*0.02) + normalize(oculus - pos) * t2;\n\t\tdist2 = DistanceToObject(pos2);\n\t\tt2 += dist2 * marchingMultplier;\t// because deformations mess up distance function.\n\t\tmCount++;\n\t}\n\tif (dist2 < 0.01) shadow = 0.0;\n\tshadow = saturate(shadow * 300.9);\n#else\n\t// fake the shadows\n\tfloat xzDist = length(pos.xz);\n\tshadow = (abs(xzDist - 3.0))*5.0;\n\tshadow += pow(saturate(-(pos.y - 2.5)), 3.0);\n\tshadow += saturate((pos.y - 2.5)*8.0);\n\tshadow *= 1.0 - saturate(xzDist - 2.995);\n\tshadow = saturate(shadow);\n\n#endif\n\n//\tfloat shadow0 = max(0.0, DistanceToObject(mix(oculus, pos, 0.333)));\n//\tfloat shadow1 = max(0.0, DistanceToObject(mix(oculus, pos, 0.666)));\n//\tshadow0 = min(shadow0, shadow1);\n\tglowDist = origGlowDist;\n\t// ----------------------------------------------------------------------------\n\n\t// calculate ambient occlusion with 2 extra distance field queries\n\tfloat ambient = DistanceToObject(pos + normal * 1.0)*0.5;\n\tambient += DistanceToObject(pos + normal * 0.1)*5.0;\n\tambient = max(0.1, pow(abs(ambient), 0.5));\t// tone down ambient with a pow and min clamp it.\n\n\tvec3 tempPos = pos;\n\tif (finalMaterial == 2.0) tempPos.y = pos.y + sinking*0.2;\n\t// look up brick texture, blended across xyz axis based on normal.\n\tvec4 tex = tex3d(tempPos*0.75, normal);\n\t//tex = tex * tex;\t// gamma correct\n\ttex.xyz = pow(tex.xyz, vec3(1.35,1.35,1.35));\t// gamma correct sorta\n\n\t// weathering texture\n\tvec3 texSpots = texture(iChannel3, pos.xz*0.085* (1.0 + pos.y*0.02)).xyz;\n\ttexSpots = saturate(texSpots * 4.0 - 0.75);\n\t//if (pos.y < -0.999)\n\ttexSpots.y = min(1.0-abs(normal.y*0.75), texSpots.y);\t// only for vertical surfaces\n\ttex.xyz = mix(tex.xyz, vec3(0.3, 0.24, 0.25)*1.25-tex.xzy*0.45, texSpots.y);\n\t//tex.xyz = vec3(0.75, 0.75, 0.75);\n\n\t// Make the rune ring texture around the top ledge\n\tfloat radial = atan(pos.x, pos.z);\n\tradial /= 2.0*PI;\n\tvec2 runeUV = vec2(radial * 16.0, pos.y + 0.14) * 3.0;\n\tif (finalMaterial == 2.0)\n\t{\n\t\truneUV = vec2(radial * 4.0, pos.y + 0.395 + sinking*0.2) * 9.0;\n\t}\n\tvec2 runeSeed = floor(runeUV)*vec2(1.0, 6.0);\n\truneUV = fract(runeUV) + (tex.xy - 0.4)*0.25;\n\n\t// closing credit text\n\tif (localTime > 46.5)\n\t{\n\t\tfloat fu = floor((uv.x*0.5+0.5)*8.0);\n\t\tvec2 seed = vec2(15.0, 2.0);\n\t\tif (fu == 1.0) seed = vec2(-5,-5);\n\t\tif (fu == 2.0) seed = vec2(34,4);\n\t\tif (fu == 4.0) seed = vec2(19,5);\n\t\tif (fu == 5.0) seed = vec2(51,4);\n\t\tif (fu == 6.0) seed = vec2(66,-2);\n\t\tif (fu == 7.0) seed = vec2(-8,6);\n\t\tvec2 shift = uv + vec2(0.0, 0.125);\n\t\truneUV = fract(shift*4.0);\n\t\truneSeed = seed;\n\t}\n\n\t// Generate a rune based on a random seed.\n\t// GLSL unrolls function calls, so try really hard to only call this once. :(\n\tvec3 runeCol = Rune(runeUV, runeSeed);\n\t// If it is the base of the dome, do the runes for that.\n\tif (floor((pos.y + 0.14)*3.0) == 8.0)\n\t{\n\t\ttex.xyz *= (1.0 - pow(runeCol.x, 0.95)*0.65);\n\t\tnormal.y -= runeCol.z*100.0;\n\t}\n\telse\n\t{\n\t\tif ((finalMaterial != 2.0) && (localTime <= 46.5)) runeCol = vec3(0.0, 0.0, 0.0);\n\t}\n\n\t// materials\n\tnormal.y += (tex.z - 0.23)*2.0;\t// fake bump map\n\tnormal = normalize(normal);\n\tvec3 ref = reflect(relVec, normal);\n\n\t// Gem material\n\tif (finalMaterial == 1.0)\n\t{\n\t\t//vec3 refraction = normalize(mix(-ref, relVec, 0.5));\n\t\ttex.xyz = pow(texture(iChannel2, ref).xyz, vec3(2.0,2.0,2.0)) * vec3(0.9, 0.1, 0.5);\n\t\t//tex.xyz += pow(texture(iChannel2, ref).xyz, vec3(2.0,2.0,2.0)) * vec3(0.9, 0.1, 0.5);\n\t}\n\t// pedestal material\n\telse if (finalMaterial == 2.0)\n\t{\n\t\t//float radial = atan(pos.x, pos.z);\n\t\t//radial /= 2.0*PI;\n\t\t//runeUV = vec2(radial * 4.0, pos.y + 0.405 + sinking*0.2) * 9.0;\n\t\t//runeCol = vec3(0.0, 0.0, 0.0);\n\t\tif (abs(normal.y) < 0.99)\n\t\t{\n//\t\t\truneCol = Rune(fract(runeUV) + (tex.xy - 0.4)*0.25, floor(runeUV)*vec2(1.0, 6.0));\n\t\t\t//runeCol.x = pow(runeCol.x, 2.0);\n\t\t\ttex.xyz *= (1.0 - pow(runeCol.x, 0.55)*0.85);// * (1.0+saturate(-runeCol.z)*18.0);\n\t\t\t//tex.xyz *= saturate(1.0 - vec3(0.997, 0.92, 0.997)*runeCol.x*0.8);//*0.3;\n\t\t\tnormal.y -= runeCol.z*52.0;\n\t\t\tnormal = normalize(normal);\n\t\t\ttex.xyz += sunCol*4.0*runeCol.x * max(0.0,sparkleLasting-0.6)*2.0;\n\t\t}\n\t}\n\t// glow ray material\n\telse if (finalMaterial == 3.0)\n\t{\n\t\ttex.xyz = sunCol*8.0;\n\t}\n\n\t// try to fake stained glass windows on the interior of the dome.\n\tfloat domeAlpha = 0.0;\n\tif (pos.y > 2.95)\n\t{\n\t\tdomeAlpha = length(pos - vec3(0.0, 2.25, 0.0)) - 3.05;\n\t\tdomeAlpha *= 12.0;\n\t\tdomeAlpha = saturate(domeAlpha);\n\t\t//tex *= alpha;// mix(tex, tex*texture(iChannel1, pos.xz*0.75).xxxw, 0.5);\n\t\tvec3 t2 = texture(iChannel1, pos.xz*0.75).yzx;\n\t\tvec3 t3 = texture(iChannel1, pos.xz*0.5).yzz;\n\t\tt2 = t2*t2;\n\t\tt3 = t3*t3;\n\t\tt2 = saturate(t2*1.0 - 0.05) * vec3(12.0,1.0,6.0);\n\t\tt3 = saturate(t3*1.5 - 0.05) * vec3(0.0,2.0,2.0);\n\t\ttex.xyz = mix(tex.xyz, (t2 + t3), domeAlpha);\n\t}\n\t// glowing hole in the ground\n\tif (pos.y < -0.99)\n\t{\n\t\tif (length(pos.xz) < 0.5) tex.xyz = sunCol*1.5;\n\t}\n\t//tex.xyz = vec3(0.75, 0.75, 0.75);\n\n\t// if ray marching found an intersection, then calculate lighting and stuff\n\tif (t <= maxDepth)\n\t{\n\t\tvec3 lightDir = pos - oculus;\n\t\tfloat lenLightDir = length(lightDir);\n\t\tfloat skyMult = max(0.0, -lightDir.y) * max(0.0, dot(-lightDir, normal));\n\t\tskyMult *= 0.55 / (lenLightDir*lenLightDir);\n\t\tvec3 envLight = environmentSphereColor;// * skyMult;// + environmentGroundColor * (normal.y * 0.5 + 0.5);\n\t\t//vec3 envLight = mix(environmentGroundColor, environmentSphereColor, (normal.y * 0.5 + 0.5)) * 0.9;\n\t\tenvLight *= shadow * skyMult;\n\t\tenvLight += environmentSphereColor * 0.045;\t// ambient is lame, but better than black.\n\t\tvec3 domeLight = vec3(1.0, 0.1, 0.5) * (normal.y * 0.5 + 0.5) * min(ambient, shadow) * 0.15;\n\n\t\tfloat d1 = dot(sunDir, pos);\n\t\tfloat d2 = dot(sunDir, oculus);\n\t\tfloat d3 = dot(sunDir, camPos);\n\t\tvec3 flatPos = pos - sunDir * d1;\n\t\tvec3 flatOculus = oculus - sunDir * d2;\n\t\tvec3 flatCam = camPos - sunDir * d3;\n\t\tfloat sunShadow = pow(saturate(0.5 - distance(flatPos, flatOculus)), 0.2);\n\t\tvec3 sunDirect = max(0.0, dot(-sunDir, normal)) * sunCol * sunShadow * 40.0;\n\t\tvec3 sunIndirect;// = 0.25*pow(saturate((3.5-distance(flatPos, flatOculus))), 2.0) * sunCol * 0.31;\n\t\tvec3 indirectDir = pos - floorHit;\n\t\tfloat indirectLen = length(indirectDir);\n\t\tindirectDir = normalize(indirectDir);\n\t\tsunIndirect = sunCol * (dot(-indirectDir, normal)*0.5+0.54) * 2.5 / pow(indirectLen, 1.75)*sunCol.x;\n\t\tfinalColor = (envLight + sunIndirect + domeLight) * tex.xyz;\n\t\tfinalColor *= vec3(1.0,1.0,1.0) * ambient;\n\t\tfinalColor += (sunDirect) * tex.xyz;// * ambient;\n\t\tfinalColor += max(vec3(0.0,0.0,0.0),\n\t\t\t\t\t\t  GetSunColorReflection(ref, normalize(-indirectDir))*0.5*tex.x*domeAlpha-0.25);\n\t\tfinalColor += sunCol * runeCol.x * 1.5 * max(0.0,sparkleLasting-0.6)*2.0;\n\t\t//finalColor = domeLight * min(ambient, shadow);\n\t\tfinalColor = mix(finalColor, vec3(0.015,0.015,0.015), pow(saturate(distance(pos, camPos)*0.075), 0.7) );\n\t\t//finalColor = vec3(1.0,1.0,1.0) * distance(pos, floorHit)*0.1;\n\t\t//finalColor = vec3(1.0,1.0,1.0) * distance(floorHit, pos)*0.01;// skyMult * shadow;\n\t\tif (distance(flatPos, flatCam) > distance(flatOculus, flatCam))\n\t\t{\n\t\t\tfloat ratioA = distance(flatOculus, flatCam) / distance(flatPos, flatCam);\n\t\t\tvec3 hazePos = mix(camPos, pos, ratioA);\n\t\t\tvec3 hazeNoise = texture(iChannel3, (hazePos.xz + vec2(0.0, -iTime* 0.125))* 0.03).xyz;\n\t\t\thaze = haze * hazeNoise.x;\n\t\t\tfinalColor += (sunCol + vec3(1.0, 1.0, 1.0)) * haze * 0.15 * sunCol.x;\n\t\t}\n\t\tfinalColor += sunCol * glowDist*0.001;\n\t\t//finalColor = vec3(1.0,1.0,1.0)*shadow*0.25;\n\t\t//finalColor = vec3(1.0,1.0,1.0)*mCount*0.005;\n\t\t//finalColor = vec3(saturate(tex.y-0.35), saturate(-(tex.y-0.35)), 0.0);\n\t}\n\n\t// closing credit text\n\tif (localTime > 46.5)\n\t{\n\t\tfloat creditsTimer = saturate((localTime - 47.0)*0.5);\n\t\t//finalColor = saturate(vec3(1.0,1.0,1.0)*0.25-creditsTimer);\n\t\tfinalColor = vec3(1.0,1.0,1.0)*0.25;\n\t\tvec2 shift = uv + vec2(0.0, 0.125);\n\t\t//runeCol = Rune(fract(shift*4.0), vec2(seed, seed))*creditsTimer;\n\t\truneCol *= creditsTimer;\n\t\tif (floor(shift.y*4.0) == 0.0)\n\t\t{\n\t\t\tfinalColor = mix(finalColor, vec3(0.25, 0.025, 0.01), pow(runeCol.x, 0.75));\n\t\t\tfinalColor += runeCol.z*2.0;\n\t\t}\n\t\t//finalColor = Rune(fract(uv*8.0), floor(uv*8.0*1.0+vec2(64.0, 0.0)*1.0)).xxx;\n\t\t//finalColor = Rune(fract(uv*8.0), floor(vec2(66.0, -2.0)*1.0)).xxx;\n\t\t// S - (-1, -7) :( (15, 2)\n\t\t// O - (5,-1) (-5, -5)\n\t\t// L - (34, 4)\n\t\t// S\n\t\t// T - (5,2) :( (19, 5)\n\t\t// I - (51, 4)\n\t\t// C - (66,-2)\n\t\t// E - (-8.0, 6.0)\n\t\t// N - (0, 4)\n\t\t// U - (-3, 0)\n\t\t// R -\n\t}\n\n\tfragColor = vec4(sqrt(clamp(finalColor*4.0, 0.0, 1.0)),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}