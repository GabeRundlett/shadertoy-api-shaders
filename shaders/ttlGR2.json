{
    "Shader": {
        "info": {
            "date": "1558123712",
            "description": "reminisce ",
            "flags": 96,
            "hasliked": 0,
            "id": "ttlGR2",
            "likes": 22,
            "name": "Feedback Scope",
            "published": 3,
            "tags": [
                "oscilloscope",
                "music",
                "distortion",
                "audio",
                "crt",
                "feedback",
                "jungle",
                "buffers"
            ],
            "usePreview": 0,
            "username": "granito",
            "viewed": 992
        },
        "renderpass": [
            {
                "code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nlowp vec3 ACESFilm( vec3 x )\n{\n    x *= 0.01; \n    lowp float a = 2.51;\n    lowp float b = 0.03;\n    lowp float c = 2.43;\n    lowp float d = 0.59;\n    lowp float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\nvec2 rot2D(vec2 p, float angle) {\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    return p * mat2(c,s,-s,c);    \n}\n\n// Below -> Forked Slightly modified -> https://www.shadertoy.com/view/XsjSzR\n\n// Emulated input resolution.\n\n// Fix resolution to set amount.\n#define res (vec2(180.0/1.0,120.0/1.0))\n\n// Hardness of scanline.\n//  -8.0 = soft\n// -16.0 = medium\nfloat hardScan=-8.0;\n\n// Hardness of pixels in scanline.\n// -2.0 = soft\n// -4.0 = hard\nfloat hardPix=-1.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0/8.0 = extreme\nvec2 warp=vec2(1.0/32.0,2.0/24.0); \n\n// Amount of shadow mask.\nfloat maskDark=6.;\nfloat maskLight=4.;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToLinear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nvec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToSrgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec3 Fetch(vec2 pos,vec2 off){\n  pos=floor(pos*res+off)/res;\n  if(max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5)return vec3(0.0,0.0,0.0);\n  return ToLinear(texture(iChannel0,pos.xy,-16.0).rgb);}\n\n// Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos){pos=pos*res;return -((pos-floor(pos))-vec2(0.5));}\n    \n// 1D Gaussian.\nfloat Gaus(float pos,float scale){return exp2(scale*pos*pos);}\n\n// 3-tap Gaussian filter along horz line.\nvec3 Horz3(vec2 pos,float off){\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  float dst=Dist(pos).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  // Return filtered sample.\n  return (b*wb+c*wc+d*wd)/(wb+wc+wd);}\n\n// 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 pos,float off){\n  vec3 a=Fetch(pos,vec2(-2.0,off));\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  vec3 e=Fetch(pos,vec2( 2.0,off));\n  float dst=Dist(pos).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wa=Gaus(dst-2.0,scale);\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  float we=Gaus(dst+2.0,scale);\n  // Return filtered sample.\n  return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);}\n\n// Return scanline weight.\nfloat Scan(vec2 pos,float off){\n  float dst=Dist(pos).y;\n  return Gaus(dst+off,hardScan);}\n\n// Allow nearest three lines to effect pixel.\nvec3 Tri(vec2 pos){\n  vec3 a=Horz3(pos,-1.0);\n  vec3 b=Horz5(pos, 0.0);\n  vec3 c=Horz3(pos, 1.0);\n  float wa=Scan(pos,-1.0);\n  float wb=Scan(pos, 0.0);\n  float wc=Scan(pos, 1.0);\n  return a*wa+b*wb+c*wc;}\n\n// Distortion of scanlines, and end of screen alpha.\nvec2 Warp(vec2 pos){\n  pos=pos*2.0-1.0;    \n  pos*=vec2(1.0+(pos.y*pos.y)*warp.x,1.0+(pos.x*pos.x)*warp.y);\n  return pos*0.5+0.5;}\n\n// Shadow mask.\nvec3 Mask(vec2 pos){\n  pos.x+=pos.y*3.0;\n  vec3 mask=vec3(maskDark,maskDark,maskDark);\n  pos.x=fract(pos.x/6.0);\n  if(pos.x<0.333)mask.r=maskLight;\n  else if(pos.x<0.666)mask.g=maskLight;\n  else mask.b=maskLight;\n  return mask;}    \n\n// Draw dividing bars.\nfloat Bar(float pos,float bar){pos-=bar;return pos*pos<4.0?0.0:1.0;}\n\n// Entry.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // Unmodified.\n\n  vec2 pos=Warp(fragCoord.xy/iResolution.xy);\n    \n  fragColor.rgb=Tri(pos)*Mask(fragCoord.xy);   \n    \n  float sound = 1.+ pow(1.- texture(iChannel0,vec2(0.5)).w, 4.) *4.;\n  vec3 color = hsv2rgb( vec3(0.25,sound*0.8-0.6,0.5) );    \n\n    //////////////////////////////////need to mask edges and distort reflection\n    // vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    // vec2 m = vec2(0.1,0.0);\n    // vec3 dir = vec3(uv, 1.);\n    // dir.yz = rot2D(dir.yz,  90. * m.y);\n    // dir.xz = rot2D(dir.xz, 180. * m.x);\n    // float maskedge =dot(vec3(pos,1.),vec3(0.,0.,-1.));\n\t// fragColor.rgb += pow(texture(iChannel1, dir).xyz,vec3(3.)) * 3.;\n    /////////////////////////////////\n\n  //out    \n  fragColor.rgb = ACESFilm( fragColor.rgb * 200. * sound * color);\n  vec3 luma = vec3(dot(fragColor.rgb, vec3(0.3,0.6,0.1)));\n  fragColor.rgb = max( mix(luma, fragColor.rgb, vec3(0.5)+luma), vec3(0.));  //saturation adjustments\n  fragColor.rgb *= fragColor.rgb;\n  fragColor.a=1.0;    \n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 ditherpattern(vec2 uv)\n{\n    vec3 d = texture(iChannel2, uv,0.0).xyz;\n    d.x = fract(iTime + d.x);\n    d.y = fract(iTime + d.y + .33);\n    d.z = fract(iTime + d.z + .66);\n\treturn d;\n}\n\nfloat saturate(float x)\n{\n    return clamp(0.,1.,x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 dither = ditherpattern(uv).xy;// + vec2(fract(iTime))).xy;\n    \n    vec2 trimuv = uv;// * vec2(0.1,1.) + vec2(0.4,0.);\n    \n    trimuv.y = 1.;\n    \n    float apixel = 1. / iResolution.y;\n    \n    //float mask = round(uv.x-(0.5-apixel));\n    \n    vec4 sound = texture(iChannel0,trimuv);\n\tfloat volume = saturate(abs((  texture(iChannel0,vec2(0.5,1.0)).x   - .5)*2.));\n    volume = smoothstep(0.,1.,volume);\n    volume = pow(volume,.05);\n    \n    vec2 uvxform = ((uv - vec2(0.5)) * vec2(1. - 0.2 *volume)) + vec2(0.5);\n    \n    uvxform += (dither-0.5) * 0.1 * volume;\n    \n    vec4 buffersound = texture(iChannel1, uvxform );\n    \n\n    fragColor = vec4(1. - round(uv.y - sound.x + 0.5));\n    fragColor -= vec4(1. - round(uv.y - sound.x + 0.5 + 0.01));\n    fragColor += buffersound * volume * 1.08;\n\nfragColor.w = sound.x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 23840,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/devi-ka-1/blegrami-vaptisma-sonic-resistance-a-compilation-for-rojava"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 bufAuv = vec2(uv.x,0.);\n    \n    vec4 bufA = texture(iChannel0,bufAuv);\n    \n    float timespan = iTimeDelta * iResolution.x;\n    float bpm = fract(iTime / 60.);\n    \n    float sound = 1.- texture(iChannel0,vec2(0.5)).w;\n\n    \n    vec4 waveform;\n    \n    waveform.x = texture(iChannel1, uv + vec2(0.0,(sound-0.5)*0.04) ).x; \n    waveform.y = texture(iChannel1, uv + vec2(0.0,(sound-0.5)*-0.04) ).x;     \n    waveform.z = texture(iChannel1, uv + vec2((sound-0.5)*0.04 ,0.0   ) ).x;     \n    \n    waveform.xyz = max(texture(iChannel0, uv).xxx, waveform.xyz * 0.66);\n    \n    fragColor = vec4(waveform);\n    \n    fragColor.w = bufA.w;\n    \n    \n    \n    \n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.xy;    \nvec2 bufBuv = vec2(uv.x,0.);    \nvec4 bufB = texture(iChannel0,bufBuv);    \nbufB.xyz = texture(iChannel0,uv).xyz;    \n    \nfloat f,z,z0;\nconst float n = 40.;\n\nvec2 xy0 = iResolution.xy/4.;\nfloat time = iTime*0.25;\nfloat h = iResolution.x/10.;\nfloat r0 = iResolution.x/6.;\t// Step of waves\nfloat r1 = iResolution.x/6.5;\t// Height of waves\nfloat phi = 35.;\n\nphi=     texture(iChannel0,vec2(0.5)).w * 8.;\nfloat pi = 3.14159265 ;//*     texture(iChannel0,vec2(0.5)).w;\nfloat p180 = pi / 180.;//*     texture(iChannel0,vec2(0.5)).w;\n\nfloat sf = sin(phi * p180);\nfloat cf = cos(phi * p180);\n\nmat2 trot = mat2(cos(time),sin(time),-sin(time),cos(time));\n\nvec2 xy = vec2(0.);\nvec2 r = vec2(0.);\nvec3 col = vec3(0.);\n\nxy.x = fragCoord.x - xy0.x;  \t\n\nz0 = -10000.;\n\nfor(float j=0.; j<=n; j++)\n  {\n  xy.y = abs(xy.x) - n * h + 2. * h * j;\n  for(int i=0; i<=1; i++)\n\t{\n\tr = xy * trot;\n\tr.y += sign(r.x) * r0;\n\tf = cos(pi * length(r) / r0);\n\n\tz = xy.y * sf + f * r1 * cf;\n\tif(z > z0)\n\t\t{\n\t\tif( abs(xy0.y+z-fragCoord.y) < 2.-.5*abs(f) )\n\t\tcol = smoothstep(.33, .66, abs(mod(vec3(f+.33,f-.33,f+1.),2.)-1.));\n\t\tz0 = z + 1.;\n\t\t}\n\txy.y += mod(n * h - abs(xy.x), h) * 2.;\t\n\t}\n  if(j > n - abs(xy.x) / h) break;\n  }\nfloat sound = smoothstep(0.,1., bufB.w*1.25);\nfragColor.xyz = mix(col,bufB.xyz,sound);\n//fragColor.xyz = bufB.xyz;\n    \nfragColor.w = bufB.w;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}