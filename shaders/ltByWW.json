{
    "Shader": {
        "info": {
            "date": "1508525422",
            "description": "I stumbled upon this when doing something completely different (weighing and normalizing sound volumes on a \"mix field\"). Invertible smooth interpolation. With p = 2 value is very close to smootherstep (overlaid in blue). Mouse x controls p.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltByWW",
            "likes": 26,
            "name": "Invertible smootherstep",
            "published": 3,
            "tags": [
                "graph",
                "inverse",
                "ramp",
                "step",
                "interpolate",
                "smootherstep",
                "sstep"
            ],
            "usePreview": 0,
            "username": "grinist",
            "viewed": 1683
        },
        "renderpass": [
            {
                "code": "// Invertible smooth interpolation.\n// sstep2 has value very close to smootherstep.\n\n// sstep with power p, inverse is the same function with p inverted.\n// p < 1: seat, p > 1: sigmoid, p = 1: lerp\nfloat sstep(float x, float p)\n{\n\tx = clamp(x, 0.0, 1.0);\n\tfloat ix = 1.0 - x;\n    x = pow(x, p);\n    ix = pow(ix, p);\n    return x / (x + ix);\n}\n\n// sstep with p = 2, separate inverse.\nfloat sstep2(float x)\n{\n\tx = clamp(x, 0.0, 1.0); // optional\n    return x * x / ((2.0 * x * (x - 1.0)) + 1.0);\n}\n\n// Inverse of sstep2\nfloat inv_sstep2(float x)\n{\n\tx = clamp(x, 0.0, 1.0);\n    return (x - sqrt(x * (1.0 - x))) / (2.0 * x - 1.0);\n}\n\n// Original smootherstep\nfloat smootherstep(float x)\n{\n\tx = clamp(x, 0.0, 1.0); // optional\n\treturn x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setupGraph(vec2(0.5), vec2(1.2), fragCoord, iResolution);\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    // translate x coordinate to an exponent between 0.1 and 10\n\tfloat p = pow(10.0, (-0.5 + mouse.x) * 2.0);\n    \n    // background\n\tfcol = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.8, 0.8, 0.8, 1.0), sqrlength(xy - graphCenter) / sqrlength(graphSize * 0.5));\n    \n\t// grid\n    drawGrid(0.1, px, vec4(0.0, 0.0, 0.0, 0.125));\n\tdrawGrid(0.5, px, vec4(0.0, 0.0, 0.0, 0.25));\n\tdrawGrid(1.0, px, vec4(0.0, 0.0, 0.0, 0.5));\n    \n    // curves\n    float r = 2.0 * px;\n    if (iMouse.z > 0.0)\n    {\n    \t// mask curve drawing in y, since verticals x = 0 and x = 1 would be drawn with inverse functions\n\t    float mask = lerpstep(-r - aa, -r + aa, xy.y) - lerpstep(1.0 + r - aa, 1.0 + r + aa, xy.y);\n        drawFuncWithInverse(sstep(xy.x, p), sstep(xy.y, 1.0 / p), r, vec4(0.91, 0.13, 0.23, mask));\n        drawFuncWithInverse(sstep(xy.x, 1.0 / p), sstep(xy.y, p), r, vec4(0.91, 0.13, 0.23, 0.25 * mask));\n    }\n    else\n    {\n\t    drawFunc(sstep2(xy.x), r, vec4(0.91, 0.13, 0.23, 1.0));\n\t    drawFunc(inv_sstep2(xy.x), r, vec4(0.91, 0.13, 0.23, 0.25));\n    \tdrawFunc(smootherstep(xy.x), r, vec4(0.15, 0.45, 0.85, 0.5));\n    }\n\n\tfragColor = fcol;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 graphSize;\nvec2 graphCenter;\nvec2 graphPos; // bottom left\n\nvec2 xy;\t// current graph coords\nfloat px;\t// pixel size in graph units, assumes uniform graph\nfloat aa;\t// aa falloff radius\nvec4 fcol;\t// current fragment color\n\nfloat lerpstep(float a, float b, float x)\n{\n    return (a == b) ? step(x, a) : clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nfloat sqrlength(vec2 v)\n{\n    return dot(v, v);\n}\n\nvoid mixColor(vec4 col, float alpha)\n{\n    fcol = vec4(mix(fcol.rgb, col.rgb, alpha * col.a), 1.0);\n}\n\nvoid drawGrid(float stepSize, float r, vec4 col)\n{\n\tvec2 grid = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) / stepSize));\n    float d = min(grid.x, grid.y) * stepSize;\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\nvoid drawCircle(vec2 pos, float r, vec4 col)\n{\n    float d = length(pos - xy);\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\n// Draws an explicit function of x with a known derivative.\n// Uses y distance to curve, breaks with great derivatives and discontinuities.\nvoid drawFunc(float y, float dy, float r, vec4 col)\n{\n    float d = abs(y - xy.y);\n    float yspan = sqrt(1.0 + dy * dy); // accurate, decent approximate: abs(dy) + 1.0 / (abs(dy) + 1.0)\n\tmixColor(col, lerpstep(yspan * (r + aa), yspan * (r - aa), d));\n}\n\n// Draws an explicit function of x, uses screen space derivative.\nvoid drawFunc(float y, float r, vec4 col)\n{\n    drawFunc(y, dFdx(y) / px, r, col);\n}\n\n// Draws an explicit function of x with a known inverse.\n// Uses distance to curve in both y and x.\nvoid drawFuncWithInverse(float y, float x, float r, vec4 col)\n{\n    vec2 d = abs(vec2(xy.x - x, xy.y - y));\n    mixColor(col, lerpstep(r + aa, r - aa, max(d.x, d.y) / length(d) * min(d.x, d.y)));\n}\n\nvoid setupGraph(vec2 center, vec2 size, vec2 fragcoord, vec3 resolution)\n{\n    graphSize = size * (resolution.xy / resolution.y);\n    graphCenter = center;\n    graphPos = graphCenter - 0.5 * graphSize;\n    xy = graphPos + fragcoord / resolution.xy * graphSize;\n\tpx = graphSize.y / resolution.y;\n    aa = 0.5 * px;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}