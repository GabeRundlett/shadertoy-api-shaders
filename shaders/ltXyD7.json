{
    "Shader": {
        "info": {
            "date": "1586285596",
            "description": "Continuing experiments with my pixel zoom code to make cool endless zooming fractals.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltXyD7",
            "likes": 8,
            "name": "Geode",
            "published": 3,
            "tags": [
                "fractal",
                "zoom",
                "recursion"
            ],
            "usePreview": 0,
            "username": "KilledByAPixel",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////\n// Eye of God Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 10.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.00001;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 8;\t// how deep to recurse\nconst int glyphSize\t\t\t\t= 3;\t// width & height of glyph in pixels\nconst float curvature\t\t\t= -16.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize);\nconst float glyphSizeLog = log(glyphSizeF);\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    i = (i+r) + (glyphPosLast.y + glyphPos.y);\n\n    vec3 myColor = vec3\n    (\n    \tmix(-0.05, 0.05, RandFloat(i)),\n    \tmix(0.0, 0.2, RandFloat(i + 10)),\n        mix(0.0, 0.2, RandFloat(i + 20))\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    //myColor.y = pow(myColor.y, 2.0);\n    //myColor.z = pow(myColor.z, 2.0);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.01*iTime;\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    // spin\n    float theta = pi/2.0;//0.05*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n\t// wave\n\tuv.x += 0.05*sin(10.0*uv.y + 0.17*iTime);\n\tuv.y += 0.05*sin(10.0*uv.x + 0.13*iTime);\n\tuv.x += 0.2*sin(1.0*uv.y + 0.31*iTime);\n\tuv.y += 0.2*sin(1.0*uv.x + 0.27*iTime);\n    return uv;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nivec2 GetFocusPos(int i) { return ivec2(glyphSize/2); }\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n\tvec3 color = InitPixelColor();\n    \n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n    // time warp\n    float time = iTime + curvature*pow(length(uv), 0.2);\n    \n\t// get time \n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n    const float gsfi = 1.0 / glyphSizeF;\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += (vec2(GetFocusPos(i)) * gsfi) * pow(gsfi,float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}