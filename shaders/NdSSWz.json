{
    "Shader": {
        "info": {
            "date": "1620875162",
            "description": "Blending of an arbitrary number of materials in a way that's compatible with textures, reflections, and material properties.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdSSWz",
            "likes": 5,
            "name": "Multi-material blending V2",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "blending"
            ],
            "usePreview": 0,
            "username": "RogerB",
            "viewed": 347
        },
        "renderpass": [
            {
                "code": "// SHARED CONSTANTS\n\nconst float VERTICAL_FOV = 60.f;\n\n// How far away from the surface counts as 0.\nconst float MARCH_EPS = 0.00001;\n\n// How far to move away from the surface of the shape before marching reflections and shadows so the march doesn't get stuck near the surface.\nconst float T_EPS = MARCH_EPS * 2.;\nconst float NORMAL_EPS = MARCH_EPS * 2.;\n\n// How large of a step to use when computing the gradient.\nconst float GRADIENT_EPS = 0.001;\n\n// How low of a transmittance to use as a cutoff for reflections.\nconst float REFLECTION_EPS = 0.001;\n\nconst float FAR_CLIP = 100.;\nconst int MAX_MARCH_STEPS = 256;\n\n// Maximum number of reflections. Total number of casts = 1+MAX_REFLECTIONS.\nconst int MAX_REFLECTIONS = 5;\n\nconst float PI = 3.1416;\n\n// CAMERA MATH\n\nvec3 computeCameraRay (vec3 eye, vec3 target, vec2 uv) {\n    vec3 look = target - eye;\n    float lookLen = length(look);\n    vec3 xDir = normalize(cross(look, vec3(0, 1, 0)));\n    vec3 yDir = normalize(cross(xDir, look));\n    \n    // Distance to move in world-space to move one unit in screen-space.\n    float unitDist = tan(VERTICAL_FOV/2. * PI/180.) * lookLen;\n    \n    vec3 rayTarget = target + unitDist*(xDir*uv.x + yDir*uv.y);\n    return normalize(rayTarget - eye);\n}\n\n// MATERIALS\n\n// An earlier version represented materials in SdResult as a vector of material weights, with one component for each material in the scene.\n// Storing/blending material properties directly scales better for scenes with many textures.\nstruct Mat {\n    vec3 diffuseCol;\n    vec3 specularCol;\n    float shininess;\n    float reflectivity;\n};\n\nconst Mat red = Mat(vec3(0.2, 0.02, 0.02), vec3(0.04, 0.02, 0.02), 32.0, 0.0);\nconst Mat green = Mat(vec3(0.02, 0.2, 0.02), vec3(0.02, 0.04, 0.02), 32.0, 0.0);\nconst Mat blue = Mat(vec3(0.02, 0.02, 0.2), vec3(0.02, 0.02, 0.04), 32.0, 0.0);\nconst Mat mirror = Mat(vec3(0.01), vec3(0.09), 64., 0.9);\n\nMat floorMat(vec3 pos) {\n    vec3 white = vec3(0.3);\n    vec3 black = vec3(0.025);\n    \n    // Smoothstep for antialising; smooth more strongly further out.\n    // TODO: Antialias better. (Idea: Compute screen-space distance (in pixels?) to the other color and blend using that.)\n    float smoothstepSize = 0.005;\n    float scale = max(10., pow(length(pos), 1.3));\n    vec2 tile2D = smoothstep(-smoothstepSize, smoothstepSize, sin(pos.xz * PI) / scale);\n    float tile = min(max(tile2D.x, tile2D.y), max(1.-tile2D.x,1.-tile2D.y)); // Fuzzy xor.\n    vec3 color = mix(white, black, tile);\n    \n    return Mat(color,vec3(0.03), 128.0, 0.0);\n}\n\n// SCENE DEFINITION\n\nstruct SdResult {\n    float dist;\n    Mat mat;\n};\n\nfloat sdSphere(float r, vec3 p) {\n    return length(p) - r;\n}\n\nfloat sdPlane(float height, vec3 p) {\n    return p.y - height;\n}\n\nfloat largest(vec3 a) {\n    return max(a.x, max(a.y, a.z));\n}\n\nfloat sdBox(vec2 r, vec2 p) {\n    vec2 d = abs(p) - r;\n    float exterior = length(max(d, 0.));\n    float interior = min(max(d.x,d.y), 0.);\n    return exterior + interior;\n}\n\nfloat sdBox(vec3 r, vec3 p) {\n    vec3 d = abs(p) - r;\n    float exterior = length(max(d, 0.));\n    float interior = min(largest(d), 0.);\n    return exterior + interior;\n}\n\nfloat sdCylinder(vec2 r, vec3 p) {\n    return sdBox(r, vec2(length(p.xz), p.y));\n}\n\nSdResult sdUnion(SdResult a, SdResult b) {\n    if (a.dist < b.dist) return a; else return b;\n}\n\nMat blend(Mat a, Mat b, float k) {\n    return Mat(\n        mix(a.diffuseCol, b.diffuseCol, k),\n        mix(a.specularCol, b.specularCol, k),\n        mix(a.shininess, b.shininess, k),\n        mix(a.reflectivity, b.reflectivity, k)\n    );\n}\n\n// TODO: Generalize exponential smoothmin to work with multiple terms, each with their own smoothing coefficient.\n// (Start by deriving an asymmetrical smoothmin for two terms, then generalize it to n terms.)\n\n// k.x is the factor used for blending shape; ky is the factor for blending material.\nSdResult sminCubic(SdResult a, SdResult b, vec2 k) {\n    k = max(k, 0.0001);\n    vec2 h = max(k - abs(a.dist - b.dist), 0.0)/k;\n    vec2 m = h * h * h * 0.5;\n    vec2 s = m * k * (1.0 / 3.0);\n    \n    SdResult res;\n    bool aCloser = a.dist < b.dist;\n    res.dist = (aCloser ? a.dist : b.dist) - s.x;\n    float blendCoeff = aCloser ? m.y : 1.0-m.y;\n    \n    res.mat = blend(a.mat, b.mat, blendCoeff);\n    return res;\n}\n\nSdResult sminCubic(SdResult a, SdResult b, float k) {\n    return sminCubic (a, b, vec2(k));\n}\n\nvec3 rot45(vec3 p) {\n    const float ROOT_2_OVER_2 = 0.70710678118;\n    return vec3(ROOT_2_OVER_2 * (p.x - p.z), p.y, ROOT_2_OVER_2 * (p.x + p.z));\n}\n\n// I'm reasonably certain that the material calculations get optimized away by the compiler in cases where only the distance is used.\n// If this isn't the case, the optimization could be done manually by making a version of this function that only computes the distance.\nSdResult sdScene(vec3 p) {\n    float time = iTime - 2.8; // Add an offset to the current time so the thumbnail at time 0 looks good.\n    vec3 sphere1Pos = vec3(0, 0.5, 0);\n    SdResult sphere1 = SdResult(sdSphere(1.0, p - sphere1Pos), red);\n    SdResult result = sphere1;\n    \n    vec3 sphere2Pos = vec3(2.5*cos(time), 1, 2.5*sin(time));\n    SdResult sphere2 = SdResult(sdSphere (1.5, p - sphere2Pos), green);\n    result = sminCubic(result, sphere2, vec2(2, 1));\n    \n    vec3 sphere3Pos = vec3(-2.*cos(time/2.), 1, 2.*sin(time/2.));\n    SdResult sphere3 = SdResult(sdSphere (1.25, p - sphere3Pos), blue);\n    result = sminCubic(result, sphere3, 1.);\n    \n    SdResult floor = SdResult(sdPlane(0.0, p), floorMat(p));\n    result = sminCubic(result, floor, 1.5);\n    \n    vec3 smallMirrorPos = vec3(1.2, 1.4, 0.);\n    SdResult smallMirror = SdResult(sdBox(vec3(0.5), p - smallMirrorPos) - 0.05, mirror);\n    result = sminCubic(result, smallMirror, vec2(1., 0.5));\n    \n    vec3 cylinderPos = vec3(-5., 1., -3.);\n    SdResult cylinder = SdResult(sdCylinder(vec2(1., 1.5), p - cylinderPos) - 0.5, mirror);\n    \n    vec3 boxPos = vec3(5., 0., -4.);\n    SdResult box = SdResult(sdBox(vec3(1., 3., 3.), rot45(p - boxPos)) - 0.1, mirror);\n    \n    SdResult mirrors = sdUnion(cylinder, box);\n    result = sminCubic(result, mirrors, 0.1);\n    \n    return result;\n}\n\n// RAY MARCHING\n\n// Returns the distance to the intersection with the scene, or -1 if no intersection is found.\nfloat march(vec3 ro, vec3 rd) {\n    float t = T_EPS;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        float d = sdScene(pos).dist;\n        t += d;\n        if (d/t < MARCH_EPS) break;\n        if (t > FAR_CLIP) return -1.;\n    }\n    return t;\n}\n\n// Returns a coefficient for how much light makes it to a point from a light source.\n// lightApparentSize controls soft shadows. A bigger number means the light takes up a larger viewing area, making softer shadows.\n// (If you want to specify an exact apparent radius, pass in tan(radius), or tan(diameter/2.) for an apparent diameter.)\n// lightDist is the distance to the light source. Used to prevent marching past a point light.\nfloat shadowMarch(vec3 ro, vec3 norm, vec3 rd, float lightApparentSize, float lightDist) {\n    ro += norm * NORMAL_EPS;\n    float t = T_EPS;\n    \n    float minDist = lightApparentSize;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        float d = sdScene(pos).dist;\n        minDist = min(minDist, d/t);\n        t += d;\n        if (d < MARCH_EPS) break; // Good for efficiency and shouldn't impact the final result.\n        if (minDist/lightApparentSize < MARCH_EPS || t > FAR_CLIP) return max(minDist, 0.) / lightApparentSize;\n    }\n    // Assume we're in shadow if we didn't complete the march. This is usually a sign that we couldn't get off the original\n    // surface because the light vector was close to perpendicular.\n    return 0.;\n}\n\n// Overload for light sources infinitely far away.\nfloat shadowMarch(vec3 ro, vec3 norm, vec3 rd, float lightApparentSize) {\n    return shadowMarch(ro, norm, rd, lightApparentSize, FAR_CLIP);\n}\n\nvec3 grad(vec3 pos) {\n    const float eps = GRADIENT_EPS;\n    // Tetrahedron approach from https://iquilezles.org/articles/normalsSDF.\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(pos+eps*e).dist;\n    }\n    return n;\n}\n\nvec3 norm(vec3 pos) {\n    return normalize(grad(pos));\n}\n\n// LIGHTING\n\nvec3 distantPointLight(vec3 lightDir, vec3 lightCol, float lightApparentSize, Mat mat, vec3 pos, vec3 rd, vec3 norm) {\n    vec3 halfVec = normalize(lightDir - rd);\n    \n    vec3 diffuse = mat.diffuseCol * clamp(dot(norm, lightDir), 0., 1.);\n    vec3 specular = mat.specularCol * pow(clamp(dot(norm, halfVec), 0., 1.), mat.shininess);\n    // Normalization from http://www.thetenthplanet.de/archives/255.\n    float specNormalization = (mat.shininess  + 2.) / (4. * (2. - pow(2., -mat.shininess/2.)));\n    \n    return lightCol * shadowMarch(pos, norm, lightDir, lightApparentSize) * (diffuse + specular*specNormalization);\n}\n\nvec3 light(Mat mat, vec3 pos, vec3 rd, vec3 norm) {\n    float occlusion = 1.; // TODO: Some kind of occlusion.\n    \n    vec3 res = vec3(0);\n    \n    vec3 sunDir = normalize(vec3(1,0.75,0.5));\n    vec3 sunCol = vec3(2);\n    float sunApparentSize = 0.047; // The physically correct number is 0.0047, but softer shadows are fun.\n    res += distantPointLight(sunDir, sunCol, sunApparentSize, mat, pos, rd, norm);\n    \n    vec3 ambient =  vec3(0.05) * occlusion;\n    res += ambient * mat.diffuseCol;\n    \n    return res;\n}\n\n\n// RENDERING\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0);\n    float transmittance = 1.;\n    \n    for (int i = min(iFrame,0); i <= MAX_REFLECTIONS; i++) {\n        float dist = march(ro, rd);\n        if (dist > 0.) {\n            vec3 pos = ro + dist*rd;\n            SdResult sd = sdScene(pos);\n            vec3 norm = norm(pos);\n\n            color += transmittance * light(sd.mat, pos, rd, norm);\n            transmittance *= sd.mat.reflectivity;\n            ro = pos + norm * NORMAL_EPS;\n            rd = reflect(rd, norm);\n            \n            if (transmittance < REFLECTION_EPS) break;\n\n            // TODO: Render light sources as a specular reflection directly on the camera.\n        } else {\n            vec3 skyLight = vec3(0.4, 0.4, 0.8);\n            vec3 skyDark = vec3(0.1, 0.1, 0.4);\n            vec3 skyColor = mix(skyDark, skyLight, rd.y);\n            color += transmittance * skyColor;\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates. (y goes from -1 to 1, x has the same scale per pixel and is centered at 0.)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.yy;\n    \n    // Fixed viewpoint.\n    // vec3 ro = vec3(0, 4, 4);\n    // vec3 target = vec3(0, 0, -2);\n    \n    // Rotating viewpoint.\n    float viewAngle = iTime/10.;\n    vec3 ro = 4. * vec3(sin(viewAngle), 1, cos(viewAngle));\n    vec3 target = -2. * vec3(sin(viewAngle), 0, cos(viewAngle));\n    \n    vec3 rd = computeCameraRay(ro, target, uv);\n    \n    vec3 color = render(ro, rd);\n    \n    color = pow(color, vec3(0.4545)); // Gamma correction.\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}