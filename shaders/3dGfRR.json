{
    "Shader": {
        "info": {
            "date": "1606352955",
            "description": "first raymarcher in a while.\nI'm always so amazed at how fast computers are.\nfor https://isohedral.ca/swirled-series - I made the submission deadline, but a clerical error got it overlooked! );\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3dGfRR",
            "likes": 20,
            "name": "checkerboard oxe 2",
            "published": 3,
            "tags": [
                "checkerboard",
                "swirled"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "const float bg = 0.5;\n\nconst float distMax     =  16.0;\nconst float stepsMax    = 100.0;\nconst float distClose   =   0.003;\nconst float gradientEps =   0.00001;\n\nfloat myTime = 0.0;\n\n\nvec3 lightPos() {\n    return vec3(1.0, 2.0, 6.0);\n    return vec3(cos(myTime * 3.1), sin(myTime * 2.3), 1.0) * 4.0;\n}\n\nfloat scene(in vec3 p, out int material) {\n    float d = BIGF;\n    \n    material = 3;\n    \n    float j = floor(p.y + 4.0);\n    if (j < 0.0 || j > 7.0) {\n        return d;\n    }\n    \n    vec3 p0 = p;\n\n    mat2 mr  = rot2(myTime);\n    p.xz *= mr;\n    \n    p.xy += 3.5;\n    \n    for (float i = 0.0; i < 8.0; i += 1.0) {\n        vec3 pp = p;\n        pp.x = p.x - i;\n        pp.y = p.y - j;\n        vec3 ppp = pp;\n        ppp.z -= cos(myTime * 0.0 + length(vec2(i, j) - 3.5) * 2.0) * 0.92;\n            \n            \n//\t    ppp *= rot3(vec3(cos(myTime), sin(myTime), 0.0), myTime * 7.0 * (32.0 + (i + j)) / 32.0);\n        float dd = sdRoundBox2(ppp, vec3(0.5), cos(myTime) * -0.25 + 0.25);\n        if (dd < d) {\n            d = dd;\n            material = int(i + j) % 2 + 3;\n        }\n    }\n\n    // clip\n    d = opIntersection(d, sdBox(p0, vec3(4.0, 10.0, 10.0)));\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneGradient6(in vec3 p) {\n    const vec2 h = vec2(gradientEps, 0);\n    int unused;\n    return normalize(vec3(scene(p+h.xyy, unused) - scene(p-h.xyy, unused),\n                          scene(p+h.yxy, unused) - scene(p-h.yxy, unused),\n                          scene(p+h.yyx, unused) - scene(p-h.yyx, unused)));\n}\nvec3 sceneGradient4(in vec3 p) {\n    const vec2 h = vec2(gradientEps, 0);\n    int unused;\n    float fp = scene(p, unused);\n    return normalize(vec3(scene(p+h.xyy, unused) - fp,\n                          scene(p+h.yxy, unused) - fp,\n                          scene(p+h.yyx, unused) - fp));\n}\nvec3 sceneGradient3(in vec3 p) {\n    const vec2 h = vec2(gradientEps, 0);\n    int unused;\n    return normalize(vec3(scene(p+h.xyy, unused),\n                          scene(p+h.yxy, unused),\n                          scene(p+h.yyx, unused)));\n}\n\n\nvoid march(in vec3 p0, in vec3 d, out vec3 pos, out vec3 nrm, out int mat, out float stepNum) {      \n    float mindist = BIGF;\n    mat = 0;\n\n    bool keepGoing  = true;\n         stepNum    = 0.0;\n    float marchDist = 0.0;\n    \n    while (keepGoing) {\n        stepNum += 1.0;\n        if (stepNum > stepsMax) {\n            mat = 1;\n            return;\n        }\n        \n        if (marchDist > distMax) {\n            mat = 2;\n            return;\n        }\n        \n        int   mmat;\n        vec3  p = p0 + d * marchDist;\n        float mdist = scene(p, mmat);\n        \n        if (mdist < distClose) {\n            mat = mmat;\n            pos = p;\n            nrm = sceneGradient4(p);\n            return;\n            \n        }\n        \n        marchDist += mdist;\n    }       \n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{        \n    // 0 to 1 in 180 frames\n    myTime = fract(float(iFrame) / 180.0);\n    \n    // ease in/out\n    myTime = smoothstep(0.0, 1.0, myTime) * PI * 2.0;\n    \n    // ortho camera\n    float smallRes = vmin(iResolution.xy);\n    vec2 xy = XY - smallRes * 0.5;\n    if (iMouse.z > 0.0) {\n\t    xy = xy - (iResolution.xy - smallRes) * 0.5;\n    }\n    \n    vec2 uv = xy / smallRes * 8.0;\n    \n    float c = 0.4;\n    \n    if (vmax(abs(uv)) > 4.0) {\n        c += 0.02;\n    }\n    \n    int   mat;\n    vec3  nrm;\n    vec3  pos;\n    vec3  p = vec3(uv, 8.0);\n    float steps;\n    march(p, vec3(0.0, 0.0, -1.0), pos, nrm, mat, steps);\n    \n    if (mat >= 3) {\n        c = max(0.0, dot(nrm, normalize(lightPos() - pos)));\n        c *= 0.3;\n        if (mat == 4) {\n            c = c + 0.7;\n        }\n    }\n\n    float myTimeMix = cos(myTime) * 0.5 + 0.5;\n    myTimeMix *= myTimeMix;\n    if (mat == 4) {\n        c = mix(c, 1.0, myTimeMix);\n    }\n    else if (mat == 3) {\n        c = mix(c, 0.0, myTimeMix);\n    }\n    \n  //  c = pow(c, 1.0 / GAMMA);\n    \n    vec3 rgb = vec3(c);\n    if (iMouse.z > 10.0) {\n        rgb.x += steps / stepsMax;\n      //  rgb.y  = length(pos - p) / distMax;\n    }\n    \n    \n    RGBA = vec4(rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float BIGF  = 1e9;\nconst float GAMMA = 2.2;\nconst float PI    = 3.14159265359;\n    \nfloat vmin(in vec2 v) {return min(v.x, v.y);}\nfloat vmax(in vec2 v) {return max(v.x, v.y);}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n// same as sdRoundBox but takes the bevel out of the box instead of adding it on.\nfloat sdRoundBox2( vec3 p, vec3 b, float r )\n{\n    return sdRoundBox(p, b - r, r);\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s,\n                s,  c);\n}\n\n// based on http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rot3(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         );\n               \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}