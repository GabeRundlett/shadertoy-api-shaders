{
    "Shader": {
        "info": {
            "date": "1553983568",
            "description": "Trying out iq's odd SDF from https://www.shadertoy.com/view/tsSSRD to see how stable/artifact-free it is. Quickly thrown into a less empty scene with lighting (blinn-phong), shadows, ao and some 'post-processing'. Hardly any glitches... good Lipschitz!",
            "flags": 64,
            "hasliked": 0,
            "id": "tdBXWw",
            "likes": 6,
            "name": "Trying iq's 'goo thing'-SDF",
            "published": 3,
            "tags": [
                "3d",
                "phong",
                "raymarch",
                "sound",
                "sdf",
                "shadow",
                "post",
                "ao",
                "spheretrace",
                "blinn"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 634
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// iq's 'goo thing'-SDF - Trying out iq's odd SDF from ShaderToy-meeting\n// at GDC 2019\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c,s,-s,c);\n}\n\n// iq's 'goo thing'-SDF from https://www.shadertoy.com/view/tsSSR\nfloat sdThingFromIQ (vec3 p) {\n    float s = 2. + 3.*(.5+.5*cos (4.*iTime));\n    p.xyz += .05 * sin(2.0 * p.yxx + iTime) * s;\n    p.xyz += .025 * cos(4.0 * p.yxx + iTime) * s;\n    p.xyz += .0125 * cos(8.0 * p.yxx + iTime) * s;\n    p.xyz += .00625 * sin(16.0 * p.yxx + iTime) * s;\n    float r = .5 + .3*(.5+.5*cos (6.*iTime));\n    return length(p) - r;\n}\n\n// sorry about the lazy-ass 'material-system' using call-by-reference id & pout\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n\tfloat ground = p.y + 1.;\n\tfloat wall = p.z + 1.;\n\tfloat size = 3.;\n\tvec3 thingCenter = p;\n\tthingCenter.x = mod (p.x + .5*size, size) - .5*size;\n\tthingCenter.xz *= r2d (45.*iTime);\n\tthingCenter.yz *= r2d (65.*iTime);\n\tfloat thing = sdThingFromIQ (thingCenter);\n\tfloat d = min (ground, min (wall, thing));\n\tif (d == ground) {id = 1; pout = p;}\n\tif (d == wall) {id = 2; pout = p;}\n\tif (d == thing) {id = 3; pout = thingCenter;}\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int id, inout vec3 pout)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i< 64; ++i) {\n\t\tvec3 p = ro+d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < .0001*(1. + .125*t)) break;\n\t\td += t*.4;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p) {\n\tint ignored1;\n\tvec3 ignored2;\n\tfloat d = map (p, ignored1, ignored2);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p+e.xyy, ignored1, ignored2),\n                            map (p+e.yxy, ignored1, ignored2),\n                            map (p+e.yyx, ignored1, ignored2))-d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, vec3 ldir) {\n\tfloat d2l = distance (lp, p);\n\tint ignored1;\n\tvec3 ignored2;\n\tfloat d2w = march (p+.01*n, ldir, ignored1, ignored2);\n\treturn d2l < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, float i){\n\tfloat ao = .0;\n\tfloat dist = .0;\n\tint ignored1;\n\tvec3 ignored2;\n\tfor (int a = 1; a <= 6; ++a) {\n\t\tdist = float (a)*stepsize;\n\t\tao += max (.0, (dist - map (p+n*dist, ignored1, ignored2))/dist);\n\t}\n\treturn 1. - ao*i;\n}\n\nvec3 shade (vec3 ro,\n            vec3 rd,\n            float d,\n            vec3 n,\n            vec3 lp,\n            vec3 lc,\n            float li,\n            int id,\n            vec3 pout) {\n    vec3 p = ro + d*rd;\n\tfloat ld = distance (p, lp); \n\tvec3 ldir = normalize (lp - p);\n\tfloat att = 5. / (ld*ld);\n\tvec3 mat = vec3 (.2);\n\tif (id == 1) mat = mix (vec3 (.3, .25, .1),\n                            vec3 (.25, .3, .2),\n                            smoothstep(.0, .9, cos (20.*p.x) * sin(20.*p.z)));\n\tif (id == 2) mat = mix (vec3 (.0, .3, .1),\n                            vec3 (.0, .1, .3),\n                            smoothstep (.0, .9, cos (5.*p.x) + sin (5.*p.y)));\n\tif (id == 3) mat = mix (vec3 (.3, .0, .0),\n                            vec3 (.3, .3, .0),\n                            smoothstep (.0,.9,cos (20.*pout.y)));\n\tfloat s = sha (p, lp, n, ldir);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\n    float shiny = 100.;\n    if (id == 1 ) {\n        float hf = texture (iChannel0, .75*p.xz).r;\n        float lf = texture (iChannel0, .25*p.xz).r;\n        float fac = hf + lf;\n        shiny *= fac;\n    }\n    if (id == 2) {\n        float hf = texture (iChannel0, .75*p.xy).r;\n        float lf = texture (iChannel0, .25*p.xy).r;\n        float fac = hf + lf;\n        shiny *= fac;\n    }\n    if (id == 3) {\n        float hf = texture (iChannel0, 32.*pout.xz).r;\n        float lf = texture (iChannel0, .1*pout.xz).r;\n        float fac = mix (lf,\n                         hf,\n                         smoothstep (.0,\n                                     .9,\n                                     cos (20.*pout.y)));\n        shiny *= fac;\n    }\n\n    float sp = pow (max (.0, dot (h, n)), shiny);\n\n    vec3 am = vec3 (.05);\n\tfloat ao = ao (p, n, .1, .1);\n\treturn ao*att*s*(am + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f =normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x+u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .5*length (uv);\n\n\tvec3 ro = vec3 (cos (iTime), 1.+.75*(.5+.5*cos(5.*iTime)), 2.);\n\tvec3 rd = cam (uv, ro, vec3 (.0), 2.);\n\tint id = 0;\n\tvec3 pout = vec3 (.0);\n\tfloat d = march (ro, rd, id, pout);\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\tvec3 col = shade (ro, rd, d, n,\n                      vec3 (.0, .0, 2.),\n                      vec3 (.9, .85, .5),\n                      4.,id, pout);\n\tcol += shade (ro, rd, d, n,\n                  vec3 (.0, 3., .0),\n                  vec3 (.2, .2, .9),\n                  6.,id, pout);\n\tcol += shade (ro, rd, d, n,\n                  vec3 (-3., 1., .5),\n                  vec3 (.9, .5, .3), 2.,id, pout);\n\n\tcol = col / (1.25 + col*.5);\n\tcol *= 1. - .65*length(uvRaw*2.-1.);\n\tcol *= mix (1., .75, cos (700.*uvRaw.y));\n\tcol = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 18232,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/professorkliq/all-that-matters-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}