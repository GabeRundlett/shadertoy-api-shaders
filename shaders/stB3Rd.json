{
    "Shader": {
        "info": {
            "date": "1625174799",
            "description": "For learning and testing sdf rendering",
            "flags": 1,
            "hasliked": 0,
            "id": "stB3Rd",
            "likes": 3,
            "name": "SDF-Develop",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "golinad",
            "viewed": 367
        },
        "renderpass": [
            {
                "code": "// Uncomment for debug rendering\n//#define COMPLEXITY\n//#define ISOLINES\n//#define CURVATURE\n\nfloat delta = 0.0001;\nfloat delta2 = 0.1;\nfloat maxT = 20.0;\n//vec4 bgColor = vec4(0.25,0.5,0.8,1.0);\nvec4 bgColor = vec4(1.0,1.0,1.0,1.0);\n\n// SDF primitives\n// giving primitives a position makes them easy to use\n// but more complex in calculation and difficult to use with manipulations like extrude\nfloat sdSphere(vec3 pos, float r, in vec3 p) {\n    return distance(p, pos) - r;\n}\nfloat sdBox(vec3 pos, vec3 ext, in vec3 p) {\n// ok for inner part, but sharp outside and too long distance at corners\n// works, but incompatible with rounding\n/*    return max(max(abs(p.x - pos.x) - ext.x/2.0, \n                   abs(p.y - pos.y) - ext.y/2.0),\n                   abs(p.z - pos.z) - ext.z/2.0);*/\n    vec3 q = abs(p-pos) - ext/2.0;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y),q.z),0.0);\n}\nfloat sdTorus(in vec3 p, float r1, float r2) {\n    vec3 c = vec3(normalize(p.xy)*r1, 0.0);\n    return distance(p, c) - r2;\n}\n\n// SDF operations\nfloat sdUnion(float a, float b) {return min(a,b);}\nfloat sdIntersect( float a, float b) {return max(a,b);}\nfloat sdSubstract(float a, float b) {return max(a, -b);}\n\nfloat sdShell(float d, float t) {return abs(d)-t;}\n\nvec3 sdExtrude(vec3 pos, vec3 dir) {\n    return pos - clamp(pos, -0.5*dir, 0.5*dir);\n}\nvec3 sdArray(vec3 pos, vec3 step) {\n    // we dont want the break in the center\n    // the repeaded block should be centered at origin\n    return mod(pos +0.5*step, step) - 0.5*step;\n}\nvec3 sdMirror(vec3 pos) {\n    return abs(pos);\n}\n\nfloat isoLines(float d, float seg) {\n    return mod(d, seg) > seg*0.95 ^^ d < 0.0?1.0:0.0;\n}\n\nfloat map(in vec3 p) {\n    float d1 = sdShell(sdSphere(vec3(0,0,0), 0.5, sdExtrude(sdArray(p-vec3(sin(iTime), cos(iTime), 0.0), vec3(2,2,2)), vec3(0,1,0))), 0.1);\n    float d2 = sdBox(vec3(cos(iTime), sin(iTime), sin(iTime)), vec3(8.0,2.0,12), p) - 1.0;\n    float d = sdSubstract(d1,d2);\n    //d = sdUnion(d, sdTorus(sdMirror(p - vec3(cos(iTime), sin(iTime), sin(iTime)-5.0)) - vec3(3,0,1), 2.0, 1.0));\n    \n    return d;\n}\n\n// calculate normal based on simplified(3 vs. 6 samples) gradient around pos\n// Note: when we are marching solids, d is 0 on surface\nvec3 calcNormal(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta,0,0));\n    float dy = map(p + vec3(0,delta,0));\n    float dz = map(p + vec3(0,0,delta));\n    \n    return normalize(vec3(dx-d, dy-d, dz-d));\n}\n\nfloat calcCurvature(in vec3 p, in float d) {\n    float dx = map(p + vec3(delta2,0,0));\n    float dy = map(p + vec3(0,delta2,0));\n    float dz = map(p + vec3(0,0,delta2));\n    \n    float ndx = map(p + vec3(-delta2,0,0));\n    float ndy = map(p + vec3(0,-delta2,0));\n    float ndz = map(p + vec3(0,0,-delta2));\n    \n    \n    return clamp((dx+dy+dz+ndx+ndy+ndz-6.0*d)/delta2/4.0,-1.0,1.0);\n}\n\nvoid render(out vec4 fragColor, in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    \n    int j = 0;\n    for(int i = 0; i < 100; i++) {\n        if (t > maxT) {\n            fragColor = bgColor;\n            break;\n        }\n        \n        float d = map(ro+t*rd);\n        if(d < delta || i == 99) {\n            vec3 n = calcNormal(ro+t*rd, d);\n            fragColor = vec4((n*0.5+0.5)*min(calcCurvature(ro+t*rd, d)+1.0, 1.0),1.0);\n#ifdef CURVATURE\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), calcCurvature(ro+t*rd, d) *0.5 + 0.5);\n#endif\n            break;\n        } else {\n            t += d;\n        }\n        j++;\n    }\n    // fade to bg (fog)\n    fragColor = mix(fragColor, bgColor, t/maxT);\n    \n#ifdef COMPLEXITY //marching complexity\n    fragColor = mix(vec4(0,0,1,1), vec4(1,0,0,1), float(j)/100.0);\n#endif\n}\n\nvoid debugRender(out vec4 fragColor, in vec2 uv) {\n    float d = map(vec3(uv,0));\n    vec3  n = calcNormal(vec3(uv, 0), d);\n    float l = isoLines(d, 0.1);\n\n    // colored\n    //fragColor = vec4((n*0.5+0.5)*l,1.0);\n    \n    // monochrome\n    fragColor = vec4(l,l,l,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y*2.0;\n    \n#ifdef ISOLINES\n    debugRender(fragColor, uv);\n    //fragColor = vec4(mod(uv, 1.0), 0,1);\n#else\n    vec3 ro = vec3(0,0,1);\n    vec3 rd = normalize(vec3(uv.xy, 0) - ro);\n    render(fragColor, ro , rd);\n#endif\n\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n\n    render(fragColor, fragRayOri, fragRayDir);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}