{
    "Shader": {
        "info": {
            "date": "1502389237",
            "description": "mouse.xy    stretches straight parts of red j-shape\nblue dots show mouse.xy and the utilized symmetry-transformation.\n\nsolved in\nhttps://www.shadertoy.com/view/XsSBDc",
            "flags": 0,
            "hasliked": 0,
            "id": "4dSBWc",
            "likes": 0,
            "name": "jj stretch",
            "published": 3,
            "tags": [
                "mirror",
                "j",
                "branchless",
                "90deg",
                "stretch",
                "superprim",
                "bisymmetry",
                "cane",
                "quater"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 516
        },
        "renderpass": [
            {
                "code": "/*\nspecial application of diagonal mirroring:\nhttps://www.shadertoy.com/view/XsBBD3\nwhich is a simpler variant of \"glide reflection\"=\"transflect\":\nhttps://www.shadertoy.com/view/XsfBDH\nand an important part for my optimizazions on distance-field-fonts:\nhttps://www.shadertoy.com/view/MsSfWV\nwhere this is usefull to define the glyphs \"j,t,r\", utilizing bisymmetry.\n*/\n\n//also stretch .x-domain, this is overly excessive and slighly buggy, depending on resolution.\n#define doublestretch\n\n\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\n//float line(vec2 u,vec2 m){u.x=-u.x;float k=dot(m,u.yx);return k;}\n//float lineN(vec2 u,vec2 m){return line(u,normalize(m));}\n\n\n//#define stretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n/*\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nfloat sat(float a,vec2 m){    \n a=.5*(sign(a)+m.x)*a+m.y;\n a=(sign(2.-a)+1.)*(a-2.)+2.; \n return a*.5;}\nfloat sat(float a){return sat(a,vec2(1));}//return clamp(a,0.,1.); \n*/\n\n/*\nvec2 mirror(vec2 u){u=.5*u*mat2(sqrt(2.)*vec4(-1,1,1,1));//eight rotation;\n u.y=abs(u.y);return u;}\n*/\n//mirrorNegated()=180deg rotation is simpler than mirror()\n//the tricky thing is setting the mirror axis.\nvec2 mirrorNegated(vec2 u){\n return u*sign(u.x+u.y);//the sign() part sets the mirror axis\n}\n\n\n/*\n//the human readable branching version:\nfloat jjBranching(vec2 u,vec2 m){m=abs(m);\n //return b;\n if(u.x>-1.){\n  if(1.>u.y)return abs(length(u-vec2(-1,1))-2.);  //<-bottom right curve\n  else      return length(vec2(u.x-1.,mStretch((u.y-1.),m.y)));//<-top right straight\n }//bottom left straight->:\n u.y+=1.;\n #ifdef doublestretch\n u.x=mStretch(u.x,(m.x+1.));\n #else\n u.x+=1.;\n #endif\n return length(u*sign(u.x+u.y+2.001));//because +2.0 is ugly in some resolutions.\n}*/\n//semi-branching seens to make most sense here:\nfloat jj(vec2 u,vec2 m){\n if(u.y<1.&&u.x>-1.)return abs(length(u-vec2(-1,1))-2.);//<-bottom right curve;\n //i do not like double &&, but at least its not ||\n //straight is more complex than curved part above:\n m=abs(m);\n vec2 b=vec2(u.x-1.,mStretch((u.y-1.),m.y));//<-top right straight has priority\n u.y+=1.;\n #ifdef doublestretch\n u.x=mStretch(u.x,(m.x+1.));//bottom left straight STRETCH is optional here\n #else\n u.x+=1.;\n #endif \n vec2 c=u*sign(u.x+u.y+2.001);//<-bottom left straight, includes uncanny reflection\n //the line can be skipped by making m.xy=mStretch(.xy,.001)? soomething like that.\n //but it requires a rottion transform to get the distance to the mirror.\n //not worth it.\n u.y=sign(u.y-1.)+1.; \n vec2 p=.5*u.y*(b+c)-c;\n //p=mix(c,b,sign(u.y-1.)*.5+.5);\n return length(p);}//delaying the length() nicely.\n\n/*\n//below is branchless version of the above , showing that 100& branchless is not smart all the time.\n//i am sure i can de-branch this with a better bias.\nfloat jjBranchless(vec2 u,vec2 m){m=abs(m);\n vec2 w=u;\n w.y+=1.;\n #ifdef doublestretch\n w.x=mStretch(w.x,(m.x+1.));\n #else\n w.x+=1.;\n #endif\n float t=u.x;//for final branch.\n float s=sign(1.-u.y);\n u.x+=s;\n u.y-=1.;\n float c=.5*(1.-s)*(mStretch(u.y,m.y)+u.y)-u.y;//=.5*(-s*b+b-v-s*v);//==if(s>0.)c=u.y;else c=mStretch(u.y,m.y);\n c=length(vec2(u.x,c));\n float d=(s+1.)*(abs(c-2.)-c)*.5+c;//(s-1.)*(d-c)*.5+d;//d=mix(abs(c-2.),c,(-sign(s)*.5+.5));//if(s>0.)d=abs(c-2.);else d=c;\n float e= length(w*sign(w.x+w.y+2.001));//because +2.0 is ugly in some resolutions.  \n return mix(e,d,sign(t+1.)*.5+.5);\n //if(t>-1.){return d;}return e;\n}\n/**/\n\n#define frame(u) (u-.5*iResolution.xy)*9./iResolution.y\nvoid mainImage(out vec4 O, in vec2 U){\n\tvec2 u=frame(U);\n    vec2 m=frame(iMouse.xy);\n    vec3 c=vec3(0);\n    c.g=length(mirrorNegated(u)-mirrorNegated(m));//green circles show cursor and \"mirroring\".\n    u-=vec2(1,-1);\n    c.r=jj(u,m)-1.;               //red j-shape\n    float fsaa=7./min(iResolution.x,iResolution.y);\n    \n    c.r=fract(c.r);\n    c.rg=smoothstep(fsaa,-fsaa,c.rg-.5);\n    //u=abs(u);\n    float hair=6./min(iResolution.x,iResolution.y);\n    u+=vec2(1,-1);\n    u=abs(u)-hair;\n    u=fract(u);\n    c.b=max(u.x,u.y);\n    c.b=fract(c.b);\n\tO = vec4(c,1.0);\n}\n\n/*\nthe BISYMETRY PRINCIPLE: v2\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}