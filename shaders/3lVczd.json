{
    "Shader": {
        "info": {
            "date": "1611620012",
            "description": "My new look shader. It's almost developped accidentaly.\nThe sound is based on ttg's.\nhttps://www.shadertoy.com/view/4dlyWl\nThe basic performance algorithm is just a copy and paste of his shader.\nI made a few adjustments to make it fit my visuals.",
            "flags": 40,
            "hasliked": 0,
            "id": "3lVczd",
            "likes": 15,
            "name": "CLOUD WATCHER",
            "published": 3,
            "tags": [
                "clouds",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 1412
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  .-----..-.            .--. .-.                 .-.        .-.   .-.       .-.      .-.                //\n//  `-. .-': :           : .--': :                 : :        : :.-.: :      .' `.     : :                //\n//    : :  : `-.  .--.   : :   : :   .--. .-..-. .-' : .--.   : :: :: : .--. `. .'.--. : `-.  .--. .--.   //\n//    : :  : .. :' '_.'  : :__ : :_ ' .; :: :; :' .; :`._-.'  : `' `' ;' .; ; : :'  ..': .. :' '_.': ..'  //\n//    :_;  :_;:_;`.__.'  `.__.'`.__;`.__.'`.__.'`.__.'`.__.'   `.,`.,' `.__,_;:_;`.__.':_;:_;`.__.':_;    //\n//                                                                                                        //\n//                                                                                                        //\n//  \"The Clouds Watcher\" by iY0Yi                                                                         //\n//  https://www.shadertoy.com/view/3lVczd                                                                 //\n//                                                                                                        //\n//  Created by Atsushi Hashimoto 2021                                                                     //\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.                   //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 tonemapACES(vec3 color){\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\n}\n\n// Interpolation funcs from:\n// https://www.shadertoy.com/view/MsXGDj\nfloat tcCatmullRom(float x, float v0,float v1, float v2,float v3){\n    if(abs(v1-v2)<.001)return v1; // edited\n\tfloat c2 = -.5 * v0\t+ 0.5*v2;\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n}\nfloat tcThirdOrderSpline(float x, float L1,float L0, float H0,float H1){\n\treturn \t\t  L0 +.5 *\n\t\t\tx * ( H0-L1 +\n\t\t\tx * ( H0 + L0 * -2.0 +  L1 +\n\t\t\tx * ((H0 - L0)* 9.0\t + (L1 - H1)*3.0 +\n\t\t\tx * ((L0 - H0)* 15.0 + (H1 - L1)*5.0 +\n\t\t\tx * ((H0 - L0)* 6.0\t + (L1 - H1)*2.0 )))));\n}\nfloat tcCubic(float x, float v0,float v1, float v2,float v3){\n\tfloat p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\nfloat tcSmoothstep(float x, float v0, float v1, float v2,float v3){\n\tx = x*x*(3.0-2.0*x);\n\treturn (v2-v1)*x + v1;\n}\nfloat tcLinear(float x, float v0, float v1, float v2,float v3){\n\treturn (v2-v1)*x + v1;\n}\n\n#define INTP tcCatmullRom\n\nfloat fivePointToneCurve(float col, float low, float lmid, float mid, float hmid, float high){\n    float VU = -0.25+low;\n\tfloat V1 =  0.0 +low;\n\tfloat V2 =  0.25+lmid;\n\tfloat V3 =  0.5 +mid;\n\tfloat V4 =  0.75+hmid;\n\tfloat V5 =  1.0 +high;\n\tfloat VO =  1.25+high;\n\n\tif(col<.25)\n\t\treturn INTP( col*4.,      VU, V1, V2, V3);\n\telse if(col<.5)\n\t\treturn INTP((col-.25)*4., V1, V2, V3, V4);\n    else if(col<.75)\n\t\treturn INTP((col- .5)*4., V2, V3, V4, V5);\n\telse if(col<1.)\n\t\treturn INTP((col-.75)*4., V3, V4, V5, VO);\n    else\n        return 0.;\n}\n\nvec3 fivePointToneCurve(vec3 col, float low, float lmid, float mid, float hmid, float high){\n\tvec3 res;\n\tres.x = fivePointToneCurve(col.r, low, lmid, mid, hmid, high);\n\tres.g = fivePointToneCurve(col.g, low, lmid, mid, hmid, high);\n\tres.b = fivePointToneCurve(col.b, low, lmid, mid, hmid, high);\n\treturn res;\n}\n\nfloat dithering(float v, vec2 coord){\n\tv=pow(v, 8.);\n\tvec2 p = coord;\n\tp = mod(p.xx + vec2(p.y, -p.y), vec2(.1));\n\tfloat res=0.;\n\tvec2 coords = coord;\n\n\tcoords.y *= .75+.25*hash12(p);\n\tfloat rand_ditherVal = gfbm(coords*.75, 2, .5);\n\tconst float paletteDist = 1.15;\n\tres=v + (rand_ditherVal - .5) * paletteDist;\n\tres=smoothstep(0.1,1.,res);\n\tres=sat(floor(res*6.)/5.);\n\n\treturn res;\n}\n\nvec3 unpackRenderData(in vec2 fragCoord){\n\tvec4 packedData = texelFetch(iChannel0, ivec2(fragCoord/ERNST_RENDER_SCALE), 0);\n\trenDat.albedo = unpackU4(packedData.x).rgb;\n\trenDat.shadow = unpackU4(packedData.x).a;\n\trenDat.diffuse = s2u(unpackS3(packedData.y).r);\n\trenDat.specular = s2u(unpackS3(packedData.y).g);\n\trenDat.ao = s2u(unpackS3(packedData.y).b);\n\trenDat.normal = normalize(unpackS3(packedData.z));\n\trenDat.depth = packedData.w;\n\tfloat shade = sat(u2s(renDat.diffuse)) * renDat.shadow;\n\tshade += renDat.ao * .3;\n\trenDat.result = mix(vec3(0), renDat.albedo, shade);\n\trenDat.result += renDat.specular * renDat.shadow;\n\trenDat.result = tonemapACES(renDat.result);\n\trenDat.result = pow(renDat.result, vec3(1./2.2));\n\treturn renDat.result;\n}\n\n#define getBuf(co) texelFetch(iChannel0, ivec2((co)/ERNST_RENDER_SCALE), 0)\nvec3 getAlbedo(vec2 coord){\n    R(coord, u2s(hash11(floor(fract(iTime*.01)*100.)))*.0025);\n    #define alb(c) unpackU4(getBuf(mod(coord+c*ERNST_RENDER_SCALE, floor(iResolution.xy*.95))).x).rgb\n    vec3 c00 = alb(vec2( 0, 0));\n    vec3 cp0 = alb(vec2( 1, 0));\n    vec3 c0p = alb(vec2( 0, 1));\n    vec3 cpp = alb(vec2( 1, 1));\n    vec3 cn0 = alb(vec2(-1, 0));\n    vec3 c0n = alb(vec2( 0,-1));\n    vec3 cnn = alb(vec2(-1,-1));\n    vec3 cpn = alb(vec2( 1,-1));\n    vec3 cnp = alb(vec2(-1, 1));\n    #define dst(x) distance(x,c00)<.1\n    bool bp0 = dst(cp0);\n    bool b0p = dst(c0p);\n    bool bpp = dst(cpp);\n    bool bn0 = dst(cn0);\n    bool b0n = dst(c0n);\n    bool bnn = dst(cnn);\n    bool bpn = dst(cpn);\n    bool bnp = dst(cnp);\n    \n    vec2 uv = fract(coord*INV_ERNST_RENDER_SCALE);\n    uv=abs((uv)*2.);\n    \n    if(!bpp && hash12(floor(coord*INV_ERNST_RENDER_SCALE)+floor(iTime))<(.1+abs(sin(iTime*.01))*.25)){\n        return mix(c00, cpp, sms(1.92, 2., length(uv-vec2(1,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime))<.25){\n        return mix(c00, cnn, sms(1.92, 2., length(uv-vec2(0,0)*2.)));\n    }\n    \n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        return mix(c00, cp0, sms(1.92, 2., length(uv-vec2(0,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.xy*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        return mix(c00, c0n, sms(1.92, 2., length(uv-vec2(1,0)*2.)));\n    }\n    \n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.025+abs(sin(iTime*.01))*.05){\n        return alb(floor(hash22(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2)*10.)*10.));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.1))<.15+abs(sin(iTime*.01))*.15){\n        return mix(c00, c0n, sms(1.92, 2., length(uv*2.-2.)));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.5+abs(sin(iTime*.01))*.15){\n        return mix(c00, c0n, sms(1.92, 2., dot(uv,vec2(1))));\n    }\n    \n\treturn unpackU4(getBuf(coord).x).rgb;\n}\nvec3 getNormal(vec2 coord){\n\treturn normalize(unpackS3(getBuf(coord).z));\n}\nfloat getShadow(vec2 coord){\n    R(coord, u2s(hash11(floor(fract(iTime*.021)*100.)))*.0025);\n\tfloat res = unpackU4(getBuf(coord).x).a;\n    \n    #define sha(c) unpackU4(getBuf(mod(coord+c*ERNST_RENDER_SCALE, floor(iResolution.xy*.95))).x).a\n    float c00 = sha(vec2( 0, 0));\n    float cp0 = sha(vec2( 1, 0));\n    float c0p = sha(vec2( 0, 1));\n    float cpp = sha(vec2( 1, 1));\n    float cn0 = sha(vec2(-1, 0));\n    float c0n = sha(vec2( 0,-1));\n    float cnn = sha(vec2(-1,-1));\n    float cpn = sha(vec2( 1,-1));\n    float cnp = sha(vec2(-1, 1));\n    #define dstsh(x) abs(x-c00)<.1\n    bool bp0 = dstsh(cp0);\n    bool b0p = dstsh(c0p);\n    bool bpp = dstsh(cpp);\n    bool bn0 = dstsh(cn0);\n    bool b0n = dstsh(c0n);\n    bool bnn = dstsh(cnn);\n    bool bpn = dstsh(cpn);\n    bool bnp = dstsh(cnp);\n    \n    vec2 uv = fract(coord*INV_ERNST_RENDER_SCALE);\n    uv=abs((uv)*2.);\n    \n    if(!bpp && hash12(floor(coord*INV_ERNST_RENDER_SCALE)+floor(iTime))<(.1+abs(sin(iTime*.01))*.25)){\n        res = mix(c00, cpp, sms(1.92, 2., length(uv-vec2(1,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime))<.25){\n        res = mix(c00, cnn, sms(1.92, 2., length(uv-vec2(0,0)*2.)));\n    }\n    \n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        res = mix(c00, cp0, sms(1.92, 2., length(uv-vec2(0,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.xy*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        res = mix(c00, c0n, sms(1.92, 2., length(uv-vec2(1,0)*2.)));\n    }\n    \n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.025+abs(sin(iTime*.01))*.05){\n        res = sha(floor(hash22(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2)*10.)*10.));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.1))<.15+abs(sin(iTime*.01))*.15){\n        res = mix(c00, c0n, sms(1.92, 2., length(uv*2.-2.)));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.5+abs(sin(iTime*.01))*.15){\n        return mix(c00, c0n, sms(1.92, 2., dot(uv, vec2(1,-1))));\n    }\n    \n    return res;\n}\nfloat getDepth(vec2 coord){\n\treturn getBuf(coord).w;\n}\n\nfloat getSpecular(vec2 coord){\n\treturn s2u(unpackS3(getBuf(coord).y).g);\n}\nfloat getAO(vec2 coord){\n\treturn s2u(unpackS3(getBuf(coord).y).b);\n}\nvec3 getSharpenNormal(in vec2 coord, float strength){\n\tvec3 sum = getNormal(coord)  *  9. +\n\tgetNormal(coord+vec2( 1, 0)) * -1. +\n\tgetNormal(coord+vec2( 1, 1)) * -1. +\n\tgetNormal(coord+vec2( 0, 1)) * -1. +\n\tgetNormal(coord+vec2(-1, 0)) * -1. +\n\tgetNormal(coord+vec2(-1,-1)) * -1. +\n\tgetNormal(coord+vec2( 0,-1)) * -1. +\n\tgetNormal(coord+vec2(-1, 1)) * -1. +\n\tgetNormal(coord+vec2( 1,-1)) * -1. ;\n\treturn mix(getNormal(coord), sum , strength);\n}\n\nfloat getDiffuse(vec2 coord){\nR(coord, u2s(hash11(floor(fract(iTime*.007)*100.)))*.0025);\n\tfloat res = s2u(unpackS3(getBuf(coord).y).r);\n    \n    \n    #define dif(c) s2u(unpackS3(getBuf(mod(coord+c*ERNST_RENDER_SCALE, floor(iResolution.xy*.95))).y).r)\n    float c00 = dif(vec2( 0, 0));\n    float cp0 = dif(vec2( 1, 0));\n    float c0p = dif(vec2( 0, 1));\n    float cpp = dif(vec2( 1, 1));\n    float cn0 = dif(vec2(-1, 0));\n    float c0n = dif(vec2( 0,-1));\n    float cnn = dif(vec2(-1,-1));\n    float cpn = dif(vec2( 1,-1));\n    float cnp = dif(vec2(-1, 1));\n    #define dstdf(x) abs(x-c00)<.1\n    bool bp0 = dstdf(cp0);\n    bool b0p = dstdf(c0p);\n    bool bpp = dstdf(cpp);\n    bool bn0 = dstdf(cn0);\n    bool b0n = dstdf(c0n);\n    bool bnn = dstdf(cnn);\n    bool bpn = dstdf(cpn);\n    bool bnp = dstdf(cnp);\n    \n    vec2 uv = fract(coord*INV_ERNST_RENDER_SCALE);\n    uv=abs((uv)*2.);\n    \n    if(!bpp && hash12(floor(coord*INV_ERNST_RENDER_SCALE)+floor(iTime))<(.1+abs(sin(iTime*.01))*.25)){\n        res = mix(c00, cpp, sms(1.92, 2., length(uv-vec2(1,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime))<.25){\n        res = mix(c00, cnn, sms(1.92, 2., length(uv-vec2(0,0)*2.)));\n    }\n    \n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        res = mix(c00, cp0, sms(1.92, 2., length(uv-vec2(0,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.xy*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        res = mix(c00, c0n, sms(1.92, 2., length(uv-vec2(1,0)*2.)));\n    }\n    \n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.025+abs(sin(iTime*.01))*.05){\n        res = dif(floor(hash22(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2)*10.)*10.));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.1))<.15+abs(sin(iTime*.01))*.15){\n        res = mix(c00, c0n, sms(1.92, 2., length(uv*2.-2.)));\n    }\n    \n    res+=sms(.1,.8, gnoise(floor(coord*INV_ERNST_RENDER_SCALE)+floor(hash11(floor(iTime*.5)*1000.)*20.)))*.3;\n\treturn res;\n}\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2){\n\tvec2 difN = abs(nlm1.xy - nlm2.xy);\n\treturn smoothstep(.3, .2, difN.x + difN.y);\n}\n\nfloat getOutline(vec2 coord){\n\tvec2 coords = coord;\n\tcoords += u2s(gfbm((coord+iResolution.xy*.15)*.1, 1, .5))*.5;\n\tvec3 offset = vec3(1, -1, 0) * u2s(max(1., 1.5*gfbm(coord*.1, 3, .5))) * .4;\n\toffset.xy += u2s(hash22(coord*vec2(321.,2144.)))*.5;\n\tfloat edge = 1.0;\n\tedge *= calcEdge(getNormal(coords+offset.xx), getNormal(coords+offset.yy));\n\tedge *= calcEdge(getNormal(coords+offset.xy), getNormal(coords+offset.yx));\n\tedge *= calcEdge(getNormal(coords+offset.zy), getNormal(coords+offset.zx));\n\tedge *= calcEdge(getNormal(coords+offset.yz), getNormal(coords+offset.xz));\n\treturn edge;\n}\n\nfloat getShadowEdge( vec2 coord ){\n\tvec2 coords = coord;\n\tfloat sha = getShadow(coords);\n\tsha -= .5;\n\tsha = abs(sha);\n\tsha = smoothstep(.1,.2,sha);\n\treturn sha;\n}\nfloat getDottedShadow(vec2 coord){\n\tvec2 uv = coord;\n\tuv *= mat2(cos(.8+vec4(0, 11, 33, 0)));\n\tuv = mod(uv*.25, 1.);\n\tfloat res = 0.;\n\tfloat shadow = getShadow(coord);\n\tshadow = max(.65,shadow*.85) + .35*getAO(coord);\n\tshadow = 1. - shadow;\n\tres = smoothstep(shadow, shadow+1., pow(length(uv-.5), 4.));\n\tres = smoothstep(.0, .2, pow(res, .05));\n\treturn res;\n}\n\nfloat hatching(vec2 coord, float tickness, float angle, float dark, float light, bool centered, float contrast){\n\tvec2 v = coord.xy / iResolution.xy;\n\tvec3 n = normalize(getNormal(coord));\n\tR(v, angle);\n\tif((distance(getAlbedo(coord), MAT_CLOUD)<.15)){\n\t    tickness *=.5;\n\t}\n\t\n\tv.y = mod(v.y*iResolution.y/tickness, 1.)-.5;\n\tv.y += u2s(gfbm(coord.yx*.5, 2, .5))*.25;\n\n\tfloat shading = max(0., getDiffuse(coord)-.5)*2.;\n\tshading = shading * getShadow(coord);\n\tshading = sat(shading * .7 + .5 * pow(getAO(coord), .5));\n\tshading = shading*.85+.15*sat(gfbm(coord*.015, 3, .5));\n\tshading = pow(shading, .75);\n\tif((distance(getAlbedo(coord), MAT_CLOUD)<.15)){\n\t\tshading = max(0., getDiffuse(coord));\n\t\tshading = pow(shading, .65);\n\t}\n\t\n\tif(centered)\n\t{\n\t\tshading = (shading-.5)*2.;\n\t\tshading = abs(shading)*2.;\n\t\tshading = shading + .5;\n\t}\n\tif(renDat.depth>.9)\n\tshading = .825;\n\t\n\tshading = smoothstep(dark, light, pow(shading*contrast, .8));\n\tfloat line = smoothstep((1.-shading), 10.5*(1.-shading), abs(v.y));\n\treturn line;\n}\n\nfloat getHatching(vec2 coord){\n\tfloat ln = 1.;\n\tconst float mul = 1.;\n    ln*= pow(hatching(coord, 3., -PI*.55+.5, -1.4, 1.4, false, 1.5), 1.5);\n    ln*= pow(hatching(coord, 3., -PI*.5+1.5, -1.4, 1.4, false, 1.5), 1.5);\n    if(!(distance(getAlbedo(coord), MAT_CLOUD)<.15)){\n        ln*= pow(hatching(coord, 3.,  PI*.5-1.5, -1.4, 1.4, false, 1.9), 1.5);\n        ln*= pow(hatching(coord, 3.,  PI*.45-.5, -1.4, 1.4, false, 1.9), 1.5);\n    }\n\treturn ln;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tunpackRenderData(fragCoord);\n    \n\tvec3 col = vec3(.8, .77, .7);\n\n\tfloat shading = sat(u2s(renDat.diffuse));\n\tshading *= renDat.shadow;\n\tshading = shading*.7+.3*renDat.ao;\n\tshading = smoothstep(.3, 1., shading);\n\n\tfloat contrast = 8.8;\n\tfloat midpoint = .5;\n\tshading = sat(shading);\n\n\tcol*= getHatching(fragCoord);\n\tcol+=dithering((smoothstep(.0,1., renDat.specular*renDat.shadow)), fragCoord);\n\n\tvec3 albedo = getAlbedo(fragCoord+u2s(gfbm(fragCoord*.01, 1, .5))*u2s(gfbm(fragCoord.yx*.05, 1, .5))*64.*INV_ERNST_RENDER_SCALE);\n\tif((distance(getAlbedo(fragCoord), MAT_CLOUD)<.15)){\n\t\talbedo = mix(albedo, FOG_COL, sat(pow(renDat.depth-FOG_START*.5, FOG_POW)));\n\t}\n\telse{\n\t\talbedo = mix(albedo, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n    col*= albedo;\n    col*= dithering(gnoise(fragCoord*.18+iTime*5.)+gnoise(fragCoord*.35-iTime*5.)+.8, fragCoord*.1)*vec3(0.953,0.925,0.867)*1.2;\n    col+= 1.-dithering((1.-gnoise(fragCoord*.3+iTime*5.)*gnoise(fragCoord*.2-iTime*5.))+.8, fragCoord*.2);\n\n\tcol = pow(col, vec3(1./2.2));\n    vec2 uv = fract(fragCoord*INV_ERNST_RENDER_SCALE);\n    \n    //dbg_2V(abs((uv)*2.-1.));\n    \n    uv=abs((uv)*2.);\n    uv.x-=2.*step(.5, hash12(floor(fragCoord*INV_ERNST_RENDER_SCALE+floor(hash11(iTime)*1000.))));\n    uv.y-=2.*step(.5, hash12(floor(fragCoord*INV_ERNST_RENDER_SCALE+floor(hash11(iTime)*1000.)).yx));\n    //dbg_1F(sms(1.92, 2., length(uv)));\n\tfragColor = vec4(col, 1.);\n    drawDebug(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// General\n#define iFrameRate 60.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0., 1.)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// Raymarching\n#define MIN_DIST .001\n#define MAX_DIST 2000.0\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n#define MAT_CLOUD vec3(.96)\n#define FOG_FLOAT .7\n#define MAT_SKIN vec3(.6795, .6921, .6281)\n#define MAT_TOPS vec3(.3248, .5531, .6038)\n#define MAT_TOPSARM vec3(.4392, .4885, .3929)\n#define MAT_GROUND vec3(.4385, .239, .1594)\n#define MAT_PANTS vec3(.2203, .179, .142)\n#define MAT_TOE vec3(.0637, .0637, .0637)\n#define MAT_FLOOR vec3(.8, .754, .4222)\n#define MAT_ERNST0 vec3(.8, .8, .8)\n\n#define AMB_COL vec3(.3588, .3672, .3269)\n#define AMB_STRENGTH .2\n#define FOG_COL vec3(.5903, .7484, .735)\n#define FOG_START .01\n#define FOG_POW 2.11\n\n#define isMat(name) (distance(getAlbedo(coord), name)<.25)\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\t\tfloat total = 0.;\n\tfloat frequency = 1.;\n\tfloat amplitude = 1.;\n\tfloat maxValue = 0.;\n\tfor(int i=0;i<rep;i++) {\n\t\ttotal += gnoise(vec2(n.x * frequency, n.y * frequency)) * amplitude;\n\t\tmaxValue += amplitude;\n\t\tamplitude *= pers;\n\t\tfrequency *= 2.;\n\t}\n\tres = total/maxValue;\n\treturn res;\n}\n\n#define ERNST_RENDER_SCALE float(iResolution.x/1200.*floor(fract(pow(iTime*.002, 1.25))*256.+16.))\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\nstruct RenderData{\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\nuint packUnorm3x10(vec3 x) {\n\tx = round(clamp(x, 0., 1.) * 1023.);\n\tuvec3 r = uvec3(x);\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packU3(x) uintBitsToFloat(packUnorm3x10(x))\nvec3 unpackUnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tvec3 v = vec3(r) / 1023.0;\n\treturn v;\n}\n#define unpackU3(x) unpackUnorm3x10(floatBitsToUint(x))\nuint packSnorm3x10(vec3 x) {\n\tx = round(clamp(x,-1., 1.) * 511.);\n\tuvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n\tuvec3 mag = uvec3(abs(x));\n\tuvec3 r = sig.xyz << 9 | mag.xyz;\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packS3(x) uintBitsToFloat(packSnorm3x10(x))\nvec3 unpackSnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tuvec3 sig = r >> 9;\n\tuvec3 mag = r & uvec3(0x1FF);\n\tvec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n\tvec3 fmag = vec3(mag) / 511.;\n\treturn fsig * fmag;\n}\n#define unpackS3(x) unpackSnorm3x10(floatBitsToUint(x))\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x, 0., 1.) * 255.);\n\tuvec4 r = uvec4(x);\n\treturn r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n#define packU4(x) uintBitsToFloat(packUnorm4x8(x))\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n\tvec4 v = vec4(r) / 255.0;\n\treturn v;\n}\n#define unpackU4(x) unpackUnorm4x8(floatBitsToUint(x))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n\tvec3 up;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\n// \"init\": init camera/lights.\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\n    cam0.position = vec3(3.3043, .8457, -6.1505);\n\tcam0.quaternion = vec4(.6967, .1758, .1704, .6743);\n\tcam0.fov = .3456;\n\tcam0.orthoDist = 0.;\n\tcam0.orthoScale = 0.;\n\n\tlit0.direction = normalize(vec3(-.6948, .4383, -.8938));\n\tlit0.color = vec3(1., 1., 1.);\n\tlit0.shadowStart = .05;\n\tlit0.shadowEnd = 30.;\n\tlit0.shadowSoft = 32.;\n\tlit1.direction = normalize(vec3(-.0948, -.4383, .8938));\n\tlit1.color = vec3(.3, .3, .3);\n\tlit1.shadowStart = .05;\n\tlit1.shadowEnd = 30.;\n\tlit1.shadowSoft = 50.;\n}\n\n// \"camera\": create camera vectors.\nvoid camera(vec2 uv){\n\n\tfloat pY = 1.35;\n    float cL = 1.8;\n    vec3 forcus = vec3(0,1.6,0);\n    float fov = .5;\n    vec2 h=vec2(.7,-.7);\n    \n    int LOOP = 60*30;\n    int cF = iFrame%LOOP;\n    if(cF<60*5){\n        pY = 10.;\n        cL = 5.;\n        h = vec2(.1,-.7);\n        forcus = vec3(0,10.88,0);\n        fov = .1+sin(iTime*.01)*.05;\n    }\n    else\n    if(cF<60*10){\n        //man\n        pY = 1.4+sin(iTime*.01);\n        cL = 1.5;\n        h = vec2(.0,.5);\n        forcus = vec3(0,1.58,0);\n        fov = .5;\n    }\n    else\n    if(cF<60*15){\n        pY = 10.+sin(iTime*.01);\n        cL = 5.;\n        h = vec2(.1,-.7);\n        forcus = vec3(0,10.88,-10.+sin(iTime*.01)*10.);\n        fov = 1.;\n    }\n    else\n    if(cF<60*20){\n        //man\n        pY = 1.4+sin(iTime*.01);\n        cL = 2.;\n        h = vec2(.5,-.5);\n        forcus = vec3(0,1.58,0);\n        fov = .8;\n    }\n    else\n    if(cF<60*25){\n        pY = 1.5;\n        cL = 15.;\n        h = vec2(2.1,-.7);\n        forcus = vec3(0,1.48,0);\n        fov = .53;\n    }\n    else\n    if(cF<60*30){\n        //man\n        pY = 1.;\n        cL = 5.;\n        h = vec2(.1,-.7);\n        forcus = vec3(0,10.88,0);\n        fov = 1.3;\n    }\n    \n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,pY,0);\n    pos.xz = normalize(h)*cL;\n\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcam0.up = up;\n    mat3 camMat = mat3(cu, cv, cw);\n    ray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ray.origin = pos;\n\n}\n\n// SDF functions\nfloat vmax(vec3 v){\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p,in float r){\n\treturn length(p)-r;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\t//return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 d=abs(p)-b;\n\treturn length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nfloat pMirror(float x, float k){\n\treturn sqrt(x * x + k);\n}\n\n// \"polyAbs\" by iq:\n// https://www.shadertoy.com/view/3sVBRG\nfloat polyAbs(float x, float m, float n){\n\tx = abs(x);\n\tif( x>m ) return x;\n\tfloat a = 2.0*n - m;\n\tfloat b = 2.0*m - 3.0*n;\n\tfloat t = x/m;\n\treturn (a*t + b)*t*t + n;\n}\n\nfloat fOpUnionPoly(float a, float b, float m, float n){\n\treturn (a+b-polyAbs(a-b, m, n))*.5;\n}\n\nvec4 v4OpUnionPoly(vec4 a, vec4 b, float m, float n){\n\tfloat res = (a.x+b.x-polyAbs(a.x-b.x, m, n))*.5;\n\treturn vec4(res, mix(a.yzw, b.yzw, sat(exp(-res))));\n}\n\nvec4 sdMan(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0., -1., 0.)), bsr=2.5;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpManRoot = p;\n\tcpManRoot.xyz += vec3(0., 0., 0.);\n\t\n\tvec3 cp000_002 = cpManRoot;\n\tcp000_002.xyz += vec3(0., 0., 0.);\n\t\n\tvec3 cpHead = cpManRoot;\n\tcpHead.xyz += vec3(0., -1.9, 0.);\n\t\n\tvec3 cpTorso = cpManRoot;\n\tcpTorso.xyz += vec3(0., -1.0317, 0.);\n\t{\n\t\tvec3 q = cpTorso;\n\t\tq.xz += u2s(gfbm(q.xy*10., 2, .25))*.025;\n\t\tcpTorso = q;\n\t}\n\n\tvec3 cp000_001 = cpManRoot;\n\tcp000_001.xyz += vec3(0., -1.6491, 0.);\n\t\t\n\tvec3 cpArmBase = cp000_001;\n\tcpArmBase.xyz += vec3(0., 0., 0.);\n\t\tvec3 cpArmBase_mir0_Pos = max(vec3(0), sign(cpArmBase));\n\tvec3 cpArmBase_mir0_Neg = max(vec3(0),-sign(cpArmBase));\n\tcpArmBase.x = pMirror(cpArmBase.x, 0.);\n\n\tvec3 cpArmBaseEf = cp000_001;\n\tcpArmBaseEf.xyz += vec3(0., 0., 0.);\n\t\tvec3 cpArmBaseEf_mir0_Pos = max(vec3(0), sign(cpArmBaseEf));\n\tvec3 cpArmBaseEf_mir0_Neg = max(vec3(0),-sign(cpArmBaseEf));\n\tcpArmBaseEf.x = pMirror(cpArmBaseEf.x, 0.);\n\t{\n\t\tvec3 q = cpArmBaseEf;\n\t\tq.xz += u2s(gfbm(q.xy*10., 2, .25))*.025;\n\t\tcpArmBaseEf = q;\n\t}\n\n\tvec3 cpLegBase = cpTorso;\n\tcpLegBase.xyz += vec3(0., .034, 0.);\n\t\tvec3 cpLegBase_mir0_Pos = max(vec3(0), sign(cpLegBase));\n\tvec3 cpLegBase_mir0_Neg = max(vec3(0),-sign(cpLegBase));\n\tcpLegBase.x = pMirror(cpLegBase.x, 0.);\n\n\tvec3 cpArmShoulder = cpArmBase;\n\tcpArmShoulder.xyz += vec3(-.3007, -.0087, 0.);\n\t\n\tvec3 cpArmShoulderEf = cpArmBaseEf;\n\tcpArmShoulderEf.xyz += vec3(-.3007, -.0087, 0.);\n\t\n\tvec3 cpLegHip = cpLegBase;\n\tcpLegHip.xyz += vec3(-.1523, .0438, 0.);\n\t\n\tvec3 cpArmElbow = cpArmShoulder;\n\tcpArmElbow.xyz += vec3(0., .3489, 0.);\n\t\n\tvec3 cpArmElbowEf = cpArmShoulderEf;\n\tcpArmElbowEf.xyz += vec3(0., .3489, 0.);\n\t\n\tvec3 cpLegKnee = cpLegHip;\n\tcpLegKnee.xyz += vec3(0., .4081, 0.);\n\t\n\tvec3 cpArmWrist = cpArmElbow;\n\tcpArmWrist.xyz += vec3(0., .3019, 0.);\n\t\n\tvec3 cpLegAnkle = cpLegKnee;\n\tcpLegAnkle.xyz += vec3(0., .4265, 0.);\n\t\n\td = sdEllipsoid(cpTorso+vec3(0., -.2067, 0.), vec3(.2456, .2, .1826));\n\tres = v4OpUnion(vec4(d, MAT_TOPS), res);\n\n\td = sdEllipsoid(cpTorso+vec3(-.0076, .011, 0.), vec3(.1347, .1347, .1347));\n\tres = v4OpUnionSmooth(vec4(d, MAT_PANTS), res, .01);\n\n\td = sdEllipsoid(cpTorso+vec3(0., -.5324, 0.), vec3(.253, .2, .1895));\n\tres = v4OpUnionSmooth(vec4(d, MAT_TOPS), res, .187);\n\n\td = sdEllipsoid(cpLegBase+vec3(-.1189, .0291, 0.), vec3(.1347, .1347, .1347));\n\td = fOpUnionSmooth(sdEllipsoid(cpLegHip+vec3(-.0028, .251, 0.), vec3(.1347, .2116, .1347)), d, .1044);\n\td = fOpUnionSmooth(sdEllipsoid(cpLegKnee+vec3(-.0028, .196, 0.), vec3(.1119, .1861, .1119)), d, .1044);\n\tres = v4OpUnionSmooth(vec4(d, MAT_PANTS), res, .1044);\n\n\td = sdEllipsoid(cpArmShoulderEf+vec3(.1115, .0417, -.011), vec3(.0669, .0669, .0669));\n\td = fOpUnionPoly(sdEllipsoid(cpArmShoulderEf+vec3(-.0085, .1711, 0.), vec3(.0871, .1683, .0871)), d, .268, .046);\n\tres = v4OpUnionPoly(vec4(d, MAT_TOPSARM), res, .097, .055);\n\n\td = sdEllipsoid(cpHead, vec3(.05, .05, .05));\n\tres = v4OpUnion(vec4(d, MAT_SKIN), res);\n\n\td = sdEllipsoid(cpArmElbowEf+vec3(-.0085, .1297, 0.), vec3(.0905, .1625, .0905));\n\tres = v4OpUnionPoly(vec4(d, MAT_TOPSARM), res, .133, .036);\n\n\td = sdEllipsoid(cpLegAnkle+vec3(-.0028, .0402, 0.), vec3(.0753, .0661, .1119));\n\tres = v4OpUnionSmooth(vec4(d, MAT_TOE), res, .01);\n\n\td = sdEllipsoid(cpArmWrist+vec3(.0028, .0697, 0.), vec3(.05, .05, .05));\n\tres = v4OpUnion(vec4(d, MAT_SKIN), res);\n\n\td = sdEllipsoid(cpLegAnkle+vec3(-.0028, .0402, .0892), vec3(.0753, .0575, .1119));\n\tres = v4OpUnionPoly(vec4(d, MAT_TOE), res, .115, .022);\n\treturn res;\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp001_001 = p;\n\tcp001_001.xyz += vec3(0., -10.0332, 0.);\n\t{\n\t\tvec3 q = cp001_001;\n        q.y-=30.;\n\t\tq.y += gfbm(q.xz*.01, 4, .25)*80.;\n\t\tcp001_001 = q;\n\t}\n\n\td = sdPlane(cp001_001);\n\td = fOpUnion(sdSphere(cp001_001+vec3(0., 5., -4.8), 1.), d);\n\tres = v4OpUnion(vec4(d, MAT_GROUND), res);\n\tres = v4OpUnionSmooth(sdMan(p), res, .01);\n\treturn res;\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec2 voronoi(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec2 res = vec2(100.);\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    for(int l=-1; l<=1; l++)    \n    {\n        vec3 b = vec3(j,k,l);\n        vec3 r = b-f+hash33(i+b);\n        float d = dot(r,r);\n\n        if( d < res.x )\n            res = vec2( d, res.x );\t\t\t\n        else if( d < res.y )\n            res.y = d;\n    }\n\n    return res;\n}\n// The clouds were borrowed from Bananaft's shader.\n// I have not understand it yet... \n// https://www.shadertoy.com/view/XldGR7\nfloat sdClouds(vec3 p)\n{\n    p.z+=iTime;\n    p.y-=80.;//terrainH(p.xz, 2, false)*.5;\n    // p.yz*=mat2(cos(.5+vec4(0,11,33,0)));\n    // vec2 vrn1 = voronoi(p * 0.03 + vec3(iTime * 0.025, -iTime * 0.05, 0.));\n    // vec2 vrn2 = voronoi(p * 0.2 + vec3(iTime * 0.5, -iTime * 0.1, 0.));\n\t// vrn1*=vec2(6,3)*3.5;\n    // float q = (vrn1.y - vrn1.x);\n    // float d = sdSphere(vec3(q, p.y, q), 10.);//+jitter.x*.5;\n    \n    // // vrn2*=vec2(3,1);\n    // float disp = (vrn2.y + vrn2.x);\n    // // float disp = (vrn2.x);\n    // return (d + disp*2.5);\n\tvec2 vrn2 = voronoi(p * 0.02);\n\tfloat v3 =  voronoi(p * 0.2).x;\n\tfloat v2 = 0.8 - vrn2.x * (1.5 - vrn2.y );\n\tfloat v =  voronoi(p * 0.125).x;// vrn.x;// * (1.4 - vrn.y);\n\tfloat cld = max(11. - v2 * 10., 0.);\n\tfloat d = sdSphere(vec3(cld, p.y, cld), 5.5);      \n\t//v = -.3 + v* 2.1 ;\n\td += v + v3 * 1.4;\n    \n    return d;\n}\n\nfloat hitClouds()\n{\n    float t = 1.;\n    const int ITR=300;\n    int i=ZERO;\n    for(; i < ITR; ++i)\n    {\n        float d = sdClouds(ray.origin + ray.direction * t);\n        t += d;\n\n        if((d)<MIN_DIST*300. || t>MAX_DIST)\n        {\n           break;\n        }\n    }\n    return t;\n}\n\nfloat ssClouds(vec3 p)\n{\n    float ss = 0.0;\n    const float LEN = 10.;\n    const float DEN = .97;\n    for(int i = 0 ;  i < 5; ++i)\n    {\n        float d = sdClouds(p + lit0.direction*LEN*float(i));\n        ss += d * (1.-DEN);\n    }\n    return sat(ss);\n}\n\nvec3 normalClouds(vec3 p){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n         vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n         n += e*sdClouds(p+0.001*e);\n     }\n     return normalize(n);\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; // big, such that y = 0 on the first iteration\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n#if 1\n\t\tres = min( res, k*h/t);\n#else\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0,1,0);\n\t\trenDat.diffuse = FOG_FLOAT*1.18;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 1.;\n\t\trenDat.ao = 1.;\n\t\trenDat.depth = .9;\n\t\trenDat.result = FOG_COL;\n\n        float t=hitClouds();\n        vec3 p=ray.origin+ray.direction*t;\n        if(t<MAX_DIST)\n        {\n\t\t\trenDat.albedo = MAT_CLOUD;\n\t\t\tvec3 n = normalClouds(p);\n\n\t\t\tvec3 dir = quat_rotate(cam0.quaternion, vec3(0,0,-1)).xzy;\n\t\t\tvec3 up = quat_rotate(cam0.quaternion, vec3(0,1,0)).xzy;\n\t\t\tvec3 pos = cam0.position;\n\t\t\tfloat fov = cam0.fov;\n\t\t\tvec3 target = pos-dir;\n\n\t\t\tvec3 cw = normalize(target - pos);\n\t\t\tvec3 cu = normalize(cross(cw, up));\n\t\t\tvec3 cv = normalize(cross(cu, cw));\n\n\t\t\tvec3 side = cross(dir, up);\n\t\t\trenDat.normal.x = dot(n, cu);\n\t\t\trenDat.normal.y = dot(n, up);\n\t\t\trenDat.normal.z = dot(n, -dir);\n\t\t\trenDat.normal = normalize(renDat.normal);\n\t\t\t\n            float ss = ssClouds(p);\n\t\t\trenDat.diffuse = ss;\n            renDat.result = vec3(ss);\n            renDat.result = mix(renDat.result, vec3(abs(ray.direction.y)), sat(t/MAX_DIST*1.));\n            renDat.diffuse = mix(renDat.diffuse, FOG_FLOAT, sat(t/MAX_DIST*1.));\n\t\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n            \n        }\n\t}\n\telse{\n\t\trenDat.albedo = res.yzw;\n\n\t\tvec3 n = normal(p);\n\n\t\tvec3 dir = quat_rotate(cam0.quaternion, vec3(0,0,-1)).xzy;\n\t\tvec3 up = quat_rotate(cam0.quaternion, vec3(0,1,0)).xzy;\n\t\tvec3 pos = cam0.position;\n\t\tfloat fov = cam0.fov;\n\t\tvec3 target = pos-dir;\n\n\t\tvec3 cw = normalize(target - pos);\n\t\tvec3 cu = normalize(cross(cw, up));\n\t\tvec3 cv = normalize(cross(cu, cw));\n\n\t\tvec3 side = cross(dir, up);\n\t\trenDat.normal.x = dot(n, cu);\n\t\trenDat.normal.y = dot(n, up);\n\t\trenDat.normal.z = dot(n, -dir);\n\t\trenDat.normal = normalize(renDat.normal);\n\n        float lamb1 = s2u(dot(n, lit0.direction));\n\t\tfloat lamb2 = sat(dot(n, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+n*.0001, n);\n\t\trenDat.ao = 1.;\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\t\t\n        renDat.diffuse += lamb2*renDat.ao;\n        renDat.diffuse += renDat.ao*AMB_STRENGTH;\n        \n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH);\n\t\trenDat.result*= renDat.albedo;\n\t\trenDat.specular = 0.;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t\trenDat.diffuse = mix(renDat.diffuse, FOG_FLOAT, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\nvec4 packRenderData(){\n\t#define dlamp(x) clamp(abs(x)*.994+.003,.0, 1.)*sign(x)\n\treturn vec4(\n\t\t\tpackU4(vec4(renDat.albedo, renDat.shadow)),\n\t\t\tpackS3(dlamp(u2s(vec3(renDat.diffuse, renDat.specular, renDat.ao)))),\n\t\t\tpackS3(dlamp(renDat.normal)), // pack/unpackS3: data is alive in .003 to .997 only.\n\t\t\trenDat.depth\n\t\t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE) return;\n\n\tuv*=ERNST_RENDER_SCALE;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    fragColor = packRenderData();\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This sound shader is based on ttg's shader.\n// \"Bitshift Variations in C Port\" by ttg:\n// https://www.shadertoy.com/view/4dlyWl\n// The basic performance algorithm is just a copy and paste of his shader.\n// I made a few adjustments to make it fit my visuals.\n\n/*\nBitshift Variations in C Minor\nCopyright 2013 Robert Miles <soundcloud.com/robertskmiles>\n*/\n\n// \"BY}6YB6%\", \"Qj}6jQ6%\"\nconst int seq1[] = int[](66,0,0,54,0,66,0,0);\nconst int seq2[] = int[](16,0,0,0,0,81,0,0);\n\nint g(int i,int x,int t,int o){\n    return((3&x&(i*((\n        (3&i>>16)!=0 ? seq1[t%8] : seq2[t%8] )+51\n        )>>o))<<4);\n}\n                     \nint s(int i, float time){\n\tint n, s;\n    return(\n        g(i,1+int(time*.1+1.)%3,n=i>>14,10+int(time*.2+1.)%5));\n}\n\n/* //////////////////////////\nSimple audio resampling\nCopyright 2017 Theron Tarigo\n*/\n\nvec2 mainSound( in int samp, float time )\n{\n    // Simple resampling algorithm\n    int samprate = 8000;\n    int i = int(fract(time)*float(samprate))+int(floor(time))*samprate;\n    float rem = fract(fract(time)*float(samprate));\n    uint s1 = uint(s(i,time))%256u;\n    uint s2 = uint(s(i+1,time))%256u;\n    float f1 = float(s1)/255.;\n    float f2 = float(s2)/255.;\n    float f = f1*(0.5+0.5*cos(3.141592653589793*rem));// +\n              //f2*(0.5-0.5*cos(3.141592653589793*rem)) ;\n    return vec2( f );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}