{
    "Shader": {
        "info": {
            "date": "1599036260",
            "description": "Below street level",
            "flags": 0,
            "hasliked": 0,
            "id": "3lBBWm",
            "likes": 13,
            "name": "Escalator 2",
            "published": 3,
            "tags": [
                "tunnel",
                "underground",
                "stair"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 337
        },
        "renderpass": [
            {
                "code": "// \"Escalator 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // =1 for optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, pPos[2];\nvec2 stCs;\nfloat tCur, dstFar, stSpd, stAng, stRise, stWid, stHt, stLen, wThk, psgSep, psgWid, pSpd,\n   pRot[2], stExt, stTurn;\nint idObj, vuMode;\nconst int idStep = 1, idPlat = 2, idHrail = 3, idSep = 4, idWal = 5, idFlor = 6, idCeil = 7,\n   idLamp = 8, idBod = 9, idEye = 10;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat CeilDf (vec3 p, vec3 pr, float dMin)\n{\n  vec3 q;\n  float dc[3], dp[2], dd[3], d;\n  q = p;\n  q.x = abs (q.x) - psgSep;\n  q.y -= - stHt * sign (p.x) - 0.06;\n  dc[2] = length (vec2 (q.x, q.y - 2.3)) - 1.7;\n  dd[2] = max (abs (dc[2]) - wThk, 3. - q.y);\n  dc[2] = max (dc[2] + wThk, 2.8 - q.y);\n  q = p;\n  dc[0] = length (vec2 (q.z, q.y + 5.6)) - 12.;\n  dp[0] = dc[0] - wThk;\n  dd[0] = max (max (max (abs (dc[0]) - wThk, 6. - q.y), abs (q.x + 3.8) - stLen), - dc[2]);\n  dc[0] = max (max (dc[0] + wThk, 5.9 - q.y), - q.x - 9.);\n  dc[1] = length (vec2 (q.z, pr.y + 5.7)) - 10.6;\n  dp[1] = dc[1] - wThk;\n  dd[1] = max (max (max (abs (dc[1]) - wThk, 4.45 - pr.y), abs (q.x - 3.5) - stLen - 0.3), - dc[2]);\n  dc[1] = max (dc[1] + wThk, 4.3 - pr.y);\n  dd[2] = max (dd[2], max (- dc[0], - dc[1]));\n  d = min (min (max (dd[0], dp[1]), max (dd[1], dp[0])), dd[2]);\n  DMIN (idCeil);\n  return dMin;\n}\n\nfloat LampDf (vec3 p, vec3 pr, float dMin)\n{\n  vec3 q;\n  float d;\n  q = vec3 (mod (pr.x + 0.8, 1.6) - 1., pr.y - 3.8, pr.z - 2. * stWid + wThk).zyx;\n  d = max (PrCapsDf (q, 0.12, 0.25), abs (pr.x - 0.3 * stLen) - stLen - 0.8);\n  DMINQ (idLamp);\n  q = p;\n  q = vec3 (mod (q.x + 0.8, 1.6) - 0.6, q.y - 5.6, pr.z - 2. * stWid + wThk).zyx;\n  d = max (PrCapsDf (q, 0.12, 0.25), abs (p.x + 4.) - 3.);\n  DMINQ (idLamp);\n  q = p;\n  q.xz = abs (q.xz);\n  q.x = abs (q.x - psgSep);\n  q -= vec3 (psgWid, - stHt * sign (p.x) + 2.6, 5. * stWid);\n  d = PrCapsDf (q, 0.152, 0.25);\n  DMINQ (idLamp);\n  return dMin;\n}\n\nfloat BodDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  for (int j = 0; j < 2; j ++) {\n    for (float k = -1.; k <= 1.; k += 2.) {\n      q = p - pPos[j] * k - vec3 (0.16, 0.8, 0.);\n      q.xz = Rot2D (q.xz, pRot[j] + pi * step (0.5, k));\n      d = PrRoundBoxDf (q, vec3 (0.11 - 0.02 * q.y, 0.8, 0.25 - 0.06 * q.y) - 0.1, 0.1);\n      d = min (d, PrCylDf ((q - vec3 (0., 0.7, 0.)).xzy, 0.3, 0.02));\n      DMINQ (idBod);\n      q.z = abs (q.z);\n      q -= vec3 (0.1, 0.4, 0.12);\n      d = PrCylDf (q.yzx, 0.09, 0.1);\n      DMINQ (idEye);\n    }\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pr;\n  float dMin, d, s1, s2, spx;\n  dMin = dstFar;\n  spx = sign (p.x);\n  p.z = mod (p.z + 8. * stWid, 2. * 8. * stWid) - 8. * stWid;\n  pr = vec3 (Rot2Cs (p.xy, stCs), abs (p.z) - 2. * stWid);\n  q = p;\n  d = max (abs (q.y) - stHt, abs (pr.z) - stWid);\n  q.xy = pr.xy / stRise;\n  q.x = mod (q.x * stCs.y + stSpd * tCur * sign (p.z), 1.);\n  s1 = q.x / stCs.x;\n  s2 = (q.x - 1.) * stCs.x / (stCs.y * stCs.y);\n  d = 0.6 * stRise * max (max (d, q.y + 0.5 * abs (s1 + s2) - 0.5 * (s1 - s2)), -3.32 - q.y);\n  DMIN (idStep);\n  q = p;\n  q.z = pr.z;\n  d = min (PrBoxDf (q - vec3 (stLen + 0.8, - stHt - 0.02, 0.), vec3 (0.8, 0.02, stWid)),\n     PrBoxDf (q - vec3 (- stLen - 0.8, stHt - 0.02, 0.), vec3 (0.8, 0.02, stWid)));\n  DMIN (idPlat);\n  q = p;\n  d = min (PrCaps2Df ((q.xy - vec2 (stLen + 0.3, - stHt + 0.49)).yx, 0.85, 0.52),\n     PrCaps2Df ((q.xy - vec2 (- stLen - 0.7, stHt + 0.49)).yx, 0.55, 0.52));\n  d = min (d, max (max (abs (pr.y - 0.28) - 0.55, abs (q.x) - stLen - 0.3),\n     abs (q.y - 0.48) - stHt - 0.52));\n  d = max (d, max (abs (abs (pr.z) - stWid - wThk), 0.) - wThk);\n  DMIN (idHrail);\n  q = p;\n  d = max (max (abs (pr.y - 0.15) - 0.42, max (abs (q.x) - stLen - 0.3, - stHt - 0.15 - q.y)),\n     max (stWid + 0.1 - abs (pr.z), pr.z - 2. * stWid));\n  DMIN (idSep);\n  q = p;\n  q.z = abs (q.z) - 8. * stWid - wThk;\n  d = abs (PrBox2Df (q.xz, vec2 (stLen + 3.4, 4. * stWid))) - wThk;\n  d = max (d, max (abs (pr.y - 1.3) - 3.4, abs (q.y - 1.5) - stHt - 1.6));\n  DMIN (idWal);\n  q = p;\n  d = PrBox2Df (vec2 (abs (q.x) - stLen - 6.4, q.y + stHt * spx - 1.5), vec2 (wThk, 1.6));\n  if (vuMode == 0) d = max (d, 4. * stWid - abs (p.z));\n  DMIN (idWal);\n  q = p;\n  q.x = abs (q.x) - psgSep;\n  q.y -= - stHt * spx - 0.06;\n  d = PrBox2Df (q.xy, vec2 (psgWid, wThk));\n  q.x -= -3.1;\n  d = min (d, PrBoxDf (q, vec3 (1.6, wThk, 4. * stWid)));\n  DMIN (idFlor);\n  if (vuMode >= 0) dMin = CeilDf (p, pr, dMin);\n  dMin = LampDf (p, pr, dMin);\n  dMin = BodDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.03, 0.07, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.2 * smoothstep (0.35, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sq.x * sq.y, ss.y);\n}\n\nvoid Setup ()\n{\n  stSpd = 2.;\n  stRise = 0.2;\n  stWid = 0.7;\n  stHt = 3.;\n  wThk = 0.05;\n  stAng = pi / 5.;\n  stCs = sin (stAng + vec2 (0.5 * pi, 0.));\n  stLen = stHt / (stCs.y / stCs.x);\n  psgSep = stLen + 4.9;\n  psgWid = 1.5;\n  pSpd = (stCs.x / stCs.y) * stRise * stSpd / (2. * stLen);\n  stExt = (stLen + 16. * stRise * stCs.x / stCs.y) / stLen;\n  stTurn = stExt * stLen - pi * stWid;\n  for (int j = 0; j < 2; j ++) {\n    pPos[j].xy = stExt * vec2 (stLen, - stHt) * (1. - 2. * mod (pSpd * tCur / stExt +\n       float (j) / 2., 1.));\n    pPos[j].y = clamp (pPos[j].y, - stHt + 0.02, stHt - 0.02);\n    pPos[j].z = 2. * stWid;\n    pRot[j] = 0.;\n    if (abs (pPos[j].x) > stTurn) {\n      pRot[j] = (pPos[j].x - sign (pPos[j].x) * stTurn) / (2. * stWid);\n      pPos[j].xz = vec2 (stTurn * sign (pPos[j].x), 0.) + Rot2D (vec2 (0., 2. * stWid), - pRot[j]);\n    }\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, qr, rg, u, ltDirL[3];\n  vec2 vf;\n  float dstObj, s, sh, nDotL, dSum, sSum, ux, uz;\n  int idObjP;\n  bool fxz;\n  col = vec3 (0.2, 0.2, 0.4);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    qr = vec3 (Rot2Cs (ro.xy, stCs), abs (ro.z) - 2. * stWid);\n    idObjP = idObj;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    ux = abs (ro.x) - stLen;\n    uz = mod (ro.z + 8. * stWid, 2. * 8. * stWid) - 8. * stWid;\n    if (idObjP == idStep || idObjP == idPlat) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.3);\n      if (vn.y > 0.99) {\n        s = mod (12. * ro.z / stWid, 1.);\n        col4 *= 0.4 + 0.6 * SmoothBump (0.1, 0.9, 0.05, s);\n        if (idObjP == idStep || idObjP == idPlat && ux < 1.1) col4 =\n           mix (vec4 (0., 0.1, 0., 0.), col4, 0.6 + 0.4 * SmoothBump (0.03, 0.97, 0.01,\n           mod (ro.x * (stCs.y / stCs.x) / stRise + tCur * sign (ro.z) * stSpd, 1.)));\n        if (idObjP == idPlat) col4 = mix (vec4 (0., 0.1, 0., 0.), col4,\n           1. - 0.4 * SmoothBump (0.03, 0.06, 0.01, ux - 1.1));\n        vn.z = 0.3 * (SmoothBump (0.75, 0.95, 0.05, s) - SmoothBump (0.05, 0.25, 0.05, s));\n        vn.y = sqrt (1. - dot (vn.xz, vn.xz));\n      } else {\n        col4 = mix (0.7 * col4, vec4 (0., 0.3, 0., 0.1), SmoothBump (0.3, 0.7, 0.05, mod (4. * ro.z / stWid, 1.))) *\n           (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.02, mod (16. * ro.z / stWid, 1.)));\n      }\n    } else if (idObjP == idHrail) {\n      col4 = vec4 (0.9, 0.8, 0.7, 0.2);\n      if (abs (vn.x) + abs (vn.y) > 0.001) col4 *= 0.05;\n      else {\n        if (abs (ro.x - 0.25) < stLen && qr.y < 0.18) col4 *= 0.5;\n        col4.rgb *= 1. - 0.2 * SmoothBump (0.45, 0.55, 0.02, mod (2. * ro.x, 1.));\n        if (length (vec2 (ux - 1.3, ro.y + stHt * sign (ro.x) - 0.5)) < 0.07)\n           col4 = (sign (ro.x) == sign (ro.z)) ? vec4 (0., 1., 0., -1.) : vec4 (1., 0., 0., -1.);\n      }\n    } else if (idObjP == idSep) {\n      col4 = vec4 (0.6, 0.4, 0.2, 0.1);\n      if (vn.y > 0.1) {\n        s = mod (2. * ro.x, 1.);\n        col4.rgb *= 0.8 + 0.2 * SmoothBump (0.43, 0.57, 0.02, s);\n        vn.xy = Rot2D (vn.xy, -0.2 * pi * SmoothBump (0.05, 0.1, 0.02, abs (s - 0.5)) * sign (s - 0.5));\n      } else if (abs (vn.x) > 0.99) { \n         col4.rgb *= 0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * ro.z, 1.));\n      }\n      vf = vec2 (128., 0.2);\n    } else if (idObjP == idWal) {\n      col4 = vec4 (0.45, 0.5, 0.6, 0.1);\n      fxz = (abs (vn.x) > abs (vn.z));\n      rg = ShStagGrid ((fxz ? ro.zy : ro.xy), vec2 (2., 3.));\n      col4.rgb = mix (col4.rgb, vec3 (0.6, 0.7, 0.4), 0.5 - 0.5 * rg.y);\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n      u.y = abs (abs (ro.y) - stHt) - 1.5;\n      u.z = uz;\n      if (abs (length (u.yz) - 0.5) < 0.11) col4 = vec4 (0.7, 0., 0., 0.1);\n      u.yz = abs (u.yz) - vec2 (0.12, 0.7);\n      if (max (u.y, u.z) < 0.) col4 = vec4 (0., 0., 0.7, 0.1);\n      u.x = ux - (psgSep - stLen);\n      u.y = ro.y + stHt * sign (ro.x);\n      if (abs (u.x) < psgWid && abs (u.y - 1.51) > 1.49 || u.x > - (stLen + 1.5) && u.y < 0.02 ||\n         ro.x < -0.7 && ro.y > stHt + 2.98 || ro.x > -0.7 &&\n         ro.x < stLen + 3.4 && qr.y > 4.44) col4 *= 0.5;\n      if (abs (qr.x + 0.8) < stLen + 1. && abs (qr.y - 1.) < 0.01) {\n        if (abs (mod (qr.x + 0.9 * sign (ro.z) * stSpd * tCur * stRise / stCs.y + 0.1, 0.2) - 0.1) < 0.05)\n           col4 = vec4 (0., 1., 0.5, -1.);\n        else col4 *= 0.8;\n      }\n      if (abs (u.x) < psgWid ||ux < 3.) {\n        s = LampDf (ro, qr, dstFar);\n        col4.rgb += vec3 (0.9, 0.9, 0.8) / (5. + 4000. * s * s);\n      }\n      vf = vec2 (64., 0.5);\n    } else if (idObjP == idLamp) {\n      col4 = vec4 (vec3 (0.9, 0.9, 0.8) * (0.95 + 0.05 * cos (64. * pi * qHit.y)), -1.);\n    } else if (idObjP == idFlor) {\n      col4 = vec4 (0.45, 0.55, 0.5, 0.);\n      if (abs (vn.y) > 0.99) {\n        rg = ShStagGrid (ro.zx, vec2 (4.));\n        col4.rgb *= 0.9 + 0.1 * rg.y;\n        if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n        else vn.yz = Rot2D (vn.yz, rg.x);\n      }\n      u.xz = vec2 (ux - psgWid, abs (ro.z) - 2. * stWid);\n      u.xz = max (abs (vec2 (u.x, abs (u.z) - stWid)) - vec2 (0.07, 0.07), -0.05);\n      col4.rgb *= 0.8 + 0.2 * smoothstep (0., 0.05, max (u.x, u.z));\n      s = length (vec2 (ux - 4.9, uz)) - 0.4;\n      if (s < 0.) {\n        col4 = (abs (s) < 0.02) ? vec4 (0.5, 0.5, 0.6, 0.1) :\n           vec4 (vec3 (0.6, 0.5, 0.4) * (0.9 + 0.1 * smoothstep (-0.7, -0.6, cos (32. * pi * s))), 0.);\n        vn = vec3 (0., 1., 0.);\n      } else vf = vec2 (64., 1.);\n    } else if (idObjP == idCeil) {\n      col4 = vec4 (0.45, 0.55, 0.5, 0.1);\n      col4.rgb *= 1. - 0.15 * SmoothBump (0.4, 0.6, 0.05, Truch (8. * ro.xz));\n      u.xz = abs (ro.xz);\n      s = smoothstep (0., 0.01, min (max (abs (u.z - 0.1) - 0.03, u.x - 7.7),\n         abs (abs (u.x - psgSep) - 0.1) - 0.03));\n      if (s < 0.999) col4 = mix (vec4 (0.8, 0.8, 0.7, -1.), col4, s);\n      else vf = vec2 (128., 0.25);\n    } else if (idObjP == idBod) {\n      col4 = (qHit.y > 0.68 || qHit.x > 0. && abs (qHit.y + 0.1) < 0.4 && abs (qHit.z) < 0.01) ?\n         vec4 (0.1, 0.1, 0.1, 0.) : vec4 (0., 0.3, 0.4, 0.1);\n    } else if (idObjP == idEye) {\n      col4 = (length (qHit.yz) < 0.06) ? vec4 (0.8, 0.4, 0.4, -1.) : vec4 (0., 0.3, 0.4, 0.1);\n    }\n    sh = 1.;\n    if (idObjP == idStep && vn.y > 0.99 || idObjP == idPlat || idObjP == idFlor)\n       sh = 0.7 + 0.3 * smoothstep (0.02, 0.1, BodDf (ro, dstFar));\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (ux > 3.42) {\n        ltDirL[0] = normalize (vec3 (1., 1., 0.));\n        ltDirL[1] = normalize (vec3 (-1., 1., 0.));\n      } else {\n        ltDirL[0] = normalize (vec3 (0.5, 1., 1.));\n        ltDirL[1] = normalize (vec3 (0.5, 1., -1.));\n      }\n      ltDirL[2] = ltDir;\n      dSum = 0.;\n      sSum = 0.;\n      for (int k = 0; k < 3; k ++) {\n        nDotL = max (dot (vn, ltDirL[k]), 0.);\n        if (idObjP == idStep || idObjP == idPlat) nDotL *= nDotL;\n        dSum += ((k < 2) ? 0.5 : 1.) * nDotL;\n        sSum += ((k < 2) ? 0.5 : 1.) * pow (max (dot (normalize (ltDirL[k] - rd), vn), 0.), 32.);\n      }\n      col = col4.rgb * (0.2 + 0.5 * sh * dSum) + step (0.95, sh) * col4.a * sSum;\n    } else col = col4.rgb * (0.3 - 0.7 * dot (vn, rd));\n  }\n  col *= max (0.1, 1. - 2. * smoothstep (0., 1., dstObj / (2. * dstFar)));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid[2], ut[2], mSize, msw;\n  float el, az, zmFac, asp, vuId, regId, sr, a, t, tt;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., -1.);\n  mMid[1] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., 1.);\n  for (int k = 0; k < 2; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  vuMode = -1;\n  regId = -1.;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 2; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (max (abs (msw.x), abs (msw.y)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  if (vuMode != 0) {\n    vuId = 0.;\n    for (int k = 0; k < 2; k ++) {\n      if (max (ut[k].x, ut[k].y) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = float (k + 1);\n        break;\n      }\n    }\n    if (regId == 1.) {\n      if (vuId == 0. || vuId == 1.) vuId = 1. - vuId;\n    } else if (regId == 2.) {\n      if (vuId == 0. || vuId == 2.) vuId = 2. - vuId;\n    }\n    vuMode = int (vuId) + 1;\n  }\n  Setup ();\n  if (vuMode == 0) {\n    az = -0.4 * pi;\n    el = -0.1 * pi;\n  } else if (vuMode == 1) {\n    az = 0.;\n    el = 0.;\n  } else if (vuMode == 2) {\n    az = -0.5 * pi;\n    el = 0.;\n  } else if (vuMode == 3) {\n    az = 0.5 * pi;\n    el = 0.;\n  }\n  if (mPtr.z > 0.) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  if (vuMode == 0) {\n    zmFac = 3.5;\n  } else if (vuMode == 1) {\n    t = mod (pSpd * tCur / stExt + 0.25, 2.);\n    tt = mod (t, 1.);\n    ro.xy = stExt * vec2 (stLen, - stHt) * (1. - 2. * tt);\n    ro.y = clamp (ro.y, - stHt + 0.02, stHt - 0.02);\n    ro.z = 2. * stWid;\n    if (t > 1.) ro *= -1.;\n    ro.y += 2. - 0.05;\n    if (abs (ro.x) > stTurn) {\n      a = (ro.x - sign (ro.x) * stTurn) / (2. * stWid);\n      if (t > 1.) a = pi - a;\n      ro.xz = vec2 (stTurn * sign (ro.x), 0.) + Rot2D (vec2 (0., 2. * stWid), - a);\n    } else a = (t > 1.) ? pi : 0.;\n    az += a - 0.5 * pi;\n    el -= 0.8 * stAng * SmoothBump (0.3, 0.7, 0.05, tt) * sign (t - 1.);\n    zmFac = 2.;\n  } else if (vuMode == 2) {\n    ro = vec3 (8., -1., 0.);\n    zmFac = 1.5;\n  } else if (vuMode == 3) {\n    ro = vec3 (-8., 5., 0.);\n    zmFac = 1.5;\n  } \n  vuMat = StdVuMat (el, az);\n  if (vuMode == 0) ro = vuMat * vec3 (0., 0., -30.);\n  dstFar = 60.;\n  ltDir = vuMat * normalize (vec3 (0., 0.3, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = mix (col, vec3 (Maxv3 (col)), 0.2);\n  if (vuMode > 0) {\n    for (int k = 0; k < 2; k ++) {\n      if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n         col = vec3 (0.4, 0., 0.);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}