{
    "Shader": {
        "info": {
            "date": "1688048153",
            "description": "prism sdf",
            "flags": 0,
            "hasliked": 0,
            "id": "Dd2yRt",
            "likes": 1,
            "name": "[RMO] - prism",
            "published": 3,
            "tags": [
                "raymarch",
                "prism"
            ],
            "usePreview": 0,
            "username": "silica163",
            "viewed": 221
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fColor, in vec2 fCoord )\n{\n    vec2 uv = (2.*fCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 1.5;\n    vec2 m = vec2(time*.1,-abs(sin(time/40.)*1.));\n    m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 c = vec3(0);\n    \n    /*vec3 camera = vec3(m*PI*2.,2);\n    \n    vec3 ca = vec3(\n        atan(camera.z,camera.y),\n        PI/2.+atan(camera.x,camera.z),\n        0\n    );*/\n    // camera angle\n    vec3 ca = vec3(\n        PI/2.+m.y*PI/1.5,\n        PI/2.-m.x*PI/1.,\n        0\n    );\n    \n    float camz = PI;\n    vec3 camera = vec3(0,0,camz)*rotX(ca.x)*rotY(ca.y);\n    vec3 plane = vec3(uv,1)*rotX(ca.x)*rotY(ca.y);\n    \n    Ray r = initRay(camera,plane);\n    \n    pr[0].p = vec3(0.);\n    pr[0].s = vec3(.2,1,6);\n    \n    //l[0].p = vec3(2,2,2);//*rotX(ca.x)*rotY(ca.y);\n    l[0].p = vec3(-2,2,2)*rotX(ca.x)*rotY(ca.y);\n    \n    march(r,0);\n    N = sNormal(r.p);\n    \n    //c = N*.5+.5;\n    //c = r.p;\n    c += render(r); \n    fColor = vec4(c,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define time iTime\n#define resolution iResolution\n#define mouse iMouse.xy\n#define PI 3.14159265\n#define MAX_DIST  100.\n#define MIN_DIST  .001\n#define MAX_STEP  256\n#define MAX_REF   2\n\n#define rotX(a) mat3(      1, 0,       0, 0, sin(a), cos(a),      0,- cos(a), sin(a))\n#define rotY(a) mat3( sin(a), 0, -cos(a), 0,      1,      0, cos(a),       0, sin(a))\n#define rotZ(a) mat3( sin(a), 0, -cos(a), 0,      1,      0, cos(a),       0, sin(a))\n#define rot2D(a) mat2(sin(a),cos(a),-cos(a),sin(a))\n\nconst int LIGHTS = 1;\nconst int PRISM = 1;\n\nstruct Ray {\n\tvec3 o;\n\tvec3 p;\n\tvec3 dir;\n\tvec3 c;\n\tfloat dist;\n    float rl;\n};\n\nstruct Light {\n\tvec3 p;\n\tvec3 c;\n    vec3 L;\n},l[LIGHTS];\n\nvec3 N = vec3(0);\nvec3 V = vec3(0);\n\nstruct Prism {\n    vec3 p;\n    vec3 s;\n    vec3 c;\n},pr[PRISM];\n\nfloat polygon(vec2 uv,vec2 p,float r,float n){\n    uv = uv - p;\n    n = floor(n);\n    float pa = PI-atan(uv.x,uv.y);      // position angle\n    float sa = 2.*PI/n;                 // side angle\n    float id = (pa - mod(pa,sa)) / sa ;\n    float ra = id * (sa) + sa/2.;       // rotate angle\n    float ir = cos(sa/2.)*r;            // inner radius\n    float sl = sin(sa/2.)*r;            // half side length\n    \n    uv = rot2D(ra)*uv;\n    uv += vec2(-ir,0);\n    \n    if(uv.x < 0.)return uv.x;\n    \n    return length(vec2(uv.x,uv.y - clamp(uv.y,-sl,sl)));\n}\n\nfloat prismSDF(vec3 p,int id){\n    vec2 d = vec2(0);\n    Prism ps = pr[id];\n    vec3 cp = p - ps.p;\n    \n    d = vec2(abs(cp.y)-ps.s.x,polygon(cp.xz,vec2(0),ps.s.y,ps.s.z)-.05) * vec2(.5,1);\n    \n    return min(max(d.y,d.x),0.) + length(max(d,0.));\n}\n\nfloat dist(vec3 p){\n\tfloat d = 0.;\n    \n    d = prismSDF(p,0)-.05;\n    \n\treturn d;\n}\n\nfloat lightDist(vec3 p,float d){\n    for(int i = 0;i<LIGHTS;i++)\n        d = min(d,length(p - l[i].p)-.1);\n\treturn d;\n}\n\nvoid march(inout Ray r,int t){\n\tfor(int i = 0;i<MAX_STEP;i++){\n\t\tr.p = r.o + r.dist*r.dir;\n\t\tfloat d = dist(r.p);\n\t\td = t == 0 ? d : min(d,lightDist(r.p,d));\n\t\tif(d <= MIN_DIST || d > MAX_DIST)break;\n\t\tr.dist += d;\n\t}\n    r.rl += r.dist;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(.001,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat diffuse(vec3 p,vec3 L){\n\treturn max(dot(sNormal(p),normalize(L)),0.);\n}\n\nvoid lNormal(inout Light l,Ray r){\n\tl.L = normalize(l.p-r.p);\n}\n\nvec3 render(Ray r){\n    vec3 c = vec3(0);\n    N = sNormal(r.p);\n    for( int i = 0;i< LIGHTS;i++){\n        lNormal(l[i],r);\n        c += diffuse(r.p,l[i].L);\n    }\n    c *= .5+.5*N;\n    \n    if(r.dist > MAX_DIST)c = vec3(.1);\n    return c;\n}\n\nRay initRay(vec3 c,vec3 p){\n    // c camera\n    // p projection plane\n    Ray r;\n    r.o = c;\n    r.p = r.o;\n    r.dir = normalize(p-c);\n    r.c = vec3(0);\n    r.dist = 0.;\n    r.rl = 0.;\n    return r;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}