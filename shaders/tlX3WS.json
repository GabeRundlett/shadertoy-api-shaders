{
    "Shader": {
        "info": {
            "date": "1557598014",
            "description": "Shaderization of https://www.instagram.com/p/BxJmvadl4Ht/\nTry changing the branch count at line 6.\n\nIf someone has a good idea for the elbow() I'm interested, because the turn is not so perfect",
            "flags": 0,
            "hasliked": 0,
            "id": "tlX3WS",
            "likes": 20,
            "name": "Erell at Oberkampf",
            "published": 3,
            "tags": [
                "2d",
                "streetart"
            ],
            "usePreview": 0,
            "username": "eliemichel",
            "viewed": 657
        },
        "renderpass": [
            {
                "code": "// \"Erell at Oberkampf\"\n// Copyright (c) May 2019 - Alt144 (Elie Michel)\n// License: CC 3.0 BY - Please notify me when using it\n\n// Parameters\nconst float branches = 3.;\n\n#define PI 3.14159265\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(vec2 co) {\n    vec2 q = floor(co);\n    vec2 r = co - q;\n    r = r * r * (3. - 2. * r);\n    vec2 e = vec2(0.,1.);\n    return mix(\n    \tmix(rand(q + e.xx), rand(q + e.yx), r.x),\n        mix(rand(q + e.xy), rand(q + e.yy), r.x),\n        r.y);\n}\n\nmat2 rot(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c, s, -s, c);\n}\n\n\nvec2 moda(vec2 uv, float n, out float idx) {\n    float a = atan(-uv.y, -uv.x) + PI;\n    float r = 2.*PI/n;\n    idx = floor(a/r);\n    a = mod(a, r);\n    return vec2(cos(a), sin(a)) * length(uv);\n}\n\nvec2 elbow90(vec2 uv) {\n    vec2 tuv = vec2(-uv.y+.295, uv.x);;\n    float a = atan(uv.x, uv.y);\n    vec2 ruv = vec2(2.*PI*a*.03, length(uv));\n    return mix(tuv, mix(uv, ruv, step(0., uv.x)), step(0., uv.y));\n}\n\nvec2 elbow(vec2 uv, float angle) {\n    vec2 tuv = rot(angle) * uv;\n    vec2 thuv = rot(angle/2.) * uv;\n    \n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    vec2 ruv = vec2(2.*PI*a*.03, length(uv));\n    \n    vec2 toff = vec2(+.19 * angle, 0.);\n    return mix(mix(uv, ruv, step(0., uv.x)), mix(tuv + toff, ruv, step(tuv.x, 0.)), step(0., thuv.x));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k - abs(b - a))/k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\nfloat gate(float a, float b, float t) {\n    return max(a-t, t-b);\n}\n\nfloat sinstep(float x)\n{\n    return (1. - cos(PI * x)) * .5;\n}\n\nvec4 worm5(vec2 uv, float len) {\n    vec2 uv0 = uv;\n    uv.x = -abs(uv.x - len/2.) + len/2.; // symmetry\n    float head = length(uv*2.-1.) - 1.;\n    float h = gate(.5, len-.5, uv.x);\n    float v = gate(.0, 1., uv.y);\n    float d = max(h, v);\n    d = min(d, head*.5);\n    vec3 color = vec3(1.-pow(sinstep(smoothstep(.5, len, uv0.x)), 1.));\n    color *= vec3(.9,.92,.95);\n    return vec4(color, d);\n}\n\nfloat fill(float d) {\n    return smoothstep(.05, .0, d);\n}\n\nvec4 straitWorms(vec2 uv, float len, vec2 m, float n) {\n    float margin = m.x;\n    float ymargin = m.y;\n    uv.y += ymargin*.3*.5;\n    vec2 udx = vec2(1., floor(uv.y/.3/(1.+ymargin)));\n    uv.x += udx.y*.7;\n    float way = (fract(udx.y/2.)*2.-.5);\n    uv.x += iTime * way;\n    uv.x *= way*2.;\n    vec2 guv = vec2(fract(uv.x * 3./(len+margin))*(len+margin)-margin*.5,fract(uv.y/.3/(1.+ymargin))*(1.+ymargin)-ymargin*.5);\n    vec4 w = worm5(guv, len);\n    //w.rgb *= vec3(1.,0.5,0.);\n    w.a = max(w.a, gate(.0, .3*n, -uv.y/(1.+ymargin))*5.);\n    return w;\n}\n\nvec4 secondElbowWorms(vec2 uv, float angle, float len, float margin) {\n    uv += rot(angle*.5)*vec2(.39/sin(angle*.5),.0);\n    uv += rot(angle)*vec2(.96/sin(angle),.0);\n    vec2 euv = elbow(uv, PI-angle);\n    euv.x += iTime;\n    vec2 guv = vec2(fract(euv.x * 3./(len+margin))*(len+margin)-margin*.5,euv.y/.3);\n    vec4 w = worm5(guv, len);\n    return w;\n}\n\nvec4 compOver(vec4 under, vec4 over) {\n    under.rgb = mix(under.rgb, over.rgb, fill(over.a));\n    return under;\n}\n\nvec4 compAdd(vec4 under, vec4 over) {\n    under.rgb += mix(vec3(0.), over.rgb, fill(over.a));\n    return under;\n}\n\nvec4 line(vec2 uv, float angle, float d3, float margin) {\n    vec2 diag = rot(PI-angle)*uv;\n    float mdiag = (diag.y+margin*d3)*3.;\n    vec4 w;\n    w.rgb = vec3(.8,.6,.2);\n    w.a = gate(margin*d3,margin*d3*2.,-uv.y)*5.;\n    w.a = max(w.a, mdiag*2.)*1.5;\n    return w;\n}\n\nfloat sat(float x) { return clamp(x, 0.,1.); }\n\nfloat select(float id, float target) {\n    return sat(1.-abs(id-target));\n}\n\nvec4 hex(vec2 uv)\n{\n    float odd = floor(uv.x*2.);\n    float cid = floor(uv.x*2.+.5);\n    uv.y += odd*sqrt(3.)/2.;\n    uv.x = fract(uv.x*2.)*.5;\n    \n    vec2 uv2 = 2./3. * rot(PI/3.) * uv;\n    vec2 uv3 = 2./3. * rot(PI/3.) * (vec2(-1., 1.) * uv + vec2(0., sqrt(3.)/3.));\n    float gx = floor(uv2.x*2.);\n    vec2 udx = vec2(floor(fract(uv2.x)*3.), floor(fract(uv3.x)*3.));\n    float h = sat(udx.x - udx.y);\n    float s2 = dot(mix(vec2(3., -1.), vec2(2., 1.), h), vec2(1., (udx.x + udx.y)));\n    vec2 nuv = uv*sqrt(3.)/3.*2.;\n    float sl = -1./sqrt(3.) * (select(udx.y, 1.)*2.-1.);\n    nuv.y = fract(nuv.y+1./3.+.5+nuv.x*sl-sl*.5/sqrt(3.))-nuv.x*sl-.5+sl/3.45; // 3.45 is magick :/\n    nuv.x = mix(-sqrt(3.)/3.+nuv.x, nuv.x, h);\n    \n    nuv = rot(s2*PI/3.+PI/6.) * nuv;\n    return vec4(nuv, s2, cid);\n}\n\nfloat patternD8(vec2 uv) {\n    float r1 = perlin(uv*1.+iTime);\n    float r3 = (perlin(uv*1.+iTime*.1+r1) + perlin(uv*1.+vec2(-2.*iTime, 0.)))*.5;\n    \n    vec4 huv = hex(uv);\n    uv = huv.xy;\n    \n    float r2 = rand(huv.ww);\n    float circles = length((uv-vec2(.0,-.33))*vec2(1.2,1.))-mix(.02, .04, mod(huv.z,2.)) * mix(1.,3.,r1);\n    float center = length(uv)-mix(.04, .06, r2);\n    float lines = max((abs(fract(uv.x*6.)-.5)-.2)*2.5, abs(uv.y+.6)-.03 * mix(5.,.5,r3));\n    \n    float d = min(circles*2., center*2.);\n    d = min(d, lines);\n    \n    return d*2.;\n}\n\n\nfloat pattern1(vec2 uv) {\n    //return fill(patternD4(uv)) + fill(patternD4(uv)+.5)*.5;\n    return fill(patternD8(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 uv0 = uv;\n    \n    float angle = 2.*PI/branches;\n    float d3 = .3;\n    \n    // Frame\n    float zoom = 5.;\n    float ratio = iResolution.y/iResolution.x;\n    float z = step(ratio, uv.x);\n    uv -= vec2(-ratio*.5-.2,.2);\n    uv *= 1.6;\n    uv = rot(angle*.25) * uv;\n    \n    vec2 closeup = uv / zoom;\n    closeup -= vec2(.1,0.);\n    \n    uv = mix(uv, closeup, z);\n    zoom = mix(1., zoom, z);\n    vec4 zm = vec4(1.,1.,1.,zoom);\n    vec2 fuv = uv;\n    \n    float ridx = 0.;\n    uv = moda(uv, branches, ridx);\n    uv.xy = -uv.xy;\n    \n    float isFirst = sat(1. - mod(ridx, 3.));\n    float isSecond = sat(1. - abs(mod(ridx, 3.) - 1.));\n    float isThird = sat(1. - abs(mod(ridx, 3.) - 2.));\n    \n    mat2 mat = rot(PI-angle);\n    uv += rot(angle*.5)*vec2(.35/sin(angle*.5),.0);\n    vec2 euv = elbow(uv, PI-angle);\n    \n    // Symmetry\n    vec2 vy = rot(angle*.5)*vec2(0.,1.);\n    uv = mix(uv, uv - 2.*dot(uv, vy)*vy, isThird);\n    \n    float pattern = -patternD8(fuv*20.)/20.*zoom+.02*zoom;\n    \n    float mlen = 4.;\n    float margin = .3;\n    euv.x += iTime*.4;\n    vec2 guv = vec2(fract(euv.x * 3./(mlen+margin))*(mlen+margin)-margin*.5,euv.y/.3);\n    vec4 w = worm5(guv, mlen);\n    w.rgb = pow(w.rgb, vec3(mix(2., .5, fill(pattern))));\n    \n    vec4 col = vec4(.01, .01, .03, 1.0);\n    col = compAdd(col, w * zm);\n    \n    w = straitWorms(uv+vec2(.0,mix(0.,margin*d3*2., isThird)), mlen, vec2(margin), 2.);\n    vec2 diag = rot(PI-angle)*uv;\n    float mdiag = (diag.y+margin*d3)*3.;\n    w.rgb *= mix(vec3(1.), vec3(.7,.75,.88), smoothstep(-.7, 0., mdiag));\n    w.rgb = mix(w.rgb, vec3(.0), smoothstep(-.3, 0., mdiag));\n    w.rgb = pow(w.rgb, vec3(mix(2., .5, fill(pattern))));\n    w.a = max(w.a, mdiag);\n    col = compAdd(col, w * zm);\n    \n    w = secondElbowWorms(uv+vec2(.21,.0), angle, mlen, margin);\n    w.a = mix(1., w.a, isThird);\n    w.rgb = pow(w.rgb, vec3(mix(2., .5, fill(pattern))));\n    col = compAdd(col, w * zm);\n    \n    vec2 uv2 = uv;\n    uv2 += mix(vec2(0.), rot(angle)*vec2(.8/sin(angle),.0), isSecond);\n    w = line(uv2, angle, d3, margin);\n    w.a = mix(w.a, 1., isFirst);\n    w.rgb = pow(w.rgb, vec3(mix(1.5, 0.8, fill(pattern+.03))));\n    col = compOver(col, w * zm);\n    \n    uv2 = uv;\n    uv2 = uv2 - 2.*dot(uv2, vy)*vy;\n    uv2.x += 1.11;\n    w = line(uv2, angle, d3, margin);\n    w.a = mix(1., w.a, isThird);\n    w.rgb = pow(w.rgb, vec3(mix(1.5, 0.8, fill(pattern+.03))));\n    col = compAdd(col, w * zm);\n    \n    col = mix(col, vec4(1.), step(ratio, uv0.x)*step(uv0.x, ratio + .04));\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}