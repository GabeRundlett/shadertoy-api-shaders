{
    "Shader": {
        "info": {
            "date": "1551438526",
            "description": "Click ring for new maze; click in small view to switch views; rider height alternates above / below walls; algorithm from \"Maze Solver\".",
            "flags": 32,
            "hasliked": 0,
            "id": "3dsSD7",
            "likes": 17,
            "name": "Maze Trip",
            "published": 3,
            "tags": [
                "maze"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 521
        },
        "renderpass": [
            {
                "code": "// \"Maze Trip\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\n\n#define MAX_CAP 10\n\nvec3 ltDir, qHit, qnHit, bSize;\nvec2 gSize, cEn, cEx, cPos[MAX_CAP], cDir[MAX_CAP];\nfloat dstFar, tCur, nStep, growLim, pathLen, hiRide;\nint idObj, idCap, nCap;\nbool isVis[MAX_CAP];\nconst float pi = 3.14159;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p : vec2 (- p.y, p.x)) :\n     ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat ValMaze (vec2 p)\n{\n  vec2 ut, e;\n  float dw, s;\n  ut = p * gSize;\n  s = Loadv4 (floor (ut)).x;\n  dw = WallDst (ut, s);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (ut) - e).x == ai) dw = min (dw, WallDst (ut, mod (ai + 2., 4.)));\n  }\n  return dw;\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, b;\n  vec2 s;\n  float dMin, d;\n  dMin = dstFar;\n  b = bSize;\n  b.xz *= (1. - 0.9 / gSize);\n  q = p;\n  d = SmoothMax (ValMaze (0.5 * q.xz / bSize.xz + 0.5) - 0.13, abs (q.y - 0.3) - 0.2, 0.05);\n  d = min (d, abs (q.y - 0.1) - 0.01);\n  d = 0.7 * max (d, length (max (abs (q.xz) - b.xz, 0.)) - 0.05);\n  DMIN (1);\n  s = bSize.xz - vec2 (0.4, 4. * bSize.z / gSize.y);\n  q = p;\n  q -= vec3 (s.x, 0.3, s.y);\n  d = max (PrRoundCylDf (q.yzx, 0.42, 0.1, 0.2), 0.34 - length (q.yz));\n  DMIN (2);\n  q = p;\n  q -= vec3 (- s.x, 0.3, - s.y);\n  d = max (PrRoundCylDf (q.yzx, 0.42, 0.1, 0.2), 0.34 - length (q.yz));\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, sMin;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      sMin = s;\n      qnHit = vec3 (s.xy, 0.);\n    } else {\n      drz = - len * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          s = ro + d * rd;\n          dMin = d;\n          sMin = s;\n          sMin.z -= drz;\n          qnHit = s;\n        }\n      }        \n    }\n  }\n  return vec4 (sMin, dMin);\n}\n\nfloat AllCapsHit (vec3 ro, vec3 rd)\n{\n  vec4 ds;\n  vec3 rom, rdm, qHitM, qnHitM;\n  float dMin;\n  dMin = dstFar;\n  for (int k = 0; k < MAX_CAP; k ++) {\n    if (k == nCap) break;\n    if (isVis[k] && (hiRide > 0. || k > 0)) {\n      rom = ro;\n      rom.xz = Rot2Cs (rom.xz - cPos[k] - vec2 (1.) + bSize.xz, cDir[k]);\n      rom.y -= 0.28;\n      rdm = rd;\n      rdm.xz = Rot2Cs (rdm.xz, cDir[k]);\n      ds = CapsHit (rom.zyx, rdm.zyx, 0.15, 0.3);\n      if (ds.w < dMin) {\n        dMin = ds.w;\n        idCap = k;\n        qHitM = ds.xyz;\n        qnHitM = qnHit;\n        qnHitM.xz = Rot2Cs (qnHitM.xz, - cDir[k]);\n      }\n    }\n  }\n  qHit = qHitM.zyx;\n  qnHit = normalize (qnHitM).zyx;\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, cb;\n  vec3 col, vn;\n  vec2 ut, utg, utt, e, ee, h, vf;\n  float dstObj, dstCap, nw, fPair, s;\n  dstObj = ObjRay (ro, rd);\n  if (nStep > 6. * growLim || pathLen > 0.) dstCap = AllCapsHit (ro, rd);\n  else dstCap = dstFar;\n  if (min (dstCap, dstObj) < dstFar) {\n    if (dstObj < dstCap) {\n      vf = vec2 (0.);\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        if (ro.y > 0.) {\n          ut = 0.5 * (ro.xz / bSize.xz + 1.);\n          utg = gSize * ut;\n          if (ro.y < 0.12) {\n            col4 = vec4 (0.3, 0.5, 0.1, 0.05) * (0.7 + 0.3 * smoothstep (0.13, 0.23, ValMaze (ut)));\n            h = abs (utg - (cEn + vec2 (1.) - vec2 (0.7, 0.)));\n            if (max (h.x, h.y) < 0.3) col4 = vec4 (0.7, 0.7, 0.5, 0.);\n            h = abs (utg - (cEx + vec2 (1.) + vec2 (0.7, 0.)));\n            if (max (h.x, h.y) < 0.3) col4 = vec4 (0.7, 0.7, 0.5, 0.);\n            col4 *= 0.8 + 0.2 * Fbm2 (64. * ro.xz);\n          } else {\n            col4 = vec4 (0.7, 0.7, 0.5, 0.05);\n            s = 1. - SmoothBump (0.05, 0.08, 0.01, abs (abs (ro.y - 0.31) - 0.15));\n            if (abs (ro.y - 0.31) < 0.1) s = min (s,\n               min (SmoothBump (0.07, 0.93, 0.02, mod (4. * utg.x, 1.)),\n               SmoothBump (0.07, 0.93, 0.02, mod (4. * utg.y, 1.))));\n            col4.rgb *= 0.7 + 0.3 * s;\n            vf = vec2 (32., 0.3 + 0.7 * s);\n          }\n          if (nStep > 6. * growLim || pathLen > 0.) {\n            nw = Loadv4 (floor (mod (utg - 0.5, gSize))).y;\n            utt = fract (utg + 0.5) - 0.5;\n            cb = mod (floor (nw / vec4 (1., 2., 4., 8.)), 2.);\n            if      (cb.x * cb.z > 0.) fPair = 0.;\n            else if (cb.y * cb.w > 0.) fPair = 1.;\n            else if (cb.x * cb.y > 0.) fPair = 2.;\n            else if (cb.y * cb.z > 0.) fPair = 3.;\n            else if (cb.z * cb.w > 0.) fPair = 4.;\n            else if (cb.w * cb.x > 0.) fPair = 5.;\n            if      (fPair == 0.) s = utt.x;\n            else if (fPair == 1.) s = utt.y;\n            else {\n              e = vec2 (0.5, -0.5);\n              if      (fPair == 2.) ee = e.xx;\n              else if (fPair == 3.) ee = e.xy;\n              else if (fPair == 4.) ee = e.yy;\n              else if (fPair == 5.) ee = e.yx;\n              utt -= ee;\n              s = length (utt) - 0.5;\n            }\n            if (nw >= 32. && ro.y < 0.12) {\n              s = smoothstep (0.02, 0.025, abs (abs (s) - 0.1));\n              col4.rgb = mix (vec3 (0.7, 0.7, 0.8), col4.rgb, s);\n              vf = vec2 (64., 0.1 + 0.4 * s);\n              for (int k = 0; k < MAX_CAP; k ++) {\n                if (k == nCap) break;\n                if (isVis[k]) {\n                  utt = Rot2Cs (utg - cPos[k] - vec2 (1.), cDir[k]).yx;\n                  col4.rgb *= 0.7 + 0.3 * smoothstep (0., 0.1,\n                     length (utt - vec2 (0., clamp (utt.y, - 0.3, 0.3))) - 0.15);\n                }\n              }\n            }\n          }\n        } else col4 = vec4 (0.);\n      } else if (idObj == 2) {\n        col4 = vec4 (0.7, 0.7, 0.5, 0.05);\n        vf = vec2 (32., 0.3);\n      }\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    } else if (dstCap < dstFar) {\n      vn = qnHit;\n      if (abs (qHit.x) > 0.3) col4 = (qHit.x > 0.) ? vec4 (0.3, 1., 0.3, 0.2) :\n         vec4 (1., 0.3, 0.3, 0.2);\n      else col4 = vec4 (1., 1., 0.3, 0.2);\n      if (idCap == 0) col4 = mix (vec4 (0.3, 0.3, 1., 0.2), col4,\n         smoothstep (0.02, 0.04, abs (qHit.z)));\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) +\n       0.7 * max (dot (vn, ltDir), 0.)) + col4.a * pow (max (dot (normalize (ltDir - rd),\n       vn), 0.), 64.);\n  } else {\n    col = vec3 (0.8, 0.8, 1.) * (0.4 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col, wgBxC;\n  vec2 canvas, uv, ori, ca, sa, mMid, ut, mSize, ms;\n  float asp, sr, az, el, zmFac, vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  gSize = Loadv4 (vec2 (0., 0.)).zw;\n  cEn = Loadv4 (vec2 (1., 0.)).zw;\n  cEx = Loadv4 (vec2 (2., 0.)).zw;\n  stDat.zw = Loadv4 (vec2 (3., 0.)).zw;\n  growLim = stDat.z;\n  pathLen = stDat.w;\n  stDat.zw = Loadv4 (vec2 (4., 0.)).zw;\n  nStep = stDat.z;\n  nCap = int (stDat.w);\n  for (int k = 0; k < MAX_CAP; k ++) {\n    if (k == nCap) break;\n    cPos[k] = Loadv4 (vec2 (2. * float (k), 1.)).zw;\n    cDir[k] = Loadv4 (vec2 (2. * float (k) + 1., 1.)).zw;\n    isVis[k] = (pathLen > 0. && length (cDir[k]) < 1.001);\n  }\n  bSize = vec3 (0.5 * gSize.x, 0.15, 0.5 * gSize.y);\n  mPtr = vec4 (Loadv4 (vec2 (5., 0.)).zw, Loadv4 (vec2 (6., 0.)).z, 0.);\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (- asp + mSize.x, 1. - mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuId = 0.;\n  if (pathLen > 0. && max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1. - vuId;\n  }\n  regId = 0.;\n  if (mPtr.z > 0.) {\n    ms = vec2 ((0.5 + mPtr.x) * asp, 0.5 - mPtr.y) - mSize;\n    if (max (ms.x, ms.y) < 0.) regId = 1.;\n    if (regId == 1.) vuId = 1. - vuId;\n  }\n  hiRide = Loadv4 (vec2 (6., 0.)).w;\n  if (pathLen > 0. && vuId == 0.) {\n    ro.xz = cPos[0] + vec2 (1.) - bSize.xz;\n    ro.y = hiRide > 0. ? 1.05 : 0.35;\n    ro.xz += 0.001 * length (bSize.xz);\n    az = -0.5 * pi - atan (cDir[0].y, - cDir[0].x);\n    el = hiRide > 0. ? -0.16 * pi : 0.;\n    if (regId == 0. && mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += 0.3 * pi * mPtr.y;\n    }\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    zmFac = 1.6;\n  } else {\n    az = 0.;\n    el = -0.5 * pi;\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    ro = vuMat * vec3 (0.001, 0., -4.) * length (bSize.xz);\n    zmFac = 5.5;\n  }\n  dstFar = 80.;\n  ltDir = normalize (vec3 (-1., 3., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (vuId == 0. && regId == 0.) {\n    wgBxC = vec3 (0.48 * asp, 0.46, 0.022);\n    if (abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y < 2.) col = vec3 (1., 1., 0.7);\n    if (mPtr.z > 0. && max (abs (uv.x), abs (uv.y)) < 0.03 && min (abs (uv.x), abs (uv.y)) < 0.003)\n       col = vec3 (0.8, 0.8, 0.1);\n  }\n  if (pathLen > 0. && max (ut.x, ut.y) < 0.) {\n    if (min (abs (ut.x), abs (ut.y)) * canvas.y < 2.) col = vec3 (0.2, 0.2, 0.1);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Maze Trip\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\n#define MAX_GSIZE  16.\n#define MAX_CAP    10\n\nvec2 gSize;\nint nCap;\nconst float pi = 3.14159;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p : vec2 (- p.y, p.x)) :\n     ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat ValMaze (vec2 p)\n{\n  vec2 e;\n  float dw, s;\n  s = Loadv4 (floor (p)).x;\n  dw = WallDst (p, (s >= 0.) ? s : -1.);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (p) - e).x == ai) dw = min (dw, WallDst (p, mod (ai + 2., 4.)));\n  }\n  return dw;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, fVal, cb, cbi, cbf;\n  vec3 wgBxC;\n  vec2 canvas, iFrag, um, ud, cPos[MAX_CAP], cDir[MAX_CAP], ev[4], cEn, cEx, p, p1, p2,\n     s1, s2;\n  float tCur, nStep, growLim, ai, ar, nw, nwn, nb, dir, asp, pathLen, t, ti, spd,\n     nCyc, pWait, hiRide;\n  int kIn;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = vec2 (MAX_GSIZE);\n  if (fragCoord.x >= max (gSize.x, 2. * float (MAX_CAP)) || fragCoord.y >= gSize.y) discard;\n  asp = canvas.x / canvas.y;\n  init = (iFrame <= 5);\n  wgBxC = vec3 (0.48 * asp, 0.46, 0.022);\n  mPtrP.z = Loadv4 (vec2 (6., 0.)).z;\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) < wgBxC.z) {\n      if (mPtrP.z <= 0.) init = true;\n    }\n  }\n  iFrag = floor (fragCoord);\n  fVal = Loadv4 (iFrag);\n  ev[0] = vec2 (0., 1.);\n  ev[1] = vec2 (1., 0.);\n  ev[2] = vec2 (0., -1.);\n  ev[3] = vec2 (-1., 0.);\n  cbf = vec4 (1., 2., 4., 8.);\n  if (! init) {\n    nStep = Loadv4 (vec2 (4., 0.)).z;\n    init = (mod (nStep + 1., 18000.) == 0.);\n  }\n  if (init) {\n    mPtrP = mPtr;\n    nStep = 0.;\n    nCap = 0;\n    pathLen = 0.;\n    growLim = floor (1.7 * max (gSize.x, gSize.y));\n    ar = -1.;\n    cEn = vec2 (0., 1.);\n    cEx = gSize - 2. - vec2 (0., 1.);\n    hiRide = 1.;\n    if (iFrag.y == 0. && iFrag.x < gSize.x - 1.) ar = 1.;\n    else if (iFrag.x == gSize.x - 1. && iFrag.y < gSize.y - 1.) ar = 0.;\n    else if (iFrag.y == gSize.y - 1. && iFrag.x > 0.) ar = 3.;\n    else if (iFrag.x == 0. && iFrag.y > 0.) ar = 2.;\n    if (iFrag.x == cEn.x && iFrag.y > cEn.y) ar = 0.;\n    else if (iFrag.x > cEx.x && iFrag.y <= cEx.y) ar = 2.;\n    if (iFrag.y > 0. && iFrag.y < gSize.y - 1.) {\n      if (Hashff (tCur + 111.1) > 0.5 && iFrag.x == floor (gSize.x / 4.)) ar = 2.;\n      if (Hashff (tCur + 211.1) > 0.5 && iFrag.x == floor (3. * gSize.x / 4.)) ar = 0.;\n    }\n    fVal.x = ar;\n  } else {\n    cEn = Loadv4 (vec2 (1., 0.)).zw;\n    cEx = Loadv4 (vec2 (2., 0.)).zw;\n    stDat.zw = Loadv4 (vec2 (3., 0.)).zw;\n    growLim = stDat.z;\n    pathLen = stDat.w;\n    nCap = int (Loadv4 (vec2 (4., 0.)).w);\n    hiRide = Loadv4 (vec2 (6., 0.)).w;\n    ++ nStep;\n    ar = fVal.x;\n    if (nStep < growLim && ar < 0.) {\n      ai = floor (4. * Hashfv2 (iFrag + tCur));\n      if (Hashfv2 (iFrag + tCur + 11.1) > 0.3) {\n        if (iFrag.y == 1.) {\n          if (ai == 2.) ai = 0.;\n        } else if (iFrag.y == gSize.y - 2.) {\n          if (ai == 0.) ai = 2.;\n        } else if (iFrag.x == 1.) {\n          if (ai == 3.) ai = 1.;\n        } else if (iFrag.x == gSize.x - 2.) {\n          if (ai == 1.) ai = 3.;\n        }\n      }\n      if (Loadv4 (iFrag + ((ai < 2.) ? ((ai == 0.) ? ev[0] : ev[1]) :\n         ((ai == 2.) ? ev[2] : ev[3]))).x >= 0.) ar = ai;\n    }\n    fVal.x = ar;\n    if (nStep < growLim) fVal.y = (iFrag.x <= gSize.x - 2. && iFrag.y <= gSize.y - 2.) ? -1. : 0.;\n    if (nStep > 2. * growLim) pathLen = floor (Loadv4 (cEx).y / 32.);\n    if (iFrag.x <= gSize.x - 2. && iFrag.y <= gSize.y - 2.) {\n      cb = vec4 (0.);\n      ar = Loadv4 (iFrag).x;\n      cb.wz += vec2 ((ar == 0.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[0]).x;\n      cb.wx += vec2 ((ar == 2.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + vec2 (1., 1.)).x;\n      cb.yx += vec2 ((ar == 2.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[1]).x;\n      cb.yz += vec2 ((ar == 0.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      nw = fVal.y;\n      if (nStep == growLim) {\n        nw = dot (cb, vec4 (1.));\n      } else if (nStep > growLim && nStep < 2. * growLim) {\n        if (nw < 3.) {\n          nb = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y >= 3.) ++ nb;\n          if (nw + nb == 3.) nw = 4.;\n        } else nw = 4.;\n      } else if (nStep == 2. * growLim) {\n        if (nw < 3.) {\n          nw = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y < 3.) nw += cbf[k];\n        } else nw = 0.;\n      } else if (nStep > 2. * growLim && nStep < 6. * growLim && pathLen == 0.) {\n        if (nw > 0. && nw < 32.) {\n          dir = 0.;\n          cbi = 1. / cbf;\n          cb = mod (floor (nw * cbi), 2.);\n          if (iFrag.x == cEn.x && iFrag.y == cEn.y) {\n            if (cb[2] > 0.) dir = 1.;\n            nw += 32. * 1.;\n          } else {\n            cbi = cbi.zwxy;\n            for (int k = 0; k < 4; k ++) {\n              if (nw < 32. && cb[k] > 0.) {\n                nwn = Loadv4 (mod (iFrag + ev[k], gSize)).y;\n                if ((nwn - 32.) * mod (floor (nwn * cbi[k]), 2.) > 0.) {\n                  nw += 32. * (floor (nwn / 32.) + 1.);\n                  kIn = k;\n                  break;\n                }\n              }\n            }\n            if (kIn == 0) {\n              if (cb[2] > 0. || cb[3] > 0.) dir = 1.;\n            } else if (kIn == 1) {\n              if (cb[3] > 0. || cb[0] > 0.) dir = 1.;\n            } else if (kIn == 2) {\n              if (cb[1] > 0.) dir = 1.;\n            } else if (kIn == 3) {\n              if (cb[2] > 0.) dir = 1.;\n            }\n          }\n          nw += 16. * (dir - mod (floor (nw / 16.), 2.));\n        }\n      }\n      fVal.y = nw;\n    }\n    if (nStep > 6. * growLim || pathLen > 0.) {\n      if (nCap == 0) nCap = int (clamp (6. * pathLen / dot (gSize, vec2 (1.)), 6., float (MAX_CAP)));\n      spd = 0.01;\n      pWait = 0.6;\n      nCyc = floor (spd * nStep / (pathLen + pWait));\n      hiRide = mod (nCyc + 1., 2.);\n      for (int k = 0; k < MAX_CAP; k ++) {\n        if (k == nCap) break;\n        t = spd * nStep + (pathLen + pWait) * float (k) / float (nCap); \n        t = mod (t, pathLen + pWait) + 1.;\n        cDir[k] = vec2 (99.);\n        ti = floor (t);\n        if (ti >= 1. && ti <= pathLen) {\n          p1 = cEn + vec2 (-1., 0.);\n          p2 = cEx + vec2 (1., 0.);\n          for (float iy = 0.; iy < MAX_GSIZE; iy ++) {\n            if (iy == gSize.y - 1.) break;\n            for (float ix = 0.; ix < MAX_GSIZE; ix ++) {\n              if (ix == gSize.x - 1.) break;\n              nw = floor (Loadv4 (vec2 (ix, iy)).y / 32.);\n              if (nw == ti) p = vec2 (ix, iy);\n              else if (ti > 1. && nw == ti - 1.) p1 = vec2 (ix, iy);\n              else if (ti < pathLen && nw == ti + 1.) p2 = vec2 (ix, iy);\n            }\n          }\n          s1 = mix (p1, p, t - ti);\n          s2 = mix (p, p2, t - ti);\n          cPos[k] = 0.5 * (s1 + s2);\n          cDir[k] = vec2 (1., -1.) * normalize (s2 - s1);\n        } else if (t - 1. < pathLen + 0.5 * pWait) {\n          cPos[k] = cEx + vec2 (0.5, 0.);\n          cDir[k] = vec2 (1., 0.);\n        } else {\n          cPos[k] = cEn - vec2 (0.5, 0.);\n          cDir[k] = vec2 (1., 0.);\n          if (k == 0) hiRide = 1. - hiRide;\n        }\n      }\n    }\n  }\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) fVal.zw = gSize;\n    else if (iFrag.x == 1.) fVal.zw = cEn;\n    else if (iFrag.x == 2.) fVal.zw = cEx;\n    else if (iFrag.x == 3.) fVal.zw = vec2 (growLim, pathLen);\n    else if (iFrag.x == 4.) fVal.zw = vec2 (nStep, nCap);\n    else if (iFrag.x == 5.) fVal.zw = mPtr.xy;\n    else if (iFrag.x == 6.) fVal.zw = vec2 (mPtr.z, hiRide);\n  } else if (iFrag.y == 1.) {\n    for (int k = 0; k < MAX_CAP; k ++) {\n      if (k == nCap) break;\n      if      (iFrag.x == 2. * float (k)) fVal.zw = cPos[k];\n      else if (iFrag.x == 2. * float (k) + 1.) fVal.zw = cDir[k];\n    }\n  }\n  fragColor = fVal;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}