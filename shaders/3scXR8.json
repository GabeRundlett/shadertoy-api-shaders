{
    "Shader": {
        "info": {
            "date": "1571371841",
            "description": "Inktober, but with shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "3scXR8",
            "likes": 4,
            "name": "shadetober #16 (wild)",
            "published": 3,
            "tags": [
                "inktober",
                "shadertober",
                "shadetober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "percentcer",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "// should be a square for best results\n#define NUM 25\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y * .25;\n    // warm up the clock a bit\n    float dt = iTime + 10.;\n\n    // init points\n    vec2 points[NUM];\n    int stride = 5;\n    for(int i = 0; i < NUM; i++) {\n        float row = float(i / stride);\n        float col = float(i % stride);\n        points[i] = (-2. + vec2(col, row)) / float(stride);\n\n        // todo this could probably use some more interesting movement\n        points[i] += vec2(\n             sin(dt*.123*float(i)) * .1,\n             sin(19. + dt*.256*float(i)) * .1\n            );\n    }\n    \n    // debug origin draw\n    #if 0\n    if (uv.x > -.01 && uv.x < .01) { fragColor = vec4(1.,0.,0.,1.); return;}\n    if (uv.y > -.01 && uv.y < .01) { fragColor = vec4(1.,0.,0.,1.); return;}\n    #endif\n\n    // this loop calculates the closest and second closest distances\n    // it will be used for the classic f2-f1 voronoi border\n    vec2 dist = vec2(.5);\n    for(int i = 0; i < NUM; i++) {\n        float d = distance(uv, points[i]);\n        if (d < dist.x) {\n            // store the new closest value and record\n            // what the previous one was in dist.y\n            dist.y = dist.x;\n            dist.x = d;\n        } else if (d < dist.y) {\n            // sometimes the closest value doesn't \n            // change but the second closest does\n            dist.y = d;\n        }\n    }\n\n    // colors are based on leopard print patterns\n    vec3 base = vec3(1.,.8,.5);\n    vec3 outerspot = vec3(0.1, .05, .02);\n    vec3 innerspot = vec3(.81, .37, .01);\n\n    // easy f2-f1 voronoi. consider incorporating iq's perfect border\n    // if you want something more predictable\n    vec3 voro = vec3(dist.y - dist.x);\n    vec3 col = mix(base, outerspot, step(.02, voro));\n    col = mix(col, innerspot, step(.06, voro));\n\n    fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}