{
    "Shader": {
        "info": {
            "date": "1710197091",
            "description": "No ray tracing skybox with procedural clouds and sea.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3sXDs",
            "likes": 6,
            "name": "No tracing skybox",
            "published": 3,
            "tags": [
                "sea",
                "clouds",
                "skybox"
            ],
            "usePreview": 0,
            "username": "DinDotDout",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "#define SUPERSAMPLING\nconst int samples = 2;\n\nconst float PI = 3.141592;\nconst vec3 SKY_COLORS[3] = vec3[3](vec3(0.8, 0.38, 0.00), vec3(0.18, 0.43, 0.76), vec3(0.40, 0.70, 0.90));\nconst float CLOUDS_DEGRADE = 0.85;\nconst float CLOUDS_SIZE = 0.4;\nconst float CLOUDS_HEIGHT = 2.0;\nconst float CLOUDS_SPEED = 10.0;\nconst float CLOUDS_DEFORM_SPEED = 1.0;\n\nconst int FLUFFINESS_NOISE_OCTAVE = 1;\nconst float FLUFFINESS_NOISE_SCALE = 3.0;\nconst float FLUFF_SPEED = -3.0;\n\nconst float CENTER_DISTANCE = .2;\nconst float ZOOM = 1.0;\n\nconst vec4 CLOUDS_COLOR = vec4(1.0, 1.0, 1.0, 0.95);\n\nconst float SEA_HEIGHT = .5;\nconst float WATER_SCALE = 8.;\nconst vec4 FOAM_COLOR = vec4(0.82, 0.88, 0.80,1.0);\nconst vec4 SEA_COLOR = vec4(0.0, 0.5, 0.8, 1.0);\n\nconst float SUN_ALPHA = 1.2;\n\nvec3 sun(in vec3 ro, in vec3 rd) {\n    vec3 lightDir = normalize(vec3(-0.8, .35, 2));\n\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    vec3 sun = 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 5.0);\n    sun += 0.25 * vec3(1.0, 0.8, 0.6) * pow(sundot, 64.0);\n    sun += 0.2 * vec3(1.0, 0.8, 0.6) * pow(sundot, 512.0);\n    return sun;\n}\n\nvec4 bg(in vec3 ro, in vec3 rd) {\n    float normalized_rdy = inverse_lerp(-1.0, 1.0, rd.y);\n    int index = int(normalized_rdy);\n    float fraction = fract(normalized_rdy);\n    vec3 new_bg = mix(SKY_COLORS[index], SKY_COLORS[min(index + 1, 2)], fraction);\n    return vec4(new_bg, 1.0);\n}\n\nfloat get_cloud_layer(vec3 position, float offset) {\n    float timeScale = iTime * 0.01 / (position.z * (offset + sign(offset)));\n\n    float displacement = timeScale * CLOUDS_SPEED;\n    float rippleDisplacement = timeScale * CLOUDS_DEFORM_SPEED;\n    vec3 cloudPosition = vec3(position.x + displacement, position.y, rippleDisplacement);\n    vec3 randomOffset = vec3(0.0, 0.0, 1000.0) * offset * position.z;\n    float cloudsNoisePersistence = 1.0;\n    int cloudsNoiseOctave = 1;\n    float cloudBase = SimplexNoise(cloudPosition + randomOffset, cloudsNoiseOctave, 1.0, cloudsNoisePersistence);\n    cloudBase = inverse_lerp(-1.0, 1.0, cloudBase); // Normalize\n\n    float fluffinessNoisePersistence = 1.0;\n    float fluffMovement = timeScale * FLUFF_SPEED + displacement;\n    vec3 fluffPosition = vec3(position.x + fluffMovement, position.y, 0.0);\n    float cloudRipples = SimplexNoise(fluffPosition + randomOffset, FLUFFINESS_NOISE_OCTAVE, FLUFFINESS_NOISE_SCALE, fluffinessNoisePersistence);\n    cloudRipples = abs(cloudRipples);\n\n    cloudRipples = 1.0 - cloudRipples;\n    cloudRipples = sqrt(cloudRipples);\n    cloudRipples = 1.0 - cloudRipples;\n    cloudBase = inverse_lerp(0.0, CLOUDS_SIZE, cloudBase);\n    float clouds = mix(cloudBase, cloudRipples, cloudRipples);\n    return clouds;\n}\n\nvec2 get_plane_height(vec3 ro, vec3 rd, float height) {\n    float dist = (height - ro.y) / rd.y;\n    vec3 p = ro + dist * rd;\n    return p.xz;\n}\n\nfloat degrade_horizon(in vec3 ro, in vec3 rd, in bool up) {\n    float direction = sign(rd.y);\n    direction = 2.0 * float(up) - 1.0;\n    ro *= direction;\n    rd *= direction;\n    return smoothstep(1.0, CLOUDS_DEGRADE, sqrt(1.0 - rd.y));\n}\n\nvec4 clouds_texture(in vec3 ro, in vec3 rd) {\n    vec2 p = get_plane_height(ro, rd, CLOUDS_HEIGHT);\n    float t = iTime * 0.1;\n    float cloud_noise = get_cloud_layer(vec3(p, CLOUDS_HEIGHT), -1.0);\n    vec4 clouds = CLOUDS_COLOR;\n    clouds.a *= step(cloud_noise, 1.0);\n  \n    // Horizon degrade\n    float gradient = smoothstep(-0.5, 0.5, rd.y);\n    clouds.rgb *= gradient;\n    clouds.a *= degrade_horizon(ro, rd, true);\n    return clouds;\n}\n\n\nvec4 sea_texture(vec3 ro, vec3 rd){\n    vec2 seaHeight = get_plane_height(ro, rd, SEA_HEIGHT);\n    \n    float planeHeightX = (sin(iTime + rd.x / .3) + 2.0) / 3.0;\n    planeHeightX -= .009*(sin(iTime + rd.x / .009) + 2.0) / 2.0; // Micro warp\n    float planeHeightZ = (sin(iTime + rd.z / .25) + 2.0) / 3.0;\n    planeHeightZ -= .009*(sin(iTime + rd.z / .003) + 2.0) / 2.0; // Micro warp\n    \n    vec2 wavesHeight = seaHeight + get_plane_height(ro, rd, planeHeightX + planeHeightZ);\n    \n    vec2 noise_mov = vec2(0.0, -iTime * 0.1);\n    float noise = SimplexNoiseRaw(vec3(noise_mov+wavesHeight*10.0, iTime*.1))*.3;\n    vec2 c = voronoi(WATER_SCALE * wavesHeight+noise+vec2(iTime*.3, -.3*iTime));\n    float point= smoothstep(0.2, .71, c.x);\n\n    float waveDetail = SimplexNoiseRaw(vec3(wavesHeight * 1.0 + vec2(iTime*.3, 0.0), iTime * 0.3)) * 0.5;\n    float foamDetail = SimplexNoiseRaw(vec3(wavesHeight * 20.0, iTime * 0.1)) * 0.2;\n\n    vec4 seaColor = mix(SEA_COLOR, FOAM_COLOR, point);\n    seaColor += waveDetail;\n    seaColor -= foamDetail;\n\n    // Add more details to the sea\n    float seaDetail = SimplexNoiseRaw(vec3(wavesHeight * 30.0, iTime * 0.1)) * 0.1;\n    seaColor += seaDetail;\n\n    // Adjust the color to make it more like sea water\n    seaColor = mix(seaColor, vec4(0.0, 0.3, 0.6, 1.0), 0.6);\n\n    return seaColor;\n}\n\n\nvec3 skybox(in vec3 ro, in vec3 rd) {\n    vec4 skyCol = bg(ro, rd);\n    vec4 clouds = clouds_texture(ro, rd);\n\n\n    vec4 sea = sea_texture(ro, rd);\n    float horizon = degrade_horizon(ro, rd*.5, false);\n    sea.rgb = mix(SEA_COLOR.rgb, sea.rgb, horizon);\n    sea.a *= horizon;\n    \n    vec4 sea_mix = mix(skyCol, sea, sea.a);\n    vec4 sky_mix = mix(sea_mix, clouds, clouds.a);\n    return clamp(sky_mix.rgb + sun(ro, rd) * SUN_ALPHA, 0.0, 1.0);\n}\n\nmat3 set_camera(in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro); // FW\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw * ZOOM);\n}\n\nmat3 rotate3D_pitch_yaw(float pitch, float yaw) {\n    float cosPitch = cos(pitch);\n    float sinPitch = sin(pitch);\n    float cosYaw = cos(yaw);\n    float sinYaw = sin(yaw);\n\n    return mat3(\n            vec3(cosYaw, sinPitch * sinYaw, -cosPitch * sinYaw),\n            vec3(0.0, cosPitch, sinPitch),\n            vec3(sinYaw, -sinPitch * cosYaw, cosPitch * cosYaw)\n        );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -CENTER_DISTANCE);\n\n    vec2 mouse = iMouse.xy/iResolution.xy-.5;\n    float rot_x = mouse.x * PI;\n    float rot_y = mouse.y; // -1 to 1 feels just fine\n    ro *= rotate3D_pitch_yaw(-rot_y, rot_x); // yaw and pitch\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 cam = set_camera(ro, ta, 0.0);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    vec3 color;\n\n    // Remove some aliasing\n    #ifdef SUPERSAMPLING\n        color = vec3(0.0);\n        for (int i = 0; i < samples; ++i) {\n            for (int j = 0; j < samples; ++j) {\n                vec2 offset = vec2(float(i), float(j)) / float(samples) - 0.5;\n                vec3 rd = normalize(cam * vec3(uv + offset / iResolution.y, 1.0));\n                color += skybox(ro, rd);\n            }\n        }\n        color /= float(samples * samples);\n    #else\n        color = skybox(ro, rd);\n    #endif\n\n    fragColor.rgb = color.rgb;\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float inverse_lerp(float min1, float max1, float value) {\n    return (value - min1) / (max1 - min1);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n// Raw simplex implementau9tion by candycat\n// Source: https://www.shadertoy.com/view/4sc3z2\nfloat SimplexNoiseRaw(vec3 pos) {\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(pos + (pos.x + pos.y + pos.z) * K1);\n    vec3 d0 = pos - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nfloat SimplexNoise(vec3 pos, int octaves, float scale, float persistence) {\n    float final = 0.0;\n    float amplitude = 1.0;\n    float maxAmplitude = 0.0;\n\n    for (int i = 0; i < octaves; ++i) {\n        final += SimplexNoiseRaw(pos * scale) * amplitude;\n        scale *= 2.0;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n    }\n\n    float noise = (final / maxAmplitude);\n    return noise;\n}\n\nvec2 hash22(vec2 uv)\n{\n    //uv = mod(uv, 4.0); // tile\n    uv = vec2(dot(uv, vec2(127.1, 311.7)),\n            dot(uv, vec2(269.5, 183.3)));\n    return fract(sin(uv) * 18.5453);\n}\n\n\n// return distance, and cell id\nvec2 voronoi(in vec2 x)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec3 m = vec3(8.0);\n    for (int j = -1; j <= 1; j++)\n        for (int i = -1; i <= 1; i++)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash22(n + g);\n            vec2 r = g - f + o;\n            float d = dot(r, r);\n            if (d < m.x)\n                m = vec3(d, o);\n        }\n\n    return vec2(sqrt(m.x), m.y + m.z);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}