{
    "Shader": {
        "info": {
            "date": "1534200148",
            "description": "The first steps in a Perlin-like gradient noise function.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ldyD2",
            "likes": 3,
            "name": "Noise In Progress",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "gradient",
                "wip"
            ],
            "usePreview": 0,
            "username": "IAmSparticle",
            "viewed": 560
        },
        "renderpass": [
            {
                "code": "/*\nThis shader is a work in progress.\n\nAt the risk of oversimplificatin, Perlin noise is generated by selecting pseudo-random\ngraditent vectors at the integer units of an n-dimensional grid, projecting points onto \nthose gradients, then interpolating the resulting heights acording to the distance from\neach of units bounding the points. This shader is obviouly not Perlin-noise. This \nshader implements pseudo-random gradient generation in a 4d space and scales those 4d \ngradients to the 4d color space for debuging.\n\nPerlin's hashing of inputs generated axial artifacts. He create simplex noise to address\nthis.  In \"Better Gradient Noise\" (https://www.cs.utah.edu/~aek/research/noise.pdf), \nKensler et al. propose sevral improvements to Perlin noise.  Relivent to this shader,\nthey sugest using unique permutation tables for each axis and xor-ing the results of\neach to index the gradient-vector table. \n\nThis shader implements multiple perterbation tables directly, however, a simple xor of \nthe resulting coordinates generated repitition artifacts modulo the perturbaton tables \nsizes.  To resovle this, the result of the the x perturbation was xored with the y \ncoordinate to index the y perturbation. This was repeated for the remaining two \ndimensions. While this significantly reduced the artifacts, some artifacts remained \nalong the x axis. Xoring the value back with the noise-space x coordinated to index a\nsecond lookup of the x perturbation tables elimanted these visual artifacts.\n\nThis shader is for my reference while I create a new shader which fully implements a \nPerlin-like gradient noise function. \n*/ \n\n/* These arrays are used to perturb indexing of the gradient vector array. These number\nare not magic. They where generated with four sucessive invocations of the python \none-liner `random.sample([x for x in range(257)], 257);` Though I have not tested it,\nany set of sequences generated in this way should perturb the gradient vector array\njust fine (albeit in a different order). */\nconst int[257] x_perts = int[](122, 157, 41, 75, 247, 215, 201, 106, 179, 67, 109, 2, 44, 144, 43, 99, 51, 5, 66, 223, 30, 112, 206, 183, 213, 37, 3, 0, 103, 12, 93, 143, 13, 127, 162, 136, 164, 166, 124, 107, 239, 72, 108, 211, 246, 161, 52, 90, 11, 220, 14, 203, 168, 95, 236, 214, 155, 196, 151, 251, 202, 219, 61, 59, 248, 76, 22, 45, 199, 154, 121, 46, 125, 28, 83, 186, 149, 181, 111, 232, 15, 158, 24, 191, 194, 229, 18, 172, 254, 178, 185, 192, 69, 80, 4, 7, 235, 131, 101, 226, 234, 189, 63, 105, 88, 49, 160, 163, 134, 175, 176, 47, 139, 198, 225, 74, 256, 152, 16, 231, 118, 23, 133, 253, 42, 249, 187, 27, 255, 55, 71, 34, 218, 78, 212, 98, 100, 86, 228, 242, 224, 33, 77, 10, 171, 200, 148, 227, 216, 184, 8, 240, 21, 1, 54, 145, 92, 25, 233, 89, 53, 205, 209, 82, 244, 195, 204, 20, 237, 147, 128, 197, 156, 62, 116, 142, 190, 126, 68, 170, 110, 29, 48, 26, 150, 73, 245, 174, 114, 252, 250, 217, 40, 79, 207, 39, 60, 56, 102, 135, 19, 222, 38, 241, 6, 238, 81, 58, 31, 57, 36, 87, 120, 119, 141, 104, 84, 132, 91, 230, 94, 146, 208, 113, 138, 9, 173, 177, 65, 243, 137, 167, 193, 123, 140, 210, 188, 70, 32, 85, 96, 97, 50, 117, 35, 182, 17, 169, 221, 129, 180, 64, 153, 159, 165, 130, 115);\nconst int[257] y_perts = int[](189, 201, 143, 210, 90, 55, 20, 27, 221, 47, 249, 17, 29, 45, 255, 56, 121, 142, 175, 26, 248, 76, 40, 188, 180, 44, 0, 112, 137, 48, 132, 70, 151, 200, 209, 53, 231, 184, 149, 176, 28, 163, 199, 130, 219, 164, 15, 65, 233, 106, 58, 25, 168, 171, 98, 187, 136, 32, 134, 198, 115, 227, 256, 124, 206, 146, 127, 216, 197, 238, 111, 242, 105, 12, 95, 86, 57, 14, 237, 85, 99, 46, 247, 33, 154, 36, 232, 69, 156, 225, 214, 13, 170, 211, 172, 125, 60, 23, 24, 109, 212, 250, 117, 244, 126, 9, 166, 77, 139, 190, 162, 224, 243, 167, 169, 152, 10, 246, 203, 92, 21, 183, 71, 122, 220, 67, 93, 174, 64, 150, 196, 110, 75, 38, 208, 192, 107, 217, 49, 252, 41, 80, 230, 193, 68, 155, 87, 114, 178, 118, 31, 207, 228, 141, 148, 52, 218, 179, 4, 215, 2, 135, 82, 78, 97, 194, 103, 138, 72, 202, 182, 66, 160, 88, 96, 205, 61, 63, 222, 94, 11, 226, 147, 241, 50, 59, 83, 173, 119, 100, 120, 245, 34, 89, 144, 42, 251, 108, 254, 185, 123, 181, 54, 6, 102, 73, 223, 145, 19, 8, 39, 81, 239, 234, 5, 186, 91, 240, 128, 43, 161, 253, 157, 84, 235, 229, 213, 204, 113, 18, 140, 177, 236, 16, 129, 195, 3, 153, 35, 116, 165, 158, 101, 104, 131, 191, 22, 79, 62, 37, 7, 1, 133, 51, 74, 30, 159);\nconst int[257] z_perts = int[](75, 58, 198, 164, 90, 182, 121, 179, 103, 217, 31, 162, 17, 24, 147, 120, 256, 244, 72, 5, 216, 209, 22, 66, 205, 155, 215, 232, 186, 20, 239, 84, 153, 144, 150, 32, 14, 255, 109, 27, 3, 28, 180, 35, 195, 19, 193, 2, 137, 38, 126, 160, 9, 41, 174, 88, 86, 134, 188, 60, 106, 81, 132, 203, 49, 79, 208, 65, 251, 56, 13, 44, 40, 191, 25, 12, 93, 149, 243, 141, 11, 226, 69, 6, 168, 99, 236, 183, 228, 37, 71, 52, 192, 223, 10, 204, 129, 48, 151, 29, 197, 202, 116, 53, 187, 246, 4, 219, 213, 172, 30, 117, 220, 231, 89, 77, 196, 227, 125, 158, 206, 234, 128, 165, 201, 229, 124, 51, 235, 67, 114, 250, 222, 42, 159, 189, 127, 225, 136, 26, 85, 154, 110, 64, 200, 249, 143, 212, 50, 248, 108, 33, 210, 54, 194, 161, 157, 237, 68, 76, 1, 107, 0, 238, 252, 100, 105, 135, 96, 73, 156, 63, 62, 146, 170, 178, 171, 8, 152, 133, 199, 119, 34, 113, 94, 233, 82, 112, 115, 104, 173, 177, 166, 241, 47, 70, 122, 102, 23, 118, 181, 184, 167, 92, 207, 224, 87, 140, 245, 39, 185, 218, 130, 240, 57, 43, 131, 16, 74, 142, 163, 15, 80, 46, 18, 230, 169, 247, 97, 175, 95, 55, 123, 7, 111, 91, 45, 83, 61, 59, 190, 21, 148, 176, 221, 214, 78, 36, 145, 138, 242, 211, 139, 253, 98, 254, 101);\nconst int[257] w_perts = int[](28, 94, 76, 143, 203, 93, 249, 138, 125, 36, 107, 252, 236, 137, 91, 101, 159, 49, 55, 214, 201, 4, 209, 97, 59, 247, 195, 242, 170, 18, 175, 181, 67, 156, 213, 152, 35, 109, 251, 12, 120, 190, 133, 113, 194, 86, 204, 20, 162, 61, 117, 42, 25, 46, 155, 164, 79, 41, 126, 115, 240, 180, 53, 103, 208, 70, 151, 114, 38, 173, 69, 161, 131, 121, 64, 234, 122, 154, 163, 1, 43, 57, 212, 197, 84, 241, 202, 146, 111, 6, 179, 253, 65, 87, 63, 17, 96, 100, 78, 140, 183, 26, 45, 52, 166, 178, 150, 153, 71, 230, 92, 254, 145, 48, 11, 58, 157, 123, 246, 238, 19, 210, 233, 189, 147, 3, 211, 192, 54, 81, 130, 124, 188, 80, 223, 98, 205, 8, 243, 248, 250, 68, 207, 39, 142, 30, 105, 21, 221, 89, 206, 88, 231, 108, 85, 51, 77, 149, 148, 168, 198, 24, 184, 83, 95, 33, 99, 62, 73, 239, 118, 169, 215, 200, 144, 72, 139, 135, 199, 60, 244, 10, 104, 44, 216, 116, 112, 237, 29, 219, 182, 191, 228, 75, 37, 196, 9, 82, 235, 158, 134, 172, 174, 186, 0, 27, 185, 50, 187, 129, 34, 229, 22, 16, 256, 226, 218, 193, 106, 160, 102, 167, 31, 74, 232, 110, 245, 5, 132, 222, 177, 171, 90, 217, 255, 13, 7, 14, 136, 165, 66, 2, 32, 128, 220, 47, 23, 119, 141, 56, 225, 176, 227, 127, 15, 224, 40);\n\n/* This table represents directions from the center of a 4d unit cube to the midpoint \nof each segment of the tesseract. */\nconst vec4[32] grads   = vec4[](\n    vec4( 1, 1, 1, 0), vec4( 1, 1, 0, 1), vec4( 1, 1, 0,-1), vec4( 1, 1,-1, 0),\n\tvec4( 1, 0, 1, 1), vec4( 1, 0, 1,-1), vec4( 1, 0,-1, 1), vec4( 1, 0,-1,-1),\n\tvec4( 1,-1, 1, 0), vec4( 1,-1, 0, 1), vec4( 1,-1, 0,-1), vec4( 1,-1,-1, 0), \n    vec4( 0, 1, 1, 1), vec4( 0, 1, 1,-1), vec4( 0, 1,-1, 1), vec4( 0, 1,-1,-1),\n    vec4( 0,-1, 1, 1), vec4( 0,-1, 1,-1), vec4( 0,-1,-1, 1), vec4( 0,-1,-1,-1),\n    vec4(-1, 1, 1, 0), vec4(-1, 1, 0, 1), vec4(-1, 1, 0,-1), vec4(-1, 1,-1, 0),\n    vec4(-1, 0, 1, 1), vec4(-1, 0, 1,-1), vec4(-1, 0,-1, 1), vec4(-1, 0,-1,-1),\n    vec4(-1,-1, 1, 0), vec4(-1,-1, 0, 1), vec4(-1,-1, 0,-1), vec4(-1,-1,-1, 0)\n);\n\n/* Select a gradient vector from  4d noise space */\nvec4 grad(ivec4 pert) \n{\n    int i = x_perts[(pert.x) % 257];\n    i = y_perts[(pert.y ^ i) % 257];\n    i = z_perts[(pert.z ^ i) % 257];\n    i = w_perts[(pert.w ^ i) % 257];\n    i = x_perts[(pert.x ^ i) % 257];\n    return grads[i % 32];\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float framesPerSec = iTime * 60.0;  // 60 Frames per Second\n    float scalingFactor = 1.0;\t\t\t// 1 pixel in screen space = 1 unit in noise space\n    vec4 noiseSpaceCoord = vec4(\n        fragCoord,     // xy \n        0,             // z\n        framesPerSec   // w\n     );\n\n    // purturbation vector in a scaled version of the noise space coordinate\n    ivec4 pertVec = ivec4(noiseSpaceCoord / scalingFactor);\n    \n    // get the gradient vector for this chosen noise space coordinate.\n    vec4 gradVec = grad(pertVec); \n    \n    fragColor = (gradVec + 1.0) * 0.5; // Move gradient vector components into the range\n                                       // from 0 to 1 for visualization only.                            \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}