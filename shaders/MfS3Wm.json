{
    "Shader": {
        "info": {
            "date": "1704300715",
            "description": "Gravitational fluid simulation accelerated with a data structure similar to Radiance Cascades",
            "flags": 32,
            "hasliked": 0,
            "id": "MfS3Wm",
            "likes": 8,
            "name": "CFD Gravity simulation",
            "published": 3,
            "tags": [
                "advection",
                "physics",
                "gravity",
                "cfd"
            ],
            "usePreview": 1,
            "username": "Suslik",
            "viewed": 453
        },
        "renderpass": [
            {
                "code": "// A continuous solver for the Newton's gravity equation (F=-G m1 m2 / r^2)\n// based on a data structure similar to Radiance Cascades (https://www.shadertoy.com/view/mlSfRD)\n// uses the same integration as https://www.shadertoy.com/view/XfBGWw\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    fragColor = texture(iChannel0, uv);\n    vec4 resColor = vec4(0.0f);\n    ivec2 atlasSize = ivec2(iResolution.xy);\n    uint cascadeIndex = 0u;//uint(iMouse.y / 100.0f);\n    vec2 atlasUv = GetAtlasBilinearTapPoint(uv, cascadeIndex, atlasSize, 0);\n    vec4 linearColor = abs(texture(iChannel0, atlasUv)) * vec4(vec2(0.02f), 1.0f, 1.0f);\n    resColor = pow(linearColor, vec4(vec3(1.0f / 2.2f), 1.0f));\n    fragColor = resColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float dt = 0.01f;\nconst uint cascadesCount = 7u;\nconst float minDistance = 0.0f;\n\n//this can be 2 or 4\n#define SCALING_FACTOR 2\n\n#if SCALING_FACTOR == 2\n    const float cascade0Dist = 15.0f;\n#else\n    const float cascade0Dist = 1.0f;\n#endif\n\n\n//http://www.jcgt.org/published/0009/03/02/paper.pdf\nuvec3 hash33UintPcg(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy; //swizzled notation is not exactly the same because components depend on each other, but works too\n\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy;\n    return v;\n}\n\nvec3 hash3i3f(ivec3 seed)\n{\n    uvec3 hash_uvec3 = hash33UintPcg(uvec3(seed));\n    return vec3(hash_uvec3) * (1.0f / float(~0u));\n}\n\nvec4 PackPixel(vec2 velocity, float density, float color)\n{\n    return vec4(velocity, density, color);\n}\n\nvec2 GetImpulse(vec4 pixel)\n{\n    return pixel.xy;\n}\n\nfloat GetDensity(vec4 pixel)\n{\n    return pixel.z;\n}\n\nfloat GetColor(vec4 pixel)\n{\n    return pixel.w;\n}\n\nvec4 GatherAdvectedPixel(sampler2D tex, ivec2 dstIndex, float dt)\n{\n    const int searchRadius = 10;\n    ivec2 srcIndex;\n    \n    vec2 resImpulse = vec2(0.0f);\n    float resDensity = 0.0f;\n    float resColor = 0.0f;\n    for(srcIndex.y = dstIndex.y - searchRadius; srcIndex.y < dstIndex.y + searchRadius; srcIndex.y++)\n    {\n        for(srcIndex.x = dstIndex.x - searchRadius; srcIndex.x < dstIndex.x + searchRadius; srcIndex.x++)\n        {\n            vec4 srcPixel = texelFetch(tex, srcIndex, 0);\n            vec2 srcImpulse = GetImpulse(srcPixel);\n            float srcDensity = GetDensity(srcPixel);\n            float srcColor= GetColor(srcPixel);\n            vec2 srcVelocity = srcImpulse / max(1e-7f, srcDensity);\n            \n            vec2 advectedIndex = vec2(srcIndex) + srcVelocity * dt;\n            vec2 weights = max(vec2(1.0f, 1.0f) - abs(advectedIndex - vec2(dstIndex)), 0.0f);\n            \n            float weight = weights.x * weights.y;\n            resImpulse += srcImpulse * weight;\n            resDensity += srcDensity * weight;\n            resColor += srcColor * weight;\n        }\n    }\n    return PackPixel(resImpulse, resDensity, resColor);\n}\n\nfloat CrossProduct(vec2 a, vec2 b) //returns a pseudoscalar\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 CrossProduct(vec2 a, float b) //b is a pseudoscalar\n{\n    return vec2(-a.y, a.x) * b;\n}\n\nvec4 ComputeLocalInteraction(sampler2D tex, ivec2 dstIndex, float dt)\n{\n    float totalDensity = 0.0f;\n    float totalColor = 0.0f;\n    float totalMass = 0.0f;\n    vec2 totalImpulse = vec2(0.0f, 0.0f);\n    vec2 totalMassCenter = vec2(0.0f, 0.0f);\n    float totalAngularImpulse = 0.0f;\n    float totalInertiaMoment = 0.0f;\n\n    vec2 dv = vec2(0.0f, -30.0f) * dt;\n    ivec2 size = textureSize(tex, 0);\n\n    vec4 centerPixel = texelFetch(tex, dstIndex, 0);\n    float resDensity = GetDensity(centerPixel);\n    float resColor = GetColor(centerPixel);\n    \n    int searchRadius = 10;\n    ivec2 offset;\n    for(offset.y = -searchRadius; offset.y <= searchRadius; offset.y++)\n    {\n        for(offset.x = -searchRadius; offset.x <=  searchRadius; offset.x++)\n        {\n            ivec2 srcIndex = dstIndex + offset * 4;\n            vec4 srcPixel = texelFetch(tex, srcIndex, 0);\n            vec2 srcImpulse = GetImpulse(srcPixel);\n            float srcDensity = GetDensity(srcPixel);\n            vec2 delta = -vec2(srcIndex);\n\n            /*srcImpulse += dv * srcDensity;\n            if(srcIndex.x < 0 || srcIndex.y < 0 || srcIndex.x >= size.x || srcIndex.y >= size.y)\n            {\n                srcImpulse = vec2(0.0f);\n                srcDensity = 1e3f;\n            }*/\n            float srcAngularImpulse = -CrossProduct(srcImpulse, delta);\n            float srcInertiaMoment = dot(delta, delta) * srcDensity;\n            vec2 srcMassCenter = srcDensity * vec2(srcIndex);\n            \n            totalMass += srcDensity;\n            totalImpulse += srcImpulse;\n            totalMassCenter += srcMassCenter;\n            totalAngularImpulse += srcAngularImpulse;\n            totalInertiaMoment += srcInertiaMoment;\n        }\n    }\n\n    float invMass = 1.0f / max(1e-7f, totalMass);\n    vec2 resMassCenter = totalMassCenter * invMass;\n    vec2 resMassCenterVelocity = totalImpulse * invMass;\n    \n    float resMassCenterAngularImpulse = totalAngularImpulse - CrossProduct(totalImpulse, resMassCenter);\n    float resMassCenterIntertiaMoment = totalInertiaMoment - dot(resMassCenter, resMassCenter) * totalMass;\n    float resAngularVelocity = resMassCenterAngularImpulse / max(1e-7f, resMassCenterIntertiaMoment);\n    \n    vec2 resVelocity = resMassCenterVelocity - CrossProduct(vec2(dstIndex) - resMassCenter, resAngularVelocity);\n    \n\n    return vec4(PackPixel(resVelocity * resDensity, resDensity, resColor));\n}\n\nfloat Checkerboard(vec2 uv)\n{\n    return step(0.5f, fract(uv.y + 0.5f * step(0.5f, fract(uv.x))));\n}\n\nvec4 VelocityToColor(vec2 v)\n{\n    return length(v) * vec4(v.x > 0.0f ? 1.0f : 0.0f, v.x < 0.0f ? 1.0f : 0.0f, 0.0f, 0.0f);\n}\n\nivec2 GetCascadeSize(ivec2 atlasSize, uint cascadeIndex)\n{\n    ivec2 baseSize = atlasSize / 2;\n    return baseSize >> cascadeIndex;\n}\n\nivec2 GetAtlasPixel(ivec2 cascadePixel, uint cascadeIndex, int fieldIndex, ivec2 atlasSize)\n{\n    ivec2 baseSize = atlasSize / 2;\n    ivec2 currOffset = ivec2(baseSize.x * fieldIndex, 0);\n    ivec2 currSize = baseSize;\n    for(uint i = 0u; i < cascadeIndex; i++)\n    {\n        currOffset.y += currSize.y;\n        currSize.y /= 2;\n    }\n    return currOffset + cascadePixel;\n}\n\nstruct CascadeLocation\n{\n    ivec2 cascadePixel;\n    uint cascadeIndex;\n    int fieldIndex;\n};\n\nCascadeLocation GetCascadeLocation(ivec2 atlasPixel, ivec2 atlasSize)\n{\n    CascadeLocation loc;\n    loc.cascadePixel = ivec2(0);\n    ivec2 baseSize = atlasSize / 2;\n\n    loc.fieldIndex = atlasPixel.x < baseSize.x ? 0 : 1;\n    \n    ivec2 currOffset = ivec2(baseSize.x * loc.fieldIndex, 0);\n    \n    ivec2 currSize = baseSize;\n    for(loc.cascadeIndex = 0u; loc.cascadeIndex < cascadesCount; loc.cascadeIndex++)\n    {\n        if(atlasPixel.y >= currOffset.y && atlasPixel.y < currOffset.y + currSize.y && atlasPixel.x >= currOffset.x && atlasPixel.x <= currOffset.x + currSize.x)\n        {\n            loc.cascadePixel = atlasPixel - currOffset;\n            return loc;\n        }\n        currOffset.y += currSize.y;\n        currSize /= 2;\n    }\n    //loc.cascadeIndex = 0u;\n    loc.fieldIndex = -1;\n    return loc;\n}\n\nint idot(ivec2 a, ivec2 b)\n{\n    return a.x * b.x + a.y * b.y;\n}\nvec2 IntegrateGravityRangeAcceleration(sampler2D atlasTex, ivec2 cascadePixel, uint cascadeIndex, ivec2 atlasSize, vec2 dist0Minmax)\n{\n    float dist0Mult = float(1u << cascadeIndex);\n\n    ivec2 cascadeSize = GetCascadeSize(atlasSize, cascadeIndex);\n    int aabbSize = int(floor(dist0Minmax.y / dist0Mult + 1.0f));\n    \n    ivec4 aabbMinMax = ivec4(\n        max(ivec2(0), cascadePixel - ivec2(aabbSize)),\n        min(cascadeSize - ivec2(1), cascadePixel + ivec2(aabbSize)));\n    vec2 totalAcceleration = vec2(0.0f);\n    ivec2 baseAtlasPixel = GetAtlasPixel(cascadePixel, cascadeIndex, 0, atlasSize);\n    \n    float areaMult = float((1u << cascadeIndex) * (1u << cascadeIndex));\n    ivec2 srcCascadePixel;\n    for(srcCascadePixel.y = aabbMinMax.y; srcCascadePixel.y <= aabbMinMax.w; srcCascadePixel.y++)\n    {\n        for(srcCascadePixel.x = aabbMinMax.x; srcCascadePixel.x <= aabbMinMax.z; srcCascadePixel.x++)\n        {\n            ivec2 offset = srcCascadePixel - cascadePixel;\n            float lensq = float(idot(offset, offset)) *  dist0Mult * dist0Mult;\n            if(lensq < dist0Minmax.x * dist0Minmax.x || lensq >= dist0Minmax.y * dist0Minmax.y) continue; \n            ivec2 srcAtlasPixel = baseAtlasPixel + offset;\n            vec4 srcPackedPixel = texelFetch(atlasTex, srcAtlasPixel, 0);\n            float density = GetDensity(srcPackedPixel);\n            float srcMass = density * areaMult;\n            \n            vec2 delta = vec2(offset) * dist0Mult;\n            float l = length(delta);\n            totalAcceleration += srcMass * delta / max(1e-7f, l * l * l);\n        }\n    }\n    return totalAcceleration;\n}\n\nfloat GetCascadeDist(uint cascadeIndex)\n{\n    return pow(float(SCALING_FACTOR), float(cascadeIndex));\n}\n\nvec2 GetAtlasBilinearTapPoint(vec2 uv, uint cascadeIndex, ivec2 atlasSize, int fieldIndex)\n{\n    ivec2 baseSize = atlasSize / 2;\n    ivec2 currOffset = ivec2(baseSize.x * fieldIndex, 0);\n    ivec2 currSize = baseSize;\n    for(uint i = 0u; i < cascadeIndex; i++)\n    {\n        currOffset.y += currSize.y;\n        currSize.y /= 2;\n    }\n    return (vec2(currOffset) + vec2(baseSize) * uv / pow(2.0f, float(cascadeIndex))) / vec2(atlasSize);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 atlasPixel = ivec2(fragCoord);\n    ivec2 atlasSize = ivec2(iResolution.xy);\n    CascadeLocation loc = GetCascadeLocation(atlasPixel, atlasSize);\n    ivec2 atlasPixelTest = GetAtlasPixel(loc.cascadePixel, loc.cascadeIndex, loc.fieldIndex, atlasSize);\n    ivec2 baseSize = atlasSize / 2;\n\n    vec4 resColor = vec4(0.0f);\n    if(loc.fieldIndex == 0)\n    {\n        if(loc.cascadeIndex > 0u)\n        {\n            ivec2 baseAtlasPixel = GetAtlasPixel(loc.cascadePixel * 2, loc.cascadeIndex - 1u, loc.fieldIndex, atlasSize);\n            for(int x = 0; x < 2; x++)\n            {\n                for(int y = 0; y < 2; y++)\n                {\n                    resColor += texelFetch(iChannel0, baseAtlasPixel + ivec2(x, y), 0) * 0.25f;\n                }\n            }\n        }else\n        {\n            if(iMouse.z > 0.5f || iFrame < 10)\n            {\n                vec2 delta0 = vec2(atlasPixel) - vec2(baseSize) * vec2(0.4f, 0.45f);\n                vec2 delta1 = vec2(atlasPixel) - vec2(baseSize) * vec2(0.6f, 0.55f);\n                \n                \n                float dir = 0.0f;\n                vec2 velocity = vec2(0.0f);\n                float density = 0.0f;\n                float color = 0.0f;\n                \n                for(int i = 0; i < 250; i++)\n                {\n                    vec3 particleHash0 = hash3i3f(ivec3(i, 0, 0));\n                    vec3 particleHash1 = hash3i3f(ivec3(i, 1, 0));\n                    vec2 delta = vec2(atlasPixel) - vec2(baseSize) * particleHash0.xy;\n                    if(length(delta) < iResolution.x / 100.0f)\n                    {\n                        velocity = (particleHash1.xy - vec2(0.5f)) * 300.0f * (iMouse.x / iResolution.x);\n                        //velocity += vec2(-delta.y, delta.x) * (particleHash1.z - 0.5f) * 10.0f * (iMouse.y / iResolution.y);\n                        density = 15.0f;\n                        float r = length(delta);\n                        float centMass = density * 3.1415f * r * r;\n                        float centAcc = centMass / max(1e-7f, r * r);\n                        vec2 normDelta = delta / max(1e-7f, length(delta));\n                        vec2 tangentDir = vec2(-normDelta.y, normDelta.x);\n                        float centVelocity = sqrt(centAcc * r);\n                        velocity += tangentDir * centVelocity * (particleHash1.z > 0.0f ? 1.0f : 1.0f);\n                        color = 0.5f;\n                    }\n                }\n                vec2 delta = vec2(0.0f);\n                if(length(delta0) < length(delta1))\n                {\n                    delta = delta0;\n                    dir = 1.0f;\n                }else\n                {\n                    delta = delta1;\n                    dir = -1.0f;\n                }\n                vec4 texturedPixel = (texture(iChannel1, vec2(atlasPixel) / vec2(baseSize)) - vec4(0.2f, 0.2f, 0.0f, 0.0f)) * vec4(vec2(0.0f), 5.0f, 1.0f);\n                vec4 packedPixel = PackPixel(velocity * density, density, color * density);\n                float ratio = pow(max(0.0f, iMouse.y / float(atlasSize.y)), 6.0f);\n                resColor = mix(\n                    texturedPixel,\n                    packedPixel,\n                    ratio);\n            }else\n            {\n                vec4 advectedPixel = GatherAdvectedPixel(iChannel0, atlasPixel, dt);\n                vec2 impulse = GetImpulse(advectedPixel);\n                float density = GetDensity(advectedPixel);                \n                float color = GetColor(advectedPixel);\n                \n\n                vec2 acceleration = vec2(0.0f, 0.0f);\n                {\n                    vec2 uv = (vec2(loc.cascadePixel) + vec2(0.5f)) * float(1 << loc.cascadeIndex) / vec2(baseSize);\n                    vec2 atlasUv = GetAtlasBilinearTapPoint(uv, loc.cascadeIndex + 1u, atlasSize, 1);\n                    acceleration += texture(iChannel0, atlasUv).xy;\n                }\n                impulse += acceleration * density * dt;\n                \n                resColor = PackPixel(impulse, density, color);\n            }\n            //resColor = texelFetch(iChannel1, atlasPixel, 0);\n        }\n    }else\n    if(loc.fieldIndex == 1)\n    {\n        vec2 cascadeRange = vec2(\n            (loc.cascadeIndex == 0u ? 0.0f : GetCascadeDist(loc.cascadeIndex - 1u)) + minDistance,\n            GetCascadeDist(loc.cascadeIndex) + minDistance) * cascade0Dist;\n        vec2 acceleration = IntegrateGravityRangeAcceleration(iChannel0, loc.cascadePixel, loc.cascadeIndex, atlasSize, cascadeRange);\n        if(loc.cascadeIndex + 1u < cascadesCount)\n        {\n            vec2 uv = (vec2(loc.cascadePixel) + vec2(0.5f)) * float(1 << loc.cascadeIndex) / vec2(baseSize);\n            vec2 atlasUv = GetAtlasBilinearTapPoint(uv, loc.cascadeIndex + 1u, atlasSize, 1);\n            //acceleration += texture(iChannel0, atlasUv).xy;\n        }\n        resColor = vec4(acceleration, 0.1f, 0.0f);\n    }\n    fragColor = resColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}