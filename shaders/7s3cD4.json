{
    "Shader": {
        "info": {
            "date": "1656472922",
            "description": "(Click and Drag)\nThis is similar to a raymarcher, but each iteration the light will move a fixed distance and change direction due to gravity, which is modeled with Newtonian gravity. The accretion disk is a textured plane in the shape of a disk.",
            "flags": 0,
            "hasliked": 0,
            "id": "7s3cD4",
            "likes": 8,
            "name": "Raycasting a Black Hole",
            "published": 3,
            "tags": [
                "3d",
                "blackhole",
                "lensing"
            ],
            "usePreview": 0,
            "username": "SpinningCube",
            "viewed": 563
        },
        "renderpass": [
            {
                "code": "// Black Hole Raycasting\n\nconst float pi = 3.1415926536;\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\nvec3 sky(vec3 rayDir) {\n    //vec3 background = 10. * vec3(rayDir.xy, 0.);\n    vec3 background;\n    background = texture(iChannel0, 1. * vec2(atan(rayDir.z, rayDir.x), rayDir.y)).rrr;\n    background = 1.5 * pow(background, vec3(25.));\n    background += .1 * pow(texture(iChannel1, vec2(atan(rayDir.z, rayDir.x), rayDir.y)).rgb, vec3(2.));\n    //background = 2. * pow(background, vec3(2.2));\n    return background * pow(length(rayDir.xz), 2.0);\n}\n\n// A pattern I made for the accretion disk.\nvec3 diskTexture (vec2 pos) {\n    float D = length(pos);\n    float F = min(1., 30. * (D - .95/6.2));\n    F *= F;\n    D = 1. - D;\n    D *= min(1., 10. * D);\n    float D0 = D;\n    D = pow(D, 1.5);\n    D += D0 * D0 * D0 * 0.08 * smoothstep(0., 1., texture(iChannel0, rotate(8. * iTime) * pos/10. + 0.05 * vec2(iTime)).r);\n    float atanvalue = atan(pos.y, pos.x);\n    float sinPatterns = sin(-80. * D + 5. * iTime + -1. * atanvalue) + 0.3 * sin(-152. * D + 3. * iTime + -1. * atanvalue) + 0.2 * sin(-134. * D + 10. * iTime + -1. * atanvalue);\n    //vec3 diskCol = vec3(0.1, 0.7, 1.); // Cyan\n    //vec3 diskCol = vec3(1., 0.45, .2); // Orange\n    float colorShift = -iTime / 2. + 3.;\n    colorShift += 4. * D0;\n    vec3 diskCol = 0.5 * vec3(sin(colorShift) + 1., sin(colorShift + 2. * pi/3.) + 1., sin(colorShift + 4. * pi/3.) + 1.);\n    diskCol = mix(diskCol, vec3(1.), 0.45);\n    \n    diskCol = pow(diskCol, vec3(2.2));\n    return F * D * (0.5 * abs(sinPatterns) + 0.5) * 8. * diskCol;\n}\n\nfloat plane (vec3 rayPos, float y) {\n    return abs(rayPos.y - y);\n}\n\nvec3 ray (vec3 rayPos, vec3 rayDir) { // Might be better described as a \"photon\" instead of a ray\n    vec3 cam = rayPos;\n    float moveDist = 1.;\n    for (int i = 0; i < 600; i++) {\n        rayDir = normalize(rayDir - 10. * 0.5 * moveDist * normalize(rayPos)/(20. * length(rayPos) * length(rayPos)) ); // Gravity\n        \n        bool diskBool = false || (length(rayPos.xz) < 6. && length(rayPos.xz) > .95);\n        bool diskBool2 = false || (length(rayPos.xz) < 6. && length(rayPos.xz) > .95);\n        \n        float minDist = plane(rayPos, 0.) - 0.04;\n        moveDist = min(minDist + float(!diskBool2), .1);\n        //moveDist = .1;\n        rayPos += 0.5 * moveDist * rayDir;\n        \n        if (diskBool && minDist < 0.01) {\n            return diskTexture(rayPos.xz/6.2);\n        }\n        \n    }\n    vec3 sky = mix(sky(rayDir), sky(rayDir.yzx), 0.5);\n    return float(length(rayPos) > 10.) * sky;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates\n    vec2 screen = (fragCoord - iResolution.xy/2.)/min(iResolution.x, iResolution.y);\n    \n    vec3 col;\n    \n    // texture test\n    col = diskTexture(screen.xy);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5);\n    \n    if (mouse == vec2(-0.5)) {\n        mouse = vec2(0., -.02);\n    }\n    \n    vec3 cam = vec3(0, 0, -11);\n    vec3 rayDir = normalize(vec3(screen.xy, 1.2));\n    \n    cam.yz *= rotate(pi * -mouse.y);\n    cam.xz *= rotate(2. * pi * -mouse.x);\n    //rayDir.xy *= rotate(-.4);\n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2. * pi * -mouse.x);\n    \n    col = ray(cam, rayDir);\n    col *= 1.5; col = vec3(tanh(col.r), tanh(col.g), tanh(col.b)); // Lazy tonemapping\n    \n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1./2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}