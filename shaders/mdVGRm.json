{
    "Shader": {
        "info": {
            "date": "1678352641",
            "description": "gradient color blend 2",
            "flags": 0,
            "hasliked": 0,
            "id": "mdVGRm",
            "likes": 1,
            "name": "gradient color blend 2",
            "published": 3,
            "tags": [
                "gradientcolorblend2"
            ],
            "usePreview": 0,
            "username": "tianluo97",
            "viewed": 149
        },
        "renderpass": [
            {
                "code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    \n    //cubicPulse动态混合过程\n    //earthmap\n    float divisionLine1 = 1.3/19.0 + 0.02;\n    //digital hardware\n    float divisionLine2 = 3.5/19.0;\n    //machine social network\n    float divisionLine3 = 6.6/19.0;\n    //FE\n    float divisionLine4 = 10.0/19.0;\n    //operation center\n    float divisionLine5 = 13.0/19.0;\n    //logo\n    float divisionLine6 = 16.0/19.0;\n    \n    float divisonTime;\n    float divisionLine;\n\n    \n    //from earthmap to digital hardware\n    //divisionLine = divisionLine1 + (divisionLine2 - divisionLine1) * smoothstep(0.0,1.0,iTime);\n    \n    //from digital hardware to machine social network\n    //divisionLine = divisionLine2 + (divisionLine3 - divisionLine2) * smoothstep(0.0,1.0,iTime);\n    \n    //from machine social network to FE\n    //divisionLine = divisionLine3 + (divisionLine4 - divisionLine3) * smoothstep(0.0,1.0,iTime);\n    \n    //from FE to operation center\n    //divisionLine = divisionLine4 + (divisionLine5 - divisionLine4) * smoothstep(0.0,1.0,iTime);\n    \n    //from operation center to logo\n    //divisionLine = divisionLine5 + (divisionLine6 - divisionLine5) * smoothstep(0.0,1.0,iTime);\n    \n    float d = cubicPulse(divisionLine1,0.21,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    //maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    \n    //深色色板\n    float PI = 3.1415926;\n    float time = iTime * 0.05; \n    float scale = 0.5;\n    \n    vec4 vcolor0 = vec4(0.180,0.427,1.000,1.0);\n    vec4 vcolor1 = vec4(0.259,0.459,1.000,1.0);\n    vec4 vcolor2 = vec4(0.420,0.576,1.000,1.0);\n    vec4 vcolor3 = vec4(1.000,0.475,0.302,1.0);\n    vec4 vcolor4 = vec4(1.000,0.749,0.502,1.0);\n    \n    float step0 = 0.22 * scale;\n    float step1 = 0.45 * scale;\n    float step2 = 0.65 * scale;\n    float step3 = 0.80  * scale;\n    \n    float offset = uv.x-0.35-time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor; \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    //darkColor = correct(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    darkColor = correct(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor3, dist2);\n    //darkColor = correct(vcolor2, vcolor3, dist2);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    darkColor = mix(vcolor3, vcolor4, dist02);\n    darkColor = correct(vcolor3, vcolor4, dist02);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    darkColor = mix(vcolor4, vcolor0, dist3);\n    darkColor = correct(vcolor4, vcolor0, dist3);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //浅色色板\n    float qscale = 0.5;\n    float qtime = iTime* 0.05;\n    \n    vec4 qcolor0 = vec4(0.502,0.557,1.000,1.0);\n    float brightness = 0.20;\n\tfloat contrast = 1.0;\n    float saturation = 1.0;\n    qcolor0 = saturationMatrix(saturation) * qcolor0; \n    brightnessAdjust(qcolor0, brightness); \n    contrastAdjust(qcolor0, contrast); \n    \n    vec4 qcolor1 = vec4(0.439,0.580,1.000,1.0);\n    float brightness1 = 0.30;\n\tfloat contrast1 = 1.0;\n    float saturation1 = 1.0;\n    qcolor1 = saturationMatrix(saturation1) * qcolor1; \n    brightnessAdjust(qcolor1, brightness1); \n    contrastAdjust(qcolor1, contrast1); \n    \n    vec4 qcolor2 = vec4(1.000,0.447,0.078,1.0);\n    float brightness2 = 0.3;\n\tfloat contrast2 = 1.5;\n    float saturation2 = 0.6;\n    qcolor2 = saturationMatrix(saturation2) * qcolor2; \n    brightnessAdjust(qcolor2, brightness2); \n    //contrastAdjust(qcolor2, contrast2); \n    \n    vec4 qcolor3 = vec4(1.000,0.671,0.400,1.0);\n    float brightness3 = 0.45;\n\tfloat contrast3 = 1.2;\n    float saturation3 = 0.9;\n    qcolor3 = saturationMatrix(saturation3) * qcolor3; \n    brightnessAdjust(qcolor3, brightness3); \n    contrastAdjust(qcolor3, contrast3); \n\n    vec4 qcolor4 = vec4(0.580,0.686,1.000,1.0);\n    float brightness4 = 0.15;\n\tfloat contrast4 = 1.0;\n    float saturation4 = 1.0;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4);\n    \n    float qstep0 = 0.3 * qscale;\n    float qstep1 = 0.5 * qscale;\n    float qstep2 = 0.65 * qscale;\n    float qstep3 = 0.85 * qscale;\n    \n    float qoffset = uv.x+0.2-qtime;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    lightColor = vec4(dist0);\n    lightColor = mix(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    lightColor = vec4(dist1);\n    lightColor = mix(qcolor1, qcolor2, dist1);\n    }\n    \n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    lightColor = vec4(dist2);\n    lightColor = mix(qcolor2, qcolor3, dist2);\n    }\n    \n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    lightColor = vec4(dist02);\n    lightColor = mix(qcolor3, qcolor4, dist02);\n    }\n    \n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    lightColor = vec4(dist3);\n    lightColor = mix(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    \n    //最终混合后的fragColor\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //从night状态开始激活\n    vec4 nightColor1 = vec4(0.000,0.067,0.259,1.0);\n    vec4 nightColor0 = vec4(0.000,0.165,0.620,1.0);\n    vec4 nightColor = mix(nightColor0, nightColor1, pow(uv.x,1.));\n    nightColor = sqrt(nightColor);\n    \n    //night to awake\n\t//fragColor = mix(nightColor, fragColor, smoothstep(0.0,1.0,iTime*0.2));\n    \n    //adding mask\n    float endMask = smoothstep(0.6,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.702,0.788,1.000,1.0);\n    fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    //Debug\n    //fragColor = vec4(maskColor,1.0);\n    //fragColor = vec4(lightColor);\n    //fragColor = vec4(darkColor);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n    if (uv.y<-0.1&&uv.y > -1.2){\n    fragColor = vec4(darkColor);\n    }\n    if (uv.y<-1.3&&uv.y > -2.4){\n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    darkColor = correct(vcolor0, vcolor1, dist0);\n    darkColor = vec4(dist0,dist0,dist0,1.0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    //darkColor = correct(vcolor1, vcolor2, dist1);\n    darkColor = vec4(dist1,dist1,dist1,1.0);\n    }\n    \n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor3, dist2);\n    darkColor = correct(vcolor2, vcolor3, dist2);\n    darkColor = vec4(dist2,dist2,dist2,1.0);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    darkColor = mix(vcolor3, vcolor4, dist02);\n    darkColor = correct(vcolor3, vcolor4, dist02);\n    darkColor = vec4(dist02,dist02,dist02,1.0);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    darkColor = mix(vcolor4, vcolor0, dist3);\n    //darkColor = correct(vcolor4, vcolor0, dist3);\n    darkColor = vec4(dist3,dist3,dist3,1.0);\n    }\n    \n    //darkColor = sqrt(darkColor);\n    //fragColor = darkColor;\n    }\n    \n    if (uv.y<-2.5&&uv.y > -3.6){\n    //fragColor = vec4(lightColor);\n    }\n    if (uv.y<-3.7&&uv.y > -4.8){\n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    lightColor = vec4(dist0);\n    //lightColor = mix(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    }\n    \n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    lightColor = vec4(dist2);\n    //lightColor = mix(qcolor2, qcolor3, dist2);\n    }\n    \n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    lightColor = vec4(dist02);\n    //lightColor = mix(qcolor3, qcolor4, dist02);\n    }\n    \n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    lightColor = vec4(dist3);\n    //lightColor = mix(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    \n    //fragColor = vec4(lightColor);\n    \n    }\n   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}