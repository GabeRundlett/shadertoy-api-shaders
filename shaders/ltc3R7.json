{
    "Shader": {
        "info": {
            "date": "1468376822",
            "description": "After much trial and error a supernova explosion has become a more earthly gasoline/gas explosion. You can zoom in with 1,2,3 keys and mouse left-right axis orbits the camera. Now with more substance and better fade-in/fade-outs!",
            "flags": 16,
            "hasliked": 0,
            "id": "ltc3R7",
            "likes": 73,
            "name": "Gas Explosion",
            "published": 3,
            "tags": [
                "explosion",
                "fire",
                "volumetric",
                "smoke",
                "looping",
                "gas"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 6894
        },
        "renderpass": [
            {
                "code": "// Based on https://www.shadertoy.com/view/lsySzd\n//\n// \"Volumetric explosion\" by Duke\n//-------------------------------------------------------------------------------------\n// Based on \"Supernova remnant\" (https://www.shadertoy.com/view/MdKXzc) \n// and other previous shaders \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n//\n// And based on https://www.shadertoy.com/view/XlcGRn\n//\n// \"Space Elevator\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// And based on https://www.shadertoy.com/view/4djSRW\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n//\n// With varous small tweaks to have the effect play nice against a colorful background,\n// keeping the black smoky look.\n//\n// Explosion colors\nconst vec3 veDensityBeg  = vec3(0.22,0.16,0.046);\nconst vec3 veDensityEnd  = vec3(0.403,0.291,0.216);\nconst vec3 veMediaCenter = vec3(0.305,0.49,0.616);\nconst vec3 veMediaEdge   = vec3(0.918,0.796,0.495);\n// Sky colors\nconst vec3 veColSkyHigh = vec3(0.0, 0.1, 0.3);\nconst vec3 veColSkyLow  = vec3(0.2, 0.4, 0.6);\nconst vec3 veColStars   = vec3(0.8, 0.9, 1.0);\nconst float accuscale = -0.005;\nconst float scalestar = 18.1  ;\nconst float subdiv    = 11.714;\nconst float variable  = 0.612 ;\nconst float variable2 = 1.171 ;\n// Default\nconst bool veBOTH         = !false;\nconst bool veLEFT         = !true ;\nconst bool veLOW_QUALITY  = false;\nconst bool veDITHERING    = !true ;\nconst bool veTONEMAPPING  = false;\nconst bool veBackground   = true ;\nconst float veBackgroundCutoff      = 0.891;\nconst float veBackgroundCutoffStart = 0.387;\n\nvec4 iiMouse;\n#define iMouse iiMouse\n//-------------------\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n#define pi 3.14159265\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n    return (x < 0.) ? -1. : 1.;\n}\nvec2 sgn(vec2 v) {\n    return vec2(sgn(v.x),sgn(v.y));\n}\nvec3 sgn(vec3 v) {\n    return vec3(sgn(v.x),sgn(v.y),sgn(v.z));\n}\n\nvoid veR( inout vec2 p, in float a) {\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// iq's noise\nfloat veNoise( in vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn 1. - 0.82 * mix(rg.x, rg.y, f.z);\n}\n\nfloat veFBM(vec3 p) {\n\treturn veNoise(p * .06125) * .5 + veNoise(p * .125) * .25\n\t\t\t+ veNoise(p * .25) * .125 + veNoise(p * .4) * .2;\n}\n\nfloat veSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nfloat veExplosionRadius(float maxRadius, float veProgress) {\n    return mix(1.0/8.0,1.0, sqrt(veProgress))*maxRadius;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float veNudge = 100.3 * 4.;\t// size of perpendicular vector\nfloat veNormalizer = 1.0 / sqrt(1.0 + veNudge * veNudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat veSpiralNoiseC(vec3 p) {\n\tfloat n = 0.0; // noise amount\n\tfloat iter = 2.0;\n\tfor (int i = 0; i < 8; i++) {\n\t\t// add sin and cos scaled inverse with the frequency\n\t\tn += -abs(sin(p.y * iter) + cos(p.x * iter)) / iter; // abs for a ridged look\n\t\t// rotate by adding perpendicular and scaling down\n\t\tp.xy += vec2(p.y, -p.x) * veNudge;\n\t\tp.xy *= veNormalizer;\n\t\t// rotate on other axis\n\t\tp.xz += vec2(p.z, -p.x) * veNudge;\n\t\tp.xz *= veNormalizer;\n\t\t// increase the frequency\n\t\titer *= 1.733733;\n\t}\n\treturn n;\n}\n\nfloat veVolumetricExplosion(vec3 p, float radius, float maxRadius, float veProgress) {\n    float sdSphere = veSphere(p, radius)*(4. * 1.92 *.25/1.92 * 1.0*        veExplosionRadius(8.0,1.0)/maxRadius);\n    float noise1 = (veLOW_QUALITY) ? veNoise(p * 12.5) * .2 : veFBM(p * 50.);\n    float age = mix(2.0, -7.5, 1.-pow(1.-veProgress,2.5));\n    float noise2 = veSpiralNoiseC(p.zxy * 0.4132 + 0.333*vec3(0,0,1) * (25.*veProgress+max(0.,iMouse.x-15.0) * 0.1));\n    float result = min(0.,sdSphere)*.999 +\n        (0.25+1.75*veProgress+3.*veProgress*veProgress+4.*veProgress*veProgress*veProgress)*max(0.,sdSphere) +\n        0.999*noise1 +\n        0.999*age +\n        0.999*(noise2+1.0/1.25) * 1.25;\n\treturn result;\n}\n\nfloat veMap(vec3 p, float maxRadius, float count, float veProgress) {\n\tveR(p.yz, -6. * (1.-sqrt(veProgress)));\n\tveR(p.zx, count + iMouse.x * 0.008 * pi + 0.0*4. * veProgress);\n    //p += so;\n    //p -= so;\n    if(maxRadius == 1.0) {\n    return veVolumetricExplosion(p * 1.*8.0, \n                                               4. * 1.92 *.25/1.92 * veProgress* veExplosionRadius(8.0,veProgress),\n                                               4. * 1.92 *.25/1.92 * 1.0*        veExplosionRadius(8.0,1.0),\n                                               veProgress)/ 1.;\n    }\n    float VolExplosion = veVolumetricExplosion(p * 1.5, \n                                               4. * 1.92 *.25/1.92 * veProgress* veExplosionRadius(maxRadius,veProgress),\n                                               4. * 1.92 *.25/1.92 * 1.0*        veExplosionRadius(maxRadius,1.0),\n                                               veProgress)/ 1.5;\n\treturn VolExplosion;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 veComputeColor(float density, float radius, float maxRadius) {\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix(veDensityBeg, veDensityEnd, 1. - density);\n\n\t// color added to the media\n\tvec3 colCenter = 7. * veMediaCenter;\n\tvec3 colEdge = 1.5 * veMediaEdge;\n\tresult *= mix(colCenter, colEdge, min((radius + .05) / .9, 1.15));\n\n\treturn result;\n}\n\nvec3 veSphereIntersect(vec3 ro, vec3 rd, vec3 so, float radius) {\n    vec3 sr = ro - so;\n    float tsr = dot(sr, rd);\n    float delta = radius * radius - dot(sr, sr) + tsr * tsr;\n    float deltasqrt = (delta < 0.0) ? 0.0f : sqrt(delta);\n    float t0 = -tsr - deltasqrt;\n    float t1 = -tsr + deltasqrt;\n    return vec3(t0, t1, -tsr);\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 veToneMapFilmicALU(vec3 _color) {\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2 * _color + vec3(0.5)))\n\t\t\t/ (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvec3 veAddZoom(vec3 rd, vec3 ro) {\n\tconst float KEY_1 = 49.5 / 256.0;\n\tconst float KEY_2 = 50.5 / 256.0;\n\tconst float KEY_3 = 51.5 / 256.0;\n\tfloat key = 0.0;\n\tkey += 0.7 * texture(iChannel1, vec2(KEY_1, 0.25)).x;\n\tkey += 1.4 * texture(iChannel1, vec2(KEY_2, 0.25)).x;\n\tkey += 2.1 * texture(iChannel1, vec2(KEY_3, 0.25)).x;\n\treturn ro - (ro - rd) * key * 1.6 / 6.;\n}\n\nconst vec4 vecHashA4 = vec4(0., 1., 57., 58.);\nconst vec3 vecHashA3 = vec3(1., 57., 113.);\nconst float vecHashM = 43758.54;\n\nvec4 veHashv4f(float p) {\n\treturn fract(sin(p + vecHashA4) * vecHashM);\n}\n\nfloat veNoisefv2(vec2 p) {\n\tvec4 t;\n\tvec2 ip, fp;\n\tip = floor(p);\n\tfp = fract(p);\n\tfp = fp * fp * (3. - 2. * fp);\n\tt = veHashv4f(dot(ip, vecHashA3.xy));\n\treturn mix(mix(t.x, t.y, fp.x), mix(t.z, t.w, fp.x), fp.y);\n}\n\nfloat veNoisefv3(vec3 p) {\n\tvec4 t1, t2;\n\tvec3 ip, fp;\n\tfloat q;\n\tip = floor(p);\n\tfp = fract(p);\n\tfp = fp * fp * (3. - 2. * fp);\n\tq = dot(ip, vecHashA3);\n\tt1 = veHashv4f(q);\n\tt2 = veHashv4f(q + vecHashA3.z);\n\treturn mix(mix(mix(t1.x, t1.y, fp.x), mix(t1.z, t1.w, fp.x), fp.y),\n\t\t\tmix(mix(t2.x, t2.y, fp.x), mix(t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat veFbm3(vec3 p) {\n\tfloat f, a;\n\tf = 0.;\n\ta = 1.;\n\tfor (int i = 0; i < 5; i++) {\n\t\tf += a * veNoisefv3(p);\n\t\ta *= 0.5;\n\t\tp *= 2.;\n\t}\n\treturn f;\n}\n\nfloat veFbmn(vec3 p, vec3 n) {\n\tvec3 s;\n\tfloat a;\n\ts = vec3(0.);\n\ta = 1.;\n\tfor (int i = 0; i < 5; i++) {\n\t\ts += a * vec3(veNoisefv2(p.yz), veNoisefv2(p.zx), veNoisefv2(p.xy));\n\t\ta *= 0.5;\n\t\tp *= 2.;\n\t}\n\treturn dot(s, abs(n));\n}\n\nvec3 veSpaceCol(vec3 ro, vec3 rd) {\n\tvec3 rds, col;\n\trds = floor(2000. * rd);\n\trds = 0.00015 * rds + 0.1 * veNoisefv3(0.0005 * rds.yzx);\n\tfor (int j = 0; j < 19; j++)\n\t\trds = abs(rds) / dot(rds, rds) - 0.9;\n\tcol = veColStars * min(1., 0.5e-3 * pow(min(6., length(rds)), 5.));\n\tfloat s = pow(max(0., abs(dot(rd, vec3(0.0, 1.0, 0.0)))), 1.60);\n\tcol = veColSkyLow + col * (1. - smoothstep(0.9, 1., s));\n\ts = pow(s, 128.);\n\tcol += veColSkyHigh * (0.2 * s + 0.9 * pow(s, 8.));\n\treturn col;\n}\n//----------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n\tp3 += dot(p3, p3.yxz + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n\tp3 += dot(p3, p3.yxz + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n// From iq's website\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\nfloat parabola(float x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), k);\n}\nvec4 parabola(vec4 x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), vec4(k));\n}\nvec3 parabola(vec3 x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), vec3(k));\n}\nfloat pcurve(float x, float a, float b) {\n\tfloat k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n\treturn k * pow(x, a) * pow(1.0 - x, b);\n}\nvec3 veStars(vec3 ro, vec3 rd) {\n\tvec3 bs[8];\n\tvec3 srd = rd;\n\tfloat size = floor(subdiv);\n\trd *= length(rd) / max(abs(rd.x), max(abs(rd.y), abs(rd.z)));\n\trd *= size;\n\tvec3 lower = floor(rd + 0.5);\n\tvec3 point = rd - lower;\n\tvec3 ba = rd - ro;\n\tvec3 nba = normalize(ba);\n\tfloat ilba = 1.0 / dot(ba, ba);\n\tvec3 nbatilba = nba * ilba;\n\tfloat d = 99999999.0;\n    \n\tfor (int xi = -1; xi <= 1; xi++) {\n\t\tfor (int yi = -1; yi <= 1; yi++) {\n\t\t\tfor (int zi = -1; zi <= 1; zi++) {\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\tvec3 box = lower + vec3(float(xi), float(yi), float(zi));\n\t\t\t\t\tvec4 a = vec4(0.0);\n\t\t\t\t\tfor (int t = 0; t < 4; t++) {\n\t\t\t\t\t\tfloat v = float(t + 1) * .152;\n\t\t\t\t\t\tvec3 pos = (box * v + float(5 * i));\n\t\t\t\t\t\ta += hash43(pos);\n\t\t\t\t\t}\n\t\t\t\t\tvec3 local = a.xyz / 4.0 - 0.5;\n\t\t\t\t\tfloat dist = sdCapsule(ro + srd, ro, ro + box + local,\n\t\t\t\t\t\t\ta.w * accuscale);\n\t\t\t\t\td = min(d, dist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvec3 result = pow(\n\t\t\tclamp(pcurve(d * scalestar, 0.0, 1.0 + 31.0 * variable), 0.0, 1.0),\n\t\t\tvariable2) * veColStars;\n\treturn result;\n}\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1)*step(t1.zxy,t1);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\nfloat sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 oiMouse=clamp(iMouse,vec4(0.),iResolution.xyxy-1.);\n    iMouse=vec4(0);\n\tvec2 uv = fragCoord / iResolution.xy;\n    float veProgress = mod(iTime * 0.1, 1.);\n    float count = floor(iTime * 0.1);\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y-vec2(0,0.5), 1.));\n\tvec3 ro = vec3(0., 8., -16.);\n\tro = veAddZoom(rd, ro);\n    if(iMouse.z>0.) {\n        veR(rd.yz, max(0.,iMouse.y-50.) / iResolution.y * 2.508 * pi);\n    } else {\n        float a = pi*sin(iTime*.5)*.375*0.0;\n        veR(rd.yz, a);\n    }\n    float tmin=-1.0;\n    vec3 nor;\n    vec3 pos;\n    vec3 colb;\n\n    float nearest = 1e9;\n    vec3 nearestOrigin = vec3(-1);\n    float nearestProgress = 0.0;\n\n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld = 0., td = 0., w = 0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat density = 1., t = 0.;\n\tconst float h = 0.1;\n\tvec4 sum = vec4(0.0);\n    //veProgress = fract(veProgress*1.+0.5+0.0*((gl_FragCoord.x>=.5*iResolution.x)?.3:.7));\n    vec3 so = 0.0*((uv.x>=0.5)?vec3(7.0+2.0*veProgress,-11.+17.*veProgress,5):vec3(-7.0-2.0*veProgress,-12.+18.*veProgress,5))+0.5;\n    float maxRadius = 16.0;\n    vec4 fix = vec4(39,59,759,420);//oiMouse;\n    vec4 fix1 = exp2((  mod(fix,(2.*vec4(20,15,20,15)))/(2.*vec4(20,15,20,15)-1.))*2.0-1.);\n    vec4 fix2 = exp2((floor(fix/(2.*vec4(20,15,20,15)))/(1.*vec4(20,15,20,15)-1.))*2.0-1.);\n    fix1=mix(fix1,vec4(0.5),smoothstep(0.5,0.75,veProgress));\n    fix2=mix(fix2,vec4(0.5),smoothstep(0.5,0.75,veProgress));\n    //fix2.x=1.0;\n    vec3 intersect = veSphereIntersect(ro, rd, so, veExplosionRadius(maxRadius,veProgress));\n\tfloat min_dist = intersect.x, max_dist = intersect.y;\n    const bool veDev = true;\n\tif (min_dist != max_dist && max_dist > 0.0) {\n\t\tt = min_dist;\n\t\t// raymarch loop\n\t\tfor (int i = 0; i < 86; i++) {\n\t\t\tif (veLOW_QUALITY && i >= 56) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec3 pos = ro + t * rd;\n            //pos= (pos-0.5)*pow(vec3(1.+abs(0.5-uv.x)*2.),vec3(0,-0.75,0))+0.5;\n\t\t\t// Loop break conditions.\n\t\t\tif (td > 0.99 || t > max_dist)\n\t\t\t\tbreak;\n\t\t\t// evaluate distance function\n\t\t\tfloat d = veMap(pos-so, maxRadius, count, veProgress);\n\t\t\tif (!veBOTH && veLEFT || veBOTH && uv.y < 0.5) {\n                d = (abs(d) + 0.07/fix1.x);\n            } else {\n                float v = 1.-(1.-veProgress)*sqrt(1.-veProgress);\n                v = sqrt(veProgress);\n                v = smoothstep(0.03125,0.5,1.0-v);\n                v = pcurve(veProgress,0.25,4.5);\n                d = mix(abs(d) + 0.07/fix1.x, d, v);\n            }\n\t\t\t// change this string to control density\n\t\t\td = max(mix(d, 10.0, 0.*smoothstep(0.75,1.0,veProgress)), 0.00000003); //0.03 less detail\n\t\t\t// point light calculations\n\t\t\tvec3 ldst = so - pos;\n            \n\t\t\tfloat lDist = max(length(ldst)*fix2.x, 0.01);//0.1, 0.000000000000001 it's all the same\n\t\t\t// the color of light\n\t\t\tvec3 lightColor = vec3(1.0, 0.5, 0.25);\n\t\t\t// bloom\n\t\t\tvec3 halo = lightColor / exp(pow(lDist, 3.) * 0.108/fix1.z);\n\t\t\tsum.rgb += halo * (0.0333*fix2.z * smoothstep(0.5, 0.1, veProgress) + smoothstep(.125, .0, veProgress));\n            if(!veDev && h >= d) {\n\t\t\t    td += 1. / 70. + (sin(7.*d+ veProgress)+1.-veProgress)/128.*smoothstep(.3, .125, abs(veProgress-0.7));\n\n//\t\t\t\tld = (d < h*fix) ? h*fix - d : max(0.,0.2*fix - d);\n\t\t\t\t// compute weighting factor\n//\t\t\t\tw = (1. - td) * ld;\n\t\t\t\t// accumulate density\n//\t\t\t\ttd += w/fix;\n//\t\t\t\ttd += (d < h*fix) ? 1. / 200000. : 1. / 70.*fix + (sin(7.*d + veProgress)+1.-veProgress)/128.*smoothstep(.3, .125, abs(veProgress-0.7));\n\n            } else {\n\t\t\t\t// compute local density\n                float choice = smoothstep(-0.5*h,0.5*h, d - h);\n\t\t\t\tld = mix(h - d, max(0.2*fix1.w - d,0.), choice);\n\t\t\t\t// compute weighting factor\n\t\t\t\tw = (1. - td) * ld;\n\t\t\t\t// accumulate density\n\t\t\t\ttd += w/fix2.w;\n\t\t\t\ttd += mix(1./((fix1.y-0.5)/1.5*199930.+70.), fix2.y*1. / 70. + (sin(7.*d + veProgress)+1.-veProgress)/128.*smoothstep(.3, .125, abs(veProgress-0.7)),choice);\n\t\t\t\tvec4 col = vec4(veComputeColor(td, lDist, maxRadius), mix(td, td * w, choice));\n\t\t\t\t// emission\n\t\t\t\tsum += sum.a * vec4(sum.rgb, 0.0) * 0.2 / lDist;\n\t\t\t\t// uniform scale density\n\t\t\t\tcol.a *= 0.2;\n\t\t\t\t// colour by alpha\n\t\t\t\tcol.rgb *= col.a;\n\t\t\t\t// alpha blend in contribution\n\t\t\t\tsum = sum + col * (1.0 - sum.a);\n            }\n            float dither;\n\t\t\tif (veDITHERING) {\n\t\t\t\t// idea from https://www.shadertoy.com/view/lsj3Dw\n\t\t\t\tdither = texture(iChannel2, vec2(120.0* uv.y, -280.0* uv.x+ 0.5* sin(4.* veProgress+ 480.0* uv.y))).r;\n            } else {\n\t\t\t\tdither = 0.5;\n            }\n            d *= .8 + 0.08 * dither;\n\t\t\t// trying to optimize step size\n            float stepMult = (veLOW_QUALITY) ? 0.25 : max(0.08 * min(length(ldst), d), 0.16);\n            t += max(d * stepMult, 0.01);\n\t\t}\n\t\t// simple scattering\n        sum *= 1. / exp(ld * 0.2) * ((veLOW_QUALITY) ? 0.9 : 0.8);\n\t\tsum = clamp(sum, 0.0, 1.0);\n\t\tsum.xyz = sum.xyz * sum.xyz * (3.0 - 2.0 * sum.xyz);\n\t}\n\n    float pass = smoothstep(veBackgroundCutoff, veBackgroundCutoffStart, td);\n    sum.xyz += colb * pass * (1.0 - sum.a);\n    if(tmin>0.0){sum.a=1.0;}\n\tif (veBackground) {\n\t\t// stars background\n\t\t//vec3 stars = vec3(veNoise(rd * 200.0) * 0.5 + 0.5);\n\t\tvec3 stars = veStars(ro, rd);\n\t\tvec3 starbg = mix(veColSkyHigh, veColSkyLow,\n\t\t\t\tabs(1.5 * dot(normalize(rd), vec3(0., 1., 0.))));\n\t\t//vec3 starbg = mix(veColSkyHigh, veColSkyLow, uv.y);\n\t\t//vec3 brightness = smoothstep(0.95, 1.0, stars);\n\t\t//float limits = dot(vec3(0.0), rd) + 0.75;\n\t\t//starbg += veColStars * brightness * limits;\n//\t\tif (td < veBackgroundCutoff) {\n//\t\t}\n\t\t//starbg *= pass;\n\t\tsum.xyz += (starbg + stars) * pass * (1.0 - sum.a);\n\t\t//sum.xyz += (veSpaceCol(ro, rd) * pass + starbg) * (1.0 - sum.a);\n\t\t//sum.xyz += veSpaceCol(ro, rd) * (1 - sum.a);\n\t}\n\n\tif (veTONEMAPPING) {\n\t\tsum.xyz = veToneMapFilmicALU(sum.xyz * 2.2);\n\t}\n    fragColor = vec4(sum.xyz, 1.0);\n    //gl_FragColor = fragColor;\n}\n#undef iMouse\nvoid mainImage(out vec4 O, in vec2 U){iiMouse=iMouse;mainImage1(O,U);}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}