{
    "Shader": {
        "info": {
            "date": "1531419021",
            "description": "A revised version; use mouse to override automatic view selection and look around.",
            "flags": 32,
            "hasliked": 0,
            "id": "4l3cz8",
            "likes": 12,
            "name": "River Flight 2",
            "published": 3,
            "tags": [
                "landscape",
                "aircraft",
                "flight"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 812
        },
        "renderpass": [
            {
                "code": "// \"River Flight 2\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\n\nmat3 flMat;\nvec3 flPos, flVd, enPos, qHit, qHitTr, sunDir, trkA, trkF;\nfloat dstFar, tCur, szFac, wSpan, flVel;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat WingDf (vec3 p, float span, float sRad, float trans, float thck, float tapr)\n{\n  float s, dz;\n  s = abs (p.x - trans);\n  dz = s / span;\n  return max (length (abs (p.yz) + vec2 (sRad + tapr * dz * dz * dz, 0.)) - thck, s - span);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, fusLen, wSweep, taPos, d, wr, ws, cLen;\n  fusLen = (11./13.) * wSpan;\n  wSweep = 0.11;\n  taPos = (12.5/13.) * wSpan;\n  p = flMat * (p - flPos);\n  dMin = dstFar / szFac;\n  p /= szFac;\n  q = p;\n  wr = q.z / fusLen;\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.045 + 0.08 * wr, 0.),\n     0.11 * fusLen, 0.46 * fusLen);\n  DMINQ (1);\n  d = PrCapsDf (q - fusLen * vec3 (0., 0., -0.32),\n     (0.15 - 0.07 * wr * wr) * fusLen, fusLen);\n  if (d < dMin + 0.1) {\n    dMin = SmoothMin (dMin, d, 0.1);  idObj = 2;  qHit = q;\n  }\n  ws = wSweep * abs (p.x) / wSpan;\n  q = p + vec3 (0., 0.054 * fusLen - 6. * ws, 0.12 * fusLen + 12. * ws);\n  d = WingDf (q, wSpan, 13.7, 0., 14., 0.3);\n  if (d < dMin + 0.2) {\n    dMin = SmoothMin (dMin, d, 0.2);  idObj = 3;  qHit = q;\n  }\n  q = p + vec3 (0., -0.1 - 6. * ws, taPos + 12. * ws);\n  d = WingDf (q, 0.37 * wSpan, 6.8, 0., 7., 0.3);\n  DMINQ (4);\n  ws = wSweep * abs (p.y) / wSpan;\n  q = p.yxz + vec3 (0.5, 0., taPos + 12. * ws);\n  d = WingDf (q, 0.16 * wSpan, 6.8, 2.2, 7., 0.3);\n  DMINQ (5);\n  q = p;\n  q.x = abs (q.x);\n  cLen = 3.5;\n  wr = q.z / cLen;\n  d = max (PrCylDf (q - enPos, (0.2  - 0.07 * wr * wr) * cLen, cLen),\n     - PrCylDf (q - enPos, 0.04 * cLen, 1.02 * cLen));\n  DMINQ (6);\n  d = PrConeDf (q - enPos - vec3 (0., 0., 4.2), vec3 (0.8, 0.6, 0.7));\n  DMINQ (7);\n  return 0.8 * dMin * szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 180; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  p = flMat * (p - flPos);\n  dMin = dstFar / szFac;\n  p /= szFac;\n  q = p;\n  q.x = abs (q.x);\n  q -= enPos;\n  d = PrCylDf (q - vec3 (0., 0., 3.65), 1.9, 0.05);\n  if (d < dMin) {\n    dMin = d;\n    qHitTr = q;\n  }\n  return dMin * szFac;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.07 * szFac;\n  for (int j = 0; j < 24; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.07 * szFac;\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 3.3 + 0.8 * sin (0.05 * t), t);\n}\n\nvec3 TrackDir (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float wAmp, h, w;\n  w = smoothstep (1.5, 4.5, sqrt (abs (p.x - TrackPath (p.y).x)));\n  h = -2.;\n  if (w > 0.) {\n    q = 0.07 * p;\n    qRot = 2.2 * mat2 (0.8, -0.6, 0.6, 0.8);\n    h = -0.4;\n    wAmp = 15.;\n    for (int j = 0; j < 4; j ++) {\n      h += wAmp * Noisefv2 (q);\n      wAmp *= -0.35;\n      q *= qRot;\n    }\n  }\n  h = mix (-2., h, w);\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0. || s > dstFar) break;\n    sLo = s;\n    s += max (0.01 * s, 0.4 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 FlyerCol (vec3 vn)\n{\n  vec3 col;\n  vec2 ws;\n  vec3 bCol = vec3 (0.9, 0.9, 1.), wCol = vec3 (0.9, 0.7, 0.1), uCol = vec3 (0.9, 0.4, 0.4);\n  float cLine, s1, s2;\n  cLine = 1.;\n  if (idObj >= 3 && idObj <= 5) {\n    if (idObj == 3) {\n      s1 = 1.8;  s2 = 6.;\n    } else if (idObj == 4) {\n      s1 = 1.1;  s2 = 1.1;\n    } else if (idObj == 5) {\n      s1 = 1.1;  s2 = 1.2;\n    }\n    if (abs (qHit.x) > s2 - 0.03) cLine = 1. - 0.5 * SmoothBump (- 0.08, 0.08, 0.02, qHit.z + s1);\n    if (qHit.z < - s1) cLine = 1. - 0.5 * SmoothBump (- 0.05, 0.05, 0.02, abs (qHit.x) - s2);\n  }\n  if (idObj == 1 || idObj == 2) {\n    col = mix (uCol, bCol, 1. - smoothstep (-0.6, 0., vn.y));\n    if (idObj == 2 && vn.y < 0.) col = mix (bCol, wCol, SmoothBump (0., 3., 0.1, qHit.z + 1.45));         \n  } else if (idObj == 3 || idObj == 4) col = mix (bCol, wCol, SmoothBump (0., 3., 0.1, qHit.z));\n  else if (idObj == 5) col = mix (bCol, wCol, SmoothBump (0., 2., 0.1, qHit.z));\n  else if (idObj == 6) col = bCol;\n  else if (idObj == 7) col = wCol;\n  if (idObj == 1) {\n    if (qHit.z > 4.5 && abs (qHit.x) > 0.07) idObj = 8;\n  } else if (idObj == 2) {\n    if (qHit.z > -9. && qHit.z < 3.) {\n      ws = vec2 (qHit.y - 0.6, mod (1.5 - qHit.z, 1.5) - 0.75);\n      if (dot (ws, ws) < 0.1) idObj = 8;\n    }\n  }\n  if (idObj == 8) col = vec3 (0.2);\n  return col * cLine;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.2, 0.9), vec3 (0.45, 0.45, 0.6), 1. - max (rd.y, 0.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, rdd;\n  float fCloud, cloudLo, cloudRngI, atFac, clSum, attSum, att, a, sd;\n  const float nLay = 30.;\n  cloudLo = 300.;\n  cloudRngI = 0.005;\n  atFac = 0.04;\n  fCloud = 0.5;\n  rd.y = max (rd.y, 0.001);\n  ro.xz += 15. * tCur;\n  p = vec3 (ro.xz + (cloudLo - ro.y) * rd.xz / rd.y, cloudLo).xzy;\n  rdd = rd / (cloudRngI * rd.y * (2. - rd.y) * nLay);\n  clSum = 0.;\n  attSum = 0.;\n  att = 0.;\n  for (float j = 0.; j < nLay; j ++) {\n    q = p + j * rdd;\n    att += atFac * max (fCloud - Fbm3 (0.005 * q), 0.);\n    a = (1. - attSum) * att;\n    clSum += a * (q.y - cloudLo) * cloudRngI;\n    attSum += a;\n    if (attSum >= 1.) break;\n  }\n  sd = max (dot (rd, sunDir), 0.);\n  clSum = 2.5 * (clSum + 0.5 * (1. - attSum) * pow (sd, 4.)) + 0.3;\n  return mix (clamp (mix (SkyBg (rd) + step (0.1, sd) * vec3 (1., 1., 0.9) * min (0.8 * pow (sd, 64.) +\n     pow (sd, 2048.), 1.), vec3 (0.9, 0.9, 0.95) * clSum, attSum), 0., 1.), SkyBg (rd), pow (1. - rd.y, 16.));\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec2 e = vec2 (1., 0.);\n  return (sd.z > 0.) ? 0.05 * pow (abs (sd.z), 4.) *\n     (2. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n     e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n     e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n     e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy))) : vec3 (0.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 col, colR, colG, vn, vnn;\n  float dstGrnd, dstObj, dstTrObj, dstWat, sh, spec, dFac, f;\n  bool isRefl;\n  wSpan = 13.;\n  enPos = vec3 (0.3 * wSpan, -0.2, -1.5);\n  HexVorInit ();\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  dstTrObj = TransObjRay (ro, rd);\n  if (dstTrObj > min (dstGrnd, dstObj)) dstTrObj = dstFar;\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  isRefl = false;\n  if (dstWat < min (dstGrnd, dstObj)) {\n    ro += dstWat * rd;\n    rd = reflect (rd, VaryNf (0.5 * ro + vec3 (0., 0., 0.2 * tCur), vec3 (0., 1., 0.),\n       0.2 - 0.18 * smoothstep (0.1, 0.15, dstWat / dstFar)));\n    ro += 0.01 * rd;\n    dstGrnd = GrndRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  } else dstWat = 0.;\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vnn = flMat * vn;\n      col = FlyerCol (vnn);\n      col = mix (col, SkyCol (ro, reflect (rd, vn)), ((idObj == 8) ? 0.7 :\n         0.2 * smoothstep (0.1, 0.3, vnn.y)));\n      sh = ObjSShadow (ro, sunDir);\n      spec = 0.2;\n    } else {\n      ro += dstGrnd * rd;\n      vnn = GrndNf (ro, dstGrnd);\n      dFac = (1. - smoothstep (0.3, 0.4, dstGrnd / dstFar)) *\n         (1. - smoothstep (-0.2, -0.1, dot (rd, vnn)));\n      colR = vec3 (0.);\n      colG = vec3 (0.);\n      if (vnn.y < 0.8) {\n        f = length (ro.xz);\n        colR = mix (vec3 (0.4, 0.3, 0.2), vec3 (0.35, 0.3, 0.25),\n           mix (0.5, smoothstep (0.2, 0.8, Fbm2 (4. * vec2 (8. * f, ro.y))), dFac));\n        colR *= mix (1., 0.95 + 0.05 * Noisefv2 (64. * vec2 (f, ro.y)), dFac);\n        vc = HexVor (vec2 (4. * ro.y, 6. * f));\n        colR *= mix (vec3 (1.), vec3 (0.8 + 0.2 * vc.w, 1., 1.), dFac);\n        colR *= mix (1., 0.95 + 0.05 * smoothstep (0.03 + 0.03 * vc.w,\n           0.05 + 0.03 * vc.w, vc.x), dFac);\n        vn = VaryNf (vec3 (1., 0.05, 1.) * ro, vnn, 6. * (1. - smoothstep (0.4, 0.8, vnn.y)) * dFac);\n      } else {\n        vn = VaryNf (ro, vnn, (0.5 + 3.5 * smoothstep (0.8, 0.82, vnn.y)) * dFac *\n           (1. - smoothstep (0.8, 1., dstGrnd / 50.)));\n      }\n      if (vnn.y > 0.77) colG = mix (vec3 (0.2, 0.4, 0.3), vec3 (0.2, 0.5, 0.2),\n         mix (0.5, smoothstep (0.1, 0.9, Fbm2 (1. * ro.xz)), dFac));\n      col = mix (colR, colG, smoothstep (0.77, 0.8, vnn.y));\n      col = mix (vec3 (0.1, 0.4, 0.1), col, 0.5 + 0.5 * smoothstep (0., 0.05, ro.y));\n      sh = 1.;\n      spec = mix (0.01, 0., smoothstep (0.75, 0.8, vnn.y));\n    }\n    sh = min (sh, 1. - 0.4 * smoothstep (0.4, 0.7, Fbm2 (0.1 * ro.xz - tCur * vec2 (0.15, 0.))));\n    col = col * (0.1 + 0.1 * vec3 (0.8, 0.9, 1.) * (max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n       max (vn.y, 0.)) + sh * 0.8 * vec3 (1., 1., 0.9) * max (dot (vn, sunDir), 0.)) +\n       sh * spec * vec3 (1., 1., 0.9) * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    if (isRefl) col = mix (0.9 * col, vec3 (0.5, 1., 0.5), 0.05);\n    col = mix (col, SkyBg (rd), smoothstep (0.4, 1., (dstWat + min (dstGrnd, dstObj)) / dstFar));\n  } else {\n    col = SkyCol (ro, rd);\n    if (isRefl) col = mix (0.9 * col, vec3 (0.5, 1., 0.5), 0.05);\n  }\n  if (dstTrObj < dstFar) col = 0.7 * col + 0.1 - 0.04 * SmoothBump (1.5, 1.7, 0.02, length (qHitTr.xy));\n  return clamp (mix (col, vec3 (col.r), 0.2) * mix (1., smoothstep (0., 1., Maxv3 (col)), 0.2), 0., 1.);\n}\n\nvoid FlyerPM (float s)\n{\n  vec3 vel, va;\n  vec2 cs;\n  flPos = TrackPath (s);\n  vel = TrackDir (s);\n  va = cross (TrackAcc (s), vel) / length (vel);\n  flVd = normalize (vel);\n  cs = sin (15. * length (va) * sign (va.y) + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\n#define N_VU 5\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur, stDat;\n  vec3 ro, rd, vd, col;\n  vec2 mMid[N_VU], ut[N_VU], mSize, canvas, uv, uvv, ori, ca, sa;\n  float el, az, asp, zmFac, vuMode, centMode, smMode, nVu, f, tCyc, sunEl, sunAz;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  stDat = Loadv4 (vec2 (0., 0.));\n  mPtr.xyz = stDat.xyz;\n  vuMode = stDat.w;\n  nVu = float (N_VU);\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  tCyc = 200.;\n  centMode = (vuMode >= 0.) ? vuMode : mod (floor (6. * tCur / tCyc), nVu);\n  trkA = 8. * vec3 (1.9, 2.9, 4.3);\n  trkF = 0.15 * vec3 (0.23, 0.17, 0.13);\n  szFac = 0.15;\n  asp = canvas.x / canvas.y;\n  mSize = vec2 (asp / nVu, 1. / (nVu + 1.));\n  for (int k = 0; k < N_VU; k ++) {\n    mMid[k] = - vec2 (mSize.x / mSize.y, 1.) + vec2 (2 * (k + 1), 1) * mSize;\n    ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  smMode = -1.;\n  for (int k = 0; k < N_VU; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      smMode = float (k);\n      break;\n    }\n  }\n  if (smMode >= 0.) {\n    vuMode = smMode;\n  } else {\n    vuMode = centMode;\n    uv.y -= mSize.y;\n  }\n  flVel = 6.;\n  FlyerPM (flVel * tCur);\n  az = 0.;\n  el = 0.;\n  if (smMode == -1. && mPtr.z > 0. && mPtr.y > -0.5 + (1. / (nVu + 1.))) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  if (vuMode == 0. || vuMode == 1.) {\n    f = floor (flVel * tCur / (0.5 * tCyc));\n    ro = TrackPath ((0.5 * tCyc) * (f + 0.5));\n    f = 2. * mod (f, 2.) - 1.;\n    ro.xy += (vuMode == 0.) ? vec2 (flVel * f, 1.1 * GrndHt (ro.xz + vec2 (9. * f, 0.))) :\n       vec2 (2. * f, 1. - ro.y);\n    vd = flPos - ro;\n    zmFac = 2. + 0.03 * length (vd);\n  } else if (vuMode == 2. || vuMode == 3.) {\n    ro = TrackPath (flVel * tCur + sign (vuMode - 2.5) * 30. *\n       (1. - 0.8 * abs (sin (pi * mod (flVel * tCur / tCyc, 1.)))));\n    vd = flPos - ro;\n    zmFac = 2.7;\n  } else if (vuMode == 4.) {\n    ro = vec3 (vec2 (0., 0.7) + vec2 (0.6, 0.2) * sin (2. * pi * mod (0.05 * tCur, 1.) +\n       vec2 (0.5 * pi, 0.)), -4.) * flMat + flPos;\n    vd = flVd;\n    zmFac = 1.5;\n  }\n  vd = normalize (vd);\n  ori = vec2 (el + asin (vd.y), az + 0.5 * pi - atan (vd.z, vd.x));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  sunAz = 0.01 * 2. * pi * tCur;\n  sunEl = pi * (0.3 + 0.05 * sin (0.35 * sunAz));\n  sunDir = vec3 (0., sin (sunEl), cos (sunEl));\n  sunDir.xz = Rot2D (sunDir.xz, sunAz);\n  dstFar = 250.;\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.), 0.5 * pi * (a + 0.5));\n    rd = vuMat * normalize (vec3 (uvv, zmFac));\n    col += (1. / naa) * (ShowScene (ro, rd) + GlareCol (rd, sunDir * vuMat, uvv));\n  }\n  col =  pow (clamp (col, 0., 1.), vec3 (0.7));\n  for (int k = 0; k < N_VU; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n       col = (float (k) == centMode) ? vec3 (0.8, 0.3, 0.3) : vec3 (0.8, 0.8, 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  if (f > 0.001) {\n    g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n    n += f * (g - n * dot (n, g));\n    n = normalize (n);\n  }\n  return n;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"River Flight 2\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (vec2 vId);\n\nconst float pi = 3.14159;\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n#define N_VU 5\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec2 canvas, iFrag;\n  float tCur, tMouse, nStep, nVu, vuMode;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (fragCoord.x >= 2. || fragCoord.y >= 1.) discard;\n  iFrag = floor (fragCoord);\n  if (iFrame > 5) {\n    stDat = Loadv4 (vec2 (0., 0.));\n    mPtrP.xyz = stDat.xyz;\n    vuMode = stDat.w;\n    stDat = Loadv4 (vec2 (1., 0.));\n    tMouse = stDat.x;\n  } else {\n    mPtrP = mPtr;\n    vuMode = -1.;\n    tMouse = tCur;\n  }\n  nVu = float (N_VU);\n  if (mPtr.z > 0.) {\n    if (mPtr.y < -0.5 + (1. / (nVu + 1.))) vuMode = floor (nVu * clamp (mPtr.x + 0.5, 0., 0.99));\n    tMouse = tCur;\n  } else if (tCur - tMouse > 10.) vuMode = -1.;\n  if (iFrag.y == 0.) {\n    if (iFrag.x == 0.) fragColor = vec4 (mPtr.xyz, vuMode);\n    else  if (iFrag.x == 1.) fragColor = vec4 (tMouse, 0., 0., 0.);\n  }\n}\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}