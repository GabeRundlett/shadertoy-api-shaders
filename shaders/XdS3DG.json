{
    "Shader": {
        "info": {
            "date": "1392674394",
            "description": "More octahedra and tetrahedra. And worms. Use mouse to rotate view.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdS3DG",
            "likes": 33,
            "name": "Escher's Planaria",
            "published": 3,
            "tags": [
                "escher",
                "tetrahedra",
                "octahedra",
                "planaria",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 1703
        },
        "renderpass": [
            {
                "code": "#define s3 1.7320508075688772\n#define i3 0.57735026918962584\n\n#define farval 1e5\n\n#define ppp vec3( 1.0,  1.0,  1.0)\n#define ppm vec3( 1.0,  1.0, -1.0)\n#define pmp vec3( 1.0, -1.0,  1.0)\n#define pmm vec3( 1.0, -1.0, -1.0)\n#define mpp vec3(-1.0,  1.0,  1.0)\n#define mpm vec3(-1.0,  1.0, -1.0)\n#define mmp vec3(-1.0, -1.0,  1.0)\n#define mmm vec3(-1.0, -1.0, -1.0)\n\nconst vec3 tgt = vec3(-0.5, 0.5, 0.5);\nconst vec3 cpos = vec3(12.51951088,  5.82929222,  23.82997848);\n\nconst vec3 fogc = vec3(0.56, 0.58, 0.62);\n\n\nconst mat3 R = mat3(  9.76533123e-01,   3.80711949e-02,  -2.11975573e-01,\n\t\t\t\t\t  7.67662775e-04,  -9.84860642e-01,  -1.73346262e-01,\n\t\t\t\t\t -2.15365898e-01,   1.69115641e-01,  -9.61778264e-01);\n\nconst mat3 Kinv = mat3( 0.0026788,   0.,          0.,       \n\t\t\t \t\t    0.,          0.0026788,   0.,\n\t\t\t\t\t   -1.07257601, -0.6084867,   1.); \n\nconst vec2 origResolution = vec2(596.0, 486.0);\n\n\nvec3 L = normalize(vec3(-0.5, 1.5, 1.25));\n\n#define miss vec4(vec3(0.0), farval);\n\n\n#define rayiter 75\n#define marchiter 70\n#define dmax 40.0\n\n\nvec4 pselect(vec4 a, vec4 b) {\n\treturn a.w < b.w ? a : b;\n}\n\nfloat par(vec3 fp) {\n\treturn fract(0.5*dot(vec3(1.0), fp)+0.5) * 4.0 - 1.0;\n}\n\nvec4 tetN(in vec3 p) {\n\treturn pselect(pselect(vec4(ppp, dot(mmm,p)), vec4(pmm, dot(mpp,p))),\n\t\t\t\t   pselect(vec4(mpm, dot(pmp,p)), vec4(mmp, dot(ppm,p))));\n}\n\nvec4 classify(in vec3 pos) {\n\t\n\tvec3 fp = floor(pos);\n\t\n\tvec3 t = fp + 0.5;\n\t\n\tfloat parity = par(fp);\n\t\n\tvec4 n = tetN(parity*(pos-t));\n\t\t\n\treturn n.w > -0.5 ? vec4(t, parity) : vec4(t + 0.5*parity*n.xyz, 0.0);\n\t\n}\n\n\nvec4 plane(vec3 o, vec3 d, vec3 n) {\n\n\tfloat denom = dot(d,n);\n\treturn vec4( n, denom < 0.0 ? 1e5 : (1.0-dot(o,n))/denom );\n\t\n}\n\nvec4 uplane(vec3 o, vec3 d, vec3 n) {\n\t\n\tfloat dn = dot(d,n);\n\tfloat s = sign(dn);\n\tfloat t = (1.0-s*dot(o,n))/(s*dn);\n\treturn vec4( s*n, t );\n\t\n}\n\n// ray test for tetrahedron centered at ctr (assumes ray started inside)\nvec4 raytet(in vec3 o, in vec3 d, inout vec4 octet) {\n\t\n\to -= octet.xyz;\n\t\n\to *= 2.0;\n\td *= 2.0;\n\t\t\t\n\tvec4 p = pselect(pselect(plane(o, d, octet.w*ppp), \n\t\t\t\t\t\t\t plane(o, d, octet.w*pmm)),\n\t\t\t\t\t pselect(plane(o, d, octet.w*mpm),\n\t\t\t\t\t\t\t plane(o, d, octet.w*mmp)));\n\t\n\toctet = vec4(octet.xyz + 0.5 * p.xyz, 0.0);\n\t\n\treturn vec4(-p.xyz*i3, p.w);\n\t\n}\n\n// ray test for octahedron centered at ctr (assumes ray started inside)\nvec4 rayoct(in vec3 o, in vec3 d, inout vec4 octet) { \n\t\n\to -= octet.xyz;\n\n\tvec4 p = pselect(pselect(uplane(o, d, ppp), \n\t\t\t\t\t\t\t uplane(o, d, ppm)), \n\t\t\t\t\t pselect(uplane(o, d, pmp), \n\t\t\t\t\t\t\t uplane(o, d, pmm))); \n\t\t\n\toctet.xyz += 0.5*p.xyz;\n\toctet.w = par(floor(octet.xyz));\n\t\n\treturn vec4(-p.xyz*i3, p.w);\n\n}\n\n\nvec3 normalMap(vec3 n, vec3 p, float w) {\n\t\n\tvec3 s = sign(n);\n\tp *= s;\n\t\n\tconst vec3 nn = vec3(1.0);\n\t\n\tvec2 uv = mix(vec2(1.0, 0.0), vec2(-0.5, 0.5), w);\n\t\n\tvec3 a = vec3(uv.x, uv.y, uv.y);\n\tvec3 b = vec3(uv.y, uv.x, uv.y);\n\tvec3 c = vec3(uv.y, uv.y, uv.x);\t\n\n\tfloat k = uv.y-uv.x; \n\tfloat j = uv.y+uv.x;\n\t\n\tvec3 nab = vec3(k, k, 0.0);\n\tvec3 nbc = vec3(0.0, k, k);\n\tvec3 nca = vec3(k, 0.0, k);\n\t\t\n\tfloat r = 0.15 - 0.05*w;\n\t\n\tvec3 d = clamp((p*mat3(nab, nbc, nca)-j*k)/r, 0.0, 1.0);\n\t\n\treturn s * normalize(mat3(c,a,b)*d);\n\t\n}\n\n\nfloat sdTet(in vec3 p, in float s) {\n\treturn (-tetN(p/s).w*i3 - 0.5*i3)*abs(s);\t\n}\n\nfloat sdOct(in vec3 p, in float s) {\n\treturn (dot(vec3(i3), abs(p/s)) - i3)*s;\n}\n\nvec3 projLine(vec3 a, vec3 d, vec3 p) {\n\treturn a + d*clamp( dot(p-a, d) / dot(d, d), 0.0, 1.0 );\n}\n\nfloat line(vec3 a, vec3 d, vec3 p) {\n\treturn distance(p, projLine(a, d, p) );\n}\n\nfloat octline(vec3 a, vec3 d, float r, vec3 p) {\n\treturn sdOct(p - projLine(a, d, p), r);\n}\n\nfloat tets(vec3 lo, float n, vec3 pos) {\n\t\n\tfloat py = pos.y - lo.y;\n\tfloat ya = clamp(4.0*floor(0.25*py+0.5), 0.0, 4.0*n);\n\tfloat yb = clamp(4.0*floor(0.25*py)+2.0, 2.0, 4.0*n+2.0);\n\t\n\treturn min(sdTet(pos - (lo + vec3(0.0, ya, 0.0)), 3.0),\n\t\t\t   sdTet(pos - (lo + vec3(0.0, yb, 0.0)), 3.0));\n\n}\n\nfloat pillar(vec3 a, float dy, vec3 p) {\n\tvec3 pos = vec3(a.x, clamp(p.y, a.y, a.y+dy), a.z);\n\treturn distance(pos,p);\n}\n\n#define intersect(a, b) max(a,b)\n#define unite(a, b) min(a,b)\n#define subtract(a, b) max(a,-(b))\n\nfloat env(in vec3 pos) {\n\n#define dppp dot(pos, ppp)\n#define dppm dot(pos, ppm)\n#define dpmp dot(pos, pmp)\n#define dpmm dot(pos, pmm)\n#define dmpp dot(pos, mpp)\n#define dmpm dot(pos, mpm)\n#define dmmp dot(pos, mmp)\n#define dmmm dot(pos, mmm)\n\n\n#define pA (dpmp)\n#define pB (dmmp+14.0)\n#define pC (dmpp-4.0)\n#define pD (dpmm-4.0)\n#define pE (dmmm-12.0)\n#define pF (dppm+10.0)\n#define pG (dmpm-20.0)\n#define pH (dpmm+24.0)\n#define pI (dppp-20.0)\n#define pJ (dpmm+6.0)\n#define pK (dmmm+26.0)\n#define pL (dmpm+14.0)\n#define pM (dmpp+16.0)\n#define pN (dppp+0.0)\n#define pO (dmmp+16.0)\n#define pP (dppp+22.0)\n#define pQ (dmmp)\n#define pR (dpmp+26.0)\n#define pS (dmpp+14.0)\n#define pT (dppp-28.0)\n#define pU (dmpm+14.0)\n#define pV (dpmp+40.0)\n\n\tfloat o = intersect(intersect(pA, pE), intersect(pC, pD));\n\to = unite(o, intersect(intersect(pA, pF), intersect(pG, pI)));\n\to = unite(o, intersect(pA, intersect(pH, pI)));\n\to = unite(o, intersect(intersect(pA, pB), pD));\n\to = unite(o, intersect(pA, pO));\n\to = unite(o, intersect(pB, pJ));\n\to = unite(o, intersect(pB, pK));\n\to = unite(o, intersect(pB, pL));\n\to = unite(o, intersect(pM, pN));\n\to = unite(o, subtract(intersect(pC, pQ), pE));\n\to = unite(o, intersect(pP, pR));\n\to = unite(o, intersect(intersect(pS, pT), pU));\t\n\to = unite(o, pV);\n\t\n\to*= i3;\n\t\n\n\t// bounding octahedron\n\t//o = unite(o, -sdOct(pos-vec3(12.0, 5.0, 23.0), 70.0));\n\n\t// left platform\n\to = unite(o, sdOct(pos-vec3(-16.0, -6.0, 8.0), 14.0));\n\n\t// center platform\n\to = unite(o, sdOct(pos-vec3(0.0, -8.0, -2.0), 10.0));\n\n\t// center bottom platform\t\n\to = unite(o, octline(vec3(0.0, -16.0, 8.0), vec3(8.0, 0.0, 8.0), 8.0, pos));\n\n\t// left platform\n\to = unite(o, octline(vec3(-15.0, -0.0, 15.0), vec3(0.0, -6.0, 6.0), 8.0, pos));\n\t\n\t// bottom left platform\n\to = unite(o, sdOct(pos - vec3(3.0, -9.0, 21.0), 11.0));\n\t\n\t// upper right \"decoration\"\n\to = unite(o, sdTet(pos-vec3(13.5, 8.5, 9.5), -3.0));\n\to = unite(o, sdTet(pos-vec3(13.0, 8.0, 10.0), 2.0));\n\to = unite(o, sdOct(pos-vec3(12.0, 7.0, 11.0), 2.0));\n\t\n\t// center right pillar\n\to = unite(o, pillar(vec3(5.0, -6.0, 0.0), 12.0, pos) - 0.75);\n\t\n\t// right pillar below decoration\t\n\to = unite(o, pillar(vec3(15.5, -5.0, 6.5), 10.0, pos) - 0.75);\n\n\t// line off of center platform\n\to = unite(o, line(vec3(0.0, -8.0, 7.0), vec3(8.0, 0.0, 8.0), pos) - 0.75 );\n\t\n\t// line from left plattform to lower platform\n\to = unite(o, line(vec3(-3.0, -6.0, 8.0), vec3(3.0, -3.0, 0.0), pos) - 0.75 );\n\t\n\t// center left pillar\n\to = unite(o, pillar(vec3(-6.75, 1.5, 5.75), 10.0, pos) - 0.5 );\n\n\t// center pillar\n\to = unite(o, intersect(pA, tets(vec3(-0.5, 1.5, -0.5), 3.0, pos)));\n\n\t// left pillar\n\to = unite(o, pillar(vec3(-5.0, -20.0, 11.0), 30.0, pos) - 1.25 );\n\t\t\n\t// pointy line between right pillars\n\to = unite(o, line(vec3(7.75, -5.5, -2.75), vec3(-8.0, 0.0, -8.0), pos) -0.7);\n\n\t// octahedron outline in middle\n\tvec3 p = vec3(11.0, -1.0, 13.0);\n\to = unite(o, line(p, vec3( 8.0, -8.0,  0.0), pos)-0.6);\n\to = unite(o, line(p, vec3(-8.0, -8.0,  0.0), pos)-0.6);\n\to = unite(o, line(p, vec3( 0.0, -8.0,  8.0), pos)-0.6);\n\to = unite(o, line(p, vec3( 0.0, -8.0, -8.0), pos)-0.6);\n\t\n\treturn o;\n\n}\n\n\nvec3 fog(vec3 color, float t) {\n\tfloat fogv = exp(-0.0006*t*t);\n\treturn mix(fogc, color, fogv);\n}\n\n\n\nfloat smin( float a, float b ) {\n\tconst float k = 0.05;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float x, float y) {\n\treturn -smin(-x, -y);\n}\n\nfloat wedge(in vec3 pos, float a, float b, float r) {\n\tfloat s1 = length(pos - vec3( a, -b, 0.0))-r;\n\tfloat s2 = length(pos - vec3(-a, -b, 0.0))-r;\n\treturn smax(-pos.y, smax(s1, s2));\n}\n\nfloat wtip(in vec3 pos) {\n\treturn smax(-pos.z, wedge(pos-vec3(0.0, 0.0, -0.6), 1.85, 3.4, 4.0));\n}\n\nvec2 eye(vec2 pos) {\n\t\n\tpos.y -= 0.85;\n\tpos = abs(pos);\n\tpos.y *= 0.7;\n\t\n\tconst vec2 ctr = vec2(0.055, 0);\n\tconst float r0 = 0.035;\n\tconst float r1 = 0.015;\n\tconst float r2 = 0.013;\n\t\n\tpos -= ctr;\n\t\n\tfloat w = step(length(pos),r0);\n\t\n\tconst float sx = 1.5;\n\tconst float sy = 1.0; \n\t\n\tvec2 pc = r1 * normalize(dot(pos, vec2(sx, sy)) > 0.0 ? vec2(-sy, sx) : pos);\n\tfloat p = step(length(pos - pc), r2);\n\t\n\treturn vec2(w, p);\n\t\n}\n\n\nvec2 opU(in vec2 a, in vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\n\nvec2 worm(in vec3 p) {\n\t\n\tconst float scale = 6.0;\n\t\n\tp /= scale;\n\n\tp.z += 0.16;\n\tp.y += 0.03;\n\t\t\t\t\t\t \n\tconst float f = 6.0;\n\tconst float a = 0.03;\n\tp.y += a*sin(f*p.z+5.0*iTime);\n\t\n\tvec2 e = eye(p.xz);\n\t\n\tfloat stripe = 0.5 + 0.49*sin(p.z*70.0);\n\tstripe = mix(0.0, stripe, smoothstep(0.02, 0.1, p.y));\n\t\n\tfloat c = mix(0.7-0.1*stripe, mix(2.0, 1.0, e.y), e.x);\n\t\n\tfloat body =  wedge(p, 1.70, 3.5, 4.0);\n\t\t\t\t  \n\tp.z -= 0.8;\n\tfloat nose = wtip(p);\n\t\n\tconst vec3 delta = vec3(0.0, 0.0, 0.05);\n\t\n\tfloat cheeks = smin(wtip(p.zyx + delta), \n\t\t\t\t\t\twtip((p.zyx - delta)*vec3(1.0, 1.0, -1.0)));\n\t\n\tfloat head = smin(nose, cheeks);\n\t\n\t\n\treturn vec2( scale*smin(body, head), c );\n\t\n\t//return eye(p) * vec2(scale, 1.0);\n\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\t\n#define wdims vec3(1.4, 0.7, 5.4)\n\nvec4 wormline(in vec3 p0, in vec3 d, in float a, in float b, in vec3 pos) {\n\n\tvec3 z = normalize(d);\n\tvec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n\tvec3 y = cross(z, x);\n\t\t\n\tvec3 p = (pos - (p0 + (a + mod(4.0*iTime, b-a))*z))*mat3(x,y,z);\n\t\n\tfloat w = sdBox(p, wdims);\n\t\n\treturn vec4(p, w);\n\t\n}\n\n\nvec2 map(in vec3 pos) {\t\n\n\t// mid right to bottom left\n\tvec4 o = wormline(vec3(16.0, -1.5, -9.0), \n\t\t\t\t\t  vec3(-2.0, -0.4, 2.4), \n\t\t\t\t\t  -7.0, 44.0, pos);\t\n\t\n\t// back center to left\n\to = pselect(o, wormline(vec3(-13.0, -0.5, -10.5), \n\t\t\t\t\t\t\tvec3(2.2, 0.4, 4.0), \n\t\t\t\t\t\t\t-3.0, 44.0, pos));\n\t\n\t// right of center to bottom right\n\to = pselect(o, wormline(vec3(1.0, 0.0, -11.0),\n\t\t\t\t\t\t\tvec3(2.0, -0.0, 2.0),\n\t\t\t\t\t\t\t-4.0, 35.0, pos));\n\t\n\t// left to mid right\t\n\to = pselect(o, wormline(vec3(-6.0, 3.6, 10.0),\n\t\t\t\t\t\t\tvec3(11.0, -1.6, -12.0),\n\t\t\t\t\t\t\t-14.0, 40.0, pos));\n\n\t// thru pyramid\n\to = pselect(o, wormline(vec3(11.0, -3.9, 14.5),\n\t\t\t\t\t\t\tvec3(-1.0, 0.25, 0.1), \n\t\t\t\t\t\t\t-15.0, 26.0, pos));\n\t\n\t// close top to bottom\n\to = pselect(o, wormline(vec3(-5.0, 14.0, 11.0), \n\t\t\t\t\t\t\tvec3(0.3, -0.2, 0.2),\n\t\t\t\t\t\t\t-1.0, 33.0, pos));\n\t\n\tif (o.w > 0.2) {\n\t\treturn vec2(o.w, 1.8);\n\t} else {\n\t\treturn worm(o.xyz);\n\t}\n\t\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<marchiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\tif (t > maxd) { m = -1.0; }\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos ) {\n\t\n\tvec3 eps = vec3( 0.03, 0.0, 0.0 );\n\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\n\treturn normalize(nor);\n\t\n}\n\nvec3 hue(float h) {\n\tvec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn h >= 1.0 ? vec3(h-1.0) : (clamp(min(c, -c+4.0), 0.0, 1.0)*0.75 + 0.2);\n}\n\nvec3 light(in vec3 color, in vec3 n, in vec3 rd, in float specc, in float spece) {\n\tvec3 diffamb = color*clamp(dot(n,L), 0.0, 1.0);\n\treturn diffamb + specc*pow(clamp(dot(rd, reflect(L,n)), 0.0, 1.0), spece);\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd ) {\n\t\n\tvec2 tm = castRay(ro, rd, dmax);\n\t\n\tif (tm.y >= 0.0) {\n\t\tvec3 n = calcNormal(ro + tm.x * rd);\n\t\tvec3 color = light(hue(tm.y), n, rd, 0.4, 40.0);\n\t\treturn vec4(color, tm.x);\n\t} else {\n\t\treturn vec4(vec3(0.0), 1e5);\n\t}\n\t\n}\n\n\n/*\nvec4 raymarch( in vec3 ro, in vec3 rd ) {\n\t\n\tvec3 t = vec3(4.0, 0.0, 4.0) + sin(iTime)*vec3(4.0, 5.0, 0.0);\n\n\t// p = ro + s*rd\n\t// p' = R(ro + s*rd) + t\n\t\n\t// ro' = Rro + t\n\t// rd' = Rrd\n\t\n\tmat3 M = R;\n\t\n\trd = M*rd;\n\tro = M*ro - M*t;\n\t\n\tvec3 rdi = 1.0/rd;\t\n\tvec3 b = vec3(1.0, 0.5, 3.0);\n\t\t\n\tvec3 t1 = (-b - ro)*rdi;\n\tvec3 t2 = ( b - ro)*rdi;\n\t\n\tvec3 tvmin = min(t1, t2);\n\tvec3 tvmax = max(t1, t2);\n\t\t\n\tfloat tmin = max(max(tvmin.x, tvmin.y), tvmin.z);\n\tfloat tmax = min(min(tvmax.x, tvmax.y), tvmax.z);\t\t\n\t\n\tif (tmin <= tmax) {\n\t\treturn vec4(vec3(1.0), tmin);\n\t} else {\n\t\treturn miss;\n\t}\n \n}\n*/\n\nvec4 raytrace(in vec3 ro, in vec3 rd) {\n\t\n\tvec4 h = miss;\n\n\tfloat t = 7.0;\n\tro += t*rd;\n\t\n\tvec4 octet = classify(ro);\n\t\n\tvec3 p = ro;\n\t\n\tfor (int iter=0; iter<rayiter; ++iter) {\n\t\t\n\t\tif (h.w < 1e5) { continue; }\n\t\t\t\t\t\t\t\n\t\tvec4 s = (octet.w == 0.0) ? rayoct(p, rd, octet) : raytet(p, rd, octet);\n\t\t\n\t\tp += s.w*rd;\n\t\tt += s.w;\n\n\t\tif (env(octet.xyz) < 0.0) {\n\t\t\tvec3 nn = normalMap(s.xyz, p-octet.xyz, abs(octet.w));\n\t\t\th = vec4(normalize(mix(nn, s.xyz, smoothstep(20.0, 50.0, t))), t);\n\t\t}\n\n\t}\n\t\n\tvec3 col = fogc; \n\n\tif (h.w < farval) {\n\t\tvec3 l = light(vec3(0.95, 0.98, 1.0), h.xyz, rd, 0.3, 5.0);\n\t\tvec3 e = texture(iChannel0, R*reflect(rd, h.xyz)).zyx;\n\t\tcol = mix(l, e, 0.18);\n\t}\t\n\t\n\treturn vec4(col, h.w);\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\n\tvec2 theta = vec2(0.0);\n\t\n\tif (max(iMouse.x, iMouse.y) > 20.0) { \n\t\ttheta.yx = (iMouse.xy - 0.5*iResolution.xy) * 0.3 / iResolution.xy;\n\t}\n\n\tfloat cx = cos(theta.x);\n\tfloat sx = sin(theta.x);\n\tfloat cy = cos(theta.y);\n\tfloat sy = sin(theta.y);\n\t\n\tmat3 Rx = mat3(1.0, 0.0, 0.0, \n\t\t\t\t   0.0, cx, sx,\n\t\t\t\t   0.0, -sx, cx);\n\t\n\tmat3 Ry = mat3(cy, 0.0, -sy,\n\t\t\t\t   0.0, 1.0, 0.0,\n\t\t\t\t   sy, 0.0, cy);\n\n\tfloat resScale = origResolution.y / iResolution.y;\n\t\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * vec2(resScale, -resScale) + 0.5*origResolution;\n\t\n\t\n\tmat3 RR = R*Ry*Rx*mat3(R[0].x, R[1].x, R[2].x,\n\t\t\t\t\t\t   R[0].y, R[1].y, R[2].y,\n\t\t\t\t\t\t   R[0].z, R[1].z, R[2].z);\n\t\n\n\tvec3 cam = cpos;\n\tvec3 tar = mix(cam, tgt, 0.75);\n\n#if 1\n\tcam += vec3(0.0, 0.1*sin(1.3*iTime), 0.0);\n\tuv.x += (2.0 + 1.0*sin(0.04*uv.y+0.7*iTime+3.0)) * sin(0.05*uv.y + 2.0*iTime);\n#endif\n\n\tvec3 ro = RR*(cam-tar) + tar;\n\tvec3 rd = RR*normalize((Kinv*vec3(uv,1.0))*R);\n\t\n\tvec4 bg = raytrace(ro, rd);\n\tvec4 fg = raymarch(ro, rd);\n\t\n\tvec4 p = pselect(bg, fg);\n\t\n\tvec3 col = fog(p.xyz, p.w);\n\t\n\tcol = pow(col, vec3(0.7));\n\t\n\tfragColor.xyz = col;\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}