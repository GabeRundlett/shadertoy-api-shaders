{
    "Shader": {
        "info": {
            "date": "1465482632",
            "description": "hax",
            "flags": 0,
            "hasliked": 0,
            "id": "MdjGWR",
            "likes": 1,
            "name": "Production Company Ident",
            "published": 3,
            "tags": [
                "raymarch",
                "clouds"
            ],
            "usePreview": 0,
            "username": "kig",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "#define THRESHOLD 0.01\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 120\n#define MAX_SAMPLES 16.0\n\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat map( in vec3 p )\n{\n\tp.y = pow(p.y, 1.3);\n\t\n\tfloat d = -0.1 - p.y;\n\n\tvec3 dir = 8.0*normalize(p);\n\tdir.y = 0.0;\n\tvec3 q = p - dir+vec3(-0.0,3.0,-0.0)*(0.2*iTime);\n\tfloat f;\n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n\n\td += 3.5 * f;\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\treturn d*d;\n}\n\n\nfloat scene(vec3 p)\n{\n\tmat3 m = rotationXY(vec2(0.0, -0.2*iTime + 3.14159*0.25));\n\tfloat cube = length(max(abs((m*p) - vec3(0.0, 2.0, 0.0)) - vec3(0.95), 0.0)) - 0.05;\n\tcube = min(cube, length(max(abs(p - vec3(0.0, 0.6, 0.0)) - vec3(0.95, 0.25, 0.95), 0.0)) - 0.05);\n\tcube = min(cube, length(max(abs(p - vec3(0.0, 3.4, 0.0)) - vec3(0.95, 0.25, 0.95), 0.0)) - 0.05);\n\treturn cube;\n}\n\nmat material(vec3 p)\n{\n\tfloat cube = length(max(abs(p - vec3(0.0, 2.0, 0.0)) - vec3(0.95), 0.0)) - 0.05;\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n\tm.transmit = vec3(0.95, 0.7, 0.5);\n\tm.diffuse = 0.1;\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec2 fragCoord, vec3 nml)\n{\n    vec3 lightPos_ = vec3(\n        cos(iTime*0.2)*4.0, \n        sin(iTime)*3.0 - 4.0, \n        sin(iTime*0.2)*8.0\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\n\t\n\tvec3 bgColz = vec3(0.5, 0.2, 0.15);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = vec3(0.0);\n\tbgCol += max(0.0, bgDiff)*vec3(0.25, 0.5, 0.6);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.3, 0.2, 0.3);\n\tbgCol += vec3(0.43, 0.07, 0.25)*(pow(1.0-abs(bgDiff), 16.0)*(0.2*dot(uv,uv)));\n\tbgCol += 0.02*sun*pow( sp, 3.0);\n\tbgCol += bgColz*pow( sp, 8.0);\n\tbgCol += sun*pow( sp, 256.0);\n\tbgCol += bgColz*pow( sp, abs(bgLight.y)*128.0);\n\treturn bgCol;\n}\n\nfloat shade(inout ray r, vec3 nml, float d)\n{\n\tmat m = material(r.p);\n\tr.light += m.emit * r.transmit;\n\tr.transmit *= m.transmit;\n\treturn m.diffuse;\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n\nray setupRay(vec2 uv, float k) {\n\tmat3 rot = rotationXY( vec2( -0.603, iTime*0.0602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(uv*-1.0, -7.5) + vec3(0.0, 3.0, 0.0);\n\tr.d = rot * normalize(vec3(uv, 1.0));\n\n\treturn r;\n}\n\nvec3 trace(vec2 fragCoord, vec2 uv, vec2 uvD, inout float sceneDist)\n{\t\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\n\tfloat minDist = 9999999.0;\n\tfloat count = 0.0;\n\tfloat diffuseSum = 0.0, maxDiffuseSum = 0.0;\n\t\n\tvec3 accum = vec3(0.0);\n\tsceneDist = 9999999.0;\n\n\tray r = setupRay(uv, 1.0);\n\tvec3 op = r.p;\n\tfloat k = 1.0;\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (k > MAX_SAMPLES) break;\n\t\tfloat dist = scene(r.p);\n\t\tminDist = min(minDist, dist);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tif (sceneDist == 9999999.0) {\n\t\t\t\tsceneDist = length(r.p - op);\n\t\t\t}\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n\t\t\tfloat diffuse = shade(r, nml, dist);\n\t\t\tdiffuseSum += diffuse;\n\t\t\toffset(r.d, k, k+10.0*dot(nml, r.d), diffuse*0.5);\n\t\t\tr.d = reflect(r.d, nml);\n\t\t\tr.p += 4.0*THRESHOLD * r.d;\n\t\t\tcount++;\n\t\t\t\n\t\t\tif (dot(r.transmit, sun) < 0.2) {\n\t\t\t\t// if even the brightest light in the scene can't\n\t\t\t\t// make the ray brighter, let's bail.\n\t\t\t\taccum += r.light;\n\t\t\t\tk++;\n\t\t\t\tr = setupRay(uv+(uvD*mod(xy(k, 4.0), 4.0)/4.0), k);\n\t\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\t\tdiffuseSum = 0.0;\n\t\t\t}\t\t\t\n\t\t} else if (dist > MAX_DISTANCE) {\n\t\t\tvec3 bg = shadeBg(fragCoord, -r.d);\n\t\t\tif (minDist > THRESHOLD*1.5) {\n\t\t\t\tr.light = bg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taccum += r.light + r.transmit * bg;\n\t\t\tk++;\n\t\t\tr = setupRay(uv+(uvD*mod(xy(k, 4.0), 4.0)/4.0), k);\t\t\t\n\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\tdiffuseSum = 0.0;\n\t\t}\n\t}\n\t\n\taccum += r.light;\n\treturn accum / k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (2.0 * uv - 1.0) * aspect;\n\n\tvec2 uvD = 2.0*aspect / iResolution.xy;\n\t\n\tray r;\n\tr = setupRay(uv, 0.0);\n\t\n\tfloat dist;\n\t\n\tvec3 light = trace(fragCoord, uv, uvD, dist);\n\tif (dist > 10000.0) {\n\t\tr.p += 4.6*r.d;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tfloat c = map( r.p );\n\t\t\tr.p += 0.7*r.d;\n\t\t\tr.transmit *= 1.0+c*0.09;\n\t\t}\n\t}\n\tr.light = r.transmit * light;\n\t\n\tfragColor = vec4( 1.0 - exp(-1.3 * r.light), 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}