{
    "Shader": {
        "info": {
            "date": "1648266736",
            "description": "A simple path-traced fractal, fixing many of the mistakes from my previous attempt. Bow bounce lighting actually works and I used  better rng. Also applied some post.",
            "flags": 32,
            "hasliked": 0,
            "id": "NlXcR2",
            "likes": 5,
            "name": "Basic menger pathtracer v2",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "gi",
                "path"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "//The actual rendering is in buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv)/float(iFrame);\n    col = col*exp(vec4(1.1,1.05,1.2,1. ));\n    fragColor = smoothstep(-0.,1.,col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 sun = normalize(vec3(0.2,0,-1.)); // The direction of the sunlight\nconst vec3 suc = vec3(1.,0.7,0.3); // sunlight color\nconst float unIntersect = 0.001; // don't touch this\nconst int iter = 6; // number of GI bounces\nconst float bou_coef = 4.; // intensity of bounce light\nconst float sun_coef = 2.2; // intensity of sun light\nconst float amb_coef = 1.5; // intensity of ambient light\n//Dosn't actually need an array, just makes it easer to use many materials\n// Pbr also wasn't implemented\nconst vec3[] colors = vec3[](vec3(0.),vec3(0.25));\n\n//ambient light color\nvec3 amb(vec3 rd){\n    return clamp(vec3(vec2(0.8,0.9)*(1.1-rd.y*rd.y*rd.y),1.),vec3(0.),vec3(1.));\n}\n\n#define rotations\n\n//Heavy performance impact \n#define raymarchSteps 60\n\n#define ZERO min(iFrame, 0)\n\n//SDF stuff....\nconst float pi = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// rotation matrix\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s,\n                -s, c);\n}\n\n// transfrom a point to from a fractal\nvec3 trans(vec3 p, float s){\n        //Mirror\n        p = abs(p)-1.*s;\n        p *= -1.;\n        //Reflect column\n        p.xy = ((p.x - p.y > 0.) ? p.yx : p.xy);  \n        p.zy = ((p.z - p.y > 0.) ? p.yz : p.zy);  \n\n        //construct column\n        p.y = (abs(p.y-0.5*s)-0.5*s);\n        \n        return p;\n}\n// distance to a fractal\n// yes you can use a loop, but I wanted controll over the rotations\nvec4 map(vec3 p) {\n\n    const float scale = 260.;\n\n    p*= scale;\n    \n    #ifdef rotations\n    p = trans(p, 27.*9.);\n    p.xy *= rotate(2.2);\n    p = trans(p, 27.*3.);\n    p.zy *= rotate(5.2);\n    p = trans(p, 27.);\n    p.xz *= rotate(2.12);\n    p = trans(p, 9.);\n    p.yz *= rotate(1.512);\n    p = trans(p, 3.);\n    p.yz *= rotate(1.12);\n    p = trans(p, 1.);\n    p.zy*=rotate(0.1);\n    #else\n    p = trans(p, 27.*9.);\n    p = trans(p, 27.*3.);\n    p = trans(p, 27.);\n    p = trans(p, 9.);\n    p = trans(p, 3.);\n    p = trans(p, 1.);\n    \n    #endif\n\n    return vec4(sdBox(p, vec3(.5))/scale-0.001, p);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\n\n\n// For the fractal\nfloat intersection(vec3 ro, vec3 rd){\n    float dist;\n    float T;\n    for (int i = 0; i < raymarchSteps; i++){\n        dist = map(ro+rd*T).x;\n        T+=dist;\n        if (dist < 0.00001 || dist > 2.)\n            break;\n    }\n    \n    return T;\n\n}\n\n// Hash function\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n\n//Random direction\nvec3 hash3( vec3 p )\n{\n    p+=iTime*vec3(0.8,0.5,-2.);\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn normalize(fract(sin(p)*43758.5453123)-0.5);\n}\n\nvec3 ranReflect(vec3 inc, vec3 nor, float r){\n    vec3 ref = reflect(inc,nor);\n    vec3 ran = hash3(inc+nor);\n    ran *= sign(dot(ran,nor));\n    \n    vec3 dir = mix(reflect(inc,nor), ran, r);\n    \n    return normalize(dir);\n}\n\nstruct world {\n    int  id;\n    vec3 pos;\n    vec3 nor;\n    float dis;\n};\n\nworld wolrdIntersect(vec3 ro, vec3 rd){\n    vec3 nor = vec3(0);\n    float d = 10e10;\n    int id = 0;\n    //fractal\n    {\n        float md = intersection(ro,rd);\n        if (map(ro+rd*md).x < 0.1 && md < d){\n            id = 1;\n            nor = calcNormal(ro+rd*md);\n            d = md;\n        }\n    }\n    /*//ball\n    {\n        vec3 ce = vec3(0,-0.32,-.97);\n        float bd = sphIntersect(ro, rd, ce, 0.05).x;\n        if (bd > -0.1 && bd < d){\n            id = 2;\n            nor = normalize(ce-ro+bd*rd)*-1.;\n            d = bd;\n        }\n    }*/\n    return world(id,ro+d*rd,nor, d);\n}\n\n//Trace a path away from the shape and return 1 if we hit nothing\nfloat getShadow(vec3 p, vec3 rd){\n    rd = normalize(rd+ hash3(rd+p)*0.1);\n    p+=unIntersect*rd;\n    return wolrdIntersect(p, rd).id == 0 ? 1. : 0.;\n}\n\n//Shadow ray in a random direction\nvec3 getAmbiance(vec3 p, int i){\n    vec3 rd = hash3(p+float(i*i));\n    \n    return getShadow(p+unIntersect*rd,rd)*amb(rd);\n}\n\nstruct ligt {\n    vec3 scl;\n    float sha;\n    vec3 amb;\n\n};\nvec3 render(vec3 ro, vec3 rd){\n    vec3 dir = rd;\n    vec3 p = ro;\n    \n    ligt[iter] lig;\n    //Get light\n    for (int i=0;i<iter;i++){\n\n        world w = wolrdIntersect(p+dir*.05, dir);\n        float sha = getShadow(w.pos, sun);\n\n        //Colors\n        if (w.id==0){\n            if (i==0)\n                //Sky\n                return 0.3*amb(dir);\n             else {\n                break;\n            }\n        }\n        \n        vec3 am = vec3(0.);\n        for(int a=0;a<1;a++){\n            am += getAmbiance(w.pos,a)*2.;\n        }\n        \n        lig[i] = ligt(colors[w.id], sha, am);\n        \n        dir = hash3(p+w.pos+dir);\n        dir *= sign(dot(w.nor,dir));\n\n        p = w.pos;\n\n\n    }\n    vec3 col = vec3(0);\n    for (int i=iter-1;i>-1;i--) {\n    \n         vec3 scl = lig[i].scl;\n         float sha = lig[i].sha;\n         vec3 am = lig[i].amb;\n         \n          //prevoius bounce\n          col = col*scl*bou_coef+\n                //sun light\n                scl*sha*suc*sun_coef+\n                //ambient light\n                scl*am*amb_coef;\n\n    }\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 o = hash3(vec3(uv, iTime)).xz/iResolution.xy*0.5;\n    vec3 rd = normalize(vec3(\n            (uv-0.5)*vec2(1.,iResolution.y/iResolution.x)+o,\n            1.));\n    rd.xz *= rotate(.25);\n    rd.yz *= rotate(0.3);\n\n    vec3 ro = vec3(0.,-0.3,-1.);\n\n    vec3 col = render(ro,rd);\n    \n    vec3 prev = texture(iChannel0, uv).xyz;\n    \n    col += prev;\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}