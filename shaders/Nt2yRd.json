{
    "Shader": {
        "info": {
            "date": "1650144984",
            "description": "Mandelbulb",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt2yRd",
            "likes": 3,
            "name": "Mandelbulb - Spi3lot",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot",
                "anaglyph",
                "mandel",
                "bulb",
                "mandebulb"
            ],
            "usePreview": 0,
            "username": "Spi3lot",
            "viewed": 226
        },
        "renderpass": [
            {
                "code": "// CONSTANTS\n#define PI 3.1415926535\n\n// RAY MARCHING SETTINGS\n#define EPSILON 0.001\n#define MAX_STEPS 100\n\n// MANDELBULB SETTINGS\n#define POWER 2.0\n#define BAILOUT 2.0\n#define MAX_ITERATIONS 50\n\n// LIGHT SETTINGS\n#define LIGHT_ROTATION_SPEED 1.0\n#define LIGHT_ANGLE iTime * LIGHT_ROTATION_SPEED\n#define LIGHT 10.0 * vec3(cos(LIGHT_ANGLE), sin(LIGHT_ANGLE), -1)\n//#define LIGHT 100.0 * vec3(cos(iTime), 0, sin(iTime))\n\n// ZOOM\n#define ZOOM 1.0\n\n// FOV (leave as is for best results)\n#define FOVX 0.4 * PI / ZOOM\n#define FOVY FOVX * iResolution.y / iResolution.x\n\n// GLOW EFFECT\n#define GLOW_EFFECT\n\n// 3D ANAGLYPH (RED-CYAN)\n//#define ANAGLYPH\n#define ANAGLYPH_OFFSET vec3(0.05, 0.0, 0.0)\n\n\nfloat iterations = -1.0;\n\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat sdf(vec3 pos)\n{\n    vec3 z = pos;\n\tfloat dr = 1.0;\n    float r;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n\t\tr = length(z);\n\n\t\tif (r > BAILOUT) {\n            iterations = float(i);\n            break;\n        }\n\n\t\t// convert to polar coordinates\n\t\tfloat theta = POWER * acos(z.z / r) - PI * 0.5;\n\t\tfloat phi = POWER * atan(z.y, z.x);\n\t\tdr = pow(r, POWER - 1.0) * POWER * dr + 1.0;\n\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, POWER);\n\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\n\treturn 0.5 * log(r) * r / dr;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    const float eps = 5.0;  // The larger, the better (for some reason)\n    const vec2 h = vec2(eps, 0);\n\n    vec3 a = vec3( sdf(p - h.xyy),\n                   sdf(p - h.yxy),\n                   sdf(p - h.yyx) );\n\n    vec3 b = vec3( sdf(p + h.xyy),\n                   sdf(p + h.yxy),\n                   sdf(p + h.yyx) );\n\n    return normalize(b - a);\n}\n\nvec3 GetLight(vec3 pos)\n{\n    return normalize(LIGHT - pos);\n}\n\n\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    rd = normalize(rd);\n    float minDist = 1.0 / 0.0;  // Used for glow effect\n    \n    // Marching to the Mandelbulb\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = sdf(ro);\n\n        if (dist < minDist)\n            minDist = dist;\n\n        if (dist <= EPSILON)\n        {\n            vec3 normal = GetNormal(ro);\n            vec3 ro2Light = GetLight(ro);\n            \n            float light = clamp(dot(normal, ro2Light), 0.0, 1.0);\n            float ambientExposure = 1.0;\n\n            ro -= rd * EPSILON * 2.0;\n\n            // Ambient Occlusion\n            //   Marching to the light source\n            //   and checking for collisions on the way\n            for (int j = 0; j < MAX_STEPS; j++)\n            {\n                float distLightSource = length(LIGHT - ro);\n                if (distLightSource <= EPSILON)\n                {\n                    ambientExposure = 1.0;\n                    break;\n                }\n\n                float distMandel = sdf(ro);\n                if (distMandel <= EPSILON)\n                {\n                    ambientExposure = 0.5;\n                    break;\n                }\n\n                ro += ro2Light * min(distLightSource, distMandel);\n            }\n\n            vec4 col = vec4(1);\n            //vec4 col = vec4(iterations);\n            //col = cos(col);\n\n            return light * ambientExposure * col;\n        }\n\n        ro += rd * dist;\n    }\n\n#ifdef GLOW_EFFECT\n    return vec4(1e-3 / minDist);  // Glow\n#else\n    return vec4(0.0, 0.0, 0.0, 1.0);\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 norm = uv - 0.5;\n    \n    vec2 fov = vec2(FOVX, FOVY);\n    vec3 ro = vec3(LIGHT.xy / 20.0, -4);\n    vec3 rd = vec3(norm * fov, 1.0);  //vec3 rd = vec3(norm * fov, ZOOM);\n    vec4 col;\n    \n#ifdef ANAGLYPH\n    vec4 red = vec4(1,0,0,1) * march(ro + ANAGLYPH_OFFSET, rd);\n    vec4 cyan = vec4(0,1,1,1) * march(ro - ANAGLYPH_OFFSET, rd);\n    col = red + cyan;\n#else\n    col = march(ro, rd);\n#endif\n\n    // Output to screen\n    fragColor = col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}