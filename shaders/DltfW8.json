{
    "Shader": {
        "info": {
            "date": "1706791526",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "DltfW8",
            "likes": 7,
            "name": "_Electric Noise Sphere",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "pk1234",
            "viewed": 184
        },
        "renderpass": [
            {
                "code": "// shader strongly inspired by Noise animation - Electric by nimitz:  https://www.shadertoy.com/view/ldlXRS\n// but it's a 3D variation with some modifications\n\n#define numOctaves 4\n\nfloat fbm( in vec3 x, in float G )\n{    \n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*abs(gradnoise3d(f*x).x);      \n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat sample_fbm(vec3 pos){\n    float posy = pow(1.0 - pos.y, 0.01);\n    \n    pos = 6.0 * pos;\n    \n    float timeScaled = iTime * 0.08;\n    \n    vec3 random_offset = vec3(\n        fbm(pos * 0.7 + timeScaled , 0.5),\n        fbm(pos * 0.5 + timeScaled , 0.6),\n        fbm(pos * 0.6 + timeScaled , 0.65)\n        );\n    \n\n    vec3 offset = random_offset * 0.3;\n    \n   // mat3 Rot = Rot_y(-iTime * 0.04 * posy);\n     mat3 Rot = Rot_y(-iTime * 0.04);\n    pos = pos + offset;\n    \n    pos = Rot * pos;\n    return fbm(pos, 0.6);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfres = 0.5 * iResolution.xy;    \n\n    // get clip space (-1,1) vertical\n    vec2 uv = GetClippedSpaceCoords(fragCoord, iResolution);\n    \n    // mouse - in [-1, 1]^2\n    float mouse_vertical = GetMouseVerticalAngle(iMouse, iResolution);\n    float mouse_hori = GetMouseHorizontalAngle(iMouse, iResolution);\n    \n    // ray origin\n    vec3 ro = vec3(0,0,0);\n   \n    // ray dir\n    vec3 rd = vec3(uv.x,uv.y,-1.5);\n    rd = normalize(rd);\n    rd *=Rot_x(mouse_vertical);\n    rd *=Rot_y(mouse_hori);\n    \n    // get angles\n    vec2 phi_theta =GetPhiTheta(rd);\n    float phi = -phi_theta.x;\n    \n    // get tangent vec dirs\n    vec3 latitude_tangent = normalize(cross(rd, rd - rd.y));\n    vec3 long_tangent = cross(rd, latitude_tangent);\n   \n    // get angle value, flip so that it goes from top to bottom\n    float angle = saw_pattern(1.05, phi - iTime * PI * 0.10);\n    \n    // get circle value\n    //float circ_val = adsr(angle, 0.3, 0.99, 1.0, 5., 0.5);\n    float circ_val = adsr(angle, 0.5, 0.99, 0.99, 5., 0.5);;\n    rd *= (1.0 + circ_val * 0.1);\n        \n    // basic noise sample\n    float sample_val = sample_fbm(rd);\n    \n    // highlight of part near equator\n    float hori_highlight = smoothstep(0.08, 1.7, abs(phi));\n    hori_highlight = hori_highlight * 9. + 0.3;\n    \n    // highlight of the moving circle\n    float circ_highlight_sample = adsr(angle-0.02, 0.3, 0.980, 0.980, 8.,1.0);;\n    float circ_highlight = 1.0 - pow(circ_highlight_sample, 1.0);\n    \n    // get total factor that we'll invert the color by\n    float factor = sample_val  * hori_highlight * circ_highlight;\n    \n    // get color - blend purple and orange, depending on circle highlight\n    vec3 col_purple = vec3(.2,0.1,0.4);\n    vec3 col_orange = vec3(0.447,0.200,0.031);    \n    float col_blend = pow(circ_highlight_sample, 1.0);\n    vec3 col = mix(col_purple, col_orange, circ_highlight_sample);\n    \n    col = col * 0.3 / factor;\n    \n    // debug circle lines for visualization\n    //if (abs(phi) < 0.002) col = vec3(1.);   \n    //if (abs(angle - 0.01) < 0.002) col = vec3(1.);\n    //if (abs(angle - 0.9) < 0.002) col = vec3(1.);\n    //if (abs(angle - 0.999) < 0.002) col = vec3(1.);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define HALF_PI 1.570796\n#define S smoothstep\n#define T iTime\n\nvec3 hash( ivec3 p )     // this hash is not production ready, please\n{                        // replace this by something better\n\tivec3 n = ivec3( p.x*127 + p.y*311 + p.z*74,\n                     p.x*269 + p.y*183 + p.z*246,\n                     p.x*113 + p.y*271 + p.z*124);\n\n\t// 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*vec3( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nvec4 gradnoise3d( in vec3 x )\n{\n    // grid\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    \n    // quintic interpolant\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec3 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( i+ivec3(0,0,0) );\n    vec3 gb = hash( i+ivec3(1,0,0) );\n    vec3 gc = hash( i+ivec3(0,1,0) );\n    vec3 gd = hash( i+ivec3(1,1,0) );\n    vec3 ge = hash( i+ivec3(0,0,1) );\n\tvec3 gf = hash( i+ivec3(1,0,1) );\n    vec3 gg = hash( i+ivec3(0,1,1) );\n    vec3 gh = hash( i+ivec3(1,1,1) );\n    \n    // projections\n    float va = dot( ga, f-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, f-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, f-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, f-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, f-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, f-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, f-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, f-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\nmat3 Rot_x(float a) {\n    float s=sin(a), c=cos(a);\n    return mat3(\n    1.0, 0.0, 0.0,  \n    0.0, c, -s,\n    0.0, s, c);\n}\n\nmat3 Rot_y(float a) {\n    float s=sin(a), c=cos(a);\n    return mat3(\n    c, 0.0, -s,    \n    0.0, 1.0, 0.0,\n    s, 0.0, c);\n}\n\nvec2 GetPhiTheta(vec3 rd){\n    float phi = atan(rd.y, sqrt(rd.x * rd.x + rd.z * rd.z));\n    \n    float theta = atan(rd.z, abs(rd.x));\n    if (rd.x < 0.) theta = PI - theta;\n    \n    return vec2(phi, theta + PI * 0.5);\n}\n\nfloat cos_bump(float angle, float freq){\n    angle = clamp(angle * freq, -HALF_PI , HALF_PI);\n    return cos(angle);\n}\n\n// identity on [0,1], extended elsewhere\nfloat saturate(float x){\n    return clamp(x, 0.,1.);\n}\n\n// relevant stuff happens at [0,1], function is 0 elsewhere\n// [attack_start, sustain_start] - goes from 0. to 1.\n// [sustain_start, sustain_end] - constant 1.\n// [decay_start, 1.0] - goes from 1. to 0.\nfloat adsr(float x, float attack_start, float sustain_start, float decay_start, float attack_pow, float decay_pow){\n    float attack_length = sustain_start - attack_start;\n    \n    float attack = saturate((x-attack_start)*(1.0/attack_length));\n    \n    float decay = saturate((1.-x)*(1.0 / (1.0 - decay_start)));\n    \n    return pow(attack, attack_pow) * pow(decay, decay_pow);\n}\n\n\n// acts as identity on [-radius, radius], periodic elsewhere\nfloat saw_pattern(float radius, float x){\n    return mod(x + radius, 2.0 * radius) - radius;\n}\n\n// returns clipped space coords, [-1,1] vertically, horizontal scaled\nvec2 GetClippedSpaceCoords(in vec2 fragCoord, in vec3 iResolution){\n    vec2 halfres = 0.5 * iResolution.xy;    \n    vec2 uv = (fragCoord-halfres)/halfres.y;\n    return uv;\n}\n\nfloat GetMouseVerticalAngle(in vec4 iMouse, in vec3 iResolution){\n    vec2 halfres = 0.5 * iResolution.xy;    \n\tvec2 m = (iMouse.xy - halfres) / halfres;\n    return m.y*HALF_PI;\n}\n\nfloat GetMouseHorizontalAngle(in vec4 iMouse, in vec3 iResolution){\n    vec2 halfres = 0.5 * iResolution.xy;    \n\tvec2 m = (iMouse.xy - halfres) / halfres;\n    return m.x*PI;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}