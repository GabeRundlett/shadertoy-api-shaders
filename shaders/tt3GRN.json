{
    "Shader": {
        "info": {
            "date": "1577835221",
            "description": "Happy new year everyone!\n\nv1.1 Added an initial bright flash at the starting of each explosion. (Thanks bigwings)\nv1.2 Improved water reflections.\nv1.3 Added a crescent moon.\nv1.4 Rockets slow down nearing apex.",
            "flags": 0,
            "hasliked": 0,
            "id": "tt3GRN",
            "likes": 83,
            "name": "Happy 2020!",
            "published": 3,
            "tags": [
                "noise",
                "reflection",
                "fbm",
                "water",
                "particles",
                "city",
                "lights",
                "fireworks"
            ],
            "usePreview": 1,
            "username": "piyushslayer",
            "viewed": 5591
        },
        "renderpass": [
            {
                "code": "/**\n This shader is basically an improvement upon a previous fireworks shader I did a while\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\n instead of the just following the same pattern in a loop, so the fireworks show can be\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\n\n I wish a very happy and a prosperous new year to everyone!\n*/\n\n#define PI  3.141592653589793\n#define TAU 6.283185307179586\n#define EPS 1e-4\n\n// Helper macros \n#define C(x) clamp(x, 0., 1.)\n#define S(a, b, x) smoothstep(a, b, x)\n#define F(x, f) (floor(x * f) / f)\n\n// Fireworks control variables\n#define FIREWORK_COUNT 6\n#define FIREWORK_DURATION 8.5\n#define FIREWORK_LOW .75\n#define FIREWORK_HIGH 1.05\n#define ROCKET_PARTICES 16\n#define ROCKET_DURATION 1.5\n#define FLASH_DURATION ROCKET_DURATION + .2 \n#define THRUSTER_SPEED .25\n#define EXPLOSION_STRENGTH .025;\n#define EXPLOSION_PARTICLES 128\n\n// Hash functions by Dave_Hoskins\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec3 hash31(float p)\n{\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn vec3(n) * (1. / float(0xffffffffU));\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\n\tuint q = (n.x ^ n.y) * 1597334673U;\n\treturn float(q) * (1. / float(0xffffffffU));\n}\n\n// Function to remap a value from [a, b] to [c, d]\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Noise (from iq)\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3. - 2. * f);\n\tf.xy += p.xy + p.z * vec2 (37., 17.);\n\tf.xy = texture (iChannel0, (f.xy + .5) / 256., -256.).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\n// Tiny fbm\nfloat fbm (in vec3 p) {\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\n}\n\n// Building window lights from www.shadertoy.com/view/wtt3WB\nfloat windows (vec2 uv, float offset)\n{\n    vec2 grid = vec2(20., 1.);\n    uv.x += offset;\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\n    uv.x *= n1 * 6.;\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\n    float n = fbm(id.xxx);\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\n    vec2 lPos = fract(uv * lightGrid);\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\n    n2 = smoothstep(.225, .5, n2);\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\n}\n\n// Building skyline \nfloat buildings(vec2 st)\n{\n    // An fbm style amalgamation of various cos functions\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\n    return C((st.y + b - .1) * 100.);\n}\n\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\nfloat stars(vec2 st, vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y += .3;\n    uv.y = abs(uv.y);\n    float t = iTime * .1;\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\n    twinkle = twinkle * .5 + .5;\n    return h.x * h.y * twinkle * 1.5;\n}\n\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\nvec3 fireworks(vec2 st)\n{\n\tvec2 fireworkPos, particlePos;\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\n    {\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\n        // This hash changes after each firework cycle (rocket + explosion)\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\n        fireworkCol = fireworkHash * .5 + .5;\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\n        // Random firework x coordinate but confined to a certain column based on j\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\n        // Duration of each firework with a random start time\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\n        if (time > ROCKET_DURATION)\n        {\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\n            {\n                // Unique hash that yeilds a separate spread pattern for each explosion\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \n\t\t\t\t\t* 1619.8196 + 469.7119);\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\n                // Radius expands exponentially over time, i.e. explosion effect\n                radius = radiusScale * time * time;\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\n                // particlePos.y -= 8. * pow(particlePos.x, 4.); \n                // willow effect\n                particlePos.y -= max(EPS, pow(length(particlePos) - 0.05, 2.0) * 1.25);\n                // slightly descend back down due to gravity\n                particlePos.y -= pow(radius / radiusScale, 3.0) * 4e-5; \n                // bloom\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\n                // Shimmering effect for explosion particles\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \n                    * (sin((iTime * max(1.3, fireworkHash.z * 2.0) + particleHash.y * TAU) * 18.)));\n                shimmerThreshold = FIREWORK_DURATION * .9;\n                // Fade after a certain time threshold\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\n                    * fade * fireworkCol;\n            }\n            \n            // Initial instant flash for the explosion\n            if(time < FLASH_DURATION)\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\n        }\n        else\n        {\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\n            // ease out sine\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\n            fireworkPos = vec2(fireworkHash.x, \n                    rocketPath * fireworkHash.y);\n            // Slight random wiggle for the rocket's path\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\n            \n            // Rockets flying before the explosion\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\n            {\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\n                // rocket trail size\n                float t = time * (2. - time);\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\n\t\t\t\t\t* particleHash.z * .1;\n                // Confine theta to a small value for a vertical thrust effect\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\n            }\n        }\n    }  \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    uv.y += .3; // shift the horizon a bit lower\n    float reflection = 0.;\n    \n    if (uv.y < 0.)\n    {\n        reflection = 1.;\n        // watery distortion in the lake (improved)\n        /**\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\n\t\t*/\n        \n        // slightly better looking water waves\n        uv.x += cos(uv.y * 192. - iTime * .6) * sin(uv.y * 96. + iTime * .75) * .042;\n    }\n\n    // Our special uv coord that gives us reflection effect for pratically free\n    vec2 st = vec2(uv.x, abs(uv.y));\n    vec3 col = vec3(0.);\n    \n    // Background mountain\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\n    mountain = C(S(-.005, .005, mountain));\n    \n    float building = buildings(st);\n    \n    // Finally blend everything together\n    \n    // Sky color\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\n    // Blend the mountain and the sky\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\n    // Occlude the mountain with the building skyline\n    col *= building;\n    \n    // Yellow-ish window color tint\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \n    \n    // Moon white circle\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\n    \n    //Twinkly stars, masked by the buildings, mountain, and the moon\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\n    \n    // Cut the main moon circle with an offset inverted one to make a crescent\n    moon *= smoothstep(.32, .48, length(st-vec2(.92, .88))) * 1.25;\n    \n    // Add the moon to the scene\n    col += moon * vec3(1.2, 1.18, 1.);\n    \n    \n    // Fireworks launch from behind the buildings, but in front of the mountains\n    col += C(fireworks(st)) * (building + moon);\n    \n    // Slightly change of the reflections to watery blueish-green\n    col.r -= reflection * .05;\n    col.gb += reflection * .01;\n    \n    fragColor = vec4(col - hash11(fragCoord.x * fragCoord.y * 0.2 * (iTime + 50.0)) * 0.008, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}