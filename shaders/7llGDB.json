{
    "Shader": {
        "info": {
            "date": "1622790026",
            "description": "SDF autovoxelizer... the more granular the faster!",
            "flags": 0,
            "hasliked": 0,
            "id": "7llGDB",
            "likes": 15,
            "name": "SDF autovoxelizer",
            "published": 3,
            "tags": [
                "sdf",
                "distance",
                "field",
                "signed",
                "voxelizer",
                "autovoxelizer"
            ],
            "usePreview": 0,
            "username": "toomuchvoltage",
            "viewed": 658
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   SDF autovoxelizer.\n   If you know a faster way, please comment.\n\n   Covered under the MIT license:\n\n   Copyright (c) 2021 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\n#define DRAW_DISTANCE 100.0\n#define M_PI 3.1415926535\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sceneMetaballs (vec3 p)\n{\n    float curTime = iTime * 3.0;\n    vec3 p1 = vec3(sin(curTime * 0.95 + 11.0), sin(curTime * 0.87 + 9.0), cos(curTime * 0.95 - 7.0)) * 0.5;\n    vec3 p2 = vec3(sin(curTime * 1.24 + 2.0), sin(curTime * 1.37 - 8.0), cos(curTime * 1.17 + 6.0)) * 0.5;\n    vec3 p3 = vec3(sin(curTime * 1.04 - 3.0), sin(curTime * 1.05 + 3.0), cos(curTime * 1.41 + 3.0)) * 0.5;\n    float sp1 = length(p + p1) - 0.5;\n    float sp2 = length(p + p2) - 0.5;\n    float sp3 = length(p + p3) - 0.5;\n    return opSmoothUnion (opSmoothUnion(sp1, sp2, 0.7), sp3, 0.7);\n}\n\n// Larval by Paul Malin: https://www.shadertoy.com/view/ldB3Rz\n\n// mat3 from quaternion\nmat3 SetRot( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n// mat3 from axis / angle\nmat3 SetRot( vec3 vAxis, float fAngle )\n{\t\n\treturn SetRot( vec4(normalize(vAxis) * sin(fAngle), cos(fAngle)) );\n}\n\nmat3 m;\nfloat sceneKIFS( in vec3 vPos )\n{\n    vPos /= 0.1;\n    const float fScale=1.25;\n    const vec3 vOffset = vec3(-1.0,-2.0,-0.2);\t\n\t\n\tfloat fTotalScale = 1.0;\n\tfor(int i=0; i<16; i++)\n\t{\t\n\t\tvPos.xyz = abs(vPos.xyz);\n\t\tvPos *= fScale;\n\t\tfTotalScale *= fScale;\n\t\tvPos += vOffset;\n\t\tvPos.xyz = (vPos.xyz) * m;\n\t\t\n\t\tfloat fCurrDist = length(vPos.xyz) * fTotalScale;\n\t}\n\n\tfloat l = length(vPos.xyz) / fTotalScale;\n\t\n\tfloat fDist = l - 0.1;\n\treturn fDist * 0.1;\n}\n\nfloat sdBox( vec3 p, float b )\n{\n    vec3 q = abs(p) - vec3 (b);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Switch below to sceneKIFS(x) for KIFS!\n#define scene(x) sceneMetaballs(x)\n#define edgeLen 0.025\n\nfloat voxelizeScene (vec3 p)\n{\n    float halo = scene(p) - edgeLen * 1.732;\n    if ( halo >= 0.001 )\n    {\n        return halo;\n    }\n    else\n    {\n        vec3 tmpI;\n        modf(p / edgeLen, tmpI);\n        vec3 descP = (tmpI) * edgeLen;\n\n        float retdist = edgeLen;\n        for (int i = -1; i != 2; i++)\n            for (int j = -1; j != 2; j++)\n                for (int k = -1; k != 2; k++)\n                {\n                    descP = (tmpI + vec3(i,j,k)) * edgeLen;\n                    float sceneEval = scene(descP);\n                    if ( sceneEval < 0.0 ) retdist = min(sdBox(p - descP, edgeLen), retdist);\n                }\n        return retdist;\n    }\n}\n\nbool sphereMarchScene(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = voxelizeScene (samplePt);\n        if ( curDist < 0.001 )\n        {\n            hitNorm.x = voxelizeScene(samplePt + vec3(0.001, 0.0, 0.0)) - voxelizeScene(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = voxelizeScene(samplePt + vec3(0.0, 0.001, 0.0)) - voxelizeScene(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = voxelizeScene(samplePt + vec3(0.0, 0.0, 0.001)) - voxelizeScene(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = SetRot( vec3(0.1, 1.0, 0.01), iTime * 0.3 );\n\n    vec2 uvRaw = fragCoord/iResolution.xy;\n    vec2 uv = uvRaw * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec4 mouseInfo = iMouse / iResolution.xxxx;\n    \n    vec3 curEye = vec3 (cos(mouseInfo.x * 6.0 - M_PI * 0.5), mouseInfo.y * 6.0 - M_PI * 0.5, sin(mouseInfo.x * 6.0 - M_PI * 0.5)) * 3.0;\n    vec3 sampleLook = normalize (-curEye);\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    if ( dot (up, vec3 (0.0, 1.0, 0.0)) < 0.0 ) up = -up;\n    \n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n\n    samplePt = curEye + sampleDir;\n    bool samplingLight = false;\n    vec3 hitNorm, hitPoint;\n    vec3 colorAccum = vec3 (0.0);\n\n    if ( sphereMarchScene (samplePt, sampleDir, hitPoint, hitNorm) )\n        fragColor = vec4 (abs(dot(sampleDir,hitNorm)));\n    else\n        fragColor = texture(iChannel0, sampleDir);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}