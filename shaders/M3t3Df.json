{
    "Shader": {
        "info": {
            "date": "1717099366",
            "description": "This kinda works with a lot of limitations",
            "flags": 0,
            "hasliked": 0,
            "id": "M3t3Df",
            "likes": 4,
            "name": "First-class functions",
            "published": 3,
            "tags": [
                "cursed"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 87
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y * 3.0;\n    vec2 mo = (iMouse.xy*2.0-iResolution.xy)/iResolution.y * 3.0;\n    if (iMouse.z < 0.0001)\n        mo = vec2(0);\n    \n    \n    \n    // --- ⬇⬇⬇ THE INTERESTING PART ⬇⬇⬇ ---\n\n    // \"Functional\" programming by passing method name\n    // as parameter into another \"method\"!\n    float value1 = fbm4(uv + 10.0, valueNoise);\n    float value2 = fbm8(uv + 10.0, cellNoise);\n    vec2 value3 = derivative(uv * 5.0, 0.001, valueNoise)*0.5+0.5;\n    \n    // --- ⬆⬆⬆ THE INTERESTING PART ⬆⬆⬆ ---\n    \n    \n    \n    vec3 value = mix(vec3(value1), vec3(value2), step(mo.x, uv.x));\n    value = mix(vec3(value3, 0.0), value, step(mo.y, uv.y));\n\n    fragColor = vec4(value,1.0);\n}\n\n// The trick is at the bottom of Common",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The trick is at the bottom of Common\n\n// Hashes made by Dave_Hoskins from https://www.shadertoy.com/view/4djSRW\nfloat hash1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\nvec2 hash2(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash2(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec4 hash4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec4 hash4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash4(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 f = fract(p);\n    // smootherstep\n    f = 6.0*f*f*f*f*f - 15.0*f*f*f*f + 10.0*f*f*f;\n    vec2 c = floor(p);\n    vec2 e = vec2(0, 1);\n    \n    float tl = hash1(c + e.xy);\n    float tr = hash1(c + e.yy);\n    float bl = hash1(c + e.xx);\n    float br = hash1(c + e.yx);\n    \n    return mix(mix(bl, br, f.x), mix(tl, tr, f.x), f.y);\n}\n\nfloat cellNoise(vec2 p)\n{\n    float r = 100000.0;\n    vec2 fp = floor(p);\n    for(int x = -1; x <= 1; x++)\n    for(int y = -1; y <= 1; y++)\n    {\n        vec2 cell = fp+vec2(x, y);\n        vec2 rp = cell+0.5+(hash2(cell)-0.5)*1.0;\n        r = min(r, distance(p, rp));\n    }\n    return r;\n}\n\n\n// \"Methods\" that take another method/macro as the parameter\n// Quite limited though, unfortunately\n#define derivative(uv, eps, func) (vec2(func(uv + vec2(eps, 0)) - func(uv - vec2(eps, 0)), func(uv + vec2(0, eps)) - func(uv - vec2(0, eps)))/eps*0.5)\n#define fbm2(uv, func) (func((uv)+10.0)*0.5+func((uv)*2.0+10.0)*0.25)\n#define fbm4(uv, func) (fbm2((uv), func)+func((uv)*4.0+10.0)*0.125+func((uv)*8.0+10.0)*0.0625)\n#define fbm8(uv, func) (fbm4((uv), func)+func((uv)*16.0+10.0)/16.0+func((uv)*32.0+10.0)/32.0+func((uv)*64.0+10.0)/64.0+func((uv)*128.0+10.0)/128.0)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}