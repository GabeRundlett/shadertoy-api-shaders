{
    "Shader": {
        "info": {
            "date": "1683547445",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!",
            "flags": 0,
            "hasliked": 0,
            "id": "DlKGzR",
            "likes": 22,
            "name": "Year of Truchets #019",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 276
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Year of Truchets #019\n    05/08/2023  @byt3 - m3chanic\n    \n    Just a mix of things laying around on the shader floor scrapped together \n    with some reflections and love.. \n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265\n#define PI2         6.28318530\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(26.37,45.93)))*4374.23); }\n\n// https://www.shadertoy.com/view/wsjfRD \n// simple fbm noise generation for clouds\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2. - 1.;\n}\n// A perlin noise function. Since we are not using textures, we am gonna sample 8 corners of a cube.\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0., 1., v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1, 0, 0));\n    float c = rand(u + vec3(0, 1, 0));\n    float d = rand(u + vec3(1, 1, 0));\n    float e = rand(u + vec3(0, 0, 1));\n    float f = rand(u + vec3(1, 0, 1));\n    float g = rand(u + vec3(0, 1, 1));\n    float h = rand(u + vec3(1, 1, 1));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n// The fbm function.\nfloat fbm(vec3 p) {\n    vec3 off = vec3(.175,.4,.0) * T;\n    vec3 q = p + off;\n    // fbm\n    float f = .5 * perlin(q); q *= 2.;\n    f += .125 * perlin(q); q *= 2.;\n    f += .225 * perlin(q); q *= 2.;\n    return clamp(f - p.y, .0, 1.);\n}\n\n//@iq shapes\nfloat box( vec3 p, vec3 s ) {\n    p = abs(p)-s;\n    return length(max(p,0.))+min(max(p.x, max(p.y, p.z)),0.)-.025;\n}\n\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0),speed=vec3(0);\nmat2 r90,r35,r25;\n\nconst float size = 2.125;\nconst float hlf = size/2.;\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    vec2 id = floor((p.xz+hlf)/size);\n    vec2 q = mod(p.xz+hlf,size)-hlf;\n\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n    float hs = hash21(id);\n    float hss = hs;\n    if(hs>.5) q*=r90;\n    \n    hs = perlin(vec3(id,.1)*2.2);\n    \n    vec2 d2 = vec2(length(q-hlf), length(q+hlf));\n    vec2 gx = d2.x<d2.y ? vec2(q-hlf) : vec2(q+hlf);\n\n    float ff = .15+perlin(vec3(p.xz,T*.7)*.45)*.75;  \n    float tk = .35+.25*sin(ff+(p.x*.33+p.z*.21)-T);\n    \n    vec3 r = vec3(gx.x,p.y-ff,gx.y);\n    vec3 t = vec3(q.x,p.y-ff,q.y);\n\n    float d4 = trs(r,vec2(hlf,tk));\n\n    if(hs>.75) {\n        d4 = min(length(t.yz)-tk,length(t.yx)-tk);\n    } else if (hs>.5) {\n        d4 = min(length(vec3(abs(t.x)-hlf,t.yz))-tk,length(vec3(t.yx,abs(t.z)-hlf))-tk);\n    } else if (hs>.25) {\n        d4 = min(length(t.yx)-tk, length(vec3(abs(t.x)-hlf,t.yz))-tk);\n    }\n\n    if(d4<res.x){\n        float rs=fract(hss*432.32);\n        res = vec2(d4,rs<.465?3.:4.);\n        hit = p; \n        gid = vec3(id,1);\n    }\n    \n    float fl = p.y+2.;\n    if(fl<res.x){\n        res = vec2(fl,2.);\n        hit = p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec4 sumColor;\nvec2 marcher(vec3 ro, vec3 rd, int steps,  float bnc) {\n    float t = .0;\n    float m = .0;\n    for( int i=0; i<steps; i++ ) {\n        vec3 p = ro + rd * t;\n        vec2 d = map(p);\n        //@42yeah https://www.shadertoy.com/view/wsjfRD \n        // simple volume trace in my march\n        float density = fbm(p);\n        if (density > 1e-2) {\n            vec4 color = vec4(mix(vec3(0), vec3(1), density), density);\n            color.w *= .5;\n            color.rgb *= color.w;\n            sumColor += color * (1.1 - sumColor.a);\n        }\n        //\n        m = d.y;\n        if(d.x<MIN_DIST*t||t>MAX_DIST) break;\n        t += i<32? d.x*.4 : d.x;\n    }\n    return vec2(t,m);\n}\n\nvec3 hue(float t) {\n    return .45 + .35*cos(PI2*t*(vec3(.12,.47,.92)+vec3(.88,.97,.85))); \n}\n\nvec4 FC = vec4(.65,.75,.75,0);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float bnc, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100,bnc);\n    hitPoint = hit;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-5,20,-15);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.1);\n        vec3 hp = hitPoint*vec3(-1,1,1);\n \n        float diff = clamp(dot(n,l),.1,.95);\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(normalize(lpos),n)),.1),45.);\n\n        if(m==2.){\n            h = vec3(.1);\n            vec2 f = fract(hp.xz)-.5;\n            if(f.x*f.y>0.) {h = vec3(0); ref = vec3(0);}\n        }\n        if(m==3.){\n            h = hue(((121.-hp.z)*.02)+((321.-hp.x)*.015));\n            ref = h*.35;\n        }\n        if(m==4.){\n            h = vec3(clamp(.1+perlin(hp*.12),0.,1.));\n            ref = vec3(.1);\n        }\n\n        C = (diff*h)+spec;\n\n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    } else {\n        C = vec3(1);\n    }\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r35=rot(-.685);\n    r25=rot(-.685+.2*sin(T*.125));\n    r90=rot(1.5707);\n    speed = vec3(0,0,T*.55);\n    \n    // zoom level \n    float zoom = 10.;\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*zoom,-(zoom+5.));\n    vec3 rd = vec3(0,0,1);\n    \n    ro.yz*=r35,ro.xz*=r25;\n    rd.yz*=r35,rd.xz*=r25;\n\n    // reflection loop (@BigWings)\n    vec3 C = vec3(0),ref=vec3(0), fil=vec3(1);\n    float d = 0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n  \n    C += sumColor.rgb;\n    C = mix(C,clamp(C*.75,vec3(0),vec3(1)),hash21(uv+2.));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}