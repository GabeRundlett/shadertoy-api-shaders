{
    "Shader": {
        "info": {
            "date": "1570845340",
            "description": "Inktober, but with shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "wdGGDy",
            "likes": 4,
            "name": "shadetober #11 (snow)",
            "published": 3,
            "tags": [
                "inktober",
                "shadertober",
                "shadetober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "percentcer",
            "viewed": 405
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n#define MAX_MARCHING_STEPS 256\n#define EPSILON .0001\n#define MAX_DEPTH 40.\n\nconst float rad = 2.;\n\nfloat sdWibblySphere( vec3 p, float s )\n{\n    float timeShift = mod(iTime, PI * 2.);\n\tp.y += sin(p.y * 4. + timeShift) * 1.;\n    return length(p)-(s);\n}\n\n// \"snow\" heh geddit\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nvec3 gradient(vec3 p) {\n    return normalize(vec3(\n        sdWibblySphere(vec3(p.x + EPSILON, p.yz), rad) - sdWibblySphere(vec3(p.x - EPSILON, p.yz), rad),\n        sdWibblySphere(vec3(p.x, p.y + EPSILON, p.z), rad) - sdWibblySphere(vec3(p.x, p.y - EPSILON, p.z), rad),\n        sdWibblySphere(vec3(p.xy, p.z + EPSILON), rad) - sdWibblySphere(vec3(p.xy, p.z - EPSILON), rad)\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5,.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(.2) * (1.4 - length(uv));\n    uv += vec2(.5,.5);\n    \n    // pos out of screen neg into screen\n    vec3 eye = vec3(0., 0., 5.);\n    vec2 pix = fragCoord - iResolution.xy * .5;\n    float z = iResolution.y / tan((PI * .5) * .5);\n    vec3 ray = normalize(vec3(pix, -z));\n    \n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n        vec3 hPoint = eye + depth * ray;\n        float dist = sdWibblySphere(hPoint, rad);\n        if (dist < EPSILON) {\n            vec3 norm = gradient(hPoint);\n            col = vec3(norm.z) * rand((20. + iTime) * uv.x * uv.y);\n            break;\n        }\n        depth += dist;\n        if (depth > MAX_DEPTH) {\n            break;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}