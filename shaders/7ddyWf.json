{
    "Shader": {
        "info": {
            "date": "1654199552",
            "description": "This is our final project",
            "flags": 0,
            "hasliked": 0,
            "id": "7ddyWf",
            "likes": 5,
            "name": "Art Room - Final Project",
            "published": 3,
            "tags": [
                "art"
            ],
            "usePreview": 1,
            "username": "Charbake",
            "viewed": 284
        },
        "renderpass": [
            {
                "code": "//Creating the map of the whole world of SDFs\nfloat map(vec3 p, settings setts)\n{\n    return world_sdf(p, iTime, setts);\n}\n\n\n// Computing the normals\nvec3 computeNormal(vec3 p, settings setts)\n{\n    const float h = 1e-4;\n    float dist = world_sdf(p, iTime, setts);  \n    float distx = world_sdf(p+vec3(h,0.,0.), iTime, setts) - dist;\n    float disty = world_sdf(p+vec3(0.,h,0.), iTime, setts) - dist;\n    float distz = world_sdf(p+vec3(0.,0.,h), iTime, setts) - dist;\n    vec3 un_norm = vec3(distx, disty, distz);\n    return normalize(un_norm);\n}\n\n//Sphere tracing\nbool sphere_tracing(ray r,\n               \t\tint max_iter,\n               \t\tsettings setts,\n               \t\tout vec3 hit_loc,\n               \t\tout int iters)\n{\n    hit_loc = r.origin + r.direction * (-r.origin.y / r.direction.y);\n    iters = 1;\n\n    float step_size;\n    vec3 old_loc = r.origin;\n    int curr_iters = 1;\n    while (curr_iters < max_iter){\n        step_size = world_sdf(old_loc, iTime, setts);\n        vec3 curr_loc = old_loc + step_size*r.direction;\n        if (step_size < 1e-4){\n            hit_loc = curr_loc;\n            iters = curr_iters;\n            return true;\n        }\n        old_loc = curr_loc;\n        curr_iters += 1;\n    }\n    iters = max_iter;\n    return false;\n}\n\n\nvec3 shade(ray r, int iters, settings setts)\n{\n    vec3 p = r.origin;\n    vec3 d = r.direction;\n    \n    if (setts.shade_mode == GRID)\n    {\n    \tfloat res = 0.2;\n    \tfloat one = abs(mod(p.x, res) - res / 2.0);\n    \tfloat two = abs(mod(p.y, res) - res / 2.0);\n    \tfloat three = abs(mod(p.z, res) - res / 2.0);\n    \tfloat interp = min(one, min(two, three)) / res;\n        \n        return mix( vec3(0.2, 0.5, 1.0), vec3(0.1, 0.1, 0.1), smoothstep(0.0,0.05,abs(interp)) );\n    }\n    else if (setts.shade_mode == COST)\n    {\n        return vec3(float(iters) / float(cost_norm));\n    }\n    else if (setts.shade_mode == NORMAL)\n    {\n        vec3 normal = computeNormal(p, setts);\n        vec3 calc = vec3((normal.x+1.0)/2.0, (normal.y+1.0)/2.0, (normal.z+1.0)/2.0);\n        return calc;\n    }\n    else if (setts.shade_mode == DIFFUSE_POINT)\n    {\n        float r = abs(cos(iTime * 0.2));\n        float g = abs(sin(iTime * 0.2));\n        float b = abs(tan(iTime * 0.2));\n        \n        //static light source\n        vec3 light_pos = vec3(0.0, 7., -2.);\n        \n        //moving light source\n        //vec3 light_pos = vec3(r, 4. + g, b);\n     \n        vec3 light_intensity = vec3(20.0);\n        vec3 surface_color = vec3(0.0,0.8,0.9);\n        \n        //Changing color\n        //vec3 surface_color = vec3(r, g, b);\n        \n        vec3 normal = computeNormal(p, setts);\n        vec3 Li = light_intensity/dot(light_pos-p, light_pos-p);\n        vec3 color = surface_color*max(0.0, dot(normalize(light_pos-p), normalize(normal)))*Li;\n        return color;\n    }\n    else\n    {\n        return vec3(0.0);\n    }\n    \n    return vec3(0.0);\n}\n\n\nvec3 render(settings setts, vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    if (p.y < -0.95)\n    {\n        float val = cos(iTime * anim_speed);\n    }\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= aspect;\n   \n    //Static Camera\n    vec3 eye = vec3(0.0, 0.5 , -4.1);\n    \n    // RIGHT STACK\n    //vec3 eye = vec3(1.4, 0.2 , -0.9);\n    //vec3 dir = vec3(-0.9, 0.3, 1.0) - eye;\n    \n    //Rotating the camera\n    //float change = abs(1. - abs(cos(iTime*0.2)));\n    //vec3 eye = vec3(0.0, 0.5 + 5.*change, -4.0);\n    \n   // Shelf View\n    //vec3 eye = vec3(1.45, 0.75 , -2.0);\n    //vec3 dir = vec3(-1.5, 0.8, 0.) - eye;\n    \n    //Left Wall View\n    //vec3 eye = vec3(-1.49, 0.75 , -1.0);\n    //vec3 dir = vec3(1.3, 0.95, 0.) - eye;\n    \n    //vec3 eye = vec3(-1.45, 0.75 , -4.0);\n    \n    \n    vec3 dir = vec3(0.0, 0.8, 0.) - eye;\n    vec3 up = vec3(0, 1., 0);\n    \n    \n    float focal_length = 2.;\n    \n    vec3 u,v,w;\n    compute_camera_frame(dir, up, u, v, w);\n    \n    ray r;\n    switch(projection_func) {\n        case PROJECTION_ORTHOGRAPHIC:\n            r = generate_ray_orthographic(uv, eye, u, v, w);\n            break;\n     \n        case PROJECTION_PERSPECTIVE:\n            r = generate_ray_perspective(uv, eye, u, v, w, focal_length);\n            break;\n    }\n    \n    int max_iter = 1000;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 hit_loc;\n    int iters;\n    bool hit;\n    \n    if (sphere_tracing(r, max_iter, setts, hit_loc, iters))\n    {\n        r.origin = hit_loc;\n        col = shade(r, iters, setts);\n    }\n    \n\n    \n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(render(render_settings, fragCoord), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// pre-defined constants\n#define EPSILON 1e-4\n#define PI 3.1415926535897932384626433832795\n\n\n// shade mode\n#define GRID 0\n#define COST 1\n#define NORMAL 2\n#define AMBIENT 3\n#define DIFFUSE_POINT 4\n#define ENVIRONMENT_MAP 5\n\n\n// Render Settings\n\nstruct settings\n{\n    int shade_mode;\n};\n\nsettings render_settings = settings(NORMAL);\n\nfloat anim_speed = 0.35;\nint cost_norm = 200;\n\nvec3 two_tone_color_a = vec3(0.6 * 1.0, 0.6 * 1.0, 0.0 * 1.0);\nvec3 two_tone_color_b = vec3(0.2 * 1.0, 0.1 * 1.0, 0.9 * 1.0);\nvec3 two_tone_dir = vec3(1.0, 1.0, 0.0);\n\n//SDFs -- All reused from previous assignments\n\n// returns the signed distance to a sphere from position p\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n// returns the signed distance to a box from position p\nfloat sdBox( vec3 p, vec3 half_bounds )\n{\n    vec3 dist = abs(p) - half_bounds;\n    float max_dist = max(dist.x,max(dist.y,dist.z));\n    float inside = min(max_dist, 0.0);\n    float outside = length(max(dist, 0.0));\n    return inside + outside;\n}\n\n// returns the signed distance to a cylinder from position p\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  b_minus_a = b - a;\n    vec3  p_minus_a = p - a;\n    float ba_ba = dot(b_minus_a,b_minus_a);\n    float pa_ba = dot(p_minus_a,b_minus_a);\n    float x = length(p_minus_a*ba_ba-b_minus_a*pa_ba) - r*ba_ba;\n    float y = abs(pa_ba-ba_ba*0.5)-ba_ba*0.5;\n    float x2 = x*x;\n    float y2_ba = y*y*ba_ba;\n    float dist = 0.0;\n    if (max(x,y)<0.0){\n        dist = -min(x2,y2_ba);\n    }\n    else{\n        if (x>0.0){\n            dist = x2;\n        }\n        if (y>0.0){\n            dist += y2_ba;\n        }\n    }\n    return sign(dist)*sqrt(abs(dist))/ba_ba;\n}\n\n// returns the signed distance to a cone from position p\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec3  b_minus_a = b - a;\n    vec3  p_minus_a = p - a;\n    float rb_minus_ra  = rb-ra;\n    float ba_dot = dot(b_minus_a,b_minus_a);\n    float pa_dot = dot(p_minus_a,p_minus_a);\n    float pa_ba = dot(p_minus_a,b_minus_a)/ba_dot;\n    float x = sqrt( pa_dot - pa_ba*pa_ba*ba_dot );\n    \n    float radius = 0.0;\n    if (pa_ba<0.5){\n        radius = ra;\n    }\n    else{\n        radius = rb;\n    }\n    float x_mag = max(0.0,x-radius);\n    float y_mag = abs(pa_ba-0.5)-0.5;\n    float k = rb_minus_ra*rb_minus_ra + ba_dot;\n    float f = max((rb_minus_ra*(x-ra)+pa_ba*ba_dot)/k, 0.0);\n    f = min(f,1.0);\n    float x_mag1 = x-ra - f*rb_minus_ra;\n    float y_mag1 = pa_ba - f;\n    float ori = 0.0;\n    if (x_mag1<0.0 && y_mag<0.0){\n        ori = -1.0;\n    }\n    else{\n        ori = 1.0;\n    }\n    float xx = x_mag*x_mag;\n    float yy = y_mag*y_mag;\n    float xx1 = x_mag1*x_mag1;\n    float yy1 = y_mag1*y_mag1;\n    \n    float squared = min(xx + yy*ba_dot, xx1 + yy1*ba_dot);\n    return ori*sqrt(squared);\n}\n\n//Boolean Set Operations - All reused from previous assignments\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = max(k-abs(d1-d2), 0.0);\n    float s_union = min(d1, d2) - (h*h)/(4.0*k);\n    return s_union;\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    float h = max(k-abs(-d1-d2), 0.0);\n    float s_subtraction = max(-d1, d2) + (h*h)/(4.0*k);\n    return s_subtraction;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2), 0.0);\n    float s_intersection = max(d1, d2) + (h*h)/(4.0*k);\n    return s_intersection;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  float len = length(p.xz)-t.x;\n  vec2 q = vec2(len,p.y);\n  return length(q)-t.y;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\n\n#define PROJECTION_ORTHOGRAPHIC 0\n#define PROJECTION_PERSPECTIVE  1\n\nint projection_func = PROJECTION_PERSPECTIVE;\n\n//Ray generation\nstruct ray { \n    vec3 origin;\n    vec3 direction;\n};\n\n\n//Computing the camera frame\nvoid compute_camera_frame(vec3 dir, vec3 up, out vec3 u, out vec3 v, out vec3 w){\n    w = -dir/(sqrt(dot(dir,dir)));\n    u = (cross(up, w))/(sqrt(dot(cross(up,w),cross(up,w))));\n    v = cross(w,u);\n}\n\n//Generating an orthographic ray\nray generate_ray_orthographic(vec2 uv, vec3 e, vec3 u, vec3 v, vec3 w) {\n    return ray(e + uv.x*u + uv.y*v, -w);\n\n}\n\n//Generating a persepective ray\nray generate_ray_perspective(vec2 uv, vec3 eye, vec3 u, vec3 v, vec3 w, float focal_length) {\n    vec3 dir = -1.0*focal_length*w + uv.x*u + uv.y*v;\n    return ray(eye, dir/length(dir));\n}\n\n// returns the signed distance to an infinate plane with a specific y value\nfloat sdPlane(vec3 p, float z)\n{\n    return p.z - z;\n}\n\nfloat world_sdf(vec3 p, float time, settings setts)\n{\n    float dist = 100000.0;\n    \n    //Room itself\n    \n    dist = sdPlane(p.xzy,  -0.3); // floor\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(0.0, 0.0, 102.0), vec3(100.)), 0.001);  //back wall\n    \n    //Left pedestal -- built with cylinders, toruses, and a cone on top\n  \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(1.2,-0.25,1.7), vec2(0.2, 0.04)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(1.2,0.25,1.7), vec2(0.2, 0.04)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(1.2,0.0,1.7), vec2(0.2, 0.04)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(1.2,0.5,1.7), vec2(0.2, 0.04)), 0.01);  \n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(1.2,-0.25,1.7), vec3(-0.2,-0.25,0.), vec3(-0.2,1.1,0.), 0.04), 0.001);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(1.2,-0.25,1.7), vec3(0.2,-0.25,0.) , vec3(0.2,1.1,0.), 0.04), 0.001);\n   \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(1.2,-0.25,1.7), vec3(0.0,-0.25,0.2), vec3(0.,1.1,0.2), 0.04), 0.001);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(1.2,-0.25,1.7), vec3(0.,-0.25,-0.2) , vec3(0.0,1.1,-0.2), 0.04), 0.001);\n    \n    vec3 cone_a = vec3(0.0, 0.75, 0.0);\n    vec3 cone_b = vec3(0.0, 0.85, 0.0);\n    float cone_ra = 0.2;\n    float cone_rb = 0.3;\n    dist = opSmoothUnion(dist, sdCone(p - vec3(1.2,0.0,1.7), cone_a, cone_b, cone_ra, cone_rb), 0.01);\n    \n    \n    //Right pedestal -- built of toruses and slanted cylinders\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.3, 0.03)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.25, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.2, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.15, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.1, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.01, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.3, 0.03)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.25, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.2, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.15, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.1, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.01, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.315,0.8,0.), vec3(-0.315,-0.2,0.), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(-0.315,0.8,0.), vec3(0.315,-0.2,0.), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.0,0.8,0.315), vec3(0.0,-0.2,-0.315), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.0,0.8,-0.315), vec3(0.0,-0.2,0.315), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.23,0.8,0.23), vec3(-0.23,-0.2,-0.23), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(-0.23,0.8,-0.23), vec3(0.23,-0.2,0.23), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.23,0.8,-0.23), vec3(-.23,-0.2,0.23), 0.02), 0.01);\n   \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(-0.23,0.8,0.23), vec3(0.23,-0.2,-0.23), 0.02), 0.01);\n    \n    \n    //Chandelier -- all made of cones\n    float height = 1.6;\n    float closeZ = 0.5;\n    \n    vec3 cone_a1 = vec3(0.0, -0.4, 0.0);\n    vec3 cone_b1 = vec3(0.0, -0.1, 0.0);\n    float cone_ra1 = 0.0;\n    float cone_rb1 = 0.1;\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a1, cone_b1, cone_ra1, cone_rb1), 0.1);\n    \n    vec3 cone_a2 = vec3(0.0, 0.1, 0.0);\n    vec3 cone_b2 = vec3(0.0, 0.4, 0.0);\n    float cone_ra2 = 0.1;\n    float cone_rb2 = 0.0;\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a2, cone_b2, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a3 = vec3(0.1, 0.0, 0.0);\n    vec3 cone_b3 = vec3(0.4, 0.0, 0.0);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a3, cone_b3, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a4 = vec3(-0.1, 0.0, 0.0);\n    vec3 cone_b4 = vec3(-0.4, 0.0, 0.0);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a4, cone_b4, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a5 = vec3(0.0, 0.0, 0.1);\n    vec3 cone_b5 = vec3(0.0, 0.0, 0.4);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a5, cone_b5, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a6 = vec3(0.0, 0.0, -0.1);\n    vec3 cone_b6 = vec3(0.0, 0.0, -0.4);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a6, cone_b6, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a7 = vec3(-0.25, -0.25, -0.25);\n    vec3 cone_b7 = vec3(-0.05, -0.05, -0.05);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a7, cone_b7, cone_ra1, cone_rb1), 0.1);\n    \n    vec3 cone_a8 = vec3(0.05, 0.05, 0.05);\n    vec3 cone_b8 = vec3(0.25, 0.25, 0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a8, cone_b8, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a9 = vec3(0.05, -0.05, 0.05);\n    vec3 cone_b9 = vec3(0.25, -0.25, 0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a9, cone_b9, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a10 = vec3(-0.05, 0.05, -0.05);\n    vec3 cone_b10 = vec3(-0.25, 0.25, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a10, cone_b10, cone_ra2, cone_rb2), 0.1);\n   \n    vec3 cone_a11 = vec3(-0.05, -0.05, 0.05);\n    vec3 cone_b11 = vec3(-0.25, -0.25, 0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a11, cone_b11, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a12 = vec3(-0.05, 0.05, 0.05);\n    vec3 cone_b12 = vec3(-0.25, 0.25, 0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a12, cone_b12, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a13 = vec3(0.05, 0.05, -0.05);\n    vec3 cone_b13 = vec3(0.25, 0.25, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a13, cone_b13, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a14 = vec3(0.05, -0.05, -0.05);\n    vec3 cone_b14 = vec3(0.25, -0.25, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a14, cone_b14, cone_ra2, cone_rb2), 0.1);\n  \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-0.,.5,closeZ), vec3(0.0,1.2,0.), vec3(0.,4.,0.), 0.02), 0.01);\n   \n    \n    //Painting Frame\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-0.0,1.0+0.25,1.65), vec3(0.8, 0.5, 0.01)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-0.0,1.51+0.25,1.65), vec3(0.818, 0.02, 0.02)), 0.0002);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-0.0,0.49+0.25,1.65), vec3(0.818, 0.02, 0.02)), 0.0002);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-0.8,1.0+0.25,1.65), vec3(0.02, 0.484, 0.02)), 0.0002);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(0.8,1.0+0.25,1.65), vec3(0.02, 0.484, 0.02)), 0.0002);\n   \n    //Painting\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.46,1.1+0.25,1.65),0.08), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.08,1.29+0.25,1.65),0.13), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.39,0.81+0.25,1.65),0.1), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.6,0.8+0.25,1.65),0.1), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.5,0.71+0.25,1.65),0.05), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.56,0.65+0.25,1.65),0.01), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.68,0.92+0.25,1.65),0.01), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.5,1.21+0.25,1.65),0.06), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.26,0.67+0.25,1.65),0.07), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.24,0.65+0.25,1.65),0.02), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.32,0.93+0.25,1.65),0.04), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.38,0.89+0.25,1.65),0.05), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.58,1.03+0.25,1.65),0.1), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.24,1.07+0.25,1.65),0.06), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.65,1.23+0.25,1.65),0.05), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.39,1.37+0.25,1.65),0.05), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.03,0.88+0.25,1.65),0.07), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.22,0.89+0.25,1.65),0.07), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.16,0.91+0.25,1.65),0.02), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.35,1.06+0.25,1.65),0.09), 0.01);\n    \n    //Bookshelf\n    vec3 cone_a15 = vec3(0.00, 0.00, -0.05);\n    vec3 cone_b15 = vec3(0.00, 0.00, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(-1.55,0.5,1.2), cone_a15, cone_b15, 0.3, 0.3), 0.01);\n    \n    vec3 cone_a16 = vec3(0.00, 0.00, -0.05);\n    vec3 cone_b16 = vec3(0.00, 0.00, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(-1.55,0.5,-0.6), cone_a16, cone_b16, 0.3, 0.3), 0.01);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-1.36,0.5,0.2),vec3(0.10, 0.04, 0.9)), 0.01);\n    \n    \n    float rightWall = sdBox(p - vec3(-101.5, 0.0, 0.0), vec3(100.));  //right wall\n    \n    float inlay = sdBox(p - vec3(-1.55, 1.0, 0.15), vec3(0.075, 0.5, 0.8));\n    \n    float subtract = opSmoothSubtraction(inlay, rightWall, 0.01);\n    \n    float inlay2 = sdBox(p - vec3(-1.65,  1.0, 0.15), vec3(0.075, 0.4, 0.7));\n    \n    float subtract2 = opSmoothSubtraction(inlay2, subtract, 0.01);\n    \n    float inlay3 = sdBox(p - vec3(-1.75,  1.0, 0.15), vec3(0.075, 0.3, 0.6));\n    \n    float subtract3 = opSmoothSubtraction(inlay3, subtract2, 0.01);\n    \n    float inlay4 = sdBox(p - vec3(-1.85,  1.0, 0.15), vec3(0.075, 0.2, 0.5));\n    \n    float subtract4 = opSmoothSubtraction(inlay4, subtract3, 0.01);\n    \n    float inlay5 = sdBox(p - vec3(-1.95, 1.0, 0.15), vec3(0.075, 0.1, 0.4));\n   \n    float subtract5 = opSmoothSubtraction(inlay5, subtract4, 0.01);\n    \n    float inlay6 = sdSphere(p - vec3(-1.95, 1.0, 0.25), 0.1);\n    \n    float subtract6 = opSmoothSubtraction(inlay6, subtract5, 0.007);\n    \n    float inlay7 = sdSphere(p - vec3(-1.95, 1.0, 0.45), 0.1);\n    \n    float subtract7 = opSmoothSubtraction(inlay7, subtract6, 0.007);\n    \n    float inlay8 = sdSphere(p - vec3(-1.95, 1.0, -0.15), 0.1);\n    \n    float subtract8 = opSmoothSubtraction(inlay8, subtract7, 0.007);\n    \n    float inlay9 = sdSphere(p - vec3(-1.95, 1.0, 0.05), 0.1);\n    \n    float subtract9 = opSmoothSubtraction(inlay9, subtract8, 0.007);\n    \n    dist = opSmoothUnion(dist, subtract9, 0.001);\n    \n    //Names\n    \n    //A\n    float height2 = 0.25;\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.8,-0.2,0.0), vec3(0.62,0.2,0.0), 0.02), 0.03);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.44,-0.2,0.0), vec3(0.62,0.2,0.0), 0.02), 0.03);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.72,-0.03,0.0), vec3(0.52,-0.03,0.0), 0.02), 0.03);\n    \n    //B\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.34,-0.2,0.0), vec3(0.34,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.34,-0.2,0.0), vec3(0.14,-0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.34,0.2,0.0), vec3(0.14,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.34,0.,0.0), vec3(0.14,0.,0.0), 0.02), 0.02);\n   \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,-0.13,0.0), vec3(0.06,-0.07,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,0.13,0.0), vec3(0.06,0.07,0.0), 0.02), 0.02);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,-0.13,0.0), vec3(0.14,-0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,0.13,0.0), vec3(0.14,0.2,0.0), 0.02), 0.02);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,-0.07,0.0), vec3(0.14,0.0,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,0.07,0.0), vec3(0.14,0.0,0.0), 0.02), 0.02);\n    \n  \n    //C\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.08,0.1,0.0), vec3(-0.08,-0.1,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.38,-0.2,0.0), vec3(-0.18,-0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.38,0.2,0.0), vec3(-0.18,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.18,-0.2,0.0), vec3(-0.08,-0.1,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.18,0.2,0.0), vec3(-0.08,0.1,0.0), 0.02), 0.02);\n  \n    //D\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.5,-0.2,0.0), vec3(-0.5,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.82,0.1,0.0), vec3(-0.82,-0.1,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.5,-0.2,0.0), vec3(-0.72,-0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.5,0.2,0.0), vec3(-0.72,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.72,-0.2,0.0), vec3(-0.82,-0.1,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.72,0.2,0.0), vec3(-0.82,0.1,0.0), 0.02), 0.02);\n    \n    //Connectors\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.62,-0.32,0.0), vec3(-0.25,-0.32,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.62,-0.32,0.0), vec3(0.62,-0.25,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-0.25,-0.32,0.0), vec3(-0.25,-0.25,0.0), 0.02), 0.02);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.22,0.32,0.0), vec3(-0.25,0.32,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.22,0.32,0.0), vec3(0.22,0.25,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-0.25,0.32,0.0), vec3(-0.25,0.25,0.0), 0.02), 0.02);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.62,0.4,0.0), vec3(-0.62,0.4,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.62,0.4,0.0), vec3(0.62,0.25,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-0.62,0.4,0.0), vec3(-0.62,0.25,0.0), 0.02), 0.02);\n    \n    //Left tower\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.2,1.02,1.7), vec3(0.169)), 0.001);\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.07,1.335,1.54), vec3(0.145)), 0.001);\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.27,1.64,1.74), vec3(0.14)), 0.001);\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.1,1.88,1.74), vec3(0.1)), 0.001);\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.2,2.135,1.74), vec3(0.15)), 0.001);\n    \n    //right tower\n    float sphere1 = sdSphere(p-vec3(-0.95,1.1,1.57),0.32);\n    float sphere2 = sdSphere(p-vec3(-1.3,1.1,1.57),0.32);\n    float intersect1 = opSmoothIntersection(sphere1, sphere2, 0.01);\n    dist = opSmoothUnion(dist, intersect1, 0.001);\n    \n    float sphere3 = sdSphere(p-vec3(-0.95,1.562,1.57),0.27);\n    float sphere4 = sdSphere(p-vec3(-1.3,1.562,1.57),0.27);\n    float intersect2 = opSmoothIntersection(sphere3, sphere4, 0.01);\n    dist = opSmoothUnion(dist, intersect2, 0.001);\n    \n    float sphere5 = sdSphere(p-vec3(-0.95,1.91,1.57),0.23);\n    float sphere6 = sdSphere(p-vec3(-1.3,1.91,1.57),0.23);\n    float intersect3 = opSmoothIntersection(sphere5, sphere6, 0.01);\n    dist = opSmoothUnion(dist, intersect3, 0.001);\n    \n    //left wall\n    float leftwall = opSmoothUnion(dist, sdBox(p - vec3(101.5, 0.0, 0.0), vec3(100.)), 0.001);   //left wall  -- right wall is with book shelf\n    float sphere7 = sdSphere(p - vec3(2.55,1.0,0.3),1.3);\n    float box = sdBox(p - vec3(1.5,1.0,0.3),vec3(0.3));\n    \n    float intersect4 = opSmoothSubtraction(box,sphere7, 0.01);\n    float intersect5 = opSmoothSubtraction(box, leftwall, 0.01);\n    float dist2 = opSmoothUnion(intersect5, intersect4, 0.01);\n    \n    dist = opSmoothUnion(dist, dist2, 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(p - vec3(1.6,1.0,0.3),0.29), 0.01);\n    \n    return dist; \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}