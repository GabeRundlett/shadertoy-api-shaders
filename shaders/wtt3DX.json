{
    "Shader": {
        "info": {
            "date": "1577814529",
            "description": "wait for song drop,\nsry for slow compilation times d;",
            "flags": 96,
            "hasliked": 0,
            "id": "wtt3DX",
            "likes": 4,
            "name": "Day 13",
            "published": 3,
            "tags": [
                "blabla",
                "city"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 449
        },
        "renderpass": [
            {
                "code": "\n// Depth of Field pass. Code from https://www.shadertoy.com/view/Xd3GDl\n// which is an implementation of DICE's depth of field paper\n\n//#define USE_RANDOM\n\n\n#define FOCUS_FORMULA ((abs(texture(iChannel0,uv).w - FOCUS_DISTANCE)*BLUR_AMT ))\n\nconst float blurdist_px = 64.0;\n\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\nvec3 sampletex( vec2 uv )\n{\n    #ifdef SRGBLIN\n    \treturn srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n    #else\n    \treturn  texture( iChannel0, uv, -10.0 ).rgb ;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurdist = FOCUS_FORMULA;\n \n    //float srnd = hash12n(uv+fract(iTime))-0.5;\n    \n   \tvec3 sumcol0 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( 1.0, 0.577350269189626 );\n    \tvec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    \tvec2 p1 = uv + 0.5 * blurdist * blurvec;\n    \tvec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    \tvec2 p = p0;\n        p += stepvec;\n    \n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n        \tsumcol0 += sampletex(p);\n            p += stepvec;\n        }\n        sumcol0 /= float(NUM_SAMPLES);\n    }\n    \n    vec3 sumcol1 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( -1.0, 0.577350269189626 );\n        vec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n        vec2 p1 = uv + 0.5 * blurdist * blurvec;\n        vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n        vec2 p = p0;\n        p +=  stepvec;\n\n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n        \tsumcol1 += sampletex(p);\n            p += stepvec;\n        }\n        sumcol1 /= float(NUM_SAMPLES);\n    }\n\n    vec3 sumcol = min( sumcol0, sumcol1 );\n\n    #ifdef SRGBLIN\n    \tfragColor = vec4( lin2srgb( sumcol ), 1.0 );\n    #else\n    \tfragColor = vec4( sumcol , 1.0 );\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 20688,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/hudsonmohawke/system"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat zOffs;\n\n\n#define dmin(a, b) (a.x < b.x) ? a : b\n\n#define fov 0.7\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n  vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*fov + up*uv.y*fov;\n}\n\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define pi acos(-1.)\n#define tau (1.*pi)\n\n#define dmin(a, b) (a.x < b.x) ? a : b // takes 2 vec2, does a minimum of them \n#define dmax(a, b) (a.x > b.x) ? a : b\n\n#define pmod(p, x) (mod(p,x) - x*0.5)\n\n\n\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(in vec2 p) { \n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 5; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .5;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\n\nvec3 carToPol(vec3 p) { // learned this here -- https://www.shadertoy.com/view/WsSXWm\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n\n\n\n// ------- Material Properties ------- //\nvec3 albedos[2] = vec3[](\n  vec3(0.001),\n  vec3(0.4)\n);\nfloat reflectivity[2] = float[](\n  1.,\n  0.3\n);\nfloat fresPow[2] = float[](\n  20.,\n  6.\n);\n\n// ------- SDFs ------- //\n\nfloat sdBox(vec3 p, vec3 s){\n  p = abs(p) - s;\n  return max(p.x, max(p.y,p.z));\n  }\n  \n  \n  \n#define BOXH 0.7\n#define BOXW 0.5\n#define FLOORH BOXH\n#define FLOORREP 4.\n  \n  \n  \nfloat FLOORID = 0.;\nfloat FLOORID_INNER = 0.;\n  \n  \n  \n  \n// max 10\n  \nvec2 idXZ = vec2(0.);\n#define focusFloor (-20. + sin(iTime*0.04) * 20.)\n#define floorCnt  8.\nfloat distBetweenFloors = floorCnt*FLOORH;\n\nfloat r11(float i) {return fract(sin(i*3254.23)*124125.);}\n  \nvec2 sdFloor(vec3 p) {\n  vec2 d = vec2(10e5);\n  \n  //if (idXZ.y == -2. && idXZ.x == -2. ) {p.x -= 20.4;}\n  \n  ////p.x -= (idXZ.x + 1)*4.;\n  float rA = r11(FLOORID);\n  float rB = r11(FLOORID*1.3);\n  float rID = r11(idXZ.x + idXZ. y + 2.);\n  \n  float boxc = 4.;\n  \n  float segment = mod(FLOORID, 2.);\n  \n    if (iTime >84. ) {\n        for( int i = 0; i < 4; i++){\n        \tp = abs(p);\n            p.zy *= rot(-0.1 + cos(iTime*0.5)*0.1);\n            p.xy *= rot(0.5 + sin(iTime)*0.5);\n            //p.x += 0.8;\n            \n        }\n    }\n    \n    for (int i = 0; i < int(boxc) ; i ++) {\n        p = abs(p);\n        if(rA < 0.5) {\n        \tp.yz *= rot(-0.5*pi);\n            //p.x -= 0.4;\n        }\n        p.x -= BOXW;\n        //  p.z -= BOXW;\n    }\n    int offs = max(int(boxc) + 5 * int(rID*4.) - clamp(int(FLOORID + 20.), 0, 30), 0);\n    \n    if (idXZ == vec2(-1.)){\n        //offs = max(int(boxc) + 10 - clamp(int(FLOORID + 20.), 0, 30), 0);\n    \toffs = max(int(boxc) + 5 * int(rID*4.) - clamp(int(FLOORID + 20.), 0, 30) + 5, 0);\n    }\n    \n    if (offs == 0) {\n        p.xz *= rot((floor(rB*10.)/4.)*pi);\n        p.yz *= rot((floor(rB*7.)/4.)*pi);\n        p.xz *= rot((floor(rA*15.)/4.)*pi);\n        \n        p.x += rB*0.2;\n        if (rB < 0.5 ){\n        \tp.xz *= rot(0.25);\n        }\n    \n    }\n    \n    if (floor(rID*20.) > 10. && idXZ != vec2(-1.)) {\n    \treturn vec2(10e1);\n    \n    }\n    for (int i = 0; i < offs; i ++) {\n        p.xz *= rot(0.25*pi);\n        if (rA < 0.5) {\n          //p.xz *= rot(0.25*pi);\n        } else {\n          \n        }\n        //p.xz *= rot(0.25*pi);\n        p = abs(p);\n        p.z -= BOXW;\n    } \n\n  if (FLOORID_INNER == floorCnt - 1.) {\n    //p.x -= 0.6;\n    p.xy *= rot(0.4);\n    //p.x -= 0.1;\n    //p.z -= 0.1;\n    p.y += BOXH*0.52;\n    \n  }\n  \n  \n  //p.xz *= rot(0.5*pi);\n  //p.x += BOXW*boxc;\n  //p.z += 1.1;\n  p = abs(p);\n  \n  //p.x += 1.;\n  d = dmin(d, vec2(sdBox(p,vec3(BOXW*1.01, BOXH, BOXW*1.02)), 0.));\n  p = abs(p);\n  p.x -= BOXW * 0.3;\n  \n  vec3 z = p;\n  \n  if (rB < 0.5) {\n    z.xy *= rot(0.2*pi);  \n    for(int i = 0; i < 4; i++) {\n      z = abs(z);\n      z.x += 0.01;\n      z.xy *= rot(-1.*pi);    \n    }\n    \n    z.z -= 0.01;  \n    \n  }\n  \n  \n  \n  d = dmin(d, vec2(sdBox(p,vec3(BOXW, 0.01,BOXW*1.1)), 1.));\n  \n  d = dmin(d, vec2(sdBox(z,vec3(0.04, BOXH,BOXW*1.1)), 1.));\n  d.x *= 0.3;\n  return d;  \n}\nvec2 map(vec3 p) {\n  \n  float modDist = 30.;\n  p.xz -= modDist/2.;\n  idXZ = floor(p.xz/modDist);\n  p.xz = pmod(p.xz, modDist);\n  vec2 d = vec2(10e5);\n  FLOORID = floor((p.y/distBetweenFloors ));\n  FLOORID_INNER = floor(fract(p.y/distBetweenFloors)*floorCnt);\n  //FLOORID_INNER = floor((mod(p.y,distBetweenFloors))/FLOORH);\n  p.y = pmod(p.y, FLOORH);\n  \n  d = dmin(d,sdFloor(p));\n  \n  return d;\n  \n}\n\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.001, 0.);\n  return normalize(map(p).x - vec3(\n    map(p - t.xyy).x,\n    map(p - t.yxy).x,\n    map(p - t.yyx).x\n  ));\n}\n\n\n\nvec3 glow = vec3(0);\n\n#define spectra(x,t) (0.5 + 0.6*sin(vec3(0.8,0.4,0.9)*t + x)) \nfloat getBG(vec3 p, float mult) {\n    p.yz *= rot(-0.5*pi);\n    vec3 polarCoords = carToPol(p);\n    return fbm(polarCoords.yz*mult)*0.06;\n}\n\n// ------- Main ------- //\nvec4 render(vec2 uv) {\n  vec3 col = vec3 (0);\n\n  #define ZOOM 12.\n  #define ROTSPEED 0.5\n  \n  vec3 ro = vec3(0. + sin(iTime*ROTSPEED)*ZOOM,0. + distBetweenFloors*focusFloor,0. + cos(iTime*ROTSPEED)*ZOOM);\n  vec3 lookAt = vec3(0,ro.y,0);\n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  vec3 p = ro; float t = 0.;\n  \n  float FBM = 1.;\n  #define ITERS 240\n  for (int i = 0; i <= ITERS; i++) {\n    vec2 d = map(p);\n    glow += spectra(d.x - 8. + p.z - sin(iTime), 18.)*0.1;\n    if(d.x < 0.001) {\n        // learnopengl.com PBR\n      vec3 n = getNormal(p);\n      int m_id = int(d.y);\n        float metalness = reflectivity[m_id];\n        float roughness = 0.04;\n        vec3 albedo = albedos[m_id];\n        vec3 N = getNormal(p);\n        vec3 V = normalize(ro - p);\n\n        vec3 F0 = vec3(0.04); \n        F0 = mix(F0, albedo, metalness);\n\n\n        // calculate per-light radiance\n        vec3 L = normalize(vec3(1));\n        vec3 H = normalize(V + L);\n        float d    = 0.5;\n        float attenuation = 1.0 / (d * d);\n        attenuation = 1.;\n        vec3 radiance     = vec3(1) * attenuation;        \n\n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0)*0.9;       \n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metalness;\t  \n\n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = numerator / max(denominator, 0.001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        vec3 Lo = (kD * albedo / pi + specular) * radiance * NdotL;    \n\n        vec3 ambient = vec3(0.03) * albedo * 1.;          \n\n        Lo += ambient;\n        col += Lo;\n        float bg = getBG(reflect(rd, n), 1.)* (1. - reflectivity[m_id]*0.9)*0.1;\n        //col += bg*2.;\n        \n        break;\n\n        \n        /*\n      vec3 lDir = normalize(vec3(-1));\n      vec3 h = normalize(lDir - rd);\n      float diff = max(dot(lDir, n), 0.);\n      float fres = pow(max(dot(-rd, n), 0.),  fresPow[id]);\n      float spec = pow(max(dot(h, n), 0.), 5.)*0.2;\n      \n      \n      //col += mix(diff*0.4 *albedos[id], fres, reflectivity[id]);\n      col += mix(albedos[id]*diff, vec3(fres)*spec, reflectivity[id] * (1. - bg)*0.15);\n      //col += ;\n      */\n      break;\n      }\n    if(t > 80. || i == ITERS ) {\n      // -- Background -- //\n      rd.yz *= rot(-0.5*pi);\n      vec3 polarCoords = carToPol(rd);\n      \n      //col += polarCoords.y / tau;\n      \n      break;\n    }\n      \n    t += d.x;\n    p = ro + rd*t;\n  }\n  \n  col = mix(col,vec3(1.,1,1)*0.03,clamp(pow(max(t*0.016 - 0.1, 0.), 2.), 0., 1.));\n  col *= vec3(1.16,1.04,1);\n  col = pow(col, vec3(0.97,1,1));\n  col = pow(col, vec3(0.45));\n  \n  return vec4(col, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Depth of Field pass. Code from https://www.shadertoy.com/view/Xd3GDl\n// which is an implementation of DICE's depth of field paper\n\n//#define USE_RANDOM\nconst vec2 blurdir = vec2( 1.0, 1.0 );\n\nconst float blurdist_px = 64.0;\n\n\n//#define FOCUS_FORMULA (abs(texture(iChannel0,uv).w - 2.))\n#define FOCUS_FORMULA ((abs(texture(iChannel0,uv).w - FOCUS_DISTANCE)*BLUR_AMT ))\nconst float MULT = 4.0;\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvec3 sampletex( vec2 uv )\n{\n    #ifdef SRGBLIN\n    \treturn srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n    #else\n    \treturn  texture( iChannel0, uv, -10.0 ).rgb ;\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 blurdir = vec2( 0.0, 1.0 );\n    vec2 blurvec = normalize(blurdir) / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurdist = FOCUS_FORMULA;\n    \n    vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    vec2 p1 = uv + 0.5 * blurdist * blurvec;\n    vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iTime))-0.5) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n        vec3 smpl = sampletex(p);\n        sumcol += smpl;\n        p += stepvec;\n    }\n    sumcol /= float(NUM_SAMPLES);\n    sumcol = max( sumcol, 0.0 );\n    \n    \n    #ifdef SRGBLIN\n    \tfragColor = vec4( lin2srgb( sumcol * MULT ), texture( iChannel0,uv).w );\n    #else\n    \tfragColor = vec4( sumcol * MULT , texture( iChannel0,uv).w );\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\n#define NUM_SAMPLES 50\n#define BLUR_AMT (0.1)\n#define FOCUS_DISTANCE (9.)\n\n\n#define PI acos(-1.)\n\n#define SRGBLIN\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}