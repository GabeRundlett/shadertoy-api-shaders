{
    "Shader": {
        "info": {
            "date": "1669229739",
            "description": "Watercolor effect",
            "flags": 0,
            "hasliked": 0,
            "id": "ddsSRj",
            "likes": 5,
            "name": "Watercolor Effect",
            "published": 3,
            "tags": [
                "watercolor"
            ],
            "usePreview": 1,
            "username": "Peace",
            "viewed": 561
        },
        "renderpass": [
            {
                "code": "// Turns color to water color\nvec3 getWaterColor(vec3 color) {\n    // Makes so each channel of the color has definition of \"bands\" (instead of normal color definition of 256)  \n    const float bands = 6.0;\n    vec3 col = round(color * bands) / bands;\n    // \"length(col)\" make brightness of \"color\" limited, since \"col\" has limited definition and we are grabbing brightness from that\n    // While \"normalize(color)\" get's only color, which has normal definition\n    // So multiplying length(col) with normalize(color) gives color which has low definition brightness but high definition color\n    // Making it look similar to watercolor painting\n    // Then it interpolates normal color with this constrained color to add a bit of detail\n    return mix(color, length(col) * normalize(color), 0.7);\n}\n\n// get's random number for 2D coordinate\nfloat rand(vec2 uv) {\n\treturn fract(sin(dot(vec2(12.9898,78.233), uv)) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Split's screen in 2 parts for comparision\n    if(uv.x >= 0.5) // watercolored texture color\n    {\n        // this adds some randomness to the uv, making it look grainy        \n        vec2 ruv = clamp(uv + (vec2(rand(uv), rand(uv + vec2(13.61, -21.35))) * 2.0 - 1.0) / iResolution.xy * 2., vec2(0), vec2(1));\n        // mixing between grainy and smooth texture\n        vec3 t = mix(textureLod(iChannel0, ruv, 2.0).rgb, textureLod(iChannel0, uv, 2.0).rgb, 0.5);\n        fragColor.rgb = getWaterColor(t);\n    }\n    else // normal texture color\n    {\n        fragColor.rgb = texture(iChannel0, uv).rgb;\n    }\n    \n    // middle line in split screen\n    float d = abs(uv.x - 0.5) / 0.005;\n    if(d < 1.0) \n    {\n        // Added smoothstep interpolation to make middle line look smoother\n        fragColor.rgb = mix(vec3(0), fragColor.rgb, smoothstep(0.0, 1.0, d * d));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}