{
    "Shader": {
        "info": {
            "date": "1605867891",
            "description": "Contrast many-few",
            "flags": 32,
            "hasliked": 0,
            "id": "wdcfDS",
            "likes": 0,
            "name": "Contrast many-few",
            "published": 3,
            "tags": [
                "life",
                "cellular"
            ],
            "usePreview": 0,
            "username": "illus0r",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n    vec3 px=vec3(1./iResolution.xy,0);\n    vec4 col;\n    for(float i=0.;i<8.;i++){\n        for(float j=0.;j<8.;j++){\n            vec2 ij = vec2(i,j);\n\t\t    col = max(col,texture(iChannel0,(FC+ij)/iResolution.xy));\n        }\n    }\n    uv=(FC*2.-iResolution.xy)/iResolution.y;\n    fragColor = col;\n    if(1.3>length(uv-vec2(.5)))fragColor = vec4(.2*length(uv-vec2(.5)));\n    //fragColor = texture(iChannel0,(floor(FC/1.))/iResolution.xy)*2.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R 1.\n\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\nВ каждом пикселе может быть одна или несколько клеток. Они могут:\n- отталкиваться,\n- притягиваться,\n- делиться,\n\nкогда получится растущая клякса, можно сделать мутации:\nпри делении клетка может поменять цвет на рандомный и \nеё потомки его сохранят.\n\nКлетки описаны в пикселях текстуры.\n- Как несколько клеток могут находиться в одном пикселе?\n- Как хранятся координаты? Скорость не надо хранить, вроде.\n- Как клетка попадает в соседнюю? Надо перечитать статью котика.\n\nАлгоритм:\n- кто остаётся\n- кто уходит\n- кто приходит\n\nХочется в rgba держать координаты 10 клеток сразу. \nДля простоты пока будем только rg юзать. Чтобы влезало много, \nможно первые позиции использовать для разряда. \nУсловно:\n2,147,483,647\nДве клетки с координатами .2147, .4836\nКоординаты-то меняются от 0 до 1.\nНо в МВП можно и одну клетку сделать. Пусть внимательнее смотрит вокруг и избегает столкновений.\nСперва пусть они отталкиваются только.\n\nНу, поехали.\n\n*/\n\nfloat rnd(float x) {return fract(54321.987 * sin(987.12345 * x))*2.-1.;}\n\n//vec4 decodePV(){\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec3 px = vec3(1./iResolution.xy,.0);\n    vec2 p;\n    vec2 v;\n    \n    // начальные положения клеток\n    if(mod(float(iFrame),500.)==0.){\n        fragColor=vec4(0.);// `p` of 0. means empty cell\n        if(mod(FC.x+.5,16.)==0. && mod(FC.y+.5,16.)==0.){\n            fragColor=vec4(.5,.5,.5+rnd(uv.x),.5+rnd(uv.y));//.5 to place to the center\n        }\n        return;\n    }\n    \n    // if noone enters the pixel remain empty\n    fragColor.rgba = vec4(0.);\n    \n    // добавить тех, кто прилетит в пиксель\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue;\n            //fragColor.rgba = vec4(i,j,0.,1.); return;\n            vec4 neighbour=texture(iChannel0,uv_n);\n            \n            if(length(neighbour)==0.)continue;\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            \n            // if empty, continue\n            \n            if(length(v)>1.) v = normalize(v);\n            // только одна клетка может быть в пикселе.\n            // Так что как только найдена попаадющая сюда клетка,\n            // выходим из цикла\n            p+=v;\n            if(p.x<1. && p.y<1. && p.x>=0. && p.y>=0.){\n                fragColor.rg = p;\n                fragColor.ba = v*.5+.5;\n                //break;\n            }\n        }\n    }\n    \n    // удалить тех, кто улетит из пикселя\n    \n    // найти силу воздействия соседей\n\n    // перерасчитать скорость\n    \n    //fragColor = vec4(p,v*.5+.5);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}