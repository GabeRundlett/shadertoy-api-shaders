{
    "Shader": {
        "info": {
            "date": "1690816333",
            "description": "animation n2",
            "flags": 0,
            "hasliked": 0,
            "id": "mlfcW7",
            "likes": 19,
            "name": "animation n2",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "animation",
                "draw"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "///---jorge2017a2\n//31-jul-2023-\n//animation n2\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(7.0*antialiasing(1.0),b,d)\n#define PI 3.141516\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n\nvec3 lineah(vec2 p, float posy, vec3 colOut)\n{\nfloat s1;\ns1=p.x+0.001;\nfloat d1=abs(p.y-posy);\nvec3 col= DrawFigBorde(vec3(0.0,1.0,0.0), colOut, d1);\nreturn col;\n}\n\nvec3 lineav(vec2 p, float posx, vec3 colOut)\n{\nfloat s1;\ns1=p.y+0.001;\nfloat d1=abs(p.x-posx);\nvec3 col= DrawFigBorde(vec3(0.0), colOut, d1);\nreturn col;\n}\n\n\nfloat N21(vec2 p)\n{ return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);}\n\n\n\nvec3 OrejaBz(vec2 p, vec3 col)\n{\nvec2 pc1p1=vec2(9.430,2.810);\nvec2 pc1p2=vec2(9.480,3.110);\nvec2 pc1p3=vec2(9.600,2.920);    \n\nvec2 pc2p1=vec2(9.820,2.820);\nvec2 pc2p2=vec2(9.870,3.000);\nvec2 pc2p3=vec2(9.990,2.910);\n\nfloat b1= sdBezier(p, pc1p1,pc1p2,pc1p3);\nfloat b2= sdBezier(p, pc2p1,pc2p2,pc2p3);\n\ncol= DrawFigBorde(vec3(0.0),col,b1);\ncol= DrawFigBorde(vec3(0.0),col,b2);\n\nreturn col;\n}\n\n\nvec3 cerBz(vec2 p, vec3 col)\n{\nvec2 pc3p1=vec2(9.440,2.450);\nvec2 pc3p2=vec2(9.490,2.550);\nvec2 pc3p3=vec2(9.650,2.450);\n\nvec2 pc4p1=vec2(9.920,2.470);\nvec2 pc4p2=vec2(9.940,2.550);\nvec2 pc4p3=vec2(10.000,2.590);\n\nvec2 pc5p1=vec2(9.760,2.180);\nvec2 pc5p2=vec2(9.890,2.240);\nvec2 pc5p3=vec2(10.110,2.270);\n\nvec2 pc6p1=vec2(9.410,1.660);\nvec2 pc6p2=vec2(9.600,1.900);\nvec2 pc6p3=vec2(9.460,2.060);\n\nvec2 pc7p1=vec2(10.090,1.770);\nvec2 pc7p2=vec2(9.670,1.930);\nvec2 pc7p3=vec2(9.440,1.730);\n\nfloat d3= sdBezier(p,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(p,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(p,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(p,pc6p1,pc6p2,pc6p3);\nfloat d7= sdBezier(p,pc7p1,pc7p2,pc7p3);\n\ncol= DrawFigBorde(vec3(0.0),col,d3);\ncol= DrawFigBorde(vec3(0.0),col,d4);\ncol= DrawFigBorde(vec3(0.0),col,d5);\ncol= DrawFigBorde(vec3(0.0),col,d6);\ncol= DrawFigBorde(vec3(0.0),col,d7);\nreturn col;\n}\n\n\nvec3 patasCer00(vec2 p, vec3 col)\n{\nvec2 pc8p1=vec2(8.980,1.450);\nvec2 pc8p2=vec2(8.970,1.250);\nvec2 pc8p3=vec2(9.010,1.110);\n\nvec2 pc9p1=vec2(8.190,1.530);\nvec2 pc9p2=vec2(8.190,1.440);\nvec2 pc9p3=vec2(8.160,1.410);\n\nvec2 pc10p1=vec2(7.950,1.620);\nvec2 pc10p2=vec2(7.770,1.410);\nvec2 pc10p3=vec2(7.790,1.250);\n\nvec2 pc11p1=vec2(9.250,1.550);\nvec2 pc11p2=vec2(9.310,1.420);\nvec2 pc11p3=vec2(9.280,1.320);\n\n\nfloat d8= sdBezier(p,pc8p1,pc8p2,pc8p3);\nfloat d9= sdBezier(p,pc9p1,pc9p2,pc9p3);\nfloat d10=sdBezier(p,pc10p1,pc10p2,pc10p3);\nfloat d11=sdBezier(p,pc11p1,pc11p2,pc11p3);\n\ncol= DrawFigBorde(vec3(0.0),col,d8);\ncol= DrawFigBorde(vec3(0.0),col,d9);\ncol= DrawFigBorde(vec3(0.0),col,d10);\ncol= DrawFigBorde(vec3(0.0),col,d11);\n\n\nreturn col;\n}\n\nvec3 cerdito(vec2 p, vec3 col)\n{\nvec2 p1=vec2(8.53,2.21);\nvec2 med1=vec2(0.95,0.75);\nfloat d1=sdEllipse(p-p1,med1);\n\n\nvec2 p2=vec2(8.53,2.18);\nvec2 med2=vec2(1,0.75);\n\nfloat ang = 5.0 * PI / 180.0;\n\nvec2 pr = Rotate(p-p2, med2, ang);\nfloat d2  = sdEllipse(pr, med2);\n\nfloat dfin=min(d1,d2);\n\n\nvec2 p3=vec2(9.55,2.22);\nvec2 med3=vec2(0.55,0.59);\nfloat d3=sdEllipse(p-p3,med3);\n\nvec2 p4=vec2(9.83,2.24);\nvec2 med4=vec2(0.3,0.54);\nfloat d4=sdEllipse(p-p4,med4);\nd3=min(d3,d4);\n\nvec2 p5=vec2(9.68,2.21);\nvec2 med5=vec2(0.45,0.59);\nfloat d5=sdEllipse(p-p5,med5);\nd3=min(d3,d5);\n\nvec2 p6=vec2(10.2,2.01);\nvec2 med6=vec2(0.26,0.25);\nfloat d6=sdEllipse(p-p6,med6);\n\nvec2 p7=vec2(9.97,2.32);\nvec2 med7=vec2(0.06,0.08);\nfloat d7=sdEllipse(p-p7,med7);\n\n\nvec2 p8=vec2(9.63,2.23);\nvec2 med8=vec2(0.06,0.08);\nfloat d8=sdEllipse(p-p8,med8);\n\nvec2 p9=vec2(10.08,1.99);\nvec2 med9=vec2(0.02,0.07);\n//rotar\nang = 10.0 * PI / 180.;\npr = Rotate(p-p9, med9, ang);\nfloat d9  = sdEllipse(pr, med9);\n\nvec2 p10=vec2(10.34,2.03);\nvec2 med10=vec2(0.02,0.07);\nfloat d10=sdEllipse(p-p10,med10);\n ang = -10.0 * PI / 180.0;\n pr = Rotate(p-p10, med10, ang);\nd10  = sdEllipse(pr, med10);\n\n\nvec2 p11=vec2(9.64,2.06);\nvec2 med11=vec2(0.02,0.07);\nang = 10. * PI / 180.0;\nvec2 med=vec2(0.02, 0.07);\npr = Rotate(p-p11, med11, ang);\nfloat d11  = sdEllipse(pr, med);\n\n\n//pies\nvec2 p12=vec2(9.06,1);\nvec2 med12=vec2(0.22,0.07);\nfloat d12=sdEllipse(p-p12,med12);\n\n\nvec2 p13=vec2(9.39,1.23);\nvec2 med13=vec2(0.25,0.07);\nfloat d13=sdEllipse(p-p13,med13);\n\n\nvec2 p14=vec2(8.14,1.33);\nvec2 med14=vec2(0.25,0.07);\nfloat d14=sdEllipse(p-p14,med14);\n\nvec2 p15=vec2(7.75,1.14);\nvec2 med15=vec2(0.25,0.07);\nfloat d15=sdEllipse(p-p15,med15);\n\n    col= DrawFigBorde(vec3(1.0), col, dfin);\n    col= DrawFigBorde(vec3(1.0), col, d3);\n    col= DrawFigBorde(vec3(1.0), col, d6);\n    col= DrawFigBorde(vec3(0.0), col, d7);\n    col= DrawFigBorde(vec3(0.0), col, d8);\n    col= DrawFigBorde(vec3(0.0), col, d9);\n    col= DrawFigBorde(vec3(0.0), col, d10);\n    col= DrawFigBorde(vec3(0.0), col, d11);\n    col= DrawFigBorde(vec3(1.0), col, d12);\n    col= DrawFigBorde(vec3(1.0), col, d13);\n    col= DrawFigBorde(vec3(1.0), col, d14);\n    col= DrawFigBorde(vec3(1.0), col, d15);\n    col= OrejaBz(p,col);\n    col=cerBz(p,col);\n    col=patasCer00(p,col);\n    return col;\n}\n\n\nvec3 vallasInc(vec2 p, vec3 col)\n{\nvec2 pos=vec2(3.03,2.89);\nvec2 med=vec2(0.12,0.855);\nfloat d7= sdBox(p-pos, med );\n\nfloat ang = -45.0 * PI / 180.0;\nvec2 pr =Rotate(p- pos, med/2.0, ang);\n\nd7 = sdBox(pr, med);\n\n//poste centro\n pos=vec2(3.82,1.62);\n med=vec2(0.25,0.925);\nfloat d1= sdBox(p-pos, med );\n//elipse centro\nvec2 p2=vec2(3.8,2.61);\nvec2 med2=vec2(0.27,0.11);\nfloat d2=sdEllipse(p-p2,med2);\n\nd7=differenceSDF(d7,d1);\nd7=differenceSDF(d7,d2);\n\n pos=vec2(3.06,1.74);\n med=vec2(0.12,0.855);\nfloat d8= sdBox(p-pos, med );\nang = -45.0 * PI / 180.0;\npr = Rotate(p- pos, med/ 2.0, ang);\nd8 = sdBox(pr, med);\n\nd8=differenceSDF(d8,d1);\n\n//poste 1\n pos=vec2(5.9,-0.17);\n med=vec2(0.345,1.03);\nfloat d5= sdBox(p-pos, med );\n//elipse poste 1\nvec2 p6=vec2(5.86,0.95);\nvec2 med6=vec2(0.44,0.11);\nfloat d6=sdEllipse(p-p6,med6);\n\npos=vec2(4.39,1.37);\nmed=vec2(0.12,1.18);\nfloat d9= sdBox(p-pos, med );\nang = -45.0 * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\n\nd9 = sdBox(pr, med);\nd9=differenceSDF(d9,d5);\nd9=differenceSDF(d9,d6);\n\npos=vec2(4.4,0.19);\nmed=vec2(0.12,1.18);\nfloat d10= sdBox(p-pos, med );\nang = -45.0 * PI / 180.0;\npr = Rotate(p-pos, med/ 2.0, ang);\n\nd10 = sdBox(pr, med);\nd10=differenceSDF(d10,d5);\ncol = DrawFigBorde(vec3(0.75),col,d7);\ncol = DrawFigBorde(vec3(0.75),col,d8);\ncol = DrawFigBorde(vec3(0.67),col,d9);\ncol = DrawFigBorde(vec3(0.67), col, d10);\n    return col;\n}\n\nvec3 vallas(vec2 p, vec3 col)\n{    \nvec2 pos=vec2(3.82,1.62);\nvec2 med=vec2(0.25,0.925);\nfloat d1= sdBox(p-pos, med );\n\n\nvec2 p2=vec2(3.8,2.61);\nvec2 med2=vec2(0.27,0.11);\nfloat d2=sdEllipse(p-p2,med2);\n\nvec2 p3=vec2(2.63,3.99);\nvec2 med3=vec2(0.27,0.11);\nfloat d3=sdEllipse(p-p3,med3);\n\npos=vec2(2.70,2.86);\nmed=vec2(0.25,1.03);\nfloat d4= sdBox(p-pos, med );\n\n\npos=vec2(5.9,-0.17);\nmed=vec2(0.345,1.03);\nfloat d5= sdBox(p-pos, med );\n\nvec2 p6=vec2(5.86,0.95);\nvec2 med6=vec2(0.44,0.11);\nfloat d6=sdEllipse(p-p6,med6);\n\ncol= DrawFigBorde(vec3(0.70),col,d1);\ncol= DrawFigBorde(vec3(0.45),col,d2);\ncol= DrawFigBorde(vec3(0.45),col,d3);\ncol= DrawFigBorde(vec3(0.75),col,d4);\ncol= DrawFigBorde(vec3(0.75),col,d5);\ncol= DrawFigBorde(vec3(0.45),col,d6);\nreturn col;\n}\n\nvec3 cerBz02(vec2 p, vec3 col)\n{\nvec2 pc1p1=vec2(8.240,2.220);\nvec2 pc1p2=vec2(8.490,2.040);\nvec2 pc1p3=vec2(8.620,2.150);\n\nvec2 pc2p1=vec2(8.340,3.070);\nvec2 pc2p2=vec2(8.640,3.050);\nvec2 pc2p3=vec2(8.650,2.830);\n\nvec2 pc3p1=vec2(10.000,2.940);\nvec2 pc3p2=vec2(9.960,3.130);\nvec2 pc3p3=vec2(10.150,3.220);\n\nvec2 pc4p1=vec2(10.290,2.980);\nvec2 pc4p2=vec2(10.300,3.150);\nvec2 pc4p3=vec2(10.520,3.210);\n\nvec2 pc5p1=vec2(10.130,2.540);\nvec2 pc5p2=vec2(10.040,2.810);\nvec2 pc5p3=vec2(10.260,2.690);\n\nvec2 pc6p1=vec2(10.510,2.680);\nvec2 pc6p2=vec2(10.460,2.830);\nvec2 pc6p3=vec2(10.550,2.840);\n\nvec2 pc7p1=vec2(10.320,2.240);\nvec2 pc7p2=vec2(10.510,2.400);\nvec2 pc7p3=vec2(10.650,2.380);\n\nvec2 pc8p1=vec2(10.370,1.930);\nvec2 pc8p2=vec2(10.610,1.800);\nvec2 pc8p3=vec2(10.800,1.940);\n\nvec2 pc9p1=vec2(10.290,1.740);\nvec2 pc9p2=vec2(10.360,1.620);\nvec2 pc9p3=vec2(10.260,1.450);\n\nvec2 pc10p1=vec2(9.820,1.310);\nvec2 pc10p2=vec2(9.980,1.510);\nvec2 pc10p3=vec2(9.840,1.640);\nfloat d1= sdBezier(p,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(p,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(p,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(p,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(p,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(p,pc6p1,pc6p2,pc6p3);\nfloat d7= sdBezier(p,pc7p1,pc7p2,pc7p3);\nfloat d8= sdBezier(p,pc8p1,pc8p2,pc8p3);\nfloat d9= sdBezier(p,pc9p1,pc9p2,pc9p3);\nfloat d10= sdBezier(p,pc10p1,pc10p2,pc10p3);\ncol=DrawFigBorde(vec3(0.0),col,d1);\ncol=DrawFigBorde(vec3(0.0),col,d2);\ncol=DrawFigBorde(vec3(0.0),col,d3);\ncol=DrawFigBorde(vec3(0.0),col,d4);\ncol=DrawFigBorde(vec3(0.0),col,d5);\ncol=DrawFigBorde(vec3(0.0),col,d6);\ncol=DrawFigBorde(vec3(0.0),col,d7);\ncol=DrawFigBorde(vec3(0.0),col,d8);\ncol=DrawFigBorde(vec3(0.0),col,d9);\ncol=DrawFigBorde(vec3(0.0),col,d10);\n    return col;\n}\n\n\nvec3 cerdito02(vec2 p, vec3 col)\n{\nfloat ang;\nvec2 pr;\n\nvec2 pos=vec2(9.38,2.35);\nvec2 med=vec2(0.85,0.75);\nfloat d1=sdEllipse(p-pos,med);\n\n pos=vec2(9.54,2.32);\n med=vec2(0.85,0.75);\nfloat d2=sdEllipse(p-pos,med);\nd2=min(d1,d2);\ncol = DrawFigBorde(vec3(1.0), col, d2);\n\n\n pos=vec2(10.2,2.34);\n med=vec2(0.55,0.64);\nfloat d3=sdEllipse(p-pos,med);\n\n//cabeza\npos=vec2(10.6,2.1);\nmed=vec2(0.35,0.25);\nfloat d4=sdEllipse(p-pos,med);\nd4=min(d4,d3);\ncol = DrawFigBorde(vec3(1.0), col, d4);\n\n\n//nariz\npos=vec2(10.85,2.19);\nmed=vec2(0.23,0.24);\nfloat d5=sdEllipse(p-pos,med);\ncol = DrawFigBorde(vec3(1.0), col, d5);\n\n//ojo\npos=vec2(10.29,2.42);\nmed=vec2(0.06,0.08);\nfloat d6=sdEllipse(p-pos,med);\ncol = DrawFigBorde(vec3(0.0), col, d6);\n\n//ojo\npos=vec2(10.6,2.52);\nmed=vec2(0.06,0.08);\nfloat d7=sdEllipse(p-pos,med);\ncol = DrawFigBorde(vec3(0.0), col, d7);\n\npos=vec2(9.81,1.318);\nmed=vec2(0.25,0.08);\nang = -30.0 * PI/180.0;\npr = Rotate(p-pos, med, ang);\nfloat d9  = sdEllipse(pr, med);\ncol = DrawFigBorde(vec3(1.0), col, d9);\n\n\npos=vec2(10.38,1.649);\nmed=vec2(0.28,0.08);\n ang = -30.0 * PI / 180.0;\n pr = Rotate(p-pos, med, ang);\nfloat d10  = sdEllipse(pr, med);\ncol = DrawFigBorde(vec3(1.0), col, d10);\n\n\n//pie atras\npos=vec2(7.94,2.21);\nmed=vec2(0.28,0.08);\n ang = -30.0 * PI / 180.0;\n pr = Rotate(p-pos, med, ang);\nfloat d11  = sdEllipse(pr, med);\ncol = DrawFigBorde(vec3(1.0), col, d11);\n\n//pie atras 2\npos=vec2(8.52,2.03);\nmed=vec2(0.28,0.08);\n ang = -30. * PI / 180.;\n pr = Rotate(p-pos, med, ang);\nfloat d12  = sdEllipse(pr, med);\nd12=differenceSDF(d12,d1);\ncol = DrawFigBorde(vec3(1.0), col, d12);\n\ncol= cerBz02(p,col);\n\nreturn col;\n}\n\n\nvec3 escena(vec2 p, vec3 col,vec2 p2)\n{  \n    \n   float d1=abs(p.x-4.0+p.y);\nfloat d2=abs(p.x-12.0+p.y);\n col= DrawFigBorde(vec3(0.0), col, d1);\n col= DrawFigBorde(vec3(0.0), col, d2);\n\n\n   float tt=fract(iTime*1.0);\n   if(tt<0.5)\n       col=cerdito(p,col);\n   else\n       col=cerdito02(p,col);\n       \n   col= vallas(p,col);\n   col= vallasInc(p,col);\n   \n\n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 uv2=uv*5.0;\n    uv-=vec2(-1.5,-0.5);\n    uv*=4.0;\n    \n    vec3 col=vec3(0.5);\n    col=escena(uv,col,uv2);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n\n\n//Quadratic Bezier - exact   (https://www.shadertoy.com/view/MlKcDD)\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}