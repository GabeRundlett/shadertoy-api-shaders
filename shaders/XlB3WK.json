{
    "Shader": {
        "info": {
            "date": "1432282745",
            "description": "Testing some raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "XlB3WK",
            "likes": 6,
            "name": "BasicRaymarchingPrimitives",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "zlnimda",
            "viewed": 562
        },
        "renderpass": [
            {
                "code": "/* ----------------------------------------------------------------------------\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * Nimda@zl wrote this file.  As long as you retain this notice you\n * can do whatever you want with this stuff. If we meet some day, and you think\n * this stuff is worth it, you can buy me a beer in return.\n * ----------------------------------------------------------------------------\n */\n\nfloat stopDelta = 60.0;\n\nfloat distBubblePlane(vec3 pos)\n{ // plane at y = 0\n    return pos.y + sin(pos.x * 3.0) * sin(pos.z * 3.0) * 0.2 *  sin(iTime);\n}\n\nfloat distSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat distBox(vec3 pos, vec3 scale)\n{\n    return length(max(abs(pos) - scale, vec3(0.0)));\n}\n\nfloat distTorus(vec3 pos, vec2 radius)\n{\n    return length(vec2(pos.x, abs(length(pos.yz) - radius.x))) - radius.y;\n}\n\nfloat distCylinder(vec3 pos, vec2 size)\n{\n    vec2 vDist = vec2(length(pos.xz) - size.y, abs(pos.y) - size.x);\n    return length(max(vDist, 0.0)) + min(max(vDist.x, vDist.y), 0.0);\n}\n\nfloat ComputeDist(vec3 pos)\n{\n    float dist = min(distBubblePlane(pos),\n                     distSphere(pos - vec3(1.0, 1.0, 0.0), 0.5));\n    dist = min(dist, distBox(pos - vec3(-1.0, 1.0, 0.0), vec3(0.5)));\n    dist = min(dist, distTorus(pos - vec3(0.0, 1.0, 1.5), vec2(0.5, 0.25)));\n    dist = min(dist, distCylinder(pos - vec3(0.0, 1.0, -1.5), vec2(0.5, 0.25)));\n    return dist;\n}\n\nfloat DistToObjects(vec3 camPos, vec3 rayDir)\n{\n    float startDelta = 1.0;\n    float delta = startDelta;\n    float maxDist = 0.002;\n    \n    for (int it = 0; it < 80; ++it)\n    {\n        float dist = ComputeDist(camPos + rayDir * delta);\n        if (dist <= maxDist || delta > stopDelta) break;\n        delta += dist;\n    }\n    return delta;\n}\n\nvec3 getNormalAtPoint(vec3 pos)\n{\n    float delta = 0.001;\n    vec2 unit = vec2(1.0, 0.0);\n    return normalize(vec3(ComputeDist(pos + unit.xyy * delta) - ComputeDist(pos - unit.xyy * delta),\n                          ComputeDist(pos + unit.yxy * delta) - ComputeDist(pos - unit.yxy * delta),\n                          ComputeDist(pos + unit.yyx * delta) - ComputeDist(pos - unit.yyx * delta)));\n}\n\n// basic raymarch\nvec3 render(vec3 camPos, vec3 rayDir)\n{\n    vec3 color = vec3(0.6, 0.6, 1.0);\n    \n    float dist = DistToObjects(camPos, rayDir);\n    if (dist < stopDelta)\n    {\n        vec3 normal = getNormalAtPoint(camPos + rayDir * dist);\n        vec3 directLight = normalize(vec3(-2.0, 5.0, -1.0));\n        float diffuse = clamp(dot(normal, directLight), 0.0, 1.0);\n        color = color * diffuse;\n    }\n    color /= max(dist*0.25, 1.0);\n    return color;\n}\n\n// Camera Matrix\nmat3 GetCameraMatrix(vec3 camFow)\n{\n    vec3 camUp = vec3(0.0, 1.0, 0.0); // world up is cam up\n    \n    vec3 camRight = normalize(cross(camFow, camUp));\n    \n    return mat3(camRight, camUp, camFow);\n}\n\n// Main entry\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixel = uv * 2.0 - 1.0;\n    float viewRatio = iResolution.x/iResolution.y;\n    pixel.x *= viewRatio;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float time = iTime * 0.5;\n    \n    float deltaRot = mouse.x * 3.14 * 2.0 + time;\n    \n    vec3 camPos = vec3(-5.0 * cos(deltaRot), 1.0, -5.0 * sin(deltaRot));\n    vec3 camFow = vec3(1.0 * cos(deltaRot), 0.0, 1.0 * sin(deltaRot));\n    \n    mat3 camMat = GetCameraMatrix(camFow);\n    \n    vec3 rayDir = camMat * normalize(vec3(pixel.xy, viewRatio*1.8));\n    \n    vec3 color = render(camPos, rayDir);\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}