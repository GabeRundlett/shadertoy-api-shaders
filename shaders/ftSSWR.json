{
    "Shader": {
        "info": {
            "date": "1627381375",
            "description": "Accessing the archives...",
            "flags": 0,
            "hasliked": 0,
            "id": "ftSSWR",
            "likes": 12,
            "name": "Data Storage",
            "published": 3,
            "tags": [
                "robot",
                "kinematics",
                "mechanism"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "// \"Data Storage\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2f (float p);\n\nvec3 qHit,ltPos, cPos;\nvec2 gCur, gSize, cDel, angC;\nfloat dstFar, tCur, tCyc, tPhs, hCyc, bWid, zPos;\nint idObj;\nbool isSh;\nconst int idCyl = 1, idTel = 2, idRail = 3, idFrame = 4, idBase = 5, idWal = 6, idSup = 7, idLamp = 8,\n   idCylP = 9;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, ts, zFrm;\n  dMin = dstFar;\n  zFrm = 3. * 0.9 + 0.96;\n  zPos = 0.;\n  for (float k = float (VAR_ZERO); k <= 3.; k ++) {\n    q = p;\n    q.xy -= vec2 (0.5 * (gCur.x + cDel.x), cDel.y);\n    if (k > 0.) zPos += 0.1 + 0.9 * SmoothBump (0.3 + 0.03 * k, 0.7 - 0.03 * k, 0.03, tPhs);\n    q.xz = Rot2D (q.xz, angC.x);\n    q.yz = Rot2D (q.yz, angC.y);\n    q.z -= 0.9 * zPos;\n    d = PrRoundCylDf (q, 0.2 - 0.03 * k, 0.02, 0.5);\n    DMINQ (idTel);\n  }\n  ts = abs (tPhs - 0.5) - 0.42;\n  if (hCyc == 0. || ts < 0.) cPos.xy = vec2 (0.5 * gCur.x, (hCyc == 0.) ? 0.5 * gCur.y : cDel.y);\n  else cPos.xy = vec2 (0.5 * gCur.x + 2. * bWid * smoothstep (0., 0.08, ts) * sign (tPhs - 0.5),\n     -0.25 * gSize.y - 2. + 0.5);\n  q = p;\n  if (hCyc == 0. || ts < 0.) {\n    q.xy -= cPos.xy;\n    if (hCyc != 0.) {\n      q.xz = Rot2D (q.xz, angC.x);\n      q.yz = Rot2D (q.yz, angC.y);\n      q.z -= 0.9 * (zPos - 3.);\n    }\n    q.z -= zFrm;\n    d = PrRoundCylDf (q, 0.15, 0.02, 0.41);\n  } else {\n    d = bWid - abs (q.x);\n    q.xy -= cPos.xy;\n    q = q.xzy;\n    d = max (PrRoundCylDf (q, 0.15, 0.02, 0.4), - d);\n  }\n  DMINQ (idCylP);\n  q = p;\n  d = max (PrBox2Df (q.xy, 0.25 * gSize), - PrBox2Df (q.xy - 0.5 * gCur, vec2 (0.25)));\n  q.xy = mod (q.xy + 0.25, 0.5) - 0.25;\n  q.z -= zFrm;\n  d = max (d, PrRoundCylDf (q, 0.15, 0.02, 0.4));\n  DMINQ (idCyl);\n  q = p;\n  q.x -= 0.5 * (gCur.x + cDel.x);\n  q.y -= cDel.y;\n  q.xz = Rot2D (q.xz, angC.x);\n  d = PrRoundCylDf (q.yzx, 0.03, 0.02, 0.45);\n  DMINQ (idRail);\n  q = p;\n  q.x -= 0.5 * (gCur.x + cDel.x);\n  q.xz = Rot2D (q.xz, angC.x);\n  q.y -= 0.25 * gSize.y + 0.5;\n  d = min (PrCylDf (vec3 (q.xz, q.y - 0.65), 0.12, 0.9), PrCapsDf (vec3 (q.xz, abs (q.y + 0.05) - 0.2).yzx,\n     0.12, 0.4));\n  q.x = abs (q.x) - 0.4;\n  q.y -= -0.25 * gSize.y - 0.5;\n  d = min (d, SmoothMax (PrCapsDf (q.xzy, 0.12, 0.25 * gSize.y + 0.65),\n     - PrRoundBoxDf (q - vec3 (-0.08, -0.2, 0.), vec3 (0.08, 0.25 * gSize.y + 0.2, 0.04), 0.01), 0.02));\n  DMINQ (idRail);\n  q = p;\n  q.z = abs (q.z - zFrm) - 0.3;\n  d = max (PrRoundBoxDf (q, vec3 (0.25 * gSize + 0.25, 0.05) - 0.05, 0.05),\n     - max (PrBox2Df (q.xy, vec2 (0.25 * gSize)), length (mod (q.xy + 0.25, 0.5) - 0.25) - 0.17));\n  DMINQ (idFrame);\n  q = p;\n  q.xy = abs (q.xy);\n  q -= vec3 (0.25 * gSize.xy + vec2 (0.1, 1.1), zFrm);\n  d = PrRoundCylDf (q.xzy, 0.4, 0.02, 0.9);\n  DMINQ (idSup);\n  if (! isSh) {\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (bWid, -0.25 * gSize.y - 0.98, 2.);\n    d = max (PrRoundBoxDf (q, vec3 (0.25, 1.2, 5.) - 0.02, 0.02), - SmoothMax (q.x - 0.1,\n       PrBox2Df (q.yz - vec2 (-0.4, -2.), vec2 (0.6, 0.3)), 0.02));\n    DMINQ (idWal);\n    q = p;\n    q.y = abs (q.y);\n    q.yz -= vec2 (0.25 * gSize.y + 2.08, 2.);\n    d = PrRoundBoxDf (q, vec3 (bWid + 0.25, 0.1, 5.) - 0.02, 0.02);\n    DMINQ (idBase);\n    q = p - ltPos;\n    d = PrCapsDf (q.yzx, 0.16, 0.3);\n    DMINQ (idLamp);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 ObjCol (vec3 ro)\n{\n  vec4 col4;\n  float s;\n  if (idObj == idCyl || idObj == idCylP) {\n    col4 = vec4 (0.2, 0.7, 1., 0.2) * (1. - 0.3 * smoothstep (0., 0.02, abs (abs (qHit.z) - 0.2)) - 0.1) *\n       (0.6 + 0.4 * smoothstep (0., 0.02, length (qHit.xy) - 0.05));\n    if (abs (qHit.z) < 0.2) col4 *= (1. + 0.3 * smoothstep (0.4, 0.5, sin (16. * atan (qHit.y, - qHit.x))));\n    if (idObj == idCylP && hCyc != 0. && zPos < 2.99 && abs (qHit.z) > 0.3)\n       col4 = mix (col4, vec4 (1., 0., 0., -1.), step (0.5, mod (4. * tCur, 1.)));\n  } else if (idObj == idTel) {\n    col4 = vec4 (0.8, 0.85, 0.8, 0.2) *\n       (1. - 0.2 * smoothstep (0., 0.05, abs (qHit.z) - 0.4));\n  } else if (idObj == idRail) {\n    col4 = vec4 (0.85, 0.85, 0.9, 0.2);\n  } else if (idObj == idFrame) {\n    col4 = vec4 (0.6, 0.6, 0.4, 0.) * (1. - 0.4 * smoothstep (0., 0.02,\n       PrRoundBox2Df (qHit.xy, vec2 (0.25 * gSize) - 0.1, 0.2)));\n    if (cDel.y == 0.5 * gCur.y && length (qHit.xy - cPos.xy) < 0.22) col4 = vec4 (0., 1., 0., -1.);\n  } else if (idObj == idSup) {\n    col4 = vec4 (0.6, 0.6, 0.4, 0.1);\n    if (length (qHit.xz) > 0.35) col4 *= 0.8 + 0.2 * smoothstep (-0.4, -0.2,\n       sin (16. * atan (qHit.z, - qHit.x)));\n  } else if (idObj == idBase) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.);\n    if (abs (ro.x) < bWid + 0.2 && abs (ro.y) < 0.25 * gSize.y + 2.1) {\n      col4 *= 0.6 + 0.4 * smoothstep (0., 0.03, abs (abs (qHit.z + 2.) - 0.2) - 0.02);\n      if (abs (qHit.z + 2.) < 0.2) col4 *= 0.6 + 0.4 * smoothstep (0., 0.03,\n         abs (mod (qHit.x, 0.5) - 0.25) - 0.02);\n    }\n  } else if (idObj == idWal) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.);\n    if (abs (ro.x) < bWid + 0.2) {\n      s = (1. - smoothstep (0., 0.02, abs (qHit.z + 2.) - 0.3)) *\n         (1. - smoothstep (0., 0.02, abs (qHit.y + 0.4) - 0.6));\n      if (s > 0. && sign (ro.x) * sign (cPos.x - 0.5 * gCur.x) > 0. && abs (ro.x) > bWid - 0.15)\n         col4 = vec4 (1., 0., 0., -1.);\n      else col4 *= 1. - 0.2 * s;\n    }\n  } else if (idObj == idLamp) {\n    col4 = vec4 (vec3 (0.9, 0.9, 0.8) * (0.95 + 0.05 * cos (64. * pi * qHit.y)), -1.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir;\n  float dstObj, tf, ltDist, sh, nDotL;\n  gSize = vec2 (13., 9.);\n  bWid = 4.5;\n  tCyc = 10.;\n  tCur += 2. * tCyc;\n  tPhs = mod (tCur / tCyc, 1.);\n  hCyc = floor (mod (tCur / tCyc + 0.5, 2.));\n  tf = floor (tCur / (2. * tCyc));\n  gCur = - floor (gSize / 2.) + floor (gSize * Hashv2f (17.11 * tf));\n  angC.y = (hCyc != 0.) ? -0.5 * pi *  (1. - SmoothBump (0.15, 0.85, 0.05, tPhs)) : 0.;\n  angC.x = angC.y;\n  cDel.x = (floor (gSize.x * Hashv2f (17.11 * (tf - 1.)).x - floor (gSize.x / 2.)) - gCur.x) *\n     (1. - smoothstep (0., 1.5, tCur - 2. * tCyc * tf));\n  cDel.y = (0.5 * gCur.y + 2.5) * SmoothBump (0.15, 0.85, 0.06, tPhs) - 2.5;\n  ltPos = vec3 (0., 0.25 * gSize.y + 1.8, -2.6);\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro);\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == idRail || idObj == idTel) nDotL *= nDotL;\n    isSh = true;\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir, ltDist);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       step (0.95, sh) * col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    else col = col4.rgb * (0.5 - 0.5 * dot (rd, vn));\n  } else {\n    col = vec3 (0.1, 0.1, 0.15);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az = 0.2 * pi * (2. * mod (floor (0.05 * tCur), 2.) - 1.) *\n       SmoothBump (0.3, 0.7, 0.15, mod (0.05 * tCur, 1.));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.5, -18.);\n  ro.y -= 0.5;\n  zmFac = 3.5;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}