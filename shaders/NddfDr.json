{
    "Shader": {
        "info": {
            "date": "1656363924",
            "description": "https://en.wikipedia.org/wiki/Losharik",
            "flags": 0,
            "hasliked": 0,
            "id": "NddfDr",
            "likes": 11,
            "name": "Horble",
            "published": 3,
            "tags": [
                "losharik",
                "horble"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "// Also see Static Horble. Same model, runs faster without arrays and without loops.\n// https://www.shadertoy.com/view/NsdfW4\n\nint leftFoot;\nint rightFoot;\nint rearFoot;\nint saddle;\n\nvoid connectHorble()\n{\n    // animation blend states\n    float t = .5+.5*cos(iTime/2.0); t*1.;\n    float u = .5+.5*cos(iTime/3.2); u*=.5;\n    float v = smoothstep(0.2,0.3,cos(iTime/2.7)); v*=1.;\n    float w = smoothstep(0.5,0.6,cos(iTime/4.2+2.0)); w*=1.;\n    float x = cos(iTime*12.); x*=smoothstep(0.5,1.0,cos(iTime/2.3));\n    float y = .5+.5*cos(iTime*2.); y*=smoothstep(0.73,1.0,cos(iTime/3.9));\n    u += .15 * y;\n\n    float bend;\n\n    // first ball\n    root(vec3(0.0, 0.0, 0.0), vec2(0.00 + fade(.1,u), 0.53 + fade(.02,t) + fade(-.020,u)), 0.10); turn(radians(5. + fade(-6.,u)));\n    \n    // right leg\n    bend = 40. + fade(-2.,t) + fade(1.5,u);\n    connect(vec3(0.70, 0.50, 0.40), radians(200. + fade(3.,t) + fade(-7.,u)), 0.05);\n    connect(vec3(0.80, 0.20, 0.00), radians(bend), 0.05);\n    connect(vec3(0.70, 0.01, 0.00), radians(bend), 0.05);\n    connect(vec3(0.60, 0.10, 0.00), radians(bend*1.2), 0.05);\n    connect(vec3(0.60, 0.00, 0.00), radians(bend*-.5), 0.05);\n    connect(vec3(0.50, 0.01, 0.00), radians(bend*-.5), 0.06); rightFoot = current;\n    up(6);\n\n    // back\n    bend = -20.;\n    connect(vec3(0.70, 0.10, 0.00), radians(-bend + fade(-2.,t)), 0.12); saddle = current;\n    connect(vec3(0.70, 0.00, 0.00), radians(2.*bend), 0.10); turn(radians(-bend)); \n\n    // tail\n    bend = -20.+fade(25.,y);\n    connect(vec3(0.90, 0.30, 0.02), radians(055.), 0.05);\n    connect(vec3(0.70, 0.05, 0.00), radians(bend), 0.05);\n    connect(vec3(0.40, 0.01, 0.00), radians(bend), 0.05);\n    connect(vec3(0.80, 0.35, 0.00), radians(bend), 0.07);\n    up(4);\n    \n    // rear leg\n    bend = -15. + fade(1.,t) + fade(-10.,u);\n    connect(vec3(0.01, 0.01, 0.01), radians(310. + fade(20.,u)), 0.05);\n    connect(vec3(0.05, 0.20, 0.02), radians(bend), 0.05);\n    connect(vec3(0.00, 0.00, 0.00), radians(bend), 0.05);\n    connect(vec3(0.80, 0.00, 0.00), radians(bend*1.5), 0.05);\n    connect(vec3(0.00, 0.01, 0.03), radians(bend*.1), 0.05);\n    connect(vec3(0.00, 0.00, 0.00), radians(bend*-.2), 0.06); rearFoot = current;\n    up(6);\n    up(2);\n\n    // head\n    bend = -15.;\n    connect(vec3(0.80, 0.05, 0.00), radians(140.), 0.05);\n    connect(vec3(0.00, 0.05, 0.20), radians(bend), 0.05);\n    connect(vec3(0.00, 0.40, 0.00), radians(bend), 0.05);\n    connect(vec3(0.80, 0.40, 0.03), radians(bend), 0.15);\n    connect(vec3(0.70, 0.00, 0.00), radians(310.), 0.05); move(-0.010, 0.000); up(1);\n    // eye\n    connect(vec3(0.90, 0.90, 0.90), radians(000.), 0.07); move(-0.190, 0.020); turn(radians(150.+fade(20.,u)));\n    connect(vec3(0.00, 0.00, 0.00), radians(000.), 0.06); move(-0.132+fade(-.005,w), 0.014+fade(-.007,v)); up(2);\n    // nose\n    connect(vec3(0.10, 0.01, 0.00), radians(080.), 0.06); move(-0.030, 0.000); up(1);\n    // mouth\n    connect(vec3(0.40, 0.05, 0.00), radians(125.), 0.03); move(-0.030+fade(.002,x), 0.000); up(1);\n    up(4);\n    \n    // left leg\n    bend = 25. + fade(-4., t);\n    connect(vec3(0.00, 0.00, 0.20), radians(215. + fade(7.,t) + fade(-4.,u)), 0.05);\n    connect(vec3(0.00, 0.20, 0.00), radians(bend), 0.05);\n    connect(vec3(0.00, 0.00, 0.15), radians(bend), 0.05);\n    connect(vec3(0.01, 0.01, 0.01), radians(bend), 0.05);\n    connect(vec3(0.40, 0.02, 0.00), radians(bend*-.2), 0.05);\n    connect(vec3(0.00, 0.00, 0.00), radians(bend*-.3), 0.06); leftFoot = current;\n    up(6);\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    f = 2. / iResolution.y;\n    vec2 uv = O - vec2(iResolution.x / 2., 0);\n    uv *= f;\n    uv.y -= 0.2;\n    uv.x += 0.3;\n    \n    connectHorble();\n\n    C = vec4(0.11, 0.40, 0.90, 1);\n    vec3 light = normalize(vec3(10, 9, 5));\n    vec3 rd = vec3(0, 0, -1);\n    vec3 grass = vec3(0.6,0.7,0);\n    vec2 shadow = (circles[leftFoot].center + circles[rightFoot].center + circles[rearFoot].center * 2.) / 4.;\n    //vec2 shadow = vec2(circles[saddle].center.x, 0.);\n    float rshadow = length((uv - shadow)*vec2(1.5,5));\n    grass *= mix(.5, 1., smoothstep(0.1, 1., rshadow));\n    C = blend(C, grass, -uv.y/f);\n    for (int i=0 ; i<N ; ++i)\n    {\n        vec2 offset = uv - circles[i].center;\n        float r = length(offset);\n        vec3 color = circles[i].color;\n        vec3 normal = vec3(offset / circles[i].radius, 0);\n        normal.z = sqrt(max(0., 1. - l2(normal.xy)));\n        color *= .5 + clamp(dot(normal, light), 0., 1.);\n        color += vec3(.1) * pow(clamp(l2(cross(rd, normal)), 0., 1.), 4.) * clamp(dot(normal, light)+.1, 0., 1.);\n        color += vec3(.5) * pow(clamp(dot(reflect(rd, normal), light), 0., 1.), 30.);\n        C = blend(C, color, -(r-circles[i].radius)/f);\n    }\n    C.xyz = sqrt(C.xyz);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct Circle\n{\n    int parent;\n    vec3 color;\n    vec2 center;\n    float radius;\n    float angle;\n};\n\nconst int N = 3 + (3+1) + (3+(1+(1+2+1+1))) + 3 * (5+1);\n\nint free, current;\nCircle[N] circles;\n\nmat2 R(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\nvec2 v(float a)\n{\n    return vec2(1, 0) * R(a);\n}\nvoid root(vec3 color, vec2 center, float radius)\n{\n    free = 0;\n    circles[free] = Circle(free, color, center, radius, 0.);\n    current = free++;\n}\nvoid connect(vec3 color, float angle, float radius)\n{\n    vec2 center = circles[current].center;\n    angle += circles[current].angle;\n    center += v(angle) * (circles[current].radius + radius);\n    circles[free] = Circle(current, color, center, radius, angle);\n    current = free++;\n}\nvoid move(float dx, float dy)\n{\n    circles[current].center += vec2(dx, dy) * R(circles[current].angle);\n}\nvoid turn(float da)\n{\n    circles[current].angle += da;\n}\nvoid up(int n)\n{\n    for (int i=0 ; i<n ; ++i)\n        current = circles[current].parent;\n}\n\nfloat fade(float target, float x) { return mix(0., target, x); }\n\nfloat f;\nvec4 blend(vec4 C, vec3 c, float r)\n{\n    return mix(C, vec4(c, 1), clamp(r + .5, 0., 1.));\n}\n\nfloat l2(vec2 x)\n{\n    return dot(x, x);\n}\n\nfloat l2(vec3 x)\n{\n    return dot(x, x);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}