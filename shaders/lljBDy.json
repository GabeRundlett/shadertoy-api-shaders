{
    "Shader": {
        "info": {
            "date": "1517101924",
            "description": "an attempt at figuring out how to trilinearly interpolate eight alphablended colors. this is an iterative approach, but I hope to eventually find a closed-form solution.",
            "flags": 0,
            "hasliked": 0,
            "id": "lljBDy",
            "likes": 29,
            "name": "Trilinear Interpolation w. Alpha",
            "published": 3,
            "tags": [
                "blending",
                "trilinear",
                "interpolation",
                "alpha"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1661
        },
        "renderpass": [
            {
                "code": "// with small optimal tweakings from @nothings\n\n// WIP\n//#define CLOSED_FORM\n\nconst float tau = 6.283185;\n\nbool cube(vec3 org, vec3 dir, out float near, out float far) {\n    vec3 p = -org/dir;\n    vec3 q = 0.5/abs(dir);\n\tvec3 tmin = p - q;\n\tvec3 tmax = p + q;\n    near = max(tmin.x,max(tmin.y,tmin.z));\n\tfar = min(tmax.x,min(tmax.y,tmax.z));\n\treturn near < far && far > 0.0;\n}\n\n\nvoid transformray (vec3 ro, vec3 rd, mat2 rotationY, vec3 offset, out vec3 outro, out vec3 outrd)\n{\n\toutro = ro + offset;\n\toutro = vec3(rotationY * outro.xz, outro.y).xzy;\n\toutrd = vec3(rotationY * rd.xz, rd.y).xzy;\n}\n\nvoid trilinear_integral_factors(out float f[8], vec3 ro, vec3 rd, float t) {\n    float t2 = 0.5*t*t;\n    float t3 = (2.0/3.0)*t2*t;\n    float t4 = t2*t2;\n\n    float dxdydz = rd.x*rd.y*rd.z*t4;\n    float ddo = (rd.y*rd.z*ro.x + rd.x*rd.z*ro.y + rd.x*rd.y*ro.z)*t3;\n    float doo = (rd.z*ro.x*ro.y + rd.y*ro.x*ro.z + rd.x*ro.y*ro.z)*t2;\n    float oxoyoz = ro.x*ro.y*ro.z*t;\n    float dxdydz_ddo_doo_oxoyoz = dxdydz + ddo + doo + oxoyoz;\n\n    float dxdy = rd.x*rd.y*t3;\n    float dxdz = rd.x*rd.z*t3;\n    float dydz = rd.y*rd.z*t3;\n\n    float oxdy = rd.y*ro.x*t2;\n    float oxdz = rd.z*ro.x*t2;\n\n    float dxoy = rd.x*ro.y*t2;\n    float oydz = rd.z*ro.y*t2;\n\n    float dxoz = rd.x*ro.z*t2;\n    float dyoz = rd.y*ro.z*t2;\n\n    float dx = rd.x*t2;\n    float dy = rd.y*t2;\n    float dz = rd.z*t2;\n    \n    float oxoy = ro.x*ro.y*t;\n    float oxoz = ro.x*ro.z*t;\n    float oyoz = ro.y*ro.z*t;\n\n    float ox = ro.x*t;\n    float oy = ro.y*t;\n    float oz = ro.z*t;\n    \n    f[0] = ( // 000\n    - dxdydz_ddo_doo_oxoyoz\n    + dxdy + dxdz + dydz\n    + oxdy + oxdz + dxoy + oydz + dxoz + dyoz - dx - dy - dz\n    + oxoy + oxoz + oyoz - ox - oy - oz + t\n    );\n    f[1] = ( // 001\n    + dxdydz_ddo_doo_oxoyoz\n    - dxdy - dxdz\n    - oxdy - oxdz - dxoy - dxoz + dx\n    - oxoy - oxoz + ox\n    );\n    f[2] = ( // 010\n    + dxdydz_ddo_doo_oxoyoz\n    - dxdy - dydz\n    - oxdy - dxoy - oydz - dyoz + dy\n    - oxoy - oyoz + oy\n    );\n    f[4] = ( // 100\n    + dxdydz_ddo_doo_oxoyoz\n    - dxdz - dydz\n    - oxdz - oydz - dxoz - dyoz + dz\n    - oxoz - oyoz + oz\n    );\n    f[6] = ( // 110\n    - dxdydz_ddo_doo_oxoyoz\n    + dydz\n    + oydz + dyoz\n    + oyoz\n    );\n    f[5] = ( // 101\n    - dxdydz_ddo_doo_oxoyoz\n    + dxdz\n    + oxdz + dxoz\n    + oxoz\n    );\n    f[3] = ( // 011\n    - dxdydz_ddo_doo_oxoyoz\n    + dxdy\n    + oxdy + dxoy\n    + oxoy\n    );\n    f[7] = ( // 111\n    + dxdydz_ddo_doo_oxoyoz\n    );    \n    \n}\n\nfloat dot8(float c[8], float f[8]) {\n    return\n          c[0] * f[0]\n        + c[1] * f[1]\n        + c[2] * f[2]\n        + c[3] * f[3]\n        + c[4] * f[4]\n        + c[5] * f[5]\n        + c[6] * f[6]\n        + c[7] * f[7];\n}\n\nconst float A = 1.0;\nconst float B = 0.0;\nvec4 C[8] = vec4[](\n#if 1\n    vec4(0,0,0,B),\n    vec4(1,0,0,A),\n    vec4(0,1,0,A),\n    vec4(1,1,0,B),\n    vec4(0,0,1,A),\n    vec4(1,0,1,B),\n    vec4(0,1,1,B),\n    vec4(1,1,1,A)\n#elif 0\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B)\n#elif 1\n    vec4(0,0,0,B),\n    vec4(1,0,0,B),\n    vec4(0,1,0,B),\n    vec4(1,1,0,B),\n    vec4(0,0,1,A),\n    vec4(1,0,1,A),\n    vec4(0,1,1,A),\n    vec4(1,1,1,A)\n#else\n    vec4(0,0,0,B),\n    vec4(1,0,0,A),\n    vec4(0,1,0,A),\n    vec4(1,1,0,A),\n    vec4(0,0,1,A),\n    vec4(1,0,1,A),\n    vec4(0,1,1,A),\n    vec4(1,1,1,B)\n#endif\n);\n\n// smallest non-inf number: exp(-103.9) or exp2(-149.99999)\n\nvec4 tf(vec4 s) {\n    return s;\n}\n\nvec4 tfinv(vec4 s) {\n    return s;\n}\n\nvec4 map(vec3 p) {\n    vec4 c00 = mix(tf(C[0]), tf(C[1]), p.x);\n    vec4 c01 = mix(tf(C[2]), tf(C[3]), p.x);\n    vec4 c10 = mix(tf(C[4]), tf(C[5]), p.x);\n    vec4 c11 = mix(tf(C[6]), tf(C[7]), p.x);\n    vec4 c0 = mix(c00, c01, p.y);\n    vec4 c1 = mix(c10, c11, p.y);\n    vec4 c = mix(c0, c1, p.z);    \n    return c;\n}\n\n// 8 is the lowest that still looks okay\n// there's only a faint visible difference between 32 and 256\n// particularly the peaks become more intense at low iterations\nconst int N = 256;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// camera\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 0.55; // move camera closer\n\tvec3 camro = normalize(vec3(1.0, -0.1 + sin(iTime)*0.5+0.5, 0.0));\n\tvec3 w = -camro;\n\tcamro *= 2.5;\n\tvec3 u = normalize(cross( vec3(0.0, 1.0, 0.0), w ));\n\tvec3 v = normalize(cross(w,u));\n\tvec3 camrd = normalize(p.x * u + p.y * v + 1.5 * w);\n\tfragColor = vec4(0.0);\n\t\n\t// rotation\n\tfloat angle = 5.0 * iMouse.x / iResolution.x;\n\tif( iMouse.z < 0.5 )\n\t\tangle = iTime + 4.7;\n\tfloat ca = cos(angle);\n\tfloat sa = sin(angle);\n\tmat2  m = mat2(ca, -sa, sa, ca);\n\t\n\tfloat far, near;\n\tvec3 ro, rd;\n\t\n    vec3 c = vec3(0.0);\n#ifdef CLOSED_FORM    \n    float k = 1.0;\n#else\n    float k = 1.0;\n#endif\n\t// cube\n\ttransformray(camro, camrd, m, vec3(0.0), ro, rd );\n    if (cube (ro, rd, near, far)) {\n        float d = (far - near);\n        vec3 p0 = (ro + rd * near)+0.5;\n        vec3 p1 = (ro + rd * far)+0.5;       \n#ifdef CLOSED_FORM\n        float f[8];\n        vec3 rd = p1 - p0;\n        float l = length(rd);\n        trilinear_integral_factors(f, p0, normalize(rd), l);\n        //trilinear_integral_factors(f, p0, rd, 1.0);\n        k = 0.0;\n        float CF = 0.99;\n        for (int i = 0; i < 8; ++i) {\n            k += log(1.0 - C[i].w*CF)*f[i];\n            c += log(1.0 - C[i].rgb*C[i].w*CF)*f[i];\n        }\n        k = exp(k);\n        c = 1.0 - exp(c);\n#else\n        float s = 1.0/float(N);\n        vec4 c0 = map(p0);\n        vec4 c1 = map(p1);\n        // solve front to back\n        for (int i = 0; i <= N; ++i) {\n            float x = float(i)*s;\n//#define CLOSED\n#ifdef CLOSED\n        float a = c0.w;\n        float b = c1.w;\n        //float k0 = exp(-D*log(a)/(a - b));\n        float k0 = d*x;\n        float k1 = log(a + (b-a)*x)*d/(a - b);\n        float k1b = log(a + (b-a)*x)*(d/(a - b) - 1.0);\n        float k2 = -log(a)*d/(a-b);\n        vec3 u = c0.rgb;\n        vec3 v = c1.rgb;\n#endif\n            vec3 p = clamp(p0 + (p1 - p0)*x, vec3(0.0), vec3(1.0));\n     \t\tvec4 src = tfinv(map(p));\n            vec3 col = src.rgb; // color\n            // two possible volume curves, experimentally found\n            //float tl = 1.0/(1.0 + exp(1.0/(1.0 - a) - 1.0/a)); // planck-taper function\n            \n            // front to back alpha blending iteration\n#ifdef CLOSED\n            float C = b-a;\n            vec3 D = v-u;\n            float Tl = a + C*x;\n            k = clamp(exp(d*x)*pow(1.0-x*C/(1.0-a), d/C),0.0,1.0);\n            //c = c + s*d*(u + x*D)*(a + C*x)*k/(1.0 - (a + C*x));\n            \n            vec3 T0 = u*a;\n            vec3 T1 = (D*a + u*C)*x;\n            vec3 T2 = D*C*x*x;            \n            \n            c = c + s*d*(T0 + T1 + T2)*k/(1.0 - (a + C*x));          \n            \n#else\n            float a = src.w; // normalized loglevel\n            float tl = 1.0 - 1.0/(1.0 - a);\n            float ttl = pow(exp(tl), d*s); // distribute over s=1/N iterations\n            c = c + col*(1.0 - ttl)*k;\n\t\t\tk *= ttl; // compute remaining visibility\n#endif\n    \t}\n#endif\n    }\n#ifdef CLOSED_FORM    \n    c = c + (texture(iChannel0, p*2.0).rrr * 0.2 + 0.2)*k;\n#else\n    c = c + (texture(iChannel0, p*2.0).rrr * 0.2 + 0.2)*k;\n    //c = vec3(k);\n#endif\n#if 0\n    if (max(c.r,max(c.g,c.b)) > 1.0) {\n        c = vec3(1.0,0.0,0.0);\n    }\n#endif\n    fragColor = vec4(pow(c, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}