{
    "Shader": {
        "info": {
            "date": "1625081493",
            "description": "Compared to original:\n- Does not use arrays\n- Shows all reflections\n- uses iFrame (N=2000 might be very slow)",
            "flags": 0,
            "hasliked": 0,
            "id": "stsXzn",
            "likes": 3,
            "name": "Reflections of N-E Shockwave",
            "published": 3,
            "tags": [
                "dynamicalsystem",
                "hyperbolicgeometry"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 264
        },
        "renderpass": [
            {
                "code": "/*  \n\thttp://math.ucsd.edu/%7Eaterras/bigbang.htm\n\tFrom Audrey Terras' Harmonic Analysis on Symmetric Spaces and Applications, 2nd edition, p. 316.\n\tExercise 3.6.19 (Harold Stark): Computer-Generated Movie of a Non-Euclidean Shock Wave. \n\tStark created this movie on his Atari ST which is still operating.\n*/\n\nconst int N = 2000;\nconst float y_start = 5.;\nconst float y_end = 10.;\n\nconst float width_screen = 10.;\n\nconst float time_reset = 2. * log2(float(N)) + log2(y_start) + log2(y_end);\n\n// performs consecutive translations in a single step (faster, but does not show all reflections)\nconst bool merge_translations = false;\n\nvoid circle_inversion(inout vec2 z) // z -> -1/z  ( = - conj(z) / |z|^2 )\n{\n\tz.x = -z.x;\n\tz /= dot(z,z);\n}\n\nvoid horizontal_translation(inout vec2 z) // z -> z+-1\n{\n    if (merge_translations)\n        z.x = fract(z.x + 0.5) - 0.5;\n    else\n        z.x = z.x < 0. ? z.x + 1. : z.x - 1.;\n}\n\nbool invert_circle(vec2 z)\n{\n    return dot(z, z) < 1.;\n}\n\nbool translate(vec2 z)\n{\n    return abs(z.x) > 0.5;\n}\n\nvoid plot(inout vec3 C, vec3 c, vec2 z, float r)\n{\n    if (dot(z, z) < r * r)\n        C = c;\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    float time = exp2(mod(float(iFrame) / 60., time_reset)); // time flows exponentially in hyperbolic space\n    float time_inv = 1. / time;\n\n    float f = width_screen / iResolution.x;\n    vec2 st = vec2(O - vec2(iResolution.x, 0) / 2.) * f;\n    \n    vec3 color = vec3(1);\n    if(abs(abs(st.x)-0.5) < f && length(st.xy) >= 1.) // Left and Right border of fundamental domain\n        color = vec3(0);\n    else if(abs(length(st.xy)-1.) < f) // lower circle of fundamental domain\n        color = vec3(0);\n\telse if(abs(st.x) <= 0.5 && length(st.xy) >= 1.)\n        color = vec3(.95);\n\n\tfor(int j=0; j<N; ++j)\n    {\n        float jf = float(j) / float(N);\n        vec3 point_color = vec3(sin(jf*2.), jf, 1.-jf);\n\t\n\t\tvec2 h = vec2(jf-0.5, y_start);\n\t\th.y *= time_inv;\n\t\t\n        while(invert_circle(h) || translate(h)) // Applying gamma, i.e. put into fundamental domain\n        {\n            if(invert_circle(h))\n            {\n                plot(color, vec3(1,0,0), st - h, f);\n                circle_inversion(h);\n            }\n            if(translate(h))\n            {\n                plot(color, vec3(1,0,1), st - h, f);\n                horizontal_translation(h);\n            }\n        }\n        plot(color, point_color, st - h, f);\n\t}\n\n    C = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}