{
    "Shader": {
        "info": {
            "date": "1677076990",
            "description": "Para crear una variante de este shader con un array de cubos equidistantes y centrados en la cámara, podemos modificar la función GetDist para que calcule la distancia al objeto más cercano que sea un cubo equidistante del centro de la cámara.\n\nAquí está ",
            "flags": 0,
            "hasliked": 0,
            "id": "msc3R7",
            "likes": 1,
            "name": "chatGPT Raytrace Mod",
            "published": 3,
            "tags": [
                "chatgpt"
            ],
            "usePreview": 0,
            "username": "Sergeindamix",
            "viewed": 172
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n#define CUBE_SIZE 2.0\n#define CUBE_GAP 1.0\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    vec3 cube_pos = CUBE_SIZE * floor(p / CUBE_SIZE);\n    float d = sdBox(p - cube_pos, vec3(1));\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p);\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f,r);\n    vec3 c = f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n\n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n    }\n\n    col = pow(col, vec3(.4545)); // gamma correction\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}