{
    "Shader": {
        "info": {
            "date": "1449266483",
            "description": "Proof of Concept for the shader that will be used for game \"Forbidden - The Untold Tale\"\n\nThis is my first modern shader, so tips and suggestions are more than welcome :)",
            "flags": 0,
            "hasliked": 0,
            "id": "Mdc3WH",
            "likes": 1,
            "name": "Forbidden - Flashlight",
            "published": 3,
            "tags": [
                "lighting",
                "flashlight",
                "proofofconcept"
            ],
            "usePreview": 0,
            "username": "PetrifiedLasagna",
            "viewed": 990
        },
        "renderpass": [
            {
                "code": "/*\n\nTODO: Shadow projection\n\nSince this shader is so simple, I do not mind if anyone uses it.\nIf you do use it or modify it for your own applications, please make sure to give credit\nusing my username.\n\nFEATURES:\n*light reacts to distance(can bend to objects in non-circular ways)\n\n*specify a flashlight raduis which is calculated with flashrad*dist\n\n*specify the smallest distance that the light will shrink to e.g. 0.5. Additionally,\n the flashlight will not grow larger than falloff end (if >0).\n\n*light will smoothly transition from maximum intensity to 0 based on falloff start and end.\n can be disabled by setting falloff end to 0.0.\n\n\n\nif you release this within your source you must leave the following text alone within it.\n\nCreated by: PetrifiedLasagna\nshader source: https://www.shadertoy.com/view/Mdc3WH\n*/\n\n//layout(origin_lower_left) in vec4 fragCoord;\n//layout(location = 0) out vec4 fragColor;\n\n//All Global Vars meant to be uniform\n//uniform vec2 winsize;//required for flashlight to work\nfloat flashrad = 45.0;\nfloat flash_min_dist = 1.0;\nfloat flash_falloff_start = 2.0;\nfloat flash_falloff_end = 5.0;\n\nstruct collisionT{\n    vec4 col;\n    float dist;\n};\n\nstruct rectT{\n    vec3 pos;\n    float width;\n    float height;\n    vec4 col;\n};\n\ncollisionT process_Image(vec2 coord){\n    float t = iTime;\n    \n    rectT rc[3];\n    rc[0].pos = vec3(cos(t)*150.0+iResolution.x/2.0-40.0, sin(t)*150.0+iResolution.y/2.0-40.0, 3.5);\n    rc[1].pos = vec3(cos(t/4.0)*100.0+iResolution.x/4.0, iResolution.y/2.0-40.0, 3.0);\n    rc[2].pos = vec3(cos(t)*50.0+iResolution.x/2.0-40.0, sin(t)*50.0+iResolution.y/2.0-40.0, 2.5);\n    for(int i = 0; i < 3; i++){\n        rc[i].width = 80.0;\n        rc[i].height = 80.0;\n        rc[i].col = vec4(1.0 * float(i==0), 1.0 * float(i==1), 1.0 * float(i==2), 1.0);\n    }\n    \n    collisionT ret;\n    ret.col = texture(iChannel0, coord.xy / iResolution.xy);\n    //ret.dist = sqrt(pow(coord.x, 2.0) + pow(coord.y, 2.0) + pow(4.8, 2.0));\n    ret.dist = 4.0;\n    \n    for(int i = 0; i < 4; i++){\n        rectT r = rc[i];\n        if((coord.x-r.pos.x >= 0.0 && coord.x-r.pos.x < r.width) &&\n           (coord.y-r.pos.y >= 0.0 && coord.y-r.pos.y < r.height)){\n            ret.col = r.col;\n            //ret.dist = ret.dist = sqrt(pow(coord.x, 2.0) + pow(coord.y, 2.0) + pow(2.0, 2.0));\n            ret.dist = r.pos.z;\n        }\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    collisionT ret = process_Image(fragCoord);\n    fragColor = ret.col;\n    if(flashrad == 0.0)\n        return;\n    \n    \n    vec2 flashp = iResolution.xy/2.0;\n    //vec2 flashp = winsize.xy/2.0;\n    //float dist = abs(sin(iTime/4.0))*5.5;\n    float dist = ret.dist;\n    //float dist = fragCoord.z;\n\tfloat light;\n    if(flash_falloff_end > 0.0 && dist>flash_falloff_end)\n        light = flashrad*flash_falloff_end;\n    else if(dist<flash_min_dist)\n        light = flashrad*flash_min_dist;\n    else\n        light = flashrad*dist;\n    \n    light *= light;\n    \n    float dcol = pow(fragCoord.x - flashp.x, 2.0) + pow(fragCoord.y - flashp.y, 2.0);\n    \n    if(dcol >= light *.25){\n    \tif(dcol < light *.75)\n        \tfragColor *= .75;\n        else if(dcol < light)\n            fragColor *= .5;\n        else\n            fragColor *= .018;\n    }\n    \n    if(flash_falloff_end > 0.0 && dist >= flash_falloff_start){\n        float scalar = 1.0 - clamp((dist - flash_falloff_start) / (flash_falloff_end - flash_falloff_start),\n                                 0.0, 1.0);\n        fragColor *= scalar;\n    }\n    \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}