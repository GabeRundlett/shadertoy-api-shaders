{
    "Shader": {
        "info": {
            "date": "1645169160",
            "description": "first take at transparency.\n\nmouse to orbit.  Lower Left = auto-orbit.  Upper Left = cross-eyed stereo + auto-orbit.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dlBRf",
            "likes": 17,
            "name": "Ordinary Glass, with Comments",
            "published": 3,
            "tags": [
                "reflection",
                "transparency",
                "glass",
                "recursion",
                "queue"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 423
        },
        "renderpass": [
            {
                "code": "// Fork of \"Ordinary Glass, with Comments\" by elenzil. https://shadertoy.com/view/7dlBRf\n// 2022-02-23 00:29:54\n\n/*\n\n    Ordinary Glass, with Comments\n    -----------------------------\n    \n    I've been wanting for a long time to try an approach to glass.\n    The main tricky/interesting part is how to handle the growing number of rays.\n    In raytracing simple materials, each pixel results in one ray\n    that travels into the scene and hits something, and maybe gets reflected,\n    but it's still one ray at a time.\n    But when a ray hits a glassy surface, it splits into two:\n    one child ray gets transmitted through the material and one gets reflected.\n    Then each of those split into two, and so on.\n    \n    In a normal CPU environment you would handle this ray-branching with recursion\n    but GPUs have no recusion. So I thought I'd try keeping a queue of rays,\n    and have a loop that runs forever, pulling rays from the queue and either\n    finishing the ray by contributing color to the pixel or forking into one or more\n    child-rays. Along the way each ray has to remember what share of contribution\n    it has for the scene.\n    \n    It looks like this:\n    \n    1. Find the initial ray leaving the pixel and entering the scene.\n       This ray has full contribution of 1.  Add it to the queue.\n\n    2. While the ray queue is not empty:\n       * pull a ray out of the queue.\n       * march it until it hits a surface or reaches the marching limit.\n         * if it reaches the marching limit, color it Sky.\n         * if it reaches a surface:\n           * use some fraction of the ray's \"contribution\" for diffuse shading.\n             this involves another marching step for shadows.\n           * use the remaining fraction to create child rays for reflection and transmission,\n             and add them to the queue.\n             \n    This was my first time marching through the dark (in) side of the SDF,\n    so it's likely there are some thing I'm missing there.\n    There are still some artifacts I haven't figured out.\n        * speckles in the plain featureless portions of surfaces\n        * something's weird with floor reflections plus transmission\n        * high attenuation coefficient yields weird results\n        * black edges on iOS.\n          - this makes me this something's uninitialized.\n    \n    I've heard that arrays and globals have poor performance in GLSL,\n    but it seems to do allright. The array size is being used is just 6 or so.\n               \n    There may be other approaches to this,\n    I haven't checked how folks like Dr2 and byt3_m3chanic are doing it.\n    .. Now I have. A lot of folks are using a stack,\n    but some of the best ones just treat each interface-crossing\n    as either entirely transmissive or entirely reflective, based on total internal reflection.\n\n\n    I've tried to add Shane-style comments, but it's still fairly messy.\n*/\n\n\n// Fork of \"elenzil marcher base\" by elenzil. https://shadertoy.com/view/fdffDn\n// 2022-02-12 15:40:33\n\n// todo\n// [x] optimize queue!\n// [x] actual attenuation while in material\n// [x] total internal reflection\n// [ ] fresnel ?\n// [ ] better environment\n// [ ] vignette\n// [ ] consider a conveyor-belt style presentation ?\n// [ ] AA\n// [ ] per-object materials\n// [ ] shadows that know about transparency\n// [ ] diffusion\n\n\n// the maximum number of simultaneous rays in the backlog.\n// the number of rays per pixel can be more than this.\nconst uint  gMaximumRaysInQueue = 10u;\n\n// a ray must have at least this much contribution left to be enqueued.\nconst float gMinimumRayContribution = 0.005f;\n\n// #define HEATMAP\n\n\nstruct ray_t {\n    // origin\n    vec3  ro;\n    \n    // direction\n    vec3  rd;\n    \n    // what amount of the pixel this ray is contributing. [0, 1]\n    float contribution;\n    \n    // whether this ray is on the inside of the SDF.\n    bool  internal;\n};\n\n\n////////////////////////////////////////////////////////////////////////////\n// This section of code implements a ring-buffer queue for holding rays.\n// Using a queue of rays instead of a stack\n// because earlier child-rays are more important than later.\n// ie, if we used a stack, the less-contributing rays would get processed\n// earlier than the more-contributing rays, eating up our budgets.\n// This is a pretty standard implementation of a ring-buffer, not special to GLSL.\n// The only difference from an implementation in say C++ is no error-checking!\n\n// my kingdom for templates in GLSL..\n#define QTYPE ray_t\nconst uint gQCapacity = gMaximumRaysInQueue;\nconst uint gQNumSlots = gQCapacity + 1u;\nQTYPE gQ[gQNumSlots];\nuint gQHead = 0u;\nuint gQTail = 0u;\n\n// the number of items in the queue\nuint QCount() {\n\tif (gQHead >= gQTail) {\n\t\treturn gQHead - gQTail;\n\t}\n\telse {\n\t\treturn gQNumSlots - (gQTail - gQHead);\n\t}\n}\n\n// the remaining capacity of the queue\nuint QSpaceLeft() {\n\treturn gQCapacity - QCount();\n}\n\nbool QIsFull() {\n\treturn QSpaceLeft() == 0u;\n}\n\nbool QIsEmpty() {\n\treturn QCount() == 0u;\n}\n\n// add an item to the head of the queue.\n// only call this if the queue is not empty !\nvoid QEnqueue(QTYPE item) {\n\tgQHead = (gQHead + 1u) % gQNumSlots;\n\tgQ[gQHead] = item;\n}\n\n// pull an item off the tail of the queue.\n// only call this if the queue is not empty !\nQTYPE QDequeue() {\n\tgQTail = (gQTail + 1u) % gQNumSlots;\n\treturn gQ[gQTail];\n}\n\n// conditionally add a ray to the queue\nbool addRay(in ray_t ray) {\n    if (QIsFull()) {\n        return false;\n    }\n    if (ray.contribution < gMinimumRayContribution) {\n        return false;\n    }\n    QEnqueue(ray);\n    return true;\n}\n\n// do not call this if the queue is empty !\nray_t popRay() {\n    return QDequeue();\n}\n\n// this section has a bunch of globals which are configured once per pixel per frame,\n// and then re-used multiple times.\n// for example, rotation matrices used in the core map() function.\n// I haven't noticed other people doing this, perhaps there's a reason..\nfloat gViewTheta = 0.0;\nvec3  gSceneCenter = gVy * 1.4;\nfloat gRounding = 0.075;\nvec3  gLightDirection = normalize(vec3(1.0, -2.0, 1.0));\nfloat gUnderStepFactor = 1.0;\nvec2  gRes;\nbool  gDoStereo = false;\n\nfloat gSSZoom;\nvec2  gM;\nmat2  gSceneRot1;\nmat2  gSceneRot2;\nmat2  gSceneRot3;\nmat2  gSceneRot4;\nfloat gBoxTwist = 0.0;\nvec3  gOuterBox;\nvec3  gInnerBox;\nvec3  gCornerBox;\nfloat gCornerBoxRounding;\nfloat gMouseTargetRad;\nvec3  gBallPos;\nfloat gBallRad;\nfloat gBallSep;\n\n// the maximum number of steps to raymarch.\nint   gMaxMarchStepsExternal = 250;\nint   gMaxMarchStepsInternal = 200;\n\n// pre-calculate values which are used in the core map() sdf function.\nvoid configMap() {\n    gSceneRot1 = rot2( -gViewTheta * 0.5);\n    gSceneRot2 = rot2(sin(gViewTheta * 4.0) * 0.1);\n    gSceneRot3 = rot2(cos(gViewTheta * 4.0) * 0.1);\n    gSceneRot4 = rot2(gT);\n    \n    gOuterBox = vec3(1.0);\n    gInnerBox = vec3(mix(0.0, 0.98, smoothstep(-0.9, 0.9, -cos(gT * 0.621))));\n    \n    float CBf = smoothstep(2.0, 3.0, gT);\n    gCornerBox         = CBf * vec3(0.6);\n    gCornerBoxRounding = CBf * gRounding;    \n    \n    gBallRad = 0.3;\n    gBallSep = 0.1;\n\n    // these odd numbers like 0.91, 0.31 all over the place\n    // are just to keep the various cyclic aspects from lining up\n    // so that the exact state of the scene keeps varying over time.\n    gBallPos = gSceneCenter;\n    gBallPos.x  += -cos(gT * 0.91 ) * 1.5;\n    gBallPos.z  +=  sin(gT * 0.91 ) * 1.5;\n    gBallPos.y  +=  sin(gT * 0.31) * (1.3 - gBallRad - gBallSep);\n    \n    // some twist for the box.\n    // twisting ruins the accuracy of the distance field,\n    // so while twisting we under-step during marching.\n    float twistT = gT / 4.123;\n    float btc = smoothstep(0.7, 1.0, -cos(twistT));\n    gBoxTwist = btc * 0.7 * sign(sin(twistT / 2.0));\n    gUnderStepFactor = mix(1.0, 0.82, btc);\n}\n\n// more configuration.\nvoid configGlobals0() {\n    gMouseTargetRad = 50.0;\n}\n\nvoid configGlobals1() {\n    gSSZoom = 0.8;\n\n    gT = iTime * PI / 10.0;\n    gSSEps  = 3.0/MINRES/gSSZoom;\n    gSSLw   = 2.0/MINRES/gSSZoom;\n\n    vec2 M = iMouse.xy;\n    if (gDoStereo || length(M) < gMouseTargetRad) {\n        M = (vec2(cos(gT * 0.751) * 0.8, cos(gT * 0.631)) * 0.4 + 0.4) * gRes.xy;\n    };\n    gM = M / gRes.xy;\n    gViewTheta = gM.x * PI * 2.0 + sin(gT * 0.71) * 0.1;\n}\n\n// a variable to track the number of calls to map().\n// this can be displayed as a 'heat map'.\nfloat gMapCalls = 0.0;\n\n// the core signed-distance-function routine.\nfloat map(vec3 p) {\n    float d = 1e9;\n    \n    gMapCalls += 1.0;\n    \n    // mod() the incoming point by a fairly large value,\n    // just to get some extra geometry in the background.\n    float repD = 50.0;\n    p.xz = mod(p.xz + repD/2.0, repD) - repD/2.0;\n    \n    // move to the center of our scene\n    vec3 pp = p - gSceneCenter;\n    \n    // apply some view-dependent wobble\n    pp.xz *= gSceneRot1;\n    pp.yz *= gSceneRot2;\n    pp.xy *= gSceneRot3;\n    \n    mat2 twist = rot2(pp.z * gBoxTwist);\n    pp.xy *= twist;\n    \n    // the main cube\n    d  = opU(d, sdBox   (pp, gOuterBox - gRounding) - gRounding);\n    \n    // minus a sube inside of it which grows and shrinks.\n    d  = opS(d, sdBox   (pp, gInnerBox - gRounding) - gRounding);\n   \n    // use abs() to now operate on each corner at once\n    vec3 ppp = abs(pp) - gV1 * 1.0;\n    // subtract a cube from each/the corner\n    d = opS(d, sdBox(ppp, gCornerBox) - gCornerBoxRounding);\n    \n    // move to the ball\n    ppp = p - gBallPos;\n    \n    // subtract a 'force field' from around where the ball will be\n    d = opS(d, sdSphere(ppp, gBallRad + gBallSep));\n    \n    // work in a sub-distance metric.\n    // this isn't really needed for what's here now,\n    // but it was useful for a more complex ball thing for a while.\n    float dd = 1e9;\n    // a regular sphere\n    dd = opU(dd, sdSphere(ppp, gBallRad));\n    // minus a growing/shrinking sphere inside of it.\n    dd = opS(dd, sdSphere(ppp, gBallRad * mix(0.0, 0.95, smoothstep(-0.4, 0.4, sin(gT * 2.31)))));\n    // union our sub-distance field with the main one.\n    d = opU(d, dd);\n    \n    // add a ground plane.\n    // I'm having some strange artifacts with the ground plane and reflectivity.\n    d = opU(d, sdPlnY(p));\n  \n    return d;\n}\n\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*gWSEps);\n    }\n    return normalize(n);\n}\n\n// return a ray from the camera through our pixel and into the scene.\n// uv should be 0 in the center of the viewport, not 0.5.\nray_t getCamRay(vec2 uv, bool isLeftEye) {\n\n    ray_t ray;\n    \n    float stereoSep = -0.1 * (isLeftEye ? -1.0 : 1.0);\n    \n    // this seed ray is the whole contribution of the pixel!\n    // .. or at least it is until I add anti-aliasing.\n    ray.contribution = 1.0;\n\n    float zoomFac = 0.7;\n    \n    // where the whole camera is looking to.\n    // ping-pongs between the flying ball and the main cube.\n    float viewPingPong = smoothstep(0.8, 1.0, -cos(gT * 0.113));\n    vec3  lookDst = mix(gSceneCenter, gBallPos, viewPingPong);\n    \n    // where the camera is looking from.\n    // also ping-pongs.\n    vec3  lookSrc = vec3(cos(gViewTheta), (1.4 - gM.y * 1.3) * 4.0/3.0, sin(gViewTheta)) * 3.0;\n    lookSrc = mix(lookSrc, gBallPos * vec3(2.2, 1.3, 2.2), viewPingPong);\n    \n    // some rough logic to keep the camera a safe distance away from the ball and cube\n    float lsl  = length(lookSrc);\n    float lsl2 = max(lsl, 4.0);\n    lookSrc = lookSrc / lsl * lsl2;\n    \n    // construct an orthobasis for the camera. altho I don't turn it into an actual matrix.\n    vec3  camFw   = normalize(lookDst - lookSrc);\n    vec3  camRt   = normalize(cross(camFw, gVy));\n    vec3  camUp   = cross(camRt, camFw);\n    \n    lookSrc += camRt * stereoSep;\n    camFw   = normalize(lookDst - lookSrc);\n    camRt   = normalize(cross(camFw, gVy));\n    camUp   = cross(camRt, camFw);\n    \n\n    \n    // determine a 'look to' point for this specific pixel.\n    // gV0 is vec3(0).\n    vec3  p       = gV0;\n    p            += lookSrc;\n    p            += camFw;\n    p            += camRt * uv.x * zoomFac;\n    p            += camUp * uv.y * zoomFac;\n    \n    // copy it to the ray.\n    ray.ro        = lookSrc;\n    ray.rd        = normalize(p - ray.ro);\n    \n    // if the camera is initially inside an object, things are going to look weird,\n    // but at least this gives them a shot at correctness.\n    ray.internal  = map(p) < 0.0;\n    \n    return ray;\n}\n\n// ordinary raymarching.\n// return distance along ray to nearest intersection.\n// also returns the minimum distance from the ray to a surface. ie, often 0.\nfloat marchExternal(vec3 ro, vec3 rd, out float minD) {\n    float t = 0.0;\n    minD = 1e9;\n    \n    vec3 p;\n    for (int n = 0; n < gMaxMarchStepsExternal && (dot(p, p) < 1e4); ++n) {\n        p = ro + rd * t;\n        float d = map(p);\n        minD = min(minD, d);\n        if (d < gWSEps) {\n            minD = 0.0;\n            return t;\n        }\n        \n        t += d * gUnderStepFactor;\n    }\n    \n    return 1e9;\n}\n\n// raymarching in the negative side of the SDF.\nfloat marchInternal(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    \n    for (int n = 0; n < gMaxMarchStepsInternal && t < 1e2; ++n) {\n        vec3  p = ro + rd * t;\n        float d = map(p);\n        if (d > -gWSEps) {\n            return t;\n        }\n\n        t -= d * gUnderStepFactor;\n    }\n    \n    return 1e9;\n}\n\n// a function for some 'sky'. takes direction only, no positon.\n// could be replaced with a cubemap.\nvec3 sky(vec3 dir) {\n    float theta = atan(dir.z, dir.x);\n    vec3 rgb = abs(dir);\n    float absst = abs(sin(theta * 10.0 ));\n    rgb = mix(rgb, vec3(1.0), 0.2 * smoothstep(0.05, 0.0, absst - 0.2));\n    rgb *= mix(1.0, smoothstep(-0.1, 0.1, dir.y), 0.7);\n    rgb = mix(rgb, vec3(rgb.x + rgb.y + rgb.z) / 3.0, absst);\n    return rgb;\n}\n\n// takes a ray off the queue, marches it, potentially adds children to the queue.\n// repeats indefinitely until either the queue is empty or we pass a limit.\n// in a recursive implementation this would be \"processRay()\", and would call itself.\nvec3 processRays() {\n\n    // rgb is the output pixel color. start with black.\n    vec3 rgb = gV0;\n    \n    // track how many rays we've processed.\n    // stop when either that number is too large,\n    // or when the queue is empty.\n    uint processingIter;\n    for (processingIter = 0u;\n        processingIter < gQCapacity * 3u && !QIsEmpty();\n        ++processingIter) {\n        \n        // take the oldest ray out of the queue.\n        // on the first call to this method, there is only one ray in the queue,\n        // so the queue is empty after this call.\n        ray_t ray = popRay();\n        \n        // march either external or internal, depending on the ray.\n        float distanceAlongRayToSurface;\n        if (ray.internal) {\n            distanceAlongRayToSurface = marchInternal(ray.ro, ray.rd);\n        }\n        else {\n            float _unused;\n            distanceAlongRayToSurface = marchExternal(ray.ro, ray.rd, _unused);\n        }\n        \n        // if the returned distance is \"near\", call it a surface.\n        // if it's \"far\", call it the sky.\n        if (distanceAlongRayToSurface < 1e4) {\n        \n            // the position of the intersection\n            vec3  p    = ray.ro + distanceAlongRayToSurface * ray.rd;\n            vec3  grad = getNormal(p);\n            vec3  n    = grad;\n            \n            // If the ray is internal,\n            // we need to adjust the normal to point inwards.\n            // We also attenuate the ray's contribution according\n            // to how much material the ray passed through.\n            if (ray.internal) {\n                // surface normal is from the gradient, so flip it.\n                n = -n;\n                \n                // attenuation\n                ray.contribution *= exp(-1.0 * distanceAlongRayToSurface);\n            }\n            \n            // poor-man's materials: there's floor, sky, and everything else.\n            bool isFloor = p.y < 0.001;\n            \n            // diffuse component\n            float diffAmt = isFloor ? 0.9 : 0.05;\n            // dot the surface normal with our light direction\n            float diff = max(0.0, dot(n, -gLightDirection));\n            \n            // shadows\n            // only do these if there's a point.\n            if (diff * diffAmt * ray.contribution > 0.01) {\n                // for shadows we march towards the light\n                // and take advantage of the ease with which raymarching\n                // tells you approximately how close you came to any surface,\n                // and use that for a little soft shadowing.\n                // Soft shadowing tends to being out the artifacts in raymarching,\n                // so we understep significantly.\n                // Don't forget to offset the initial point from the surface by a bit,\n                // and not to use 'n' for that, because for internal rays it points inward.\n                float minD;\n                const float penumbra = 0.1;\n                float saveUnderStep = gUnderStepFactor;\n                int   saveMaxSteps  = gMaxMarchStepsExternal;\n                gMaxMarchStepsExternal = 200;\n                gUnderStepFactor *= 0.3;\n                marchExternal(p + grad * (penumbra + 0.01), -gLightDirection, minD);\n                diff *= smoothstep(0.0, penumbra, minD);\n                gUnderStepFactor = saveUnderStep;\n                gMaxMarchStepsExternal = saveMaxSteps;\n            }\n            \n            // almost done with diffuse shading.\n            // calculate albedo, the inherent color of the surface.\n            // it's white for glass, and patterned for the floor.\n            // note this is still modulated by the 'diffAmt' factor.\n            vec3 albedo = gV1 * 0.5;\n            if (isFloor) {\n                float x = abs(cos(p.z)) - 0.5 * -cos(p.x * 1.5);\n                x = sqrt(x);\n                albedo = gV1 * 0.4 * smoothstep(0.49, 0.51, x) + 0.05;\n                albedo = (albedo) / (1.0 + length(p) * 0.5);\n                albedo.r *= 0.5;\n            }\n            \n            // ambient light.\n            // it's good to add in some of this\n            // so that albedo texture that's in shadow isn't lost.\n            diff = max(0.04, diff);\n            \n            // add the diffuse lighting to the pixel.\n            rgb += diff * ray.contribution * diffAmt * albedo;\n            \n            // add rays for reflection and transmission\n\n            // \"eta\" is the greek letter Î·.\n            // it's the ratio of the two indices of refraction of the mediums.\n            // eg, air to glass.\n            // we animate the index of refraction a little,\n\n            const float ior_air     = 1.0003;\n            const float ior_water   = 1.333;\n            const float ior_quartz  = 1.46;\n            const float ior_diamond = 2.42;\n\n            float eta = ior_air / ior_diamond;\n\n            // if we're transitioning from inside to outside,\n            // eta should be inverted.\n            if (ray.internal) {\n                eta = 1.0 / eta;\n            }\n\n            // The next chunk of code determines the contributions\n            // of the reflected and refracted rays.\n\n            // this is the portion of the ray contribution left for\n            // reflection and refraction, after whatever diffuse used up.\n            float reflectAndRefractAmt = 1.0 - diffAmt;\n\n            // this is what portion of the reflect/refract portion is reflect vs. refract.\n            // 0 = all reflection, no transmission\n            // 1 = all transmission, no reflection\n            float reflectVsRefract = smoothstep(-1.0, -0.5, cos(gT * 0.221));\n\n            reflectVsRefract = min(0.95, reflectVsRefract);\n\n\n            // glsl conveniently provides these helpers:\n            vec3  reflectDir = reflect(ray.rd, n);\n            vec3  refractDir = refract(ray.rd, n, eta);\n\n            // refract() returns 0 if there's total internal reflection.\n            // it's critical to handle this case because it's common.\n            bool totalInternal = dot(refractDir, refractDir) == 0.0;\n\n            // no transmission if total internal reflection.\n            // no transmission for the floor\n            if (isFloor || totalInternal) {\n                reflectVsRefract = 0.0;\n            }\n\n            // The portion of the contribution for reflection and transmission\n            float reflectAmt = reflectAndRefractAmt * (1.0 - reflectVsRefract);\n            float refractAmt = reflectAndRefractAmt * reflectVsRefract;\n            float reflectContribution = ray.contribution * reflectAmt;\n            float refractContribution = ray.contribution * refractAmt;\n\n            // the origin of the ray for reflection should be offset from the surface a bit.\n            // the origin for transmission should be inset into the surface a bit.\n            vec3  reflectSrc = p + n * gWSEps * 2.0;\n            vec3  refractSrc = p - n * gWSEps * 2.0;\n\n\n            // enqueue the reflected ray. it copies the parent ray's internal-ness\n            if (!addRay(ray_t(reflectSrc, reflectDir, reflectContribution,  ray.internal))) {\n                // ray was not enqueued, either the queue was full or the contribution was too small.\n                rgb += sky(ray.rd) * reflectContribution;\n            }\n\n            // enqueue the transmitted ray. it inverts the parent ray's internal-ness\n            if (!addRay(ray_t(refractSrc, refractDir, refractContribution, !ray.internal))) {\n                // ray was not enqueued, either the queue was full or the contribution was too small.\n                rgb += sky(ray.rd) * refractContribution;\n            }\n            \n        }\n        else {\n            // this ray did not hit a surface. it's the sky!\n            // ray contribution is still super important here,\n            // as that's handling all the attenuation due to transmission, reflection.\n            rgb += sky(ray.rd) * ray.contribution;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid addCircle(inout vec3 rgb, in vec2 p, float rad) {\n    float lp = length(p);\n    rgb = mix(rgb, gV0, 0.1 * smoothstep(2.0, 0.0,     lp - rad));\n    rgb = mix(rgb, gV1, 0.2 * smoothstep(2.0, 0.0, abs(lp - rad)));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    configGlobals0();\n    \n    vec2 xy = XY;\n    \n    gDoStereo = length(vec2(iMouse.x, RES.y - iMouse.y)) < gMouseTargetRad;    \n    gRes = gDoStereo ? vec2(RES.x / 2.0, RES.y) : RES.xy;    \n    bool isLeftEye = XY.x < gRes.x;    \n    if (gDoStereo && !isLeftEye) {\n        xy.x -= gRes.x;        \n    }\n    \n    // set up some things we'll re-use\n    configGlobals1();\n    \n    // configure the geometry of the scene.\n    // this is called once per pixel here,\n    // but map() is called hundreds of times.\n    configMap();\n    \n    // screen-space coordinates with 0,0 at the center\n    vec2 uv = (xy - gRes.xy / 2.0) / MINRES * 2.0 / gSSZoom;\n    \n    // kick things off with a single ray for this pixel\n    addRay(getCamRay(uv, isLeftEye));\n\n    // march the ray and all its children\n    vec3 rgb = processRays();\n    \n    // gamma\n    rgb = pow(rgb, vec3(1./2.2));\n    \n    // \"UI\"\n    addCircle(rgb, XY, gMouseTargetRad);\n    addCircle(rgb, vec2(XY.x, iResolution.y - XY.y), gMouseTargetRad);\n\n    #ifdef HEATMAP\n    float pixelExpense = clamp(gMapCalls/1000.0, 0.0, 1.0);\n    rgb   *= 0.2;\n    rgb.r += pixelExpense;\n    #endif\n    \n    RGBA = vec4(rgb, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    iResolution\n#define MINRES min(RES.x, RES.y)\n#define ZERO   (min(iFrame, 0))\n\nconst float PI = 3.14159265359;\n\n// WS = world space SS = screen space\nfloat gWSEps = 0.001;  // WS epsilon for surfaces\nfloat gSSEps;          // SS epsilon for smoothstep\nfloat gSSLw;           // SS line width\nfloat gT;\n\nconst vec3 gV0 = vec3(0.0);\nconst vec3 gV1 = vec3(1.0);\nconst vec3 gVx = vec3(1.0, 0.0, 0.0);\nconst vec3 gVy = vec3(0.0, 1.0, 0.0);\nconst vec3 gVz = vec3(0.0, 0.0, 1.0);\n\nconst vec3 gMagenta = vec3(1.0, 0.0, 1.0);\nconst vec3 gGreen   = vec3(0.0, 1.0, 0.0);\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat opU(float A, float B) {\n    return min(A, B);\n}\nfloat opS(float A, float B) {\n    return -min(-A, B);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCylX(vec3 p, float r) {\n    return length(p.yz) - r;\n}\n\nfloat sdCylY(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdCylZ(vec3 p, float r) {\n    return length(p.xy) - r;\n}\nfloat sdPlnY(vec3 p) {\n    return p.y;\n}\nfloat sdSlabX(vec3 p, float r) {\n    return abs(p.x) - r;\n}\nfloat sdSlabY(vec3 p, float r) {\n    return abs(p.y) - r;\n}\nfloat sdSlabZ(vec3 p, float r) {\n    return abs(p.z) - r;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}