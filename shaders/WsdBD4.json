{
    "Shader": {
        "info": {
            "date": "1605115025",
            "description": "This is my submission to the jFig 2020 rendering contest. \nImplementing the Student-t normal distribution function from Ribardiere et al. (2017)\nAnd also a modified procedural solid phasor noise using a 3D simplex grid.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsdBD4",
            "likes": 7,
            "name": "[jFig2020] Student-t NDF",
            "published": 3,
            "tags": [
                "ndf",
                "phasor",
                "jfig",
                "studentt"
            ],
            "usePreview": 0,
            "username": "H4w0",
            "viewed": 453
        },
        "renderpass": [
            {
                "code": "//=======================================================\n//= [jFIG2020] Isotropic Student-t NDF\n//=======================================================\n//== Here is my humble submission to the jFig 2020 rendering contest.\n//== This shadertoy contains an implementation of an isotropic student-t normal distribution function (NDF for short).\n//== This NDF was introduced by Ribardiere et al. in 2017 in the following paper \n//== *- STD: Studentâ€™s t-Distribution of Slopes for Microfacet Based BSDFs\n//==\t(PROJECT PAGE : https://mribar03.bitbucket.io/projects/eg_2017/)\n//==\n//== By tuning the gamma parameter between 2.0 and +inf you can change the tail of the lobe.\n//== When gamma is equal to 2.0, the lobe is the same as a GGX.\n//== When gamma tends to infinity, the lobe tends to a Beckmann one.\n//==\n//== The sphere is procedurally textured using a modified solid phasor noise \n//== *- Procedural Phasor Noise (by Tricard and Efremov et al. 2019 (ARTICLE : https://hal.inria.fr/hal-02118508))\n//== I used a local random phase noise formulation which is based on a sum of cosines on a regular grid.\n//== As a grid I used a simplex grid to only sum 4 noise contributions at a position.\n//== To animate the procedural solid texture I modified a pulse with modulation using a cosine wave.\n//==\n//== I used the cubmap buffer to pre-render the scene without the sphere to add a fake reflection.\n//=======================================================\n//== Remarks :\n//== *- This WebGL implementation is not quite numerically stable depending on the gamma parameter\n//== \tso i clamped it to 10.\n//=======================================================\n//== Controls : \n//== *-\tThe mouse X axis controls the roughness of the isotropic microfacet NDF\n//== *- The mouse Y axis constrol the gamma parameters which is remap between 2.0 and 10.0\n//=======================================================\n//== NDF Implementations details :  \n//== *- Computations are done in tangent space (PBRT-like)\n//== *- Code can be a lot simplified but I wanted a verbose/self-explained code \n//== *- Code could have more checks (non-zero length before normalization, etc.)\n//== *- NDFs are expressed using the slope distribution function P22\n//== *- Fresnel Term uses the Schlick Approximation\n//== *- Some equations are written with the lovely style of @valentingalea (https://www.shadertoy.com/view/XtBXDz)\n//== \t( again it's a personal taste :D )\n//=======================================================\n//== I also used some code from :\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy (https://www.shadertoy.com/view/4sSSW3)\n//== *- @iq shaders\n//== \t- Intersectors ( Plane and Sphere )\n//== \t- HSV and HSL ( hsv2rgb from https://www.shadertoy.com/view/lsS3Wc)\n//== \t- Filtered Checkerboards (https://iquilezles.org/articles/checkerfiltering)\n//== *- Thibault Tricard phasor noise implementations (check https://www.shadertoy.com/user/ThibaultTricard)\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\nconst float metallic = 0.;\t\t// 0. or 1.\nconst float reflectance = 0.35; // [0.35;1]\nconst float MIN_GAMMA = 2.0;\t\nconst float MAX_GAMMA = 10.0;\t// Due to numerical issues 10 is the maximal gamma\n\nconst uint JFIGW = 32u;\nconst uint JFIGH = 18u;\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Student Distribution -----------------------------------------------------\nfloat p22_student_t_isotropic(float x, float y, float alpha, float gamma)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma = alpha * m_i_sqrt_2;\n    float two_sigma_sqr = sigma*sigma*2.f;\n    float alpha_sqr = alpha*alpha;\n\n    return(\n            ( pow(gamma - 1.,gamma)*pow(m_sqrt_2*sigma,2.*gamma-2.) )\n    / //-------------------------------------------------------------------\n        ( m_pi*pow( (gamma-1.)*two_sigma_sqr + x_sqr + y_sqr, gamma) )\n    );\n}\n\nfloat ndf_student_t_isotropic(vec3 omega_h, float alpha, float gamma)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float std_p22 = p22_student_t_isotropic(slope_x,slope_y,alpha,gamma);\n    return(\n                  std_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_student_t_isotropic(vec3 omega, float alpha, float gamma)\n{\n    float tan_theta  = tan_theta(omega);\n    if(tan_theta==0.) \n    {return 0.;}\n    \n    /* fixed mistake */\n    float root     = alpha * tan_theta;\n    float rootInv  = 1. / root;  \n    float lambda   = 0.; \n\n    float S1 = root * pow(gamma-1.+rootInv*rootInv , 1.5-gamma);\n    float S2 = F_21(rootInv)*F_22(gamma)*F_23(gamma)*F_24(rootInv);\n    float F1 = pow(gamma-1.,gamma) / (2.*gamma-3.);\n    float F2 = Gamma_Approx(gamma-0.5f) / (sqrt(m_pi)*Gamma_Approx(gamma));\n\n    lambda = (S1*F1 + S2*sqrt(gamma-1.))*F2 - 0.5f;\n\n    return( max(lambda,0.) );\n}\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n\n\n\nvec3 render(in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy)\n{\n   vec2  mouse = clamp(iMouse.xy / iResolution.xy ,0.,1.);\n   float roughness = remap(clamp( mouse.x , 0., 1. ) , 0.01, 1., 0.1, 0.5);\n   float gamma = remap(clamp( mouse.y , 0., 1. ) , 0.01, 1., MIN_GAMMA, MAX_GAMMA);\n    \n   vec3  color = get_background_color(rd);\n\n   int id = -1;\n   float tmin = 1e10;\n   float occlusion = 1.;\n   vec3 pos = vec3(0.);\n   vec3 nor = vec3(0.);\n   vec3 alb = vec3(0.5);\n\n   float plane_hit = plane_get_hit(ro,rd,PLANE);\n   if(plane_hit > 0.0)\n   {\n      \ttmin = plane_hit;\n      \tid = 0;\n      \tpos = ro+plane_hit*rd;\n      \tnor = PLANE.xyz;\n      \tocclusion = 1. - sphere_occlusion(pos,nor,SPHERE);\n\n      \tvec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n      \tvec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n      \tfloat checker = checkersGradBox( pos.xz, dpdx.xz, dpdy.xz );\n      \tcolor = render_plane(pos,nor,rd,vec3(checker),occlusion);\n\t}\n\n   float sphere_hit = sphere_get_hit(ro,rd,SPHERE);\n   if(sphere_hit> 0.0 && sphere_hit<tmin) \n   {\n      \tid = 1;\n      \ttmin = sphere_hit;\n      \tpos = ro + sphere_hit * rd;\n      \tnor = sphere_get_normal(pos,SPHERE);\n      \tocclusion = 0.5+0.5*nor.y;\n      \n      \t// now it's time to procedurally texturing the sphere\n       \n      \t// Using JFig logo as a mask\n      \tvec2 uv = vec2( 0.5 + atan(nor.x,nor.z)/m_2_pi , 0.5 - asin(-nor.y) / m_pi ); // Using sphere uv mapping (and reverse the normal y to flip the logo)\n      \tvec2 id = floor(uv*3.);\n       \tvec2 coords = fract(uv*3.) * vec2(JFIGW, JFIGH) * when_eq(id.y,1.);\n\n      \t// noise parameters \n      \tfloat pulse = 1.+cos(iTime);\n      \tvec2 freq = 2.5 + vec2(0,pulse);\n      \tvec2 orient = vec2(iTime,0.0);\n\n      \tfloat mask = smoothstep(0.0,1.0,0.5+0.3*cos(0.5*iTime));\n      \tif( jfig(uint(coords.x),uint(coords.y)) )\n      \t{\n        \tmask = 1.0;\n      \t}\n      \n       \tfloat noise = simplex_solid_random_phasor_noise( pos*5., 5, freq, orient, 1., 1.-mask);\n      \n      \n\t\talb = pow( hsv2rgb(vec3(0.5+0.5*cos(0.1*iTime),0.6,0.95)) , vec3(2.2));\n      \talb *= noise;\n      \n   }\n\n   if(id > 0)\n   {\n      \t// World Space \n      \tvec3 P = pos;\n      \tvec3 N = nor;   \n      \tvec3 L = get_light_direction();\n      \tvec3 V = -rd;\n      \tvec3 R = reflect(rd,nor);\n      \t// Tangent Space\n      \tmat3 TBN   = orthonormal_basis(N);\n      \tmat3 TBN_t = transpose(TBN);\n      \tvec3 wo = normalize(TBN_t * V);\n      \tvec3 wi = normalize(TBN_t * L);\n      \tvec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n      \tvec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)  \n\n      \tfloat wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n      \tfloat wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n      \n \t\t//-- Filament BRDF parametrization\n      \t//-- Single scattering\n      \t//-- diffuse lambertian term + specular term\n      \tfloat alpha = roughness*roughness;\n      \tvec3  base_color  = alb;\n      \tvec3  F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;    \n\t\tvec3  F = fresnel_schlick(wi_dot_wh,F0);\n      \n      \t//-- Sun Lighting\n      \tfloat lambda_wo = lambda_student_t_isotropic(wo,alpha,gamma);\n      \tfloat lambda_wi = lambda_student_t_isotropic(wi,alpha,gamma);\n      \tfloat D = ndf_student_t_isotropic(wh,alpha,gamma);\n      \tfloat G = 1. / (1. + lambda_wo + lambda_wi);    \n      \n      \tvec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ; \n      \tvec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n      \n      \tvec3 sun = wg_dot_wi * (diffuse_lambert + specular_microfacet);\n       \n      \t// fake ambiant term\n      \tcolor = 0.05*occlusion*alb;\n      \t// fake bounce shading term\n      \tcolor += F*m_i_pi*texture(iChannel0,N,alpha*20.).rgb;\n      \t// microfacet sun shading term\n      \tcolor += sun;  \n   \n   }\n   color = apply_fog(color,get_background_color(rd),tmin);\n   return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   float speed = 0.3*iTime;\n   float radius = 3.;\n   \n   vec3 ro = vec3( radius * cos(speed), 0.25 , radius * sin(speed) );\n   vec3 ta = vec3(0.,-0.25,0.);\n\n   vec2 p  = (2.*(fragCoord              )-iResolution.xy)/iResolution.y;\n   vec2 px = (2.*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n   vec2 py = (2.*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n\n   vec3 rd = compute_camera_ray_direction(p, ro, ta, 0.);\n   vec3 rdx = compute_camera_ray_direction(px, ro, ta, 0.);\n   vec3 rdy = compute_camera_ray_direction(py, ro, ta, 0.);\n\n   fragColor = vec4( render(ro,rd, rdx, rdy) , 1.);\n   fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-----------------------------------------------------------------------------\n//-- Noise User Parameters ----------------------------------------------------------\nconst uint  LRPN_GLOBAL_SEED \t= 0u;\nconst int   LRPN_COSINES \t\t= 5;\nconst float LRPN_SCALE_FREQ \t= 10.;\nconst float LRPN_SCALE_SPACE \t= 1.;\nconst float LRPN_MAGNITUDE \t\t= 1.;\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359; \nconst float m_pi_2      = 1.5707963267; \nconst float m_2_pi      = 6.2831853071; \nconst float m_i_pi      = 0.31830988618; \nconst float m_sqrt_2    = 1.41421356237;\nconst float m_i_sqrt_2  = 0.70710678119; \n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;  \n\nconst bool  USE_DIFFUSE_TERM = true;\nconst vec4  SPHERE = vec4(0.,0.,0.,1.);\nconst vec4  PLANE  = vec4(0.,1.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-1.5,1.5,0.1));\nconst vec3  BACKGROUND_COLOR = vec3(0.5,0.6,1.0);\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat get_light_intensity()            { return LIGHT_INTENSITY; }\nvec3  get_light_direction()            { return LIGHT_DIRECTION; }\nvec3  get_background_color(in vec3 rd) { return BACKGROUND_COLOR; }\n\n//-----------------------------------------------------------------------------\n//-- Utils --------------------------------------------------------------------\nfloat remap(float v, float oldmin, float oldmax, float newmin, float newmax)\n{\n \treturn( newmin + (v-oldmin) * (newmax-newmin)/(oldmax-oldmin)  );   \n}\n\nfloat when_eq(float x,float y)\n{\n    return(1.0-abs(sign(x-y)));\n}\n\n// from iq's HSV and HSL (https://www.shadertoy.com/view/lsS3Wc)\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0.f, 1.f - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.f) ? 1.f : clamp(w.x / sin_theta(w), -1.f, 1.f);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.f) ? 0.f : clamp(w.y / sin_theta(w), -1.f, 1.f);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n          \n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n   return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n// from @nimitz's \"Cheap orthonormal basis\" on Shadertoy (https://www.shadertoy.com/view/4sSSW3)\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n   vec3 oc = ro - sph.xyz;\n   float b = dot( oc, rd );\n   float c = dot( oc, oc ) - sph.w*sph.w;\n   float h = b*b - c;\n   if( h<0.0 ) return(-1.0);\n   h = sqrt( h );\n   return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n   return normalize(pos-sph.xyz);\n}\n\nfloat sphere_soft_shadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n   vec3 oc = ro - sph.xyz;\n   float b = dot( oc, rd );\n   float c = dot( oc, oc ) - sph.w*sph.w;\n   float h = b*b - c;\n   \n   float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n   float t = -b - sqrt( max(h,0.0) );\n   return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t ); \n} \n\nfloat sphere_occlusion(vec3 pos, vec3 nor, vec4 sph )\n{\n   vec3  di = sph.xyz - pos;\n   float l  = length(di);\n   float nl = dot(nor,di/l);\n   float h  = l/sph.w;\n   float h2 = h*h;\n   float k2 = 1.0 - h2*nl*nl;\n\n   float res = max(0.0,nl)/h2;\n   if( k2 > 0.0 ) // approx. for penetration\n   {\n      res = clamp(0.5*(nl*h+1.0)/h2,0.0,1.0);\n      res = sqrt( res*res*res );\n   }\n   return res;\n}\n\n//-----------------------------------------------------------------------------\n//-- Plane Intersection Functions --------------------------------------------\nfloat plane_get_hit(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n   return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\nvec3 plane_get_normal(in vec4 plane)\n{\n   return(plane.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Procedural Checkerboard --------------------------------------------------\n// from IQ's https://iquilezles.org/articles/checkerfiltering\nfloat checkers( in vec2 p )\n{\n    vec2 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n//-----------------------------------------------------------------------------\n//-- Simple fog ---------------------------------------------------------------\nvec3 apply_fog(vec3 color, vec3 skycolor, float dist)\n{\n\treturn mix( color, skycolor, vec3( 1.0-exp( -0.0001*dist*dist*dist)) );\n}\n\n//-----------------------------------------------------------------------------\n//-- Shading ------------------------------------------------------------------\nvec3 diffuse_shading_sky(in vec3 V, in vec3 N, in vec3 albedo)\n{\n   return clamp(dot(N,vec3(0.,1.,0.)),0.0,1.0)*m_i_pi*albedo*get_background_color(V);\n}\n\nvec3 diffuse_shading_sun(in vec3 V, in vec3 N, in vec3 L, in vec3 albedo)\n{\n   vec3 diffuse  = clamp( dot(N,L), 0.0, 1.0 ) * m_i_pi * albedo; \n   return diffuse;\n}\n\nvec3 render_plane(vec3 P, vec3 N, vec3 rd, vec3 alb, float occ)\n{\n\tvec3 L = get_light_direction();\n    vec3 color = 0.05*occ*alb;\n    color += diffuse_shading_sky(rd,N,alb) * sphere_soft_shadow( P+m_eps_4f*N, N, SPHERE, 1.0 );\n    color += diffuse_shading_sun(rd,N,L,alb) * sphere_soft_shadow( P+m_eps_4f*N, L, SPHERE, 2.0 );\n\treturn(color);\n}\n\n//-----------------------------------------------------------------------------\n//-- Student t utils ----------------------------------------------------------\nfloat abgam(float x)\n{\n  float gam0 = 1./ 12.;\n  float gam1 = 1./ 30.;\n  float gam2 = 53./ 210.;\n  float gam3 = 195./ 371.;\n  float gam4 = 22999./ 22737.;\n  float gam5 = 29944523./ 19733142.;\n  float gam6 = 109535241009./ 48264275462.;\n  float temp = 0.5*log(2.f*m_pi) - x + (x - 0.5)*log(x)\n    + gam0/(x + gam1/(x + gam2/(x + gam3/(x + gam4 /\n      (x + gam5/(x + gam6/x))))));\n\n  return temp;\n}\n\nfloat Gamma_Approx(float x)\n{\n  return( exp(abgam (x + 5.))/(x*(x + 1.)*(x + 2.)*(x + 3.)*(x + 4.)) );\n}\n\nfloat F_21(float nu)\n{\n    float nu_2  = nu*nu; \n    float nu_3  = nu*nu_2;\n    return(\n           (1.066*nu + 2.655*nu_2 + 4.892*nu_3)\n    / //---------------------------------------------------------------\n        ( 1.038 + 2.969*nu + 4.305*nu_2 + 4.418* nu_3)\n    ); \n}\n\nfloat F_24(float nu)\n{\n    float nu_2  = nu*nu; \n    float nu_3  = nu*nu_2;\n    return(\n          (6.537 + 6.074*nu - 0.623*nu_2 + 5.223*nu_3)\n    / //---------------------------------------------------------------\n          (6.538 + 6.103*nu - 3.218*nu_2 + 6.347*nu_3)\n    ); \n}\n\nfloat F_22(float gamma)\n{\n    float gamma_2  = gamma*gamma; \n    float gamma_3  = gamma*gamma_2; \n    return(\n           (14.402 - 27.145*gamma + 20.574*gamma_2 - 2.745*gamma_3)\n    / //---------------------------------------------------------------\n        ( -30.612 + 86.567*gamma - 84.341*gamma_2 + 29.938* gamma_3)\n    ); \n}\n\nfloat F_23(float gamma)\n{\n    float gamma_2  = gamma*gamma; \n    float gamma_3  = gamma*gamma_2; \n    return(\n           (-129.404 + 324.987*gamma - 299.305*gamma_2 + 93.268*gamma_3)\n    / //---------------------------------------------------------------\n          ( -92.609 + 256.006*gamma - 245.663*gamma_2 + 86.064* gamma_3)\n    ); \n}\n\n//----------------------------------------------------------------------------------\n// PRNG ----------------------------------------------------------------------------\n\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Galerne et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\nuint  wang_hash(uint seed)                                      {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)         {const uint period=1024u; uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  cell_seed(const in ivec3 c, const in uint offset)         {const uint period=1024u; uint s=(((((uint(c.z)%period)*period)+(uint(c.y)%period))*period)+(uint(c.x)%period))+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                      {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                          {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma){return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Profile Functions ----------------------------------------------------------------------------------- \n//-- From Thibault Tricard source : https://www.shadertoy.com/view/wlsXWf\nfloat PWM(float x, float r) {return mod(x,m_2_pi)> m_2_pi *r ? 1.0 : 0.0;}\n\n//-----------------------------------------------------------------------------\n//-- Simplex Solid LRPN Code --------------------------------------------------\nfloat gaussian_window_3D(in vec3 st, in float c, in float s)\n{\n   mat3 sig = mat3(s);\n   float body = -0.5*dot(st,inverse(sig)*st);\n   return c*exp(body);\n}\n\nvec2 local_random_phase_noise(\n    \tin ivec3 vertex_index,\n    \tin vec3  noise_coords,\n    \tin int   nof_cosines,\n    \tin vec2  range_frequency,\n        in vec2  range_orientation,\n    \tin float window_magni,\n    \tin float window_width\n\t)\n{\n   uint seed    = cell_seed(vertex_index,LRPN_GLOBAL_SEED);\n   uint prng    = wang_hash(seed);\n\n   vec2 sc = vec2(0.); \n   for(int k=0; k<nof_cosines; k++)\n   {\n      float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y); \t // pick a frequency \n      float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y); // pick an orientation\n      float ph = myrand_uniform_0_1(prng)*m_2_pi; // pick a phase (shift)\n  \n      float omega_r = fr;\n      float omega_t = or;\n      float omega_p = acos(myrand_uniform_0_1(prng)*2.-1.);\n      vec3 F = omega_r * vec3(cos(omega_t) * sin(omega_p), sin(omega_t) * sin(omega_p), cos(omega_p));\n      \n      sc.x +=  cos(m_2_pi* dot(F, noise_coords) + ph);\n      sc.y +=  sin(m_2_pi* dot(F, noise_coords) + ph);\n   }\n   return gaussian_window_3D(noise_coords,window_magni,window_width) * sc / float(nof_cosines);\n}\n\nfloat simplex_solid_random_phasor_noise(\n    \tin vec3  P, // Evaluation Point\n    \tin int   C, // Number of Cosines\n    \tin vec2  F, // Frequency Range (freq_min ; freq_max) \n    \tin vec2  O, // Orientation Range (theta_min ; theta_max)\n    \tin float K,  // Gaussian Window Magnitude\n      in float mask\n\t)\n{\n   const float F3 = 0.333333333; /* -> 1/3 */\n   const float G3 = 0.166666667; /* -> 1/6 : distance edge-to-edge of the simplex grid */\n   /* i think it should tend to 1/6*1/3 to reach zero at the width of the gaussian window (3*\\sigma ~ 0)*/\n   /* but i chose a narrower width because of some tetrahedral artefacts...*/\n   const float WW = 0.03;\n   \n   vec3 i = floor(P + (P.x + P.y + P.z) * F3);\n   vec3 d0 = P - (i - (i.x + i.y + i.z) * G3);\n   vec3 e = step(vec3(0.0), d0 - d0.yzx);\n   vec3 i1 = e * (1.0 - e.zxy);\n   vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n   \n   vec3 d1 = d0 - (i1 - 1. * G3);\n   vec3 d2 = d0 - (i2 - 2. * G3);\n   vec3 d3 = d0 - (1. - 3. * G3);   \n   \n   vec2 n0 = local_random_phase_noise(ivec3(i + 0.), d0, C, F, O, K, WW);\n   vec2 n1 = local_random_phase_noise(ivec3(i + i1), d1, C, F, O, K, WW);\n   vec2 n2 = local_random_phase_noise(ivec3(i + i2), d2, C, F, O, K, WW);\n   vec2 n3 = local_random_phase_noise(ivec3(i + 1.), d3, C, F, O, K, WW);\n   vec2 N = n0+n1+n2+n3;\n\n   float Phi = atan(N.y,N.x);\n   return( PWM(Phi,mask) );\n}\n\n/* Beware Neyret2 is watching you ! */",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n   vec2  mouse = clamp(iMouse.xy / iResolution.xy ,0.,1.);\n   float roughness = clamp( 0.01 + mouse.x , 0., 0.5 );\n   float gamma = 1.51 + clamp( 0.01 + mouse.y , 0., 1. )*5.;\n\n   //vec3 color = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n   vec3 color = get_background_color(rd);\n\n   int id = -1;\n   float tmin = 1e10;\n   float occlusion = 1.;\n   vec3 pos = vec3(0.);\n   vec3 nor = vec3(0.);\n   vec3 alb = vec3(0.5);\n\n   float plane_hit = plane_get_hit(ro,rd,PLANE);\n   if(plane_hit > 0.0)\n   {\n      tmin = plane_hit;\n      id = 1;\n      pos = ro+plane_hit*rd;\n      nor = PLANE.xyz;\n      float checker = checkers( pos.xz );\n      alb = vec3(checker);\n   }\n\n   if(id >= 0)\n   {\n      color = render_plane(pos,nor,rd,alb,occlusion);\n   }\n   color = apply_fog(color,get_background_color(rd),tmin);\n   return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainCubemap( out vec4 fragColor,  in vec2 fragCoord, \n                  in vec3  fragRayOri, in vec3 fragRayDir )\n{  \n  \tif(iFrame>1)\n   \t{\n       discard;\n   \t}\n    \n   fragColor = vec4( render(fragRayOri,fragRayDir) , 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}