{
    "Shader": {
        "info": {
            "date": "1649633096",
            "description": "Crystal Computers II  // Splitting space and folding it - moving a pseudo retro tape drive in that space - then unfold to view. \n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Ns3XR4",
            "likes": 24,
            "name": "Crystal Computers II",
            "published": 3,
            "tags": [
                "crystalcomputers"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    4/10/22 @byt3_m3chanic\n    Crystal Computers II\n\n    I like the whole glass/transparent thing a lot - rocking \n    my refraction loop (thanks @blackle). I love those little\n    plastic boxes / transparent containers - project boxes. so\n    thats where this kind of comes from - more just playing\n    visually.\n    \n    Technically its just a of folds and a version of a retro \n    pseudo tape drive [IBM style]\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\nmat2 rot (float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nfloat lsp(float begin, float end, float t) {return clamp((t-begin)/(end-begin),0.,1.);}\nfloat eoc(float t) {return (t=t-1.)*t*t+1.;}\n\n// http://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p) {\n    const float angle = 2.*PI/3.;\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (3./2.)) ? abs(c) : c;\n} \n\n// The Folds\nvoid tet(inout vec4 p) {\n\tp = abs(p);\n\tif (p.x < p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x > p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x < p.z) p.xz = p.zx; p.x = -p.x;\n\tif (p.x > p.z) p.xz = p.zx; p.x = -p.x;\n}\nvoid sep(inout vec4 p){\n\tif (p.x + p.y<0.) p.xy = -p.yx;\n\tif (p.x + p.z<0.) p.xz = -p.zx;\n\tif (p.y + p.z<0.) p.zy = -p.yz;\n}\n//@iq thanks for the sdf's!\nfloat cap( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat sdbox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.))+min(max(p.x,max(q.y,q.z)),0.),\n      length(max(vec3(q.x,p.y,q.z),0.))+min(max(q.x,max(p.y,q.z)),0.)),\n      length(max(vec3(q.x,q.y,p.z),0.))+min(max(q.x,max(q.y,p.z)),0.));\n}\n\n//globals\nmat2 tprot,rx,ry,mmt1,mmt2,mmt3,gr;\nvec3 hit=vec3(0);vec3 hitPoint=vec3(0);\nfloat tmod,ga1,ga2,ga3,ga4,ga5,tt;\n\nconst float size = 35.;\nconst float hlf = size/2.;\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n    \n    p.xz*=gr;\n    vec4 P = vec4(p.xyz,1.);\n    tet(P);\n\n    vec3 q = P.xyz; \n    q.y-=3.;\n    q.yz*=mmt1;\n    q.x=abs(q.x)-(2.75+(3.*ga3)+ga4);\n    q.zx*=mmt2;\n    q.z=abs(q.z)-(2.-(2.25*ga1));\n    q.yx*=mmt3;\n\n    float mainbox = sdbox(q-vec3(0,1.1,0),vec3(1.5,3,.75));\n    float cutbox =  sdbox(q-vec3(.45,1.25,.775),vec3(.85,2.5,1.1));\n    mainbox = max(mainbox, -cutbox);\n\n    float frame2 = sdframe(q-vec3(0,1.1,0),vec3(1.6,3.1,.82),.075)-.0125;\n    if(frame2<res.x) res = vec2(frame2,4.);\n    float frame = sdbox(q-vec3(-.3,1.3,.7),vec3(.445,1.35,.05));\n    float tapeB = cap(vec3(q.y,q.z,abs(q.x))-vec3(2.8,.55,.65),.225,.1);\n    tapeB = min(  cap(vec3(q.y,q.z,abs(q.x))-vec3(1.95,.5,.65),.100,.1),tapeB);\n\n    vec3 tq1 = q.yzx-vec3(2.9,.25,.55);\n    tq1.x=abs(abs(tq1.x+1.65)-1.2)-.6;\n    frame = min(cap(tq1+vec3(0,.35,0),.25,.5),frame);\n    vec3 pq1 = tq1;\n    pq1.xz*=tprot;\n    modPolar(pq1.xz);\n    float tcbx = sdbox(pq1-vec3(.4,0,0),vec3(.09,.09,.075));\n    \n    float tape1 = cap(tq1,.575,.05);\n    tape1=max(tape1,-tcbx);\n    if(tape1<res.x) res = vec2(tape1,3.);\n\n    vec3 bq = q-vec3(-.9,3,.65);\n    bq.y=abs(abs(abs(bq.y)-.4)-.2)-.1;\n    bq.x=abs(bq.x)-.2;\n    float btn1 = sdbox(bq,vec3(.15,.05,.25))-.0125;\n    btn1 = min(sdbox(q-vec3(-.5,1.25,.85),vec3(.45,.3,.06))-.0125,btn1);\n    if(btn1<res.x) res = vec2(btn1,2.);\n    \n    mainbox = min(mainbox, frame);\n    if(mainbox<res.x) res = vec2(mainbox,1.);\n\n    res.x/=P.w;\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist) {\n    t*=mindist;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n) \n{\n    \n    n = normal(p,d,1.);\n    vec3 lpos =  vec3(3,10,-8);\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),0.,1.);\n\n    vec3 h = vec3(.3);\n    \n    if(m==1.) {\n        vec3 h2 =mix(vec3(.05),vec3(.4),clamp((p.y+1.)*.25,0.,1.));\n        h=mix(h2,vec3(.1),clamp((p.z+4.)*.1,0.,1.));\n    }\n\n    if(m==2.) {\n        vec3 h2=mix(vec3(.596,.110,.690),vec3(.961,.000,.094),clamp((p.x+2.)*.07,0.,1.));\n        h=mix(vec3(.600,0.525,0.039),h2,clamp((p.z+2.)*.07,0.,1.));\n    }\n    if(m==3.) {\n        vec3 h2 =mix(vec3(.000,.639,.514),vec3(.698,.608,.165),clamp((p.x+4.)*.1,0.,1.));\n        h=mix(h2,vec3(.871,.169,.847),clamp((p.y+3.)*.1,0.,1.));\n    }\n    if(m==4.) {\n        vec3 h2 =mix(vec3(.5),vec3(.1),clamp((p.y+1.)*.25,0.,1.));\n        h=mix(h2,vec3(.01),clamp((p.z+4.)*.1,0.,1.));\n    }\n    return diff*h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n    tprot=rot(T*3.);\n    tmod = mod(time,24.);\n\n    float t1 = lsp(1.,4.,tmod);\n    float t2 = lsp(8.,10.,tmod);\n    float t3 = lsp(4.,7.,tmod);\n    float t4 = lsp(12.,16.,tmod);\n    float t5 = lsp(4.,6.,tmod);\n    float t6 = lsp(8.,10.,tmod);\n    float t7 = lsp(3.,12.,tmod);\n    float t8 = lsp(15.,16.,tmod);\n    \n    ga1 = eoc(t1-t2);ga1 = ga1*ga1*ga1;\n    ga2 = eoc(t3-t4);ga2 = ga2*ga2*ga2;  \n    ga3 = eoc(t5-t6);ga3 = ga3*ga3*ga3;  \n    ga4 = eoc(t7-t8);ga4 = ga4*ga4*ga4;\n\n    tt = time*.167;\n    mmt1=rot(ga1*PI-tt);\n    mmt2=rot((ga1+ga2)*PI);\n    mmt3=rot(ga3*PI+tt);\n    gr=rot(ga1+ga2+ga3+ga4+T*.125);\n    \n    // set UV's\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(.0075);\n    \n    // to make thigns fun faster and being\n    // isometric and all - clipping the center\n    if(uv.x<.65&&uv.x>-.65){\n\n        //orthographic camera\n        const float zoom = 17.;\n        vec3 ro = vec3(uv*zoom,-zoom);\n        vec3 rd = vec3(0,0,1.);\n\n        rx = rot(-.78);\n        ry = rot( .78*sin(tt*.5));\n\n        ro.yz *= rx; ro.xz *= ry;\n        rd.yz *= rx; rd.xz *= ry;\n\n        vec3  p = ro + rd;\n        float atten = 1.;\n        float k = 1.;\n        float d = 0.;\n        float iv = 1.;\n        for(int i=0;i<128;i++)\n        {\n            vec2 ray = map(p);\n            vec3 n=vec3(0);\n            float m = ray.y;\n\n            d = i<32 ? ray.x*.5 : ray.x;\n            p += rd * d *k;\n    \n            if (d*d < 1e-7) {\n\n                C+=render(p,rd,ro,d,ray.y,n)*atten;\n\n                atten *= .575;\n                p += rd*.025;\n                k = sign(map(p).x);\n\n                if(m== 3.) {\n                    rd=reflect(-rd,n);\n                    p+=n*.01;\n                } else {\n                    vec3 rf=refract(rd,n,iv > 0. ? .85 : .1);\n                    iv *= -1.;\n                    if(length(rf) == 0.) rf = reflect(rd,n);\n                    rd=rf;\n                    p+=-n*.1;\n                }\n            } \n\n            if(distance(p,rd)>125.) { break; }\n        }\n\n    }\n \n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.5 ? C+.005 : C;\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}