{
    "Shader": {
        "info": {
            "date": "1636991074",
            "description": "its hot",
            "flags": 0,
            "hasliked": 0,
            "id": "sttGWs",
            "likes": 4,
            "name": "Hot Stuff 2",
            "published": 3,
            "tags": [
                "ray",
                "displacement",
                "sphere"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(1, 1);\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n//iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) \n{\n    vec2 uv = (fragCoord.xy/iResolution.xy)-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    float y = (((iMouse.y)/(iResolution.y))*3.14)+0.01;\n    ro = vec3(\n        cos(iMouse.x*0.01)*sin(y),\n        sin(iMouse.x*0.01)*sin(y),\n        cos(y)\n    );\n        ro *= 3.;\n    vec3 at = vec3(0.0);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 0, 1), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.1 * cam_z);\n}\nvec2 sphere(in vec3 ro, in vec3 rd, in vec3 ce, in float ra) {\n    vec3 oc = ro-ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b-c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\nvec2 box(in vec3 ro, in vec3 rd, in vec3 size) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n    return vec2(tN, tF);\n}\nbool f(vec3 p) {\n \treturn noise((p*8.)+vec3(iTime, iTime*0.1, iTime*2.0)) < (0.15-(length((p))-1.0))*4.0;//tan((phi+(sin((p.y+(iTime*0.2))*5.0)*1.))*5.) > 2.0;//sin(length(vec2(p.x, p.z))+iTime) > p.y;\n}\nconst float ss = 0.01;\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    vec2 planet = sphere(ro, rd, vec3(0), 1.);\n    vec2 sur = sphere(ro, rd, vec3(0), 1.2);\n    float thru=0.0;\n    if (sur.x != -1.0) {\n        if (sur.x > 0.0) {\n\t        thru = sur.y-sur.x;\n            if (planet.x > 0.0) {\n            \tthru = planet.x-sur.x;\n            }\n        } else {\n        \tthru = sur.y;\n            if (planet.x > 0.0) {\n            \tthru = planet.x;\n            }\n        }\n    }\n    vec3 col = vec3(0);\n    vec3 start = ro+rd*sur.x;\n    if (sur.x < 0.0) {\n    \tstart = ro;\n    }\n    float i;\n    float s = thru*ss;\n    for (i = 0.0; i < thru; i += s) {\n    \tstart += rd*s;\n        if (f(start)) {\n            float of = (length(start)-1.03)*20.;\n            col = vec3(mix(vec3(1.0, 1.0, 0.5), vec3(1.0, 0.4, 0.0), of));\n        \t//col += 0.01;\n            break;\n        }\n    }\n    if (length(start)-1.0 < 0.0001) {\n    \treturn vec3(1.0, 1.0, 0.8);\n    };\n    if (col.x == 0.0) {\n        return vec3(mix(vec3(0.5, 0.0, 0.0), vec3(1.0, 0.9, 0.2), noise(rd*2.0)-0.2));\n    }\n    return vec3(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec3 rd;\n\tvec3 ro;\n    Camera(fragCoord, ro, rd);\n    vec3 c = getColor(ro ,rd);\n    fragColor = vec4(c, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}