{
    "Shader": {
        "info": {
            "date": "1589050283",
            "description": "i recently learned about an algorithm for solving pdes, and after playing around a bit with it i made this. (more info in the code comment)",
            "flags": 32,
            "hasliked": 0,
            "id": "3dfBWj",
            "likes": 8,
            "name": "laser show",
            "published": 3,
            "tags": [
                "2d",
                "montecarlo",
                "laser",
                "pde",
                "wos"
            ],
            "usePreview": 0,
            "username": "unnick",
            "viewed": 752
        },
        "renderpass": [
            {
                "code": "/* i first learned about this algorithm from this shader:\n * https://www.shadertoy.com/view/WsXBzl\n *\n * the algorithm works by basically\n * doing a bunch of random walks\n * and walking until it hits a laser\n * or one of the sides of the buffer,\n * and then it averages the results of these walks.\n *\n * random walks are very slow though, so how can this run\n * at 60 fps (!) on my geforce gt 610? (which was released in 2012!)\n *\n * the answer is simple, it uses an sdf to speed things up!\n * a random walk is equally likely to hit any point\n * of a sphere, so we can skip a bunch of unnecessary steps\n * by just picking a random point on a sphere\n *\n * the method i described above solves the laplace equation,\n * but it can be generalized to solve a lot of other pdes.\n * but if you want to know how that works, go read the original paper :^)\n *\n * http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n * \"Monte Carlo Geometry Processing: A Grid-Free Approach to PDE-Based Methods on Volumetric Domains\"\n * by rohan sawhney and keenan crane\n */\n\n//buffer A: boundary conditions & sdf\n//          xyz = color, w = sdf\n//buffer B: solver (the output is split into 4 quadrants)\n//          xyz = color, w = # of sucessful samples\n//buffer C: merging & smoothing\n//          xyz = color, w = 1\n//this buffer: applying symmetries + displaying\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y;\n    #ifdef symmetric\n    pos = abs(pos);\n    if(pos.y > pos.x) pos.yx = pos.xy;\n    #endif\n    col = texture(iChannel0, (pos * vec2(res.y/res.x, 1.) + 1.) * .5);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float linesdf(vec2 p, vec2 start, vec2 dir) {\n    vec2 p2 = p - start;\n    float h = clamp(dot(p2, dir) / dot(dir, dir), 0., 1.);\n    return length(p2 - h*dir);\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y;\n    \n    col.w = bignum; col.xyz = vec3(0);\n    col.w = min(col.w, (        coord.x) / res.y);\n    col.w = min(col.w, (res.x - coord.x) / res.y);\n    col.w = min(col.w, (        coord.y) / res.y);\n    col.w = min(col.w, (res.y - coord.y) / res.y);\n    \n    /*#ifdef symmetric\n    pos = abs(pos);\n    if(pos.y > pos.x) pos.yx = pos.xy;\n    #endif*/\n    #ifdef symmetric\n    if(pos.y > pos.x + eps) discard;\n    if(pos.y < 0.) discard;\n    #endif\n    \n    int lrng = hash(int(iTime * laser_chspeed + laser_choffs));\n    int crng = hash(int(iTime * color_chspeed) ^ 0x80000000);\n    int frng = hash(int(iFrame) ^ 0xC0000000);\n    for(int i = 0; i < laser_num; i++) {\n        float tmp = rand1f(lrng) * tau;\n        float rot = (float(rand(lrng) >> 30) * 2. - 1.) * laser_speed;\n        float fft_ch = rand1f(lrng);\n        float amp = pow(texture(iChannel0, vec2(fft_ch,0)).x, fft_adjust);\n        \n        #ifdef symmetric\n        vec2 start = rand2f(lrng);\n        #else\n        vec2 start = (rand2f(lrng) * 2. - 1.) * vec2(res.x/res.y, 1.);\n        #endif\n        \n        vec2 dir = cossin(tmp + iTime * rot) * mix(amp*fft_laser_len, laser_base_len, fft_baselen_mix);\n        \n        vec3 lcol  = vec3(rand2f(crng), 1).xzy;\n        lcol *= laser_brightness + amp * fft_brightness_factor;\n        \n        float ldist = linesdf(pos, start, dir) - eps;\n        if(ldist < col.w) {\n            col.w = ldist;\n            col.xyz = lcol;\n        }\n    }\n    \n    col.w *= .95;\n    col.w -= eps;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 20,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//constants\n\n#define tau 6.283\n#define res iResolution.xy\n#define ires ivec2(res)\n#define eps (1.5/res.y)\n#define bignum 1e4\n\n\n\n//parameters\n\n#define symmetric\n#define laser_num 32\n\n#define laser_brightness .5\n\n//laser beam rotation rate\n//lower = slower\n#define laser_speed 5.\n\n//speed of light decay\n//lower = faster\n#define laser_decay -15.\n\n//color & laser pos change rate\n//lower = slower\n#define color_chspeed 2.5\n#define laser_chspeed (color_chspeed / 8.)\n//change offset\n#define laser_choffs (-1./16.)\n\n#define fft_adjust 3.\n#define fft_brightness_factor 2.\n#define fft_laser_len 2.\n#define laser_base_len .3\n#define fft_baselen_mix .3\n\n//lower = better quality, but slightly slower\n#define render_darkness_cutoff -2.\n\n#define render_samples 16\n#define render_max_steps 32\n\n#define render_block_offs 2\n#define render_block_size 5\n\n\n\n//functions\n\n#define unsplitFetch(ch, pos) texelFetch(ch, ((pos) >> 1) + ((pos) & 1) * (ires >> 1), 0)\n\nvec2 cossin(float a) {\n    return vec2(cos(a), sin(a));\n}\n\nint hash(int x) {\n    x ^= 0x4AB10B90;\n    x *= 0x5F02BC5D;\n    x ^= x >> 16;\n    x *= 0xE3105FD3;\n    x ^= x >> 16;\n    return x;\n}\n\nint hash4(ivec4 v) {\n    return hash(v.x ^ hash(v.y) ^ hash(v.z ^ hash(v.w)));\n}\n\nint rand(inout int x) {\n    x *= 0xB315C74D;\n    x += 0x7B1922B9;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand1f(inout int x) {\n    return (float(rand(x) >> 7) + .5) / 16777216.;\n}\n\nvec2 rand2f(inout int x) {\n    vec2 vec;\n    vec.x = rand1f(x);\n    vec.y = rand1f(x);\n    return vec;\n}\n\nvec3 rand3f(inout int x) {\n    vec3 vec;\n    vec.x = rand1f(x);\n    vec.y = rand1f(x);\n    vec.z = rand1f(x);\n    return vec;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 sdf(vec2 p) {\n    #ifdef symmetric\n    p = abs(p);\n    if(p.y > p.x) p.yx = p.xy;\n    #endif\n    return texture(iChannel0, (p * vec2(res.y/res.x, 1.) + 1.) / 2.);\n}\n\n/*vec4 sdf(vec2 p) {\n    vec4 col;\n    col.x = normalize(p).x * .5 + .5;\n    col.yz = vec2(sin(sin(sin(p*tau)*tau)*tau));\n    //col.xyz = vec3(1);\n    col.w = length(p) - .5;\n    float dist = 10000.;\n    dist = min(dist, p.y + 1.);\n    dist = min(dist, 1. - p.y);\n    dist = min(dist, p.x + res.x/res.y);\n    dist = min(dist, res.x/res.y - p.x);\n    col.w = min(col.w, dist);\n    if(dist < .01) col.xyz = vec3(0);\n    return col;\n}*/\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    ivec2 ipos = ivec2(coord);\n    ivec2 shuffled;\n    shuffled.x = (ipos.x<<1) % ires.x + ((ires.x & 1) ^ 1) * (ipos.x > (ires.x>>1) ? 1 : 0);\n    shuffled.y = (ipos.y<<1) % ires.y + ((ires.y & 1) ^ 1) * (ipos.y > (ires.y>>1) ? 1 : 0);\n    \n    vec2 pos = (vec2(shuffled) * 2. + 1. - res) / res.y;\n    #ifdef symmetric\n    if(shuffled.y - (ires.y >> 1) > shuffled.x - (ires.x >> 1) + 1) discard;\n    if(shuffled.y - (ires.y >> 1) < 0) discard;\n    #endif\n    \n    col = vec4(0,0,0,.01); // xyz = color, w = sample count\n    for(int samp = 0; samp < render_samples; samp++) {\n        int rng = hash4(ivec4(\n            iFrame,\n            (ivec2(coord) + samp * render_block_offs) >> render_block_size,\n            samp\n        ));\n        vec2 p = pos; float lmul = 0.;\n        for(int i = 0; i < render_max_steps; i++) {\n            vec4 val = sdf(p);\n            float dist = val.w;\n            if(dist < eps) {\n                col += vec4(val.xyz * exp(lmul), 1);\n                break;\n            }\n            if(lmul < render_darkness_cutoff) {\n                col += vec4(0,0,0, 1);\n                break;\n            }\n            p += dist * cossin(rand1f(rng) * tau);\n            lmul += dist*dist * laser_decay;\n            //add += dist*dist;\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//smoothing\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    ivec2 ipos = ivec2(coord);\n    #ifdef symmetric\n    if(ipos.y - (ires.y >> 1) > ipos.x - (ires.x >> 1) + 1) discard;\n    if(ipos.y - (ires.y >> 1) < 0) discard;\n    #endif\n    \n    col  = unsplitFetch(iChannel0, ipos + ivec2(0,0));\n    col += unsplitFetch(iChannel0, ipos + ivec2(1,0));\n    col += unsplitFetch(iChannel0, ipos + ivec2(0,1));\n    col += unsplitFetch(iChannel0, ipos + ivec2(1,1));\n    col /= col.w;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}