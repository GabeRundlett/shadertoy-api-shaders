{
    "Shader": {
        "info": {
            "date": "1568363785",
            "description": "my first shadertoy",
            "flags": 0,
            "hasliked": 0,
            "id": "wd33DH",
            "likes": 4,
            "name": "OOOFF",
            "published": 3,
            "tags": [
                "oof"
            ],
            "usePreview": 0,
            "username": "Bouyer",
            "viewed": 410
        },
        "renderpass": [
            {
                "code": "\nmat3 rot(vec3 angles)\n{   \n    float theta = angles.y;\n    float c = cos(theta);\n    float s = sin(theta);\n    mat3 m = mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    \n    theta = angles.x;\n    c = cos(theta);\n    s = sin(theta);\n    m *= mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n    \n    theta = angles.z;\n    c = cos(theta);\n    s = sin(theta);\n    m *= mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n    \n    return m;\n}\n\nvec3 warp(vec3 p)\n{\n    mat3 m = rot((floor((p + 4.) / 8.) + vec3(0., -1., 0.)) * iTime);\n    \n    vec3 rep = mod(p + vec3(4.), 8.) - vec3(4.);\n    return m * rep;\n}\n\nfloat sdf(vec3 p)\n{\n    p = warp(p);\n    float h2 = 1.;\n    float r = 1.;\n    float inflate = .5;\n    \n    float capDist = max(abs(p.y) - h2, 0.);\n    float sideDist = max(length(p.xz) - r, 0.);\n    return sqrt(pow(sideDist, 2.) + pow(capDist, 2.)) - inflate;\n}\n\nfloat eyeSDF(vec3 p, vec2 eyePos)\n{\n    return length(vec2(2, 1) * (p.xy - eyePos)) - .2;\n}\n\nfloat mouthSDF(vec3 p)\n{\n    float thickness = .05;\n    \n    float ringDist = max(abs(length(p.xy * vec2(1.6, 1)) - 1.) - thickness, 0.);\n    float hideFactor = max(p.y + .4, 0.);\n    \n    \n    return ringDist + hideFactor;\n}\n\nvec3 albedoSDF(vec3 p)\n{\n    p = warp(p);\n    float eyeDist = min(eyeSDF(p, vec2(.33, .7)), eyeSDF(p, vec2(-.33, .7)));\n    eyeDist = min(eyeDist, mouthSDF(p));\n    \n    float factor = clamp(eyeDist * 10., 0., 1.);\n    if (p.z < 0.)\n        factor = 1.;\n    \n    return mix(vec3(0.05, 0.05, 0.1), vec3(1., .85, .2), factor);\n}\n\nvec3 nsdf(vec3 p)\n{\n    vec2 H = vec2(0., 0.01);\n    return normalize(vec3(sdf(p + H.yxx), sdf(p + H.xyx), sdf(p + H.xxy)) - sdf(p));\n}\n\nvec3 lighting(vec3 albedo, vec3 n)\n{\n    float NL = max(dot(n, vec3(1., 1., 1.)), 0.) * .8;\n    return (NL + .1) * albedo;\n}\n\nmat3 view()\n{\n    return rot(.02 * vec3(sin(iTime * .5672), sin(iTime * .1414), sin(iTime * 0.114) * 0.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\t\n    vec3 O = vec3(0., mod(-iTime * 20., 64.) * 0., 5.);\n    vec3 D = view() * normalize(vec3(uv.x, uv.y, -1.));\n    \n    float l = 0.0;\n    vec3 p;\n    float d;\n    for (int i = 0; i < 100; i++)\n    {\n        p = O + D * l;\n        d = sdf(p);\n        l += d;\n    }\n    \n    vec3 n = nsdf(p);\n    vec3 albedo = albedoSDF(p);\n    \n    if (d > .01)\n        fragColor = vec4(0.);\n    else\n    \tfragColor = vec4(lighting(albedo, n), 1.0);\n    \n    float fogFactor = clamp(l / 100., 0., 1.);\n    fragColor = mix(fragColor, vec4(0.), fogFactor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}