{
    "Shader": {
        "info": {
            "date": "1587506447",
            "description": "Basic implementation of Frostbite's material + relevant sampling strategies.\nCamera controls via mouse + shift key.\n\nhttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf",
            "flags": 48,
            "hasliked": 0,
            "id": "wsScWt",
            "likes": 66,
            "name": "Frostbite Material Render-Ref",
            "published": 3,
            "tags": [
                "globalillumination",
                "pathtracing",
                "mis",
                "pbr",
                "ggx",
                "multipleimportancesampling",
                "frostbite"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 2467
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nBasic implementation of Frostbite's material + relevant sampling strategies.\nCamera controls via mouse + shift key.\n\nReferences:\n\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\thttps://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\nThe bulk of the material specific code is in the Common tab; direct light sampling routines + rendering in BufferA. Tonemapping in Image.\n*/\n\n\n#if 1\nvec4 cubic2(float x)\n{\n\tfloat x2 = x * x;\n\tfloat x3 = x2 * x;\n\tvec4 w;\n\tw.x = -x3 + 3.0f * x2 - 3.0f * x + 1.0f;\n\tw.y = 3.0f * x3 - 6.0f * x2 + 4.0f;\n\tw.z = -3.0f * x3 + 3.0f * x2 + 3.0f * x + 1.0f;\n\tw.w = x3;\n\treturn w / 6.0f;\n}\n\nvec4 SampleCubic(vec2 mPos)\n{    \n\tmPos -= 0.5f;\n\n\tvec2 fuvw = fract(mPos);\n\tmPos -= fuvw;\n\n\tvec4 cubicX = cubic2(fuvw.x);\n\tvec4 cubicY = cubic2(fuvw.y);\n\n\tvec2 cX = mPos.xx + vec2(-0.5f, 1.5f);\n\tvec2 cY = mPos.yy + vec2(-0.5f, 1.5f);\n\n\tvec2 sX = cubicX.xz + cubicX.yw;\n\tvec2 sY = cubicY.xz + cubicY.yw;\n\n\tvec2 offsetX = cX + cubicX.yw / sX;\n\tvec2 offsetY = cY + cubicY.yw / sY;\n\n\tvec4 value0;\n\tvec4 value1;\n\tvec4 value2;\n\tvec4 value3;\n\n\tvalue0 = textureLod(iChannel0, vec2(offsetX.x, offsetY.x) / iResolution.xy, 0.0);\n\tvalue1 = textureLod(iChannel0, vec2(offsetX.y, offsetY.x) / iResolution.xy, 0.0);\n\tvalue2 = textureLod(iChannel0, vec2(offsetX.x, offsetY.y) / iResolution.xy, 0.0);\n\tvalue3 = textureLod(iChannel0, vec2(offsetX.y, offsetY.y) / iResolution.xy, 0.0);\n\n\tfloat lX = sX.x / (sX.x + sX.y);\n\tfloat lY = sY.x / (sY.x + sY.y);\n\n\treturn mix(mix(value3, value2, lX), mix(value1, value0, lX), lY);\n}\n#else\nfloat BSpline(float x)\n{\n    bool s = x < 0.0;\n    \n    x = abs(x);\n\n    bool c = x < 1.0;\n    \n    if(!c) x = 2.0 - x;\n    \n    float x2 = x  * x;\n    float x3 = x2 * x;\n\t\n    float r = x3 * (1.0/6.0);\n    \n    if(c) r = r * 3.0 - x2 + 2.0/3.0;\n    \n    return r;\n}\nvec2 BSpline(vec2 v)\n{\n    return vec2(BSpline(v.x), BSpline(v.y));\n}\n\nvec4 SampleCubic(vec2 uv)\n{\n    uv += 0.5;\n    vec2 uv0 = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    vec4 col = vec4(0.0);\n    for(float y = 0.0; y < 4.0; ++y)\n    for(float x = 0.0; x < 4.0; ++x)\n    {\n        vec2 o = vec2(x, y);\n        vec2 w = 1.0 - abs(fuv - o);\n        w = BSpline(fuv - o+1.0);\n        \n    \tcol += texelFetch(iChannel0, ivec2(uv0+o)-2, 0) * (w.x*w.y);\n    }\n    \n    return col;\n}\n#endif\n\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\n\n// ACES fit by Stephen Hill (@self_shadow)\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl \n// more info: https://www.shadertoy.com/view/WltSRB\n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\n// AP1 => RRT_SAT\nconst mat3 RRT_SAT = mat3\n(\n\t0.970889, 0.026963, 0.002148,\n\t0.010889, 0.986963, 0.002148,\n\t0.010889, 0.026963, 0.962148\n);\n\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 ToneTF0(vec3 x)\n{\n    vec3 a = (x            + 0.0509184) * x;\n    vec3 b = (x * 0.973854 + 0.7190130) * x + 0.0778594;\n    \n    return a / b;\n}\n\nvec3 ToneTF1(vec3 x)\n{\n    vec3 a = (x          + 0.0961727) * x;\n    vec3 b = (x * 0.9797 + 0.6157480) * x + 0.213717;\n    \n    return a / b;\n}\n\nvec3 ToneTF2(vec3 x)\n{\n    vec3 a = (x            + 0.0822192) * x;\n    vec3 b = (x * 0.983521 + 0.5001330) * x + 0.274064;\n    \n    return a / b;\n}\n\nvec3 RRTAndODTFit(vec3 x)\n{\n    vec3 a = (x            + 0.0245786) * x;\n    vec3 b = (x * 0.983729 + 0.4329510) * x + 0.238081;\n    \n    return a / b;\n}\n\nvec3 Tonemap_ACESFitted(vec3 srgb)\n{\n    vec3 color = srgb * ACESInputMat;\n   \n   #if 1\n    color = ToneTF2(color);\n   #else\n    color = RRTAndODTFit(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n\n    return color;\n}\n\nvec3 Tonemap_ACESFitted2(vec3 acescg)\n{\n    vec3 color = acescg * RRT_SAT;\n    \n   #if 1\n    color = ToneTF2(color);\n   #else\n    color = RRTAndODTFit(color);\n   #endif\n    \n    color = color * ACESOutputMat;\n\n    return color;\n}\n\nvec3 Tonemap(vec3 col)\n{\n    #if 1\n    #ifdef USE_ACESCG\n\tcol = Tonemap_ACESFitted2(col);\n    #else\n\tcol = Tonemap_ACESFitted(col);\n    #endif\n    #endif\n    \n    col = clamp01(col);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 uv)\n{\n    float exposure = 3.0;\n    \n\tvec2 tex = uv / iResolution.xy;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n\n    col = Tonemap(col * exp2(exposure));\n    \n    #if 1\n    {\n        /* oversample tonemapping; prevents aliased edges around very bright spots/light sources */\n        vec3 fcol = vec3(0.0);\n        vec3 fm = vec3(0.0);\n\n        const uint count = 8u; \n        for(uint i = 0u; i < count; ++i)\n        {\n            vec2 o = Float11(Roberts(uvec2(0u), i));\n            vec2 off = o * 0.75;\n            //off = vec2(Sample_Triangle(o.x), Sample_Triangle(o.y))*1.5;\n\n            //vec3 c0 = textureLod(iChannel0, (uv + off) / iResolution.xy, 0.0).rgb;\n            vec3 c0 = SampleCubic(uv + off).rgb;\n            c0 *= exp2(exposure);\n\n            vec3 c1 = Tonemap(c0);\n\n            fm += clamp01((c1 - c0)*(c1 - c0));\n\n            fcol += (c1);\n        }\n\n        fcol /= float(count);\n        fm /= float(count);\n\n        col = mix(col, fcol, 1.0-(1.0-fm)*(1.0-fm));\n        //col = mix(col, fcol, fm);\n    }\n    #endif\n    \n    #if 0\n    // vignetting:\n    vec2 s = abs(tex*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n\t#endif\n    \n    fragColor = vec4(sRGB_EOTF(clamp(col, 0.0, 1.0)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nBasic implementation of Frostbite's material + relevant sampling strategies.\nCamera controls via mouse + shift key.\n\nReferences:\n\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\thttps://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\nThe bulk of the material specific code is in the Common tab; direct light sampling routines + rendering in BufferA. Tonemapping in Image.\n*/\n\n\n////////////////////////////////////////////////////////////\n//--------------------------------------------------------//\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n//--------------------------------------------------------//\n////////////////////////////////////////////////////////////\n\n\n// settings for the spherical light sources:\nconst vec3 LightPos = vec3(0.0, 8.0, 0.0);\nconst float R2 = 16.1;// squared radius\nconst float Flux = 512.0;\n\nconst float A = R2 * 4.0 * Pi;\n\nconst float HemiSphProjOmega = Pi;\nconst float SphOmega = 4.0 * Pi;\n\nconst float Radiance = Flux / A / HemiSphProjOmega;\nconst float Intensity = Flux / SphOmega; // = Radiance * (HemiSphProjOmega * R2);\n\n\n// voxel-based, Cornell box-like scene:\nbool map(vec3 p)\n{\n    p += 0.5;\n    vec3 b = abs(p);\n    \n    bool r;\n    \n    r =      b.x < 8.0;\n    r = r && b.y < 8.0;\n    r = r && b.z < 8.0;\n    \n    r = r && !(b.x < 7.0 && b.y < 7.0 && p.z > -7.0);\n   \n    r = r || (p.x > 1.0 && p.x < 5.0 && p.z > 1.0 && p.z < 5.0 && p.y > -8.0 && p.y < -3.0);\n    r = r || (p.x >-5.0 && p.x <-1.0 && p.z > -5.0 && p.z <-1.0 && p.y > -8.0 && p.y < 0.0);\n    \n    float ws = 2.0;\n    //if(p.y > 7.0 && b.x < ws && b.z < ws) r = false;\n    \n    return r;\n}\n\n// albedo:\nvec3 mapC(vec3 p)\n{\n    p += 0.5;\n    vec3 b = abs(p);\n    \n    vec3 c = vec3(1.0);\n    \n    if(b.y < 7.0 && p.z > -7.0) \n        if(p.x < -7.0) \n            c = vec3(1.0, 0.2, 0.01);//orange wall\n        else if(p.x > 7.0) \n            c = vec3(0.01, 0.3, 1.0);// blue wall\n        \n\n    return c;\n}\n\nvec3 minmask(vec3 v)\n{\n    return vec3(v.x <= v.y && v.x <= v.z,\n                v.y <  v.z && v.y <  v.x,\n                v.z <  v.x && v.z <= v.y);\n}\n\n// modified version of iq's DDA implementation: https://www.shadertoy.com/view/4dfGzs\nbool VoxelRayCast(vec3 rp, vec3 rd, /**/ out vec3 vp, out vec3 n, out float t)\n{\n\tvec3 pos = floor(rp);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 off = (-rp + (rs * 0.5 + 0.5)) * ri;\n\n\tvec3 mm = vec3(0.0);\n    \n\tif(map(pos)) { t = 0.0; n = vec3(0.0); vp = pos; return true; }\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 128; i++) \n\t{        \n        vec3 dis = pos * ri + off;\n\n        mm = minmask(dis);\n            \n        pos += mm * rs;\n        \n\t\tif(map(pos)) { hit = true; break; }\n\t}\n\t\n    // intersect the cube\t\n    vec3 mini = (pos - rs) * ri + off;   \n\tt = max(mini.x, max(mini.y, mini.z));\n\n\tn = -mm * rs;\n\tvp = pos;\n\n\treturn hit;\n}\n\n\nbool Intersect_Scene(vec3 rp, vec3 rd, bool isPrimaryRay,\n                     out float t, out vec3 n, out vec3 a, inout bool hitLight)\n{\n    bool doTestLight = hitLight;\n    hitLight = false;\n        \n    vec3 vp;\n    bool hit = VoxelRayCast(rp, rd, /*out*/ vp, n, t);\n    \n    //a = vec3(1.0);\n    a = mapC(vp);\n    \n\tif(doTestLight)    \n    {\n        vec2 t0;\n\t\tfloat hit0 = Intersect_Ray_Sphere(rp, rd, LightPos, R2, /*out*/ t0);\n        \n        if(hit0 == 1.0)\n        {\n            if(!hit || t0.x < t)\n            {\n                t = t0.x;\n                n = normalize(rp + rd * t0.x - LightPos);\n                a = vec3(1.0);\n                \n                hitLight = true;\n            }\n            \n            hit = true;\n        }\n    }\n    \n    return hit;\n}\n\n// --------------------------------------------------------------------------------------------------------------------------\nvec3 Sample_PointLight(vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 pl = LightPos;\n    vec3 vecl = pl - p;\n    vec3 L = normalize(vecl);\n    float d2 = dot(vecl, vecl);\n\n    float t2; vec3 n2; vec3 a2; bool hitLight2 = false;\n    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, hitLight2);\n\n    if(hit && t2*t2 < d2) return vec3(0.0);\n        \n    float att = 1.0 / d2;\n\n    return Frostbite_R(V, N, L, albedo, roughness, F0) * att * Intensity;\n}\n\nvec3 Sample_DirLight(vec3 V, vec3 p, vec3 N, vec3 L, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    float t2; vec3 n2; vec3 a2; bool hitLight2 = false;\n    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, hitLight2);\n\n    if(hit) return vec3(0.0);\n\n    return Frostbite_R(V, N, L, albedo, roughness, F0) * (Intensity * Pow2(0.125));// just set brightness heuristically here based on point light intensity\n}\n\n\nvec3 Sample_SphLight_HemiSph(vec3 V, vec3 p, vec3 N, inout uint h, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 L;\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n        \t  \n        L = Sample_Sphere(h0, h1, N);\n    }\n\n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);\n\n    if(!isLight2) return vec3(0.0);\n    \n    float NoL = clamp01(dot(N, L));\n    \n    return Frostbite_R(V, N, L, albedo, roughness, F0) * Radiance * NoL * pi2;\n}\n\nvec3 Sample_SphLight_ClmpCos(vec3 V, vec3 p, vec3 N, inout uint h, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 L;\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n\n        L = Sample_ClampedCosineLobe(h0, h1, N);\n    }\n\n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);\n\n    if(!isLight2) return vec3(0.0);\n    \n    return Frostbite_R(V, N, L, albedo, roughness, F0) * Radiance * pi;\n}\n\n// s [0..1]\nvec3 Sample_SphLight_SolidAngle(vec2 s, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    float ct; vec3 Lc, L; float sang;\n    Sample_SolidAngle(s, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L, /*out*/ sang);\n\n    float NoL = dot(N, L);\n\n    if(NoL <= 0.0) return vec3(0.0);\n    \n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit = Intersect_Scene(p, L, false, /*out: */ t2, n2, a2, isLight2);\n\n    if(!isLight2 && t2 < dot(LightPos-p, Lc)) return vec3(0.0);\n    \n    vec3 f = Frostbite_R(V, N, L, albedo, roughness, F0);\n    float rpdf = sang;\n\n    return f * rpdf * Radiance;\n}\n\n// s0 [0..1], s1 [0..1]\nvec3 Sample_SphLight_MIS(vec2 s0, vec2 s1, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    float ct; vec3 Lc, L0; float sang;\n    Sample_SolidAngle(s0, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L0, /*out*/ sang);\n    float pdf00 = 1.0/sang;\n\n    vec3 L1; vec3 f1; float pdf11;\n    Sample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ f1, /*out*/ pdf11);\n\n    bool couldL1HitLight = dot(L1, Lc) > ct;\n    \n    vec3 f0 = Frostbite_R(V, N, L0, albedo, roughness, F0);\n         f1 = Frostbite_R(V, N, L1, albedo, roughness, F0);\n\n    float pdf01 = couldL1HitLight ? pdf00 : 0.0;\n    float pdf10 = EvalPDF_GGX_R(V, N, L0, alpha);\n\n    float w0, w1;\n    #if 1\n    w0 = (pdf00) / (Pow2(pdf00) + Pow2(pdf10));\n    w1 = (pdf11) / (Pow2(pdf11) + Pow2(pdf01));        \n    #else\n    w0 = 1.0 / (pdf00 + pdf23);\n    w1 = 1.0 / (pdf11 + pdf32);\n    #endif\n\n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit2 = Intersect_Scene(p, L0, false, /*out*/ t2, n2, a2, isLight2);\n\n    float t3; vec3 n3; vec3 a3; bool isLight3 = true;\n    bool hit3 = Intersect_Scene(p, L1, false, /*out*/ t3, n3, a3, isLight3);\n\n    if((isLight2 == false && t2 < dot(LightPos-p, Lc)) || dot(N, L0) <= 0.0) f0 = vec3(0.0);\n    if(couldL1HitLight == false || isLight3 == false) f1 = vec3(0.0);\n\n    vec3 res  = pdf00 == 0.0 ? vec3(0.0) : f0 * w0;\n         res += pdf11 == 0.0 ? vec3(0.0) : f1 * w1;\n\n    return res * Radiance;       \n}\n\n// single sample version of Sample_SphLight_MIS; use this if intersecting the scene is expensive\n// s0 [0..1], s1 [0..1], s2 [0..1]\nvec3 Sample_SphLight_MIS2(vec2 s0, vec2 s1, float s2, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    float ct; vec3 Lc, L0; float sang;\n    Sample_SolidAngle(s0, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L0, /*out*/ sang);\n    float pdf00 = 1.0/sang;\n\n    vec3 L1; vec3 f1; float pdf11;\n    Sample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ f1, /*out*/ pdf11);\n\n    bool couldL1HitLight = dot(L1, Lc) > ct;\n    \n    vec3 f0 = Frostbite_R(V, N, L0, albedo, roughness, F0);\n         f1 = Frostbite_R(V, N, L1, albedo, roughness, F0);\n\n    float pdf01 = couldL1HitLight ? pdf00 : 0.0;\n    float pdf10 = EvalPDF_GGX_R(V, N, L0, alpha);\n\n    float w0, w1;\n    #if 1\n    w0 = Pow2(pdf00) / (Pow2(pdf00) + Pow2(pdf10));\n    w1 = Pow2(pdf11) / (Pow2(pdf11) + Pow2(pdf01));        \n    #elif 1\n    w0 = (pdf00) / ((pdf00) + (pdf10));\n    w1 = (pdf11) / ((pdf11) + (pdf01)); \n    #else\n    w0 = 0.5; \n    w1 = 1.0 - w1;\n    #endif\n\n    float wn = couldL1HitLight == false ? 1.0 : w0 / (w0 + w1);\n\n    bool doUseSmpl0 = s2 <= wn;\n\n    float denom = doUseSmpl0 ? pdf00 * wn : pdf11 * (1.0 - wn);\n\n    vec3 L = doUseSmpl0 ? L0 : L1;\n\n    if(dot(N, L) <= 0.0 || denom == 0.0) return vec3(0.0);\n    \n    float t2; vec3 n2; vec3 a2; bool isLight2 = true;\n    bool hit2 = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);\n\n    if(hit2 && isLight2)\n    {\n        if(doUseSmpl0)\n            return f0 / denom * w0 * Radiance;\n        else\n            return f1 / denom * w1 * Radiance;\n    }\n}\n\n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\nvec3 MapColor(vec3 srgb)\n{\n    #ifdef USE_ACESCG\n    return srgb * sRGBtoAP1;\n    #else\n    return srgb;\n    #endif\n}\n\nvec3 UnitDiskToHemisphere(vec2 p)\n{\n    float s = dot(p, p);\n    float l = sqrt(2.0 - s);\n    \n    return vec3(p.x * l, 1.0 - s, p.y * l);\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uvO)\n{     \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 iResolution2 = iResolution.xy;\n    vec2 uv0 = uvO;\n    \n    bool isRight = false;\n    \n    #if 0\n    if(uv0.x >= iResolution.x * 0.5)\n    {\n       uv0.x -= iResolution.x * 0.5;\n       isRight = true;\n    }\n    \n    iResolution2.x = iResolution.x * 0.5;\n    #endif\n    \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / iResolution2.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n\n    vec2 ang = vec2(-0.42 * Pi, -Pi * 0.08);\n    ang += mouseAccu.xy * 0.008;\n    \n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(2.5 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n    \n\n    uint frameNum = uint(frameAccu);\n    \n    uint h = WellonsHash(uvec3(uv, frameNum), 0u).x;\n    uvec2 hh = WellonsHash(uvec2(uv), 0u).xy;\n    uint hh1 = WellonsHash(uvec2(uv), 0u).z;\n    \n    vec2 tc;\n    {\n        vec2 off;\n        {\n            // filter kernel:\n            float h0 = Hash11(h);\n            float h1 = Hash11(h);\n            \n        \toff = vec2(Sample_Triangle(h0), \n                       Sample_Triangle(h1));\n        }\n\n       #ifdef USE_BLOOM\n       //if(false)\n        {\n            // heavy tail bloom kernel:\n            vec2 h01 = Float01(Roberts(hh, frameNum));\n            float h0 = h01.x*2.0-1.0;\n            float rr = h01.y;\n            \n            vec2 dir = AngToVec(h0 * Pi);\n            float r = sqrt(rr);\n            \n           #if 0\n           \n            r = sqrt(2.0*rr-rr*rr) / (1.0 - rr);\n            \n           #elif 0\n           \n            r = tan(r*Pi*0.5)/(Pi)*2.0;\n            r=r*r;\n            r*=0.125*0.125;\n            \n           #elif 1\n           \n            r = rr / (1.0 - rr);\n            \n            float s = 0.5;\n            r = (sqrt(s*s+r*r)-s)*(s+sqrt(1.0+s*s));\n            \n            r*= 0.0001 * iResolution.x;\n           \n           #elif 1\n           \n            r = log((1.0+r)/(1.0-r))*0.3;\n            r*=r;\n            r*=r;\n            r*=r;\n           \n           #endif\n           \n        \toff += AngToVec(h0 * Pi) * r;\n        }\n       #endif\n        \n       #ifdef USE_BLOOM\n       //if(false)\n        if(((frameNum + hh1) % 16u) == 0u) \n        {\n            // blobby bloom kernel:\n            vec2 h01 = Float01(Roberts(uvec2(0u), (frameNum + hh1) / 16u));\n            float h0 = h01.x*2.0-1.0;\n            float rr = h01.y;\n            \n            vec2 dir = AngToVec(h0 * Pi);\n            float r = sqrt(rr);\n            \n           #if 0\n           \n           float s = 64.0*(rr+.5);// * (rr*rr);\n           \n           float bump = pow(clamp01(1.0-Pow2(r*2.0-1.0)), 32.0);\n           //bump = 0.0;\n           \n           //rr = mix((cos(rr*s)+rr*s-1.0)/s, rr, 0.5);\n           \n           r = (sqrt(1.0/pow(1.0-rr, 8.0) - 1.0)-0.75*bump)*0.5;\n           \n           #elif 0\n           \n           r = sqrt(1.0/((rr*rr) * (rr*rr)) - 1.0)*0.25;\n           //r = sqrt(1.0/pow(rr, 8.0) - 1.0)*0.5;\n            //r = sqrt((2.0*rr-rr*rr)*(2.0-(2.0*rr-rr*rr))) / Pow2(rr - 1.0)*0.5;\n            \n           #elif 0\n           \n            r = sqrt(2.0*rr-rr*rr) / (1.0 - rr)*0.5;\n            \n           #elif 0\n           \n            r = sqrt(rr / sqrt(1.0 - rr*rr));\n           \n           #elif 1\n           \n            r = log((1.0+r)/(1.0-r));\n            r*=r;\n            r *= 0.125;\n            //r = pow(r, 1.25);\n           #endif           \n           \n        \toff += AngToVec(h0 * Pi) * r * (0.125 * iResolution.x);\n            \n           //vec2 gauss = Sample_Gauss2D(h01.x, h01.y*2.0-1.0);\n            \n            //off += gauss * (0.125*0.5  * iResolution.x);\n        }\n       #endif\n        \n        tc = (uv0.xy + off - iResolution2.xy * 0.5) / (iResolution2.xx * 0.5);\n    }\n    \n    vec3 lpos = vec3(0.0);\n    #if 0\n    {\n        // lens pos / dof:\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n\t\t\n        vec2 lpos0 = Sample_Disk(h0, h1) * 0.1;\n        \n        lpos = cmat * vec3(lpos0, 0.0);\n    }\n    #endif\n\n    float focalLen = 0.6;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    #if 0\n    {\n        float c = 0.5;\n        float s = 0.7;\n        \n        tc.y *= c;\n        tc *= s;\n        \n        vec3 u = UnitDiskToHemisphere(tc);\n        tc = u.xz;\n        focalLen = u.y*0.9;\n        \n        tc /= s;\n        tc.y/=c;\n    }\n    #endif\n\n    float S1 = max(18.0, cdist);// focus plane dist / focalLen\n    S1 = 1.0;\n    vec3 rdir = normalize(cmat * (vec3(tc, focalLen) * S1) - lpos); \n \n    rdir = cmat * Pannini(tc, Pi*0.6, 0.5);\n    \n    #if 0\n    vec2 lightAng = vec2(Pi * 0.7, Pi * 0.1);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light0 = AngToVec(lightAng);\n    light0 = vec3(0.49292178644304296, 0.7169771439171534, 0.49292178644304296);\n    \n    vec3 light = light0;\n    {\n        float h0 = Hash11(h);\n        float h1 = Hash01(h);\n\n        h1 = mix(0.999, 1.0, h1);\n        h1 = 1.0;\n        \n        light = Sample_Sphere(h0, h1, light);\n    }\n    #endif\n    \n    vec3 W = vec3(1.0);\n    vec3 col = vec3(0.0);\n    \n    float t; vec3 N; vec3 color;\n    vec3 p = cpos + lpos;\n    vec3 dir = rdir;\n\n    vec2 tt; \n    float res = Intersect_Ray_Cube(p, dir, vec3(16.0) + vec3(1e-5), /*out:*/ tt);   \n    \n    if(res == 1.0)\n    {\n    \tp += dir * tt.x;\n    }\n    \n    if(res != -1.0)\n    {\n        uint GIBounceCount = 3u;\n        \n        for(uint i = 0u; i < GIBounceCount; ++i)\n        {\n            bool hitLight = true;\n            if(Intersect_Scene(p, dir, i == 0u, /*out:*/ t, N, color, hitLight))\n            {\n                if(t == 0.0) break;\n                \n                p += dir * t;\n                p += N * 0.0001;\n                p -= dir * min(t*0.5, 0.0001);\n\n                vec3 V = -dir;\n\n                vec3 albedo, F0; float roughness;\n                {\n                    float metalness = 0.0;\n                    float reflectance = 0.5;\n                    \n                   #if 0\n                    vec3 fp = fract(p);\n                    \n                    float s = 0.01;\n                    bool m;\n                    m =      (fp.x < s || fp.x > 1.0 - s || fp.y < s || fp.y > 1.0 - s);   \n                    m = m && (fp.x < s || fp.x > 1.0 - s || fp.z < s || fp.z > 1.0 - s);   \n                    m = m && (fp.z < s || fp.z > 1.0 - s || fp.y < s || fp.y > 1.0 - s);   \n\n                    color *= m ? 0.0 : 1.0;\n\t\t\t\t   #endif\n                    \n                    vec3 fp2 = fract((p - N * 0.001) * 0.5);\n                    bvec3 m2 = greaterThan(fp2, vec3(0.5));\n\n                    bool checker = m2.x != m2.y != m2.z;\n\n                    if((p.x > 0.0) != (p.y > 0.0) != (p.z > 0.0))\n                    {\n                        metalness = 1.0;\n                        //color = mix(color, vec3(1.0), 0.2);\n                        //roughness *= 0.5;\n                        roughness = 0.7;\n\n                        roughness = checker ? 0.4 : 0.1;\n\n                    }\n                    else\n                    {\n                        roughness = checker ? 0.6 : 0.1;\n                    }\n                    //alpha = 0.02;\n\t\t\t\t\tcolor = MapColor(color);\n                    \n\t\t\t\t\tConvertMtlParams(color, reflectance, metalness, /*out*/ albedo, /*out*/ F0);\n                }\n                \n                // -------------------------------------------------------------------------------------------------------------\n\n               #if 0\n                // implicit light sampling (for verification)\n                if(hitLight == true)\n                {\n                    col += W * Radiance;\n\n                    break;\n                }\n\n               #else\n\n                if(hitLight == true)\n                {\n                    if(i == 0u) \n                    col += W * Radiance;\n\n                    break;\n                }\n\n               #if 0\n\n                // make sure LightPos is not inside scene geometry when using this\n                col += Sample_PointLight(V, p, N, albedo, roughness, F0) * W;\n\n               #elif 0\n\n                col += Sample_DirLight(V, p, N, normalize(vec3(1.0, 1.0, 1.0)), albedo, roughness, F0) * W;\n\n               #elif 0\n\n                //col += Sample_SphLight_HemiSph(V, p, N, /*inout*/ h, albedo, roughness, F0) * W;      \n                col += Sample_SphLight_ClmpCos(V, p, N, /*inout*/ h, albedo, roughness, F0) * W;      \n\n               #elif 0\n\n                col += Sample_SphLight_SolidAngle(Hash01x2(h), V, p, N, albedo, roughness, F0) * W;      \n\n               #elif 1\n                {\n                    vec2  s0 = Hash01x2(h);\n                    vec2  s1 = Hash01x2(h);\n                    \n                   #ifdef USE_LDS\n                    if(i == 0u)\n                    {\n                        s0 = Float01(Roberts(hh ^ 0xFA760509u, frameNum));\n                        s1 = Float01(Roberts(hh ^ 0x82DD24D6u, frameNum));\n                    }\n                   #endif\n                    \n                \tcol += Sample_SphLight_MIS(s0, s1, V, p, N, albedo, roughness, F0) * W;      \n                }   \n               #elif 1\n                {\n                    vec2  s0 = Hash01x2(h);\n                    vec2  s1 = Hash01x2(h);\n                    float s2 = Hash01(h);\n                    \n                   #ifdef USE_LDS\n                    if(i == 0u)\n                    {\n                        s0 = Float01(Roberts(hh   ^ 0xFA760509u, frameNum));\n                        s1 = Float01(Roberts(hh   ^ 0x82DD24D6u, frameNum));\n                        s2 = Float01(Roberts(hh.x ^ 0x2FE84799u, frameNum));\n                    }\n                   #endif\n                    \n                \tcol += Sample_SphLight_MIS2(s0, s1, s2, V, p, N, albedo, roughness, F0) * W;      \n                }\n               #endif\n               #endif\n\n\n                {\n                    vec2  s0 = Hash01x2(h);\n                    vec2  s1 = Hash01x2(h);\n                    float s2 = Hash01(h);\n                    \n                   #ifdef USE_LDS\n                    if(i == 0u)\n                    {\n                        s0 = Float01(Roberts(hh   ^ 0x8CF64DC5u, frameNum));\n                        s1 = Float01(Roberts(hh   ^ 0xFED0592Du, frameNum));\n                        s2 = Float01(Roberts(hh.x ^ 0xAEDF2BF3u, frameNum));\n                    }\n                   #endif\n                    \n                   #if 1\n                    // appears to work better than the MIS version\n                    Sample_ScatteredDir(s0, s1, s2, /*inout*/dir, /*inout*/W, N, albedo, roughness, F0);\n                   #else\n                    Sample_ScatteredDirMIS(s0, s1, s2, /*inout*/dir, /*inout*/W, N, albedo, roughness, F0);\n                   #endif\n                }\n            } \n            else \n            {\n\t\t\t\t// sample sky box\n\n                break;\n            }\n        }\n    } \n    else \n    {\n\t\t// sample sky box\n    }\n    \n    vec3 colLast = textureLod(iChannel0, uvO.xy / iResolution.xy, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        // persistent state stuff:\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nBasic implementation of Frostbite's material + relevant sampling strategies.\nCamera controls via mouse + shift key.\n\nReferences:\n\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\thttps://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n\nThe bulk of the material specific code is in the Common tab; direct light sampling routines + rendering in BufferA. Tonemapping in Image.\n*/\n\n// render with sharp primaries so bounce light colors behave reasonably well ( https://www.shadertoy.com/view/WltSRB ):\n#define USE_ACESCG\n\n//#define USE_BLOOM\n\n// use low-discrepancy sequences for the first direct light sampling and scattered ray direction sampling (doesn't improve quality all that much)\n//#define USE_LDS\n\n// LDS sequences don't work when bloom is active since the bloom kernel use LDS sequences themselves\n#ifdef USE_BLOOM\n #undef USE_LDS\n#endif\n\n\n#define Frame float(iFrame)\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n/* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\nvec3 Pannini(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = Pi05 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n// Box-Muller Transform: \n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n// u (0..1] | v [-1..1]\nvec2 Sample_Gauss2D(float u, float v)\n{\n    float l = sqrt(-2.0 * log(u));\n    \n    return vec2(cos(v * Pi), sin(v * Pi)) * l;\n}\n\nconst float pi      = 3.14159274;\nconst float rpi     = 0.31830989;\n\t\t\t\t   \nconst float pi2     = 6.28318530;\nconst float rpi2    = 0.15915494;\n\t\t\t\t   \nconst float pi05    = 1.57079632;\nconst float rpi05   = 0.63661977;\n\nconst float sqrt05  = 0.70710678;\nconst float rsqrt05 = 1.41421356;\n\nconst float phi     = 1.61803398;\nconst float rphi    = 0.61803398;\n\n\nfloat OrenNayar(vec3 V, vec3 N, vec3 L, float sigma)\n{\n    float NoL = clamp01(dot(N, L));\n    float NoV = clamp01(dot(N, V));\n    \n\tfloat sigma2 = sigma * sigma;\n\n\tfloat A = 1.0 - 0.5  * sigma2 / (sigma2 + 0.33);\n\tfloat B =       0.45 * sigma2 / (sigma2 + 0.09);\n\n\tfloat term0 = sqrt((1.0 - NoV * NoV) * (1.0 - NoL * NoL)) / max(NoL, NoV);\n\n\tvec3 V_proj = normalize(V - N * NoV);\n\tvec3 L_proj = normalize(L - N * NoL);\n\n\tfloat term1 = clamp01(dot(V_proj, L_proj));\n\n\treturn (A + (B * term1 * term0)) * NoL * rpi;\n}\n\n\n// float ct, sang; vec3 Lc, L;\n// Sample_SolidAngle(s, p, lp, lr2, /*out*/ ct, /*out*/ Lc, /*out*/ L, /*out*/ sang)\n// s [0..1]\nvoid Sample_SolidAngle(vec2 s, vec3 p, vec3 lp, float lr2, \n                       out float ct, out vec3 Lc, out vec3 L, out float sang)\n{\n    vec3 lvec = lp - p;\n    \n   \tfloat len2 = dot(lvec, lvec);\n    \n    if(len2 == 0.0)\n    {\n        ct = 0.0;\n        Lc = vec3(0.0, 1.0, 0.0);\n        L  = vec3(0.0, 1.0, 0.0);\n        sang = pi2;\n        \n        return;\n    }\n    \n\tfloat rlen = rsqrt(len2);\n\n    Lc = lvec * rlen;\n    \n    ct = sqrt(clamp01(1.0 - lr2 * (rlen * rlen)));\n    \n    L = Sample_Sphere(s.x * 2.0 - 1.0, mix(ct, 1.0, s.y), Lc);\n\n    sang = ct * -pi2 + pi2;\n}\n\n\nfloat FresnelSchlick(float ct, float f0)\n{\n\tfloat x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return f0 * (1.0 - w) + w;\n}\n\nvec3 FresnelSchlick(float ct, vec3 f0)\n{\n    float x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return f0 * (1.0 - w) + w;\n}\n\nfloat FresnelSchlick(float ct, float f0, float f90)\n{\n\tfloat x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return mix(f0, f90, w);\n}\n\nvec3 FresnelSchlick(float ct, vec3 f0, vec3 f90)\n{\n    float x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return mix(f0, f90, w);\n}\n\n\nfloat GGX_V(float NoL, float NoV, float alpha)\n{\n\tfloat aa = alpha*alpha;\n    \n\tfloat t0 = NoL * sqrt((-NoV * aa + NoV ) * NoV + aa);\n\tfloat t1 = NoV * sqrt((-NoL * aa + NoL ) * NoL + aa);\n\t\n    return 0.5 / (t0 + t1);\n}\n\nfloat GGX_G(float NoL, float NoV, float alpha)\n{\n\tfloat aa = alpha * alpha;\n    \n\tfloat t0 = NoL * sqrt((-NoV * aa + NoV ) * NoV + aa);\n\tfloat t1 = NoV * sqrt((-NoL * aa + NoL ) * NoL + aa);\n\t\n    return (NoL * NoV * 2.0) / (t0 + t1);\n}\n\nfloat GGX_D(float NoH, float alpha)\n{\n    float aa = alpha * alpha;\n    \n    float t = (NoH * aa - NoH) * NoH + 1.0;\n\n\treturn aa / (pi * (t * t));\n}\n\n/*\n#elif 0\nfloat GGX_D(float NoH, float a)\n{\n    //float t = (NoH * (a*a) - NoH) * NoH + 1.0;\n\t//return (a*a-1.0) / (log(a*a) * pi * (t));\n    \n    float t = (NoH * (a*a) - NoH) * NoH + 1.0;\n\treturn (a*a-1.0) / (log(a*a*2.0/(1.0+a*a)) * pi * (t))*0.5;\n}\n#else\nfloat GGX_D(float NoH, float a)\n{\n    float t = (NoH * (a*a) - NoH) * NoH + 1.0;\n\tfloat n = (a*a-1.0) / (log(a*a) * pi * (t));\n    \n    float t2 = (NoH * (a*a) - NoH) * NoH + 1.0;\n\tfloat n2 = (a*a) / (pi * (t2 * t2));\n    \n    return mix(n, n2, 0.99);\n}\n#endif\n*/\n\nfloat GGX_G(float ct, float alpha)\n{\n    float aa = alpha * alpha;\n    float ct2 = ct * ct;\n    \n    return 2.0 * ct / (ct + sqrt(aa + ct2 - aa * ct2));\n}\n\nvec3 GGX_BRDF(vec3 N, vec3 V, vec3 L, float alpha, vec3 f0)\n{\n    vec3 H  = normalize(V + L);\n    float VoH = clamp01(dot(V, H));\n    float NoH = clamp01(dot(N, H));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    \n    float denom = NoV * NoL;\n\n    if (denom == 0.0) return vec3(0.0);\n\n    float D = GGX_D(NoH, alpha);\n    float G = GGX_G(NoL, NoV, alpha);\n    vec3  F = FresnelSchlick(VoH, f0);\n\n    return (F * G * D) * 0.25 / denom;\n}\n\nvec3 GGX_R(vec3 N, vec3 V, vec3 L, float alpha, vec3 f0)\n{\n    vec3 H  = normalize(V + L);\n    float VoH = clamp01(dot(V, H));\n    float NoH = clamp01(dot(N, H));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    \n    float denom = NoV;\n\n    if (denom == 0.0) return vec3(0.0);\n\n    float D = GGX_D(NoH, alpha);\n    float G = GGX_G(NoL, NoV, alpha);\n    vec3  F = FresnelSchlick(VoH, f0);\n\n    return (F * G * D) * 0.25 / denom;\n}\n\n\nfloat GGXAlphaFromRoughness(float roughness) \n{\n    return roughness * roughness;\n}\n\nfloat F0FromReflectance(float reflectance)\n{\n    return reflectance * reflectance * 0.16;\n}\n\nvoid ConvertMtlParams(vec3 color, float reflectance, float metalness, out vec3 albedo, out vec3 F0)\n{\n    F0 = mix(vec3(F0FromReflectance(reflectance)), color, metalness);\n    \n    albedo = color * (1.0 - metalness);\n}\n                      \n\n/* https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf */ \n/* https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf */\nfloat DisneyDiffuse_BRDF(float NoV, float NoL, float HoL, float linearRoughness)\n{\n\tfloat energyBias   = mix(0.0,     0.5 , linearRoughness);\n\tfloat energyFactor = mix(1.0, 1.0/1.51, linearRoughness);\n    \n\tfloat fd90 = energyBias + 2.0 * (HoL*HoL) * linearRoughness;\n    \n\tconst float f0 = 1.0;\n    \n\tfloat lightScatter = FresnelSchlick(NoL, f0, fd90);\n\tfloat viewScatter  = FresnelSchlick(NoV, f0, fd90);\n\t\n\treturn lightScatter * viewScatter * energyFactor * rpi;\n}\n\n/* https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf */\nvec3 Frostbite_R(vec3 V, vec3 N, vec3 L, vec3 albedo, float roughness, vec3 F0)\n{    \n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 H = normalize(V + L);\n    \n    float NoH = clamp01(dot(N, H));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    float HoV = clamp01(dot(H, V));\n    \n    if(NoL == 0.0 || NoV == 0.0) return vec3(0.0);\n    \n    float D   = GGX_D(NoH,      alpha);\n    float Vis = GGX_V(NoL, NoV, alpha);\n    float G   = GGX_G(NoV, NoL, alpha);\n    \n    vec3 F = FresnelSchlick(HoV, F0);\n\n    vec3 diffuse = albedo * DisneyDiffuse_BRDF(NoV, NoL, HoV, roughness);\n\n    return (diffuse + D * F * Vis) * NoL;\n}\n\n\n/* Eric Heitz | Sampling the GGX Distribution of Visible Normals | http://jcgt.org/published/0007/04/01/ */\n// Input Ve: view direction\n// Input alpha_x, alpha_y: roughness parameters\n// Input U1, U2: uniform random numbers\n// Output Ne: normal sampled with PDF D_Ve(Ne) = G1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z\nvec3 Sample_GGX_VNDF(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2)\n{\n\t// Section 3.2: transforming the view direction to the hemisphere configuration\n\tvec3 Vh = normalize(Ve * vec3(alpha_x, alpha_y, 1.0));\n\t\n    // Section 4.1: orthonormal basis (with special case if cross product is zero)\n\tfloat lensq = (Vh.x*Vh.x) + (Vh.y*Vh.y);\n\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1.0, 0.0, 0.0);\n\tvec3 T2 = cross(Vh, T1);\n\t\n    // Section 4.2: parameterization of the projected area\n\tfloat r = sqrt(U1);\n\tfloat phi = 2.0 * pi * U2;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = 0.5 * (1.0 + Vh.z);\n\tt2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n    \n\t// Section 4.3: reprojection onto hemisphere\n\tvec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2))*Vh;\n    \n\t// Section 3.4: transforming the normal back to the ellipsoid configuration\n\tvec3 Ne = normalize(vec3(Nh.xy, max(0.0, Nh.z)) * vec3(alpha_x, alpha_y, 1.0));\n    \n\treturn Ne;\n}\n\n#if 1\n// routines that sample the visible distribution of microfacet normals\n\n// s [0..1]\nvoid Sample_GGX_R(vec2 s, vec3 V, vec3 N, float alpha, vec3 F0, out vec3 L, out vec3 w)\n{\n    vec3 H;\n    {\n    \tvec3 ox, oz;\n\t\tOrthonormalBasisRH(N, /*out*/ ox, oz);\n    \t\n    \tvec3 Vp = vec3(dot(V, ox), dot(V, oz), dot(V, N));\n    \t\n        vec3 Hp = Sample_GGX_VNDF(Vp, alpha, alpha, s.x, s.y);\n    \t\n        H = ox*Hp.x + N*Hp.z + oz*Hp.y;\n    }\n    \n    vec3 F = FresnelSchlick(dot(H, V), F0);\n\n    L = 2.0 * dot(V, H) * H - V;\n    \n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    \n    float G2 = GGX_G(NoV, NoL, alpha);\n    float G1 = GGX_G(NoV, alpha);\n    \n    w = G1 == 0.0 ? vec3(0.0) : F * G2 / G1;\n}\n\n// s [0..1]\nvoid Sample_GGX_R(vec2 s, vec3 V, vec3 N, float alpha, vec3 F0, out vec3 L, out vec3 f, out float pdf)\n{\n    vec3 H;\n    {\n    \tvec3 ox, oz;\n\t\tOrthonormalBasisRH(N, /*out*/ ox, oz);\n    \t\n    \tvec3 Vp = vec3(dot(V, ox), dot(V, oz), dot(V, N));\n    \t\n        vec3 Hp = Sample_GGX_VNDF(Vp, alpha, alpha, s.x, s.y);\n    \t\n        H = ox*Hp.x + N*Hp.z + oz*Hp.y;\n    }\n    \n    vec3 F = FresnelSchlick(dot(H, V), F0);\n\n    L = 2.0 * dot(H, V) * H - V;\n    \n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    float HoV = clamp01(dot(H, V));\n    float NoH = clamp01(dot(N, H));\n    \n    float G1 = GGX_G(NoV, alpha);\n    float G2 = GGX_G(NoV, NoL, alpha);\n    float D  = GGX_D(NoH, alpha);\n    \n    f   = NoV == 0.0 ? vec3(0.0) : (F * G2 * D) * 0.25 / NoV;\n    pdf = NoV == 0.0 ?      0.0  : (    G1 * D) * 0.25 / NoV;\n}\n\nfloat EvalPDF_GGX_R(vec3 V, vec3 N, vec3 L, float alpha)\n{\n    vec3 H = normalize(V + L);\n    float NoH = clamp01(dot(N, H));\n    float NoV = clamp01(dot(N, V));\n    \n    /*\n    float G1 = GGX_G(NoV, alpha);\n    float D  = GGX_D(NoH, alpha);\n    \n    return (G1 * D) * 0.25 / NoV;\n    /*/\n    float alpha2 = alpha*alpha;\n    float NoV2 = NoV*NoV;\n    \n    float t0 =     (NoH  *  alpha2 - NoH) * NoH + 1.0;\n    float t1 = sqrt(NoV2 * -alpha2 + NoV2 + alpha2) + NoV;\n    \n    float denom = (t0*t0) * t1;\n    \n    return denom == 0.0 ? 0.0 : (alpha2 * rpi2) / denom;\n    //*/\n}\n\n#else\n// routines that sample the distribution of microfacet normals (ignoring visibility)\n\n// s [0..1]\nvoid Sample_GGX_R(vec2 s, vec3 V, vec3 N, float alpha, vec3 F0, out vec3 L, out vec3 w)\n{\n    float l = rsqrt((alpha*alpha)/s.y + 1.0 - (alpha*alpha));\n    \n    vec3 H = Sample_Sphere(s.x * 2.0 - 1.0, l, N);\n\n    L = 2.0 * dot(V, H) * H - V;\n    \n    float HoV = clamp01(dot(H, V));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    float NoH = clamp01(dot(N, H));\n\n    vec3  F = FresnelSchlick(HoV, F0);  \n    float G = GGX_G(NoV, NoL, alpha);\n    \n    float denom = NoV * NoH;\n    \n    w = denom == 0.0 ? vec3(0.0) : F * G * HoV / denom;\n}\n\n// s [0..1]\nvoid Sample_GGX_R(vec2 s, vec3 V, vec3 N, float alpha, vec3 F0, out vec3 L, out vec3 f, out float pdf)\n{\n    float l = rsqrt((alpha*alpha)/s.y + 1.0 - (alpha*alpha));\n    \n    vec3 H = Sample_Sphere(s.x * 2.0 - 1.0, l, N);\n\n    L = 2.0 * dot(V, H) * H - V;\n    \n    float HoV = clamp01(dot(H, V));\n    float NoV = clamp01(dot(N, V));\n    float NoL = clamp01(dot(N, L));\n    float NoH = clamp01(dot(N, H));\n\n    vec3 F = FresnelSchlick(HoV, F0);  \n    float G = GGX_G(NoL, NoV, alpha);\n    float D = GGX_D(NoH, alpha);\n    \n    f   = NoV == 0.0 ? vec3(0.0) : (F * G  * D) * 0.25 / NoV;\n    pdf = HoV == 0.0 ?      0.0  : (   NoH * D) * 0.25 / HoV;\n}\n\nfloat EvalPDF_GGX_R(vec3 V, vec3 N, vec3 L, float alpha)\n{\n    vec3 H = normalize(V + L);\n    float NoH = clamp01(dot(N, H));\n    float HoV = clamp01(dot(H, V));\n    \n    float D  = GGX_D(NoH, alpha);\n    \n    return HoV == 0.0 ? 0.0 : (NoH * D) * 0.25 / HoV;\n}\n#endif\n\n\n// s0 [0..1], s1 [0..1], s2 [0..1]\nvoid Sample_ScatteredDir(vec2 s0, vec2 s1, float s2, inout vec3 rd, inout vec3 W, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 V = -rd;\n\n    vec3 L0, w0;\n    {\n        vec3 L = Sample_ClampedCosineLobe(s0.x * 2.0 - 1.0, s0.y, N);\n        \n        vec3 H = normalize(V + L);\n        \n        float HoV = clamp01(dot(H, V));\n    \tfloat NoV = clamp01(dot(N, V));\n    \tfloat NoL = clamp01(dot(N, L));\n        \n    \tw0 = albedo * DisneyDiffuse_BRDF(NoV, NoL, HoV, roughness) * pi;\n        L0 = L;\n    }\n    \n    vec3 L1, w1;\n    {\n        vec3 L, w;\n    \tSample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ w1);\n    }\n\n    float w0s = dot(w0, vec3(0.2, 0.7, 0.1));\n    float w1s = dot(w1, vec3(0.2, 0.7, 0.1));\n    \n    if(w0s == 0.0 && w1s == 0.0)\n    {\n        W = vec3(0.0);\n        rd = L0;\n        \n        return;\n    }\n    \n    #if 0\n    w0s = 0.5;\n    w1s = 1.0 - w0s;\n    #elif 0\n    float wn = (w0s*w0s) / ((w0s*w0s) + (w1s*w1s));\n    #else\n    float wn = w0s / (w0s + w1s);\n\t#endif\n    \n    bool doUseSmpl0 = s2 <= wn;\n\n    float denom = doUseSmpl0 ? wn : (1.0 - wn);\n\n    rd = doUseSmpl0 ? L0 : L1;\n    W *= doUseSmpl0 ? w0 : w1;\n\n    W /= denom == 0.0 ? 1.0 : denom;\n}\n\n// s0 [0..1], s1 [0..1], s2 [0..1]\nvoid Sample_ScatteredDirMIS(vec2 s0, vec2 s1, float s2, inout vec3 rd, inout vec3 W, vec3 N, vec3 albedo, float roughness, vec3 F0)\n{\n    float alpha = GGXAlphaFromRoughness(roughness);\n    \n    vec3 V = -rd;\n\n    vec3 L0; float pdf00;\n    {\n        L0 = Sample_ClampedCosineLobe(s0.x * 2.0 - 1.0, s0.y, N);\n\t\tpdf00 = dot(N, L0) * rpi;        \n    }\n\n    vec3 L1; vec3 f1; float pdf11;\n    Sample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ f1, /*out*/ pdf11);\n\n    vec3 f0 = Frostbite_R(V, N, L0, albedo, roughness, F0);\n         f1 = Frostbite_R(V, N, L1, albedo, roughness, F0);\n\n    float pdf01 = dot(N, L1) * rpi;\n    float pdf10 = EvalPDF_GGX_R(V, N, L0, alpha);\n\n    float w0, w1;\n    #if 0\n    w0 = 0.5; \n    w1 = 1.0 - w1;\n    #elif 1\n    w0 = Pow2(pdf00) / (Pow2(pdf00) + Pow2(pdf10));\n    w1 = Pow2(pdf11) / (Pow2(pdf11) + Pow2(pdf01));        \n    #else\n    w0 = (pdf00) / ((pdf00) + (pdf10));\n    w1 = (pdf11) / ((pdf11) + (pdf01));  \n    #endif\n\n    #if 0\n    if(albedo.r == 0.0 && albedo.g == 0.0 && albedo.b == 0.0)\n    {\n    \tw0 = 0.0;\n    \tw1 = 1.0;\n    }\n    #endif\n    \n    float wn = w0 / (w0 + w1);\n\n    bool doUseSmpl0 = s2 <= wn;\n\n    float denom = doUseSmpl0 ? pdf00 *        wn : \n                               pdf11 * (1.0 - wn);\n\n    rd = doUseSmpl0 ? L0 : L1;\n\n    if(denom == 0.0)\n    {\n        W = vec3(0.0);\n        \n        return;\n    }\n    \n    if(doUseSmpl0)\n        W *= f0 * w0;\n    else\n        W *= f1 * w1;\n\n    W /= denom;\n}\n\n\n\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}