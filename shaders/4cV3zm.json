{
    "Shader": {
        "info": {
            "date": "1712576393",
            "description": "Pixel alphabets using a 5x5 pixel grid\n\nClick and drag â†” to browse through every glyph",
            "flags": 0,
            "hasliked": 0,
            "id": "4cV3zm",
            "likes": 9,
            "name": "Pixel Alphabets",
            "published": 3,
            "tags": [
                "cc0",
                "fonts",
                "glyphs",
                "english",
                "alphabets"
            ],
            "usePreview": 0,
            "username": "cmzw",
            "viewed": 179
        },
        "renderpass": [
            {
                "code": "// Pixel Alphabets - License: CC0\n\n#define GLYPH_SCALE .9\n#define GRID_SCALE 4.\n\n// #define OFFSET_ROWS\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += iDate.z;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat p(vec2 uv, int i) {\n    float ic = float(i);\n\tvec2 gr = 1.0 - abs(uv*7.-0.5 - vec2(mod(ic,7.), floor(ic/7.)));\n\treturn smoothstep(0.25, 0.5, min(gr.x,gr.y));\n}\n\nfloat b(int n, int b) { return float(mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0); }\n\nfloat pa(vec2 uv, int g) {\n\tconst ivec3 n[] = ivec3[](\n\t\tivec3(0x9F00, 0x27C8, 0x0112),\n        ivec3(0x8F00, 0x27C8, 0x00F2),\n        ivec3(0x9F00, 0x2040, 0x01F0),\n        ivec3(0x8F00, 0x2448, 0x00F2),\n        ivec3(0x9F00, 0x27C0, 0x01F0),\n        ivec3(0x9F00, 0x27C0, 0x0010),\n        ivec3(0x9F00, 0x2340, 0x01F2),\n        ivec3(0x9100, 0x27C8, 0x0112),\n        ivec3(0x1F00, 0x8102, 0x01F0),\n        ivec3(0x1F00, 0x2204, 0x00F1),\n        ivec3(0x9100, 0x21C4, 0x0111),\n        ivec3(0x8100, 0x2040, 0x01F0),\n        ivec3(0x9100, 0x254D, 0x0112),\n        ivec3(0x9100, 0x2549, 0x0113),\n        ivec3(0x9F00, 0x2448, 0x01F2),\n        ivec3(0x9F00, 0x27C8, 0x0010),\n        ivec3(0x9F00, 0x2548, 0x0171),\n        ivec3(0x9F00, 0xA7C8, 0x0190),\n        ivec3(0x9F00, 0x07C0, 0x01F2),\n        ivec3(0x1F00, 0x8102, 0x0040),\n        ivec3(0x9100, 0x2448, 0x01F2),\n        ivec3(0x9100, 0x4448, 0x0041),\n        ivec3(0x9100, 0xA548, 0x00A2),\n        ivec3(0x1100, 0x4105, 0x0111),\n        ivec3(0x1100, 0x8105, 0x0040),\n        ivec3(0x1F00, 0x4104, 0x01F0)\t\n\t);\n\t\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tr = max(r, p(uv, i   )*b(n[g].x,i));\n\t\tr = max(r, p(uv, i+16)*b(n[g].y,i));\n\t\tr = max(r, p(uv, i+32)*b(n[g].z,i));\n\t}\n\treturn r;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = vec2(1,-1) * (2.*I - iResolution.xy) / iResolution.y;\n    vec2 grid = ( uv + vec2(iTime*0.05,0.0))*GRID_SCALE;\n    \n    #ifdef OFFSET_ROWS\n    grid -= vec2(mod(floor(grid).y,2.0)*0.5,0.0);\n    #endif\n    \n    float glyph = pa(1.0/GLYPH_SCALE*(fract(grid)-0.5)+0.5,\n        int(hash12(floor(grid))*26.));\n\n    if(iMouse.z > 0.)\n        glyph = pa(uv*0.5 + .5,int(iMouse.x/iResolution.x*26.));\n\n    O = vec4(glyph);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}