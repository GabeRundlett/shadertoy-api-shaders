{
    "Shader": {
        "info": {
            "date": "1596542501",
            "description": "nice sin?",
            "flags": 0,
            "hasliked": 0,
            "id": "WlsBWr",
            "likes": 26,
            "name": "nice sin",
            "published": 3,
            "tags": [
                "sin"
            ],
            "usePreview": 0,
            "username": "curiouspers",
            "viewed": 661
        },
        "renderpass": [
            {
                "code": "// Raymarching part from \"Sphere Gears - Step 1\" by iq. https://shadertoy.com/view/ws3GD2\n// 2020-08-03 19:04:37\n\n// Created by curiouspers 04/08/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// set AA 2 if you have beafy pc\n#define AA 2\n#define OPTIMIZE 1\n\n// not worth it, too different look\n#define SIMPLERAO 0\n#define ORTHOANIM 0\n\n// #define SDBOX( p, r ) (  length(max(abs(p)-r,0.)))\n\nfloat hash( in float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdBox( in vec3 p, in vec3 r )\n{\n    vec3 d = abs(p)-r;\n    return length(max(d,0.));\n}\nfloat displacement(in vec3 p, in float force){\n\treturn (sin(force*p.z*1.0)/2.) / force;\n}\n\nvec4 map( in vec3 p, float time )\n{\n    vec3 boxSize = vec3(0.03, 0.2, 0.4);\n    vec3 start = vec3(0.32,-0.1,0.0);\n    vec3 dif = vec3(0.08,0.0,-0.015);\n    float d = 0.1;\n    \n    p -= start;\n    \n    #if OPTIMIZE\n    // bounding box\n    float bbox = sdBox( p+vec3(0.495,-0.09,0.), vec3(0.54, 0.2, 0.65) );\n    if (bbox < 0.05){\n    #endif\n        \n    float t = iTime*1.75;\n    float an1 = smoothstep(0.0,1.0,(sin(t+10.26)*.5+.6));\n    an1 *= an1;\n    float an2 = smoothstep(0.0,1.0,(sin(t+0.6)*.5+.6));\n    an2 *= an2;\n    float an3 = smoothstep(0.0,1.0,(sin(t+42.745)*0.5+0.6));\n    an3 *= an3;\n    float an4 = smoothstep(0.0,1.0,(sin(t+0.345)*0.5+0.6));\n    an4 *= an4;\n    float an5 = smoothstep(0.0,1.0,(sin(t+142.745)*0.6+0.6));\n    an5 *= an5;\n    float an6 = smoothstep(0.0,1.0,(sin(t+2.135)*0.6+0.6));\n    an6 *= an6;\n    float an7 = smoothstep(0.0,1.0,(sin(t+3.956)*0.7+0.6));\n    an7 *= an7;\n    float an8 = smoothstep(0.0,1.0,(sin(t+1.3)*0.7+0.6));\n    an8 *= an8;\n    \n\t#if 0\n    p.z = p.z*(0.8*smoothstep(0.0,1.0,(sin(t/4.)*2.6+.0)));\n\t#else\n\tp.z = p.z*0.8;\n\t#endif\n    vec3 q = p;\n    \n\n    for(float i=0.01; i<13.; i+=1.){\n        q=p+dif*i;\n        \n        #if OPTIMIZE\n        float bbox = sdBox( q +vec3(0.,-0.1,0.), vec3(boxSize.x, boxSize.y*1.0, boxSize.z) );\n        //d = min(d, bbox);\n        if (bbox >= 0.064){\n            continue;\n        }\n        #endif\n        \n        float h = hash(i*i/3.);\n        float h2 = hash(h*i/3.);\n        float c2 = mod(i-0.01, 2.);\n        float c3 = mod(i-0.01, 3.);\n        float c4 = mod(i-0.01, 4.);\n        float c5 = mod(i-0.01, 5.);\n        float c6 = mod(i-0.01, 6.);\n        vec3 qd = q+vec3(0.,0.,0.1)*h;\n        \n        if (i<1.){\n            q.y += displacement(q, 40.)*0.8;\n            float dis = displacement(qd+vec3(0.,0.,1.), 30.)*1.0 ;\n            q.y += dis+dis*an1;\n            q.y += \t\tdisplacement(qd+vec3(0.,0.,0.2), 60.)*1.0 * an3;\n\t\t} else {\n            q.y += (displacement(qd+vec3(0.,0.,1.2*h2), 20.)*0.9) ;\n            q.y += (displacement(qd+vec3(0.,0.,1.1*h),  20.)*an4*1.0) * c2 ;\n            q.y += (displacement(qd+vec3(0.,0.,1.9*h2), 20.)*an5*0.5) * c3;\n            q.y += (displacement(qd+vec3(0.,0.,1.5*h),  30.)*an6*0.7) * c4;\n            q.y += (displacement(qd+vec3(0.,0.,6.2*h),  30.)*an7*0.4) * c5;\n            q.y += (displacement(qd+vec3(0.,0.,2.2*h),  40.)*an8*0.3) * c6;\n    \t}\n        q.y += smoothstep(0.9,1.1,abs(q.z+dif.z)/boxSize.z)/10.; // edges\n        float d2 = sdBox( q, boxSize);\n        d = min(d, d2);\n        \n        // if hit box in front - skip all next boxes\n        #if OPTIMIZE\n        if (d2<0.0135)\n            break;\n        #endif\n    }\n\t\n    #if OPTIMIZE\n    }\n    #endif\n\n    //d = min(bbox,d);\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    #if SIMPLERAO\n    int   a = 3;\n    float b = 1.;\n    #else\n    int   a = 5;\n    float b = 4.;\n    #endif\n    \n    for( int i=ZERO; i<a; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/b;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 1.9;\n    float tmax = 3.1;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time)/2.;\t\t\t//hack\n        if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\n\t    // camera\t\n        float an = 1.0;// 6.2831*time/40.0;\n        vec3 ta = vec3( 0.0, 0.1, 0.0 )*1.9;\n    \tvec3 ro = vec3(1., 1.2, 2.);// ray origin (camera pos)\n    \t//ro = vec3(0., 1.2, 2.);// ray origin (camera pos)\n        //vec3 ro = ta + vec3( 0.5*cos(an), 0.2, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0. );\n        \n        // ray direction\n        float fl = 4.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n        \n    #if !ORTHOANIM\n    float f = 0.56;\n\t#else\n\tfloat f = iMouse.x/iResolution.x;\n    #endif\n        \n    vec3 rd_orth = setCamera(ro, ta, 0.)*normalize(vec3(0., 0., 1.0));// ray direction via orthographic projection\n    rd = mix(rd, rd_orth, f);\n\n    #if ORTHOANIM\n    float orthRectSize = .0 + 3.0*iMouse.y/iResolution.y;\n    vec3 ro_orth = ro + vec3(p * orthRectSize, 0.);// ray origin \n    ro = mix(ro, ro_orth, f);\n    #endif\n        \n\n        // background\n        vec3 bcol = vec3(0.01, 0.7, 1.0);\n        vec3 tcol = vec3(0.71, 0.35, 0.87)-0.25;\n        vec3 col = mix(bcol, tcol, p.y*.5+0.5 /*1.0+rd.y*/);//vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        \n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n            vec3 l = vec3(2.0,1.0,-1.);\n            float ndl = dot(nor,l)*.4+.6;\n            vec3 amb = col*.5;\n            float rim = (dot(rd,nor)*.5+.5);\n            rim = clamp(0.0,1.0,(pow(rim,1.)));\n            float invRim = 1.0-rim;\n            invRim*=invRim*invRim*invRim;\n                        \n            float y = tuvw.y;\n            y = y*y*8.5;\n            y += 2.0;\n            y /= 3.0;\n            tcol = vec3(0.823, 0.686, 0.992)*0.8;\n\t\t\tcol = mix(bcol, tcol, y);\n            \n            col = col*ndl+amb;\n            col *= col + sin(tuvw.yyy*3000.)*col*0.9*invRim * nor.y + rim;\n            \n    #if SIMPLERAO\n            float ao = calcAO( tuvw.yzw, nor, time )*1.5;\n            ao += 3.0*ao*(1.-nor.y); // top\n            float side = nor.x*(1.-ao)*.8;  // side\n            ao += side;\n            ao *= ao;\n            col = mix(col,col*ao/.9,0.6);\n    #else\n            float ao = calcAO( tuvw.yzw, nor, time )*1.2;\n            ao += 2.0*ao*(1.-nor.y); // top\n            ao += nor.x*(1.-ao)*.2;  // side\n            col = mix(col,col*ao/.9,0.6);\n    #endif\n            \n            // color correction\n            col *= 0.5;\n            col *= col + nor.y*0.4;\n            //col = vec3(ao);\n        }\n            \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // gamma        \n    tot = pow(tot,vec3(0.45) );\n    \n    // cheap dithering to remove banding\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    // show banding\n    #if 0\n    tot = floor(tot*255.)/255.;\n    tot = (abs(dFdy(tot))+abs(dFdx(tot)))*200.0;\n    #endif\n\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}