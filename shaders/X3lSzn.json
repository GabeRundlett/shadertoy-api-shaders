{
    "Shader": {
        "info": {
            "date": "1709086020",
            "description": "Color tests",
            "flags": 0,
            "hasliked": 0,
            "id": "X3lSzn",
            "likes": 11,
            "name": "SDF Edge Color tests",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "template"
            ],
            "usePreview": 0,
            "username": "tristanantonsen",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////\n// Tristan Antonsen 2023\n////////////////////////////////////////////////////////////////\n// References\n// Distance functions & structure based on Inigo Quilez's (iq) shaders & functions https://iquilezles.org/\n// Ray marcher inspired by iq's work and The Art of Code's work (https://www.shadertoy.com/view/XlGBW3)\n\n// Ray marching constants\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n////////////////////////////////////////////////////////////////\n// Noise\n////////////////////////////////////////////////////////////////\n\n// Hash & voronoi from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\n// Main reference: https://iquilezles.org/articles/distfunctions/\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r)\n{\n    // Modified to account for the radius without changing the size of the box\n    p = abs(p)-(s-r);\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// fromhttps://mercury.sexy/hg_sdf/\nfloat opChamfer(float a, float b, float r)\n{\n    return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU);\n    p = rotX(p, m.y*PI + PI);\n    return p;\n}\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 po) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = orbitControls(po);\n\n    vec2 res;\n    vec3 pSym = vec3(abs(p.x), p.yz);\n\n    // Cage thing\n    vec3 cageCenter = vec3(-0.7,0.,0.);\n\n    float s = sdSphere(p-cageCenter,vec3(0.),1.);\n    res = vec2(s, 1.0); // id to track color     \n\n    float rc = 0.3;\n    float cyl1 = sdRoundedCylinder(p-cageCenter, rc, 0.05, 1.);\n    float cyl2 = sdRoundedCylinder(rotZ(p-cageCenter, PI/2.), rc, 0.05, 1.);\n    float cyl3 = sdRoundedCylinder(rotX(p-cageCenter, PI/2.), rc, 0.05, 1.);\n    \n    \n    float cyls = opSmoothUnion(cyl1, opSmoothUnion(cyl2, cyl3, 0.), 0.0);\n    res.x = opSmoothSubtraction(res.x, cyls, 0.);\n    \n    // set light blue\n    if (cyls < res.x) {res.y = 2.;};\n\n    float b = sdRoundedBox(p-cageCenter, vec3(0.75), 0.);\n\n    // set dark blue\n    res.x = opSmoothIntersection(res.x, b, 0.);\n    if (res.x < b + 0.0001) {res.y = 3.;};\n    \n    \n    // Sphere cube\n    float d1 = sdSphere(p, vec3(1.6,0.4,0.4), 0.6);\n    float d2 = sdRoundedBox(p-vec3(0.8,0.,0.), vec3(.5), 0.05);\n    \n    float blendRadius = 0.07;\n    float d3 = opChamfer(d1, d2, blendRadius); // id to track color     \n    //float d3 = opSmoothUnion(d1, d2,0.1); // id to track color  \n    //float d3 = opUnion(d1, d2); // id to track color  \n    \n    //d3 = opSubtraction(d2, d1); // id to track color     \n    //d3 = opIntersection(d2, d1); // id to track color    \n    \n    // set sphere cube color\n    if (d3 < res.x) {res.y = 1.;};\n    res.x = opUnion(res.x, d3);\n    \n    \n        \n    // *Very* hacky edge coloring. Difficult to get constant line width.\n    float thresh = 0.006;\n    thresh = float(iResolution.y) / 100000.;\n    \n    float e = min(max(abs(cyl1), abs(cyl2)), max(abs(cyl2), abs(cyl3)));   // edges between cyl1 & cyl2 + cyl2 & cyl3\n          e = min(e, max(abs(cyl3), abs(cyl1)));  // edges between cyl3 & cyl1\n          e = min(e, max(abs(b), abs(cyls)));     // edges between cyls & b\n          //e = min(e, (max(d1, d2)));       // edges between cube & sphere (different threshold b/c of blends?)\n          e = min(e, (max(d1, d2) - blendRadius / 2.15));       // edges between cube & sphere (different threshold b/c of blends?)\n    \n    if (e - thresh < 0.) { res.y = -1.;};         // set color to edge \n        \n\n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        minDist = min(minDist, ds.x);\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., 0., -10.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        float c = 0.5 *sin(2. * iTime) + 0.5;\n\n        if (d.y == 1.0) color = vec3(0.7);\n        if (d.y == 2.0) color = vec3(0., 225., 248.) / 255.;\n        if (d.y == 3.0) color = vec3(0.2,0.2,0.5);\n        if (d.y == -1.0) color = vec3(1., 0., 0.) * c;\n        \n        color *= illumination; \n        \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        color += specular * 0.08;\n         \n         \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45;\n       \n        fragColor = vec4(color, 1.0);\n\n        \n    }\n\n        \n        \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}