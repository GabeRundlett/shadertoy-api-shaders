{
    "Shader": {
        "info": {
            "date": "1553306024",
            "description": "I tool for exploring and making art with fractals in real-time. I've written short excerpts to explain which each setting does.\n\nGood sources for coordinates for Mandelbrot zooms here:\nhttp://www.cuug.ab.ca/dewara/mandelbrot/Mandelbrowser.html",
            "flags": 0,
            "hasliked": 0,
            "id": "tsjXzm",
            "likes": 1,
            "name": "Fractal Art",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "Mrfixit13",
            "viewed": 368
        },
        "renderpass": [
            {
                "code": "//SETTINGS\n\n//MODES-----------------------------------------------------------------------------\n//Mode 0: Julia set based on mouse coords\n//Mode 1: Mandelbrot set based on mouse coords\n//Mode 2: Julia set based on JULIA_SET option\n//Mode 3: Normal Madelbrot set\n#define MODE 0\n\n\n//QUALITY---------------------------------------------------------------------------\n//max number of iterations. Higher numbers = more detail\n#define MAX_ITER 128\n\n//Sets the square root of the number of supper sampls 1 = 1 sample 2 = 4 samples 3 = 9 samples \n//Recomend setting is 2. Set to 1 for better framerate\n#define SAMPLES 3\n\n\n//CONTROLS--------------------------------------------------------------------------\n//Sets the coordinates of the center in fractle space\n#define CENTER vec2(0.0, 0.0)\n\n//Higher values = more precision\n#define MOUSE_PRECISION 2.1\n\n//Only applys to mode 2\n#define JULIA_SET vec2(-0.123, 0.745)\n\n\n//ZOOM------------------------------------------------------------------------------\n//Higher values = more zoomed\n#define ZOOM 0.7\n\n//Controls how fast we zoom in\n#define ZOOM_RATE 0.0\n\n\n//COLORS----------------------------------------------------------------------------\n//The colors we use to render. Set to 0, 1, 2, or 3\n#define COLOR_SCHEME 0\n\n//The number of times we repeat our color scheme\n#define COLOR_REPETITION 1.0\n\n//Set to 0 to disable smooth colors. Set to 1, 2, 3, or 4 to smooth\n#define SMOOTH_COlORS 1\n\n\n//COLOR SCHEMES---------------------------------------------------------------------\n//You can modify any of the color schemes simply by adding or removing colors from the list\n#if COLOR_SCHEME == 0\nvec3 colors[] = vec3[](\n    vec3(0.156, 0.172, 0.203),\t//black\n    vec3(0.745, 0.313, 0.274),\t//red-2\n    //vec3(0.878, 0.423, 0.458),\t//red-1\n\tvec3(0.819, 0.603, 0.400),\t//orange\n\tvec3(0.898, 0.752, 0.482),\t//yellow\n   \tvec3(0.596, 0.764, 0.474),\t//green\n    vec3(0.337, 0.713, 0.760),\t//cyan\n    vec3(0.380, 0.686, 0.937),\t//blue\n    vec3(0.776, 0.470, 0.866),\t//purple\n\tvec3(0.156, 0.172, 0.203));\t//black\n\n#elif COLOR_SCHEME == 1\nvec3 colors[] = vec3[](\n    vec3(0.156, 0.172, 0.203),\t//black\n    vec3(0.380, 0.686, 0.937),\t//blue\n    vec3(0.898, 0.752, 0.482),\t//yellow\n    vec3(0.819, 0.603, 0.400),\t//orange\n   \tvec3(0.745, 0.313, 0.274),\t//red-2\n\tvec3(0.156, 0.172, 0.203));\t//black\n\n#elif COLOR_SCHEME == 2\n  \nvec3 colors[] = vec3[](    \n    //vec3(0.156, 0.172, 0.203),\t//black\n    vec3(0.745, 0.313, 0.274),\t//red-2\n\tvec3(0.819, 0.603, 0.400),\t//orange\n\tvec3(0.898, 0.752, 0.482),\t//yellow\n    vec3(0.337, 0.713, 0.760),\t//cyan\n    vec3(0.380, 0.686, 0.937),\t//blue\n\tvec3(0.156, 0.172, 0.203));\t//black\n\n#else \nvec3 colors[] = vec3[]( \n    vec3(0.156, 0.172, 0.203),\t//black\n    vec3(0.878, 0.423, 0.458),\t//red-1\n\tvec3(0.819, 0.603, 0.400),\t//orange\n\tvec3(0.898, 0.752, 0.482),\t//yellow\n   \tvec3(0.596, 0.764, 0.474),\t//green\n    vec3(0.380, 0.686, 0.937),\t//blue\n    vec3(0.776, 0.470, 0.866),\t//purple\n\tvec3(0.156, 0.172, 0.203));\t//black\n#endif\n#define NUM_COLORS (colors.length())\n\n\n//PROCEDURAL COLOR------------------------------------------------------------------\n//described here https://iquilezles.org/articles/palettes\n#define USE_PROCEDURAL_COLORS 0\n#define A vec3(0.5, 0.5, 0.5)\n#define B vec3(0.5, 0.5, 0.5)\n#define C vec3(1.0, 1.0, 1.0)\n#define D vec3(0.45, 0.55, 0.65)\n\n\n//OTHER-----------------------------------------------------------------------------\n//higher values = more blur\n#define BLUR vec2(0.0)\n\n//Escape radius used for fractal calcualtion\n#define ESCAPE_RADIUS 3.1\n\n\n\nfloat fractal(vec2 p0, vec2 pc, int max_iter)\n{\n\tvec2 p = p0;\n    \n    for(int it = 0; it < max_iter; ++it)\n    {    \n      \n     \tif(dot(p, p) > ESCAPE_RADIUS*ESCAPE_RADIUS)\n\t\t\t#if   SMOOTH_COlORS == 1\n            return float(it) - log2(log(length(p)));\n        \t#elif SMOOTH_COlORS == 2\n\t\t\treturn float(it) - log2(log2(length(p)));\n        \t#elif SMOOTH_COlORS == 3\n        \treturn float(it) - log2(log(dot(p, p)));\n        \t#elif SMOOTH_COlORS == 4\n        \treturn float(it) - log2(log2(dot(p, p)));\n        \t#else\n        \treturn float(it);\n        \t#endif\n\n     \tfloat x = p.x * p.x - p.y * p.y + pc.x;    \n     \tp.y = 2.0 * p.y * p.x + pc.y;\n     \tp.x = x;\n    }\n    \n    return float(max_iter);\n}\n\nvec3 sample_color_linear(float t)\n{   \n    float s = float(NUM_COLORS-1) * t;\n    return mix(colors[int(floor(s))], colors[int(ceil(s))], fract(s));\n}\n\n\nvec3 sample_color_procedural(float t)\n{    \n    return (A + B * cos(2.0 * 3.1415*(C * t + D)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = ZOOM - 1.0 + exp(iTime * ZOOM_RATE);\n    vec2 uv \t= (((fragCoord + vec2(0.5)) * 2.0 - iResolution.xy) / iResolution.yy) / zoom + CENTER;\n    vec2 mouse \t= (((iMouse.xy + vec2(0.5)) * 2.0 - iResolution.xy) / iResolution.yy) / MOUSE_PRECISION;  \n    vec2 pixel_size = (vec2(2.0) + BLUR * 10.0) / iResolution.yy / zoom;\n\n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i < SAMPLES; ++i)\n    {\n        for(int j = 0; j < SAMPLES; ++j)\n        {\n            vec2 offset = ((vec2(i,j) + vec2(0.5)) / vec2(SAMPLES) - vec2(0.5)) * pixel_size;\n           \n    \t\t#if   MODE == 0 || MODE > 3\n            float iter = fractal(uv + offset, mouse, MAX_ITER);\n            #elif MODE == 1\n            float iter = fractal(mouse, uv + offset, MAX_ITER);\n            #elif MODE == 2\n            float iter = fractal(uv + offset, JULIA_SET, MAX_ITER);\n            #else\n            float iter = fractal(vec2(0.0), uv + offset, MAX_ITER); \t\n            #endif\n            \n            iter /= float(MAX_ITER);\n            iter = mod(max(0.0, iter) * COLOR_REPETITION, 1.00001);\n    \t\t//iter = sqrt(iter);\n            \n            #if USE_PROCEDURAL_COLORS\n\t\t\tcolor += sample_color_procedural(iter);\n            #else\n           \tcolor += sample_color_linear(iter);\n            #endif\n        }\n    }\n    \n    color /= float(SAMPLES * SAMPLES);\n   \t//color += (texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy).xyz - vec3(0.5)) * (1.0 / 255.0);\n   \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}