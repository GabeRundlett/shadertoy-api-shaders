{
    "Shader": {
        "info": {
            "date": "1720133180",
            "description": "A number of non-moving shaders (4 out of 5 by shadertoyjiang) that I was curious to see with some simple animation.\n\nSee code for credits and links.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "M3VXzy",
            "likes": 4,
            "name": "(Re)animated",
            "published": 3,
            "tags": [
                "fractal",
                "flower",
                "animated",
                "collection",
                "reanimated"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 124
        },
        "renderpass": [
            {
                "code": "/* A number of static shaders (4 out of 5 by shadertoyjiang) that I was curious to see with some simple animation.\n\n1. Newton Flower 4 by shadertoyjiang (erased?)\n2. Third flower by shadertoyjiang (https://www.shadertoy.com/view/cd2fDG)\n3. Mandel by shadertoyjiang (erased?)\n4. Second flower by shadertoyjiang (https://www.shadertoy.com/view/DdSfRK)\n5. BC: Box Pattern by BackwardsCap (https://www.shadertoy.com/view/dtyczD)\n\n*/\n\n#define TIME_PER_FX 4\n\n// Newton Flower 4 by shadertoyjiang (erased?)\nvoid mainImage1( out vec4 O, vec2 u )\n{\n\tvec2 g,q,R=iResolution.xy,\n\tv=24.*(u+u-R)/R.y,h;//=v;\n\n\tfloat a,r,s,i;  //,p=5., l=1.;\n\n\tfor(;i++<10.   ;)\n\n\t\ta=atan(v.y, v.x)+.618,\n\n\t\tr=length(v)*.7,      //(p-1.5   )/p,\n\t\t\n        s=.2/r/r/r/r,     //s=l/(p*pow(r, p-l)),\t\t\n\n\t\tg=q,q=v, \n\n\t\tv=vec2(r*cos(a+sin(iTime)*0.25)-s*cos(-4.*a),   // -4.=1.-p\n\n\t\t       r*sin(a+cos(iTime*0.73)*0.25)-s*sin(-4.*a))\n               \n       /*可注销 // */  ,  i<3.       ? h = v : h \n           ;\n\n    g = abs(q - g);\n\th = abs(v - h);\n\ts =g.x * g.y;\n\n\tO = vec4( 1.7 * log(1. + s) - .8\n\t\t,     .25 * log(1. + h.x * h.y) - .4 \n\t\t,     .3  * log(1. + s * s) - .1\n\t\t, 1.);\n}\n\n\n// Third flower by shadertoyjiang (https://www.shadertoy.com/view/cd2fDG)\nvoid mainImage2( out vec4 O, vec2 u ){\n\n    float a,r,s,i;\n\n    vec2  g,h,q, R = iResolution.xy,\n\n          v = 2.1*(u+u-R)/R.y + vec2(5,7.7);\n\n    float time = iTime*0.6;\n\n    for (;i++<12.;) \n\n        a = atan(v.y, v.x) + .7,\n\n        r = length(v)* .5,\n\n        s = .1 / r / r,  \n\n        g = q, q = v,  // v, q, g = memory of v over 3 steps\n\n        v =  vec2(r * cos(a+sin(time)*0.25+0.2) - s * cos(a + a),  \n\n                  r * sin(a+sin(time*0.73)*0.25+0.2) + s * sin(a + a)),\n\n        i<2. ? h=v : h;\n\n    g = abs(q - g);\n\n    h = abs(v - h);\n\n    s = g.x * g.y;  \n\n    O = log(1.+vec4(s, h.x*h.y, s*s, 0 )) * vec4(4,.2,.1,1); O.r -= 2.8;\n}\n\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a)) // rot\n\n// Mandel by shadertoyjiang (erased?)\nvoid mainImage3( out vec4 O, in vec2 w ) {\n\tvec2 R = iResolution.xy,\n    \n         c = (.5 * R - w.xy ) / R.x * (3.+sin(iTime)*2.),\n\n         u,v,d;\n\n    c*=rot(iTime*0.4);\n\tc.x-=0.63;c.y-=0.0;\n\n\n\tfloat l = 1.,i,j,t,m = 99.,n = m + l ;  //,s = .5;\n\n\tfor(;i++<77.;)\n\t{\n\t\tu = vec2(u.x * u.x -u.y * u.y, 2. * u.x * u.y) + c;\n\n\t\tt = dot(u,u);\n\n\t\tif(t < m)\n\t\t{ \n\t\t\tn = m; m = t ;j++;\n\t\t} \n\t\telse if(t < n) n = t;\n\n\t\tif(t > 99.) break;\n\n\t}\n\n\tt= l /(pow (m, .5) + l);\n\n\ti= 1.4 * (m / n + t) * pow(t, .5);\n\n         O.xyz = .5 + .5 * cos(6.28 * pow(l / (l + i) + i,.5) + vec3(0.,.4,.7));\n}\n\n\n// Second flower by shadertoyjiang (https://www.shadertoy.com/view/DdSfRK)\nvoid mainImage4( out vec4 O, in vec2 u ){\n    float a,r,s;\n    vec2 g,h,q, R=iResolution.xy,\n                                                                                       //v= 36.*(u-.5*R)/R.y + vec2(22.,34.);\n    // 36.                                                                                   // v= 30.*(u-.5*R)/R.y + vec2(18., 32);\n    v = 32. * (u - .5 * R) / R.y \n        * mat2(1., -.05, .05, 1.)     // 可以不要，旋转图片\n        + vec2(21., 34); // (20., 34.);\n   \n    float time = iTime*0.6;\n    for (int i;i<12;i++) \n    { \n        a = atan(v.y, v.x) + .613;  //615\n                                                                                       // a += .01 * sin(iTime);\n        r = length(v) *.5;\n        s = .3 / r / r;                                                                //.333  1./3.           //  thanks to Observer // s = 1. / 3. / pow(r, 2.); \n                                                                                       // 原先想改 .333 ，但怕不够精确，试了 Observer 改的代码，居然可以 。 想到sqr()，没想到 r*r        \n        g = q; q = v; v =\n        vec2(r * cos(a+0.05+sin(time)*0.2) - s * cos(a + a),                                              // - s * cos(-2. * a);  thanks to Observer\n             r * sin(a+0.2+cos(time*0.73)*0.2) + s * sin(a + a));                                             // - s * sin(-2. * a) \n\n        if(i<1) h=v;\n    }\n    \n    g = abs(q - g);h = abs(v - h);\n    \n                      s = g.x * g.y;\n                          \n    O =vec4(4. * log(1. + s) - 3.,\n            .2 * log(1. + h.x * h.y) - .38, //调节树枝粗细\n            .1 * log(1. + s * s) ,          //调节红与粉  .1   .2\n            1.);\n}\n\n\n#define TAU 6.283\n#define pow(a,b) pow(abs(a),b)\n\nvec2 f(vec2 p)\n{\n    vec2 t = vec2(pow(p.x,2.)-pow(p.y,2.), -2.*p.x*p.y);\n    t *= sin(iTime*1.)*1. + 1.05;\n    float b = pow(p.x,4.) + pow(p.y,4.) + 2.*pow(p.x,2.)*pow(p.y,2.);\n    return (t/b)-(p/3.);\n}\n\nvec2 P(vec2 p, float i)\n{\n    vec2 v = f(f(f(f(f(f(p))))));\n    float ti = TAU * (i/3.0);\n    \n    #ifdef SHIFT\n    ti -= iTime - p.x * p.x * length(p);\n    #endif\n\n    return v - vec2(cos(ti),sin(ti));    \n}\n\n\n#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n// BC: Box Pattern by BackwardsCap (https://www.shadertoy.com/view/dtyczD)\nvoid mainImage5( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    uv *= R(iTime * 0.25);\n\n\n    float p0 = length(P(uv, 1.0)), p1=length(P(uv,2.0)), p2=length(P(uv,3.0));\n\n    \n\n    vec3 c = vec3(0);\n\n    \n\n    if(p0 <= min(p1,p2)) c = vec3(0.557,0.286,0.961);\n\n    if(p1 <= min(p2,p0)) c = vec3(0.000,0.114,0.643);\n\n    if(p2 <= min(p0,p1)) c = vec3(0.129,0.376,0.780);\n\n    fragColor = vec4(c,1.0);\n}\n\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    int i = (int(iTime) % (5 * TIME_PER_FX)) / TIME_PER_FX + 1;\n\n    switch(i) {\n        case 1: mainImage1(O, u); break;\n        case 2: mainImage2(O, u); break;\n        case 3: mainImage3(O, u); break;\n        case 4: mainImage4(O, u); break;\n        case 5: mainImage5(O, u); break;\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}