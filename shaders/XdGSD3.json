{
    "Shader": {
        "info": {
            "date": "1466867140",
            "description": "Press R for start the game.\nUse the arrow keys to move and space to shoot. \n\nBe quick or you'll end up infected !!!\n",
            "flags": 56,
            "hasliked": 0,
            "id": "XdGSD3",
            "likes": 3,
            "name": "Virus Attack!  [MIGJRV] ",
            "published": 3,
            "tags": [
                "raymarching",
                "game",
                "pgatr",
                "migjrv",
                "celularmap"
            ],
            "usePreview": 0,
            "username": "Jorcassa",
            "viewed": 876
        },
        "renderpass": [
            {
                "code": "const int N_STEPS = 17;\nconst float NEAR = 0.001;\nconst float FAR = 100.0;\nconst float DELTA = 0.002;\n\n\nvec3 debug = vec3( 0.0 );\n\nconst vec3 colorBox = vec3( 1.0, 0.0, 0.0 );\nconst vec3 colorCylinder = vec3( 0.0, 1.0, 0.0 );\nconst float PI = 3.14159265359;\t\n\n//coordenadas en las texturas\n//coords para los datos\nconst vec2 coordAntivirus = vec2( 0.0, 0.0 ); //x -> dcha/izq relativo; y-> dcha/izq virus; z->up virus\nconst vec2 coordState\t  = vec2( 1.0, 0.0 ); //x->Start; y->win z->loose w->time\nconst vec2 coordSound\t  = vec2( 2.0, 0.0 ); //x->b1; y-> explosion  z->loose w->win\nconst vec2 coordBullet\t  = vec2( 3.0, 0.0 ); //x->pos; y-> altura  z->si hay\nconst vec2 coordV1\t      = vec2( 4.0, 0.0 ); //x->pos; y-> altura  z->si hay\nconst vec2 coordV2\t      = vec2( 5.0, 0.0 ); //x->pos; y-> altura  z->si hay\nconst vec2 coordV3   \t  = vec2( 6.0, 0.0 ); //x->pos; y-> altura  z->si hay\nconst vec2 coordVA1       = vec2( 7.0, 0.0 );\nconst vec2 coordVA2       = vec2( 8.0, 0.0 );\n\n//vars de los datos\nfloat posAntiv = 0.0;\nvec4 state = vec4( 0.0 );\nvec4 bulletInfo = vec4( 0.0 );\nvec4 v1Info     = vec4( 0.0 );\nvec4 v2Info     = vec4( 0.0 );\nvec4 v3Info     = vec4( 0.0 );\nvec4 vA1Info    = vec4( 0.0 );\nvec4 vA2Info\t= vec4( 0.0 );\n\n\nfloat gameTime  = 0.0;\n\n//funciones para el mapa cellular\nvec2 Hash2(vec2 p)\n{\n\tfloat r = (iTime*0.0002)*523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n    \n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\nvec4 CellularMap( vec2 uv )\n{\n\tvec4 distancias = vec4 (9999.9, 9999.9, 9999.9, 9999.9);\n    vec4 distancias2 = vec4 (9999.9, 9999.9, 9999.9, 9999.9);\n\n\n\tvec2 r = vec2( uv ) * 13.0;\n\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 pixel = backgroundColor;\n\t\n\tvec2 celda = floor(r);    \n\t\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t\t\t// visit neighborhood\n      for (int j=-1; j<=1; j++)\t\n      {\t\t\t\t\t\t\t// to find the closest point\n\t\t  vec2 vecino = celda + vec2(float(i),float(j)); \t\t// neighbor cells\n\t\t  vec2 hash = Hash2(vecino);\t \t\t\t\t\t\t\t// cell ID\n\t\t  vec2 p_final = vec2(vecino.x + hash.x, vecino.y + hash.y);\t// random point in cell\n\t\t  float dist = length(p_final-r);\t\t\t  \t\t\t\t// dist to point\n\t\t  \n\t\t  if(dist < distancias[0])\n          {\n\t\t\t  distancias[3] = distancias[2];\n\t\t\t  distancias[2] = distancias[1];\n\t\t\t  distancias[1] = distancias[0];\n\t\t\t  distancias[0] = dist;\n\t\t  } \n\t\t  else if(dist < distancias[1])\n          {\n\t\t\t  distancias[3] = distancias[2];\n\t\t\t  distancias[2] = distancias[1];\n\t\t\t  distancias[1] = dist;\n\t\t  }\n\t\t  else if(dist < distancias[2])\n          {\n\t\t\t  distancias[3] = distancias[2];\n\t\t\t  distancias[2] = dist;\n\t\t  }\n\t\t  else if(dist < distancias[3])\n          {\n\t\t\t  distancias[3] = dist;\n\t\t  }\n\t\t  \n\t  }\n\t  \n\t\n\tpixel = vec3( abs( sin( iTime * 0.0002 ) ) * (1.0-distancias[0] ) +\n                  (1.0 - abs( sin( iTime * 0.0002 ) ))  * ( distancias[0] )        ,\n                  0, 0);\n\t\n\treturn vec4( pixel, 1.0);\n}\n\n//funciones de transformacion\nvec3 opTx( vec3 p, vec3 translate, vec3 rotation )\n{\n    mat3 rx = mat3 (\n        \t\t\t\t1.0,               0.0,                0.0,\n        \t\t\t\t0.0, cos( rotation.x ), -sin( rotation.x ),\n\t\t\t            0.0, sin( rotation.x ),  cos( rotation.x )\n        \t\t\t);\n    \n    mat3 ry = mat3 (\n        \t\t\t\t cos( rotation.y ), 0.0, sin( rotation.y ),\n        \t\t\t\t               0.0, 1.0, \t\t\t  0.0,\n\t\t\t            -sin( rotation.y ), 0.0, cos( rotation.y )\n        \t\t\t);\n    \n    mat3 rz = mat3 (\n        \t\t\t\tcos( rotation.z ), -sin( rotation.z ), 0.0,\n        \t\t\t\tsin( rotation.z ),  cos( rotation.z ), 0.0,\n\t\t\t            \t\t\t  0.0, \t\t\t\t  0.0, 1.0\n        \t\t\t);\n    \n    \n    mat3 m = rx * ry * rz;\n    \n    vec3 q =  m * p;\n    q      += translate;\n    \n    return q;\n}\n\n/////funciones para primitivas\n\n\nfloat sdSphere( in vec3 p, in float radius )\n{\n\treturn length( p ) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  return length( max( abs( p ) - b, 0.0 ) );\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat Antibody( vec3 pos )\n{\n    \n    float t = sdCapsule( pos, vec3( 0.0, -5.0, 0.0 ), vec3( 0.0, -4.0, 0.0 ), 0.2  );\n    \n    t = smin( t, sdCapsule( pos, vec3(  0.6, -3.5, 0.0 ), vec3( 0.0, -3.9, 0.0 ), 0.2 ), 0.05 );\n    t = smin( t, sdCapsule( pos, vec3( -0.6, -3.5, 0.0 ), vec3( 0.0, -3.9, 0.0 ), 0.2 ), 0.05 );\n    \n    return t;\n}\n\n\nfloat Virus( vec3 pos )\n{\n    float t = smin( sdSphere( pos, 0.5 ), sdCapsule( pos, vec3( 0.0, 0.7, 0.0 ), vec3( 0.0, -0.7, 0.0 ), 0.06 ), 0.3 );\n    t = smin(                        t, sdCapsule( pos, vec3( 0.7, 0.0, 0.0 ), vec3( -0.7, 0.0, 0.0 ), 0.06 ), 0.3 );\n    return t;\n}\n\nvec4 GetMinObject( float p1, float p2, vec3 color1, vec3 color2 )\n{\n    return p1 < p2 ? vec4( p1, color1 ) : vec4( p2, color2 );\n}\n\n//funciones del ray marching\n//vamos a devolver un vec4 para codificar el color  dependiendo del objeto\nvec4 CreateWorld( vec3 pos )\n{   \n    //v1 y anticuerpo\n    vec4 result = vec4( Antibody( pos + vec3( posAntiv, 0.0, 0.0 ) ), 1.0, 1.0, 1.0 );\n                       \n    vec3 transform  = vec3( v1Info.x, v1Info.y , 0.0 );\n    \n    if( vA1Info.x > 0.0 )\n    {\n    \tresult = GetMinObject(     result.r, \n                               Virus( pos + transform ),\n                               result.gba, \n                               vec3( 0.0, 0.7, 0.5 ) );\n    }    \n    \n    //v2 y anticuerpo\n    if( vA1Info.y > 0.0 )\n    {\n    \ttransform  = vec3( v1Info.z, v1Info.w, 0.0 );\n    \tresult = GetMinObject( \t   result.r, \n                               Virus( pos + transform ),\n                               result.gba, \n                               vec3( 0.0, 0.7, 0.5 ) );\n    }\n    \n    //v3 y anticuerpo\n    if( vA1Info.z > 0.0 )\n    {\n    \ttransform  = vec3( v2Info.x, v2Info.y , 0.0 );\n    \tresult = GetMinObject( \t   result.r, \n                               Virus( pos + transform ),\n                               result.gba, \n                               vec3( 0.0, 0.7, 0.5 ) );\n    }\n    \n    //v4 y anticuerpo\n    if( vA1Info.w > 0.0 )\n    {\n    \ttransform  = vec3( v2Info.z, v2Info.w, 0.0 );\n    \tresult = GetMinObject(     result.r, \n                               Virus( pos + transform ),\n                               result.gba, \n                               vec3( 0.0, 0.7, 0.5 ) );\n    }\n    \n    //v5 y anticuerpo\n    if( vA2Info.x > 0.0 )\n    {\n   \t \ttransform  = vec3( v3Info.x, v3Info.y, 0.0 ); \n    \tresult = GetMinObject( \t   result.r, \n                               Virus( pos + transform ),\n                               result.gba, \n                               vec3( 0.0, 0.7, 0.5 ) );\n    }\n    \n    if( vA2Info.y > 0.0 )\n    {\n    \t//v6 y anticuerpo\n    \ttransform  = vec3( v3Info.z, v3Info.w, 0.0 );\n    \tresult = GetMinObject( \t   result.r, \n                               Virus( pos + transform ),\n                               result.gba, \n                               vec3( 0.0, 0.7, 0.5 ) );\n    }\n    \n    if( bulletInfo.z > 0.0 )\n    {\n        transform  = vec3( 0.0, 0.0 , 0.0 );  \n    \tresult = GetMinObject( \t   result.r, \n                               sdSphere( pos + vec3( bulletInfo.xy, 0.0 ) , 0.1 ),\n                               result.gba, \n                               vec3( 8.0, 0.7, 0.0 ) );\n    }\n    \n    \n    \n    return result;\n}\n\n\n\n//realizamos el raymarching\nvec4 RayMarching( vec3 ro, vec3 rd )\n{\n    vec4 t \t= vec4( NEAR, 0.0, 0.0, 0.0 );\n    vec4 d \t= vec4( 0.0 );\n    \n    for( int i = 0; i < N_STEPS; i++ )\n    {\n        \n\t\tvec3 pos = ro + rd * t.x;        \n       \n\t\td = CreateWorld( pos );\n        \n        if( d.x < DELTA )\n        {\n         \treturn vec4( t.x, d.gba );   \n        }\n        \n        t.x += d.x;\n        \n        if( t.x > FAR )\n        {\n            return vec4( FAR, 0.0, 0.0, 0.0 );\n        }\n            \n    }\n    \n    return vec4( FAR, 0.0, 0.0, 0.0 );\n}\n\n\n\n//obtenemos la direccion del rayo\nvec3 GetCamRay( vec3 ro, vec3 target, vec3 up, vec2 uv, float fov )\n{\n    vec3 dir = normalize( target - ro );\n    \n    vec3 right = normalize( cross( dir, up ) );\n    \n    vec3 upV   = normalize( cross( right, dir ) );\n    \n    vec3 point = ro + dir + right * uv.x * fov + upV * uv.y * fov;\n    \n    return normalize( point - ro );\n    \n}\n\n\n//obtenemos la normal mediante el gradiente\nvec3 GetNormal( vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    CreateWorld(pos+eps.xyy).x - CreateWorld(pos-eps.xyy).x,\n\t    CreateWorld(pos+eps.yxy).x - CreateWorld(pos-eps.yxy).x,\n\t    CreateWorld(pos+eps.yyx).x - CreateWorld(pos-eps.yyx).x );\n\treturn normalize(normal);\n}\n\n\n//para las sombras\nfloat SoftShadow( vec3 ro,vec3 rd )\n{\n\tfloat mask = 1.0;\n    float t = NEAR;\n  \n    for( int i = 0; i < N_STEPS; i++ )\n    {\n\t\tfloat h = CreateWorld( ro + rd * t ).x;\n        \n        mask = min( mask, 8.0*h/t );\n        \n        t += clamp( h, 0.02, 0.10 );\n        \n        if( h<0.001 || t > FAR ) break;\n    }\n    \n    return clamp( mask, 0.0, 1.0 );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = 2.0 *( fragCoord / iResolution.xy ) - 1.0; \n    \n    \n    //------------------------\n    // load game state\n    //------------------------\n    state          = texture( iChannel0, (coordState+0.5)/iChannelResolution[0].xy );\n    posAntiv       = state.x == 0.0 ? 0.5 : texture( iChannel0, (coordAntivirus+0.5)/iChannelResolution[0].xy ).r;\n    bulletInfo     = texture( iChannel0, (coordBullet+0.5)/iChannelResolution[0].xy );\n    v1Info         = texture( iChannel0, (coordV1+0.5)/iChannelResolution[0].xy );\n    v2Info         = texture( iChannel0, (coordV2+0.5)/iChannelResolution[0].xy );\n    v3Info         = texture( iChannel0, (coordV3+0.5)/iChannelResolution[0].xy );\n    vA1Info        = texture( iChannel0, (coordVA1+0.5)/iChannelResolution[0].xy );\n    vA2Info        = texture( iChannel0, (coordVA2+0.5)/iChannelResolution[0].xy );\n    gameTime       = state.w * 60.0;\n    \n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    uv.y *= aspectRatio;\n    \n    //parametros de la camara\n    vec3 ro  \t= vec3( 0.0, 0.0, 10.0 );\n    vec3 target = vec3( 0.0 );\n  \n    //luz direccional \n    vec3 lightDir = normalize( vec3( -1.0, -1.0, -1.0 ) );\n    \n    // ray direction\n\tvec3 rd = GetCamRay( ro, target, vec3( 0.0, 1.0, 0.0 ), uv, 1.0 );\n    \n    //obtenemos la distancia al punto de collision + el color del material correspondiente\n    vec4 t = RayMarching( ro, rd );\n    \n    if( t.x < FAR )\n    {\n        vec3 point = ro + rd * t.x;\n\t\tvec3 normal = GetNormal( point );\n        float NdotL = dot( normal, -lightDir );\n        \n        float mask = SoftShadow(  point, -lightDir );\n        \n        vec3 refl = reflect( rd, normal );\n        float s = max( dot( -rd, normal ), 0.0 );\n        \n        float specularI = pow( s, 16.0 ); \n        \n         vec4 color = vec4( ( t.gba * ( NdotL + specularI ) ) * mask ,1.0) + vec4( 0.1, 0.1, 0.1, 0.0 );\n        \n        if( state.y > 0.0 )\n            fragColor = abs( vec4( cos( iTime * uv.x + 3.0 ), cos( 9.0 * iTime * uv.y - 1.0 ), cos( 3.0 * iTime * uv.x + 3.0 ), 1.0  ) ) * abs ( sin(  ( uv.x + iTime ) * 3.0 ) ) * NdotL * state.y;\n   \t\t\n        if( state.y == 0.0 )\n            fragColor = color;\n    }\n    else\n    {\n        vec4 color = CellularMap( uv );\n        fragColor = 0.5 * color * ( 1.0 - state.z ) + vec4( 0.0, color.x ,0.0, 1.0 ) * state.z * sin( iTime * 7.0 ) ; //de momento lo comento que es un infierno para la vista\n    }\n        \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// definicion de constantes para control de teclado\n// Obtenido de un shader de poljere (https://www.shadertoy.com/view/Xst3zX#)\nconst float KEY_SPACE    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_R     = 82.5/256.0;\n\n\nconst float GAME_TIME  = 20.0;\nconst float HALF_WIDTH = 14.0;\nconst float MAX_HEIGHT = 10.0;\nconst float TIME_FRAC  = 2.0;\n\n\nconst vec4 OFF_V1 = vec4( 0.0, -4.3, -2.0, -3.2 ); //x1,y1,x2,y2\nconst vec4 OFF_V2 = vec4( 3.0, -2.1, -5.0, 0.0 );\nconst vec4 OFF_V3 = vec4(-2.0, 0.0, 7.0, 0.9 );\n\nconst float BULLET_RADIUS = 0.1;\nconst float VIRUS_RADIUS  = 1.3;\n\n/////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n//Obtenido de un shader de iq (https://www.shadertoy.com/view/MddGzf)\n\n\nbool leftKey = false;\nbool rightKey = false;\nbool spaceKey = false;\nbool rKey = false;\n\nvoid checkKeys(){\n    \n\tleftKey = texture(iChannel1,vec2(KEY_LEFT,0.5)).r >0.5;\n    rightKey = texture(iChannel1,vec2(KEY_RIGHT,0.5)).r >0.5;\n    spaceKey = texture(iChannel1,vec2(KEY_SPACE,0.5)).r >0.5;\n    rKey = texture(iChannel1,vec2(KEY_R,0.5)).r >0.5;\n   \n}\n\n//coords para los datos\nconst vec2 coordAntivirus = vec2( 0.0, 0.0 ); //x -> dcha/izq relativo; y-> dcha/izq virus; z->up virus\nconst vec2 coordState\t  = vec2( 1.0, 0.0 ); //x->Start; y->win z->loose w->time\nconst vec2 coordSound\t  = vec2( 2.0, 0.0 ); //x->b1; y-> explosion  z->loose w->win\nconst vec2 coordBullet\t  = vec2( 3.0, 0.0 ); //x->pos; y-> altura  z->si hay\nconst vec2 coordV1\t      = vec2( 4.0, 0.0 ); //x->pos; y-> altura  z->si hay\nconst vec2 coordV2\t      = vec2( 5.0, 0.0 ); //x->pos; y-> altura  z->si hay\nconst vec2 coordV3   \t  = vec2( 6.0, 0.0 ); //x->pos; y-> altura  z->si hay\n\nconst vec2 coordVA1       = vec2( 7.0, 0.0 ); //\nconst vec2 coordVA2       = vec2( 8.0, 0.0 ); // para saber si estan vivos\n\n\n\n//iq functions\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\n//interseccion entre esferas\nbool SphereIntersection( vec2 p1, vec2 p2, float r1, float r2 )\n{\n    float dist = length( p1 - p2 );\n    \n    return r1 + r2 >= dist;\n}\n\nvoid CalculateMovement( out vec4 v1, out vec4 v2, out vec4 v3, float t )\n{\n    \n    float yOffset = floor( t / TIME_FRAC );\n    \n    v1 = vec4( sin( t * 0.8 ) * 7.0      , -4.3 + yOffset,\n               sin( t * 0.8 ) * 7.0 - 2.0, -3.2 + yOffset\n        \t );\n    \n    v2 = vec4( sin( t * 0.8 ) * 7.0 + 3.0, -2.1 + yOffset ,\n               sin( t * 0.8 ) * 7.0 - 5.0,  0.0 + yOffset\n              );\n    \n    v3 = vec4(  sin( t * 0.8 ) * 7.0 - 2.0, 0.0 + yOffset,\n                sin( t * 0.8 ) * 7.0 + 7.0, 0.9 + yOffset\n        \t );\n              \n}\n\n\nvoid CheckVictory( inout vec4 state, inout vec4 v1, inout vec4 v2, inout vec4 v3, inout vec4 bullet, inout vec4 va1, inout vec4 va2 ) \n{\n   \n    if( va1.x > 0.0 )\n    {\n        if( bullet.z > 0.0 )\n        {\n            if( SphereIntersection( vec2( v1.x, v1.y ), vec2( bullet.x, bullet.y ), VIRUS_RADIUS, BULLET_RADIUS ) )\n            {\n                va1.x    = 0.0;\n                bullet.z = 0.0;\n            }\n        }\n       \n      \tif( v1.y > 3.5 && va1.x > 0.0  )\n        {\n            state.x = 0.0;\n            state.z = 1.0;\n            state.y = 0.0;\n            state.w = 0.0;\n        }\n    }\n    \n    if( va1.y > 0.0 )\n    {\n       if( bullet.z > 0.0 )\n        {\n            if( SphereIntersection( vec2( v1.z, v1.w ), vec2( bullet.x, bullet.y ), VIRUS_RADIUS, BULLET_RADIUS ) )\n            {\n                va1.y    = 0.0;\n                bullet.z = 0.0;\n            }\n        }\n       \n      \tif( v1.w > 3.5 && va1.y > 0.0  )\n        {\n            state.x = 0.0;\n            state.z = 1.0;\n            state.y = 0.0;\n            state.w = 0.0;\n        }\n    }\n    \n    if( va1.z > 0.0 )\n    {\n       if( bullet.z > 0.0 )\n        {\n            if( SphereIntersection( vec2( v2.x, v2.y ), vec2( bullet.x, bullet.y ), VIRUS_RADIUS, BULLET_RADIUS ) )\n            {\n                va1.z    = 0.0;\n                bullet.z = 0.0;\n            }\n        }\n       \n      \tif( v2.y > 3.5 && va1.z > 0.0  )\n        {\n            state.x = 0.0;\n            state.z = 1.0;\n            state.y = 0.0;\n            state.w = 0.0;\n        }\n    }\n    \n    if( va1.w > 0.0 )\n    {\n        if( bullet.z > 0.0 )\n        {\n            if( SphereIntersection( vec2( v2.z, v2.w ), vec2( bullet.x, bullet.y ), VIRUS_RADIUS, BULLET_RADIUS ) )\n            {\n                va1.w    = 0.0;\n                bullet.z = 0.0;\n            }\n        }\n       \n      \tif( v2.w > 3.5 && va1.w > 0.0  )\n        {\n            state.x = 0.0;\n            state.z = 1.0;\n            state.y = 0.0;\n            state.w = 0.0;\n        }\n    }\n    \n    \n    if( va2.x > 0.0 )\n    {\n        if( bullet.z > 0.0 )\n        {\n            if( SphereIntersection( vec2( v3.x, v3.y ), vec2( bullet.x, bullet.y ), VIRUS_RADIUS, BULLET_RADIUS ) )\n            {\n                va2.x    = 0.0;\n                bullet.z = 0.0;\n            }\n        }\n       \n      \tif( v3.y > 3.5 && va2.x > 0.0  )\n        {\n            state.x = 0.0;\n            state.z = 1.0;\n            state.y = 0.0;\n            state.w = 0.0;\n        }\n    }\n    \n    if( va2.y > 0.0 )\n    {\n        if( bullet.z > 0.0 )\n        {\n            if( SphereIntersection( vec2( v3.z, v3.w ), vec2( bullet.x, bullet.y ), VIRUS_RADIUS, BULLET_RADIUS ) )\n            {\n                va2.y    = 0.0;\n                bullet.z = 0.0;\n            }\n        }\n       \n      \tif( v3.w > 3.5 && va2.y > 0.0  )\n        {\n            state.x = 0.0;\n            state.z = 1.0;\n            state.y = 0.0;\n            state.w = 0.0;\n        }\n    }\n    \n    if( bullet.y < -5.0 )\n    {\n        bullet.z = 0.0;\n    }\n    \n    if( va1.x == 0.0 && va1.y == 0.0 && va1.z == 0.0 && va1.w == 0.0 && va2.x == 0.0 && va2.y == 0.0 )\n    {\n        state.z = 0.0;\n        state.y = 1.0;\n        state.w = 0.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    // don't compute gameplay outside of the data area\n    if( fragCoord.x > 14.0 || fragCoord.y>14.0 ) discard;\n    \n    vec2 uv =(-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n\t//---------------------------------------------------------------------------------   \n\t// load game state\n\t//---------------------------------------------------------------------------------\n    vec4 posAntivirus = loadValue( coordAntivirus );\n    vec4 state        = loadValue( coordState );\n    vec4 bullet       = loadValue( coordBullet );\n    vec4 v1Info       = loadValue( coordV1     );\n    vec4 v2Info       = loadValue( coordV2     );\n    vec4 v3Info       = loadValue( coordV3     );\n    vec4 vA1Info      = loadValue( coordVA1    );\n    vec4 vA2Info      = loadValue( coordVA2    );\n    \n    checkKeys();\n\n    //---------------------------------------------------------------------------------\n\t// store game state\n\t//---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n \n    if( state.x == 0.0 && state.y == 0.0 && state.z == 0.0 )\n    {\n        vA1Info = vec4( 1.0 );\n        vA2Info = vec4( 1.0 );\n    }\n    \n    if( rKey  ) //solo funciona el start si no se esta jugando\n    {\n        state = vec4( 1.0, 0.0, 0.0 , 0.0 );\n        vA1Info = vec4( 1.0 );\n        vA2Info = vec4( 1.0 );\n    \tposAntivirus.x = 0.0;\n        \n    }\n    \n    if( state.x > 0.0 ) \n    {\n        state.w += ( iTimeDelta / 60.0 ); \n    \tCalculateMovement( v1Info, v2Info, v3Info, state.w * 60.0 );\n        \n    }\n    //entrada para jugar\n    //movimiento\n    if( rightKey ) posAntivirus.x = clamp( posAntivirus.x - 0.5, -9.0, 9.0 );\n    if(  leftKey ) posAntivirus.x = clamp( posAntivirus.x + 0.5, -9.0, 9.0 );\n    \n    //disparo\n    if( spaceKey && bullet.z == 0.0 && state.x > 0.0 )\n    {\n        bullet.z = 1.0;\n        bullet.x = posAntivirus.x;\n        bullet.y = 3.9;\n    }\n    \n    if( bullet.z > 0.0 )\n    {\n        bullet.y -= iTimeDelta * 4.0;\n    }\n    \n    CheckVictory( state, v1Info, v2Info, v3Info, bullet, vA1Info, vA2Info ); // comprobamos colisiones y si se ha perdido o ganado\n    \n    storeValue( coordState, state, fragColor, fragCoord );\n    storeValue( coordAntivirus, posAntivirus, fragColor, fragCoord );\n    storeValue( coordBullet, bullet, fragColor, fragCoord );\n    storeValue( coordV1, v1Info, fragColor, fragCoord );\n    storeValue( coordV2, v2Info, fragColor, fragCoord );\n    storeValue( coordV3, v3Info, fragColor, fragCoord );\n    storeValue( coordVA1, vA1Info, fragColor, fragCoord );\n    storeValue( coordVA2, vA2Info, fragColor, fragCoord );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\nconst float A  = 880.0;\nconst float AS = 932.33;\nconst float B  = 987.77;\nconst float C  = 523.25;\nconst float CS = 554.37;\nconst float D  = 587.33;\nconst float DS = 622.25;\nconst float E  = 659.26;\nconst float F  = 698.46;\nconst float FS = 739.99;\nconst float G  = 830.61;\nconst float GS = 880.00;\n\nconst float OCTAVE_STEP = B - C;\nconst float PI = 3.14159265359;\t\n\n#define VOLUME 12.0\n\nfloat Instrument( float freq, float t )\n{\n    freq /= 10.0;\n    float note =  0.3 * sin( 2.0 * PI * freq * t ) * exp( -t * 5.0 );\n\n    note += 0.1 * cos( 2.0 * PI * freq * t ) * exp( -t * 1.0 );\n    note *= note * note;\n    \n    return note;\n}\n\n// main instrument\n\nfloat PlayNote( float time, float globalTime, float speed )\n{\n    float mask = clamp( globalTime - time + 1.0, 0.0, 1.0 );\n    \n    return mask;\n}\n\nvec2 mainSound( in int samp, float time )\n{ \n    time = time * 2.5;\n    time = mod( time , 16.0 ); //tiempo de duracion de la cancion\n    vec2  note  = vec2( 0.0, 25.0 ); \n    float sound = 0.0;\n    \n   //primer compas\n    sound = PlayNote( 1.0, time, 1.0 );\n    note.x  = Instrument( E, sound );\n    \n    sound = PlayNote( 2.0, time, 1.0 );\n    note.x  += Instrument( F, sound ); \n    \n    sound = PlayNote( 3.0, time, 2.0 );\n    note.x  += Instrument( E, sound );\n    \n  \tsound = PlayNote( 3.5, time, 2.0 );\n    note.x  += Instrument( A, sound );\n    \n    sound = PlayNote( 4.0, time, 2.0 );\n    note.x  += Instrument( G, sound );\n   \n    sound = PlayNote( 4.5, time, 2.0 );\n    note.x  += Instrument( F, sound );\n    \n    // segunda compas\n    sound = PlayNote( 5.0, time, 1.0 );\n    note.x  += Instrument( D, sound );\n    \n    sound = PlayNote( 6.0, time, 1.0 );\n    note.x  += Instrument( G, sound );\n   \n    sound = PlayNote( 7.0, time, 2.0 );\n    note.x  += Instrument( F, sound );\n    \n    sound = PlayNote( 7.5, time, 2.0 );\n    note.x  += Instrument( D, sound );\n    \n    sound = PlayNote( 8.0, time, 2.0 );\n    note.x  += Instrument( F, sound );\n    \n    sound = PlayNote( 8.5, time, 2.0 );\n    note.x  += Instrument( D, sound );\n    \n    //tercer compas\n    sound = PlayNote( 9.0, time, 1.0 );\n    note.x  += Instrument( E, sound );\n    \n    sound = PlayNote( 10.0, time, 1.0 );\n    note.x  += Instrument( F, sound ); \n    \n    sound = PlayNote( 11.0, time, 2.0 );\n    note.x  += Instrument( E, sound );\n    \n  \tsound = PlayNote( 11.5, time, 2.0 );\n    note.x  += Instrument( A, sound );\n    \n    sound = PlayNote( 12.0, time, 2.0 );\n    note.x  += Instrument( G, sound );\n    \n    sound = PlayNote( 12.5, time, 2.0 );\n    note.x  += Instrument( F, sound );\n    \n    // cuarto compas\n    sound = PlayNote( 13.0, time, 1.0 );\n    note.x  += Instrument( G, sound );\n    \n    sound = PlayNote( 14.0, time, 1.0 );\n    note.x  += Instrument( A, sound );\n   \n    sound = PlayNote( 15.0, time, 2.0 );\n    note.x  += Instrument( G, sound );\n    \n    sound = PlayNote( 15.5, time, 2.0 );\n    note.x  += Instrument( F, sound );\n    \n    sound = PlayNote( 16.0, time, 2.0 );\n    note.x  += Instrument( D, sound );\n    \n    sound = PlayNote( 16.5, time, 2.0 );\n    note.x  += Instrument( F, sound );\n    \n    return note * VOLUME;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}