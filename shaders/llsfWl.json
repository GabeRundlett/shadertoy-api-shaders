{
    "Shader": {
        "info": {
            "date": "1514071059",
            "description": "Playing with ray-triangle intersection.",
            "flags": 0,
            "hasliked": 0,
            "id": "llsfWl",
            "likes": 12,
            "name": "Triangle Intersections",
            "published": 3,
            "tags": [
                "triangle",
                "intersection",
                "barycentric",
                "branchfree",
                "trumbore",
                "moller"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1265
        },
        "renderpass": [
            {
                "code": "// (c) Matthew Arcus 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Experimenting with ray-triangle intersection algorithms.\n// Finding intersection requires solving a linear system of equations.\n// Can solve directly with matrix inversion or, possibly faster,\n// use Cramer's rule, with simplifications (Möller, Trumbore algorithm).\n\n// Draws a twisted prism of N triangles centred around origin.\n// Color is a direct conversion of barycentric coords to RGB.\n\nconst int N = 50;\nfloat scale = 1.5;\n\nconst float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\n\n// find a,b such that:\n// p + kr = av0 + bv1 + (1-a-b)v2 = a(v0-v2)+b(v1-v2)+v2\n// ie. -kr + a(v0-v2) + b(v1-v2) = p-v2\n// return vec4(k,a,b,c) where c = 1-a-b\n#if 0\n// Solve linear system with a matrix inversion\nvec4 triangle(vec3 p, vec3 r, vec3 v0, vec3 v1, vec3 v2) {\n  vec3 a = inverse(mat3(-r,v0-v2,v1-v2))*(p-v2);\n  return vec4(a,1.0-a.y-a.z);\n}\n#else\n// Standard algorithm by Tomas Möller and Ben Trumbore.\n// Uses Cramer's rule with some simplifications to solve linear system as above.\n// http://webserver2.tecgraf.puc-rio.br/~mgattass/cg/trbRR/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\nvec4 triangle(vec3 o, vec3 d, vec3 v0, vec3 v1, vec3 v2) {\n  // find a,b such that:\n  // p + kr = av0 + bv1 + (1-a-b)v2 = a(v0-v2)+b(v1-v2)+v2\n  // ie. -kr + a(v0-v2) + b(v1-v2) = p-v2\n  vec3 e1 = v0 - v2;\n  vec3 e2 = v1 - v2;\n  vec3 t = o - v2;\n  vec3 p = cross(d,e2);\n  vec3 q = cross(t,e1);\n  vec3 a = vec3(dot(q,e2),dot(p,t),dot(q,d))/dot(p,e1);\n  return vec4(a,1.0-a.y-a.z);\n}\n#endif\n\n// Rotation matrices, nb: column major.\n// Matrix from quaternion\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  return 2.0*mat3(0.5-y*y-z*z, x*y+z*w,     x*z-y*w,\n                  x*y-z*w,     0.5-x*x-z*z, y*z+x*w,\n                  x*z+y*w,     y*z-x*w,     0.5-x*x-y*y);\n}\n\n// Rotations about x,y,z axes.\nmat3 xrotate(float theta) {\n  return mat3(1,0,0,0,cos(theta),sin(theta),0,-sin(theta),cos(theta));\n}\nmat3 yrotate(float theta) {\n  return mat3(cos(theta),0,sin(theta),0,1,0,-sin(theta),0,cos(theta));\n}\nmat3 zrotate(float theta) {\n  return mat3(cos(theta),sin(theta),0,-sin(theta),cos(theta),0,0,0,1);\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  // Rotate camera with quaterion.\n  vec3 axis = normalize(vec3(1,1,1));\n  float theta = -0.1618*iTime;\n  mat3 m = qrot(vec4(sin(theta)*axis,cos(theta)));\n  vec3 p = vec3(0,0,-6);\n  vec3 q = normalize(vec3(xy,0)-p);\n  vec2 mouse = float(iMouse.x > 0.0)*TWOPI*(iMouse.xy-iResolution.xy)/iResolution.xy;\n  // y coord determines rotation about x axis etc.\n  m = m*yrotate(mouse.x)*xrotate(-mouse.y);\n  p = m*p; q = m*q;\n\n  // Initialize triangle matrices\n  mat3 m1 = zrotate(-0.5*iTime); // Rotate triangle about centre\n  mat3 m1inc = zrotate(TWOPI/float(N));\n  mat3 m2 = mat3(1); // Rotate triangle about y-axis\n  mat3 m2inc = yrotate(TWOPI/float(N));\n  vec3 off = vec3(1,0,0); // Base triangle offset\n  vec4 amin = vec4(1e8,0,0,0);\n  for (int i = 0; i < N; i++) {\n    // Equilateral triangle pointing left.\n    vec3 v0 = off + m1*vec3(-1,0,0);\n    vec3 v1 = off + m1*vec3(0.5,-0.866,0);\n    vec3 v2 = off + m1*vec3(0.5,0.866,0);\n    v0 = m2*v0; v1 = m2*v1; v2 = m2*v2;\n    m1 = m1inc*m1;\n    m2 = m2inc*m2;\n    vec4 a = triangle(p,q,v0,v1,v2);\n    // Vectorize comparisons,check:\n    // 0 <= a,b,c <= 1 and 0 <= k < kmin\n    bool hit = all(bvec2(all(greaterThanEqual(a,vec4(0))),\n                         all(lessThanEqual(a,vec4(amin.x,1,1,1)))));\n    amin -= float(hit)*amin; // Try to avoid rounding error\n    amin += float(hit)*a;\n  }\n  outColor = vec4(amin.yzw,1.0); // Use barycentric coords as RGB values\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}