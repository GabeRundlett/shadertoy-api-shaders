{
    "Shader": {
        "info": {
            "date": "1596912488",
            "description": "orb sea",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsfD7",
            "likes": 2,
            "name": "orb_sea",
            "published": 3,
            "tags": [
                "tunnel"
            ],
            "usePreview": 0,
            "username": "slackmage",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "// Lowlands juggernauts - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n// Thankx to Flopine for the octan mirror method suggestion, and thanks to Mercury for writing it.\n\n// \"Fortnite is cool, but don't forget who the real fascists are.\" - Woody Guthrie\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,gg,tnoi;vec3 np,bp,op,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r; return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nvec2 mo(vec2 p, vec2 d) {p=abs(p)-d;if(p.y>p.x) p=p.yx;return p;} //FLOPINE MULTI OCTAN MIRROR THINGY WRITEN BY MERCURY IN THEIR SDF LIB  https://www.shadertoy.com/view/ttffWH\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25; //MERCURTY SDF LIBRARY IS HERE OFF COURSE: http://mercury.sexy/hg_sdf/\n     f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p )\n{ \n  np=p; p.z=mod(p.z+tt*5.,40.)-20.;  \n  op=p; //Originally thought I would do a sort of bounce animation but i found this slow forward crawl more menacing:\n  p.y+=sin(op.z*.2+tt)*3.-5.; //Flopine pointed out a really good bounce ease function like this: p.y -= bouncy(fract(tt))*10.; using this function: float bouncy (float T){return sqrt(abs(sin(T*PI)));} \n  pp=p; //Thankx again Flopine\n  pp.xz=mo(pp.xz, vec2(1.)); \n  pp.yz*=r2(1.2+sin(p.y*.5+tt)*.3);\n  pp.yz=mo(pp.yz,vec2(0.5,1.));\n  pp.xy=mo(pp.xy,vec2(2.5));  \n  tnoi=texNoise((np.xz+vec2(20,tt*2.))*.018).r;    \n  vec2 h,t=vec2(length(p)-5.,5); //SHELL BLUE\n  t.x=max(abs(t.x)-.4,abs(pp.z)-.5);    \n  t.x=min(t.x,9.5*(op.y+tnoi*2.+4.)); //TERRAIN BLUE\n  bp=pp; bp.xy*=r2(-.9);\n  t.x=smin(t.x,0.1*max(length(bp.xz)-max(1.4-tnoi*4.,1.45),p.y-6.),2.); //TENTACLES BLUE    \n  float frill=sin(pp.y*15.)*0.03;    \n  h=vec2(length(p)-5.5,9); //SHELL WHITE\n  h.x=max(h.x,abs(pp.z)-.2);\n  h.x=max(h.x,-(length(p)-4.+frill));\n  bp=pp; bp.xy*=r2(.4585);\n  h.x=min(0.8*length(bp.yz+vec2(2,0.))-.1+abs(bp.x)*.02,h.x);\n  t=t.x<h.x?t:h;  \n  h=vec2(length(p)-5.4,1); //SHELL BLACK\n  h.x=abs(h.x)-.2;\n  h.x=max(h.x,abs(pp.z)-.3);  \n  h.x=max(h.x,abs(abs(abs(pp.x)-1.)-.5)-.25);  \n  t=t.x<h.x?t:h;    \n  h=vec2(length(p)-3.+frill,5); //CORE \n  pp.xy*=r2(-.6); h.x=smin(h.x,.8*length(pp.xz-vec2(.2,1.+tnoi*3.))-.4+frill,3.);  \n  t=t.x<h.x?t:h;   \n  h.x=min(h.x,0.2*length(cos(op*.2)-5.5)); //TERRAIN SOFT ORBS\n  g+=0.1/(0.1+h.x*h.x*40.);  \n  h=vec2(length(p)-10.+frill,5); //RED CORE   \n  pp.xy*=r2(-.1);\n  h.x=smin(h.x,length(pp.xz-vec2(.2,1.1+tnoi*3.))-.2+frill,3.);\n  h.x=smin(h.x,.6*length(abs(bp+vec3(2,2.+tnoi*5.,0.))-2.)-.7,1.);    \n  gg+=0.1/(0.1+h.x*h.x*(80.-79.9*sin(op.y*.2+tt+1.)));\n  t=t.x<h.x?t:h; t.x*=0.7;\n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(0);\n  for(int i=0;i<228;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>120.) break;\n    t.x+=h.x;t.y=h.y;    \n  }\n  if(t.x>120.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,12.82);\n  vec3 ro=mix(vec3(0,-4,-15.),vec3(10,2,-15.),ceil(sin(tt))),\n  cw=normalize(vec3(0,0,0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.15,.1,.14)-length(uv)*.2;\n  ld=normalize(vec3(.3,.1,-.3));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=vec3(.1,.2,.4);\n    if(z.y<5.)al=vec3(0);\n    if(z.y>5.)al=vec3(1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.05)*a(.1)+.2)*(dif*vec3(1.1,.2,.4)*3.+s(.5)),fo,min(fr,1.5));\n    co=mix(fo,co,exp(-.00005*t*t*t));\n  }  \n  fragColor = vec4(pow(co+g*.2*vec3(.31,.2,.7)+gg*.2*vec3(.7,.2,.1),vec3(.55)),1);\n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}