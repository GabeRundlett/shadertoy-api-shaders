{
    "Shader": {
        "info": {
            "date": "1716514134",
            "description": "Using https://www.shadertoy.com/view/lX33zN\nBackground derived from https://www.shadertoy.com/view/43c3Rr\n",
            "flags": 8,
            "hasliked": 0,
            "id": "43dGRM",
            "likes": 3,
            "name": "Shadertoy Barbershop Quartet",
            "published": 3,
            "tags": [
                "2d",
                "sound",
                "harmony"
            ],
            "usePreview": 0,
            "username": "dray",
            "viewed": 209
        },
        "renderpass": [
            {
                "code": "// Derived from https://www.shadertoy.com/view/43c3Rr\n\nfloat irnd=0.;\nfloat rnd(float l,float h)\n{\n  irnd = mod(irnd*54.2+.5,12.33);\n  return irnd*(h-l)/(12.33)+l;\n}\n\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn vec2(\n      a.x * b.x - a.y * b.y,\n      a.x * b.y + b.x * a.y );\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n\treturn vec2(\n\t\ta.x * b.x + a.y * b.y,\n\t\ta.x * b.x - a.y * b.y ) /\n        ( b.x*b.x + b.y*b.y );\n}\n\n\n\nvec2 rot2d(vec2 inp,float ang) {\n  float s = sin(ang);\n  float c = cos(ang);\n  return vec2( inp.x * c + inp.y * s, inp.y * c - inp.x * s ); \n}\n\n\nbool anote(vec2 coor,vec2 orig,float size,float rot)\n{\n  coor = rot2d(coor-orig,rot)+orig;\n  return distance(coor,orig) < 1.*size || ( abs(coor.x-(orig.x+.8*size)) < .2*size && abs(coor.y-(orig.y+3.*size))<3.*size );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    float xtime = iTime * .1;\n\n    irnd = floor(xtime);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 aa;\n    vec2 bb=uv;\n    float ex=mix(cos(xtime*.98), rnd(-1.,1.), clamp(mod(xtime*1.,1.),0.,1.));\n    float ey=mix(sin(xtime*.78), rnd(-1.,1.), clamp(mod(xtime*1.,1.),0.,1.));\n    for (int i = 0; i<8; i++){\n      bb=bb-uv;\n      aa=cmul(bb+ex,bb+ey)+uv;\n      bb=cdiv(aa+ex,aa+ey);\n    }\n    float d=abs(bb.x*aa.x + bb.y*aa.y)/11.;\n\n    // Output to screen\n    vec3 col = vec3(d+rnd(.2,1.),d+rnd(.2,1.),d+rnd(.2,1.));\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n\n\n    for ( int cc = 0; cc < 100; ++cc )\n      if ( anote( uv, vec2(rnd(0.,1.)+sin(iTime*rnd(0.,5.))*.2,rnd(0.,1.)+sin(iTime*rnd(0.,5.))*.2), rnd(.01,.05), sin(rnd(0.,5.)*iTime) ) ) {\n        col = vec3(0.);\n        break;\n      }\n\n\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float cc = 0.;\n    int xx = int(mod((fragCoord.x+iTime*30.)/3.,40.));\n    int yy = int(mod((fragCoord.y+iTime*30.)/3.,15.));\n    int xi = 0;\n    #define _ 0\n    #define COL(a,b,c,d,e,f,g) if ( xx == xi++ && (((a+b*2+c*4+d*8+e*16+f*32+g*64) & (1 << yy)) != 0) ) \\\n       col = mix( col, vec3(1.0),  2. / ( 1. + iTime * 4. ) );\n    COL(1,_,_,_,1,1,_)\n    COL(1,_,_,1,_,_,1)\n    COL(1,_,_,1,_,_,1)\n    COL(_,1,1,_,_,_,1)\n    COL(_,_,_,_,_,_,_)\n    COL(_,1,1,1,1,1,_)\n    COL(1,_,_,_,_,_,1)\n    COL(1,_,_,_,_,_,1)\n    COL(_,1,1,1,1,1,_)\n    COL(_,_,_,_,_,_,_)\n    COL(_,1,1,1,1,1,1)\n    COL(1,_,_,_,_,_,_)\n    COL(1,_,_,_,_,_,_)\n    COL(_,1,1,1,1,1,1)\n    COL(_,_,_,_,_,_,_)\n    COL(1,1,1,1,1,1,1)\n    COL(_,_,_,_,1,1,_)\n    COL(_,_,1,1,_,_,_)\n    COL(1,1,1,1,1,1,1)\n    COL(_,_,_,_,_,_,_)\n    COL(1,1,1,1,1,1,1)\n    COL(1,_,_,_,_,_,1)\n    COL(1,_,_,_,_,_,1)\n    COL(_,1,1,1,1,1,_)\n    COL(_,_,_,_,_,_,_)\n    COL(_,1,_,_,_,_,_)\n    COL(1,1,1,_,_,_,_)\n    COL(1,1,1,_,_,_,_)\n    COL(_,1,1,1,1,1,1)\n    COL(_,_,_,_,1,1,_)\n    COL(_,_,_,1,1,_,_)\n    COL(_,_,_,_,_,_,_)\n    \n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// David Rayna 5/2024\n// Based on https://www.shadertoy.com/view/lX33zN\n\n#define PI (3.1415926535)\n#define TAU (2.*PI)\n\n// This works for vibrato and more\n#define SINC(X) (sin(X)/(X))\n\n// 12-tone notes\n#define C D f f\n#define D E f f\n#define E F f\n#define F G f f\n#define G A f f\n#define A 440.\n#define B A s s\n\n// accidentals\n#define s * 1.05946\n#define f * 0.9438\n\n// octaves\n#define L * .5\n#define H * 2.\n\n// durations\n#define e + .125\n#define t + .16666666666666\n#define q + .25\n#define h + .5\n#define w + 1.\n\n// Inline repeats\n#define DO1(X) X\n#define DO2(X) X X\n#define DO3(X) X X X\n#define DO4(X) X X X X\n#define DO6(X) DO3(X) DO3(X)\n#define DO8(X) DO4(X) DO4(X)\n#define DO16(X) DO8(X) DO8(X)\n\nstruct PART { \n  float fc;    // frequency to play current note\n  float tempo; // tempo and place in music\n  float note;  // time into current note\n  float pfc;   // prev frequency\n  float vol;   // vol\n  float vib;   // vibrato amplitude\n  float vibf;  // vibrato freq\n  float dst;   // distortion\n  float pw;    // pw\n  float env;   // envelope\n};\n\n#define StartInstr(p1,xtempo) \\\n  p1.fc = 0.; \\\n  p1.tempo = xtempo; \\\n  p1.pfc = -1.; \\\n  p1.vol = .1; \\\n  p1.vib = 0.; \\\n  p1.vibf = 12.; \\\n  p1.dst = 1.; \\\n  p1.pw = 0.; \\\n  p1.env = 100. \\\n\n\n#define Instrum(p1) \\\n  clamp( p1.pw + p1.dst * sin( p1.note * TAU * p1.fc + sin(TAU*p1.vibf*time)*p1.vib ), -1., 1. ) * p1.vol * exp(-p1.note/p1.env);\n\n\n#define ROUNDTO(X,Y) (round((X)/(Y))*(Y))\n\n// Start playing at 0 phase and play until a 0 phase in the waveform (within 1/2 cycle of desired duration)\n#define PHS0(TIM,FC) ROUNDTO(TIM,1./(FC)) \n#define P(CH,FC,DUR,EXTRA) if ( CH.tempo < PHS0(DUR,FC) ) { \\\n  CH.pfc = CH.fc = FC; CH.note = CH.tempo; CH.tempo += 10000.; EXTRA; } \\\n  else { CH.tempo -= PHS0(DUR,FC); }\n\n#define Z(CH,DUR,EXTRA) if ( CH.tempo < (DUR) ) { CH.vol=0.; CH.tempo += 10000.; EXTRA; } else { CH.tempo -= (DUR); }\n\n// Linear ramp starts at 0 phase and ends at 0\n#define PHS0r(TIM,F1,F2) ROUNDTO(TIM,2./((F2)+(F1)))   /* maybe some magic here ? */\n#define RAMP(CH,F1,F2,DUR,EXTRA) if ( CH.tempo < PHS0r(DUR,F1,F2) ) { \\\n  CH.note = CH.tempo; CH.fc = (F1) + ((F2)-(F1)) * CH.note / PHS0r(DUR,F1,F2) / 2.; \\\n  CH.tempo += 10000.; EXTRA; } \\\n  else { CH.tempo -= PHS0r(DUR,F1,F2); }\n\n\n#define RP(CH,F2,DUR,EX) RAMP(CH,CH.pfc<0.?F2:CH.pfc,F2,(DUR)/3.,EX) P(CH,F2,(DUR)*2./3.,EX) CH.pfc=F2;\n\n\n////////////// Here we go /////////////////////////////////////\n\nvec2 mainSound( int samp, float time )\n{\n    \n    float left = 0., right = 0.;\n    \n    PART p1, p2, p3, p4;\n    \n    //samp += int(iSampleRate) * 12; // jump ahead for testing\n    \n    samp %= 34 * int(iSampleRate);\n    float tempo = float(samp)/iSampleRate;    \n    \n    StartInstr(p1,tempo);\n    StartInstr(p2,tempo);\n    StartInstr(p3,tempo);\n    StartInstr(p4,tempo);\n\n\n    RP(p1,C,w,) RP(p2,E,w,) RP(p3,G,w,) RP(p4,B,q q q,)\n    RP(p1,E,w,) RP(p2,G,w,) RP(p3,B,q q q,) RP(p4,C,w,)\n    RP(p1,G,w,) RP(p2,B,q q q,) RP(p3,C,q,) RP(p4,E,q,)\n    RP(p1,B,q q q,) RP(p2,C,w,) RP(p3,E,w,) RP(p4,G,w,)\n    RP(p1,C,q,) RP(p2,E,q,) RP(p3,G,q,) RP(p4,B,q,)\n\n    RP(p1,C,q,) RP(p2,E,q,) RP(p3,G,q,) RP(p4,B,q,)\n#define MT s s s s /* minor third */\n    RP(p1,C MT,q,) RP(p2,E MT,q,) RP(p3,G MT,q,) RP(p4,B MT,q,)\n#define MT2 MT MT  /* 2 minor thirds */\n    RP(p1,C MT2,q,) RP(p2,E MT2,q,) RP(p3,G MT2,q,) RP(p4,B MT2,q,)\n    RP(p1,C MT,q,) RP(p2,E MT,q,) RP(p3,G MT,q,) RP(p4,B MT,q,)\n    RP(p1,C MT2,q,) RP(p2,E MT2,q,) RP(p3,G MT2,q,) RP(p4,B MT2,q,)\n    RP(p1,C,q,) RP(p2,E,q,) RP(p3,G,q,) RP(p4,B,q,)\n#define MT3 MT MT MT  /* 3 minor thirds */\n    RP(p1,C MT3,q,)          RP(p2,E MT3,q,)   RP(p3,G MT3,q,)   RP(p4,B MT3,q,p4.vib=1.1;)\n\n\n\n    RP(p1,C,w w,)       RP(p2,E,w w,)          RP(p3,G,w h,)      RP(p4,B,w,) \n                                                                  RP(p4,C H H,w w w,p4.vib=2.;p4.vibf=8.;)\n                                               RP(p3,G L,h w w,)\n    RP(p1,E,w ,)        RP(p2,C H, w,) \n    RP(p1,E H,h,)     RP(p2,G H,h,) \n    RP(p1,C ,h,)       RP(p2,E ,h,) \n    \n\n    P(p1,F L,w w h,)   P(p2,A L,w w h,)            P(p3,C,w w h,)        RP(p4,E,w,)\n                                                                         RP(p4,A,w h,)\n\n\n    RP(p1,C,w w,)    RP(p2,E,w w,)              RP(p3,G,w,p3.vib=1.)     RP(p4,C L L,w w w w,p4.pw=.2;)\n    RP(p1,C H,w w,)  RP(p2,E H,w w,)            RP(p3,G H,w,p3.vib=1.)\n                                                RP(p3,G,w w,p3.vib=1.)\n\n\n\n    RP(p1,C,w w,)    RP(p2,A,w w,)           RP(p3,F L,w w,)        RP(p4,A L L L,w,p4.pw=.5;)\n                                                                    RP(p4,F L L,w,p4.pw=.5;)\n                                                                             \n                                                                             \n    RP(p1,F * 1.01,w w,)   RP(p2,F * .98,w w q,)     RP(p3,F * .99,w w q q,)     RP(p4,F,w w q q q,) \n    RP(p1,F f * 1.01,w,)   RP(p2,F f * .98,w q,)     RP(p3,F f  * .99,w q q,)     RP(p4,F f,w q q q,) \n    RP(p1,F f f * 1.01,w,)   RP(p2,F f f * .98,w q,)     RP(p3,F f f * .99,w q q,)     RP(p4,F f f,w q q q,) \n    RP(p1,F f f f * 1.01,w,)   RP(p2,F f f f * .98,w q,)     RP(p3,F f f f * .99,w q q,)     RP(p4,F f f f,w q q q,) \n\n    \n    RP(p1,D,w w q q q q,p1.dst=1.2)       RP(p2,B L,w w q q q,p2.dst=1.2)    RP(p3,G L,w w q q,p3.dst=1.2)     RP(p4,F L,w w q,p4.dst=1.2) \n\n    P(p1,G,q,p1.env=e)                P(p2,A,q,p2.env=e)                P(p3,C H,q,p3.env=e)            P(p4,G H,q,p4.env=e)\n    P(p1,G L,q,p1.env=e)              P(p2,A L,q,p2.env=e)              P(p3,C,q,p3.env=e)              P(p4,G,q,p4.env=e)\n    P(p1,G,q,p1.env=q;p1.pw=.2)   P(p2,A,q,p2.env=q;p2.pw=.2)   P(p3,C L,q,p3.env=q;p3.pw=.2)        P(p4,G L,q,p4.env=q;p4.pw=.2)\n    P(p1,G L,h,p1.env=w;p1.pw=.2) P(p2,A L,h,p2.env=w;p2.pw=.2) P(p3,C L,h,p3.env=w;p3.pw=.2)        P(p4,G,h,p4.env=w;p4.pw=.2)\n\n \n    RP(p1,C,w w,)    RP(p2,E,w w,)              RP(p3,G,w,p3.vib=1.)     RP(p4,C L L,w q q q  ,p4.pw=.2;)\n    RP(p1,C H,w w,)  RP(p2,E H,w q,)            RP(p3,G H,w,p3.vib=1.)\n                                                RP(p3,G,q,p3.vib=1.)\n\n\n\n\n    RP(p1,C L,q q q,)               RP(p2,G L L,q q q,)               RP(p3,E L,q q q, )         RP(p4,G L,q q q,)\n     P(p1,C L,w w,p1.env=w)        P(p2,G L L,w w,p2.env=w)        P(p3,E L,w w,p3.env=w)   P(p4,G L,w w w,p4.env=w)\n\n\n    left += Instrum(p1);\n    left += Instrum(p2);\n\n    right += Instrum(p3);\n    right += Instrum(p4);\n\n////// output results //////////////////\n\n    return vec2( left, right );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}