{
    "Shader": {
        "info": {
            "date": "1572782600",
            "description": "Contrast shader for codevember01",
            "flags": 0,
            "hasliked": 0,
            "id": "WstXWS",
            "likes": 6,
            "name": "Codevember01 - Contrast",
            "published": 3,
            "tags": [
                "2d",
                "contrast",
                "codevember"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 245
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat sat(float a)\n{\n  return clamp(a,0.0,1.0);\n}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\n\nvec3 negate(vec3 col, bool yes)\n{\n  if (yes)\n     return vec3(1.)-col;\n  return col;\n}\n\nbool range(float a, float mi, float ma)\n{\n  return a > mi && a <ma;\n}\n\nvec3 drawCircle(vec2 uv, vec2 pos, float rad)\n{\n  vec3 col;\n  col += vec3(0.5,0.,0.34);\n  if (rad<0.)\n    col = vec3(1.)-col;\n    rad = abs(rad);\n  float thick = 0.01;\n  return col*float(range(length(uv-pos), rad-thick, rad));\n}\n\nvec3 drawCir(vec2 uv, vec2 pos, float rad, float diag)\n{\n  uv = uv-pos;\n\n  float luv = mix(length(uv),lenny(uv),(0.5+0.5*sin(iTime))*diag);\n  float grad = (abs(luv - rad)/0.15);\n  vec3 col = vec3(pow(sat(1.-grad),5.))*vec3(1.);\n  float a = atan(uv.y,uv.x)/PI;\n  col += (luv/rad)*1000.*pow(abs(mod((0.3*iTime*PI+(luv*2.*PI)+a+sin(75.*pow(luv,4.2)+15.*iTime+a)*0.05),0.1)-0.05),2.5)*float(luv <rad);\n  return col;\n}\n\nvec3 rdrMain(vec2 uv)\n{\n  vec3 colGrad = vec3(0.45,0.34,0.78).yzz;\n  vec3 acc;\n\n  acc = mix(colGrad, vec3(0.3), 1.-length(uv));\n  acc *=min(pow(max(length(uv),0.1),3.5),1.);\n  acc += drawCir(uv, vec2(sin(iTime)*0.2,0.15*cos(iTime*0.4)),(0.4*sin(iTime)+0.6),1.);\n  return acc;\n}\n\nvec3 rdrLines(vec2 uv)\n{\n  const int lines = 16;\n  vec3 acc;\n\n  for (int i = 0; i< lines;++i)\n  {\n    float fi = float(i);\n    vec2 pos= vec2(rand(vec2(fi, 8.-fi)), rand(vec2(8.-fi,fi)));\n    pos-= vec2(0.5);\n    pos += (fi/8.)*vec2(sin(iTime*fi/8.),cos(iTime));\n    acc += drawCir(uv, pos,0.05*max(1.-pos.x,0.2),0.)*vec3(fi/12.,pos.y,fi/7.);\n  }\n  return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec2 center = vec2(0.5)*iResolution.xy/iResolution.xx;\n  uv = uv - center;\n  uv *= 2.5;\n\n\n  vec3 col = rdrMain(uv);\n  float inMask = float(uv.y< (sin(uv.x*10.+iTime*3.)*0.05+0.3*sin(iTime+uv.x)));\n  col = negate(col,bool(inMask));\n  col *= 1.-pow(length(uv),2.5);\n  col += rdrLines(uv);\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}