{
    "Shader": {
        "info": {
            "date": "1550009029",
            "description": "iMouse.x sets number of corners\n\narbitray polygon sdf\nwinding number algorithm.\nhttps://en.wikipedia.org/wiki/Point_in_polygon\nhttp://geomalgorithms.com/a03-_inclusion.html",
            "flags": 0,
            "hasliked": 0,
            "id": "3d23WK",
            "likes": 12,
            "name": "Winding arbiitiary ngon",
            "published": 3,
            "tags": [
                "sdf",
                "polygon",
                "ngon",
                "winding"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 725
        },
        "renderpass": [
            {
                "code": "//parent: https://www.shadertoy.com/view/WdSGRd\n//with 2 suggested mods for performance:\n\n#define N 32\n#define corners int(floor(float(N-1)*(1.-iMouse.x/iResolution.x))+1.)\n\n//#define N corners\n//no dynamic-runtime arrays in opengl, so just use a max length array\n\nfloat cross2d(vec2 v0, vec2 v1){return v0.x*v1.y-v0.y*v1.x;}\n\n\n// signed distance to a 2D polygon\n// adapted from triangle\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPoly( in vec2[N] poly, in vec2 p,int cor)\n{\n    float d = dot(p-poly[0],p-poly[0]);\n    float s = 1.0;\n    int iter=cor;\n    for( int i=0; i<iter; i++)    {\n        // distance\n        int i2 = (i+1)%cor;\n\tvec2 e = poly[i2] - poly[i];\n        vec2 v = p - poly[i];\n        vec2 pq = v - e*clamp( dot(v,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(pq, pq));\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        vec2 v2 = p - poly[i2];\n        float val3 = cross2d(e,v); //isLeft\n        bvec3 cond = bvec3( v.y>=0.0, v2.y<0.0, val3>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  // have a valid up or down intersect\n    }\n    \n    return sqrt(d) * s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t//p *= 2.;    \n    p+=.25;\n    vec2[N] poly;\n    float t=iTime*.04;\n    for(int i=0;i<corners;i++){\n        float f=float(i);\n        //vec2 a=vec2(cos((t*f)*(sqrt(3.)*.5+.5)) , sin((t*f)*(sqrt(5.)*.5+.5))) \n        vec2 a=vec2(cos((t*f)*(sqrt(3.)*.5+.5)) , sin((t+f)*(sqrt(5.)*.5+.5))) ;;\n        poly[i]=cos(a*2.); }\n\tfloat d = sdPoly(poly, p,corners );\n    //...\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n   \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}