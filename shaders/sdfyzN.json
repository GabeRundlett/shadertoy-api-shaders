{
    "Shader": {
        "info": {
            "date": "1642652165",
            "description": "\"You are seeing the sounds you're hearing.\" A visualizer of L/R waveforms and their resulting oscilloscope shapes. More thorough description in the comments.\n\nHit \"reset time\" after the video starts so the sound will play and be synced to the video.",
            "flags": 40,
            "hasliked": 0,
            "id": "sdfyzN",
            "likes": 19,
            "name": "XY Oscilloscope Sound Drawings",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "oscilloscope",
                "sound",
                "tetrahedron",
                "4d",
                "mushroom",
                "tesseract"
            ],
            "usePreview": 0,
            "username": "amhall",
            "viewed": 740
        },
        "renderpass": [
            {
                "code": "// These sounds draw shapes on an oscilloscope in XY mode where the left channel\n// is the X axis and the right channel is the Y axis. This shader visualizes the\n// left (top) and right (bottom) waveforms, and approximates a much slowed down\n// version of what is happening on the oscilloscope display.\n\n// Reduce samplesPerFrame in the Common tab to speed up if necessary.\n\n// To get a better sense of what the sounds would actually look like on an\n// oscilloscope, change phaseSpan to 1.0 and increase samplesPerFrame in the Common\n// tab (or play these sounds into a digital oscilloscope software).\n\n// To get a better sense of the path being traced, reduce animationFrequency and/or\n// enable FADE in the Common tab.\n\n// If you've never heard of oscilloscope music, I highly recommend the work of\n// Jerobeam Fenderson and Hansi Raber: https://www.youtube.com/c/jerobeamfenderson1\n\n// I'll also take this opportunity to share my own oscilloscope music piece that I\n// composed for school: https://www.youtube.com/watch?v=H5NK549Lg1I\n\n// Common has the sound synthesis and animation parameters, Buffer A computes a\n// select number of samples, buffer B does the path visualization.\n\n// Created by Anthony Hall\n\n\nvec3 waveforms(vec2 wave, float y)\n{\n    float lY = y;\n    float rY = y;\n    lY = 2.0 * y - 1.0;\n    rY = 2.0 * y + 1.0;\n    \n    float dist = min(abs(lY - wave.x), abs(rY - wave.y));\n    \n    float intensity = linestep(0.2, 0.005, dist);\n    return pow(vec3(intensity), vec3(10.0, 3.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 path = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.xy;\n\n    // The L/R visualization visualizes two cycles of the wave at the current time\n    float window = floor(iTime * baseFrequency);\n    float time = (window + uv.x) / baseFrequency;\n    vec2 samples = sound(time, time);\n    vec3 wave = waveforms(samples, 1.1 * uv.y);\n    \n    fragColor = vec4(0.5 * wave + path, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// All the sound synthesis and animation parameters are here\n\n// The number of samples taken by the visualizer. A line is drawn between each sample,\n// so this is the bottleneck.\nconst int samplesPerFrame = 100;\n\n// The frequency at which the entire shape is drawn once.\nconst float animationFrequency = 1.8;\n\n// The percentage of the entire shape that is spanned by the visualizer at any given time.\nconst float phaseSpan = 0.4; \n\n// The amount of time spent on each shape.\nconst float shapeDuration = 4.0;\n\n// This makes the line fade toward the end so that visually the path is more clear.\n// It's more expensive and there are glitches when line segments overlap. To prevent\n// glitches, phaseSpan must be less than 0.375 when FADE is enabled.\n//#define FADE\n\nconst float baseFrequency = 55.0 * exp2(7.0/12.0); // E2 note\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Slightly cheaper linear version of smoothstep\nfloat linestep(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nvec2 CS(float theta)\n{\n    return vec2(cos(theta), sin(theta));\n}\n\nmat2 rotate(float theta)\n{\n    vec2 cs = CS(theta);\n    return mat2(cs.x, cs.y, -cs.y, cs.x);\n}\n\n// Projects so that the closest face of the canonical cube maps to the canonical square\nvec2 perspectiveProject(vec3 point, float fov)\n{\n    float offset = 1.0 / tan(fov / 2.0);\n    float cameraZ = -(1.0 + offset);\n    float zDist = point.z - cameraZ;\n    return point.xy / (zDist / offset);\n}\n\n// Projects so that the closest face of the canonical tesseract maps to the canonical cube\nvec3 perspectiveProject(vec4 coord, float fov)\n{\n    float offset = 1.0 / tan(fov / 2.0);\n    float cameraW = -(1.0 + offset);\n    float wDist = coord.w - cameraW;\n    return coord.xyz / (wDist / offset);\n}\n\nvec3 tetrahedron(float phase)\n{\n    const vec3[] vertices = vec3[](\n        vec3(1.0, 1.0, 1.0),\n        vec3(-1.0, 1.0, -1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(1.0, -1.0, -1.0));\n    \n    const ivec2[] lines = ivec2[](\n        ivec2(0, 1),\n        ivec2(1, 2),\n        ivec2(2, 0),\n        ivec2(0, 3),\n        ivec2(3, 1),\n        ivec2(1, 2),\n        ivec2(2, 3),\n        ivec2(3, 0));\n        \n    float totalPhase = float(lines.length()) * phase;\n    ivec2 line = lines[int(totalPhase)];\n    float linePhase = fract(totalPhase);\n    \n    return mix(vertices[line.x],\n        vertices[line.y],\n        linePhase) / sqrt(3.0);\n}\n\nvec4 tesseract(float phase)\n{\n    vec4[] vertices = vec4[](\n        // Cube in -w\n        // Square in -z, -w\n        vec4(-1, -1, -1, -1),\n        vec4(1, -1, -1, -1),\n        vec4(1, 1, -1, -1),\n        vec4(-1, 1, -1, -1),\n        \n        // Square in +z, -w\n        vec4(-1, -1, 1, -1),\n        vec4(1, -1, 1, -1),\n        vec4(1, 1, 1, -1),\n        vec4(-1, 1, 1, -1),\n        \n        // Cube in +w\n        // Square in -z, +w\n        vec4(-1, -1, -1, 1),\n        vec4(1, -1, -1, 1),\n        vec4(1, 1, -1, 1),\n        vec4(-1, 1, -1, 1),\n        \n        // Square in +z, +w\n        vec4(-1, -1, 1, 1),\n        vec4(1, -1, 1, 1),\n        vec4(1, 1, 1, 1),\n        vec4(-1, 1, 1, 1)); // 0s, 1s easy to deal with, normalize to canonical\n        \n    // Euler path of hypercube lines\n    ivec2[] lines = ivec2[](\n        ivec2(0, 4),\n        ivec2(4, 7),\n        ivec2(7, 3),\n        ivec2(3, 11),\n        ivec2(11, 15),\n        ivec2(15, 14),\n        ivec2(14, 10),\n        ivec2(10, 2),\n        ivec2(2, 6),\n        ivec2(6, 5),\n        ivec2(5, 13),\n        ivec2(13, 14),\n        ivec2(14, 6),\n        ivec2(6, 7),\n        ivec2(7, 15),\n        ivec2(15, 12),\n        ivec2(12, 4),\n        ivec2(4, 5),\n        ivec2(5, 1),\n        ivec2(1, 9),\n        ivec2(9, 8),\n        ivec2(8, 12),\n        ivec2(12, 13),\n        ivec2(13, 9),\n        ivec2(9, 10),\n        ivec2(10, 11),\n        ivec2(11, 8),\n        ivec2(8, 0),\n        ivec2(0, 1),\n        ivec2(1, 2),\n        ivec2(2, 3),\n        ivec2(3, 0));\n        \n    float totalPhase = float(lines.length()) * phase;\n    ivec2 line = lines[int(totalPhase)];\n    float linePhase = fract(totalPhase);\n    \n    return mix(vertices[line.x],\n        vertices[line.y],\n        linePhase) / 2.0;\n}\n\n// Slightly modified version of Jerobeam Fenderson's oscilloscope mushroom\n// https://www.youtube.com/watch?v=rtR63-ecUNo\nvec3 mushroom3D(float numMushrooms, float animationTime, float phase)\n{\n    float stemPhase = fract(phase * numMushrooms); // <- Change the number of mushrooms here\n    const float spiralFreq = 10.0;\n    vec3 point = vec3(0.0, 2.0 * stemPhase - 1.0, 0.0);\n\n    // Main spiral\n    point.xz = CS(spiralFreq * stemPhase * twoPi);\n    \n    // Stem vs cap diameter applied to main spiral\n    point.xz *= mix(0.6 * sin(twoPi * stemPhase), 0.07, float(stemPhase < 0.75));\n    \n    // Rotation\n    point.xz += 0.6 * stemPhase * CS((phase + 0.08 * animationTime) * twoPi);\n    \n    return vec3(point) / sqrt(3.0);\n}\n\n// Polygon that works with fractional vertex values\nvec2 polygon(float vertices, float phase)\n{\n    float totalPhase = phase * vertices;\n    float startIndex = floor(totalPhase);\n    float endIndex = startIndex + 1.0;\n    vec2 startVertex = CS(startIndex / vertices * twoPi);\n    vec2 endVertex = CS(min(endIndex / vertices * twoPi, twoPi));\n    \n    // linePhase must be corrected for fractional vertex values\n    float linePhase = fract(totalPhase);\n    linePhase /= mix(1.0, fract(vertices), float(endIndex > vertices));\n    return mix(startVertex, endVertex, linePhase);\n}\n\n// Inscribes a bunch of polygons\nvec2 inscribe(float levels, float vertices, float theta, float phase)\n{\n    float totalPhase = phase * levels;\n    float level = floor(totalPhase);\n    float levelPhase = fract(totalPhase);\n    \n    float slice = twoPi / vertices;\n    float halfSlice = 0.5 * slice;\n    \n    float sliceTheta = mod(theta, slice) - halfSlice;\n    float levelScale = cos(halfSlice) / cos(sliceTheta);\n    \n    return pow(levelScale, level) * rotate(theta * level) * polygon(vertices, levelPhase);\n}\n\n// The visualizer's frequency is much, much slower than the note frequency. To\n// preserve animations (e.g. rotation) between the waveform and the visualization,\n// separate time parameters are used.\nvec2 sound(float soundTime, float animationTime)\n{\n    float phase = fract(baseFrequency * soundTime);\n    float shape = mod(animationTime / shapeDuration, 4.0);\n    float currentShape = floor(shape);\n    \n    float localAnimationTime = fract(shape) * shapeDuration;\n    float envelope = smoothstep(0.0, 0.08, 0.5 - abs(fract(shape) - 0.5));\n    float cycleAlternate = floor(mod(animationTime / shapeDuration / 4.0, 2.0));\n    vec2 result = vec2(0.0);\n    \n    // Inscribed triangles\n    if (currentShape == 0.0)\n    {\n        result = rotate(0.2 * animationTime + 1.5)\n            * inscribe(6.0, 3.0 + 2.0 * cycleAlternate, 0.2 * localAnimationTime / shapeDuration, phase);\n    }\n    // Tetrahedron\n    else if (currentShape == 1.0)\n    {\n        vec3 point = tetrahedron(phase) ;\n        point.xz = rotate(0.25 * animationTime) * point.xz;\n        point.yz = rotate(-0.5) * point.yz;\n        result = perspectiveProject(point, radians(30.0));\n    }\n    // Mushroom\n    else if (currentShape == 2.0)\n    {\n        vec3 point = mushroom3D(3.0 - cycleAlternate, animationTime, phase);\n        point.yz = rotate(-0.5) * point.yz;\n        result = perspectiveProject(point, radians(30.0));\n    }\n    // Tesseract\n    else if (currentShape == 3.0)\n    {\n        vec4 point4 = tesseract(phase);\n        point4.yw = rotate(-0.35 * animationTime) * point4.yw;\n        point4.xz = rotate(0.15 * animationTime) * point4.xz;\n\n        vec3 point3 = perspectiveProject(point4, radians(120.0));\n        point3.yz = rotate(-0.4) * point3.yz;\n        result = 2.0 * perspectiveProject(point3, radians(30.0));\n    }\n    return result * envelope;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// In Common tab\nvec2 mainSound( int samp, float time )\n{\n    return sound(time, time);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "// Buffer A calculates the samples for which lines will be drawn in the visualization.\n// Each of the first (samplesPerFrame) fragments calculates one point.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int index = int(fragCoord.x + fragCoord.y * iResolution.x);\n    \n    vec2 point = vec2(0.0);\n    \n    if (index < samplesPerFrame)\n    {\n        float sampleTime = (iTime * animationFrequency + phaseSpan * float(index) / float(samplesPerFrame - 1))\n         / baseFrequency;\n        point = sound(sampleTime, iTime);\n    }\n    \n    fragColor = vec4(point, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer B performs the XY visualization. The backbuffer is used so the path has\n// a fading tail.\n\nconst float lineThickness = 0.0075; \n\n// From Inigo Quilez\nfloat lineDist(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec2 readSample(int index)\n{\n    ivec2 texel = ivec2(index % int(iResolution.x), index / int(iResolution.x));\n    return texelFetch(iChannel0, texel, 0).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = 1.1 * (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Only compute near the limits of the waveforms: [-1, 1]\n    float bound = max(abs(uv.x), abs(uv.y));\n    if (bound < 1.1)\n    {\n        float dist = 1e5;\n        float intensity = 1.0;\n\n        for (int i = 0; i < samplesPerFrame - 1; i++)\n        {\n            vec2 start = readSample(i);\n            vec2 end = readSample(i + 1);\n            float newDist = lineDist(uv, start, end);\n\n#ifdef FADE   \n            // Progressively brighten each line\n            // The pixel will take the intensity value of the closest line\n            // This method is very glitchy when lines overlap due to floating point error\n            intensity = mix(intensity, float(i + 1) / float(samplesPerFrame - 1),\n                float(newDist < dist));\n#endif\n            dist = min(dist, newDist); \n        }\n        // Fade off near the border and brighten just a smidge for FADE mode\n        intensity *= linestep(1.1, 0.95, bound);\n        intensity = 0.2 + 0.8 * intensity;\n        \n        float line = min(lineThickness / dist, 1.0);\n        color = intensity * pow(vec3(line), vec3(10.0, 1.0, 10.0));\n        vec3 previous = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n        color = (0.45 * color + 0.75 * previous); // Blend with backbuffer\n    }\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}