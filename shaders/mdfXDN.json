{
    "Shader": {
        "info": {
            "date": "1668905719",
            "description": "A starfield 4-D spacetime described by Greg Egan in his Orthogonal series. Different wavelengths have a different angle relative to the observer's time, leading to the spectral star trails. Can you spot the Peerless?",
            "flags": 32,
            "hasliked": 0,
            "id": "mdfXDN",
            "likes": 7,
            "name": "Riemmanian Starfield",
            "published": 3,
            "tags": [
                "raymarching",
                "volumetric",
                "4d",
                "orthogonal"
            ],
            "usePreview": 0,
            "username": "A_Toaster",
            "viewed": 550
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture( iChannel0, uv ).xyz * 0.5;\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nconst float FIELD_OF_VIEW = 1.2;\n\n// camera directions\nconst vec4 FWD_4 = vec4(1., 0., 0., 0.);\nconst vec4 UP_4 = vec4(0., 0., 1., 0.);\n\n// raymarching parameters\nconst float GLOW_DIST = 0.05;\n#ifdef HIGH_QUALITY\n\nconst float MAX_DIST = 300.;\n#define MAX_ITERATIONS 64\nconst float STAR_SIZE = 0.15;\n#else\n#ifdef POTATO_QUALITY\nconst float MAX_DIST = 200.;\n#define MAX_ITERATIONS 16\nconst float STAR_SIZE = 0.3;\n#else\nconst float MAX_DIST = 300.;\n#define MAX_ITERATIONS 32\nconst float STAR_SIZE = 0.2;\n#endif\n#endif\n\n// cluster settings\nconst float CLUSTER_CELL_SIZE = 15.;\nconst float CLUSTER_RAND_VEL = float(STAR_VELOCITY);\nconst vec4 CLUSTER_FUTURE = vec4(0., 0., 0., 1.);\n// Used to keep stars centered within their domains\nconst float CENTER_LIGHT_TIME_VEL = 1. / sqrt(1. + 0.5 * 0.5);\n\n// projection operator\nvec4 proj(vec4 u, vec4 v) {\n    return (u * dot(u,v)) / dot(u, u);\n}\n\n// Calculate a vector orthogonal (but not orthonormal) to three other 4-vectors\nvec4 cross4(vec4 u, vec4 v, vec4 t){\n    return vec4(\n        ( u.w * v.z - u.z * v.w) * t.y + (-u.w * v.y + u.y * v.w) * t.z + (-u.y * v.z + u.z * v.y) * t.w,\n        (-u.w * v.z + u.z * v.w) * t.x + ( u.w * v.x - u.x * v.w) * t.z + ( u.x * v.z - u.z * v.x) * t.w,\n        ( u.w * v.y - u.y * v.w) * t.x + (-u.w * v.x + u.x * v.w) * t.y + (-u.x * v.y + u.y * v.x) * t.w,\n        ( u.y * v.z - u.z * v.y) * t.x + (-u.x * v.z + u.z * v.x) * t.y + ( u.x * v.y - u.y * v.x) * t.z\n    \n    );\n}\n\n// Returns a 4-d ray direction orthogonal to the time vector given a set of camera parameters.\nvec4 camera_spacelike_dir(vec2 uv, vec4 cameraDirection, vec4 cameraUp, vec4 cameraFuture) {\n    \n\tuv = uv * FIELD_OF_VIEW;\n    \n    // Up/fwd vec orthogonal to future\n    vec4 fut = cameraFuture;\n    vec4 up_vec = normalize(cameraUp - proj(fut, cameraUp));\n    vec4 fwd_vec = normalize(cameraDirection - proj(fut, cameraDirection));\n    // Right vec orthogonal to all other directions\n    vec4 right_vec = normalize(cross4(up_vec, fwd_vec, fut));\n    \n    vec4 spacelike_dir = normalize(fwd_vec + uv.y * up_vec + uv.x * right_vec);\n    \n    return spacelike_dir;\n}\n\n// Returns 4-d ray direction given a spacelike direction and a velocity in the timelike direction.\nvec4 camera(vec4 spacelike_dir, vec4 cameraFuture, float futureVel) {\n    vec4 timelike_dir = cameraFuture * futureVel;\n    \n    return normalize(spacelike_dir + timelike_dir);\n}\n\nint hash(ivec3 co){\n    return co.x + 123 * co.y + 12345 * co.z;\n}\n\n\nvec4 rand1_4(float i) {\n    vec2 co = vec2(i, floor(i / iChannelResolution[0].x));\n    return texture(iChannel0, co);\n}\n\nvec3 rand3_3(ivec3 i) {\n    ivec2 co = ivec2(mod(float(i.x + 13 * i.z), iChannelResolution[0].x), mod(float(i.y + 29 * i.z), iChannelResolution[0].y));\n    return texelFetch(iChannel0, co, 0).rgb;\n}\n\nvec3 rand3_1(ivec3 i) {\n    ivec2 co = ivec2(mod(float(i.x + 13 * i.z), iChannelResolution[0].x), mod(float(i.y + 29 * i.z), iChannelResolution[0].y));\n    return texelFetch(iChannel0, co, 0).rgb;\n}\n\n// Nebula density\nfloat nebula(vec4 p) {\n    // Component in space directions\n    vec3 p_s = p.xyz;\n    \n    float n0 = texture(iChannel1, p_s * 0.005).r;\n    float n1 = texture(iChannel1, p_s * 0.001).r;\n    float n2 = texture(iChannel1, p_s * 0.0002).r;\n\n    return clamp(n0 * n1  * n1 * n2 - 0.1, 0., 1.);\n}\n\n// 4D star cluster SDF\n// SDF between a cluster and a dispersing line of light of different wavelengths.\n// 'elongation' is a vector from the point at one end of the spectrum to the other.\nfloat sdCluster (vec4 p, vec4 elongation, float l) {\n    float dist = CLUSTER_CELL_SIZE;\n    \n    ivec3 p_idx = ivec3(floor(p.xyz / CLUSTER_CELL_SIZE));\n    \n    // Loop over adjacent cells\n    #ifdef HIGH_QUALITY\n    for(int x = -1; x <= 1; x++) {\n        for(int y = -1; y <= 1; y++) {\n            for(int z = -1; z <= 1; z++) {\n    #else\n    int x,y,z = 0;\n    #endif\n                ivec3 idx = p_idx + ivec3(x, y, z);\n                \n                vec3 star_future_3 = (rand3_3(idx) - vec3(0.5)) * CLUSTER_RAND_VEL;\n                vec4 star_future = normalize(CLUSTER_FUTURE + vec4(star_future_3, 0.));\n\n                vec3 star_pos_3 = rand3_3(idx + ivec3(17, 37, 49)) * CLUSTER_CELL_SIZE * 0.5 + CLUSTER_CELL_SIZE * 0.25;\n                vec4 star_pos = vec4(star_pos_3 + vec3(idx) * CLUSTER_CELL_SIZE, CENTER_LIGHT_TIME_VEL * length(vec3(idx)));\n                vec4 pa = p - star_pos;\n\n                // Elongate along elongation vector\n                vec4 orth_elongation = elongation - proj(star_future, elongation);\n                float t2 = dot(pa, orth_elongation)/dot(orth_elongation, orth_elongation);\n                pa = pa - clamp(t2, -1., 0.) * orth_elongation;\n\n                // Elongate (infinitely) along star future\n                float t1 = dot(pa, star_future)/dot(star_future, star_future);\n                pa = pa - t1 * star_future;\n\n                // Calculate distance to star\n                dist = min(dist, length(pa));\n                \n    #ifdef HIGH_QUALITY\n            }\n        }\n    }\n    #endif\n    return dist;\n}\n\n// Volumetric 4d raymarching\nfloat raymarch4d(vec4 spacelike_rd, vec4 ro, vec4 future_vec, float lower_vel, float upper_vel) {\n\n    vec4 lower_ray_dir = camera(spacelike_rd, future_vec, lower_vel);\n    vec4 upper_ray_dir = camera(spacelike_rd, future_vec, upper_vel);\n    vec4 elongation_vec = upper_ray_dir - lower_ray_dir;\n    \n    vec4 ray_pos = ro;\n    float l = 0.;\n    float d = 0.;\n    float min_dist = MAX_DIST;\n    //Accumulated density\n    float a = 0.;\n    // Raymarching loop\n    for(int i = 0; i < MAX_ITERATIONS; i++){\n        vec4 p = ray_pos + l * lower_ray_dir;\n        d = sdCluster(ray_pos + l * lower_ray_dir, l * elongation_vec, l);\n        a += min(1., exp2(STAR_SIZE - d / GLOW_DIST));\n        l += d + STAR_SIZE * 0.5;\n        if (l > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return a;\n    \n}\n\nvec2 raymarch4dNebula(vec4 spacelike_rd, vec4 ro, vec4 future_vec, float lower_vel, float upper_vel) {\n\n    vec4 lower_ray_dir = camera(spacelike_rd, future_vec, lower_vel);\n    vec4 upper_ray_dir = camera(spacelike_rd, future_vec, upper_vel);\n    vec4 elongation_vec = upper_ray_dir - lower_ray_dir;\n    \n    vec4 ray_pos = ro;\n    float l = 0.;\n    float d = 0.;\n    float min_dist = MAX_DIST;\n    //Accumulated density\n    vec2 a = vec2(0.);\n    // Raymarching loop\n    for(int i = 0; i < MAX_ITERATIONS; i++){\n        vec4 p = ray_pos + l * lower_ray_dir;\n        d = sdCluster(ray_pos + l * lower_ray_dir, l * elongation_vec, l);\n        float intensity = clamp(20. / (d), 5., 20.);\n        a += vec2(nebula(p), nebula(p + vec4(1000., 0.,0.,0.))) * intensity;\n        \n        l += 5.;\n        if (l > MAX_DIST) {\n            \n            break;\n        }\n    }\n    return a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cam_uv = ((fragCoord/iResolution.xy) - vec2(0.5)) * vec2(iResolution.x / iResolution.y, 1.);\n    \n    // Calculate camera position & direction. The requires 3 orthogonal vectors to define in 4d.\n    float orbit_rate = 0.05; // radians/sec\n    \n    vec2 m = iMouse.xy / iResolution.xy * 30. - vec2(15.);\n    \n    vec4 fwd = vec4(sin(iTime * orbit_rate), cos(iTime * orbit_rate), 0., 0.);\n    #ifdef CAMERA_MOTION\n    float vel = (0.1 - 0.1 * cos(iTime * 0.1));\n    vec4 future = normalize(vec4(0., -0.5 * vel, 0., 1.));\n    #else\n    vec4 future = vec4(0.,0.,0.,1.);\n    #endif\n    vec4 camera_d = camera_spacelike_dir(cam_uv, fwd, UP_4, future);\n    vec4 base_pos = 20. * (0.1 * iTime - sin(iTime * 0.1)) * vec4(0., 1.,0.,0.);\n    #ifdef STARS_MOVE\n    vec4 ray_pos = base_pos + fwd * m.x + UP_4 * m.y -future * iTime;\n    #else\n    vec4 ray_pos = base_pos + fwd * m.x + UP_4 * m.y;\n    #endif\n    \n    \n    // Raymarch 4 different wavelength/velocity ranges\n    float r = raymarch4d(camera_d, ray_pos, future, 0.58, 0.65); // Red light is slowest (Pointed most towards the camera's future)\n    float g = raymarch4d(camera_d, ray_pos, future, 0.51, 0.59);\n    float b = raymarch4d(camera_d, ray_pos, future, 0.46, 0.54);\n    float v = raymarch4d(camera_d, ray_pos, future, 0.44, 0.48); // Violet light is fastest\n    \n    vec2 n = raymarch4dNebula(camera_d, ray_pos, future, 0.44, 0.65) / float(MAX_ITERATIONS);\n    \n    // Wavelength range colors\n    vec3 r_col = vec3(0.8, 0.1, 0.);\n    vec3 g_col = vec3(0.1, 0.8, 0.);\n    vec3 b_col = vec3(0., 0.2, 0.4);\n    vec3 v_col = vec3(0.25, 0., 0.6);\n    vec3 nebula_col1 = vec3(1., 0.5, 0.);\n    vec3 nebula_col2 = vec3(0.5, 0.0, 1.);\n    // Additively mix final color\n    vec3 col = r * r_col + g * g_col + b * b_col + v * v_col + n.x * nebula_col1 + n.y * nebula_col2;\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// A starfield 4-D spacetime described by Greg Egan in his Orthogonal series.\n//\n// The universe rendered here is mostly accurate to the one described by Greg Egan in his Orthogonal \n// series.\n//\n// This scene shows a universe with 4 dimensions, much like our own, except that there is no special\n// \"time\" dimension. Objects are free to move in any direction (Always with a velocity of 1).\n// For any given observer, their direction of motion dictates their own arrow of time.\n//\n// Stars are modelled as infinitely long 4-d lines. Because these lines are not parallel (The stars\n// are moving), the 3-D domain repetition is a bit of a hack and sometimes ends up cutting off parts\n// of stars. It only works well when the observer's arrow of time is approximately parallel with\n// the stars.\n// \n// One consequence of this universe is that the speed of light depends on its wavelength (which\n// depends on its orientation relative to you). This creates the streaks seen behind the stars.\n// For the sake of accuracy, rendering is done by sampling light is sampled at a few different \n// wavelength ranges. This also contributes to slow rendering.\n//\n// Another consequence is that a constantly accelerating object will eventually have a direction\n// orthogonal to its original direction, which would appear to a stationary observer like moving at an\n// infinite velocity.\n//\n// One aspect which is not modelled is that this universe must be a finite, compact manifold thanks to\n// the properties of light waves. This could likely be modelled by domain repitition, but care would\n// have to be taken to ensure that every star loops back to its original position after exactly one lap.\n//\n// For a more complete explaination of the physics/geometry of Riemmanian spacetime,\n// see http://gregegan.net/ORTHOGONAL/ORTHOGONAL.html\n\n\n\n// ------------------------------------------ SETTINGS ------------------------------------------\n// More stars & less artifacts - uncomment if your computer can handle it\n\n//#define HIGH_QUALITY\n\n// Less stars and more performance\n\n//#define POTATO_QUALITY\n\n// Stars will actually move through the 4d spacetime.\n// This causes artefacts with the domain repetition after some time\n\n//#define STARS_MOVE\n\n// Controls how long star trails are.\n#define STAR_VELOCITY 0.1\n\n// Take camera velocity into account when rendering stars.\n// This will give a more realistic perspective of a moving observer.\n#define CAMERA_MOTION\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}