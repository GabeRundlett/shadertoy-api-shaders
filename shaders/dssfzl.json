{
    "Shader": {
        "info": {
            "date": "1689086552",
            "description": "attack for artfight 2023 @ redbirdrabbit!!!!!!\nseems to break on certain gpus - i didn't intend to turn this into a shadertoy upload, only exporting to gif, sorry!\nhttps://artfight.net/attack/4948553.get-comfortable",
            "flags": 32,
            "hasliked": 0,
            "id": "dssfzl",
            "likes": 24,
            "name": "Get Comfortable . [artfight2023]",
            "published": 3,
            "tags": [
                "2d",
                "artfight",
                "artfight2023"
            ],
            "usePreview": 0,
            "username": "oatmealine",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592653\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n  p = fract(p * .1031);\n  p *= p + 33.33;\n  p *= p + p;\n  return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n  p3 += dot(p3, p3.zyx + 31.32);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n  const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n  const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n  vec2  a = p - i + (i.x+i.y)*K2;\n  float m = step(a.y,a.x); \n  vec2  o = vec2(m,1.0-m);\n  vec2  b = a - o + K2;\n  vec2  c = a - 1.0 + 2.0*K2;\n  vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n  vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n  return dot( n, vec3(70.0) );\n}\n\n//perform one step of netwon's method to finalize the estimate\n#define ONE_NEWTON_STEP\n\n// of equation x^3+c1*x+c2=0\n/* Stolen from http://perso.ens-lyon.fr/christophe.winisdoerffer/INTRO_NUM/NumericalRecipesinF77.pdf,\n   page 179 */\n// subsequently stolen from https://www.shadertoy.com/view/MdfSDn\nfloat cubicRoot(float c1, float c2) {\n\tfloat q = -c1/3.;\n\tfloat r = c2/2.;\n\tfloat q3_r2 = q*q*q - r*r;\n\tif(q3_r2 < 0.) {\n\t\tfloat a = -sign(r)*pow(abs(r)+sqrt(-q3_r2),.333333);\n\t\tfloat b = a == 0. ? 0. : q/a;\n\t\treturn a+b;\n\t}\n\tfloat theta = acos(r/pow(q,1.5));\n\treturn -2.*pow(q,.5)*cos(theta/3.);\n}\n\nvec2 cls_one(vec2 p, float f) {\n  //sorry this is unreadable\n  float f2 = f*f; //sq\n  float cmn = 8.*f2*f2;\n  float x = sin(p.x*f)/f;\n  float pp = ((-4.*p.y-4.)*f2 + 1.)/cmn;\n  float qq = -x/cmn;\n  float sol = cubicRoot(pp, qq);\n  \n  x = asin(clamp(sol*f,-1.,1.))/f;\n  return vec2(x,-cos(f*2.*x));\n}\n\nvec3 sine_SDF(vec2 p, float freq) {\n  float wavelen = PI/freq;\n\n  //map p to be within the principal half cycle\n  float cell = round(p.x/wavelen)*wavelen;\n  float sgn = sign(cos(p.x*freq));\n  p.x = (p.x-cell)*sgn;\n  \n  vec2 off = vec2(-PI/freq/2.,0);\n  //approximate either side of the principal half cycle with\n  //the distance to the 2nd chebyshev polynomial of the 1st kind\n  vec2 a = -off+cls_one(off+p, freq/2.);\n  vec2 b =  off-cls_one(off-p, freq/2.);\n\n  //pick closest, comment out to see how the one-sided approximation looks\n  if (length(p-b) < length(p-a)) a = b;\n\n#ifdef ONE_NEWTON_STEP\n  //newton's method update via lagrange multipliers\n  //visually very close after one step, but more increases accuracy quadratically\n  vec3 K = vec3(a,p.x-p.y);\n  \n  //it might be possible to simplify this a lot...\n  vec3 lagrange = vec3(2.*(K.x-p.x)+K.z*-cos(K.x*freq)*freq,\n      2.*(K.y-p.y)-K.z,\n      K.y+sin(K.x*freq));\n  K -= (inverse(mat3(2.-K.z*-sin(K.x*freq)*freq*freq,0,cos(K.x*freq)*freq,0,2,1,-cos(K.x*freq)*freq,-1,0))*lagrange);\n  a = K.xy;\n  a.y = -sin(a.x*freq);\n#endif\n\n  float dist = length(p-a)*sign(p.y+sin(p.x*freq));\n  //map the closest point back to global coordinates\n  a.x *= sgn; a.x += cell;\n  return vec3(dist,a);\n}\n\nvec2 rotate(vec2 uv, float rot) {\n  // algebra formula for rotation by matrix , https://en.wikipedia.org/wiki/Rotation_matrix\n  mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n  // rotation of uv with matrix algebra formula where is set the rotation angle \n  return m * uv;\n}\n\n// ohhhhhh inigo quilez what would i do without you...\n\nfloat sdCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n  vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n  vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n  vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n  vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n  vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n  float s = sign( e0.x*e2.y - e0.y*e2.x );\n  vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                    vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                    vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n  return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w ) {\n  float r = 0.5*length(b-a);\n  float d = 0.5*(r*r-w*w)/w;\n  vec2 v = (b-a)/r;\n  vec2 c = (b+a)*0.5;\n  vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n  vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n  return length( q-h.xy) - h.z;\n}\n\n// polynomial smooth min\nfloat smin(float a, float b, float k) {\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat rand(vec2 n) { \n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noisenoise(vec2 p){\n  vec2 ip = floor(p);\n  vec2 u = fract(p);\n  u = u*u*(3.0-2.0*u);\n\n  float res = mix(\n    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n  return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm(vec2 p, float time) {\n  float f = 0.0;\n\n  f += 0.500000*noisenoise( p + time  ); p = mtx*p*2.02;\n  f += 0.031250*noisenoise( p ); p = mtx*p*2.01;\n  f += 0.250000*noisenoise( p ); p = mtx*p*2.03;\n  f += 0.125000*noisenoise( p ); p = mtx*p*2.01;\n  f += 0.062500*noisenoise( p ); p = mtx*p*2.04;\n  f += 0.015625*noisenoise( p + sin(time) );\n\n  return f/0.96875;\n}\n\nfloat pattern(in vec2 p, float time) {\n\treturn fbm(p + fbm(p + fbm(p, time), time), time);\n}\n\nvec4 maple(vec2 uv, vec2 pos, float rot, float scale) {\n  uv -= pos;\n  uv *= scale;\n  uv += pos;\n\n  uv.x += sin(uv.y * PI) * 0.05;\n\n  vec2 p = uv;\n\n  uv -= pos;\n  uv = rotate(uv, rot);\n  uv.x = -abs(min(uv.x, -uv.x));\n  uv += pos;\n\n  float round = 0.05;\n\n  float d = 9e9;\n  //d = smin(d, sdOrientedVesica(uv, pos, pos + vec2(-0.35, 0.0), 0.06), round);\n  d = smin(d, sdOrientedVesica(uv, pos, pos + vec2(-0.305, 0.15), 0.04), round);\n  d = smin(d, sdOrientedVesica(uv, pos, pos + vec2(-0.18, 0.3), 0.04), round);\n  d = smin(d, sdOrientedVesica(uv, pos + vec2(-0.07, 0.02), pos + vec2(-0.3, 0.3), 0.08), round);\n  d = smin(d, sdOrientedVesica(uv, pos, pos + vec2(0, 0.45), 0.1), round);\n  d = smin(d, sdOrientedVesica(uv, pos + vec2(0.0, 0.1), pos + vec2(-0.065, 0.4), 0.02), round);\n  d = smin(d, sdOrientedVesica(uv, pos + vec2(0.0, 0.1), pos + vec2(-0.1, 0.34), 0.05), round);\n\n  float rad = 0.01;\n  float alpha = smoothstep(rad, rad - 15. / iResolution.x, d);\n\n  vec3 col = vec3(1.0, 0.3, 0.0);\n  col -= max(0.02 - d, 0.0) * 1.0;\n  \n  // outline\n  col = mix(vec3(0.1), col, clamp(smoothstep(0.01, 0.05, rad - d), 0.0, 1.0));\n\n  col += (0.28 - length(vec2(p.x * 0.8, p.y) - vec2(-0.1, 0.5))) * 0.2;\n\n  return vec4(col, alpha);\n}\n\nvec4 eye(vec2 uv, vec2 pos, float t) {\n  uv -= pos;\n  vec2 uvI = uv;\n\n  float blink = 1.0 - pow(1.0 - ((sin(t * PI * 2.0)) * 0.5 + 0.5), 150.0);\n  //float blink = 1.0;\n\n  uv.y /= blink;\n\n  float size = 0.14 - blink * 0.02;\n  vec2 eyePos = vec2(uv.x, uv.y + sign(uv.y) * size);\n\n  float rad = 0.2;\n  float dist = length(eyePos);\n  bool inside = dist < rad;\n\n  float alpha = smoothstep(rad + 10. / iResolution.x, rad, dist);\n  vec3 col = vec3(1.0);\n\n  col -= smoothstep(0.8, 1.2, length(mix(uv, uvI, 0.6) * vec2(0.75, 1.0) - vec2(0.0, -0.1)) * 7.0) * 0.2;\n\n  vec2 irisPos = vec2(noise(vec2(t * 1.3, 0.0)), noise(vec2(0.0, -t * 1.3))) * 0.006;\n  float irisDist = 1.0 - length(irisPos - uvI) / 0.2;\n  float irisMix = smoothstep(0.6, 0.8, irisDist);\n  col = vec3(mix(col.r, 0.0, mix(irisMix, sqrt(irisMix), 0.3)), mix(col.g, 0.0, mix(irisMix, sqrt(irisMix), 0.8)), mix(col.b, 0.0, sqrt(irisMix)));\n\n  return vec4(col.rgb, alpha);\n}\n\nvec4 limb(vec2 uv, float t, float shift) {\n  if ((uv.y - uv.x) > 0.2) return vec4(0.0);\n  uv += vec2(0.1, -0.73);\n  float rad = 0.01 + noise(vec2(uv.y, shift)) * 0.01 + smoothstep(-0.3, -0.1, uv.y) * 0.1;\n  float dist = abs(sine_SDF((vec2(uv.y, uv.x) + vec2(0.0, -0.5)) * 2.0, 2.75 + sin(t * PI * 2.0) * 0.07).x);\n  float alpha = smoothstep(rad + 50. / iResolution.x, rad, dist);\n  return vec4(vec3(0.0), alpha);\n}\nvec4 limb2(vec2 uv, float t, float shift) {\n  //if (uv.x > 0.15) return vec4(0.0);\n  vec2 p = uv;\n  uv += vec2(-0.55, 0.55);\n  float rad = 0.01 + noise(vec2(uv.y, shift)) * 0.01;\n  float dist = abs(sine_SDF((uv + vec2(0.0, -0.5)) * 2.0, 1.25 + sin(t * PI * 2.0) * 0.07).x);\n  float alpha = smoothstep(rad + 50. / iResolution.x, rad, dist);\n  return mix(vec4(vec3(0.0), alpha), vec4(0.0), clamp((p.x - 0.13) / (0.13 - 0.1), 0.0, 1.0));\n}\nvec4 limb3(vec2 uv, float t, float shift) {\n  //if (uv.x > 0.4) return vec4(0.0);\n  vec2 p = uv;\n  uv += vec2(-0.9, 0.77);\n  float rad = 0.01 + noise(vec2(uv.y, shift)) * 0.01;\n  float dist = abs(sine_SDF((uv + vec2(0.0, -0.5)) * 2.0, 1.55 + sin(t * PI * 2.0 - 0.5) * 0.07).x);\n  float alpha = smoothstep(rad + 50. / iResolution.x, rad, dist);\n  return mix(vec4(vec3(0.0), alpha), vec4(0.0), clamp((p.x - 0.41) / (0.5 - 0.41), 0.0, 1.0));\n}\n\nvec4 head(vec2 uv, vec2 pos, float shift, float t) {\n  uv -= pos;\n\n  float dist = abs(uv.x) + abs(uv.y) + length(uv) * 0.2;\n  float rad = 0.36;\n\n  float alpha = smoothstep(rad + 15. / iResolution.x, rad, dist);\n  vec3 col = mix(vec3(0.1), vec3(0.5), clamp(smoothstep(0.01, 0.04, rad - dist), 0.0, 1.0));\n  col += ((0.28 + sin(shift) * 0.02) - length(vec2(uv.x * 0.8, uv.y) - vec2(-0.15, 0.2)));\n\n  vec4 l = maple(uv, vec2(0.0, 0.15), sin(t * PI * 2.0 - 1.5) * 0.2, 1.2);\n\n  return vec4(mix(l.rgb, col, alpha), max(alpha, l.a));\n}\n\nvec4 leaf(vec2 uv, vec2 pos, float angle, float scale, vec3 baseCol) {\n  uv -= pos;\n\n  uv *= scale;\n  uv = rotate(uv, angle);\n  uv += vec2(0.15, 0.0);\n\n  float size = 0.14;\n  vec2 eyePos = vec2(uv.x, uv.y + sign(uv.y) * size);\n\n  float rad = 0.2;\n  float dist = length(eyePos);\n  bool inside = dist < rad;\n\n  float alpha = smoothstep(rad + 15. / iResolution.x, rad, dist);\n  vec3 col = baseCol;\n\n  col -= smoothstep(0.8, 1.2, length(rotate(uv, -angle) + vec2(0.05, -0.1)) * 7.0) * 0.1;\n\n  float shadeScale = 1.0;\n  float xDist = shadeScale * 0.5 - (length(uv - vec2(0.0, 0.48)) * shadeScale);\n\n  col -= smoothstep(0.98, 1.0, shadeScale - abs(xDist)) * 0.1;\n\n  // outline\n  col = mix(vec3(0.1), col, clamp(smoothstep(0.0, 0.013, rad - dist), 0.0, 1.0));\n\n  return vec4(col, alpha);\n}\n\n#define rgb(r,g,b) (vec3(r,g,b) / 255.0)\n\n// see viewpalette.html\n#define PALETTE_SIZE 8\nvec3 colors[PALETTE_SIZE] = vec3[](\n  rgb(201, 204, 161),\n  rgb(202, 160, 90),\n  rgb(174, 106, 71),\n  rgb(139, 64, 73),\n  rgb(84, 51, 68),\n  rgb(81, 82, 98),\n  rgb(99, 120, 125),\n  rgb(142, 160, 145)\n);\n\nvec3 getPalette(vec3 col) {\n  // comparasion\n  float minDist = 9e9;\n  vec3 newCol;\n\n  for (int i = 0; i < PALETTE_SIZE; i++) {\n    vec3 compareCol = colors[i];\n\n    vec3 distVec = abs(col - compareCol);\n    float dist = (distVec.r + distVec.g + distVec.b) / 3.0;\n\n    if (dist < minDist) {\n      newCol = compareCol;\n      minDist = dist;\n    }\n  }\n\n  return newCol;\n}\n\n\nfloat Bayer2(vec2 a) {\n  a = floor(a);\n  return fract(a.x/2. + a.y*a.y * .75);\n}\n\n#define Bayer4(a)   ( Bayer2( .5*(a))/4. + Bayer2(a) )\n#define Bayer8(a)   ( Bayer4( .5*(a))/4. + Bayer2(a) )\n#define Bayer16(a)  ( Bayer8( .5*(a))/4. + Bayer2(a) )\n#define Bayer32(a)  ( Bayer16(.5*(a))/4. + Bayer2(a) )\n#define Bayer64(a)  ( Bayer32(.5*(a))/4. + Bayer2(a) )\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float t = fract(iTime * 0.2);\n  float shift = t * 5.0;\n\n  float itimer = fract(t + 0.2);\n  float downslope = pow(max(cos(itimer * 2.0 * PI * 0.188) * 2.0 - 1.0, 0.0), 0.6);\n  float downslope2 = max(pow(max(cos(fract(itimer + 0.05) * 2.0 * PI * 0.188) * 2.0 - 1.0, 0.0), 0.6), 0.0);\n  float upslope = pow(max(cos(itimer * 2.0 * PI * 2.0) + itimer - 1.0, 0.0), 0.5);\n  float intense = max(downslope, upslope);\n\n  // square & center\n  uv -= 0.5;\n  uv.x /= iResolution.y / iResolution.x;\n  uv += 0.5;\n  \n  if (uv.x < 0.0 || uv.x > 1.0) {\n    fragColor = vec4(vec3(0.0), 1.0);\n    return;\n  }\n\n  // pix\n  float pix = 256.0;\n  uv = floor(uv * pix) / pix + 0.001;\n\n  //uv.x += noise(uv * 2.0 + 0.5 * shift) * 0.003;\n  //uv.y += noise(uv * 2.0 - 0.5 * shift) * 0.003;\n\n  float fbmnoise = fbm(uv * 2.0, sin(t * PI * 2.0));\n  \n  // uncenter & unsquare\n  vec2 puv = uv;\n  puv -= 0.5;\n  puv.x *= iResolution.y / iResolution.x;\n  puv += 0.5;\n  \n  vec2 wuv = puv + vec2(sin(fbmnoise * 2.0 * PI), cos(fbmnoise * 2.0 * PI)) * 0.14 * (1.0 - intense);\n  float disp = 0.05 * (1.0 - intense);\n  vec3 bgcol = (\n    texture(iChannel0, wuv + vec2(disp, disp)).rgb +\n    texture(iChannel0, wuv + vec2(-disp, disp)).rgb +\n    texture(iChannel0, wuv + vec2(disp, -disp)).rgb +\n    texture(iChannel0, wuv + vec2(-disp, -disp)).rgb\n  ) / 4. - vec3(0.02);\n\n  vec3 chromacol = vec3(0.0, 0.25, 1.0);\n\n  vec3 col = chromacol;\n\n  vec4 ll = limb(vec2(1.0 - uv.x, uv.y), t, shift);\n  col = mix(col, ll.rgb, ll.a);\n  vec4 ll2 = limb2(uv, t, shift);\n  col = mix(col, ll2.rgb, ll2.a);\n  vec4 ll3 = limb3(uv, t, shift);\n  col = mix(col, ll3.rgb, ll3.a);\n\n  vec2 hpos = vec2(0.5, 0.6);\n  vec2 hmov1 = vec2(sin(t * PI * 2.0), cos(t * PI * 2.0));\n  vec2 hmov2 = vec2(cos(t * PI * 2.0), sin(t * PI * 2.0 + 1.0));\n  vec2 hmov = vec2(noise(hmov1.xy * 0.2 + 10.0), noise(hmov2.xy * 0.2 + 5.0));\n  vec2 huv = rotate((uv + hmov * 0.03) - hpos, sin(t * PI * 2.0) * 0.1) + hpos;\n  vec4 h = head(huv, hpos, intense, t);\n  col = mix(col, h.rgb, h.a);\n\n  vec4 e = eye(huv, hpos, t);\n  col = mix(col, e.rgb, e.a);\n\n  vec4 l1 = leaf(uv, vec2(0.5 + sin(t * PI * 2.0) * 0.02, 0.2 + sin(t * PI * 2.0) * 0.01), -sin(t * PI * 2.0 + 0.9) * 0.2 + 0.3 + PI, 1.0, vec3(1.0, 0.5, 0.1));\n  col = mix(col, l1.rgb, l1.a);\n  vec4 l2 = leaf(uv, vec2(0.15 + sin(t * PI * 2.0 - 0.5) * 0.04, 0.1), sin(t * PI * 2.0 - 1.2) * 0.2 - 0.5 + PI, 1.5, vec3(1.0, 0.3, 0.1));\n  col = mix(col, l2.rgb, l2.a);\n  vec4 l3 = leaf(uv, vec2(0.8 + sin(t * PI * 2.0) * 0.02, 0.08 + sin(t * PI * 2.0) * 0.01), -sin(t * PI * 2.0 + 0.1) * 0.2 + 0.4 + PI, 1.7, vec3(1.0, 0.55, 0.1));\n  col = mix(col, l3.rgb, l3.a);\n\n  float chroma = smoothstep(length(col - chromacol), 0.0, 0.5) / 0.3;\n\n  float posterize = 7.0;\n  col += mix(\n    hash13(vec3(uv.xy * iResolution.xy, shift)) * 1.4,\n    Bayer64(uv.xy * pix + shift) * 0.5,\n    intense\n  ) * (1. / posterize);\n  //col = floor(col.rgb * posterize + hash13(vec3(uv.xy * iResolution.xy, shift)) * 0.5) / posterize;\n  //col = floor(col.rgb * posterize + Bayer64(uv.xy * pix + shift) * 0.5) / posterize;\n  col = getPalette(col);\n  //col = floor(col.rgb * posterize) / posterize;\n\n  col = pow(col, vec3(mix(1.0, 2.5 + hash11(t * 50.0) * 1.0, 1.0 - intense)));\n\n  float bgblend = mix(chroma, 1.0, pow(intense, 1.5));\n  float fuckening = mix(bgblend, min(bgblend, 1.0 - e.a), 1.0 - downslope2);\n\n  vec3 back = mix(bgcol, vec3(0.0), 0.2);\n\n  fragColor = vec4(mix(back, col, fuckening), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}