{
    "Shader": {
        "info": {
            "date": "1570379344",
            "description": "Creating a husky is quite hard, so i made a doggo. Many doggos. Many many dogogogogosgod ododgogosdogogogo",
            "flags": 0,
            "hasliked": 0,
            "id": "tdV3Wm",
            "likes": 4,
            "name": "Shadertober 06 Husky",
            "published": 3,
            "tags": [
                "inktober",
                "husky",
                "rarymarching",
                "doggo"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 450
        },
        "renderpass": [
            {
                "code": "// SHADERTOBER 06 Husky\n// Poulet vert 06-10-2019\n// many thanks to iq, flafla2, leon\n\n#define PI 3.14159\n#define MAXSTEP 64\n\nfloat Vignette(vec2 uv, float force)\n{\n    float f = clamp(force, 0.001, 1.0);\n    return f + (1.0 - length(uv)) * f;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// Scene setup\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0);\n    float x = 0.0;\n    float y = 0.0;\n    \n    t = vec2(pos.y, 0.0);\n    \n    // doggo\n    \n    vec3 dP = pos + vec3(0.0, -0.1, 1.7);\n    \n    dP.xz *= rot(PI/6.0);\n    dP.x -= iTime;\n    dP.y -= abs(sin(iTime*10.)*.1);\n    dP = opRep(dP, vec3(1.0, 0.0, 1.0));\n    vec2 dog = vec2(sdBox(dP, vec3(.1, .05, .05)), 0.0);\n    \n    vec3 oreP = dP + vec3(-0.08, -0.07, 0.04);\n    float or = sdBox(oreP, vec3(0.02, 0.03, 0.01));\n    oreP = dP + vec3(-0.08, -0.07, -0.04);\n    or = uSDF(or, sdBox(oreP, vec3(0.02, 0.03, 0.01)));\n    vec2 orm = vec2(or, 0.0);\n    \n    vec3 patP = dP + vec3(-0.09, 0.06, 0.04);\n    float pat = sdBox(patP, vec3(0.01));\n    patP = dP + vec3(0.09, 0.06, 0.04);\n    pat = uSDF(pat, sdBox(patP, vec3(0.01)));\n    patP = dP + vec3(0.09, 0.06, -0.04);\n    pat = uSDF(pat, sdBox(patP, vec3(0.01)));\n    patP = dP + vec3(-0.09, 0.06, -0.04);\n    pat = uSDF(pat, sdBox(patP, vec3(0.01)));\n    vec2 patm = vec2(pat, 0.0);\n    \n    vec3 faceP = dP + vec3(-0.1, -0.02, 0.02);\n    vec2 face = vec2(sdBox(faceP, vec3(.005)), 2.0);\n    faceP = dP + vec3(-0.1, -0.02, -0.02);\n    face = opU(face, vec2(sdBox(faceP, vec3(.005)), 2.0));\n    faceP = dP + vec3(-0.1, -0.0, 0.0);\n    face = opU(face, vec2(sdBox(faceP, vec3(.04, .02, .015)), 0.0));\n    faceP = dP + vec3(-0.13, 0.02, 0.0);\n    face = opU(face, vec2(sdBox(faceP, vec3(.002, .01, .005)), 1.0));\n    faceP = dP + vec3(-0.14, -0.02, 0.0);\n    face = opU(face, vec2(sdBox(faceP, vec3(.01)), 2.0));\n    \n    t = opU(t, dog);\n    t = opU(t, orm);\n    t = opU(t, patm);\n    t = opU(t, face);\n    \n    return t;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(float(i)/64., ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(.0); \n        \n    }\n    else\n    {\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(1.0 - t.x);\n        }\n        else if(t.y == 1.0)\n        {\n            col = vec3(1.0, 0.3, 0.7);\n        }\n        else if(t.y == 2.0)\n        {\n            col = vec3(0.0, 0.0, 0.0);\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime * 0.5;\n    \n    vec3 cp = vec3(0.0, .25, -2.0);\n    vec3 ct = vec3(cos(iTime), 0.1, sin(iTime));\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    // compo\n    col -= mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), screenUV.y)*.3;\n    \n    col *= vec3(Vignette(uv, 0.45));\n    \n    col *= 1.1;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}