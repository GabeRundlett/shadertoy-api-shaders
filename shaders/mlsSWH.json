{
    "Shader": {
        "info": {
            "date": "1674742938",
            "description": "Yet another curl noise demonstration. This one focuses more on presentation than procedural fluid flow, etc, so I wouldn't take the physics component too seriously.",
            "flags": 32,
            "hasliked": 0,
            "id": "mlsSWH",
            "likes": 114,
            "name": "Visualizing Curl Noise",
            "published": 3,
            "tags": [
                "noise",
                "swirl",
                "fluid",
                "gradient",
                "curl",
                "warp",
                "bump",
                "flow",
                "vortex"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2392
        },
        "renderpass": [
            {
                "code": "/*\n\n    Visualizing Curl Noise\n    ----------------------\n\n    This example consists of simple to apply procedural and aesthetic \n    lighting cliches. In particular, it's some bump mapped warped noise\n    with colored highlighing. The warp operation used is the curl of a\n    noise based function, and it's applied in feedback form.\n    \n    Field flow examples are not new to me, but I hadn't been motivated to\n    post one until seeing Leon's really nice \"Curling Smoke\" submission. \n    I cobbled together some old code for this example, but it was good to \n    have Leon's and a couple of Fabrice's examples to refer to. I liked \n    the way Leon used blue noise to slightly randomize the offset sample \n    length when bump mapping, so I \"borrowed\" that idea. :)\n    \n    If you're not familiar with a curl function, I tend to liken it to \n    a perpendicular gradient vector of sorts that directs the flow in \n    a direction perpendicular to the tangential motion, which results \n    in vortex swirls -- Intuitively, if an object or particle travels \n    along a curve and you apply a sideways force component, a spiralesque \n    traversal pattern will result. \n    \n    Domain warping is a pretty common graphics procedure and there are \n    too many examples on Shadertoy to count. The idea is to warp the \n    input coordinates in some way prior to passing them to a function. \n    The function can be whatever you want, like a simple 2D checker or \n    Truchet pattern, texture, or a 3D object. You can warp the \n    coordinates just once, or integrate them, which can be achieved via \n    multiple loop iterations, or in buffered feedback form. I'm using\n    the latter method here.\n    \n    In regard to appearance, I wanted to provide a flow example that \n    clearly demonstrated the swirly flow motion. I did that by applying\n    a heavy bump and some surface curvature shading -- By the way,\n    curvature is easy to apply and can really bring out a surface.\n    \n    I used a very basic aesthetic cliche for the lighting. There are three\n    lights, including a main directional white light, and two lesser\n    strength red and blue lights, which hit from opposing directions. If\n    you've watched a movie lately, then I'm sure you're familiar with it.\n    \n    Anyway, this is not meant to be a treatise on applying curl distortion \n    to noise, or using the curl vector in general, but hopefully, it'll \n    give someone a start. By the way, I have an old 3D curl example that\n    I intend to post at some stage.\n    \n    \n    Related examples:\n    \n    // Really fun to watch. The transcendental noise works nicely\n    // in Leon's example, but I'm not sure it would have with the\n    // setup I have here.\n    https://www.shadertoy.com/view/cl23Wt\n    \n    // Integrating uv coordinates to a noise flow texture. IQ has a\n    // heap of \"Iterations\" tagged shaders that are all worth looking at.\n    Texture flow III - iq\n    https://www.shadertoy.com/view/ldjXD3\n    \n    // Related vector field line example. Fabrice has a heap of\n    // flow related examples that are worth looking at.\n    vortex field (flow/magnetic) - FabriceNeyret2\n    https://www.shadertoy.com/view/lljczz\n\n \n*/\n\n\n// Pinkish purple highlights.\n//#define PINK\n\n\n/*\n// Smoother texture sample.\nvec3 tx2D5(vec2 p, float mL){\n    vec3 col = texture(iChannel0, p, mL).xyz;\n    vec3 e = vec3(1./iResolution.xy, 0);\n    col += (texture(iChannel0, p + e.xz).xyz + texture(iChannel0, p - e.xz).xyz +\n            texture(iChannel0, p + e.yz).xyz + texture(iChannel0, p - e.yz).xyz)*.7;\n    return col/3.8;\n\n}*/\n\n// Texture samples.\nvec3 tx2D(vec2 p){ return texture(iChannel0, p).xyz; }\n\n// Texture height.\nfloat getHeight(vec2 p){ return dot(tx2D(p), vec3(.299, .587, .114)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Screen coordinates.\n    vec2 iR = iResolution.xy;\n    vec2 uv = fragCoord/iR;\n    \n    \n    // Texture samples.\n    vec3 col = tx2D(uv);\n    // Height value and offset sample for the colored lights.\n    float height = dot(col, vec3(.299, .587, .114));\n    float height2 = getHeight(uv - normalize(vec2(1, 2))*.001*vec2(iR.x/iR.y, 1));\n    \n\n    // High frequency blue noise sample offset that I took from Leons curl example.\n    vec3 nTx = texture(iChannel1, fragCoord/1024.).xyz;\n    vec2 e = vec2((pow(dot(nTx, vec3(.299, .587, .114)), 3.)*.5 + .5)*.007, 0);\n    //vec2 e = vec2(.0045, 0); // Constant sample distance.\n\n    // Taking four nearby offset samples to use for gradient and curvature calculations.\n    vec4 t4 = vec4(getHeight(uv - e.xy),  getHeight(uv + e.xy), \n               getHeight(uv - e.yx), getHeight(uv + e.yx));\n\n    // Using the samples above and some vector math to obtain the surface normal. \n    // I did it this way just to show that there were other possibilities.\n    //vec3 vx = vec3(e.x, 0, -t4.y) - vec3(-e.x, 0, -t4.x);\n    //vec3 vy = vec3(0, -e.x, -t4.z) - vec3(0, e.x, -t4.w);\n    vec3 vx = vec3(e.x*2., 0, t4.x - t4.y);\n    vec3 vy = vec3(0, -e.x*2., t4.w - t4.z);\n    vec3 sn = normalize(cross(vx, vy));\n    \n    // One line approximation to the above, if you prefer.\n    //vec3 sn = normalize(vec3(t4.x - t4.y, t4.z - t4.w, -height*e.x*2.)); \n    \n    // Using the four samples above to calculate the surface curvature.\n    float amp = .7;\n    float curv = clamp((height*4. - dot(t4, vec4(1)))/e.x/2.*amp + .5, 0., 1.);\n         \n     \n    // Directional light. \n    vec3 ld = normalize(vec3(-.5, 1, -1));\n    // Point light, if preferred.\n    //vec3 ld = normalize(vec3(.25, 1.25, -.5) - vec3(uv, 0));\n\n    // Directional derivative colored heighlight values.\n    float b = max(height2 - height, 0.)/.001;\n    float b2 = max(height - height2, 0.)/.001;\n    // Highlight colors.\n    vec3 hiCol = vec3(.02, .2, 1)*b*.8 + vec3(1, .2, .1)*b2*.3;\n\n    #ifdef PINK\n    // Pinkish purple lights.\n    col = mix(col.xzy, col, max(dot(sn, ld), 0.));\n    #endif\n    \n    // Specular light, if you wanted that.\n    /*\n    vec3 rd = normalize(vec3(uv, 1));\n    float spe = pow(max(dot(reflect(ld, sn), rd), 0.), 16.);\n    hiCol += spe*2.;\n    */\n\n    // Applying the directional light, colored highlights and a bit of \n    // ambient light to the surface.\n    col *= max(dot(sn, ld), 0.) + hiCol + .4;\n\n    // Applying the curvature.\n    col *= curv + .2; \n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Integrate more frames and increase the swirl length.\n//#define LONGER\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(27, 57, 111)));   \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n \n}\n\n/*\n// Hastily modified \"uint\" based hash function. It's a mixture of\n// IQ and Fabrice's versions. It should be more reliable, but I\n// haven't tested it for speed inside a raymarching loop, so I'll\n// leave the old function (above) in place for now.\n//\n// IQ's hash function here: https://www.shadertoy.com/view/XlXcW4 \n//\n// IQ's uvec3 to vec3 hash.\nvec3 hash33(vec3 f){\n\n    //const uint k = 1664525U; // Numerical Recipes.\n    const uint k = 20170906U; // Today's date -- Use three days ago's date if you want a prime.\n\n    uvec3 x = floatBitsToUint(f);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(2./float(0xffffffffU)) - 1.;\n}\n*/\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing -- I'll rewrite it at some stage. By the way, Stefan Gustavson has an account on\n// Shadertoy, if you feel like tracking that down.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p){\n\n    // Skewing the cubic grid, then determining the first vertex and fractional position.\n    vec3 i = floor(p + dot(p, vec3(1./3.)) );  p -= i - dot(i, vec3(1./6.));\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of \n    // the intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.\n    // Technically, these are the vectors from \"p\" to the vertices, but you know what I mean. :)\n    vec3 p1 = p - i1 + 1./6., p2 = p - i2 + 1./3., p3 = p - .5;\n  \n\n    // 3D simplex falloff - based on the squared distance from the fractional position \"p\" within the \n    // tetrahedron to the four vertex points of the tetrahedron. \n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n     \n    // Dotting the fractional position with a random vector, generated for each corner, in order to \n    // determine the weighted contribution distribution... Kind of. Just for the record, you can do a \n    // non-gradient, value version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), \n                  dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary.\n \n}\n\n\n// Layered noise function.\nfloat fBm(in vec3 p){\n    \n    // Rewriting the fBm function to lower compile times.\n    float n = 0., sum = 0., a = 1.;\n    vec3 offs = vec3(0, .23, .07);\n    for(int i = min(0, iFrame); i<3; i++){\n    \n        n += tetraNoise(p*exp2(float(i)) + offs.x)*a;\n        sum += a;\n        a *= .5;\n        offs = offs.yzx;\n    \n    }\n    \n    return n/sum;\n    \n    //return (tetraNoise(p)*4. + tetraNoise(p*2. + .23)*2. + tetraNoise(p*4. + .07))/7.;\n    //return (tetraNoise(p)*2. + tetraNoise(p*2. + .23)*1.)/3.;\n}\n \n \n// Flow function.\nfloat flow(vec3 p){\n\n   // Emulating moving toward the surface of a sphere, or landing on \n   // planet Cartoon Jupiter, if you prefer. :)\n \n   p.z -= dot(p, p)*.5; \n   p.xy *= rot2(iTime/16.);\n   #ifdef LONGER\n   // Longer swirl strands get too tight if you slice through\n   // Z too quickly, so it needs slowing down.\n   p.z += .1*iTime;\n   #else\n   p.z += .15*iTime;\n   #endif\n   \n   // You can put whatever function you want here, but simplex noise has nice\n   // animation qualities, so I've used that. At some stage, I'll try other \n   // things. By the way, if you have any suggestions, feel free to let me know.\n   return fBm(p*1.5);\n   \n   \n   /*\n   // Failed angular noise experiment.\n   p += vec3(.0, .0, .2)*iTime/3.;\n   return fBm(p*1.5*2.)*2. - 1.;\n   */\n  \n}\n\n \n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n   \n    // Coordinates.\n    vec2 iR = iResolution.xy;\n    vec2 uv = fragCoord/iR; // Window coordinates.      \n    vec2 uva = (fragCoord - iR/2.)/iR.y; // Centered, aspect correct coordinates.\n  \n    // Taking the curl of the flow function. Intuitively, the perpendicular\n    // vector to the tangent vector \"v\" is simply, \"vec2(v.y, -v.x)\", and the\n    // curl is analogous to the gradient equivalent, \"vec2(df/dy, -df/dx)\".\n    vec2 e = vec2(.005, 0);\n    vec3 p = vec3(uva, 0);//vec3(p, length(p)*.5);\n    float dx = (flow(p + e.xyy) - flow(p - e.xyy))/(2.*e.x);\n    float dy = (flow(p + e.yxy) - flow(p - e.yxy))/(2.*e.x);\n    vec2 curl = vec2(dy, -dx);\n     \n    // 3D curl. Not used here.\n    //float dz = (noise(p + e.yyx) - noise(p - e.yyx))/(2.*e.x);\n    //vec3 curl = vec3(dz - dy, dx - dz, dy - dx);\n \n/*\n    // Angular offsetting... Not right for this example.\n    vec2 e = vec2(.001, 0);\n    vec3 pos = vec3(p, 0);/\n    float a = (flow(pos))*6.2831*1.5;\n    vec2 curl = vec2(cos(a), -sin(a))*2.;\n*/\n      \n \n    // Update the field coordinates.\n    uv += curl*.006*vec2(iR.y/iR.x, 1); // Move to the new position.\n    \n    \n    // Buffer sample from the new position.\n    vec3 val = texture(iChannel0, uv).rgb;\n \n    \n    //col = texture(iChannel2, uv, 3.).xyz; col *= col;\n    //col = smoothstep(.0, .5, col);\n\n    // Create a transcental color pattern using the warped coordinates.\n    float snNs = dot(sin(uv*8. - cos(uv.yx*12.)), vec2(.25)) + .5;\n    vec3 col = .5 + .45*cos(6.2831*snNs/6. + vec3(0, 1.2, 2)*.8);\n    //vec3 col = mix(vec3(1, .8, .6).zyx, vec3(.6, .3, .2), snNs);\n   \n    // Color shading.\n    // Just the original function without the curl, which gives the\n    // impression of cast shadows.\n    col *= flow(p)*2. - .5;\n    // This is more correct, but I like the uncurled shading more.\n    //col *= flow(vec3(uv, 0))*2. - .5;\n    \n  \n    // Ridges -- Probably a little too much, but it'd be an interesting\n    // addition if you wanted to raymarch the surface.\n    //col *= abs(fract(col.x*16.) - .5)*2.*.04 + .96;\n     \n    \n    // Mix the curent warped color texture in with the previous one.\n    // Some people like to inject pixels from the sides and add those, but\n    // for this example, I'm performing a simple blend... However you mix\n    // frames is entirely up to you.\n    //\n    // More frames generally result in longer spirals. However, the speed at \n    // which we cut through the Z-planes (p.z += a*iTime), might need to \n    // be lowered.\n    #ifdef LONGER\n    const float nFrames = 32.;\n    #else\n    const float nFrames = 16.;\n    #endif\n    if(iFrame>0) col = mix(val, col, 1./nFrames);\n    \n  \n    fragColor = vec4(max(col, 0.), 1);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}