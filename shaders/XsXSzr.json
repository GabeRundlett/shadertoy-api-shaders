{
    "Shader": {
        "info": {
            "date": "1395646435",
            "description": "Just a simple raymarched sword model!",
            "flags": 0,
            "hasliked": 0,
            "id": "XsXSzr",
            "likes": 22,
            "name": "Simple Sword",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "wood",
                "sword",
                "craft",
                "steel"
            ],
            "usePreview": 0,
            "username": "HLorenzi",
            "viewed": 1425
        },
        "renderpass": [
            {
                "code": "\n#define RAYMARCH_ITERATIONS 40\n#define SHADOW_ITERATIONS 20\n#define SHADOW_STEP 0.75\n#define SHADOW_SMOOTHNESS 4.0\n\n// Distance functions from iquilezles.org\nvoid fSubtraction(inout float a, inout float m1, float b, float m2) {if (-b > a) {a = -b; m1 = m2;}}\nvoid fIntersection(inout float d1, inout float m1, float d2, float m2) {if (d2 > d1) {d1 = d2; m1 = m2;}}\nvoid fUnion(inout float d1, inout float m1, float d2, float m2) {if (d2 < d1) {d1 = d2; m1 = m2;}}\nfloat pPlane(vec3 p, vec3 n, float d) {return dot(p,n) + d;}\nfloat pSphere(vec3 p, float s) {return length(p)-s;}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\nfloat pCone(vec3 p, vec2 c) {float q = length(p.yz); return dot(c,vec2(q,p.x));}\nfloat pTorus(vec3 p, vec2 t) {vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat pTorus2(vec3 p, vec2 t) {vec2 q = vec2(length(p.xy)-t.x,p.z); return length(q)-t.y;}\nfloat pCapsule(vec3 p, vec3 a, vec3 b, float r) {vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r;}\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat distf(vec3 p, inout float m)\n{\n\tfloat d = pSphere(p, 22.0);\n\tm = 1.0;\n\t\n\tvec3 motion = vec3(0,0,cos(iTime * 2.0) * 6.0);\n\tp += motion;\n\t\n\t// Blade\n\tfIntersection(d, m, pPlane(p, normalize(vec3(0.01,0.2,1)), -1.0), 1.0);\n\tfIntersection(d, m, pPlane(p, normalize(vec3(0.01,-0.2,1)), -1.0), 1.0);\n\tfIntersection(d, m, pPlane(p, normalize(vec3(0.01,0.2,-1)), -1.0), 1.0);\n\tfIntersection(d, m, pPlane(p, normalize(vec3(0.01,-0.2,-1)), -1.0), 1.0);\n\t\n\t// Tip\n\tfIntersection(d, m, pPlane(p, normalize(vec3(-0.07,-0.2,1)), -1.5), 1.0);\n\tfIntersection(d, m, pPlane(p, normalize(vec3(-0.07,0.2,1)), -1.5), 1.0);\n\tfIntersection(d, m, pPlane(p, normalize(vec3(-0.07,-0.2,-1)), -1.5), 1.0);\n\tfIntersection(d, m, pPlane(p, normalize(vec3(-0.07,0.2,-1)), -1.5), 1.0);\n\t\n\t// Base\n\tfSubtraction(d, m, pSphere(p * vec3(1,2,1) - vec3(22,10,0), 8.0), 1.0);\n\tfSubtraction(d, m, pSphere(p * vec3(1,2,1) - vec3(22,-10,0), 8.0), 1.0);\n\t\n\t// Handle\n\tfUnion(d, m, pRoundBox(p - vec3(22.0 + cos(p.y * 0.3),0,0),\n\t\t\t\t\t\t   vec3(1,6.0 + cos(p.z * 10.0) * 0.15,1.0 + cos(p.y) * 0.5), 0.1), 2.0);\n\tfUnion(d, m, pCapsule(p, vec3(23,0,0), vec3(34,0,0), cos(p.x * 3.0) * 0.2 + 1.0), 2.0);\n\t\n\t\n\t// Ground\n\tp -= motion;\n\tfUnion(d, m, pPlane(p, vec3(0,0,1), 20.0), 0.0);\n\t\n\treturn d;\n}\n\n\nvec3 normal(vec3 p)\n{\n\tconst float eps = 0.01;\n\tfloat m = 0.0;\n    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z), m) - distf(vec3(p.x+eps,p.y,p.z), m)),\n                   (distf(vec3(p.x,p.y-eps,p.z), m) - distf(vec3(p.x,p.y+eps,p.z), m)),\n                   (distf(vec3(p.x,p.y,p.z-eps), m) - distf(vec3(p.x,p.y,p.z+eps), m))\n\t\t\t\t );\n    return normalize(n);\n}\n\nvec4 raymarch(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\tfloat material = 0.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos, material);\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += distEval;\n\t}\n\t\n\tif (dist >= maxDist) material = 0.0;\n\t\n\treturn vec4(dist, material, 0, 0);\n}\n\nfloat shadow(vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++) {\n\t\tfloat m = 0.0;\n        float h = distf(from + increment * t, m);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, SHADOW_SMOOTHNESS * h / t);\n        t += SHADOW_STEP;\n    }\n    return res;\n}\n\n\nfloat time;\nvec4 getPixel(vec2 p, vec3 from, vec3 increment, vec3 light)\n{\n\tvec4 c = raymarch(from, increment);\n\tvec3 hitPos = from + increment * c.x;\n\tvec3 tex = texture(iChannel0, hitPos.xy * 0.01).xyz;\n\tvec3 normalDir = normalize(normal(hitPos) + tex * 0.005);\n\tfloat shade = shadow(hitPos, vec3(0,0,1)) * 0.5 + 0.5;\n\t\n\tfloat diffuse = max(0.0, dot(normalDir, -light)) * 0.7 + 0.3;\n\tfloat specular = 0.0;\t\n\tif (dot(normalDir, -light) > 0.0) {\n\t\tspecular = pow(max(0.0, dot(reflect(-light, normalDir), normalize(from - hitPos))), 5.0);\n\t}\n\t\n\tvec4 col;\n\tvec3 reflectDir = reflect(increment, normalDir);\n\tvec4 reflection = texture(iChannel1, normalize((reflectDir).yzx));\n\t\n\tif (c.y == 1.0)\n\t{\n\t\tcol = mix(reflection, mix(vec4(1,1,1,1) * diffuse, vec4(1,1,1,1), specular), 0.25);\n\t}\n\telse if (c.y == 2.0)\n\t\tcol = mix(reflection,\n\t\t\t\t  mix(mix(vec4(0.9,0.3,0.1,1), vec4(1,0.4,0.2,1), tex.x) * diffuse,\n\t\t\t\t  vec4(0.9,0.3,0.1,1) * 1.2, specular * 20.0), 0.75);\n\telse\n\t\tcol = texture(iChannel1, normalize(hitPos.yzx)) * shade;\n\t\t\t\t\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// pixel position\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= -iResolution.x/iResolution.y;\n\t\t\t  \n\t// mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif (iMouse.x == 0.0 && iMouse.y == 0.0) {\n\t\tm = vec2(time * 0.06 + 1.67, 0.78);\t\n\t}\n\t\n\tm = vec2(iTime * 0.12, 0.25 + cos(iTime * 0.6) * 0.1);\n\t\n\tm = -1.0 + 2.0 * m;\n\tm *= vec2(4.0,-1.4);\n\n\t// camera position\n\tfloat dist = 60.0;\n\tvec3 ta = vec3(5,0,-5);\n\tvec3 ro = vec3(5,0,-5) + \n\t\tvec3(cos(m.x) * cos(m.y) * dist, sin(m.x) * cos(m.y) * dist, sin(m.y) * dist);\n\t// camera direction\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3(0,0,1);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t// calculate color\n\tvec4 col = getPixel(p, ro, rd, normalize(ro - rd));\n    col = pow(col, vec4(1.0 / 2.2));\n    col = col*1.4-0.4;\n\tfragColor = col;\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}