{
    "Shader": {
        "info": {
            "date": "1494572427",
            "description": "Anyone know of a resource or algorithm to UV parameterize a quadric surface so I can texture/displacement map it better?\nFunction at line 81: vec2 map(vec3 location, quadric q)",
            "flags": 0,
            "hasliked": 0,
            "id": "lsXfRr",
            "likes": 2,
            "name": "Quadratic map function",
            "published": 3,
            "tags": [
                "ray",
                "displacement",
                "quadric",
                "raytrace",
                "projection",
                "function",
                "trace"
            ],
            "usePreview": 0,
            "username": "KylBlz",
            "viewed": 561
        },
        "renderpass": [
            {
                "code": "#define GAMMA\t\t.5\n#define EXPOSURE\t1.\n\n//some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define minT(a) (a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x\n#define tex(a,b) textureLod(a,b,0.)\n#define texComp(a,b,c) vec3max((tex(a, b).rgb * c))\n\n//Absorb, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, Refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 a, e; vec2 s, u; float r, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, distance material\nstruct hit { vec3 l, n; float d; mat m; };\n//Origin, Direction, Color, current material\nstruct ray { vec3 o, d, c; mat m; };\n//location, coefficients c.xyz*L^2=-c.w, orientation, Material, id\nstruct qdr { vec3 l; vec4 c; mat3 o; mat m; int d; };\n\nconst float\teps = .0001, ieps = .9999,\n\t\t\tzfar = 100., sml = .001, isml = .999,\n\t\t\tpi_rcp = .3183098, pi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732051;\n\nconst mat nullMat = mat(v30, v30, v20, v20, 0., 0., 0);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, zfar, nullMat);\nconst vec2 nullT = vec2(zfar, 0.);\n\n\n////////////////////// Materials //////////////////////\nconst mat\n//conductor\n\t_air = mat(vec3(.99), vec3(.99), vec2(.01), vec2(.1), 1.0003, 0., 0),\n//dynamic materials\n  \t_mqdr = mat(v30, v30, v20, v20, -1., 0., 40),\n\t_dbg = mat(v30, v30, v20, v20, -1., 0., 99);\n\n\n////////////////////// Primitives //////////////////////\nqdr qdr0 = qdr(v30, vec4(eps,1.,1., -1.), mat3(1.), _mqdr, 30),\n    qdr1 = qdr(v30, vec4(1.,eps,1., -1.), mat3(1.), _mqdr, 31),\n    qdr2 = qdr(v30, vec4(1.,1.,eps, -1.), mat3(1.), _mqdr, 32);\n\n\n////////////////////// some tools //////////////////////\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n\tfloat a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n}\nvec3 norm3(sampler2D iChannel, in vec3 comp, in vec3 px, in vec2 uv) {\n\tfloat s01 = texComp(iChannel, uv + px.xy, comp), s21 = texComp(iChannel, uv + px.zy, comp),\n\t\ts10 = texComp(iChannel, uv + px.yx, comp), s12 = texComp(iChannel, uv + px.yz, comp);\n\tvec3 va = normalize(vec3(px.xy*4., s21 - s01)),\n\t\tvb = normalize(vec3(px.yx*4., s12 - s10));\n\treturn cross(va, vb).xzy;\n}\n\n\n////////////////////// Quadric functions //////////////////////\nfloat sd(in vec3 l, in qdr q) {\n    //this isnt actually the distance\n    return length(sqrt(q.c.xyz) * (l - q.l)) - sqrt(-q.c.w);\n}\nvec2 map(in vec3 l, in qdr q) {\n\t//https://en.wikipedia.org/wiki/Quadric#Projective_geometry ???\n    return (l.xz - l.y) - (q.l.xz - q.l.y) ;\n}\nvec3 nrm(in vec3 l, in qdr q) {\n    return normalize(q.c.xyz*q.c.xyz * (l - q.l));\n}\nseg rayseg(in ray r, in qdr q) {\n\tvec3 o = r.o - q.l;\n    float a = dot(q.c.xyz, r.d * r.d),\n    \t  b = dot(q.c.xyz * 2., o * r.d),\n    \t  c = dot(q.c.xyz, o * o) + q.c.w;\n    if (a != 0.) {\n        float h = b * b - 4. * a * c;\n        if (h < 0.) return nullSeg;\n        h = sqrt(h);\n        return seg(vec2(-b-h, -b+h) * (.5 / a), ivec2(q.d, -q.d));\n    }\n    return seg(vec2(-c / b), ivec2(q.d));\n}\n\n\n////////////////////// Trace functions //////////////////////\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\nvoid lt(inout hit o, in hit h) {\n\tif (h.d < o.d) o = h;\n}\n\n#define _trc(r, j) seg s = rayseg(r, j); float d = minT(s.t); vec3 l = r.o + r.d * d; return hit(l, nrm(l, j), d, j.m)\nhit trace(in ray r, in qdr o) { _trc(r, o); }\n\n#define _trcPOM(r, j) hit h = trace(r, o); if (h.d >= zfar) return h; sa += h.d*.01; vec3 l = v30; vec2 uvw = v20; float depth = 0., height = 0., ld = 0., mar = 0., p = heightScale * sa / -dot(r.d, h.n); p += ms * sign(p); for (int i = 0; i < 32; i++) { mar += p; l = h.l + r.d*mar; uvw = map(l, o); depth = -sd(l, o); height = heightScale - heightScale * texComp(heightMap, fract(uvw*scale), comp); if (depth > height || depth < 0.) break; ld = height - depth; } if (depth < height || depth < 0.) return nullHit; float cd = depth - height, lerp = 1. - clamp(ld / (ld + cd), 0., 1.); mar -= p*lerp; l = h.l + r.d*mar; h.l = l; h.d += mar; vec3 px = 1.0001 / iResolution.yyy * vec3(-1., 0., 1.); uvw = map(l, o) \nhit tracePOM(in ray r, in qdr o, in sampler2D heightMap, in vec3 comp, in float scale, in float heightScale) {\n    float ms = .05, sa = .05;\n    _trcPOM(r, o);\n\tmat3 rot = mat3(v30, nrm(l, o), v30);\n    basis(rot[1], rot[0], rot[2]);\n\th.n = norm3(heightMap, comp, px, fract(uvw*scale)) * vec3(-1., 1., -1.) * inverse(rot);\n\treturn h;\n}\n\n\n////////////////////// Scene //////////////////////\nhit traceScene(in ray r) {\n\thit ret = nullHit;\n    // sort by number of pixels that will be seen to reduce work\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n\t\t\tlt(ret, tracePOM(r, qdr0, iChannel0, vec3(1.,0.,0.), .1, 1.));\n    \t\tqdr0.l.y -= 10.;\n            qdr0.c.x += eps;\n            \n            lt(ret, tracePOM(r, qdr1, iChannel0, vec3(1.,0.,0.), .1, 1.));            \n    \t\tqdr1.l.x -= 10.;\n            qdr1.c.y += eps;\n            \n            lt(ret, tracePOM(r, qdr2, iChannel0, vec3(1.,0.,0.), .1, 1.));\n    \t\tqdr2.l.y -= 10.;\n            qdr2.c.z += eps;\n        }\n        qdr0.l.y += 50.;\n        qdr0.c.x -= eps*5.;\n        qdr0.l.z -= 10.;\n        \n        qdr1.l.x += 50.;\n        qdr1.c.y -= eps*5.;\n        qdr1.l.z -= 10.;\n        \n        qdr2.l.y += 50.;\n        qdr2.c.z -= eps*5.;\n        qdr2.l.x -= 10.;\n    }\n    return ret;\n}\n\n\n////////////////////// Dynamic material implementation //////////////////////\nmat mqdr(in ray r, inout hit h) {\n    float lp = 1000./(1.+h.d*h.d);\n    return mat(\n\t\tv30,\n\t\tvec3(max(.05*lp, lp*-dot(h.n, r.d))) * tex(iChannel1, (h.l.xz-h.l.y)*.1).rgb,\n\t\tv20, v20,\n\t\t_mqdr.r, 0., _mqdr.d);\n}\nmat dbg(in ray r, inout hit h) {\n    return mat(\n\t\tv30,\n\t\tmax(v30, h.n),\n\t\tv20, v20,\n\t\t_dbg.r, 0., _dbg.d);\n}\n\n//updates dynamic materials (ghetto, find better solution)\nvoid updateMaterials(inout hit h, in ray r) {\n\tif (h.m.d < 40) return;\n\telse if (h.m.d == _mqdr.d) h.m = mqdr(r, h);\n\telse if (h.m.d == _dbg.d) h.m = dbg(r, h);\n}\n\n//here we go\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.y *= iResolution.y / iResolution.x;\n    \n\t//update camera\n    float sg = sin(iTime*.5), cg = cos(iTime*.4);\n\tvec3 l = vec3(41.*cg, 21.*(1.-cg*sg), 31.*sg);\n    mat3 b = mat3(v30, v30, normalize(vec3(-25.) - l));\n    basis(b[2], b[0], b[1]);\n    vec3 d = b * normalize(vec3(uv, 1.));\n    \n    //begin tracing\n\thit res;\n\tray r = ray(l, d, _air.a, _air);\n\t//trace scene\n\tres = traceScene(r);\n\t//update dynamic materials\n\tupdateMaterials(res, r);\n\t\n    //material color\n\tvec3 final = r.c * res.m.e;\n    //sky color and fog\n    final = mix(final, vec3(.3,.7,1.)+max(-.3, dot(d, vec3(0., -sc45, sc45))), res.d*res.d*.00008);\n    float eye = clamp(pow(dot(uv, uv), 2.), 0., 1.);\n    fragColor = vec4(pow(final*EXPOSURE, vec3(GAMMA+eye)), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}