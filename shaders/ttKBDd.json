{
    "Shader": {
        "info": {
            "date": "1615355207",
            "description": "FBM is fun",
            "flags": 0,
            "hasliked": 0,
            "id": "ttKBDd",
            "likes": 44,
            "name": "Planetary Soup",
            "published": 3,
            "tags": [
                "3d",
                "fbm",
                "sphere",
                "warp"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 866
        },
        "renderpass": [
            {
                "code": "// Cole Peterson\n\n\nvec4 sphere(vec3 ro, vec3 rd, vec3 cn, float r){\n    float b = 2.*dot(rd, ro - cn);\n    float c = dot(ro - cn, ro - cn) - (r*r);\n    float d = (b*b) - (4.*c);\n \t\n    if(d < 0.) \n        return vec4(0);\n    else{\n     \tfloat t = .5*(-b - sqrt(d));   \n        return vec4(ro+rd*t, t);\n    }\n}\n\nconst float rad = 2.;\nfloat camR = 4.14;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    float ux = uv.x;\n    uv *= rot(-iTime*.12 + 2.2);\n    \n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float ang = iTime*.12 + 7.;\n    \n    \n    if(iMouse.z > 0.){\n        camR -= m.y*6.;\n        ang += m.x;\n    }\n    \n    ro.x += camR*cos(ang);\n    ro.z += camR*sin(ang);\n    \n    rd.xz *= rot(ang + pi/2. + .04);\n    \n    \n    \n    vec3 ld = normalize(vec3(0.4, 0.3, -0.5));\n    \n    float ts = .5;\n    \n    vec3 pp = vec3(0);\n    vec3 n = vec3(0);\n    \n    vec3 cntr = vec3(0., 0., 0.);\n    vec4 p = sphere(ro, rd, cntr, rad);\n    \n    vec3 col = vec3(0);\n    \n    if(p.w > 0.){\n        pp = p.xyz;\n        n = pp - cntr;\n        n = normalize(n);\n        \n        vec2 cuv = abs(vec2(atan(n.z, n.x), acos(p.y / rad))); \n        cuv *= rot(-iTime*.05 * ts);\n        \n        float n1 = 2.*octnse(cuv, 10, -iTime*.08 * ts) - 1.;\n        float n2 = 2.*octnse((cuv+3.), 10, -iTime*.03 * ts) - 1.;\n    \n        vec2 os = vec2(n1, n2);\n    \n        float val = octnse((cuv + vec2(n1, n2)*3.6), 8, -iTime*.1 * ts);\n        \n        col += .35+.35*cos(vec3(1.4, .7, 0.9)*n1*10. + iTime*.35);\n        col += .48+.37*cos(vec3(2.2, .1, 0.3)*n2*20. + vec3(.7, 1.2, .7));\n        col += .48+.23*cos(vec3(1.4, .7, 0.9)*val*30. + vec3(.2, 0.8, 4.7)+ iTime*.25);\n        col*=.38;\n        \n        vec3 ref = reflect(n, rd);\n        float val2 = octnse((ref.xy + os*10. + val*5.), 8, -iTime*.1 * ts);\n        \n        col *= val2*3. * vec3(.9, .8, .8);\n        col *= max(dot(n, -rd), 0.0)*vec3(.9, .8, .7);\n    }\n    else{\n        col += .7*ss(.3, .01, simplex3d(rd*160.));\n        col += .15*texture(iChannel0, rd).yzx;\n    }\n    \n    col = col*col*1.7;\n    \n    \n    \n    col = 1.-exp(-col);\n    \n    f = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nconst float pi = 3.14159;\n\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat octnse(vec2 p, int oct, float t){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n        p.x += t;\n     \tn += perlin(p) * a *.5;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\n\n\n\n\n\n\n// 3D simplex noise stuff from: https://www.shadertoy.com/view/XsX3zB\nconst float F3 =  .3333333;\nconst float G3 =  .1666667;\nvec3 random3(vec3 c) {\n\tfloat j = 4096.*sin(dot(c,vec3(17., 59.4, 15.)));\n\tvec3 r;\n\tr.z = fract(512.*j);\n\tj *= .125;\n\tr.x = fract(512.*j);\n\tj *= .125;\n\tr.y = fract(512.*j);\n\treturn r-.5;\n}\n\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.), x - x.yzx);\n\t vec3 i1 = e*(1. - e.zxy);\n\t vec3 i2 = 1. - e.zxy*(1. - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.*G3;\n\t vec3 x3 = x - 1. + 3.*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(.6 - w, 0.);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n    \n     float nse = dot(d, vec4(52.));\n    \n     //return nse;\n\t return 1.-exp(-(nse+1.)*.5);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}