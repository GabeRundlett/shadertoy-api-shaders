{
    "Shader": {
        "info": {
            "date": "1726233754",
            "description": "Dividing crosses into pentagons, then rendering a Truchet pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "lXsczH",
            "likes": 40,
            "name": "Cross-Based Pentagon Truchet",
            "published": 3,
            "tags": [
                "2d",
                "truchet",
                "pattern",
                "cross",
                "pentagon",
                "faux"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 288
        },
        "renderpass": [
            {
                "code": "/*\n\n    Cross-Based Pentagon Grid\n    -------------------------\n    \n    A while back, I came across a few really cool looking Truchet tiling images\n    by Swedish generative artist, Roni Kaufman. As is often the case, I thought \n    it would be fun to reproduce one in pixelshader form, do I did, then forgot \n    about it, until now.\n    \n    I've affixed various Truchet patterns to quite a few tiling configurations,\n    but not this particular one. At the time, I was working on a cross-based \n    traversal, so quickly modified it to accommodate the tiling you see. I should\n    point out that the pentagon pattern is in a Cairo tiling arrangement (type 4,\n    non-adjacent right angles), but the method used to produce it is not the way \n    to approach generalized Cairo tiling. In fact, I could think of one way to \n    produce this specific pattern by using some simple edge trickery on strategic \n    squares... Either way, the process is pretty straight forward:    \n    \n    Lay down a square grid of crosses that are resized and rotated in such a way \n    as to leave room for another set of equal sized crosses -- It's pretty easy, \n    and the details are below. Create another grid half a diagonal cell away, then \n    fill it with the same cross configuration. Choose the closest cross, partition \n    it into four pentagons, and you're done with the grid setup. At that point, \n    you can do whatever you want, but these pentagons are filled with a blobby \n    Truchet pattern, which can be achieved with some very basic CSG operations.\n    \n    In regard to design, I've rendered this in a faux 3D layered style. It's hard \n    to beat the simplistic original pattern -- which I've provided a link to below,\n    but at least it's a little different. I used similar colors to pay homage to \n    the original. I'll probably put together a proper 3D version at some stage.\n    \n    \n    \n    // Based on the following:\n    \n    // Cairo Pentagonal Tiling - Roni Kaufman \n    https://x.com/KaufmanRoni/status/1475457931806228485/photo/4\n    \n\n*/\n\n// Display the reverse Truchet pattern.\n//#define REVERSE_PATTERN\n\n// Show the grid that contains the crosses. The pentagons are\n// obviously contained within those.\n//#define SHOW_GRID\n\n// Show vertices, or not.\n//#define SHOW_VERTICES\n\n// Directional derivative based bump mapping.\n//#define BUMP\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n    b -= a; \n    return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n/*\n// IQ's signed box formula.\nfloat sBox(in vec2 p, in vec2 b){\n\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\n// Cross bound: We don't need a proper distance field to check\n// boundary lines, so we should save ourselves some extra calculations.\n// It was nice to have IQ's proper distance field cross function to \n// refer to when checking the workings. You can find it, here: \n// iquilezles.org/articles/distfunctions2d\n// \n// \"b.x\" represents the height and width of the entire cross, and\n// \"b.y\" the cross thickness.\nfloat bndCross(in vec2 p, in vec2 b){\n     \n    // There's probably a more succinct and faster way to write\n    // this, but it will do.\n    p = abs(p);\n    p = p.x<p.y ? p - b.yx : p - b;\n    return max(p.x, p.y);\n}\n\n// Global scale.\nvec2 gSc = vec2(1)/2.5;\n\n\nvec2 gP; // Global local coordinates.\nvec2[12] gCList; // Cross vertex list.\nvec2[5] gPList;  // Pentagon vertex list.\n\nvec2 gID; // Global square ID.\n\n// The cross-based pentagon pattern.\nvec4 distField(vec2 p){\n    \n    \n    // Overall coordinates and scale.\n    vec2 oP = p;\n    vec2 sc = gSc;\n    \n    // Box vertex and mid-edge IDs. Each are handy to have when working with squares.\n    mat4x2 vID = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5));\n    mat4x2 eID = mat4x2(vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n    \n    \n    // The cross has thickness one third of the height, which is evident from\n    // the imagery. If you turn on the grid settings, you'll see that a one to\n    // three ratio perpendicular triangle is involved, etc.\n    // Cross rotation angle.\n    float a = atan(1., 3.);\n    // Cross height: This follows from the above. Feel free to get out a pen and\n    // paper, or you could take a lazy coder's word for it. :D\n    float ht = cos(a); // sqrt(9./10.);\n    // The width needs to be one third of the height in order for two equal size\n    // crosses to tile the plane.\n    vec2 si = sc*vec2(ht, ht/3.)/2.;\n    \n    // Cross ID. Only two crosses are needed to tile the plane.\n    int crossID = 0;\n    // Each cross can be subdivided into four pentagons.\n    int pentID = 0;\n    \n    \n    // Square grid setup. Cell ID and local coordinates.\n    vec2 q = p;\n    vec2 iq = floor(q/sc);\n    q -= (iq + .5)*sc;\n    \n    // More debugging.\n    //float sq = sBox(q, sc/2.);\n    \n    // Copying and rotating local coordinates.\n    q = rot2(a)*q;    \n    gP = q;\n    \n    // The first cross, distance field value and ID.\n    float d0 = bndCross(q, si);\n    float d = d0;\n    vec2 id = iq;\n    \n    // Saving the original box ID... Not sure what this is for. Probably debugging.\n    gID = iq;\n    \n    // Next cross.\n    q = oP - vID[2]*sc;\n    iq = floor(q/sc);\n    q -= (iq + .5)*sc;\n \n    q = rot2(a)*q;\n    float d1 = bndCross(q, si);\n        \n    if(d1<d){\n       d = d1;\n       id = iq + .5;\n       gP = q;\n       crossID = 1;\n    }\n    \n\n    // Calculating the cross vertices: Not that it matters here, but if you\n    // were doing something inside a raymarching loop, you'd take all this stuff\n    // outside of this function... and condense it down.\n    //\n    // Four inner vertices.\n    mat4x2 vIn, vOutA, vOutB;\n    \n    // Precalculating the inner vertices.\n    for(int i = 0; i<4; i++){\n        // Inner vertices.\n        vIn[i] = vID[i]*ht/3.*sc.x; // \"ht/3\" is the cross width.\n    }\n    \n    for(int i = 0; i<4; i++){\n        // Outer vertices clockwise (two each).\n        vOutA[i] = vIn[i] + eID[i]*2.*ht/3.*sc.x; // Inner plus cross-width.\n        vOutB[i] = vIn[(i + 1)%4] + eID[i]*2.*ht/3.*sc.x; // Next inner plus cross-width.\n        \n        // Cross list in clockwise order.\n        gCList[3*i] = vIn[i];\n        gCList[3*i + 1] = vOutA[i];\n        gCList[3*i + 2] = vOutB[i];\n         \n    }\n    \n    \n    // Splitting the crosses into four pentagons.\n    float oD = d;\n    vec2 oID = id;\n    \n    // Two diagonal lines across the center to partition the cross\n    // into pentagons.\n    float ln0 = -distLineS(gP, vec2(0), vID[0]);\n    float ln1 = distLineS(gP, vec2(0), vID[1]);\n    \n    for(int i = 0; i<4; i++){\n        // Easier logic, but more line calls.\n        //float ln0 = distLineS(gP, vec2(0), vID[i]);\n        //float ln1 = distLineS(gP, vec2(0), vID[(i + 1)%4]);\n        //float pent = max(d, max(ln0, -ln1));\n        \n        // Use the lines above to subdivide the cross into pentagons,\n        vec2 dir = sign(vID[i]);\n        // Pentagon on one side of the lines.\n        float pent = max(d, max(dir.x*ln0, dir.y*ln1));\n        // The remainder of the partitioned cross on the other.\n        d = max(d, -pent);\n        \n        // Update the minimum pentagon distance, if necessary.\n        if(pent<d){\n           d = pent; // Pentagon distance.\n           id = oID + eID[i]/2.; // Pentagon ID.\n           pentID = i; // Pentagon number.\n        }\n  \n    }\n    \n    // Pentagon vertex list. Not really used here, but handy to have.\n    int n = 3*pentID;\n    gPList[0] = gCList[n];\n    gPList[1] = gCList[n + 1];\n    gPList[2] = gCList[n + 2];\n    gPList[3] = gCList[(n + 3)%12];\n    gPList[4] = vec2(0);\n    \n    // Center point.\n    //vec2 cntr = mix(gPList[0], gPList[2], .5);\n    //d = max(d, -(length(gP - cntr) - .015));\n    \n    \n    /*\n    #if 1\n    \n    vec2[12] tmp = gCList;\n    \n    // Line up the vertices.\n    for(int i = 0; i<12; i++){\n    \n        int j = i;\n        if(crossID==0){\n        \n           // Line up alternative checkers.\n           if(mod(oID.x + oID.y, 2.)==0.) j = (i + 6)%12;\n           \n        }\n        else{\n           // Line up alternative checkers.\n           if(mod(oID.x + oID.y, 2.)==0.) j = (i + 6)%12;\n           \n           // Reverse the vertices on the second lot of crosses\n           // and advance by one... Trial and error.\n           j = (13 - j)%12;\n        }\n        \n        gCList[i] = tmp[j];\n        \n    }\n    \n    #endif\n    */\n    \n    // Debugging.\n    //d += .01*sc.x;\n    //d = abs(d + .035*sc.x) - sc.x*.035;\n    //d = max(d, sq);\n    \n    // Distance, cross and pentagon ID, and cell ID.\n    return vec4(d, crossID*4 + pentID, id);\n}\n\n\n// The blobby Truchet. Written in a few minutes, but it seems to work.\n// A lot of this is common sense... to anyone with a basic knowledge of CSG.\nfloat getTruchet(vec2 p, vec4 d4){\n\n   \n    // Truchet scale.\n    vec2 sc = gSc;\n    \n    // Polygon ID.\n    vec2 id = d4.zw;\n    \n    // Pentagon vertex list: gPList.\n\n    // Cross ID, and pentagon ID.\n    //int crossID = int(d4.y)/4;\n    int pentID = int(d4.y)%4;\n    \n    // Two random numbers.\n    float rnd = hash21(id + .01);\n    float rnd2 = hash21(id + .02);\n    \n    \n    // Square side length and pointed tip side length.\n    float sL = length(gPList[0] - gPList[1]);\n    float sL45 = length(gPList[0] - gPList[4]);\n\n    // Line width and... dot width... I'm not sure why\n    // I named it that, but it's for the dot at the pointed tip.\n    float lw = sc.x/18.; // Line width.\n    float dw = sL45 - (sL/2. - lw); // The dot width is dependent on the line width.\n    \n    // The distanc field.\n    float d = 1e5;\n    \n    // There are three kinds of tiles here, and each have an equal chance of appearing\n    // in the pattern. There are other combinations, but these three seem to work\n    // best together.\n    if(rnd2<1./3.){\n    \n        // Tile one: Pointed tip dot, arc and mid edge dot.\n    \n        // Point vertex.\n        d = length(gP - gPList[4]) - dw;\n        \n        if(rnd<.5){\n            if(pentID==0 || pentID==2) gP.y = -gP.y;\n            else gP.x = -gP.x;\n        }\n        // Mid edge vertex;\n        d = min(d, length(gP - mix(gPList[2], gPList[3], .5)) - lw);\n        \n        // Arc.\n        float arc = length(gP - gPList[1]) - sL/2.;\n        arc = abs(arc) - lw;\n        d = min(d, arc);\n    \n    }\n    else if(rnd2<2./3.){\n    \n        // Tile 2: The blobby tri-pronged line and the pointed dot tip.\n    \n        // Point vertex.\n        d = length(gP - gPList[4]) - dw;\n        \n        vec2 e0 = mix(gPList[0], gPList[1], .5);\n        vec2 e2 = mix(gPList[2], gPList[3], .5);\n        // Half edge line.\n        float ln = -distLineS(gP, e0, e2) - lw;\n        // Cut out the end corners.\n        ln = max(ln, -(length(gP - gPList[1]) - (sL/2. - lw)));\n        ln = max(ln, -(length(gP - gPList[2]) - (sL/2. - lw)));\n        \n        d = min(d, ln);\n    \n    }\n    else {\n    \n        // Tile 3: The four pronged blobby cross.\n    \n        // Four corners cut out.\n        d = -1e5;\n        d = max(d, -(length(gP - gPList[1]) - (sL/2. - lw)));\n        d = max(d, -(length(gP - gPList[2]) - (sL/2. - lw)));\n        \n        d = max(d, -(length(gP - gPList[0]) - (sL/2. - lw)));\n        d = max(d, -(length(gP - gPList[3]) - (sL/2. - lw)));\n    \n    }\n    \n\n    // Interesting, but not for this pattern.\n    //d = abs(d + .0425*sc.x) - sc.x*.0425;\n     \n    // I think I like the reverse pattern more, but I thought I'd\n    // default to the basics.\n    #ifdef REVERSE_PATTERN\n    d = -d;\n    #endif\n  \n    // Return the Truchet distance.\n    return d;\n\n\n}\n\n// The square grid.\nfloat gridField(vec2 p){\n    \n    // Scale, cell ID and local coordinates.\n    vec2 sc = gSc;\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n    // Boundary.\n    p = abs(p) - .5*sc;\n    return abs(max(p.x, p.y)) - .005*sc.x;\n}\n\n// A very simple random line routine. It was made up on the\n// spot, so there would certainly be better ways to do it.\nfloat randLines(vec2 p){\n    \n    // Scaling.\n    float sc = 32./gSc.x;\n    p *= sc;\n    \n    // Offset the rows for a more random look.\n    p.x += hash21(vec2(floor(p.y), 7) + .2)*sc;\n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Distance field value and random cell number.\n    float d;\n    float rnd = hash21(ip + .34);\n    \n    // Randomly, but not allowing for single dots.\n    if(rnd<.333 && mod(ip.x, 2.)==0.){\n    \n       // Dots on either side of the cell wall mid-points, to create a space.\n       d = min(length(p - vec2(-.5, 0)), length(p - vec2(.5, 0)));\n        \n    }\n    else {\n        // Otherwise, just render a line that extends beyond the cell wall\n        // mid-points.\n        d =  abs(distLineS(p, vec2(-1, 0), vec2(1, 0)));\n    }\n    \n    // Applying some width.\n    d -= 1./6.;\n    \n    // Scaling down the distance value to match scaling up\n    // the coordinates.\n    return d/sc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Stretched screen coordinates.\n    vec2 uv2 = fragCoord/iResolution.xy - .5;\n    \n    // Emulating a bit of camera tilting.\n    uv.xy *= (.98 + .04/(uv.y + 1.5));\n    \n    // Add a bit of faux screen curvature.\n    uv *= .95 + dot(uv2, uv2)*.1;\n    \n      \n    // Scaling and translation.\n    float gSc = 1.;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-1, -.5)*iTime/12.;\n    \n    \n    // Making a copy of the original coordinates.\n    vec2 oP = p;\n\n    \n    // Faux extrusion.\n    float zDist = length(vec3(0, 0, -1) - vec3(uv, 0.));\n    vec4 d4Sd = distField(p - vec2(.005) + (uv)/(.5 + zDist)*.04);\n    float trSd = getTruchet(gP, d4Sd);\n    \n    // Regular pattern vertices appear on the extruded layer.\n    #ifdef SHOW_VERTICES\n    #ifndef REVERSE_PATTERN\n    float vert = 1e5;\n    for(int i = 0; i<4; i++){\n         vert = min(vert, length(gP - gPList[i]) - .017);\n    }\n    #endif\n    #endif\n    \n    // Ground highlights.\n    vec4 d4Hi2 = distField(p - vec2(.005) + (uv)/(.5 + zDist)*.04 - vec2(-.01, -.02)*.7);\n    \n    // Truchet hightlights.\n    vec4 d4Hi = distField(p - vec2(-.01, -.02)*.7);\n    float trHi = getTruchet(gP, d4Hi);\n    // Truchet shadows.\n    vec4 d4Sh = distField(p - vec2(-.01, -.02));\n    float trSh = getTruchet(gP, d4Sh);\n    \n    // The Truchet face pattern.\n    vec4 d4 = distField(p);\n    float tr = getTruchet(gP, d4);\n    \n    // Reverse pattern vertices appear on the floor layer.\n    #ifdef SHOW_VERTICES\n    #ifdef REVERSE_PATTERN\n    float vert = 1e5;\n    for(int i = 0; i<4; i++){\n         vert = min(vert, length(gP - gPList[i]) - .017);\n    }\n    #endif\n    #endif\n    \n    // Smoothing function.\n    float sf = 1./iResolution.y*gSc;\n    \n    // Random reddish background color.\n    float rnd = hash21(d4.zw + .11);\n    vec3 oCol = .5 + .45*cos(6.2831*rnd/4. + vec3(0, 1, 2)*1.35);\n\n   \n    // Cross and pentagon IDs.\n    int crossID = int(d4.y)/4;\n    int pentID = int(d4.y)%4;\n    \n    // Alternate crosses. \n    //if(croosID == 0) oCol = oCol.zyx;\n    \n    //oCol = vec3(0, .487, .493); // Green.\n    //oCol = vec3(1, .1, .175);   // Red.\n     \n    // Transition variable.\n    float tran = smoothstep(-.1, .1, sin(iTime/3. + .1));\n    // Time based color mixing... Not very elegant, but it'll do.\n    oCol = mix(mix(vec3(.05, .487, .493), oCol.yxz/(.75 + oCol.yxz), .3), \n           mix(vec3(1, .1, .2), oCol, .2), tran);\n    \n    /*\n    // Debug: Displaying the four pentagon colors. \n    // Yellow, Red, Green, Blue.\n    mat4x3 sCol = mat4x3(vec3(1, .8, .2), vec3(1, .2, .2), \n                         vec3(.2, .8, .2), vec3(.2, .6, 1));\n    oCol = sCol[pentID]*.8;\n    */\n    \n    // Distance based color mixing.\n    oCol = mix(oCol, mix(vec3(.2, .4, .9), oCol.zyx, tran), \n               smoothstep(.3,  .7, length(uv2)));\n    \n    #ifdef BUMP\n    // Directional derivative bump mapping.\n    float bmpFloor = max(d4Hi.x - d4.x, 0.)/.02;\n    oCol = oCol*(.75 + bmpFloor*.7);\n    #endif\n    \n    // Adding a random line pattern to the background.\n    float pat = randLines(rot2(3.14159/4.)*p);\n    oCol = mix(oCol*1.2, oCol*.8, (1. - smoothstep(0., sf, pat)));\n\n    // Debug: Display the cross pattern.\n    //if(crossID == 0) oCol = oCol.zxy/(1.5 + oCol.zxy)*2.;\n    \n    // Initiating the overal color, edge with and line width.\n    vec3 col = vec3(.15);\n    float ew = .006;\n    float lnW = .01;\n\n    // Rendering the background.\n    //col = mix(col, col*.5, (1. - smoothstep(0., sf, d4Sh.x)));\n    col = vec3(0);//mix(col, vec3(0), (1. - smoothstep(0., sf, d4Sd.x)));\n    col = mix(col, oCol + .25, (1. - smoothstep(0., sf, d4Sd.x + ew)));\n    \n    col = mix(col, oCol, (1. - smoothstep(0., sf, max(d4Sd.x + ew, d4Hi2.x + ew*1.5))));\n\n\n    /*\n    vec2 cntr = mix(gPList[0], gPList[2], .5);\n    float cVert = length(gP - cntr) - .0175;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, cVert)));\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, cVert + ew)));\n    */\n    \n     \n    // Interesting, but a bit much.\n    //float lw = gSc/64.;\n    //tr = abs(tr + lw) - lw;\n    \n    // Debug, to show the tiles better. Omitting the Truchet pattern\n    // altogether would also work.\n    //tr = max(tr, -(abs(d4.x) + ew/2.));\n    \n    // Base Truchet color.\n    vec3 tCol = vec3(1, .7, .15); //vec3(.985, .685, .114)\n    //vec3 tCol = vec3(.75);\n    // More transparency.\n    //tCol = mix(tCol, col*1.35, .85);\n    \n    // Length based Truchet color mixing.\n    tCol = mix(tCol, mix(tCol.zyx, tCol.xzy, tran), smoothstep(.3,  .7, length(uv2)));\n\n    // Adding a tiny bit of transparency.\n    tCol = tCol*col*.3 + tCol*.8;//\n    \n    #ifdef BUMP\n    // Directional derivative bump mapping.\n    float bmpTruch = max(trHi - tr, 0.)/.02;\n    tCol = tCol*(.75 + bmpTruch*.7);\n    #endif\n    \n    // Render the Truchet side layers to give the appearance of extrusion.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, trSd - ew/2.));\n    col = mix(col, mix(tCol, oCol, .5)*.7, 1. - smoothstep(0., sf, trSd + ew*1.5 - ew/2.));\n\n    // Truchet shadow, followed by the Truchet face layer.\n    float sdF = iResolution.y/450.; // Shadow distance factor.\n    col = mix(col, col*.5, 1. - smoothstep(0., sf*4.*sdF, trSh));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, tr));\n    col = mix(col, tCol + .5, 1. - smoothstep(0., sf, tr + ew*1.5));\n\n    // Adding in the highlights.\n    col = mix(col, tCol, 1. - smoothstep(0., sf, max(tr + ew*1.5, trHi + ew*1.5)));\n    \n    /*\n    // Debugging cross vertices.\n    for(int i = 0; i<12; i++){\n        \n        float vert = length(gP - gCList[i]) - .017;\n \n        vec3 vCol = mix(col, vec3(1), .5);\n        //vec3 vCol = .5 + .45*cos(6.2831*float(i)/12. + vec3(0, 1, 2));//vec3(i)/12.;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert)));\n        col = mix(col, vCol, (1. - smoothstep(0., sf, vert + ew*1.25)));\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert + .005 + ew*1.25)));\n    \n    }\n    */\n    \n    \n    // Vertex points.\n    #ifdef SHOW_VERTICES\n    vec3 vCol = mix(col, vec3(1), .5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert));\n    col = mix(col, vCol, 1. - smoothstep(0., sf, vert + ew*1.25));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert + .005 + ew*1.25));\n    #endif\n    \n    // The square grid.\n    #ifdef SHOW_GRID\n    float grid = gridField(p);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*2.*sdF, grid - ew/1.5));\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, grid));\n    #endif\n    \n    // Adding a random line pattern to the truchet face.\n    col = mix(col*1.15, col*.85, 1. - smoothstep(0., sf, max(pat, tr)));\n \n  \n    // Rough gamma correction and screen presentation.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}