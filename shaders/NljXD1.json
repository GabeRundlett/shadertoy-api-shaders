{
    "Shader": {
        "info": {
            "date": "1627588245",
            "description": "drawing 2d 29-Jul-2021\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "NljXD1",
            "likes": 7,
            "name": "drawing 2d 29-Jul-2021",
            "published": 3,
            "tags": [
                "drawing2d29jul2021"
            ],
            "usePreview": 0,
            "username": "jorge2017a1",
            "viewed": 252
        },
        "renderpass": [
            {
                "code": "/// IQ funciones....\n//https://iquilezles.org/articles/distfunctions2d\n/// por jorge2017a1...drawing 2d 29-Jul-2021\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n#define TAU 6.28318530718 // 2 * pi\n#define PHI 1.57079632679 // pi / 2\n#define PI 3.1415926   ///3.14159265358979323846264\n\n\n\nvec2 rotatevec2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));\n  \n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  \n  return colOut;\n}\n\n\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 colBlanco= vec3(1.0);\nconst vec3 colRojo= vec3(1.0,0.0,0.0);\nconst vec3 colRojo2= vec3(8.0,0.0,0.0);\n\nconst vec3 col0= vec3(0.18,0.05,0.00);\nconst vec3 col1= vec3(0.98,0.47,0.63);\nconst vec3 col2= vec3(0.57,0.22,0.48);\nconst vec3 col3= vec3(0.64,0.11,0.13);\nconst vec3 col4= vec3(0.69,0.38,0.65);\nconst vec3 col5= vec3(0.11,0.28,0.56);\nconst vec3 col6= vec3(0.96,0.60,0.12);\nconst vec3 col7= vec3(0.87,0.66,0.56);\nconst vec3 col8= vec3(0.89,0.66,0.56);\n\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n///-----------------------------------------------------\n\n\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.35;\n    uv*=1.5;\n    \n    float sm=smoothstep(radians(-5.0), radians(5.0) ,(fract(iTime*0.5)));\n    //uv=rotatevec2(uv,sm+radians(300.0)+(iTime)*3.141516/360.0 );\n    uv=rotatevec2(uv,sm+radians(300.0));\n    \n   \n    vec3 col=NubeYrayo(uv, iTime);\n    \n    float sds1= sdStar(uv, 2.0, 8, 5.0); // m=[2,n]\n    col= DrawFigBorde(col5,col,sds1);\n    \n    float sdt1= sdTriangleIsosceles(uv-vec2(0.0,-1.35), vec2(1.5,0.7));\n    col= DrawFigBorde(col1,col,sdt1);\n    \n    \n    float sdE1= sdEllipse(uv, vec2(1.0,1.2) );\n    float sdE2= sdEllipse(uv, vec2(1.0,-1.5-uv.y)  );\n    sdE2=differenceSDF(sdE1,sdE2);\n    \n   col= DrawFigBorde(col2,col,sdE1);\n   col= DrawFigBorde(col0,col,sdE2);\n    \n    \n    vec2 uv2=rotatevec2(uv-vec2(0.0,-0.6),radians(90.00));\n    float sdv1= sdVesica(uv2, 0.65, 0.5);\n    col= DrawFigBorde(col3,col,sdv1);\n    \n    \n    uv.x=abs(uv.x)-0.5;\n    \n    float wi=0.5;\n    float he=0.4; \n    float sk=0.7+abs(sin(fract(iTime*0.5))); \n    float sdp1= sdParallelogram(uv,  wi,he,sk );\n    float sdc1= sdCircle(uv,0.35);\n    \n    \n    float sdc2= sdCircle(uv,0.2);\n    float sdc3= sdCircle(uv,0.1);\n    \n    float inters= intersectSDF(sdc1,sdp1);\n    col= DrawFigBorde(colBlanco,col, inters);\n     sdc2= intersectSDF(sdc2,sdp1);\n    col= DrawFigBorde(col0,col,sdc2);\n    col= DrawFigBorde(col3,col,sdc3);\n    \n   \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Stormy Night\n// By: Brandon Fogerty\n// bfogerty at gmail dot com \n// xdpixel.com\n\n\nfloat Hash( vec2 p)\n{\n     vec3 p2 = vec3(p.xy,1.0);\n    return fract(sin(dot(p2,vec3(37.1,61.7, 12.4)))*3758.5453123);\n}\n\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n     vec2 f = fract(p);\n     f *= f * (3.0-2.0*f);\n\n    return mix(mix(Hash(i + vec2(0.,0.)), Hash(i + vec2(1.,0.)),f.x),\n               mix(Hash(i + vec2(0.,1.)), Hash(i + vec2(1.,1.)),f.x),\n               f.y);\n}\n\nfloat fbm(vec2 p)\n{\n     float v = 0.0;\n     v += noise(p*1.0)*.5;\n     v += noise(p*2.)*.25;\n     v += noise(p*4.)*.125;\n     return v;\n}\n\nvec3 clouds( vec2 uv, vec2 dir, float time )\n{\n\tdir *= time;\n\tvec3 finalColor = fbm( (uv * 1.5) + dir ) * vec3( 1.0 );\t\n\t\n\treturn finalColor;\n}\n\nvec3 lightning( vec2 uv, float time )\n{\n\tfloat timeVal = time;\n\tvec3 finalColor = vec3( 0.0 );\n\tfor( int i=0; i < 3; ++i )\n\t{\n\t\tfloat indexAsFloat = float(i);\n\t\tfloat amp = 40.0 + (indexAsFloat*1.0);\n\t\tfloat period = 2.0 + (indexAsFloat+2.0);\n\t\t\n\t\tfloat thickness = mix( 0.1, 0.7, uv.y * 0.5 + 0.5 );\n\t\t\n\t\tfloat intensity = mix( 0.5, 1.5, noise(uv*10.0) );\n\t\tfloat t = abs( thickness / (sin(uv.x + fbm( uv + timeVal * period )) * amp) * intensity );\n\t\tfloat show = fract(abs(sin(timeVal))) >= 0.95 ? 1.0 : 0.0;\n\t\tshow *= step( abs(fbm( vec2( sin(time * 50.0), 0.0 ) )), 0.4);\n\t\t\n\t\t\n\t\tfinalColor +=  t * vec3( 0.3, 0.5, 2.0 ) * show;\n\t}\n\t\n\treturn finalColor;\n}\n\nvec3 NubeYrayo(vec2 uv, float time)\n{\n\n\tvec3 finalColor = vec3( 0.0 );\n\tfinalColor += sin( clouds( uv, vec2( 1.0, 0.1 ) , time));\n\t\n\tfloat xOffset = mix( 1.5, -1.5, fbm(vec2( fract(time), 0.00 ) ) );\n\tvec2 uvOffset = vec2( xOffset, 0.0 );\n\t\n\tvec2 lightningUV = uv + uvOffset;\n\t\n\tfloat theta = 3.14159 * 2.1;\n\tlightningUV.x = uv.x * cos(theta) - uv.y*sin(theta); \n\tlightningUV.y = uv.x * sin(theta) + uv.y*cos(theta); \n\t\n\t\n\tfinalColor += lightning( lightningUV + uvOffset ,time);\n    finalColor += lightning( lightningUV + vec2(-1.5,0.0) ,time*4.5)*vec3(1.0,0.2,0.2);\n\t\n\t//finalColor -= sin( clouds( uv, vec2( 2.0 ), time )) * 0.30;\n    return finalColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}