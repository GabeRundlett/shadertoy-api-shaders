{
    "Shader": {
        "info": {
            "date": "1569488230",
            "description": "A design inspired by scales patterns found on traditional japanese fabric and indian mandala art.\nIt also features motion blur. Best viewed in full screen.\nTry staring at it for a minute ;)",
            "flags": 64,
            "hasliked": 0,
            "id": "WdtGWf",
            "likes": 113,
            "name": "Seigaiha Mandala",
            "published": 3,
            "tags": [
                "motion",
                "hypnotic",
                "pattern",
                "japanese",
                "scales",
                "fabric"
            ],
            "usePreview": 0,
            "username": "PixelPhil",
            "viewed": 3787
        },
        "renderpass": [
            {
                "code": "//\n// Seigaiha Mandala by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define S(a,b,c) smoothstep(a,b,c)\n\n\n// blends a pre-multiplied src onto a dst color (without alpha)\nvec3 premulMix(vec4 src, vec3 dst)\n{\n    return dst.rgb * (1.0 - src.a) + src.rgb;\n}\n\n// blends a pre-multiplied src onto a dst color (with alpha)\nvec4 premulMix(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = premulMix(src, dst.rgb);\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);\n    return res;\n}\n\n// compute the round scale pattern and its mask\n// output rgb is premultiplied by alpha\nvec4 roundPattern(vec2 uv)\n{\n    float dist = length(uv);\n    \n    // Resolution dependant Anti-Aliasing for a prettier thumbnail\n    // Thanks Fabrice Neyret & dracusa for pointing this out.\n    float aa = 8. / iResolution.x;\n\n    // concentric circles are made by thresholding a triangle wave function\n    float triangle = abs(fract(dist * 11.0 + 0.3) - 0.5);\n    float circles = S(0.25 - aa * 10.0, 0.25 + aa * 10.0, triangle);\n\n    // a light gradient is applied to the rings\n    float grad = dist * 2.0;\n    vec3 col = mix(vec3(0.0, 0.5, 0.6),  vec3(0.0, 0.2, 0.5), grad * grad);\n    col = mix(col, vec3(1.0), circles);\n    \n    // border and center are red\n    vec3 borderColor = vec3(0.7, 0.2, 0.2);\n    col = mix(col, borderColor, S(0.44 - aa, 0.44 + aa, dist));\n    col = mix(col, borderColor, S(0.05 + aa, 0.05 - aa, dist));\n    \n    // computes the mask with a soft shadow\n    float mask = S(0.5, 0.49, dist);\n    float blur = 0.3;\n    float shadow = S(0.5 + blur, 0.5 - blur, dist);\n   \n    return vec4(col * mask, clamp(mask + shadow * 0.55, 0.0, 1.0)); \n}\n\n\n//computes the scales on a ring of a given radius with a given number of scales\nvec4 ring(vec2 uv, float angle, float angleOffet, float centerDist, float numcircles, float circlesRad)\n{\n    // polar space is cut in quadrants (one per scale)\n    float quadId = floor(angle * numcircles + angleOffet);\n    \n    // computes the angle of the center of the quadrant\n    float quadAngle = (quadId + 0.5 - angleOffet) * (6.283 / numcircles);\n    \n    // computes the center point of the quadrant on the circle\n    vec2 quadCenter = vec2(cos(quadAngle), sin(quadAngle)) * centerDist;\n    \n    // return to color of the scale in the quadrant\n    vec2 circleUv = (uv + quadCenter) / circlesRad;\n    return roundPattern(circleUv);\n}\n\n// computes a ring with two layers of overlapping patterns\nvec4 dblRing(vec2 uv, float angle, float centerDist, float numcircles, float circlesRad, float t)\n{\n    // Odd and even scales dance up and down\n    float s = sin(t * 3.0 + centerDist * 10.0) * 0.05;\n    float d1 = 1.05 + s;\n    float d2 = 1.05 - s;\n    \n    // the whole thing spins with a sine perturbation\n    float rot = t * centerDist * 0.4 + sin(t + centerDist * 5.0) * 0.2;\n    \n    // compute bith rings\n    vec4 ring1 = ring(uv, angle, 0.0 + rot, centerDist * d1, numcircles, circlesRad);\n    vec4 ring2 = ring(uv, angle, 0.5 + rot, centerDist * d2, numcircles, circlesRad);\n    \n    // blend the results\n    vec4 col = premulMix(ring1, ring2);\n    \n    // add a bit of distance shading for extra depth\n    col.rgb *= 1.0 - (centerDist * centerDist) * 0.4;\n    \n    return col;\n}\n\n// computes a double ring on a given radius with a number of scales to fill the circle evenly\nvec4 autoRing(vec2 uv, float angle, float centerDist, float t)\n{\n    float nbCircles = 1.0 + floor(centerDist * 23.0);\n    return dblRing(uv, angle, centerDist, nbCircles, 0.23, t);\n}\n\n// Computes the pixel color for the full image at a givent time\nvec3 fullImage(vec2 uv, float angle, float centerDist, float t)\n{\n    vec3 col;\n    \n    // the screen is cut in concentric rings\n    float space = 0.1;\n    \n    // determine in which ring the pixel is\n    float ringRad = floor(centerDist / space) * space;\n    \n\t// computes the scales in the previous, current and next ring\n\tvec4 ringCol1 = autoRing(uv, angle, ringRad - space, t);\n \tvec4 ringCol2 = autoRing(uv, angle, ringRad, t);\n    vec4 ringCol3 = autoRing(uv, angle, ringRad + space, t);\n    \n    // blends everything together except in the center\n    if (ringRad > 0.0)\n    {\n        col.rgb = ringCol3.rgb;\n        col.rgb = premulMix(ringCol2, col.rgb);\n        col.rgb = premulMix(ringCol1, col.rgb);\n    }\n\telse\n    {\n        col.rgb = ringCol2.rgb; \n    }\n\n    return col;\n}\n\n// A noise function that I tried to make as gaussian-looking as possible\nfloat noise21(vec2 uv)\n{\n    vec2 n = fract(uv* vec2(19.48, 139.9));\n    n += sin(dot(uv, uv + 30.7)) * 47.0;\n    return fract(n.x * n.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; \n    \n    uv *= 0.9;\n    \n    // Computes polar cordinates\n    float angle = atan(uv.y, uv.x) / 6.283 + 0.5;\n    float centerDist = length(uv);\n    \n    vec3 col = vec3(0.0);\n    \n\t// average 4 samples at slightly different times for motion blur\n    float noise = noise21(uv + iTime);\n    for (float i = 0.0; i < 4.0; i++)\n    {\n        col += fullImage(uv, angle, centerDist, iTime - ((i + noise) * 0.03));\n    }\n    col /= 4.0;\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 19731,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/alvydasm/the-heart-of-reiki-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}