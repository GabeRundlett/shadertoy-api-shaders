{
    "Shader": {
        "info": {
            "date": "1700677142",
            "description": "A 3D plot of complex numbers to test the ITP root solver. This solver takes the best parts of bisection & secant but makes something more.\nClick & Drag!\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "clKcWK",
            "likes": 41,
            "name": "Complex Plot 3D",
            "published": 3,
            "tags": [
                "projection",
                "solver",
                "iteration",
                "bisection",
                "project",
                "root",
                "bisect",
                "bracket",
                "iterate",
                "method",
                "finder",
                "truncation",
                "itp",
                "truncate"
            ],
            "usePreview": 0,
            "username": "domrally",
            "viewed": 435
        },
        "renderpass": [
            {
                "code": "/*\nby Dom Mandy in 2023\n*/\n\n\n/*\nLightness & Gamma\nhttps://www.shadertoy.com/view/DsyfDcx\n*/\nvec3 rgb(vec4 srgb) { return mix(srgb / 12.92, pow((srgb + .055) / 1.055, vec4(2.4)), step(.04045, srgb)).rgb; }\nvec4 gamma(vec3 rgb) { return vec4(pow(rgb, vec3(1) / 2.2), 1); }\nfloat lightness(vec3 rgb) { return pow(dot(rgb, vec3(.2126, .7152, .0722)), .59 * (1.48 + sqrt(.2))); }\n\n\n/*\nColor Palette\nhttps://www.shadertoy.com/view/mltyRN\n*/\nvec3 palette(float l, float c, float h) { return l + c * l * vec3(8, 3, 9) * cos(h - vec3(0, 2, 4)); }\n\n\n/*\nComplex Functions\n*/\nvec2 M(vec2 w, vec2 z) { return vec2(w.x * z.x - w.y * z.y, w.x * z.y + w.y * z.x); }\nvec2 D(vec2 w, vec2 z) { return vec2(dot(z, w), z.x * w.y - z.y * w.x) / dot(z, z); }\nvec2 F(vec2 z) { const vec2 v = vec2(1, 0); z = M(M(z, z), z); return D(z + v, z - v); }\n\n\n/*\nTerrain marching based on iq with adaptive error\n*/\nmat2x3 March(vec3 eye, vec3 ray) {\n    vec3 near, far;\n    for (float k, t = 6.; k++ < 89.; t *= 1.01, near = far) {\n        far = eye + ray * t;\n        vec2 f = F(far.xz);\n\n        // return when you have a positive and negative side of the hit\n        if (far.y * far.y < dot(f, f)) break;\n    }\n    return mat2x3(near, far);\n}\nvec3 Normal(vec3 p) {\n    const float e = 1e-5;\n    return normalize(vec3(\n        length(F(vec2(p.x - e, p.z))) - length(F(vec2(p.x + e, p.z))),\n        2. * e,\n        length(F(vec2(p.x, p.z - e))) - length(F(vec2(p.x, p.z + e)))\n    ));\n}\n\n\n/*\n1st root finder with superlinear convergence\nand minmax optimal worst case performance.\n*/\nvec3 Root(vec3 near, vec3 far, vec3 ray, vec3 eye) {\n    float k, \n          e = 1e-10, \n          p = 1. + ceil(log2(distance(near, far) / 2. / e)),\n          n = near.y - length(F(near.xz)),\n          f = far.y - length(F(far.xz));\n\n    for (; k < 9.; k++) {\n        // interpolate\n        vec3 bisect = (near + far) / 2.,\n             falsi = (n * far - f * near) / (n - f);\n\n        // truncate\n        float l = distance(near, far),\n              d = .1 * pow(l, 2.),\n              s = sign(distance(bisect, eye) - distance(falsi, eye));\n        vec3 trunk = d > distance(bisect, falsi)\n            ? bisect\n            : falsi + s * d * ray;\n\n        // project\n        float r = e * pow(2., p - k) - l / 2.;\n        vec3 project = r < distance(trunk, bisect)\n            ? bisect - s * r * ray\n            : trunk;\n        \n        // update\n        float update = project.y - length(F(project.xz));\n        if (update < 0.) {\n            far = project;\n            f = update;\n        } else if (update > 0.) {\n            near = project;\n            n = update;\n        } else {\n            return project;\n        }\n    }\n    \n    return (near + far) / 2.;\n}\n\n\nvoid mainImage(out vec4 pixel, vec2 uv) {\n    // coordinates\n    vec2 R = iResolution.xy;\n    uv = 4. * (uv + uv - R) / max(R.x, R.y);\n    uv += vec2(.6, 7.8);\n    vec3 eye = vec3(uv, -9),\n         ray = normalize(vec3(0, -1, 1)),\n         sun = normalize(vec3(2, 3, -1));\n    \n    // animation\n    float t = mix(iTime, iMouse.x / 200., max(0., sign(iMouse.z))),\n          r = atan(ray.z, ray.x) - t,\n          e = atan(eye.z, eye.x) - t,\n          l = atan(sun.z, sun.x) - t;\n    ray.xz = vec2(cos(r), sin(r));\n    eye.xz = vec2(cos(e), sin(e)) * length(eye.xz);\n    sun.xz = vec2(cos(l), sin(l)) * .7;\n\n    // ray casting\n    mat2x3 hit = March(eye, ray);\n    vec3 root = Root(hit[0], hit[1], ray, eye),\n         normal = Normal(root);\n\n    // lighting\n    vec2 result = F(root.xz);\n    vec3 g = pow(.5 + .5 * sin((9. * root)), vec3(.1));\n    float shine = lightness(rgb(texture(iChannel0, reflect(ray, normal)))),\n          glow = 2. * lightness(rgb(texture(iChannel1, refract(ray, normal, .67)))),\n          hue = 2. + atan(result.y, result.x),\n          diffuse = .1 * max(0., dot(sun, normal)),\n          specular = .3 * shine * max(0., dot(reflect(sun, normal), ray)),\n          grid = g.x * g.y * g.z;\n\n    vec3 color = diffuse + specular + palette(glow, .2, hue);\n\n    pixel = gamma(grid * color);\n}\n\n\n/*\nthanks to Real_NC for discussion pre listing\nhttps://www.shadertoy.com/user/Real_NC\n\nSEE ALSO\n\nby harry7557558 in 2021\nhttps://www.shadertoy.com/view/sljSzD\n\nby Ivo Oliveira & Ricardo Takahashi in 2020\nhttps://en.wikipedia.org/wiki/ITP_method#The_algorithm\n\nby djmkultra in 2015\nhttps://www.shadertoy.com/view/ltsXD7\n\nby Inigo Quilez in 2002\nhttps://iquilezles.org/articles/terrainmarching\n\nby Jahnke and Emde in 1909\nhttps://www.dbraulibrary.org.in/RareBooks/Tables%20of%20Function%20with%20formula%20and%20Curves.pdf\n\nby wolfram\nhttps://reference.wolfram.com/language/ref/ComplexPlot3D.html\n\nby maple\nhttps://www.maplesoft.com/support/help/maple/view.aspx?path=plots%2Fcomplexplot3d\n*/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}