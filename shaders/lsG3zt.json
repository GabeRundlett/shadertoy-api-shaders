{
    "Shader": {
        "info": {
            "date": "1455822402",
            "description": "Another experiment in distance function ray marching, based on Ruslan Shestopalyuk's \"Distance Functions Playground\" code.",
            "flags": 64,
            "hasliked": 0,
            "id": "lsG3zt",
            "likes": 7,
            "name": " Carousel",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "modeling"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 1322
        },
        "renderpass": [
            {
                "code": "/*\n\tCAROUSEL by wjbgrafx   2-18-16\n\t\n\t\"A new and rare invencon knowne by the name of the royalle carousell or \n\ttournament being framed and contrived with such engines as will not only \n\tafford great pleasure to us and our nobility in the sight thereof, but \n\tsufficient instruction to all such ingenious young gentlemen as desire to \n\tlearne the art of perfect horsemanshipp.\" \n\tFrom a letter of 1673\t\t\thttp://www.thesaurus.com/browse/carousel\n\t\n\tThis code is based mainly on\t\n\tDistance functions playground, by Ruslan Shestopalyuk, 2014/15\t\n\thttps://github.com/silverio/raymarching\n\thttps://www.shadertoy.com/view/MtXGDr\n\t\n\tAdded additional code for specular and reflection light components from\n\thttp://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\thttps://www.shadertoy.com/view/XlXGRM\n\t\n\tThe shadow() function was added from ChristmasTree.frag        \n\thttps://github.com/silverio/raymarching/blob/master/ChristmasTree.frag\n\t\n\tAdditional sources\n\t------------------\t\n\tUnsigned Triangle function by Inigo Quilez\t\n\thttps://iquilezles.org/articles/distfunctions\n\n\tSmooth Minimum blending function by Otavio Good\n\thttps://www.shadertoy.com/view/XtjXWD\n\n\tHG_SDF GLSL Library for building signed distance bounds by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\n    Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n    https://www.shadertoy.com/view/lll3z4\n\n\t\"Simple test/port of Mercury's SDF library to WebGL\"\n\thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\n\t--------------------------------\n\tEditing and modification by wjb. \n\t\n\tThe modeling code within the map() function is licensed under a Creative\n\tCommons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\t\n\tI can highly recommend the Raymarching Christmas Tree tutorial at the\n\taddress above. It gave me some insights into modeling with distance \n\tfunctions that I haven't seen elsewhere.\t\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n\n#define MTL_BACKGROUND          -1.0\n\n#define NORMAL_EPS              0.001\n\n#define NEAR_CLIP_PLANE         0.001\n#define FAR_CLIP_PLANE          110.0 \n#define MAX_RAYCAST_STEPS       100  \n#define STEP_DAMPING            0.98\n#define DIST_EPSILON            0.001\n\n#define MAX_SHADOW_DIST         100.0\n#define MAX_SHADOW_STEPS        30\n#define SHADOW_SOFTNESS\t\t\t16.0 // 2.0=very soft 128.0=very hard\n\n#define LIGHT_POSITION          vec3( 0.0, 12.0, 5.0 );\n#define GLOBAL_LIGHT_COLOR      vec3( 0.8, 1.0, 0.9)\n#define SPEC_COLOR              vec3( 0.8, 0.90, 0.60 )\n#define SPEC_POWER              32.0\n#define BACKGROUND_COLOR        vec3( 0.1, 0.2, 0.8 )\n#define MAX_RAY_BOUNCES         6.0\t\n#define MATERIAL_REFLECTIVITY   0.55\n#define FOG_DENSITY\t\t\t\t-0.0003\n#define REFLECT_ANGLE_LIMIT\t\t0.01\n\n#define CAM_DIST                80.0\n#define CAM_H                   1.5\n#define CAM_FOV_FACTOR          4.0\n#define LOOK_AT_H               0.2\n\n#define LOOK_AT                 vec3(0.0, LOOK_AT_H, 0.0)\n\n#define N_TOR_ROT\t\t\t\tPI * 0.325\n#define TOP_TOR_ROT\t\t\t\tPI * 0.165\n\n//------------------------------------------------------------------------------\n// Function declarations\nvec3 applyTexture( vec4 hitPosAndID );\nvec3 texture1( vec3 pos );\nvec3 texture2( vec3 pos );\nvec3 texture3( vec3 pos );\nvec3 texture4( vec3 pos );\nvec3 texture5( vec3 pos );\nvec3 texture6( vec3 pos );\nvec3 texture7( vec3 pos );\n\n// Comments here are from the HG_SDF Library.\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions);\nfloat fSphere(vec3 p, float r);\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height);\n// Cone with correct distances to tip and base circle. \n// Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height);\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c );\nfloat snoise(vec3 v);\nfloat smin(float a, float b);\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map( vec3 p ) \n{\n\t// Copy p before repetition domain operation.\n\tvec3 p0 = p;\n\n\t// Ground Plane\n\tfloat objID = 1.0;\n\tvec2 ground = vec2( fPlane( p - vec3( 0.0, -1.0, 0.0 ),\n\t                      normalize( vec3( 0.0, 1.0, 0.0 ) ), 1.0 ), objID );\t\n\t\n\t// Ground ring for inner structure frame.\n\tobjID = 2.0;\n\tvec2 inGrndRing = vec2( fTorus( p - vec3( 0.0, -1.85, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\t\t\n\t// Top ring for inner structure frame.\n\tvec2 inUprRing = vec2( fTorus( p - vec3( 0.0, 9.7, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\t\n\t// Ground ring for outer structure frame.\n\tobjID = 3.0;\n\tvec2 outGrndRing = vec2( fTorus( p - vec3( 0.0, -1.85, 0.0 ), 0.15, 20.0 ), \n\t                                                                   objID );\t\n\t// Top ring for outer structure frame.\n\tvec2 outUprRing = vec2( fTorus( p - vec3( 0.0, 10.0, 0.0 ), 0.15, 20.0 ), \n\t                                                                   objID );\t\n\t// Roof\n\tobjID = 4.0;\n\tvec2 roof = vec2( fCone( p - vec3( 0.0, 10.0, 0.0 ), 20.0, 5.0 ), objID );\n\t\n\t// Repetition : \n\t//------------------------------------\n\tfloat segNum = pModPolar( p.xz, 6.0 );\n\t//------------------------------------\n\t\n\t// Inner ring poles\n\tobjID = 2.0;\n\tvec2 inrPole = vec2( fCylinder( p - vec3( 10.0, 0.0, 0.0 ), 0.15, 10.0 ), \n\t                                                                   objID );\n\t// Outer ring poles\n\tobjID = 3.0;\n\tvec2 outrPoleA = vec2( fCylinder( \n\t                       p - vec3( 19.3, 0.0, -5.0 ), 0.15, 10.0 ), objID );\n\t                                                                   \n\tvec2 outrPoleB = vec2( fCylinder( \n                           p - vec3( 19.3, 0.0,  5.0 ), 0.15, 10.0 ), objID );\n\t                                                                   \n\t// Roof dividers\n\tvec2 rfDivA = vec2( fCapsule( p, vec3( 19.3, 10.0, 5.0 ),\n\t                                 vec3(  0.0, 15.0, 0.0 ), 0.1 ), objID );\n\t\n\tvec2 rfDivB = vec2( fCapsule( p, vec3( 19.3, 10.0, -5.0 ),\n\t                                 vec3(  0.0, 15.0, 0.0 ), 0.1 ), objID );\n\t\n\t//------------------------------------\t\n\t// Calculating horse up/down movement.\n\t//------------------------------------\n\t// From the HG_SDF Library:\n\t// \"Many of the operators partition space into cells. An identifier\n\t// or cell index is returned, if possible. This return value is\n\t// intended to be optionally used e.g. as a random seed to change\n\t// parameters of the distance functions inside the cells.\"\n\t\n\t// I used the variable segNum for the return values, but they were not the\n\t// simple values I'd expected. The ranges or exact values returned for each \n\t// segment ( direction ) are listed below. So it wasn't just simply a matter\n\t// of testing for an individual value, it required testing in a certain\n\t// order: NW, NE, E, SE, W, SW, S, else N \n\t\n\t// nothing >3 or <-2\n\t// NW,W >2 and <=3\n\t// SW,W,NW >1 and <=2\n\t// nothing >1 and <2\n\t// NE,E,SE = 1\n\t// nothing >0 and <1\n\t// NE,E = 0\n\t// nothing >-1 and <0\n\t// NE = -1\n\t// nothing >-2 and <-1\n\t// NW = -2\n\t// nothing <-2\n\n\t// Assign varying y-coords for each horse copy.\n\tfloat bodyPosY = 0.0;\n\n\tif ( segNum <= -2.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime );\n\t}\n\telse if ( segNum < -1.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 150.0 );\n\t}\n\telse if ( segNum < 0.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 300.0 );\n\t}\n\telse if ( segNum < 1.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 450.0 );\n\t}\n\telse if ( segNum < 2.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 600.0 );\n\t}\n\telse if ( segNum < 3.0 )\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 750.0 );\n\t}\n\telse\n\t{\n\t\t bodyPosY = 0.6 * sin( iTime + 900.0 );\n\t}\n\t\t\n\t//--------------------------------------------\n\t// Horse body\n\tobjID = 5.0;\n\tfloat y = 1.25; // Initial ground offset for horse body\n\t\n\tfloat body1= fSphere( p - vec3( 15.0, y + bodyPosY, -0.9 ), 0.9 );\n\tfloat body2 = fSphere( p - vec3(15.0, y + bodyPosY,  0.9 ), 0.9 );\n\tvec2 body = vec2( smin( body1, body2 ), objID );\n\n\t//--------------------------------------------\n\t// Legs\n\t// Front left leg in two parts\n\tfloat x = 14.3,\n\t      z = -1.2,\n\t      legFLa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t   \n\t                            vec3( x, -0.25 + bodyPosY, z - 0.61 ), 0.2 );\n\n\tvec2 legFLb = vec2( smin( body1, legFLa ), objID );\n\n\tvec2 legFL = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z - 0.61 ),\n\t                                vec3( x, -1.26 + bodyPosY, z - 0.6 ), \n\t                                0.16 ), objID );\n\t//--------------------------------------------\n\t// Front right leg in two parts\n\tx = 15.7;\n\tz = -1.2;\n\tfloat legFRa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t         \n\t                            vec3( x, -0.25 + bodyPosY, z + 0.13 ), 0.2 );\n\n\tvec2 legFRb = vec2( smin( body1, legFRa ), objID );\n\n\tvec2 legFR = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z + 0.12 ),\n\t                                vec3( x, -1.26 + bodyPosY, z + 0.9 ), \n\t                                0.16 ), objID );\t\n\t\n\t//--------------------------------------------\n\t// Back left leg in two parts\n\tx = 14.5;\n\tz = 1.2;\n\tfloat legBLa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t  \n\t                            vec3( x, -0.25 + bodyPosY, z - 0.75 ), 0.2 );\n\n\tvec2 legBLb = vec2( smin( body2, legBLa ), objID );\n\n\tvec2 legBL = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z - 0.75 ),\n\t                                vec3( x, -1.26 + bodyPosY, z - 0.6 ), \n\t                                0.16 ), objID );\n\t\n\t//--------------------------------------------\n\t// Back right leg in two parts\n\tx = 15.7;\n\tz = 1.2;\n\tfloat legBRa = fCapsule( p, vec3( x,  0.25 + bodyPosY, z ),\t\n\t                            vec3( x, -0.25 + bodyPosY, z + 0.13 ), 0.2 );\n\n\tvec2 legBRb = vec2( smin( body2, legBRa ), objID );\n\n\tvec2 legBR = vec2( fCapsule( p, vec3( x, -0.26 + bodyPosY, z + 0.12 ),\n\t                                vec3( x, -1.26 + bodyPosY, z + 0.75 ), \n\t                                0.16 ), objID );\n\t\n\t//--------------------------------------------\n\t// Neck\n\tfloat neckA = fCapsule( p, vec3( 15.0, 2.0 + bodyPosY, -1.8 ),\n\t                          vec3( 15.0,  3.0 + bodyPosY, -2.3 ), 0.35 );\n\t                          \n\tvec2 neck = vec2( smin( neckA, body1 ), objID );\t\n\t\n\t//--------------------------------------------\n\t// Head\n\tfloat headA = fCapsule( p, vec3( 15.0, 3.1 + bodyPosY, -2.5 ),\n\t                           vec3( 15.0, 2.1 + bodyPosY, -3.25 ), 0.275 );\n\t \n\tvec2 head = vec2( smin( neckA, headA ), objID );\t\n\t\n\t//---------------------------------------------\t\n\t// Tail\n\tvec2 tail = vec2( fCapsule( p, vec3( 15.0,  1.6 + bodyPosY, 1.7 ),\n\t                                vec3( 15.0, -0.5 + bodyPosY, 2.5 ), \n\t                                0.125 ), objID );\n\t\n\t//---------------------------------------------\n\t// Ears\n\tvec2 earL = vec2( fCapsule( p, vec3( 14.6, 3.2 + bodyPosY, -2.2 ),\n\t                               vec3( 14.6, 3.9 + bodyPosY, -2.2 ),\n\t                               0.1 ), objID );  \n\t\n\tvec2 earR = vec2( fCapsule( p, vec3( 15.4, 3.2 + bodyPosY, -2.2 ),\n\t                               vec3( 15.4, 3.9 + bodyPosY, -2.2 ),\n\t                               0.1 ), objID );  \n\t\n\t//---------------------------------------------\n\t// Horse pole\n\tobjID = 2.0;\n\tvec2 hPole = vec2( fCylinder( \n\t                        p - vec3( 15.0, 0.0, 0.0 ), 0.05, 10.0 ), objID );\t\n\t// Flag pole\n\tvec2 flagPole = vec2( fCylinder(\t\n\t                        p - vec3( 0.0, 15.0, 0.0 ), 0.05, 3.0 ), objID );\n\t\n\t// Flag in non-repeated space: p0\n\tobjID = 6.0;\n\tfloat wind = sin( iTime );\n\tvec2 flag = vec2( udTriangle( p0, vec3(  0.0, 16.5, 0.0 ), \n\t                                  vec3(  0.0, 18.0, 0.0 ),\n\t                           vec3( -5.0, 17.0 + wind, wind * 2.0 ) ), objID );\n\t// Pole top spheres\n\tvec2 poleTopA = vec2( fSphere( p - vec3( 19.3, 10.5, -5.0 ), 0.4 ), objID );\n\tvec2 poleTopB = vec2( fSphere( p - vec3( 19.3, 10.5,  5.0 ), 0.4 ), objID );\n\t\n\t// Flag sphere\n\tobjID = 3.0;\n\tvec2 flagSphere = vec2( fSphere( p - vec3( 0.0, 15.4, 0.0 ), 0.4 ), objID );\n\t\n\t// Outer ring spheres\n\tobjID = 2.0;\n\tvec2 outRingA = vec2( fSphere( p - vec3( 19.3, -1.65, -5.0 ), 0.6 ), objID );\n\tvec2 outRingB = vec2( fSphere( p - vec3( 19.3, -1.65,  5.0 ), 0.6 ), objID );\n\n\t// Center sphere\n\tobjID = 7.0;\t\n\tvec2 cntrSphere = vec2( \n\t                      fSphere( p - vec3( 0.0, -9.0, 0.0 ), 10.0 ), objID );\n\t\n\t// Center ring spheres\n\tobjID = 4.0;\n\tvec2 cntrRingSphere = vec2( \n\t                      fSphere( p - vec3( 9.0, -1.25, 0.0 ), 0.75 ), objID ); \n\t                      \n\t//-------------------------------------------\n\t// Distance comparisons for minimum distance.\n\t\n\tvec2 closest = ground.s < inGrndRing.s ? ground : inGrndRing;\n\tclosest = closest.s < inUprRing.s ? closest : inUprRing;\n\tclosest = closest.s < outGrndRing.s ? closest : outGrndRing;\n\tclosest = closest.s < outUprRing.s ? closest : outUprRing;\n\tclosest = closest.s < roof.s ? closest : roof;\n\tclosest = closest.s < inrPole.s  ? closest : inrPole;\n\tclosest = closest.s < outrPoleA.s  ? closest : outrPoleA;\n\tclosest = closest.s < outrPoleB.s  ? closest : outrPoleB;\n\tclosest = closest.s < rfDivA.s  ? closest : rfDivA;\n\tclosest = closest.s < rfDivB.s  ? closest : rfDivB;\n\n\tclosest = closest.s < body.s ? closest : body;\n\tclosest = closest.s < legFLb.s ? closest : legFLb ;\n\tclosest = closest.s < legFL.s ? closest : legFL;\n\tclosest = closest.s < legFRb.s ? closest : legFRb ;\n\tclosest = closest.s < legFR.s ? closest : legFR;\n\tclosest = closest.s < legBLb.s ? closest : legBLb ;\n\tclosest = closest.s < legBL.s ? closest : legBL;\n\tclosest = closest.s < legBRb.s ? closest : legBRb ;\n\tclosest = closest.s < legBR.s ? closest : legBR;\n\tclosest = closest.s < neck.s ? closest : neck;\n\tclosest = closest.s < head.s ? closest : head;\n\tclosest = closest.s < tail.s ? closest : tail;\n\tclosest = closest.s < earL.s ? closest : earL;\n\tclosest = closest.s < earR.s ? closest : earR;\n\t\n\tclosest = closest.s < hPole.s ? closest : hPole;\n\tclosest = closest.s < flagPole.s ? closest : flagPole;\n\tclosest = closest.s < flag.s ? closest : flag;\n\tclosest = closest.s < poleTopA.s ? closest : poleTopA;\n\tclosest = closest.s < poleTopB.s ? closest : poleTopB;\n\tclosest = closest.s < flagSphere.s ? closest : flagSphere;\n\tclosest = closest.s < outRingA.s ? closest : outRingA;\n\tclosest = closest.s < outRingB.s ? closest : outRingB;\n\tclosest = closest.s < cntrSphere.s ? closest : cntrSphere;\n\tclosest = closest.s < cntrRingSphere.s ? closest : cntrRingSphere;\n\t\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// CALC NORMAL\n// -----------\n// The surface normal computed using the finite difference formula.\nvec3 calcNormal( in vec3 p )\n{\n    vec2 d = vec2( NORMAL_EPS, 0.0 );\n    \n    return normalize( vec3( map( p + d.xyy ).x - map( p - d.xyy ).x,\n                            map( p + d.yxy ).x - map( p - d.yxy ).x,\n                            map( p + d.yyx ).x - map( p - d.yyx ).x ) );\n}\n\n//------------------------------------------------------------------------------\n\n// RAY MARCH\n// ---------\n\nvec2 rayMarch( vec3 rayOrig, vec3 rayDir ) \n{\n    vec2 objDistID = vec2( 0.0 );\n    float t = NEAR_CLIP_PLANE;\n    float m = MTL_BACKGROUND;\t// -1 : flag for hit far clip plane\n    \n    for (int i = 0; i < MAX_RAYCAST_STEPS; i++ ) \n    {\n        objDistID = map( rayOrig + rayDir * t );\n        \n        if ( objDistID.x < DIST_EPSILON || t > FAR_CLIP_PLANE )  \n        {\n        \tbreak;\n        }\n        t += objDistID.x * STEP_DAMPING;\n    }\n\n    m = objDistID.y;\n\n    if ( t > FAR_CLIP_PLANE ) \n    {\n    \tm = MTL_BACKGROUND;\n    }\n    return vec2( t, m );\n}\n\n// end rayMarch()\n\n//------------------------------------------------------------------------------\n\n// APPLY FOG\n// ---------\n\n// Fog is implemented by mixing in the the background color exponentially,\n// depending on the distance to the point. wjb added skyClr to replace\n// background color.\nvec3 applyFog( vec3 clr, float dist, vec3 skyClr ) \n{\n    //return mix( clr, BACKGROUND_COLOR, 1.0 - exp( -0.0015 * dist * dist ) );\n    vec3 fog = mix( clr, skyClr, 1.0 - exp( FOG_DENSITY * dist * dist ) );\n\treturn clamp( fog, 0.0, 0.4 );\n}\n\n//------------------------------------------------------------------------------\n\n// SHADOW\n// ------\n// source : https://iquilezles.org/articles/rmshadows\n// Added from ChristmasTree.frag        \n// https://github.com/silverio/raymarching/blob/master/ChristmasTree.frag\n// tmin = DIST_EPSILON, tmax = MAX_SHADOW_DIST\nfloat shadow( vec3 rayOrig, vec3 rayDir, float tmin, float tmax ) \n{\n    float shadowAmt = 1.0;\n    float t = tmin;\n    \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ ) \n    {\n        float d = map( rayOrig + rayDir * t ).s * STEP_DAMPING;\n        \n        if ( d < DIST_EPSILON || t > tmax ) \n        {\n        \tbreak;\n        }\n        \n        shadowAmt = min( shadowAmt, SHADOW_SOFTNESS * d / t );\n        \n        t += clamp( d, 0.01, 0.25 );\n    }\n\n    return clamp( shadowAmt, 0.0, 1.0 );\n}\n\n// end shadow()\n\n//------------------------------------------------------------------------------\n\n// RENDER\n// ------\n\nvec3 render( vec3 rayOrig, vec3 rayDir, vec4 objHitPosID, vec3 skyClr ) \n{\n\t// Added from \n\t// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n    // Reflections\n    // -----------\n    // After the ray hits an object, we can cast so called secondary rays, \n    // including the one in the direction of the reflection vector. For \n    // reflections we'll keep doing it either until we reach the hit number or \n    // raymarching step limit:\n    vec3 objClr = vec3( 0.0 );\n    //vec3  lightDir = -rayDir; // original - light position is at ray origin\n    \n    vec3 lightDir = LIGHT_POSITION - LOOK_AT;\n    lightDir = normalize( lightDir );\n        \n    vec3 mtlClr = applyTexture( objHitPosID );\n    vec2 objDistID = vec2( 0.0 );\n    \n    float specSharp = 0.9;//1.0\t// the specular \"sharpness\" coefficient\n    float ambient = 0.01;\n\n\tfor ( float i = 0.0; i < MAX_RAY_BOUNCES; i++ ) \n\t{\n\t\t// Number of raymarch calls can be set separately from reflection loop.\n\t\tif ( i < 3.0 )\n\t\t{\n\t    \tobjDistID = rayMarch( rayOrig, rayDir );\n\t\t}\n\n\t    float objDist = objDistID.x;\n\t    float objID = objDistID.y;\n\t    \n\t    vec3 pos = rayOrig + objDist * rayDir;\n\t    vec3 nor = calcNormal( pos );\n\t    //vec3 mtlClr = getMaterialColor( objID ); // original\n    \t\n    \t// The dot product of the angle between the normal vector at the object \n    \t// hit position and the light direction vector returns a value between \n    \t// -1 and +1; which is then clamped between 0 and +1 to give the diffuse \n    \t// light component value ( 0 = darkest, 1 = brightest ). \n    \tfloat diffuse = clamp( dot( nor, lightDir ), 0.0, 1.0 );\n        diffuse *= shadow( pos, lightDir, DIST_EPSILON, MAX_SHADOW_DIST );\n\t\n\t\t// Added from \n\t\t// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\t    // Phong ( specular ) component\n\t    // ----------------------------\n\t    // Phong model adds so-called specular component on top of the diffuse \n\t    // Lambertian one. Essentially it's a fake reflection that assumes that \n\t    // environment consists from a single blob light source. \n\t    \n\t    // rayDir is view direction, specSharp is the specular \"sharpness\" \n\t    // coefficient (used to adjust the shape of the reflected fake blob), \n\t    // ref is \"reflection vector\"\n\t    vec3 ref = reflect( rayDir, nor );\n\t    float specular = pow(clamp(dot(ref, lightDir), 0.0, 1.0), SPEC_POWER);\n    \n\t    // Modified from\n\t\t// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\t    //vec3 clr = mtlClr*(ambient + GLOBAL_LIGHT_COLOR*diffuse);\n\t    vec3 clr = mtlClr * ( ambient + GLOBAL_LIGHT_COLOR * \n\t                                     ( diffuse + specular * SPEC_COLOR ) );       \t\n    \tclr = mix( applyFog( clr, objDist, skyClr ), clr, 0.33 );\n\t\t\n\t\t// Added from\n\t\t// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\t\tobjClr += clr * specSharp; //  blend in (a possibly reflected) new color\n\t\t\n\t\t// If the reflection angle is very small, discontinue the loop.\n\t\tif ( abs( dot( nor, rayDir ) ) < REFLECT_ANGLE_LIMIT )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// The ray origin is updated to the sum of the current ray position and\n\t\t// the reflection vector multiplied by the \"close enough to be a hit\"\n\t\t// value. I think this is done to move the ray position far enough away\n\t\t// from the hit object so that it doesn't immediately hit it again ( per\n\t\t// code comments from Shane in raymarching.com code ).\n        rayOrig = pos + ref * DIST_EPSILON;\n        \n        //specSharp is the specular \"sharpness\" coefficient (used to adjust the \n        // shape of the reflected fake blob in the Christmas Tree shader)\n        specSharp *= MATERIAL_REFLECTIVITY;\n        rayDir = ref;\n\t}    \n   \n    return vec3( clamp( objClr, 0.0, 1.0 ) );\n}\n\n// end render()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// SKY COLOR\n// ---------\n// https://www.shadertoy.com/view/lll3z4\n// Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n/*\n * Gardner Cos Clouds\n *\n * Translated/adapted from the RenderMan implementation in\n * Texturing & Modeling; a Procedural Approach (3rd ed, p. 50)\n */\n \nvec3 skyColor( vec2 pix )\n{\n\tconst int nTerms = 10;\n\t\n\tfloat zoom = 1.0,\n          cloudDensity = 0.0,\n          amplitude = 0.4,//0.45,\n          xphase = 0.9 * iTime,\n          yphase = 0.7,\n          xfreq = 2.0 * PI * 0.023,\n          yfreq = 2.0 * PI * 0.021,\n    \n          offset = 0.5,\n          xoffset = 37.0,\n          yoffzet = 523.0,\n    \n          x = pix.x,\n          y = pix.y,\n\t      scale = 1.0 / iResolution.x * 60.0 * 1.0 / zoom;\n\n    x = x * scale + offset + iTime * 1.5;\n    y = y * scale + offset - iTime / 2.3;\n    \n    for ( int i = 0; i < nTerms; i++ )\n    {\n        float fx = amplitude * ( offset + cos( xfreq * ( x + xphase ) ) );\n        float fy = amplitude * ( offset + cos( yfreq * ( y + yphase ) ) );\n        cloudDensity += fx * fy;\n        xphase = PI * 0.5 * 0.9 * cos( yfreq * y );\n        yphase = PI * 0.5 * 1.1 * cos( xfreq * x );\n        amplitude *= 0.602;\n        xfreq *= 1.9 + float( i ) * .01;\n        yfreq *= 2.2 - float( i ) * 0.08;\n    }\n\n    return mix( vec3(0.25, 0.55, 0.96 ), vec3( 1.0 ), cloudDensity * 2.0 );   \n}\n\n// end skyColor()\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// \thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n\t}\n\telse\n\t{\n\t\t// wjb added the 180 degree rotation ( PI ) because the objects were\n\t\t// being created on the negative side of the x-axis ( mirrored position\n\t\t// across z-plane ) instead of the positive side, where they should be.\n\t\tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange + PI;\n\t}\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = 0.25 * ( sin( iTime * 0.1 ) + 1.0 );\n\t}\n\telse\n\t{\n\t\t// Scale mouse.y so x-axis rotation range is only from partway overhead\n\t\t// to just about level with ground.\n\t\tang = ( 0.4825 * iMouse.y - iResolution.y * 0.5 ) * rotRange; \n\t}\n\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// For skyColor()\n\tvec2 curPix = fragCoord.xy;\n\tcurPix *= vec2( 0.35, 0.65 );\n\t\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n \tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), p );   \n    \n    // Determine whether ray has reached back plane.\n    vec2 objDistID = rayMarch( camPos, rayDir );\n    \n    // Set to background and skip the reflection and lighting process if the\n    // ray got all the way to the back.\n    vec3 skyClr = skyColor( curPix );\n    vec3 color = skyClr;                        \n    \n\tif ( objDistID.s < FAR_CLIP_PLANE )\n\t{\t\t\n\t\tvec3 objHitPos = camPos + rayDir * objDistID.s;\n\t\tvec4 objHitPosID = vec4( objHitPos, objDistID.t );\n\t\tcolor = render( camPos, rayDir, objHitPosID, skyClr );\n\t}\n\t\n    fragColor = vec4(color, 1.0);\n}\n\n//------------------------------------------------------------------------------\n\n// APPLY TEXTURE\n// -------------\n\nvec3 applyTexture( vec4 hitPosAndID )\n{\n\tvec3 baseColor = vec3( 0.0 ),\n\t     pos = hitPosAndID.xyz;\n\t\n\tint objNum = int( hitPosAndID.w );\n\n\t// ground\n\tif ( objNum == 1 )\n\t{\t\t\n\t\tbaseColor = texture1( pos );\n\t}\t\n\t// inner rings, inner pillars\n\telse if ( objNum == 2 )\n\t{\n\t\tbaseColor = texture2( pos );\n\t}\t\n\t// outer rings, outer pillars\n\telse if ( objNum == 3 )\n\t{\n\t\tbaseColor = texture3( pos );\n\t}\t\n\t// roof\t\n\telse if ( objNum == 4 )\n\t{\n\t\tbaseColor = texture4( pos );\n\t}\n\t// horse\t\t\t\n\telse if ( objNum == 5 )\n\t{\n\t\tbaseColor = texture5( pos );\n\t}\t\n\t// pole top sphere\n\telse if ( objNum == 6 )\n\t{\n\t\tbaseColor = texture6( pos );\n\t}\t\n\t// center sphere\n\telse if ( objNum == 7 )\n\t{\n\t\tbaseColor = texture7( pos );\n\t}\t\n\t\n\treturn baseColor;\n}\n\n// end applyTexture()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 1\n// ---------\n\nvec3 texture1( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0, 0.7, 0.2 );\t\n\t\t\n\tfloat scale = 1.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.5;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Marble( triangular ) #1\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture1()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 2\n// ---------\n\nvec3 texture2( vec3 pos )\n{\n\tvec3 objClr = vec3( 1.0, 1.0, 0.0 );\t\n\t\t\n\tfloat scale = 4.0,\n\t\t  complexity = 2.5,\n\t\t  mixVal = 0.6;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Combination Marble( triangular) with Marble( sharp ) #10\n\t// Marble( triangular )\n\tvec3 v = pos * scale;\n\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n\tt += snoise(v);\t\n\tfloat value = t - floor(t);\t\t\t\n\t// smooth out the discontinuity\n\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n\tvalue = 0.333 + value*0.667;\n\tvec3 color = vec3(value);\t\t    \n\t// Marble ( sharp )  :  wjb added variable complexity factor\n\tt = (v.x + 2.0*v.y + 3.0*v.z);\n\tt +=  snoise(v) * complexity;\n\tvalue =  abs(sin(t));\n\tcolor /= vec3(sqrt(value)); // modified to divide    \t\t    \n\treturn mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture2()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 3\n// ---------\n\nvec3 texture3( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.75, 0.0, 1.0 );\t\n\t\t\n\tfloat scale = 2.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.9;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #21 )\n\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t// on white background\n\tvec3 v = pos * scale;\n\tfloat value = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture3()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 4\n// ---------\n\nvec3 texture4( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0, 0.15, 1.0 );\t\n\t\t\n\tfloat scale = 2.0,\n\t\t  complexity = 0.5,\n\t\t  mixVal = 0.6;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #19 )\n\t// With complexity = 1.0, squiggly lines in objColor on white\n\tvec3 v = pos * scale;\n\tfloat value = log( pow( snoise( v ), 2.0 ) ) * complexity; \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture4()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 5\n// ---------\n\nvec3 texture5( vec3 pos )\n{\n\treturn vec3( 0.0 );\n//\tvec3 objClr = vec3( 0.0 );\t\n//\t\n//\tfloat scale = 1.0,\n//\t\t  //complexity = 5.0,\n//\t\t  mixVal = 0.5;\t  \n//\t\n//\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n//\t// Marble( triangular ) #1\n//\tvec3 v = pos * scale;\n//\tfloat t = (v.x + 2.0*v.y + v.z)*0.25;\t\t\t\n//\tt += snoise(v);\t\n//\tfloat value = t - floor(t);\t\t\t\n//\t// smooth out the discontinuity\n//\tvalue = value*(1.0 - smoothstep(0.95,1.0,value));  \n//\tvalue = 0.333 + value*0.667;\n//\tvec3 color = vec3(value);\t\t    \n//    return mix( color, objClr, mixVal );        \t\t\t\t\n}\n\n// end texture5()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 6\n// ---------\n\nvec3 texture6( vec3 pos )\n{\n\tvec3 objClr = vec3( 1.0, 0.0, 0.0 );\t\n\t\n\tfloat scale = 2.0,\n\t\t  complexity = 5.0,\n\t\t  mixVal = 0.9;\t  \n\t\n\t// wjb modified Perlin Noise 3D ( #21 )\n\t// Blotches of objClr surrounded by very thin squiggly black lines\n\t// on white background\n\tvec3 v = pos * scale;\n\tfloat value = exp( inversesqrt( pow( snoise( v ), 2.0 ) * complexity ) ); \n    value = 0.75 + value*0.25;\n    vec3 color = vec3( value);    \t\t    \n    return mix( color, objClr, mixVal );        \t\t\t\t\t\n}\n\n// end texture6()\n\n//------------------------------------------------------------------------------\n\n// TEXTURE 7\n// ---------\n\nvec3 texture7( vec3 pos )\n{\n\tvec3 objClr = vec3( 0.0 ),//( 1.0, 0.0, 1.0 ),\n\t     color = vec3( 0.0 );\t\n\t\n\tfloat scale = 2.0,\n\t\t  mixVal = 0.5;\t  \n\t\n\t// http://math.hws.edu/graphicsbook/demos/c7/procedural-textures.html\n\t// Checkerboard 3D #6\n\tvec3 v = pos * scale;\n\tfloat a = floor( v.x );\n\tfloat b = floor( v.y );\n\tfloat c = floor( v.z );\n\tif ( mod( a + b + c, 2.0 ) > 0.5 ) \n\t{  // a+b+c is odd\n\t    color = vec3( 0.3 ); // the dark value\n\t}\n\telse \n\t{  // a+b+c is even\n\t    color = vec3( 1.0 ); // the light value\n\t}    \t\t\n\treturn mix( color, objClr, mixVal );        \t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n// end texture7()\n\n//------------------------------------------------------------------------------\n//==============================================================================\n// Triangle - unsigned\n// https://iquilezles.org/articles/distfunctions\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n//------------------------------------------------------------------------------\n\n// SMOOTH MINIMUM\n// --------------\n// https://www.shadertoy.com/view/XtjXWD\t-Otavio Good\n// smooth blending function; k should be negative. -4.0 works nicely.\nfloat smin(float a, float b)\n{\n\tfloat k = -4.0;\n\treturn log2( exp2( k * a ) + exp2( k * b ) ) / k;\n}\n\n//==============================================================================\n// The code below is excerpted from :\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n#define clamp(x,a,b) min(max(x,a),b)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//\n    // FOLLOWING CODE was OBTAINED FROM https://github.com/ashima/webgl-noise\n    // This is the code for 3D  Perlin noise, using simplex method.\n    //\n    \n    //------------------------------- 3D Noise ------------------------------------------\n    \n    // Description : Array and textureless GLSL 2D/3D/4D simplex \n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    // \n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      { \n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n      \n      // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n      \n      // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n      \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n      \n      // Permutations\n        i = mod289(i); \n        vec4 p = permute( permute( permute( \n                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n      \n      // Gradients: 7x7 points over a square, mapped onto an octahedron.\n      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n      \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n      \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n      \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n      \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n      \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n      \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n      \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n      \n      //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n      \n      // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                      dot(p2,x2), dot(p3,x3) ) );\n      }\n\n//------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 1660,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/reichmarshall/gladiolus-rag-on-pipe-organ"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}