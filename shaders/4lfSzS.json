{
    "Shader": {
        "info": {
            "date": "1437405566",
            "description": "i found in game.interstellarmovie.com planet generator and simulated generation of stars with the noise.\nyou can rotate with mouse \n[url=https://www.youtube.com/watch?v=Z_uN24AQaV4]  Interstellar gameplay[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4lfSzS",
            "likes": 201,
            "name": "Awesome star",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "noise",
                "ray",
                "sun",
                "star"
            ],
            "usePreview": 1,
            "username": "foxes",
            "viewed": 19662
        },
        "renderpass": [
            {
                "code": "// Panteleymonov A K 2015\n\n//\n// procedural noise from https://www.shadertoy.com/view/4sfGzS\n// for first variant\n/*float hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}*/\n\n// animated noise\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\n//vec4 WS=vec4(10.25,32.25,15.25,3.25);\nvec4 WS=vec4(0.25,0.25,0.25,0.25);\n\n//\n//vec4 hash4(vec4 x){ return fract(fract(x*0.31830988618379067153776752674503)*fract(x*0.15915494309189533576888376337251)*265871.1723); }\n//vec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\n//float noise3( vec3 x )\n//{\n//    vec3 p = floor(x);\n//    vec3 f = fract(x);\n//    f = f*f*(3.0-2.0*f);\n//    float n = p.x + dot(p.yz,vec2(157.0,113.0));\n//    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n//    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\n//}\n\n// just a noise\n//float noise4( vec4 x )\n//{\n//    vec4 p = floor(x);\n//    vec4 f = fract(x);\n//    p.w=mod(p.w,100.0); // looping noise in one axis\n//    f = f*f*(3.0-2.0*f);\n//    float n = p.x + dot(p.yzw,vec3(157.0,113.0,642.0));\n//    vec4 vs1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n//    n = n-642.0*p.w + 642.0*mod(p.w+1.0,100.0);\n//    vec4 vs2=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n//    vs1=mix(vec4(vs1.xz,vs2.xz),vec4(vs1.yw,vs2.yw),vec4(f.y));\n//    vs1.xy=mix(vs1.xz,vs1.yw,vec2(f.z));\n//    return mix(vs1.x,vs1.y,f.w);\n//}\n\n// mix noise for alive animation\n//float noise4r( vec4 x )\n//{\n//    return (noise4(x)+noise4(x+=WS)+noise4(x+=WS)+noise4(x+=WS))*0.25;\n//    //return noise4(x);\n//}\n\n// mix noise for alive animation, full source\nvec4 hash4( vec4 n ) { return fract(sin(n)*1399763.5453123); }\nvec3 hash3( vec3 n ) { return fract(sin(n)*1399763.5453123); }\nvec3 hpos( vec3 n ) { return hash3(vec3(dot(n,vec3(157.0,113.0,271.0)),dot(n,vec3(271.0,157.0,113.0)),dot(n,vec3(113.0,271.0,157.0)))); }\n//vec4 hash4( vec4 n ) { return fract(n*fract(n*0.5453123)); }\n//vec4 hash4( vec4 n ) { n*=1.987654321; return fract(n*fract(n)); }\nfloat noise4q(vec4 x)\n{\n\tvec4 n3 = vec4(0,0.25,0.5,0.75);\n\tvec4 p2 = floor(x.wwww+n3);\n\tvec4 b = floor(x.xxxx+n3) + floor(x.yyyy+n3)*157.0 + floor(x.zzzz +n3)*113.0;\n\tvec4 p1 = b + fract(p2*0.00390625)*vec4(164352.0, -164352.0, 163840.0, -163840.0);\n\tp2 = b + fract((p2+1.0)*0.00390625)*vec4(164352.0, -164352.0, 163840.0, -163840.0);\n\tvec4 f1 = fract(x.xxxx+n3);\n\tvec4 f2 = fract(x.yyyy+n3);\n\tf1=f1*f1*(3.0-2.0*f1);\n\tf2=f2*f2*(3.0-2.0*f2);\n\tvec4 n1 = vec4(0,1.0,157.0,158.0);\n\tvec4 n2 = vec4(113.0,114.0,270.0,271.0);\t\n\tvec4 vs1 = mix(hash4(p1), hash4(n1.yyyy+p1), f1);\n\tvec4 vs2 = mix(hash4(n1.zzzz+p1), hash4(n1.wwww+p1), f1);\n\tvec4 vs3 = mix(hash4(p2), hash4(n1.yyyy+p2), f1);\n\tvec4 vs4 = mix(hash4(n1.zzzz+p2), hash4(n1.wwww+p2), f1);\t\n\tvs1 = mix(vs1, vs2, f2);\n\tvs3 = mix(vs3, vs4, f2);\n\tvs2 = mix(hash4(n2.xxxx+p1), hash4(n2.yyyy+p1), f1);\n\tvs4 = mix(hash4(n2.zzzz+p1), hash4(n2.wwww+p1), f1);\n\tvs2 = mix(vs2, vs4, f2);\n\tvs4 = mix(hash4(n2.xxxx+p2), hash4(n2.yyyy+p2), f1);\n\tvec4 vs5 = mix(hash4(n2.zzzz+p2), hash4(n2.wwww+p2), f1);\n\tvs4 = mix(vs4, vs5, f2);\n\tf1 = fract(x.zzzz+n3);\n\tf2 = fract(x.wwww+n3);\n\tf1=f1*f1*(3.0-2.0*f1);\n\tf2=f2*f2*(3.0-2.0*f2);\n\tvs1 = mix(vs1, vs2, f1);\n\tvs3 = mix(vs3, vs4, f1);\n\tvs1 = mix(vs1, vs3, f2);\n\tfloat r=dot(vs1,vec4(0.25));\n\t//r=r*r*(3.0-2.0*r);\n\treturn r*r*(3.0-2.0*r);\n}\n\n// body of a star\nfloat noiseSpere(vec3 ray,vec3 pos,float r,mat3 mr,float zoom,vec3 subnoise,float anim)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    \n    vec3 r1=vec3(0.0);\n    \n    float s=0.0;\n    float d=0.03125;\n    float d2=zoom/(d*d); \n    float ar=5.0;\n   \n    for (int i=0;i<3;i++) {\n\t\tfloat rq=r*r;\n        if(c <rq)\n        {\n            float l1=sqrt(rq-c);\n            r1= ray*(b-l1)-pos;\n            r1=r1*mr;\n            s+=abs(noise4q(vec4(r1*d2+subnoise*ar,anim*ar))*d);\n        }\n        ar-=2.0;\n        d*=4.0;\n        d2*=0.0625;\n        r=r-r*0.02;\n    }\n    return s;\n}\n\n// glow ring\nfloat ring(vec3 ray,vec3 pos,float r,float size)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n   \n    float s=max(0.0,(1.0-size*abs(r-sqrt(c))));\n    \n    return s;\n}\n\n// rays of a star\nfloat ringRayNoise(vec3 ray,vec3 pos,float r,float size,mat3 mr,float anim)\n{\n  \tfloat b = dot(ray,pos);\n    vec3 pr=ray*b-pos;\n       \n    float c=length(pr);\n\n    pr*=mr;\n    \n    pr=normalize(pr);\n    \n    float s=max(0.0,(1.0-size*abs(r-c)));\n    \n    float nd=noise4q(vec4(pr*1.0,-anim+c))*2.0;\n    nd=pow(nd,2.0);\n    float n=0.4;\n    float ns=1.0;\n    if (c>r) {\n        n=noise4q(vec4(pr*10.0,-anim+c));\n        ns=noise4q(vec4(pr*50.0,-anim*2.5+c*2.0))*2.0;\n    }\n    n=n*n*nd*ns;\n    \n    return pow(s,4.0)+s*s*n;\n}\n\nvec4 noiseSpace(vec3 ray,vec3 pos,float r,mat3 mr,float zoom,vec3 subnoise,float anim)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    \n    vec3 r1=vec3(0.0);\n    \n    float s=0.0;\n    float d=0.0625*1.5;\n    float d2=zoom/d;\n\n\tfloat rq=r*r;\n    float l1=sqrt(abs(rq-c));\n    r1= (ray*(b-l1)-pos)*mr;\n\n    r1*=d2;\n    s+=abs(noise4q(vec4(r1+subnoise,anim))*d);\n    s+=abs(noise4q(vec4(r1*0.5+subnoise,anim))*d*2.0);\n    s+=abs(noise4q(vec4(r1*0.25+subnoise,anim))*d*4.0);\n    //return s;\n    return vec4(s*2.0,abs(noise4q(vec4(r1*0.1+subnoise,anim))),abs(noise4q(vec4(r1*0.1+subnoise*6.0,anim))),abs(noise4q(vec4(r1*0.1+subnoise*13.0,anim))));\n}\n\nfloat sphereZero(vec3 ray,vec3 pos,float r)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    float s=1.0;\n    if (c<r*r) s=0.0;\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n    float time=iTime*1.0;\n    \n\tfloat mx = iMouse.z>0.0?iMouse.x/iResolution.x*10.0:time*0.025;\n    float my = iMouse.z>0.0?iMouse.y/iResolution.y*4.0-2.0:-0.6;\n    vec2 rotate = vec2(mx,my);\n\n    vec2 sins=sin(rotate);\n    vec2 coss=cos(rotate);\n    mat3 mr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\n    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;    \n\n    mat3 imr=mat3(vec3(coss.x,0.0,-sins.x),vec3(0.0,1.0,0.0),vec3(sins.x,0.0,coss.x));\n    imr=imr*mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,-sins.y),vec3(0.0,sins.y,coss.y));\n\t\n    vec3 ray = normalize(vec3(p,2.0));\n    vec3 pos = vec3(0.0,0.0,3.0);\n    \n    float s1=noiseSpere(ray,pos,1.0,mr,0.5,vec3(0.0),time);\n    s1=pow(min(1.0,s1*2.4),2.0);\n    float s2=noiseSpere(ray,pos,1.0,mr,4.0,vec3(83.23,34.34,67.453),time);\n    s2=min(1.0,s2*2.2);\n    fragColor = vec4( mix(vec3(1.0,1.0,0.0),vec3(1.0),pow(s1,60.0))*s1, 1.0 );\n    fragColor += vec4( mix(mix(vec3(1.0,0.0,0.0),vec3(1.0,0.0,1.0),pow(s2,2.0)),vec3(1.0),pow(s2,10.0))*s2, 1.0 );\n\t\n    fragColor.xyz -= vec3(ring(ray,pos,1.03,11.0))*2.0;\n    fragColor = max( vec4(0.0), fragColor );\n    \n    float s3=ringRayNoise(ray,pos,0.96,1.0,mr,time);\n    fragColor.xyz += mix(vec3(1.0,0.6,0.1),vec3(1.0,0.95,1.0),pow(s3,3.0))*s3;\n\n    float zero=sphereZero(ray,pos,0.9);\n    if (zero>0.0) {\n    \t//float s4=noiseSpace(ray,pos,100.0,mr,0.5,vec3(0.0),time*0.01);\n\t    vec4 s4=noiseSpace(ray,pos,100.0,mr,0.05,vec3(1.0,2.0,4.0),0.0);\n    \t//float s5=noiseSpace(ray,pos,100.0,vec3(mx,my,0.5),vec3(83.23,34.34,67.453),time*0.01);\n    \t//s4=pow(s4*2.0,6.0);\n    \t//s4=pow(s4*1.8,5.7);\n    \ts4.x=pow(s4.x,3.0);\n    \t//s5=pow(s5*2.0,6.0);\n    \t//fragColor.xyz += (vec3(0.0,0.0,1.0)*s4*0.6+vec3(0.9,0.0,1.0)*s5*0.3)*sphereZero(ray,pos,0.9);\n    \tfragColor.xyz += mix(mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),s4.y*1.9),vec3(0.9,1.0,0.1),s4.w*0.75)*s4.x*pow(s4.z*2.5,3.0)*0.2*zero;\n    \t//fragColor.xyz += (mix(mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),s4*3.0),vec3(1.0),pow(s4*2.0,4.0))*s4*0.6)*sphereZero(ray,pos,0.9);\n        \n        \n\t\t/*float b = dot(ray,pos);\n  \t\tfloat c = dot(pos,pos) - b*b;\n    \tfloat l1 = sqrt(abs(10.0-c));\n    \tvec3 spos = (ray*(b-l1))*mr;\n        vec3 sposr=ceil(spos)+spos/abs(spos)*0.5;\n        //sposr+=hpos(sposr)*0.2;\n        \n        float ss3=max(0.0,ringRayNoise(ray,(sposr)*imr,0.001,10.0,mr,time));\n        fragColor.xyz += vec3(ss3);*/\n    }\n    \n    //fragColor = max( vec4(0.0), fragColor );\n    //s+=noiseSpere(ray,vec3(0.0,0.0,3.0),0.96,vec2(mx+1.4,my),vec3(83.23,34.34,67.453));\n    //s+=noiseSpere(ray,vec3(0.0,0.0,3.0),0.90,vec2(mx,my),vec3(123.223311,956.34,7.45333))*0.6;\n    \n    fragColor = max( vec4(0.0), fragColor );\n\tfragColor = min( vec4(1.0), fragColor );\n}\n\n//\n// SunShader 1.0 for Unity3D 4-5\n//\n// Panteleymonov Aleksandr 2016\n//\n// foxes@bk.ru\n// mail@panteleymonov.ru\n//\n/*\nShader \"Space/Star/Sun\"\n{\n\tProperties\n\t{\n\t\t_Radius(\"Radius\", Float) = 0.5\n\t\t_Light(\"Light\",Color) = (1,1,1,1)\n\t\t_Color(\"Color\", Color) = (1,1,0,1)\n\t\t_Base(\"Base\", Color) = (1,0,0,1)\n\t\t_Dark(\"Dark\", Color) = (1,0,1,1)\n\t\t_RayString(\"Ray String\", Range(0.02,10.0)) = 1.0\n\t\t_RayLight(\"Ray Light\", Color) = (1,0.95,1.0,1)\n\t\t_Ray(\"Ray End\", Color) = (1,0.6,0.1,1)\n\t\t_Detail(\"Detail Body\", Range(0,5)) = 3\n\t\t_Rays(\"Rays\", Range(1.0,10.0)) = 2.0\n\t\t_RayRing(\"Ray Ring\", Range(1.0,10.0)) = 1.0\n\t\t_RayGlow(\"Ray Glow\", Range(1.0,10.0)) = 2.0\n\t\t_Glow(\"Glow\", Range(1.0,100.0)) = 4.0\n\t\t_Zoom(\"Zoom\", Float) = 1.0\n\t\t_SpeedHi(\"Speed Hi\", Range(0.0,10)) = 2.0\n\t\t_SpeedLow(\"Speed Low\", Range(0.0,10)) = 2.0\n\t\t_SpeedRay(\"Speed Ray\", Range(0.0,10)) = 5.0\n\t\t_SpeedRing(\"Speed Ring\", Range(0.0,20)) = 2.0\n\t\t_Seed(\"Seed\", Range(-10,10)) = 0\n\t}\n\t\tSubShader\n\t{\n\t\tTags{ \"Queue\" = \"Transparent\" \"IgnoreProjector\" = \"True\" \"RenderType\" = \"Transparent\" }\n\t\tLOD 100\n\n\t\tPass\n\t\t{\n\t\t\tBlend One OneMinusSrcAlpha\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t#pragma target 4.0\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t#if UNITY_5_0\n\t\t\t\tUNITY_FOG_COORDS(1)\n\t\t\t#endif\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\n\t\t\tsampler2D _MainTex;\n\t\t\tfloat _Radius;\n\t\t\tfloat _RayString;\n\t\t\tfixed4 _Light;\n\t\t\tfixed4 _Color;\n\t\t\tfixed4 _Base;\n\t\t\tfixed4 _Dark;\n\t\t\tfixed4 _Ray;\n\t\t\tfixed4 _RayLight;\n\t\t\tint _Detail;\n\t\t\tfloat _Rays;\n\t\t\tfloat _RayRing;\n\t\t\tfloat _RayGlow;\n\t\t\tfloat _Zoom;\n\t\t\tfloat _SpeedHi;\n\t\t\tfloat _SpeedLow;\n\t\t\tfloat _SpeedRay;\n\t\t\tfloat _SpeedRing;\n\t\t\tfloat _Glow;\n\t\t\tfloat _Seed;\n\n\t\t\tfloat4 posGlob; // center position\n\t\t\t\t\t\t\t\t\t\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\t\t\n\t\t\t\tposGlob = float4(UNITY_MATRIX_MV[0].w, UNITY_MATRIX_MV[1].w, UNITY_MATRIX_MV[2].w,0);\n\t\t\t\tfloat3x3 r=transpose((float3x3)UNITY_MATRIX_MV);\n\t\t\t\tfloat3x3 m;\n\t\t\t\tm[2]=normalize(mul(r,(float3)posGlob));\n\t\t\t\tm[1]=normalize(cross(m[2],float3(0.0, 1.0, 0.0)));\n\t\t\t\tm[0]=normalize(cross(m[1],m[2]));\n\t\t\t\to.uv1 = mul(transpose(m), (float3)v.vertex);\n            \to.vertex = mul(UNITY_MATRIX_MVP, float4(o.uv1, 1.0));\n\t\t\t\t\n\t\t\t\t#if UNITY_5_0\n\t\t\t\tUNITY_TRANSFER_FOG(o,o.vertex);\n\t\t\t\t#endif\n\t\t\t\treturn o;\n\t\t\t}\n\n\t\t\t// animated noise\n\t\t\tfixed4 hash4(fixed4 n) { return frac(sin(n)*(fixed)753.5453123); }\n\n\t\t\t// mix noise for alive animation\n\t\t\tfixed noise4q(fixed4 x)\n\t\t\t{\n\t\t\t\tfixed4 n3 = fixed4(0,0.25,0.5,0.75);\n\t\t\t\tfixed4 p2 = floor(x.wwww+n3);\n\t\t\t\tfixed4 b = floor(x.xxxx +n3) + floor(x.yyyy +n3)*157.0 + floor(x.zzzz +n3)*113.0;\n\t\t\t\tfixed4 p1 = b + frac(p2*0.00390625)*fixed4(164352.0, -164352.0, 163840.0, -163840.0);\n\t\t\t\tp2 = b + frac((p2+1)*0.00390625)*fixed4(164352.0, -164352.0, 163840.0, -163840.0);\n\t\t\t\tfixed4 f1 = frac(x.xxxx+n3);\n\t\t\t\tfixed4 f2 = frac(x.yyyy+n3);\n\t\t\t\t\n\t\t\t\tfixed4 n1 = fixed4(0,1.0,157.0,158.0);\n\t\t\t\tfixed4 n2 = fixed4(113.0,114.0,270.0,271.0);\t\t\n\t\t\t\tfixed4 vs1 = lerp(hash4(p1), hash4(n1.yyyy+p1), f1);\n\t\t\t\tfixed4 vs2 = lerp(hash4(n1.zzzz+p1), hash4(n1.wwww+p1), f1);\n\t\t\t\tfixed4 vs3 = lerp(hash4(p2), hash4(n1.yyyy+p2), f1);\n\t\t\t\tfixed4 vs4 = lerp(hash4(n1.zzzz+p2), hash4(n1.wwww+p2), f1);\t\n\t\t\t\tvs1 = lerp(vs1, vs2, f2);\n\t\t\t\tvs3 = lerp(vs3, vs4, f2);\n\t\t\t\t\n\t\t\t\tvs2 = lerp(hash4(n2.xxxx+p1), hash4(n2.yyyy+p1), f1);\n\t\t\t\tvs4 = lerp(hash4(n2.zzzz+p1), hash4(n2.wwww+p1), f1);\n\t\t\t\tvs2 = lerp(vs2, vs4, f2);\n\t\t\t\tvs4 = lerp(hash4(n2.xxxx+p2), hash4(n2.yyyy+p2), f1);\n\t\t\t\tfixed4 vs5 = lerp(hash4(n2.zzzz+p2), hash4(n2.wwww+p2), f1);\n\t\t\t\tvs4 = lerp(vs4, vs5, f2);\n\t\t\t\tf1 = frac(x.zzzz+n3);\n\t\t\t\tf2 = frac(x.wwww+n3);\n\t\t\t\t\n\t\t\t\tvs1 = lerp(vs1, vs2, f1);\n\t\t\t\tvs3 = lerp(vs3, vs4, f1);\n\t\t\t\tvs1 = lerp(vs1, vs3, f2);\n\t\t\t\t\n\t\t\t\treturn dot(vs1,0.25);\n\t\t\t}\n\t\t\t\t\t\n\t\t\tfloat RayProj;\n\t\t\tfloat sqRadius; // sphere radius\n\t\t\tfloat fragTime;\n\t\t\tfloat sphere; // sphere distance\n\t\t\tfloat3 surfase; // position on surfase\n\n\t\t\t// body of a star\n\t\t\tfixed noiseSpere(float zoom, float3 subnoise, float anim)\n\t\t\t{\n\t\t\t\tfixed s = 0.0;\n\n\t\t\t\tif (sphere <sqRadius) {\n\t\t\t\t\tif (_Detail>0.0) s = noise4q(fixed4(surfase*zoom*3.6864 + subnoise, fragTime*_SpeedHi))*0.625;\n\t\t\t\t\tif (_Detail>1.0) s =s*0.85+noise4q(fixed4(surfase*zoom*61.44 + subnoise*3.0, fragTime*_SpeedHi*3.0))*0.125;\n\t\t\t\t\tif (_Detail>2.0) s =s*0.94+noise4q(fixed4(surfase*zoom*307.2 + subnoise*5.0, anim*5.0))*0.0625;//*0.03125;\n\t\t\t\t\tif (_Detail>3.0) s =s*0.98+noise4q(fixed4(surfase*zoom*600.0 + subnoise*6.0, fragTime*_SpeedLow*6.0))*0.03125;\n\t\t\t\t\tif (_Detail>4.0) s =s*0.98+noise4q(fixed4(surfase*zoom*1200.0 + subnoise*9.0, fragTime*_SpeedLow*9.0))*0.01125;\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t}\n\n\t\t\tfixed4 frag (v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat invz =1/_Zoom;\n\t\t\t\t_Radius*=invz;\n\t\t\t\tfragTime=_Time.x*10.0;\n\t\t\t\tposGlob = float4(UNITY_MATRIX_MV[0].w, UNITY_MATRIX_MV[1].w, UNITY_MATRIX_MV[2].w,0);\n\t\t\t\tfloat3x3 m = (float3x3)UNITY_MATRIX_MV;\n\t\t\t\tfloat3 ray = normalize(mul(m, i.uv1) + posGlob.xyz);\n\t\t\t\tm = transpose((float3x3)UNITY_MATRIX_V);\n\n\t\t\t\tRayProj = dot(ray, (float3)posGlob);\n\t\t\t\tfloat sqDist=dot((float3)posGlob, (float3)posGlob);\n\t\t\t\tsphere = sqDist - RayProj*RayProj;\n\t\t\t\tsqRadius = _Radius*_Radius;\n\t\t\t\tif (RayProj<=0.0) sphere=sqRadius;\n\t\t\t\tfloat3 pr = ray*abs(RayProj) - (float3)posGlob;\n\t\t\t\t\n\t\t\t\tif (sqDist<=sqRadius) {\n\t\t\t\t\tsurfase=-posGlob;\n\t\t\t\t\tsphere=sqDist;\n\t\t\t\t} else if (sphere <sqRadius) {\n\t\t\t\t\tfloat l1 = sqrt(sqRadius - sphere);\n\t\t\t\t\tsurfase = mul(m,pr - ray*l1);\n\t\t\t\t} else {\n\t\t\t\t\tsurfase=(float3)0;\n\t\t\t\t}\n\n\t\t\t\tfixed4 col = fixed4(0,0,0,0);\n\n\t\t\t\tif (_Detail >= 1.0) {\n\t\t\t\t\tfloat s1 = noiseSpere(0.5*_Zoom, float3(45.78, 113.04, 28.957)*_Seed, fragTime*_SpeedLow);\n\t\t\t\t\ts1 = pow(s1*2.4, 2.0);\n\t\t\t\t\tfloat s2 = noiseSpere(4.0*_Zoom, float3(83.23, 34.34, 67.453)*_Seed, fragTime*_SpeedHi);\n\t\t\t\t\ts2 = s2*2.2;\n\n\t\t\t\t\tcol.xyz = fixed3(lerp((float3)_Color, (float3)_Light, pow(s1, 60.0))*s1);\n\t\t\t\t\tcol.xyz += fixed3(lerp(lerp((float3)_Base, (float3)_Dark, s2*s2), (float3)_Light, pow(s2, 10.0))*s2);\n\t\t\t\t}\n\n\t\t\t\tfixed c = length(pr)*_Zoom;\n\t\t\t\tpr = normalize(mul(m, pr));//-ray;\n\t\t\t\tfixed s = max(0.0, (1.0 - abs(_Radius*_Zoom - c) / _RayString));//*RayProj;\n\t\t\t\tfixed nd = noise4q(float4(pr+float3(83.23, 34.34, 67.453)*_Seed, -fragTime*_SpeedRing + c))*2.0;\n\t\t\t\tnd = pow(nd, 2.0);\n\t\t\t\tfixed dr=1.0;\n\t\t\t\tif (sphere < sqRadius) dr = sphere / sqRadius;\n\t\t\t\tpr*=10.0;\n\t\t\t\tfixed n = noise4q(float4(pr+ float3(83.23, 34.34, 67.453)*_Seed, -fragTime*_SpeedRing + c))*dr;\n\t\t\t\tpr*=5.0;\n\t\t\t\tfixed ns = noise4q(float4(pr+ float3(83.23, 34.34, 67.453)*_Seed, -fragTime*_SpeedRay + c))*2.0*dr;\n\t\t\t\tif (_Detail>=3.0) {\n\t\t\t\t\tpr *= 3.0;\n\t\t\t\t\tns = ns*0.5+noise4q(float4(pr+ float3(83.23, 34.34, 67.453)*_Seed, -fragTime*_SpeedRay + 0))*dr;\n\t\t\t\t}\n\t\t\t\tn = pow(n, _Rays)*pow(nd,_RayRing)*ns;\n\t\t\t\tfixed s3 = pow(s, _Glow) + pow(s, _RayGlow)*n;\n\n\t\t\t\tif (sphere < sqRadius) col.w = 1.0-s3*dr;\n\t\t\t\tif (sqDist>sqRadius)\n\t\t\t\t\tcol.xyz = col.xyz+lerp((fixed3)_Ray, (fixed3)_RayLight, s3*s3*s3)*s3; //pow(s3, 3.0)\n\t\t\t\t\n\t\t\t\tcol = clamp(col, 0, 1);\n\n#if UNITY_5_0\n\t\t\t\t// apply fog\n\t\t\t\tUNITY_APPLY_FOG(i.fogCoord, col);\n#endif\n\t\t\t\treturn col;\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}