{
    "Shader": {
        "info": {
            "date": "1659873563",
            "description": "Simple fast ray tracing with many simplifications",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt3yWM",
            "likes": 12,
            "name": "Simple not accurate ray tracing",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "shadow",
                "antialiasing",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "mireq",
            "viewed": 445
        },
        "renderpass": [
            {
                "code": "// Constants\n#if HW_PERFORMANCE==1\n#define AA 2\n#else\n#define AA 1\n#endif\n\n#define M_PI 3.141592654\n#define MAX_REFLECTIONS 3\n#define MAX_DIST 10000.0\n\n// Render single item color\n#define renderItem(iName, sName, data) \\\n\tresult = iName(rayOrigin, rayDirection, data); \\\n\tif (result.dist > 0.00001 && result.dist <= dist) { \\\n\t\tfragColor = vec4(sName(rayOrigin, rayDirection, result), 1.0); \\\n\t\tdist = result.dist; \\\n\t}\n\n\n// Calculate reflected ray\n#define calcReflect(iName, rName, data) \\\n\tresult = iName(reflectOrigin, reflectDirection, data); \\\n\tif (result.dist > 0.00001 && result.dist <= dist) { \\\n\t\treflectStrength = rName(reflectOrigin, reflectDirection, result); \\\n\t\trayOrigin = reflectOrigin + reflectDirection * result.dist; \\\n\t\trayDirection = reflect(reflectDirection, result.norm); \\\n\t\tdist = result.dist; \\\n\t}\n\n\n// Scene definition\nconst vec4 spherePos = vec4(-0.9, 0.5, 1.0, 0.5);\nconst vec4 glassSpherePos = vec4(0.0, 0.5, 0.5, 0.5);\n\nconst vec3 lightAmbientIntensity = vec3(0.2, 0.2, 0.2);\nconst vec3 lightDiffuseIntensity = vec3(0.4, 0.4, 0.4);\nconst vec3 lightDiffuseDirection = normalize(vec3(1.0, 1.0, -1.0));\n\n// Index of refraction\nconst float ior = 1.4;\n\n\nstruct IntersectResult\n{\n\tfloat dist; // Distance from ray origin, negative - not intersecting\n\tvec3 norm; //Normal vector\n};\n\n\n// Sphere intersection (from outside and from inside)\nIntersectResult iSphereUniversal(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sphere, in bool outside) {\n\tvec3 oMinusC = rayOrigin - sphere.xyz;\n\tfloat b = dot(rayDirection, oMinusC);\n\tfloat c = dot(oMinusC, oMinusC) - sphere.w * sphere.w;\n\tfloat delta = b * b - c;\n\n\tif (delta < 0.0) {\n\t\treturn IntersectResult(-1.0, vec3(0.0));\n\t}\n\n\tfloat dist = -b;\n\tif (outside) {\n\t\tdist -= sqrt(delta);\n\t}\n\telse {\n\t\tdist += sqrt(delta);\n\t}\n\tvec3 nor = normalize((rayOrigin + rayDirection * dist) - sphere.xyz);\n\treturn IntersectResult(dist, nor);\n}\n\n\nIntersectResult iSphere(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sphere) {\n\treturn iSphereUniversal(rayOrigin, rayDirection, sphere, true);\n}\n\nIntersectResult iSphereInside(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sphere) {\n\treturn iSphereUniversal(rayOrigin, rayDirection, sphere, false);\n}\n\n\n// Sphere shading\nvec3 sSphere(in vec3 rayOrigin, in vec3 rayDirection, in IntersectResult res)\n{\n\t// Difuse attentuation\n\tfloat attentuation = dot(res.norm, lightDiffuseDirection);\n\t// Diffuse intensity\n\tvec3 diffuse = lightDiffuseIntensity * clamp(attentuation, 0.0, 1.0);\n\t// Combined with ambient light\n\treturn lightAmbientIntensity + diffuse;\n}\n\n\n// Reflection intensity calculation\nfloat rSphere(in vec3 rayOrigin, in vec3 rayDirection, in IntersectResult res)\n{\n\t// Fresnel factor\n\tfloat fresnel = pow(max(1.0 - dot(res.norm, -rayDirection), 0.0), 3.5);\n\t// Constant factor\n\tconst float metalic = 0.05;\n\t// Combined reflection intensity\n\treturn clamp(fresnel + metalic, 0.0, 1.0);\n}\n\n\n// Plane intersection (position is y coordinate)\nIntersectResult iPlane(in vec3 rayOrigin, in vec3 rayDirection, in float position)\n{\n\treturn IntersectResult(\n\t\t(position - rayOrigin.y) / rayDirection.y, // Plane in height y\n\t\tvec3(0.0, 1.0, 0.0) // Normal always facing up\n\t);\n}\n\n\n// Shade plane\nvec3 sPlane(in vec3 rayOrigin, in vec3 rayDirection, in IntersectResult res)\n{\n\t// Intersection position\n\tvec3 pos = rayOrigin + rayDirection * res.dist;\n\t// Distance to sphere\n\tfloat dist = length(pos - spherePos.xyz);\n\t// Apparent angle size - https://www.neoprogrammics.com/sphere_angular_diameter/\n\tfloat angle = 2.0 * acos(sqrt(dist*dist - spherePos.w*spherePos.w) / dist);\n\t// (2*pi*(1-cos(angle/2)))/(4*pi)\n\tfloat shadow = cos(angle / 2.0); // Shadow factor\n\t\n\t// Same calculation for second sphere\n\tdist = length(pos - glassSpherePos.xyz);\n\tangle = 2.0 * acos(sqrt(dist*dist - glassSpherePos.w * glassSpherePos.w) / dist);\n\n\t// (Not correctly) combined shadow factor\n\tshadow = shadow * cos(angle / 2.0);\n\n\t// Checker color\n\tfloat color = mod(floor(pos.x) + floor(pos.z), 2.0);\n\t// Combined grayed checker collor disappearing in distance 20-100\n\treturn vec3(color * 0.8 + 0.1) * shadow + smoothstep(20.0, 100.0, res.dist);\n}\n\n\n// Constant reflection factor\nfloat rPlane(in vec3 rayOrigin, in vec3 rayDirection, in IntersectResult res)\n{\n\treturn 0.2;\n}\n\n\nIntersectResult iBackground(in vec3 ro, in vec3 rd, in float dummy)\n{\n\t// Maximal distance, any normal direction\n\treturn IntersectResult(MAX_DIST, rd);\n}\n\n\nvec3 sBackground(in vec3 ro, in vec3 rd, in IntersectResult res)\n{\n\t// Formula from here https://www.shadertoy.com/view/NtjcW3\n\treturn cos(rd) * vec3(.8, .7, 1.1) * smoothstep(0.0, 0.1, rd.y) + vec3(smoothstep(-0.1, 0.0, -rd.y));\n}\n\n\n// Construct camera matrix\nmat3 lookAt(in vec3 cameraPos, in vec3 lookAtPoint)\n{\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // Forward vector\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // Right vector\n\tvec3 cu = normalize(cross(cd, cr)); //Top vector\n\treturn mat3(cr, cu, cd);\n}\n\n\nvec4 rayReflect(inout vec3 reflectOrigin, inout vec3 reflectDirection)\n{\n\t// Output color and intensity (default zero)\n\tvec4 fragColor = vec4(0.0);\n\n\t// Macro renderItem needs reflectOrigin and reflectDirection names\n\tvec3 rayOrigin = reflectOrigin;\n\tvec3 rayDirection = reflectDirection;\n\tIntersectResult result;\n\tfloat dist = MAX_DIST;\n\n\t// Default value - no reflection (if don't hit any sufrace)\n\tfloat reflectStrength = 0.0;\n\n\t// Calculate reflection strength and ray direction\n\tcalcReflect(iPlane, rPlane, 0.0);\n\tcalcReflect(iSphere, rSphere, spherePos);\n\tcalcReflect(iSphere, rSphere, glassSpherePos);\n\n\tif (reflectStrength < 0.0001) { // Too low strength\n\t\treturn fragColor;\n\t}\n\n\t// Reset distance\n\tdist = MAX_DIST;\n\n\t// Render from new ray position\n\trenderItem(iSphere, sSphere, spherePos);\n\trenderItem(iSphere, sSphere, glassSpherePos);\n\trenderItem(iPlane, sPlane, 0.0);\n\trenderItem(iBackground, sBackground, 0.0);\n\n\t// Update ray (propagate to outer function)\n\treflectOrigin = rayOrigin;\n\treflectDirection = rayDirection;\n\n\t// Output color and intensity\n\treturn vec4(fragColor.rgb, reflectStrength);\n}\n\n\nvec4 rayRefract(inout vec3 refractOrigin, inout vec3 refractDirection)\n{\n\t// Similar to rayReflect\n\tvec3 rayOrigin = refractOrigin;\n\tvec3 rayDirection = refractDirection;\n\n\tvec4 fragColor = vec4(0.0);\n\n\tIntersectResult result;\n\tfloat dist = MAX_DIST;\n\n\t// VÃ½poÄet vzdialenosti k objektom\n\tresult = iSphere(rayOrigin, rayDirection, spherePos);\n\tif (result.dist > 0.00001) { dist = min(dist, result.dist); }\n\tresult = iPlane(rayOrigin, rayDirection, 0.0);\n\tif (result.dist > 0.00001) { dist = min(dist, result.dist); }\n\n\tfloat refractStrength = 0.0;\n\n\tresult = iSphere(rayOrigin, rayDirection, glassSpherePos);\n\tif (result.dist > 0.0001 && result.dist < dist) {\n\t\t// Hardcode strength for sphere\n\t\trefractStrength = 0.8;\n\n\t\t// Compute new ray (inside sphere)\n\t\trefractOrigin = rayOrigin + rayDirection * result.dist;\n\t\t// Refraction from air to glass\n\t\trefractDirection = refract(rayDirection, result.norm, 1.0 / ior);\n\n\t\t// Compute intersection inside sphere\n\t\tresult = iSphereInside(refractOrigin, refractDirection, glassSpherePos);\n\t\t\n\t\t// Compute new ray outside sphere\n\t\trefractOrigin = refractOrigin + refractDirection * result.dist;\n\t\t// Refraction from glass to air\n\t\trefractDirection = refract(refractDirection, -result.norm, ior / 1.0);\n\n\t\t// Update ray\n\t\trayOrigin = refractOrigin;\n\t\trayDirection = refractDirection;\n\n\t\t// Reset distance\n\t\tdist = MAX_DIST;\n\n\t\t// Render other objects\n\t\trenderItem(iSphere, sSphere, spherePos);\n\t\trenderItem(iPlane, sPlane, 0.0);\n\t\trenderItem(iBackground, sBackground, 0.0);\n\t}\n\n\treturn vec4(fragColor.rgb, refractStrength);\n}\n\n\nvec4 rayTrace(in vec3 rayOrigin, in vec3 rayDirection)\n{\n\tvec4 fragColor = vec4(0.0);\n\n\t// Max distance on beginning\n\tfloat dist = MAX_DIST;\n\tIntersectResult result;\n\n\t// Render objects\n\trenderItem(iBackground, sBackground, 0.0);\n\trenderItem(iPlane, sPlane, 0.0);\n\trenderItem(iSphere, sSphere, spherePos);\n\trenderItem(iSphere, sSphere, glassSpherePos);\n\n\t// Secondary rays used to compute reflection and refraction\n\tvec3 reflectOrigin = rayOrigin;\n\tvec3 reflectDirection = rayDirection;\n\tfloat reflectStrength = 1.0;\n\tvec3 refractOrigin = rayOrigin;\n\tvec3 refractDirection = rayDirection;\n\tfloat refractStrength = 1.0;\n\n\t// Compute reflection / refraction\n\tfor (int i = 0; i < MAX_REFLECTIONS; i++) {\n\t\t// Color and strength calculated\n\t\tvec4 reflectColor = rayReflect(reflectOrigin, reflectDirection);\n\t\tvec4 refractColor = rayRefract(refractOrigin, refractDirection);\n\t\treflectStrength *= reflectColor.a;\n\t\trefractStrength *= refractColor.a;\n\t\t// Break cycle if strength is too low\n\t\tif (reflectStrength < 0.001 && refractStrength < 0.001) {\n\t\t\tbreak;\n\t\t}\n\t\t// Mix colors\n\t\tfragColor.rgb = mix(fragColor.rgb, refractColor.rgb, refractStrength);\n\t\tfragColor.rgb += reflectColor.rgb * reflectStrength;\n\t}\n\n\treturn fragColor;\n}\n\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Calculate coordinates in interval [-0.5, 0.5]\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n\n\t// Camera properties\n\tvec3 lookAtPoint = vec3(sin(iTime / 3.5) * 0.5 - 0.2, 0.5, 0.75 + sin(iTime / 11.0) * 0.5);\n\tvec3 rayOrigin = vec3(sin(iTime) * 2.0, sin(iTime / 2.0) * 0.5 + 0.75, cos(iTime) * 2.0);\n\n\t// Calculate camera matrix\n\tmat3 cameraMatrix = lookAt(rayOrigin, lookAtPoint);\n\n\t// Ray direction and zoom factor\n\tvec3 rayDirection = cameraMatrix * normalize(vec3(uv, 0.8));\n\n\tfragColor = rayTrace(rayOrigin, rayDirection);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = vec4(0.0);\n\n\t// Antialiasing\n\tconst float fraction = 1.0 / float(AA);\n\tconst float fraction2 = fraction / float(AA);\n\tfor (int i = 0; i < AA; i++) {\n\t\tfor (int j = 0; j < AA; j++) {\n\t\t\tvec4 color = vec4(0.0);\n\t\t\tvec2 shift = vec2(\n\t\t\t\tfloat(i) * fraction + float(AA - j - 1) * fraction2,\n\t\t\t\tfloat(j) * fraction + float(i) * fraction2\n\t\t\t);\n\t\t\trender(color, fragCoord + shift);\n\t\t\tfragColor += clamp(color, 0.0, 1.0);\n\t\t}\n\t}\n\n\tfragColor = fragColor / float(AA * AA);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}