{
    "Shader": {
        "info": {
            "date": "1649279372",
            "description": "rainbow band man + signed distance fields v1.1b",
            "flags": 32,
            "hasliked": 0,
            "id": "NlSyz1",
            "likes": 0,
            "name": "Rainbow Band Man SDF",
            "published": 3,
            "tags": [
                "sdf",
                "animated",
                "distance",
                "field",
                "signeddistancefield",
                "signed",
                "encode",
                "encoder"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 112
        },
        "renderpass": [
            {
                "code": "// A very simplistic approach at rendering 2-dimensional signed distance fields.\n// It is iterative and at most has a O(width > height ? width : height) runtime.\n// Can be used to create outlines, shadows, glow and other things.\n\n// Buffers:\n// A - Shape Input\n// B - Shape Postprocessing\n// C - Signed Distance Field Generator\n// D - Signed Distance Field Postprocessing\n// Image - Final Render\n\nconst vec3 glowOuterColor = vec3(1., 1., 1.);\nconst float glowOuterRadius = 100.0;\n\n// #define DEBUG\nconst float debugRange = 256.0;\n\nfloat drawBar(in float x, in float x0, in float r){\n    float px = 1./iResolution.y;\n    // px*=2.;\n    return smoothstep(.0, px , abs(x-x0)-r/2. );\n}\nfloat drawBar(in float x, in float x0){\n    return drawBar(x,x0,0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    #ifdef DEBUG\n    fragColor = abs(texture(iChannel0, uv).rgba / debugRange);\n    return;\n    #endif\n    \n    float v = texture(iChannel0, uv).r;\n    fragColor.rgb = vec3(0.5, 0.5, 0.5);\n    \n    vec4 bufA = texture(iChannel3, uv);\n    if (bufA.a > 0.0) {\n        fragColor.rgb = bufA.rgb;\n    }\n    \n    float g = v / glowOuterRadius;\n    g = clamp(g, 0., 1.);\n    if (g > 0.)\n        fragColor.rgb = mix(glowOuterColor, fragColor.rgb, g);\n        \n        \n    // Normalized pixel coordinates (from 0 to 1)\n    uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.333;\n    vec3 col = vec3(0.);\n    float b = v/200.;\n    bool inside=false;\n    if (b<0.)inside=true;\n    \n    float draw=1.;\n    float drawcol = 0.;\n    float movespeed = -0.05*SPEED;\n    for (float i=0.0;i<1.;i+=0.1){\n        draw *= drawBar(i,b);\n    }\n    b += mod(iTime*movespeed,0.1);\n    draw = smoothstep(0.0,0.02*length(uv),nsin((b)*20.*PI-0.5*PI));\n    col = vec3(draw);\n    vec3 neon = 1.-col;\n    \n    float grad = 1.-mod(b,0.1)*10.;\n    float timestep = floor(-iTime*10.*SPEED);\n    float band = floor(b*10.+timestep)*0.13;\n    // col += band;\n    col *= hsv2rgb_smooth(vec3(band,1.,1.));\n    // col += grad*0.3;\n    // col /= .8+grad;\n    // col *= 1.2-grad;\n    // col = vec3(grad*grad+(1.-grad));\n    \n    // deboog\n    // if (uv.x<sin(iTime*0.33)) col = vec3(b);\n    \n    if (BUZZ) {\n        col *= 0.3;\n        col -= grad*grad * (1.-grad) * 3.;\n        neon *= hsv2rgb_smooth(vec3(band,1.,1.));\n        neon *= neon;\n        col += neon*5.;\n        float filament;\n        for (int i=1;i<3;i++){\n            filament = smoothstep(0.0,0.003*length(uv),nsin((b)*20.*PI-0.5*PI));\n            col += vec3(1.-filament)*float(i)/2.;\n            b += (noise(vec3(float(i)+uv*20.*float(i+1),iTime))*0.02-0.01) * (0.2+length(uv));\n        }\n    }\n    \n    if (inside) col*=0.;\n    if (inside) col=texture(iChannel3,fragCoord/iResolution.xy).rgb;\n    \n    if (!inside) col *= nclamp(iTime*0.25);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define INPUT_VIDEO\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n    // greenscreen\n    vec4 pickcol = vec4(0.051,0.639,0.145,1.);\n    float dist = distance(col, pickcol) * 2.;\n    const float distMin = 0.3;\n    const float distRange = 0.1;\n    dist -= distMin;\n    dist /= distRange;\n    dist = clamp(dist, 0., 1.);\n    col.rgb -= 1.0 - dist;\n\n    fragColor.rgb = col.rgb;\n    fragColor.a = (dist > 0.1 ? 1.0 : 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Improved iterative Signed Distance Field encoder based on V1:\n//  https://www.shadertoy.com/view/XlfBDl\n//\n// It's a really simple approach at doing this and most likely\n//  can be done much faster by splitting horizontal and vertical\n//  passes and by using loops for testing for distances. There is\n//  also a UV channel stored within the blue and alpha of the\n//  result, allowing higher precision if necessary.\n//\n// Output definition:\n// .r  = Positive Distance\n// .g  = Negative Distance\n// .ba = UV of nearest edge\n\n// Parameters\nconst float threshold = 0.1;\n\n#define POSSIBLY_INFINITE 18446744073709551616.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame == 0) {\n        fragColor = vec4(POSSIBLY_INFINITE);\n        return;\n    }\n    \n    vec2 uvStep = 1.0 / iResolution.xy;\n    vec3 uvStep0 = vec3(uvStep.x, uvStep.y, 0.);\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    bool inside = false;\n    \n    // Test if we are in- or outside of the shape.\n    float alpha = texture(iChannel1, uv).a;\n    if (alpha > threshold) {\n        inside = true;\n        fragColor.r = 0.0;\n        fragColor.ba = uv;\n    } else {\n        inside = false;\n        fragColor.g = 0.0;\n        fragColor.ba = uv;\n    }\n    \n    if (inside) { // Negative Values\n        vec3 test = vec3(POSSIBLY_INFINITE, POSSIBLY_INFINITE, POSSIBLY_INFINITE);\n        vec3 iU, iD, iL, iR;\n        iU = texture(iChannel0, uv - uvStep0.zy).gba;\n        iD = texture(iChannel0, uv + uvStep0.zy).gba;\n        iL = texture(iChannel0, uv - uvStep0.xz).gba;\n        iR = texture(iChannel0, uv + uvStep0.xz).gba;        \n    \tif (iU.r < test.r) { test = iU; }\n    \tif (iD.r < test.r) { test = iD; }\n    \tif (iL.r < test.r) { test = iL; }\n    \tif (iR.r < test.r) { test = iR; }\n        \n        vec3 m = vec3(0.4142135623730950488016887242097, 0, 0);\n        iU = texture(iChannel0, uv - uvStep0.xy).gba;\n        iD = texture(iChannel0, uv - vec2(-uvStep0.x, uvStep0.y)).gba;\n        iL = texture(iChannel0, uv + uvStep0.xy).gba;\n        iR = texture(iChannel0, uv + vec2(uvStep0.x, -uvStep0.y)).gba;\n    \tif (iU.r < test.r) { test = iU + m; }\n    \tif (iD.r < test.r) { test = iD + m; }\n    \tif (iL.r < test.r) { test = iL + m; }\n    \tif (iR.r < test.r) { test = iR + m; }\n        \n        if (test.r < POSSIBLY_INFINITE) {\n            fragColor.g = test.r + 1.;//distance(fragCoord, test.gb / uvStep) + 0.5;\n            fragColor.ba = test.gb;\n        }\n    } else { // Positive Values\n        vec3 test = vec3(POSSIBLY_INFINITE, POSSIBLY_INFINITE, POSSIBLY_INFINITE);\n        vec3 iU, iD, iL, iR;\n        iU = texture(iChannel0, uv - uvStep0.zy).rba;\n        iD = texture(iChannel0, uv + uvStep0.zy).rba;\n        iL = texture(iChannel0, uv - uvStep0.xz).rba;\n        iR = texture(iChannel0, uv + uvStep0.xz).rba;\n        \n    \tif (iU.r < test.r) { test = iU; }\n    \tif (iD.r < test.r) { test = iD; }\n    \tif (iL.r < test.r) { test = iL; }\n    \tif (iR.r < test.r) { test = iR; }\n        \n        vec3 m = vec3(0.4142135623730950488016887242097, 0, 0);\n        iU = texture(iChannel0, uv - uvStep0.xy).rba;\n        iD = texture(iChannel0, uv - vec2(-uvStep0.x, uvStep0.y)).rba;\n        iL = texture(iChannel0, uv + uvStep0.xy).rba;\n        iR = texture(iChannel0, uv + vec2(uvStep0.x, -uvStep0.y)).rba;\n    \tif (iU.r < test.r) { test = iU + m; }\n    \tif (iD.r < test.r) { test = iD + m; }\n    \tif (iL.r < test.r) { test = iL + m; }\n    \tif (iR.r < test.r) { test = iR + m; }\n        \n        if (test.r < POSSIBLY_INFINITE) {\n            fragColor.r = test.r + 1.;//distance(fragCoord, test.gb / uvStep) + 0.5;\n            fragColor.ba = test.gb;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.r - col.g);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define BUZZ false\n#define PI 3.14159265359\n#define SPEED 0.5\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat nsin(in float x){\n    return sin(x)*0.5+0.5;\n}\n\nfloat nclamp(in float x){\n    return clamp(0.,1.,x);\n}\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}