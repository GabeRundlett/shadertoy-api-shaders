{
    "Shader": {
        "info": {
            "date": "1575778434",
            "description": "I modeled the \"Wobble Chess Set\" by Umbra. \nProduct Link: https://www.umbra.com/products/wobble-chess\nImage: https://images-na.ssl-images-amazon.com/images/I/71bGxoCicpL._SL1500_.jpg",
            "flags": 0,
            "hasliked": 0,
            "id": "tsGSDc",
            "likes": 15,
            "name": "Wobble Chess",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefields",
                "primitives",
                "chess"
            ],
            "usePreview": 0,
            "username": "g4b0r",
            "viewed": 595
        },
        "renderpass": [
            {
                "code": "//\n// The MIT License\n// Copyright Â© 2019 Gabor Nagy\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// I modeled the \"Wobble Chess Set\" by Umbra. \n// Product Link: https://www.umbra.com/products/wobble-chess\n// Image: https://images-na.ssl-images-amazon.com/images/I/71bGxoCicpL._SL1500_.jpg\n//\n// I own this physical chess board, and I wanted to see if I could render\n// it real-time with ray-marching techniques.\n//\n// On my Mac Mini and a Radion RX Vega 56 eGPU, I'm getting 60fps at 800x450.\n// Each chess piece is only placed on the map one time, and using repetition\n// and symetry to get the full chess set on the board. Without that trick\n// I was not able to get real-time performnce.\n//\n// Credits:\n// Based on concepts and code written by Inigo Quilez. Thanks for all of the\n// articles and code you have made public!\n//\n// 3D wood texture by Otavio Good. \n// Taken from: https://www.shadertoy.com/view/ldscDM\n//\n\n#define AA 1\n#define skyColor vec3(.7,.7,.9)\n\n//-------------------- Start: wood texture\nfloat repramp(in float x) {\n\treturn pow(sin(x)*0.5+0.5, 8.0) + cos(x)*0.7 + 0.7;\n}\n\n// Noise generator from https://otaviogood.github.io/noisegen/\n// Params: 3D, Seed 1, Waves 128, Octaves 7, Smooth 1\nfloat NoiseGen(in vec3 p) {\n    float wave0 = 0.0;\n    float wave1 = 0.0;\n    wave0 += sin(dot(p, vec3(-1.316, 0.918, 1.398))) * 0.0783275458;\n    wave1 += sin(dot(p, vec3(0.295, -0.176, 2.167))) * 0.0739931495;\n    wave0 += sin(dot(p, vec3(-0.926, 1.445, 1.429))) * 0.0716716966;\n    wave1 += sin(dot(p, vec3(-1.878, -0.174, 1.258))) * 0.0697839187;\n    wave0 += sin(dot(p, vec3(-1.995, 0.661, -0.908))) * 0.0685409863;\n    wave1 += sin(dot(p, vec3(-1.770, 1.350, -0.905))) * 0.0630152419;\n    wave0 += sin(dot(p, vec3(2.116, -0.021, 1.161))) * 0.0625361712;\n    wave1 += sin(dot(p, vec3(0.405, -1.712, -1.855))) * 0.0567751048;\n    wave0 += sin(dot(p, vec3(1.346, 0.945, 1.999))) * 0.0556465603;\n    wave1 += sin(dot(p, vec3(-0.397, -0.573, 2.495))) * 0.0555747667;\n    wave0 += sin(dot(p, vec3(0.103, -2.457, -1.144))) * 0.0516322279;\n    wave1 += sin(dot(p, vec3(-0.483, -1.323, 2.330))) * 0.0513093320;\n    wave0 += sin(dot(p, vec3(-1.715, -1.810, -1.164))) * 0.0504567036;\n    wave1 += sin(dot(p, vec3(2.529, 0.479, 1.011))) * 0.0500811899;\n    wave0 += sin(dot(p, vec3(-1.643, -1.814, -1.437))) * 0.0480875812;\n    wave1 += sin(dot(p, vec3(1.495, -1.905, -1.648))) * 0.0458268348;\n    wave0 += sin(dot(p, vec3(-1.874, 1.559, 1.762))) * 0.0440084357;\n    wave1 += sin(dot(p, vec3(1.068, -2.090, 2.081))) * 0.0413624154;\n    wave0 += sin(dot(p, vec3(-0.647, -2.197, -2.237))) * 0.0401592830;\n    wave1 += sin(dot(p, vec3(-2.146, -2.171, -1.135))) * 0.0391682940;\n    wave0 += sin(dot(p, vec3(2.538, -1.854, -1.604))) * 0.0349588163;\n    wave1 += sin(dot(p, vec3(1.687, 2.191, -2.270))) * 0.0342888847;\n    wave0 += sin(dot(p, vec3(0.205, 2.617, -2.481))) * 0.0338465332;\n    wave1 += sin(dot(p, vec3(3.297, -0.440, -2.317))) * 0.0289423448;\n    wave0 += sin(dot(p, vec3(1.068, -1.944, 3.432))) * 0.0286404261;\n    wave1 += sin(dot(p, vec3(-3.681, 1.068, 1.789))) * 0.0273625684;\n    wave0 += sin(dot(p, vec3(3.116, 2.631, -1.658))) * 0.0259772492;\n    wave1 += sin(dot(p, vec3(-1.992, -2.902, -2.954))) * 0.0245830241;\n    wave0 += sin(dot(p, vec3(-2.409, -2.374, 3.116))) * 0.0245592756;\n    wave1 += sin(dot(p, vec3(0.790, 1.768, 4.196))) * 0.0244078334;\n    wave0 += sin(dot(p, vec3(-3.289, 1.007, 3.148))) * 0.0241328015;\n    wave1 += sin(dot(p, vec3(3.421, -2.663, 3.262))) * 0.0199736126;\n    wave0 += sin(dot(p, vec3(3.062, 2.621, 3.649))) * 0.0199230290;\n    wave1 += sin(dot(p, vec3(4.422, -2.206, 2.621))) * 0.0192399437;\n    wave0 += sin(dot(p, vec3(2.714, 3.022, 4.200))) * 0.0182510631;\n    wave1 += sin(dot(p, vec3(-0.451, 4.143, -4.142))) * 0.0181293526;\n    wave0 += sin(dot(p, vec3(-5.838, -0.360, -1.536))) * 0.0175114826;\n    wave1 += sin(dot(p, vec3(-0.278, -4.565, 4.149))) * 0.0170799341;\n    wave0 += sin(dot(p, vec3(-5.893, -0.163, -2.141))) * 0.0167655258;\n    wave1 += sin(dot(p, vec3(4.855, -4.153, 0.606))) * 0.0163155335;\n    wave0 += sin(dot(p, vec3(4.498, 0.987, -4.488))) * 0.0162770287;\n    wave1 += sin(dot(p, vec3(-1.463, 5.321, -3.315))) * 0.0162569125;\n    wave0 += sin(dot(p, vec3(-1.862, 4.386, 4.749))) * 0.0154338176;\n    wave1 += sin(dot(p, vec3(0.563, 3.616, -5.751))) * 0.0151952226;\n    wave0 += sin(dot(p, vec3(-0.126, 2.569, -6.349))) * 0.0151089405;\n    wave1 += sin(dot(p, vec3(-5.094, 4.759, 0.186))) * 0.0147947096;\n    wave0 += sin(dot(p, vec3(1.319, 5.713, 3.845))) * 0.0147035221;\n    wave1 += sin(dot(p, vec3(7.141, -0.327, 1.420))) * 0.0140573910;\n    wave0 += sin(dot(p, vec3(3.888, 6.543, 0.547))) * 0.0133309850;\n    wave1 += sin(dot(p, vec3(-1.898, -3.563, -6.483))) * 0.0133171360;\n    wave0 += sin(dot(p, vec3(1.719, 7.769, 0.340))) * 0.0126913718;\n    wave1 += sin(dot(p, vec3(-2.210, -7.836, 0.102))) * 0.0123746071;\n    wave0 += sin(dot(p, vec3(6.248, -5.451, 1.866))) * 0.0117861898;\n    wave1 += sin(dot(p, vec3(1.627, -7.066, -4.732))) * 0.0115417453;\n    wave0 += sin(dot(p, vec3(4.099, -7.704, 1.474))) * 0.0112591564;\n    wave1 += sin(dot(p, vec3(7.357, 3.788, 3.204))) * 0.0112252325;\n    wave0 += sin(dot(p, vec3(-2.797, 6.208, 6.253))) * 0.0107206906;\n    wave1 += sin(dot(p, vec3(6.130, -5.335, -4.650))) * 0.0105693992;\n    wave0 += sin(dot(p, vec3(5.276, -5.576, -5.438))) * 0.0105139072;\n    wave1 += sin(dot(p, vec3(9.148, 2.530, -0.383))) * 0.0103996383;\n    wave0 += sin(dot(p, vec3(3.894, 2.559, 8.357))) * 0.0103161113;\n    wave1 += sin(dot(p, vec3(-6.604, 8.024, -0.289))) * 0.0094066875;\n    wave0 += sin(dot(p, vec3(-5.925, 6.505, -6.403))) * 0.0089444733;\n    wave1 += sin(dot(p, vec3(9.085, 10.331, -0.451))) * 0.0069245599;\n    wave0 += sin(dot(p, vec3(-8.228, 6.323, -9.900))) * 0.0066251015;\n    wave1 += sin(dot(p, vec3(10.029, -3.802, 12.151))) * 0.0058122824;\n    wave0 += sin(dot(p, vec3(-10.151, -6.513, -11.063))) * 0.0057522358;\n    wave1 += sin(dot(p, vec3(-1.773, -16.284, 2.828))) * 0.0056578101;\n    wave0 += sin(dot(p, vec3(11.081, 8.687, -9.852))) * 0.0054614334;\n    wave1 += sin(dot(p, vec3(-3.941, -4.386, 16.191))) * 0.0054454253;\n    wave0 += sin(dot(p, vec3(-6.742, 2.133, -17.268))) * 0.0050050132;\n    wave1 += sin(dot(p, vec3(-10.743, 5.698, 14.975))) * 0.0048323955;\n    wave0 += sin(dot(p, vec3(-9.603, 12.472, 14.542))) * 0.0043264378;\n    wave1 += sin(dot(p, vec3(13.515, 14.345, 8.481))) * 0.0043208884;\n    wave0 += sin(dot(p, vec3(-10.330, 16.209, -9.742))) * 0.0043013736;\n    wave1 += sin(dot(p, vec3(-8.580, -6.628, 19.191))) * 0.0042005922;\n    wave0 += sin(dot(p, vec3(-17.154, 10.620, 11.828))) * 0.0039482427;\n    wave1 += sin(dot(p, vec3(16.330, 14.123, -10.420))) * 0.0038474789;\n    wave0 += sin(dot(p, vec3(-21.275, 10.768, -3.252))) * 0.0038320501;\n    wave1 += sin(dot(p, vec3(1.744, 7.922, 23.152))) * 0.0037560829;\n    wave0 += sin(dot(p, vec3(-3.895, 21.321, 12.006))) * 0.0037173885;\n    wave1 += sin(dot(p, vec3(-22.705, 2.543, 10.695))) * 0.0036484394;\n    wave0 += sin(dot(p, vec3(-13.053, -16.634, -13.993))) * 0.0036291121;\n    wave1 += sin(dot(p, vec3(22.697, -11.230, 1.417))) * 0.0036280459;\n    wave0 += sin(dot(p, vec3(20.646, 14.602, 3.400))) * 0.0036055008;\n    wave1 += sin(dot(p, vec3(5.824, -8.717, -23.680))) * 0.0035501527;\n    wave0 += sin(dot(p, vec3(6.691, 15.499, 20.079))) * 0.0035029508;\n    wave1 += sin(dot(p, vec3(9.926, -22.778, 9.144))) * 0.0034694278;\n    wave0 += sin(dot(p, vec3(-9.552, -27.491, 2.197))) * 0.0031359281;\n    wave1 += sin(dot(p, vec3(21.071, -17.991, -11.566))) * 0.0030453280;\n    wave0 += sin(dot(p, vec3(9.780, 1.783, 28.536))) * 0.0030251754;\n    wave1 += sin(dot(p, vec3(8.738, -18.373, 22.725))) * 0.0029960272;\n    wave0 += sin(dot(p, vec3(14.105, 25.703, -8.834))) * 0.0029840058;\n    wave1 += sin(dot(p, vec3(-24.926, -17.766, -4.740))) * 0.0029487709;\n    wave0 += sin(dot(p, vec3(1.060, -1.570, 32.535))) * 0.0027980099;\n    wave1 += sin(dot(p, vec3(-24.532, -19.629, -16.759))) * 0.0025538949;\n    wave0 += sin(dot(p, vec3(28.772, -21.183, -9.935))) * 0.0024494819;\n    wave1 += sin(dot(p, vec3(-28.413, 22.959, 8.338))) * 0.0024236674;\n    wave0 += sin(dot(p, vec3(-27.664, 22.197, 13.301))) * 0.0023965996;\n    wave1 += sin(dot(p, vec3(-27.421, 20.643, 18.713))) * 0.0023203498;\n    wave0 += sin(dot(p, vec3(18.961, -7.189, 35.907))) * 0.0021967023;\n    wave1 += sin(dot(p, vec3(-23.949, 4.885, 33.762))) * 0.0021727461;\n    wave0 += sin(dot(p, vec3(35.305, 8.594, 20.564))) * 0.0021689816;\n    wave1 += sin(dot(p, vec3(30.364, -11.608, -27.199))) * 0.0021357139;\n    wave0 += sin(dot(p, vec3(34.268, 26.742, 0.958))) * 0.0020807976;\n    wave1 += sin(dot(p, vec3(-26.376, -17.313, -32.023))) * 0.0020108850;\n    wave0 += sin(dot(p, vec3(31.860, -32.181, -2.834))) * 0.0019919601;\n    wave1 += sin(dot(p, vec3(25.590, 32.340, 21.381))) * 0.0019446179;\n    wave0 += sin(dot(p, vec3(-17.771, -23.941, 37.324))) * 0.0018898258;\n    wave1 += sin(dot(p, vec3(-38.699, 19.953, -22.675))) * 0.0018379538;\n    wave0 += sin(dot(p, vec3(-46.284, 11.672, -15.411))) * 0.0017980056;\n    wave1 += sin(dot(p, vec3(-32.023, -43.976, -7.378))) * 0.0016399251;\n    wave0 += sin(dot(p, vec3(-42.390, -21.165, -31.889))) * 0.0015752176;\n    wave1 += sin(dot(p, vec3(-18.949, -40.461, 39.107))) * 0.0015141244;\n    wave0 += sin(dot(p, vec3(-21.507, -5.939, -58.531))) * 0.0014339601;\n    wave1 += sin(dot(p, vec3(-51.745, -43.821, 9.651))) * 0.0013096306;\n    wave0 += sin(dot(p, vec3(39.239, 25.971, -52.615))) * 0.0012701774;\n    wave1 += sin(dot(p, vec3(-49.669, -35.051, -36.306))) * 0.0012661695;\n    wave0 += sin(dot(p, vec3(-49.996, 35.309, 38.460))) * 0.0012398870;\n    wave1 += sin(dot(p, vec3(27.000, -65.904, -36.267))) * 0.0011199347;\n    wave0 += sin(dot(p, vec3(-52.523, -26.557, 57.693))) * 0.0010856391;\n    wave1 += sin(dot(p, vec3(-42.670, 0.269, -71.125))) * 0.0010786551;\n    wave0 += sin(dot(p, vec3(-9.377, 64.575, -68.151))) * 0.0009468199;\n    wave1 += sin(dot(p, vec3(14.571, -29.160, 106.329))) * 0.0008019719;\n    wave0 += sin(dot(p, vec3(-21.549, 103.887, 36.882))) * 0.0007939609;\n    wave1 += sin(dot(p, vec3(-42.781, 110.966, -9.070))) * 0.0007473261;\n    wave0 += sin(dot(p, vec3(-112.686, 18.296, -37.920))) * 0.0007409259;\n    wave1 += sin(dot(p, vec3(71.493, 33.838, -96.931))) * 0.0007121903;\n    return wave0+wave1;\n}\n\nvec3 woodTexture(in vec3 p) {\n\tfloat rings = repramp(length(p.xz + vec2(NoiseGen(p*vec3(8.0, 1.5, 8.0)), \n                                             NoiseGen(-p*vec3(8.0, 1.5, 8.0)+4.5678))*0.05)*64.0) / 1.8;\n\trings -= NoiseGen(p *1.0)*0.75;\n\tvec3 te = mix(vec3(0.3, 0.19, 0.075)*0.95, vec3(1.0, 0.73, 0.326)*0.4, rings)*1.5;\n\tte = max(vec3(0.0), te);\n\tfloat rough = (NoiseGen(p*64.0*vec3(1.0, 0.2, 1.0))*0.1+0.9);\n\tte *= rough;\n    te = clamp(te, 0., 1.);\n    return te;\n}\n//-------------------- End: wood texture\n\nvoid rotate(inout vec2 point, float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    float px = point.x * c - point.y * s;\n    float py = point.x * s + point.y * c;\n    point.x = px;\n    point.y = py;\n}\n\nfloat dot2(in vec3 v )\n{\n    return dot(v,v);\n}\n\n//-------------------- Start: distance functions (primitives)\n// More info by Inigo Quilez:\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdPlane(in vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p, in float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox(in vec3 p, in vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(in vec3 p, in vec3 a, in vec3 b, in float r1, in float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2(pa*l2 - ba*y);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCylinder(in vec3 p, in vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderH(in vec3 p, in vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//-------------------- End: distance functions (primitives)\n\n// Intersection\nfloat opI(in float d1, in float d2)\n{\n    return max(d2,d1);\n}\n\n// Subtraction\nfloat opS(in float d1, in float d2)\n{\n    return max(-d2,d1);\n}\n\n// Union\nvec2 opU(in vec2 d1, in vec2 d2)\n{\t\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n// Union (float)\nfloat opU(in float d1, in float d2)\n{\t\n    return min(d1,d2);\n}\n\n// Smooth Union\nvec2 opSU(in vec2 d1, in vec2 d2, in float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n\treturn vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.y);\n}\n\n// Smooth Union (float)\nfloat opSU(in float d1, in float d2, in float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Repeat with limit\nvec2 opRepLim(in vec2 p, in float s, in vec2 limmin, in vec2 limmax)\n{\n    return p-s*clamp(round(p/s),-limmin,limmax);\n}\n\n//-------------------- Start: Chess Pieces\nvec2 pawn(in int id, in vec3 p)\n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.55, 0.0), 0.55), \n                           sdBox(pos-vec3(0., .55 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.55, 0.0), 0.55), \n                        sdBox(pos-vec3(0., .55 - .5, 0.), vec3(1.,.5,1.))), float(id)+100.0);    \n    top = opSU(top, vec2(sdSphere(pos-vec3( 0.0, 1.55, 0.0), 0.33 ), 4. ), 0.38);\n    \n    return opU(bottom, top);\n}\n\nvec2 bishop(in int id, in vec3 p) \n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 1.5, 0.0)), vec2(.15, .7)), float(id)+100.0), 0.6);\n    top = opSU(top, vec2(sdSphere(pos-vec3( 0.0, 2.5, 0.0), 0.4 ), float(id)+100.0), 0.3);\n    top.x = opS(top.x, sdBox(pos-vec3(0., 2.8, 0.), vec3(.05,0.2,1.05)));\n    \n    return opU(bottom, top);\n}\n\nvec2 king(in int id, in vec3 p)\n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 1.7, 0.0)), vec2(.15, 1.4)), float(id)+100.0), 0.6);\n    top = opSU(top, vec2(sdSphere(pos-vec3( 0.0, 2.9, 0.0), 0.4 ), float(id)+100.0), 0.3);\n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 2.0, 0.0)), vec2(.3, .04)), float(id)+100.0), 0.12);\n    \n    vec2 hat = vec2(sdBox(pos-vec3(0.,3.4,0.), vec3(.05,.2,.05)), 10.0);\n    hat = opU(hat, vec2(sdBox(pos-vec3(0.,3.45,0.), vec3(.18,.05,.05)), 10.0));\n    \n    return opU(opU(bottom, top), hat);\n}\n\nvec2 queen(in int id, in vec3 p) \n{   \n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 1.7, 0.0)), vec2(.15, 1.4)), float(id)+100.0), 0.6);\n    top = opSU(top, vec2(sdSphere(pos-vec3( 0.0, 2.9, 0.0), 0.4 ), float(id)+100.0), 0.3);\n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 2.0, 0.0)), vec2(.3, .04)), float(id)+100.0), 0.12);\n    \n    vec2 hat = vec2(sdSphere(pos-vec3(0.,3.35,0.), .1), 10.0);\n    \n    return opU(opU(bottom, top), hat);\n}\n\nvec2 rook(in int id, in vec3 p)\n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opSU(top, vec2(sdCylinder(vec3(pos-vec3(0.0, 1.2, 0.0)), vec2(.285, .7)), float(id)+100.0), 0.3);\n    top = opSU(top, vec2(sdCylinder(pos-vec3( 0.0, 2.1, 0.0), vec2(0.45,0.15)), float(id)+100.0), 0.3);\n    top.x = opS(top.x, sdBox(pos-vec3(0., 2.3, 0.), vec3(.05,0.2,1.05)));\n    top.x = opS(top.x, sdBox(pos-vec3(0., 2.3, 0.), vec3(1.05,0.2,.05)));\n    \n    return opU(bottom, top);\n}\n\nvec2 knight(in int id, in vec3 p) \n{\n    vec3 pos = p;\n    vec2 bottom = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                           sdBox(pos-vec3(0., .7 + .5, 0.), vec3(1.,.5,1.))), 10.0);\n    \n    vec2 top = vec2(opS(sdSphere(pos-vec3( 0.0, 0.7, 0.0), 0.7), \n                        sdBox(pos-vec3(0., .7-.5, 0.), vec3(1.,.5,1.))), float(id)+100.0);\n    \n    top = opU(top, vec2(opS(opI(sdBox(pos-vec3(0., 1.7, 0.), vec3(.7,1.,.15)),\n                                sdCylinderH(pos-vec3(3.005-.68, .7, 0.), vec2(3.01,.15))),\n                                sdCylinderH(pos-vec3(3.0-.20, .7, 0.), vec2(3.0,.25))), float(id)+100.0));\n    \n    vec3 boxPos = pos;\n    rotate(boxPos.xy, 3.15/5.9);\n    top.x = opU(top.x, sdBox(boxPos - vec3(-0.9,1.7,0.0), vec3(.4,.25,.15)));\n    top.x = opS(top.x, sdBox(boxPos - vec3(-1.5,2.82,0.0), vec3(1.1,1.0,.35)));\n        \n    return opU(bottom, top);\n}\n//-------------------- End: Chess Pieces\n\nvec2 map(in vec3 pos)\n{\n    // Board\n    vec2 res = vec2(sdBox(pos - vec3(-0.,-.5,-0.), vec3(16., .45, 16.)), 11.0);\n    vec2 board = vec2(sdBox(pos - vec3(-0.05,.3,-0.05), vec3(7.9, .3, 7.9)), 1.0);     \n    res = opU(res, board);\n    \n    // Cut repeated spheres\n    vec3 q = pos - vec3(1.,0.,1.);\n    q.xz = opRepLim( q.xz, 2., vec2(4.0,4.0), vec2(3.0,3.0));\n    res.x = opS(res.x, sdSphere(q - vec3(0., 5.4, 0.), 5.));   \n    \n    // Add chess pieces\n    // We can place one of each piece, and the rest is symmetry.\n    float bottom = 0.325;\n    \n    // Unique id for each chess piece\n    int id = int(clamp(pos.z + 8.,0.,15.) / 2.0)*8 + int(clamp(pos.x + 8.,0.,15.) / 2.0);\n\n    vec3 mirrorZPos = pos;\n    mirrorZPos.z = abs(mirrorZPos.z);\n    \n    vec3 mirrorZXPos = mirrorZPos;\n    mirrorZXPos.x = abs(mirrorZXPos.x);\n    \n    vec3 pawnPos = mirrorZPos - vec3(1.,0.,5.);\n    pawnPos.xz = opRepLim( pawnPos.xz, 2., vec2(4.0,0.0), vec2(3.0,0.0));\n\tres = opU(res, pawn(id, pawnPos - vec3(0., bottom, 0.)));\n\n    vec3 knightPos = mirrorZPos - vec3(5.,0.,7.);\n    knightPos.xz = opRepLim( knightPos.xz, 10., vec2(1.0,0.0), vec2(0.0,0.0));\n\tres = opU(res, knight(id, knightPos - vec3(0., bottom, 0.)));    \n\n\tres = opU(res, rook(id, mirrorZXPos - vec3(7., bottom, 7.)));    \n\tres = opU(res, bishop(id, mirrorZXPos - vec3(3., bottom, 7.)));    \n    res = opU(res, queen(id, mirrorZPos - vec3(1., bottom, 7.)));\n    res = opU(res, king(id, mirrorZPos - vec3(-1., bottom, 7.)));\n    \n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n    float tmin = .05;\n    float tmax = 100.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<70; i++ )\n    {\n\t    float precis = 0.0001*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    \n    float t = .2;\n    for( int i=0; i<70; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        res = min( res, k*max(h,0.0)/t );\n        if( res<0.001 ) break;\n        t += clamp(h,0.01,0.5);\n    }\n\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec4 colorForMat(in float m, in vec3 pos, in vec3 nor) \n{\n\tvec3 col = vec3(0.);\n    float mirror = 0.;\n    \n    if( m<1.5 )\n    {    \n        if (nor.y > 0.5) {\n            col = (mod(pos.x, 4.0)>2.)!=(mod(pos.z, 4.0)>2.) ? .01+texture(iChannel0,pos.zx*1.5).xyz*.15 : .3+texture(iChannel0,pos.zx*0.5).xyz*.7*vec3(.7,1.,1.);\n        } else if (abs(nor.x) > 0.5) {\n            col = .01+texture(iChannel0,pos.zy*0.5).xyz*.15;\n        } else {\n\t\t\tcol = .01+texture(iChannel0,pos.xy*0.5).xyz*.15;\n        }\n  \t} \n    else if ( m==10.0 ) \n    {\n        col = vec3(0.01);\n        mirror = 0.9;\n    }\n    else if ( m==11.0 )\n    {\n        col = vec3(0.4);\n        mirror = 0.5;\n        col = (0.5 + texture(iChannel1,pos.xz*.05).xyz * 0.5) * .6;\n    }\n    else if ( m >= 100.0 ) \n    {\n        int id = int(m - 100.0);\n        vec3 te = woodTexture(pos.xyz*0.75);\n        \n        if (id >= 32) {\n            col = 0.01 + te*0.15*vec3(1.3,1.,1.);\n        } else {\n        \tcol = 0.2 + te*0.8;\n        }\n    }\n    \n    return vec4(clamp(col,0.0,1.0), mirror);\n}\n\nvec3 lighting(in vec3 pos, in vec3 nor, in vec3 rd, in vec3 ref, out float spe) \n{\n\tfloat occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.1) );\n    vec3  hal = normalize( lig-rd );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    dif *= calcShadow(pos, lig, 50.);\n\n    spe = pow(clamp(dot(nor, hal), 0.0, 1.0),16.0)*\n        dif *\n        (0.04 + 0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0), 5.0));\n\n    vec3 lin = vec3(0.0);\n\n\tlin += 3.80*dif*vec3(1.30,1.00,0.70);\n\tlin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n\tlin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n\tlin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;    \n    lin *= 0.30;\n\n    return lin;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{     \n\tvec3 col = vec3(0.0);\n\tfloat atten = 1.0;\n    \n\tfor( int k=0; k<2; k++ )\n\t{\n    \tvec2 res = castRay(ro,rd);\n    \tfloat t = res.x;\n\t\tfloat m = res.y;\n                \n        if( m>-0.5 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal( pos );   \n            vec3 ref = reflect( rd, nor );\n\n            vec4 material = colorForMat(m, pos, nor);\n\n            float spe = 0.;\n            vec3 lin = lighting(pos, nor, rd, ref, spe);\n\n            vec3 c = material.rgb*lin.xyz;       \n            c += 9.0*spe*vec3(1.00,0.90,0.70);\n\n            col += c * atten;\n\n            atten *= material.w;\n            ro = pos + 0.001*nor;\n            rd = ref;\n        } else if (t > 1.) {\n            col += skyColor * atten;\n            break;\n        }\n    \n\t\tif (atten == 0.0) break;\n    }\n\treturn clamp(col,0.0,1.0);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 rayOrigin(in vec2 mo, in float time) {\n    vec3 ro = vec3(18.*cos(0.2*time), 8.+mo.y*6.0, 18.*sin(0.2*time));\n    return ro;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 2.*iTime + 23.41;\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        vec3 ro = rayOrigin(mo, time);\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n        vec3 col = render(ro, rd);\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    tot = pow(tot, vec3(0.45));\n    fragColor = vec4(tot, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}