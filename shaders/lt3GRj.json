{
    "Shader": {
        "info": {
            "date": "1470198028",
            "description": "Improved version of P_Malin's Smaller Numbers with more accurate numbers display while removing its fudge factor. Also demonstrates font size independent character positioning and tracking the mouse pointer without going offscreen.",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3GRj",
            "likes": 23,
            "name": "Prints Numbers",
            "published": 3,
            "tags": [
                "utility",
                "numbers",
                "font",
                "digits"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 3296
        },
        "renderpass": [
            {
                "code": "\n// Prints numbers\n\n// Original version: https://www.shadertoy.com/view/4sBSWW\n\n// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Note that the values printed are not always accurate!\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n// Original version\nfloat PrintValue00(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// Improved version\n//\n// Most important change is dropping everything left of the decimal point ASAP \n// when printing the fractional digits. This is done to bring the magnitule down\n// for the following division and modulo.\n//\n// Another change is to replace the logarithm with a power-of-ten value \n// calculation that is needed later anyway.\n// This change is optional, either one works.\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\nfloat GetCurve(float x)\n{\n\treturn ceil(sin( x * 3.14159 * 4.0 )*10.0-0.5)/10.0;\n}\n\nfloat GetCurveDeriv(float x) \n{ \n\treturn 3.14159 * 4.0 * cos( x * 3.14159 * 4.0 ); \n}\n\n// Multiples of 4x5 work best\nvec2 fontSize = vec2(4,5) * vec2(5,3);\n\nvec2 grid(int x, int y) { return fontSize.xx * vec2(1,ceil(fontSize.y/fontSize.x)) * vec2(x,y) + vec2(2); }\n\nvec2 limitTo(vec2 point, int x1, int y1, int x2, int y2, int startX, int startY) {\n    return clamp(point, grid(x1,y1), iResolution.xy - grid(x2,y2)) + grid(startX, startY);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 vColour = vec3(0.0);\n\tvec2 mouse = iMouse.xy;\n\n\tif(mouse.x < 10.0 && mouse.y < 10.0) {\n\t\tmouse =( vec2(sin(iTime), cos(iTime))/2.0+0.5)*iResolution.xy;\n\t}\n\t// Draw Horizontal Line\n\tif(abs(fragCoord.y - iResolution.y * 0.5) < 1.0)\n\t{\n\t\tvColour = vec3(0.25);\n\t}\n\t// Draw Sin Wave\n\t// See the comment from iq or this page\n\t// https://iquilezles.org/articles/distance\n\tfloat fCurveX = fragCoord.x / iResolution.x;\n\tfloat fSinY = (GetCurve(fCurveX) * 0.25 + 0.5) * iResolution.y;\n\tfloat fSinYdX = (GetCurveDeriv(fCurveX) * 0.25) * iResolution.y / iResolution.x;\n\tfloat fDistanceToCurve = abs(fSinY - fragCoord.y) / sqrt(1.0+fSinYdX*fSinYdX);\n\tfloat fSetPixel = fDistanceToCurve - 1.0; // Add more thickness\n\tvColour = mix(vec3(1.0, 0.0, 0.0), vColour, clamp(fSetPixel, 0.0, 1.0));\t\n\n\t// Draw Sin Value\t\n\tfloat fValue4 = GetCurve(mouse.x / iResolution.x);\n\tfloat fPixelYCoord = (fValue4 * 0.25 + 0.5) * iResolution.y;\n\t\n\t// Plot Point on Sin Wave\n\tfloat fDistToPointA = length( vec2(mouse.x, fPixelYCoord) - fragCoord.xy) - 4.0;\n\tvColour = mix(vColour, vec3(0.0, 1.0, 1.0), (1.0 - clamp(fDistToPointA, 0.0, 1.0)));\n\t\n\t// Plot Mouse Pos\n\tfloat fDistToPointB = length( vec2(mouse.x, mouse.y) - fragCoord.xy) - 4.0;\n\tvColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n\t\n\t// Print Sin Value\n\tvec2 vPixelCoord4 = limitTo(vec2(mouse.x, fPixelYCoord),0,2,8,4,0,0);// + vec2(4.0, 4.0);\n\tfloat fDigits = 2.0;\n\tfloat fDecimalPlaces = 4.0;\n\tfloat fIsDigit4 = PrintValue(fragCoord, vPixelCoord4, fontSize, fValue4, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit4);\n\t\n\t// Print Shader Time\n\tfDigits = 6.0;\n\tvColour = mix( vColour, vec3(0.0, 0.0, 1.0), PrintValue(fragCoord, grid(11,0), fontSize, iTime, fDigits, fDecimalPlaces));\n\n\t// Print Date\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, grid(0,0), fontSize, iDate.x, 4.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, grid(5,0), fontSize, iDate.y + 1.0, 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, grid(8,0), fontSize, iDate.z, 2.0, 0.0));\n\n\t// Draw Time\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, grid(24,0), fontSize, mod(iDate.w / (60.0 * 60.0), 12.0), 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, grid(27,0), fontSize, mod(iDate.w / 60.0, 60.0), 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, grid(30,0), fontSize, mod(iDate.w, 60.0), 2.0, 0.0));\n\t\n\tif(mouse.x >= 0.0)\n\t{\n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = limitTo(mouse.xy, 8,2,8,4,-8,1);\n\t\tfloat fValue2 = mouse.x / iResolution.x;\n\t\tfDigits = 1.0;\n\t\tfDecimalPlaces = 5.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, fontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = limitTo(mouse.xy, 8,2,8,4,0,1);\n\t\tfloat fValue3 = mouse.y / iResolution.y;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, fontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n\t\n\tfragColor = vec4(vColour,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}