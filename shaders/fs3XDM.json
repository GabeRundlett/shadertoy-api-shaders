{
    "Shader": {
        "info": {
            "date": "1633321680",
            "description": "Combining boids with [url=https://michaelmoroz.github.io/Reintegration-Tracking/]reintegration tracking[/url]. Parameters cycle over time by default, edit defines in common shader to vary.",
            "flags": 32,
            "hasliked": 0,
            "id": "fs3XDM",
            "likes": 73,
            "name": "Fluidic Boids",
            "published": 3,
            "tags": [
                "simulation",
                "fluid",
                "mipmap",
                "predator",
                "boids",
                "prey",
                "ecology"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 1804
        },
        "renderpass": [
            {
                "code": "//#define DEBUG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0,0,0,1);\n    vec2 uv = fragCoord / iResolution.xy;\n\n#ifdef DEBUG\n    if (uv.x < 0.25) {\n        vec4 data = textureLod(iChannel0, floor(fragCoord/16.)*16. / iResolution.xy, 4.);\n        vec2 vel = data.zw;\n\n        fragColor.rgb = .6 + .6 * cos(atan(vel.y,vel.x) + vec3(0,23,21));\n        \n        data = textureLod(iChannel1, fragCoord / iResolution.xy, 4.);\n    \tfragColor.rgb += 60. * length(data.zw);\n        return;\n    }\n#endif\n\n    vec4 data = texture(iChannel0, fragCoord / iResolution.xy);\n    particle P = getParticle(data, fragCoord);\n    vec2 vel = P.V;\n\n    fragColor.rgb = .6 + .6 * cos(atan(vel.y,vel.x) + vec3(0,23,21));\n    fragColor.rgb *= sqrt(clamp(P.M, 0., 1.));\n\n#ifdef DEBUG\n    data = texture(iChannel1, fragCoord / iResolution.xy);\n    for(int i = -2; i <= 2; i++) {\n        for(int j = -2; j <= 2; j++) {\n            vec4 data = texture(iChannel1, (fragCoord + vec2(i,j)) / iResolution.xy);\n            if(data.x > 0.001) {\n                fragColor.rgb += 0.4 * exp(-pow(distance(data.xy, fragCoord), 2.) / 2.);\n                return;\n            }\n        }\n    }\n#endif\n    if (0.00 < uv.y && uv.y < 0.01 && 5.*uv.x < ALIGNMENT)  fragColor += 0.5;\n    if (0.01 < uv.y && uv.y < 0.02 && 5.*uv.x < SEPARATION) fragColor += 0.5;\n    if (0.02 < uv.y && uv.y < 0.03 && 5.*uv.x < COHESION)   fragColor += 0.5;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Prey (boids with fluidic characteristics)\n\n#define MAX_SPEED 0.9\n#define MAX_FORCE 0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    if(iFrame < 10) {\n        float q = 2.*PI * hash12(1. + fragCoord);\n        particle P;\n        P.X = fragCoord;\n        P.V = MAX_SPEED * vec2(cos(q), sin(q));\n        P.M = 1.;\n        fragColor = saveParticle(P, fragCoord);\n        return;\n    }\n    \n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n    particle P = getParticle(data, fragCoord);\n\n    if(P.M < 0.01) {\n        P.X = fragCoord;\n        P.V = vec2(0);\n        P.M = 0.05;\n    }\n    \n    vec2 pos = P.X;\n    vec2 vel = P.V;\n\n    float nCount = 0.;\n\n    vec2 alignment = vec2(0);\n    vec2 cohesion = vec2(0);\n    vec2 separation = vec2(0);\n\n    for(int i = -NEIGHBOR_DIST; i <= NEIGHBOR_DIST; i++) {\n        for(int j = -NEIGHBOR_DIST; j <= NEIGHBOR_DIST; j++) {\n            vec2 ij = vec2(i,j);\n            if(ij == vec2(0) || length(ij) > float(NEIGHBOR_DIST)) continue;\n\n            vec4 data2 = texture(iChannel0, fract((fragCoord + ij) / iResolution.xy));\n            particle P2 = getParticle(data2, fragCoord + ij);\n            vec2 pos2 = P2.X;\n            vec2 vel2 = P2.V;\n            float m = P2.M;\n\n            separation += m * normalize(pos - pos2) / distance(pos, pos2);\n\n            alignment += m * vel2;\n            cohesion += m * pos2;\n            nCount += m;\n\n            // nearby predators\n            data2 = textureLod(iChannel1, fract((fragCoord + ij) / iResolution.xy), 0.);\n            if(data2.x > 0.001) separation += normalize(pos - data2.xy);\n\n            // distant predators\n            vec2 coord = fragCoord + 16. * ij;\n            data2 = textureLod(iChannel1, fract(coord / iResolution.xy), 4.);\n            vel2 = data2.zw;\n            separation += normalize(pos - coord) * length(vel2);\n        }\n    }\n    \n    if (nCount > 0.) cohesion = cohesion / float(nCount) - pos;\n\n    if(cohesion != vec2(0)) cohesion = clamp_length(\n        MAX_SPEED * normalize(cohesion) - vel, MAX_FORCE);\n    if(alignment != vec2(0)) alignment = clamp_length(\n        MAX_SPEED * normalize(alignment) - vel, MAX_FORCE);\n    if(separation != vec2(0)) separation = clamp_length(\n        MAX_SPEED * normalize(separation) - vel, MAX_FORCE);\n\n    vel += alignment * ALIGNMENT;\n    vel += separation * SEPARATION;\n    vel += cohesion * COHESION;\n    vel -= 0.1 * textureLod(iChannel0, fragCoord / iResolution.xy, 7.).zw; // zero out average velocity of swarm\n    P.V = clamp_length(vel, MAX_SPEED);\n    fragColor = saveParticle(P, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// reintegration tracking code from https://www.shadertoy.com/view/ttBcWm\n#define Bi(p) ivec2(mod(p,iResolution.xy))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, DIFFUSION);\n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if(P.M != 0.)\n    {\n        P.X /= P.M;\n        P.V /= P.M;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    particle P;\n    Reintegration(iChannel0, P, fragCoord);\n    fragColor = saveParticle(P, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Predators (classic boids)\n\n#define MAX_SPEED 1.2\n#define MAX_FORCE 0.1\n#define DESIRED_SEPARATION 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    if(iFrame < 10) {\n        if(hash12(fragCoord) < 0.001) {\n            float q = 2.*PI * hash12(1. + fragCoord);\n            fragColor = vec4(fragCoord.xy, cos(q), sin(q));\n        }\n        return;\n    }\n    \n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n\n    if(data == vec4(0)) {\n        if (length(hash33(vec3(fragCoord, iFrame))) < 0.015) {\n            data = vec4(fragCoord, 0, 0);\n        } else {\n            return;\n        }\n    }\n    \n    vec2 pos = data.xy;\n    vec2 vel = data.zw;\n\n    vec2 separation = vec2(0);\n\n    for(int i = -NEIGHBOR_DIST; i <= NEIGHBOR_DIST; i++) {\n        for(int j = -NEIGHBOR_DIST; j <= NEIGHBOR_DIST; j++) {\n            vec2 ij = vec2(i,j);\n            if(ij == vec2(0) || length(ij) > float(NEIGHBOR_DIST)) continue;\n\n            vec4 data2 = textureLod(iChannel0, fract((fragCoord + ij) / iResolution.xy), 0.);\n            if(data2.x > 0.001 && distance(pos, data2.xy) < float(DESIRED_SEPARATION))\n                separation += normalize(pos - data2.xy) / distance(pos, data2.xy);\n\n            // nearby prey\n            data2 = texture(iChannel1, fract((fragCoord + ij) / iResolution.xy));\n            particle P2 = getParticle(data2, fragCoord + ij);\n            separation -= P2.M * normalize(pos - P2.X);\n\n            // distant prey\n            vec2 coord = fragCoord + 16. * ij;\n            data2 = textureLod(iChannel1, fract(coord / iResolution.xy), 4.);\n            //vec2 vel2 = data2.zw;\n            //separation -= normalize(pos - coord) * length(vel2);\n            float m = data2.y;\n            separation -= normalize(pos - coord) * m;\n        }\n    }\n\n    vel = MAX_SPEED * normalize(vel + MAX_FORCE * normalize(separation));\n    pos = mod(pos + vel, iResolution.xy);\n    fragColor = vec4(pos, vel);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    for(int i = -2; i <= 2; i++) {\n        for(int j = -2; j <= 2; j++) {\n            vec4 data = texture(iChannel0, fract((fragCoord + vec2(i,j)) / iResolution.xy));\n            if(abs(data.x - fragCoord.x) < 0.5 && abs(data.y - fragCoord.y) < 0.5) {\n                fragColor = data;\n                return;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define NEIGHBOR_DIST 6\n#define DIFFUSION     1.12\n#define ALIGNMENT     (0.7 + 0.3 * cos(PI * iTime/5.))\n#define SEPARATION    (0.7 + 0.3 * cos(PI * iTime/6.))\n#define COHESION      (0.7 + 0.3 * cos(PI * iTime/7.))\n\n///\n\n#define PI 3.14159265359\n\nvec2 clamp_length(vec2 v, float r) {\n    if(length(v) > r) return r * normalize(v);\n    return v;\n}\n\nuint pack(vec2 x)\n{\n    x = 65535.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65535.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    float M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P;\n    if (data == vec4(0)) return P;\n    P.X = decode(data.x) + pos;\n    P.M = data.y;\n    P.V = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    vec2 x = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(x), P.M, P.V);\n}\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}