{
    "Shader": {
        "info": {
            "date": "1369417084",
            "description": "Just a modification of the shader 'lot of spheres', so you can use it with the Oculus Rift (http://www.oculusvr.com/). All constants are empircal measured. Run the shader full screen.",
            "flags": 0,
            "hasliked": 0,
            "id": "lds3D8",
            "likes": 18,
            "name": "Oculus rift & Spheres",
            "published": 3,
            "tags": [
                "spheres",
                "raytrace",
                "oculusrift"
            ],
            "usePreview": 0,
            "username": "reinder",
            "viewed": 1558
        },
        "renderpass": [
            {
                "code": "// Created by Reinder Nijhoff 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n\n// empirical measured values\n#define EYEDISTANCE  1. \n#define LENSDISTANCE -0.136 \n#define FOV 0.62  \n\n#define SHADOW\n//#define REFLECTION\n\n#define RAYCASTSTEPS 30\n\n#define EXPOSURE 0.9\n#define EPSILON 0.0001\n#define MAXDISTANCE 400.\n#define GRIDSIZE 10.\n#define GRIDSIZESMALL 8.\n#define MAXHEIGHT 10.\n#define SPEED 2.5\n\nfloat time;\n\n//\n// math functions\n//\n\nconst mat2 mr = mat2 (0.84147,  0.54030,\n\t\t\t\t\t  0.54030, -0.84147 );\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\nvec2 hash2( float n ) {\n\treturn fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\n}\nvec2 hash2( vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(2.1459123,3.3490423));\n}\nvec3 hash3( float n ) {\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nvec3 hash3( vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\n//\n// intersection functions\n//\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersectUnitSphere ( in vec3 ro, in vec3 rd, in vec3 sph, out float dist, out vec3 normal ) {\n\tvec3  ds = ro - sph;\n\tfloat bs = dot( rd, ds );\n\tfloat cs = dot(  ds, ds ) - 1.0;\n\tfloat ts = bs*bs - cs;\n\t\n\tif( ts > 0.0 ) {\n\t\tts = -bs - sqrt( ts );\n\t\tif( ts>0. ) {\n\t\t\tnormal = normalize( (ro+ts*rd)-sph );\n\t\t\tdist = ts;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n//\n// Scene\n//\n\nvoid getSphereOffset( vec2 grid, inout vec2 center ) {\n\tcenter = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\n}\nvoid getMovingSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\n\t// falling?\n\tfloat s = 0.1+hash( grid.x*1.23114+5.342+754.324231*grid.y );\n\tfloat t = 14.*s + time/s;\n\t\n\tfloat y =  s * MAXHEIGHT * abs( cos( t ) );\n\tvec2 offset = grid + sphereOffset;\n\t\n\tcenter = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\n}\nvoid getSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\n\tvec2 offset = grid + sphereOffset;\n\tcenter = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\n}\nvec3 getSphereColor( vec2 grid ) {\n\treturn normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );\n}\n\nvec3 trace(vec3 ro, vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {\n\tmaterial = 0; // sky\n\tdist = MAXDISTANCE;\n\tfloat distcheck;\n\t\n\tvec3 sphereCenter, col, normalcheck;\n\t\n\tif( intersectPlane( ro,  rd, 0., distcheck) && distcheck < MAXDISTANCE ) {\n\t\tdist = distcheck;\n\t\tmaterial = 1;\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tcol = vec3( 1. );\n\t} else {\n\t\tcol = vec3( 0. );\n\t}\n\t\n\t// trace grid\n\tvec2 map = floor( ro.xz / GRIDSIZE ) * GRIDSIZE;\n\tfloat deltaDistX = GRIDSIZE*sqrt(1. + (rd.z * rd.z) / (rd.x * rd.x));\n\tfloat deltaDistY = GRIDSIZE*sqrt(1. + (rd.x * rd.x) / (rd.z * rd.z));\n\tfloat stepX, stepY, sideDistX, sideDistY;\n\t\n\t//calculate step and initial sideDist\n\tif (rd.x < 0.) {\n\t\tstepX = -GRIDSIZE;\n\t\tsideDistX = (ro.x - map.x) * deltaDistX / GRIDSIZE;\n\t} else {\n\t\tstepX = GRIDSIZE;\n\t\tsideDistX = (map.x + GRIDSIZE - ro.x) * deltaDistX / GRIDSIZE;\n\t}\n\tif (rd.z < 0.) {\n\t\tstepY = -GRIDSIZE;\n\t\tsideDistY = (ro.z - map.y) * deltaDistY / GRIDSIZE;\n\t} else {\n\t\tstepY = GRIDSIZE;\n\t\tsideDistY = (map.y + GRIDSIZE - ro.z) * deltaDistY / GRIDSIZE;\n\t}\n\t\n\tbool hit = false; \n\t\n\tfor( int i=0; i<RAYCASTSTEPS; i++ ) {\n\t\tif( hit || distance( ro.xz, map ) > dist+GRIDSIZE ) continue;\n\n\t\tvec2 offset;\n\t\tgetSphereOffset( map, offset );\n\t\t\n\t\tgetMovingSpherePosition( map, -offset, sphereCenter );\n\t\t\n\t\tif( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\n\t\t\tdist = distcheck;\n\t\t\tnormal = normalcheck;\n\t\t\tmaterial = 2;\n\t\t\thit = true;\n\t\t}\n\t\t\n\t\tgetSpherePosition( map, offset, sphereCenter );\n\t\tif( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\n\t\t\tdist = distcheck;\n\t\t\tnormal = normalcheck;\n\t\t\tcol = vec3( 2. );\n\t\t\tmaterial = 3;\n\t\t\thit = true;\n\t\t}\n\t\t\t\t\t\t\n\t\tif (sideDistX < sideDistY) {\n\t\t\tsideDistX += deltaDistX;\n\t\t\tmap.x += stepX;\n\t\t} else {\n\t\t\tsideDistY += deltaDistY;\n\t\t\tmap.y += stepY;\n\t\t}\t\t\n\t}\n\t\n\tvec3 color = vec3( 0. );\n\tif( (hit || material == 1) ) {\n\t\tintersection = ro + rd*dist;\n\t\tvec2 map = intersection.xz - mod( intersection.xz, vec2(GRIDSIZE,GRIDSIZE) );\n\t\t\n\t\tif( material == 1 || material == 3 ) {\n\t\t\t// lightning\n\t\t\tvec3 c = vec3( -GRIDSIZE,0., GRIDSIZE );\n\t\t\tfor( int x=0; x<3; x++ ) {\n\t\t\t\tfor( int y=0; y<3; y++ ) {\n\t\t\t\t\tvec2 mapoffset = map+vec2( c[x], c[y] );\t\t\n\t\t\t\t\tvec2 offset;\n\t\t\t\t\tgetSphereOffset( mapoffset, offset );\n\t\t\t\t\tvec3 lcolor = getSphereColor( mapoffset );\n\t\t\t\t\tvec3 lpos;\n\t\t\t\t\tgetMovingSpherePosition( mapoffset, -offset, lpos );\n\t\t\t\t\t\n\t\t\t\t\tfloat shadow = 1.;\n#ifdef SHADOW\n\t\t\t\t\tif( material == 1 ) {\n\t\t\t\t\t\tfor( int sx=0; sx<3; sx++ ) {\n\t\t\t\t\t\t\tfor( int sy=0; sy<3; sy++ ) {\n\t\t\t\t\t\t\t\tif( shadow < 1. ) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvec2 smapoffset = map+vec2( c[sx], c[sy] );\t\t\n\t\t\t\t\t\t\t\tvec2 soffset;\n\t\t\t\t\t\t\t\tgetSphereOffset( smapoffset, soffset );\n\t\t\t\t\t\t\t\tvec3 slpos, sn;\n\t\t\t\t\t\t\t\tgetSpherePosition( smapoffset, soffset, slpos );\n\t\t\t\t\t\t\t\tfloat sd;\n\t\t\t\t\t\t\t\tif( intersectUnitSphere( intersection, normalize( lpos - intersection ), slpos, sd, sn )  ) {\n\t\t\t\t\t\t\t\t\tshadow = 0.;\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tcolor += col * lcolor * ( shadow * max( dot( normalize(lpos-intersection), normal ), 0.) *\n\t\t\t\t\t\t\t\t\t\t\t (1. - clamp( distance( lpos, intersection )/GRIDSIZE, 0., 1.) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// emitter\n\t\t\tcolor = (1.5+dot(normal, vec3( 0.5, 0.5, -0.5) )) *getSphereColor( map );\n\t\t}\n\t}\n\treturn color;\n}\n\n// left\nfloat w = 1.0;\nfloat h = 1.0;\nfloat scaleFactor = 1.0;\n\nvec2 leftLensCenter = vec2( LENSDISTANCE, 0. );\nvec2 rightLensCenter = vec2( -LENSDISTANCE, 0. );\n\nvec2 Scale;\nvec2 ScaleIn = vec2( 1., 1.);\nvec4 HmdWarpParam = vec4(1., 0.22, 0.24, 0);\n\nvec2 HmdWarp(vec2 in01, vec2 lensCenter) {\n   vec2 theta = (in01-lensCenter) * ScaleIn; // Scales to [-1, 1]\n   float rSq = dot(theta, theta);\n   vec2 rvector = theta * \n\t (HmdWarpParam.x + HmdWarpParam.y * rSq +\n      HmdWarpParam.z * rSq * rSq +\n      HmdWarpParam.w * rSq * rSq * rSq);\n   return lensCenter + Scale * rvector;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    Scale = 0.65*vec2( 1., iResolution.x/iResolution.y );\n    time = iTime;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = 2.0*q;\n\t\n\tp.x *= 2.;\n\t\t\n\tbool lefteye = true;\n\tif( p.x > 2. ) {\n\t\tp.x -= 2.;\n\t\tlefteye = false;\n\t}\n\tp -= vec2(1.);\n\t\t\n\tp = HmdWarp( p, lefteye?leftLensCenter:rightLensCenter );\n\n\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// camera\t\n\tvec3 ce = vec3( cos( 0.232*time) * 10., 7.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );\n\tvec3 ro = ce;\n\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\n\t\n\tfloat roll = -0.15*sin(0.5*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\n\tvec3 go = vec3( 0.0 );\n\tgo.x = (lefteye?-0.5*EYEDISTANCE:0.5*EYEDISTANCE);\n\tro += go.x*cu + go.y*cv;\n\n\t// create offset voor left or right eye\n\tvec3 er = normalize( vec3( p.xy, FOV ) );\n\tvec3 rd = er.x*cu + er.y*cv + er.z*cw;\n\t\n\t\n\t\n\t// raytrace\n\tint material;\n\tvec3 normal, intersection;\n\tfloat dist;\n\t\n\tvec3 col = trace(ro, rd, intersection, normal, dist, material);\n\n#ifdef REFLECTION\n\tif( material > 0 ) {\n\t\tvec3 ro = intersection + EPSILON*normal;\n\t\trd = reflect( rd, normal );\n\t\tcol += 0.05 * trace(ro, rd, intersection, normal, dist, material);\n\t}\n#endif\n\t\n\tcol = pow( col, vec3(EXPOSURE, EXPOSURE, EXPOSURE) );\t\n\tcol = clamp(col, 0.0, 1.0);\n\t\n\n\n\tfragColor = vec4( col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}