{
    "Shader": {
        "info": {
            "date": "1667366474",
            "description": "Erosion and dilation from mathematical morphology implemented with JFA so that its time complexity is independent of the radius - it could easily run real time in a single pass for small radiuses.",
            "flags": 32,
            "hasliked": 0,
            "id": "DdS3zm",
            "likes": 5,
            "name": "Morphology with JFA",
            "published": 3,
            "tags": [
                "effect",
                "flood",
                "jump",
                "algorithm",
                "minimum",
                "maximum",
                "minimax"
            ],
            "usePreview": 1,
            "username": "fad",
            "viewed": 567
        },
        "renderpass": [
            {
                "code": "// The erosion/dilation filter sets the current pixel's colour to the\n// min/maximum value in its neighbourhood of a given radius. Change the settings\n// in Buffer A. If you change the iChannel0 texture here, make sure to change it\n// in Buffer A as well\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(texelFetch(iChannel1, ivec2(fragCoord), 0).xy) % textureSize(iChannel0, 0), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The settings you can change are:\n// - whether to erode or dilate\n// - what channel to use as the value for a pixel\n// - what distance metric to use (p-norm)\n// - the radius to search within\n\n// You can experiment with your own channel values or distance metrics by\n// changing the channelValue or distanceFunction functions :)\n\n// If you change the iChannel0 texture here, make sure to change it in the Image\n// buffer as well\n\n#define EROSION   0\n#define DILATION  1\n\n#define RED       0\n#define GREEN     1\n#define BLUE      2\n#define ALPHA     3\n#define LUMINANCE 4\n\n// Settings (have to reset time/change resolution to see effects):\n#define MODE    DILATION\n#define CHANNEL LUMINANCE\n#define P_NORM  1.0\n#define RADIUS  10.0\n\nfloat channelValue(vec4 color) {\n    switch (CHANNEL) {\n        case RED:       return color.r;\n        case GREEN:     return color.g;\n        case BLUE:      return color.b;\n        case ALPHA:     return color.a;\n        case LUMINANCE: return dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n    }\n}\n\nfloat distanceFunction(vec2 a, vec2 b) {\n    return pow(pow(abs(b.x - a.x), P_NORM) + pow(abs(b.y - a.y), P_NORM), 1.0 / P_NORM);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 d = texelFetch(iChannel1, ivec2(0), 0);\n\n    if (iFrame == 0 || d.a != iResolution.x) {\n        fragColor.b = 0.0;\n    } else {\n        fragColor.b = d.b + 1.0;\n    }\n    \n    fragColor.a = iResolution.x;\n    int iFrame = int(fragColor.b);\n    ivec2 p = ivec2(fragCoord);\n    fragColor.rg = vec2(0.0);\n    \n    if (iFrame == 0) {        \n        fragColor.rg = fragCoord;        \n        return;\n    }\n    \n    int numSteps = int(ceil(log2(max(iResolution.x, iResolution.y))));\n    \n    if (iFrame > numSteps) {        \n        fragColor = texelFetch(iChannel1, p, 0);\n        return;\n    }\n    \n    int k = 1 << numSteps - iFrame;    \n    float best = MODE == EROSION ? 1e30 : -1e30;\n    \n    for (int i = -k; i <= k; i += k) {\n        for (int j = -k; j <= k; j += k) {\n            ivec2 s = p + ivec2(i, j);\n            \n            if (any(lessThan(ivec4(s, iResolution.xy - 1.0), ivec4(0, 0, s)))) {\n                continue;\n            }\n\n            vec2 q = texelFetch(iChannel1, s, 0).xy;\n\n            if (q == vec2(0.0)) {\n                continue;\n            }\n\n            float d = distanceFunction(fragCoord, q);\n            float v = channelValue(texelFetch(iChannel0, ivec2(q) % textureSize(iChannel0, 0), 0));\n\n            if (d < RADIUS && (MODE == EROSION ? v < best : v > best)) {\n                best = v;\n                fragColor.rg = q;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}