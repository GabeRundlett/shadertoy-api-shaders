{
    "Shader": {
        "info": {
            "date": "1710289704",
            "description": "There seems to an universal upward moving and downward moving principle. \nExpansion and contraction. Emptiness and form. Creation and dissolution. An endless cycle.",
            "flags": 0,
            "hasliked": 0,
            "id": "43BSzW",
            "likes": 0,
            "name": "[phreax] kundalini 2",
            "published": 3,
            "tags": [
                "raymarching",
                "cubes",
                "glow",
                "iridescent"
            ],
            "usePreview": 0,
            "username": "phreax",
            "viewed": 55
        },
        "renderpass": [
            {
                "code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2024\n\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define BUMP_EPS 0.004\n#define sabsk(x, k) sqrt(x * x + k * k)\n#define sabs(x) (sabsk(x, .01))\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\n\nfloat tt, g_mat;\nvec3 ro;\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\nvec2 field(in vec2 x)\n{\n    vec2 n = floor(x);\n\tvec2 f = fract(x);\n\tvec2 m = vec2(5.,1.);\n\tfor(int j=0; j<=1; j++)\n\tfor(int i=0; i<=1; i++)\n    {\n\t\tvec2 g = vec2( float(i),float(j) );\n\t\tvec2 r = g - f;\n        float d = length(r)*(sin(1.)*0.5+1.5); //any metric can be used\n        d = sin(d*5.+abs(0.5)*1.8+0.2);\n\t\tm.x *= d;\n\t\tm.y += d*1.4;\n    }\n\treturn abs(m);\n}\n\nvec3 tex(in vec2 p, in float ofst)\n{   \n    p *= .3;\n   \n    vec2 rz = field(p*ofst*0.5);\n\tvec3 col = sin(vec3(2.,1.,.1)*rz.y*.1+3.+ofst*2.)+.9*(rz.x+1.);\n\tcol = col*col*.5;\n    col *= .19;\n\treturn col * vec3(0.969,0.694,0.510);\n}\n\nvec3 cubem(in vec3 p, in float ofst)\n{\n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return tex( vec2(p.z,p.y)/p.x,ofst );\n    else if (p.y > p.x && p.y > p.z) return tex( vec2(p.z,p.x)/p.y,ofst );\n    else return tex( vec2(p.y,p.x)/p.z,ofst );\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\n//  some 2d noise for dithering\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\n// ortho normal basis \nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\n// Zucconi's spectral palette\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\n// spectral palette by wavelength\nvec3 waveSpectrum(float w){\n\n    if(w > 700.0 || w < 400.0){\n        return vec3(0);\n    }\n    \n\tfloat x = fract((w - 400.0)/ 300.0);\n    \n\tvec3 col = spectral_zucconi6(x);\n\n    // Undo gamma\n    col = invGamma(col);\n\n    return col;\n}\n\n\n// physical based diffraction grating\nvec3 diffraction(vec3 rd, vec3 n, vec3 td, vec3 l, float d) {\n\n    vec3 col = vec3(0);\n\n    float cos_ThetaL = dot(l, td);\n    float cos_ThetaV = dot(rd, td);\n   \n    float u = abs(cos_ThetaL - cos_ThetaV);\n    \n    if(u == 0.) {\n        return vec3(0);\n    }\n    \n    for(float i=1.; i < 2.; i++) {\n        float wavelength = u * d / i;\n        col += waveSpectrum(wavelength);\n    }\n    col = clamp(col, vec3(0), vec3(1));\n    return col;\n}\n\nvec3 transform(vec3 p) {\n   p.yz *= rot(PI*.25 + tt);\n   p.yx *= rot(PI*.25 + .4*tt);\n    return p;\n}\n\n\n\nfloat box(vec3 p, vec3 r) {\n  vec3 d = abs(p) - r;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat pMod(float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn p;\n}\n\n#define PHI 1.618033988749895\n#define SQR2 1.4152135\n#define ISQR2 1./SQR2\n\n// Million thanks to https://mercury.sexy/hg_sdf\nconst vec3 GDFVectors[19] = vec3[](\n\tnormalize(vec3(1, 0, 0)),\n\tnormalize(vec3(0, 1, 0)),\n\tnormalize(vec3(0, 0, 1)),\n\n\tnormalize(vec3(1, 1, 1 )),\n\tnormalize(vec3(-1, 1, 1)),\n\tnormalize(vec3(1, -1, 1)),\n\tnormalize(vec3(1, 1, -1)),\n\n\tnormalize(vec3(0, 1, PHI+1.)),\n\tnormalize(vec3(0, -1, PHI+1.)),\n\tnormalize(vec3(PHI+1., 0, 1)),\n\tnormalize(vec3(-PHI-1., 0, 1)),\n\tnormalize(vec3(1, PHI+1., 0)),\n\tnormalize(vec3(-1, PHI+1., 0)),\n\n\tnormalize(vec3(0, PHI, 1)),\n\tnormalize(vec3(0, -PHI, 1)),\n\tnormalize(vec3(1, 0, PHI)),\n\tnormalize(vec3(-1, 0, PHI)),\n\tnormalize(vec3(PHI, 1, 0)),\n\tnormalize(vec3(-PHI, 1, 0))\n);\n\n\n\nfloat fGDF(vec3 p, float r, int begin, int end) {\n\tfloat d = 0.;\n\tfor (int i = begin; i <= end; ++i)\n\t\td = max(d, abs(dot(p, GDFVectors[i])));\n\treturn d - r;\n}\n\n// from iq\nfloat octahedron( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat dodecahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 13, 18);\n}\n\n\nfloat icosahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 12);\n}\nfloat g_glow;\n\nfloat map(vec3 p) {   \n\n    vec3 bp = p;\n \n  //  p.z += 15.*fract(.1*tt);\n\n    p.yz *= rot(.5*PI);\n\n    vec3 pg = p;\n    pg.y = pMod(pg.y-5.*tt, 8.)-.5;\n    pg.y *= .5;\n    \n    float dg = smin(length(p.xz) - .02, length(pg) - .5, .5);\n    \n    g_glow += .1/(.1+pow(abs(dg), 4.)*50.);\n\n  //  pModInterval1(p.z, 20., 0., 2.);\n    p.x = sabs(p.x) - 2.5;\n    p.xz *= rot(.2*tt+p.y*mix(.03, .1, SIN(.4*tt)));\n    p.x = sabs(p.x) - 1.5;\n    p.xz *= rot(.2*tt+p.y*mix(.2, .3, SIN(.1*tt)));\n    p.x = sabs(p.x) - 1.;\n    p.x += 2.*sin(p.y*.5-1.5+tt);\n    p.xz *= rot(.4*tt-p.y*mix(.1, .2, SIN(.5*tt)));\n    p.xz = sabs(p.xz) - 1.5;\n    p.xz *= rot(.4*tt-p.y*mix(.1, .2, SIN(.9*tt)));\n\n    p += 1.1;\n\n    vec3 cId;\n    \n    float s = mix(.3, .7, SIN(.5*tt));\n    float num = 2.;\n    float len  = 100.;\n//    p.y += tt;\n    cId.x = pModInterval1(p.y, s, -len, len);\n    cId.y = pModInterval1(p.x, s, 0., num);\n    cId.z = pModInterval1(p.z, s, 0., num);\n    // p.xy *= rot(.5*tt);\n   \n    //p.xz *= rot(cId.x*cId.z+.4*tt);\n   \n   \n    float cs = s*mix(.02, .3, SIN(.5*(cId.x/(num))+5.*tt));\n  //  float d = box(p, vec3(cs)) - 0.3*cs;\n    float d = dodecahedron(p, cs) - 0.3*cs;\n    \n    float d2 = length(p) - cs;\n    //d = mix(d, d2, SIN((.4*cId.x/num)+tt));\n    \n    d = max(d, -(length(ro-bp)-5.));\n\n    return d*.5;\n\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat gridSurf( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*2., 1.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor) {\n    \n    const float eps = BUMP_EPS;\n    float ref = gridSurf(p);                 \n    vec3 grad = vec3( gridSurf(vec3(p.x-eps, p.y, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y-eps, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n}\n\n// iq's shadow function\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 g_p;\n// why not put the raymarcher in a separate function (;\nvec3 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        if(abs(d) < 0.0001 || t > 100.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    \n    g_p = p;\n    \n    return vec3(t, mat, t);\n}\n\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\n// smooth noise\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 rdToCol(vec3 rd) {\n    // Ray direction as color\n    \n   // rd = min(max(\n    vec3 col = rd;\n\n    // Output to cubemap\n\n    col.g *=.7;\n    col.r *= 1.1;\n    return col;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    \n    // camera system\n    vec3 f = normalize(l - p),  // forward vector\n         r = normalize(cross(vec3(0, 1, 0), f)), // right vector\n         u = cross(f, r), // up vector\n         c = p + f * z, // center of virtual screen\n         i = c + uv.x * r + uv.y * u, // intersection with screen\n         rd = normalize(i - p);  // ray direction\n         \n    return rd;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    tt = .5*iTime;\n    float zoom = mix(4., 9., SIN(.4*iTime));\n    vec3  lp = vec3(3., 0., -5),\n          lp2 = vec3(-3., 0., -20);\n\n\n    //uv = uv.yx;\n    vec3 col;\n    \n    ro = vec3(.0, 7.+4.*sin(.3*tt), -13.);\n    vec3 lookat = vec3(0, 0, 0);\n\n    \n    vec3 rd = getRayDir(uv, ro, lookat, .8);\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.106,0.255,0.275);\n    vec3 c2 = vec3(0.165,0.051,0.286);\n    \n    // light color\n    vec3 lc1 = vec3(0.745,0.761,0.976);\n    vec3 lc2 = vec3(0.573,0.922,0.969);\n    \n    \n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 200.;\n        vec3 rm = raymarch(ro, rd, steps);\n        \n        float glow = g_glow;\n        mat = rm.y;\n        \n        \n        vec3 p = ro + rm.x*rd;\n        \n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                                e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n    \n     \n        if(rm.x < 50.) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l2), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n            \n            float shd=softshadow( p, l, 0.1, 10. );\n       \n            float sss = smoothstep(0., 1., map(p + l * .3)) / .4;\n            float sss2 = smoothstep(0., 1., map(p + l2 * .3)) / .4;\n\n\n            vec3 n2 = n;\n            n2.xy += noise(p.xy) * .5 - .025;\n            n2 = normalize(n2);\n            float height = atan(n2.y, n2.x);\n\n            vec3 iri = spectral_zucconi6(height*1.11)*smoothstep(.8, .2, abs(n2.z))-.02;\n\n            col += ( (dif+.4*sss)*lc1 + (.4*sss2+dif2)*lc2) + .03*iri;\n      \n            float ao = calcAO(p, n);\n\n            col *= mix(col, col*ao, .5);\n      \n            if(mat == 0.) {\n               rd = reflect(rd, n);\n                \n               rd.yz *= rot(PI*.6 + .4*tt);\n               rd.yz = rd.zy;\n         \n               vec3 refl = cubem(rd, 3.); //texture(iChannel0, rd).rgb;\n             \n      //         refl = invGamma(refl);\n    \n               \n               refl *= mix(vec3(1), spectral_zucconi6(n.x*n.y*3.), .4); // reflect rainbows too\n               col = mix(col, .9*refl, .9);\n               col *= rdToCol(rd)*.35;\n                t = rm.z;\n               float fog = 1.-exp(-t*t*0.00005);\n \n        \n                col = mix(col, vec3(0.510,0.969,0.961), fog);\n                if(t > 20.) col *= .2;;\n              \n            } \n\n        } else {\n            col =  mix(c1+.2, c2-.2, (pow(dot(uv, uv), .8)))*.5+.1; // background\n            \n            col *= .3;\n            \n            col = invGamma(col);\n\n        } \n        \n        float glow_v = 1.2-smoothstep(.0, 1., SIN(3.*tt));\n        col += glow_v*.05*glow *vec3(0.224,0.941,0.953) ;\n    }\n    \n    \n\n   // col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv));\n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    \n    col = pow(col*1.8, vec3(1.4))*2.;\n    col = gamma(col); // gamma\n    \n    \n    fragColor = vec4(col, 1.0 - t * 0.03);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n\n    col.g *=.7;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}