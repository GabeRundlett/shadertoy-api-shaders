{
    "Shader": {
        "info": {
            "date": "1640069192",
            "description": "Some stars for the Solstice.  \"Isogonal\" polygons where alternate sides are equal length, coloured according to \"winding number\", calculated using algorithm from Numerical Recipes.\n\nMouse sets polygon parameters (or press 'm' to stay with animation).",
            "flags": 16,
            "hasliked": 0,
            "id": "ft3XDl",
            "likes": 26,
            "name": "Solstice Stars",
            "published": 3,
            "tags": [
                "polygon",
                "winding",
                "semiregular"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 415
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Solstice Stars, Matthew Arcus, mla, 2021\n//\n// \"Isogonal\" polygons, coloured according to winding number.\n//\n// <mouse>: sets N,M parameters (unless m pressed)\n// m: disable mouse action\n// c: colouring\n// h: hatching\n// x: don't show compound polygons\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Two sets, A, B, of N evenly spaced points around the unit circle.\n// Connect A[i] to B[i] and B[i] to A[i+M]\n\nint N = 17; // 2N points\nint M = 3;  // Connect every M points\n\nfloat offset = 0.0; // Angular offset between point sets.\n\n// Parity = 0: set A, parity = 1: set B\nvec2 getpoint(int index, int parity) {\n  float theta = TWOPI*float(index)/float(N) + (float(parity)-0.5)*offset;\n  return vec2(cos(theta),sin(theta));\n}\n\n// Winding number - straight out of Numerical Recipes, streamlined\n// a little, and also getting distance to line.\n// Need a little bodge to detect returning to start (eg. when M divides N).\nint polywind(vec2 p, inout float d) {\n  int wind = 0, start = 0; \n  // Rebase everything to p\n  vec2 q = getpoint(0,0)-p;\n  for (int i = 1; i <= 2*N; i++) {\n    int index = M*(i>>1)%N;\n    vec2 r = getpoint(index+start,i&1)-p;\n    d = min(d,segment(q,r));\n    float t = determinant(mat2(q,r));\n    if (q.y <= 0.0) {\n      if (r.y > 0.0 && t > 0.0) wind++;\n    } else {\n      if (r.y <= 0.0 && t < 0.0) wind--;\n    }\n    // This next conditional handles the situation where\n    // M is a multiple of N, so we have a compound polygon.\n    if (index == 0 && (i&1) == 0) {\n      if (key(CHAR_X)) break; // Don't show compounds\n      // This code moves to the start of the next polygon.\n      start++;\n      r = getpoint(start,0)-p;\n    }\n    q = r;\n  }\n  d = sqrt(d);\n  return wind;\n}\n\nvec3 getcol(int i) {\n  vec3 col = vec3(1);\n  // Seasonal colours from https://www.schemecolor.com/\n  if (i == 3) col = vec3(135,10,30)/255.0;\n  else if (i == 1) col = vec3(255,194,70)/255.0;\n  else if (i == 2) col = vec3(92,134,10)/255.0;\n  else if (i == 0) col = vec3(199,52,8)/255.0;\n  else if (i == 4) col = vec3(0,93,0)/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float time = 0.1*iTime;\n  offset = TWOPI*(time + 0.5);\n  vec2 p = 1.05*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 mouse = vec2(0);\n  float mgrid = 20.0;\n  M = int(time);\n  if (!key(CHAR_M) && iMouse.x > 0.0) {\n    N = 3+int(mgrid*iMouse.x/iResolution.x);\n    M = int(mgrid*iMouse.y/iResolution.y);\n  }\n  M = 1+(M%(N-1));\n  p = p.yx; // Flip x and y\n  float px = fwidth(p.x);\n  vec3 col = vec3(1,1,0.6);\n  float d = 1e8;\n  int wind = polywind(p,d);\n  if (!key(CHAR_C) && (wind&1) != 0) col = getcol(abs(wind)>>1);\n  vec3 tex = texture(iChannel0,fragCoord/iResolution.x).xyz;\n  col = mix(vec3(0),col,smoothstep(-px,px,d-0.01*(0.5+0.5*dot(tex,tex))));\n  if (!key(CHAR_H) && (wind&1) != 0) {\n    // Hatching\n    float d = fract(30.0*(p.x));\n    d = min(d,1.0-d);\n    d /= 30.0;\n    float hwidth = 0.005*(0.5+dot(tex,tex));\n    col = mix(vec3(0),col,smoothstep(-px,px,d-hwidth));\n  }\n  col *= 0.5+0.5*sqrt(tex);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(uint x) {\n  return float(ihash(x))/pow(2.0,32.0);\n}\n\nfloat segment(vec2 a, vec2 b) {\n  b -= a;\n  float h = -dot(a,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  a+=b*h;\n  return dot(a,a);\n}\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}