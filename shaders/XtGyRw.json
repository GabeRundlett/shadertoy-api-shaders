{
    "Shader": {
        "info": {
            "date": "1535424780",
            "description": "Random mistake that reminds me of Helen Frankenthaler's colors",
            "flags": 0,
            "hasliked": 0,
            "id": "XtGyRw",
            "likes": 2,
            "name": "Frankenthaler",
            "published": 3,
            "tags": [
                "color"
            ],
            "usePreview": 0,
            "username": "momoro",
            "viewed": 553
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592654\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\nfloat atan201(float x, float y) {\n    return (atan(x, y) + PI) / (PI * 2.);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\nvec2 sin01(vec2 n) {\n    return sin(n)/2.+.5;\n}\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm1d(float x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 1.144;\n    float gain = 1.092;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(vec2(frequency*x));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat smootheststep(float t) {\n    return -20.*pow(t, 7.)+70.*pow(t,6.)-84.*pow(t,5.)+35.*pow(t,4.); // when smootherstep's second derivative isn't enough\n}\n\n\nfloat pcsmooth(float x) {\n    return -\n        pow(cos((PI*(x)/2.)), 3.) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec4 color;\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    st /=30.036;\n    st += vec2(0.000,-0.055);\n    \n    st *= rotate(iTime/.9);\n    \n    /////////////////////////////////////////////////////////////\n    // Blobby circle\n    #define arcs 7.\n    \n    float f = atan201(st.x, st.y); // angle\n    float m = smoothstep(0., 1., fract(f * arcs)); // mix amount\n\t\n     m = pcsmooth(fract(f*arcs));\n    \n    f = ceil(f * arcs) / arcs; // split up\n    \n    float fNext = f + 1./arcs;\n    // fNext = f;\n    \n    \n    // Smooth the blob at the end\n    bool e = false;\n    if(f > (arcs-1.)/arcs + .01) {\n\t\tfNext = 1./arcs;\n    }\n    \n    // Add noise\n    float amp = 10000.;\n    float freq = 30.;\n    \n    float offset = 1.144 + iTime/300.;\n    f = fbm1d(f, amp, freq, offset);\n    fNext = fbm1d(fNext, amp, freq, offset);\n    \n    f =  map(f, -20., 1., 0.648, 0.712);\n    fNext = map(fNext, -20., 1., 0.648, 0.712);\n\n    float len = length(st);\n\n    float mx = mix(f, fNext, m);\n    len += mx * 0.080;\n    \n  //  float c = smoothstep(len, 0.712, 0.900);\n    \n   // color.rgb = vec3(c);\n\n  //  color.a = 1.;\n    //color.rgb = vec3(mx);\n    \n    #define steps 10.\n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n        df = len + -0.040;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.028)) * 1.016 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/2.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.108);\n        hsv.y = .9;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.640) * f;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n    \n    st = st * rotate(-3.148);\n    st += vec2(-0.030,0.070);\n    st *= 1.288;\n\n    \n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n        df = len  *-0.116;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.036)) * 1.064 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/9.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.964);\n        hsv.y = .9;\n        hsv.z = .3;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.01) - 0.472;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n        \n    color = color;\n    \n    fragColor = color;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}