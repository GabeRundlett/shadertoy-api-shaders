{
    "Shader": {
        "info": {
            "date": "1633938640",
            "description": "simplex grid\nI had a look at the shader by flyguy: [url]https://www.shadertoy.com/view/ltfXWr[/url] \njust to make sure I was on the right track.\nMost of the lighting code is from Shane!\n ",
            "flags": 0,
            "hasliked": 0,
            "id": "NdcSDj",
            "likes": 20,
            "name": "Segment Simplex Grid",
            "published": 3,
            "tags": [
                "simplex"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "#define FAR 50.\n\n/*\n\n//I found this pretty tricky.\n\n//First imagine just a regular grid and I want to make segments\n//from each center point out in for directions to the four neighboring\n//center points\n\n//but each cell ends half way out in all directions so ofcours\n//if I just extend the segments out from one cell, they will\n//touch the segments coming from the neighbouring cells so that's good\n//and it worked.\n\n//but for a simplex grid and for this aesthetic with segments, I need\n//a segment on the diagonal.\n\n//So I basically had to start a new grid shifted 0.5 on x and z\n//to get a new cell that allowed for segments on the diagonal \n//without getting cut off. BECAUSE for some reason, along the diagonal\n//if theyu get cut they don't just touch the neighbors. Instead\n//there are tons of artifacts.\n\n//so I'm using two coordinate systems and calculating the height\n//for 6 points (4 for the first system and 2 for the second)\n\n//and I'd honestly love to have small spheres or gems or something\n//at each vertex but the skewing skews the spheres so they look off.\n\n//I might come back and experiment more later though.\n\n*/\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    p/=1.9;\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    //f += 0.1250*noise( p ); p = m*p*2.01;\n    //f += 0.0625*noise( p ); \n    return f*1.3;\n}\n\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 snoise3( in float x )\n{\n#if 1    \n    return -1.0 + 2.0*textureLod( iChannel2, vec2(x,4.5)/256.0, 0.0 ).xyz;\n#else    \n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return -1.0 + 2.0*mix( hash3(p+0.0), hash3(p+1.0), f );\n#endif    \n}\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\nfloat planeVonTri(vec3 p, vec3 A, vec3 B, vec3 C){\n    \n    vec3 BA = A - B;\n    vec3 CA = A - C;\n    vec3 n  = normalize(cross(BA,CA));\n    //where is the intersection of line and plane?\n    //plane = dot(n,P) = 0\n    //line = ro + rd*t = P\n    float t = dot(n,p-A);\n    \n return t;   \n}\nfloat seggy( vec3 P, vec3 A, vec3 B){\n    \n    //dist auf line segment zu punkt\n    //nahrest dist auf line zu punkt\n    //P = A + t*(B-A);\n    //dot((P-P3),(B-A)) = 0\n    //(A+t*(B-A)-P3)*(B-A)) = 0;\n    //A*(B-A)+t*(B-A)*(B-A)-P3*(B-A) = 0\n    //A*(B-A) - P3*(B-A) + t*(B-A)*(B-A)\n    //(A-P3)*(B-A) + t*(B-A)*(B-A)\n    //t = dot((A-P3),(B-A)) / dot((B-A),(B-A));\n    vec3 AP = P-A;\n    vec3 BA = B-A;\n    \n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n                    \n    vec3 P3 = A + t*BA;                \n    float dist = length(P - P3) - 0.03;\n    return dist;\n}\n\nmat2 rot(float a){\n    float cs = cos(a),si = sin(a);\n    return mat2(cs, si, -si, cs);\n}\n\n\nfloat objectID = 0.;\nfloat glow = 0.;\n\n//FROM DAVE HOSKINS\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n\nfloat map(vec3 p){\n    /*\n    float PosX, PosY;\n    PosX = 1.0 - iMouse.x/iResolution.x*4. + 0.5;//0.2*2.*(rechts - links);\n    PosY = 1.0 - iMouse.y/iResolution.y*4. + 1.5;\n    float cs = cos(PosX), si = sin(PosX);\n    //p.xy = mat2(cs, si, -si, cs)*p.xy;\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n\t//p*=0.9;*/\n    \n    p.xz *= mat2(1.1547, 0., 1.1547*0.5,1.);\n    float sphere_radius = 0.35;\n    vec3 sp = p;\n   // sp.y -= 0.23;\n    //float k = length(sp) - sphere_radius;\n    float alle = 100.;\n    //sp = p;\n    \n\n    //sp.y += 0.5;\n    //sp.xz *= rot(sp.y*3.);\n    \n    \n    \n    \n    sp.xz = fract(p.xz)-0.5;\n    vec2 id = floor(p.xz);\n    float ball_gross = fract(sin(dot(vec2(12.55,74.2),id))*452354.);\n    float t = iTime;\n    \n    float gross = 1.3;\n    \n    float height = fbm4(id+t)*gross;\n    float heightL = fbm4((id + vec2(0.,1.))+t)*gross;\n    float heightR = fbm4((id + vec2(0.,-1.))+t)*gross;\n    float heightV = fbm4((id + vec2(-1.,0.))+t)*gross;\n    float heightH = fbm4((id + vec2(1.,0.))+t)*gross;\n    \n    \n    float k = seggy(sp, vec3(0.,height,0.), vec3(-1.,heightV,0.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0., heightL,1.0));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0.,heightR,-1.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(1.0,heightH,0.0));\n    alle = smin(alle, k, 0.);\n    \n    //k = length(sp - vec3(0.,height,0.))-0.03-ball_gross*0.037;\n    //alle = smin(alle, k, 0.);\n    \n    //k = seggy(sp - vec3(id.x, height, id.y), vec3(id.x, height, id.y), \n    //                   vec3(0.0,0.,0.0));\n    //alle = smin(alle, k, 0.);\n    \n    vec3 st = p;\n    \n    //this screwed me up for a (h)while\n   // st.y += 0.5;\n    \n    //HERE:\n    //I create a new shifted coord system so that I can get \n    //that pesky diagonal segment\n    st.xz = fract(p.xz-0.5)-0.5;\n    vec2 id2 = floor(p.xz-0.5);\n    \n    \n    //for floor here, actually:\n    //the mid point is the + 0.5,0.5\n    //the bottom is 0,0 because that is the floor value, id\n    //and the top would have to be + 1.,1.\n    \n    float heightDB = fbm4(id2 +t)*gross;\n    float heightDT = fbm4(id2 + vec2(1.) +t)*gross;\n    \n    /////\n    float heightTLT = fbm4(id2 + vec2(0.,1.) +t)*gross;\n    float heightBRB = fbm4(id2 + vec2(1.,0.) +t)*gross;\n    \n    //float heightMD = fbm4(id2 - vec2(0.5))*gross;\n    \n    //THE DIAGONAL!!\n    k = seggy(st, vec3(-0.5, heightDB, -0.5), \n                  vec3( 0.5, heightDT,  0.5) );\n                  \n    alle = smin(alle, k, 0.);\n    \n    //check which side of the diagonal of the square we are on\n    //and make a plane with the three coordinates of that triangle\n    float pl = st.x < st.z \n    \n                         ?\n                        \n               planeVonTri(st,\n                     vec3( 0.5, heightDT,  0.5),\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3(-0.5, heightTLT, 0.5) )\n                     \n                         : \n                        \n               planeVonTri(st,\n                     //you need to have this exact order for A,B and C!\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3( 0.5, heightDT,  0.5),\n                     \n                     vec3( 0.5, heightBRB, -0.5) );\n    \n    \n    //kind of a Shane x Nusan hybrid ID check\n    if(pl < 0.005){\n       // glow += 0.0001/pow(pl,0.2);\n        objectID = 1.;   \n    }\n    alle = min(alle, pl);\n\n   //\n   //alle = min(alle, length(st)-0.15);\n    return alle;// min(alle, sp.y+0.7-fbm4(p.xz));\n    \n}\n\n//FROM SHANE\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.95;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n//FROM SHANE\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n\n//FROM SHANE?\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n//FROM SHANE!\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = objectID == 1. ? vec3(.08,0.,0.) :vec3(.3,0.18,0.04)*0.7;//getObjectColor(sp);\n   // if(objectID == 2.) objCol = vec3(1.);\n    \n    float specFact = objectID == 1. ? 6. : 20.;\n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff*8. + .15) + vec3(.8, .5, .2)*spec*specFact) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, pow(t/FAR,5.));\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0.3,0.051,0.), fogF); \n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself at this point. :)\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    //rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    //rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 2. + sin(iTime)*0.1, -4.5 + iTime*4.);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 2., 3.5);\n    \n    vec3 sceneColor;\n    float t = trace(ro, rd);\n    //sceneColor = mix(sceneColor, vec3(0.3,0.051,0.), clamp(pow(t/FAR, 20.),0.,1.));\n    if(t < FAR){\n    ro += rd*t;\n    vec3 sn = getNormal(ro);\n    sceneColor = doColor(ro, rd, sn, lp, t);\n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n    \n   \n    \n\n   // sceneColor += texture(iChannel1,rd).xyz*0.01;\n    \n    sceneColor *= sh;\n    sceneColor += glow;\n    }\n    else{\n    \n    sceneColor = vec3(0.);//texture(iChannel1,rd).xyz*0.51;\n    //sceneColor += ;\n    \n    //sky gradient\n    sceneColor = mix(sceneColor, vec3(0.3,0.051,0.), pow(1.-uv.y,5.)*0.24);\n    \n    //stars\n    sceneColor = mix(sceneColor, \n                    vec3(0.9), \n                    pow(texture(iChannel2 ,uv).r, (80.)));\n                    \n    /*sceneColor = mix(sceneColor, vec3(0.,0.0,0.), \n                 1.-smoothstep(0.12,0.26,\n                 length(uv-vec2(0.0))-0.25));\n       */          \n                 //1.-smoothstep(0.18,0.2,length(uv)-0.25));\n    sceneColor = mix(sceneColor, vec3(0.9,0.5,0.1), \n                    clamp(pow(1.-(length(uv)-0.2),4.)*0.04, 0., 1.));\n                  \n    sceneColor = mix(sceneColor, vec3(0.9,0.5,0.1), \n                    clamp(pow(1.-(length(uv)-0.52),8.)*0.01, 0., 1.));\n      \n    sceneColor = mix(sceneColor, vec3(1.,0.75,0.5), \n                    clamp(pow(1.-(length(uv)-0.34),300.)*0.1, 0., 1.));\n      \n    \n    //sceneColor = mix(sceneColor, vec3(1.),  pow(1.-(length(uv)-0.4),60.));\n    \n    }\n   \n    \n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}