{
    "Shader": {
        "info": {
            "date": "1699417376",
            "description": "Nyancats running on a spherical tetrahedron rotating in hyperspace.",
            "flags": 0,
            "hasliked": 0,
            "id": "mlcczj",
            "likes": 3,
            "name": "Nyancats Tetra Race",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "tetrahedron",
                "nyancat",
                "stereographic",
                "hypersphere"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 170
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Nyancats Tetra Race\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// DOCUMENTATION:\n//  - https://people.maths.ox.ac.uk/trefethen/lightning.html\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 7.;\nconst float CAM_FLE = 1.3;\nconst float BBOX_RADIUS = 6.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BBOX_RADIUS;\n\n// ray march\nconst int MAX_MARCHING_STEPS = 300;\nfloat RAY_STEP_FACTOR3 = 0.568;\nconst float RAY_PRECISION = 0.001;\n\n// 4D rotation\nfloat ROT_4D_a = 1./60.;\n\n// equal spaced skin width\nconst float SD_w0 = 0.1;\n\n// texture\nconst float TEX_UV_SHARPNESS = 0.00000001;\nconst vec2  TEX_UV_SUBDIV = vec2(6., 1.);\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {   \n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sig(sr): sens of rotation, abs(sr) : number edges per face\n    vec2 z = vec2(0.);\n    \n    // stereographic 4D, rotation\n    p = rot4D( p, 2.*PI*ROT_4D_a, sqrt(abs(8.)));\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell. \n    pn = tetra_cells(pn, cell_id, sr);\n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    // complex plane   \n    z = cTeraPolyArc2disk(z);\n\n    /// r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (8.<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(8.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    /// stereographic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    \n    float fracu = 1.0;\n    ////fractal level 0: Torus\n    au = atan(p.y, p.x);\n    rxy = length(p.xy); \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= 8.;\n\n    // distance estimation\n    float d = log(length(z));\n    \n    // equal spaced skin\n    d =  abs(d) - SD_w0;\n    \n    #if 0\n    st_assert( d != INF, 0 ); // Shows the +INF singularity as a sphere (floating point precision).\n    #else\n    if (d == INF) {d = 1.;} // step through the singularity\n    #endif\n    \n    // torus complex plane, torus angle_u, platonic solid cell_id\n    mat.xy = z; mat.z = au *fracu, mat.w = cell_id;\n    return d;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BBOX_RADIUS));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR3;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) // max steps\n    { \n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t; //th = 0.0001; // minimal bound surface hit\n        float h = map( pos);\n        if( t>dis.y || h<th ) break; // ray outside BB or hit.\n        t += h*fh; // distance\n    }\n    if( t<dis.y ) // ray inside BB\n    {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) {\n\t// camera transformation\n\tif (iMouse.x > 0.0)\n\t{\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n\treturn p.xyz;\n}\n\nvec4 nyancat(vec2 z, float scale, vec2 ju, float time) {   \n    z.x = fract(z.x-time/scale); // run, input z.x in [0., 1.], periodic & cyclic in x-direction (0)\n    z.y = fract(z.y);            // periodic in y-direction (comment in out)\n    z *= scale;\n    z.y -= ju.x*abs(cos(PI*ju.y*time));           // jump, amplitude, frequency\n    return ((.05<z.x&&z.x<.9)&&(0.<z.y&&z.y<.65)) // BB rectangle\n    ? texture(iChannel1,\n        vec2(40./256.*(z.x+floor(6.*fract(ju.y*time))),z.y+.2)) // sprite animation loop\n    : vec4(0.);   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // slider mapping\n    RAY_STEP_FACTOR3 = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\n    \n    // time modulation    \n    ROT_4D_a *= 1. * iTime;\n    \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // ray\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px ); // distance hit ray surface\n\n        // color\n        vec3 col_sun = vec3(1.,1.,0.8);\n        vec3 col_sky = vec3(0.7,0.7,1.);\n        \n        // background\n        vec3 col = col_sky;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // platonic solid sector id\n            float ps_id = mat.w;\n            col = h2rgb(ps_id/float(4));\n            \n            // uv-coords\n            vec2 mat_uv = 0.5*vec2(mat.z, atan(mat.y,mat.x))/PI;\n            vec2 mat_ny = mat_uv;\n            \n            // uv-grid\n            mat_uv.xy *= vec2(3.*1.,3.);\n            col *= 0.5+ 0.5*smoothstep( -TEX_UV_SHARPNESS,TEX_UV_SHARPNESS\n                                      , sin(2.*PI*mat_uv.x)*sin(2.*PI*mat_uv.y));\n            // nyancat            \n            mat_ny += vec2(0.,1./3.);\n            mat_ny *= vec2(7.,1.);\n            vec4 tex = nyancat(mat_ny.xy, 3., vec2(0.1,1.), 0.5*iTime);\n            col = mix(col,tex.rgb,tex.a);\n\n            // lighting\n            // point_light\n            vec3 point_lo = vec3(0, -10, 0);\n            vec3 point_ld = normalize(point_lo - p);\n\n            // phong: ambient- diffuse- specular- light reflections\n            col = col * 0.5  * col_sky\n                + col * 0.25 * col_sun * clamp(dot(point_ld, n), 0., 1.)\n                + col * 0.75 * col * col_sun * pow(clamp(dot(reflect(point_ld, n), -rd), 0., 1.), 10.);\n            // fresnel\n            col += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.4 * col_sky;\n        }\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    fragColor = vec4(rgb2srgb(tot),1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float INF = abs(1./0.);\nconst float NAN = abs(0./0.);\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cTeraPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 15; // poles\n    const vec2[NUM_j] rf = vec2[]\n    (vec2(-0.4534, -0.8913)\n    ,vec2( 0.5001,  0.8660)\n    ,vec2(-1.0000,  0.0001)\n    ,vec2( 0.5008, -0.8656)\n    ,vec2(-0.5452,  0.8383)\n    ,vec2( 0.1901,  0.9818)\n    ,vec2( 0.9875, -0.1576)\n    ,vec2(-0.9856, -0.1691)\n    ,vec2( 0.4224, -0.9064)\n    ,vec2( 0.5738,  0.8190)\n    ,vec2(-0.9995,  0.0311)\n    ,vec2( 0.4858,  0.8741)\n    ,vec2( 0.5760, -0.8175)\n    ,vec2(-1.0000, -0.0061)\n    ,vec2( 0.4959, -0.8684));\n    \n    const vec2[NUM_j] rw = vec2[]\n    (vec2( 0.2728,  0.0   )  \n    ,vec2( 0.0003,  0.0126)\n    ,vec2(-0.0016, -0.0121)\n    ,vec2(-0.0172,  0.0324)\n    ,vec2( 0.1417, -0.4629)\n    ,vec2(-0.4681, -0.2288)\n    ,vec2(-0.2433,  0.2822)\n    ,vec2( 0.1996, -0.0082)\n    ,vec2( 0.2884, -0.0353)\n    ,vec2(-0.0666,  0.1824)\n    ,vec2(-0.0357, -0.1136)\n    ,vec2(-0.1091,  0.0396)\n    ,vec2(-0.0831,  0.2627)\n    ,vec2( 0.0598, -0.0284)\n    ,vec2( 0.0597,  0.0760));\n\n    const vec2[NUM_j] rz = vec2[]\n    (vec2(-0.239570, -0.459171)\n    ,vec2( 0.354172,  0.611300)\n    ,vec2(-0.706487,  0.001072)\n    ,vec2( 0.356785, -0.606740)\n    ,vec2(-0.277869,  0.437059)\n    ,vec2( 0.047259,  0.573454)\n    ,vec2( 0.515842, -0.066306)\n    ,vec2(-0.591622, -0.166501)\n    ,vec2( 0.221135, -0.605193)\n    ,vec2( 0.413545,  0.494105)\n    ,vec2(-0.671697,  0.057599)\n    ,vec2( 0.309337,  0.611574)\n    ,vec2( 0.414577, -0.491758)\n    ,vec2(-0.695342, -0.019940)\n    ,vec2( 0.334074, -0.612218));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);;\n}\n\n/// 4D transformation\nvec4 sp3to4D(vec3 p3) {\n    float r2_p3=dot(p3,p3);\n    if(r2_p3<=1.) {               // Pn\n        float k = 2./(1.+r2_p3);\n        return vec4(k*p3,(1.-k));}\n    else {                        // Ps TODO: Spherical singularity does not disappear! That would be too easy. :)\n        p3 = p3/r2_p3; r2_p3 = dot(p3,p3);\n        float k = 2./(1.+r2_p3);\n        return vec4(k*p3,-(1.-k));}\n}\n\nvec3 sp4to3D(vec4 p4) {\n    if(p4.w<=0.) {                 // Pn\n        float k = 1./(1.-p4.w);\n        return k*p4.xyz;}\n    else {                         // Ps TODO: Spherical singularity does not disappear! That would be too easy. :)\n        float k = 1./(1.+p4.w);\n        vec3 p3 = k*p4.xyz;\n        return p3/dot(p3,p3);}\n}\n\nvec3 rot4D(in vec3 p, in float t, in float r_inv) {\n    p /=r_inv;            // normalize to hyper-unit-circle (unit-sphere)\n    vec4 p4 = sp3to4D(p); // forward project 3d hyper-plane to 4d hyper-unit-sphere\n    // rotations\n    p4.xw = cmul(p4.xw, vec2(cos(-t),sin(-t)));\n    p4.xy = cmul(p4.xy, vec2(cos(-0.7*t),sin(-0.7*t)));\n    p4.yz = cmul(p4.yz, vec2(cos(-0.3*t),sin(-0.3*t)));\n    p = sp4to3D(p4);      // back project 4d hyper-unit-sphere to 3d hyper-plane (3d cartesian space)\n    p *=r_inv;            // unnormalize from hyper-unit-circle (unit-sphere)\n    return p;\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 tetra_cells(in vec3 p, out float cell_id, out float sr){\n\t//// tetrahedron (bounded by a cube)\n\t// cells: A,B,C,D\n\t// cell walls defined by the face_normal\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    \n    // map n-cells to 1-cell by rotation\n    // rotation angles\n    const float a45 = PI/4.;             // 45° \n    const float a35 = atan(sqrt(8.))/2.; // 35.264°\n    const float a30 = PI/6.;             // 30°\n    \n    const vec2 ei_a45 = vec2(cos(a45), sin(a45));\n    const vec2 ei_a35 = vec2(cos(a35), sin(a35));\n    const vec2 ei_a30 = vec2(cos(a30), sin(a30));\n    \n    vec2 ei_y = ei_a45;   \n    vec2 ei_x = ei_a35;\n    vec2 ei_z = ei_a30;\n    // symmetries\n    if(nBA && nCA && nDA) //inside cell A\n\t{\n\t\tcell_id =  0.;\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if( nCB && nDB && !nBA) //inside cell B\n\t{\n\t\tcell_id =  1.;\n\t\tei_y   *= -1.; // a = -3.*45°\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if(!nCA && !nCB && nDC) //inside cell C\n\t{\n\t\tcell_id =  2.;\n\t\tei_y.x *= -1.; // a = +3.*45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\telse if(!nDA && !nDB && !nDC)//inside cell D\n\t{\n\t\tcell_id =  3.;\n\t\tei_y.y *= -1.; // a = -45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\tp.zx = cmul(p.zx,ei_y); // y-axis\n\tp.yz = cmul(p.yz,ei_x); // x-axis\n\tp.xy = cmul(p.xy,ei_z); // z-axis\n\t// 3 edges per face, non cyclic\n\tsr = 3.;\n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n    // https://iquilezles.org/articles/intersectors/\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n \n// colorspace transformations\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}