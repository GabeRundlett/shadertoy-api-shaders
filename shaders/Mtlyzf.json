{
    "Shader": {
        "info": {
            "date": "1505850790",
            "description": "mouse.x sets shape\nmouse.y rotates object\n\nfork of:\nhttps://www.shadertoy.com/view/XdfGW4\nwithout global var.\nvery minor fix for better compatibility. might update it more later.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mtlyzf",
            "likes": 15,
            "name": "patched 4D Polytopes",
            "published": 3,
            "tags": [
                "4d",
                "polychora",
                "platonic",
                "hyper",
                "polytope"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1025
        },
        "renderpass": [
            {
                "code": "/*\nfork of:\nhttps://www.shadertoy.com/view/XdfGW4\n Without global var.\n  Very minor fix for better compatibility.\n I might update it more later.\n*/\n\n// Original DE from Knighty's Fragmentarium frag.\n// Adapted by Syntopia\n\n// Click in the six different zones, to display\n// the six regular polytopes in 4D.\n//\n// Move up/down in a zone to rotate in 4D.\n//\n// For more info:\n// http://blog.hvidtfeldts.net/index.php/2012/02/distance-estimated-polychora/\n//\n// Knighty's original thread on FractalForums, where the code was posted:\n// http://www.fractalforums.com/general-discussion-b77/solids-many-many-solids/\n\n/*\nType,U,V,W,T\n3,0,1,0,0 - 5-cell (hypertetrahedron)\n4,0,1,0,0 - 8-cell (hypercube or Tesseract)\n4,0,0,1,0 - 24-cell (hyperoctahedron)\n4,0,0,0,1 - 16-cell  (no 3D equvivalent)\n5,0,1,0,0 - 120-cell (hyperdodecahedron)\n5,0,0,0,1 - 600-cell (hypericosahedron)\n*/\n\n#define MaxSteps 40\n#define MinimumDistance 0.05\n#define normalDistance     0.002\n\n#define PI 3.141592\n#define Scale 3.0\n#define FieldOfView 0.5\n#define Jitter 0.6\n#define FudgeFactor 1.0\n\n#define Ambient 0.32184\n#define Diffuse 0.5\n#define LightDir vec3(1.0)\n#define LightColor vec3(0.6,1.0,0.158824)\n#define LightDir2 vec3(1.0,-1.0,1.0)\n#define LightColor2 vec3(1.0,0.933333,1.0)\n#define Offset vec3(0.92858,0.92858,0.32858)\n\n// Return rotation matrix for rotating around vector v by angle\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Polychora parameters\nint Type = 5;\n\n\nfloat VRadius = 0.05048;\nfloat SRadius = 0.05476;\n\nmat3 rot;\nvec4 nc,nd,p;\nfloat zone = 0.0;\n\nvoid init(inout float U,inout float V,inout float W,inout float T){\n\tvec2 UV = iMouse.xy/iResolution.xy;\n\tfloat aa = 0.0;\n\t\n\t// Different zone presets\n\tif (iMouse.z>0.0) {\n\t\tif (UV.x < 1./6.) {\n\t\t\tType = 3;U = 0.; V = 1.; W = 0.; T = 0.;\n\t\t\tzone = 1.0;\n\t\t} else if (UV.x < 2./6.) {\n\t\t\tType = 4;U = 0.; V = 1.; W = 0.; T = 0.;\n\t\t\tzone = 2.0;\n\t\t} else if (UV.x < 3./6.) {\n\t\t\tType = 4;U = 0.; V = 0.; W = 1.; T = 0.;\n\t\t\tzone = 3.0;\n\t\t} else if (UV.x < 4./6.) {\n\t\t\tType = 4;U = 0.; V = 0.; W = 0.; T = 1.;\n\t\t\tzone = 4.0;\n\t\t} else if (UV.x < 5./6.) {\n\t\t\tType = 5;U = 0.; V = 1.; W = 0.; T = 0.;\n\t\t\tzone = 5.0;\n\t\t} else  {\n\t\t\tType = 5;U = 0.; V = 0.; W = 0.; T = 1.;\n\t\t\tzone = 6.0;\n\t\t}  \n\t\taa = UV.y*90.;\n\t}\n\tfloat cospin=cos(PI/float(Type)), isinpin=1./sin(PI/float(Type));\n\tfloat scospin=sqrt(2./3.-cospin*cospin), issinpin=1./sqrt(3.-4.*cospin*cospin);\n\n\tnc=0.5*vec4(0,-1,sqrt(3.),0.);\n\tnd=vec4(-cospin,-0.5,-0.5/sqrt(3.),scospin);\n\n\tvec4 pabc,pbdc,pcda,pdba;\n\tpabc=vec4(0.,0.,0.,1.);\n\tpbdc=0.5*sqrt(3.)*vec4(scospin,0.,0.,cospin);\n\tpcda=isinpin*vec4(0.,0.5*sqrt(3.)*scospin,0.5*scospin,1./sqrt(3.));\n\tpdba=issinpin*vec4(0.,0.,2.*scospin,1./sqrt(3.));\n\t\n\tp=normalize(U*pabc+V*pbdc+W*pcda+T*pdba);\n\n\tvec3 RotVector = vec3(0.0,1.0,0.1);\n\trot = rotationMatrix3(normalize(RotVector), aa);//in reality we need a 4D rotation\n}\n\nvec4 fold(vec4 pos) {\n\tif (Type == 3) {\n\t\tfor(int i=0;i<3;i++){\n\t\t\tpos.xy=abs(pos.xy);\n\t\t\tfloat t=-2.*min(0.,dot(pos,nc)); pos+=t*nc;\n\t\t\tt=-2.*min(0.,dot(pos,nd)); pos+=t*nd;\n\t\t}\n\t} else if (Type == 4) {\n\t\tfor(int i=0;i<8;i++){\n\t\t\tpos.xy=abs(pos.xy);\n\t\t\tfloat t=-2.*min(0.,dot(pos,nc)); pos+=t*nc;\n\t\t\tt=-2.*min(0.,dot(pos,nd)); pos+=t*nd;\n\t\t}\n\t} else if (Type == 5) {\n\t\tfor(int i=0;i<15;i++){\n\t\t\tpos.xy=abs(pos.xy);\n\t\t\tfloat t=-2.*min(0.,dot(pos,nc)); pos+=t*nc;\n\t\t\tt=-2.*min(0.,dot(pos,nd)); pos+=t*nd;\n\t\t}\n\t}\n\treturn pos;\n}\n\nfloat DD(float ca, float sa, float r){\n\t//magic formula to convert from spherical distance to planar distance.\n\t//involves transforming from 3-plane to 3-sphere, getting the distance\n\t//on the sphere then going back to the 3-plane.\n\treturn r-(2.*r*ca-(1.-r*r)*sa)/((1.-r*r)*ca+2.*r*sa+1.+r*r);\n}\n\nfloat dist2Vertex(vec4 z, float r){\n\tfloat ca=dot(z,p), sa=0.5*length(p-z)*length(p+z);//sqrt(1.-ca*ca);//\n\treturn DD(ca,sa,r)-VRadius;\n}\n\nfloat dist2Segment(vec4 z, vec4 n, float r){\n\t//pmin is the orthogonal projection of z onto the plane defined by p and n\n\t//then pmin is projected onto the unit sphere\n\tfloat zn=dot(z,n),zp=dot(z,p),np=dot(n,p);\n\tfloat alpha=zp-zn*np, beta=zn-zp*np;\n\tvec4 pmin=normalize(alpha*p+min(0.,beta)*n);\n\t//ca and sa are the cosine and sine of the angle between z and pmin. This is the spherical distance.\n\tfloat ca=dot(z,pmin), sa=0.5*length(pmin-z)*length(pmin+z);//sqrt(1.-ca*ca);//\n\treturn DD(ca,sa,r)-SRadius;\n}\n\n//it is possible to compute the distance to a face just as for segments: pmin will be the orthogonal projection\n// of z onto the 3-plane defined by p and two n's (na and nb, na and nc, na and and, nb and nd... and so on).\n//that involves solving a system of 3 linear equations.\n//it's not implemented here because it is better with transparency\n\nfloat dist2Segments(vec4 z, float r){\n\tfloat da=dist2Segment(z, vec4(1.,0.,0.,0.), r);\n\tfloat db=dist2Segment(z, vec4(0.,1.,0.,0.), r);\n\tfloat dc=dist2Segment(z, nc, r);\n\tfloat dd=dist2Segment(z, nd, r);\n\t\n\treturn min(min(da,db),min(dc,dd));\n}\n\nfloat DE(vec3 pos) {\n\t//return length(pos)-1.;\n\tfloat r=length(pos);\n\tvec4 z4=vec4(2.*pos,1.-r*r)*1./(1.+r*r);//Inverse stereographic projection of pos: z4 lies onto the unit 3-sphere centered at 0.\n\tz4.xyw=rot*z4.xyw;\n\tz4=fold(z4);//fold it\n\n\treturn min(dist2Vertex(z4,r),dist2Segments(z4, r));\n}\n\nvec3 lightDir;\nvec3 lightDir2;\n\n// Backgorund\nvec3 bg(vec3 dir) {\n\tif (dir.z>0.0) {\n\t\tfloat sun =clamp(dot(dir, normalize(vec3(0.2,0.2,0.5))),0.0,1.0);\n\t\tvec3 sky = vec3(0.6,0.4,1.0)*(1.0-dir.z*dir.z*0.4);\n\t\tsky += 1.3*pow(sun,30.0)*vec3(1.0,0.8,0.8);\n\t\treturn sky;\n\t} else {\n\t\tvec3 ground =  vec3(0.6,0.4,0.4)*(pow(abs(dir.z),0.1)*1.0);\n\t\treturn ground;\n\t}\n}\n\n\n// Lighting. Adds some environment reflections\nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tfloat diffuse = 0.3*max(0.0,dot(-normal, lightDir)); // Lambertian\n\tfloat diffuse2 =0.3* max(0.0,dot(-normal, lightDir2)); // Lambertian\n\tvec3 r = reflect(normal,dir);\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color) +0.5*bg(r);\n}\n\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n// Returns (r,theta [0..pi],phi [-pi,pi])\nvec3 cartesianToSpherical(vec3 p) {\n\tfloat r = length(p);\n\tfloat theta = acos(p.z/r);\n\tfloat phi = atan(p.y,p.x);\n\treturn vec3(r,theta,phi);\n}\n\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i <= MaxSteps; i++) {\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\t\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\tfloat ao = 1.0-float(steps)/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\tvec3 b = bg(dir);\n\tb = mix(b, vec3(0.0,0.0,0.0), 0.2);\n\tif (steps == MaxSteps) {\n\t\treturn vec4(b,1.0);\n\t}\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor =(color*Ambient+light)*(ao);\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float U = 0.0*cos(iTime)*0.5+0.1;\nfloat V =  0.2*sin(iTime*0.1)*0.5+0.2;\nfloat W =  1.0*cos(iTime*1.2)*0.5+0.5;\nfloat T =  0.01;\n\tinit(U,V,W,T);\n\t\n\t// Camera \n\tvec3 camPos = 0.4*(12.0+2.0*sin(iTime*0.6))*vec3(cos(iTime*0.3),sin(iTime*0.3),-1.6);\n\tvec3 target = vec3(0.0,0.0,0.0);\n\tvec3 camUp  = vec3(0.0,0.0,1.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tlightDir= -normalize(camPos+7.5*camUp);\n\tlightDir2=-normalize( camPos- 6.5*camRight);\n\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tfloat vignette = 0.2*pow(dot(coord,coord),1.0);\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tvec3 col = rayMarch(camPos, rayDir, fragCoord).xyz;   \n    col = clamp(col, 0.0,1.0);\n    col *=(1.0-vignette);\n\t\n\t// Marker at the bottom to indicate zone\n\tfloat pos =6.0*fragCoord.x/iResolution.x;\n\tif (pos<zone && pos>zone-1.0 && coord.y<-0.8) {\n\t\tcol = col.xxx;\n\t}\n    col=col.yzx;//color swivel to distinguish from older version\n\t\n\tfragColor = vec4(col,1.0);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}