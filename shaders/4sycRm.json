{
    "Shader": {
        "info": {
            "date": "1521394407",
            "description": "Tech Demo I made for Train Jam 2018 in KodeLife and ported to ShaderToy. I'm really pleased with it!\nWalk around by clicking right or left and the character will move around. There's not much gameplay... Have fun!\n- Made in 48 hours",
            "flags": 32,
            "hasliked": 0,
            "id": "4sycRm",
            "likes": 9,
            "name": "Dancing Trees - Train Jam 2018",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "3d",
                "game",
                "sdf",
                "fast",
                "fun",
                "trees",
                "dancing",
                "train",
                "jam",
                "leaves",
                "trainjam",
                "48hours"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 838
        },
        "renderpass": [
            {
                "code": "// Click to the left or right of the screen to make the character move.\n// That's it... Have fun!\n\nfloat Noise(in vec2 p)\n{\n    return fract(sin(p.x + 432.55342) * 653.2 + cos(p.y * 431.431 + 75487.3) * 4321.543232);\n}\n\nvec3 Translate(in vec3 p, in vec3 t)\n{\n    return p - t;\n}\n\nfloat Box(in vec3 p, in vec3 d)\n{\n    return length(max(abs(p) - d, 0.0));\n}\n\nfloat Cylinder(in vec3 p, in vec3 d, in float r, in float h)\n{\n    float dist = dot(p, d);\n    return max((distance(p, d * dist) - r), Box(p, vec3(r, r, h)));\n}\n\nfloat Plane(in vec3 p, in vec3 d, in float h)\n{\n    return dot(p, d) - h;\n}\n\nfloat SDF(in vec3 p)\n{\n    float c1 = Cylinder(Translate(p, vec3(-0.9, 0, -0.1)), vec3(0.0, 0.0, 1.0), 0.1, 0.1);\n    float c2 = Cylinder(Translate(p, vec3(0.9, 0, -0.1)), vec3(0.0, 0.0, 1.0), 0.1, 0.1);\n    \n    float tv = Plane(p, vec3(0.0, 0.0, -1.0), 0.05);\n    float b = Box(p, vec3(0.6, 0.35, 0.5));\n    \n    float threeButtons = 10000.0;\n    for(float i = 0.0; i < 3.0; i += 1.0)\n    {\n        threeButtons = min(threeButtons, Box(Translate(p, vec3(-1.02 + i * 0.09, -0.18, 0.0)), vec3(0.03, 0.02, 0.1)));\n    }\n    \n    return min(min(min(min(c1, c2), tv), b), threeButtons);\n}\n\nvec3 Norm(in vec3 p)\n{\n    const float E = 0.01;\n    return normalize(vec3(\n        SDF(p + vec3(E, 0.0, 0.0)) - SDF(p - vec3(E, 0.0, 0.0)),\n        SDF(p + vec3(0.0, E, 0.0)) - SDF(p - vec3(0.0, E, 0.0)),\n        SDF(p + vec3(0.0, 0.0, E)) - SDF(p - vec3(0.0, 0.0, E))\n    ));\n}\n\nvec4 RenderTV(in vec2 uv, in float aspect)\n{   \n    vec3 f = vec3(0, 0, 1.0);\n    vec3 r = vec3(1.0, 0, 0);\n    vec3 u = vec3(0, 1.0, 0);\n    \n    vec3 o = vec3(0,0,-2.0);\n    vec3 dir = normalize(f * 3.0 + r * uv.x * aspect + u * uv.y);\n    \n    vec4 fc = vec4(0.0);\n    float d = 0.0;\n    for(float i = 0.0; i < 64.0; i+=1.0)\n    {\n        vec3 p = o + dir * d;\n        float sdf = SDF(p);\n        \n        if(sdf < 0.001)\n        {\n            const vec3 ld = normalize(vec3(-0.707, 0.707, -0.707));\n            vec3 n = Norm(p);\n            \n            float isTV = step(o.z + 1.94, p.z);\n            vec4 tvTex = vec4(vec4(0.7, 0.5, 0.2, 1.0)) + Noise(vec2(uv.y)) * 0.1;\n            float diff = max(dot(n, ld), 0.15);\n            \n            vec4 tex = mix(vec4(0.7, 0.9, 0.7, 1.0), tvTex, isTV);\n            fc = tex * diff;\n            break;\n        }\n        \n        d += sdf;\n    }\n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy* 2.0 - 1.0;\n\n    float noise = Noise(vec2(floor(uv.y * 100.0 + iTime * 50.0)));\n    vec4 pp = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    \n    vec4 b = RenderTV(uv, iResolution.x / iResolution.y);\n    fragColor =  mix(b, pp * min(noise + 0.7, 1.0), pp.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 13,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(iFrame == 0)\n    {\n        InitState();\n    }\n    else\n    {\n        LoadState(iChannel0);\n        \n        vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n        gameState.playerPos += vec2(mouse.x * 0.3 * iTimeDelta, 0.0);\n        gameState.movementSpeed = vec2(mouse.x * 0.3 * min(iTimeDelta, 0.016) * 150.0, 0.0);\n        \n        gameState.playerPos.x = clamp(gameState.playerPos.x, -3.5, 3.5);\n    }\n\n    SaveState(uv, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "struct GameState\n{\n    vec2 playerPos;\n    vec2 movementSpeed;\n} gameState;\n\nvoid InitState()\n{\n    gameState.playerPos = vec2(-0.6, -0.25);\n    gameState.movementSpeed = vec2(0.0, 0.0);\n}\n\nvoid LoadState(in sampler2D channel)\n{\n    vec4 playerFetch = texelFetch(channel, ivec2(0), 0);\n    \n    gameState.playerPos = playerFetch.xy;\n    gameState.movementSpeed = playerFetch.zw;\n}\n\nfloat IsInside( vec2 p, vec2 c ) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x,d.y);\n}\n\nvoid SaveValue(in vec2 currentLoc, in vec2 saveLoc, in vec4 value, out vec4 write)\n{\n    write = IsInside(currentLoc, saveLoc) > 0.0 ? value : write;\n}\n\nvoid SaveState(in vec2 currentLoc, out vec4 write)\n{\n    SaveValue(currentLoc, vec2(0.0), vec4(gameState.playerPos, gameState.movementSpeed), write);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const float PI = 3.14159;\n\nfloat Rect(in vec2 p, in vec2 s)\n{\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat Circle(in vec2 p, in float r)\n{\n    return length(p) - r;\n}\n\nvec2 Translate(in vec2 p, in vec2 t)\n{\n    return p - t;\n}\n\nvec2 Repeat(in vec2 p, in vec2 r)\n{\n    return mod(p, r) - r * 0.5;\n}\n\nfloat Noise(vec2 p)\n{\n    return fract(sin(p.x + 432.55342) * 653.2 + cos(p.y * 431.431 + 75487.3) * 4321.543232);\n}\n\nvec4 Ground(in vec2 p)\n{\n    float ground = Rect(Translate(p, vec2(0.0, -0.5)), vec2(5.0, 0.3 + sin(p.x * 2.5) * 0.01));\n\n    float gm = step(ground, 0.001);\n    \n    float grass = step(abs(p.y + 0.45), 0.15 + sin(p.x * 10.0) * 0.01 * sin(p.x * 3.0) * 4.0);\n    const vec4 grassC = vec4(0.5, 0.5, 0.1, 1.0);\n    vec4 groundC = vec4(0.7, 0.4, 0.2, 1.0) + sin(p.x * 2.0 + 3.4) * 0.01;\n    \n    return mix(grassC, groundC, grass) * gm;\n}\n\nvec4 Sky(in vec2 p)\n{\n    vec4 sun = vec4(1.0, 0.5, 0.3, 1.0) * max(1.0 - length(p - vec2(0.8, 0.5)), 0.0);\n    vec4 sky = vec4(0.2, 0.7, 0.7, 1.0) + sun;\n    return sky;\n}\n\nvec2 Rotate(vec2 p, float a)\n{\n    return vec2(p.x * cos(a) + p.y * sin(a), p.x * sin(a) + p.y * -cos(a));\n}\n\nvec4 Character(vec2 p)\n{\n    vec4 legs = vec4(0.0);\n    const vec4 skinColor = vec4(0.9 * 1.2, 0.6 * 1.2, 0.3 * 1.2, 1.0);\n\n    vec2 tp = Translate(Rotate(Translate(p, vec2(0.0, -0.4)), sin(iTime * 4.0) * PI / 4.0 * gameState.movementSpeed.x), vec2(0.0, 0.3));\n    float rleg = step(Rect(tp, vec2(0.1, 0.3)), 0.001);\n    legs = mix(legs, vec4(skinColor.rgb * rleg * 0.97, 1.0), rleg);\n    \n    vec2 ltp = Translate(Rotate(Translate(p, vec2(0.0, -0.4)), sin(-iTime * 4.0) * PI / 4.0 * gameState.movementSpeed.x), vec2(0.0, 0.3));\n    float lleg = step(Rect(ltp, vec2(0.1, 0.3)), 0.001);\n    legs = mix(legs, skinColor * lleg, lleg);\n    \n    float butt = step(Circle(Translate(p, vec2(0.07 * -sign(gameState.movementSpeed.x), -0.40)), 0.13), 0.001);\n    float butt2 = step(Circle(Translate(p, vec2(0.1 * -sign(gameState.movementSpeed.x), -0.40)), 0.14), 0.001);\n    legs = mix(legs, vec4(skinColor.rgb * butt2 * 0.9, 1.0), butt2);\n    legs = mix(legs, skinColor * butt, butt);\n    \n    float h = step(Circle(Translate(p, vec2(0.0, 0.5)), 0.4), 0.001);\n    float eye = step(Circle(Translate(p, vec2(0.2 * sign(gameState.movementSpeed.x), 0.6)), 0.07), 0.001);\n    \n    vec2 itp = Translate(Rotate(Translate(p, vec2(0.2 * sign(gameState.movementSpeed.x), 0.6)), sin(iTime * 3.0 + 1.21)), vec2(0.0, -0.02));\n    float iris = step(Circle(itp, 0.06), 0.001);\n    vec4 head = skinColor * h;\n    head = mix(head, vec4(eye), eye);\n    head = mix(head, vec4(0.0, 0.0, 0.0, 1.0) * iris, iris);\n    \n    float b = step(Rect(p, vec2(0.1, 0.4)), 0.001);\n    vec4 body = skinColor * b;\n    body = mix(body, legs, legs.a);\n    body = mix(body, head, head.a);\n    \n    return body;\n}\n\nvec4 FirstScene(in vec2 p, in vec2 uv)\n{\n    vec4 sky = Sky(uv);\n    vec4 ground = Ground(p);\n\n    vec2 cp = Translate(p, gameState.playerPos);\n    float c = Rect(cp, vec2(0.2, 0.2));\n    vec2 cUV = cp / vec2(0.1, 0.2);\n    \n    vec4 cc = Character(cUV * vec2(0.1 / 0.2, 1.0)) * step(c, 0.001);\n    \n    vec4 treeC = vec4(0);\n    vec2 tp = Translate(p, vec2(0.0, 0.25));\n    for(float i = 0.0; i < 50.0; i+=1.0)\n    {\n        float id = i / 20.0;\n        vec2 treeP = Translate(tp, vec2(-3.0 + (id * 3.3 + Noise(vec2(i) * 0.05)) + sin(tp.y * 8.0) * 0.02 * sin(iTime * 4.0), 0.0));\n        \n        float trunkRect = Rect(treeP, vec2(0.05 + (tp.y * tp.y) * 0.15, 0.48 + Noise(vec2(id)) * 0.07));\n        float cutoutCount = floor(Noise(vec2(id)) * 5.0);\n        for(float c = 0.0; c <= cutoutCount; c += 1.0)\n        {\n            float rad = 0.03 / cutoutCount;\n            float width = (rad + 0.03) * cutoutCount;\n            float cut = Circle(Translate(treeP, vec2(c * (rad + 0.04) - width * 0.46, -(0.48 + Noise(vec2(id)) * 0.07))) * vec2(1.0, 2.0), rad);\n            trunkRect = max(trunkRect, -cut);\n        }\n        \n        float branchCount = floor(Noise(vec2(id + 10.0)) * 5.0);\n        for(float b = 0.0; b <= branchCount; b += 1.0)\n        {\n            float branchNoise = Noise(vec2(b + id)) * 2.0 - 1.0;\n            float branchHeight = 0.1 + branchNoise * 0.3;\n            \n            vec2 branchp = Translate(treeP, vec2(0.12 * sign(branchNoise) -  + branchNoise * 0.08, branchHeight - cos(treeP.x * 40.0 + iTime * 3.0) * 0.01));\n            float branchRect = Rect(branchp, vec2(0.07 + branchNoise * 0.08, 0.01));\n            trunkRect = min(trunkRect, branchRect);\n        }\n        \n        float treeTrunk = step(trunkRect, 0.001);  \n        \n        float leaves = step(Circle(Translate(treeP, vec2(0.0, 0.4 + Noise(vec2(i / 10.0)) * 0.1)), 0.3  + sin(p.x * 20.0) * 0.01), 0.001);\n        \n        treeC = mix(vec4(0.4  - Noise(vec2(i / 50.0)) * 0.2, 0.7  + Noise(floor(p * 20.0)) * 0.1, 0.0, 1.0) * leaves, treeC, treeC.a);\n        \n        vec4 trunkColor = vec4(0.7 - Noise(vec2(i / 50.0)) * 0.1, 0.4, 0.0, 1.0);\n        trunkColor.rgb += sin(p.x * 300.0) * 0.01 * round(Noise(p * 10.0));\n        treeC = mix(trunkColor * treeTrunk, treeC, treeC.a);\n    }\n    \n    vec4 fTreeC = vec4(0);\n    vec2 ftp = Translate(p, vec2(0.0, -0.3));\n    for(float i = 0.0; i < 10.0; i+=1.0)\n    {\n        float id = i / 20.0;\n        vec2 treeP = Translate(ftp, vec2(-4.0 + (id * 7.0 + Noise(vec2(i)) * 9.0)  + sin(tp.y * 4.0) * 0.04 * sin(iTime * 4.0), 0.0));\n        float treeTrunk = Rect(treeP, vec2(0.1 + (ftp.y * ftp.y) * 0.15, 0.5 + Noise(vec2(id)) * 0.04));  \n        \n        float branchCount = floor(Noise(vec2(id + 10.0)) * 5.0);\n        for(float b = 0.0; b <= branchCount; b += 1.0)\n        {\n            float branchNoise = Noise(vec2(b + id)) * 2.0 - 1.0;\n            float branchHeight = 0.3 + branchNoise * 0.3;\n            \n            vec2 branchp = Translate(treeP, vec2(0.12 * sign(branchNoise) -  + branchNoise * 0.08, branchHeight - cos(treeP.x * 40.0  + iTime * 3.0) * 0.01));\n            float branchRect = Rect(branchp, vec2(0.1 + branchNoise * 0.1, 0.015));\n            treeTrunk = min(treeTrunk, branchRect);\n        }\n        \n        treeTrunk = step(treeTrunk, 0.001);\n        \n        float leaves = step(Circle(treeP - vec2(0.0, 0.8 + Noise(vec2(i / 10.0)) * 0.1), 0.5 + sin(p.x * 10.0) * 0.05), 0.001);\n        \n        fTreeC = mix(vec4(0.2 - Noise(vec2(i / 10.0)) * 0.1, 0.5 + Noise(floor(p * 20.0)) * 0.1, 0.0, 1.0) * leaves, fTreeC, fTreeC.a);\n        \n        vec4 trunkColor = vec4(0.5 - Noise(vec2(i / 10.0)) * 0.1, 0.2, 0.0, 1.0);\n        trunkColor.rgb += sin(p.x * 300.0) * 0.01 * round(Noise(p * 10.0));\n        \n        fTreeC = mix(trunkColor * treeTrunk, fTreeC, fTreeC.a);\n    }\n    \n    const float LeafDuration = 10.0;\n    \n    float leafCollumn = floor(p.x * 10.0);\n    float leafNoise = Noise(vec2(leafCollumn));\n    float leafOffset = leafNoise * 400.0;\n    \n    float leafGeneration = floor(iTime / LeafDuration);\n    float leafGenerationLife = mod(iTime, LeafDuration + leafOffset + 1.0);\n    \n    float leafPosition = leafGenerationLife - leafOffset - 1.0;\n    \n    vec2 lp = Translate(Rotate(Translate(p, vec2(leafCollumn / 10.0 + 0.05 + sin(iTime * 3.0 + leafCollumn) * 0.02, -leafPosition / LeafDuration * (1.0 + leafNoise * 2.0))), sin(iTime + PI / 4.0) * 0.5), vec2(0.0, 0.01));\n    float distToLeaf = Circle(lp * vec2(1.0, 2.0), 0.025);\n    float leafEdge = step(distToLeaf, 0.001);\n    \n    vec4 leaves = vec4(0.2 - Noise(vec2(leafCollumn)) * 0.1, 0.5 + Noise(floor(vec2(lp.x * 20.0))) * 0.1, 0.0, 1.0) * leafEdge;\n    \n    vec4 fc = vec4(0.0);\n    fc = sky;\n    fc = mix(fc, ground, ground.a);\n    fc = mix(fc, treeC, treeC.a);\n    fc = mix(fc, cc, cc.a);\n    fc = mix(fc, leaves, leaves.a);\n    fc = mix(fc, fTreeC, fTreeC.a);\n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    LoadState(iChannel0);\n\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    vec2 suv = uv * vec2(aspect, 1.0);\n    \n    vec2 cam = suv + vec2(gameState.playerPos.x, 0.0);\n\n    vec4 fc = vec4(0.0);\n\n    fc = FirstScene(cam, suv);\n\n    float cutout = Rect(uv, vec2(0.55)) - 0.1;\n    fragColor = fc * step(cutout, 0.01);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}