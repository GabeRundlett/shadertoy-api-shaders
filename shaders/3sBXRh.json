{
    "Shader": {
        "info": {
            "date": "1552821173",
            "description": "I can't complete the rotation function",
            "flags": 0,
            "hasliked": 0,
            "id": "3sBXRh",
            "likes": 0,
            "name": "functioning rotation function",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "MODer",
            "viewed": 388
        },
        "renderpass": [
            {
                "code": "vec3 CamPos(){\n    vec3 p = vec3(0.,-.1,0.0);\n    return p;}\nvec3 CamRor(){\n    vec3 r;\n    //r = vec3(-iMouse.y/iResolution.y+0.5, iMouse.x/iResolution.x-0.5, 0.)*3.14;\n    r.xy = (iMouse.yx/iResolution.yx);\n    r.y += 0.5;\n    r.x -= 0.5;\n    r.xy *= -1.;\n    r *= 3.14;\n    //r.xz = vec2(cos(r.y)*(-iMouse.y/iResolution.y+0.5),sin(-r.y)*(-iMouse.y/iResolution.y+0.5))*3.14*cos((iMouse.y/iResolution.y)*3.14/4.);\n    return r;}\n\nvec3 pointR(vec3 pos, vec3 r, vec3 p){\n    pos = mXYZ(pos+p, r)/50.;\n    pos += CamPos();\n    return pos.xyz;\n}\nfloat pointRay(vec2 os, vec2 uv, vec3 pos, vec3 r){\n    pos = mXYZ(pos, r);\n    pos.xy /= pos.z;\n    if(pos.z < 0.){return 0.;}\n    float col = point(uv, pos.xy+os, pos.z*10.);\n    return col;\n}\nfloat cubRay(vec2 uv, vec3 r, vec3 size){\n    float col;\n    vec2 OS = vec2(0.5);\n    for(int x = 0; x < 11; x++){for(int z = 0; z < 11; z++){col += pointRay(OS, uv, pointR(vec3(float(x-6),float(1),float(z-6)) , r, vec3(0.,0.,0.)).xyz/10.,CamRor().xyz)/10.;}}\n    for(int x = 0; x < 5; x++){for(int y = 0; y < 5; y++){for(int z = 0; z < 5; z++){col += pointRay(OS, uv, pointR(vec3(float(x-3),float(y-3),float(z-3)) , r, vec3(0.,0.,-20.)).xyz/10.,CamRor().xyz)/10.;}}}\n    col += pointRay(OS, uv, pointR(vec3(.0,4.,6.), r, vec3(0.,-2.,-7.)).xyz/10.,CamRor().xyz);\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime/2.;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uvR;\n    fragColor = vec4(cubRay(uv, vec3(\n          (t*1.5+uvR.x)*0.\n        , (t+uvR.y)//*0.\n        , t*0.\n    ), vec3(0.5)));//--*0.\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 mFull(vec3 pos, float r){\n    return vec3(\n    pos.x,\n    pos.y*cos(r)+pos.z*sin(r),\n    pos.y*-sin(r)+pos.z*cos(r)\n    );\n}\nvec3 mXYZ(vec3 p, vec3 r){\n    return mFull(mFull((mFull(p.zyx, r.z).zyx).yxz,r.y).yxz,r.x);  \n}\nfloat point(vec2 uv, vec2 p,float s){s*=1.5;return smoothstep(0.015/s,0.014/s,distance(uv,p));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}