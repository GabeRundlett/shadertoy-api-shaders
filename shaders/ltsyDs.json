{
    "Shader": {
        "info": {
            "date": "1507041972",
            "description": "Comparison between triangular noise (bottom) and approximate Gaussian blue noise (top).",
            "flags": 0,
            "hasliked": 0,
            "id": "ltsyDs",
            "likes": 6,
            "name": "Gaussian Blue Noise",
            "published": 3,
            "tags": [
                "noise",
                "blue",
                "gaussian",
                "dithering"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 994
        },
        "renderpass": [
            {
                "code": "//\n// Gaussian Blue Noise\n// by Timo Kinnunen 2017\n//\n// Comparison between approximated Gaussian blue noise\n// and triangular noise.\n//\n// The idea is to approximate a Gaussian distribution by\n// adding a bunch of uncorrelated random values together.\n// Given enough values the familiar bell shaped curve\n// should emerge, but we only add 4 to reduce the cost.\n//\n// To approximate blue noise, the resulting random values\n// are filtered. Using a 5x5 filter kernel causing\n// \"ringing\" would give a nice result, but we only\n// use a 3x1 kernel on the theory that on an LCD screen\n// vertical stripes are less apparent than\n//\n// __________ horizontal lines. ___________\n//\n// The end result is a self-contained noise function that\n// hopefully should optimize well.\n//\n\n//\n// Based on Triangular PDF Noise Dithering by andyborrell\n// @ https://www.shadertoy.com/view/Mllczf\n//\n\n//\n// Segments from top to bottom are:\n// No quantisation\n// Quantisation after approximate Gaussian blue noise applied\n// Quantisation after triangular noise PDF applied\n// Quantisation without noise\n//\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(p.xyx * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.x+p3.yz)*p3.zy);\n}\nfloat blugausnoise(vec2 c1) {\n    //vec2 c0 = vec2(c1.x- 1.,c1.y);\n    //vec2 c2 = vec2(c1.x+ 1.,c1.y);\n    vec3 cx = c1.x+ vec3(-1,0,1);\n    vec4 f0 = fract(vec4(cx* .1031,c1.y* .1030));\n    vec4 f1 = fract(vec4(cx* .0973,c1.y* .0970));\n\tvec4 t0 = vec4(f0.xw,f1.xw);//fract(c0.xyxy* vec4(.1031,.1030,.0973,.0970));\n\tvec4 t1 = vec4(f0.yw,f1.yw);//fract(c1.xyxy* vec4(.1031,.1030,.0973,.0970));\n\tvec4 t2 = vec4(f0.zw,f1.zw);//fract(c2.xyxy* vec4(.1031,.1030,.0973,.0970));\n    vec4 p0 = t0+ dot(t0,t0.wzxy+ 19.19);\n    vec4 p1 = t1+ dot(t1,t1.wzxy+ 19.19);\n    vec4 p2 = t2+ dot(t2,t2.wzxy+ 19.19);\n\tvec4 n0 = fract(p0.zywx* (p0.xxyz+ p0.yzzw));\n\tvec4 n1 = fract(p1.zywx* (p1.xxyz+ p1.yzzw));\n\tvec4 n2 = fract(p2.zywx* (p2.xxyz+ p2.yzzw));\n    return .66666667* (n1.x+ n1.y+ n1.z+ n1.w- 1.0)\n        - 0.16666667* (n0.x+ n0.y+ n0.z+ n0.w+ n2.x+ n2.y+ n2.z+ n2.w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/ iResolution.xy;\n\n    float bands = 4.;\n    \n    float i = fract(uv.x+ iTime* 0.1);\n    if (uv.y < 0.75) {\n        if (uv.y > 0.5) {\n            i += blugausnoise(fragCoord)/ bands;  // \"Gaussian\" \"blue\" noise\n        } else if (uv.y > 0.25) {\n            vec2 rand = hash22(fragCoord);\n            i += (rand.x+ rand.y- 1.0)/ bands;  // Triangular PDF noise\n        }\n        i = floor(i* bands+ 0.5)/ bands; // Quantisation\n    }\n    \n    fragColor = vec4(i,i,i,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}