{
    "Shader": {
        "info": {
            "date": "1459136647",
            "description": "Forked from the amazing shader by mhnewman: https://www.shadertoy.com/view/XlXGD7\n\nTODO: Implement with JavaScript. ",
            "flags": 0,
            "hasliked": 0,
            "id": "lstXW8",
            "likes": 19,
            "name": "Earth fly by",
            "published": 3,
            "tags": [
                "earth"
            ],
            "usePreview": 0,
            "username": "marvindanig",
            "viewed": 3392
        },
        "renderpass": [
            {
                "code": "// Forked from the amazing shader by mhnewman: https://www.shadertoy.com/view/XlXGD7\n\n//\tMy first contribution to Shadertoy\n//\tI have been a big fan of this community for a while and I want to thank iq for\n//\tthis wonderful site.\n//\tHash functions from David Hoskins via https://www.shadertoy.com/view/4djSRW\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat hash12(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \n                   hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12(i + vec2(0.0, 1.0)), \n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat hash12_3(vec2 p) {\n\tfloat f = hash12(p);\n    return f * f * f;\n}\n\nfloat noise_3(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12_3(i + vec2(0.0, 0.0)), \n                   hash12_3(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12_3(i + vec2(0.0, 1.0)), \n                   hash12_3(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5 * noise(p); p = m * p;\n    f += 0.25 * noise(p); p = m * p;\n    f += 0.125 * noise(p); p = m * p;\n    f += 0.0625 * noise(p); p = m * p;\n    f += 0.03125 * noise(p); p = m * p;\n    f += 0.015625 * noise(p);\n    return f / 0.984375;\n}\n\nvec3 getDir(vec2 screenPos) {\n    screenPos -= 0.5;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    return normalize(vec3(0.0, -1.0, -3.0)\n                     + screenPos.x * vec3(1.0, 0.0, 0.0)\n                     - screenPos.y * vec3(0.0, -0.948683298, 0.316227766));\n}\n\nbool getPosition(in vec3 camera, in vec3 dir, out vec2 pos) {\n    bool valid = false;\n    \n\tfloat b = dot(camera, dir);\n\tfloat c = dot(camera, camera) - 1.0;\n\tfloat h = b * b - c;\n\tif (h > 0.0) {\n        valid = true;\n        \n        vec3 p = camera + (-b - sqrt(h)) * dir;\n        pos = p.xz + iTime * vec2(0.005, 0.02);\n\t}\n\n\treturn valid;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screen = fragCoord.xy / iResolution.xy;\n    \n    vec3 camera = vec3(0.0, 1.2, 0.7);\n    vec3 dir = getDir(screen);\n    \n    vec3 earth = vec3(0.0, 0.0, 0.0);\n    vec2 position;\n    if (getPosition(camera, dir, position)) {\n        float geography = fbm(6.0 * position);\n\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\n        float population = smoothstep(0.2, 0.6, fbm(2.0 * position) + coast);\n        vec2 p = 40.0 * position;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast);\n        population = smoothstep(0.0, 0.02, population);\n\n        vec3 land = vec3(0.1 + 2.0 * population, 0.07 + 1.3 * population, population);\n        vec3 water = vec3(0.0, 0.05, 0.1);\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\n\n        vec2 wind = vec2(fbm(30.0 * position), fbm(60.0 * position));\n        float weather = fbm(20.0 * (position + 0.03 * wind)) * (0.6 + 0.4 * noise(10.0 * position));\n\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\n        earth = mix(ground, vec3(0.5, 0.5, 0.5), clouds); \n\n        float lightning = 0.0;\n        vec2 strike;\n        if (getPosition(camera, getDir(hash21(iTime)), strike)) {\n            vec2 diff = position - strike;\n            lightning += clamp(1.0 - 1500.0 * dot(diff, diff), 0.0, 1.0);\n        }\n        lightning *= smoothstep(0.65, 0.75, weather);\n        earth += lightning * vec3(1.0, 1.0, 1.0);\n    }\n    \n    vec3 altitude = camera - dir * dot(camera, dir);\n    float horizon = sqrt(dot(altitude, altitude));\n    \n    vec3 atmosphere = vec3(0.2, 0.25, 0.3);\n    atmosphere = mix(atmosphere, vec3(0.05, 0.1, 0.3), smoothstep(0.992, 1.004, horizon));\n    atmosphere = mix(atmosphere, vec3(0.1, 0.0, 0.0), smoothstep(1.0, 1.004, horizon));\n    atmosphere = mix(atmosphere, vec3(0.2, 0.17, 0.1), smoothstep(1.008, 1.015, horizon));\n    atmosphere = mix(atmosphere, vec3(0.0, 0.0, 0.0), smoothstep(1.015, 1.02, horizon));\n\n    horizon = clamp(pow(horizon, 20.0), 0.0, 1.0);\n    fragColor = vec4(mix(earth, atmosphere, horizon), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}