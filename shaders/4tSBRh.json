{
    "Shader": {
        "info": {
            "date": "1514412686",
            "description": "Improved version of V1, adds support for positive and negative values and adds an animated preview. Hopefully doesn't break the website this time.\n\n2018-09-29: Fixed Firefox support",
            "flags": 32,
            "hasliked": 0,
            "id": "4tSBRh",
            "likes": 8,
            "name": "Signed Distance Fields v1.1b",
            "published": 3,
            "tags": [
                "sdf",
                "animated",
                "distance",
                "field",
                "signeddistancefield",
                "signed",
                "encode",
                "encoder"
            ],
            "usePreview": 0,
            "username": "Xaymar",
            "viewed": 931
        },
        "renderpass": [
            {
                "code": "// A very simplistic approach at rendering 2-dimensional signed distance fields.\n// It is iterative and at most has a O(width > height ? width : height) runtime.\n// Can be used to create outlines, shadows, glow and other things.\n\n// Buffers:\n// A - Shape Input\n// B - Shape Postprocessing\n// C - Signed Distance Field Generator\n// D - Signed Distance Field Postprocessing\n// Image - Final Render\n\n#define OUTLINE\nconst float outlineDist = 0.0;\nconst float outlineRange = 4.0;\nconst vec3 outlineColor = vec3(13., 162., 38.) / 255.0;\n\n//#define SHADOW_OUTER\nconst vec2 shadowOuterOffset = vec2(32., 4.);\nconst float shadowOuterMinimum = -4.0;\nconst float shadowOuterMaximum = 4.0;\nconst float shadowOuterRange = shadowOuterMaximum - shadowOuterMinimum;\nconst float shadowOuterStrength = 0.5;\n\n//#define SHADOW_INNER\nconst vec2 shadowInnerOffset = vec2(-4., 4.);\nconst float shadowInnerMinimum = -4.;\nconst float shadowInnerMaximum = 4.;\nconst float shadowInnerRange = shadowInnerMaximum - shadowInnerMinimum;\nconst float shadowInnerStrength = 1.0;\n\n//#define GLOW_INNER\nconst vec3 glowInnerColor = vec3(0., 0., 0.);\nconst float glowInnerRadius = 6.0;\n\n//#define GLOW_OUTER\nconst vec3 glowOuterColor = vec3(1., 1., 1.);\nconst float glowOuterRadius = 4.0;\n\n//#define DEBUG\nconst float debugRange = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    #ifdef DEBUG\n    fragColor = abs(texture(iChannel0, uv).rgba / debugRange);\n    return;\n    #endif\n    \n    float v = texture(iChannel0, uv).r;\n    fragColor.rgb = vec3(0.5, 0.5, 0.5);\n\n    #ifdef SHADOW_OUTER\n    {\n        float v2 = texture(iChannel0, uv + (shadowOuterOffset / iResolution.xy)).r;\n       \tfloat vc = v2 - shadowOuterMinimum;\n        float vd = clamp(vc / shadowOuterRange, 0.0, 1.0);\n        \n        if (v > 0.0) {\n        \tfragColor.rgb = mix(vec3(0.), fragColor.rgb, (1.0 - (1.0 - vd) * shadowOuterStrength));\n        }\n    }\n    #endif\n    \n    #ifdef GLOW_INNER\n    {\n        float g = -v / glowInnerRadius;\n        g = clamp(g, 0., 1.);\n        if (g > 0.)\n        \tfragColor.rgb = mix(glowInnerColor, fragColor.rgb, g);\n    }\n    #endif\n    \n    vec4 bufA = texture(iChannel3, uv);\n    if (bufA.a > 0.0) {\n        fragColor.rgb = bufA.rgb;\n    }\n    \n    #ifdef SHADOW_INNER\n    {\n        float v2 = texture(iChannel0, uv + (shadowInnerOffset / iResolution.xy)).r;\n       \tfloat vc = v2 - shadowInnerMinimum;\n        float vd = clamp(vc / shadowInnerRange, 0.0, 1.0);\n        \n        if (v < 0.0) {\n        \tfragColor.rgb = mix(vec3(0.), fragColor.rgb, 1.0 - vd * shadowInnerStrength);\n        }\n    }\n    #endif\n    \n    #ifdef OUTLINE\n    {\n        float vc = v - outlineDist;\n        float vd = clamp(vc / outlineRange, 0.0, 1.0);\n        float vr = abs(vd - 0.5) * 2.0;\n        if (vd > 0.0 && vd < 1.0) {\n            fragColor.rgb = outlineColor * (1.0 - vr);\n        }\n    }\n    #endif\n    \n    #ifdef GLOW_OUTER\n    {\n        float g = v / glowOuterRadius;\n        g = clamp(g, 0., 1.);\n        if (g > 0.)\n        \tfragColor.rgb = mix(glowOuterColor, fragColor.rgb, g);\n    }\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define INPUT_VIDEO\n#define INPUT_CIRCLE\n\nconst vec4 green = vec4(13., 162., 38., 255.) / 255.0;\n\nvec4 RGBtoYUV(vec4 rgba, mat3 yuv) {\n\treturn vec4(\n        rgba.r * yuv[0][0] + rgba.g * yuv[0][1]  + rgba.b * yuv[0][2],\n\t\trgba.r * yuv[1][0]  + rgba.g * yuv[1][1]  + rgba.b * yuv[1][2],\n\t\trgba.r * yuv[2][0] + rgba.g * yuv[2][1] + rgba.b * yuv[2][2],\n\t\trgba.a\n\t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    #ifdef INPUT_VIDEO\n    {\n\t\tvec4 col = texture(iChannel0, uv);\n        const mat3 mYUV709n = mat3(\n            0.2126, 0.7152, 0.0722,\n            -0.1145721060573399, -0.3854278939426601, 0.5,\n            0.5, -0.4541529083058166, -0.0458470916941834\n        );\n        \n        // Cheapest possible de-greening and green-screening. Terrible quality.\n        vec3 yuv_replace = RGBtoYUV(green, mYUV709n).rgb;\n        vec3 yuv_here = RGBtoYUV(col, mYUV709n).rgb;\n        \n        float dist = distance(yuv_replace, yuv_here) * 2.;\n        const float distMin = 0.3;\n        const float distMax = distMin + 0.2;\n        float distRange = distMax - distMin;\n        dist -= distMin;\n        dist /= distRange;\n        dist = clamp(dist, 0., 1.);\n        \n        fragColor.a = (dist > 0.1 ? 1.0 : 0.0);\n        fragColor.rgb = (col.rgb - (green.rgb * (1.0 - dist)));\n    }\n    #elif defined(INPUT_CIRCLE)\n    {\n        float minSize = min(iResolution.x, iResolution.y);\n        float innerRadius = (iMouse.x / iResolution.x);\n        float outerRadius = (iMouse.y / iResolution.y);\n        fragColor.a = 0.0;\n        float dist = distance(((fragCoord - (iResolution.xy / 2.0)) / minSize), vec2(0, 0)) * 2.0;\n        if ((dist >= innerRadius) && (dist <= innerRadius + outerRadius)) {\n            fragColor.a = 1.0;\n        }\n    }\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Improved iterative Signed Distance Field encoder based on V1:\n//  https://www.shadertoy.com/view/XlfBDl\n//\n// It's a really simple approach at doing this and most likely\n//  can be done much faster by splitting horizontal and vertical\n//  passes and by using loops for testing for distances. There is\n//  also a UV channel stored within the blue and alpha of the\n//  result, allowing higher precision if necessary.\n//\n// Output definition:\n// .r  = Positive Distance\n// .g  = Negative Distance\n// .ba = UV of nearest edge\n\n// Parameters\nconst float threshold = 0.1;\n\n#define POSSIBLY_INFINITE 18446744073709551616.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame == 0) {\n        fragColor = vec4(POSSIBLY_INFINITE);\n        return;\n    }\n    \n    vec2 uvStep = 1.0 / iResolution.xy;\n    vec3 uvStep0 = vec3(uvStep.x, uvStep.y, 0.);\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    bool inside = false;\n    \n    // Test if we are in- or outside of the shape.\n    float alpha = texture(iChannel1, uv).a;\n    if (alpha > threshold) {\n        inside = true;\n        fragColor.r = 0.0;\n        fragColor.ba = uv;\n    } else {\n        inside = false;\n        fragColor.g = 0.0;\n        fragColor.ba = uv;\n    }\n    \n    if (inside) { // Negative Values\n        vec3 test = vec3(POSSIBLY_INFINITE, POSSIBLY_INFINITE, POSSIBLY_INFINITE);\n        vec3 iU, iD, iL, iR;\n        iU = texture(iChannel0, uv - uvStep0.zy).gba;\n        iD = texture(iChannel0, uv + uvStep0.zy).gba;\n        iL = texture(iChannel0, uv - uvStep0.xz).gba;\n        iR = texture(iChannel0, uv + uvStep0.xz).gba;        \n    \tif (iU.r < test.r) { test = iU; }\n    \tif (iD.r < test.r) { test = iD; }\n    \tif (iL.r < test.r) { test = iL; }\n    \tif (iR.r < test.r) { test = iR; }\n        \n        vec3 m = vec3(0.4142135623730950488016887242097, 0, 0);\n        iU = texture(iChannel0, uv - uvStep0.xy).gba;\n        iD = texture(iChannel0, uv - vec2(-uvStep0.x, uvStep0.y)).gba;\n        iL = texture(iChannel0, uv + uvStep0.xy).gba;\n        iR = texture(iChannel0, uv + vec2(uvStep0.x, -uvStep0.y)).gba;\n    \tif (iU.r < test.r) { test = iU + m; }\n    \tif (iD.r < test.r) { test = iD + m; }\n    \tif (iL.r < test.r) { test = iL + m; }\n    \tif (iR.r < test.r) { test = iR + m; }\n        \n        if (test.r < POSSIBLY_INFINITE) {\n            fragColor.g = test.r + 1.;//distance(fragCoord, test.gb / uvStep) + 0.5;\n            fragColor.ba = test.gb;\n        }\n    } else { // Positive Values\n        vec3 test = vec3(POSSIBLY_INFINITE, POSSIBLY_INFINITE, POSSIBLY_INFINITE);\n        vec3 iU, iD, iL, iR;\n        iU = texture(iChannel0, uv - uvStep0.zy).rba;\n        iD = texture(iChannel0, uv + uvStep0.zy).rba;\n        iL = texture(iChannel0, uv - uvStep0.xz).rba;\n        iR = texture(iChannel0, uv + uvStep0.xz).rba;\n        \n    \tif (iU.r < test.r) { test = iU; }\n    \tif (iD.r < test.r) { test = iD; }\n    \tif (iL.r < test.r) { test = iL; }\n    \tif (iR.r < test.r) { test = iR; }\n        \n        vec3 m = vec3(0.4142135623730950488016887242097, 0, 0);\n        iU = texture(iChannel0, uv - uvStep0.xy).rba;\n        iD = texture(iChannel0, uv - vec2(-uvStep0.x, uvStep0.y)).rba;\n        iL = texture(iChannel0, uv + uvStep0.xy).rba;\n        iR = texture(iChannel0, uv + vec2(uvStep0.x, -uvStep0.y)).rba;\n    \tif (iU.r < test.r) { test = iU + m; }\n    \tif (iD.r < test.r) { test = iD + m; }\n    \tif (iL.r < test.r) { test = iL + m; }\n    \tif (iR.r < test.r) { test = iR + m; }\n        \n        if (test.r < POSSIBLY_INFINITE) {\n            fragColor.r = test.r + 1.;//distance(fragCoord, test.gb / uvStep) + 0.5;\n            fragColor.ba = test.gb;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.r - col.g);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}