{
    "Shader": {
        "info": {
            "date": "1476505934",
            "description": "mouse does stuff.\n\ncleaned\nhttps://www.shadertoy.com/view/4dVGzw\nstarting to understand how to use this, is better without C1-continuinuity\nsubstraction of distances is in line 245 ish , mixing 2 shapes by sin(time)*.5+.5",
            "flags": 0,
            "hasliked": 0,
            "id": "XlV3Dy",
            "likes": 21,
            "name": "AD6 Goursat DerivativeArithmetic",
            "published": 3,
            "tags": [
                "numbers",
                "derivative",
                "dual",
                "paniq",
                "arithmetic",
                "continuous",
                "automatic",
                "differential",
                "derivate",
                "goursat",
                "continuity",
                "superprim"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1711
        },
        "renderpass": [
            {
                "code": "// arithmetic set for automatic differentiation, \n// derivative arithmetic [DA] for\n// https://en.wikipedia.org/wiki/Smoothness\n// of shapes that (otherwise) lack C1-continuity.\n// based on    : https://www.shadertoy.com/view/4dVGzw\n// inspired by : https://www.shadertoy.com/view/Mdl3Ws \n//\n//explained at http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n//wiki         https://en.m.wikipedia.org/wiki/Automatic_differentiation\n//summary:     https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\n\n#define Goursat\n//toggle between 2 distance fields|surfaces:\n//Goursat-surface (non-C1 continuous)\n//or the parameetric superprim\n//https://www.shadertoy.com/view/4dVGzw\n\n/*\nmouse does stuff.\ncleaned and starting to undertand how to use:\nsubstraction of distances is in line 235 ish\n, mixing 2 shapes by sin(time)*.5+.5\n*/\n\n#define IterRm 64\n//max raymarch iterations|steps\n\n#define IterSh 24\n//softshadow iterations\n\n#define StepFactor .99\n//stepfactor range [.1 to 2.], where larger values tend to overstep.\n//if(lipschitzConstant>1., distance is overestimated.\n//... lazy fix for that is scaling stepDistance*=StepFactor\n//I noticed better quality with a smaller stepfactor AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n//Using f'(x)= f(d)/dx notation for derivates:\n//https://en.wikipedia.org/wiki/Derivative#Notation\n\n//this defines common operations but on a (pseudo) dual number (i,j), defined as:\n//[j] stays \"underived\"\n//[i] calculates the gradient as byproduct\n//[i] becomes Operation(i,FirstDerivateOf(Operation(i,j))\n//[i] is always precise and this way usually calculates faster than using central differences,\n//mostly because a lot of operations have a lot of values cancel each other out, allowing \"shortcuts\".\n//especially canceling out a lot of domainVectors at once, which is nice for vectorHardware.\n//\n//\"pseudo\" dual because [i] has 3 dimensions, and [j] has 1 dimension that modifies on all dimensions of [i], \n//because graphic cards are good with domain operators on vectors.\n//we define your dual number (where one part calculates with derivative of the other part and itself)\n//as type vec4(vec3,float)\n//and the 3 dimensions|domains are resolved with [struct DAVec3{}] and [da_domain()]:\nstruct DAVec3{vec4 x;vec4 y;vec4 z;};\nDAVec3 da_domain(vec3 p){return DAVec3(\n vec4(1.,0.,0.,p.x),\n vec4(0.,1.,0.,p.y),\n vec4(0.,0.,1.,p.z));}\n//this lets you derive over 3 dimensions at once OR seperately, using very self-similar dual-function variants:\n#define dacon(a) vec4(0.,0.,0.,a)\n#define i1 in float\n#define i4 in vec4\n#define i3 in vec3\nvec4 da_const(i1 a){return dacon(a);}\n//as proof of concept, remember the derivates of sin|cos:\n//sin => cos => -sin => -cos => sin =>...\nvec4 da_sin(i4 a){return vec4( a.xyz*cos(a.w),sin(a.w));}\nvec4 da_cos(i4 a){return vec4(-a.xyz*sin(a.w),cos(a.w));}\n//eulers number, exponential functions and natural log:\nvec4 da_exp(i4 a){float w=exp(a.w);return vec4(a.xyz*w,w);}//exp(a)==pow(e,a)\nvec4 da_log(i4 a){return vec4(a.xyz/a.w,log(a.w));}\n\n#define siq safeinv(q),q);}\nfloat safeinv(i1 a){return (a==0.)?a:1./a;}//reciprocal,1/x but 1./0.=1.; sometimes makes more sense than divBy0!\nvec4 da_abs (i4 a){return vec4(a.xyz*sign(a.w),abs(a.w));}\nvec4 da_pow2(i4 a){return vec4(2.*a.w*a.xyz, a.w*a.w);}\nvec4 da_sqrt(i4 a){float q=sqrt(a.w);\n return vec4(.5*a.xyz*siq\n\n//derivatives of functions with 2 variables are trickier:\n//because only .w determines breanching of min()|max() (in the nature of dual numbers, only one matters here)\n//optionally, a float parameter can be given as vec4(0,0,0,f):\nvec4 da_min(i4 a,i4 b){return(a.w<=b.w)?a:b;}\nvec4 da_min(i4 a,i1 b){return(a.w<=b  )?a:da_const(b);}\nvec4 da_min(i1 a,i4 b){return(a  < b.w)?da_const(a):b;}\nvec4 da_max(i4 a,i4 b){return(a.w>=b.w)?a:b;}\nvec4 da_max(i4 a,i1 b){return(a.w>=b  )?a:da_const(b);}\nvec4 da_max(i1 a,i4 b){return(a  > b.w)?da_const(a):b;}\n//I assume the more general logic here is that all these functions with 2 parameters do:\n/*vec4 r;\n  r.w  = operationOn(a.w,b.w);\n  r.xyz= operationOn(a.xyz , vec3(firstDerivateOf(r.w))); //firstDerivateOf(r.w)==[tricky part]==(3d graphs tangents)\n  return r;*/\n//f(a,b)=mod(a,b) => f'(a,b)=1. , (still disontinuous, not defined for whole multiples of b).\nvec4 da_mod(i4 a,i4 b){return vec4(mod(a.xyz,1.),mod(a.w,b.w));}\nvec4 da_mod(i4 a,i1 b){return vec4(mod(a.xyz,1.),mod(a.w,b  ));}\nvec4 da_mod(i1 a,i4 b){return vec4(0,0,0        ,mod(a  ,b.w));}//here \"a.xyz\"==vec3(0)\n//and usually a lot cancels out in substraction/division...\nvec4 da_sub(i4 a,i4 b){return a-b;}\nvec4 da_sub(i4 a,i1 b){return vec4( a.xyz,a.w-b  );}\nvec4 da_sub(i1 a,i4 b){return vec4(-b.xyz,a  -b.w);}\nvec4 da_add(i4 a,i4 b){return a+b;}\nvec4 da_add(i4 a,i1 b){return da_sub(a,-b);}//addition as invrse substraction\nvec4 da_add(i1 a,i4 b){return da_sub(a,-b);}\n             \nvec4 da_mul(i4 a,i4 b){return vec4(a.xyz*b.w+a.w*b.xyz, a.w*b.w);}\nvec4 da_mul(i4 a,i1 b){return a*b;}\nvec4 da_mul(i1 a,i4 b){return a*b;}\nvec4 da_div(i4 a,i4 b){return vec4((a.xyz*b.w-a.w*b.xyz)/(b.w*b.w), a.w/b.w);}\nvec4 da_div(i4 a,i1 b){return a/b;}\nvec4 da_div(i1 a,i4 b){return vec4((-a*b.xyz)/(b.w*b.w), a/b.w);} \n             \n//some operations cancel out a bit more, to (nearly) tautological|identical identities:\n//<- wooha, a recursive meta-tautology!\n//vec4 da_fract(i4 a){return a;}//derivative of fract(a)=a => tautological.\nvec4 da_floor(i4 a){return dacon(a);}\nvec4 da_floor(i1 a){return dacon(a);}\n//#define mod(a,b) (a-b*floor(a/b))\n//da_mod.xyz==a.xyz-b.xyz*0==a.xyz\n\n//f(a,b)=dot(g(a),h(b)) => f'(x)              =dot(g'(a)',h(b))+dot(g(a),hÂ´(b))\n//                      => d/dx(dot(g(a),h(b))=dot(ga/gx ,h   )+dot(g   ,ha/hx); //similar to \"product rule for scalars\"\n//g(a)=c\n//h(b)=d\n//f(a,b)=dot(c,d) => f'(x)=dot(c',d)+dot(c,d');\n// c and d are type type vec3;\n//f'(x)=dot(0,d)+dot(c,0) == 0+0; ???\n            \n\n//todo: derivative of dot() appears tricky: this #define should do:\n//#define dotDer(a,b) min(f(abs(a)),abs(b))*sign(a)*sign(b)\n//vec4 da_dot(i4 a,i4 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b.w));}           \n//vec4 da_dot(i4 a,i1 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b  ));}  \n//vec4 da_dot(i1 a,i4 b){return da_dot(b,a);}//is commutative\n             \n//and it gets trickier with functions that take 3 parameters:\nvec4 da_length(i4 x,i4 y){float q=length(vec2(x.w,y.w));\n return vec4((x.xyz*x.w+y.xyz*y.w)*siq\nvec4 da_length(i4 x,i4 y,i4 z){float q=length(vec3(x.w,y.w,z.w));\n return vec4((x.xyz*x.w+y.xyz*y.w+z.xyz*z.w)*siq\n//the utility of a length() function is clear.\n\n//the utility of da_*().xyz is trickier, just search below to see  what it is ued for:\n\n\n//using the above, we define distance functions that automatically calculate their derivatives\n//this makes surfaces that are C1-discontinuous, like staircases, \n//at least have their (continuous) first rerivate calculated, which is useful for raymarching (?)\nvec4 sdSphere(DAVec3 p){\n p.x*=.8;p.x-=.5*sin(1.61*iTime);\n p.y*=.8;\n p.z*=.8;p.z-=.5*cos(1.61*iTime);\n vec4 q=da_length(p.x,p.y,p.z);\n q=da_sub(q,1.);\n return q;}\n\n\n// s: width, height, depth, thickness\n// r: .xy corner radius, .z corner radius\n//return distance to very parametric surface that contains many useful sub-shapes.\nvec4 sdSuperprim(DAVec3 p, i4 s,vec2 r) {\n    vec4 dx = da_sub(da_abs(p.x),s.x);\n    vec4 dy = da_sub(da_abs(p.y),s.y);\n    vec4 dz = da_sub(da_abs(p.z),s.z);\n    vec4 q = \n       \tda_sub(\n            da_abs(\n                da_add(\n                    da_add(\n                        da_length(\n                            da_max(da_add(dx, r.x),0.),\n                            da_max(da_add(dy, r.x),0.)),\n                  \t\tda_min(-r.x,da_max(dx,dy))),\n                    s.w)), \n                s.w);\n    return da_add(\n                da_length(\n                    da_max(da_add(q, r.y),0.0),\n                    da_max(da_add(dz, r.y),0.0)),\n                da_min(-r.y,da_max(q,dz)));\n}\n\n      \nvec4 sdGoursat(DAVec3 p\n){p.x=da_mul(p.x,2.)\n ;p.y=da_mul(p.y,2.)\n ;p.z=da_mul(p.z,2.)\n ;vec4 a=da_pow2(p.x),d=da_pow2(a);a=da_mul(5.,a)//pow2=pow(a,2.)\n ;vec4 b=da_pow2(p.y),e=da_pow2(b);b=da_mul(5.,b)\n ;vec4 c=da_pow2(p.z),f=da_pow2(c);c=da_mul(5.,c)\n ;e=da_add(e,f);b=da_add(b,c)\n ;d=da_add(d,e);a=da_add(a,b)\n ;d=da_sub(d,a)\n ;d=da_add(20.*iMouse.x/iResolution.x,d)\n ;return da_div(d,max(11.8,length(d.xyz)));}\n\nvec4 sdGoursatOld(DAVec3 p\n){p.x=da_mul(p.x,2.)\n ;p.y=da_mul(p.y,2.)\n ;p.z=da_mul(p.z,2.)\n ;vec4 d =da_add(\n  20.*iMouse.x/iResolution.x,\n  da_sub(\n   da_add(\n    da_pow2(\n     da_pow2(p.x))\n     ,da_add(\n      da_pow2(\n       da_pow2(p.y))\n       ,da_pow2(\n         da_pow2(p.z)))),\n                da_add(\n                    da_mul(5.0,da_pow2(p.x)),\n                    da_add(\n                        da_mul(5.0,da_pow2(p.y)),\n                        da_mul(5.0,da_pow2(p.z))))))\n ;return da_div(d, max(11.8,length(d.xyz)));}\n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s,out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n//set camera position & target\nvoid setCam(out vec3 o,out vec3 i,i1 t,i1 m){\n o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\nstruct DAMValue{vec4 d;float m;};\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.w>b.d.w)return b;return a;}\nDAMValue plane(DAVec3 p){return DAMValue(da_add(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n//return distance to surface of DistanceField\nDAMValue df(DAVec3 p){vec4 r;\n#ifdef Goursat\n //r=sdGoursat(p);\n //r=sdSphere(p);\n //r=da_max(-sdTangle(p),sdSphere(p));\n //r=sdGoursat(p)*.7+sdSphere(p)*.3;\n r=mix(sdGoursat(p),sdSphere(p),sin(iTime*.61)*.5+.5);\n#else\n float t=iTime,u=ss01(ss01(fract(t)));\n vec4 a,b;vec2 c,d;\n getfactor(imsc(t   ),a,c);\n getfactor(imsc(t+1.),b,d);\n DAVec3 q=DAVec3(p.z,p.y,p.x);\n if(iMouse.z>.5){\n  vec2 m=iMouse.xy/iResolution.xy;\n  r=sdSuperprim(q,vec4(vec3(1.0),mix(a.w,b.w,u)),m);\n }else\n  r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n#endif\n return min2(plane(p),DAMValue(r,0.));}\n\n//return distance & materialID\nvec2 dm(i3 p){DAMValue d=df(da_domain(p));\n return vec2(d.d.w,d.m);}\n//return material at p with normal n\nvec4 material(i3 p,i3 n ){vec4 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n return mix(vec4(n*.5+.5,.1)\n           ,vec4(d.xyz*.5 +.5,.0)*abs(mod(d.w,.1)/.1-.5)\n           ,clamp(dm(p).y,0.,1.));}\n\n//return soft shadow\nfloat shadow(i3 o,i3 i){\n const float a=32.;//shadow hardnes\n float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n for(int j=0;j<IterSh;j++){\n  h=dm(o+i*t).x;\n  r=min(r,h*a/t);\n  t+=clamp(h,.02,2.);}//limit max and min stepping distances\n return clamp(r,0.,1.);}\n\n//return p, modified by light , shadow, envMap...\nvec3 light(i3 p,i3 n,i3 i,i1 d,i4 m){\n vec3 l=normalize(vec3(1.,.7,.9));//light direction\n float o=max(0.,dot(n,l)),\n c=max(0.,dot(n,normalize(l-i))),\n s;if(c>.01)s=shadow(p+.01*n,l); \n const vec3 LigCol=vec3(1.);//light color\n vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n r+=s*c*pow(o,40.);//specular\n //r+=m.w*texture(iChannel0, reflect(i,n)).rgb;//envmap\n r*=exp(-.01*d*d);//fog  \n return r;}\n\n//return distance along ray (raymarch till surface)\nfloat rm(i3 o,i3 i){\n const float m=20.;//distance.Max\n float e=.0,h=e,t=0.;//intersection.precission\n for(int j=0;j<IterRm;j++){\n  if(h<e)break;if(t>m)return -1.;\n  h=dm(o+i*t).x*StepFactor;t+=h;}return t;}\n\n//return surface normal\nvec3 getN(in vec3 p){DAMValue d=df(da_domain(p));\n return d.d.xyz;}\n\n//return camera matrix\nmat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n return mat3(u,normalize(cross(u,w)),w);}\n\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\nvoid mainImage( out vec4 r,in vec2 fragCoord ){\n vec2 p=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y,\n m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i;\n setCam(o,i,iTime,m.y+.2);//camMovement\n const float roll=0.,lens=2.;//camRoll,CamLensLength\n vec3 d=normalize(calcLookAtMatrix(o,i,roll)*vec3(p.xy,lens));//ray.direction\n vec3 c=vec3(0);\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n r=vec4(c,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}