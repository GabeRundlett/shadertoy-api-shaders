{
    "Shader": {
        "info": {
            "date": "1506023268",
            "description": "4kb intro by the SandS.\n3rd place at Chaos Constructions 2017 demoparty.\nDownload exe, sources, youtube, etc.: http://www.pouet.net/prod.php?which=71630",
            "flags": 64,
            "hasliked": 0,
            "id": "MtXczn",
            "likes": 48,
            "name": "HAL 4000",
            "published": 3,
            "tags": [
                "wireframe",
                "landscape"
            ],
            "usePreview": 0,
            "username": "Manwe",
            "viewed": 7707
        },
        "renderpass": [
            {
                "code": "// HAL 4 kb intro by the SandS\n\nprecision highp float;\n\n#define t (mod(iTime,108.))\n\nfloat torus(vec3 o, float k)\n{\n    o.z -= 4.5; // pivot point\n    vec3 r = vec3(t/2.3, t/1.95, t/2.7), s = sin(r), c = cos(r); // rotate over axis x,y,z\n    o *= mat3( // rotation\n         c.y,     s.z*s.y,            -s.y*c.z,\n        -s.x*s.y, c.x*c.z+s.x*s.z*c.y, s.z*c.x-s.x*c.z*c.y,\n         c.x*s.y, s.x*c.z-c.x*s.z*c.y, s.z*s.x+c.x*c.z*c.y\n    );\n    float s1=clamp((t-33.)/14.,0.,1.); // morph to sphere on 0:33\n    k = mix(k,0.,s1*s1*s1);\n    float n = 8.-6.*k, l = 3.8*k-2.;\n    n = mix(n,2.,s1*s1*s1);\n    o = abs(o);\n    return pow(pow(o.x,n)+pow(o.y,n)+pow(o.z,n)+l,2.)-k*8.*(o.x*o.x + o.y*o.y);\n}\n\nfloat shape(vec3 o)\n{\n    return sin(o.x*5.)/15. + cos(o.x+1.5)/3. + sin(o.z+t)/5. - cos(o.x+2.)*cos(o.z+t)/3.;\n}\n\nfloat rt(vec3 o)\n{\n    return length(o-vec3(o.x,shape(o) - 1.5,o.z));\n}\n\nfloat s(float a, float z) // move star field\n{\n    return ( a-a*z+1. ) * 991.;\n}\n\nfloat wire(float dist) // convert distance to color\n{\n    return pow(1. - min(1.,abs(dist)),4.);\n}\n\nvoid mainImage(out vec4 outcolor, vec2 coordVar)\n{    \n    coordVar /= iResolution.xy;\n    float aspect = 16. / 9.;\n    vec2 uv = (coordVar - vec2(.5)) / vec2(1., aspect) *1.4;\n\n    float cf=0., ct=0., cm=0., cl=0., cs = 0., pi = 3.1416; // init colors: field, torus, torus, light, stars\n    float l = 1., d, e = .0001, m1, m2, r = 0., size, n, z; // ray length, current distance, epsilon\n    vec3 xyz, c = vec3(0.,0.,0.), norm = c, light = vec3(0.,1.,12.+max(0.,(t-47.)/8.)); // 3d-coordinates, final color, normal, light position\n\nif (t<62.) // Scene 1 from 0:00 to 1:02\n{\n// morphing\n    float kf = clamp(t/4.-5.,0.,1.); // plane -> landscape on 0:20\n    float kt = cos((t)/3.1)/2.5+.4; // cube -> toruns, from 0 to 1\n    float s1 = t - 22., td = 1.+max(s1*s1*s1/999.,0.)/9.; // torus distance\n    n = min(t*t*t/451.,17.7)+.3; // number of torus slices\n    n = mix(n,3.,clamp((t-42.)/5.,0.,1.));\n\n// draw field\n    z=30.-fract(t);\n    for (int i=30; i>0; i--) // z-slices from far to near\n    {\n        xyz = vec3(uv*(1.+z),z); // form 3D coordinates from screen coordinates and z\n        cf = max(cf, pow(wire( -xyz.y-1.5 + kf*shape(xyz+vec3(0.,0.,1.)) ),7.)*-uv.y*2.6); // draw field slice\n        z--;\n    };\n\n// draw torus\n// using SandS' super original proprietary rendering technic, let's call it \"Z-sliced space\" :)\n    z = 4.5 + 2.*(n-1.)/(n+1.); // start z\n    for (int i=18; i>0; i--) // z-slices from far to near\n    {\n        xyz = vec3(uv*(2.+z)*td,z); // form 3D coordinates from screen coordinates and z\n        cm = max(cm, float(torus(xyz,kt)<.1)); // draw torus mask\n        ct = max(ct, wire(torus(xyz,kt))/(z-2.6)); // draw torus slice\n        z -= 4./(n+1.); // density of render, smaller is better\n    };\n\n    cm = 1.-cm; // torus mask\n\n    if (t>46.)\n    {\n    // raymarching\n        xyz = normalize(vec3(uv, 1.)); // view direction\n\n        for (int i=0; i<40; i++)\n        {\n            d = rt(xyz*l);\n            if (d<.001) break;\n            l += d;\n            if (l>40.) break;\n        }\n        if (l<40.)\n        {\n            xyz *= l; // actual point\n            norm = normalize(vec3(\n            rt(xyz+vec3(e,0.,0.)) - rt(xyz-vec3(e,0.,0.)),\n            rt(xyz+vec3(0.,e,0.)) - rt(xyz-vec3(0.,e,0.)),\n            rt(xyz+vec3(0.,0.,e)) - rt(xyz-vec3(0.,0.,e))));\n            cl = cm*pow((length(norm+normalize(light-xyz))-1.1)*max(1.2-length(light-xyz)/15.,0.),4.);\n        }\n    }\n\n// draw stars\n    e = 2371.;\n\n    for(int i=0; i<40; i++)\n    {\n        n = t/15.;\n        if (t>=47.1)\n        {\n            n = 47.1/15. + (t-47.1)/20.;\n        }\n        z = fract(n+r); // n = slow time\n        m2 = s(uv.y,z);\n        if(m2 > 935.) // if higher than field\n        {\n            m1 = s(uv.x,z);\n            d = fract( sin( pow(floor(m1), floor(m2)/941.) ) * e );\n            if(d > .9985)\n            {\n                d = distance(vec2(m1,m2),vec2(floor(m1)+.5,floor(m2)+.5))*2.;\n                cs = max ( cs, z * min(1.,pow(1.5-d,15.)) );\n                cs = max ( cs, z * max(0.,1.-d) );\n            }\n        }\n        e-=.9;\n        r += .05;\n    }\n\n    cf *= cm; // apply torus mask to the field\n    cs *= cm; // apply torus mask to stars\n\n    cf *= clamp(t/4.-2.5,0.,1.); // fade in field on 0:10\n    cs *= clamp(t-31.,0.,1.); // fade in stars on 0:31\n\n    cl += cm*max(2.-l/20.,0.)*max(norm.z,0.); // add z-normals to the field light\n\n    cl *= pow(clamp(t*2.-93.2,0.,1.),3.); // fade in the field light at 0:46.6 - 0:47.1\n\n    c = vec3(cs/2., cs*cs, sqrt(cs)) +    // mix stars\n        vec3(0., cl*cl, cl) +    // mix lights\n        vec3(0., ct*ct, ct) +    // mix torus\n        vec3(cf*cf/2., 0., cf);  // mix field\n\n    c *= min(1.,t/4.); // global fade in\n\n    d = 2.-clamp(t/4.-12.75,0.,2.); // run big circle at 0:51\n    cf = smoothstep(1.,0.,abs(d-length(uv))) ; // global fade out\n    c += vec3(0., cf*cf, cf);    // mix big circle\n\n    d = 2.-clamp(t/4.-13.5,0.,2.2); // global fadeout at 54:00\n    cf = smoothstep(d-.1,d+.1,length(uv)) ;\n    c *= 1. - cf;\n} // endif t < 1:02\n\n\n\nelse // Scene 2 from 1:02\n{\n\nif (t<104.)\n{\n    m1 = min(t,85.)-62.; // stop move at 1:25\n    size = 31. - m1; // HAL size\n\n    z = fract(cos(m1*3.9)+sin(m1)*cos(m1*3.7)) ;// random blinking\n    if (t<65.) z = 3.-m1;\n\n    r = length(uv) * size;\n    cf = max(0.,.7-min(1.,r)); // red\n    ct = pow( r/99.*float(r<.6) , .4)    +    (.8-r)*float(r<.02); // blue\n    cm = min(1.,pow(max(0.,1.25-r),8.))/(10.-z*3.)    +    (z*.8+.3)*min(.7,pow(max(0.,.15-r)*9.,12.)); // yellow;\n\n    n = uv.y*size; // gradient\n\n// add plasma to red\n    m2 =\n    .3+.6*cos(cos(9.*(uv.x-.4)*pi + t/3.) + 9.*uv.y + t/7.) -\n    .6+.6*cos(cos(9.*uv.y*pi + t/5.) + 9.*(uv.x-.4) - t/9.);\n    cf += clamp(m2, 0., 1.)/3. * smoothstep(.1, 0., r-.4); // plasma * mask\n// end plasma\n    cf = mix(cf, floor(cf*16.)/16., max(0.,0.-n)); // discret red\n\n\n    xyz = vec3(cf+cm,cm,ct); // HAL 9000\n\n\tcf = atan(abs(uv.x),uv.y);\n    cm = clamp(pow(1.3-abs(cf),7.), 0.,1.); // mask\n    cm+= clamp(pow(1.05-abs(.8-cf),7.), 0.,1.); // mask\n\n    cm *= smoothstep(.1, 0., r-.53); // mask red radius\n\n    cl = max(0.,n) * pow(1.-sqrt(abs(r-.55)), 10.); // lights\n    cl += -pow(abs(n),3.) * pow(1.-sqrt(abs(r-.5)), 14.);\n\n\n    cl *= (.5 + cm/2.); // apply mask to the lights\n\n\n    cf = smoothstep(.97, .99, 1.035-abs(r-.68)); // rim\n    cf -= (1.-z/3.) * .5 * float(r>.61) * smoothstep(.0,.01,.685-r);\n\n    r = length(uv*vec2(.7,1.))*size; // lamps perspective\n\n\n    m2 = 1.35-fract(m1/24.); // ideal radius is .36\n    ct = 0.;\n    for(int i=1; i<4; i++)\n    {\n        ct += min(.8, max(0.,n) * pow(1.2-sqrt(abs(length(r-m2/float(i)))), 12.) )/((float(i)+.5)/1.5); // cool lamp\n    }\n\n    ct*=cm;\n\n    cl += ct;\n\n    light = vec3(cl*.9,cl*.9,cl);\n    norm = .4 * sqrt(n + .8) * vec3(cf/2.7,cf/2.,cf/1.5); // border\n\n    c = float(r<2.)*(xyz+light+norm);\n    c *= min(1.,(t-62.)/4.); // global fade in at 1:02\n\n}\n}\n    outcolor = vec4(c, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 12005,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/pavel-ksan/gravity-waves"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}