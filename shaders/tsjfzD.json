{
    "Shader": {
        "info": {
            "date": "1589920899",
            "description": "Our fave hobby during the quarantine.\nSound ON!",
            "flags": 8,
            "hasliked": 0,
            "id": "tsjfzD",
            "likes": 18,
            "name": "Shaderflix",
            "published": 3,
            "tags": [
                "shadow",
                "logo",
                "light",
                "tv",
                "television"
            ],
            "usePreview": 0,
            "username": "friol",
            "viewed": 817
        },
        "renderpass": [
            {
                "code": "\n//\n// friol 2o2o\n// sdf functions, ao and softshadows by iq\n// 20.05.2020: removed the fadeout at the end because the preview was showing a black screen\n// ah, shadertoy...\n// 20.05.2020: 16x sort-of antialiasing \n//\n\n// undefine this if it's too slow on your system\n#define ANTIALIASING\n\n\nconst int sdfIterationsAmount=256;\nconst vec3 vollightPos=vec3(0.0,.2,-2.0);\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\n//\n//\n//\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xy)-2.0*ra+rb, abs(p.z) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r,float elx,float ely )\n{\n  vec2 d = abs(vec2(length(vec2(p.x*elx,p.y*ely)),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 SDFMainScene(vec3 r)\n{\n    vec3 origR=r;\n    float t=10000.0;\n    const float letterSegmentWidth=0.08;\n    const float letterY=0.5;\n\n    float myTime=(iTime-0.6)*4.5;\n    float timeshift=0.2;\n    \n    float szheight=0.40*sin(myTime-3.141592/4.0);\n    float hzheight=0.38*sin(myTime-3.141592/4.0-timeshift);\n    float azheight=0.36*sin(myTime-3.141592/4.0-timeshift*2.0);\n    float dzheight=0.34*sin(myTime-3.141592/4.0-timeshift*3.0);\n    float deheight=0.32*sin(myTime-3.141592/4.0-timeshift*4.0);\n    float drheight=0.30*sin(myTime-3.141592/4.0-timeshift*5.0);\n    float dtheight=0.28*sin(myTime-3.141592/4.0-timeshift*6.0);\n    float doheight=0.26*sin(myTime-3.141592/4.0-timeshift*7.0);\n    float dyheight=0.24*sin(myTime-3.141592/4.0-timeshift*8.0);\n    \n    if (myTime>3.141592) szheight=0.20;\n    if (myTime>3.141592+timeshift) hzheight=0.20;\n    if (myTime>3.141592+timeshift*2.0) azheight=0.20;\n    if (myTime>3.141592+timeshift*3.0) dzheight=0.20;\n    if (myTime>3.141592+timeshift*4.0) deheight=0.20;\n    if (myTime>3.141592+timeshift*5.0) drheight=0.20;\n    if (myTime>3.141592+timeshift*6.0) dtheight=0.20;\n    if (myTime>3.141592+timeshift*7.0) doheight=0.20;\n    if (myTime>3.141592+timeshift*8.0) dyheight=0.20;\n    \n    // bg plane\n    const float mutationTime=1.5;\n    float plz=-0.95;\n    if (iTime>mutationTime) plz=-1.12;\n\n    float bgPlane=sdPlane(r-vec3(0.0,0.0,plz),vec4(0.0,0.0,-1.0,1.0));\n    t=min(t,bgPlane);\n\n    if (iTime<0.6) if ((t==bgPlane)) return vec2(t,1.0);\n    else return vec2(-1.0,-1.0);\n\n    if ((r.x>=-0.02)&&(r.x<0.41)) {if (r.y<-0.44) r.y-=sin(r.x+1.1)*.06; }\n    else if ((r.x>=1.25)&&(r.x<1.53)) { if (r.y<-0.42) r.y-=sin(r.x+1.1)*.06; }\n    else if ((r.x<2.14)&&(r.y<-0.25)) r.y-=sin(r.x+1.1)*.06;\n        \n    // S\n\tfloat sxpos=-1.66;\n    \n    float supminusbox=sdBox(r-vec3(sxpos+0.42,-0.2,0.0),vec3(0.4,0.4,szheight+0.4521));\n    float sdwminusbox=sdBox(r-vec3(sxpos-0.38,0.2,0.0),vec3(0.4,0.4,szheight+0.4521));\n\n    float zsupcurve=sdCappedCylinder(r-vec3(sxpos,0.202,0.0),\n                                    0.212*1.12,szheight,0.9,0.83);\n    float smincurve=sdCappedCylinder(r-vec3(sxpos,0.202,0.0),\n                                    0.101*1.12,szheight+0.1,0.9,0.92);\n    zsupcurve=opSubtraction(smincurve,zsupcurve);\n    zsupcurve=opSubtraction(supminusbox,zsupcurve);\n\tt=min(t,zsupcurve);    \n\n    float zsdwcurve=sdCappedCylinder(r-vec3(sxpos,-0.21,0.0),\n                                    0.212*1.12,szheight,0.9,0.83);\n    float sdwmincurve=sdCappedCylinder(r-vec3(sxpos,-0.21,0.0),\n                                    0.101*1.12,szheight+0.1,0.9,0.92);\n    zsdwcurve=opSubtraction(sdwmincurve,zsdwcurve);\n    zsdwcurve=opSubtraction(sdwminusbox,zsdwcurve);\n\tt=min(t,zsdwcurve);    \n    \n\n    \n    // H\n    float hxpos=-1.23;\n    \n    float lh=sdBox(r-vec3(hxpos,0.0,0.0),vec3(letterSegmentWidth,letterY,hzheight));\n    t=min(t,lh);\n    float rh=sdBox(r-vec3(hxpos+3.7*letterSegmentWidth,0.0,0.0),vec3(letterSegmentWidth,letterY,hzheight));\n    t=min(t,rh);\n    float horzh=sdBox(r-vec3(hxpos+.2,0.0,0.0),vec3(2.0*letterSegmentWidth,letterSegmentWidth,hzheight));\n    t=min(t,horzh);\n    \n    // A\n    float axpos=-0.6;\n\n    float suba=sdBox(r-vec3(axpos,-0.9,0.0),vec3(1.2,0.4,azheight+0.4521));\n\tfloat subaup=sdBox(r-vec3(axpos,0.9,0.0),vec3(1.2,0.4,azheight+0.1));\n    vec3 ra1=rotz(r,-0.15);\n    float la=sdBox(ra1-vec3(axpos,-0.22,0.0),vec3(letterSegmentWidth,letterY*1.3,azheight));\n    la=opSubtraction(suba,la);\n    la=opSubtraction(subaup,la);\n    t=min(t,la);\n    vec3 ra2=rotz(r,0.15);\n    float ra=sdBox(ra2-vec3(axpos+0.25,0.04,0.0),vec3(letterSegmentWidth,letterY*1.2,azheight));\n    ra=opSubtraction(suba,ra);\n    ra=opSubtraction(subaup,ra);\n    t=min(t,ra);\n    float horza=sdBox(r-vec3(axpos+.12,-0.1,0.0),vec3(2.0*letterSegmentWidth,letterSegmentWidth,azheight));\n    t=min(t,horza);\n\n    // D\n    float dxpos=-0.02;\n    \n    float leftd=sdBox(r-vec3(dxpos,0.0,0.0),vec3(letterSegmentWidth,letterY,dzheight));\n    t=min(t,leftd);\n    \n    float dcurve=sdCappedCylinder(r-vec3(dxpos+letterSegmentWidth-0.03,0.0,0.0),0.212*1.12,dzheight,0.7,0.48);\n    float dminus=sdBox(r-vec3(dxpos-0.3,0.0,0.0),vec3(0.3,1.0,0.63));\n    float dmincurve=sdCappedCylinder(r-vec3(dxpos+letterSegmentWidth-0.06,0.0,0.0),0.22*0.7,0.43,0.7,0.48);\n    dcurve=opSubtraction(dminus,dcurve);\n    dcurve=opSubtraction(dmincurve,dcurve);\n    t=min(t,dcurve);\n    \n    // E\n    float depos=0.53;\n    \n    float lefte=sdBox(r-vec3(depos,0.0,0.0),vec3(letterSegmentWidth,letterY,deheight));\n    t=min(t,lefte);\n    float horzeup=sdBox(r-vec3(depos+.14,0.42,0.0),vec3(2.7*letterSegmentWidth,letterSegmentWidth,deheight));\n    t=min(t,horzeup);\n    float horzemid=sdBox(r-vec3(depos+.14,0.0,0.0),vec3(1.7*letterSegmentWidth,letterSegmentWidth,deheight));\n    t=min(t,horzemid);\n    float horzedwn=sdBox(r-vec3(depos+.14,-0.42,0.0),vec3(2.7*letterSegmentWidth,letterSegmentWidth,deheight));\n    t=min(t,horzedwn);\n    \n    // R\n    float drpos=1.10;\n    \n    float leftr=sdBox(r-vec3(drpos,0.0,0.0),vec3(letterSegmentWidth,letterY,drheight));\n    t=min(t,leftr);\n    \n    float rcurve=sdCappedCylinder(r-vec3(0.05+drpos+letterSegmentWidth,letterY*0.38,0.0),0.21*0.7,drheight,0.7,0.48);\n    float rmincurve=sdCappedCylinder(r-vec3(0.0+drpos+letterSegmentWidth,letterY*0.4,0.0),0.21*0.4,drheight+0.1,0.7,0.48);\n\trcurve=opSubtraction(rmincurve,rcurve);\n    t=min(t,rcurve);\n    vec3 ra3=rotz(r,0.31);\n    float rleg=sdBox(ra3-vec3(drpos+0.12,-0.75,0.0),vec3(letterSegmentWidth,letterY*0.6,drheight)); \n    float subr=sdBox(r-vec3(drpos,-0.9,0.0),vec3(1.2,0.4,drheight+0.41));\n    rleg=opSubtraction(subr,rleg);\n\tt=min(t,rleg);\n    \n    // T\n    float txpos=1.63;\n    \n    float horztup=sdBox(r-vec3(txpos+.14,0.42,0.0),vec3(3.2*letterSegmentWidth,letterSegmentWidth,dtheight));\n    t=min(t,horztup);\n    float tmid=sdBox(r-vec3(txpos+0.14,0.0,0.0),vec3(letterSegmentWidth,letterY,dtheight));\n    t=min(t,tmid);\n    \n    // O\n    float oxpos=2.24;\n    \n    float ocurve=sdCappedCylinder(r-vec3(oxpos+letterSegmentWidth,0.0,0.0),letterY*0.49,doheight,0.9,0.48);\n    float minocurve=sdCappedCylinder(r-vec3(oxpos+letterSegmentWidth,0.0,0.0),letterY*0.28,doheight+0.1,1.0,0.43);\n    ocurve=opSubtraction(minocurve,ocurve);\n    t=min(t,ocurve);\n    \n    // Y\n    float yxpos=2.86;\n    \n    float centralline=sdBox(r-vec3(yxpos-0.02,-0.3,0.0),vec3(letterSegmentWidth,letterY*0.5,dyheight));\n    t=min(t,centralline);\n\n    float suby=sdBox(r-vec3(yxpos,0.9,0.0),vec3(1.2,0.4,dyheight+0.4521));\n    const float yyangle=0.35;\n    vec3 ra4=rotz(r,-yyangle);\n    float lefty=sdBox(ra4-vec3(yxpos-0.18,1.3,0.0),vec3(letterSegmentWidth,letterY*.7,dyheight));\n    lefty=opSubtraction(suby,lefty);\n    t=min(t,lefty);\n    vec3 ra5=rotz(r,yyangle);\n    float righty=sdBox(ra5-vec3(yxpos-0.20,-0.7,0.0),vec3(letterSegmentWidth,letterY*.68,dyheight));\n    righty=opSubtraction(suby,righty);\n    t=min(t,righty);\n\n\t//    \n\n    if ((t==bgPlane)) return vec2(t,1.0);\n    if ((t==zsupcurve)||(t==zsdwcurve)) return vec2(t,2.0);\n    if ((t==lh)||(t==rh)||(t==horzh)) return vec2(t,2.0);\n    if ((t==la)||(t==ra)||(t==horza)) return vec2(t,2.0);\n    if ((t==leftd)||(t==dcurve)) return vec2(t,2.0);\n    if ((t==lefte)||(t==horzeup)||(t==horzedwn)||(t==horzemid)) return vec2(t,2.0);\n    if ((t==leftr)||(t==rcurve)||(t==rleg)) return vec2(t,2.0);\n    if ((t==horztup)||(t==tmid)) return vec2(t,2.0);\n    if ((t==ocurve)) return vec2(t,2.0);\n    if ((t==centralline)||(t==lefty)||(t==righty)) return vec2(t,2.0);\n    \n    return vec2(-1.0,-1.0);\n}\n\n//\n//\n//\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFMainScene(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec3 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t=0.0;\n    bool hit=false;\n    vec2 res;\n    float edgedist=0.0;\n    \n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        res = SDFMainScene(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n            edgedist=t;\n            hit=true;\n            break;\n        }\n\n        t+=res[0];\n    }\n    \n    if (hit==false) return vec3(-1.0);\n    return vec3(t,res[1],edgedist);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = SDFMainScene( ro + rd*t )[0];\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = SDFMainScene( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 fogColor=vec3(0.02,0.1,0.2);\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vollightPos);\n    \n    vec3 rayHit = castRay(rayOrigin, rayDir);\n    \n    #ifdef ANTIALIASING\n    const float aaraydelta=0.001;\n    const int numaarays=16;\n    vec3 aaarray[numaarays];\n    for (int r=0;r<numaarays;r++)\n    {\n    \taaarray[r] = castRay(rayOrigin, \n              vec3(rayDir.x+aaraydelta*sin(3.141592*2.0*float(r)/float(numaarays)),\n                   rayDir.y+aaraydelta*cos(3.141592*2.0*float(r)/float(numaarays)),\n                   rayDir.z));\n    }\n    #endif\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n\n    vec3 N=calcNormal(pHit);\n    float dotprod=max(dot(N,L),0.0);\n\n    vec3 shadowLight=normalize(vec3(-1.2, 1.8, -0.52));\n    const float mutationTime=1.5;\n    \n    if (mat==1.0) // bg plane\n    {\n        col=vec3(dotprod)*vec3(0.9,0.9,0.9);\n\n        #ifdef ANTIALIASING\n        float totMissed=0.0;\n        for (int r=0;r<numaarays;r++)\n        {\n            if (aaarray[r][1]==2.0) totMissed+=1.0/float(numaarays);\n        }        \n      \tif (iTime>=mutationTime) col=mix(col,vec3(244.0/255.0,6.0/255.0,16.0/255.0),totMissed);\n        #endif\n        \n        float ss=calcSoftshadow( pHit, shadowLight, 0.01, 2.5,0);\n        if (iTime<mutationTime) col=mix(col,vec3(156.0/255.0,162.0/255.0,174.0/255.0),1.0-ss);\n    }\n    else if (mat==2.0) // letters\n    {\n        if (iTime<mutationTime) \n        {\n            float lettersIntensity=0.60;\n            col=vec3(lettersIntensity)*dotprod;\n\n            #ifdef ANTIALIASING\n            float totMissed=0.0;\n            for (int r=0;r<numaarays;r++)\n            {\n                if (aaarray[r][1]==1.0) totMissed+=1.0/float(numaarays);\n            }        \n            col=mix(col,vec3(0.9),totMissed);\n            #endif\n            \n            float occ = calcAO( pHit, N );\n            col*=occ*3.1;\n            float ss=calcSoftshadow( pHit, shadowLight, 0.01, 2.5,0 );\n            col=mix(col,vec3(ss,ss,ss),0.65);\n            col=clamp(col,0.763,1.0);\n        }\n        else\n        {\n            col=vec3(244.0/255.0,6.0/255.0,16.0/255.0);\n            \n            #ifdef ANTIALIASING\n            float totMissed=0.0;\n            for (int r=0;r<numaarays;r++)\n            {\n                if (aaarray[r][1]==1.0) totMissed+=1.0/float(numaarays);\n            }        \n            col=mix(col,vec3(0.9),totMissed);\n            #endif\n        }\n    }\n    else if (mat==3.0)\n    {\n        col=vec3(0.1,0.2,0.1);\n    }\n    else if (mat==4.0)\n    {\n        col=vec3(0.01,0.1,0.3);\n    }\n    else\n    {\n        col=fogColor;\n    }\n    \n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    float fov=1.9;\n    vec2 result = fov*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float camxpos=0.75;\n    float camypos=0.0;\n\tif (iMouse.z>0.0)\n    {\n    \tvec2 mousepos=(iMouse.xy-0.5*iResolution.xy)/iResolution.x;\n        camxpos=(mousepos.x)*4.0;\n        camypos=(mousepos.y)*4.0;\n    }    \n\n    float camzadder=0.0;\n    if (iTime>=1.5) camzadder=(iTime-1.5)/8.0;\n    camPos=vec3(camxpos,camypos,-5.9-clamp(camzadder,0.0,.5));\n    camTarget=vec3(camxpos,camypos,1.0);\n    //camPos=vec3(camxpos,camypos,-3.5);\n    //camTarget=vec3(camxpos,camypos,1.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4((render(camPos, rayDir,uv,fragCoord).xyz),1.0);\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n\tvec2 coord = (uv2 - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    float rf = sqrt(dot(coord, coord)) * 0.19;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);\n    \n    vec4 src = finalCol;\n\tfragColor = vec4(src.rgb * e, 1.0);\n\n    if (iTime<0.53) fragColor=vec4(0.0);\n    if (abs(uv.y)>0.92) fragColor=vec4(0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//\n// basically, the shaderflix sound consists in:\n// - two kicks with reverb, shifted by 0.2s \n// - a drone/synth low note\n// - two 1 high and 1 octave down sinuses\n// (the original here is more of a reverse thingie)\n//\n\n\n#define PI 3.1415926535897932384626433832795\n\nconst float tempo=2.0;\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 897612.531);\n}\n\n// perlin noise\nfloat nse(float x)\n{\n    float y = floor(x);\n    x -= y;\n    x = x * x * (3. - 2. * x);\n    return mix(hash(y), hash(y + 1.), x) - .5;\n}\n\n// crude vowel-\"A\" instrument\nfloat voc(float t, float f, float formant)\n{\n    float x = fract(t * f) / f;\n    return (sin(x * 6. * formant) * .4 + sin(x * 12. * formant) + sin(x * 26. * formant) * .2) * min(x * 1000., 1.) * exp(x * -200.);\n}\n\n// a swarm of voc()'s\nvec2 inst2(float t, float f)\n{\n    vec2 v = vec2(0., 0.);\n    float formant = 250. * exp2(sin(t * .1));\n    for(int i = 0; i < 16; ++i)\n    {\n        float h = float(i);\n       \tfloat m = voc(t + h / 3., f + pow(2.01, (h - 8.) * .2), formant);\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .1;\n}\n\n// squarewave-ish instrument\nvec2 inst4(float t, float f)\n{\n    vec2 v = vec2(0., 0.);\n    for(int i = 0; i < 8; ++i)\n    {\n        float h = float(i) * 2. + 1.;\n        float x = h;\n       \tfloat m = sin(t * f * 2. * PI * x) * (1. + nse(h * 41. + t * 10.)) / h;\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .25;\n}\n\n// by srtuss -> https://www.shadertoy.com/view/4ddfWX\n// 2 octaves of choir + playing harmonics, which gives some symphonic qualities\nvec2 choir(float time, float n)\n{\n    float choirFrequency=175.0*1.0;\n    vec2 v = vec2(0.0);\n    v+=inst2(time, choirFrequency * pow(2., n / 12.));\n    v += inst2(-time, 2.0*choirFrequency * pow(2., n / 12. - 1.));\n\n    return v;\n}\n\n//\n// boom/kick\n//\n\nfloat boomKick(float t,float punchiness)\n{\n    float h = 0.7;\n    float tt = t;\n    float v;\n    float phs = (pow(tt, 0.5) + t) * 1.1;\n    float thekick=clamp(-1.0, 1.0, (nse(phs * punchiness) + sin(phs * 200.0) * 0.5) * \n               exp(max(0.04 - tt, 0.0) * -10.0) * exp(max(tt, 0.0) * -4.0) * 8.0) * 1.4;\n    return v+thekick;\n}\n\n//\n// sibilant\n//\n\nfloat sibilant(float t,float tstart,float octave,float volume)\n{\n    if ((t>=tstart)&&(t<=tstart+3.141592))\n    {\n\t\treturn volume*abs(sin(t-tstart))*sin((t-tstart)*460.0*octave);\n    }\n    else return 0.0;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n\tvec2 v=vec2(0.0);\n    float x;\n    \n    const float firstKickDelay=0.89;\n    const float choirDelay=firstKickDelay+0.14;\n    x = mod(time-choirDelay, 32. / tempo);\n    \n    if (time>firstKickDelay)\n    {\n        float k=boomKick(time-firstKickDelay,500.0);\n    \tv+=vec2(k*0.65,k*0.35)*0.2;\n    }\n    \n    if (time>choirDelay)\n    {\n    \tv += choir((time-choirDelay)*1.0, -15.) * clamp(x * tempo * .5, 0., 1.) * smoothstep(6. + 4., 5., x * tempo);\n        float k=boomKick(time-choirDelay,1000.0);\n    \tv+=vec2(k*0.35,k*0.65)*0.1;\n    }\n\n    v.y += sibilant(time,firstKickDelay+0.04,8.0,0.25);\n    v.x += sibilant(time,choirDelay+1.5,4.0,0.1);\n \n    if (time>7.0) return vec2(0.0);\n    \n    return v;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}