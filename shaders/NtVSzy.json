{
    "Shader": {
        "info": {
            "date": "1641151657",
            "description": "Vector map of the earth delta-encoded into 8-bit vectors used to trace out the SDF.\nSign is generated using a simple even-odd point in N-gon check.",
            "flags": 32,
            "hasliked": 0,
            "id": "NtVSzy",
            "likes": 51,
            "name": "Metal Globe",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "earth",
                "compression",
                "ngon",
                "encoding",
                "globe"
            ],
            "usePreview": 0,
            "username": "Flyguy",
            "viewed": 959
        },
        "renderpass": [
            {
                "code": "#define VIEW_SDF 0\n\nconst int MAX_ITER = 70;\n\nconst float GLOBE_RAD = 50.0;\nconst float GRID_LINES = 26.0;\nconst float GRID_THICK = 0.6;\nconst float LAND_THICK = 2.0;\nconst float BORDER_CHAMFER = 0.15;\n\nconst float MAT_BACKGROUND = 0.;\nconst float MAT_SILVER = 1.;\nconst float MAT_GOLD = 2.;\n\nvec2 sdGlobeMap(vec3 p, float mat)\n{\n   vec2 texc = vec2(\n        atan(p.y, p.x)/tau + 0.5,\n        1.- atan(length(p.xy), p.z)/pi + 1.0\n    );\n    float sdf = texture(iChannel0,texc,0.).x;\n    \n    return vec2(sdf*length(p), mat); \n}\n\nvec2 sdGlobeShell(vec3 p)\n{\n    vec2 dland = sdGlobeMap(p, MAT_GOLD);\n    dland = opSChamfer(BORDER_CHAMFER, opN(sdSphere(p, GLOBE_RAD, MAT_GOLD)), dland); \n    dland = opS(sdSphere(p, GLOBE_RAD-LAND_THICK, MAT_GOLD), dland); \n    \n    return dland;\n}\n\nvec2 sdGrid(vec3 p)\n{\n    float gridrad = GLOBE_RAD - LAND_THICK - GRID_THICK;\n    vec3 plon = Revolve(AngRep(p.xyz,tau/GRID_LINES).zxy);\n    vec3 plat = AngRep(Revolve(p.xyz).xzy, tau/GRID_LINES);\n    \n    vec2 dgrid = sdSphere(plon - vec3(gridrad,0,0), GRID_THICK, MAT_SILVER);\n    dgrid = opS(sdCylinder(p, sin(pi/GRID_LINES)*gridrad, MAT_SILVER), dgrid);\n    dgrid = opU(sdSphere(plat - vec3(gridrad,0,0), GRID_THICK, MAT_SILVER), dgrid);\n    \n    return dgrid;\n}\n\nvec2 Map(vec3 p)\n{\n    vec2 d = opN(sdSphere(p,200.0, MAT_BACKGROUND));\n    \n    d = opU(d, sdGrid(p));\n    d = opU(d, sdGlobeShell(p));\n    \n    return d;\n}\n\nvec4 MarchRay(vec3 orig, vec3 dir)\n{\n    vec3 mPos = orig;\n    vec3 lPos = orig;\n    float mat = 0.;\n    \n    for(int i = 0;i < MAX_ITER;i++)\n    {\n        vec2 dMap = Map(mPos);\n        \n        if(dMap.x < eps)\n        {\n            mat = dMap.y;\n            break;\n        }\n        else\n        {\n            lPos = mPos;\n            mPos += dir*dMap.x;\n        }   \n    }\n    \n    return vec4(mPos, mat);\n}\n\nvec3 Normal(vec3 p)\n{\n    vec2 offs = vec2(eps,0);\n    float c = Map(p).x;\n    return normalize(vec3(\n        Map(p+offs.xyy).x - c,\n        Map(p+offs.yxy).x - c,\n        Map(p+offs.yyx).x - c\n    ));\n}\n\nvec4 textureTriPlanar(sampler2D tex, vec3 p, vec3 n, float lod)\n{\n    n = abs(n);\n    n /= n.x+n.y+n.z;\n    vec4 tx = texture(tex, p.yz, lod);\n    vec4 ty = texture(tex, p.zx, lod);\n    vec4 tz = texture(tex, p.xy, lod);\n    vec4 to = vec4(0);\n    to = mix(to,tx,n.x);\n    to = mix(to,ty,n.y);\n    to = mix(to,tz,n.z);\n    return to;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y - res/2.0;\n    vec2 m = iMouse.xy/iResolution.xy - 0.5;\n    \n    m = (iMouse.xy == vec2(0)) ? vec2(iTime*0.4, -0.7*cos(iTime*0.2)) //Thumbnail\n                               : m*vec2(tau,pi); //Mouse look\n    \n    //Camera\n    mat3 camMat = Rotate(vec3(m.y, 0.0, m.x));\n    vec3 orig = vec3(0,-130,0) * camMat;\n    vec3 dir = normalize(vec3(uv.x,0.9,uv.y)) * camMat;\n    \n    vec4 hit = MarchRay(orig, dir);\n    vec3 nrm = Normal(hit.xyz);\n    \n    vec3 col = vec3(0); \n    \n    if(hit.w == MAT_BACKGROUND) //Background\n    {\n        col = texture(iChannel1,dir.xzy,0.).rgb;\n    }\n    \n    if(hit.w == MAT_SILVER) //Grid silver-metallic\n    {\n        vec3 env = texture(iChannel1,reflect(dir, nrm).xzy,0.).rgb;\n        env = env*0.9+0.1;\n        col = vec3(0.95)*env;\n\n        float shadow = smoothstep(0.0,3.0,sdGlobeShell(hit.xyz).x);\n        shadow = mix(1.0, shadow, max(0.,dot(normalize(hit.xyz),nrm)));\n        shadow = shadow*0.5+0.5;\n        col *= shadow;\n    }\n    \n    if(hit.w == MAT_GOLD) //Map gold-metallic \n    {\n        vec4 tex = textureTriPlanar(iChannel2, hit.xyz*0.01, nrm, 0.);\n        nrm = normalize(nrm + tex.xyz*0.05);\n        vec3 env = texture(iChannel1,reflect(dir, nrm).xzy,0.).rgb;\n        env = env*0.9+0.1;\n        col = vec3(0.15,0.1,0.04)*env*9.;\n        \n        float shadow = smoothstep(0.0,3.0,sdGrid(hit.xyz).x);\n        shadow = mix(1.0, shadow, max(0.,-dot(normalize(hit.xyz),nrm)));\n        shadow = shadow*0.5+0.5;\n        col *= shadow;\n    }\n    \n    fragColor = vec4(col, 0);\n    \n    #if(VIEW_SDF == 1)\n        float _dist = 2.*texelFetch(iChannel0, ivec2(fragCoord),0).r;\n        fragColor.rgb = mix(vec3(0.3,0.5,1),vec3(1,0.7,0.3),step(0.,_dist));\n        fragColor.rgb *= 0.9+0.1*(-cos(_dist*300.0));\n        fragColor.rgb *= smoothstep(0.002,0.005,abs(_dist)); \n        fragColor.rgb *= 1.0/(1.0+abs(_dist)*15.);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Constants\nconst float inf = 1e3;\nconst float eps = 0.03;\nconst float pi = 3.14159265;\nconst float tau = 6.28318531;\n\n//Transformation / Domain Modification Functions\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n//Angular Repeat\nvec3 AngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n//Revolve (radial extrude) around Z\nvec3 Revolve(vec3 p)\n{\n    return vec3(length(p.xy), 0.0, p.z);\n}\n\n\n//SDF Combination Operators\n//Union\nvec2 opU(vec2 a, vec2 b) \n{ \n    return (a.x < b.x) ? a : b;\n}\n\n//Subtract\nvec2 opS(vec2 a, vec2 b)\n{\n    return (-a.x > b.x) ? vec2(-a.x,a.y) : b;\n}\n\n//Intersection\nvec2 opI(vec2 a, vec2 b)\n{\n    return (a.x > b.x) ? a : b;\n}\n\n//Negate\nvec2 opN(vec2 a)\n{\n    return vec2(-a.x,a.y);\n}\n\n//Subtract with 's' x 45deg chamfer at boundary. \nvec2 opSChamfer(float s, vec2 a, vec2 b)\n{\n    return vec2(max(max(-a.x, b.x), -((a.x+-b.x)-s)/sqrt(2.0)), a.y);\n}\n\n\n//SDF Functions\nvec2 sdCylinder(vec3 p, float r, float mat)\n{\n  return vec2(length(p.xy)-r, mat);\n}\n\nvec2 sdPlane(vec3 p, vec3 n, float h, float mat)\n{\n  return vec2(dot(p,normalize(n)) + h, mat);\n}\n\nvec2 sdSphere(vec3 p, float r, float mat)\n{\n  return vec2(length(p)-r, mat);\n}\n\nvec2 sdTorus(vec3 p, vec2 t, float mat)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec2(length(q)-t.y, mat);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Earth map SDF\n\nconst int VECS_PER_FRAME = 50; //# of vectors to decompress per frame.\nconst int VECT_COUNT = 3040; //Total # of vectors (4096 max).\nconst int SHAPE_COUNT = 101; //Total # of shapes (256 max).\nconst float MAX_EXTENT = 756.0; //Max X/Y dim of the vector image for scaling (1024 max).\nconst vec2 ASPECT = vec2(2,1);\n\n//Maps a linear address to a location in a 2D region.\nivec2 IdxToUV(int addr, ivec2 base, ivec2 size)\n{\n    return ivec2(addr % size.x, (addr / size.x) % size.y) + base;\n}\n\n//Maps a location in a 2D region to a linear address.\nint UVToIdx(ivec2 uv, ivec2 base, ivec2 size)\n{\n    uv -= base;\n    return (uv.x + uv.y * size.x);\n}\n\n//Outputs vector & shape data to the alpha channel on the 1st frame.\n//Data will be sampled from the alpha channel on following frames.\n//Avoids performace issues caused by the large arrays.\nvec4 Initialize(ivec2 uv)\n{\n    int i = UVToIdx(uv, ivec2(0), ivec2(iResolution.xy));\n    \n    int vecdata = 0;\n    \n    //Vector data\n    //Each int contains 4 bytes, each byte is a vector with 2 signed 4-bit (-8 - +7) components.\n    const int vects[] = int[VECT_COUNT/4](\n        0x4F0E2F41,0x412F3F5D,0x411F0E20,0xCF0DFF0F,0xEF0E200F,0xD1E2A0D3,0xFEFFD102,0xF0EEE0E1,\n        0x13E0DEE2,0x11130324,0xCE0C4E20,0xE0E1DFFE,0x2303E1DF,0x17325032,0xDEB4F212,0x0E2AEBDC,\n        0x311D204F,0x21D20212,0x02D0FF0E,0x01D02F22,0x010F1F21,0x311EEFE1,0x31435531,0x11E10152,\n        0xCEDFE0E1,0xD0CEFEE0,0x0FEF0ECD,0x2F0F1F30,0xD0C20121,0x12F2D1F2,0xFEDFD0F1,0xFEE0CED0,\n        0x3E11202F,0x4F51212F,0xE201315D,0xAFE12301,0x2E0EDEE0,0xD09E605F,0x3DCDFCEF,0x403E3AED,\n        0xEF400E3F,0x20710ED0,0x3E5F0ECE,0xDC0C3B20,0x09CFDC0D,0x304C0DBB,0x606E4121,0x21305F7E,\n        0x7671402F,0x71534602,0x03336134,0x616202C1,0xD0F1122F,0x112F2101,0xDFC004C5,0xD0FEF0F1,\n        0xD201E1B5,0x70706201,0x91F11171,0xE102C0D1,0xC4C19191,0x94C0D392,0x9F9F9191,0xEF0F9E9E,\n        0x2102F1E0,0x1E3F2F1F,0x1FFEF3D0,0x2203F2CE,0xD0EFB03E,0xAFAFD0DF,0xDCCFAFAF,0x725F7F3D,\n        0x52505F41,0x52315234,0xD0B1C1F1,0xFE2F31F2,0x1E3101D1,0x02D206FF,0xFEE0C4B4,0x2B4D300B,\n        0x0EEE0F2E,0xEFE33331,0xF2223EFE,0xEFE1B512,0x0C2EEE0C,0x2F20142F,0x03F0DF21,0xD2EF1E30,\n        0xE0021F40,0xA0EF3FFF,0x22E190FF,0x301F3041,0xF1034E11,0x0E2E0EF0,0x2102E0EF,0x1EFFEC20,\n        0x1EFF1EED,0xE2C0FF0D,0x42D5C2F3,0xC1024301,0x2D33F103,0xF103103D,0x2F331302,0x1CFD1C0D,\n        0x1BDDD234,0xFEF2122E,0xE0FEEE0D,0x3114E203,0xE0EE0E4F,0x0D2F2104,0x2104F0FE,0x43314B19,\n        0x36322243,0x03350714,0xE9F9DEE1,0xE0CDBBDC,0x02FFD3E1,0x312EEED1,0xFFD0E103,0x0D2F1A0B,\n        0x0214552D,0xE1BCC2F2,0x30120712,0xAE0E0D2B,0x5151E2A0,0x04E22240,0xFC09DEE2,0xF332302C,\n        0xF212F2F2,0x1E0BEFF3,0xED0C201F,0x2F2206E0,0x01F2F00E,0x1727072F,0x03F30732,0xF3073755,\n        0x17240335,0x03311207,0x11F507E7,0xE2F603F2,0x12F105E0,0x4E4D0317,0xF5172331,0xD70607D3,\n        0x022112E7,0xF4E50232,0x22202B21,0x05202D20,0x32C21433,0x300E3E22,0x0143F322,0x21F24131,\n        0xE11336F2,0xE0ED1ECE,0xCF9FB2FE,0xAE9092D0,0xE7E7D7C7,0x032503E7,0x274403E4,0x43023227,\n        0x05640224,0x36440422,0x230525F3,0x03B31230,0x030717F5,0xF7F7E334,0x02471704,0x22E7D313,\n        0x22273631,0x440331E2,0xF5E4C407,0xD203F707,0x44A72203,0x124F2147,0xD20317E3,0x41320614,\n        0x2204E2F3,0xE7C322E2,0xD4053305,0x022507E0,0x05D30225,0xF7F70731,0x03F0E3F7,0x22E507D2,\n        0xE1C5F6D4,0xE712E322,0xBA0C9DC6,0x03C4B0CC,0xF715E531,0xF707F7E7,0x90909007,0x90909090,\n        0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,\n        0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,\n        0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,0x09090909,\n        0x09090909,0x09090909,0x09090909,0x70707070,0xEE707070,0xFE1F22F1,0x1F4002C1,0x1F30F1D0,\n        0xD3D2D00F,0x0E4D3F20,0x0F2F03E0,0x0F2F11D1,0xD02001E0,0x5D2002C1,0xFBEEE0ED,0x4243F3D2,\n        0xCC0D1F21,0x2254E1DF,0x01D0FF21,0xE1CF1F31,0xFD2F2021,0x30F303D0,0xE2DF0E2D,0x91EE3021,\n        0x4002E0FF,0xB72F5011,0xC4E0D2B7,0xE1D2EFD0,0x2CD0B4E0,0xFE2D7D1E,0x0B4E0BBF,0x7D203220,\n        0x5EFE2E3B,0x31205C21,0xB0D422D1,0xEF0274C2,0x2E3F02D2,0x14F2DF0D,0xEFFE0D3E,0xF22F34E3,\n        0xDE301FDF,0xCE1031F1,0xEE2F32F1,0xDFDE1D0D,0xAFA2BF9F,0xA1417003,0x4E4022B2,0x40F2315F,\n        0x312EED1E,0x742F4307,0x9CD2B321,0xEDE0A3D0,0xEF90DEA0,0x2BFD3EFD,0x524F7F6F,0x741362E2,\n        0x02B1A0AE,0x5E4F5032,0x95A494E5,0x21C2F1B0,0x90DFE0C2,0x03E1E5E0,0xEF02D421,0x3A09FFC5,\n        0x2F216AFE,0x4F7D6C0E,0x3E5F2F7E,0xDF405D5E,0xC0CD1EDE,0x31C3B034,0xE37E5042,0xD5B0CE91,\n        0xBFA003B0,0x203FEEED,0xD202502F,0x301E2011,0xEEC11D2F,0x303E405F,0xB3217141,0xCEFEC0E4,\n        0xA2E0EF3C,0xBFB0BEB0,0x2ECDEBEE,0xB03F0FBC,0x307E0FBE,0x72163265,0x414232E2,0x525F412F,\n        0x0F316101,0x0F2001E0,0x2001F1FF,0x3101D00E,0x01B3DF0F,0xD00E1F7F,0xFF0F3101,0x2002F1F0,\n        0xE0CC0F1F,0xF15033E2,0xED111FFF,0x05E1DE0F,0x0D2E2032,0x0C2002E1,0xE203B3FE,0x2012F212,\n        0xEF1D1D3E,0x1F2001F1,0xE20533D3,0x3D0CCED1,0x21201D1D,0xE1EEFD0D,0xD2FE1FFF,0x0311D4F3,\n        0x3F4E2031,0x2D0DD0EE,0x0FFE2F0E,0xCB0DFD5F,0x13F4E0FD,0xDFF132E2,0x04E1F5F2,0x20320626,\n        0x0E4D0D1E,0x3F02F1E0,0x43517203,0x46142361,0x25172342,0x3E303346,0x2F540261,0x41E33F40,\n        0x2FFE203E,0x32033013,0x09202337,0x6DEC2FF9,0x1B093A0C,0x1DFCF9F9,0x09EFFCFB,0x1DFE2DEF,\n        0x0BEFEBF9,0xF4E0ECED,0xEEE90BEE,0x07C5D1D3,0x9294D717,0xD2BEF3D0,0x1DC02204,0xB3B1CFDE,\n        0xE29494D0,0xE102D303,0xD10E3FFE,0xC91F2101,0xBFD0EEBF,0x9BCCCEA0,0xA09291BF,0x7F6E0EDF,\n        0x2EFE5D20,0x2E0DBF0A,0x90DDBB1D,0x91C090BF,0xF2E2D0D2,0x22613215,0xDED0E323,0x07DF9F90,\n        0x9F9FC302,0x0234C392,0x334043C3,0xD1014213,0x2111F1FF,0xE203C3E2,0x31D20332,0xC4C1D0E1,\n        0xB604E2B2,0xC0D191C2,0xD402E2D2,0x04E5E0E2,0x91F4D2A4,0x9D9D9E90,0x9F9F9F90,0x9AFBAD9E,\n        0xADBFB1BE,0xFEAD9E9C,0x9EB1C12B,0xD0CE0DDB,0xF2C02DDE,0xDFAFFEE0,0xC0D3D0DD,0xC0DDD0CC,\n        0xDBD3C392,0x7E6B3B0C,0x2E52707F,0x30025172,0x417170FE,0x7172713F,0x71717070,0x70717070,\n        0x4C5C6E40,0x5E7E506D,0x703E7D7F,0x503F2042,0x42414371,0x5F4E7060,0x5BEEBF0F,0x401F3D4E,\n        0x7B3D497D,0x3C4C59DC,0x7D712F5D,0x7B403E7C,0xC00E6E7E,0x93C1E1D2,0x0FB0C292,0x5B502F7C,\n        0x7D7F7C41,0x7D206E6A,0x715F707E,0x7A7F2070,0x5C5F213E,0x0EFE2F4F,0x5A7D2D5F,0xDF3B0A3B,\n        0x402FEDEB,0xBCCCE0BD,0xFCEBDCDD,0x03322420,0x1B204343,0x3DFD6FFC,0x2304735E,0x3DFE0A30,\n        0x0324322D,0x2E6903F1,0x36431530,0xF7E5F526,0xE3E7F7F7,0x06173202,0xE233B333,0xF4D60312,\n        0x303E2E6F,0x2F3BEBCD,0xE7153073,0xF5E4D403,0x0350C422,0x93DEE213,0xE0FED0D6,0x27E5E00B,\n        0x5003433E,0x423F3033,0x0DBDE207,0xE2D2B4CF,0x5302A0F4,0x6F3E2A50,0x16E21653,0x0397E407,\n        0xB0C304D3,0xDFE1B7E4,0xC2FF6ABC,0x1DCEB3F2,0x6B2B1AC1,0x323EFB1C,0x32411205,0x0DDEFD3F,\n        0xEC5D522F,0xD2EFB01D,0xD3D4CECC,0xCC2D0DE0,0xCE61213C,0xDFEE0ECD,0xB1BECDFD,0xE513A1F3,\n        0xA1F6D4C3,0xFFD002E0,0x407E33D3,0x4E4F4323,0x2F42102F,0x14E54160,0xC39103A5,0xA3C26234,\n        0xE3C4A2C2,0x90D1F2E0,0x9203D2CF,0xED4EEFB0,0x623E0B2F,0x990E2273,0x1DD0E20B,0x14DFFD5C,\n        0xF3C0DEC3,0xB00242D3,0xFDEDE00E,0xFD533EBC,0x29B1CEA9,0x09091B0B,0x1CDD0BF9,0xDA0DFE0E,\n        0xEC3AFFE3,0xC402D2BD,0xDFF215F4,0x132D09EC,0xED2C2F2D,0xEFE0F3D2,0xE0FDE0E3,0x3F2103E3,\n        0xD2C10220,0x3507F706,0xFC0A1C3F,0x1706111B,0x222F44E6,0x05314402,0x14362445,0xEF0F2012,\n        0x2E1102F1,0x0E3101D0,0x11F20221,0xE412503F,0xF2E0FEE0,0x35372122,0x130323C1,0x1E3E12F2,\n        0x04E20220,0x3E11C7E5,0x2F21300E,0x12533222,0xDFD0F2D2,0xE1E090F1,0xF1EEDFE0,0x2F402133,\n        0x23203F60,0x01C0E131,0x21021231,0x0760F2E1,0x27362F24,0x04C23227,0x24320222,0xE507C603,\n        0x07C1CED1,0x024206D7,0xA0D305E2,0x023202F2,0x310615F1,0x124E2102,0xE7D0E3F2,0x0707B605,\n        0xF607B1F3,0xE2D0F233,0xF7053031,0xC1E4C7D7,0xF0C40412,0xFECFFEEE,0x2F0B3E3C,0x0EDEE0FF,\n        0x0BD0E1C1,0x0FEEA9EB,0x0DEE0D2E,0xDECF1EFF,0xE1DFF2F0,0xC0EFFEE0,0xAEFECFFD,0x5F7F7FDD,\n        0x42246351,0x1F413344,0x0C4EDBCF,0xFFE1E0AA,0xFF0D3EF9,0x9B9A0B09,0x02D2F2CC,0x32C30211,\n        0x90D10110,0xFEE0E191,0xFEC1D0DF,0x707070EF,0xA0CE2F20,0x9C9C9DBF,0xAC2F0EDD,0xC2D0CDCF,\n        0xEDEF90C1,0x31201EFE,0x300E2F70,0xDD0E2E31,0x2F322F0F,0xFE0FDFCC,0x32C102E1,0xDECCD0E4,\n        0xD1A2D2E0,0x9EE2EFC0,0xDB9C9E9D,0xE0EFFCCC,0xFFDFD0E1,0x32401F0E,0xAC0E2F30,0xA2C293CF,\n        0x9BCD9091,0x1E600FEF,0xB0EF6C7D,0xC0B1E19F,0x90D1C3D3,0x2EFF91D1,0x306F6E6C,0x41705D4F,\n        0x7F7F703F,0x50502EBC,0x5F5E4F3E,0xEE0DEDFF,0x9DFEDED0,0xDFFEADEE,0xB0AF90F1,0x5E0FBDBE,\n        0x406E5F6F,0x7F7F7F3F,0x5D0EEE50,0xFC6D5D30,0x5D29FB1F,0x6B0DEE1F,0xFF0F2E7E,0xD193C1EF,\n        0xA0E10111,0xB1226304,0xD0B3E3D1,0xFECE9DAD,0xDFEE0DD0,0xEDCCFDDE,0x5D0FDE0E,0x6E11207F,\n        0x3E4E304E,0x4F3E7F30,0xB10E5D7E,0x90939192,0x9491C2D1,0xC2B0D293,0x02252622,0x9E9E9FD0,\n        0x9C9B9D9E,0xAF9ECDBF,0xF19190C1,0xBFC09190,0xACCECCCE,0xBB9FB092,0xCF9D9FC0,0x1DECBC9C,\n        0x0FFF0EEC,0x7E515F3D,0x7F707E7D,0x2F7E7E7F,0x73715170,0x7E413F7F,0x3F7D7D7F,0x4E707141,\n        0x0B1F7E0A,0x0D2DFEB9,0x4D7B0ECC,0x4E5D5F6D,0x423F604E,0x503F5071,0x6252502F,0x12424261,\n        0x43737074,0xE1013142,0x17076607,0xE1DFD323,0xC201DFC0,0xB7C1E304,0x02337012,0x2203C7C5,\n        0x4203F103,0x2F702171,0x3E0DDE0F,0x2E0EEF0F,0x705E3EFF,0x0EDE0E3F,0xDFDEC0B3,0x7D5F3E0F,\n        0x4E3C4D7F,0xFE3F0F2F,0xD1E1E2C0,0xD3E1F2E2,0x0E1FFFE1,0xCEE0D1F0,0xFFD0FF0F,0xF212204B,\n        0x3F400211,0x5E4D2D4D,0x0DBC0F3E,0xD0DF0F1E,0xB0CEDDEE,0xFFFACECE,0xFF0F4E0E,0x203F302E,\n        0x335F7041,0x42F5F205,0x204B6E60,0x01300422,0x211044F2,0x34314312,0x23606F14,0xD3910111,\n        0x01F1F3E0,0x6034E237,0x2C41C462,0x0B1F2621,0x4F413F1D,0x21432341,0xD0DC0E1F,0xB0CDEDDE,\n        0x9FBCE0C3,0x5CDF0DDF,0x0E207D20,0x6E3E0DBC,0x21661070,0x63115303,0x23202F54,0x053431F2,\n        0xE513F437,0x03E204D1,0xDFD1D5C7,0x1C1CFDFE,0x01E3C1D0,0xE302202F,0x13212F12,0x0D3F0E2F,\n        0x13E1DCEE,0x13F2D122,0xAFEFFE21,0x3111E1A0,0x3231303F,0xE1B1E11F,0xF2313001,0x2EFE2F20,\n        0x312123FE,0xDEDFEF30,0x512130EF,0x02421032,0xE1F1D1E1,0x21012301,0x1322201D,0xEFFFEFD1,\n        0xF2C301D3,0x0AEED0D1,0xFD0C2E2D,0x3F1DFEEE,0x0EEFE0E3,0xD3D0E2CD,0x0121E1D0,0xB2EF0DC1,\n        0xFEEEA0E1,0x2F0F3E1E,0x3E313140,0x303F4E20,0x2344422F,0xF1DEEC0F,0x0DFD3234,0x2112F3F0\n    );\n    \n    //Shape data\n    //Bit layout:31--Index--20,19--YPos--10,9--XPos--0\n    //Defines the vertex index and absolute location of each shape's 1st point.\n    const int shapes[] = int[SHAPE_COUNT](\n        0x00094D65,0x02997D57,0x037A4137,0x048A0CB5,0x04EA00BA,0x0539A0BB,0x0582F2C0,0x0713A2CE,\n        0x08A34292,0x09639E9F,0x0FE2B9F4,0x10625117,0x10A290E7,0x1114F5CC,0x12B7381A,0x1305E4A1,\n        0x135770B4,0x146724BF,0x14B73CC9,0x159724D6,0x15E78CBE,0x16288967,0x1668BD75,0x17283D94,\n        0x17783DA9,0x17DB358C,0x1A0B35C8,0x1A7B49DD,0x1B1B3DE3,0x1B7B3DEB,0x1BCA89DA,0x1D3A7DC8,\n        0x1D8B2E30,0x1E6B2237,0x1EE79662,0x1F5AE689,0x201AE295,0x20AA9EE0,0x210A16F1,0x2150C400,\n        0x3734DADB,0x3774CAD8,0x37C4F2C0,0x380496BC,0x38754EB3,0x38B55AB4,0x38F562AD,0x393592A7,\n        0x3985AAA3,0x3A255E6D,0x3A957276,0x3AE58E7C,0x3B35BE72,0x3B95BA6D,0x3BE60E6F,0x3C75D284,\n        0x3EF5525D,0x3F456261,0x3F95625B,0x3FF5C244,0x40368E5B,0x4076A65D,0x40B60668,0x42763E53,\n        0x4406920B,0x44864A2A,0x46F6926A,0x47B72660,0x49B8EA8C,0x4C39F8DA,0x4C7A14BF,0x4CCA78BE,\n        0x4D09784C,0x4D697405,0x4DA9E005,0x4E19C022,0x4E7B0872,0x4EBB187A,0x4F3B2C93,0x4F7B208A,\n        0x503AE087,0x508AF488,0x514AC895,0x524AF87D,0x543B0486,0x5489D504,0x5A6ADD3A,0x5AA1C8ED,\n        0x5AF8A0CE,0x7D3B54E1,0x81EB04A4,0x8249B588,0x828A41B9,0xB5C904B0,0xB698ECAE,0xB758E8B2,\n        0xB8196243,0xB898AD9D,0xBB08FDCE,0xBD48B8BB,0xBDA8CCC2\n    );\n    \n    //Output vectors (hi-byte = shape index, lo-byte = 8-bit vector\n    if(i < VECT_COUNT) \n    {\n        int bytevec = (vects[i/4] >> ((i%4)*8));\n        int shpidx = 0;\n        for(int j = 0;j < SHAPE_COUNT;j++)\n        {\n            if(i >= ((shapes[j]>>20)&0xFFF))\n            {\n                shpidx = j;\n            }\n            else\n            {\n                break;\n            }\n        }\n        \n        vecdata = ((shpidx&0xFF) << 8) | (bytevec&0xFF);\n    }\n    else\n    {\n        i -= VECT_COUNT;\n        \n        //Output shape origins (X/Y)\n        //1 component per-pixel since only the alpha channel is free.\n        if(i < SHAPE_COUNT*2)\n        {\n            vecdata = (shapes[i/2] >> 10*(i%2))&0x3FF;\n        }\n        else //Output 0s for every other address.\n        {\n            vecdata = 0;\n        }\n    } \n    \n    return vec4(1e6, 0, 0, vecdata);\n}\n\n//Get 8-bit vector 'i' from alpha channel\n//and unpack into a vec2 (X,Y) and shape index (Z).\nvec3 GetVector(int i)\n{\n        int v = int(texelFetch(iChannel0, IdxToUV(i, ivec2(0), ivec2(iResolution.xy)), 0).a);\n        \n        int vx = bool(v&0x08) ? -((~v+1)&0x0F) : v&0x0F;\n        v = v >> 4;\n        int vy = bool(v&0x08) ? -((~v+1)&0x0F) : v&0x0F;\n        v = v >> 4;\n        \n        return vec3(vec2(vx, vy) / MAX_EXTENT, v&0xFF);\n}\n\n//Get the absolute location of the 1st of shape 'i'.\nvec2 GetShapeOrigin(int i)\n{\n    i = VECT_COUNT+i*2;\n    ivec2 iRes = ivec2(iResolution.xy);\n    return vec2(\n        texelFetch(iChannel0, IdxToUV(i  , ivec2(0), iRes), 0).a,\n        texelFetch(iChannel0, IdxToUV(i+1, ivec2(0), iRes), 0).a\n    ) / MAX_EXTENT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    \n    //Initialize vector data on 1st frame, stored in alpha channel.\n    if(iFrame == 0) \n    {\n        fragColor = Initialize(ivec2(fragCoord));\n    }\n    //Create SDF from the vector data.\n    else if(iFrame <= (VECT_COUNT/VECS_PER_FRAME+1))\n    {\n        int vidx = (iFrame-1)*VECS_PER_FRAME;\n        vec2 p = fragCoord / iResolution.xy;\n        vec2 p0 = fragColor.yz; \n        float sdf = fragColor.x;\n        \n        for(int i = 0;i < VECS_PER_FRAME;i++)\n        {\n            if(vidx >= VECT_COUNT) { break; } //Stop if loop goes past the last vector.\n            \n            vec3 curvec = GetVector(vidx);\n            vec3 prevec = GetVector(vidx-1);\n            \n            //Get the abs. position for the 1st point.\n            //If the shape index changes, set p0 to the abs. position of the new shape.\n            if(vidx == 0 || curvec.z != prevec.z)\n            {\n                p0 = GetShapeOrigin(int(curvec.z));\n            }\n\n            vec2 p1 = p0 + curvec.xy;\n\n            //Line drawing\n            vec2 line = p1 - p0;\n            float frac = dot(p - p0,line) / dot(line,line);\n            vec2 pnear = (p0 + line * clamp(frac, 0.0, 1.0)) - p;\n            pnear.x = mod(pnear.x+0.5,1.0)-0.5; //Make SDF tile horizontally.\n            float dline = length(pnear * ASPECT);\n            sdf = min(abs(sdf), dline) * sign(sdf); //Combine with SDF (ignoring sign)\n            \n            //N-Gon filling for sign\n            if(p.y >= min(p0.y,p1.y) && p.y < max(p0.y,p1.y)) //If p.y is between the highest & lowest point.\n            {\n                if(p.x > mix(p0.x, p1.x, (p.y-p0.y)/(p1.y-p0.y))) //If p.x is to the left of the line.\n                {\n                    sdf = -sdf; //Flip the sign\n                }\n            }\n            \n            \n            p0 = p1;\n            vidx++;\n        }\n\n        fragColor.xyz = vec3(sdf, p0); \n        \n        //Clear y/z/w channels, put resolution into y,z for re-scaling.\n        if(vidx >= VECT_COUNT)\n        {\n            fragColor = vec4(fragColor.x,iResolution.xy,0);\n        }\n    }\n    else\n    {\n        //Re-scale texture when going full-screen (doesn't work when exiting full screen).\n        vec2 preres = texelFetch(iChannel0,ivec2(0),0).yz;\n        \n        if(preres.xy != iResolution.xy)\n        {\n            vec2 uv = (fragCoord / iResolution.xy) * (preres.xy/iResolution.xy); \n            fragColor.x = texture(iChannel0,uv,0.).x;\n            fragColor.yz = iResolution.xy;\n        }\n    }\n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}