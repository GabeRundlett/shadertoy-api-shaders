{
    "Shader": {
        "info": {
            "date": "1727316129",
            "description": "When night falls",
            "flags": 32,
            "hasliked": 0,
            "id": "lXBcWW",
            "likes": 5,
            "name": "Obscura Spherus",
            "published": 3,
            "tags": [
                "3d",
                "dark"
            ],
            "usePreview": 0,
            "username": "space928",
            "viewed": 72
        },
        "renderpass": [
            {
                "code": "/////////////\n// Post FX //\n/////////////\n\n#define rnd_off(o) (((hash23(vec3(fragCoord.x, fragCoord.y, fract(iTime*animateDither)))*2.-1.)+(hash23(vec3(fragCoord.x, fragCoord.y, fract(iTime*animateDither)+0.5798765))*2.-1.0))/iResolution.xy*pow(2.,o)*bloomNoise)\n\n//https://www.shadertoy.com/view/WdjSW3\nvec3 Tonemap_Uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, x);\n    vec3 w2 = step(m + l0, x);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(x / m, vec3(c)) + b;\n    vec3 S = P - (P - S1) * exp(CP * (x - S0));\n    vec3 L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    #if ENABLE_POST_PROC\n    // Bloom based on mipmaps\n    vec3 bloom = vec3(0.);\n    bloom += textureLod(iChannel0, uv+rnd_off(1.), 1.).rgb*0.9;\n    bloom += textureLod(iChannel0, uv+rnd_off(2.), 2.).rgb*0.9;\n    bloom += textureLod(iChannel0, uv+rnd_off(3.), 3.).rgb*1.0;\n    bloom += textureLod(iChannel0, uv+rnd_off(4.), 4.).rgb*1.5;\n    bloom += textureLod(iChannel0, uv+rnd_off(5.), 5.).rgb*2.;\n    bloom += textureLod(iChannel0, uv+rnd_off(6.), 6.).rgb*2.5;\n    bloom += textureLod(iChannel0, uv+rnd_off(7.), 7.).rgb*4.0;\n    col += tanh(pow(bloom*0.5, vec3(2.)))*bloomStrength;\n    \n    col = Tonemap_Uchimura(col, tonemap_P, tonemap_a, tonemap_m, tonemap_l, tonemap_c, tonemap_b);\n    col += vec3(0.01, 0., 0.02);\n    \n    // Vignette inspired by: https://www.shadertoy.com/view/lsKSWR\n    vec2 u = uv*(1.-uv.yx);\n    float vignette = 1.-(1.-saturate(tanh(u.x*u.y*25.+0.05)*1.2))*vignetteStrength;\n    col = sqrt(vignette*col*col);\n    \n    // Dither at the end\n    float dither = (hash12(fragCoord+fract(iTime*animateDither*0.733)) + hash12(fragCoord + 0.59374+fract(iTime*animateDither*0.733)) - 0.5)/255.;\n    col += dither;\n    #endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////\n// Scene Map //\n///////////////\n#define rnd_pos(i,t) (vec3(sin(t*hash11(i)+hash11(i*5.9237+3.9842)), sin(t*hash11(i*3.8465+9855.)+hash11(i*52.9237+378.9842)), sin(t*hash11(i*84.28+6.)+hash11(i*599.9237+32.9842))))\n\nray map(vec3 p)\n{\n    vec3 s = vec3(4.);\n    vec3 q = p - s*round(p/s);\n    \n    float t = iTime;\n    float spheres = sdf_sphere(p, 0.5);\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(0. , t)*.3 - vec3(.6, -.3, -.5), 0.35));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(1. , t)*.3 - vec3(-.6, -.3, -.5), 0.25));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(2. , t)*.3 - vec3(.6, .3, -.5), 0.15));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(3. , t)*.3 - vec3(.3, .3, .5), 0.4));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(4. , t)*.3 - vec3(.6, -.3, .8), 0.05));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(5. , t)*.3 - vec3(-.3, -.75, -.3), 0.25));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(6. , t)*.3 - vec3(-.6, .8, -.2), 0.15));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(7. , t)*.3 - vec3(-.2, .78, -.5), 0.3));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(8. , t)*.3 - vec3(-.6, .5, .5), 0.05));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(9. , t)*.3 - vec3(.2, -.6, .2), 0.05));\n    spheres = min(spheres, sdf_sphere(p + rnd_pos(10., t)*.3 - vec3(.3, -.57, .4), 0.05));\n    \n    vec3 windDir = vec3(-.3, .5, 1.)*2.5;\n    for (float i = 0.; i < 25.; i += 1.)\n    {\n        float tp = fract((t+i)*.1358);\n        spheres = min(spheres, sdf_sphere(p + rnd_pos(i, t)*(.3+tp) + (tp+tp*tp)*windDir, .08*(1.-abs(tp*2.-1.))));\n    }\n    \n    ray r = ray(spheres, 0.);\n    //r = sdf_union(ray(sdf_gyroid(p, 0.), 1.), r);\n    \n    // Floor\n    //r = sdf_union(ray(sdf_box(p-vec3(0.,-1.,0.), vec3(10., .1, 10.)), 2.), r);\n    float cdist = pow(length(p.xz), 2.)*.005;\n    //float waves = sin(dot(p.xz, vec2(1, 3.1279)))*sin(dot(p.xz, vec2(-.8, .3489)))*sin(dot(p.xz, vec2(1.679, -.0149)))*min(cdist*.1, 0.5);\n    vec2 sd = vec2(2., sqrt(3.) * 2.) * .5;\n    vec2 s1 = (fract(p.xz/sd)-.5)*sd;\n    vec2 s2 = (fract(p.xz/sd+.5)-.5)*sd;//p.xz-round(p.xz);\n    vec2 sid = round(p.xz/sd)*sd;\n    vec2 sr = p.xz-round(p.xz);\n    float wh = sin(t+hash12(round(p.xz))*3.14)*.3+.5;\n    //float wh = sin(t+hash12(sid)*3.14)*.5+.5;\n    float waves = sqrt(wh+.5-dot(sr, sr))*1.2;\n    //float waves = sqrt(wh+.5-min(dot(s1, s1), dot(s2, s2)))*1.5;\n    r = sdf_union(ray(p.y+1.-cdist-waves+2.5, 2.), r);\n    \n    return r;\n}\n\n/////////////////\n// Raymarching //\n/////////////////\nvec3 computeNrm(vec3 p)\n{\n    return normalize(vec3(\n        map(p + vec3(GRADIENT_DELTA, 0, 0)).d - map(p - vec3(GRADIENT_DELTA, 0, 0)).d,\n        map(p + vec3(0, GRADIENT_DELTA, 0)).d - map(p - vec3(0, GRADIENT_DELTA, 0)).d,\n        map(p + vec3(0, 0, GRADIENT_DELTA)).d - map(p - vec3(0, 0, GRADIENT_DELTA)).d));\n}\n\nvoid raymarch(vec3 ray_start, vec3 ray_dir, out float dist, out vec3 p, out int iterations, out float mat) {\n    dist = 0.0;\n    p = ray_start;\n    float minStep = 0.01;\n    mat = -1.;\n\tray mapRes;\n    for (int i = 1; i <= MAX_RAYMARCH_ITER; i++) {\n        p = ray_start + ray_dir * dist;\n        mapRes = map(p);\n        mat = mapRes.mat;\n        if (dist > MAX_DISTANCE) {\n            iterations = i;\n            mat = -1.;\n            return;\n        }\n        if (mapRes.d < MIN_RAYMARCH_DELTA) {\n           iterations = i;\n           return;\n        }\n        dist += max(mapRes.d*STEP_DISTANCE_FACTOR, minStep);\n    }\n    return;\n}\n\nvoid camera(vec2 uv, float t, out vec3 pos, out vec3 dir) {\n    //mat3 rot = rotY((t-10.)*rotRate);\n    mat3 rot = rotY((sin(t*rotRate)*.1+.5));\n    dir = normalize(vec3(uv, 2.0)+vec3(0.,.4,0.))*rot;\n    //pos = cameraPos*rotY((t-10.)*rotRate) + (t*posTime);\n    pos = cameraPos*rot + (t*posTime);\n}\n\nvec4 computeAlbdeoRough(float mat, vec3 p, vec3 camDir) {\n    vec4 albedo = vec4(0.);\n    if(mat == -1.) {\n        // Sky\n        albedo = vec4(mix(vec3(.5,.6,.7), vec3(.3,.4,.8), abs(camDir.y)), 0.);\n    } else if (mat < .5) {\n        // Gyroid\n        albedo = vec4(vec3(.9, .1, .1), 0.5);\n    } else if (mat < 1.5) {\n        // Spheres\n        albedo = vec4(vec3(.5), 0.5);\n    } else if (mat < 2.5) {\n        // Walls\n        albedo = vec4(vec3(.1), 0.5);\n    } else if (mat < 3.5) {\n        albedo = vec4(vec3(.5), 0.5);\n    }\n    return albedo;\n}\n\nvec3 shadeLights(float d, vec3 p, vec3 nrm, float mat, vec3 camDir)\n{\n    vec4 albr = computeAlbdeoRough(mat, p, camDir);\n    vec3 alb = albr.rgb;\n    float rough = albr.a;\n    \n    if (nrm == vec3(0.))\n        return alb;\n\n    vec3 col = vec3(0.);\n    for (int i = 0; i < lights.length(); i++) \n    {\n        light l = lights[i];\n        if (l.directional) \n        {\n            vec3 ldir = l.dir;\n            float ndotl = dot(nrm, ldir);\n            //float shad = shadow(rayPos + ldir*.01, ldir);\n            float f = pow(clamp(1.-dot(nrm, -camDir), 0., .9), 3.) * (ndotl*.5+.5);\n            float x = pow(saturate(smoothstep(0.5, 0.85, ndotl*.5+.65))+f*.15, 10.) + f;\n            col += alb.rgb * x * l.col * 3.;\n            //col += alb.rgb * (ndotl*.5+.5) * l.col;\n        } \n        else \n        {\n            /*vec3 delta = p-l.pos;\n            vec3 ldir = normalize(delta);\n            float atten = 1./(dot(delta, delta)+1.);\n            atten *= clamp(smoothstep(l.innerAngle, l.outerAngle, dot(ldir, l.dir)*.5+.5), 0., 1.);\n            float ndotl = dot(nrm, ldir);\n            //float shad = shadow(rayPos + ldir*.01, ldir);\n            col += alb.rgb * (ndotl*.5+.5) * l.col * atten;*/\n        }\n    }\n    return clamp(col, 0., 3.);\n}\n\nvec3 applyFog(vec3 c, float d)\n{\n    return mix(vec3(.02, .03, .05), c, min(1./(d*d*fogDensity+1.), smoothstep(1., .9, d / MAX_DISTANCE)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 cam_uv = uv * 2.0 - 1.0;\n    cam_uv.x *= iResolution.x / iResolution.y;\n    vec3 camPos;\n    vec3 camDir;\n    camera(cam_uv, iTime, camPos, camDir);\n    \n    float d;\n    vec3 rayPos;\n    int iters;\n    float mat;\n    raymarch(camPos, camDir, d, rayPos, iters, mat);\n    vec3 nrm = computeNrm(rayPos);\n    \n    vec3 col = shadeLights(d, rayPos, nrm, mat, camDir);\n    col = applyFog(col, d);\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/////////////\n// Defines //\n/////////////\n//// Raymarcher\n#define GRADIENT_DELTA 1e-4\n#define MAX_RAYMARCH_ITER 128\n#define MIN_RAYMARCH_DELTA 1e-3\n#define MAX_DISTANCE 64.\n#define STEP_DISTANCE_FACTOR .8\n//// Scene\nconst vec3 cameraPos = vec3(0.,-1.3,-6.5);\nconst vec3 posTime = vec3(0.);\nconst float rotRate = .5;\nconst float fogDensity = 0.03;\n/*#define LIGHTS ( \\\n    light(normalize(vec3(.5,1.,.5)), vec3(0.), vec3(.5), 0., 0., true), \\\n    light(normalize(vec3(1.,0.,0.)), vec3(0.), vec3(10.), 0.95, .96, false) \\\n)*/\n#define LIGHTS ( \\\n    light(normalize(vec3(-1.,.3,0.9)), vec3(0.), vec3(1.), 0., 0., true) \\\n)\n\n//// Post processing\n#define ENABLE_POST_PROC 1\n// Reduces blinear interpolation artifacts, and I think it looks nice\nconst float bloomNoise = 0.1;\n// Set to 1. if you want animated noise.\nconst float animateDither = 1.;\nconst float bloomStrength = .2;\nconst float vignetteStrength = .9;\nconst float tonemap_P = 1.1;  // max display brightness\nconst float tonemap_a = 1.5;  // contrast\nconst float tonemap_m = 0.22; // linear section start\nconst float tonemap_l = 0.6;  // linear section length\nconst float tonemap_c = 1.33; // black\nconst float tonemap_b = 0.03;  // pedestal\n\n//////////////////\n// Data structs //\n//////////////////\nstruct ray {\n    float d;\n    float mat;\n};\n\nstruct light {\n    vec3 dir;\n    vec3 pos;\n    vec3 col;\n    float innerAngle;\n    float outerAngle;\n    bool directional;\n};\n\nconst light[] lights = light[]LIGHTS;\n\n///////////////\n// Utilities //\n///////////////\n#define saturate(x) clamp(x, 0., 1.)\n// Hash functions taken from:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4 * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat3 rotY(float x)\n{\n    return mat3(cos(x), 0., sin(x),\n                0., 1., 0.,\n                -sin(x), 0., cos(x));\n}\n\n///////////////////\n// SDF Functions //\n///////////////////\nfloat sdf_box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdf_roundedCylinder(vec3 p, float ra, float rb, float h)\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdf_sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdf_gyroid(vec3 p, float r)\n{\n    vec3 c = cos(p);\n    vec3 s = sin(p*.57987);\n    return dot(c, s)+.9;\n}\n\nfloat sdf_ellipsoid(vec3 p, vec3 r) \n{\n    return (length(p / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdf_capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat sdf_torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdf_triPrism(vec3 p, vec2 h) {\n    vec3 q = abs(p);\n    return max(q.y-h.y,max(q.x*0.866025+p.z*0.5,-p.z)-h.x*0.5);\n}\n\nray sdf_union(ray a, ray b)\n{\n    return ray(min(a.d, b.d), mix(b.mat, a.mat, step(a.d, b.d)));\n}\n\nray sdf_intersect(ray a, ray b)\n{\n    return ray(max(a.d, b.d), mix(a.mat, b.mat, step(b.d, a.d)));\n}\n\nray sdf_subtract(ray a, ray b)\n{\n    return ray(max(a.d, -b.d), mix(a.mat, b.mat, step(-b.d, a.d)));\n}\n\nray sdf_smin(ray a, ray b, float k) \n{\n\tfloat h = clamp(0.5 + 0.5 * (b.d - a.d) / k, 0., 1.);\n\treturn ray(mix(b.d, a.d, h) - k * h * (1. - h), mix(a.mat, b.mat, h));\n}\n\nray sdf_smax(ray a, ray b, float k) \n{\n\tfloat h = clamp( 0.5 + 0.5 * (b.d - a.d) / k, 0.0, 1.0 );\n\treturn ray(mix(b.d, a.d, h) + k * h * (1. - h), mix(a.mat, b.mat, h));\n}\n\nfloat sdf_union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat sdf_intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat sdf_subtract(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat sdf_smin(float a, float b, float k) \n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdf_smax(float a, float b, float k) \n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "///////////////////////\n// Post FX - Digital //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvC = uv * 2. - 1.;\n    \n    #if ENABLE_POST_PROC\n    //float smoothRnd = sin(uv.x*12.+uv.y*13.+iTime)*cos(uv.y*7.-uv.x*3.667-iTime*.6+1.8)*cos(-uv.y*2.578+uv.x*1.789+22.8-iTime*.2)*.5+.5;\n    \n    vec2 rndF = hash22(vec2(iFrame&17616, iFrame&104));\n    vec2 rnd = hash23(vec3(uv*6791., iFrame));\n    vec2 rndX = hash22(vec2(uv.y*7867., iFrame));\n    //uv.x = mod(uv.x*uv.x, 0.1)/uv.x;\n    //ivec2 iuv = ivec2(uv*64.);\n    //uv = fract(vec2(iuv)/64.);\n    vec2 hDist = vec2((rndX.x*2.-1.)*mix(.003, .05, pow(length(uvC), 3.)), 0.);\n    vec2 uvPxl = trunc((uv+hDist)*16.) * (1./16.);//+rnd*.01;\n    //float rndPxl = hash12(vec2(uvPxl.x, uvPxl.y)*100.+0.*vec2(iFrame&17616));\n    //if (rndPxl < (sin(iTime * .5)+1.)*.3)\n    //    uv = -uv + hDist;\n    if (uv.y >= rndF.x && uv.y < rndF.y)\n        uv.x += 0.0+rndX.x*.005+rnd.x*0.005;\n    //if (rndF.y >\n    uv.y += trunc(rndF.y*3.-rndX.x*5.)/iResolution.y;\n    \n    float abb = step(rndX.y, 0.3);\n    float r = texture(iChannel0, uv).r;\n    float g = texture(iChannel0, uv+hDist*abb).g;\n    float b = texture(iChannel0, uv-hDist*abb).b;\n    float l = fract((uvPxl.x + uvPxl.y*1123.)*0.17398)*0.1;\n    if (l > rndF.x && l < rndF.y)\n        g = -b;\n    \n    fragColor = vec4(r, g, b, 1.);\n    #else\n    fragColor = texture(iChannel0, uv);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}