{
    "Shader": {
        "info": {
            "date": "1457182799",
            "description": "Inspired by one of the wallpaper types generated by the Android app \"Tapet\". Could do with a better palette generation algorithm to avoid so many ugly combos. Loads of inefficiency, esp. the AA, but there's only so many new wallpapers you need per second.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsK3Wt",
            "likes": 6,
            "name": "Geometric wallpaper",
            "published": 3,
            "tags": [
                "2d",
                "wallpaper"
            ],
            "usePreview": 0,
            "username": "Edward",
            "viewed": 961
        },
        "renderpass": [
            {
                "code": "// License: http://unlicense.org/\n\n#define VIGNETTE\n#define DITHER\n#define ROTATE\n#define ANTIALIAS 8\n#define FRAME_CALC int(iTime)\n#define GRID_MIN 20.\n#define GRID_MAX 200.\n#define GRID_SEED 1237.\n#define COLOUR_MIN 2.\n#define COLOUR_MAX 6.\n#define COLOUR_SEED 2356.\n#define ORIENTATION_SEED 3456.\n\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float hash(vec2 co) {\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n// http://glslsandbox.com/e#18922.0\nvec2 rotate(vec2 p, float a) {\n    return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nvec4 calcValue(in vec2 fragCoord) {\n    vec4 fragColor;\n    int frame = FRAME_CALC;\n    float gridSize = floor((GRID_MAX - GRID_MIN + 1.) * hash(vec2(frame, GRID_SEED)) + GRID_MIN); \n    float numColours = floor((COLOUR_MAX - COLOUR_MIN + 1.) * hash(vec2(frame, COLOUR_SEED)) + COLOUR_MIN);\n    vec2 square = floor(fragCoord / gridSize); \n    int orientation = int(2. * hash(square + ORIENTATION_SEED + float(frame)));\n    vec2 innerCoord = mod(fragCoord, gridSize);\n    if(orientation == 1) {innerCoord.y = gridSize - innerCoord.y;}\n    vec2 triangle = square * vec2(1.,2.);\n    if(innerCoord.x > innerCoord.y) {triangle.y += 1.;}\n    float colorIndex = floor(hash(triangle + COLOUR_SEED) * numColours);\n    fragColor.r = hash(vec2(colorIndex + COLOUR_SEED, frame));\n    fragColor.g = hash(vec2(colorIndex + COLOUR_SEED, frame + 1000));\n    fragColor.b = hash(vec2(colorIndex + COLOUR_SEED, frame + 2000));\n    fragColor.a = 1.;\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 coord = fragCoord;\n    \n    #ifdef ROTATE\n        coord = rotate(coord, float(FRAME_CALC) + .5);\n    #endif\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    \n    for(int i = 0; i < ANTIALIAS; i++) {\n        for(int j = 0; j < ANTIALIAS; j++) {\n            fragColor += calcValue(coord + vec2(float(i) / float(ANTIALIAS), float(j) / float(ANTIALIAS)));\n        }\n    }\n    \n    fragColor /= float(ANTIALIAS*ANTIALIAS);\n\n    #ifdef VIGNETTE\n    \tfloat vignette = 1. - .85 * length(iResolution.xy / 2. - fragCoord) / length(iResolution.xy / 2.);\n    \tfragColor.rgb *= pow(vignette,.4);\n    #endif\n\n    #ifdef DITHER\n        float ditherOffset = mod(mod(fragCoord.x,2.)+mod(fragCoord.y,2.)*2.+2.,4.)/4.-.375;\n        vec3 scaledColour = fragColor.xyz * 256.;\n        fragColor.xyz = floor(scaledColour+ditherOffset)/(vec3(255));\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}