{
    "Shader": {
        "info": {
            "date": "1690909581",
            "description": "Gravity simulation. Press 'r' to reset and 't' to switch views. Four colored gravity points attract particles with initial position of the pixel. Change common file for different behaviour. Check http://y2u.be/3jJ51bj1jTM which this was inspired by.",
            "flags": 48,
            "hasliked": 0,
            "id": "DtsczS",
            "likes": 1,
            "name": "Gravity's Fractal Spectrum",
            "published": 3,
            "tags": [
                "simulation",
                "fractals",
                "physics",
                "particle",
                "gravity"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Convert to pixel coordinates\n    vec2 pixel = fragCoord;\n    vec3 color = vec3(0.0); // Initialize as black\n\n    // Check if 't' or 'T' key is pressed\n    bool keyT = texelFetch(iChannel1, ivec2(KEY_T, 0), 0).x > 0.5;\n\n    // Fetch the particle data from Buffer A\n    vec4 bufferAColor = texelFetch(iChannel0, ivec2(pixel), 0);\n    vec2 position = bufferAColor.rg;\n\n    if(keyT) {\n        for(int i = 0; i < 4; i++) {\n            vec2 gpPos = gravityPoints[i].position;\n            vec3 gpColor = gravityPoints[i].color;\n\n            float distance = length(pixel - gpPos);\n            if(distance < RADIUS) {\n                color = gpColor;\n                break;\n            }\n        }\n\n        for(int i = 0; i < numRenderIndices; i++) {\n            ivec2 renderIndex = renderIndices[i];\n            vec4 bufferAColor = texelFetch(iChannel0, renderIndex, 0);\n            vec2 position = bufferAColor.rg;\n\n            if(distance(position, pixel) < 1.0) {\n                color = vec3(1.0); // Render as white\n                break;\n            }\n        }\n    } else {\n        vec3 totalColor = vec3(0.0);\n        float totalWeight = 0.0;\n        for(int i = 0; i < 4; i++) {\n            vec2 gpPos = gravityPoints[i].position;\n            vec3 gpColor = gravityPoints[i].color;\n            float distance = length(position - gpPos);\n            float weight = 1.0 / (distance + 1.0);\n            totalColor += weight * gpColor;\n            totalWeight += weight;\n        }\n        color = totalColor / totalWeight; // Calculate weighted average\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Get integer position from fragCoord\n    ivec2 pixel = ivec2(fragCoord);\n\n    vec4 previousColor;\n\n    // Check if 'r' or 'R' key is pressed\n    bool keyR = texelFetch(iChannel1, ivec2(KEY_R, 0), 0).x > 0.5;\n\n    if (keyR || iFrame == 0) {\n        previousColor = vec4(fragCoord.x, fragCoord.y, initVel.x, initVel.y);\n    } else {\n        // Read the previous frame's color\n        previousColor = texelFetch(iChannel0, pixel, 0);\n    }\n\n    // Get the position and velocity from the color\n    vec2 position = previousColor.rg;\n    vec2 velocity = previousColor.ba;\n\n    // Calculate total acceleration\n    vec2 totalAcceleration = vec2(0.0);\n    for(int i = 0; i < 4; i++) {\n        vec2 direction = gravityPoints[i].position - position;\n        float distance = length(direction);\n        if(distance >= RADIUS) {\n            vec2 normalizedDirection = direction / distance;\n            vec2 acceleration = G * normalizedDirection / (distance * distance);\n            totalAcceleration += acceleration;\n        } else {\n            velocity = vec2(0.0);  // Velocity set to 0 if within RADIUS\n            totalAcceleration = vec2(0,0);\n            break;\n        }\n    }\n\n    // Calculate the time variable 't'\n    float t = 1.0 / (length(totalAcceleration)*1000. + 0.01);\n    if(t < 1.0) {\n        t = 1.0;\n    }\n\n    // Half-acceleration application\n    velocity += 0.5 * totalAcceleration * t;\n\n    // Position update\n    position += velocity * t;\n\n    // Second half-acceleration application\n    velocity += 0.5 * totalAcceleration * t;\n    \n    // Friction\n    velocity = velocity * pow(1. - friction, t);\n\n    fragColor = vec4(position, velocity);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n/*\nThis ShaderToy project demonstrates a particle simulation\nunder the influence of gravitational forces from four point\nsources. Each point has its own gravitational field and is\nrepresented by a distinct color. When you start the\nsimulation, each particle begins with an initial velocity\nwhich can be modified through the 'common file'. The initial\nposition of each particle is the pixel position. Over time\nas the particle moves, the origial pixel is showing the\ncolor of the nearest gravity point.\nSee:\nhttps://www.youtube.com/watch?v=3jJ51bj1jTM&ab_channel=prossello\nFor a better understanding of how this works. This\nsimulation was mostly inspired by this video.\n\n\nTo interact with the simulation:\n\n    Press the 'R' key to reset the simulation. When reset,\n    each particle will be set back to its original position\n    with the initial velocity.\n    \n    Press and hold the 'T' key to toggle between different\n    visualization modes. One mode renders the gravity points\n    and specific particles as colored discs, while the other\n    mode colors the particles based on a weighted average of\n    the colors of the nearest gravity points.\n\nCustomizing the simulation:\n\nIn the 'common file', several constants and structures allow\nyou to customize the simulation to your needs.\n\n    'G': The gravitational constant. Higher values will\n        result in stronger gravitational forces.\n    'friction': Determines how much the particles slow down\n        over time. A value of 0.0 means no friction, while a\n        value of 1.0 means maximum friction.\n    'initVel': The initial velocity of the particles when\n        the simulation is reset. You can experiment with\n        different values to see how they affect the\n        particles' motion.\n    'GravityPoint': A structure that defines the position\n        and color of a gravity point. The simulation\n        currently includes four gravity points, but you can\n        add or remove gravity points as needed.\n\nThe code for this project was largely written with the help\nof ChatGPT.\n\nThe simulation is optimized by making the particle move in\na faster pace when they are far from a gravitational\npoint. This is why their motion may seem somewhat uneven.\n\n*/\n\n\nconst float G = 1.0;  // Gravitational constant, change as needed\nconst float friction = 0.0; // 0.0 is no friction, 1. is total friction\nconst vec2 initVel = vec2(0.05, 0.02); // Initial velocity of the particles\n\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\nconst float RADIUS = 5.0;\n\nstruct GravityPoint {\n    vec2 position;\n    vec3 color;\n};\n\nGravityPoint gravityPoints[4] = GravityPoint[](\n    GravityPoint(vec2(220.0, 120.0), RED),\n    GravityPoint(vec2(380.0, 120.0), GREEN),\n    GravityPoint(vec2(220.0, 280.0), BLUE),\n    GravityPoint(vec2(380.0, 280.0), YELLOW)\n);\n\nconst int off = 0;\nconst int numRenderIndices = 6;\nivec2 renderIndices[numRenderIndices] = ivec2[](\n    ivec2(571, 175+0),\n    ivec2(571, 175+1),\n    ivec2(571, 175+2),\n    ivec2(571, 175+3),\n    ivec2(571, 175+4),\n    ivec2(571, 175+5)\n);\n\n// Input.\nconst int KEY_R  = 82;\nconst int KEY_T  = 84; // Added definition for 'T' key\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}