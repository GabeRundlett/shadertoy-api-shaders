{
    "Shader": {
        "info": {
            "date": "1504119877",
            "description": "Minor improvements on \nhttps://www.shadertoy.com/view/MsXGDj\nsimple cubic interpolating splines, Hermite, or special cases of Hermite.\nsmoothstep, or the cos() that is close to smoothstep.\n\nchose a more constrained function, for performance over quality\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Xtscz7",
            "likes": 19,
            "name": "Curve fitting 2",
            "published": 3,
            "tags": [
                "noise",
                "spline",
                "smoothstep",
                "cubic",
                "fract",
                "hash",
                "catmullrom",
                "catmull",
                "hermite",
                "crom"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1931
        },
        "renderpass": [
            {
                "code": "//2d spline cubic hermite curve fitting 2 mod()\n\n//default zoom level of the whole view\n#define ViewZoom 1.5\n//scale.y of the spline\n#define scaleY 4.\n\n//modify zoom with mouse.x\n//#define ZoomByX\n//modify offset by mouse.y\n//#define OffsetByY\n\n/*\nFitting a curve trough points = control_vectors \n... is a lazy and user friendly way to define curves=splines.\nTo interpolate between 2 given vectors, giving +2 further away vectors (\n... to have enough parameters for a cubic function.\nFor flexibility, spline functions are n-dimensional #define's\n\nBEWARE that you may need to add extra round brackets; ();\n... Due to how #define's copy paste labels, \n... instead of substituting parameters of higher degree functions,\n... which often messes up orders of operations, unless you explicitly add enough \"()\"\n\nThis is for performance over quality:\ntherefore you chose a more specialized function, \n... which likely does not look as good as a (slower) more general function \n... that would allow more tweaking.\nfor performance and simplicity, this adds the constrain that .x are of even distance\n...meant for fract() tesselation/tiling.\n\nfor performance, only cubic Hermite splines and single cosines are used. \nfor performance, splines are uniform, \n... non uniform splines are \"weighted\", which adds a loop that averages a sum.\nfor performance, splines are not rationalized, \n... rationalized splines (can) recursively blend with neighbors to get smoother.\neg [NURBS] = [Non-Uniform-Rational(ized)-Basis-Spline] could do more, but would be slower.\n*/\n\n//#define Use_Linear\n//#define Use_Cosine\n//#define Use_Smoothstep\n//#define Use_Hermite\n//#define Use_Catmull_Rom\n//#define Use_Cubic\n\n// The functions use the following iterpolation format to interpolate y=f(x)\n\n// a----b-x--c----d\n// Where 'x' is the fractional diff betweeen b and c.\n// a.x,b.x,c.x,d.x  are evenly spaced via fract(), and .y is set by a hash.\n//this constrain makes sense to tesselate terrain.\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n//hash11 fast mediocre, better for mobile gpu.\nfloat h11(float p){vec3 f=fract(vec3(p)*.1031);f+=dot(f,f.yzx+19.19);\n return fract((f.x+f.y)*f.z);}\n//disadvantages: diagonal patterns, bad derivatives.\n//advantages: good performance, even distribution. (for better distribution, include phi) \n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\n#define dd(a) dot(a,a)\n#define u2(a) (a*2.-1.)\n#define u5(a) (a*.5+.5)\n//seesaw wave\n#define ss2t(a) a=abs(fract(a)*2.-1.)\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n#define sat(a) clamp(a,0.,1.)\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//return distance of [u] from segment, from [a] to [b]\nv0 segment(v1 p,v1 a,v1 b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n#define grid(u) mav(abs(u2(fract(u))))\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n#define  fsaa 2./min(iResolution.x,iResolution.y)\nv3 rg(vec4 c){\n return mix(fract(c*4.),smoothstep(fsaa,-fsaa,c),.5+(atan(c))/acos(-1.));}\n\n\n//float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}//doesnt look too good.\n#define Linear(x,a,b) a*(x*(b/a-1.)+1.)\n//float Cosine(float x, float a, float b){return (b-a)*(1.-cos(x*acos(-1.)))*.5 + a;}\n#define Cosine(x,a,b) ((b-a)*(1.-cos(x*acos(-1.)))*.5 + a)\n//float Smoothstep(float x, float a, float b){return (b-a)*x*x*(3.-2.*x)+a;}\n#define Smoothstep(x,a,b) ((b-a)*x*x*(3.-2.*x)+a)\n//lower lipschitz == less likely spheretracking overestimation.\n//most general, smoothest most excessive, most zigzag, lowest lipschitz\n#define HermiteD(x,a,b,e,f) (b+.5*x*(e+b-a+x*(a-b+e+x*3.*(e*3.+f+x*5./3.*(-e*3.-f+x*.4*(e*3.+f))))))\n#define Hermite(x,a,b,c,d) HermiteD(x,a,b,(c-b),(a-d))\n//special case of Hermite(), with a smooth .5 average. medium zigzag\n#define Catmull_Rom(x,a,b,c,d) ((((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b)\n//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n#define Cubic(x,a,b,c,d) ((((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b)\n//Cosine() is smoother than Cubic()\n\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 u =fra(U),m=fra(iMouse.xy);  \n \n #ifdef ZoomByX\n u*=m.x;m*=m.x;//mouse.x zooms in\n #endif\n u.y+=.5;\n\n float p=(iTime*.5+u.x)*scaleY,\n x=fract(p);p=floor(p);\n float a=h11(p),\n       b=h11(p+1.),\n       c=h11(p+2.),\n       d=h11(p+3.);//theese 4 could be vec4, using hash44\n vec4 r=vec4(0);\n\t\n    /*\n#ifdef Use_Linear\n\tf = Linear(x, b, c);\n#elif defined Use_Cosine\n\tf = Cosine(x, b, c);//has more good derivatives than smoothstep()\n#elif defined Use_Smoothstep\n\tf = Smoothstep(x, b, c);\n#elif defined Use_Cubic\n    f =  Cubic(x, a, b, c, d);\n#elif defined Use_Catmull_Rom\n\tf = Catmull_Rom(x, a, b, c, d);\n#elif defined Use_Hermite\n\tf = Hermite(x, a, b, c, d);\n#endif\n*/\n //above is a buffet of function to apply to 4 colors .rgba below,.a<-yellow\n r.g=Catmull_Rom(x,a,b,c,d);//special case of ThirdOrderSpline(), with a smooth .5 average. medium zigzag\n r.a=Cubic(x,a,b,c,d);//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n r.b=Cosine(x,b,c);//smoothest derivatives, most sizzag\n r.r=Hermite(x,a,b,c,d);//slowest, most general,smoothest, high zigzags, lowest lipschitz\n //r.b=Linear(x,b,c);\n    \n r-=u.y;//display distance.y, no fancy differential estimation here.\n \n #ifdef OffsetByY\n r+=vec4(-1.5,-.5,.5,1.5)*(m.y-1.);//offset.y\n #endif\n    \n //to overwrite all with one\n //r=vec4(r.a);\n \n //to set some to 0;\n //r.r=0.;  \n //r.g=0.; \n //r.b=0.; \n //r.a=0.;\n    \n r*=.1;//scaling the distance field here makes it more elegant, less cognitive load.\n \n r=1.-rg(r);//turn into distance field visualisation negative distace is brighter\n    //this visualization mixes fract(r) with smoothstep(r) by atan(r)/acos(-1.)\n    \n r.rg=mix(r.rg,r.aa,.5);//mix yellow into .gr\n \n //add some dots as markers. they are visible by inverting colors on their inside\n //f is distance to control vectors (split in 2, within mod())\n float f=dd((vec2(x   ,(u.y-b)*scaleY)));\n f=min(f,dd((vec2(x-1.,(u.y-c)*scaleY))));\n //f=sqrt(f);//skippable, squared distance is just fine, scales dorse though\n f=smoothstep(fsaa,-fsaa,f-.005);\n //f=fract(f);//to defug f.\n r=mix(r,1.-r,f);//invert colors inside a Dot\n O=vec4(r.xyz,1);}\n/*\n\n//--------------------------------------------------------------------------------\n//in memoriam, refference backup from https://www.shadertoy.com/view/MsXGDj\n/*\nfloat Cubic(float x, float a,float b, float c,float d) \n{\n\tfloat p =d-c-a+b;\n\treturn p*(x*x*x)\n        +(a-b-p)*(x*x)\n        +(c-a)*x\n        +b;\n}*/\n/*\n//return distance.y of [x], where a,b,c,d are the .y values to control points.\n//a,b,c,d are evenly spaced, using fract(), usually a hash.\nfloat Cubic(float x, float a,float b, float c,float d){\n\treturn (((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b;\n}//2nd derivative is smooth, 3rd derivatuce sucks, such is the life of cubics.\n*/\n\n//--------------------------------------------------------------------------------\n/*float Catmull_Rom(float x, float a,float b, float c,float d){\n    //vec3 v=vec3(c-a,2.*(a+c+c)-d-5.*b,(d-a+3.*(b-c)));\n\t//return ((v.z*x+v.y)*x+v.x)*.5*x+b;\n\treturn (((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b;\n//\tOr, the same result with...\n//\tfloat x2 = x  * x;\n//\tfloat x3 = x2 * x;\n//\treturn 0.5 * ( ( 2.0 * v1) + (-v0 + v2) * x +\n//                  (2.0 * v0 - 5.0 *v1 + 4.0 * v2 - v3) * x2 +\n//                  (-v0 + 3.0*v1 - 3.0 *v2 + v3) * x3);\n}\n/**/\n\n//--------------------------------------------------------------------------------\n\n/*\nfloat ThirdOrderSpline(float x, float a,float b, float c,float d){\n float cb=c-b; //c=cb+b\n float ad=a-d;\n return (b+.5*x*(cb+b-a+x*(a-b+cb+x*3.*(cb*3.+ad+x*5./3.*(-cb*3.-ad+x*.4*(cb*3.+ad))))));\n}*/\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}