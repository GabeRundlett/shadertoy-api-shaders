{
    "Shader": {
        "info": {
            "date": "1690102161",
            "description": "nice",
            "flags": 96,
            "hasliked": 0,
            "id": "dsjBWG",
            "likes": 1,
            "name": "SWS3005_15",
            "published": 3,
            "tags": [
                "1"
            ],
            "usePreview": 0,
            "username": "HU_YINGXUAN",
            "viewed": 160
        },
        "renderpass": [
            {
                "code": "const float music_length=120.0;\nconst float blur_turn = 13.0;\nconst float fading_turn=14.0;\nconst float first_turn=16.0;\nconst float end_turn=20.0;\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Add the original image to the blurred image to get the final image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float t = mod(iTime, music_length);\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n    \n    //The range of this pix fit the OriginalImageTex's size,\n    //Use the texel coordinate of gl_fragcoord and texelFetch can imporve the accuracy\n    vec4 origin = texture(iChannel0,uv);\n    \n    //The size of the blurred threshold image is smaller,\n    //Use the texCoord and texture() to sample the corresponding value;\n    vec4 color = texture(iChannel1,uv);\n    \n     fragColor = origin + color;\n    if(t>blur_turn && t<fading_turn){    \n        fragColor =origin + color*100.0*((t-blur_turn)/(fading_turn-blur_turn)) ;\n    }\n    if(t>fading_turn && t<first_turn){    \n        fragColor = (origin + color*100.0)*(1.0-(t-fading_turn)/(fading_turn-blur_turn)) ;\n    }\n    if(t> first_turn && t<end_turn){    \n        fragColor = (origin + color)*((t-first_turn)/(end_turn-first_turn)) ;\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 8;\nconst int NUM_MATERIALS = 31;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 39;\n\nconst float music_length=120.0;\nconst int max_inflate=16;\nconst float delay=1.3;\nconst float first_turn=16.5;\nconst float second_turn=91.0;\nconst float stop_point=10.0; \nconst float lowest = -9.0;\nconst float highest = 50.0;\n\nconst float Rpow = 1.3;//radius parameter\nconst float tStep = 4.0;//period for spheres emergement && height\nconst float rs =  10.0;//radius divede speed\nconst float AS = 4.0;//speed for angles\nconst float tBegin = -80.0;//time for pyramid\nconst float IP = 6.0;//initialized posotion\nconst float ys = 8.0;//y speed divided\nconst float boost = 5.0;//time for boost\nconst float boostpara =12.0;//boost parameter\nconst float radius_con=1.0;\n\n\n\n// 生成0~1伪随机数\nfloat random(float x)\n{\n    return fract(sin(x) * 43758.5453123);\n}\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\n\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nPlane_t Plane[NUM_PLANES];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length);\n   // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    \n    // Material[1].k_d = vec3( 0.3, 0.2, 0.5 );\n    Material[1].k_d = vec3( 0.8, 0.6, 0.2 );\n    Material[1].k_a = 0.5 * Material[1].k_d;\n    Material[1].k_r = 3.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    \n    \n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    //粉球\n    Material[3].k_d = vec3( 0.8, 0.7, 0.6 );\n    Material[3].k_a = 0.5 * Material[3].k_d;\n    Material[3].k_r = 1.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n    \n    //蓝球\n    Material[4].k_d = vec3( 0.2, 0.1, 1.0 );\n    Material[4].k_a = 0.5 * Material[4].k_d;\n    Material[4].k_r = 1.0 * Material[4].k_d;\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 64.0;\n    \n    //红金球\n    Material[5].k_d = vec3( 0.7, 0.4, 0.2 );\n    Material[5].k_a = 0.5 * Material[5].k_d;\n    Material[5].k_r = 2.0 * Material[5].k_d;\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 64.0;\n    \n    //绿色球\n    Material[6].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[6].k_a = 0.5 * Material[6].k_d;\n    Material[6].k_r = 1.0 * Material[6].k_d;\n    Material[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].n = 64.0;\n    \n    //绿色球(黄色，渲染后）\n    Material[7].k_d = vec3( 0.2, 0.8, 0.2 );\n    Material[7].k_a = 0.5 * Material[7].k_d;\n    Material[7].k_r = 3.0 * Material[7].k_d;\n    Material[7].k_rg = 0.5 * Material[7].k_r;\n    Material[7].n = 64.0;\n    \n\n    // mercury\n    Material[8].k_d = vec3( 0.8, 0.6, 0.2 );\n    Material[8].k_a = 0.5 * Material[8].k_d;\n    Material[8].k_r = 3.0 * Material[8].k_d;\n    Material[8].k_rg = 0.5 * Material[8].k_r;\n    Material[8].n = 64.0;\n    \n    //venus\n    Material[9].k_d = vec3( 0.3, 0.7, 0.8 );\n    Material[9].k_a = 0.5 * Material[9].k_d;\n    Material[9].k_r = 1.0 * Material[9].k_d;\n    Material[9].k_rg = 0.5 * Material[9].k_r;\n    Material[9].n = 64.0;\n  \n    //earth\n    Material[10].k_d = vec3( 0.5, 0.1, 1.0 );\n    Material[10].k_a = 0.5 * Material[10].k_d;\n    Material[10].k_r = 0.2 * Material[10].k_d;\n    Material[10].k_rg = 0.5 * Material[10].k_r;\n    Material[10].n = 64.0;\n    \n    //mars\n    Material[11].k_d = vec3( 0.8, 0.7, 0.2 );\n    Material[11].k_a = 0.5 * Material[11].k_d;\n    Material[11].k_r = 0.3 * Material[11].k_d;\n    Material[11].k_rg = 0.5 * Material[11].k_r;\n    Material[11].n = 64.0;\n    \n    // jupitor\n    Material[12].k_d = vec3(0.7, 0.4, 0.1);\n    //Material[12].k_a =vec3(0.6, 0.4, 0.0);\n    Material[12].k_a =0.5 * Material[12].k_d;\n    //Material[12].k_r = vec3(0.5, 0.5, 0.5 );\n    Material[12].k_r =0.3 * Material[12].k_d;\n    Material[12].k_rg = 1.0 * Material[12].k_r;\n    Material[12].n = 0.078125;\n    \n    // saturn\n    Material[13].k_d = vec3(1.0, 0.3, 0.1);\n    Material[13].k_a =0.5*Material[13].k_d;\n    Material[13].k_r = vec3(1.0, 0.4, 0.1 );\n    Material[13].k_rg = 0.3 * Material[13].k_r;\n    Material[13].n = 0.078125;\n    \n    //uranus\n    Material[14].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[14].k_a = 0.2 * Material[2].k_d;\n    Material[14].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[14].k_rg = 0.5 * Material[2].k_r;\n    Material[14].n = 128.0;\n    \n    // neptune(紫色）\n    Material[15].k_d = vec3( 0.6, 0.2, 0.7 );\n    Material[15].k_a = 0.3 * Material[15].k_d;\n    Material[15].k_r = 0.5 * Material[15].k_d;\n    Material[15].k_rg = 0.5 * Material[15].k_r;\n    Material[15].n = 0.07;\n    \n    // Silver material.\n    Material[16].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[16].k_a = 0.01 * Material[16].k_d;\n    Material[16].k_r = 2.0 * Material[16].k_d;\n    Material[16].k_rg = 1.0 * Material[16].k_r;\n    Material[16].n = 64.0;\n    \n    \n    // 奇点球材质.\n    Material[17].k_d = vec3( 0.6, 0.6, 0.2 );\n    Material[17].k_a = 0.5 * Material[16].k_d;\n    Material[17].k_r = 20.0 * Material[16].k_d;\n    Material[17].k_rg = 5.0 * Material[16].k_r;\n    Material[17].n = 64.0;\n    \n    //term2 专属\n    \n    // neptune(紫色）\n    Material[18].k_d = vec3( 0.6, 0.2, 0.7 );\n    Material[18].k_a = 0.3 * Material[18].k_d;\n    Material[18].k_r = 0.5 * Material[18].k_d;\n    Material[18].k_rg = 0.5 * Material[18].k_r;\n    Material[18].n = 64.0;\n    \n    //uranus(蓝色)\n    Material[19].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[19].k_a = 0.5 * Material[19].k_d;\n    Material[19].k_r = 0.5 * Material[19].k_d;\n    Material[19].k_rg = 0.5 * Material[19].k_r;\n    Material[19].n = 128.0;\n    \n    // saturn\n    Material[20].k_d = vec3(1.0, 0.3, 0.1);\n    Material[20].k_a = 0.5 * Material[19].k_d;\n    Material[20].k_r = 0.5 * Material[19].k_d;\n    Material[20].k_rg = 0.5 * Material[19].k_d;\n    Material[20].n = 64.0;\n    \n    //红金球\n    Material[21].k_d = vec3( 0.7, 0.4, 0.2 );\n    Material[21].k_a = 0.5 * Material[21].k_d;\n    Material[21].k_r = 0.5 * Material[21].k_d;\n    Material[21].k_rg = 0.5 * Material[21].k_r;\n    Material[21].n = 64.0;\n    \n    //粉球\n    Material[22].k_d = vec3( 0.8, 0.7, 0.6 );\n    Material[22].k_a = 0.5 * Material[22].k_d;\n    Material[22].k_r = 0.5 * Material[22].k_d;\n    Material[22].k_rg = 0.5 * Material[22].k_r;\n    Material[22].n = 64.0;\n    \n    //绿色球(黄色，渲染后）\n    Material[23].k_d = vec3( 0.2, 0.8, 0.2 );\n    Material[23].k_a = 0.5 * Material[23].k_d;\n    Material[23].k_r = 0.5 * Material[23].k_d;\n    Material[23].k_rg = 0.5 * Material[23].k_r;\n    Material[23].n = 64.0;\n    \n    // mercury\n    Material[24].k_d = vec3( 0.8, 0.6, 0.2 );\n    Material[24].k_a = 0.5 * Material[24].k_d;\n    Material[24].k_r = 0.5 * Material[24].k_d;\n    Material[24].k_rg = 0.5 * Material[24].k_r;\n    Material[24].n = 64.0;\n    \n    //venus\n    Material[25].k_d = vec3( 0.3, 0.7, 0.8 );\n    Material[25].k_a = 0.5 * Material[25].k_d;\n    Material[25].k_r = 0.5 * Material[25].k_d;\n    Material[25].k_rg = 0.5 * Material[25].k_r;\n    Material[25].n = 64.0;\n    \n    //earth\n    Material[26].k_d = vec3( 0.5, 0.1, 1.0 );\n    Material[26].k_a = 0.5 * Material[10].k_d;\n    Material[26].k_r = 0.5 * Material[10].k_d;\n    Material[26].k_rg = 0.5 * Material[10].k_r;\n    Material[26].n = 64.0;\n    \n    //x\n    Material[27].k_d = vec3( 0.7, 0.3, 0.5 );\n    Material[27].k_a = 0.5 * Material[27].k_d;\n    Material[27].k_r = 0.5 * Material[27].k_d;\n    Material[27].k_rg = 0.5 * Material[27].k_r;\n    Material[27].n = 64.0;\n    \n    //y\n    Material[28].k_d = vec3( 0.2, 0.6, 1.0 );\n    Material[28].k_a = 0.5 * Material[10].k_d;\n    Material[28].k_r = 0.5 * Material[10].k_d;\n    Material[28].k_rg = 0.5 * Material[10].k_r;\n    Material[28].n = 64.0;\n    \n    //z\n    Material[29].k_d = vec3( 0.7, 0.7, 0.5 );\n    Material[29].k_a = 0.5 * Material[29].k_d;\n    Material[29].k_r = 0.5 * Material[29].k_d;\n    Material[29].k_rg = 0.5 * Material[29].k_r;\n    Material[29].n = 64.0;\n    \n    //x\n    Material[30].k_d = vec3( 0.8, 0.1, 0.3 );\n    Material[30].k_a = 0.5 * Material[30].k_d;\n    Material[30].k_r = 0.5 * Material[30].k_d;\n    Material[30].k_rg = 0.5 * Material[30].k_r;\n    Material[30].n = 64.0;\n    \n    \n    \n    \n    \n    //First step\n    if(t<=first_turn){\n    // Light 0.\n    Light[0].position = vec3( 6.0, 4.0, -3.0 );\n    Light[0].I_a = vec3( 0.0, 0.0, 0.8 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n    // Light 1.\n    Light[1].position = vec3( -6.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.0, 0.0, 0.8);\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n    \n    // 奇点\n    Sphere[0].center = vec3( 0.0,0.0, 0.0 );\n    Sphere[0].radius = max(0.1,(t+delay)/2.0*abs(sin(120.0 / 60.0 * PI * iTime)));\n    Sphere[0].materialID = 17;\n\n    \n    }\n        \n        if(t > first_turn && t<=second_turn){\n         // Light 2.\n          Light[2].position = vec3( 30.0, 0.0, 5.0 );\n        Light[2].I_a = vec3( 1.0, 1.0, 1.0 );\n        Light[2].I_source = vec3( 1.0, 1.0, 1.0 );\n\n        // Light 3.\n        Light[3].position = vec3( 28.0,0.0, 3.0 );\n        Light[3].I_a = vec3( 1.0, 1.0, 1.0);\n        Light[3].I_source = vec3( 1.0, 1.0, 1.0 );\n\n            //左上侧镜面\n //           Plane[1].A = 1.0;\n //           Plane[1].B = 1.0;\n //           Plane[1].C = 1.0;\n //           Plane[1].D = 42.0;\n //           Plane[1].materialID = 16;\n            //右上侧镜面\n //           Plane[2].A = -1.0;\n //           Plane[2].B = 1.0;\n //           Plane[2].C = 1.0;\n  //          Plane[2].D = 42.0;\n  //          Plane[2].materialID = 16;\n            //右下角镜面\n //           Plane[3].A = -1.0;\n  //          Plane[3].B = 1.0;\n    //        Plane[3].C = -1.0;\n     //       Plane[3].D = 42.0;\n       //     Plane[3].materialID = 16;\n            //左下角镜面\n         //   Plane[3].A = 1.0;\n           // Plane[3].B = 1.0;\n           // Plane[3].C = -1.0;\n           // Plane[3].D = 42.0;\n           // Plane[3].materialID = 16;\n        \n        \n        \n        float height= highest-(highest-lowest)*(t-first_turn)/(second_turn-first_turn);\n        if( t <(first_turn +boost) ){\n            float BOOST = (-(t-first_turn)*(t-first_turn)+2.0*boost*(t-first_turn))/boostpara;//Symmetry axis to be 5 after first_turn && distance to be 25*5/parameter\n            \n            \n            Sphere[0].center = vec3( 0.0,height, 0.0 );\n            Sphere[0].radius = 6.0;\n            Sphere[0].materialID = 1;\n\n            //mercary\n            Sphere[1].center = vec3( pow(Rpow,(t-tBegin-7.0*tStep)/rs) * cos(AS*(t-tBegin-7.0*tStep)) , IP-(t-tBegin-7.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-7.0*tStep)/rs) * sin(AS*(t-tBegin-7.0*tStep)) );\n            Sphere[1].center = Sphere[1].center + Sphere[0].center ;\n            Sphere[1].radius = 0.5+radius_con;\n            Sphere[1].materialID = 18;\n\n            //venus\n            Sphere[2].center = vec3( pow(Rpow,(t-tBegin-6.0*tStep)/rs) * cos(AS*(t-tBegin-6.0*tStep)) , IP-(t-tBegin-6.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-6.0*tStep)/rs) * sin(AS*(t-tBegin-6.0*tStep)) );\n            Sphere[2].center = Sphere[2].center + Sphere[0].center ;\n            Sphere[2].radius = 0.7+radius_con;\n            Sphere[2].materialID = 19;\n\n            //earth\n            Sphere[3].center = vec3( pow(Rpow,(t-tBegin-5.0*tStep)/rs) * cos(AS*(t-tBegin-5.0*tStep)) , IP-(t-tBegin-5.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-5.0*tStep)/rs) * sin(AS*(t-tBegin-5.0*tStep)) );\n            Sphere[3].center = Sphere[3].center + Sphere[0].center ;\n            Sphere[3].radius = 1.0+radius_con;\n            Sphere[3].materialID = 20;\n\n            //mars\n            Sphere[4].center = vec3( pow(Rpow,(t-tBegin-4.0*tStep)/rs) * cos(AS*(t-tBegin-4.0*tStep)) , IP-(t-tBegin-4.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-4.0*tStep)/rs) * sin(AS*(t-tBegin-4.0*tStep)) );\n            Sphere[4].center = Sphere[4].center + Sphere[0].center ;\n            Sphere[4].radius = 0.7+radius_con;\n            Sphere[4].materialID = 21;\n\n            //jupiter\n            Sphere[5].center = vec3( pow(Rpow,(t-tBegin-3.0*tStep)/rs) * cos(AS*(t-tBegin-3.0*tStep)) , IP-(t-tBegin-3.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-3.0*tStep)/rs) * sin(AS*(t-tBegin-3.0*tStep)) );\n            Sphere[5].center = Sphere[5].center + Sphere[0].center ;\n            Sphere[5].radius =2.0+radius_con;\n            Sphere[5].materialID = 22;\n\n            //saturn\n            Sphere[6].center = vec3( pow(Rpow,(t-tBegin-2.0*tStep)/rs) * cos(AS*(t-tBegin-2.0*tStep)) , IP-(t-tBegin-2.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-2.0*tStep)/rs) * sin(AS*(t-tBegin-2.0*tStep)) );\n            Sphere[6].center = Sphere[6].center + Sphere[0].center ;\n            Sphere[6].radius = 1.7+radius_con;\n            Sphere[6].materialID = 23;\n\n            //uranus\n\n            Sphere[7].center = vec3( pow(Rpow,(t-tBegin-1.0*tStep)/rs) * cos(AS*(t-tBegin-1.0*tStep)) , IP-(t-tBegin-1.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-1.0*tStep)/rs) * sin(AS*(t-tBegin-1.0*tStep)) );\n            Sphere[7].center = Sphere[7].center + Sphere[0].center ;\n            Sphere[7].radius = 1.3+radius_con;\n            Sphere[7].materialID = 24;\n\n            //neptune\n\n            Sphere[8].center = vec3( pow(Rpow,(t-tBegin-0.0*tStep)/rs) * cos(AS*(t-tBegin-0.0*tStep)) , IP-(t-tBegin-0.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-0.0*tStep)/rs) * sin(AS*(t-tBegin-0.0*tStep)) );\n            Sphere[8].center = Sphere[8].center + Sphere[0].center ;\n            Sphere[8].radius =1.5+radius_con;\n            Sphere[8].materialID = 25;\n\n            ////mercary\n            Sphere[11].center = vec3( pow(Rpow,(t-tBegin-8.0*tStep)/rs) * cos(AS*(t-tBegin-8.0*tStep)) , IP-(t-tBegin-8.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-8.0*tStep)/rs) * sin(AS*(t-tBegin-8.0*tStep)) );\n            Sphere[11].center = Sphere[11].center + Sphere[0].center ;\n            Sphere[11].radius = 0.5+radius_con;\n            Sphere[11].materialID = 26;\n\n            //venus\n            Sphere[12].center = vec3( pow(Rpow,(t-tBegin-9.0*tStep)/rs) * cos(AS*(t-tBegin-9.0*tStep)) , IP-(t-tBegin-9.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-9.0*tStep)/rs) * sin(AS*(t-tBegin-9.0*tStep)) );\n            Sphere[12].center = Sphere[12].center + Sphere[0].center ;\n            Sphere[12].radius = 0.7+radius_con;\n            Sphere[12].materialID = 27;\n\n            //earth\n            Sphere[13].center = vec3( pow(Rpow,(t-tBegin-10.0*tStep)/rs) * cos(AS*(t-tBegin-10.0*tStep)) , IP-(t-tBegin-10.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-10.0*tStep)/rs) * sin(AS*(t-tBegin-10.0*tStep)) );\n            Sphere[13].center = Sphere[13].center + Sphere[0].center ;\n            Sphere[13].radius = 1.0+radius_con;\n            Sphere[13].materialID = 28;\n\n            //mars\n            Sphere[14].center = vec3( pow(Rpow,(t-tBegin-11.0*tStep)/rs) * cos(AS*(t-tBegin-11.0*tStep)) , IP-(t-tBegin-11.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-11.0*tStep)/rs) * sin(AS*(t-tBegin-11.0*tStep)) );\n            Sphere[14].center = Sphere[14].center + Sphere[0].center ;\n            Sphere[14].radius = 0.7+radius_con;\n            Sphere[14].materialID = 29;\n\n            //jupiter\n            Sphere[15].center = vec3( pow(Rpow,(t-tBegin-12.0*tStep)/rs) * cos(AS*(t-tBegin-12.0*tStep)) , IP-(t-tBegin-12.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-12.0*tStep)/rs) * sin(AS*(t-tBegin-12.0*tStep)) );\n            Sphere[15].center = Sphere[15].center + Sphere[0].center ;\n            Sphere[15].radius =2.0+radius_con;\n            Sphere[15].materialID = 30;\n\n            //saturn\n            Sphere[16].center = vec3( pow(Rpow,(t-tBegin-13.0*tStep)/rs) * cos(AS*(t-tBegin-13.0*tStep)) ,IP-(t-tBegin-13.0*tStep)/ys - BOOST*(t-first_turn), pow(Rpow,(t-tBegin-13.0*tStep)/rs) * sin(AS*(t-tBegin-13.0*tStep)) );\n            Sphere[16].center = Sphere[16].center + Sphere[0].center ;\n            Sphere[16].radius = 1.7;\n            Sphere[16].materialID = 25;\n\n        }\n        else{\n            //70s to\n            // sun\n            Sphere[0].center = vec3( 0.0,height, 0.0 );\n            Sphere[0].radius = 6.0;\n            Sphere[0].materialID = 1;\n\n            //mercary\n            Sphere[1].center = vec3( pow(Rpow,(t-tBegin-7.0*tStep)/rs) * cos(AS*(t-tBegin-7.0*tStep)) , IP-(t-tBegin-7.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-7.0*tStep)/rs) * sin(AS*(t-tBegin-7.0*tStep)) );\n            Sphere[1].center = Sphere[1].center + Sphere[0].center ;\n            Sphere[1].radius = 0.5+radius_con;\n            Sphere[1].materialID = 18;\n\n            //venus\n            Sphere[2].center = vec3( pow(Rpow,(t-tBegin-6.0*tStep)/rs) * cos(AS*(t-tBegin-6.0*tStep)) , IP-(t-tBegin-6.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-6.0*tStep)/rs) * sin(AS*(t-tBegin-6.0*tStep)) );\n            Sphere[2].center = Sphere[2].center + Sphere[0].center ;\n            Sphere[2].radius = 0.7+radius_con;\n            Sphere[2].materialID = 19;\n\n            //earth\n            Sphere[3].center = vec3( pow(Rpow,(t-tBegin-5.0*tStep)/rs) * cos(AS*(t-tBegin-5.0*tStep)) , IP-(t-tBegin-5.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-5.0*tStep)/rs) * sin(AS*(t-tBegin-5.0*tStep)) );\n            Sphere[3].center = Sphere[3].center + Sphere[0].center ;\n            Sphere[3].radius = 1.0+radius_con;\n            Sphere[3].materialID = 20;\n\n            //mars\n            Sphere[4].center = vec3( pow(Rpow,(t-tBegin-4.0*tStep)/rs) * cos(AS*(t-tBegin-4.0*tStep)) , IP-(t-tBegin-4.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-4.0*tStep)/rs) * sin(AS*(t-tBegin-4.0*tStep)) );\n            Sphere[4].center = Sphere[4].center + Sphere[0].center ;\n            Sphere[4].radius = 0.7+radius_con;\n            Sphere[4].materialID = 21;\n\n            //jupiter\n            Sphere[5].center = vec3( pow(Rpow,(t-tBegin-3.0*tStep)/rs) * cos(AS*(t-tBegin-3.0*tStep)) , IP-(t-tBegin-3.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-3.0*tStep)/rs) * sin(AS*(t-tBegin-3.0*tStep)) );\n            Sphere[5].center = Sphere[5].center + Sphere[0].center ;\n            Sphere[5].radius =2.0+radius_con;\n            Sphere[5].materialID = 22;\n\n            //saturn\n            Sphere[6].center = vec3( pow(Rpow,(t-tBegin-2.0*tStep)/rs) * cos(AS*(t-tBegin-2.0*tStep)) , IP-(t-tBegin-2.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-2.0*tStep)/rs) * sin(AS*(t-tBegin-2.0*tStep)) );\n            Sphere[6].center = Sphere[6].center + Sphere[0].center ;\n            Sphere[6].radius = 1.7+radius_con;\n            Sphere[6].materialID = 23;\n\n            //uranus\n\n            Sphere[7].center = vec3( pow(Rpow,(t-tBegin-1.0*tStep)/rs) * cos(AS*(t-tBegin-1.0*tStep)) , IP-(t-tBegin-1.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-1.0*tStep)/rs) * sin(AS*(t-tBegin-1.0*tStep)) );\n            Sphere[7].center = Sphere[7].center + Sphere[0].center ;\n            Sphere[7].radius = 1.3+radius_con;\n            Sphere[7].materialID = 24;\n\n            //neptune\n\n            Sphere[8].center = vec3( pow(Rpow,(t-tBegin-0.0*tStep)/rs) * cos(AS*(t-tBegin-0.0*tStep)) , IP-(t-tBegin-0.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-0.0*tStep)/rs) * sin(AS*(t-tBegin-0.0*tStep)) );\n            Sphere[8].center = Sphere[8].center + Sphere[0].center ;\n            Sphere[8].radius =1.5+radius_con;\n            Sphere[8].materialID = 25;\n\n            ////mercary\n            Sphere[11].center = vec3( pow(Rpow,(t-tBegin-8.0*tStep)/rs) * cos(AS*(t-tBegin-8.0*tStep)) , IP-(t-tBegin-8.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-8.0*tStep)/rs) * sin(AS*(t-tBegin-8.0*tStep)) );\n            Sphere[11].center = Sphere[11].center + Sphere[0].center ;\n            Sphere[11].radius = 0.5+radius_con;\n            Sphere[11].materialID = 26;\n\n            //venus\n            Sphere[12].center = vec3( pow(Rpow,(t-tBegin-9.0*tStep)/rs) * cos(AS*(t-tBegin-9.0*tStep)) ,IP-(t-tBegin-9.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-9.0*tStep)/rs) * sin(AS*(t-tBegin-9.0*tStep)) );\n            Sphere[12].center = Sphere[12].center + Sphere[0].center ;\n            Sphere[12].radius = 0.7+radius_con;\n            Sphere[12].materialID = 27;\n\n            //earth\n            Sphere[13].center = vec3( pow(Rpow,(t-tBegin-10.0*tStep)/rs) * cos(AS*(t-tBegin-10.0*tStep)) , IP-(t-tBegin-10.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-10.0*tStep)/rs) * sin(AS*(t-tBegin-10.0*tStep)) );\n            Sphere[13].center = Sphere[13].center + Sphere[0].center ;\n            Sphere[13].radius = 1.0+radius_con;\n            Sphere[13].materialID = 28;\n\n            //mars\n            Sphere[14].center = vec3( pow(Rpow,(t-tBegin-11.0*tStep)/rs) * cos(AS*(t-tBegin-11.0*tStep)) , IP-(t-tBegin-11.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-11.0*tStep)/rs) * sin(AS*(t-tBegin-11.0*tStep)) );\n            Sphere[14].center = Sphere[14].center + Sphere[0].center ;\n            Sphere[14].radius = 0.7+radius_con;\n            Sphere[14].materialID = 29;\n\n            //jupiter\n            Sphere[15].center = vec3( pow(Rpow,(t-tBegin-12.0*tStep)/rs) * cos(AS*(t-tBegin-12.0*tStep)) , IP-(t-tBegin-12.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-12.0*tStep)/rs) * sin(AS*(t-tBegin-12.0*tStep)) );\n            Sphere[15].center = Sphere[15].center + Sphere[0].center ;\n            Sphere[15].radius =2.0+radius_con;\n            Sphere[15].materialID = 30;\n\n            //saturn\n            Sphere[16].center = vec3( pow(Rpow,(t-tBegin-13.0*tStep)/rs) * cos(AS*(t-tBegin-13.0*tStep)) , IP-(t-tBegin-13.0*tStep)/ys - boost*boost*boost/boostpara, pow(Rpow,(t-tBegin-13.0*tStep)/rs) * sin(AS*(t-tBegin-13.0*tStep)) );\n            Sphere[16].center = Sphere[16].center + Sphere[0].center ;\n            Sphere[16].radius = 1.7+radius_con;\n            Sphere[16].materialID = 18;\n            // Circling sphere.\n            //Sphere[1].center = vec3( 3.0+1.5 * cos(iTime), -0.3, 1.5 * sin(iTime) );\n            //Sphere[1].radius = 0.5;\n            //Sphere[1].materialID = 2;\n        }\n    }\n        if(t > second_turn){\n   \n        // Light 2.\n        Light[2].position = vec3( 30.0, 0.0, 5.0 );\n        Light[2].I_a = vec3( 1.0, 1.0, 1.0 );\n        Light[2].I_source = vec3( 1.0, 1.0, 1.0 );\n\n        // Light 3.\n        Light[3].position = vec3( 28.0,0.0, 3.0 );\n        Light[3].I_a = vec3( 1.0, 1.0, 1.0);\n        Light[3].I_source = vec3( 1.0, 1.0, 1.0 );\n        \n        //移动距离/s\n        float height = min(10.0,(highest-lowest)*(t-second_turn)/(music_length-second_turn)+lowest);\n        //底面镜面\n        Plane[0].A = 0.0;\n        Plane[0].B = 1.0;\n        Plane[0].C = 0.0;\n        Plane[0].D = 0.0;\n        Plane[0].materialID = 16;\n        //左上侧镜面\n        Plane[1].A = 0.0;\n        Plane[1].B = 0.0;\n        Plane[1].C = 1.0;\n        Plane[1].D = -50.0;\n        Plane[1].materialID = 16;\n        //右上侧镜面\n//        Plane[2].A = -1.0;\n//        Plane[2].B = 1.0;\n//        Plane[2].C = 1.0;\n//        Plane[2].D = 42.0;\n//        Plane[2].materialID = 16;\n        //右下角镜面\n//        Plane[3].A = -1.0;\n //       Plane[3].B = 1.0;\n//        Plane[3].C = -1.0;\n //       Plane[3].D = 42.0;\n //       Plane[3].materialID = 16;\n        //左下角镜面\n //       Plane[3].A = 1.0;\n//        Plane[3].B = 1.0;\n//        Plane[3].C = -1.0;\n//        Plane[3].D = 42.0;\n//        Plane[3].materialID = 16;\n        // sun\n        Sphere[0].center = vec3( 0.0,height,0.0);\n        Sphere[0].radius = 6.0;\n        Sphere[0].materialID = 1;\n        //mercary\n        Sphere[1].center = vec3( 8.0*cos(iTime),height,8.0*sin(iTime));\n        Sphere[1].radius = 1.0;\n        Sphere[1].materialID = 9;\n\n        //enus\n        Sphere[2].center = vec3( 12.0*cos(2.0*iTime),height,12.0*sin(2.0*iTime));\n        Sphere[2].radius = 1.4;\n        Sphere[2].materialID = 10;\n\n        //earth\n        Sphere[3].center = vec3( 16.0*cos(1.5*iTime),height,16.0*sin(1.5*iTime));\n        Sphere[3].radius = 2.0;\n        Sphere[3].materialID = 11;\n\n        //mars\n        Sphere[4].center = vec3( 21.0*cos(1.2*iTime),height,21.0*sin(1.2*iTime));\n        Sphere[4].radius = 1.4;\n        Sphere[4].materialID = 12;\n\n        //jupiter\n        Sphere[5].center = vec3( 27.0*cos(0.8*iTime),height,27.0*sin(0.8*iTime));\n        Sphere[5].radius = 3.2;\n        Sphere[5].materialID = 13;\n\n        //\n        Sphere[6].center = vec3(35.0*cos(0.7*iTime),height,35.0*sin(0.7*iTime));\n        Sphere[6].radius = 3.0;\n        Sphere[6].materialID = 14;\n\n        //uranus\n //       Sphere[7].center = vec3( *cos(0.5*iTime),height,24.5*sin(0.5*iTime));\n //       Sphere[7].radius = 1.3;\n //       Sphere[7].materialID = 14;\n\n        //neptune\n //       Sphere[8].center = vec3(  28.0,height,0.0);\n //       Sphere[8].radius =1.5;\n //       Sphere[8].materialID = 15;\n        \n        //随机材料选择\n        bool equal = (mod((t-fract(t)),2.0)== 0.0);\n        if(equal){\n            int matrial1 = int(9.0 + mod(10.0 * random(iTime),4.0));\n            int matrial2 = int(9.0 + mod(10.0 * random(iTime+1.0),4.0));\n            int matrial3 = int(9.0 + mod(10.0 * random(iTime+2.0),4.0));\n            int matrial4 = int(9.0 + mod(10.0 * random(iTime+3.0),4.0));\n            int matrial5 = int(9.0 + mod(10.0 * random(iTime+4.0),4.0));\n            int matrial6 = int(9.0 + mod(10.0 * random(iTime+5.0),4.0));\n            int matrial7 = int(9.0 + mod(10.0 * random(iTime+6.0),4.0));\n            int matrial8 = int(9.0 + mod(10.0 * random(iTime+7.0),4.0));\n            int matrial9 = int(9.0 + mod(10.0 * random(iTime+8.0),4.0));\n\n            Sphere[0].materialID = matrial1;\n            Sphere[1].materialID = matrial2;\n            Sphere[2].materialID = matrial3;\n            Sphere[3].materialID = matrial4;\n            Sphere[4].materialID = matrial5;\n            Sphere[5].materialID = matrial6;\n            Sphere[6].materialID = matrial7;\n            Sphere[7].materialID = matrial8;\n            Sphere[8].materialID = matrial9;\n        }\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    //??\n    vec3 origin_dup=ray.o - sph.center;\n    float a = dot(ray.d,ray.d);\n    float b = dot(ray.d,origin_dup)*2.0;\n    float c = dot(origin_dup,origin_dup)- sph.radius*sph.radius;\n    float d= b*b-4.0*a*c;\n    float t0=(-b-sqrt(d))/(2.0*a);\n    float t1=(-b+sqrt(d))/(2.0*a);\n    if(d<0.0){\n        return false;\n    }\n    if(d==0.0)\n    {\n        if(t0<tmin||t0>tmax) return false;\n        else{\n            t = t0;\n            hitPos = ray.o + t0 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        } \n    }\n    if(d>0.0)\n    {\n        //??\n        if(t0>tmin&&t0<tmax)\n        {\n            t = t0;\n            hitPos = ray.o + t0 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        }\n        if(t1>tmin&&t1<tmax)\n        {\n            t = t1;\n            hitPos = ray.o + t1 * ray.d;\n            hitNormal = normalize( hitPos - sph.center );\n            return true;\n        }\n        return false;\n    }\n\n\n    return false;  // Replace this with your code.\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 origin_dup=ray.o - sph.center;\n    float a = dot(ray.d,ray.d);\n    float b = dot(ray.d,origin_dup)*2.0;\n    float c = dot(origin_dup,origin_dup)- sph.radius*sph.radius;\n    float d= b*b-4.0*a*c;\n    float t0=(-b-sqrt(d))/(2.0*a);\n    float t1=(-b+sqrt(d))/(2.0*a);\n    if(d<0.0){\n        return false;\n    }\n    if(d==0.0)\n    {\n        if(t0<tmin||t0>tmax) return false;\n        else{\n            return true;\n        } \n    }\n    if(d>0.0)\n    {\n        if(t0>tmin&&t0<tmax)\n        {\n            return true;\n        }\n        if(t1>tmin&&t1<tmax)\n        {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    vec3 cubemapReflectionColor = texture(iChannel0,ray.d).rgb;\n \n     for(int i=0; i<NUM_PLANES; i++){\n        temp_hasHit = IntersectPlane( Plane[i], ray, DEFAULT_TMIN, nearest_t,\n                         temp_t, temp_hitPos, temp_hitNormal );\n        if(temp_hasHit==true && nearest_t>temp_t){\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            hasHitSomething = temp_hasHit;\n            nearest_hitMatID =  Plane[i].materialID;\n        }\n   }\n\n\n    for(int i=0; i<NUM_SPHERES; i++){\n        temp_hasHit = IntersectSphere( Sphere[i], ray, DEFAULT_TMIN, nearest_t,\n                         temp_t, temp_hitPos, temp_hitNormal );\n        if(temp_hasHit==true && nearest_t>temp_t){\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            hasHitSomething = temp_hasHit;\n            nearest_hitMatID =  Sphere[i].materialID;\n        }\n    }\n\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return cubemapReflectionColor;\n    \n    Ray_t reflect_ray;\n    reflect_ray.o = nearest_hitPos;\n    reflect_ray.d = normalize(reflect(ray.d,nearest_hitNormal));\n\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n\n\n    bool inShadow=false;\n    Ray_t Shadow_ray;\n    \n    for(int i =0 ; i<NUM_LIGHTS; i++){\n        Shadow_ray.o = nearest_hitPos;\n        Shadow_ray.d = normalize(Light[i].position-nearest_hitPos);\n\n       \n       for(int i=0; i<NUM_PLANES; i++){\n            inShadow = IntersectPlane( Plane[i], Shadow_ray, DEFAULT_TMIN, nearest_t);\n            if(inShadow) break;\n        }\n\n        if(!inShadow){\n            for(int i=0; i<NUM_SPHERES; i++){\n                inShadow = IntersectSphere( Sphere[i], Shadow_ray, DEFAULT_TMIN, nearest_t);\n                if(inShadow) break;\n            }\n        }\n\n\n        I_local += PhongLighting( Shadow_ray.d, nearest_hitNormal, -ray.d, inShadow,\n                    Material[nearest_hitMatID],Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    \n //   I_local = mix(cubemapReflectionColor, I_local, step(nearest_t - DEFAULT_TMAX, 0.));\n //   I_local=cubemapReflectionColor;\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length);\n    vec3 cam_pos;\n    vec3 cam_lookat;\n    vec3 cam_up_vec;\n    \n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n     //First step\n    if(t<=first_turn){\n        // Position the camera.\n        // Position the camera.\n        cam_pos = vec3(0.0, 0.0, max(12.0,(20.0-t)) );\n        cam_lookat = Sphere[0].center;\n        cam_up_vec = vec3(0.0, 1.0, 0.0 );\n    \n    }\n    \n   if(t > first_turn && t<=second_turn){\n        // Position the camera.\n        // Position the camera.\n        cam_pos = vec3(50.0*cos(t*0.5), 0.1, 50.0*sin(t*0.5) );\n        cam_lookat = vec3(Sphere[0].center.x,Sphere[0].center.y-5.0,Sphere[0].center.z);\n        cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    }\n\n\n    \n      if(t > second_turn){\n       // cam_pos = vec3( 20.0*(t-second_turn)/(music_length-second_turn)*cos(t*0.8), 0.001+(t-second_turn)/(music_length-second_turn)*(highest-25.0-0.1),20.0*(t-second_turn)/(music_length-second_turn)*cos(t*0.8));\n       cam_pos = vec3( max(20.0,40.0*min(1.0,(t-second_turn)/(music_length-second_turn))*cos(t*0.8)), 0.001+(t-second_turn)/(music_length-second_turn)*(highest-25.0-0.1),max(20.0,40.0*min(1.0,(t-second_turn)/(music_length-second_turn))*sin(t*0.8)));\n       cam_lookat = vec3(Sphere[0].center.x,Sphere[0].center.y,Sphere[0].center.z);\n       cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    }\n\n\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 34044,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/louis-liu-319983371/star-sky-orchestral-two-steps-from-hell128-audiotrimmercom-audiotrimmercom"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float LuminanceThreshold= 0.6;\n\n/////////////////////////////////////////////////////////////////////////////\n// Approximates the brightness of a RGB value.\n/////////////////////////////////////////////////////////////////////////////\nfloat Luminance( vec3 color )\n{\n    const vec3 LuminanceWeights = vec3(0.2126, 0.7152, 0.0722);\n    return dot(LuminanceWeights, color);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Threshold the original image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  float brightness=Luminance(texture(iChannel0, uv.xy).rgb);\n\n  fragColor = (brightness > LuminanceThreshold)? texture(iChannel0, uv.xy):vec4(0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int blurFilterWidth = 51;\nconst int halfWidth = 25;\nfloat weights[blurFilterWidth];\n\n/////////////////////////////////////////////////////////////////////////////\n// 1D gaussian function.\n/////////////////////////////////////////////////////////////////////////////\nfloat gauss(float x, float sigma2)\n{\n    const float PI = 3.1415926535897932384626433832795;\n    float coeff = 1.0 / sqrt(2.0 * PI * sigma2);\n    float expon = -(x * x) / (2.0 * sigma2);\n    return (coeff * exp(expon));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Set up 1D texture map that contains the 1D blur filter.\n/////////////////////////////////////////////////////////////////////////////\nvoid SetUpBlurFilterTexture()\n{\n    float sigma = float(halfWidth) / 2.0;  // Filter spans over 4 sigma (standard deviation).\n    float sigma2 = sigma * sigma;\n\n    float sum = 0.0;\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        float offset=float(i) - float(halfWidth);\n        weights[i] = gauss(offset, sigma2);\n        sum += weights[i];\n    }\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        weights[i] = weights[i] / sum;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Apply horizontal blurring to the threshold image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     \n    //After getting the fragment coordinate of fragment,\n    //Use the middle value of the blurFilterTex on the beginning fragment;\n    ivec2 pix = ivec2(fragCoord.xy);\n    SetUpBlurFilterTexture();\n    \n    vec4 sum = texture(iChannel0, uv) * weights[halfWidth];\n\n    //Apply the 1D Gaussian \n    for( int i = 1; i < halfWidth+1; i++ ) {\n        ivec2 offsetCoord = ivec2(pix.x + i, pix.y);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth+i];\n        offsetCoord = ivec2(pix.x - i, pix.y);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth-i];\n    }\n\n    //fragColor =texelFetch(iChannel0, pix, 0);\n    //fragColor =texture(iChannel2, uv.xy);\n    fragColor = sum;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int blurFilterWidth = 51;\nconst int halfWidth = 25;\nfloat weights[blurFilterWidth];\n\n/////////////////////////////////////////////////////////////////////////////\n// 1D gaussian function.\n/////////////////////////////////////////////////////////////////////////////\nfloat gauss(float x, float sigma2)\n{\n    const float PI = 3.1415926535897932384626433832795;\n    float coeff = 1.0 / sqrt(2.0 * PI * sigma2);\n    float expon = -(x * x) / (2.0 * sigma2);\n    return (coeff * exp(expon));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Set up 1D texture map that contains the 1D blur filter.\n/////////////////////////////////////////////////////////////////////////////\nvoid SetUpBlurFilterTexture()\n{\n    float sigma = float(halfWidth) / 2.0;  // Filter spans over 4 sigma (standard deviation).\n    float sigma2 = sigma * sigma;\n\n    float sum = 0.0;\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        float offset=float(i) - float(halfWidth);\n        weights[i] = gauss(offset, sigma2);\n        sum += weights[i];\n    }\n\n    for (int i = 0; i < blurFilterWidth; i++) {\n        weights[i] = weights[i] / sum;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Apply horizontal blurring to the threshold image.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     \n    //After getting the fragment coordinate of fragment,\n    //Use the middle value of the blurFilterTex on the beginning fragment;\n    ivec2 pix = ivec2(fragCoord.xy);\n    SetUpBlurFilterTexture();\n    \n    vec4 sum = texture(iChannel0, uv) * weights[halfWidth];\n\n    //Apply the 1D Gaussian \n    for( int i = 1; i < halfWidth+1; i++ ) {\n        ivec2 offsetCoord = ivec2(pix.x , pix.y+ i);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth+i];\n        offsetCoord = ivec2(pix.x , pix.y- i);\n        sum += texelFetch(iChannel0, offsetCoord, 0)*weights[halfWidth-i];\n    }\n\n    //fragColor =texelFetch(iChannel0, pix, 0);\n    //fragColor =texture(iChannel2, uv.xy);\n    fragColor = sum;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Interstellar\n// Hazel Quantock\n// This code is licensed under the CC0 license http://creativecommons.org/publicdomain/zero/1.0/\n\nfloat max3(vec3 rd) {\n   return max(max(rd.x, rd.y), rd.z);\n}\n/*original  https://www.shadertoy.com/view/XlfGRj */\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.3\n\n#define zoom   2.300\n#define tile   0.250\n#define speed  0.010 \n\n#define brightness 0.0115\n#define darkmatter 0.500\n#define distfading 0.530\n#define saturation 0.750\n\nconst float tau = 6.28318530717958647692;\nconst float music_length=120.0;\nconst float first_turn=16.0;\nconst float second_turn=90.0;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn texture( iChannel0, (vec2(x)+0.5)/256.0, -100.0 );\n}\n\nvec4 Rand( in int x )\n{\n\tvec2 uv;\n\tuv.x = (float(x)+0.5)/256.0;\n\tuv.y = (floor(uv.x)+0.5)/256.0;\n\treturn texture( iChannel0, uv, -100.0 );\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    //the music will begin after 2 secs\n    float t = mod(iTime, music_length);\n    //t=t+first_turn;\n      //  t=t+second_turn;\n    \n    if(t<=first_turn){\n        vec3 ray;\n        ray.xy = 2.0*(fragCoord.xy-iResolution.xy*.5)/iResolution.x;\n        ray.z = 1.0;\n\n        float offset = t*.5;\t\n        float speed2 = (cos(offset)+1.0)*2.0;\n        float speed3 = speed2+.1;\n        offset += sin(offset)*.96;\n        offset *= 2.0;\n\n\n        vec3 col = vec3(0);\n\n        vec3 stp = ray/max(abs(ray.x),abs(ray.y));\n\n        vec3 pos = 2.0*stp+.5;\n        for ( int i=0; i < 20; i++ )\n        {\n            float z = Noise(ivec2(pos.xy)).x;\n            z = fract(z-offset);\n            float d = 50.0*z-pos.z;\n            float w = pow(max(0.0,1.0-8.0*length(fract(pos.xy)-.5)),2.0);\n            vec3 c = max(vec3(0),vec3(1.0-abs(d+speed2*.5)/speed3,1.0-abs(d)/speed3,1.0-abs(d-speed2*.5)/speed3));\n            col += 1.5*(1.0-z)*c*w;\n            pos += stp;\n        }\n\n        fragColor = vec4(ToGamma(col),1.0);\n    }\n    if(t>first_turn){\n        vec2 uv=fragCoord.xy/iResolution.xy-.5;\n        uv.y*=iResolution.y/iResolution.x;\n        vec3 dir=vec3(uv*zoom,1.);\n        float time=t*speed+.25;\n\n\n        float a1=.5+iMouse.x/iResolution.x*2.;\n        float a2=.8+iMouse.y/iResolution.y*2.;\n        mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n        mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n        dir.xz*=rot1;\n        dir.xy*=rot2;\n        vec3 from=vec3(1.,.5,0.5);\n        from+=vec3(time*0.,time,time*10.);\n        from.xz*=rot1;\n        from.xy*=rot2;\n\n\n        float s=0.1,fade=1.;\n        vec3 v=vec3(0.);\n        for (int r=0; r<volsteps; r++) {\n            vec3 p=sin(fract(from-s*dir)*1.10);\n            p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n            float pa,a=pa=0.;\n            for (int i=0; i<iterations; i++) { \n                p=abs(p)/dot(p,p*3.1)-formuparam; // the magic formula\n                a+=abs(length(p)+pa); // absolute sum of average change\n                pa=0.2*fract(abs(length(p/2.)));\n            }\n                float dm=max(0.,darkmatter-a*a*.001); //dark matter\n                a*=a*a; // add contrast\n                if (r>10) fade*=1.-dm; // dark matter, don't render near\n                v+=vec3(fract(smoothstep(dm,dm*.1,0.)));\n                v+=fade;\n                v+=vec3(s,1.*fract(s*s),s*s*s)*a*brightness*fade; // coloring based on distance\n                fade*=distfading; // distance fading\n                s+=stepsize;\n            }\n            v=mix(vec3(length(v)),v,saturation); //color adjust\n            fragColor = vec4(v*0.01,1.);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}