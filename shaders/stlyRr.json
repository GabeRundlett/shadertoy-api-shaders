{
    "Shader": {
        "info": {
            "date": "1647468678",
            "description": "Hopefully the shader survives the saving process this time.\nStarted off working on less-wrong shadows from glass, ended up here.\nSky, Hexagons, Donut SDF, and Hash() borrowed.",
            "flags": 0,
            "hasliked": 0,
            "id": "stlyRr",
            "likes": 52,
            "name": "The Other Great Chrome Donut",
            "published": 3,
            "tags": [
                "reflection",
                "sunset",
                "ball",
                "donut",
                "rolling",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 4660
        },
        "renderpass": [
            {
                "code": "#define RES     (iResolution)\n#define MINRES  (min(RES.x, RES.y))\n#define ZERO    (min(iFrame,0))\n\n\nconst float PI       = 3.14159265359;\nconst float gMaxTime = 3e3;   // numerical precision gets bad above this\n\nconst vec3 gV0  = vec3(0.0);\nconst vec3 gV1  = vec3(1.0);\nconst vec3 gV1n = normalize(gV1);\nconst vec3 gVx  = vec3(1.0, 0.0, 0.0);\nconst vec3 gVy  = vec3(0.0, 1.0, 0.0);\nconst vec3 gVz  = vec3(0.0, 0.0, 1.0);\n\nvec3 sky(vec3 dir);\n\n// general math\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat square(float a) { return a * a; }\nfloat selfDot(vec2 a) { return dot(a, a); }\nfloat selfDot(vec3 a) { return dot(a, a); }\n\n// author: Neil Mendoza   license: unknown    link: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis\n//mat4 rotationMatrix(vec3 axis, float angle) {     axis = normalize(axis);     float s = sin(angle);     float c = cos(angle);     float oc = 1.0 - c;          return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,                0.0,                                0.0,                                0.0,                                1.0); \n\n\n// author: blackle mori   license: unknown    link: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\nreturn mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle);\n}\n\n// SDF manipulators\nfloat opU(float a, float b) {\n    return min(a, b);\n}\nfloat opS(float a, float b) {\n    return -min(-a, b);\n}\n\n// SDF primitives\n\nfloat sdPlaneY(vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// author: sam hocevar, license: WTFPL, link: https://stackoverflow.com/a/17897228\nvec3 rgb2hsv(vec3 c) {   vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);     vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));     vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));     float d = q.x - min(q.w, q.y);     float e = 1.0e-10;     return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }\nvec3 hsv2rgb(vec3 c) {   vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\n\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins. https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\n\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(-pos.y, 0.0)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(vec3 dir, vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 p, vec3 d, vec3 lightDir)\n{\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n//---------------------------------------------------------\nfloat Pow2(float x) { return x * x; }\n// PaniniProjection from TinyTexel\n// https://www.shadertoy.com/user/TinyTexel\n// https://www.shadertoy.com/view/Wt3fzB\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = PI / 2.0 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\n\n\nvec3 getCamRayDir(vec3 camDir, vec2 uv, float zoom) {\n\n    vec3 camFw  = normalize(camDir);\n    vec3 camRt  = normalize(cross(camFw, gVy));\n    vec3 camUp  = cross(camRt, camFw);    \n    mat3 camMat = mat3(camRt, camUp, camFw);\n    \n    uv /= zoom;\n    \n    float paniniFOV = 0.35 * PI;\n    float paniniD   = 0.1;\n    vec3  rayDirCam = PaniniProjection(uv, paniniFOV, paniniD);\n    \n    return normalize(camMat * rayDirCam);\n}\n\n\n\n\n\n\n\n//-----------------------------------------------------------\n\n\n\n\n\n\nconst int   gMarchMaxSteps      = 150;\nconst float gMarchUnderStep     = 0.98;  // slight understepping to allow for convexity of floor tiles\nconst float gMarchHorizon       = 100.0;\nconst float gMarchHorizonSq     = gMarchHorizon * gMarchHorizon;\nconst float gMarchEps           = 0.001;\nconst float gNormEps            = gMarchEps;\n\n// for development: bigger pixels = clearer problems\nconst float gDownRes            = 1.0;\n\n\nconst uint  gMaximumRaysInQueue = 20u;\n\n// the maximum total number of calls to Map().\nconst float gMaxTotalMapIters   = float(gMarchMaxSteps) * 10.0;\n\n// the least significant ray which will be processed\nconst float gMinRayContribution = 0.001;\nconst float gMinRayContribSq    = gMinRayContribution * gMinRayContribution;\n\n\n\nfloat gSSZoom;\nfloat gSSEps;\nfloat gT;\nfloat gTotalMapIters = 0.0;\n\n// distance from camera to center of scene\nfloat gCamDist     = 20.0;\nvec3  gSceneCenter = gVy * 3.0;\nvec3  gLightDir;\nvec2  gTorusDims;\nvec3  gTorusPos;\nfloat gBallRad;\nfloat gBallOrbit;\nvec3  gBallPos;\nfloat gBallTime;\nfloat gBallInset;\nfloat gBallCycle;\nfloat gBallCycleHash;\nfloat gHexTileFac = 0.67;\n\n\nvec2 gMouse;    // 0 to RES\nvec2 gSSMouse;  // 0 to 1\n\nstruct ray_t {\n    vec3 ro;\n    vec3 rd;\n    bool internal;\n    bool shadow;\n    vec3 contribution;\n};\n\nstruct marchResult_t {\n    float t;\n    uint  m;\n};\n\n\n// \"diffuse\"  includes regular diffuse plus ambient\n// \"specular\" includes reflection and transmission\nstruct material_t {\n    vec3 c1;\n    vec3 c2;\n    \n    // 0 = all diffuse, 1 = all specular\n    float diffuseVsSpecular1;\n    float diffuseVsSpecular2;\n    \n    // 0 = all reflection, 1 = all transmission\n    // scoped to 'specular'\n    float reflectionVsTransmission;\n    \n    // Lambert's linear attenuation coefficient\n    float attenuationCoefficient;    \n};\n\nconst uint kMSky   = 0u;\nconst uint kMFloor = 1u;\nconst uint kMTorus = 2u;\nconst uint kMBall  = 3u;\n\n\n// scoped to 'diffuse'.\nvec3 gAmbientLight;\nvec3 gDirectionalLight;\n\n\nmaterial_t[] kMaterials = material_t[] (\n    // sky\n    material_t (\n        1.0 * vec3(0.1, 0.2, 1.0),\n        1.0 * vec3(0.3, 0.05, 0.1),\n        0.0, 0.0,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // floor\n    material_t (\n        gV1 * 0.1,\n        vec3(0.5, 0.8, 0.1) * 0.3,\n        0.2, 0.7,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // torus\n    material_t (\n        gV1 * 0.2,\n        gV0,\n        0.8, 0.0,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // ball\n    material_t (\n        gV1,\n        gV0,\n        0.2, 0.0,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    )\n);\n\nvoid configMaterials() {\n    float ambientLightAmt = 0.04;\n    float directionalLightAmt = 1.0 - ambientLightAmt;\n    \n    gAmbientLight     = ambientLightAmt * sky(gV1n);\n    gDirectionalLight = clamp(directionalLightAmt * sky(-gLightDir) * 3.0, 0.0, 1.0);\n\n    if (gBallCycleHash != 0.0) {\n        kMaterials[kMBall].diffuseVsSpecular1 = gBallCycleHash * gBallCycleHash;\n    }\n}\n\n\n// queue of ray_t's. ------------------------------\n#define QTYPE ray_t\nconst uint gQCapacity = gMaximumRaysInQueue;\nconst uint gQNumSlots = gQCapacity + 1u; QTYPE gQ[gQNumSlots]; uint gQHead = 0u; uint gQTail = 0u;\nuint QCount    ()           { if (gQHead >= gQTail) {return gQHead - gQTail;} else { return gQNumSlots - (gQTail - gQHead); } }\nuint QSpaceLeft()           { return gQCapacity - QCount(); }\nbool QIsFull   ()           { return QSpaceLeft() == 0u;}\nbool QIsEmpty  ()           { return QCount() == 0u; }\nvoid QEnqueue  (QTYPE item) { gQHead = (gQHead + 1u) % gQNumSlots; gQ[gQHead] = item; }\nQTYPE QDequeue ()           { gQTail = (gQTail + 1u) % gQNumSlots; return gQ[gQTail]; }\n//-------------------------------------------------\n\nfloat stretchRange(float t, vec2 gap, float fac) {\n    float range = gap[1] - gap[0];\n    float f     = (t - gap[0]) / range;\n\n    if (f < 0.0) {\n        return t;\n    }\n    else if (f > 1.0) {\n        return t + range * (fac - 1.0);\n    }\n    else {\n        return mix(gap[0], gap[1], f * fac);\n    }\n}\n\nvoid configGlobals1() {\n    gT       = mod(iTime, gMaxTime);\n    gT       = stretchRange(gT, vec2(90.6, 97.0), 0.2);\n    \n    gSSZoom  = 1.3;\n    gSSEps   = 4.0 / MINRES / gSSZoom;\n    \n    gMouse   = length(iMouse.xy) < 50.0 ? (vec2(sin(gT * 0.107), -cos(gT * 0.1)) * 0.5 + 0.5) * RES.xy : iMouse.xy;\n    gSSMouse = gMouse/RES.xy;\n    \n    gLightDir     = normalize(-gVy + gVz * 0.4);\n    float sunTime = gT * 0.017 - 0.3;\n    gLightDir.yx *= rot2(PI/2.0 * 1.01 * sin(sunTime) * sign(cos(sunTime)));\n    \n    gTorusDims   = vec2(4.0, 2.0);\n    gTorusPos    = gVy * gTorusDims[1] * 0.0;\n\n//  gBallInset   = (sin(gT * 0.1) * 0.3 + 0.7) * gBallRad * 1.2;\n    const float insetMinFac = 0.2;\n    const float insetMaxFac = 2.1;\n    float git    = (gT + 31.0) * 0.015;\n    gBallCycle   = floor(git - 31.0 * 0.015);\n    gBallCycleHash = hash11(gBallCycle * 15.621341);\n    float ballRadMin = 0.2;\n    float ballRadMax = 2.2;\n    float ballRadFac = mix(ballRadMin, ballRadMax, gBallCycleHash);\n    if (gBallCycle == 0.0) {\n        gBallCycleHash = 0.0;\n        ballRadFac = 1.4;\n    }\n    \n    gBallRad     = gTorusDims.y * ballRadFac;\n    float gbx    = smoothstep(1.0, 0.7, -cos(git * PI * 2.0));\n    gBallInset   = gBallRad * mix(insetMaxFac, insetMinFac, gbx);\n    gBallOrbit   = gTorusDims.x + gTorusDims.y + gBallRad + 1.00;\n    float ballDir = gBallCycleHash < 0.5 ? 1.0 : -1.0;\n    gBallTime    = gT * ballDir * mix(0.42, 0.9, gBallCycleHash) + 2.2;\n    gBallPos     = gVx * gBallOrbit + gVy * (gBallRad - gBallInset);\n    gBallPos.xz *= rot2(-gBallTime);\n\n    configMaterials();\n}\n\nvec3 toBallSpace(in vec3 p) {\n    float f = 40.0;\n    p.xz = mod(p.xz + f / 2.0, f) - f/2.0;\n    return p - gBallPos;    \n}\n\n\nmarchResult_t map(vec3 p) {\n    gTotalMapIters += 1.0;\n    \n    vec3 pbs = toBallSpace(p);\n    \n    float d1 = p.y;\n    // add some convexity to each hexagonal tile\n    vec2 v2 = p.xz * gHexTileFac;\n    float hexHash = hash12(hextile(v2) * 4.83);\n    float lt = length(p.xz);\n    float hl = dot(v2, v2);\n    d1 += hl * 0.9 / (1.0 + lt);\n    if (hexHash < 0.06) {\n        d1 += cos(hl * 40.0) * 0.003;\n    }\n        \n    \n    float subtractedTorusRad = gBallRad * 1.0001;\n    d1 = opS(d1, sdTorus(pbs + gBallPos - gVy * (gBallRad - gBallInset), vec2(gBallOrbit, subtractedTorusRad)));\n\n    vec3 pt = p - dot(gTorusDims, vec2(1.0)) * gVy;\n    pt.xy *= rot2(PI/2.0);\n    float d2 = sdTorus(pt, gTorusDims);\n    \n    float d3 = sdSphere(toBallSpace(p), gBallRad);\n    \n    marchResult_t ret = marchResult_t(1e9, kMSky);\n    if (d1 < ret.t) { ret = marchResult_t(d1, kMFloor); }\n    if (d2 < ret.t) { ret = marchResult_t(d2, kMTorus); }\n    if (d3 < ret.t) { ret = marchResult_t(d3, kMBall); }\n    \n    return ret;\n}\n\nvoid getCamPosDir(out vec3 camPos, out vec3 camDir) {\n    float y    = smoothstep(0.05, 0.95, gSSMouse.y);\n    camPos     = gVz * gCamDist;\n    camPos.yz *= rot2((0.7 - y * 0.7) *  PI / 2.0);\n    camPos.xz *= rot2((gSSMouse.x * 2.0 - 1.0) * -PI * 1.1);\n    camPos    += gSceneCenter + gVy * 1.8;\n    \n //   camPos     = gBallPos * 2.0;\n   // camPos.y   = gBallPos.y * 0.5;\n    camDir     = normalize(gSceneCenter - camPos);\n}\n\nray_t getCamRay(in vec2 uv, float camZoom, in vec3 contribution) {\n    vec3 camPos;\n    vec3 camDir;\n    getCamPosDir(camPos, camDir);\n    ray_t ray;\n    ray.ro           = camPos;\n    ray.rd           = getCamRayDir(camDir, uv, camZoom);\n    ray.internal     = map(camPos).t < 0.0;\n    ray.shadow       = false;\n    ray.contribution = contribution;\n    return ray;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) {\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*gNormEps).t;\n    }\n    return normalize(n);\n}\n\nmarchResult_t march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    vec3 p = ro;\n    \n    for (int n = 0; dot(p, p) < gMarchHorizonSq; ++n) {\n        marchResult_t mr = map(p);\n        if (mr.t < gMarchEps || n == gMarchMaxSteps) {\n            return marchResult_t(t, mr.m);\n        }\n        \n        t += mr.t * gMarchUnderStep;\n        p = ro + t * rd;\n    }\n    \n    return marchResult_t(1e9, 0u);\n}\n\n\nvec3 sky(vec3 dir) {\n    vec3 ret = simple_sky(gVy * -1.5, dir, -gLightDir);\n    // ungamma.\n    // I'm not sure if this is 'correct'\n    // but without it there are nasty pops in the post-sunset darkness.\n    ret = pow(ret, vec3(1.5));\n    return ret;\n}\n\nstruct materialProps_t {\n    vec3 albedo;\n    vec3 emissive;\n    float diffuse_vs_specular;  // 0 = diffuse 1 = specular\n};\n\nmaterialProps_t getMaterialProps(in vec3 p, uint m) {\n    materialProps_t ret;\n    \n    material_t mat = kMaterials[m];\n    \n    ret.albedo              = mat.c1;\n    ret.emissive            = gV0;\n    ret.diffuse_vs_specular = mat.diffuseVsSpecular1;\n\n    // special cases\n    switch (m) {\n        case kMFloor: {\n            \n            vec2 v2 = p.xz * gHexTileFac;\n            vec2 ht = hextile(v2);\n            ht.y *= 1.5;\n            float hash = hash12(ht);\n            if (hash * 4e3 < dot(ht, ht)) {\n                ret.albedo = mat.c2;\n                ret.emissive = ret.albedo * 0.1;\n            }\n            ret.diffuse_vs_specular = mix(mat.diffuseVsSpecular1, mat.diffuseVsSpecular2, hash);\n            break;\n        }\n        case kMBall: {\n            vec3 pp = toBallSpace(p);\n            float at = smoothstep(gBallOrbit + gBallRad + 2.0, gBallOrbit + gBallRad + 1.0, length(p.xz));\n            at = 0.1 + 0.9 * at;\n            pp.xz *= rot2(gBallTime);                       // orbit\n            pp.yz *= rot2(gBallTime * 4.0 * PI / gBallRad); // roll\n            pp.xy *= rot2(2.2);                             // de-align\n            vec3 rgb = vec3(0.0);\n            for (int n = 0; n < 3; ++n) {\n                const float eps = 0.03;\n                float s = sin(4.0 * PI * (atan(pp[(n + 2)%3], pp[(n + 1)%3]) / (PI/2.0) * 0.5 + 0.5));\n                float f = smoothstep(-eps, eps, s);\n                rgb[(n + 0)%3] += f * 0.4;\n                rgb[(n + 1)%3] += f * 0.4;\n                rgb[(n + 2)%3] += f * 0.2;\n            }\n            rgb *= at;\n            ret.albedo = mix(rgb, vec3(1.0), 0.05);\n            ret.diffuse_vs_specular *= at;\n            break;\n        }\n    }\n    \n\n#if 0\n    // ping-pong between totally matte and specular,\n    // with the nice tuned materials in the middle.\n    float blah = sin(gT * 0.1);\n    \n    if (blah < 0.0) {\n        ret.diffuse_vs_specular = mix(0.0, ret.diffuse_vs_specular, blah + 1.0);\n    }\n    else {\n        ret.diffuse_vs_specular = mix(ret.diffuse_vs_specular, 1.0, blah);\n    }\n#endif\n\n    \n    return ret;\n}\n\nvec3 processRays() {\n\n    vec3 rgb = gV0;\n\n    while (!QIsEmpty() && gTotalMapIters < gMaxTotalMapIters) {\n        ray_t ray = QDequeue();\n        \n        vec3 rayRGB = gV0;\n\n        marchResult_t mr = march(ray.ro, ray.rd);\n        \n        if (ray.shadow) {\n            if (mr.t > 1e4) {\n                rgb += ray.contribution;\n            }\n        }\n        else {\n            if (mr.t < 1e4) {\n                vec3 p = ray.ro + ray.rd * mr.t;\n\n                vec3 n = calcNormal(p);\n\n                materialProps_t mp = getMaterialProps(p, mr.m);\n\n                vec3 albedo = mp.albedo;\n\n                float specAmt = mp.diffuse_vs_specular;\n                float diffAmt = 1.0 - specAmt;\n\n                float maximumDirectionalContribution = max(0.0, dot(n, -gLightDir));\n\n                vec3 directionalAmt = gDirectionalLight * maximumDirectionalContribution;\n                vec3 diffContrib = directionalAmt * albedo * diffAmt;\n\n                if (gLightDir.y < 0.0) {\n                    if (maximumDirectionalContribution > 0.0 && !ray.internal && !QIsFull() && dot(diffContrib, diffContrib) > gMinRayContribSq) {\n                        ray_t shdwRay;\n                        shdwRay.ro           = p + n * gMarchEps * 2.0;\n                        shdwRay.rd           = -gLightDir;\n                        shdwRay.contribution = ray.contribution * diffContrib;\n                        shdwRay.internal     = false;\n                        shdwRay.shadow       = true;\n                        QEnqueue(shdwRay);\n                    }\n                    else {\n                        rayRGB += diffContrib;\n                    }\n                }\n                \n                rayRGB += albedo * gAmbientLight;\n                rayRGB += mp.emissive;\n\n                vec3 specContrib = ray.contribution * specAmt;\n\n                if (!QIsFull() && dot(specContrib, specContrib) > gMinRayContribSq) {\n                    ray_t rflRay;\n                    rflRay.ro = p + n * gMarchEps * 2.0;\n                    rflRay.rd = reflect(ray.rd, n);\n                    rflRay.contribution = specContrib;\n                    rflRay.internal = ray.internal;\n                    rflRay.shadow       = false;\n                    QEnqueue(rflRay);\n                }\n\n            }\n            else {\n                rayRGB += sky(ray.rd);\n            }\n            rgb += ray.contribution * rayRGB;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    configGlobals1();\n    \n    vec2 uv = (floor((XY - RES.xy/2.0)/gDownRes)) / MINRES * 2.0 * gSSZoom * gDownRes;\n    \n    QEnqueue(getCamRay(uv, 2.0, gV1));\n    \n    vec3 rgb = processRays();\n    \n    // temporal fade-in\n    rgb *= 0.2 + 0.8 * square(smoothstep(0.0, 8.0, iTime));\n\n    // gamma\n    rgb = pow(rgb, vec3(1.0/2.2));\n    \n    \n    RGBA = vec4(rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}