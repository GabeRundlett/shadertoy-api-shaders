{
    "Shader": {
        "info": {
            "date": "1412930981",
            "description": "i was gonna try to fix the shadows before publishing this but its been almost 10 years so w/e lol",
            "flags": 0,
            "hasliked": 0,
            "id": "MdjSDm",
            "likes": 0,
            "name": "go escape",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "ahihi",
            "viewed": 81
        },
        "renderpass": [
            {
                "code": "#define TAU 6.283185307179586\n\nstruct ObjectDistance {\n    float distance;\n    int material;\n};\n\nObjectDistance distanceUnion(ObjectDistance a, ObjectDistance b) {\n    if(a.distance < b.distance) {\n        return a;\n    } else {\n     \treturn b;\n    }\n}\n\nObjectDistance distanceDifference(ObjectDistance b, ObjectDistance a) {\n    if(-a.distance > b.distance) {\n        a.distance *= -1.0;\n        return a;\n    } else {\n        return b;\n    }        \n}\n\nvec2 polar2rect(vec2 p) {\n    return vec2(cos(p.x) * p.y, sin(p.x) * p.y);\n}\n\nfloat rand(vec2 p){\n\treturn fract(sin(dot(p.xy, vec2(1.3295, 4.12))) * 493022.1);\n}\n\nObjectDistance board(float y, int material, vec3 p) {\n    return ObjectDistance(p.y - y, material);\n}\n\nfloat sphere(float radius, vec3 p) {\n  \treturn length(p) - radius;\n}\n\n#define NO_MATERIAL 0\n#define BOARD_MATERIAL 1\n#define BLACK_MATERIAL 2\n#define WHITE_MATERIAL 3\n\nfloat stone(float compress, vec3 p) {\n    float radius = 0.45;\n    float y_radius = radius / compress;\n    \n    return sphere(radius, p * vec3(1.0, compress, 1.0) + vec3(0.0, -y_radius, 0.0));\n}\n\nObjectDistance stones(vec3 p) {\n    ObjectDistance od = ObjectDistance(-0.0, BLACK_MATERIAL);\n\n    float i = rand(vec2(floor(p.x), floor(p.z)));\n    if(i < 0.5) {\n        od.material = WHITE_MATERIAL;\n    } \n    \n    float j = rand(vec2(floor(p.x) * 92.0, floor(p.z) * 82.0));\n    \n    float jump = 0.3 * pow(abs(sin(4.0*iTime + TAU*i)), 0.8);\n    if(j < 1.0/2.0) {\n        jump -= 10.0;\n    }\n    vec3 stoneP = vec3(fract(p.x) - 0.5, p.y - jump, fract(p.z) - 0.5);\n\tod.distance = stone(2.5, stoneP);\n    return od;\n}\n\nvec3 wave(vec3 p) {\n    float wave1 = 0.3 * sin(0.44 * p.x + 0.6 * iTime);\n    float wave2 = 0.3 * sin(0.67 * p.z + 0.5 * iTime);\n    return vec3(p.x , p.y + wave1 + wave2, p.z);\n}\n\nObjectDistance sceneDistance(vec3 p) {    \n    vec3 p_wave = wave(p);\n    p = p_wave;\n\tObjectDistance d = board(0.0, BOARD_MATERIAL, p);\n        \n    d = distanceUnion(d, stones(p + vec3(0.0, 0.0, 2.0*iTime)));\n    \n    return d;\n}\n\n#define THRESHOLD 0.01\n#define MAX_ITERATIONS 256\n#define MAX_SHADOW_ITERATIONS 256\n#define NORMAL_DELTA 0.01\n#define MAX_DEPTH 60.0\n\nfloat marchShadow(vec3 lightPos, vec3 surfacePos, float k) {\n    vec3 origin = lightPos;\n    vec3 target = surfacePos;\n    \n    vec3 travel = target - origin;\n    vec3 forward = normalize(travel);\n    float travelDistance = length(travel);\n    \n    float length = 0.0;\n    float distance = 0.0;\n    for(int i = 0; i < MAX_SHADOW_ITERATIONS; i++) {\n        ObjectDistance sd = sceneDistance(origin + forward * length);\n        distance = sd.distance;\n        \n        if(abs(distance) < THRESHOLD || length > travelDistance) {\n            return 1.0;\n        }\n        \n        length += distance;\n        //light = min(light, k * rayDistance / rayLength);\n    }\n\n    //return iterations / MAX_SHADOW_ITERATIONS;\n    return 0.0;\n}\n\nstruct MarchResult {\n    float length;\n    float distance;\n    int material;\n    int iterations;\n};\n    \nMarchResult march(vec3 origin, vec3 direction) {\n    MarchResult result = MarchResult(0.0, 0.0, NO_MATERIAL, 0);\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n\t    ObjectDistance sd = sceneDistance(origin + direction * result.length);\n        result.distance = sd.distance;\n        result.material = sd.material;\n        result.iterations++;\n        \n        if(abs(result.distance) < THRESHOLD || result.length > MAX_DEPTH) {\n            break;\n        }\n        \n        result.length += result.distance;\n    }\n\n    if(result.length > MAX_DEPTH) {\n        result.material = NO_MATERIAL;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pxPos = 2.0*(0.5 * iResolution.xy - fragCoord.xy) / iResolution.xx;\n    \n    vec3 camDirection = normalize(vec3(0.6, 0.0, 0.3));\n    float camY0 = 1.0;\n  \tvec3 camPos = vec3(5.0 * sin(0.2 * iTime), 0.0, 1.0 * iTime);\n    \n    camPos.y = -wave(camPos).y + 0.9;\n    \n    vec3 camLook = camPos + vec3(0.0, 0.0, 1.0);\n    \n    vec3 camUp = vec3(0.0, 1.0, 0.0); \n    vec3 camForward = normalize(camLook - camPos);\n    vec3 camLeft = normalize(cross(camUp, camForward));\n    vec3 camUp2 = cross(camForward, camLeft);\n    vec3 camPosForward = camPos + camForward;\n    vec3 screenPos = camPosForward - pxPos.x * camLeft - pxPos.y * camUp2;\n    vec3 rayForward = normalize(screenPos - camPos);\n    \n    MarchResult mr = march(camPos, rayForward);\n    \t\n    vec3 rayEnd = camPos + mr.length * rayForward;\n    vec3 color;\n    vec3 bgColor = vec3(0.1);\n    \n    if(mr.material == NO_MATERIAL) {\n        color = bgColor;\n    } else {\n        vec3 material;\n        \n        if(mr.material == BOARD_MATERIAL) {\n            float r = 0.02;\n            float xMod = mod(rayEnd.x - 0.5, 1.0);\n            float zMod = mod(rayEnd.z - 0.5, 1.0);\n\n            bool xGrid = xMod < r || (1.0-r) < xMod;\n            bool zGrid = zMod < r || (1.0-r) < zMod;\n\n            if(xGrid || zGrid) {\n                material = vec3(0.0, 0.0, 0.0);\n            } else {\n                material = vec3(0.9, 0.6, 0.2);\n            }\n        } else if(mr.material == BLACK_MATERIAL) {\n            material = vec3(0.0, 0.0, 0.0);\n        } else if(mr.material == WHITE_MATERIAL) {\n            material = vec3(1.0, 1.0, 1.0);\n        }\n                \n        float deltaTwice = 2.0 * NORMAL_DELTA;\n        vec3 dx = vec3(NORMAL_DELTA, 0.0, 0.0);\n        vec3 dy = vec3(0.0, NORMAL_DELTA, 0.0);\n        vec3 dz = vec3(0.0, 0.0, NORMAL_DELTA);\n        vec3 normal = normalize(vec3(\n            (sceneDistance(rayEnd + dx).distance - sceneDistance(rayEnd - dx).distance) / deltaTwice,\n            (sceneDistance(rayEnd + dy).distance - sceneDistance(rayEnd - dy).distance) / deltaTwice,\n            (sceneDistance(rayEnd + dz).distance - sceneDistance(rayEnd - dz).distance) / deltaTwice\n        ));\n\n        vec3 lightPos = camPos + vec3(0.0, 5.0, 2.0);//vec3(3.0 * sin(iTime), 4.0, 0.0);\n\n        float shadow = marchShadow(lightPos, rayEnd, 8.0);\n        //float shadow = 1.0;\n        float ambient = 0.1;\n        float diffuse = dot(normal, normalize(lightPos - rayEnd));\n        float specular = pow(diffuse * 0.95, 16.0);\n\n        color = vec3(((ambient + shadow * diffuse) * material + specular) * (1.0 - mr.length * 0.01));\n        //color = vec3(rayIterations / MAX_TRACE_ITERATIONS, 0.0, shadow);\n\t    color = mix(color, bgColor, clamp(pow(mr.length / MAX_DEPTH, 0.8), 0.0, 1.0));\n\n    }\n        \n\t//color = mix(vec3(0.0), vec3(0.0, 1.0, 0.0), float(mr.iterations)/float(MAX_ITERATIONS));\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}