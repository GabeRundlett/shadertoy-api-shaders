{
    "Shader": {
        "info": {
            "date": "1665919932",
            "description": "Tiny race track in na√Øve perspective view. No ray marching, no lighting, no anti-aliasing, no motion blur. Very flat, very fast, very retro.",
            "flags": 64,
            "hasliked": 0,
            "id": "stVfR1",
            "likes": 16,
            "name": "Isle of Eight",
            "published": 3,
            "tags": [
                "retro",
                "perspective",
                "race"
            ],
            "usePreview": 0,
            "username": "ruudhelderman",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "// \"Isle of Eight\" https://www.shadertoy.com/view/stVfR1\n// Copyright 2022 Ruud Helderman\n// MIT License\n\nconst float speed = 0.4;\nconst float hang = -1.0;\nconst float height_cam = 0.01;\nconst float height_ceiling = 0.03;\nconst float fence_sqradius = 1.0375;\nconst float wall_sqradius = 0.25;\nconst float wall_thick = 0.03;\n\nconst vec4 dark = vec4(0.7, 0.7, 0.7, 1);\nconst vec4 reflection = vec4(0, 0, 0, 0.2);\n\n#define BLEND(c1, c2) ((c1).a < 1.0 ? mix((c2), vec4((c1).rgb, 1), (c1).a) : (c1))\n\nvec2 pmul(vec2 a, vec2 b)    // perpendicular multiply\n{\n    return vec2(dot(a, b), a.x * b.y - a.y * b.x);\n}\n\nvec2 perspective(vec2 uv, float h)\n{\n    return vec2(1, uv.x) * h / uv.y;\n}\n\nfloat area(vec2 coord)\n{\n    vec2 sqr = coord * coord;\n    return min(abs(sqr.x + sqr.y - 1.0), abs(sqr.y + sqr.x * (sqr.x - 1.0))) * 40.0 - 1.0;\n}\n\nbool fence(vec2 fpos)\n{\n    fpos.x = sin(45.0 * fpos.x);\n    fpos.y *= 180.0;\n    fpos *= fpos * fpos;\n    return abs(dot(fpos, fpos) - 1.9) < 1.0;\n}\n\nbool ceiling(vec2 coord)\n{\n    return abs(dot(coord, coord) - wall_sqradius) < wall_thick;\n}\n\nfloat shadow(vec2 coord)\n{\n    return ceiling(coord) ? 0.8 : 1.0;\n}\n\nbool wall(vec2 fpos)\n{\n    fpos.x = cos(fpos.x * 2.0);\n    fpos.y *= 0.54 / height_ceiling;\n    fpos *= fpos * fpos;\n    return abs(dot(fpos, fpos) - 1.02) < 1.0;\n}\n\nvec3 road_color(float a)\n{\n    return a > 0.2 ? vec3(a, 1, 0) * 0.5 : vec3(abs(a) > 0.1 ? 0.5 : 0.8);\n}\n\nvec4 earth(vec2 uv, vec2 dir, float height, vec2 path)\n{\n    vec2 coord = path + pmul(perspective(uv, -height), dir);\n    vec3 n = texture(iChannel0, coord).rgb * 0.2;\n    float a = area(coord);\n    return a < 0.6 + n.r\n        ? vec4((road_color(a) + n) * shadow(coord), 1)\n        : reflection;\n}\n\nvec4 sky(vec2 uv, vec2 dir)\n{\n    return vec4(1.0 - texture(iChannel2, normalize(vec3(pmul(vec2(uv.x, -1), dir), uv.y).xzy)).rg, 1, 1);\n}\n\nvec2 circle_wall(vec2 uv, vec2 dir, float height, vec2 path, vec2 c, float sqradius, float side)\n{\n    float b = path.x * (path.x * path.x + 2.0 * uv.x * c.x * c.x * c.x);\n    vec2 a = pmul(c, vec2(1, uv.x));\n    float m = dot(a, a);\n    float d = sqradius * m - b * b;\n    if (d > 0.0)\n    {\n        vec2 coord = pmul(a, vec2(side * sqrt(d), b)) / m;\n        float dist = dot(coord - path, dir);\n        if (dist > 0.0)\n        {\n            return vec2(atan(coord.y, coord.x), uv.y * dist + height);\n        }\n    }\n    return vec2(0);\n}\n\nvec4 walls_and_beyond(vec2 uv, vec2 dir, float height, vec2 path, vec2 c)\n{\n    // outer wall of entrance\n    vec2 fpos = circle_wall(uv, dir, height, path, c, wall_sqradius + wall_thick, -1.0);\n    if (fpos.y > 0.0 && wall(fpos))\n    {\n        return texture(iChannel0, fpos);\n    }\n    // inner wall of entrance\n    fpos = circle_wall(uv, dir, height, path, c, wall_sqradius - wall_thick, -1.0);\n    if (fpos.y > 0.0 && fpos.y < height_ceiling && wall(fpos))\n    {\n        return dark * texture(iChannel0, fpos);\n    }\n    // inner wall of exit\n    fpos = circle_wall(uv, dir, height, path, c, wall_sqradius - wall_thick, 1.0);\n    if (fpos.y > 0.0 && wall(fpos))\n    {\n        return texture(iChannel0, fpos);\n    }\n    // ceiling\n    vec2 p = perspective(uv, height_ceiling - height);\n    if (p.x > 0.0)\n    {\n        vec2 coord = path + pmul(p, dir);\n        if (ceiling(coord))\n        {\n            return dark * texture(iChannel0, coord);\n        }\n    }\n    // outer wall of exit\n    fpos = circle_wall(uv, dir, height, path, c, wall_sqradius + wall_thick, 1.0);\n    if (fpos.y > 0.0 && wall(fpos))\n    {\n        return dark * texture(iChannel0, fpos);\n    }\n    // fence\n    fpos = circle_wall(uv, dir, height, path, c, fence_sqradius, 1.0);\n    return fpos.y > 0.0 && fence(fpos)\n        ? texture(iChannel1, fpos)\n        : uv.y > 0.0 ? sky(uv, dir) : earth(uv, dir, height, path);\n}\n\nvec4 with_reflection(vec2 uv, vec2 dir, vec2 path, vec2 c)\n{\n    vec4 color = walls_and_beyond(uv, dir, height_cam, path, c);\n    return BLEND(color, walls_and_beyond(vec2(uv.x, -uv.y), dir, -height_cam, path, c));\n}\n\nbool revs(vec2 u, float v)\n{\n    return abs(u.x) < 0.1 && u.y > 0.0 && u.y < v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * speed;\n    float c = cos(t), s = sin(t);\n    \n    vec2 path = vec2(s, s * c);\n    vec2 velocity = vec2(c, 2.0 * c * c - 1.0);\n    vec2 direction = normalize(velocity);\n    vec2 dash = fragCoord / iResolution.xy * 5.0;\n    vec2 tilt = normalize(vec2(1, hang * speed * dot(direction, vec2(-4.0 * path.y, path.x))));\n    vec2 uv = pmul(tilt, (fragCoord - 0.5 * iResolution.xy) / iResolution.y);\n    \n    fragColor = revs(dash - 0.25, length(velocity))\n            ? vec4(dash.y, 2.0 - dash.y, 0, 1)\n            : with_reflection(uv, direction, path, velocity);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 29834,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/advanced-sport-touring/racing-from-bike-25sec"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}