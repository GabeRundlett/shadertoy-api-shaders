{
    "Shader": {
        "info": {
            "date": "1557737610",
            "description": "keyhole crows is watching you masturbate\nimouse.x zooms.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlsGD2",
            "likes": 4,
            "name": "Keyhole Crowd",
            "published": 3,
            "tags": [
                "keyhole",
                "crowd"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 448
        },
        "renderpass": [
            {
                "code": "//get inner uv.xy (or barycentric) AND ger a 3d tileID\n//this is VERY arbitiary.\n//i prefer carthesian here, if only for compression.\n\n//a nice shape for very basic crowd-scene (without NaNs)\n#define KeyholeCircles\n\n\n#define dd(a) dot(a,a)\n\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec4 a){return min(mi(a.xy),mi(a.zw));}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nvec4 hex2(out vec4 o,vec2 i//https://www.shadertoy.com/view/4lt3DX\n){const float w=1.53,q=w*.5\n ;vec2 v=iResolution.xy\n ,u=i=(i-v/2.)/v.y*5.*q //center\n ;//if(u.x!=u.x)u.x=1.//not busting a NaN!\n ;//if(u.y!=u.y)u.y=1.//not busting a NaN!\n ;u*=mat2(1.,-1./w,0.,2./w)\n ;vec3 g=vec3(u,1.-u.xy)//to hex\n ;u=floor(g).xy*mat2(1.,.5,0.,q)//cell id\n ;vec2 a=u+vec2(1,0)\n      ,b=u+vec2(.5,q)\n      ,c=u+vec2(1.5,q)\n ;//4 SQUARED screenspace distances to nodes:\n ;vec4 f=vec4(dd(b-i),dd(a-i),dd(u-i),dd(c-i))\n ;f.w=mi(f)//set .w to shortest of 4 distances  \n ;//if(f.w!=f.w)f.w=0.//not busting a NaN!\n ;vec2 m=iMouse.xy/iResolution.xy\n ;//if(iMouse.z<=0.)m.xy=cs(iTime)*.5+.5\n ;m.xy=vec2(.15)\n #ifdef KeyholeCircles\n ;f.w=exp2(-23.)//optional cheap keyhole-circles\n #endif\n ;if(f.w!=0.&&m.x!=0.)f.w=pow(abs(f.w),m.x)//not busting a NaN!\n ;else f.w=.5\n ;f.xyz=step(vec3(0),f.w-f.xyz)\n ;b=(b-c)*f.x\n ;a=(a-c-b)*f.y \n ;c=c+b+a\n ;vec2 t=mix(c,u,f.z)\n ;u=i-t \n ;return vec4(u,t)//unformatted output\n ;}\n\n#define pi acos(-1.)\nmat2 r2(float a){return mat2(cos(a),sin(a),sin(a),-cos(a));}\n    //mat2(cs(a),cs(a).yx*vec2(-1,1));}\n\nvoid mainImage( out vec4 o, in vec2 u\n){float t=iTime\n ;vec3 r=iResolution\n ;u*=mix(1.,iResolution.x/10.,iMouse.x/iResolution.x)\n ;u*=r2(-1.)\n ;u=-u\n ;o=hex2(o,u)\n ;u=o.xy\n ;u=r2(-1.)*u\n ;u.x=abs(u.x)-.1\n ;float a=length(u.xy)//euclidean distance to center\n ;a=smoothstep(.05,-.05,a-.05)//smooth circle in hex center\n ;vec2 id=fract(o.zw*.5)//tileID gets fractured\n ;vec2 hashs=4.*cos(o.zw*vec2(.5,.61))\n ;o.xz=o.xy*.5+.5//show uv in redBlue, shift negative into visible.\n     +fract(hashs.x-hashs.y*.61)-cos(o.z*5.)*.5+.5 //cheap hashing\n ;o.y=mix(0.,id.x,a)//greenness of dots is set by id.x\n ;o.z=mix(o.z,id.y,a)//blueness of id.x is set by id.y\n ;o.xz=mix(o.xz,vec2(0),smoothstep(.1,-.1,abs(a-.1)-.1))//eye rings\n\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}