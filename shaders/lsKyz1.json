{
    "Shader": {
        "info": {
            "date": "1521636081",
            "description": "Num keys : nb of arms\nMouse.x : rotation\nMouse.y : warp\nF : flip\nToggles :\nM : white orthogonal mesh\nB : bulb\nD : debug display\nR : reset zone display",
            "flags": 16,
            "hasliked": 0,
            "id": "lsKyz1",
            "likes": 9,
            "name": "Spiral regular orthogonal mesh",
            "published": 3,
            "tags": [
                "spiral",
                "mesh",
                "logarithmic",
                "regular",
                "orthogonal",
                "orthogonality"
            ],
            "usePreview": 1,
            "username": "ABizard",
            "viewed": 925
        },
        "renderpass": [
            {
                "code": "\n// Thanks to FabriceNeyret for his help :-)\n\n//#define SMOOTH(V,A) smoothstep(3./iResolution.y,0.,abs(V)-A)\n#define SMOOTH(V,A) smoothstep(1.5,0.,abs(V) / min(1.,length(vec2(dFdx(V),dFdy(V)))) - A)\n\n#define PI 3.141593\n#define E 2.718282\n\n#define keyToggle(K) (texture(iChannel1,vec2((.5+float(K))/256.,0.75)).x > 0.)\n#define keyPress(K) (texelFetch(iChannel1, ivec2(K, 0), 0).x > 0.)\n\n#define InBLCorner(UV) (length(UV)<30.)\n//#define InBLCorner(UV) false\n\n#define NCOS(A) (cos(A)*.5+.5)\n#define NSIN(A) (sin(A)*.5+.5)\n\n#define BLACK\t\tvec3(0)\n#define WHITE\t\tvec3(1)\n#define GREY(A)\t\tvec3(A)\n#define RED  \t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE \t\tvec3(0,0,1)\n#define TURQUOISE \tvec3(0,1,1)\n#define YELLOW \t\tvec3(1,1,0)\n#define PURPLE \t\tvec3(.5,0,1)\n#define LIGHT_BLUE\tvec3(0,.5,1)\n#define PINK\t\tvec3(1,.3,.7)\n\n///////\n// Default parameters for the spiral :\n// Zoom\n#define DEF_ALPHA .1\n// Number of \"arms\"\n#define DEF_N 6\n///////\n\n// Max number of arms\n#define MAX_N 9\n\n// Number of white orthogonal arms\n#define WHITE_MESH 2\n//#define ORTH_MESH_FACTOR 1./((beta-1.)/(E - 1.))\n//#define ORTH_MESH_FACTOR (1.+1./LOG2(beta))/(1.+LOG2(beta))\n#define ORTH_MESH_FACTOR 1./log(beta)\n\n#define SPIRAL_THICKNESS\t.5\n#define MESH_THICKNESS\t\t.4\n\n// Number of revolutions of the spiral\n#define SPIRAL_SIZE 4\n\n//////////////////////////////////////////////\n// Keyboard controls\n// 'F' : flip the spiral\n#define FLIP\t\t\t\t!keyToggle(70)\n// 'M' : display white orthogonal mesh\n#define DO_WHITE_MESH\t\t!keyToggle(77)\n// 'D' : display the spiral parameters\n#define DISPLAY_PARAMS\t\t keyToggle(68)\n// 'R' : display reset zone\n#define DISPLAY_RESET\t\t keyToggle(82)\n// 'B' : display a bulb at the center\n#define DO_BULB\t\t\t\t keyToggle(66)\n\n//////////////////////////////////////////////\n\n#define R iResolution\n\n// rho = f(theta)\nfloat f(float theta, float alpha, float beta){\n    return alpha*pow(beta,theta);\t\t\t\t\t// Logarithmic spiral\n    //return alpha+beta*(theta);\t\t\t\t\t// Archimede spiral\n}\n\n// f'\nfloat df(float theta, float alpha, float beta){\n    return alpha*pow(beta,theta) * log(beta);\t\t// Logarithmic spiral\n    //return beta;\t\t\t\t\t\t\t\t\t// Archimede spiral\n}\n\n// Offset to repeat the spiral\n#define OFFSET(K,ARM,N) float(K)*2.*PI + (float(ARM)/float(N))*2.*PI\n\nvoid drawSpiral(inout vec3 color, vec3 spiral_color, float thickness,\n                float rho, float theta, float alpha, float beta, float gamma,\n                int arm, int total_arms){\n    for(int k=-SPIRAL_SIZE; k<=SPIRAL_SIZE; k++)\n            color = mix(color,spiral_color,\n                        SMOOTH(rho - f(theta+gamma+OFFSET(k,arm,total_arms),alpha,beta),thickness));\n}\n\n//////////////////////////////////////////////\n///////////////////  MAIN  ///////////////////\n//////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = BLACK;\n    \n    // Centered normalized coordinates in [-1,1]\n    vec2 pixel = 2.*(fragCoord-floor(R.xy/4.)*2.) / R.y;\n    \n    if(FLIP)\n        pixel.y = -pixel.y;\n    \n    // Polar coords\n\tfloat rho = length(pixel),\n          theta = atan(pixel.y,pixel.x); // theta in [-PI,PI]\n    \n    \n    // Parameters of the spiral\n    float alpha,\t// zoom\n          beta,\t\t// warp\n    \t  gamma;\t// rotation\n    int\t  n;\t\t// number of arms\n    \n    // Tuning of the parameters\n    vec2 mouse = iMouse.xy;\n    if(InBLCorner(mouse)){\n        mouse = vec2(NSIN(iTime/100.),POW2(NCOS(iTime/6.)))*R.xy;\n\t}\n    alpha = DEF_ALPHA;\n    beta  =\t1. + POW2(mouse.y/R.y + .19)*3.;\n    gamma =\t(mouse.x/R.x)*2.*PI;\n        \n    n = DEF_N;\n    for(int i=1;i<=MAX_N;i++)\t// Num keys to change n\n        if(keyPress(48+i))\n            n = i;\n    \n    /////////////////////////\n    // Draw the white mesh\n    if(DO_WHITE_MESH){\n        /* Parallel mesh */\n        int n_parallel = n*WHITE_MESH;\n        for(int arm = 0; arm<n_parallel; arm++)\n            drawSpiral(color,GREY(.8),MESH_THICKNESS,rho,theta,alpha,beta,gamma,arm,n_parallel);\n        \n        /* Orthogonal mesh */\n        float beta_prime = exp(-1./log(beta));\n        int n_orth = int(round(float(n*WHITE_MESH)*ORTH_MESH_FACTOR));\n        for(int arm = 0; arm<n_orth; arm++)\n            drawSpiral(color,GREY(.8),MESH_THICKNESS,rho,theta,alpha,beta_prime,gamma,arm,n_orth);\n        \n        //drawSpiral(color,GREEN,MESH_THICKNESS,rho,theta,alpha,beta,gamma,5,n_parallel);\n        \n        /**\n        for(int arm1 = 0; arm1<n_parallel; arm1++)\n            for(int k1=-SPIRAL_SIZE; k1<1; k1++){\n                float theta1 = theta+gamma+OFFSET(k1,arm1,n_parallel);\n                for(int arm2 = 0; arm2<n_orth; arm2++)\n                    for(int k2=-3; k2<SPIRAL_SIZE; k2++){\n                \t\tfloat theta2 = theta+gamma+OFFSET(k2,arm2,n_orth);\n                        if(abs(f(theta1,alpha,beta) - f(theta2,alpha,beta_prime))<.02\n                          && abs(f(theta1,alpha,beta) - rho)<.02)\n                            color=BLUE;\n                    }\n            }\n        /**\n        int arm1=0,\n            k1=0,\n            arm2=0,\n            k2=0;\n        float theta1 = theta+gamma+OFFSET(k1,arm1,n_parallel),\n              theta2 = theta+gamma+OFFSET(k2,arm2,n_orth);\n        if(abs(f(theta1,alpha,beta) - f(theta2,alpha,beta_prime))<.02\n                          && abs(f(theta1,alpha,beta) - rho)<.02)\n                            color=BLUE;\n        /**/\n    }\n    /////////////////////////\n    \n    //if(pixel.x<0. && abs(pixel.y)<2./iResolution.y)\n    //color = RED;\n    \n    // Display parameters alpha,beta,gamma on top left\n    if(DISPLAY_PARAMS){\n\t\tvec2 pos ;\n        float scale = 0.06;\n        vec2 pixel_disp = fragCoord/R.y;\n        const vec3 display_color = LIGHT_BLUE;\n        // alpha\n        pos = vec2(.03*R.x,.92*R.y)/R.y;\n        if(display(pixel_disp, pos, scale, 0., alpha*100.))\n        \tcolor=display_color;\n        else{\n        \t// beta\n            pos.y -= scale*1.5;\n            if (display(pixel_disp, pos, scale, 0.,beta))\n                color=display_color;\n            else{\n                // gamma\n                pos.y -= scale*1.5;\n                if (display(pixel_disp, pos, scale, 0.,gamma))\n                    color=display_color;\n            }\n        }\n        \n        // FPS counter\n        scale = .03;\n        pos = vec2(.94*R.x,.95*R.y)/R.y;\n        if(display(pixel_disp, pos, scale, 0., iFrameRate))\n        \tcolor=display_color;\n\t}\n    \n    // Display reset zone\n    if(DISPLAY_RESET && InBLCorner(fragCoord)){\n        color = YELLOW;\n        if(InTriangle(fragCoord,vec2(6,12),vec2(18,4),vec2(18,20))\n           || abs(fragCoord.x - 6.) <= 2. && abs(fragCoord.y - 12.) <= 8.)\n            color = BLUE;\n    }\n    \n    if(DO_BULB){\n        #define BULB_R .1\n        #define BULB_COL vec3(.9,.9,.8)\n        float r = rho/BULB_R;\n        float bulb = exp(-r*r*r);\n        color = mix(color, BULB_COL,bulb);\n    }\n                        \n            \n    \n\n    fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// --- Digit display ----------------------------------------------------\n// Borrowed & slightly adapted from FabriceNeyret's\n//\t\thttps://www.shadertoy.com/view/ldjGWc\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat sevenSegment(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn sevenSegment(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot) {\n\tfloat point0 = float(dot/2),\n\t\t  point1 = float(dot)-2.*point0; \n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n\treturn 0.;\n}\n//    ... end of digits adapted from Andre\n\n#define STEPX .875\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\n\n// 2digit int + sign\nbool display(vec2 pixel, vec2 pos, float scale, float offset, int number, int dot){\n    // dot: draw separator\n\tvec2 uv = (pixel-pos)/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\t\n\tfloat seg = showNum(uv,number,false);\n\toffset += 2.;\n\t\n\tif (dot>0) {\n\t\tuv.x += STEPX*offset; \n\t\tseg += dots(uv,dot);\n\t\toffset += 2.;\n\t}\n\t_offset = offset;\n\treturn (seg>0.);\n}\n\n// 2.2 float + sign\nbool display(vec2 pixel, vec2 pos, float scale, float offset, float val) {\n    // dot: draw separator\n\tif (display(pixel, pos, scale, 0., int(val), 1))\n        return true;\n    if (display(pixel, pos, scale, _offset, int(fract(val)*100.), 0))\n        return true;\n\treturn false;\n}\n\n////////////////////////////////////////////////\n\n#define POW2(A) ((A)*(A))\n#define POW3(A) ((A)*(A)*(A))\n#define POW4(A) ((A)*(A)*(A)*(A))\n\n// Determines if p is in the triangle (v1,v2,v3).\n// v1,v2,v3 must be in counterclockwise order\nbool InTriangle (vec2 p, vec2 v1, vec2 v2, vec2 v3)\n{\n    return cross(vec3(p-v1,0),vec3(v2-v1,0)).z <= 0.\n        && cross(vec3(p-v2,0),vec3(v3-v2,0)).z <= 0.\n    \t&& cross(vec3(p-v3,0),vec3(v1-v3,0)).z <= 0.;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}