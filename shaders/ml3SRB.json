{
    "Shader": {
        "info": {
            "date": "1685572387",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable) - variable cube size in code",
            "flags": 0,
            "hasliked": 0,
            "id": "ml3SRB",
            "likes": 27,
            "name": "Year of Truchets #029",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 316
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #029\n    06/01/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define P9          1.57078\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    50.\n\n// globals\nfloat hspeed=0.,tspeed=0.,fspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\nvec3 hp=vec3(0),hitpoint=vec3(0);\nvec4 FC=vec4(.19,.22,.23,0);\nmat2 ra1,ra2,ra3,ra4;\n\n// consts for sizing (1-5 - more than that you'll need to move the camera back)\nconst float csize = 4.;\nconst float dsize = csize*4.;\nconst float xsize = dsize*2.;\nconst float psize = csize/2.;\nconst vec2[4] ps4 = vec2[4](vec2(-csize,-csize),vec2(-csize,csize),vec2(csize,csize),vec2(csize,-csize));\n\n// standard bag of tricks\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat ezin(float n) {n = n*n*n; return n;}\nfloat box(vec3 p, vec3 b) { vec3 q = abs(p) - b; return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\n// rotate from corner based on id\nvoid rov(inout vec2 q, int ct, mat2 ga){\n    q-=ps4[ct];\n    q*=ga;\n    q+=ps4[ct];\n}\n\n// truchet pattern\nvec3 getFace(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv)-.5;\n    float px = 12./R.x;\n    float rnd = hash21(id);\n    \n    if(rnd<.34) gv.x = -gv.x;\n    \n    vec2 d2 = vec2(length(gv-.5), length(gv+.5));\n    vec2 gx = d2.x<d2.y? vec2(gv-.5) : vec2(gv+.5);\n    float cx = length(gx)-.5;\n    float d5 = abs(max(abs(gv.x),abs(gv.y))-.5)-.005;\n    \n    if(rnd>.65) cx = min(length(gv.x)-.005,length(gv.y)-.005);\n\n    vec3 h = vec3(.0);\n    vec3 clr = hsv2rgb(vec3((uv.x+uv.y)*.15,1.,.5));\n    h = mix(h, clr,smoothstep(-px,px,abs(abs(cx)-.125)-.05));\n    h = mix(h, vec3(.5),smoothstep(-px,px,abs(cx)-.125));\n    h = mix(h, vec3(.1),smoothstep(px,-px,d5));\n    return h;\n}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p.x-=fspeed;\n    vec3 q = p-vec3(csize-1.);\n    \n    if(ga1>0.) rov(q.xy,0,ra1);\n    if(ga2>0.) rov(q.xy,1,ra2);\n    if(ga3>0.) rov(q.xy,2,ra3);\n    if(ga4>0.) rov(q.xy,3,ra4);\n\n    float d1 = box(q,vec3(csize)-.025)-.025;\n    if(d1<res.x) {\n        res=vec2(d1,1.);\n        hp=q;\n    }\n    \n    float d2 = p.y+1.;\n    if(d2<res.x) {\n        res=vec2(d2,2.);\n        hp=p;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n// low steps - its just a cube and a floor\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<100;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x*.85;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    float m =ray.y; d=ray.x;\n    \n    hitpoint=hp;\n\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        // light\n        vec3 lpos =vec3(-25.,15.,10.);\n        vec3 l = normalize(lpos-p);\n        // difused\n        float diff = clamp(dot(n,l),.09,.99);\n        // shadow\n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        // color\n        vec3 h = vec3(1.);\n        // texture - cube - floor\n        vec2 cuv; vec3 tn = n; int face = 0;\n        if(m==1.) {\n            // match rotation\n            if(ga1>0.) tn.xy*=ra1;\n            if(ga2>0.) tn.xy*=ra2;\n            if(ga3>0.) tn.xy*=ra3;\n            if(ga4>0.) tn.xy*=ra4;\n            \n            //@Shane https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using the normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n            // assign vec2 from hitpoint\n            if(face==0) cuv = hitpoint.zy+12.;\n            if(face==1) cuv = hitpoint.zx-8.;\n            if(face==2) cuv = hitpoint.xy;\n            if(face==3) cuv = hitpoint.yx-4.;\n            if(face==4) cuv = hitpoint.zx+24.;\n            if(face==5) cuv = hitpoint.zy+8.;\n\n            cuv*=.5;\n            cuv-=psize;\n            h = getFace(cuv);\n            ref = h*.4;\n        };\n        if(m==2.) {\n            cuv = p.xz-vec2(hspeed,0.)-1.;\n            h = getFace(cuv*.5);\n            ref = h*.8;\n        };\n        \n        C = (diff*h);\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    if(last>0.) C = mix(FC.rgb,C,exp(-.00008*d*d*d));\n    return vec4(C,d);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal \n    tspeed = T;\n    tmod = mod(tspeed,10.);\n    if(tmod==10.) { \n        // every loop move cube back\n        fspeed +=dsize;hspeed +=dsize;\n    } \n    // cube floor speed\n    fspeed = fract(T*.1)*xsize;\n    // texture speed\n    hspeed = (T*.1)*xsize;\n    \n    // timing\n    ga1 = ezin(lsp(0.,1.5,tmod));\n    ga2 = ezin(lsp(1.5,3.,tmod));\n    ga3 = ezin(lsp(3.,4.5,tmod));\n    ga4 = ezin(lsp(4.5,6.,tmod));\n\n    // rotation precal\n    if(ga1>0.) ra1 = rot(ga1*P9);\n    if(ga2>0.) ra2 = rot(ga2*P9);\n    if(ga3>0.) ra3 = rot(ga3*P9);\n    if(ga4>0.) ra4 = rot(ga4*P9);\n    \n    // standard setup uv/ro/rd\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(csize,-1.5,18.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse\n    float x = M.xy==vec2(0) || M.z <1. ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*2.25-1.125)*PI;\n\n    float ff = 1.5707+(.33*sin(T*.2));\n    mat2 rx = rot(-.52-x), ry = rot(-ff-y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC.rgb,C,exp(-.00008*a*a*a));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}