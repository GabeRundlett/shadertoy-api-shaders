{
    "Shader": {
        "info": {
            "date": "1510048992",
            "description": "adaptive quadtree floor tiling based on camera criterion.\nThe idea is to compute terrain data only in tiles (of constant resolution), and to keep the tiles in a LRU cache. \nEven in a very large domain, the number of tiles remains~constant and small.",
            "flags": 32,
            "hasliked": 0,
            "id": "Mt2cWG",
            "likes": 40,
            "name": "quadtree for adaptive terrain 2",
            "published": 3,
            "tags": [
                "short",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1420
        },
        "renderpass": [
            {
                "code": "// Adaptive quadtree floor tiling based on camera criterion. ( inspired from https://www.shadertoy.com/view/lljSDy )\n// NB: to be conservative, we should clip the screen proj rather than only test tile corners.\n// one more step from https://www.shadertoy.com/view/4t2cWG\n\n// --- raytrace use\n\n#define C(i) texelFetch(iChannel0,ivec2(i,0),0).xyz\n\n\nvoid mainImage( out vec4 O,  vec2 u )\n{    \n    vec2 R = iResolution.xy, P, A,\n    U = 1.3* (u+u-R)/R.y;\n    A = abs(U); float l = abs(max(A.x,A.y)-1.);\n  //O = texture(iChannel1, u/R); return;                    // show quadtree (for test)\n    \n    if ( l < 2./R.x) { O=vec4(1); return; }                 // camera border\n    vec3 p     = C(0),                                      // set camera geometry\n         d     = C(1), \n         right = C(2),\n         up    = C(3), r;\n\n    p = (p-.5)*.9+.5;                                       // why ? <><><>\n                                                            // --- ray\n  //r = mat3(right,up,d) * vec3((U+U-R)/R.y *.5*.5, 1);     // uh, I shouldn't have included fov in mat\n    r = vec3(U, 1) * inverse(mat3(right,up,d));             // uh, because I included fov in mat\n  //r = normalize(r);    // useless\n    l = - p.z/r.z;\n    P = (p + l *r).xy;                                      // floor intersection\n    P *= R.y/R;\n    \n    A = abs(P-.5);                                          // to clamp floor texture to black\n    O = l>=0. && max(A.x,A.y) < .5 ? texture(iChannel1, P) : O-O; // display floor\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --- camera management\n\nvoid mainImage( out vec4 O,  vec2 U )\n{    \n    if (U.y >= 1. || U.x >= 4.) return;\n    \n    float T = iTime, fov = .5;\n    \n    vec3  p     = vec3(.5+.5*cos(T),.5+.5*sin(T),.1),   // stored in (0,0)\n          d     = normalize(vec3(-cos(T),-sin(T),-.3)), // stored in (1,0)\n          right = normalize(vec3(d.y,-d.x,0)),          // stored in (2,0)\n          up    = cross(right,d);                       // stored in (3,0)\n    right /= fov; up /= fov;\n    \n    int i = int(U.x);\n    O.xyz = i==0 ? p : i==1 ? d : i==2 ? right : up;\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --- quadtree management\n\n// Adaptive quadtree floor tiling based on camera criterion. ( inspired from https://www.shadertoy.com/view/lljSDy )\n// NB: to be conservative, we should clip the screen proj rather than only test tile corners.\n// old version of https://www.shadertoy.com/view/4t2cWG\n\n#define T iTime\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n#define C(i) texelFetch(iChannel0,ivec2(i,0),0).xyz\n\nvec3 p,d, right, up;                              // camera pos + matrix\n\nfloat lod(vec2 P, float r) {\n    vec3 Vs = vec3(-P/r,p.z) * mat3(right,up,d);  // screen frame\n    vec2 S = abs(Vs.xy/Vs.z);                     // perspective \n    if (max(S.x,S.y)>1. || Vs.z < 1.) return 0.;  // out of frustum\n    return 7.-log2(Vs.z);                         // lod ( 0 = coarsest )\n}\n\nvoid mainImage( out vec4 o,  vec2 U )\n{    \n    o -= o;\n    float r=.09, H = iResolution.y;       // why this r value ?  <><><>\n    U /=  H;                             \n\n    p     = C(0);   // set camera geometry\n    d     = C(1); \n    right = C(2);\n    up    = C(3);\n    \n    vec2 P = p.xy, fU;                    // camera xy projection ( ugly parameter transmission )\n\n    U*=.5; P*=.5;                         // unzoom for the whole domain falls within [0,1]^n\n    \n    o.b = .25;                            // backgroud = cold blue\n    \n    for (int i=0; i<9 -int(H<200.); i++) {             // to the infinity, and beyond ! :-)\n        fU = min(U,1.-U); if (min(fU.x,fU.y) < 2.8*r/H) { o--; break; } // cell border\n#if 0\n        if (lod(P-.5, r) < float(i)) break; // cell is out of the shape (eval at tile center)\n#else\n        if (max(lod(P-.5, r), \n       // if ((\n            max( max(lod(P          ,r), lod(P-vec2(1,0),r)),\n                 max(lod(P-vec2(0,1),r), lod(P-vec2(1,1),r))\n                ))  < float(i)) break;    // cell is out of the shape (eval at tile corners)\n#endif\n                // --- iterate to child cell\n        fU = step(.5,U);                  // select child\n        U = 2.*U - fU;                    // go to new local frame\n        P = 2.*P - fU;  r *= 2.;\n        \n        o += .13;                         // getting closer, getting hotter\n    }\n               \n\to.r *= lod(P-U,r);                    // draw lod\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}