{
    "Shader": {
        "info": {
            "date": "1512736449",
            "description": "Lord of the Rings - One Ring to rule them all.\nThe inscription is a nice side effect of how surface noise works - a cool improvement would be to map a buffer with proper Black Speech glyphs.",
            "flags": 64,
            "hasliked": 0,
            "id": "4tfBRf",
            "likes": 70,
            "name": "The One Ring",
            "published": 3,
            "tags": [
                "sdf",
                "hell",
                "ring",
                "sauron",
                "lotr",
                "gold"
            ],
            "usePreview": 0,
            "username": "k_kondrak",
            "viewed": 6800
        },
        "renderpass": [
            {
                "code": "// ----------------------------------------------------\n//  \"The One Ring\" by Krzysztof Kondrak @k_kondrak\n// ----------------------------------------------------\n\n// enable/disable AA\n#define ANTIALIASING 1\n#define AA_SAMPLES 2\n#define AA_WIDTH .8\n\n#define FOV 5.5\n#define RING_RADIUS 1.5\n\n// raymarching constants\n#define MIN_DIST  .001\n#define MAX_DIST  30.\n#define NUM_STEPS 100\n#define BACKGROUND_ID 0\n#define RING_ID       1\n\n// Gold color: https://www.shadertoy.com/view/XdVSRV\nconst vec3 GOLD1 = vec3(1.1,  0.91, 0.52);\nconst vec3 GOLD2 = vec3(1.1,  1.07, 0.88);\nconst vec3 GOLD3 = vec3(1.02, 0.82, 0.55);\n\n// initial eye/camera position\nvec3 EYE = vec3(7.5, 0., 0.);\n\n// helper struct to collect raymarching data\nstruct RMInfo\n{\n  \tvec3 pos;\n  \tvec3 normal;\n  \tint  objId;\n};\n\n// ------------------\n//  1D hash function\n// ------------------\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// ----------------------------------------------\n//  noise: https://www.shadertoy.com/view/4sfGzS\n// ----------------------------------------------\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\t\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n// -----------------\n//  vector rotation\n// -----------------\nvec2 rotate(vec2 v, float a)\n{\n    return vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a));\n}\n\n// --------------------\n//  \"noisy\" gold color\n// --------------------\nvec3 Gold(vec3 p)\n{\n    p += .4 * noise(p * 24.);\n    float t = noise(p * 30.);\n    float fade = max(0., sin(iTime * .3));\n\n    vec3 gold = mix(GOLD1, GOLD2, smoothstep(.55, .95, t));\n    gold = mix(gold, GOLD3, smoothstep(.45, .25, t));\n\n\t// Glowing \"black speech\" inscription on the ring.\n    // Flicker depends on the current audio value.\n    if(p.y > .18 && p.y < .23)\n    {\n    \tgold +=  8. * fade * vec3(1., .3, 0.) * (1. + 10. * texture(iChannel1, vec2(50., 0.)).r);\n    }\n\n    // darker gold tint if the inscription is visible\n    gold *= (1. - 0.666 * fade);\n\n    return gold;\n}\n\n// ----------------------------------------\n//  calculate ray direction for eye/camera\n// ----------------------------------------\nvec3 EyeRay(vec2 fragCoord, vec3 eyeDir)\n{\n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv * 2.0 - 1.0;\n  \tuv.x *= iResolution.x / iResolution.y;\n\n    vec3 forward = normalize(eyeDir);\n\tvec3 right   = normalize(cross(vec3(.0, 1., .0), forward));\n\tvec3 up      = normalize(cross(forward, right));    \n\n\treturn normalize(uv.x * right + uv.y * up + forward * FOV);\n}\n\n// ----------------------------------------------\n//  SDF for the ring - a slightly deformed torus\n// ----------------------------------------------\nfloat Ring(vec3 pos)\n{\n    vec2 t = vec2(RING_RADIUS, RING_RADIUS * .2);\n    vec2 q = vec2(clamp(2. * (length(pos.xz) - t.x), -5., 5.),pos.y);\n\n    return length(q) - t.y;\n}\n\n// -------------------------------\n//  flickering hellish background\n// -------------------------------\nvec3 Background(vec3 ray)\n{ \n    return texture(iChannel2, ray).rgb * vec3(.7, .15, .0) * (1. + texture(iChannel1, vec2(0., 0.)).r);\n}\n\n// ----------------\n//  surface normal\n// ----------------\nvec3 SurfaceNormal(in vec3 pos)\n{\n    vec3 eps = vec3( MIN_DIST, 0., 0. );\n    return normalize(-vec3(Ring(pos + eps.xyy) - Ring(pos - eps.xyy),\n                           Ring(pos + eps.yxy) - Ring(pos - eps.yxy),\n                           Ring(pos + eps.yyx) - Ring(pos - eps.yyx)));\n}\n\n// ------------------\n//  scene raymarcher\n// ------------------\nRMInfo Raymarch(vec3 from, vec3 to)\n{\n    float t = 0.;\n    int objId = BACKGROUND_ID;\n    vec3 pos;\n    vec3 normal;\n    float dist;\n    \n  \tfor (int i = 0; i < NUM_STEPS; ++i)\n    {\n    \tpos = from + to * t;\n        dist = Ring(pos);\n\n        if (dist > MAX_DIST || abs(dist) < MIN_DIST)\n            break;\n\n        t += dist * 0.43;\n        objId = RING_ID;\n  \t}\n    \n    if (t < MAX_DIST)\n    {\n        normal = SurfaceNormal(pos);\n    }\n    else\n    {\n        objId = BACKGROUND_ID;\n    }\n\n    return RMInfo(pos, normal, objId);\n}\n\n\n// -------------------------\n//  here be scene rendering\n// -------------------------\nvec4 Draw(vec2 fragCoord)\n{   \n    vec3   col = vec3(0.);\n  \tvec3   ray = EyeRay(fragCoord, -EYE);\n  \tRMInfo rmi = Raymarch(EYE, ray);\n\n    if (rmi.objId == RING_ID)\n    {\n        col = mix(col, Gold(rmi.pos) * texture(iChannel0, reflect(ray, rmi.normal)).rgb, .99);            \n        rmi = Raymarch(rmi.pos, reflect(ray, rmi.normal));\n    }\n    else if(rmi.objId == BACKGROUND_ID)\n    {\n        col += Background(ray);\n    }\n\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    EYE.xy = rotate(EYE.xy, iTime * .03 + .015);\n    EYE.yz = rotate(EYE.yz, iTime * .03 + .015);\n\n    // Antialiasing: https://www.shadertoy.com/view/XdVSRV\n#if ANTIALIASING\n    vec4 vs = vec4(0.);\n    for (int j = 0; j < AA_SAMPLES ;j++)\n    {\n        float oy = float(j) * AA_WIDTH / max(float(AA_SAMPLES - 1), 1.);\n        for (int i = 0; i < AA_SAMPLES; i++)\n        {\n            float ox = float(i) * AA_WIDTH / max(float(AA_SAMPLES - 1), 1.);\n            vs += Draw(fragCoord + vec2(ox, oy));\n        }\n    }\n\n    fragColor = vs/vec4(AA_SAMPLES * AA_SAMPLES);\n#else\n    fragColor = Draw(fragCoord);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 12733,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/dnd-music-444515068/sauron-voice-black-speech"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}