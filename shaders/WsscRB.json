{
    "Shader": {
        "info": {
            "date": "1585052569",
            "description": "We've had the nine point circle: [url]https://www.shadertoy.com/view/tsfcDr[/url], this is the nine point conic, described by Maxime Bôcher in 1892. Also see the eleven point conic: [url]https://www.shadertoy.com/view/lt2BD3[/url].\n\nMouse selects P.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsscRB",
            "likes": 8,
            "name": "Nine Point Conic",
            "published": 3,
            "tags": [
                "conic",
                "ninepoint"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 349
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Nine Point Conic\n// Matthew Arcus, 2020.\n//\n// Given a triangle ABC and a point P, can draw a conic between:\n// The midpoints of the triangle sides\n// The midpoints of the lines from P to each vertex\n// The points where these lines cut the sides of the triangle\n//\n// Mouse controls position of P.\n//\n// First described by Maxime Bôcher in 1892.\n//\n// The conic changes from ellipse to hyperbola when it crosses one of\n// the extended triangle sides, and becomes a circles when P coincides\n// with the orthocentre (intersection of altitudes - the cyan lines).\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// The midpoint between p and q (also conjugate with point at infinity)\nvec3 midpoint(vec3 p, vec3 q) {\n  return p*q.z + p.z*q;\n}\n\nfloat distance2(vec3 p, vec3 q) {\n  p /= p.z; q /= q.z;\n  return abs(dot(p-q,p-q));\n}\n\n// Perpendicular bisector (a line)\nvec3 bisector(vec3 p,vec3 q) {\n  // (p-r).(p-r) = (q-r).(q-r) // r equidistant from p and q\n  // pp - 2pr + rr = qq - 2qr + rr\n  // pp - qq = 2pr - 2qr\n  // 2r.(p-q) = pp - qq\n  p /= p.z; q /= q.z;\n  return vec3(2.0*(p.xy-q.xy),dot(q,q)-dot(p,p));\n}\n\n// Drop perpendicular from p onto line q.\nvec3 perpendicular(vec3 p, vec3 q) {\n  // (p + kq.xy).q = 0\n  // p.q + k(q.yx).q = 0\n  float k = dot(p,q)/dot(q.xy,q.xy);\n  return p - k*vec3(q.xy,0);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 solve(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  vec3 p4a = p*p4;\n  float a = p4a.x, b = p4a.y, c = p4a.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  mat3 res = transpose(p)*m*p;\n  return res;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z; // normalize\n  vec3 pa = p-q;\n  vec3 ba = r-q;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n  float d = length(pa-h*ba);\n  return d;\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nfloat circle(vec3 p, vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return conic(p,mat3(1,0,-q.x,\n                      0,1,-q.y,\n                     -q.x,-q.y,dot(q.xy,q.xy)-r2));\n}\n\nfloat quad(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n  float t = 1e8;\n  t = min(t,segment(p,a,b));\n  t = min(t,segment(p,b,c));\n  t = min(t,segment(p,c,d));\n  t = min(t,segment(p,d,a));\n  return t;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvoid getmin(inout float d, inout int index, int i, float t) {\n  if (t < d) { d = t; index = i; }\n}\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,0,1),\n         vec3(0,0.8,0),\n         vec3(0,1,1),\n         vec3(0.8),\n         vec3(1,0,1),\n         vec3(1,1,1)\n         );\n\nvec3 getcol(int i) {\n  return colors[i];\n}\n\nvec3 diagram(vec3 p, vec3 P) {\n  vec3 pcol = vec3(0.3);\n  float lwidth = 0.005;\n  float dwidth = 1.5*fwidth(p.x/p.z);\n  float pwidth = 0.03;\n  // The triangle (P is parameter)\n  vec3 A = vec3(1.0,1.0,1), B = vec3(-1.5,-0.5,1), C = vec3(1,-1,1);\n  vec3 AB = join(A,B), BC = join(B,C), CA = join(C,A);\n  vec3 PA = join(P,A), PB = join(P,B), PC = join(P,C);\n  vec3 mBC = midpoint(B,C), mCA = midpoint(C,A), mAB = midpoint(A,B);\n  vec3 mPA = midpoint(P,A), mPB = midpoint(P,B), mPC = midpoint(P,C);\n  vec3 aA = join(PA,BC), aB = join(PB,CA), aC = join(PC,AB);\n  vec3 pA = perpendicular(A,BC);\n  vec3 pB = perpendicular(B,CA);\n  vec3 pC = perpendicular(C,AB);\n  vec3 H = join(join(A,pA),join(B,pB));\n  mat3 X = solve(mAB,mBC,mCA,mPA,mPB);\n\n  vec3 bA = bisector(A,B);\n  vec3 bB = bisector(B,C);\n  // Intersect at the circumcentre\n  vec3 O = join(bA,bB);\n  // centre of the circumcircle.\n  vec4 C1 = vec4(O,distance2(O,A));\n  \n  float d = 1e8;\n  int index = -1;\n  getmin(d,index,0,line(p,AB));\n  getmin(d,index,0,line(p,BC));\n  getmin(d,index,0,line(p,CA));\n\n  getmin(d,index,1,line(p,PA));\n  getmin(d,index,1,line(p,PB));\n  getmin(d,index,1,line(p,PC));\n\n  getmin(d,index,4,line(p,A,pA));\n  getmin(d,index,4,line(p,B,pB));\n  getmin(d,index,4,line(p,C,pC));\n\n  if (false) {\n    getmin(d,index,3,quad(p,mAB,mCA,mPC,mPB));\n    getmin(d,index,3,quad(p,mBC,mAB,mPA,mPC));\n    getmin(d,index,3,quad(p,mCA,mBC,mPB,mPA));\n  }\n  getmin(d,index,2,conic(p,X));\n  getmin(d,index,5,circle(p,C1));\n\n  vec3 col = vec3(1,1,0.8);  \n  col = mix(0.9*getcol(index),col,smoothstep(lwidth,lwidth+dwidth,d));\n  d = 1e8;\n  getmin(d,index,0,point(p,P));\n\n  getmin(d,index,0,point(p,A));\n  getmin(d,index,0,point(p,B));\n  getmin(d,index,0,point(p,C));\n\n  getmin(d,index,0,point(p,mBC));\n  getmin(d,index,0,point(p,mCA));\n  getmin(d,index,0,point(p,mAB));\n\n  getmin(d,index,0,point(p,mPA));\n  getmin(d,index,0,point(p,mPB));\n  getmin(d,index,0,point(p,mPC));\n  \n  getmin(d,index,0,point(p,aA));\n  getmin(d,index,0,point(p,aB));\n  getmin(d,index,0,point(p,aC));\n\n  getmin(d,index,0,point(p,H));\n  \n  col = mix(pcol,col,smoothstep(pwidth,pwidth+dwidth,d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 2.0;\n  vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1.0);\n  vec3 P = iMouse.x <= 0.0 ? vec3(-0.1,-0.1,1)\n    : vec3(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y,1);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}