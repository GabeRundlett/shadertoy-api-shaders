{
    "Shader": {
        "info": {
            "date": "1458314969",
            "description": "amiga, rm",
            "flags": 64,
            "hasliked": 0,
            "id": "MdcXR7",
            "likes": 13,
            "name": "â™« Boing ball.",
            "published": 3,
            "tags": [
                "amiga",
                "rm"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 746
        },
        "renderpass": [
            {
                "code": "/**\n *\n * My chrome extension for Shadertoy:\n * \n * http://bit.ly/shadertoy-plugin \n * \n */\n\n//getNormalHex or getNormalCube\n#define getNormal getNormalHex\n\n#define rgb(r, g, b) vec3(float(r), float(g), float(b)) / 255.\n\n#define FAR 50.\n#define time iTime\n#define mt iChannelTime[1]\n#define FOV 130.0\n#define FOG 0.95\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n//rotate \nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// http://mercury.sexy/hg_sdf/\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nstruct rm {\n    float dist;\n    vec2 material;\n    vec3 space;\n};\n\n//union\nrm rmU(rm g1, rm g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nrm map(vec3 p) {\n    \n    rm \n        scene,\n        objBall,\n        objFloor = objBall;\n    \n    vec3 orgP = p;\n\n    // floor\n    float matDetail = 1.0;\n    float mat = 2.0;\n\n    p.y += 4.0;\n    \n    objFloor.dist = fBox(p, vec3(100., 0.1, 100.)); \n    objFloor.material = vec2(mat, matDetail);\n    objFloor.space = p;                 \n    //floor end\n    \n    p = orgP;\n\t\n    //ball\n    float x = pModInterval1(p.x, 1.5, 2., 10.);\n    float z = pModInterval1(p.z, 2.0, -15., 10. );\n\n    p = orgP;\n    \n    p.y = orgP.y * (1. + sin(time * 5.) / 5.);\n    p.y = p.y + sin(time * 5.) * 1.5 + .9;\n    \n    \n    pR(p.xy,(time * 2.));\n    \n    p.x += fract(time / 60. / 120. + 4.);\n    \n    float rzx = pModPolar(p.zx, 14.);\n    float ryz = pModPolar(p.yz, 14.);\n\n    pModPolar(p.yx, 24. - sin(time / 2.4) * 10.);\n    \n    p.y -= 2.2;\n    \n    objBall.dist = fBox(p, vec3(0.5));\n    objBall.material = vec2(1., rzx - ryz + 1.);\n    objBall.space = p;\n    \n    \n    scene = rmU(objFloor, objBall); \n\tscene = rmU(scene, objFloor);\n    \n    return scene;\n}\n\n\nrm trace(vec3 ro, vec3 rd) {\n    rm t;\n    rm d;\n    float dist = 0.;\n    \n    for (int i = 0; i < 48; i++) {\n        d = map(ro + rd * dist);\n        dist += d.dist;\n\t\t\n        if (abs(d.dist) < 0.025 || d.dist > FAR) break;\n    }\n    t.material = d.material;\n    t.dist = dist;\n    return t;\n}\n\nrm traceRef(vec3 ro, vec3 rd) {\n    rm t;\n    rm d;\n    float dist = 0.;\n    \n    for (int i = 0; i < 24; i++) {\n        d = map(ro + rd * dist);\n        dist += d.dist;\n\t\t\n        if (abs(d.dist) < 0.025 || d.dist > FAR) break;\n    }\n    t.material = d.material;\n    t.dist = dist;\n    return t;\n}\n\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).dist - map( pos - delta.xyy ).dist;\n   n.y = map( pos + delta.yxy ).dist - map( pos - delta.yxy ).dist;\n   n.z = map( pos + delta.yyx ).dist - map( pos - delta.yyx ).dist;\n   \n   return normalize(n);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, rm obj) {\n    \n    vec3 col = vec3(.0);\n    \n    if (obj.material.x == 2.0) {\n        col = rgb(111,92,147);\n        p.x += -time * 5.;\n        p.xz /= 4.;\n        p.xz = sin(p.xz * 6.3);\n        col += ceil(p.x * p.z);\n    }\n    \n    if (obj.material.x == 1.0) {\n        if (mod(obj.material.y, 2.) < 1.) {\n            col = vec3(2.);   \n        } else {\n            col = vec3(1., 0., 0.);   \n        }\n    }\n    \n    if (obj.material.x == 3.0) col = rgb(111,92,147) / 2.;\n    \n    return col ;\n}\n\n\n// https://www.shadertoy.com/view/4dt3zn\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, rm obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 2.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 1.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .2);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvec3 sky(vec3 rd) {\n    vec3 col = rgb(111,92,147);\n    \n    vec2 uv = vec2(\n        .5 + atan(rd.z, rd.x) / 2. * PI,\n        0.// .5 + asin(rd.y) / 2. * PI\n        );\n\t\n    return col * (.3 + 2. * pow(texture(iChannel0, mod(uv / 10., 1.)).r * 1.2, 3.)) ;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\n    uv *= tan(radians (FOV) / 2.0);\n    \n    float \n        sk = sin(time * .8) * 8.0,\n        ck = cos(time * .8) * 6.0,        \n        mat = 0.;\n    \n    vec3 \n        sn,\n        light = vec3(7., 10., -10.),        \n\t\tsceneColor = vec3(0.0),\n    \n    \t// camera\n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(ck, 5. , sk), // pos\n    \tvrp =  vec3(0., .0, 0.) , // lookat    \n\t\tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n        \n    \trd = normalize(scrCoord - ro);\n\n\trm tr = trace(ro, rd);    \n    ro += rd * tr.dist;\n    \n    float fog = smoothstep(FAR * FOG, 0., tr.dist);\n    \n    if (tr.dist < FAR) {\n        \n\t    sn = getNormal(ro);\n        \n        sceneColor += doColor(ro, rd, sn, light, tr) * 1.;\n        \n        rd = reflect(rd, sn);\n        tr = trace(ro + rd * .1, rd);\n        \n        if (tr.dist < FAR) {\n            \n            ro = ro + rd * tr.dist;\n            //sn = getNormal(ro);\n            sceneColor += abs(doColor(ro, rd, sn, light, tr) ) * .4;\n            \n        }\n    }       \n    \n    sceneColor = mix(sky(rd), sceneColor, fog);\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0); \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 2458,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/demoscenedelights/pink-acid-pop"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}