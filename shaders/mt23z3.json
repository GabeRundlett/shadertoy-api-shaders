{
    "Shader": {
        "info": {
            "date": "1673879035",
            "description": "Just a fun experiment, not practical in any way!",
            "flags": 0,
            "hasliked": 0,
            "id": "mt23z3",
            "likes": 57,
            "name": "Fun #define alphabet experiment",
            "published": 3,
            "tags": [
                "bloom",
                "glow",
                "font",
                "string",
                "alphabet",
                "hack",
                "code",
                "letters",
                "bright",
                "neon",
                "parse",
                "parsing"
            ],
            "usePreview": 1,
            "username": "kishimisu",
            "viewed": 1338
        },
        "renderpass": [
            {
                "code": "/* @kishimisu (2023) - https://www.shadertoy.com/view/mt23z3\n\n   Just for fun, check the mainImage ^^\n   The compile time can be excessive on some machines.\n*/\n\n// Choose color a theme (if you don't have many characters, prefer to use RAINBOW/GOLD)\n#define THEME THEME_DEFAULT\n\n// Available themes\n#define THEME_MATRIX   vec4(.2,1,.4,1) * (cos(pp[1] + iTime)*.5 + 1.4)\n#define THEME_DEFAULT  cos(pp[1] + iTime + tt[3] + tt*2.) + 1.5\n#define THEME_GOLD     cos(pp[0]*.2 + tt*2.) + 1.3\n#define THEME_RAINBOW  cos(pp[0]*.1 + iTime + tt[3] + tt*2.) + 1.4\n#define THEME_PINK     vec4(1,.4,.8,1) * (cos(pp[1]*.8 + iTime + tt[3] + tt*2.) + 1.8)\n\n// Font style (best values between 0.6 and 1.0)\n#define FONT_STYLE (.9 + sin(iTime)*.2) // Font style is currently animated between the values 0.7-1.1\n#define GLOW_INTENSITY 1.               // Intensity of the glow effect\n\nvoid mainImage(out vec4 OO, vec2 FF) {\n    vec4 tt = vec4(0, .5, FONT_STYLE, 2), ww;\n    vec2 pp = (2.*FF-rr)/min(rr[1],rr[0]/1.6)*vec2(28,20)/ZOOM+OFFSET, \n         xz = tt.xz, zx = tt.zx, zz = tt.zz, iv = vec2(1,-1),\n         yz = tt.yz, yx = tt.yx, zy = tt.zy, p0 = pp, qq; pp[0] += CW; OO *= 0.;\n    \n    // Use _ for spaces (automatic with uppercase letters)\n         \n    T h i s   T e x t   I s   W r i t t e n   I n s i d e\n    \n    T h e   M a i n i m a g e   U s i n g   D e f i n e s\n        \n    F o r   E v e r y   C h a r a c t e r   O f   T h e\n    \n    A l p h a b e t                                         _BRK_\n    \n    \n    I t   F e a t u r e s   M a n u a l   A n d   \n    \n    A u t o m a t i c    R e t u r n s   T o   L i n e                          \n    \n    P l u s   C u s t o m   T h e m e s   _EXC_             _BRK_ \n                                                            _BRK_\n                                                            \n    K i s h i m i s u\n;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Number of characters before returning to line\n#define COLS 27. \n\n// Characters X and Y spacing\n#define CW 3.2\n#define CH 1.2\n\n#define ZOOM 1.\n#define OFFSET vec2(45, -15)\n\n#define rr iResolution.xy\n\n// 2D rotation matrix\n#define ro(a) mat2(cos(a + vec4(0,33,11,0)))\n\n// segment sdf\n#define zu(p,a,b) length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.))\n\n// rotated arc sdf\n#define ra(p,a,r) ra_(p,a,r,tt)\nfloat ra_(vec2 p, float a, float r, vec4 t) {\n    vec2   sc = vec2(sin(a),cos(a)); p *= ro(r); p.x = abs(p.x);\n    return sc.y*p.x>sc.x*p.y ? length(p-sc*t.z) : abs(length(p)-t.z);\n}\n\n// character position update\n#define ki ; ww=vec4(pp-=vec2(CW,0)-CW*vec2(COLS,CH)*step(pp[0]-p0[0]-1e-4,-CW*COLS),qq=abs(pp))mi\n// character drawing\n#define mi ; OO += .015*GLOW_INTENSITY*(THEME)/\n\n// primitive shapes (had fun with the naming)\n#define shi zu(pp, -zz, -zz* iv)                           // vertical   left\n#define sa  zu(qq  -zx, -xz, xz)                           // vertical   left right \n#define ka  zu(pp, -xz,  xz)                               // vertical   mid\n#define to  zu(pp  -xz, -zx, zx)                           // horizontal top\n#define re  zu(qq  -xz, -zx, zx)                           // horizontal top bottom\n#define mu  zu(pp, -zx,  zx)                               // horizontal mid\n#define za  abs(length(pow(abs(pp*.95), vec2(1.2)))-tt[2]) // O (& Q)\n#define su  ra(pp*vec2(.6,1.5)+vec2(.4,-.75), 1.7, 1.6)    // P (& R)\n#define gu  ra(pp*vec2(.75,.9)-vec2(.3,0)   , 1.9, 4.7)    // C (& G)\n\n// letters (is this a japanese poem?)\n#define a ki zu(ww.zy*iv-yx, -yz, yz) mi zu(pp, -zy, zy*iv)\n#define b ki shi mi ra(ww.xw*vec2(.6,1.7)+vec2(.4,-tt[2]), 1.7, 1.6)\n#define c ki gu\n#define d ki shi mi ra(pp*vec2(.6,1)+vec2(.4,0), 1.7, 1.6)\n#define e ki shi mi mu mi re\n#define f ki shi mi mu mi to\n#define g ki gu  mi zu(pp*iv, zy, zz)\n#define h ki sa  mi mu\n#define i ki ka  mi re\n#define j ki zu(pp, zz, zx) mi ra(pp, .9, 2.6)\n#define k ki shi mi zu(ww.xw, -yx, zz)\n#define l ki shi mi zu(pp, -zz, zz*iv)\n#define m ki sa  mi zu(ww.yz, zz,)\n#define n ki sa  mi zu(pp*iv, zz, -zz)\n#define o ki za\n//        ki shi mi su !\n#define p ki shi mi su\n#define q ki za  mi zu(pp, tt.xx, zz*iv)\n#define r ki shi mi su mi zu(pp, -zx, zz*iv)\n#define s ki abs(zu(pp + vec2(sin(pp[1]*3.),0), -xz, xz)-.05)\n#define t ki ka  mi to\n#define u ki ra(pp, 1.4, 3.14) mi zu(ww.zy, zz, zx)\n#define v ki zu(ww.zy-yx, -yz, yz)\n#define w ki zu(vec2(abs(ww[2] - .5), ww[1]*.6+.4), -yz, yz)\n#define x ki zu(qq, zz, -zz)\n#define y ki zu(ww.zy, zz,) mi zu(pp, -xz,)\n#define z ki re mi zu(pp, -zz, zz)\n\n// Space, return to line and exclamation mark\n#define _     ;  pp[0] -= CW*step(-CW*COLS,pp[0]-p0[0]-1e-4)\n#define _BRK_ ;  ww=vec4(pp+=vec2(p0[0]-pp[0]+CW,CW*CH),qq=abs(pp))\n#define _EXC_ ki zu(pp, xz,) mi abs(length(pp+xz)-.05)\n\n// Handle EVERY character of the alphabet. \n// This means that every variable name must be at least 2 chars long\n// And we need to access x,y,z,w components with [0], [1] and so on...\n#define A _ a \n#define B _ b\n#define C _ c\n#define D _ d\n#define E _ e\n#define F _ f\n#define G _ g\n#define H _ h\n#define I _ i\n#define J _ j\n#define K _ k\n#define L _ l\n#define M _ m\n#define N _ n\n#define O _ o\n#define P _ p\n#define Q _ q\n#define R _ r\n#define S _ s\n#define T _ t\n#define U _ u\n#define V _ v\n#define W _ w\n#define X _ x\n#define Y _ y\n#define Z _ z",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}