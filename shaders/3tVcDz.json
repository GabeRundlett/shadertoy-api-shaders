{
    "Shader": {
        "info": {
            "date": "1610828916",
            "description": "Raymarching w/ ray origin and direction transformed to world model.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tVcDz",
            "likes": 4,
            "name": "Raymarch and simple camera",
            "published": 3,
            "tags": [
                "raymarchcamera"
            ],
            "usePreview": 0,
            "username": "tombla",
            "viewed": 762
        },
        "renderpass": [
            {
                "code": "// Raymarch V6: Checkerboard and moving camera.\n\n#define LIGHT_CHECKER  vec3(1., 0.8, 0.)\n#define DARK_CHECKER   vec3(0., 0.5, 0.)\n#define ZERO_CHECKER vec3(1., 0., 0.)\n#define SKY vec3(0., 0., 1.)\n#define AA  2\n#define AAR 0.5\n\n#define PLANE_POS -1.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define CLOSENESS 0.01\n\nvec2 scale2(in vec2 uv) {\n    vec2 R = iResolution.xy;\n    return vec2((uv - 0.5 * R) / min(R.x, R.y));\n}\n\nvec2 rot2(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec3 checker(in vec2 uv, in float size) {\n    uv /= size;\n    if (max(abs(uv.x), abs(uv.y)) < .5) {\n        return ZERO_CHECKER;\n    }\n    vec2 f = floor(uv);\n    float isLight = mod(f.x + f.y, 2.);\n    return mix(DARK_CHECKER, LIGHT_CHECKER, isLight);\n}\n\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\nvec2 planeSdf(in vec3 uv) {\n    return vec2(uv.y - PLANE_POS, 1.);\n}\n\nvec2 ballSdf(in vec3 uv) {\n    uv.y /= 2.1;\n    vec3 ball = vec3(-5., 2., 0.5);\n    float r = 2.1;\n    return vec2(length(uv - ball) - r, 2.);\n}\n\n// @return distance (x) and id(y)\nvec2 sceneSdf(in vec3 uv) {\n  vec2 p = planeSdf(uv);\n  vec2 b = ballSdf(uv);\n  if (b.x < p.x) {\n      return b;\n  }\n  return p;\n}\n\nfloat rayMarch(vec3 origin, vec3 direction) {\n    float dist = 0.;\n    for(int i=0; i < MAX_STEPS; ++i) {\n        vec3 ray = origin + direction * dist;\n        float step = sceneSdf(ray).x;\n        dist += step;\n        if (step < CLOSENESS || dist > MAX_DIST) break;\n    }\n    return min(dist, MAX_DIST);\n}\n\nvec4 image(in vec2 uv) {\n    uv = scale2(uv); // scale to -1..1 on shorter axis.\n    float T = iTime;\n    vec3 eye = vec3(5., 20.+18.*sin(T/4.), 20.*sin(T)),\n         target = vec3(0., 0., 0.),\n         // This is projection (direction) of an eye at (0,0,-1) to (-1..1, -1..1, 0) plane.\n         // We'll transform it later according to eye/target/roll.\n         projection = vec3(uv.x, uv.y, 1.);\n    float roll = 0.*sin(iTime);\n    mat3 L = calcLookAtMatrix(eye, target, roll);\n    // Ray origin and direction.\n    vec3 ro = eye;\n    vec3 rd = normalize(L * projection); \n    // Distance to a shape.\n    float dist = rayMarch(ro, rd);\n    // Point at the shape\n    vec3 ray = ro + rd * dist;   \n    float skyMix = smoothstep(MAX_DIST * 0.6, MAX_DIST * 0.8, dist);\n    vec3 color = checker(ray.xz, 2.) * smoothstep(16., 0., ray.y);\n    // Final color\n    vec3 final = mix(color, SKY, skyMix); \n    return vec4(final, 1.);\n}\n\nvec4 antiAlias(in vec2 uv) {\n  vec4 O = vec4(0);\n  float S = 1./float(AA * AA),  // scale\n        d = 0.2 * sin(uv.x * 415.678  + uv.y * 303.1415), // dither AA sampling\n        r = (2. / float(AA)) * AAR * (1. + d);\n\n  vec2 b = uv - r * (float(AA) - 1.);\n  for (int y = 0; y < AA; y++) {\n      for(int x = 0; x < AA; x++) {\n          vec2 c = vec2(b.x + float(x) * r, b.y + float(y) * r);\n          O += image(c) * S;\n      }\n  } \n  return O;\n}\n\nvoid mainImage(out vec4 O, vec2 uv) {\n  O = antiAlias(uv);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}