{
    "Shader": {
        "info": {
            "date": "1494066296",
            "description": "click n drag\n\nthanks to lycium for teaching me and Kchplr for some touch-ups!",
            "flags": 0,
            "hasliked": 0,
            "id": "MdBcW3",
            "likes": 1,
            "name": "julia 0.3",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "NNenov",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n\nconst float scale = 1.8;\nconst float mscale = 3.0;\nconst float escape= 4.;\nconst float bAmt = 0.2; // moblur amount\nconst float speed = 1.0;\n\nconst int fSamples = 10; //fibonacci sequence index\nconst int iters = 256;\n\nivec2 fib(const in int f)\n{\n  int n0 = 1;\n  int n1 = 1;\n  int fi = 0;\n    \n  for (int i = 0; i < f; i++) \n  {\n    fi = n0 + n1;\n    n0 = n1;\n    n1 = fi;\n  }\n    \n  return ivec2(n0, n1);\n}\n\nfloat rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec2 rotate(vec2 v, float t)\n{\n    float tx = cos(t)*v.x-sin(t)*v.y;\n    float ty = sin(t)*v.x+cos(t)*v.y;\n    return vec2(tx,ty);\n}\n\nvec2 mandel(vec2 a, vec2 c)\n{\n    float sqrz_x = a.x * a.x - a.y * a.y;\n    float sqrz_y = 2.0 * a.x * a.y;\n    \n   \n \tvec2 md =  vec2(sqrz_x,sqrz_y) +c;\n    \n    return (md);\n    \n}\n\nvec2 julia(vec2 a, float t, vec2 mo)\n{\n    \n    float sqrz_x = a.x * a.x - a.y * a.y + 0.45 + ( (sin(t) + mo.y ) * 0.01);\n    float sqrz_y = 2.0 * a.x * a.y + 0.45 + ( (cos(t) + mo.x ) * 0.02);\n    \n   \n \tvec2 md =  vec2(sqrz_x,sqrz_y);\n    \n    return (md);\n}\n\nfloat pxFunc(vec2 px, float t)\n{\n    \n    vec2 st = -scale / 2.0 + ( px / iResolution.xy ) * scale;\n    \n    vec4 m = mscale/2.0 -(iMouse / iResolution.xxxx)*mscale;\n\n    //st += m.xy;//vec2(0., 0.);\n    \n\tst = rotate(st, -t*0.1);\n    \n    vec2 z = st;\n    \n    //z = rotate(z, t*0.1);\n    \n    \n\tint k = 32;\n\n  \tfor(int j = 0; j < iters; j++)\n    {\n\n        z = julia(z*(0.95+sin(t*2.)*0.03), t, m.xy);\n        \n        if(z.x * z.x + z.y * z.y > escape) \n        {\n           k = j;\n           break;\n        }\n     }\n  \t\n    return 1.0-(float(k)/float(iters)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n    ivec2 fi = fib(fSamples - 2);\n    int ifN = fi.x;\n    float ffN = float(fi.x);\n    float ffk = float(fi.y);\n\n    \n    vec3 sum = vec3(0.);\n    float colMap;\n    float timeMap;\n    \n    float r = rand(gl_FragCoord.xy / iResolution.xy); // not sure how to best generate a random number\n    float fx;\n    for (int i = 0; i < ifN; i++) \n    {\n        vec2 samp = vec2(\n            float(i) / ffN,\n            fract(ffk * float(i) / ffN)\n        );\n        \n        timeMap = iTime + (float(i) + r) / ffN * bAmt;\n        \n        colMap = pxFunc( gl_FragCoord.xy + samp , timeMap*speed);\n    \tfloat steps = float(iters)-sin(timeMap*0.5)*5.;\n        float r = abs(0.7+sin(colMap*(steps-sin(timeMap)*0.1)));\n        float g = abs(0.7+sin(colMap*(steps+0.1)));\n        float b = abs(0.7+sin(colMap*(steps+0.2-cos(timeMap)*0.1)));\n        sum += vec3(r,g,b);\t\n    }\n\n    vec3 colNorm = sum / ffN;\n\n    fragColor = vec4(colNorm,1.0);\n\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}