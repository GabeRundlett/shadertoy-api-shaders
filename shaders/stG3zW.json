{
    "Shader": {
        "info": {
            "date": "1637239116",
            "description": "QE, Arrows to move around (No rotation)",
            "flags": 48,
            "hasliked": 0,
            "id": "stG3zW",
            "likes": 4,
            "name": "Mandelbox Explorer",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "mandelbox"
            ],
            "usePreview": 0,
            "username": "incription",
            "viewed": 560
        },
        "renderpass": [
            {
                "code": "#define MR2 0.25\n#define iters 15\n#define SCALE 2.\n\n#define MAX_STEPS 150\n#define MAX_DIST 50.\n#define SURF_DIST 1e-3\n\nvec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;\nfloat C1 = abs(SCALE-1.0), C2 = pow(abs(SCALE), float(1-iters));\nfloat mandelbox(vec3 position) {\n\n  // distance estimate\n  vec4 p = vec4(position, 1.0), p0 = vec4(position, 1.0);  // p.w is knighty's DEfactor\n  for (int i=0; i<iters; i++) {\n    p.xyz = clamp(p.xyz *0.5+0.5, 0.0, 1.0) *4.0-2.0 - p.xyz;  // box fold: min3, max3, mad3\n    float r2 = dot(p.xyz, p.xyz);  // dp3\n    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n    p.xyzw = p*scalevec + p0;  // mad4\n  }\n  return (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nvec3 rot(vec3 point, vec3 axis, float angle)\n{\n    // based on https://suricrasia.online/demoscene/functions/#erot\n    // axis should be normalized, angle should be in radians\n    vec3 origin = dot(point, axis)*axis;\n    vec3 diff = point - origin;\n    vec3 z_axis = -axis;\n    vec3 x_axis = normalize(diff);\n    vec3 y_axis = normalize(cross(z_axis, x_axis));\n    float R = length(diff);\n    return origin + x_axis*R*cos(angle) + y_axis*R*sin(angle);\n}\n\nvec3 ScenePos(vec3 p) {\n    return rot(p, vec3(0, 1, 0), .7);\n}\n\nfloat GetDist(vec3 p) {\n\tvec3 s = vec3(0);\n    \n    float mb = mandelbox(ScenePos(p));\n    \n    return mb;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) { //ri: tet index, ro: position on tet, rd: direction on tet\n\tfloat dO=0.;\n    float dS = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + dO * rd;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(SURF_DIST*.5, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = texelFetch(iChannel0, ivec2(0), 0).xyz;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 n;\n\n    float r;\n    r = RayMarch(ro, rd);\n    vec3 p = ro + rd * r;\n    //vec3 n = GetNormal(p);\n    \n    col = vec3(0.992,0.090,0.090)*GetLight(p, ro);\n    if(r>=MAX_DIST)col=vec3(1);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_Q  = 69;\nconst int KEY_E  = 81;\n\n#define SPEED .1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dat = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 pos = dat.xyz;\n    vec3 dp = vec3(0);\n    \n    dp.x -= texelFetch(iChannel1, ivec2(KEY_LEFT,0),0).x;\n    dp.x += texelFetch(iChannel1, ivec2(KEY_RIGHT,0),0).x;\n    \n    dp.y -= texelFetch(iChannel1, ivec2(KEY_DOWN,0),0).x;\n    dp.y += texelFetch(iChannel1, ivec2(KEY_UP,0),0).x;\n    \n    dp.z -= texelFetch(iChannel1, ivec2(KEY_E,0),0).x;\n    dp.z += texelFetch(iChannel1, ivec2(KEY_Q,0),0).x;\n    \n    pos += dp * SPEED;\n    if(iFrame==0) pos = vec3(0., 0, -20. + iTime/2.);\n    fragColor = vec4(pos, dat.w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}