{
    "Shader": {
        "info": {
            "date": "1654211873",
            "description": "CodeGarden Challenge 22 - Make the CG heart logo with whatever you want\nReflections on a beating heart edition",
            "flags": 0,
            "hasliked": 0,
            "id": "Ns3yWs",
            "likes": 2,
            "name": "CodeGarden Challenge 22 #3",
            "published": 3,
            "tags": [
                "raymarching",
                "logo",
                "umbraco",
                "codegarden",
                "codegardenchallenge"
            ],
            "usePreview": 0,
            "username": "larserik",
            "viewed": 725
        },
        "renderpass": [
            {
                "code": "// Ray marching code and SDF functions copied from Inigo Quilez and Martijn Steinrucken\n// The MIT License\n// Copyright Â© 2022 Lars-Erik Aabech\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define MAX_STEPS 50\n#define MAX_DIST 10.\n#define SURF_DIST .005\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1, d2);\n}\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nfloat GetDist(vec3 p, out float col) {\n    const float hr = 0.707; // heart raduis\n    const float tr = 0.07; // torus radius\n\n    col = 1.;\n\n    float isBeat = max(0., mod(floor(iTime*1.7),3.)-1.);\n    float beat = abs(sin(iTime*TAU*1.7));\n    float scale = 1. + isBeat * beat * .2;\n\n    //float d = sdBox(p, vec3(1));\n    // Top right arc\n    vec3 p1 = p;\n    p1.x += .5 * scale;\n    p1.y -= .5 * scale;\n    p1.xy *= Rot(-0.785);\n    vec2 a = vec2(sin(1.57), cos(1.57));\n    //a = vec2(sin(3.14), cos(3.14));\n    float d1 = sdCappedTorus(p1, a, hr, tr);\n    d1 = opU(d1, sdCapsule(p1, vec3(-hr, 0., 0.), vec3(hr, 0., 0.), tr));\n    \n    // Mid right triangle\n    vec3 p2 = p;\n    p2.x += 1. * scale;\n    p2.y += (scale - 1.) * .5;\n    float d2 = sdCapsule(p2, vec3(0), vec3(1, 0, 0), tr);\n    d2 = opU(d2, sdCapsule(p2, vec3(0), vec3(1, 1, 0), tr));\n    d2 = opU(d2, sdCapsule(p2, vec3(1, 1, 0), vec3(1, 0, 0), tr));\n\n    // Bottom right triangle\n    vec3 p3 = p;\n    p3.x += 1. * scale;\n    p3.y += 0. + scale - 1.;\n    float d3 = sdCapsule(p3, vec3(0), vec3(1, 0, 0), tr);\n    d3 = opU(d3, sdCapsule(p3, vec3(0), vec3(1, -1, 0), tr));\n    d3 = opU(d3, sdCapsule(p3, vec3(1, -1, 0), vec3(1, 0, 0), tr));\n\n    float rightHalf = opU(opU(d1, d2), d3);\n    \n    // Upper left pie\n    vec3 p4 = p;\n    p4.x -= .5 * scale;\n    p4.y -= .5 * scale;\n    p4.xy *= Rot(.785);\n    float d4 = sdCappedCylinder(p4, vec3(0, 0, .001), vec3(0, 0, -.001), hr);\n    d4 = opSub(sdBox2(p4+vec3(-0,.5,0), vec3(1, .5, .5)), d4);\n    d4 = rounding(d4, tr-.005);\n\n    // Lower left triangle\n    vec3 p5 = p;\n    p5 -= vec3(scale-1.,-scale+1., 0);\n    float d5 = udTriangle(vec3(0), vec3(1, 0, 0), vec3(0, -1, 0), p5) - .001;\n    d5 = rounding(d5, tr-.006);\n\n    float leftHalf = opU(d4, d5);\n    \n    float d = min(rightHalf, leftHalf);\n    \n    if (d == d4) col = 2.;\n    if (d == d5) col = 3.;\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out float col) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p, col);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float col;\n\tfloat d = GetDist(p, col);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, col),\n        GetDist(p-e.yxy, col),\n        GetDist(p-e.yyx, col)\n    );\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Render(inout vec3 ro, inout vec3 rd, inout float ref) {\n    // Doing weird things to move the skybox to nice starting reflection and tint.\n    // Straight skybox woud be texture(iChannel0, rd).rgb, tuned to not over expose color.\n    vec3 skybox = texture(iChannel0, vec3(rd.xz*Rot(PI*-.25), rd.y)).rbg * vec3(.3, .6, .5);\n    // background tint + slight skybox\n    vec3 col = vec3(.2, .266, .694) + skybox;\n\n    // Get distance and color, TODO: move color to vec2 return type\n    float colIndex = 0.;\n    float d = RayMarch(ro, rd, colIndex);\n\n    // Make a nice color if we hit\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        // Super basic lighting\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        // Color and reflectiveness\n        if (colIndex == 1.) {\n            col = vec3(.8)*dif;\n            ref = .35;\n        }\n        else if (colIndex == 2.) {\n            col = vec3(.96, .756, .737)*dif;\n            ref = .35;\n        }\n        else if (colIndex == 3.) {\n            col = vec3(.615, .5, .341)*dif;\n            ref = .25;\n        }\n\n        // Adjust direction to reflect\n        ro = p+n*SURF_DIST*3.;\n        rd = r;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 3.2, 3);\n    if (iMouse.z > 0. && (m.x > 0. || m.y > 0.)) {\n        m -= .5;\n        m.y *= -1.;\n        ro.yz *= Rot(-m.y*PI+1.);\n        ro.xz *= Rot(-m.x*TAU);\n    } else {\n        ro.y = -1.4;\n        ro.xz *= Rot(iTime*.3);\n    }\n    ro = (normalize(ro)*6.);\n\n    uv.y += .03;\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 2.);\n\n    float ref = 0.;\n    vec3 col = Render(ro, rd, ref);\n    vec3 bounce = ref * Render(ro, rd, ref);\n    col += bounce;\n    \n    col = pow(col, vec3(1.3));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}