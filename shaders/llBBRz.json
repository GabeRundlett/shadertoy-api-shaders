{
    "Shader": {
        "info": {
            "date": "1514489868",
            "description": "some testing with gpgpu",
            "flags": 32,
            "hasliked": 0,
            "id": "llBBRz",
            "likes": 0,
            "name": "GPGPU Library",
            "published": 3,
            "tags": [
                "gpgpu"
            ],
            "usePreview": 0,
            "username": "alijaya",
            "viewed": 702
        },
        "renderpass": [
            {
                "code": "bool viewData = false; // change this to see the data\n\nstruct MemArray {\n    int memory;\n    int size;\n    int numByte;\n};\n\nvec4 d_fragColor;\nvec2 d_fragCoord;\n\nint d_usedMemory = 0;\n\nfloat get(int memory) {\n    int row = int(iResolution.x);\n    int idxPixel = memory / 4;\n    int idxChannel = memory % 4;\n    int x = idxPixel % row;\n    int y = idxPixel / row;\n    return texelFetch(iChannel0, ivec2(x, y), 0)[idxChannel];\n}\n\nint getArrayHandler(MemArray array, int index, int pos) {\n    return array.memory + 2 + index * array.numByte + pos;\n}\n\nfloat getArray(MemArray array, int index, int pos) {\n    return get(getArrayHandler(array, index, pos));\n}\n\nint alloc1() {\n    int memory = d_usedMemory;\n    d_usedMemory += 1;\n    return memory;\n}\n\nint alloc2() {\n    int memory = d_usedMemory;\n    d_usedMemory += 2;\n    return memory;\n}\n\nint alloc3() {\n    int memory = d_usedMemory;\n    d_usedMemory += 3;\n    return memory;\n}\n\nint alloc4() {\n    int memory = d_usedMemory;\n    d_usedMemory += 4;\n    return memory;\n}\n\nMemArray allocArray() {\n    MemArray array;\n    array.memory = d_usedMemory;\n    array.size = int(get(array.memory));\n    array.numByte = int(get(array.memory + 1));\n    d_usedMemory += 2 + array.size * array.numByte;\n    return array;\n}\n\n// end of library\n\nMemArray particles;\n\nvoid allocData() {\n    particles = allocArray();\n}\n\nfloat lerp(float x, float fromA, float fromB, float toA, float toB) {\n    return (x - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\nvoid drawData() {\n    int target = int(ceil(sqrt(float(d_usedMemory))));\n   \tivec2 pos = ivec2(d_fragCoord / iResolution.xy * float(target));\n    int memory = pos.y * target + pos.x;\n    float color = lerp(get(memory), -1000., 1000., 0., 1.);\n    d_fragColor = vec4(color);\n}\n\nvoid draw() {\n    for (int i=0; i<particles.size; i++) {\n        int h = getArrayHandler(particles, i, 0);\n        float x = get(h + 0);\n        float y = get(h + 1);\n        \n        float color = 1.0 - step(1., distance(vec2(x, y), d_fragCoord));\n        vec4 src = vec4(color);\n        d_fragColor = src + d_fragColor * (1.0 - src.a);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    d_fragCoord = fragCoord;\n    \n    allocData();\n    \n    if (viewData) {\n        drawData();\n    } else {\n    \tdraw();\n    }\n    fragColor = d_fragColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct MemArray {\n    int memory;\n    int size;\n    int numByte;\n};\n\nvec4 d_fragColor;\nvec2 d_fragCoord;\n\nint d_usedMemory = 0;\n\nfloat get(int memory) {\n    int row = int(iResolution.x);\n    int idxPixel = memory / 4;\n    int idxChannel = memory % 4;\n    int x = idxPixel % row;\n    int y = idxPixel / row;\n    return texelFetch(iChannel0, ivec2(x, y), 0)[idxChannel];\n}\n\nint getArrayHandler(MemArray array, int index, int pos) {\n    return array.memory + 2 + index * array.numByte + pos;\n}\n\nfloat getArray(MemArray array, int index, int pos) {\n    return get(getArrayHandler(array, index, pos));\n}\n\nvoid set(int memory, float value) {\n    int row = int(iResolution.x);\n    int idxPixel = memory / 4;\n    int idxChannel = memory % 4;\n    int x = idxPixel % row;\n    int y = idxPixel / row;\n    if (int(d_fragCoord.x) == x && int(d_fragCoord.y) == y) { // in the right pixel\n        d_fragColor[idxChannel] = value;\n    }\n}\n\nvoid setArray(MemArray array, int index, int pos, float value) {\n    set(getArrayHandler(array, index, pos), value);\n}\n\nint alloc1() {\n    int memory = d_usedMemory;\n    d_usedMemory += 1;\n    return memory;\n}\n\nint alloc2() {\n    int memory = d_usedMemory;\n    d_usedMemory += 2;\n    return memory;\n}\n\nint alloc3() {\n    int memory = d_usedMemory;\n    d_usedMemory += 3;\n    return memory;\n}\n\nint alloc4() {\n    int memory = d_usedMemory;\n    d_usedMemory += 4;\n    return memory;\n}\n\nMemArray allocArray(int size, int numByte) {\n    MemArray array;\n    array.memory = d_usedMemory;\n    array.size = size;\n    array.numByte = numByte;\n    set(array.memory, float(size));\n    set(array.memory + 1, float(numByte));\n    d_usedMemory += 2 + size * numByte;\n    return array;\n}\n\nint getPos1(int curMemory, int handler) {\n    int temp = curMemory - handler;\n    if (temp == 0) return temp;\n    else return -1;\n}\n\nint getPos2(int curMemory, int handler) {\n    int temp = curMemory - handler;\n    if (0 <= temp && temp < 2) return temp;\n    else return -1;\n}\n\nint getPos3(int curMemory, int handler) {\n    int temp = curMemory - handler;\n    if (0 <= temp && temp < 3) return temp;\n    else return -1;\n}\n\nint getPos4(int curMemory, int handler) {\n    int temp = curMemory - handler;\n    if (0 <= temp && temp < 4) return temp;\n    else return -1;\n}\n\nivec2 getIndexPosArray(int curMemory, MemArray array) {\n    int temp = curMemory - (array.memory + 2);\n    if (0 <= temp && temp < array.size * array.numByte) return ivec2(temp / array.numByte, temp % array.numByte);\n    else return ivec2(-1, -1);\n}\n\n// end of memory management\n\nint randomSeed = 0;\n\nvoid setRandomSeed(int seed) {\n    randomSeed = seed;\n}\n\nfloat random() {\n    int rowCount = int(iChannelResolution[1].x);\n    int x = randomSeed % rowCount;\n    int y = randomSeed / rowCount;\n    randomSeed++;\n    return texture(iChannel1, vec2(float(x) + 0.5, float(y) + 0.5) / iChannelResolution[1].xy).x;\n}\n\n// edit this\n\nMemArray particles;\n\nvoid allocData() {\n    particles = allocArray(100, 4);\n}\n\nvoid init(int memory) {\n    ivec2 indexPos = getIndexPosArray(memory, particles);\n    int index = indexPos[0];\n    int pos = indexPos[1];\n    if (index == -1) return; // just process first byte of item\n    \n    int handler = getArrayHandler(particles, index, 0);\n    \n    setRandomSeed(index);\n    set(handler + 0, random() * iResolution.x);\n    set(handler + 1, random() * iResolution.y);\n    set(handler + 2, mix(-100., 100., random()));\n    set(handler + 3, mix(-100., 100., random()));\n}\n\nvoid update(int memory) {\n    ivec2 indexPos = getIndexPosArray(memory, particles);\n    int index = indexPos[0];\n    int p = indexPos[1];\n    if (index == -1) return; // just process first byte of item\n    \n    int handler = getArrayHandler(particles, index, 0);\n    \n    float strength = 500.;\n    vec2 pos = vec2(get(handler + 0), get(handler + 1));\n    vec2 vel = vec2(get(handler + 2), get(handler + 3));\n    vec2 acc = vec2(0.);\n    \n    for (int i=0; i<particles.size; i++) {\n        if (i != index) {\n            int h = getArrayHandler(particles, i, 0);\n    \t\tvec2 npos = vec2(get(h + 0), get(h + 1));\n            vec2 v = npos - pos;\n            float len = length(v);\n            float len2 = len * len;\n            acc += normalize(v) * strength / len;\n        }\n    }\n    \n    vel += acc * iTimeDelta;\n    vel *= pow(0.9, iTimeDelta);\n    pos += vel * iTimeDelta;\n    set(handler + 0, pos.x);\n    set(handler + 1, pos.y);\n    set(handler + 2, vel.x);\n    set(handler + 3, vel.y);\n}\n\n// end of edit\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    d_fragCoord = fragCoord;\n    \n    d_fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    allocData();\n    \n    int beginMemory = 4 * (int(d_fragCoord.y) * int(iResolution.x) + int(d_fragCoord.x));\n    \n    if (d_usedMemory < beginMemory) discard; // We don't have to process this\n    \n    if (iFrame == 0) {\n        for (int i=0; i<4; i++) {\n            init(beginMemory + i);\n        }\n    } else {\n        for (int i=0; i<4; i++) {\n            update(beginMemory + i);\n        }\n    }\n    \n    fragColor = d_fragColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}