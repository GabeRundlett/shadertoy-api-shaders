{
    "Shader": {
        "info": {
            "date": "1564195345",
            "description": "psychedelic wire box\n\nNOTE: bug graphics in recent version mac OS.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtsXzs",
            "likes": 18,
            "name": "psychedelic flower tunnel",
            "published": 3,
            "tags": [
                "raymarching",
                "wireframe",
                "palette",
                "box"
            ],
            "usePreview": 0,
            "username": "takumifukasawa",
            "viewed": 812
        },
        "renderpass": [
            {
                "code": "//------------------------------------------------------------------------\n// # refs\n// ## repeat, mod, pmod\n// - https://qiita.com/kaneta1992/items/21149c78159bd27e0860#ifs%E3%81%AB%E3%82%88%E3%82%8B%E8%A4%87%E9%9B%91%E3%81%AA%E5%BD%A2%E7%8A%B6\n// - https://qiita.com/edo_m18/items/8c20c9c80d44e8b1dfe4#_reference-7c25132332209c2cd12e\n// - https://gam0022.net/blog/2017/03/02/raymarching-fold/\n// ## collor pallete\n// - https://www.shadertoy.com/view/ll2GD3\n// ## material mechanism\n// - https://www.shadertoy.com/view/ldlcRf\n// ## fake motion blur ?\n// - https://www.shadertoy.com/view/WllSDM\n// ## distance functions, fog ... \n// - https://iquilezles.org/www/index.htm\n//------------------------------------------------------------------------\n\nprecision highp float;\n\n#define EPS .0001\n#define PI 3.1415\n#define repeat(p, o) mod(p, o) - o * .5\n\n// ref: https://www.shadertoy.com/view/ldlcRf\n#define TEST_MAT_LESS (a, b) a < (b + .1)\n#define TEST_MAT_GREATER (a, b) a > (b - .1)\n\nconst float stopThreshold = .0001;\n\nstruct Light {\n\tvec3 position;\n  \tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n  \tfloat attenuation;\n};\n    \nstruct Surface {\n  \tfloat depth;\n  \tfloat dist;\n  \tvec3 position;\n  \tvec3 baseColor;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n  \tfloat material;\n};  \n\n// ref: https://www.shadertoy.com/view/ldlcRf\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// ref: https://www.shadertoy.com/view/WllSDM\nfloat n3(vec3 p) {\n\tvec3 r = vec3(1, 99, 999);\n\tvec4 s = dot(floor(p), r) + vec4(0., r.yz, r.y + r.z);\n\tp = smoothstep(0., 1., fract(p));\n\tvec4 a = mix(fract(sin(s) * 5555.), fract(sin(s + 1.) * 5555.), p.x);\n\tvec2 b = mix(a.xz, a.yw, p.y);\n\treturn mix(b.x, b.y, p.z);\n}\n    \n// ref: https://www.shadertoy.com/view/ll2GD3\n// t: 0-1, a: contrast, b: brightness, c: times, d: offset\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// d1 subtract to d2\nfloat opSub(float d1, float d2) {\n\treturn max(-d1, d2);\n}\n\nfloat sdWireBox(vec3 p, float s, float b) {\n    float d = 0.;\n    float o = s + .01;\n    float i = s - b;\n    d = opSub(\n        sdBox(p, vec3(o, i, i)),\n        sdBox(p, vec3(s))\n    );\n    d = opSub(\n        sdBox(p, vec3(i, o, i)),\n\t\td\n    );\n    d = opSub(\n        sdBox(p, vec3(i, i, o)),\n\t\td\n    );\n    return d;\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = atan(p.x, p.y) + PI / r;\n    float n = PI * 2. / r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\n\nvec2 scene(vec3 p) {\n    float d = 0.;\n    vec3 _p = p;\n    vec3 q = p;\n    float m = 0.;\n    \n    float scale = .8;\n    vec3 size = vec3(1.);\n    \n    float repeatNum = 12.;\n    \n    vec3 id = floor(_p / repeatNum);\n    \n    _p = repeat(_p, repeatNum);  \n    \n    d = sdWireBox(_p, .22, .07);    \n    \n    vec2 obj = vec2(d, 1.);\n    \n\t_p.xy = pmod(_p.xy, repeatNum);\n\tsize = vec3(1.);\n    \n    for(int i = 0; i < 7; i++) {\n        _p.y -= size.x * .32;\n        _p.y -= size.y;\n        _p.xz *= rot(sin(iTime * .4+ float(i) * .4) * PI * 2.);\n\n        float currentDist = sdWireBox(p, .22 * size.y, .07 * size.y);\n\t\tvec2 currentObj = vec2(currentDist, float(i) + 1.);\n        m = minMat(obj, currentObj).y;\n        obj.x = min(obj.x, currentObj.x);\n        obj.y = m;\n        \n        p = _p;\n        size *= scale;\n    }\n    \n    return vec2(obj.x, m);\n}\n\nmat3 camera(vec3 o, vec3 t, vec3 u) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, u);\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvec3 getNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  \tvec3 lightDir = light.position - position;\n  \tvec3 ref = reflect(-normalize(lightDir), normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - normal)));\n    \tfloat specularPower = 64.;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  \tvec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  \t// specular\n  \tfloat specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  \tlight.diffuse = diffuse;\n  \tlight.specular = specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n  \tLight directionalLight;\n  \tdirectionalLight.position = vec3(-.2, .2, -1.);\n  \tdirectionalLight.intensity = .8;\n  \tdirectionalLight.color = vec3(1., 1., 1.);\n  \tdirectionalLight.attenuation = 1.;\n  \tcalcDirectionalLight(directionalLight, surface, cameraPos);\n\n  \tvec3 diffuse = directionalLight.diffuse;\n  \tvec3 specular = directionalLight.specular;\n    \n  \tvec3 ambient = vec3(.2);\n  \n  \tcolor = surface.baseColor * diffuse + ambient;  \n  \n  \treturn color;\n}\n\nvec3 fog(vec3 color, float distance, vec3 fogColor, float b) {\n  \tfloat fogAmount = 1. - exp(-distance * b);\n  \treturn mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    // ref: https://www.shadertoy.com/view/WllSDM\n    float nois = (\n        n3(vec3(normalize(uv) * 20., 1.)) +\n        n3(vec3(normalize(uv) * 40., 2.)) * 1.5  +\n        n3(vec3(normalize(uv) * 100., 3.)) * 1.5\n    ) / 4.;\n    nois = pow(nois, 4.) * 2. - 1.;    \n    float tt = iTime * .11 + (nois * .01 + n3(vec3(uv * 600., 0.)) * .003) * pow(dot(uv, uv), 0.3);    \n    float speed = tt * -50.;    \n    \n    vec3 movement = vec3(0., 0., - speed);    \n    vec3 ro = vec3(6., 6., 4.) + movement;\n    vec3 target = ro + vec3(0., 0., 0.) + movement;\n    float fov = .7;\n    \n    vec3 up = vec3(0., 1., 0.);\n    up.xy *= rot(iTime * .12);\n    vec3 rd = camera(ro, target, up) * normalize(vec3(uv, fov));\n    \n    // raymarching\n    float depth = 0.;\n    float dist = 0.;\n    vec2 result = vec2(0.);\n    for(int i = 0; i < 64; i++) {\n    \tresult = scene(ro + rd * depth);\n        dist = result.x;\n        if(dist < stopThreshold) {\n            break;\n        }\n        depth += result.x;\n    }   \n    \n    vec3 color = vec3(0.);\n   \n    vec3 position = ro + rd * depth;\n    vec3 normal = getNormal(position, .01);\n    \n    Surface surface;\n    surface.depth = depth;\n    surface.dist = dist;\n    surface.position = position;\n    surface.normal = normal;\n    surface.material = result.y;\n    \n\tvec3 sceneColor = vec3(0.);\n    \n    vec3 bgColor = vec3(.05, .05, .15);\n       \n    if(dist >= stopThreshold) {\n\t    // no hit\n        sceneColor = bgColor;\n    } else {\n\t    // hit\n\t    surface.baseColor = palette(\n    \t\tsurface.material / 9.,\n        \tvec3(.7),\n        \tvec3(.75),\n        \tvec3(1.),\n        \tvec3(.5 + iTime * .14, iTime * .18, iTime * .24)    \n    \t);\n\t\tsceneColor = lighting(surface, ro);           \n    }\n\n    // fog\n    sceneColor = fog(sceneColor, depth, bgColor, .045);\n\t// vignet\n    sceneColor *= smoothstep(1.3, .6, length(uv.xy));\n \n    fragColor = vec4(sceneColor, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}