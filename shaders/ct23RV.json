{
    "Shader": {
        "info": {
            "date": "1673558594",
            "description": "This implements a simple iterative solver for the MCM differential equation.\nIt tries to shrink the length of the boundaries of segments within the image.\n\nClick + drag for different debug views.",
            "flags": 32,
            "hasliked": 0,
            "id": "ct23RV",
            "likes": 3,
            "name": "Mean Curvature Motion",
            "published": 3,
            "tags": [
                "iterative",
                "segmentation",
                "mcm"
            ],
            "usePreview": 0,
            "username": "Gegell",
            "viewed": 269
        },
        "renderpass": [
            {
                "code": "#define SOURCE_TEXTURE iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fetch the current iteration data\n    vec4 buffer = vec4(loadTex(fragCoord));\n    \n    // Compute the same intermediate values, which are also used for the actual computation in Buffer A.\n    vec2 gradient = gradient(fragCoord);\n    mat2 hessian = hessian(fragCoord);\n    float laplacian = hessian[0][0] + hessian[1][1];\n    \n    vec2 nGradient = normalizeSafe(gradient);\n    float delta = laplacian - dot(nGradient, hessian*nGradient);\n    \n    \n    switch(int(clamp(iMouse.x / iResolution.x, 0., 1.) * 5.)) {\n    // Actual output\n    case 0: \n        fragColor = buffer;\n        break;\n    // Debug views\n    case 1: // Show hessian matrix entries\n        fragColor = abs(vec4(hessian[0][0], hessian[1][1], hessian[0][1], 0) * 300.);\n        break;\n    case 2: // Show gradient\n        fragColor = vec4(gradient, 0, 0) * 100.;\n        break;\n    case 3: // Laplacian\n        fragColor = vec4(laplacian) * 1000.;\n        break;\n    case 4: // applied delta\n        fragColor = vec4(delta, 0, -delta, 1) * 1000.;\n        break;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SOURCE_TEXTURE iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prev = vec4(loadTex(fragCoord));\n    if (iFrame < 10) {\n        prev = texture(iChannel1, fragCoord/iResolution.xy).xxxx;\n    }\n    \n    vec2 gradient = gradient(fragCoord);\n    mat2 hessian = hessian(fragCoord);\n    float laplacian = hessian[0][0] + hessian[1][1];\n    \n    // Actually compute the delta as given by the mcm equation\n    // ∂t u = Δu - 1/|∇u|^2 * ∇u^T * Hess(u) * ∇u\n    gradient = normalizeSafe(gradient);\n    float delta = laplacian - 1. * dot(gradient, hessian*gradient);\n    \n    // If the above factor `1.` is increased slightly, e.g. 1.1 we observe a slight sharpening of the boundaries\n\n    // Iteratively apply the smoothing value, semi-stable up to timestep size .5\n    fragColor = prev + .45 * delta;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define normalizeSafe(v) (v * min(1./length(v), 1e20))\n\nfloat loadTex( sampler2D source, vec2 p ) {\n    vec2 ts = vec2(textureSize(source, 0));\n    return texture(source, p/ts).x;\n}\n\nuniform sampler2D SOURCE_TEXTURE;\nfloat loadTex( vec2 p ) {\n    return loadTex(SOURCE_TEXTURE, p);\n}\n\nvec2 gradient( vec2 p ) {\n    return vec2(\n        loadTex(p + vec2(1, 0)) - loadTex(p + vec2(-1, 0)),\n        loadTex(p + vec2(0, 1)) - loadTex(p + vec2(0, -1))\n    ) * 0.5;\n}\n\nmat2 hessian( vec2 p ) {\n    mat2x2 hessian;\n    hessian[0][0] = loadTex(p + vec2(-1,  0)) - 2. * loadTex(p) + loadTex(p + vec2(1, 0));\n    hessian[1][1] = loadTex(p + vec2( 0, -1)) - 2. * loadTex(p) + loadTex(p + vec2(0, 1));\n    hessian[0][1] = 0.25*(loadTex(p + vec2(-1, -1)) - loadTex(p + vec2(1, -1)) - loadTex(p + vec2(-1, 1)) + loadTex(p + vec2(1, 1)));\n    hessian[1][0] = hessian[0][1];\n    return hessian;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    }
                ],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}