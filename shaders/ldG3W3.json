{
    "Shader": {
        "info": {
            "date": "1456696093",
            "description": "The exact same Venice shader from Reinder, with my Bokeh Disc shader added on the next buffer. It's not mathematically correct, but it still looks kinda groovy... :)",
            "flags": 32,
            "hasliked": 0,
            "id": "ldG3W3",
            "likes": 67,
            "name": "Bokeh Venice",
            "published": 3,
            "tags": [
                "3d",
                "dof",
                "bokeh",
                "venice",
                "maymarche"
            ],
            "usePreview": 1,
            "username": "Dave_Hoskins",
            "viewed": 2551
        },
        "renderpass": [
            {
                "code": "// Bokeh disc.\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Buf A - Venice. Created by Reinder Nijhoff 2013\n// https://www.shadertoy.com/view/MdXGW2\n\n\n// The Golden Angle is (3.-sqrt(5.0))*PI radians.\n#define GOLDEN_ANGLE 2.39996323\n\n#define ITERATIONS 100\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n//-------------------------------------------------------------------------------------------\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, float zed)\n{\n    radius*= .008;\n\tvec3 acc = vec3(0.0), div = acc;\n    vec2 pixel = vec2(.002 *iResolution.y / iResolution.x, .002);\n    float r = 1.0;\n    vec2 vangle = vec2(0.0,radius); // Start angle\n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        r += 1. / r;\n\t    vangle *= rot;\n        vec4 col = texture(tex, uv + pixel * (r-1.) * vangle);\n        float dim = smoothstep(200.0, -1., zed-col.w);\n\t\tvec3 bokeh = (pow(col.xyz, vec3(9.0)) * 20.+1.) * dim;//..Varies depending on intensity needed..\n\t\tacc += col.xyz * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc / div;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float zed = texture(iChannel0, uv).w;\n    zed = min(zed, 150.0);\n  \n\tfragColor = vec4(Bokeh(iChannel0, uv, zed, zed), 1.0);\n  \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Venice. Created by Reinder Nijhoff 2013\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdXGW2\n//\n// My attempt to create a procedural city with a lot of lights. The city is inspired by Venice. \n// The shader is a combination of my shaders: https://www.shadertoy.com/view/Mdf3zM and \n// https://www.shadertoy.com/view/lslGDB.\n// (I have never been in Venice btw)\n//\n\n// #define SHOW_ORNAMENTS\n#define SHOW_GALLERY\n#define SHOW_LIGHTS\n#define SHOW_BRIDGES\n#define SHOW_MOON_AND_CLOUDS\n\n//----------------------------------------------------------------------\n\n#define BUMPFACTOR 0.2\n#define EPSILON 0.1\n#define BUMPDISTANCE 200.\n\n#define CAMERASPEED 15.\n\n#define BUILDINGSPACING 20.\n#define MAXBUILDINGINSET 12.\n\n#define GALLERYHEIGHT 10.5\n#define GALLERYINSET 2.5\n\nfloat time;\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*32.5454412211233);\n}\nvec2 hash2( float n ) {\n\treturn fract(sin(vec2(n,n+1.0))*vec2(11.1451239123,34.349430423));\n}\nvec3 hash3( float n ) {\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\n\treturn -1.0 + 2.0*textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tfloat  z = x.z*64.0;\n\tvec2 offz = vec2(0.317,0.123);\n\tvec2 uv1 = x.xy + offz*floor(z); \n\tvec2 uv2 = uv1  + offz;\n\treturn mix(textureLod( iChannel0, uv1 ,0.0).x,textureLod( iChannel0, uv2 ,0.0).x,fract(z))-0.5;\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n//----------------------------------------------------------------------\n// distance functions\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\nfloat udBox( vec3 p, vec3 b) {\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdCylinderXY( vec3 p, vec2 h ) {\n  return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\nfloat opU( float d1, float d2 ) {\n    return min(d2,d1);\n}\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\n//----------------------------------------------------------------------\n// building functions\n\nfloat getXoffset( float z ) {\n\treturn 20.*sin( z*0.02);\n}\n\nvec2 getBuildingInfo( in vec3 pos ) {\n\tvec2 res;\n\t// base index\t\n\tres.x = floor( pos.z/BUILDINGSPACING + 0.5 );\n\t// base z coord\n\tres.y = res.x * BUILDINGSPACING;\n\t\n\t// negative index for buildings at the right side\n\tres.x *= sign( pos.x + getXoffset(pos.z) );\n\t\n\treturn res;\n}\n\nvec4 getBuildingParams( in float buildingindex ) {\n\tvec3 h = hash3( buildingindex );\n\treturn vec4(\n\t\t20. + 4.5*floor( h.x*7. ),\t // height\n\t\th.y*MAXBUILDINGINSET,\n\t\tstep(h.z, 0.5),\t\t\t\t // sidewalk\n\t\tstep(abs(h.z-0.4),0.25)\t\t // balcony\n\t);\n}\n\nfloat baseBuilding( in vec3 pos, in float h ) {\n\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\n\t\n\tfloat res = \n\topS(\t\t\n\t\t// main building\n\t\tudBox( tpos, vec3( 8.75, h, 8.75 ) ),\n\t\t\t// windows\n\t\topS(\n\t\t\topU(\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) ),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\n\t\t\t),\n\t\t\tudBox( tpos+vec3(0.,-h,0.), vec3( 9.0, 1.0, 9.0 ) )\n\t\t)\t\t\n\t);\n\t\n\tres =\n\topU( \n\t\tres,\n\t\topI( // main building windows\n\t\t\tudBox( tpos, vec3( 8.75, h, 8.75 ) ), \n\t\t\topU(\n\t\t\t\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, h, 0.05 ) ),\n\t\t\t\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\n\t\t\t)\n\t\t)\n\t);\n\treturn res;\t\n}\n\nfloat baseGallery( in vec3 pos ) {\n\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\n\t\n\tfloat res = \n\topU(\t\n\t\topS(\n\t\t\tudBox( tpos+vec3(0.,0.,-GALLERYINSET), vec3( 8.75, GALLERYHEIGHT, 0.125 ) ),\n\t\t\topU(\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-5., tpos.z-5.), vec3( 1.6,3.,10.) ),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-8., tpos.z-5.), vec2( 1.6,10.) )\n\t\t\t)\n\t\t),\n\t\tsdTriPrism( vec3( tpos.z+3.4,-44.4+3.9*tpos.y, tpos.x), vec2( 7.5, 8.7 ) )\n\t);\n\t\n\treturn res;\t\n}\n\nfloat baseBalcony( in vec3 pos, in float h ) {\n\tfloat res = opI(\t\t\n\t\t// main building\n\t\tudBox( pos, vec3( 9.0, h, 9.0 ) ),\n\t\t\t// balcony\n\t\tsdBox( vec3( pos.x, mod(pos.y+4.5, 9.)-7.5, pos.z-5.), vec3( 40.,0.5,40.) )\n\t);\n\treturn res;\t\t\n}\n\nfloat baseBridge( in vec3 pos ) {\n\tpos.x *= 0.38;\n\tfloat res = \n\topS(\t\n\t\topU( \n\t\t\tsdBox( pos, vec3( 4., 2., 2.5 ) ),\n\t\t\tsdTriPrism( vec3( pos.x,-8.+3.*pos.y, pos.z), vec2( 4.5, 2.5 ) )\n\t\t),\n\t\tsdCylinderXY( pos+vec3( 0., 1.5, 0. ), vec2( 3.8, 3. ) )\n\t);\n\treturn res;\n}\n\n// dinstancefield definitions\n\nfloat mapSimpleTerrain( in vec3 p ) {\t\n\tp.x += getXoffset( p.z );\t\n\tp.x = -abs( p.x );\n\tvec2 res = vec2( udBox( vec3(p.x+30., p.y-1., p.z) , vec3( 20., 100.25, 99999. ) ), 1.);\n\n#ifdef SHOW_BRIDGES\n\tfloat zcenter = mod(p.z+60.,120.)-70.;\n\tres = opU( res, vec2( baseBridge( vec3( p.x, p.y, zcenter) ), 8. ) ); // bridge\n#endif\n\t\n\treturn min( res.x, p.y+10. );\n}\n\nvec2 mapTerrain( in vec3 p ) {\t\n\tvec2 buildingInfo = getBuildingInfo( p );\n\tvec4 buildingParams = getBuildingParams( buildingInfo.x );\n\t\n\tvec3 pos = p;\n\tpos.x += getXoffset( pos.z );\n\tpos.x = -abs( pos.x );\n\t\n\tvec2 res = vec2( udBox( vec3(pos.x+30., pos.y, pos.z) , vec3( 20., 0.25, 99999. ) ), 1.); // ground\n\t\n\tfloat z = buildingInfo.y;\n\tfloat zcenter = mod(pos.z+10.,20.)-10.;\n\n#ifdef SHOW_BRIDGES\n\tres = opU( res, vec2( baseBridge( vec3( pos.x, pos.y,  mod(pos.z+60.,120.)-70.) ), 8. ) ); // bridge\n#endif\n\t\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-6.0, zcenter) , 0.5 ), 3. ) ); // light\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter+0.6) , 0.35 ), 3. ) ); // light\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter-0.6) , 0.35 ), 3. ) ); // light\n\t\n\tres =  opU( res, vec2( sdCylinderXZ( vec3( pos.x+11.5, pos.y, zcenter), vec2( 0.1, 6.0) ), 4.)); // \n\t\t\t\t\t\t  \n\tpos += vec3( 28.75+buildingParams.y, 2.5, 0.);\t\t\n\tres =  opU( res, vec2( baseBuilding( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 2. ) );\n\n#ifdef SHOW_ORNAMENTS\n\tres = mix( res, opU( res, vec2( baseBalcony( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 9. ) ), buildingParams.w );\n#endif\n\t\n#ifdef SHOW_GALLERY\n\tpos.x += -8.75-GALLERYINSET;\t\t\n\tres = mix( res, opU( res, vec2( baseGallery( vec3( pos.x, pos.y, zcenter) ), 5. ) ), buildingParams.z );\n#endif\t\n\t\t\t\t\t\t\t\t\t  \n\treturn vec2( min( res.x,  11.-zcenter ), res.y );\n}\n\nfloat waterHeightMap( vec2 pos ) {\n\tvec2 posm = 0.02*pos * m2;\n\tposm.x += 0.001*time;\n\tfloat f = fbm( vec3( posm*1.9, time*0.01 ));\n\tfloat height = 0.5+0.1*f;\n\theight += 0.05*sin( posm.x*6.0 + 10.0*f );\n\t\n\treturn  height;\n}\n\n// intersection functions\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out vec3 normal ) {\n    vec3  ds = ro - sph.xyz;\n    float bs = dot( rd, ds );\n    float cs = dot(  ds, ds ) - sph.w*sph.w;\n    float ts = bs*bs - cs;\n\t\n    if( ts > 0.0 ) {\n        ts = -bs - sqrt( ts );\n\t\tif( ts>0. ) {\n\t\t\tnormal = normalize( ((ro+ts*rd)-sph.xyz)/sph.w );\n\t\t\treturn true;\n\t\t}\n    }\n\n    return false;\n}\n\nvec3 intersect( const vec3 ro, const vec3 rd ) {\n\tfloat maxd = 1500.0;\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float t = 0.0;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<140; i++ ) {\n\t\tif( abs(h)<precis || t>maxd ) break; {\n\t\t\tt += h;\n\t\t\tvec2 mt = mapTerrain( ro+rd*t );\n\t\t\th = 0.96*mt.x;\n\t\t\tm = mt.y;\n\t\t}\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nfloat intersectSimple( const vec3 ro, const vec3 rd ) {\n\tfloat maxd = 10000.0;\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ ) {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\th = mapSimpleTerrain( ro+rd*t );\n\t\t}\n    }\n\n    return t;\n}\n\nvec3 calcNormal( const vec3 pos ) {\n    vec3 eps = vec3(0.1,0.0,0.0);\n\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy).x - mapTerrain(pos-eps.xyy).x,\n           mapTerrain(pos+eps.yxy).x - mapTerrain(pos-eps.yxy).x,\n           mapTerrain(pos+eps.yyx).x - mapTerrain(pos-eps.yyx).x ) );\n}\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = mapTerrain( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvoid getSkyColor( in vec3 rd, out vec3 bgcol, out vec3 col ) {\n\tvec3 lig = normalize( vec3( -2.5, 1.7, 2.5 ) );\n\t\n\tbgcol = 1.1*vec3(0.15,0.15,0.4) - rd.y*0.4;\t\n\tbgcol *= 0.3;\n    float moon = clamp( dot(rd,lig), 0.0, 1.0 );\n\tbgcol += vec3(2.0,1.5,0.8)*0.015*pow( moon, 32.0 );\n\t\n\tcol = bgcol;\n\t\n#ifdef SHOW_MOON_AND_CLOUDS\t\n\t// moon!\n\tvec3 normal;\n\tif( intersectSphere( vec3(0., 0., 0.), rd, vec4( lig, 0.03), normal ) ) {\n\t\tfloat l = dot( normalize( vec3( 2.2, -1.9, 0.5)), normal )*(0.4+texture( iChannel2, normal.xy*0.5 ).y);\n\t\tcol += 0.2*clamp( 2.5*vec3(2.0,1.5,0.8)*clamp(l, 0.0, 1.), vec3(0.), vec3(1.) );\n\t}\t\t\t\n\t\n// cloud function by inigo: https://www.shadertoy.com/view/Mds3z2 \n\tvec2 cuv = rd.xz*(100.0)/rd.y;\n\tfloat cc = texture( iChannel2, 0.0001*cuv +0.1+ 0.0013*time ).x;\n\tcc = 0.65*cc + 0.35*texture( iChannel2, 0.0001*2.0*cuv + 0.0013*.5*time ).x;\n\tcc = smoothstep( 0.3, 1.0, 1.1*cc );\n\tcol = mix( col, 0.1*vec3(0.05,0.05,0.4), 0.99*cc );\n#endif\n}\n\n//-----------------------------------------------------\n\nvec3 path( float time ) {\n\tfloat z = time*CAMERASPEED;\t\n\treturn vec3( -getXoffset(z)+5.*cos(time*0.1), 1.25, z );\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = iTime+43.;\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\t\n    // camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x/iResolution.x;\n\ttime += off;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\t\n\tta.y *= 1.1 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.07*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\t\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\t\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\t\n\t// raymarch\n    float distSimple = intersectSimple(ro,rd);\n\tbool reflection = false;\n\t\n\tfloat dist, totaldist = 0., depth = 0.;\n\tvec3 normal, tmat, lp, lig;\n\t\n\tif( intersectPlane( ro, rd, 0., dist ) && dist < distSimple ) {\t\t\t\n\t\tro = ro+rd*dist;\n\t\ttotaldist = dist;\n\t\t\n\t\tdepth = mapTerrain(ro).x;\n\t\t\n\t\tvec2 coord = ro.xz;\n\t\tvec2 dx = vec2( EPSILON, 0. );\n\t\tvec2 dz = vec2( 0., EPSILON );\n\t\t\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\t\t\t\t\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tnormal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) / (2. * EPSILON);\n\t\tnormal.z = -bumpfactor * (waterHeightMap(coord + dz) - waterHeightMap(coord-dz) ) / (2. * EPSILON);\n\t\tnormal = normalize( normal );\n\t\t\n\t\trd = reflect( rd, normal );\n\t\treflection = true;\n\t} \n\t\n\t// intersect scene\t\n\ttmat = intersect(ro,rd);\n\ttotaldist += tmat.x;\n\t\n\t// sky\t \n\tvec3 col, bgcol;\n\tgetSkyColor( rd, bgcol, col );\n\t\t\t\n    vec3 pos = ro + tmat.x*rd;\n\t\n    if( tmat.z>-0.5 && totaldist < 500.) {\n\t\t// info building hit\n\t\tvec2 buildingInfo = getBuildingInfo( pos );\t\t\t\n\t\tvec4 buildingParams = getBuildingParams( buildingInfo.x );\n\t\t\t\n\t\tfloat z = buildingInfo.y;\n\t\tlp = vec3( 11.5*sign(buildingInfo.x)-getXoffset(z), 6.0, z );\n\t\tlig = normalize(lp-pos);\n\t\t\n\t\t// geometry\n        vec3 nor = calcNormal(pos);\n\t\t\t\t\n        // material\n\t\tvec3 mate, origmate;\n\t\tvec3 matpos = pos*0.3;\n\t\t\n#ifdef SHOW_GALLERY\n\t\tif( tmat.z == 5. )\n\t\tmate.xyz = texcube(iChannel3, matpos, nor ).xyz*0.2;\n\t\t\telse\n#endif\n\t\torigmate = mate.xyz = texcube(iChannel1, matpos, nor ).xyz*0.4;\n\t\t\n\t\tbool aboveGallery = false;\n\t\t\n\t\tif( tmat.z == 3. ) mate.xyz = 160.*vec3(1.30,1.10,0.40);\n\t\telse if( tmat.z == 2. ) mate.xyz *= \n\t\t\tclamp( 4.*texture( iChannel2, buildingInfo.x*vec2(1.4231153121) ).xyz\n\t\t\t,vec3(0.), vec3(1.) );\n\t\t\t\n\t\t// lighting\n\t\tfloat occ = calcAO( pos, nor );\n        float amb = clamp(0.5 + 0.5*nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n\t\tif( tmat.z == 5. && pos.y > GALLERYHEIGHT-2.6 ) {\n\t\t\tdif = abs(dot(nor,lig));\n\t\t\tmate.xyz = vec3(0.3,0.,0.);\n\t\t}\n\t\tdif /= dot( lp-pos,lp-pos );\n\t\t\n        float bac = max(0.2 + 0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n\t\t\n\t\tif( buildingParams.z == 1. && pos.y > GALLERYHEIGHT ) {\n\t\t\taboveGallery=true;\n\t\t}\t\t\n\t\tvec3 lcol = aboveGallery?vec3(2.9, 1.65, 0.65 ):vec3(1.30,0.60,0.40);\n\t\t\n\t\t// lights\n\t\tvec3 brdf = vec3(0.0);\n        brdf += (60.0*dif)*lcol;\n\t\tbrdf += (0.1*amb)*vec3(0.10,0.15,0.30);\n\t\tbrdf += (0.1*bac)*vec3(0.09,0.03,0.01);\n\t\t\n\t\t// surface-light interacion\n\t\tcol = (mate.xyz*brdf)*occ;\n\t\t\n\t\t// in room ?\n\t\tfloat isLeft = sign(buildingInfo.x);\n\t\t\n\t\tif( ((pos.x+getXoffset( pos.z ))*isLeft > buildingParams.y+20.25 &&\n\t\t    abs( pos.z-buildingInfo.y ) < 8.5 &&\n\t\t  \tpos.y < buildingParams.x-0.5) || false ) {\n\t\t\t\n\t\t\tvec2 roomcoord = pos.zy;\n\t\t\troomcoord.x = floor( (roomcoord.x-buildingInfo.y+5.) / 3.5 ) * 3.5 +\n\t\t\t\t\t\t  floor( (buildingInfo.y+5. ) / 10.) * 10.;\n\t\t\troomcoord.y = floor( roomcoord.y / 9. ) * 9.;\n\t\t\t\n\t\t\tif( noise( vec3(roomcoord*1.15321*isLeft, time*0.0005 ) ) > -0.1 ) {\n\t\t\t\tvec3 rlc = vec3( \n\t\t\t\t\t(buildingParams.y+3.+20.25)*isLeft-getXoffset( roomcoord.x-5. ), \n\t\t\t\t\troomcoord.y+5.5, \n\t\t\t\t\troomcoord.x-5. );\n\t\t\t\t\tvec3 ld = rlc-pos;\n\t\t\t\t\tdif = max(dot(nor,normalize(ld) ),0.0)/dot(ld,ld);\n\t\t\t\t\tcol += origmate*(dif*120.)*texture( iChannel2, roomcoord*0.1231 ).xyz;\n\t\t\t}\n\t\t}\n\n#ifdef SHOW_LIGHTS\n\t\t// and extra lights!\n\t\tfloat basez = floor( (pos.z)/2. )*2.-2.0;\n\t\tfor(int i=0; i<3; i++) {\n\t\t\tbuildingInfo = getBuildingInfo( vec3( pos.x, pos.y, basez ) );\n\t\t\t// check if building lights here\n\t\t\tif( abs( basez - buildingInfo.y ) > 8.75 ||\n\t\t\t  \tnoise( buildingInfo ) > 0.15 ) {\n\t\t\t\tbasez += 2.;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuildingParams = getBuildingParams( buildingInfo.x );\n\t\t\tvec3 rlc = vec3( (buildingParams.y-1.+20.25)*isLeft-getXoffset( basez ),\n\t\t\t\t\t\t7.7-1.5*abs(sin(basez*0.3)), basez );\n\t\t\tvec3 ld = rlc-pos;\n\t\t\tdif = max(dot(nor,normalize(ld) ),0.0)/dot(ld,ld);\n\t\t\tcol += mate.xyz*(dif*6.0)*texture( iChannel2, vec2(basez*time*0.0001)*0.1231 ).xyz;\t\n\t\t\tbasez += 2.;\n\t\t}\n#endif\n\t\n\t\tif( reflection ) {\n\t\t\tcol = mix( bgcol, col, exp(-0.00000001*pow(totaldist-dist,3.0)) );\t\t\n\t\t\tcol *= 0.9*vec3( 0.8, 0.9, 1. )*(0.5+clamp( depth*2., 0.0, 0.5));\t\t\n\t\t\tif( dist != totaldist ) totaldist = dist;\n\t\t} \n\t\tcol = mix( bgcol, col, exp(-0.00000001*pow(totaldist,3.0)) );\n\t} \n\n\t\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = clamp( col, 0.0, 1.0 );\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t\n\tcol *= vec3(1.03,1.02,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, tmat.x);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}