{
    "Shader": {
        "info": {
            "date": "1615302069",
            "description": "fork- riff #1234\n//https://www.shadertoy.com/view/WlSGWw",
            "flags": 8,
            "hasliked": 0,
            "id": "WlVfWd",
            "likes": 3,
            "name": "fork- riff #1234",
            "published": 3,
            "tags": [
                "forkriff1234"
            ],
            "usePreview": 0,
            "username": "jorge2017a1",
            "viewed": 316
        },
        "renderpass": [
            {
                "code": "//modificado por jorge flores p.  -9-mar-2020\n//https://www.shadertoy.com/view/wlcfRB\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float signal = uv.x;\n    \n    float quantizedSignal = round(signal * 8.0)/8.0;\n    \n    float error = abs(quantizedSignal-signal);\n    //error /= 0.125;\n    error /= 0.0625;\n    \n    float compare = round(signal * 8.0) / 8.0;\n    \n    //float outputCol = mix(error, compare, step(0.5, uv.y));\n    float outputCol = error;\n    float s = 0.5 + 0.5*cos(iTime+length(uv.xyx+vec3(0,2,4) ));\n    \n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 col1=vec3(outputCol*s+0.25,outputCol*s+0.3,outputCol*s+0.3);\n    \n    float t1 =mod(iTime, 3.);\n    float t2 =mod(iTime, 6.);\n    \n    if (t1<t2)\n        col1*=col;\n    \n    \n    fragColor = vec4(col1,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//modificado por jorge flores p.  -9-mar-2020\n\n//Created by nabr in 2019-06-05\n//https://www.shadertoy.com/view/WlSGWw\nvec2 mainSound( in int samp,float time){return m(time);}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//modificado por jorge flores p.  -9-mar-2020\n\n//Created by nabr in 2019-06-05\n//https://www.shadertoy.com/view/WlSGWw\n\n\n\n// nabr\n// https://www.shadertoy.com/view/WlSGWw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n\nvec2 synthv2( float t)\n{\n// --------- SYNTH\n    int t1=int(t) % 5;\n\tvec2 s = sin(t * mat4x2(496, 656, 696, 376, 776, 456, 656, 276)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n        \n    return s;\n }  \n   \n\nvec2 synthv3( float pt)\n{\n    float t=mod(pt,10.0);\n// --------- SYNTH\n    int t1=int(t) % 5;\n\tvec2 s = sin(t * mat4x2(3496, 1656, 1696, 1376, 1776, 1456, 1656, 276)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n        \n    return s;\n }  \n\nvec2 m(float t)\n{\n\t\n    // --------- SYNTH\n    int t1=int(t) % 8;\n\tvec2 s = sin(t * mat4x2(596, 756, 796, 476, 676, 356, 556, 476)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n    \n    \n    vec2 s2= synthv2( t);\n    float ta1=mod(t,5.);\n    float ta2=mod(t,10.);\n    if (ta1<ta2)\n    s+=s2;\n    else\n    s+=5.0*s2*sin(s2);\n    \n    \n    vec2 s3= synthv3( t);\n    s+=s3;\n    \n\t// --------- DRUMS(kick)\n    \n\tfloat tm = mod(t, .5);\n    float tm2 = mod(t, 1.8);\n    \n\tif(t<6.) tm = mod(t, 1.5); // intro\n\tfloat finetune = 1.8;\n    \n    if(tm<6.) tm = mod(tm, 2.5); // intro\n\tfloat finetune2 = 2.8;\n    \n\t// kick\n\t\n    float k = (sin(80.0 * exp(-sin(tm * finetune) * 10.0)) * exp(-tm * 10.0));\n\tk *= cos(120.0 * exp(-tm * 2.0));\n    \n    \n    \n    // sub\n\tfloat kovt = (k - sin(tm * 580.) * exp(-tm * 1.5));\n\tkovt *= min(1., tm * 100.) * max(0., .5 - tm);\n\tkovt -= (.25 - asin(kovt * tm * 12.));\n\tk *= min(1., tm * 500.) * max(0., 1. - tm);\n\tk = 1.9 * (kovt + k);\n    \n    \n    \n\t\n    // -------- MASTER\n    \n\treturn (k + .4 * s ) * .25;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}