{
    "Shader": {
        "info": {
            "date": "1500757195",
            "description": "The most tested singleplayer adventure of all times and one of my favourite ones! \nWASD + click for aiming and F for shooting blue portal. You can enter through the orange portal.\nSorry about trash code and that.  Use FANCY_SHADOWS in buffer B and D.",
            "flags": 112,
            "hasliked": 0,
            "id": "XsjBDm",
            "likes": 17,
            "name": "[SH17B]Portal",
            "published": 3,
            "tags": [
                "raymarching",
                "voxel",
                "portal"
            ],
            "usePreview": 1,
            "username": "Nesvi7",
            "viewed": 1974
        },
        "renderpass": [
            {
                "code": "//By Nestor Vina\n\n//Thanks to iq for the voxel casting algorithm and thanks to the shadertoy comunity for this year of sharing and learning.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    fragColor = texture(iChannel0,(fragCoord.xy/iResolution.xy));\n    \n    float orangeLevel = 0., blueLevel = 0.;\n    const float limit = 12.;\n    vec3 c;\n    \n\tfor(float i = -limit; i < limit; i++)\n        for(float j = -limit; j < limit; j++){\n           c = texelFetch(iChannel0,ivec2(fragCoord.xy)+ivec2(i,j),0).rgb;\n\t\t   orangeLevel += c == vec3(1,.5,0) ? .006: 0.;\n           blueLevel += c == vec3(0,0,1) ? .006: 0.;\n        }   \n    \n    \n    float fire = texture(iChannel2,fragCoord.xy/iResolution.xy*5.+iTime*.1).r;\n    fragColor.rgb = mix( fragColor.rgb, vec3(1,.5,0)+fire*.5, clamp(orangeLevel-fire,0.,1.) );\n    fragColor.rgb = mix( fragColor.rgb, vec3(0,0,1.)+fire*.5, clamp(blueLevel - fire,0.,1.) );\n    \n    if(fragColor.a >= 1. && fragColor.a <= 2.){\n        fragColor.rgb += (fragColor.a-1.) * vec3(1,.5,.9);\n    }\n    else if(fragColor.a >= 3.){\n        fragColor.rgb += (fragColor.a-3.) * vec3(1.5,1.5,1.5);\n    }\n    \n    \n    //fragColor = texture(iChannel3,fragCoord.xy/iResolution.xy );\n    //fragColor += texture(iChannel1, fragCoord.xy/iResolution.xy );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define fly\nconst float KEY_LEFT  = 65.5/256.0;\nconst float KEY_UP    = 87.5/256.0;\nconst float KEY_RIGHT = 68.5/256.0;\nconst float KEY_DOWN  = 83.5/256.0;\nconst float KEY_F = 70.5/256.0;\n\n\n//Normals \nconst float normal_step = 0.02;\t\nconst vec3 dx = vec3( normal_step, 0.0, 0.0 );\nconst vec3 dy = vec3( 0.0, normal_step, 0.0 );\nconst vec3 dz = vec3( 0.0, 0.0, normal_step );\n\n\nconst float PI = 3.14159265359;\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n#define udBox(p,b) length(max(abs(p)-b,0.0))\n\n\nfloat MapSDF(in vec3 p){\n    p += vec3(-15,-1,-15)-1.;\n\tfloat theFloor = udBox(p+vec3(0,.5,0), vec3(13,.5,13));\n    theFloor = min(theFloor,udBox(p+vec3(11,-5.51,0), vec3(4,.5,13)));\n    theFloor = min(theFloor,udBox(p+vec3(0,-18.5,0), vec3(16,.5,16)));\n    \n    float walls =  udBox(p+vec3(0,-9,7.5),vec3(7,9,.5));\n    walls = min(walls, udBox(p+vec3(7.5,-3,0),vec3(.5,3,7)));\n    walls = min(walls, udBox(p+vec3(5.,-3,-7.5),vec3(3,3,.5)));\n    walls = min(walls, udBox(p+vec3(-5.,-3,-7.5),vec3(3,3,.5)));\n    \n    \n    walls = min(walls, udBox(p+vec3(-7.5,-4,0),vec3(.5,3,7)));\n    walls = min(walls, udBox(p+vec3(-7.5,-3,0),vec3(.5,3,7)));\n    walls = min(walls, udBox(p+vec3(-7.5,-15,0),vec3(.5,3,7)));\n    walls = min(walls, udBox(p+vec3(-7.5,-9,-6.),vec3(.5,3,1)));\n    walls = min(walls, udBox(p+vec3(-7.5,-9,6.),vec3(.5,3,1)));\n    walls = min(walls, udBox(p+vec3(9.,-9,-7.5),vec3(6,3,.5)));\n    walls = min(walls, udBox(p+vec3(-5.,-9,-7.5),vec3(2,3,.5)));\n    walls = min(walls, udBox(p+vec3(-6.,-15,-7.5),vec3(1,3,.5)));\n    walls = min(walls, udBox(p+vec3(7.,-15,-7.5),vec3(2,3,.5)));\n    walls = min(walls, udBox(p+vec3(13.,-15,-7.5),vec3(2,3,.5)));\n    \n    walls = min(walls, udBox(p+vec3(0,-9,-13.5),vec3(7,9,.5)));\n    walls = min(walls, udBox(p+vec3(7.5,-9,-10.5),vec3(.5,9,2.5)));\n    walls = min(walls, udBox(p+vec3(-7.5,-9,-10.5),vec3(.5,9,2.5)));\n    \n    //Muro +x\n    walls = min(walls, udBox(p+vec3(15.5,-12,0),vec3(.5,6,7)));\n    //Muro +z\n    walls = min(walls,udBox(p+vec3(11,-15,7.5),vec3(4,3,.5)));\n    walls = min(walls,udBox(p+vec3(8,-9,7.5),vec3(1,3,.5)));\n    walls = min(walls,udBox(p+vec3(14,-9,7.5),vec3(1,3,.5)));\n    \n    walls = min(walls, udBox(p+vec3(8.5,-7,14.),vec3(.5,5,7)));\n    walls = min(walls, udBox(p+vec3(13.5,-7,14.),vec3(.5,5,7)));\n    walls = min(walls, udBox(p+vec3(12.5,-7,13.),vec3(3.5,5,.5)));\n    walls = min(walls, udBox(p+vec3(12.5,-13,13.),vec3(3.5,.5,5.5)));\n    \n    float glass = 9999.;\n    glass = min(glass, udBox(p+vec3(10.,-15,-7.5),vec3(1,3,.5)));\n    glass = min(glass, udBox(p+vec3(-7.5,-10,0.),vec3(.5,3,6)));\n    \n    return min(min(theFloor,walls),glass);\n}\n\nvec3 Normal( vec3 pos ){\n\n\treturn normalize (\n\t\tvec3(\n\t\t\tMapSDF( pos + dx ) - MapSDF( pos - dx ),\n\t\t\tMapSDF( pos + dy  ) - MapSDF( pos - dy ),\n\t\t\tMapSDF( pos + dz) - MapSDF( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\nbool Cast(vec3 origin, vec3 dir, float maxDist, out vec3 p){\n    float depth = 0.1;\n    \n\tfor(int i = 0; i < 20; i++){\n        //float dist = MapMat(camPos + result.depth * dir, result.matID );\n        p = origin + depth*dir;\n        float dist = MapSDF(p);\n\t\tdepth += dist;\n        if(depth >= maxDist){\n            return false;\n        }\n        \n        if( dist < 0.02){\n            return true;\n        }        \t\n    }\n    \n    return false;\n}\n\nstruct Portal{\n\tvec3 n; \n    vec3 p;\n};\n    \nPortal portalA, portalB;\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    portalA.p = vec3(-9,-3.5,-15);\n    portalA.n = vec3(1,0,0);\n    portalB.p = texture(iChannel1,vec2(0.3,0.0)).xyz;\n    portalB.n = texture(iChannel1,vec2(0.4,0.0)).xyz;\n   \n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float key = max(clamp(texture(iChannel0, vec2(90.5, 0.5)/255.).x, 0., 1.),\n                  clamp(texture(iChannel0, vec2(37.5, 0.5)/255.).x, 0., 1.));\n    \n    float mouseY = -iMouse.y/iResolution.y*10.0+PI*2.;//mouseY < -PI*1.5 ? -PI*1.5 : mouseY > -PI*.5? -PI*.5 : mouseY\n    vec2 cameraRot = vec2(mouseY < -PI*.5 ?-PI*.5 : mouseY > PI*.5? PI*.5 : mouseY,iMouse.x/iResolution.x*10.)+texture(iChannel1,vec2(0.45,0.0)).yx;\n    vec3 cameraPos = texture(iChannel1,vec2(0.2,0.0)).xyz;\n    \n    //Process input    \n     \n    mat3 cameraRotationMatrix = rotationXY( cameraRot );\n    \n    vec3 castp;\n    const float movementSpeed = .1;\n    if(uv.y <= 0.1){\n        if(uv.x <= 0.1 ){\n            if((texture( iChannel0, vec2(KEY_UP,0.5/3.0) ).x == 1.0) && length( cameraPos + portalA.p ) < 1.5 ){\n            \tvec3 normal = texture(iChannel1,vec2(0.4,0.0)).xyz;                \n                fragColor = vec4(cameraRot.xy + vec2(0., normal.x > .9 ? PI : normal.z > .9 ? PI * .5 : normal.z < -.9 ? -PI * .5 : 0.),0.0,0.0);\n            }\n            else{\n                fragColor = vec4(cameraRot.xy,0.0,0.0);\n            }\n    \t}\n        else if(uv.x <= 0.2 ){//Position\n            \n            if(iFrame == 0 ||fragColor.y < -10.)\n                fragColor = vec4(15,3,15,1);\n    \t\tif(texture( iChannel0, vec2(KEY_UP,0.5/3.0)).x == 1.0){\n                if( length( fragColor.xyz + portalA.p ) < 1.5 ){\n                \tfragColor.xyz = -portalB.p+portalB.n*.2;\n                }\n                \n\t\t\t\tvec3 movement = cameraRotationMatrix*normalize(vec3(0.0,0.0,1.0));\n                #ifdef fly\n                movement.y = 0.;\n                #endif\n                movement = normalize(movement)*movementSpeed;\n                movement = MapSDF(fragColor.xyz + movement) < 1.2 ? (MapSDF(fragColor.xyz) <= MapSDF(fragColor.xyz + movement)? movement : vec3(0)) : movement;\n\t\t\t\tfragColor += vec4(movement,0.0);\n    \t\t}\n            \n            if(texture( iChannel0, vec2(KEY_DOWN,0.5/4.0)).x == 1.0){\n                vec3 movement = cameraRotationMatrix*normalize(vec3(0.0,0.0,1.0));\n                #ifdef fly\n                movement.y = 0.;\n                #endif\n                movement = normalize(movement)*movementSpeed;\n                movement = MapSDF(fragColor.xyz + movement) < 1.2 ? (MapSDF(fragColor.xyz) <= MapSDF(fragColor.xyz - movement)? movement : vec3(0)) : movement;\n\t\t\t\tfragColor -= vec4(movement,0.0);\n    \t\t}\n            \n            if(texture( iChannel0, vec2(KEY_LEFT,0.5/4.0)).x == 1.0){\n\t\t\t\tvec3 movement = cameraRotationMatrix*normalize(vec3(1.0,0.0,0.0));\n                #ifdef fly\n                movement.y = 0.;\n                #endif\n                movement = normalize(movement)*movementSpeed;\n                movement = MapSDF(fragColor.xyz + movement) < 1.2 ? (MapSDF(fragColor.xyz) <= MapSDF(fragColor.xyz - movement)? movement : vec3(0)) : movement;\n\t\t\t\tfragColor -= vec4(movement,0.0);\n    \t\t}\n            \n            if(texture( iChannel0, vec2(KEY_RIGHT,0.5/4.0)).x == 1.0){\n\t\t\t\tvec3 movement = cameraRotationMatrix*normalize(vec3(1.0,0.0,0.0));\n                #ifdef fly\n                movement.y = 0.;\n                #endif\n                movement = normalize(movement)*movementSpeed;\n                movement = MapSDF(fragColor.xyz + movement) < 1.2 ? (MapSDF(fragColor.xyz) <= MapSDF(fragColor.xyz + movement)? movement : vec3(0)) : movement;\n\t\t\t\tfragColor += vec4(movement,0.0);\n    \t\t}\n            #ifdef fly\n            fragColor = Cast(fragColor.xyz+vec3(0,-1.8,0),vec3(0,1,0),1.,castp) ? fragColor : fragColor + vec4(0,-.2,0,0);\n            #endif\n    \t}\n        else if(uv.x <= 0.3){\n            if(iFrame == 0 ){\n                fragColor.rgb = vec3(-1,-10.5,-15);;\n            }\n            else if(texture( iChannel0, vec2(KEY_F,0.5/4.0)).x == 1.0){\n                vec3 dir = cameraRotationMatrix*normalize(vec3(0.0,0.0,1.0));\n                vec3 initial = fragColor.xyz;\n            \tfragColor.xyz = Cast(cameraPos,dir,50.,castp) ? -castp : initial; \n                vec3 normal = Normal(castp);\n            \tfragColor.xyz = abs(normal.y)>.5 ? initial : fragColor.xyz;  \n            }\n        }        \n        else if(uv.x <= 0.4){\n            if(iFrame == 0 ||fragColor.y < -10.){\n                fragColor.rgb = vec3(1,0,0);\n            }\n            else if(texture( iChannel0, vec2(KEY_F,0.5/4.0)).x == 1.0){\n                vec3 dir = cameraRotationMatrix*normalize(vec3(0.0,0.0,1.0));\n                dir = normalize(dir);\n                Cast(cameraPos,dir,100.,castp);\n                vec3 normal = Normal(castp);\n            \tfragColor.xyz = abs(normal.y) > .5 ? fragColor.xyz : normal;  \n            }\n        }   \n        else if((uv.x <= 0.5 ) && (texture( iChannel0, vec2(KEY_UP,0.5/3.0) ).x == 1.0) && length( cameraPos + portalA.p ) < 1.5 ){\n            \tvec3 normal = texture(iChannel1,vec2(0.35,0.0)).xyz;\n\t\t\t\tfragColor.x += normal.x > .9 ? PI : normal.z > .9 ? PI * .5 : normal.z < -.9 ? -PI * .5 : 0.;\n                fragColor.y = 0.;\t\t\t\n            \t\n        }   \n        \n        if(uv.x >0.5 && uv.x <= 0.6 && texture( iChannel0, vec2(KEY_F,0.5/4.0)).x == 1.0){\n            fragColor = vec4((cameraPos - cameraRotationMatrix*vec3(-.4,0.2,-.8)), iTime);\n        }\n        \n    }\n    else\n        fragColor = texture(iChannel1,uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define FANCY_SHADOWS\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.01;//0.02 for more bumpy surface\nconst float clip_far = 2000.;\nconst float clip_near = .8;\n\n// math\nconst float PI = 3.14159265359;\nconst float TWOPI = PI*2.0;\nconst float DEG_TO_RAD = PI / 180.0;\n\n//Normals \nconst float normal_step = 0.02;\t\nconst vec3 dx = vec3( normal_step, 0.0, 0.0 );\nconst vec3 dy = vec3( 0.0, normal_step, 0.0 );\nconst vec3 dz = vec3( 0.0, 0.0, normal_step );\n\n//Light \nconst vec3 light_dir = vec3(1,1,0);\n\nstruct IntersectResult{\n\tvec3 p;\n\tfloat depth;\n    int matID;\n    vec3 n;\n};\n\nstruct Portal{\n\tvec3 n; \n    vec3 p;\n};\n    \nvec4 lights[] = vec4[] (vec4(15,1.,15,40.),vec4(15,10.,15,40.),vec4(0.,10.,15,20.));\n\nPortal portalA, portalB;\nvec3 cameraPosition;\nvec4 bulletData;\nmat3 rot;\n\nvec3 RayDir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( xy, z ) );\n}\n\n\n#define udBox(p,b) length(max(abs(p)-b,0.0))\n\nfloat Portals( in vec3 p, out int id, float currentDist){\n    int myid;\n    \n    vec3 ap = p;\n    ap.z += abs(portalA.n.x) > 0.3? sin(p.y*10.+iTime*10.)*.1 : 0.;\n    ap.x += abs(portalA.n.x) > 0.3? 0. : sin(p.y*20.+iTime*10.)*.1;\n    \n    vec3 bp = p;\n    bp.z += abs(portalB.n.x) > 0.3? sin(p.y*10.+iTime*10.)*.1 : 0.;\n    bp.x += abs(portalB.n.x) > 0.3? 0. : sin(p.y*10.+iTime*10.)*.1;\n    \n    float portalBRadious = 1.5*min((iTime-bulletData.w)/.5-1.,1.);//* (sin(iTime*5.)*.5 +.5 );\n    float portala = udBox(ap+portalA.p,vec3(.02,2.,2.));\n    portala = max(length((ap+portalA.p))-1.5,portala);\n    vec3 boxScale = abs(portalB.n.x) > 0.3? vec3(.02,2.,2.) : vec3(2.,2.,.02);\n    float portalb = udBox(bp+portalB.p, boxScale);\n    portalb = max(length(bp+portalB.p)-portalBRadious,portalb);\n    myid = portala < portalb ? length(ap+portalA.p) > 1.4 ? 6 : 3 : length(bp+portalB.p) > 1.4 ? 5 : 4;\n    float dist = min(portala, portalb);\n    \n    id = dist < currentDist ? myid : id;\n    return min(dist,currentDist);\n}\n\nfloat PortalBullet( in vec3 p, out int id, float currentDist ){\n\tfloat dist = (length(p+mix(-bulletData.xyz,portalB.p,(iTime-bulletData.w)/.5))-.1);\n    int myid = 5;\n    id = dist < currentDist ? myid : id;\n    return min(dist,currentDist);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderH( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat PortalGun(in vec3 p, out int id, float currentDist){\n\tint myid = 7;\n    \n    p -= cameraPosition + rot*vec3(0,0,-.7+1.*cos(min((iTime-bulletData.w)/.1-1.,1.)));\n    float white = sdEllipsoid( (p + rot*vec3(-.4,0.2,-.8))*rot, vec3(.1,.1,.2));\n    white = min( white, sdEllipsoid( (p + rot*vec3(-.4,0.27,-1.2))*rot, vec3(.1,.05,.2)));\n    \n    float black = sdCappedCylinder( (p + rot*vec3(-.4,0.2,-1.1))*rot, vec2(.04,.2));\n    black = min(black,sdCappedCylinder( (p + rot*vec3(-.4,0.2,-1.3))*rot, vec2(.08,.01)));\n    black = min(black,sdCappedCylinder( (p + rot*vec3(-.4,0.2,-1.4))*rot, vec2(.07,.03)));\n    \n    \n    myid = white < black ? 7 : 8;\n    float dist = min(black,white);\n    \n    id = dist < currentDist ? myid : id;\n    return min(dist,currentDist);\n}\n\nfloat Cake(in vec3 p, out int id, float currentDist){\n\tint myid = 9;\n    float dist;\n    dist = sdCappedCylinderH(p,vec2(.3,.2));\n    float a = sdCappedCylinderH(p,vec2(.01,.4));\n    myid = a < dist ? 10 : myid;\n    dist = min(dist,a);\n    for(float i = 0.; i < 6.; i++){\n    \ta = length(p - vec3(sin(i)*.2,0.2,cos(i)*.2))-.05;\n        myid = a < dist ? 11 : myid;\n    \tdist = min(dist,a);    \n    }\n    \n    id = dist < currentDist ? myid : id;\n    return min(dist,currentDist);\n    \n}\n\nfloat MapMat( in vec3 p, out int id){\n    int portalid,portalgunid,portalbulletid,cakeid;\n    \n    float portals = Portals(p,portalid,9999999.);\n    float portalBullet = PortalBullet(p,portalbulletid,9999999.);\n\tfloat portalGun = PortalGun(p,portalgunid,9999999.);\n    float cake = Cake(p+vec3(-12,-2.2,-25),cakeid,9999999.);\n    \n    float dist = min(min(min(portals, portalBullet),portalGun),cake);\n    \n    id = dist == cake ? cakeid: id;\n    id = dist == portals ? portalid : id;\n    id = dist == portalBullet ? portalbulletid: id;\n    id = dist == portalGun ? portalgunid: id;\n    return dist;\n}\n\nvec3 Normal( vec3 pos, in vec3 dir ){\n\tint aux;\n    vec3 aux2;\n\treturn normalize (\n\t\tvec3(\n\t\t\tMapMat( pos + dx, aux ) - MapMat( pos - dx, aux),\n\t\t\tMapMat( pos + dy, aux ) - MapMat( pos - dy, aux),\n\t\t\tMapMat( pos + dz, aux) - MapMat( pos - dz, aux )\t\t\t\n\t\t)\n\t);\n}\n\nIntersectResult Intersect(vec3 camPos, vec3 dir){\n    IntersectResult result;\n    result.p = vec3(0);\n    result.depth = clip_near;\n    result.matID = 0;\n    \n    int detectedID = 0;\n    \n    for(int i = 0; i < 30; i++){\n        float dist = MapMat(camPos + result.depth * dir, result.matID);\n\t\tresult.depth += dist;\n        if(result.depth >= clip_far){\n            result.depth = clip_far;\n            result.matID = -1;\n            result.p = camPos+dir * result.depth;\n    \t\tresult.n = Normal(result.p,dir);\n            return result;\n        }\n        \n        if( dist < stop_threshold){\n            result.p = camPos+dir * result.depth;\n    \t\tresult.n = Normal(result.p,dir);\n            return result;\n        }\n        \t\n    }\n    \n    result.depth = clip_far;\n    result.matID = -1;\n    result.p = camPos+dir * result.depth;\n    result.n = Normal(result.p,dir);\n    return result;    \n}\n\n\nivec2 PointToTextureCoords(in vec3 p){\n\tint size = 32;\n    const float squareSide = 4.;\n    p = floor(p.xyz);\n    p.xz = mod(p.xz,float(size));\n    return ivec2(p.xz)+ivec2(int(mod(p.y,squareSide))*size,int(floor(p.y/squareSide))*size);\n}\n\nbool VoxelMap( in vec3 p ){\n    \n\treturn texelFetch(iChannel2,PointToTextureCoords(p),0).r == 1.;\n}\n\n//IQ's voxel casting\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir, out vec3 nor)\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ )  \n\t{\n\t\tif( VoxelMap(pos) ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tnor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir, out vec3 nor)\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<52; i++ )  \n\t{\n\t\tif( VoxelMap(pos) ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tnor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nIntersectResult IntersectMap(vec3 camPos, vec3 dir, float dontuseportal){\n    IntersectResult result;\n    vec3 a,b, nor;    \n    result.depth = castRay( camPos,  dir, a, b, nor );\n    result.matID = abs(nor.y)>.3 ? 1: 2;\n    result.p = camPos+dir * result.depth;\n    result.n = nor;\n    return result;\n\n}\n\nvec4 WallsMaterial( in IntersectResult ir ){\n    ir.p.x += 1.;\n    ir.p.y -= 2.;\n    ir.p.z += 1.;\n\tvec2 uv = abs(ir.n.x) > .5 ? ir.p.zy : ir.p.xy;\n    uv *= vec2(.5,1./6.);\n    uv = mod(uv,1.);\n    //uv.x += iTime;\n    vec4 c = texture(iChannel0,uv);\n    c = pow(c,vec4(.7));\n    c = vec4(c.r);\n    c *= pow(min(uv.x,1.-uv.x)*min(uv.y,1.-uv.y),.3)+.4;\n    return c;\n}\n\nvec4 FloorMaterial( in IntersectResult ir ){\n\tvec2 uv = ir.p.xz;\n    uv = mod(uv,1.);\n    vec4 c = texture(iChannel0,uv);\n    c = pow(c,vec4(.7));\n    c = vec4(c.r);\n    c *= pow(min(uv.x,1.-uv.x)*min(uv.y,1.-uv.y),.3)+.4;\n    c *= vec4(0.8,1.,1.1,0.)*.8;//vec4(0.8,1.,1.1,0.);\n    return c;\n}\n\n#ifdef FANCY_SHADOWS\nvec4 PointLight(int val, in IntersectResult ir){\n    vec3 a,b, nor;  \n    vec3 v = lights[val].xyz-ir.p;\n    float dist = castShadowRay( ir.p+ir.n*.02, normalize(v), a, b, nor );\n    dist = dist < length(v) ? 0.4: 1.;\n    return vec4(pow(max(1.-min(1.,length(lights[val].xyz-ir.p)/lights[val].w),0.),3.))*dist;\n}\n#else\nvec4 PointLight(int val, in IntersectResult ir){\n    return vec4(pow(max(1.-min(1.,length(lights[val].xyz-ir.p)/lights[val].w),0.),3.));\n}\n#endif\n\nvec4 NormalPointLight(int val, in IntersectResult ir){\n    vec3 v = lights[val].xyz-ir.p;\n    return vec4(1.)*max(0.,dot(ir.n,normalize(v)))*pow(max(1.-min(1.,length(v)/lights[val].w),0.),3.);\n}\n\nvec4 PortalAMaterial(in IntersectResult ir){\n    vec2 uv = (-portalA.p + ir.p).xz;\n    return vec4(ir.p,.5);//length(ir.p+portalA.p)<.5?.5:.6);\n}\n\nvec4 BluePortal( in IntersectResult ir ){\n    vec3 bp = ir.p;\n    bp.z += abs(portalB.n.x) > 0.3? sin(ir.p.y*10.+iTime*10.)*.1 : 0.;\n    bp.x += abs(portalB.n.x) > 0.3? 0. : sin(ir.p.y*10.+iTime*10.)*.1;\n    return vec4(0,0,1,3.+(1.-abs((length( bp + portalB.p ) -1.4)/.12-.5)/.5));\n}\n\nvec4 OrangePortal( in IntersectResult ir ){\n    vec3 ap = ir.p;\n    ap.z += abs(portalA.n.x) > 0.3? sin(ir.p.y*10.+iTime*10.)*.1 : 0.;\n    ap.x += abs(portalA.n.x) > 0.3? 0. : sin(ir.p.y*10.+iTime*10.)*.1;\n    return vec4(1,.5,0,1.+(1.-abs((length( ap + portalA.p ) -1.4)/.12-.5)/.5));\n}\n\nvec4 ProcessMaterials( in IntersectResult ir, in vec3 dir, in vec3 camPos ){\n\n    vec4 c = vec4(0);//\n    vec4 il;\n    switch( ir.matID ){\n        case -1:\n        \tc = vec4(vec3(.5),0);\n        \tbreak;\n        case 1:        \n        \til = PointLight(0,ir)+PointLight(1,ir)+PointLight(2,ir);\t\n            c = FloorMaterial(ir)*il;\n            break;\n        case 2: \n        \til = PointLight(0,ir)+PointLight(1,ir)+PointLight(2,ir);\n        \tc = WallsMaterial(ir)*il;\n        \tbreak;\n        case 3: \n        \tc = PortalAMaterial(ir);\n        \tbreak;\n        case 4:\n        \tc = vec4(ir.p,.4);\n        \tbreak;\n        case 5: //Orange\n        \tc = BluePortal(ir);\n        \tbreak;\n        case 6: //blue\n        \tc = OrangePortal(ir);\n        \tbreak;\n        case 7:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = vec4(.7,.7,.7,0.)+il*.5;\n        \tbreak;\n        case 8:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = vec4(.02,.02,.02,0.)+il*.5;\n        \tbreak;\n        case 9:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = sqrt(texture(iChannel1,ir.p.xz))*vec4(42.,21.,6.,0.)/255.+il*.5;\n        \tbreak;\n        case 10:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = vec4(.8,.8,.8,1.)+il*.5;\n        \tbreak;\n        case 11:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = mix(vec4(1,1,1,1),vec4(.8,.3,.3,0.),dot(ir.n,vec3(0,1,0)))+il*.5;\n        \tbreak;\n        \t\n    }\n    \n    return c;\n}\n\nvec4 Sky( in vec3 dir ){\n    return mix(vec4(.3,.5,.3,1),vec4(.3,.5,1,1),dot(dir,vec3(0,1,0))*.5+.5);\n}\n\nvec4 Fog(in vec4 color, in IntersectResult ir, in vec3 dir ){\n    \n    vec4 iColor = color;\n    float f = min(ir.depth*.01,1.);\n    vec4 c = mix( color, Sky(dir), f*f);\n    return (iColor.a == .4 || iColor.a == .5) ? iColor : color;\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    bulletData = texture(iChannel3,vec2(0.55,0.0));\n    \n    portalA.p = vec3(-9,-3.5,-15);\n    portalA.n = vec3(1,0,0);\n    portalB.p = texture(iChannel3,vec2(0.25,0.0)).xyz;\n    portalB.n = texture(iChannel3,vec2(0.35,0.0)).xyz;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 dir = RayDir( 45.0, iResolution.xy, fragCoord.xy );    \n    \n    rot = rotationXY( texture(iChannel3,vec2(0.05,0.0)).xy );\n\t\n    \n    cameraPosition = rot*vec3( 0.0, 0.0, 0.01 );\n    dir = rot* dir;\n    cameraPosition += texture(iChannel3,vec2(0.15,0.0)).xyz;\n    \n    IntersectResult result = IntersectMap(cameraPosition,dir,0.);\n    IntersectResult sdf = Intersect(cameraPosition,dir);\n    \n    if(sdf.depth < result.depth )\n        result = sdf;\n    \n\tfragColor = Fog( ProcessMaterials( result, dir, cameraPosition ), result, dir);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//This is the buffer that contains the voxels from the map\n\n\n#define udBox(p,b) length(max(abs(p)-b,0.0))\nfloat MapSDF( in vec3 p, out int id){\n\tid = 1;\n    p += vec3(-15.1,-1.1,-15.1);\n    float theFloor = udBox(p+vec3(0,.5,0), vec3(13,.5,13));\n    theFloor = min(theFloor,udBox(p+vec3(11,-5.51,0), vec3(4,.5,13)));\n    theFloor = min(theFloor,udBox(p+vec3(0,-18.5,0), vec3(16,.5,16)));\n    \n    float walls =  udBox(p+vec3(0,-9,7.5),vec3(7,9,.5));\n    walls = min(walls, udBox(p+vec3(7.5,-3,0),vec3(.5,3,7)));\n    walls = min(walls, udBox(p+vec3(5.,-3,-7.5),vec3(3,3,.5)));\n    walls = min(walls, udBox(p+vec3(-5.,-3,-7.5),vec3(3,3,.5)));\n    \n    \n    walls = min(walls, udBox(p+vec3(-7.5,-4,0),vec3(.5,3,7)));\n    walls = min(walls, udBox(p+vec3(-7.5,-3,0),vec3(.5,3,7)));\n    walls = min(walls, udBox(p+vec3(-7.5,-15,0),vec3(.5,3,7)));\n    walls = min(walls, udBox(p+vec3(-7.5,-9,-6.),vec3(.5,3,1)));\n    walls = min(walls, udBox(p+vec3(-7.5,-9,6.),vec3(.5,3,1)));\n    walls = min(walls, udBox(p+vec3(9.,-9,-7.5),vec3(6,3,.5)));\n    walls = min(walls, udBox(p+vec3(-5.,-9,-7.5),vec3(2,3,.5)));\n    walls = min(walls, udBox(p+vec3(-6.,-15,-7.5),vec3(1,3,.5)));\n    walls = min(walls, udBox(p+vec3(7.,-15,-7.5),vec3(2,3,.5)));\n    walls = min(walls, udBox(p+vec3(13.,-15,-7.5),vec3(2,3,.5)));\n    \n    walls = min(walls, udBox(p+vec3(0,-9,-13.5),vec3(7,9,.5)));\n    walls = min(walls, udBox(p+vec3(7.5,-9,-10.5),vec3(.5,9,2.5)));\n    walls = min(walls, udBox(p+vec3(-7.5,-9,-10.5),vec3(.5,9,2.5)));\n    \n    //Muro +x\n    walls = min(walls, udBox(p+vec3(15.5,-12,0),vec3(.5,6,7)));\n    //Muro +z\n    walls = min(walls,udBox(p+vec3(11,-15,7.5),vec3(4,3,.5)));\n    walls = min(walls,udBox(p+vec3(8,-9,7.5),vec3(1,3,.5)));\n    walls = min(walls,udBox(p+vec3(14,-9,7.5),vec3(1,3,.5)));\n    \n    walls = min(walls, udBox(p+vec3(8.5,-7,14.),vec3(.5,5,7)));\n    walls = min(walls, udBox(p+vec3(13.5,-7,14.),vec3(.5,5,7)));\n    walls = min(walls, udBox(p+vec3(12.5,-7,13.),vec3(3.5,5,.5)));\n    walls = min(walls, udBox(p+vec3(12.5,-13,13.),vec3(3.5,.5,5.5)));\n    \n    float glass = 9999.;\n    glass = min(glass, udBox(p+vec3(10.,-15,-7.5),vec3(1,3,.5)));\n    glass = min(glass, udBox(p+vec3(-7.5,-10,0.),vec3(.5,3,6)));\n    \n    //walls = glass;\n\n    id = theFloor < walls ? 1 : 2;\n    id = glass < min(theFloor,walls) ? 6: id;\n    \n    return min(min(theFloor,walls),glass);\n}\n\nvec3 TextureCoordsToPoint(in ivec2 coords){\n    int size = 32;\n    const int squareSide = 4;\n    vec3 p;\n    p.xz = mod(vec2(coords.xy),float(size));\n    \n    ivec2 index = coords.xy/size;\n    p.y = float(index.y*squareSide+index.x);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if(iFrame != 0 ){\n        int a;\n        if(MapSDF(TextureCoordsToPoint(ivec2(fragCoord)),a) <.1){\n            fragColor = vec4(1.0,0.0,1.0,1.0);\n        }\n        else{\n            fragColor = vec4(0.0,0.0,1.0,1.0);\n        }\n\t}\n\telse{\n       fragColor = texelFetch(iChannel1,ivec2(fragCoord),0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 11521,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/gdfhdhsoundcloud/portal-still-alive-2"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define FANCY_SHADOWS\n\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.01;//0.02 for more bumpy surface\nconst float clip_far = 2000.;\nconst float clip_near = 1.;\n\nstruct IntersectResult{\n\tvec3 p;\n\tfloat depth;\n    int matID;\n    vec3 n;\n};\n//Hey\n//Normals \nconst float normal_step = 0.02;\t\nconst vec3 dx = vec3( normal_step, 0.0, 0.0 );\nconst vec3 dy = vec3( 0.0, normal_step, 0.0 );\nconst vec3 dz = vec3( 0.0, 0.0, normal_step );\n\n// math\nconst float PI = 3.14159265359;\nconst float TWOPI = PI*2.0;\nconst float DEG_TO_RAD = PI / 180.0;\n\nstruct Portal{\n\tvec3 n; \n    vec3 p;\n};\n    \nPortal portalA, portalB;\n    \nvec4 lights[] = vec4[] (vec4(15,1.,15,40.),vec4(15,10.,15,40.),vec4(0.,10.,15,20.));\n\nmat3 rot;\nvec3 cameraPosition;\nvec4 bulletData;\n\n#define udBox(p,b) length(max(abs(p)-b,0.0))\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderH( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat PortalGun(in vec3 p, out int id){\n\tid = 7;\n    \n    p -= cameraPosition + rot*vec3(0,0,-.7+1.*cos(min((iTime-bulletData.w)/.1-1.,1.)));\n    float white = sdEllipsoid( (p + rot*vec3(-.4,0.2,-.8))*rot, vec3(.1,.1,.2));\n    white = min( white, sdEllipsoid( (p + rot*vec3(-.4,0.27,-1.2))*rot, vec3(.1,.05,.2)));\n    \n    float black = sdCappedCylinder( (p + rot*vec3(-.4,0.2,-1.1))*rot, vec2(.04,.2));\n    black = min(black,sdCappedCylinder( (p + rot*vec3(-.4,0.2,-1.3))*rot, vec2(.08,.01)));\n    black = min(black,sdCappedCylinder( (p + rot*vec3(-.4,0.2,-1.4))*rot, vec2(.07,.03)));\n    \n    \n    id = white < black ? 7 : 8;\n    return min(black,white);\n}\n\nfloat Cake(in vec3 p, out int id, float currentDist){\n\tint myid = 9;\n    float dist;\n    dist = sdCappedCylinderH(p,vec2(.3,.2));\n    float a = sdCappedCylinderH(p,vec2(.01,.4));\n    myid = a < dist ? 10 : myid;\n    dist = min(dist,a);\n    for(float i = 0.; i < 6.; i++){\n    \ta = length(p - vec3(sin(i)*.2,0.2,cos(i)*.2))-.05;\n        myid = a < dist ? 11 : myid;\n    \tdist = min(dist,a);    \n    }\n    \n    id = dist < currentDist ? myid : id;\n    return min(dist,currentDist);\n    \n}\n\nfloat MapMat( in vec3 p, out int id){\n    float map = PortalGun(p,id);\n    map = Cake(p+vec3(-12,-2.2,-25),id,map);\n    return map;\n}\n\nvec3 Normal( vec3 pos, in vec3 dir ){\n\tint aux;\n    vec3 aux2;\n\treturn normalize (\n\t\tvec3(\n\t\t\tMapMat( pos + dx, aux ) - MapMat( pos - dx, aux ),\n\t\t\tMapMat( pos + dy, aux ) - MapMat( pos - dy, aux ),\n\t\t\tMapMat( pos + dz, aux) - MapMat( pos - dz, aux )\t\t\t\n\t\t)\n\t);\n}\n\nIntersectResult Intersect(vec3 camPos, vec3 dir){\n    IntersectResult result;\n    result.p = vec3(0);\n    result.depth = clip_near;\n    result.matID = 0;\n    \n    int detectedID = 0;\n    \n    for(int i = 0; i < 30; i++){\n        float dist = MapMat(camPos + result.depth * dir, result.matID);\n\t\tresult.depth += dist;\n        if(result.depth >= clip_far){\n            result.depth = clip_far;\n            result.matID = -1;\n            result.p = camPos+dir * result.depth;\n    \t\tresult.n = Normal(result.p,dir);\n            return result;\n        }\n        \n        if( dist < stop_threshold){\n            result.p = camPos+dir * result.depth;\n    \t\tresult.n = Normal(result.p,dir);\n            return result;\n        }\n        \t\n    }\n    \n    result.depth = clip_far;\n    result.matID = -1;\n    result.p = camPos+dir * result.depth;\n    result.n = Normal(result.p,dir);\n    return result;    \n}\n\nivec2 PointToTextureCoords(in vec3 p){\n\tint size = 32;\n    const float squareSide = 4.;\n    p = floor(p.xyz);\n    p.xz = mod(p.xz,float(size));\n    return ivec2(p.xz)+ivec2(int(mod(p.y,squareSide))*size,int(floor(p.y/squareSide))*size);\n}\n\nbool VoxelMap( in vec3 p ){\n\treturn texelFetch(iChannel2,PointToTextureCoords(p),0).r == 1.;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir, out vec3 nor)\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ )  \n\t{\n\t\tif( VoxelMap(pos) ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tnor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir, out vec3 nor)\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<52; i++ )  \n\t{\n\t\tif( VoxelMap(pos) ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tnor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nIntersectResult IntersectMap(vec3 camPos, vec3 dir){\n    IntersectResult result;\n    vec3 a,b, nor;    \n    result.depth = castRay( camPos,  dir, a, b, nor );\n    result.matID = abs(nor.y)>.3 ? 1: 2;\n    result.p = camPos+dir * result.depth;\n    result.n = nor;\n    return result;\n\n}\n\n\nvec4 WallsMaterial( in IntersectResult ir ){\n\tir.p.x += 1.;\n    ir.p.y -= 2.;\n    ir.p.z += 1.;\n\tvec2 uv = abs(ir.n.x) > .5 ? ir.p.zy : ir.p.xy;\n    uv *= vec2(.5,1./6.);\n    uv = mod(uv,1.);\n    //uv.x += iTime;\n    vec4 c = texture(iChannel0,uv);\n    c = pow(c,vec4(.7));\n    c = vec4(c.r);\n    c *= pow(min(uv.x,1.-uv.x)*min(uv.y,1.-uv.y),.3)+.4;\n    //c.gb *= c.r*6.;\n    return c;\n}\n\nvec4 FloorMaterial( in IntersectResult ir ){\n\tvec2 uv = ir.p.xz;\n    uv = mod(uv,1.);\n    vec4 c = texture(iChannel0,uv);\n    c = pow(c,vec4(.7));\n    c = vec4(c.r);\n    c *= pow(min(uv.x,1.-uv.x)*min(uv.y,1.-uv.y),.3)+.4;\n    c *= vec4(0.8,1.,1.1,0.)*.8;//vec4(0.8,1.,1.1,0.);\n    return c;\n}\n\n#ifdef FANCY_SHADOWS\nvec4 PointLight(int val, in IntersectResult ir){\n    vec3 a,b, nor;  \n    vec3 v = lights[val].xyz-ir.p;\n    float dist = castShadowRay( ir.p+ir.n*.02, normalize(v), a, b, nor );\n    dist = dist < length(v) ? 0.4: 1.;\n    return vec4(pow(max(1.-min(1.,length(lights[val].xyz-ir.p)/lights[val].w),0.),3.))*dist;\n}\n#else\nvec4 PointLight(int val, in IntersectResult ir){\n    return vec4(pow(max(1.-min(1.,length(lights[val].xyz-ir.p)/lights[val].w),0.),3.));\n}\n#endif\n\nvec4 NormalPointLight(int val, in IntersectResult ir){\n    vec3 v = lights[val].xyz-ir.p;\n    return vec4(1,1,1,0)*max(0.,dot(ir.n,normalize(v)))*pow(max(1.-min(1.,length(v)/lights[val].w),0.),3.);\n}\n\nvec4 ProcessMaterials( in IntersectResult ir, in vec3 dir){\n    float snow = max(dot(ir.n,vec3(0.,-1.,0.)),0.);\n    \n    vec4 c = vec4(0);\n    vec4 il;\n    switch( ir.matID ){\n        case -1:\n        \tc = vec4(0,.5,0,0);\n        \tbreak;\n        case 1:\n        \til = PointLight(0,ir)+PointLight(1,ir)+PointLight(2,ir);\n            c = FloorMaterial(ir)*il;//return vec4(l,l,l,1.)*(vec4(mod(floor(ir.p.x)+floor(ir.p.z)+floor(ir.p.y),2.))*.5+.5);\n            break;\n        case 2: \n        \til = PointLight(0,ir)+PointLight(1,ir)+PointLight(2,ir);\n        \tc = WallsMaterial(ir)*il;\n        \tbreak;\n        case 3:  //ray enters in portal A\n        \tc = vec4(ir.p,.5);\n        \tbreak;\n        case 4:\n        \tc = vec4(ir.p,.4);\n        \tbreak;\n        case 7:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = vec4(.7,.7,.7,0.)+il*.5;\n        \tbreak;\n        case 8:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = vec4(.02,.02,.02,0.)+il*.5;\n        \tbreak;\n\t\tcase 9:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = sqrt(texture(iChannel0,ir.p.xz))*vec4(42.,21.,6.,255.)/255.+il*.5;\n        \tbreak;\n        case 10:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = vec4(.8,.8,.8,0)+il*.5;\n        \tbreak;\n        case 11:\n        \til = NormalPointLight(0,ir)+NormalPointLight(1,ir)+NormalPointLight(2,ir);\t\n        \tc = mix(vec4(1,1,1,0),vec4(.8,.3,.3,0.),dot(ir.n,vec3(0,1,0)))+il*.5;\n        \tbreak;\n    }\n    \n    return c;\n}\n\nvec3 RayDir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( xy, z ) );\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    bulletData = texture(iChannel3,vec2(0.55,0.0));\n    \n    portalA.p = vec3(-9,-4.,-15);\n    portalA.n = vec3(1,0,0);\n    portalB.p = texture(iChannel3,vec2(0.25,0.0)).xyz;//\n    portalB.n = texture(iChannel3,vec2(0.35,0.0)).xyz;\n    \n    fragColor = texture(iChannel1,fragCoord.xy/iResolution.xy);\n    \n    \n    rot = rotationXY( texture(iChannel3,vec2(0.05,0.0)).xy );\n    cameraPosition = rot*vec3( 0.0, 0.0, 0.01 );\n    \n    vec3 origin, dir;\n    if(fragColor.a == .4){//portal b (Down) movable\n        \n        cameraPosition += texture(iChannel3,vec2(0.15,0.0)).xyz;\n\n            \n        dir = RayDir( 45.0, iResolution.xy, fragCoord.xy ); \n        dir = rot* dir;\n        \n        vec3 portalNormal = texture(iChannel3,vec2(0.35,0.0)).xyz;\n        dir.xz = portalB.n.x < -.95 ? dir.xz : -dir.xz;\n        dir.xz = portalB.n.z < -.95 ? vec2(-dir.z,dir.x) : dir.xz;\n        dir.xz = portalB.n.z > .95 ? vec2(dir.z,-dir.x) : dir.xz;\n        \n        vec3 p = fragColor.xyz;\n        vec3 offset =  portalB.p+ p;\n        offset.xz = portalB.n.x < -.95? offset.xz : -offset.xz;\n        offset.xz = portalB.n.z < -.95? offset.zx : offset.xz;\n        offset.xz = portalB.n.z > .95? -offset.zx : offset.xz;\n            \n        origin = -portalA.p + portalA.n*.03 + offset;        \n    }\n    else if(fragColor.a == .5){//portal a \n        \n        cameraPosition += texture(iChannel3,vec2(0.15,0.0)).xyz;\n\n            \n        dir = RayDir( 45.0, iResolution.xy, fragCoord.xy ); \n        dir = rot* dir;\n        dir.xz = portalB.n.x < -.95 ? dir.xz : -dir.xz;\n        dir.xz = portalB.n.z < -.95 ? vec2(dir.z,-dir.x) : dir.xz;\n        dir.xz = portalB.n.z > .95 ? vec2(-dir.z,dir.x) : dir.xz;\n        \n        vec3 p = fragColor.xyz;\n        vec3 offset =  portalA.p+ p;\n        offset.xz = portalB.n.x < -.95? offset.xz : -offset.xz;\n        offset.xz = portalB.n.z < -.95? offset.zx : offset.xz;\n        offset.xz = portalB.n.z > .95? -offset.zx : offset.xz;\n        \n        origin = -portalB.p+portalB.n*.03 + offset;   \n    }\n    \n    if(fragColor.a == .5 || fragColor.a == .4){\n     \tIntersectResult ir = IntersectMap(origin, dir);         \n        IntersectResult ir2 = Intersect(origin,dir);\n        \n        if( ir.depth < ir2.depth )\n        \tfragColor = ProcessMaterials(ir,dir);\n        else\n            fragColor = ProcessMaterials(ir2,dir);   \n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}