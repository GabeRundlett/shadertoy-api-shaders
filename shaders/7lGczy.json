{
    "Shader": {
        "info": {
            "date": "1661712313",
            "description": "no comment",
            "flags": 0,
            "hasliked": 0,
            "id": "7lGczy",
            "likes": 3,
            "name": "RaceBall",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 0,
            "username": "Behzod",
            "viewed": 188
        },
        "renderpass": [
            {
                "code": "\n/**\n    * Thanks in advance for Shader Tutorial site\n    * https://inspirnathan.com/posts/53-shadertoy-tutorial-part-7\n    \n    |; happy code\n    \n    */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst vec3 COLOR_BACKGROUND = vec3(0.835, 1, 1);\n\nconst float roadW = 9.0;\nconst float rumbleW = roadW/3.0;\n\nfloat sdSphere(vec3 p, float r)\n{\n  float d = length(p) - r;\n  return d;\n}\n\nfloat road(vec3 p) {\n  float d = p.y + 1./* + 0.3*sin(p.z) + 0.3*/;\n  \n  float left = p.x + roadW/2.;\n  d = max(d, -left);\n  float right = -p.x + roadW/2.;\n  d = max(d, -right);\n  return d;\n}\n\nfloat rumble(vec3 p) {\n  float d = p.y + 0.7;\n  float rw = rumbleW;\n  float left = p.x + roadW/2. + rw;\n  float right = -p.x + roadW/2. + rw;\n  d = min( max(max(d, -left), left-rw), max( max(d, -right), right-rw) );\n  \n  return d;\n}\n\nfloat grass(vec3 p) {\n  float d = p.y + 1.0;\n  float rw = rumbleW;\n  float left = p.x + roadW/2. + rw;\n  float right = -p.x + roadW/2. + rw;\n  return min(max(d, left), max(d, right));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.); // ID = 0\n  vec2 flooring = vec2(road(p), 0.5); // ID = 0.5\n  vec2 sphereLeft = vec2(sdSphere(p - vec3(-2.5, 0, -2), 1.), 1.5); // ID = 1.5\n  vec2 sphereRight = vec2(sdSphere(p - vec3(2.5, 0, -2), 1.), 2.5); // ID = 2.5\n  vec2 rumbling = vec2(rumble(p), 3.5); // ID = 3.5\n  vec2 grassing = vec2(grass(p), 4.5);\n  \n  res = opU(res, flooring);\n  res = opU(res, sphereLeft);\n  res = opU(res, sphereRight);\n  res = opU(res, rumbling);\n  res = opU(res, grassing);\n  return res; // the y-component is the ID of the object hit by the ray\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  vec2 res = vec2(0.0); // initialize result to zero for signed distance value and ID\n  float id = 0.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    res = map(p); // find resulting target hit by ray\n    depth += res.x;\n    id = res.y;\n    if (res.x < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  return vec2(depth, id);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = COLOR_BACKGROUND;\n    \n    vec2 res = rayMarch(ro, rd);\n    float d = res.x; // signed distance value\n    if (d > MAX_DIST) return col; // render background color since ray hit nothing\n\n\tfloat id = res.y; // id of object\n    \n    vec3 p = ro + rd * d; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    if (id > 0.) col = dif * vec3(0.7*mod(floor(p.x) + floor(p.z), 2.0), .5, .5);\n    if (id > 1.) col = dif * vec3(0, .8, .8);\n    if (id > 2.) col = dif * vec3(1, 0.58, 0.29);\n    if (id > 3.) col = dif * vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    if (id > 4.) col = dif * vec3(0, .7, .2);\n    \n    col += COLOR_BACKGROUND * 0.2; // add a bit of the background color to blend objects more with the scene\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(10.*sin(iTime), 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  \n  vec3 col = render(ro, rd);\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}