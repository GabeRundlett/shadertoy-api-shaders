{
    "Shader": {
        "info": {
            "date": "1608924092",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "ttccW8",
            "likes": 28,
            "name": "Day 373",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 504
        },
        "renderpass": [
            {
                "code": "\n// fibonacci, texture lookup noise and sdf functions from IQ!\n// aces film from knarkowitz\n\n\n\nfloat noise3D( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\nfloat na = 0.;\n\nfloat getLeaves(vec3 p, vec3 offs){\n    float d = 10e5;\n\n\n    vec4 fib = inverseSF(normalize(p),N);\n\n\n    p *= makeBase(normalize( fib.xyz ));\n\n\n    p.z -= R;\n    \n    p.y -= smoothstep(0.2,0.,abs(p.x)*3.)*0.05*(1. - smoothstep(0.,1.,p.z*1. + 0.3));\n\n    float leaf = length(p) - leafSz;\n    \n    leaf = opSmoothUnion( leaf, max(length(p.yx) - 0.03,p.z), 0.04 );\n    \n    leaf -= smoothstep(0.2,0.,abs(p.x)*3.)*0.05;\n    \n    leaf = opSmoothSubtraction( -leaf, abs(p.y) - 0.02, 0.1 );\n    \n    d = min(d, leaf );\n    \n    return d;\n}\n\n\n\n\nfloat doLeaves(vec3 p){\n    float d = 10e5;\n    float ramt = PHI*1.*PI*4.;\n    vec3 op = p;\n    p = sphericalFromCart(p);\n\n    float transitionLen = 0.4;\n    \n    p.y += smoothstep(0.,1.6 ,p.x+ (na=noise3D(op + iTime*2.))*0.2)*0.4*smoothstep(0.,1.,abs(p.y));\n    \n    p.y -= sin(iTime*0.4 +iMouse.y/iResolution.y*PI )*0.2 + 0.1;\n    p = cartFromSpherical(p);    \n    p.yz *= rot(0.5*PI);\n    \n    \n    \n    d = min(d, getLeaves(p,vec3(0)));\n    \n    p.xz *= rot(ramt);\n    //p.xy *= rot(0.6);\n    \n    d = min(d,getLeaves(p,vec3(0)));\n    \n    p.xz *= rot(ramt);\n    \n    d = min(d,getLeaves(p,vec3(0)));\n    p.xz *= rot(ramt);\n    \n    d = min(d,getLeaves(p,vec3(0)));\n    return d;\n}\n\nvec3 petalAccum = vec3(0);\n\nfloat petalDens = 0.;\nvec2 doFlower(vec3 p, float hScale, float bendAmt, float blendpw){\n    vec2 d = vec2(10e5);\n    float h = stickSz*hScale;\n    p.xy *= rot(pow(smoothstep(0.,1.,p.y/h - 0.1),blendpw)*bendAmt);\n    float stick = sdRoundCone(p, vec3(0), vec3(0,h,0), 0.02, 0.015);\n    \n\n    p -= vec3(0,h,0);\n    \n    vec4 fib = inverseSF(normalize(p),190.);\n    p *= makeBase(normalize( fib.xyz ));\n    \n    //p.z -= RPetal;\n    \n    float petal = sdRoundCone(p, vec3(0), vec3(0.,0.,RPetal), -0.01, 0.00)*1.;\n    float petalBeginning = sdRoundCone(p, vec3(0), vec3(0.,0.,RPetal*0.3), -0.01, 0.00)*1.;\n    float petalBall = length(p - vec3(0,0,RPetal)) - 0.014;\n    \n    \n    petal = min(petal, petalBall);\n    petal = min(petal, petalBeginning);\n    if(!hit){\n        float amt =0.0015/(.003 + 100.*petal*petal)*(1.-petalDens);\n        petalDens += amt*float(petalDens<1.);\n        vec3 c = vec3(0.6,0.4,0.45);\n        c = mix(c,vec3(0.4,0.2,0.1)*0.4,smoothstep(0.01,0.,petalBeginning - 0.03));\n        c = mix(c,vec3(0.6,0.7,0.55),smoothstep(0.01,0.,petalBall - 0.03));\n        petalAccum += c*amt*float(petalDens<1.);\n    }\n        //exp(-petal*20.);\n    \n    \n    d.x = min(d.x,abs(petal - 0.0) + 0.04);\n    //petal = length(p.xy) - 0.01;\n    d = dmin(d,stick,2.);\n    //d = dmin(d,petal,1.);\n    return d;\n}\n\nvoid doParticles(vec3 p, float rep){\n    \n    p.x += iTime;\n    vec3 op = p;\n    p.y = opRepLim(p.y,1.,5.);\n    p.xz = pmod(p.xz,rep);\n    \n    p.y -= sin(op.x + iTime)*0.4 - 0.2 + noise3D(op)*0.5;\n\n    //float petal = sdRoundCone(p, vec3(0), vec3(0.,0.,RPetal), 0.01, 0.01)*1.;\n    //float petalBeginning = sdRoundCone(p, vec3(0), vec3(0.,0.,RPetal*0.3), -0.01, 0.00)*1.;\n    float petalBall = length(p - vec3(0,0,RPetal)) - 0.014;\n    \n    \n    float petal = petalBall;\n    //petal = min(petal, petalBall);\n    //petal = min(petal, petalBeginning);\n    if(!hit){\n        float amt =0.0015/(.003 + 100.*petal*petal)*(1.-petalDens);\n        petalDens += amt*float(petalDens<1.);\n        vec3 c = vec3(0.6,0.4,0.45);\n        //c = mix(c,vec3(0.4,0.2,0.1)*0.4,smoothstep(0.01,0.,petalBeginning - 0.03));\n        c = mix(c,vec3(0.6,0.7,0.55),smoothstep(0.01,0.,petalBall - 0.03));\n        petalAccum += c*amt*float(petalDens<1.);\n    }\n    \n}\n\nvec2 doFlowers(vec3 p){\n    vec2 d = vec2(10e5);\n     \n    p.x += noise3D(vec3(0,0,iTime*3.))*0.09*smoothstep(0.,1.,p.y/stickSz);\n    vec2 flowA = doFlower(abs(p),1.,0.25,0.2);\n    p.xz *= rot(1.4);\n    vec2 flowB = doFlower(abs(p),1.5,0.5,0.4);\n    \n    d = dmin(d,flowA.x,flowA.y);\n    d = dmin(d,flowB.x,flowB.y);\n    doParticles(p,2.);\n    doParticles(p - 2.4,2.);\n    \n    return d;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    float eps = -0.5;\n    \n    vec2 flowers = doFlowers(p);\n    \n    \n    d = dmin(d,flowers.x,1.);\n    d = dmin(d,doLeaves(p),1.);\n    \n    d.x *= 0.5;\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n    \n    vec3 ro = vec3(0);\n    ro.z -= 5.;\n    ro.y += 3.;\n    ro.x -= 2.;\n    ro*=0.8;\n    \n    ro.xz *= rot(-0.2 + iTime*0.2 + 3.*iMouse.x/iResolution.x); \n    \n    \n    \n    col += pal(0.2,0.6,vec3(1,2,3),1.,sin(ro.x)*0.6 - .5 + length(uv) )*1.;\n    col = max(col*0.5,0.);\n    \n    \n    vec3 lookAt = vec3(0,1,0);\n    vec3 rd = getRd(ro,lookAt, uv);\n\n    float t = 0.;\n    vec3 p = ro;\n    \n    for(int i = 0; i < 150; i++){\n        vec2 d = map(p);\n        \n        if(d.x < 0.003){\n            hit = true;\n            break;\n        } else if (t > 7.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x);\n    }\n        \n    vec3 sunDir = normalize(vec3(1));\n    vec3 lightDir = normalize(vec3(1,3,1));\n    \n    vec3 lightCol = vec3(1,0.7,0.7);\n    lightCol = vec3(1,1.,0.7);\n    \n    \n    if(hit){\n        \n        vec3 c = vec3(0);\n        vec3 n = getNormal(p);\n        \n        float ambianceAmt = 0.1;\n        vec3 ambianceCol = ambianceAmt*(lightCol + col);\n        \n        vec3 albedo = 1. + n;\n        albedo = vec3(0.5,0.7,0.3);\n        c += albedo;\n        \n        #define ao(a) smoothstep(0.,1.,map(p + n*a).x/a)\n        \n        #define sss(a) smoothstep(0.,1.,map(p + lightDir*a).x/a)\n        \n        float aoFact = ao(0.2)*mix(ao(0.1),1.,0.2)*mix(ao(.06),1.,0.3)*2. + 0.;\n        float sssFact = sss(.4)*1.4;\n        float shadFact = softshadow( p, lightDir, 0.15, 9., 2. ) + 0.02;\n        shadFact = clamp(shadFact, 0., 1.);\n        shadFact = clamp(aoFact, 0., 1.);\n        shadFact = clamp(sssFact, 0., 1.);\n        c = mix( c, ambianceCol,1.-shadFact);\n        \n        c = mix( c, vec3(0.) + ambianceCol*0.1,1.-aoFact);\n        c = mix( c, lightCol*c*1. + lightCol*0.1,sssFact);\n        \n        col = c;\n    }\n    col = mix(col + petalAccum*0.3,petalAccum*0.89,smoothstep(0.4,1.,length(petalDens)));\n    \n    col *= 1. - dot(uv,uv*0.7)*1.1;\n    col = mix( col, smoothstep(0.,1.,col*1.4), 0.4 );\n    col = mix( col, acesFilm( col ), 0.5 );\n    \n    col = pow(max(col,0.), vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R 1.\n#define RPetal 0.3\n\n#define N (14.)\n\n#define leafSz 0.4\n\n\n#define volSc 0.03\n#define stickSz 1.4\n\n\nbool hit = false;\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n#define opRepLim(p,c,l) (p-c*clamp(round(p/c),-l,l))\n\n\nconst float PI = 3.14159265359;\nconst float PHI = 1.61803398875;\nvec4 inverseSF( in vec3 p, const in float n )\n{\n\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\n    float Fk  = pow(PHI,k)/sqrt(5.0);\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    \n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\n\n    float ma = 0.0;\n    vec4 res = vec4(0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2(s&1,s>>1);\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = 1.0 - (2.0*i+1.0)/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float a = dot(p,q);\n        if (a > ma)\n        {\n            ma = a;\n            res.xyz = q;\n            res.w = i;\n        }\n    }\n    return res;\n}\n\n\n\nmat3 makeBase( in vec3 w )\n{\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    return mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 w);\n}\n\n\nvec3 sphericalFromCart(vec3 p){\n    p.yz *= rot(-0.5*PI);\n    \n    return vec3(\n        length(p),\n        acos(p.z/length(p)),\n        atan(p.y,p.x)\n    );\n}\nvec3 cartFromSpherical(vec3 p){\n    //p.xy *= rot(0.25*PI);\n    \n    return vec3(\n        p.x*sin(p.y)*cos(p.z),\n        p.x*sin(p.y)*sin(p.z),\n        p.x*cos(p.y)\n    );\n}\n\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvec2 dmin(vec2 a, float b, float id){\n    return a.x < b ? a : vec2(b,id);\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    \n    uv *= 0.7;\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}