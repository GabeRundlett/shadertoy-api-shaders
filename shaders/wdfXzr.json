{
    "Shader": {
        "info": {
            "date": "1550478982",
            "description": "Click to Drag! GLSL ES 3.0+\n\nMy first on Shadertoy, be gentle! ;-) \n\nHand-crafted Simpsons SDF! Homer just wants his donut, but darn Kodos wants to stop him!\n\nP.S. Starry background largely borrowed, and credited in the code. All primitives thanks to IQ. ",
            "flags": 0,
            "hasliked": 0,
            "id": "wdfXzr",
            "likes": 33,
            "name": "Homer and Kodos in Space",
            "published": 3,
            "tags": [
                "sdf",
                "cartoon",
                "space",
                "character",
                "reflect",
                "refract",
                "simpsons",
                "homer",
                "kodos"
            ],
            "usePreview": 1,
            "username": "emmasteimann",
            "viewed": 1440
        },
        "renderpass": [
            {
                "code": "// Dangerous! Kodos helmet is reflective!\n#define ALLOWREFLECTIONS\n\n// Slows things too.. Bends Kodos teeth and arm.\n#define ALLOWBENDS\n\n//#define JUSTKODOS\n//#define WITHOUTKODOS\n\n#define PI acos(-1.)\n#define ZERO (min(iFrame,0))\n\n// Scene Spacings:\n// 0 is center.\n\n#define KODOSLIVEHERE 20.0\n#define HOMERLIVESHERE -20.0\n#define CHARACTERSCALE 0.25\n#define CAMERAZOOM 25.0\n#define MAXDISTANCE 100.0\n#define WHERETHEFLOORLIVES 10\n\n// Color Selectors:\n#define ABEAUTIFULBACKGROUND 199.0\n#define WHITEASMYSOUL 2.0\n#define HOMERYELLOW 1.0\n#define TONGUERED 3.0\n#define BROWNBEARD 4.0\n#define KODOSGREEN 7.0\n#define BLACKASNIGHT 0.0\n#define BLUEPANTS 5.0\n#define GREYSHOES 6.0\n#define BLOODREDEYE 99.0\n#define YELLOWEYEBALLS 97.0\n#define LIVERSPOTS 98.0\n#define DROOLBLUE 96.0\n#define KODOSVENT 95.0\n#define KODOSBASECOLOR 10.0\n#define KODOSPINKLIGHTBULB 11.0\n#define DONUTBROWN 70.0\n\n// Timings for positions:\n#define PRECOMPUTEDTIME -1.\n#define PRECOMPUTEDKODOSTIME 1.\n#define PRECOMPUTEDBLINKTIME sin(iTime)\n\nint sceneStack[12];\n\nvec2 homersHeadSDF(vec3 p, float swingTime) {\n    vec2 head = vec2(sdVerticalCapsule(p,5.0,5.0), HOMERYELLOW);\n    \n    float leftEyeSpacing = -1.5;\n    \n    float eyeSize = 1.8;\n    \n    vec3 origP = p;\n    \n    vec3 eyePt = p;\n    eyePt.x = abs(eyePt.x);\n    eyePt = translate(eyePt, vec3(0,-1.5,-1.6));\n    eyePt.yz = rotate(eyePt.yz, PI * -0.15);\n    vec2 eyes = vec2(sdSphere(translate(eyePt, vec3(abs(leftEyeSpacing),2.5,-4)), eyeSize), WHITEASMYSOUL);\n    \n    p.x = -abs(p.x);\n    \n    vec2 leftTopEyelid = vec2(sdSphere(translate(p, vec3(leftEyeSpacing,2.5,-4)), eyeSize+.1), HOMERYELLOW);\n    vec2 leftBottomEyelid = vec2(sdSphere(translate(p, vec3(leftEyeSpacing,2.5,-4)), eyeSize+.1), HOMERYELLOW);\n    \n    vec3 pupilP = eyePt;\n    vec2 pupils = vec2(sdSphere(translate(pupilP, vec3(abs(leftEyeSpacing)+0.15,2.15+(swingTime*0.05),-5.3)), 0.5), BLACKASNIGHT);\n    \n    vec3 eyeSlicePoint = translate(p, vec3(0,3.5,0));\n    eyeSlicePoint.yz = rotate(eyeSlicePoint.yz, PI * abs(PRECOMPUTEDBLINKTIME) * -0.25);\n    vec2 pln = vec2(sdPlane(eyeSlicePoint, normalize(vec4(0,1,0,1))),1.0);\n    \n    diff(leftTopEyelid,pln);\n    \n    vec3 eyeSlicePointB = translate(p, vec3(leftEyeSpacing,1.5,-2));\n    eyeSlicePointB.yz = rotate(eyeSlicePointB.yz, PI * abs(PRECOMPUTEDBLINKTIME) * 0.5);\n    vec2 plnB = vec2(sdPlane(eyeSlicePointB, normalize(vec4(0,-1,0,1))),1.0);\n    \n    diff(leftBottomEyelid,plnB);\n    \n    vec2 nose = vec2(sdCapsule(p, vec3(0.0,1.0,0.0), vec3(0.0,1.0,-6.5), 1.0), HOMERYELLOW);\n    \n    vec3 neckP = translate(p, vec3(0,-3,1));\n    neckP.yz = rotate(neckP.yz, PI * -0.95);\n    vec2 neck = vec2(sdRoundCone(neckP, 3.0, 3.5, 5.0), HOMERYELLOW);\n    \n    // hair\n    vec3 a = translate(p, vec3(0,8,-1));\n    vec3 b = translate(p, vec3(0,8,1));\n    vec2 reset = p.yz;\n    \n    a.yz = rotate(a.yz, PI * 0.5);\n    b.yz = rotate(b.yz, PI * 0.5);\n    \n    // Top Hairs\n    vec2 d5 = vec2(sdTorus(a, vec2(2.75,0.3)), BLACKASNIGHT);\n    vec2 d6 = vec2(sdTorus(b, vec2(2.75,0.3)), BLACKASNIGHT);\n    \n    vec2 lefttEyeBrow = vec2(sdTorus(translate(p, vec3(-1.6,4.5,-4)), vec2(1,0.5)), HOMERYELLOW);\n    \n    vec2 beard = vec2(sdSphere(translate(p, vec3(0,-2,-3)), 3.5), BROWNBEARD);\n    \n    vec3 mouthPoint1 = translate(p, vec3(0,-3,-4.0));\n    mouthPoint1.yz = rotate(mouthPoint1.yz, PI * 0.15);\n    vec2 d11 = vec2(sdTorus(mouthPoint1, vec2(2,0.5)), BROWNBEARD);\n    \n    beard =  vec2(opSmoothUnion(beard.x, d11.x, 0.25), BROWNBEARD);\n    \n    vec3 mouthPoint2 = translate(p, vec3(0,-2.15,-4.25));\n    mouthPoint2.yz = rotate(mouthPoint2.yz, PI * 0.05);\n    vec2 d12 = vec2(sdTorus(mouthPoint2, vec2(2.1,0.7)), BROWNBEARD);\n    \n    beard =  vec2(opSmoothUnion(beard.x, d12.x, 0.75), BROWNBEARD);\n    \n    vec3 mouthPoint3 = translate(p, vec3(0,-3.5,-4.25));\n    mouthPoint3.yz = rotate(mouthPoint3.yz, PI * 0.05);\n    vec2 cylMouth = vec2(sdTorus(mouthPoint3, vec2(2.1,0.7)), BLACKASNIGHT);\n    \n    vec3 earPoint1 = translate(p, vec3(-5,2,0));\n    earPoint1.xy = rotate(earPoint1.xy, PI * 0.5);\n    earPoint1.yz = rotate(earPoint1.yz, PI * -0.15);\n    earPoint1.x *= 0.75;\n    vec2 leftEar = vec2(sdTorus(earPoint1, vec2(0.75,0.4)), HOMERYELLOW);\n    \n    vec3 sidehairP = p;\n    vec2 d15 = vec2(sdCapsule(sidehairP, vec3(-5,6,-1), vec3(-4.75,4,-2), 0.25), BLACKASNIGHT);\n    vec2 d16 = vec2(sdCapsule(sidehairP, vec3(-5,6,-1), vec3(-5,4,0), 0.25), BLACKASNIGHT);\n    vec2 d17 = vec2(sdCapsule(sidehairP, vec3(-5,6,1), vec3(-5,4,0), 0.25), BLACKASNIGHT);\n    vec2 d18 = vec2(sdCapsule(sidehairP, vec3(-5,6,1), vec3(-5,4,2), 0.25), BLACKASNIGHT);\n    \n    \n    // Yellow Parts first\n    head = vec2(opSmoothUnion(head.x, lefttEyeBrow.x, 0.75), HOMERYELLOW);\n    head = vec2(opSmoothUnion(head.x, neck.x, 1.0), HOMERYELLOW);\n    \n    \n    add(head, nose);\n    add(head, eyes);\n    \n    add(head, d5);\n    add(head, d6);\n    \n    vec3 mouthPoint = p;\n    \n    mouthPoint = translate(p, vec3(0,-3.5,-5));\n    mouthPoint.yz = rotate(mouthPoint.yz, PI * 0.05);\n    vec2 openMouth = vec2(sdCappedCylinder(mouthPoint, vec2(3,0.5)), BLACKASNIGHT);\n    \n    vec3 teethPoint = p;\n    teethPoint = translate(p, vec3(0,-3.5,-5));\n    teethPoint.yz = rotate(teethPoint.yz, PI * 0.1);\n    vec2 teethTop = vec2(sdCappedCylinder(translate(teethPoint, vec3(0,0.85,1.75)), vec2(2.5,0.5)), WHITEASMYSOUL);\n    vec2 teethBottom = vec2(sdCappedCylinder(translate(teethPoint, vec3(0,-0.75,2)), vec2(2,0.25)), WHITEASMYSOUL);\n    \n    vec2 slicePln = vec2(sdPlane(translate(mouthPoint, vec3(0,0,-1)), normalize(vec4(0,0,-1,1))), BLACKASNIGHT);\n    diff(openMouth,slicePln);\n    \n    vec3 mouthPointA = mouthPoint;\n    mouthPointA.xy = rotate(mouthPointA.xy, PI * 0.5);\n    \n    vec2 openMouthA = vec2(sdCappedCylinder(mouthPointA, vec2(0.75+ swingTime * 0.10, 3)), BLACKASNIGHT);\n    add(openMouth, openMouthA);\n    \n    beard = vec2(opSmoothSubtraction(openMouth.x, beard.x, 0.8), BROWNBEARD);\n    \n    vec3 tonguePoint = translate(p, vec3(0,-3.75,-4.5));\n    tonguePoint.x *= .5;\n    tonguePoint.yz = rotate(tonguePoint.yz, PI * -0.5);\n    \n    vec2 tongue = vec2(sdRoundCone(tonguePoint, 0.25, 0.5, 1.75), TONGUERED);\n    \n    vec2 subHole = vec2(sdSphere(translate(p, vec3(0,-2.75,-2.85)), 2.25), BLACKASNIGHT);\n    \n    vec2 hollowHole = vec2(sdSphere(translate(p, vec3(0,-2.75,-2.75)), 2.25), BLACKASNIGHT);\n    vec2 slicePlnH = vec2(sdPlane(translate(p, vec3(0,0,-3.2)), normalize(vec4(0,0,1,1))), BLACKASNIGHT);\n    \n    diff(hollowHole, slicePlnH);\n    \n    hollowHole = vec2(opOnion(hollowHole.x,0.05), BLACKASNIGHT);\n    \n    diff(beard, subHole);\n    \n    add(beard, tongue);\n    add(beard, hollowHole);\n    \n    add(beard, teethTop);\n    add(beard, teethBottom);\n    \n    add(head, beard);\n    \n    // ears\n    add(head, leftEar);\n    \n    // hairs\n    add(head, d15);\n    add(head, d16);\n    add(head, d17);\n    add(head, d18);\n    \n    add(head, leftTopEyelid);\n    add(head, leftBottomEyelid);\n    \n    add(head, pupils);\n    \n    return head;\n}\n\nvoid homerTorsoSDF(vec3 p, float swingTime, inout vec2 head) {\n    float bounce = (clamp(swingTime,0.0,-1.0) * 0.75);\n    vec3 collarPoint = translate(p, vec3(0,-8,1.75));\n    \n    vec2 collar = vec2(onion(sdCappedCone(collarPoint, 3.0, 5.5, 3.5), 0.03), WHITEASMYSOUL);\n    vec2 collarTopSlice = vec2(sdPlane(translate(collarPoint, vec3(0,-0.5,0)), normalize(vec4(0,1,0,1))), WHITEASMYSOUL);\n    vec2 collarBottomSlice = vec2(sdPlane(translate(collarPoint, vec3(0,0,0)), normalize(vec4(0,-1,0,1))), WHITEASMYSOUL);\n    \n    diff(collar, collarTopSlice);\n    diff(collar, collarBottomSlice);\n    \n    vec2 collarInside = vec2(onion(sdCappedCone(collarPoint, 3.0, 3.5, 4.25), 0.03), WHITEASMYSOUL);\n    vec2 collarInsideTopSlice = vec2(sdPlane(translate(collarPoint, vec3(0,0,0)), normalize(vec4(0,1,0,1))), WHITEASMYSOUL);\n    vec2 collarInsideBottomSlice = vec2(sdPlane(translate(collarPoint, vec3(0,0,0)), normalize(vec4(0,-1,0,1))), WHITEASMYSOUL);\n    \n    diff(collarInside, collarInsideTopSlice);\n    diff(collarInside, collarInsideBottomSlice);\n    \n    vec2 frontPiece = vec2(sdCappedCone(translate(collarPoint, vec3(0,0,-5)), 3.0, 3.0, 2.0), WHITEASMYSOUL);\n    \n    vec2 frontPieceInside = vec2(sdCappedCone(translate(collarPoint, vec3(0,2,-4)), 3.0, 0.0, 5.0), WHITEASMYSOUL);\n    \n    diff(collar, frontPiece);\n    add(head, collar);\n    \n    diff(collarInside, frontPieceInside);\n    \n    vec2 bodyTop = vec2(sdCappedCone(translate(p, vec3(0,-12,2)), 2.6, 6.0, 4.), WHITEASMYSOUL);\n    \n    collarInside = vec2(opSmoothUnion(collarInside.x, bodyTop.x, 1.0), WHITEASMYSOUL);\n    \n    vec3 tummyPoint = translate(p, vec3(0,-22,2));\n    vec2 tummy = vec2(sdRoundCone(tummyPoint, 10.0-bounce, 3.0, 8.0), WHITEASMYSOUL);\n    collarInside = vec2(opSmoothUnion(collarInside.x, tummy.x, 1.0), WHITEASMYSOUL);\n    \n    vec2 tummySlice = vec2(sdPlane(translate(collarPoint, vec3(0.0,-13.0+bounce,0.0)), normalize(vec4(0,1,0,1))), WHITEASMYSOUL);\n    diff(collarInside, tummySlice);\n    \n    add(head, collarInside);\n}\n\nvoid makeALeg(vec3 lP, vec3 leftLegTopPoint, float swingTime, inout vec2 bottom) {\n    \n    vec3 leftLegBottomPoint = translate(leftLegTopPoint, vec3(0,-10, 0));\n    \n    if (swingTime > 0.0) {\n        leftLegTopPoint.yz = rotate(leftLegTopPoint.yz, PI * swingTime * -0.23);\n        leftLegTopPoint = translate(leftLegTopPoint, vec3(0.0,swingTime * -5.0, swingTime * -8.0));\n        leftLegBottomPoint.yz = rotate(leftLegBottomPoint.yz, PI * clamp(swingTime,0.0,1.0) * 0.23);\n        leftLegBottomPoint = translate(leftLegBottomPoint, vec3(0,clamp(swingTime,0.0,1.0) * 7.0,0.0));\n    }\n    \n    vec2 leftLegTop = vec2(sdRoundCone(leftLegTopPoint, 4.0, 4.0, 8.0), BLUEPANTS);\n    vec2 leftLegBottom = vec2(sdRoundCone(leftLegBottomPoint, 4.0, 4.0, 8.0), BLUEPANTS);\n    leftLegTop = vec2(opSmoothUnion(leftLegTop.x, leftLegBottom.x, 1.0), BLUEPANTS);\n    \n    vec3 leftCapPoint = translate(lP, vec3(leftLegTopPoint.x + lP.x,-27, 0));\n    \n    if (swingTime > 0.0) {\n        leftCapPoint = translate(leftCapPoint, vec3(0,clamp(swingTime,0.0,1.0) * 6.0,clamp(swingTime,0.0,1.0) *-3.5));\n        leftCapPoint.yz = rotate(leftCapPoint.yz, PI * clamp(swingTime,0.0,1.0) * 0.23);\n    }\n    \n    vec2 leftCap = vec2(sdCappedCylinder(leftCapPoint, vec2(4, 1)), BLACKASNIGHT);\n    add(leftLegTop, leftCap);\n    \n    bottom = vec2(opSmoothUnion(bottom.x, leftLegTop.x, 1.0), BLUEPANTS);\n}\n\nvoid makeAShoe(vec3 leftCapPoint, float swingTime, inout vec2 bottom, bool right) {\n    if (swingTime > 0.0) {\n        leftCapPoint = translate(leftCapPoint, vec3(0,clamp(swingTime,0.0,1.0) * 6.0,clamp(swingTime,0.0,1.0) *-3.5));\n        leftCapPoint.yz = rotate(leftCapPoint.yz, PI * clamp(swingTime,0.0,1.0) * 0.23);\n    }\n    vec3 leftShoePoint = translate(leftCapPoint, vec3(0,-4,1));\n    \n    leftShoePoint.yz = rotate(leftShoePoint.yz, PI * 0.5);\n    vec2 leftShoe = vec2(sdRoundCone(leftShoePoint, 3.5, 3.5, 5.0), GREYSHOES);\n    \n    vec2 leftShoeSlice = vec2(sdPlane(translate(leftCapPoint, vec3(0,-3,0)), normalize(vec4(0,1,0,1))), GREYSHOES);\n    diff(leftShoe, leftShoeSlice);\n    \n    vec3 showSlicePoint = translate(leftCapPoint, vec3(0,-4,0));\n    showSlicePoint.xz = rotate(showSlicePoint.xz, PI * 0.5);\n    vec2 shoeSlice = vec2(sdTriPrism(showSlicePoint, vec2(1,50)), GREYSHOES);\n    diff(leftShoe, shoeSlice);\n    add(bottom, leftShoe);\n}\n\nvoid homerBottomSDF(vec3 p, float swingTime, inout vec2 head) {\n    float bounce = (clamp(swingTime,0.0,-1.0) * 0.75);\n    vec3 pantsPoint = translate(p, vec3(0.0,-20.0 + bounce, 2.0));\n    vec2 bottom = vec2(sdSphere(pantsPoint, 9.5), BLUEPANTS);\n    vec2 bottomSlice = vec2(sdPlane(translate(pantsPoint, vec3(0,0,0)), normalize(vec4(0,-1,0,1))), WHITEASMYSOUL);\n    \n    diff(bottom, bottomSlice);\n    \n    vec3 lP = pantsPoint;\n    \n    lP.yz = rotate(lP.yz, PI * swingTime * -0.15);\n    \n    vec3 leftLegTopPoint = translate(lP, vec3(-4.5,-15, 0));\n    makeALeg(lP, leftLegTopPoint, swingTime, bottom);\n    \n    vec3 rP = pantsPoint;\n    \n    float swingTimeOld = swingTime;\n    swingTime = -PRECOMPUTEDTIME;\n    rP.yz = rotate(rP.yz, 3.141592657 * swingTime * -0.15);\n    \n    vec3 rightLegTopPoint = translate(rP, vec3(4.5,-15, 0));\n    makeALeg(rP, rightLegTopPoint, swingTime, bottom);\n    \n    vec3 leftCapPoint = translate(lP, vec3(leftLegTopPoint.x + lP.x,-27, 0));\n    makeAShoe(leftCapPoint, swingTimeOld, bottom, false);\n    vec3 rightCapPoint = translate(rP, vec3(rightLegTopPoint.x + rP.x,-27, 0));\n    makeAShoe(rightCapPoint, swingTime, bottom, true);\n    add(head, bottom);\n}\n\nvec2 makeAnArm(vec3 leftArmPoint) {\n    vec2 leftArmSlice = vec2(sdPlane(translate(leftArmPoint, vec3(0,0.0,0)), normalize(vec4(0,1,0,1))), WHITEASMYSOUL);\n    vec2 leftArm = vec2(sdSphere(leftArmPoint, 3.0), WHITEASMYSOUL);\n    diff(leftArm, leftArmSlice);\n    \n    vec2 leftArmA = vec2(sdRoundCone( translate(leftArmPoint, vec3(0,-5,0)), 2.5, 2.5, 3.0), HOMERYELLOW);\n    \n    vec3 leftArmPointB = leftArmPoint;\n    leftArmPointB.yz = rotate(leftArmPointB.yz, PI * -0.25);\n    vec2 leftArmB = vec2(sdRoundCone( translate(leftArmPointB, vec3(0,-9,4)), 2., 2.5, 3.0), HOMERYELLOW);\n    \n    \n    vec3 Lthumbpoint = translate(leftArmPointB, vec3(0,-13,0));\n    Lthumbpoint.yz = rotate(Lthumbpoint.yz, PI * 0.75);\n    vec2 leftArmBT = vec2(sdRoundCone( translate(Lthumbpoint, vec3(0,-5,1)), 0.5, 0.5, 3.0), HOMERYELLOW);\n    \n    vec3 b1pt =  translate(leftArmPointB, vec3(-0.6,-13,4));\n    b1pt.xy = rotate(b1pt.xy, PI * -0.15);\n    vec2 leftArmB1 = vec2(sdRoundCone( translate(b1pt, vec3(1.6,-.6,0)), 0.5, 0.5, 3.0), HOMERYELLOW);\n    vec2 leftArmB2 = vec2(sdRoundCone( translate(b1pt, vec3(1.6,-.6,1.5)), 0.5, 0.5, 3.0), HOMERYELLOW);\n    vec2 leftArmB3 = vec2(sdRoundCone( translate(b1pt, vec3(1.6,-.6,-1.5)), 0.5, 0.5, 3.0), HOMERYELLOW);\n    \n    leftArmB = vec2(opSmoothUnion(leftArmB.x, leftArmBT.x, 1.0), HOMERYELLOW);\n    leftArmB = vec2(opSmoothUnion(leftArmB.x, leftArmB1.x, 1.0), HOMERYELLOW);\n    leftArmB = vec2(opSmoothUnion(leftArmB.x, leftArmB2.x, 1.0), HOMERYELLOW);\n    leftArmB = vec2(opSmoothUnion(leftArmB.x, leftArmB3.x, 1.0), HOMERYELLOW);\n    \n    leftArmA = vec2(opSmoothUnion(leftArmA.x, leftArmB.x, 1.0), HOMERYELLOW);\n    \n    add(leftArm, leftArmA);\n    return leftArm;\n}\n\nvoid homerArmsSDF(vec3 p, float swingTime, inout vec2 head) {\n    vec3 leftArmPoint = translate(p, vec3(-6,-13,0));\n    leftArmPoint.xy = rotate(leftArmPoint.xy, PI * 0.25);\n    leftArmPoint.yz = rotate(leftArmPoint.yz, PI * PRECOMPUTEDTIME * -0.15);\n    \n    vec2 leftArm = makeAnArm(leftArmPoint);\n    \n    add(head, leftArm);\n    \n    vec3 rightArmPoint = translate(p, vec3(7,-13,2));\n    rightArmPoint.xy = rotate(rightArmPoint.xy, PI * 0.05);\n    \n    rightArmPoint.yz = rotate(rightArmPoint.yz, PI * PRECOMPUTEDTIME * 0.5);\n    \n    vec2 rightArm = makeAnArm(rightArmPoint);\n    \n    add(head, rightArm);\n}\n\nvec2 homerSDF(vec3 point) {\n    float swingTime = 0.0;\n    swingTime = PRECOMPUTEDTIME;\n    float bounce = (clamp(swingTime,0.0,-1.0) * 0.75);\n    vec3 p = translate(point, vec3(0.0,18.0+bounce, HOMERLIVESHERE));\n    vec2 head = homersHeadSDF(p, swingTime);\n    homerTorsoSDF(p, swingTime, head);\n    homerBottomSDF(p, swingTime, head);\n    homerArmsSDF(p, swingTime, head);\n    return head;\n}\n\nvoid makeATooth(vec3 origin, vec3 location, vec3 shape, inout vec2 head) {\n    vec3 toothPoint = translate(origin, location);\n    toothPoint.yz = opBend(toothPoint.yz, 0.05);\n    vec2 tooth = vec2(sdCappedCone(toothPoint, shape.x,shape.y, shape.z), WHITEASMYSOUL);\n    add(head, tooth);\n}\n\nvoid makeMouthSide(vec3 origin, vec3 location, float xyRot, float yxRot, inout vec2 head) {\n    vec3 leftSideMouthPoint = translate(origin, location);\n    leftSideMouthPoint.xy = rotate(leftSideMouthPoint.xy, PI * xyRot);\n    leftSideMouthPoint.yz = rotate(leftSideMouthPoint.yz, PI * yxRot);\n    vec2 leftSideMouth = vec2(sdTorus(leftSideMouthPoint, vec2(7.6, 1.75)), KODOSGREEN);\n    vec2 leftSideMouthSlice = vec2(sdPlane(translate(leftSideMouthPoint, vec3(0,0,0)), normalize(vec4(0,0,1.2,1))), WHITEASMYSOUL);\n    diff(leftSideMouth, leftSideMouthSlice);\n    head =  vec2(opSmoothUnion(head.x, leftSideMouth.x, 0.55), KODOSGREEN);\n    add(head, leftSideMouth);\n}\n\nvec2 kodosSDF(vec3 point) {\n    float swingTime = 0.0;\n    swingTime = PRECOMPUTEDKODOSTIME;\n    \n    vec3 kodosPoint = translate(point, vec3(4,4,KODOSLIVEHERE));\n    vec3 headPoint = translate(kodosPoint, vec3(0,0,0));\n    vec3 mouthCapPoint = translate(kodosPoint, vec3(0,6,-5));\n    \n    vec2 mouthCap = vec2(sdTorus(mouthCapPoint, vec2(4, 4.5)), BLACKASNIGHT);\n    mouthCapPoint.xy = rotate(mouthCapPoint.xy, PI * -0.5);\n    vec2 mouthCap2 = vec2(sdCappedCylinder(translate(mouthCapPoint, vec3(0,0,-2)), vec2(5.5, 20)), BLACKASNIGHT);\n    add(mouthCap, mouthCap2);\n    \n    vec2 head = vec2(sdRoundCone( headPoint, 9., 11.0, 22.0), KODOSGREEN);\n    \n    vec2 headTopSlice = vec2(sdPlane(translate(headPoint, vec3(0,29,0)), normalize(vec4(0,-1,0,1))), WHITEASMYSOUL);\n    head = vec2(opSmoothSubtraction( headTopSlice.x,head.x, 0.8), KODOSGREEN);\n    \n    vec3 headInsidePoint = translate(headPoint, vec3(0,7,-2));\n    headInsidePoint.xz = rotate(headInsidePoint.xz, PI * 0.5);\n    vec2 headInside = vec2(sdEllipsoid( headInsidePoint, vec3(4., 10.0, 10.0)), BLACKASNIGHT);\n    \n    diff(head,mouthCap);\n    \n    vec3 eyePoint = translate(kodosPoint, vec3(0,18,-7.5));\n    \n    vec2 eye = vec2(sdSphere(eyePoint, 5.0),97.0);\n    \n    \n    makeMouthSide(kodosPoint, vec3(5,6.2,-5), -0.46, -0.3, head);\n    makeMouthSide(kodosPoint, vec3(-5,6.2,-5), -0.55, 0.3, head);\n    \n    vec3 lipPoint = translate(kodosPoint, vec3(0,12,-5));\n    lipPoint.xz = rotate(lipPoint.xz, PI * -0.5);\n    lipPoint.xy = rotate(lipPoint.xy, PI * 0.35);\n    vec2 lip = vec2(sdEllipsoid( lipPoint, vec3(3., 7.0, 10.0)), KODOSGREEN);\n    head =  vec2(opSmoothUnion(head.x, lip.x, 0.55), KODOSGREEN);\n    \n    vec3 lipPointB = translate(kodosPoint, vec3(0,-0.4,-3.));\n    lipPointB.xz = rotate(lipPointB.xz, PI * -0.5);\n    lipPointB.xy = rotate(lipPointB.xy, PI * -0.45);\n    vec2 lipB = vec2(sdEllipsoid( lipPointB, vec3(3., 7.0, 10.0)), KODOSGREEN);\n    head =  vec2(opSmoothUnion(head.x, lipB.x, 0.55), KODOSGREEN);\n    \n    add(head, headInside);\n    \n    makeATooth(kodosPoint,vec3(-3,4,-7), vec3(2.5, 1.5, 0.0), head);\n    makeATooth(kodosPoint,vec3(-7,3,-5), vec3(2.5, 1.5, 0.0), head);\n    makeATooth(kodosPoint,vec3(3,4,-7), vec3(2.5, 1.5, 0.0), head);\n    makeATooth(kodosPoint,vec3(7,3,-5), vec3(2.5, 1.5, 0.0), head);\n    makeATooth(kodosPoint,vec3(-2,6,-8.5), vec3(3.5,0.0, 1.5), head);\n    makeATooth(kodosPoint,vec3(-6,7,-6.5), vec3(3., 0.0, 1.5), head);\n    makeATooth(kodosPoint,vec3(2,6,-8.5), vec3(3.5, 0.0, 1.5), head);\n    makeATooth(kodosPoint,vec3(6,7,-6.5), vec3(3., 0.0, 1.5), head);\n    \n    vec3 tooth1Point = translate(kodosPoint, vec3(-3,4,-7));\n    vec3 droolPoint = translate(tooth1Point, vec3(-2,-2,1));\n    droolPoint.yz = rotate(droolPoint.yz, PI * 0.25);\n    vec2 drool = vec2(sdEllipsoid(droolPoint, vec3(2., 2., 2.0)), DROOLBLUE);\n    \n    vec3 drool1Point = translate(tooth1Point, vec3(-2,-2,-1));\n    drool1Point.yz = rotate(drool1Point.yz, PI * 0.25);\n    vec2 drool1 = vec2(sdEllipsoid(drool1Point, vec3(1., 1., 2.0)), DROOLBLUE);\n    drool = vec2(opSmoothUnion(drool.x, drool1.x, 1.0), DROOLBLUE);\n    add(head, drool);\n    \n    vec3 drool2Point = translate(drool1Point, vec3(-1,-2,-5));\n    drool2Point.xy = rotate(drool2Point.xy, PI * -0.75);\n    vec2 drool2 = vec2(sdEllipsoid(drool2Point, vec3(0.5, 0.5, 1.)), DROOLBLUE);\n    add(head, drool2);\n    \n    eyePoint.xz = rotate(eyePoint.xz, PI * -0.025);\n    vec3 pupilPoint = translate(eyePoint, vec3(0,0,-4.5));\n    vec2 pupil = vec2(sdVesica(opRevolution(pupilPoint,0.15), 3., 2. ), BLOODREDEYE);\n    eyePoint.xz = rotate(eyePoint.xz, PI * 0.025);\n    \n    vec3 browPoint = translate(eyePoint, vec3(0,1,-2));\n    browPoint.x *= .8;\n    browPoint.yz = rotate(browPoint.yz, PI * 0.65);\n    vec2 brow = vec2(sdTorus(browPoint, vec2(4.25, 1)), KODOSGREEN);\n    add(head, brow);\n    \n    vec3 browPointB = translate(eyePoint, vec3(0,-1.75,-0.5));\n    browPointB.x *= .8;\n    browPointB.yz = rotate(browPointB.yz, PI * -0.75);\n    vec2 browB = vec2(sdTorus(browPointB, vec2(4.25, 1)), KODOSGREEN);\n    add(head, browB);\n    \n    \n    vec3 leftEarPoint = translate(kodosPoint, vec3(-11,15,0));\n    vec2 leftEarSlice = vec2(sdPlane(translate(leftEarPoint, vec3(0,0,0)), normalize(vec4(0,0,1,1))), KODOSGREEN);\n    leftEarPoint.xy = rotate(leftEarPoint.xy, PI * -0.15);\n    vec2 leftEar = vec2(sdRoundCone( leftEarPoint, 2.5, 1.0, 9.0), KODOSGREEN);\n    \n    vec3 leftEarTubePoint = translate(leftEarPoint, vec3(1.5,0,-1.75));\n    leftEarTubePoint.xy = rotate(leftEarTubePoint.xy, PI * -0.05);\n    leftEarTubePoint.yz = rotate(leftEarTubePoint.yz, PI * -0.085);\n    vec2 leftEarTube = vec2(sdRoundCone( leftEarTubePoint, 1.0, 0.8, 11.0), KODOSGREEN);\n    \n    diff(leftEar, leftEarSlice);\n    add(leftEar, leftEarTube);\n    add(head, leftEar);\n    \n    vec3 rightEarPoint = translate(kodosPoint, vec3(11,15,0));\n    vec2 rightEarSlice = vec2(sdPlane(translate(rightEarPoint, vec3(0,0,0)), normalize(vec4(0,0,1,1))), KODOSGREEN);\n    rightEarPoint.xy = rotate(rightEarPoint.xy, PI * 0.15);\n    vec2 rightEar = vec2(sdRoundCone( rightEarPoint, 2.5, 1.0, 9.0), KODOSGREEN);\n    \n    vec3 rightEarTubePoint = translate(rightEarPoint, vec3(-1.5,0,-1.75));\n    rightEarTubePoint.xy = rotate(rightEarTubePoint.xy, PI * 0.05);\n    rightEarTubePoint.yz = rotate(rightEarTubePoint.yz, PI * -0.085);\n    vec2 rightEarTube = vec2(sdRoundCone( rightEarTubePoint, 1.0, 0.8, 11.0), KODOSGREEN);\n    \n    diff(rightEar, rightEarSlice);\n    add(rightEar, rightEarTube);\n    add(head, rightEar);\n    \n    add(head, pupil);\n    add(head, eye);\n    \n    \n    vec2 baseBottom = vec2(sdRoundCone( translate(kodosPoint, vec3(0,-10,0)), 10.0, 6.0, 9.0), KODOSGREEN);\n    add(head, baseBottom);\n    \n    vec2 liverSpot1 = vec2(sdEllipsoid(translate(kodosPoint, vec3(10,25,0)), vec3(1., 2, 2.0)), LIVERSPOTS);\n    add(head, liverSpot1);\n    \n    vec3 liverSpot2Point = translate(kodosPoint, vec3(-3,26,-8));\n    liverSpot2Point.xy = rotate(liverSpot2Point.xy, PI * 0.5);\n    liverSpot2Point.yz = rotate(liverSpot2Point.yz, PI * 0.5);\n    vec2 liverSpot2 = vec2(sdEllipsoid(liverSpot2Point, vec3(1., 2., 2.0)), LIVERSPOTS);\n    add(head, liverSpot2);\n    \n    vec3 liverSpot3Point = translate(kodosPoint, vec3(4,27,-8));\n    liverSpot3Point.xy = rotate(liverSpot3Point.xy, PI * 0.25);\n    liverSpot3Point.yz = rotate(liverSpot3Point.yz, PI * 0.5);\n    vec2 liverSpot3 = vec2(sdEllipsoid(liverSpot3Point, vec3(2., 1., 1.0)), LIVERSPOTS);\n    add(head, liverSpot3);\n    \n    vec3 liverSpot4Point = translate(kodosPoint, vec3(-7,27,-6));\n    liverSpot4Point.xy = rotate(liverSpot4Point.xy, PI * 0.25);\n    liverSpot4Point.yz = rotate(liverSpot4Point.yz, PI * 0.5);\n    vec2 liverSpot4 = vec2(sdEllipsoid(liverSpot4Point, vec3(1., 1., 2.0)), LIVERSPOTS);\n    add(head, liverSpot4);\n    \n    \n    return head;\n}\n\nvec2 kodosExteriorSDF(vec3 point){\n    float swingTime = 0.0;\n    swingTime = PRECOMPUTEDKODOSTIME;\n    \n    vec3 kodosPoint = translate(point, vec3(3,0,KODOSLIVEHERE));\n    vec2 base = vec2(sdCappedCylinder(translate(kodosPoint, vec3(0,-3,0)), vec2(12,3)), KODOSBASECOLOR);\n    vec2 lightbulb = vec2(sdSphere(translate(kodosPoint, vec3(-10,-3,-6)), 1.5), KODOSPINKLIGHTBULB);\n    vec2 baseBottom = vec2(sdRoundCone( translate(kodosPoint, vec3(0,-13,0)), 12.0, 8.0, 9.0), KODOSGREEN);\n    add(base, lightbulb);\n    \n    vec2 vent = vec2(sdBox(translate(kodosPoint, vec3(0,-3,-11)), vec3(4,1,1)), KODOSVENT);\n    add(base, vent);\n    \n    vec2 vent1 = vec2(sdBox(translate(kodosPoint, vec3(-6.75,-3,-9.5)), vec3(1,1,1)), KODOSVENT);\n    add(base, vent1);\n    \n    vec3 frontRightLegPoint = translate(kodosPoint, vec3(2,-13,-2));\n    frontRightLegPoint.xz = opBend(frontRightLegPoint.xz, 0.05);\n    frontRightLegPoint.yz = rotate(frontRightLegPoint.yz, PI * 0.6);\n    frontRightLegPoint.xy = rotate(frontRightLegPoint.xy, PI * -0.05);\n    vec2 frontRightLeg = vec2(sdRoundCone(frontRightLegPoint, 8.0, 2.0, 25.0), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontRightLeg.x, 1.0), KODOSGREEN);\n    \n    \n    //////\n    \n    vec3 rightFrontTentaclePoint = translate(kodosPoint, vec3(-2.,-21.,-26));\n    vec2 rightFrontTentacle = vec2( sdBezierSansClosestZ(vec3(0.,0.0,0.0), vec3(-3,-5.0,-10.0), vec3(-10.,-5.,-5.0),  rightFrontTentaclePoint, 2.), KODOSGREEN);\n    add(base, rightFrontTentacle);\n    \n    \n    ////\n    \n    vec3 frontLeftLegPoint = translate(kodosPoint, vec3(-2,-13,0));\n    frontLeftLegPoint.xz = opBend(frontLeftLegPoint.xz, 0.05);\n    frontLeftLegPoint.yz = rotate(frontLeftLegPoint.yz, PI * 0.6);\n    frontLeftLegPoint.xy = rotate(frontLeftLegPoint.xy, PI * -0.25);\n    vec2 frontLeftLeg = vec2(sdRoundCone(frontLeftLegPoint, 8.0, 2.0, 25.0), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontLeftLeg.x, 1.0), KODOSGREEN);\n    \n    \n    vec3 leftLegPoint = translate(kodosPoint, vec3(-11.5+(2.* abs(swingTime)),-19,0.+(4.* swingTime)));\n    leftLegPoint.xz = rotate(leftLegPoint.xz, PI *0.10*swingTime);\n    leftLegPoint.yz = rotate(leftLegPoint.yz, PI * 1.);\n    leftLegPoint.xy = rotate(leftLegPoint.xy, PI * -0.35);\n    \n    \n    vec2 leftLeg = vec2(sdCappedCone(leftLegPoint, 7.0, 9.5, 5.5), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, leftLeg.x, 1.0), KODOSGREEN);\n    \n    vec3 leftArmJointPoint = translate(leftLegPoint, vec3(-7,6.5,0));\n    leftArmJointPoint.xy = rotate(leftArmJointPoint.xy, PI * 0.51);\n    leftArmJointPoint.yz = rotate(leftArmJointPoint.yz, PI * 0.5);\n    vec2 leftArmJoint = vec2(sdTorus(leftArmJointPoint, vec2(7.,5.5)), KODOSGREEN);\n    vec2 leftArmSlice = vec2(sdPlane(translate(leftArmJointPoint, vec3(-1.5,-1.5,0)), normalize(vec4(-1,0,0,1))), KODOSGREEN);\n    diff(leftArmJoint, leftArmSlice);\n    \n    vec3 leftArmJointSlice = translate(leftArmJointPoint, vec3(-1,-1,0));\n    leftArmJointSlice.xz = rotate(leftArmJointSlice.xz, PI * -0.25);\n    vec2 leftArmSliceA = vec2(sdPlane(leftArmJointSlice, normalize(vec4(0,0,1,1))), KODOSGREEN);\n    diff(leftArmJoint, leftArmSliceA);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, leftArmJoint.x, 0.1), KODOSGREEN);\n    //\n    vec3 frontLeftLegAPoint = translate(kodosPoint, vec3(-27.+(2.5* abs(swingTime)),-13.,0.+(9.* swingTime)));\n    frontLeftLegAPoint.xz = rotate(frontLeftLegAPoint.xz, PI *0.10*swingTime);\n    frontLeftLegAPoint.xy = rotate(frontLeftLegAPoint.xy, PI * 0.125);\n    vec2 frontLeftLegA = vec2(sdRoundCone(frontLeftLegAPoint, 5.5, 2.0, 15.0), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontLeftLegA.x, 0.1), KODOSGREEN);\n    \n    vec3 frontLeftLegBPoint = translate(kodosPoint, vec3(-22.+(2.25* abs(swingTime)),2.,0.+(7.75* swingTime)));\n    frontLeftLegBPoint.xz = rotate(frontLeftLegBPoint.xz, PI *0.10*swingTime);\n    frontLeftLegBPoint.xy = rotate(frontLeftLegBPoint.xy, PI * -0.1);\n    vec2 frontLeftLegB = vec2(sdRoundCone(frontLeftLegBPoint, 1.95, 1.5, 3.0), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontLeftLegB.x, 1.), KODOSGREEN);\n    \n    vec3 rightLegPoint = translate(kodosPoint, vec3(11.5+(2.* -abs(swingTime)),-19.,0.+(4.* -swingTime)));\n    rightLegPoint.xz = rotate(rightLegPoint.xz, PI *0.10*swingTime);\n    rightLegPoint.yz = rotate(rightLegPoint.yz, PI * 1.);\n    rightLegPoint.xy = rotate(rightLegPoint.xy, PI * 0.35);\n    vec2 rightLeg = vec2(sdCappedCone(rightLegPoint, 7.0, 9.5, 5.5), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, rightLeg.x, 1.0), KODOSGREEN);\n    \n    vec3 rightArmJointPoint = translate(rightLegPoint, vec3(7,6.5,0));\n    rightArmJointPoint.xy = rotate(rightArmJointPoint.xy, PI * 0.31);\n    rightArmJointPoint.yz = rotate(rightArmJointPoint.yz, PI * 0.5);\n    vec2 rightArmJoint = vec2(sdTorus(rightArmJointPoint, vec2(7.,5.5)), KODOSGREEN);\n    vec2 rightArmSlice = vec2(sdPlane(translate(rightArmJointPoint, vec3(-1.5,-1.5,0)), normalize(vec4(-1,0,0,1))), KODOSGREEN);\n    diff(rightArmJoint, rightArmSlice);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, rightArmJoint.x, 0.1), KODOSGREEN);\n    \n    vec3 frontRightLegAPoint = translate(kodosPoint, vec3(27.+(2.75* -abs(swingTime)),-13.,0.+(8.75* -swingTime)));\n    frontRightLegAPoint.xy = rotate(frontRightLegAPoint.xy, PI * -0.125);\n    vec2 frontRightLegA = vec2(sdRoundCone(frontRightLegAPoint, 5.5, 2.0, 15.0), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontRightLegA.x, 0.1), KODOSGREEN);\n    \n    vec3 frontRightLegBPoint = translate(kodosPoint, vec3(22.+(3.25* -abs(swingTime)),2.,0.+(9.* -swingTime)));\n    frontRightLegBPoint.xz = rotate(frontRightLegBPoint.xz, PI *0.10*-swingTime);\n    frontRightLegBPoint.xy = rotate(frontRightLegBPoint.xy, PI * 0.1);\n    vec2 frontRightLegB = vec2(sdRoundCone(frontRightLegBPoint, 1.95, 1.5, 3.0), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontRightLegB.x, 1.), KODOSGREEN);\n    \n    \n    vec3 bottomRightLegPoint = translate(kodosPoint, vec3(2,-17,0));\n    bottomRightLegPoint.yz = rotate(bottomRightLegPoint.yz, PI * -0.6);\n    bottomRightLegPoint.xy = rotate(bottomRightLegPoint.xy, PI * 0.15);\n    bottomRightLegPoint.xz = rotate(bottomRightLegPoint.xz, PI * -0.15);\n    vec2 bottomRightLeg = vec2(sdRoundCone(bottomRightLegPoint, 8.0, 3.0, 20.0), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, bottomRightLeg.x, 1.0), KODOSGREEN);\n    \n    vec3 bottomLeftLegPoint = translate(kodosPoint, vec3(-2,-17,0));\n    bottomLeftLegPoint.yz = rotate(bottomLeftLegPoint.yz, PI * -0.6);\n    bottomLeftLegPoint.xy = rotate(bottomLeftLegPoint.xy, PI * -0.15);\n    bottomLeftLegPoint.xz = rotate(bottomLeftLegPoint.xz, PI * -0.15);\n    vec2 bottomLeftLeg = vec2(sdRoundCone(bottomLeftLegPoint, 8.0, 3.0, 20.0), KODOSGREEN);\n    baseBottom = vec2(opSmoothUnion(baseBottom.x, bottomLeftLeg.x, 1.0), KODOSGREEN);\n    \n    add(base, baseBottom);\n    return base;\n}\n\nvec2 kodosGlassSDF(vec3 point) {\n    float swingTime = 0.0;\n    swingTime = PRECOMPUTEDKODOSTIME;\n    \n    vec3 kodosPoint = translate(point, vec3(4.,4,KODOSLIVEHERE));\n    vec3 headPoint = translate(kodosPoint, vec3(0,0,0));\n    vec2 dome = vec2(sdRoundCone( headPoint, 12., 14.0, 19.0), 8.0);\n    vec2 domeSlice = vec2(sdPlane(translate(kodosPoint, vec3(0,-4,0)), normalize(vec4(0,1,0,1))), KODOSGREEN);\n    diff(dome, domeSlice);\n    vec3 pointyBitPoint = translate(kodosPoint, vec3(0,35,0));\n    vec2 pointyBit = vec2(sdCappedCone(pointyBitPoint, 4., 2.5, 0.0), 8.0);\n    add(dome, pointyBit);\n    return dome;\n}\n\nvec2 spinningDonut(vec3 point) {\n    vec3 donutPoint = translate(point, vec3(0,23,-37));\n    donutPoint.yz = rotate(donutPoint.yz, PI * -0.25);\n    donutPoint.xy = rotate(donutPoint.xy, PI * iTime);\n    vec2 donutBase = vec2(sdTorus(donutPoint, vec2(1.75,1)), DONUTBROWN);\n    return donutBase;\n}\n\nvec2 sceneWithMaterials(vec3 point){\n    vec2 base;\n    bool skipKodos = false;\n    for (int i = 0; i < 3; ++i) {\n        int yayOrNay = sceneStack[i];\n        if (i == 0) {\n            if (yayOrNay == 1) {\n                base = homerSDF(point/CHARACTERSCALE);\n                base.x = base.x * CHARACTERSCALE;\n            } else {\n                base = kodosExteriorSDF(point/CHARACTERSCALE);\n                base.x = base.x * CHARACTERSCALE;\n                skipKodos = true;\n            }\n        } else if (i == 1) {\n            if (yayOrNay == 1 && !skipKodos) {\n                vec2 kodosExterior = kodosExteriorSDF(point/CHARACTERSCALE);\n                kodosExterior.x = kodosExterior.x * CHARACTERSCALE;\n                add(base, kodosExterior);\n            }\n        } else if (i == 2) {\n            vec2 donut = spinningDonut(point/CHARACTERSCALE);\n            donut.x = donut.x * CHARACTERSCALE;\n            add(base, donut);\n        }\n    }\n    return base;\n}\n\nvec2 sceneWithGlassMaterials(vec3 point){\n    vec3 kAdjustPt = point;\n    kAdjustPt = translate(kAdjustPt, vec3(-0.25,0,0.05));\n    vec2 kodos = kodosGlassSDF(kAdjustPt/CHARACTERSCALE);\n    kodos.x = kodos.x * CHARACTERSCALE;\n    return kodos;\n}\n\nvec2 sceneInsideGlassMaterials(vec3 point){\n    vec3 kAdjustPt = point;\n    kAdjustPt = translate(kAdjustPt, vec3(-1.75,0,.5));\n    kAdjustPt.xz = rotate(kAdjustPt.xz, PI * 0.1);\n    vec2 kodos = kodosSDF(kAdjustPt/CHARACTERSCALE);\n    kodos.x = kodos.x * CHARACTERSCALE;\n    return kodos;\n}\n\n//////////////////STARS////////////////////////////\n// Nice use of FBM to generate stars! ***\n// https://www.shadertoy.com/view/llj3zV\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nvec2 rotateMe( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n    \n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                    mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n               mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                   mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nvec3 starryBackground(in vec3 dir)\n{\n    vec3 n  = abs(dir);\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x:\n    ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n    dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for(int i = 0 ; i < 10; ++i)\n    {\n        uv = rotateMe( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 50. * uv.x * uv.y + iTime;\n        vec2 u = sin( 75. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * cos( t ) + 0.75 );\n    }\n    \n    vec3 starColor = vec3( 1.0, 0.7, 0.5 );\n    vec3 newColor = f * starColor;\n    if (newColor == vec3(0)) {\n        newColor = vec3(12.0/255.0,2.0/255.0,69.0/255.0);\n    }\n    return newColor;\n}\n\n//////////////////END STARS////////////////////////////\n\nvec3 GetNormal(vec3 hitPoint) {\n    float ep = 0.0002;\n#if 0    \n    vec3 e=vec3(1e-2,0,0);\n    float d = sceneWithMaterials(hitPoint).x;\n    return normalize(vec3(sceneWithMaterials(hitPoint + e.xyy).x - d,\n                          sceneWithMaterials(hitPoint + e.yxy).x - d,\n                          sceneWithMaterials(hitPoint + e.yyx).x - d));\n#else\n    // inspired by iq who was inspired by klems\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);\n        n += e*sceneWithMaterials(hitPoint+e*ep).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 GetNormal1(vec3 hitPoint) {\n    float ep = 0.0002;\n#if 0    \n    vec3 e=vec3(1e-2,0,0);\n    float d = sceneWithGlassMaterials(hitPoint).x;\n    return normalize(vec3(sceneWithGlassMaterials(hitPoint + e.xyy).x - d,\n                          sceneWithGlassMaterials(hitPoint + e.yxy).x - d,\n                          sceneWithGlassMaterials(hitPoint + e.yyx).x - d));\n#else\n    // inspired by iq who was inspired by klems\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);\n        n += e*sceneWithGlassMaterials(hitPoint+e*ep).x;\n    }\n    return normalize(n);\n#endif \n}\n\nvec3 GetNormal2(vec3 hitPoint) {\n    float ep = 0.0002;\n#if 0    \n    vec3 e=vec3(1e-2,0,0);\n    float d = sceneInsideGlassMaterials(hitPoint).x;\n    return normalize(vec3(sceneInsideGlassMaterials(hitPoint + e.xyy).x - d,\n                          sceneInsideGlassMaterials(hitPoint + e.yxy).x - d,\n                          sceneInsideGlassMaterials(hitPoint + e.yyx).x - d));\n#else\n    // inspired by iq who was inspired by klems\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);\n        n += e*sceneInsideGlassMaterials(hitPoint+e*ep).x;\n    }\n    return normalize(n);\n#endif \n}\n\nvec3 GetColor2(vec2 distAndMaterial, vec3 hitPoint, float traveled) {\n    vec3 hitNormal = GetNormal2(hitPoint);\n    float mat = 0.0;\n    mat = distAndMaterial.y;\n    \n#ifdef ALLOWREFLECTIONS \n    vec3 baseColor = vec3(12.0/255.0,2.0/255.0,69.0/255.0);\n#else\n    vec3 baseColor = vec3(220.0/255.0, 220.0/255.0, 220.0/255.0);\n#endif\n    \n    float light = dot(hitNormal, normalize( vec3(0,5,-5)))*.5+.5;\n    \n    vec3 color = baseColor;\n    if (traveled > ABEAUTIFULBACKGROUND) {\n        color = baseColor;\n    } else if (mat == HOMERYELLOW) {\n        baseColor = vec3(1,0.851,0.058);\n        color = baseColor * light;\n    } else if (mat == WHITEASMYSOUL) {\n        baseColor = vec3(1,1,1);\n        color = baseColor * light;\n    } else if (mat == BLACKASNIGHT) {\n        baseColor = vec3(0,0,0);\n        color = baseColor;\n    } else if (mat == TONGUERED) {\n        baseColor = vec3(0.635,0.137,0.173);\n        color = baseColor * light;\n    } else if (mat == BROWNBEARD) {\n        baseColor = vec3(0.819,0.698,0.439);\n        color = baseColor * light;\n    } else if (mat == BLUEPANTS) {\n        baseColor = vec3(0.310,0.463,0.875);\n        color = baseColor * light;\n    } else if (mat == GREYSHOES) {\n        baseColor = vec3(0.259,0.310,0.275);\n        color = baseColor * light;\n    } else if (mat == KODOSGREEN) {\n        baseColor = vec3(0.643,0.691,0.231);\n        color = baseColor * light;\n    } else if (mat == BLOODREDEYE) {\n        baseColor = vec3(221.0/255.0,56.0/255.0,50.0/255.0);\n        color = baseColor * light;\n    } else if (mat == LIVERSPOTS) {\n        baseColor = vec3(145.0/255.0,128.0/255.0,66.0/255.0);\n        color = baseColor * light;\n    } else if (mat == YELLOWEYEBALLS) {\n        baseColor = vec3(252.0/255.0,238.0/255.0,177.0/255.0);\n        color = baseColor * light;\n    } else if (mat == DROOLBLUE) {\n        baseColor = vec3(194.0/255.0,220.0/255.0,199.0/255.0);\n        color = baseColor * light;\n    }\n    \n    return color;\n}\n\n\n\nvec3 GetColor(vec2 distAndMaterial, vec3 hitPoint, float traveled, vec3 dir) {\n    vec3 hitNormal = GetNormal(hitPoint);\n    float mat = 0.0;\n    mat = distAndMaterial.y;\n\n    vec3 baseColor = starryBackground(dir);\n\n    float light = dot(hitNormal, normalize( vec3(0,5,-5)))*.5+.5;\n    \n    vec3 color = baseColor;\n    \n    if (traveled > ABEAUTIFULBACKGROUND) {\n        color = baseColor;\n    } else if (mat == HOMERYELLOW) {\n        baseColor = vec3(1,0.851,0.058);\n        color = baseColor * light;\n    } else if (mat == WHITEASMYSOUL) {\n        baseColor = vec3(1,1,1);\n        color = baseColor * light;\n    } else if (mat == BLACKASNIGHT) {\n        baseColor = vec3(0,0,0);\n        color = baseColor;\n    } else if (mat == TONGUERED) {\n        baseColor = vec3(0.635,0.137,0.173);\n        color = baseColor * light;\n    } else if (mat == BROWNBEARD) {\n        baseColor = vec3(0.819,0.698,0.439);\n        color = baseColor * light;\n    } else if (mat == BLUEPANTS) {\n        baseColor = vec3(0.310,0.463,0.875);\n        color = baseColor * light;\n    } else if (mat == GREYSHOES) {\n        baseColor = vec3(0.259,0.310,0.275);\n        color = baseColor * light;\n    } else if (mat == KODOSGREEN) {\n        baseColor = vec3(0.643,0.691,0.231);\n        color = baseColor * light;\n    } else if (mat == KODOSBASECOLOR) {\n        baseColor = vec3(68.0/255.0, 118.0/255.0, 150.0/255.0);\n        color = baseColor * light;\n    } else if (mat == KODOSPINKLIGHTBULB) {\n        baseColor = vec3(208.0/255.0, 145.0/255.0, 200.0/255.0);\n        color = baseColor * light;\n    } else if (mat == DONUTBROWN) {\n        baseColor = vec3(196.0/255.0,147.0/255.0,65.0/255.0);\n        color = baseColor * light;\n    } else if (mat == KODOSVENT) {\n        baseColor = vec3(219.0/255.0,46.0/255.0,32.0/255.0);\n        color = baseColor * light;\n    }\n    \n    return color;\n}\n\nvec4 RayMarchInteriorGlass(vec3 ro, vec3 dir) {\n    float traveled = 0.0;\n    vec2 distAndMaterial = vec2(0);\n    \n    for (int i=ZERO; i < 50; ++i){\n        distAndMaterial = sceneInsideGlassMaterials(ro + dir * traveled);\n        traveled += distAndMaterial.x;\n        if (distAndMaterial.x < .01 || distAndMaterial.x > MAXDISTANCE) {\n            break;\n        }\n    }\n    \n    vec3 hitPoint = ro + dir * traveled;\n    \n    vec3 color = vec3(1);\n    color = GetColor2(distAndMaterial, hitPoint, traveled);\n    return vec4(color, traveled);\n}\n\nvec3 RayMarchReflection(vec3 ro, vec3 dir) {\n    float traveled = 0.0;\n    vec2 distAndMaterial = vec2(0);\n    \n    for (int i=ZERO; i < 30; ++i){\n        distAndMaterial = sceneWithMaterials(ro + dir * traveled);\n        traveled += distAndMaterial.x;\n        if (distAndMaterial.x < .01 || distAndMaterial.x > MAXDISTANCE) {\n            break;\n        }\n    }\n    \n    vec3 hitPoint = ro + dir * traveled;\n    \n    vec3 color = vec3(1);\n    color = GetColor(distAndMaterial, hitPoint, traveled, dir);\n    return color;\n}\n\nvec3 RayMarchGlass(vec2 uv, vec3 ro, vec3 dir) {\n    float traveled = 0.0;\n    float everythingTraveled = 0.0;\n    \n    vec2 distAndMaterial = vec2(0);\n    vec2 dnmEverythingElse = vec2(0);\n    \n    vec3 impact = vec3(1.0);\n    bool goneTooFar = false;\n    bool everythingsGoneTooFar = false;\n    bool hitGlass = false;\n    bool hitOtherThings = false;\n    \n    for (int i=ZERO; i < 100; ++i){\n        dnmEverythingElse = sceneWithMaterials(ro + dir * everythingTraveled);\n        everythingTraveled += dnmEverythingElse.x;\n        \n#ifndef WITHOUTKODOS\n        distAndMaterial = sceneWithGlassMaterials(ro + dir * traveled);\n        traveled += distAndMaterial.x;\n#endif\n        \n        if (dnmEverythingElse.x < .01) {\n            hitOtherThings = true;\n        }\n        \n#ifndef WITHOUTKODOS\n        if (distAndMaterial.x < .01) {\n            hitGlass = true;\n        }\n        \n        \n        if (distAndMaterial.x > MAXDISTANCE) {\n            goneTooFar = true;\n        }\n#endif\n        \n        if (dnmEverythingElse.x > MAXDISTANCE) {\n            everythingsGoneTooFar = true;\n        }\n        \n#ifndef WITHOUTKODOS\n        if (hitGlass && (hitOtherThings || everythingsGoneTooFar)) {\n            break;\n        }\n        \n        if (hitOtherThings && (goneTooFar || hitGlass)) {\n            break;\n        }\n        \n        if (goneTooFar && everythingsGoneTooFar) {\n            break;\n        }\n#else\n        if (hitOtherThings) {\n            break;\n        }\n        \n        if (everythingsGoneTooFar) {\n            break;\n        }\n#endif\n    }\n    \n    vec3 color = starryBackground(dir);\n    \n    if (hitGlass && hitOtherThings) {\n        vec3 scenePoint = ro + dir * everythingTraveled;\n        vec3 glassPoint = ro + dir * traveled;\n        \n        float sceneDistance = distance(ro, scenePoint);\n        float glassDistance = distance(ro, glassPoint);\n        \n        if (glassDistance >= sceneDistance) {\n            hitGlass = false;\n        } else {\n            hitOtherThings = false;\n        }\n    }\n    \n    if (hitOtherThings) {\n        vec3 hitPoint = ro + dir * everythingTraveled;\n        color = GetColor(dnmEverythingElse, hitPoint, everythingTraveled, dir);\n        return color;\n    }\n    \n    if (hitGlass) {\n        // Reflective/Refractive Surface\n        color = vec3(71.0/255.0, 142.0/255.0, 232.0/255.0);;\n        vec3 hitPoint = ro + dir * traveled;\n        vec3 hitNormal = GetNormal1(hitPoint);\n        \n        vec3 refractionDirection = normalize(refract(hitNormal, -dir,1.0/1.6));\n        \n        bool outside = dot(dir, hitNormal) < 0.0;\n        \n        float surfaceWidth = 0.001;\n        vec3 bias = surfaceWidth * hitNormal;\n        \n#ifdef ALLOWREFLECTIONS\n        vec3 reflectionDirection = normalize(reflect(dir, hitNormal));\n        vec3 reflectionRayOrig = outside ? hitPoint + bias : hitPoint - bias;\n        vec3 reflectionColor = RayMarchReflection(reflectionRayOrig, reflectionDirection);\n        float reflection = 0.04 + 0.96 * pow(1.0 - dot(-dir, hitNormal), 5.0);\n#endif\n        \n        vec3 refractionRayOrig = outside ? hitPoint - bias : hitPoint + bias;\n        vec4 refractionDandM = RayMarchInteriorGlass(refractionRayOrig, refractionDirection);\n        vec3 newHit =  refractionRayOrig + refractionDirection * refractionDandM.w;\n        vec3 newNormal = GetNormal2(hitPoint);\n        \n        float light = dot(newNormal, normalize( vec3(0,5,-5)))*.5+.5;\n        float glassTravelDist =  1.-clamp(distance(refractionRayOrig, newHit) / 16.0, 0., 1.);\n        \n#ifdef ALLOWREFLECTIONS\n        color = mix(reflectionColor*(1.0-reflection)+refractionDandM.xyz, color, 0.3);\n        \n        //color = reflectionColor*(1.0-reflection)+refractionDandM.xyz;\n        //color = mix(reflectionColor*(1.0-reflection), color, 0.5);\n#else\n        color = refractionDandM.xyz;\n#endif\n        \n        float glassLight = dot(hitNormal, normalize( vec3(0,5,-5)))*.5+.5;\n        \n        float specularStrength = 0.5;\n        vec3 lightColor = vec3(1);\n        vec3 viewDir = normalize(ro - hitPoint);\n        vec3 reflectDir = reflect(-normalize( vec3(0,5,-5)), hitNormal);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.);\n        vec3 specular = specularStrength * spec * lightColor;\n        \n        color = color * (glassLight + specular);\n        return color;\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    // Attempt at Stack based rendering\n#ifndef JUSTKODOS\n    sceneStack[0] = 1;\n    sceneStack[1] = 1;\n#else\n    sceneStack[0] = 0;\n    sceneStack[1] = 1;\n#endif\n    \n#ifdef WITHOUTKODOS\n    sceneStack[1] = 0;\n#endif\n    \n    sceneStack[2] = 1;\n    \n    vec3 cam = vec3(0,0,-CAMERAZOOM);\n    vec3 dir = normalize(vec3(uv,1));\n    \n    mat3 rot = rotationXY(vec2(0.25,0.5));\n    \n    if (iMouse.z > 0.0) {\n        rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n    }\n    \n    dir = rot * dir;\n    cam = rot * cam;\n    \n    vec2 nonCorrectedUV = fragCoord / iResolution.xy;\n    vec3 color = RayMarchGlass(nonCorrectedUV, cam, dir);\n    \n    fragColor.rgb = color;\n    fragColor *= 1.-dot(uv,uv)*.4;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat3 rotationXY( vec2 angle ) {\n    vec2 c = cos( angle );\n    vec2 s = sin( angle );\n    \n    return mat3(\n                c.y      ,  0.0, -s.y,\n                s.y * s.x,  c.x,  c.y * s.x,\n                s.y * c.x, -s.x,  c.y * c.x\n                );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    \n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d > p.x*b)\n    ? length(p-vec2(0.0,b))\n    : length(p-vec2(-d,0.0))-r;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\n\nvoid add(inout vec2 d1, in vec2 d2) {\n    if (d2.x < d1.x) d1 = d2;\n}\n\nvoid intersect(inout vec2 d1, in vec2 d2) {\n    if (d1.x < d2.x) d1 = d2;\n}\n\nvec2 rotate(const in vec2 p, const in float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 translate(vec3 p, vec3 d) {\n    return p - d;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n    \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0))\n    + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    \n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2) / dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 opBend(in vec2 p, in float d)\n{\n#ifdef ALLOWBENDS\n    p.y -= d*p.x*p.x;\n    p.y *= cos(atan(2.0*d*p.x));\n    return p;\n#else\n    return p;\n#endif\n}\n\n//////////////////////////\n//https://www.shadertoy.com/view/ldj3Wh\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 )\n{\n    \n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nfloat sdBezierSansClosestZ( vec3 a, vec3 b, vec3 c, vec3 p, in float thickness )\n{\n    vec3 w = normalize( cross( c-b, a-b ) );\n    vec3 u = normalize( c-b );\n    vec3 v = normalize( cross( w, u ) );\n    \n    vec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n    vec2 b2 = vec2( 0.0 );\n    vec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n    vec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n    \n    vec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n    \n    float result = 0.85*(sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z) - thickness);\n    \n    return result;\n}\n//////////////////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}