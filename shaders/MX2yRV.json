{
    "Shader": {
        "info": {
            "date": "1727462525",
            "description": "mouse controls camera\nstars and galaxy",
            "flags": 0,
            "hasliked": 0,
            "id": "MX2yRV",
            "likes": 10,
            "name": "Night sky.",
            "published": 3,
            "tags": [
                "skybox"
            ],
            "usePreview": 0,
            "username": "Spemble",
            "viewed": 132
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n\nvec3 rotateYawPitch(vec3 p, vec2 yp) {\n\tfloat cosYaw = cos(yp.x);\n\tfloat sinYaw = sin(yp.x);\n\tfloat cosPitch = cos(yp.y);\n\tfloat sinPitch = sin(yp.y);\n\n\t// First, apply pitch rotation (around X-axis)\n\tvec3 rotated = vec3(\n\t\tp.x,\n\t\tcosPitch * p.y - sinPitch * p.z,\n\t\tsinPitch * p.y + cosPitch * p.z\n\t);\n\n\t// Then, apply yaw rotation (around Y-axis)\n\treturn vec3(\n\t\tcosYaw * rotated.x + sinYaw * rotated.z,\n\t\trotated.y,\n\t\t-sinYaw * rotated.x + cosYaw * rotated.z\n\t);\n}\n\nvec3 rotateYawPitchInv(vec3 p, vec2 yp) {\n\tfloat cosYaw = cos(yp.x);\n\tfloat sinYaw = sin(yp.x);\n\tfloat cosPitch = cos(yp.y);\n\tfloat sinPitch = sin(yp.y);\n\n\t// First, apply yaw rotation (around Y-axis)\n\tvec3 rotated = vec3(\n\t\tcosYaw * p.x - sinYaw * p.z,\n\t\tp.y,\n\t\tsinYaw * p.x + cosYaw * p.z\n\t);\n\n\t// Then, apply pitch rotation (around X-axis)\n\treturn vec3(\n\t\trotated.x,\n\t\tcosPitch * rotated.y + sinPitch * rotated.z,\n\t\t-sinPitch * rotated.y + cosPitch * rotated.z\n\t);\n}\n\nvec3 yawPitchToDir(vec2 yp) {\n\tfloat cosPitch = cos(yp.y);\n\tfloat sinPitch = sin(yp.y);\n\tfloat cosYaw = cos(yp.x);\n\tfloat sinYaw = sin(yp.x);\n\n\treturn vec3(\n\t\tcosPitch * sinYaw,\n\t\tsinPitch,\n\t\tcosPitch * cosYaw\n\t);\n}\n\nvec2 dirToYawPitch(vec3 dir) {\n\treturn vec2(atan(dir.x, dir.z), asin(dir.y));\n\t// return vec2(atan(dir.x, dir.z), atan(dir.y, length(dir.xz)));\n}\n\n#define galaxyNormal vec3(0.577) // Which direction the galaxy is facing\n#define galaxyCenterDir vec3(-0.707, 0, 0.707) // The direction of the center of the galaxy\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat ar = iResolution.x / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= ar;\n\tvec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n\tmouse.x *= ar;\n\n\tif (iMouse.xy == vec2(0.0)) {\n\t\tmouse = vec2(-0.2, 0.0);\n\t}\n\n\tvec2 mouseYp = vec2(mouse.x, -mouse.y) * PI/2.0;\n\tvec3 dir = rotateYawPitch(normalize(vec3(uv, 1)), mouseYp);\n\tvec2 yp = dirToYawPitch(dir);\n\t// vec3 color = vec3(yp, 0.0);\n\t// vec3 color = vec3(sin(yp*9.0), 0.0);\n\t// vec3 color = vec3(noise(200.0 * dir) / 2.0 + 0.5);\n\t// vec3 color = yawPitchToDir(yp) - dir;\n\t// vec3 color = vec3(distance(yawPitchToDir(yp), dir));\n\n\t// Stars (noise-based)\n\tfloat starIntensity = mix(-1.5, 2.0, noise(200.0 * dir) + 0.10*noise(2.0 * dir));\n\tstarIntensity = clamp(starIntensity, 0.0, 1.0);\n\tvec3 starColor = vec3(\n\t\t0.7 + 0.3 * noise(100.0 * dir),\n\t\t0.7 + 0.3 * noise(103.0 * dir),\n\t\t0.7 + 0.3 * noise(106.0 * dir)\n\t);\n\tvec3 stars = starIntensity * starColor;\n\n\t// Stars (pixel perfect)\n\tfloat starScale = 30.0;\n\tvec2 ypm = vec2( // This is to make the stars more evenly distributed\n\t\typ.x / PI,\n\t\tsin(yp.y)\n\t);\n\t// vec2 localYp = mod(ypm * starScale, vec2(1.0));\n\t// vec3 stars = vec3(localYp, 0.0);\n\tvec2 cell = floor(ypm * starScale);\n\tvec2 randPos = vec2(  // Copilot-generated, may not be the best, but looks fine\n\t\tfract(sin(dot(cell, vec2(127.1, 311.7))) * 43758.5453),\n\t\tfract(sin(dot(cell, vec2(269.5, 183.3))) * 43758.5453)\n\t);\n\trandPos = mix(vec2(0.1), vec2(0.9), randPos); // Avoid the edges, where the stars can clip in and out\n\tvec2 starYpm = (cell + randPos) / starScale;\n\tvec2 starYp = vec2( // This undoes the above transformation\n\t\tstarYpm.x * PI,\n\t\tasin(starYpm.y)\n\t);\n\t// vec2 localYp = mod(yp * starScale, vec2(1.0));\n\t// float starIntensity = distance(localYp, randPos) * 2.0;\n\t// float starIntensity = distance(yp, starYp);\n\tvec3 starUvVec3 = rotateYawPitchInv(yawPitchToDir(starYp), mouseYp);\n\tvec2 starUv = starUvVec3.xy / starUvVec3.z;\n\t// float starIntensity = 1.0 - 1000.0 * distance(uv, starUv);\n\tstarUv.x /= ar;\n\tvec2 starCoord = (starUv + 1.0) / 2.0 * iResolution.xy;\n\tfloat starIntensity2 = 0.0;\n\tif (floor(starCoord) == floor(fragCoord)) { // Apparently fragCoord has values that end in .5?\n\t\tstarIntensity2 = fract(sin(dot(cell, vec2(113.5, 271.9))) * 43758.5453);\n\t\tstarIntensity2 *= 0.7 + 0.7*noise(20.0 * dir) + 0.4*noise(2.0 * dir);\n\t}\n\tvec3 stars2 = vec3(starIntensity2);\n\n\t// Galaxy\n\tfloat galaxyPlane = 5.0 * dot(galaxyNormal, dir);\n\tgalaxyPlane = 1.0 / (galaxyPlane * galaxyPlane + 1.0);\n\tfloat galaxyCenter = dot(galaxyCenterDir, dir) * 0.5 + 0.5;\n\tgalaxyCenter = galaxyCenter * galaxyCenter;\n\tfloat galaxyIntensity = galaxyPlane * galaxyCenter;\n\tvec3 galaxyColor = vec3(0.5, 0.5, 1.0);\n\tvec3 galaxy = 0.8 * galaxyIntensity * galaxyColor;\n\n\t// Dust\n\tfloat d = 0.0;\n\td += 1.00 * noise(10.0 * dir);\n\td += 0.50 * noise(20.0 * dir);\n\td += 0.25 * noise(40.0 * dir);\n\td += 0.20 * noise(80.0 * dir);\n\tvec3 dustColor = vec3(0.5, 0.4, 0.3);\n\tvec3 dust = vec3(1.0 - (d * 0.6 + 1.2) * galaxyPlane * galaxyCenter) + dustColor;\n\n\tvec3 color = stars + stars2 + galaxy * dust;\n\tfragColor = vec4(color, 1);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\n\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    #else\n    // cubic interpolant\n    vec3 u = f*f*(3.0-2.0*f);\n    #endif    \n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}