{
    "Shader": {
        "info": {
            "date": "1681235079",
            "description": "In my quest to find a Fibonacci Helix/Volume I found this nice little paper, Fibonacci Quats!\nAlexa_Super-Fibonacci_Spirals_Fast_Low-Discrepancy_Sampling_of_SO3_CVPR_2022_paper.pdf\nI wanted to do something neat with this, but this will do.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdGXzy",
            "likes": 7,
            "name": "Super Fibonacci Spirals",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "delajor",
            "viewed": 250
        },
        "renderpass": [
            {
                "code": "#define NUM_SPHERES 512\n#define PSI  1.533751168755204288118041 \n#define PHI  sqrt(2.0)\n#define GPHI 0.5 * (1.0 +  sqrt(5.0))\n\n#define LIGHT_POWER 20.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct quat\n{\n    float s;\n    vec3 v;\n};\n\nquat conjugate(quat q)\n{\n    return quat(q.s,-q.v);\n}\n\nfloat norm_squared(quat q)\n{\n    return q.s * q.s + dot(q.v, q.v);\n}\n\nfloat norm(quat q)\n{\n    return sqrt(norm_squared(q));\n}\n\nquat mul(float s, quat q)\n{\n    return quat(s * q.s, s * q.v);\n}\n\nquat div(quat q, float s)\n{\n    return quat(q.s / s, q.v / s);\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat normalify(quat q) // NOTE: can't reuse function name normalize here\n{\n    return div(q, norm(q));\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\n//quat inverse(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat invert(quat q) // NOTE: can't reuse function name inverse here\n{\n    return div(conjugate(q), norm_squared(q));\n}\n\nquat neg(quat q)\n{\n    return quat(-q.s,-q.v);\n}\n\nquat add(quat a, quat b)\n{\n    return quat(a.s + b.s, a.v + b.v);\n}\n\nquat sub(quat a, quat b)\n{\n    return quat(a.s - b.s, a.v - b.v);\n}\n\nquat mul(quat a, quat b)\n{\n    return quat(a.s * b.s - dot(a.v, b.v), a.s * b.v + b.s * a.v + cross(a.v, b.v));\n}\n\nquat div(quat a, quat b)\n{\n    return mul(a, invert(b));\n}\n\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return p + 2.0 * cross(q.v, cross(q.v, p) + q.s * p); // suggested by mla, requires q to be unit (i.e. normalized)\n\n    // Derive to https://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_formula#Vector_formulation\n    //return p + 2.0 * cross(q.v, cross(q.v, p)) + 2.0 * cross(q.v, q.s * p); // cross-product is distributive\n    //return p + 2.0 * cross(q.v, q.s * p) + 2.0 * cross(q.v, cross(q.v, p)); // vector addition is commutative\n    //return p + 2.0 * q.s * cross(q.v, p) + 2.0 * cross(q.v, cross(q.v, p)); // scalar can be factored-out\n    // translate variable names\n    vec3 x = p;\n    float a = q.s;\n    vec3 omega = q.v;\n    return x + 2.0 * a * cross(omega, x) + 2.0 * cross(omega, cross(omega, x)); // Euler Rodrigues' Formula\n}\n\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, c;\n};\n\nmat3 rotate_around_z(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\n\nmat3 rotate_around_y(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\n\nSphere getSphere0(int i){\n    float N = float(NUM_SPHERES);\n    float t = float(i) / N;\n\n    float sqti = sqrt(t);\n    float sqt1i = sqrt(1.0 - t);\n    float thet = 2.0 * PI *N * t;\n    float NtP = (N * t) / PSI;\n    float t0 = NtP - floor(NtP);\n    float x0 =  sqti * sin(thet / PHI);\n    float x1 =  sqti * cos(thet / PHI);\n    float y0 =  sqt1i * sin(thet / PSI);\n    float y1 =  sqt1i * cos(thet / PSI);\n    quat q = quat(y0, vec3(y1, x0, x1));\n    //vec3 p = rotate_around_y(0.1*float(iMouse.x)) * vec3(10.0 * x1, 10.0 * x0,t0);\n    \n    vec3 c0 = vec3(1.0, 0.3, 0.2);\n    vec3 p0 = vec3(3.0, 0.0, 0.0);\n    //p0 = rotate_around_y(0.2*float(iTime)) * p0;\n\n    vec3 p = rotate(q, p0);\n    vec3 c = rotate(q, c0);\n    \n    p = rotate_around_y(0.1*float(iTime)) * p;\n    return Sphere(0.15, p, c0);\n}\n#define MAX_STEPS 600\n#define MAX_DIST 1e10\n#define EPS .001\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n\n    int imin = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < NUM_SPHERES; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        Sphere sphere = getSphere0(i);\n        vec3 c = sphere.p;\n        float r = sphere.r;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                imin = i;\n                d = sd;\n            }\n        }\n    }\n    return imin;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int i_s = findIntersection(camO, camL, -1, d);\n    \n    if (i_s == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    \n    vec3 lightPoint = vec3(0.0);\n    Sphere sph = getSphere0(i_s);\n    \n    // Sphere color\n    vec3 sColor = sph.c;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sph.p);\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint );\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, i_s, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (false) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, -25);\n    vec3 camL = normalize(vec3(uv.x, uv.y,6));\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}