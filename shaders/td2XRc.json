{
    "Shader": {
        "info": {
            "date": "1554617385",
            "description": "spoopy spikes",
            "flags": 0,
            "hasliked": 0,
            "id": "td2XRc",
            "likes": 14,
            "name": "Evil Structure",
            "published": 3,
            "tags": [
                "raymarching",
                "ifs",
                "bump"
            ],
            "usePreview": 0,
            "username": "zackpudil",
            "viewed": 559
        },
        "renderpass": [
            {
                "code": "// SPOOPINESS\n\nvec3 ro; // I'm saving the camera as a global variable, so I can use it in the de method.\n\n// simple 2d rotation matrix.\nmat2 rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\treturn mat2(c, s, -s, c);\n}\n\n// changing the metric for measuring distance.\nfloat len(vec3 p, float l) {\n\tp = pow(abs(p), vec3(l));\t\n\treturn pow(p.x+p.y+p.z, 1.0/l);\n}\n\n// 2d varient of the change of metric formula.\nfloat len(vec2 p, float l) {\n\tp = pow(abs(p), vec2(l)); // if l is 2, this would be the good old sqrt(dot(p, p)) euclidean metric.\n\treturn pow(p.x+p.y, 1.0/l);\n}\n\n// The fuction we are iterating in our Iterating Function System.\nvec2 shape(vec3 p) {\n    // triangular prism as the purplish stuff.\n\tfloat a = len(p.xy, 1.0) - 1.0;\n\tfloat b = len(p.yz, 1.0) - 1.0;\n\t\n\tvec2 t = vec2(min(a, b), 1.0);\n\tvec2 s = vec2(len(p, 1.0) - 7.75, 2.0); // a octahedron as the black stuff.\n\t\n\treturn t.x < s.x ? t : s;\n}\n\nvec2 de(vec3 p) {\n\tvec4 q = vec4(p, 1);\n\t\n\tq.xyz -= 1.0; // this puts the center of the fractal back at the origin.\n    \n    // My favorite fract, a element of the kaliset, AbsBox fractal.\n\tfor(int i = 0; i < 5; i++) {\n\t\tq.xyz = abs(q.xyz + 1.0) - 1.0; // mirror\n\t\tq /= clamp(dot(q.xyz, q.xyz), 0.1, 1.0); // the abs(p)/dot(p, p) is basically the kaliset.\n\t\tq.xz *= rot(0.1 + float(i)*0.15); // do some rotations.\n\t\t\n\t\tq *= 2.0; // scales.\n\t}\n\t\t\n\tvec2 s = shape(q.xyz)/vec2(q.w, 1); // get the shape.\n    s.x = max(-length(p - ro) + 0.01, s.x); // use the camera position to carve out a small sphere around the camera, so collisions don't look so bad.\n    \n    return s;\n}\n\n// using a kaliset 2d fractal to modify the coords for a texture.\nvec3 tex(sampler2D s, vec2 p) {\n    for(int i = 0; i < 10; i++) {\n        p = abs(p)/dot(p, p) - vec2(0.2);\n    }\n    \n    return texture(iChannel0, p).rgb;\n}\n\n// Triplanar texture blending.  Thanks to one of the great wizards of ShaderToy: Shane.\nvec3 mat(vec3 p, vec3 n, sampler2D s) {\n    vec3 m = abs(n);\n    m /= dot(m, vec3(1));\n    \n    vec3 x = tex(s, p.yz);\n    vec3 y = tex(s, p.xz);\n    vec3 z = tex(s, p.xy);\n    \n    return (m.x*x*x + m.y*y*y + m.z*z*z);\n}\n\n// luminosity rbg.\nvec3 sgrey = vec3(0.299, 0.587, 0.114);\n\n// using a 3d texture add bump mapping to the surface.\nvec3 bump(vec3 p, vec3 n, sampler2D s) {\n    vec2 h = vec2(0.009, 0.0);\n    vec3 g = mat3(\n        mat(p - h.xyy, n, s),\n        mat(p - h.yxy, n, s),\n        mat(p - h.yyx, n, s))*sgrey;\n    \n    g = g - dot(mat(p, n, s), sgrey);\n    g -= n*dot(g, n);\n    \n    return normalize(n + 0.9*g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 col, bg;\n\tcol = bg = vec3(0.04)*(1.0 - length(uv)); // small bit of vinetting.\n\t\n\tfloat at = iTime*0.1;\n    float a = 1.4;\n\t\n    // camera setup. ro = position, rd = ray we shoot at geometry.\n\tro = vec3(a*cos(at), 0.04, -a*sin(at));\n\tvec3 ww = normalize(vec3(0, 0, 0)-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 0.5 + 0.5*smoothstep(-1.0, 1.0, cos(iTime*0.5)))); // FOV goes from 0.5 to 1 in interval.\n\t\n    // sphere tracing, main method of ray-marching.  Faster than constant step ray-marching.\n\tfloat t = 0.0, m = -1.0, mx = 50.0; // t = distance, m = material id, mx = max distance.\n\tfor(int i = 0; i < 200; i++) {\n\t\tvec2 d = de(ro + rd*t);\n\t\tif(d.x < 0.001 || t >= mx) break;\n\t\tt += d.x*0.5;\n\t\tm = d.y;\n\t}\n\t\n    // very dumb light direction.\n\tvec3 ld = normalize(vec3(0, 0.5, 0));\n\tvec2 h = vec2(0.001, 0.0); // used for calculating the gradient of the de function (normal).\n\t\n\tif(t < mx) {\n\t\tvec3 p = ro + rd*t; // get coord of position we hit.\n\t\tvec3 n = normalize(vec3( // calculate the gradient at that position and use that for normal.\n\t\t\tde(p + h.xyy).x - de(p - h.xyy).x,\n\t\t\tde(p + h.yxy).x - de(p - h.yxy).x,\n\t\t\tde(p + h.yyx).x - de(p - h.yyx).x));\n\t\t\n\t\tvec3 al = vec3(1); // albeido = color\n        float gloss = 10.0; // gloss map, used in specular value.\n        \n        if(m == 1.0) {\n            al = vec3(0.3, 0.0, 0.2)*mat(p*0.1, n, iChannel0); // the spikes have a purpilish color to them.\n            gloss = 64.0; // have a very sharp specular light.\n        } else if(m == 2.0) {\n            al = vec3(0.0); // the main body is black (only specular and fresnel terms add to the color).\n            gloss = 16.0; // shiny object\n        }\n            \n        n = bump(p, n, iChannel0); // bump the normal to get some cheap detail of the surface.\n\t\t\n        // ambient occlusion, using a wave packet to approximate distance from geometry from normal.\n\t\tfloat occ = exp2(-pow(max(0.0, 1.0 - de(p + n*(t/50.0)).x/(t/50.0)), 2.0));\n\t\tfloat dif = max(0.0, dot(ld, n)); // diffuse lighting.\n\t\t\n        // specular light.\n\t\tfloat spe = pow(max(0.0, dot(reflect(-ld, n), -rd)), gloss);\n\t\tfloat fre = pow(dot(rd, n) + 1.0, 2.0); // fresnel term (light reflecting of edge).\n\t\t\n\t\tcol = mix(occ*(al*(dif + 0.25) + vec3(0.4, 0.6, 0.8)*spe), al + 0.01, fre); // put it all together.\n\t}\n    \n    col *= 5.0;\n\t\n\tcol = mix(col, bg, 1.0 - exp(-0.2*t)); // add a bit of fog.\n\tfragColor = vec4(pow(col, vec3(0.45)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}