{
    "Shader": {
        "info": {
            "date": "1630808591",
            "description": "A mountain terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.",
            "flags": 8,
            "hasliked": 0,
            "id": "NscGWl",
            "likes": 20,
            "name": "Glacial valleys",
            "published": 3,
            "tags": [
                "noise",
                "terrain",
                "fbm",
                "ice",
                "snow",
                "mountain",
                "erosion"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 790
        },
        "renderpass": [
            {
                "code": "#define SC (250.0)\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nvec2 fluid(vec2 uv){\n //add some turbulence\n //uv /=2.;\n //return vec2(sin(uv.x),cos(uv.y))/2.;\n \n \n //decrease this number to increase the turbulence of erosion\n float turbulence = 5.;\n //float t1 = turbulence*turbulence;\n \n //uv *= turbulence;\n //vec2 uv1 = uv/t1;\n \n vec2 result = uv;\n \n //more height variation\n //uv *= (1.+(sin(uv.x/128.)+cos(uv.y/128.))/128.);\n\n \n for (float i = 1.; i < 3.; i += 1.)\n  {\n    float s2 = (sin(uv.x*i))/turbulence;\n    uv.y += s2;\n    float s1 = cos(uv.y*i)/turbulence;\n    uv.x += s1;\n    uv=uv.yx;\n  }\n  return (uv-result).yx;\n}\n\n\n#define OCTAVES 8\nvec3 fbm0(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    //uv *= .75;\n    float value = 0.;\n    float amplitude = .75,n2=0.;\n    //amplitude /= 16.;\n    vec2 n1 = vec2(0.);\n    \n    //rotate 45 degrees\n    //mat2 r = rotate2D(0.785398);\n    \n    float terrain_scale = 1.;\n    uv *= terrain_scale;\n    vec2 uv1 = uv;\n    uv += uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        vec2 f1 = fluid(uv).yx;\n        //domain warping\n        uv += f1;\n        \n        n1 =\n            //vec2(sin(uv.x+cos(uv.y*.37)/.37),cos(uv.y+sin(uv.x*.37)/.37))\n            //vec2(sin(uv.x-n1.y*value),cos(uv.y-n1.x*value))\n            //vec2(sin(uv.x),cos(uv.y))\n            //vec2(sin(uv.x),cos(uv.y))*r //badlands\n            //(vec2(sin(uv.x),cos(uv.y))+n1)/2.\n            //(n1+abs(n1-vec2(sin(uv.x),cos(uv.y))))/2.\n            f1\n        ;\n        uv1 = uv;\n        n2 =\n            n1.x+n1.y\n            //((n1.x+n1.y)-n2)\n            //n1.x+n1.y+n2*.37\n        ;\n        value -=\n            abs(n2)*amplitude\n            //abs(n2-value) * amplitude\n        ;\n        \n        //waves\n        //value += sin(uv.x/1000.+iTime)/10.;\n        \n        //erosion\n        value = sqrt(value*value+.0001);\n        \n        amplitude *= .37;\n        \n        //This makes it somewhat more realistic\n        //amplitude *= (1.+sin(uv.x/4.)/4.);\n\n        //uv *= uv*2.05*r+vec2(0.,n2);\n        uv += uv;\n        \n        //r = rotate2D(12.+(n2)*value/8.);\n    }\n    \n    return vec3(value/terrain_scale,uv);\n}\n\nfloat fbm(vec2 uv,int octaves){\n    return fbm0(uv,octaves).x;\n}\n\n/*\nfloat fbm(in vec2 uv,int octaves){\nuv /= 32.;\n  vec3 col = vec3(0);\n  for(int k = 0; k < 12; k++){\n        //another interesting variant:\n        //if(uv.y>uv.x) uv = uv.yx;\n        vec2 offset =\n            vec2(uv.x,-uv.y)*1.5\n            //vec2(mod(uv.x*2.-.5,2.),mod(uv.y,2.)*2.)\n            //vec2(mod(uv.x*2.,2.),sign(uv.x-uv.y)*mod(uv.y,2.)*2.)\n        ;\n        uv = abs(fract(uv.yx-offset)-.5);\n        if(uv.y < uv.x) uv /= 1.5;\n        //else uv /= 2.;\n    }\n    return uv.x/8.;\n}\n*/\n\n\n//a more realistic terrain\nfloat fbm1(in vec2 uv,int octaves){\n    uv *= .8;\n    return fbm(uv*2.,octaves)/2.+fbm(uv,octaves);\n}\n\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n\n    //TODO: use the local minimum in the previous frame to accelerate raymarching in the next frame\n    //vec2 prev = vec2(0.);\n    \n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n        //if(prev.y<h && prev.y<prev.x) return t; //this is the local minimum\n\t\tif( abs(h) < (0.0015 * t) || t > tMax) \n            break;\n\t\t//prev = vec2(prev.y,h);\n        t += 0.4 * h;\n\t}\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime/2.+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    //rd.yx *= rot(0.785398/4.);\n    //rd.xz *= rot(1.5*0.785398);\n    \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0-iTime/4.);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//remix of https://www.shadertoy.com/view/flcBz7\n\nfloat fmod(float a, float b){\n    for(float i = 1.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/2.),b)*i;\n    }\n    return mod(floor(a+floor(a/8./8./2.)),b);\n}\n\nvec2 mainSound(int samp, float time){\n  float\n  m1 = fmod(time*8.,8.),\n  t = time*2.*(1.+fmod(time/4.,2.)),\n  a= (1.-log(1./8./8.+fract(t)/8./2.)/2.)*(1.-log(1./8./8.+fract(t/8.)/2.)/2.),\n  nb = time*pow(2.,floor(((fmod(m1,abs(16.-m1)+1.)-m1)+1. + fmod(t,8.))/2.)/5.+7.5);\n  return\n      log(1./8./8.+(a*abs(1./8.-.5*abs(.5-vec2(fract(nb/2.*.998),fract(nb))))))\n  ;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}