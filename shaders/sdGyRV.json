{
    "Shader": {
        "info": {
            "date": "1655181088",
            "description": "Fork of https://www.shadertoy.com/view/lsKfDV but using concentric circles instead of the x and y axes.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdGyRV",
            "likes": 19,
            "name": "julia orbits circles",
            "published": 3,
            "tags": [
                "fractal",
                "julia",
                "antialias",
                "pickover",
                "stalks"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 301
        },
        "renderpass": [
            {
                "code": "#define ITERS 128\n\n#define USE_THIN_LINES 1\n\n#define MUL(a, b) (mat2(a, -a.y, a.x) * b)\n// complex number multiplication, Fabrice style.\n\n#define TRIM_EDGES 1\n// set to 0 to let stalks go to infinity -- best with a small number of ITERS\n// for instance, TRIM_EDGES=0 and ITERS=8 works well\n\n#define EXACTLY_TRIM_EDGES 0\n\nfloat ramp(in float minval, in float maxval, in float val) {\n    return clamp((val - minval) / (maxval - minval), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 z = 1.0 * uv;\n    \n    vec2 mouse_norm = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec2 axes = vec2(0.0);\n    vec2 c = mouse_norm;\n    \n    float dist1 = abs(length(z) - 0.125);\n    float dist2 = abs(length(z) - 0.25);\n    float min_dist = min(dist1, dist2);\n        \n    vec2 grad = vec2(1.0, 0.0);\n    // so, in addition to wanting to compute iterations of the function f(z) = z^2+c, we\n    // also want it's derivative, so we can estimate the distance in pixel space to the z\n    // such that f^i(z) is zero in either the real or the complex axis.\n    \n    for (int i = 0; i < ITERS; ++i) {\n             \n        vec2 zprime = 2.0 * z;\n        // here's our derivative of the next iteration in terms of this one\n        // now let's compute the derivative of the next iteration with respect to the start point\n        grad = MUL(zprime, grad);\n\n        float gradient_inv_magnitude = 1.0 / length(grad);\n        // thanks, @iq, for the tip on how to save a sqrt\n\n        z = MUL(z,z) + c;\n        // and here we actually perform our julia iteration, which is the tiniest part of the code\n        \n        \n        dist1 = abs(length(z) - 0.125) * gradient_inv_magnitude;\n        dist2 = abs(length(z) - 0.25)  * gradient_inv_magnitude;\n        // see above comment.\n        min_dist = min(min_dist, min(dist1, dist2));\n    \n        \n        if (dot(z,z) > 4.0) {\n#if EXACTLY_TRIM_EDGES            \n            min_dist = 10.0;\n\n#elif !TRIM_EDGES\n            min_dist = 0.0;\n#endif            \n            break;\n        }\n        \n    }\n    \n\n#if USE_THIN_LINES\n    vec3 col = vec3(ramp(0.0 / iResolution.y, 2.0 / iResolution.y, min_dist));\n#else\n    min_dist = min_dist * sqrt(2.0);\n\tvec3 col =\n        vec3(ramp(0.0 / iResolution.y, 2.0 / iResolution.y, min_dist),\n             ramp(1.0 / iResolution.y, 3.0 / iResolution.y, min_dist),\n             ramp(2.0 / iResolution.y, 4.0 / iResolution.y, min_dist));\n    // and here we compute our tricolored line\n#endif\n    // TODO : consider coloring by iteration\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}