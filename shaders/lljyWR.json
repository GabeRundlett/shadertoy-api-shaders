{
    "Shader": {
        "info": {
            "date": "1508358208",
            "description": "Quick demo of a couple circular area lights. Seems all other area light demos on this site are rectangular shaped.\n\n  * Point light (as comparison)\n  * Spherical light (approximate, not 'true' spherical source)\n  * Disc/Circle light\n  * Ring light",
            "flags": 32,
            "hasliked": 0,
            "id": "lljyWR",
            "likes": 36,
            "name": "Circular Area Lights",
            "published": 3,
            "tags": [
                "light",
                "circle",
                "ring",
                "area",
                "disc"
            ],
            "usePreview": 1,
            "username": "ssell",
            "viewed": 1757
        },
        "renderpass": [
            {
                "code": "/**\n * ------------------------------------------------------------------------\n * - Circular Area Lights\n * - Created by Steven Sell (ssell) / 2017\n * - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * - https://www.shadertoy.com/view/lljyWR\n * ------------------------------------------------------------------------\n *\n * Demo of a few circular area lights, including:\n *\n *     * Sphere Light (approximation, not true spherical source)\n *     * Circle/Disc Light\n *     * Ring Light\n *\n * I needed a circle/disc light for another shader when I stumbled upon\n * the ring light by accident. Decided to make a quick demo of them for \n * reference by others and future me.\n *\n * Note that there is a fair bit of duplicate/unneeded code for the light shading.\n * This is by design as this is a reference/demo piece and it shows one possible\n * way of using these lights.\n *\n * For example, all the individual light functions could be reduced to simply\n * finding the light position and attenuation value and then use those values\n * for the common lighting calculations. But in this shader, the functions are\n * intended to be completely stand-alone.\n *\n * ------------------------------------------------------------------------\n * - UI Sliders\n * ------------------------------------------------------------------------\n *\n * - Light Type\n *\n *     < 0.25 : Point Light\n *     < 0.5  : Sphere Light\n *     < 0.75 : Disc Light\n *     > 0.75 : Ring Light\n *\n * - Light Directional Type\n *\n *     If Point or Sphere:        Omnidirectional\n *     If Disc or Ring and < 0.5: Unidirectional\n *     If Disc or Ring and > 0.5: Bidirectional\n * \n * - Yaw\n *\n *     [0.0, 1.0] -> [0.0, 2PI]\n *\n * - Pitch\n *\n *     [0.0, 1.0] -> [0.0, 2PI]\n *\n * - Light Source Radius\n *\n *     [0.0, 1.0] -> [0.0, 4.0]\n *\n * - Constant Attenuation Term\n *\n *     [0.0, 1.0] -> [0.0, 1.0]\n *\n * - Linear Attenuation Term\n *\n *     [0.0, 1.0] -> [0.0, 1.0]\n *\n * - Quadratic Attenuation Term\n *\n *     [0.0, 1.0] -> [0.0, 1.0]\n *\n * ------------------------------------------------------------------------\n * - Buffers\n * ------------------------------------------------------------------------\n *\n *     * Buf A: UI rendering and input \n *     * Buf B: Scene marching and rendering\n *     * Image: Combining Buf A and Buf B\n *\n * ------------------------------------------------------------------------\n * - References / Sources\n * ------------------------------------------------------------------------\n *\n * -- UI\n *\n *     'UI easy to integrate' - XT95\n *     https://www.shadertoy.com/view/ldKSDm\n */\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 ui = texture(iChannel0, uv);\n    \n    fragColor     = texture(iChannel1, uv);\n    fragColor.rgb = mix(fragColor.rgb, ui.rgb, ui.a);       \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * -- User Interface\n * -----------------------------------------------------------\n *\n *     'UI Easy to Integrate' - XT95\n *     https://www.shadertoy.com/view/ldKSDm\n */\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 140.\n#define WIDGET_COLOR vec3(0.0)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\nvoid setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uv = fragCoord.xy;\n    \n    int rx = int(iResolution.x * 0.5) - 295;\n    int ry = int(iResolution.y) - 30;\n    \n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n        \n   \t//-----------------------------------------------------------\n    // Top Row\n    //-----------------------------------------------------------\n    \n    float type = uiSlider(0).r;\n    \n    if(type < 0.25)\n    {\n        _slider(rx, ry, 0, 1.0) _P _o _i _n _t _spc _L _i _g _h _t\n    }\n    else if(type < 0.5)\n    {\n        _slider(rx, ry, 0, 1.0) _S _p _h _e _r _e _spc _L _i _g _h _t\n    }\n    else if(type < 0.75)\n    {\n        _slider(rx, ry, 0, 1.0) _D _i _s _c _spc _L _i _g _h _t\n    }\n    else\n    {\n        _slider(rx, ry, 0, 1.0) _R _i _n _g _spc _L _i _g _h _t\n    }\n    \n   \tfloat directional = uiSlider(1).r;\n    \n    if(type < 0.5)\n    {\n        _slider(rx + 150, ry, 1, 0.0) _O _m _n _i _d _i _r _e _c _t _i _o _n\n    }\n    else if(directional < 0.5)\n    {\n        _slider(rx + 150, ry, 1, 0.0) _U _n _i _d _i _r _e _c _t _i _o _n\n    }\n    else\n    {\n        _slider(rx + 150, ry, 1, 0.0) _B _i _d _i _r _e _c _t _i _o _n\n    }\n    \n    _slider(rx + 300, ry, 2, 0.0) _Y _a _w\n    _slider(rx + 450, ry, 3, 0.0) _P _i _t _c _h\n        \n    //-----------------------------------------------------------\n    // Bottom Row\n    //-----------------------------------------------------------\n    \n    ry = int(iResolution.y) - 10;\n    \n    _slider(rx,       ry, 4, 1.0) _R _a _d _i _u _s\n    _slider(rx + 150, ry, 5, 1.0) _C _o _n _s _t _a _n _t\n    _slider(rx + 300, ry, 6, 0.1) _L _i _n _e _a _r\n    _slider(rx + 450, ry, 7, 0.1) _Q _u _a _d _r _a _t _i _c\n        \n    fragColor = min(col.rgba, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * -- Scene Marching / Rendering\n * -----------------------------------------------------------\n */\n\n#define EnableAA\n\n#define Epsilon            0.001\n#define NearClip           Epsilon\n#define FarClip            50.0\n#define MaxSteps           150\n#define PI                 3.14159265359\n#define PI2                6.28318530718\n\n#define LightTypePoint     0\n#define LightTypeSphere    1\n#define LightTypeCircle    2\n#define LightTypeRing      3\n\n#define LightDirectionOmni 0\n#define LightDirectionUni  1\n#define LightDirectionBi   2\n\n// Configurable Lighting Properties\n\nvec3  LightPos         = vec3(0.0, 1.5, 0.0);\nvec3  LightAttenuation = vec3(1.0, 0.1, 0.1);\nvec3  LightNormal      = normalize(vec3(0.0, -1.0, 0.0));\nint   LightType        = LightTypeRing;\nint   LightDirection   = LightDirectionOmni;\nfloat LightRadius      = 1.0;\nfloat LightYaw         = 0.0;\nfloat LightPitch       = 0.0;\n\n//------------------------------------------------------------------------------------------\n// Light Structs\n//------------------------------------------------------------------------------------------\n\n// Note that these structs are not truly utilized but are here to serve as an example...\n\nstruct Light_Ring\n{\n\tvec3 position;\n    vec3 normal;\n    vec3 attenuation;\n    \n    float radius;\n};\n    \nstruct Light_Point\n{\n    vec3 position;\n    vec3 attenuation;\n};\n    \nstruct Light_Sphere\n{\n    vec3 position;\n    vec3 attenuation;\n    \n    float radius;\n};\n    \n//------------------------------------------------------------------------------------------\n// Utilities\n//------------------------------------------------------------------------------------------\n    \nfloat UISlider(int id)\n{\n    return texture(iChannel1, vec2(float(id) + 0.5, 0.5) / iResolution.xy).r;\n}\n\nvoid UpdateParameters()\n{\n    LightType          = clamp(int(UISlider(0) * 4.0), 0, 3);\n    LightDirection     = (LightType > LightTypeSphere) ? int(clamp(UISlider(1) + 0.5, 0.0, 1.0)) + 1 : LightDirectionOmni;\n    LightYaw           = clamp(UISlider(2), 0.0, 1.0) * PI2;\n    LightPitch         = clamp(UISlider(3), 0.0, 1.0) * PI2;\n    LightRadius        = clamp(UISlider(4) * 4.0, 0.2, 4.0);\n    LightAttenuation.x = clamp(UISlider(5), 0.0001, 1.0);\n    LightAttenuation.y = clamp(UISlider(6), 0.0001, 1.0);\n    LightAttenuation.z = clamp(UISlider(7), 0.01, 1.0);\n}\n\n// Really lazy vector rotation...\nvec3 Rotate(in vec3 norm, in float yaw, in float pitch)\n{\n    float cosp = cos(pitch);\n    float sinp = sin(pitch);\n    \n    mat3 rotp;\n    rotp[0][0] = 1.0;\n    rotp[0][1] = 0.0;\n    rotp[0][2] = 0.0;\n    rotp[1][0] = 0.0;\n    rotp[1][1] = cosp;\n    rotp[1][2] = -sinp;\n    rotp[2][0] = 0.0;\n    rotp[2][1] = sinp;\n    rotp[2][2] = cosp;\n    \n    float cosy = cos(yaw);\n    float siny = sin(yaw);\n    \n    mat3 roty;\n    roty[0][0] = cosy;\n    roty[0][1] = 0.0;\n    roty[0][2] = siny;\n    roty[1][0] = 0.0;\n    roty[1][1] = 1.0;\n    roty[1][2] = 0.0;\n    roty[2][0] = -siny;\n    roty[2][1] = 0.0;\n    roty[2][2] = cosy;\n    \n    norm = (rotp * norm);\n    norm = (roty * norm);\n    \n    return norm;\n}\n\n/**\n * Point on/in circle derived from the source:\n * https://www.geometrictools.com/Documentation/DistanceToCircle3.pdf\n *\n *     d  = Vector point from circle origin to our position\n *     q  = Point on the circle's plane nearest to our position\n *     qc = (q - c), or the vector from circle origin to q\n *\n * With q (or qc) known, it is trivial to find the point on the circle\n * circumference nearest our position.\n *\n * Note that 'PointOnCircle' is directly derived from the above reference\n * while 'PointInCircle' is modified to accomodate cases where q lies within\n * the circle already (if length qc is less than the radius).\n */\nvec3 PointInCircle(in vec3 pos, in vec3 circlePos, in vec3 circleNorm, in float circleRadius)\n{\n    vec3 d = pos - circlePos;\n    vec3 q = d - dot(circleNorm, d) * circleNorm + circlePos;\n    \n    return (length(q - circlePos) <= circleRadius) ? q : (circlePos + circleRadius * normalize(q - circlePos));\n}\n\nvec3 PointOnCircle(in vec3 pos, in vec3 circlePos, in vec3 circleNorm, in float circleRadius)\n{\n \tvec3 d = pos - circlePos;\n    vec3 qc = d - dot(circleNorm, d) * circleNorm;\n    \n    return (circlePos + circleRadius * normalize(qc));\n}\n\n//------------------------------------------------------------------------------------------\n// Ray / Camera\n//------------------------------------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nRay Ray_LookAt(in vec2 uv, in vec3 o, in vec3 d)\n{\n    vec3 forward = normalize(d - o);\n    vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up      = normalize(cross(right, forward));\n\n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n\n    Ray ray;\n    ray.o = o;\n    ray.d = normalize((uv.x * right) + (uv.y * up) + (forward * 2.0));\n\n    return ray;\n}\n    \n//------------------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------------------\n\n// Union/Cylinder/Torus credit iq\n// https://iquilezles.org/articles/distfunctions\n\nvec2 U(in vec2 d1, in vec2 d2) \n{ \n    return (d1.x < d2.x) ? d1 : d2; \n}\nfloat Cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat Torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 RotX(in vec3 p, float a)        \n{ \n    float s = sin(a); \n    float c = cos(a); \n    return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z)); \n}\n\nvec3 RotY(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3((c * p.x) + (s * p.z), p.y, (-s * p.x) + (c * p.z));\n}\n\nvec2 Scene(in vec3 pos)\n{\n    vec3 lpos = RotX(RotY(pos - LightPos, LightYaw), LightPitch);\n    \n    vec2 ground = vec2(pos.y, 0.0);\n    vec2 walls  = vec2(min(min(pos.x - cos(pos.z * 0.2) + 8.0, -pos.x - cos(pos.z * 0.2) + 8.0), pos.z + 6.5), 1.0);\n    vec2 light  = (LightType == LightTypePoint)  ? vec2(length(lpos) - 0.1, 2.0) :\n                  (LightType == LightTypeSphere) ? vec2(length(lpos) - LightRadius, 2.0) :\n                  (LightType == LightTypeCircle) ? vec2(Cylinder(lpos, vec2(LightRadius, 0.02)), 2.0) :\n                  (LightType == LightTypeRing)   ? vec2(Torus(lpos, vec2(LightRadius - 0.1, 0.1)), 2.0) :\n                  vec2(FarClip, 0.0);\n    \n    return U(U(ground, walls), light);\n}\n\n//------------------------------------------------------------------------------------------\n// Marching\n//------------------------------------------------------------------------------------------\n\nvec2 March(in Ray ray)\n{\n\tfloat depth = NearClip;\n    float id    = 0.0;\n    \n    for(int i = 0; i < MaxSteps; ++i)\n    {\n        vec3 pos = ray.o + (ray.d * depth);\n        vec2 sdf = Scene(pos);\n        \n        if(sdf.x < Epsilon)\n        {\n            id = sdf.y;\n            break;\n        }\n        \n        depth += sdf.x;\n    }\n    \n    return vec2(depth, id);\n}\n\nvec3 SceneNormal(in vec3 pos, in float depth)\n{\n\tvec2 eps = vec2(0.001 * depth, 0.0);\n    return normalize(vec3(Scene(pos + eps.xyy).x - Scene(pos - eps.xyy).x,\n                          Scene(pos + eps.yxy).x - Scene(pos - eps.yxy).x,\n                          Scene(pos + eps.yyx).x - Scene(pos - eps.yyx).x));\n}\n\n//------------------------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------------------------\n\nfloat Attenuation(\n    float d,    // Distance to light source\n    float c,    // Constant term\n    float l,    // Linear term\n    float q)    // Quadratic term\n{\n    return (1.0 / (c + (l * d) + (q * d * d)));\n}\n\n//--------------------------------------------\n// Point Light\n//--------------------------------------------\n\n// Basic point light shading...\n\nvec3 Lighting_Point(\n    in vec3  toView,\n    in vec3  pos,\n    in vec3  norm,\n    in vec3  albedo,\n    in float intensity,\n    in float roughness)\n{\n    Light_Point light;\n    light.position    = LightPos;\n    light.attenuation = LightAttenuation;\n    \n\tvec3  toLight     = normalize(light.position - pos);\n    float lightCos    = max(0.0, dot(norm, toLight));\n    float lightDist   = length(pos - light.position);\n    float attenuation = Attenuation(lightDist, light.attenuation.x, light.attenuation.y, light.attenuation.z);\n    \n    vec3 reflVector = reflect(-toView, norm);\n    \n    vec3 dirLight = vec3(intensity) * lightCos * attenuation;\n    vec3 spcLight = vec3(0.2) * pow(max(0.0, dot(reflVector, toLight)), roughness) * lightCos;\n    \n    return (albedo * dirLight) + spcLight;\n}\n\n//--------------------------------------------\n// Sphere Light\n//--------------------------------------------\n\n// Same as point light but takes into consideration a radius.\n// Not a 'true' spherical light source but serves as a variation.\n\nvec3 Lighting_Sphere(\n    in vec3  toView,\n    in vec3  pos,\n    in vec3  norm,\n    in vec3  albedo,\n    in float intensity,\n    in float roughness)\n{\n    Light_Sphere light;\n    light.position    = LightPos;\n    light.attenuation = LightAttenuation;\n    light.radius      = LightRadius;\n    \n\tvec3  toLight     = normalize(light.position - pos);\n    float lightCos    = max(0.0, dot(norm, toLight));\n    float lightDist   = max(0.0, length(pos - light.position) - light.radius);  // Account for radius\n    float attenuation = Attenuation(lightDist, light.attenuation.x, light.attenuation.y, light.attenuation.z);\n    \n    vec3 reflVector = reflect(-toView, norm);\n    \n    vec3 dirLight = vec3(intensity) * lightCos * attenuation;\n    vec3 spcLight = vec3(0.2) * pow(max(0.0, dot(reflVector, toLight)), roughness) * lightCos;\n    \n    return (albedo * dirLight) + spcLight;\n}\n\n//--------------------------------------------\n// Circle/Disc Light\n//--------------------------------------------\n\nvec3 Lighting_Circle(\n    in vec3  toView,\n    in vec3  pos,\n    in vec3  norm,\n    in vec3  albedo,\n    in float intensity,\n    in float roughness)\n{\n    Light_Ring light;\n    light.position    = LightPos;\n    light.attenuation = LightAttenuation;\n    light.normal      = Rotate(LightNormal, LightYaw, LightPitch);\n    light.radius      = LightRadius;\n    \n    // Get the closest point on or in the circle on the plane defined by\n    // the light's position and normal. This point is then used\n    // for the standard lighting calculations.\n    \n    vec3 pointOnLight = PointInCircle(pos, light.position, light.normal, light.radius);\n    vec3 toLight      = pointOnLight - pos;\n    vec3 toLightN     = normalize(toLight);\n    \n    float lightCos    = dot(-toLightN, light.normal);\n          lightCos    = (LightDirection == LightDirectionBi) ? abs(lightCos) : max(0.0, lightCos);\n    \n    float lightDist   = length(toLight);\n    float attenuation = Attenuation(lightDist, light.attenuation.x, light.attenuation.y, light.attenuation.z);\n    \n    vec3 reflVector = reflect(-toView, norm);\n    \n    vec3 dirLight = vec3(intensity) * lightCos * attenuation;\n    vec3 spcLight = vec3(0.2) * pow(max(0.0, dot(reflVector, toLightN)), roughness) * lightCos;\n    \n    return (albedo * dirLight) + spcLight;\n}\n\n//--------------------------------------------\n// Ring Light\n//--------------------------------------------\n\nvec3 Lighting_Ring(\n    in vec3  toView,\n    in vec3  pos,\n    in vec3  norm,\n    in vec3  albedo,\n    in float intensity,\n    in float roughness)\n{\n    Light_Ring light;\n    light.position    = LightPos;\n    light.attenuation = LightAttenuation;\n    light.normal      = Rotate(LightNormal, LightYaw, LightPitch);\n    light.radius      = LightRadius;\n    \n    // Get the closest point on the circle circumference on the plane \n    // defined bythe light's position and normal. This point is then used\n    // for the standard lighting calculations.\n    \n    vec3 pointOnLight = PointOnCircle(pos, light.position, light.normal, light.radius);\n    vec3 toLight      = pointOnLight - pos;\n    vec3 toLightN     = normalize(toLight);\n    \n    float lightCos    = dot(-toLightN, light.normal);\n          lightCos    = (LightDirection == LightDirectionBi) ? abs(lightCos) : max(0.0, lightCos);\n    \n    float lightDist   = length(toLight);\n    float attenuation = Attenuation(lightDist, light.attenuation.x, light.attenuation.y, light.attenuation.z);\n    \n    vec3 reflVector = reflect(-toView, norm);\n    \n    vec3 dirLight = vec3(intensity) * lightCos * attenuation;\n    vec3 spcLight = vec3(0.2) * pow(max(0.0, dot(reflVector, toLightN)), roughness) * lightCos;\n    \n    return (albedo * dirLight) + spcLight;\n}\n\n//------------------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------------------\n\nvec3 BumpNormal(in vec3 norm, in vec2 uv)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    \n    float sampleU = texture(iChannel0, uv - eps.yx).r;\n    float sampleD = texture(iChannel0, uv + eps.yx).r;\n    float sampleL = texture(iChannel0, uv - eps.xy).r;\n    float sampleR = texture(iChannel0, uv + eps.xy).r;\n\n   \tvec3 delta = vec3(\n        (sampleL * sampleL - sampleR * sampleR), \n        0.0, \n        (sampleU * sampleU - sampleD * sampleD));\n\n    return normalize(norm + (delta * 1.0));\n}\n\nvec3 Lambertian(in vec3 color)\n{\n    return (color / PI);\n}\n\nvec3 Render(in Ray ray)\n{\n\tvec3 color = vec3(0.0);\n    vec2 march = March(ray);\n    \n    float depth = march.x;\n    float id    = march.y;\n    \n    if(depth < FarClip)\n    {\n        vec3 pos = ray.o + (ray.d * depth);\n        vec3 norm = SceneNormal(pos, depth);\n        \n        if(id < 2.0)\n        {\n            vec2  uv        = (pos.xz * 0.1);\n            vec3  albedo    = Lambertian((id < 1.0) ? texture(iChannel0, uv).rgb * vec3(1.3, 1.0, 1.0): vec3(1.0));\n            float intensity = 4.0;\n            float roughness = 64.0;\n            \n            norm = (id < 1.0) ? BumpNormal(norm, uv) : norm;\n            \n            color = (LightType == LightTypePoint)  ? Lighting_Point(-ray.d, pos, norm, albedo, intensity, roughness)  :\n                    (LightType == LightTypeSphere) ? Lighting_Sphere(-ray.d, pos, norm, albedo, intensity, roughness) :\n                    (LightType == LightTypeCircle) ? Lighting_Circle(-ray.d, pos, norm, albedo, intensity, roughness) :\n                    (LightType == LightTypeRing)   ? Lighting_Ring(-ray.d, pos, norm, albedo, intensity, roughness)   :\n                    color;\n        }\n        else\n        {\n            // Light source\n            color = vec3(1.0);\n        }\n    }\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    UpdateParameters();\n    LightPos.y += sin(iTime);\n    \n\tvec2 uv  = fragCoord.xy / iResolution.xy;\n    \n    vec3 rayOriginPos = vec3(0.0, 6.0, 20.0);\n    vec3 rayLookAtPos = vec3(0.0, 0.0, 0.0);\n    \n#ifdef EnableAA\n    for(float x = -1.0; x < 2.0; ++x)\n    {\n        for(float y = -1.0; y < 2.0; ++y)\n        {\n            vec2 ruv = uv + vec2(x, y) * 0.0005;\n            Ray  ray = Ray_LookAt(ruv, rayOriginPos, rayLookAtPos);\n            \n            fragColor.rgb += Render(ray);\n        }\n    }\n    \n    fragColor.rgb /= 9.0;\n#else\n    Ray ray = Ray_LookAt(uv, rayOriginPos, rayLookAtPos);\n    fragColor.rgb = Render(ray);\n#endif\n    \n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}