{
    "Shader": {
        "info": {
            "date": "1573290976",
            "description": "Drag the mouse around to change the view!\nA galaxy raymarcher loosely based on this paper: https://iopscience.iop.org/article/10.1088/0004-637X/783/2/138/pdf",
            "flags": 0,
            "hasliked": 0,
            "id": "tdKSRz",
            "likes": 21,
            "name": "Galaxy raymarching explained",
            "published": 3,
            "tags": [
                "raymarching",
                "noise",
                "mouse",
                "volume",
                "tutorial",
                "clouds",
                "spiral",
                "space",
                "fog",
                "galaxy",
                "explanation",
                "mobile"
            ],
            "usePreview": 1,
            "username": "skythedragon",
            "viewed": 1758
        },
        "renderpass": [
            {
                "code": "/*\nMIT License\n\nCopyright (c) 2019 Dimas \"Dimev\", \"Skythedragon\" Leenman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n===================================================================================================================================\n\nExplanation:\n\nGalaxies are essentially big clouds of gas and dust, lit by stars inside them.\nThis means we can render them as clouds, using a technique called raymarching\n\nFirst, a bit about raymarching.\nRaymarching is a technique that can be used to render clouds, fog and even atmospheres.\n(there's also distance field raymarching, but that's something different)\nIt works by taking a number of sample points along a ray, and for each sample calulate the density, and the incoming light.\nFor the light there's usually a second ray that calculates how much light is blocked before it reaches the point, but because the \ngas clouds in galaxies are lit by millions of stars, that's a bit expensive to do.\n\nIn order to make a raymarcher, we need to know the density of each sample point along the ray, \nwhich we do with the technique described here: https://iopscience.iop.org/article/10.1088/0004-637X/783/2/138/pdf\nThe technique gets the density of a sample point by combining multiple parts. \n\nThis implementation does a lot of things differently, so don't use this as a reference!\n\nFirst is the galaxy center, which is the bright, usually orange thing in the center of galaxies.\nIt's not affected by noise, unlike the other parts.\nIt's calculated using intensity * pow(distance_from_center, -0.0.855) * exp(-pow(distance_from_center, 0.25));\nwhere distance_from_center is the distance to the galaxy center / the bulge size\nIn the shader we'll be using a simpler version (exp(-distance_from_center)), to keep it fast (and I think it looks better)\n\nThe next components are the disk, the arms and the gas clouds.\nThe disk makes the galaxy flat, and makes sure there are no gas clouds outside the flat galaxy area\nIt's based on the distance to the galaxy center and the galaxy plane.\nWe use float t = tanh(abs(pos.y / disk_height));\n       exp(-distance_from_center / disk_size) * (1.0 - t * t);\nas a fallof here. exp(-distance_from-center / disk_size) maxes sure the disk isn't infinite, while the (1.0 - t * t)\nis the height fallof. It's smoother than using exp(-height), making it look better\n\nNext up are the arms. The paper suggest using a calculation that calculates the angle of the nearest arm based on the distance to the center\nbut I couldn't get this calculation to work properly, so we'll be using a different technique. It works by first rotating the \nsample point around the galaxy, and then taking the distance fallof (like with the disk) to one axis\nBecause the sample is rotated, the axis is also rotated and appears as a spiral\n\nLast is noise for the clouds. The noise itself is calculated before the arms, but the density is calculated afterwards, as it's dependent\non the arms. The clouds are calculated a bit differently, as they have no total for the ray, since they only block light in this shader.\n*/\n\n// this is the maximum trace distance. It's not used here, \n// but if you have an object blocking the ray, use it's distance as the max_dist in the raymarching function\n#define MAX_DISTANCE 1e6\n\n// let's define some variables to tune the galaxy\n// recompile the shader if you change these to see the effect\n#define GALAXY_SIZE vec3(15.0, 4.0, 15.0) /* how big the galaxy is */\n#define CENTER_SIZE 0.6 /* how big the center of the galaxy is (glowing part in the middle) */\n#define CENTER_COLOR vec3(3.2, 1.6, 0.4) /* the color of the center part */\n#define DISK_COLOR vec3(0.2, 0.3, 0.4) /* the color of the disk (outer parts) of the galaxy */\n#define DISK_SIZE 2.4 /* how big the disk is */\n#define DISK_HEIGHT 0.6 /* how thick the disk is */\n#define ARM_ROTATION 0.8 /* how much the arms rotate (higher is more spirals) */\n#define ARM_THICKNESS 8.0 /* how thick the arms are */\n#define DUST_SCALE 0.4 /* the roughness of the noise, lower means bigger clouds, while smaller means more fine clouds */\n#define DUST_THICKNESS 2.6 /* how much effect the noise has */\n\n#define BRIGHTNESS 10.0 /* the brightness of the galaxy */\n\n#define LOD_SWAP 32.0/* at what distance to use the lower lod */\n#define MIN_RAY_LENGTH 1e-3 /* the minimum length the ray needs to be to be raymarched, mainly for performance purposes */\n\n#define NOISE_SEED 32.0 /* seed to use for the noise, changing it makes the dust clouds look different */\n\n// now come some parameters that change performance, we'll use HW_PERFORMANCE to check what device we're on (0 is mobile, other is desktop)\n#if HW_PERFORMANCE == 0\n// we're on a low end device (mobile)\n#define STEPS 12 /* number of raymarch steps */\n#define STEPS_FAR 8 /* number of raymarch steps when the camera is far away */\n#define OCTAVES 1 /* number of noise octaves, more is more noise detail, 0 is no noise */\n#define OCTAVES_FAR 1 /* number of noise octaves when the camera is far away */\n\n#else\n// we're on a desktop computer (or a laptop)\n#define STEPS 32\n#define STEPS_FAR 16\n#define OCTAVES 2\n#define OCTAVES_FAR 2\n\n#endif\n\n/*\nWe'll now define the main raymarching function. This will trace a ray through a sphere, \nand sample points along the ray to render the galaxy\nThe noise is defined as a vec2, since we'll be using 2 noise octaves, 1 for rough shapes, the second for more detail\nWe make one assumption: \nThe y axis is the galaxy's up axis. The reason is that this reduces complexity, \nthe downside is that that the ray needs to be transformed first if the galaxy has a different orientation\n*/\nvec3 raymarch(\n\tvec3 start, // ray stars\n    vec3 dir, // ray direction\n    vec3 galaxy_size, // size of the galaxy (for the bounding sphere)\n    float center_size, // size of the center\n    vec3 center_color, // center color\n    vec3 disk_color, // color of the galaxy disk\n    float disk_size, // size of the disk\n    float disk_height, // thickness of the disk\n    float arm_rotation_amount, // how much the spiral rotates\n    float arm_thickness, // how thicc the arm is\n    float dust_scale, // position is multiplied by this before feeding it into the noise\n    float dust_thickness, // amplitude of the noise, if it's 0 or lower, no noise is added\n    float max_dist, // the maximum distance that can be traced\n    int steps_near, // number of samples\n    int steps_far, // number of samples when the camera is far away\n    int dust_detail_near, // the amount of noise octaves, 0 is no noise\n    int dust_detail_far, // number of noise octaves when the camera is far away\n    float lod_swap, // how far away the intersect has to be to be part of the far lod\n    float min_ray_length // if the ray is shorter than this no raymarching is performed\n) {\n    \n    // find the ray start and end \"positions\" (actually just how far they are along the ray) using a box intersect taken from here:\n    // https://iquilezles.org/articles/intersectors\n    vec3 m = 1.0 / dir;\n    vec3 n = m * start; \n    vec3 k = abs(m) * galaxy_size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float ray_start = max(max( max(t1.x, t1.y), t1.z), 0.0);\n    float ray_end = min(min(min(t2.x, t2.y), t2.z), max_dist);\n    \n    // if there is no intersection, return early\n    if( ray_start > ray_end || ray_end < 0.0) return vec3(0.0);\n    \n    // calculate the ray lenght. The reason it's called step size is because it will be divided by the number of steps later\n    // making it the step size\n    float step_size = ray_end - ray_start;\n    \n    // if the ray length is too small, stop\n    if (step_size < min_ray_length) return vec3(0.0);\n    \n    // we actually need the step size, so calculate that\n    // also switch the number of steps based on the distance\n    int steps = lod_swap > ray_start ? steps_near : steps_far;\n    int dust_detail = lod_swap > ray_start ? dust_detail_near : dust_detail_far;\n    step_size /= float(steps);\n    \n    // where we are along the ray\n    float ray_pos = ray_start;\n    \n    // the optical depth, used to calculate how much light can pass through\n    // it's essentially how much dust and gas is in the way\n    // dust (the dark clouds) also block light, but don't transmit it (in the spectrum we're interested in)\n    // because of that it still has an optical depth, but no total\n    float optical_depth_center = 0.0;\n    float optical_depth_disk = 0.0;\n    float optical_depth_dust = 0.0;\n    \n    // the total amount of light scattered, of each of the 2 types (center and disk (disk also includes arms)\n    vec3 total_center = vec3(0.0);\n    vec3 total_disk = vec3(0.0);\n    \n    // now, perform the actual raymarch.\n    // we'll be taking samples along the ray, and adding those samples to the total\n    for (int i = 0; i < steps; ++i) {\n    \t\n        // calculate the sample position\n        vec3 pos = start + dir * (ray_pos + step_size * 0.5);\n        \n        // the distance from the center\n        float distance_from_center = length(pos);\n        \n        // first, calculate the center glow\n        // Using a simplified one compared to the paper, because it's simpler and I think it also looks a bit better\n        float density_center = exp(-distance_from_center / center_size);\n        \n        // now we need to add the arms, disk and noise.\n        // this is all multiplied together, and then added\n        // first do the disk \n        float t = tanh(abs(pos.y / disk_height));\n        float density_disk_and_arms = exp(-distance_from_center / disk_size) * (1.0 - t * t);\n        \n        // to make the dust clouds, we need some noise\n        // we do this before the arms, so that the position is not warped\n        // this is IQ's noise, taken from here: https://www.shadertoy.com/view/4sfGzS\n        // Copyright 2013 Inigo Quilez, MIT Licence\n        // the reason is that it's fast and simple, but the downside is that it uses a texture\n        // feel free to replace it with a different noise function\n        float z = dust_scale;\n        float a = 1.0;\n        float density_dust = 0.0;\n        for(int j = 0; j < dust_detail; ++j) {\n            \n            vec3 p = floor(z*pos*vec3(0.9, 0.8, 1.1) + NOISE_SEED);\n            vec3 f = fract(z*pos*vec3(0.9, 0.8, 1.1));\n            f = f * f * (3.0 - 2.0 * f);\n            vec2 uv = (p.xy + vec2(37.0, 17.0)* p.z) + f.xy;\n            vec2 rg = textureLod(iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n            density_dust += a * mix(rg.x, rg.y, f.z);\n            \n            z *= 2.0;\n            a *= 0.5;\n        }\n        \n        // power of two, makes the dust look a bit nicer\n        density_dust *= density_dust;\n        \n        // and now the arms. In the paper they use a completely different method for this, but I couldn't get it to work\n        // because of that we'll be using a different (and simpler) method\n        // it works by first rotating the sample point around the center, and then taking the distance to an axis.\n        // this results in a spiral effect\n        // the angle by which to rotate the spiral\n        float angle = distance_from_center * arm_rotation_amount;\n        \n        // now actually rotate the point around the center, using a rotation matrix\n        float s = sin(angle);\n        float c = cos(angle);\n        pos.xz *= mat2(c, -s, s, c);\n        \n        // since the point is rotated, we can take the distance from an axis (x in this case), and calculate a falloff using that\n        float d = tanh(abs(pos.x / arm_thickness));\n        density_disk_and_arms *= 1.0 - (d * d);\n        \n        // most dust clouds are in the arms, so multiply the dust density with the arms density\n        density_dust *= dust_thickness * 4.0 * (-(density_disk_and_arms * density_disk_and_arms) + density_disk_and_arms);\n        \n        // and make sure the densities are correct by multiplying them by the step size\n        density_center *= step_size;\n        density_disk_and_arms *= step_size;\n        density_dust *= step_size;\n        \n        // now accumulate the density in the optical depth\n        optical_depth_center += density_center;\n        optical_depth_disk += density_disk_and_arms;\n\t\toptical_depth_dust += density_dust;\n        \n        // and calculate the amount of light scattered towards the camera\n        // for normal raymarchers, the optical depth to the light source should also be calculated, but since it's very expensive\n        // to do that with millions of stars, we assume the optical depth to the star is 0\n        vec3 attenuation = exp(-((center_color * optical_depth_center) + (disk_color * optical_depth_disk) + optical_depth_dust));\n        \n        // and finally add it to the total of the ray\n        // dust doesn't reflect light, so don't add anything there\n        total_center += density_center * attenuation;\n        total_disk += density_disk_and_arms * attenuation;\n        \n        // increase the ray position\n        // it's done last, but it's still important\n        ray_pos += step_size;\n    } \n\n    // and finally return all the values\n    return total_center * center_color + total_disk * disk_color;\n}\n\n\n\n/*\nnext, we need a way to do something with the raymarch function\n\nto do something with it we need the camera vector (which is the same as the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n\tvec2 uv    = coord.xy / resolution.xy - vec2(0.5);\n         uv.x *= resolution.x / resolution.y;\n\n    return normalize(vec3(uv.x, uv.y, -1.0));\n}\n\n/*\nWe also want the camera to rotate around the galaxy, and for that we need a rotation matrix\nThis function constructs one, and the rotate function rotates a point using this rotation matrix\n*/\nmat4 rotation_matrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotation_matrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\n/*\nfinally, the function that renders the galaxy to the screen\nIt firsts gets the camera position and vector (ray direction) and rotates them around the galaxy.\nIt also applies some exposure, so bright colors look better.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // get the ray direction\n    vec3 dir = get_camera_vector(iResolution, fragCoord);\n    \n    // get the ray start, distance to center debends on the mouse x\n    vec3 start = vec3(0.0, 0.0, iMouse.x == 0.0 ? 32.0 : 64.0 * (iMouse.x / iResolution.x));\n    \n    // now rotate the camera position and ray direction around the galaxy center\n    start = rotate(start, vec3(1.0, 0.0, 0.0), (iMouse.y / iResolution.y) * 3.14 - 1.57);\n    dir = rotate(dir, vec3(1.0, 0.0, 0.0), (iMouse.y / iResolution.y) * 3.14 - 1.57);\n                   \n    // now perform the raymarch\n    vec3 col = raymarch(\n    \tstart,\n        dir,\n        GALAXY_SIZE,\n        CENTER_SIZE,\n        CENTER_COLOR,\n        DISK_COLOR,\n        DISK_SIZE,\n        DISK_HEIGHT,\n        ARM_ROTATION,\n        ARM_THICKNESS,\n        DUST_SCALE,\n        DUST_THICKNESS,\n        MAX_DISTANCE,\n        STEPS,\n        STEPS_FAR,\n        OCTAVES,\n        OCTAVES_FAR,\n        LOD_SWAP,\n        MIN_RAY_LENGTH\n    ) * BRIGHTNESS;\n    \n    // apply exposure, makes bright areas look a bit nicer and set the fragcolor to complete the render\n    fragColor = vec4(1.0 - exp(-1.0 * col), 0.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}