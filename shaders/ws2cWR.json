{
    "Shader": {
        "info": {
            "date": "1586467905",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "ws2cWR",
            "likes": 21,
            "name": "Day 112",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 541
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 98\" by jeyko. https://shadertoy.com/view/wdXczX\n// 2020-04-06 10:18:27\n\n\n\n// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 26.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.04;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.5)*0.4;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor.b *= 0.97 + dot(uvn,uvn)*0.4;\n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.6);\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    //fragColor.b *= 1. + uv.x*0.02;\n    //fragColor.g *= 1. + uv.t*0.05;\n    fragColor *= 1. - dot(uvn,uvn)*2.;\n    \n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)\n\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define pmod(p,z) mod(p,z) - 0.5*z\n\n#define pal(a,b,d,e,f) ((a) + (b)*sin((d) * (e) + (f)))\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x,max(p.y,p.z));\n}\n\nvec3 glow = vec3(0);\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    vec3 j = p;\n    p.z = pmod(p.z, 10.);\n\n    \n    \n    for(int i = 0; i < 4; i++){\n    \tp = abs(p);\n        p.x -= 2.;\n        p.xy *= rot(0.25*pi);\n        \n        p.t -= 1.;\n        p.z += 0.2;\n        \n        \n    }\n    vec3 glown = vec3(0);\n    \n    //float dB = length(p) - 0.4;\n    \n    p = abs(p);\n    p.xy -= 0.3;\n    \n    p = abs(p);\n    p.y -= 0.2;\n    p = abs(p);\n    p.x -= 0.5;\n    p = abs(p);\n    p.x -= 0.5;\n    \n    float attd = pow(abs(sin(j.z*0.5 + iTime*0.4)), 10.);; \n    float atte = pow(abs(sin(j.z*0.5 + iTime*10.4)), 100.)*attd; \n    \n    vec3 q = p;\n    \n    q.x -= 0.4;\n    q = abs(q);\n    q.x -= 0.4;\n\n    q.y -= 0.4;\n    \n    vec3 sz = vec3(0.02,0.02,20.5);\n    float dB = sdBox(q, sz)*1.2;\n    \n    d = dmin(d, vec2(dB, 2.));\n    float att = pow(abs(sin(j.z*0.1 + iTime*0.5 + sin(j.x*4.)*0.2)), 400.);\n    \n    //glow += 0.9/(0.001 + dB*dB*2000.)*vec3(1.8 + attd*8.,0.9,0.7)*att;\n    glown += 0.9/(0.0001 + dB*dB*10.)*vec3(2.8 + attd*8.,0.9,0.7)*att;\n    \n    p.z -= 1.5;\n    \n    p = abs(p);\n    p.z -= 0.2;\n    //p.xz *= rot(0.5);\n    float dC = sdBox(p, vec3(0.02,2000.7,0.02));\n    d = dmin(d, vec2(dC, 2.));\n    float attb = pow(abs(sin(p.x*0.4 + iTime - 1.)), 10.);\n    //glown += 7.9/(0.04 + dC*dC*2000.)*vec3(1.,1.,1.7)*attb;\n\tglown += 2.9/(0.001 - - atte*2. + dC*dC*400.)*vec3(1.,1.,1.7)*attb;\n\n    //glow += 2.9/(0.001 + dC*dC*400.)*vec3(1.,1.,1.7)*attb;\n    \n    p.x -= 0.4;\n    p = abs(p);\n    p.x += 0.1;\n    p.y -= 0.2;\n    p.xy *= rot(-0.25*pi);\n    p.z -= 1.;\n    //p -= 0.4;\n    p.x -= 0.3;\n    \n    float dD = sdBox(p, vec3(0.02,1.7,0.02));\n    d = dmin(d, vec2(dD, 2.));\n    float attc = pow(abs(sin(p.y*0.4 + iTime + 4.)), 10.);\n    //glow += 10.9/(0.01 + dD*dD*2000.)*sin(vec3(0.1,0.8,0.7) + vec3(0,0,attd*2.))*attc;\n    //glow += 0.7/(0.001 + dD*dD*100.)*sin(vec3(0.1,0.1,0.9) + vec3(0,0,attd*2.))*attc;\n    \n    \n    //glown += 0.7/(0.0001 + dD*dD*100.)*sin(vec3(0.1,1.1,0.9) + vec3(0,0,attd*1.))*attc;\n    //glown += 0.7/(0.001 + dD*dD*(60. - atte*59.))*sin(vec3(0.,1. - atte*0.6,1.9) + vec3(0,0,attd*1.))*attc*vec3(1,1,1.5)*0.8;\n    //glown += 0.7/(0.001 + dD*dD*(60. - atte*59.))*sin(vec3(0.,0.4 - atte*0.6,1.9) + vec3(0,0,attd*1.))*attc*vec3(1,1,1.5)*0.8;\n    glown += 0.7/(0.001 + dD*dD*(60. - atte*59.))*sin(vec3(0.1,0.4 - atte*0.6,1.1) + vec3(0,0,attd*0.))*attc*vec3(1,1,1.)*0.8;\n    \n    \n    d.x = abs(d.x) + 0.002;\n    \n    \n    \n    glow += glown;\n    \n    d.x *= 0.4;\n    \n    return d;\n}\nint it = 0;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    t = 0.; hit = false; p = ro;\n    \n    for(it = 0; it< 60 + min(iFrame,0); it++){\n    \td = map(p);\n        \n        if(d.x < 0.001){\n        \thit = true;\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + (right*uv.x + up*uv.y)*0.6);\n}\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return -normalize(vec3(\n    \tmap(p - t.xyy).x - map(p + t.xyy).x,\n    \tmap(p - t.yxy).x - map(p + t.yxy).x,\n    \tmap(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n\tuv *= 1. - dot(uv,uv)*0.06;\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += iTime*1.;\n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.z = ro.z + 2.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p; float t; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if (d.x < 0.001){\n    \tvec3 n = getNormal(p);\n        vec3 l = normalize(vec3(1));\n        float dnh = max(dot(n,normalize(l - rd)),0.);\n        float diff = max(dot(n,l),0.);\n        float spec = pow(max(dot(n,normalize(l - rd)),0.), 20.);\n        float fres = pow(1. - dnh, 5.);\n    \n        \n        //col *= fres;\n        \n    }\n    \n    //col += float(it)*0.003;\n    \n    \n    col += glow*0.001;\n    col = mix(col, vec3(0.1,0.1,0.16 + (uv.x + 0.5)*0.1)*0.02, smoothstep(0.,1.,t*0.04 ));\n    \n    \n    \n    //col += pal(0.5,0.6,vec3(0.7,0.3,0.7), 0.7,0.6)*smoothstep(1.,0.,length(glow)*0.3);;\n    col = max(col, 0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}