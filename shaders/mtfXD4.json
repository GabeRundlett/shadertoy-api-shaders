{
    "Shader": {
        "info": {
            "date": "1675032677",
            "description": "A shader after a very long pause.",
            "flags": 32,
            "hasliked": 0,
            "id": "mtfXD4",
            "likes": 71,
            "name": "Smoking Duck",
            "published": 3,
            "tags": [
                "simulation",
                "water",
                "fluid",
                "volumetric",
                "fog",
                "smoke",
                "advection",
                "duck",
                "incompressible",
                "incompressible",
                "navier",
                "stokes",
                "jos",
                "stam"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 1889
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nconst int bloomKernel = 5;\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\n// No miracle can be done in only one pass.\nvec3 Bloom( in vec2 uv, int radius, float lod)\n{\n    float scale = pow(2.0, lod);\n    vec3  bloom = vec3(0);\n\tfor (int x = -radius; x <= radius; x++)\n\t{\n\t\tfor (int y = -radius; y <= radius; y++)\n\t\t{\n            vec2 off = vec2(x, y);\n            vec2  v = vec2(off) / float(radius);\n            float w = exp(-4.0  * (dot(v, v)));\n            //float c = dot(texture(iChannel1, (uv + off * scale) / iResolution.xy, lod).rgb, vec3(1.0 / 3.0));\n            float c = dot(texelFetch(iChannel1, ivec2(uv / scale + off), int(lod)).rgb, vec3(1.0 / 3.0));\n            bloom += pow(c, 5.0) * w;\n\t\t}\n\t}\n    return bloom / (0.25 * float(radius * radius) * pi);   // Gaussian integral\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    \n    float w = 0.5;\n    vec3 b = vec3(0);\n    for(int lod = 0; lod < 4; lod++)\n    {\n        b += Bloom(fragCoord, bloomKernel, float(lod)) * w;\n        w *= 0.54;\n    }\n    c += b;\n    fragColor = vec4(aces_tonemap(c), 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec2 fbm(vec3 p, int octaveNum)\n{\n\tvec2 acc = vec2(0);\t\n\tfloat freq = 1.0;\n\tfloat amp = 0.5;\n    vec3 shift = vec3(100);\n\tfor (int i = 0; i < octaveNum; i++)\n\t{\n\t\tacc += vec2(noise(p), noise(p + vec3(0,0,10))) * amp;\n        p = p * 2.0 + shift;\n        amp *= 0.5;\n\t}\n\treturn acc;\n}\n\n\nvec3 sampleMinusGradient(vec2 coord)\n{\n    vec3\tveld\t= texture(iChannel1, coord / iResolution.xy).xyz;\n    float\tleft\t= texture(iChannel0,(coord + vec2(-1, 0)) / iResolution.xy).w;\n    float\tright\t= texture(iChannel0,(coord + vec2( 1, 0)) / iResolution.xy).w;\n    float\tbottom\t= texture(iChannel0,(coord + vec2( 0,-1)) / iResolution.xy).w;\n    float\ttop \t= texture(iChannel0,(coord + vec2( 0, 1)) / iResolution.xy).w;\n    vec2\tgrad \t= vec2(right - left,top - bottom) * 0.5;\n    return\tvec3(veld.xy - grad, veld.z);\n}\n\nfloat vignette(vec2 q, float v)\n{\n    return pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float vig = vignette(fragCoord / iResolution.xy, 0.6);\n\t// Euler advection\n    vec2\tvelocity = sampleMinusGradient(fragCoord).xy;\n    vec3\tveld = sampleMinusGradient(fragCoord - dissipation * velocity).xyz;\n    float\tdensity = veld.z;\n    velocity = veld.xy;\n\n    vec2\tuv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    // Small perturbation\n    vec2 detailNoise = fbm(vec3(uv*25., iTime + 30.), 7) - 0.5;\n    \n    // Injection\n    vec2 injectionNoise = fbm(vec3(uv *1.5, iTime * 0.1 + 30.), 7) - 0.5;\n    //velocity += injectionNoise * 0.1;\n    density += (length(injectionNoise) * 0.004) * mix(1., vig, 1.0);\n    velocity += injectionNoise * 0.01;\n\n    // Inject emiter\n    float influenceRadius = ballRadius * 2.;\n    vec2 p = duckPosition(iFrame, iResolution.x / iResolution.y);\n    float dist = distance(uv, p);\n    if(dist < influenceRadius)\n    {\n        vec2 op = duckPosition(iFrame + 1, iResolution.x / iResolution.y);\n        vec2 ballVelocity = p - op;\n        float infuence = (influenceRadius - dist) / influenceRadius;\n        density += infuence * length(ballVelocity) * 4.0;\n        density = max(0., density);\n        velocity += infuence * (ballVelocity * 40. + detailNoise * 4.);   \n    }\n        \n    density = min(1., density);\n    density *= 0.995;     // damp\n    veld = vec3(velocity, density);\n    veld *=  mix(1., vig, 0.02);\n    fragColor = vec4(veld, texture(iChannel0,fragCoord / iResolution.xy).w);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Divergence\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 icoord = ivec2(fragCoord);\n    float vel_x_left\t= texelFetch(iChannel0, icoord + ivec2(-1,  0) , 0).x;\n    float vel_x_right\t= texelFetch(iChannel0, icoord + ivec2( 1,  0) , 0).x;\n    float vel_y_bottom\t= texelFetch(iChannel0, icoord + ivec2( 0, -1) , 0).y;\n    float vel_y_top\t\t= texelFetch(iChannel0, icoord + ivec2( 0,  1) , 0).y;\n    float divergence\t= (vel_x_right - vel_x_left + vel_y_top - vel_y_bottom) * 0.5;\n    fragColor = vec4(divergence,vec3(1)); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pressure solver 1st interation\n\n// Impired by https://www.shadertoy.com/view/MdSczK by Trirop\n// Since in shadertoy we don't have countless pass we need to do many pass at once.\n\n\n// code generated by :\n/*\n#include <iostream>\n\nconst int tabSize = 48;\n\nstd::int64_t divTab[tabSize][tabSize];\nstd::int64_t preTab[tabSize][tabSize];\n\n\nvoid recurse(int x, int y, int level)\n{\n    level--;\n    divTab[x][y] += std::int64_t(1) << std::int64_t(level * 2);\n    if (level)\n    {\n        recurse(x - 1, y, level);\n        recurse(x + 1, y, level);\n        recurse(x, y - 1, level);\n        recurse(x, y + 1, level);\n    }\n    else\n    {\n        preTab[x - 1][y]++;\n        preTab[x + 1][y]++;\n        preTab[x][y - 1]++;\n        preTab[x][y + 1]++;\n    }\n}\n\nvoid clear(std::int64_t (&tab)[tabSize][tabSize])\n{\n    for (int x = 0; x < tabSize; x++)\n    {\n        for (int y = 0; y < tabSize; y++)\n        {\n            tab[x][y] = 0;\n        }\n    }\n}\n\nvoid output(const char *functionName, std::int64_t(&tab)[tabSize][tabSize], std::int64_t multiplier)\n{\n    std::int64_t total = 0;\n    for (int x = 0; x < tabSize; x++)\n    {\n        for (int y = 0; y < tabSize; y++)\n        {\n            if (tab[x][y])\n            {\n                total += tab[x][y];\n                std::cout << \"\\tp += \" << tab[x][y] << \".*\" << functionName << \"(\" << x - tabSize / 2 << \", \" << y - tabSize / 2 << \");\\n\";\n            }\n        }\n    }\n    total *= multiplier;\n    std::cout << \"\\treturn\\tp / \" << total << \".;\\n\";\n}\n\nint main()\n{\n    clear(divTab);\n    clear(preTab);\n    recurse(tabSize / 2, tabSize / 2, 10);\n    output(\"div\", divTab, 2);\n    output(\"pre\", preTab, 1);\n}\n*/\n\nfloat div(int x,int y)\n{\n    return texelFetch(iChannel0, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getDiv( void )\n{\n    float p = 0.;\n    p += 1.*div(-9, 0);\n    p += 9.*div(-8, -1);\n    p += 4.*div(-8, 0);\n    p += 9.*div(-8, 1);\n    p += 36.*div(-7, -2);\n    p += 32.*div(-7, -1);\n    p += 97.*div(-7, 0);\n    p += 32.*div(-7, 1);\n    p += 36.*div(-7, 2);\n    p += 84.*div(-6, -3);\n    p += 112.*div(-6, -2);\n    p += 436.*div(-6, -1);\n    p += 320.*div(-6, 0);\n    p += 436.*div(-6, 1);\n    p += 112.*div(-6, 2);\n    p += 84.*div(-6, 3);\n    p += 126.*div(-5, -4);\n    p += 224.*div(-5, -3);\n    p += 1092.*div(-5, -2);\n    p += 1280.*div(-5, -1);\n    p += 2336.*div(-5, 0);\n    p += 1280.*div(-5, 1);\n    p += 1092.*div(-5, 2);\n    p += 224.*div(-5, 3);\n    p += 126.*div(-5, 4);\n    p += 126.*div(-4, -5);\n    p += 280.*div(-4, -4);\n    p += 1694.*div(-4, -3);\n    p += 2752.*div(-4, -2);\n    p += 6656.*div(-4, -1);\n    p += 6464.*div(-4, 0);\n    p += 6656.*div(-4, 1);\n    p += 2752.*div(-4, 2);\n    p += 1694.*div(-4, 3);\n    p += 280.*div(-4, 4);\n    p += 126.*div(-4, 5);\n    p += 84.*div(-3, -6);\n    p += 224.*div(-3, -5);\n    p += 1694.*div(-3, -4);\n    p += 3520.*div(-3, -3);\n    p += 11016.*div(-3, -2);\n    p += 16128.*div(-3, -1);\n    p += 24608.*div(-3, 0);\n    p += 16128.*div(-3, 1);\n    p += 11016.*div(-3, 2);\n    p += 3520.*div(-3, 3);\n    p += 1694.*div(-3, 4);\n    p += 224.*div(-3, 5);\n    p += 84.*div(-3, 6);\n    p += 36.*div(-2, -7);\n    p += 112.*div(-2, -6);\n    p += 1092.*div(-2, -5);\n    p += 2752.*div(-2, -4);\n    p += 11016.*div(-2, -3);\n    p += 21664.*div(-2, -2);\n    p += 47432.*div(-2, -1);\n    p += 59712.*div(-2, 0);\n    p += 47432.*div(-2, 1);\n    p += 21664.*div(-2, 2);\n    p += 11016.*div(-2, 3);\n    p += 2752.*div(-2, 4);\n    p += 1092.*div(-2, 5);\n    p += 112.*div(-2, 6);\n    p += 36.*div(-2, 7);\n    p += 9.*div(-1, -8);\n    p += 32.*div(-1, -7);\n    p += 436.*div(-1, -6);\n    p += 1280.*div(-1, -5);\n    p += 6656.*div(-1, -4);\n    p += 16128.*div(-1, -3);\n    p += 47432.*div(-1, -2);\n    p += 92224.*div(-1, -1);\n    p += 163476.*div(-1, 0);\n    p += 92224.*div(-1, 1);\n    p += 47432.*div(-1, 2);\n    p += 16128.*div(-1, 3);\n    p += 6656.*div(-1, 4);\n    p += 1280.*div(-1, 5);\n    p += 436.*div(-1, 6);\n    p += 32.*div(-1, 7);\n    p += 9.*div(-1, 8);\n    p += 1.*div(0, -9);\n    p += 4.*div(0, -8);\n    p += 97.*div(0, -7);\n    p += 320.*div(0, -6);\n    p += 2336.*div(0, -5);\n    p += 6464.*div(0, -4);\n    p += 24608.*div(0, -3);\n    p += 59712.*div(0, -2);\n    p += 163476.*div(0, -1);\n    p += 409744.*div(0, 0);\n    p += 163476.*div(0, 1);\n    p += 59712.*div(0, 2);\n    p += 24608.*div(0, 3);\n    p += 6464.*div(0, 4);\n    p += 2336.*div(0, 5);\n    p += 320.*div(0, 6);\n    p += 97.*div(0, 7);\n    p += 4.*div(0, 8);\n    p += 1.*div(0, 9);\n    p += 9.*div(1, -8);\n    p += 32.*div(1, -7);\n    p += 436.*div(1, -6);\n    p += 1280.*div(1, -5);\n    p += 6656.*div(1, -4);\n    p += 16128.*div(1, -3);\n    p += 47432.*div(1, -2);\n    p += 92224.*div(1, -1);\n    p += 163476.*div(1, 0);\n    p += 92224.*div(1, 1);\n    p += 47432.*div(1, 2);\n    p += 16128.*div(1, 3);\n    p += 6656.*div(1, 4);\n    p += 1280.*div(1, 5);\n    p += 436.*div(1, 6);\n    p += 32.*div(1, 7);\n    p += 9.*div(1, 8);\n    p += 36.*div(2, -7);\n    p += 112.*div(2, -6);\n    p += 1092.*div(2, -5);\n    p += 2752.*div(2, -4);\n    p += 11016.*div(2, -3);\n    p += 21664.*div(2, -2);\n    p += 47432.*div(2, -1);\n    p += 59712.*div(2, 0);\n    p += 47432.*div(2, 1);\n    p += 21664.*div(2, 2);\n    p += 11016.*div(2, 3);\n    p += 2752.*div(2, 4);\n    p += 1092.*div(2, 5);\n    p += 112.*div(2, 6);\n    p += 36.*div(2, 7);\n    p += 84.*div(3, -6);\n    p += 224.*div(3, -5);\n    p += 1694.*div(3, -4);\n    p += 3520.*div(3, -3);\n    p += 11016.*div(3, -2);\n    p += 16128.*div(3, -1);\n    p += 24608.*div(3, 0);\n    p += 16128.*div(3, 1);\n    p += 11016.*div(3, 2);\n    p += 3520.*div(3, 3);\n    p += 1694.*div(3, 4);\n    p += 224.*div(3, 5);\n    p += 84.*div(3, 6);\n    p += 126.*div(4, -5);\n    p += 280.*div(4, -4);\n    p += 1694.*div(4, -3);\n    p += 2752.*div(4, -2);\n    p += 6656.*div(4, -1);\n    p += 6464.*div(4, 0);\n    p += 6656.*div(4, 1);\n    p += 2752.*div(4, 2);\n    p += 1694.*div(4, 3);\n    p += 280.*div(4, 4);\n    p += 126.*div(4, 5);\n    p += 126.*div(5, -4);\n    p += 224.*div(5, -3);\n    p += 1092.*div(5, -2);\n    p += 1280.*div(5, -1);\n    p += 2336.*div(5, 0);\n    p += 1280.*div(5, 1);\n    p += 1092.*div(5, 2);\n    p += 224.*div(5, 3);\n    p += 126.*div(5, 4);\n    p += 84.*div(6, -3);\n    p += 112.*div(6, -2);\n    p += 436.*div(6, -1);\n    p += 320.*div(6, 0);\n    p += 436.*div(6, 1);\n    p += 112.*div(6, 2);\n    p += 84.*div(6, 3);\n    p += 36.*div(7, -2);\n    p += 32.*div(7, -1);\n    p += 97.*div(7, 0);\n    p += 32.*div(7, 1);\n    p += 36.*div(7, 2);\n    p += 9.*div(8, -1);\n    p += 4.*div(8, 0);\n    p += 9.*div(8, 1);\n    p += 1.*div(9, 0);\n    return  p / 1048576.;\n}\n\nfloat pre(int x,int y)\n{\n    return texelFetch(iChannel1, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).w;\n}\n\nfloat getPre( void )\n{\n    float p = 0.;\n    p += 1.*pre(-10, 0);\n    p += 10.*pre(-9, -1);\n    p += 10.*pre(-9, 1);\n    p += 45.*pre(-8, -2);\n    p += 100.*pre(-8, 0);\n    p += 45.*pre(-8, 2);\n    p += 120.*pre(-7, -3);\n    p += 450.*pre(-7, -1);\n    p += 450.*pre(-7, 1);\n    p += 120.*pre(-7, 3);\n    p += 210.*pre(-6, -4);\n    p += 1200.*pre(-6, -2);\n    p += 2025.*pre(-6, 0);\n    p += 1200.*pre(-6, 2);\n    p += 210.*pre(-6, 4);\n    p += 252.*pre(-5, -5);\n    p += 2100.*pre(-5, -3);\n    p += 5400.*pre(-5, -1);\n    p += 5400.*pre(-5, 1);\n    p += 2100.*pre(-5, 3);\n    p += 252.*pre(-5, 5);\n    p += 210.*pre(-4, -6);\n    p += 2520.*pre(-4, -4);\n    p += 9450.*pre(-4, -2);\n    p += 14400.*pre(-4, 0);\n    p += 9450.*pre(-4, 2);\n    p += 2520.*pre(-4, 4);\n    p += 210.*pre(-4, 6);\n    p += 120.*pre(-3, -7);\n    p += 2100.*pre(-3, -5);\n    p += 11340.*pre(-3, -3);\n    p += 25200.*pre(-3, -1);\n    p += 25200.*pre(-3, 1);\n    p += 11340.*pre(-3, 3);\n    p += 2100.*pre(-3, 5);\n    p += 120.*pre(-3, 7);\n    p += 45.*pre(-2, -8);\n    p += 1200.*pre(-2, -6);\n    p += 9450.*pre(-2, -4);\n    p += 30240.*pre(-2, -2);\n    p += 44100.*pre(-2, 0);\n    p += 30240.*pre(-2, 2);\n    p += 9450.*pre(-2, 4);\n    p += 1200.*pre(-2, 6);\n    p += 45.*pre(-2, 8);\n    p += 10.*pre(-1, -9);\n    p += 450.*pre(-1, -7);\n    p += 5400.*pre(-1, -5);\n    p += 25200.*pre(-1, -3);\n    p += 52920.*pre(-1, -1);\n    p += 52920.*pre(-1, 1);\n    p += 25200.*pre(-1, 3);\n    p += 5400.*pre(-1, 5);\n    p += 450.*pre(-1, 7);\n    p += 10.*pre(-1, 9);\n    p += 1.*pre(0, -10);\n    p += 100.*pre(0, -8);\n    p += 2025.*pre(0, -6);\n    p += 14400.*pre(0, -4);\n    p += 44100.*pre(0, -2);\n    p += 63504.*pre(0, 0);\n    p += 44100.*pre(0, 2);\n    p += 14400.*pre(0, 4);\n    p += 2025.*pre(0, 6);\n    p += 100.*pre(0, 8);\n    p += 1.*pre(0, 10);\n    p += 10.*pre(1, -9);\n    p += 450.*pre(1, -7);\n    p += 5400.*pre(1, -5);\n    p += 25200.*pre(1, -3);\n    p += 52920.*pre(1, -1);\n    p += 52920.*pre(1, 1);\n    p += 25200.*pre(1, 3);\n    p += 5400.*pre(1, 5);\n    p += 450.*pre(1, 7);\n    p += 10.*pre(1, 9);\n    p += 45.*pre(2, -8);\n    p += 1200.*pre(2, -6);\n    p += 9450.*pre(2, -4);\n    p += 30240.*pre(2, -2);\n    p += 44100.*pre(2, 0);\n    p += 30240.*pre(2, 2);\n    p += 9450.*pre(2, 4);\n    p += 1200.*pre(2, 6);\n    p += 45.*pre(2, 8);\n    p += 120.*pre(3, -7);\n    p += 2100.*pre(3, -5);\n    p += 11340.*pre(3, -3);\n    p += 25200.*pre(3, -1);\n    p += 25200.*pre(3, 1);\n    p += 11340.*pre(3, 3);\n    p += 2100.*pre(3, 5);\n    p += 120.*pre(3, 7);\n    p += 210.*pre(4, -6);\n    p += 2520.*pre(4, -4);\n    p += 9450.*pre(4, -2);\n    p += 14400.*pre(4, 0);\n    p += 9450.*pre(4, 2);\n    p += 2520.*pre(4, 4);\n    p += 210.*pre(4, 6);\n    p += 252.*pre(5, -5);\n    p += 2100.*pre(5, -3);\n    p += 5400.*pre(5, -1);\n    p += 5400.*pre(5, 1);\n    p += 2100.*pre(5, 3);\n    p += 252.*pre(5, 5);\n    p += 210.*pre(6, -4);\n    p += 1200.*pre(6, -2);\n    p += 2025.*pre(6, 0);\n    p += 1200.*pre(6, 2);\n    p += 210.*pre(6, 4);\n    p += 120.*pre(7, -3);\n    p += 450.*pre(7, -1);\n    p += 450.*pre(7, 1);\n    p += 120.*pre(7, 3);\n    p += 45.*pre(8, -2);\n    p += 100.*pre(8, 0);\n    p += 45.*pre(8, 2);\n    p += 10.*pre(9, -1);\n    p += 10.*pre(9, 1);\n    p += 1.*pre(10, 0);\n    return  p / 1048576.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    float div = getDiv();\n    float p = getPre() - div;\n    fragColor = vec4(p, div, vec3(1));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst float dissipation \t= 0.95;\n\nconst float ballRadius\t\t= 0.09;\nconst float fogHeigth\t\t= ballRadius * 3.;\nconst int\tnbSlice\t\t\t= 24;\nconst float fogSlice\t\t= fogHeigth / float(nbSlice);\nconst int\tnbSphere \t\t= 1;\nconst float shadowDensity \t= 15.;\nconst float fogDensity \t\t= 5.;\nconst float lightHeight     = 2.0;\nconst float waterHeight     = 0.2;\nconst float waterScale      = 0.025;\nconst float duckScale       = 0.25;\nconst vec3  lightPos        = vec3(0.5, lightHeight, 0.5);\n\nconst float tau =  radians(360.0);\nconst float pi =  radians(180.0);\n\n\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nbool floorIntersect(in vec3 ro, in vec3 rd, in float floorHeight, out float t) \n{\n    ro.y -= floorHeight;\n    if(rd.y < -0.01)\n    {\n        t = ro.y / - rd.y;\n        return true;\n    }\n    return false;\n} \n\n// https://iquilezles.org/articles/intersectors\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 center,out vec3 oN ) \n{\n    ro -= center;\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\nvec2 duckPosition(int frame, float aspectRatio)\n{\n    float fframe = float(frame);\n    float s = 0.02;\n    return vec2(cos(fframe * s * 0.5) * aspectRatio, sin(fframe * s)) * 0.7;\n}\n\n\nfloat dist2(vec3 v)\n{\n    return dot(v, v);\n}\n\n// Box SDF by IQ https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Duck model from Jimmi: https://www.shadertoy.com/view/4lsSDl\n\nfloat duckBody(vec3 p) {\n    float k = 6.0;\n    float a = 0.;\n    \n    //p.x = abs(p.x);\n    \n    a += exp(-k * sdSphere(p + vec3(0.11, 0, 0.1), 0.06));\n    a += exp(-k * sdSphere(p + vec3(-0.11, 0, 0.1), 0.06));\n    a += exp(-k * sdSphere(p + vec3(0.2, 0, 0.3), 0.1));\n    a += exp(-k * sdSphere(p + vec3(-0.2, 0, 0.3), 0.1));\n    a += exp(-k * sdSphere(p + vec3(0.2, 0, 0.55), 0.07));\n    a += exp(-k * sdSphere(p + vec3(-0.2, 0, 0.55), 0.07));\n    a += exp(-k * sdSphere(p + vec3(-0.00, 0, 0.72), 0.1));\n    \n    a += exp(-k * sdSphere(p + vec3(0, -0.39, 0.8), 0.01));\n\n    a += exp(-k * sdSphere(p + vec3(0, -0.7, 0.1), 0.15));\n    a += exp(-k * sdSphere(p + vec3(0, -0.65, -0.05), 0.07));\n\n    return -log(a) / k;\n}\n\nfloat beak(vec3 p, float s)\n{\n    float k = max(length(p)-s, -(length(p+vec3(-0.15,-0.2,-0.1))-0.25));\n    k = max(k, -(length(p+vec3(0.12,-0.2,-0.1))-0.25));\n    return k < 0.0 ? 0.0 : k;\n}\n\nfloat duckBeak(vec3 p)\n{\n    float k = 12.0;\n    float a = 0.;\n    \n    a += exp(-k * beak(p + vec3(0, -0.55, -0.1), 0.15));\n\n    return -log(a) / k;\n}\n\nfloat duckMap(in vec3 p)\n{\n    p /= duckScale;\n    return min(duckBody(p), duckBeak(p)) * duckScale;\n}\n\n\nvec4 nearest(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 duckMapColor(vec3 p)\n{\n    p /= duckScale;\n    p.x = abs(p.x);\n    vec4 res = vec4(duckBody(p), vec3(1, 1, 0));\n    res = nearest(res, vec4(duckBeak(p), vec3(1, 0, 0)));\n    res = nearest(res, vec4(sdSphere(p-vec3(0.09, 0.62, 0.14), 0.06), vec3(0.0, 0, 0.3)));\n    res.x *= duckScale;\n    return res;\n}\n\n#define NORMALFUNC(NAME, MAPFUNC, EPS)\t\t\t\t\t\t\t\t\\\nvec3 NAME(in vec3 p)\t\t\t\t\t\t\t\t    \t\t\t\\\n{                                                                   \\\n    const vec2 k = vec2(EPS,-EPS);\t\t\t\t                    \\\n    return normalize( k.xyy * MAPFUNC(p + k.xyy) + \t\t\t    \t\\\n                      k.yyx * MAPFUNC(p + k.yyx) + \t\t\t\t    \\\n                      k.yxy * MAPFUNC(p + k.yxy) + \t\t\t\t    \\\n                      k.xxx * MAPFUNC(p + k.xxx) );\t\t\t\t    \\\n}\n\nNORMALFUNC(calcNormalDuck,duckMap, 0.0001)\n\n// Fog by IQ https://iquilezles.org/articles/fog\n\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pressure solver 2nd interation\n\n// Impired by https://www.shadertoy.com/view/MdSczK by Trirop\n// Since in shadertoy we don't have countless passed we need to do many pass at once.\n\n\nfloat div(int x,int y)\n{\n    return texelFetch(iChannel1, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).y;\n}\n\nfloat pre(int x,int y)\n{\n    return texelFetch(iChannel1, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getPre( void )\n{\n    float p = 0.;\n    p += 1.*pre(-10, 0);\n    p += 10.*pre(-9, -1);\n    p += 10.*pre(-9, 1);\n    p += 45.*pre(-8, -2);\n    p += 100.*pre(-8, 0);\n    p += 45.*pre(-8, 2);\n    p += 120.*pre(-7, -3);\n    p += 450.*pre(-7, -1);\n    p += 450.*pre(-7, 1);\n    p += 120.*pre(-7, 3);\n    p += 210.*pre(-6, -4);\n    p += 1200.*pre(-6, -2);\n    p += 2025.*pre(-6, 0);\n    p += 1200.*pre(-6, 2);\n    p += 210.*pre(-6, 4);\n    p += 252.*pre(-5, -5);\n    p += 2100.*pre(-5, -3);\n    p += 5400.*pre(-5, -1);\n    p += 5400.*pre(-5, 1);\n    p += 2100.*pre(-5, 3);\n    p += 252.*pre(-5, 5);\n    p += 210.*pre(-4, -6);\n    p += 2520.*pre(-4, -4);\n    p += 9450.*pre(-4, -2);\n    p += 14400.*pre(-4, 0);\n    p += 9450.*pre(-4, 2);\n    p += 2520.*pre(-4, 4);\n    p += 210.*pre(-4, 6);\n    p += 120.*pre(-3, -7);\n    p += 2100.*pre(-3, -5);\n    p += 11340.*pre(-3, -3);\n    p += 25200.*pre(-3, -1);\n    p += 25200.*pre(-3, 1);\n    p += 11340.*pre(-3, 3);\n    p += 2100.*pre(-3, 5);\n    p += 120.*pre(-3, 7);\n    p += 45.*pre(-2, -8);\n    p += 1200.*pre(-2, -6);\n    p += 9450.*pre(-2, -4);\n    p += 30240.*pre(-2, -2);\n    p += 44100.*pre(-2, 0);\n    p += 30240.*pre(-2, 2);\n    p += 9450.*pre(-2, 4);\n    p += 1200.*pre(-2, 6);\n    p += 45.*pre(-2, 8);\n    p += 10.*pre(-1, -9);\n    p += 450.*pre(-1, -7);\n    p += 5400.*pre(-1, -5);\n    p += 25200.*pre(-1, -3);\n    p += 52920.*pre(-1, -1);\n    p += 52920.*pre(-1, 1);\n    p += 25200.*pre(-1, 3);\n    p += 5400.*pre(-1, 5);\n    p += 450.*pre(-1, 7);\n    p += 10.*pre(-1, 9);\n    p += 1.*pre(0, -10);\n    p += 100.*pre(0, -8);\n    p += 2025.*pre(0, -6);\n    p += 14400.*pre(0, -4);\n    p += 44100.*pre(0, -2);\n    p += 63504.*pre(0, 0);\n    p += 44100.*pre(0, 2);\n    p += 14400.*pre(0, 4);\n    p += 2025.*pre(0, 6);\n    p += 100.*pre(0, 8);\n    p += 1.*pre(0, 10);\n    p += 10.*pre(1, -9);\n    p += 450.*pre(1, -7);\n    p += 5400.*pre(1, -5);\n    p += 25200.*pre(1, -3);\n    p += 52920.*pre(1, -1);\n    p += 52920.*pre(1, 1);\n    p += 25200.*pre(1, 3);\n    p += 5400.*pre(1, 5);\n    p += 450.*pre(1, 7);\n    p += 10.*pre(1, 9);\n    p += 45.*pre(2, -8);\n    p += 1200.*pre(2, -6);\n    p += 9450.*pre(2, -4);\n    p += 30240.*pre(2, -2);\n    p += 44100.*pre(2, 0);\n    p += 30240.*pre(2, 2);\n    p += 9450.*pre(2, 4);\n    p += 1200.*pre(2, 6);\n    p += 45.*pre(2, 8);\n    p += 120.*pre(3, -7);\n    p += 2100.*pre(3, -5);\n    p += 11340.*pre(3, -3);\n    p += 25200.*pre(3, -1);\n    p += 25200.*pre(3, 1);\n    p += 11340.*pre(3, 3);\n    p += 2100.*pre(3, 5);\n    p += 120.*pre(3, 7);\n    p += 210.*pre(4, -6);\n    p += 2520.*pre(4, -4);\n    p += 9450.*pre(4, -2);\n    p += 14400.*pre(4, 0);\n    p += 9450.*pre(4, 2);\n    p += 2520.*pre(4, 4);\n    p += 210.*pre(4, 6);\n    p += 252.*pre(5, -5);\n    p += 2100.*pre(5, -3);\n    p += 5400.*pre(5, -1);\n    p += 5400.*pre(5, 1);\n    p += 2100.*pre(5, 3);\n    p += 252.*pre(5, 5);\n    p += 210.*pre(6, -4);\n    p += 1200.*pre(6, -2);\n    p += 2025.*pre(6, 0);\n    p += 1200.*pre(6, 2);\n    p += 210.*pre(6, 4);\n    p += 120.*pre(7, -3);\n    p += 450.*pre(7, -1);\n    p += 450.*pre(7, 1);\n    p += 120.*pre(7, 3);\n    p += 45.*pre(8, -2);\n    p += 100.*pre(8, 0);\n    p += 45.*pre(8, 2);\n    p += 10.*pre(9, -1);\n    p += 10.*pre(9, 1);\n    p += 1.*pre(10, 0);\n    return  p / 1048576.;\n}\n\nfloat sceneIntersection(in vec3 ro,in vec3 rd, out vec3 inter, out vec3 normal, out vec3 color, in float far)\n{\n    float d = far;\n    inter = vec3(0);\n    normal = vec3(0);\n    color = vec3(0);\n\n\n   \t// Duck\n    vec2 p = duckPosition(iFrame, iResolution.x / iResolution.y);\n    vec2 op = duckPosition(iFrame + 1, iResolution.x / iResolution.y);\n    vec2 dir = normalize(p - op);\n    vec3 y = vec3(0, 1, 0);\n    vec3 z = vec3(-dir.x, 0, -dir.y);\n    vec3 x = cross(z, y);\n\n    mat4 mr = mat4(\n    x.x,\t\ty.x,\t\tz.x,         0,\n    x.y,\t\ty.y,\t\tz.y,         0,\n    x.z,\t\ty.z,\t\tz.z,         0,\n    0,\t        0,\t        0,           1.0 );\n\n    mat4 mt = mat4(\n    1.0,\t\t0.0,\t\t0.0,         0.0,\n    0.0,\t\t1.0,\t\t0.0,         0.0,\n    0.0,\t\t0.0,\t\t1.0,         0.0,\n    -p.x,\t0,\t-p.y,     1.0 );\n\n    mat4 tr= mr * mt;\n\n    float t = 0.0;\n    vec3 tp;\n    for( int j = 0; j < 32; j++ )\n    {\n        vec3\tp = ro + t*rd;\n        tp = vec3(tr * vec4(p, 1.0));\n        float\th = duckMap(tp);\n        if( abs(h) < 0.001)\n        {\n            break;\n        }\n        t += h;\n    }\n    if(t < d)\n    {\n        d = t;\n        normal = (inverse(tr) * vec4(calcNormalDuck(tp), 0)).xyz;\n        color = duckMapColor(tp).yzw;\n    }\n    \n    // Plane\n    \n\treturn d;\n}\n\nfloat sampleFog(in vec3 pos)\n{\n    vec2 uv = pos.xz;\n    uv.x *= iResolution.y / iResolution.x;\n    uv = uv * 0.5 + 0.5;\n    if(max(uv.x, uv.y) > 1. || min(uv.x, uv.y) < 0.)\n    {\n        return 0.;\n    }\n    return texture(iChannel0, uv).z;\n}\n\nfloat height(in float y)\n{\n    y = clamp(y / fogHeigth, 0.0, 1.0);\n    return (1.0 - sin(acos(abs(y) * 2.0 - 1.0))) * fogHeigth;\n}\n\nfloat getWaterHeight(in vec3 pos)\n{\n    vec2 uv = pos.xz;\n    uv.x *= iResolution.y / iResolution.x;\n    uv = uv * 0.5 + 0.5;\n    uv = clamp(uv, 0.0, 1.0);\n    return texture(iChannel0, uv).w * waterScale;\n}\n\nvec3 getWaterNormal(in vec3 p)\n{\n    vec2 d = 1.0 / iResolution.xy;\n    float hMid = getWaterHeight(p);\n    float hRight = getWaterHeight(p + vec3(d.x, 0, 0));\n    float hTop = getWaterHeight(p + vec3(0, 0, d.y));\n    return normalize(cross(vec3(0, hTop - hMid, d.y), vec3(d.x, hRight - hMid, 0)));\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 blue = smoothstep(.2, 1., rd.y) * vec3(0, 0, .5);\n    vec3 highlight = vec3(pow(clamp(dot(rd, normalize(vec3(1, 1, 0))), 0., 1.), 100.) * 2.0)\n                   + vec3(pow(clamp(dot(rd, normalize(vec3(-0.5, 1, 0.5))), 0., 1.), 100.) * 2.0);\n    return blue + highlight;\n}\n\n// Caustic inspired by Dave Hoskins https://www.shadertoy.com/view/MdKXDm\n\nfloat F(inout vec3 key, in float R)\n{\n    key *=mat3(-2,-1,2, 3,-2,1, 1,2,2) * R;\n    return length(.5-fract(key));\n}\n\nfloat caustic(vec3 p)\n{\n    vec3 key = vec3(p * 2.0) + iTime * 0.2;\n    return pow(min(min(F(key,.5),F(key,.4)),F(key,.3)), 7.)*25.0;\n}\n\nvec3 Render(in vec3 ro,in vec3 rd,in float far, float fudge)\n{\n    vec3  inter;\n    vec3  normal;\n    vec3  baseColor; \n    float mint = sceneIntersection(ro, rd, inter, normal, baseColor, far);\n    \n    vec3 color = mint != far ? baseColor * (0.2 + 0.8 * max(0.0, dot(normal, normalize(ro * mint - lightPos)))) +  getSkyColor(reflect(rd, normal)) : vec3(0.25);\n        \n    vec3 n;\n    float aspecRatio = iResolution.x / iResolution.y;  \n\n    vec2 ret = boxIntersection(ro, rd, vec3(aspecRatio, waterHeight * 2.0, 1), vec3(0, 0, 0), n);\n    if(ret.x > 0.0 && ret.x < mint)\n    {\n        vec3 pi = ro + rd * ret.x;\n        float wt = ret.x;\n        float h = getWaterHeight(pi);\n        vec3 waterNormal;\n        if(pi.y < h)\n        {\n            waterNormal = n;\n        }\n        else\n        {\n            for (int i = 0; i < 80; i++)\n            {\n                vec3 p = ro + rd * wt;\n                float h = p.y - getWaterHeight(p);\n                if (h < 0.0002 || wt > min(mint, ret.y))\n                    break;\n                wt += h * 0.5;\n            }\n            waterNormal = getWaterNormal(ro + rd * wt);\n        }\n        \n        if(wt < ret.y && wt < mint)\n        {\n            // refract\n            vec3 enter = ro + rd * wt;\n            vec3 refr = -refract(rd, waterNormal, 0.8);\n            vec3 refn;\n            vec2 ret2 = boxIntersection(enter, refr, vec3(aspecRatio, waterHeight * 2.0, 1), vec3(0, 0, 0), refn);\n            vec3 exit = enter + refr * ret2.x;\n            float dist = distance(enter, exit);\n            color = vec3(1) * (0.2 + 0.8 * max(0.0, dot(-refn, normalize(ro * dist - lightPos))));\n            color += caustic(exit + getWaterNormal(exit)) * 0.7;\n            color = applyFog( color, vec3(0, 0, 1), dist * 3.0);\n            color += getSkyColor(reflect(rd, waterNormal));\n        }  \n    }\n    \n    // Compute Fog\n\tfloat t;\n    if(floorIntersect(ro, rd, fogHeigth, t))\n    {\n        vec3 curPos = ro + rd * t;\n        vec3 fogStep = (fogHeigth / float(nbSlice)) * rd / abs(rd.y);\n        curPos += fudge * fogStep;  // fix banding issue\n        float stepLen = length(fogStep);\n        float curDensity = 0.;\n        float transmittance = 1.;\n        float lightEnergy = 0.;\n        for(int i = 0; i < nbSlice; i++)\n        {\n            if( dot(curPos - ro, rd) > mint)\n                break;\n            float curHeigth = sampleFog(curPos) * fogHeigth;\n            float curSample = min(max(0., curHeigth - height(curPos.y)), fogSlice) * stepLen / fogSlice;\n            if(curSample > 0.001)\n            {\n                vec3 lightDir = normalize(lightPos - curPos);\n                vec3 shadowStep = (fogHeigth / float(nbSlice)) * lightDir / lightDir.y;\n                float lightDist2 = dist2(lightPos - curPos);\n                vec3 shadowPos = curPos + shadowStep * fudge;\n                float shadowDist = 0.;\n\n                for (int j = 0; j < nbSlice; j++)\n                {\n                    shadowPos += shadowStep;\n                    float curHeight = sampleFog(shadowPos) * fogHeigth;\n             \t\tshadowDist += min(max(0., curHeight - height(shadowPos.y)), fogSlice) * length(shadowStep) / fogSlice;\n               }\n\n                \n            \tfloat shadowFactor = exp(-shadowDist * shadowDensity);\n                curDensity = curSample * fogDensity;\n                float absorbedlight =  shadowFactor * (1. * curDensity);\n                lightEnergy += absorbedlight * transmittance;\n                transmittance *= 1. - curDensity;\t\n            }\n            curPos+= fogStep;       \n        }\n        color = mix(color, vec3(lightEnergy * 1.8), 1. - transmittance);\n    }  \n    \n    \n    return color;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera       \n    float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + radians(90.);\n    float phi\t= - radians(45.);\n    vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n    vec3 ta = vec3( 0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta );\n\n    vec3 rd =  ca*normalize(vec3(p,1.5));        \n\n    vec3 col = Render(ro ,rd, 6., hash12(fragCoord + iTime));\n\n\n    tot += col;\n            \n\ttot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n    \n    float pr = getPre() - div(0,0);\n\tfragColor = vec4( tot, pr );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}