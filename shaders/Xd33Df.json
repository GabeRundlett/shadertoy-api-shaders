{
    "Shader": {
        "info": {
            "date": "1452407216",
            "description": "A simple erosion process. Over time, water is added and removed. Arrow keys to move. Still some bugs and rendered with the equivalent of a room full of monkeys with typewriters. Comment out the first line in Image shader for more monkeys.",
            "flags": 48,
            "hasliked": 0,
            "id": "Xd33Df",
            "likes": 18,
            "name": "Erosion Compute",
            "published": 3,
            "tags": [
                "erosion"
            ],
            "usePreview": 0,
            "username": "Alway_PanicButton",
            "viewed": 1582
        },
        "renderpass": [
            {
                "code": "#define FASTER_RENDER\n\nvoid rot2( inout vec2 r, float theta )\n{\n    float co = cos(theta);\n    float si = sin(theta);\n    r = vec2( r.x * co + r.y * si,\n             -r.x * si + r.y * co );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = vec4( 0., 0., 0., 0. );\n    \n    vec3 p = vec3( 0.5, -0.20, 3.2 );\n    p.xy = texture( iChannel1, vec2( 258.5, 0.5 ) / iResolution.xy ).xy;\n    vec3 d = normalize( vec3( uv.x - .5, 1.0, uv.y - 1.5 ) );\n    \n    if( iMouse.w > 0.)\n    {\n    rot2( d.yz, iMouse.y / iResolution.y * 1.-.5 );\n    rot2( d.yx, iMouse.x / iResolution.x * 1.-.5 );\n    }\n    \n    vec3 w = vec3(0.);\n    if( iTime > 0.25 )\n    {\n#ifndef FASTER_RENDER\n    for( int i = 0; i < 512; i++ )\n#else\n    for( int i = 0; i < 128; i++ )\n#endif\n    {\n        vec2 p256 = p.xy * 256.;\n        if( p256.x < 0. || p256.y < 0. || p256.x > 255. || p256.y > 249. )\n            p256.xy = vec2(5.);\n        vec4 t = texture( iChannel1, p256 / iResolution.xy );\n        if( w.x == 0. && t.x + t.y + t.z > p.z*2. && t.z > 0.001 )\n        {\n            c.b += 10. * t.z;\n            c.rgb += t.w / (t.z + 0.1);  // light-blue-white for sediment-rich water\n            float sum = t.x + t.y + t.z;\n        \tvec4 tx = texture( iChannel1, p256 / iResolution.xy + vec2( 1. / iResolution.x, 0. ) );\n        \tvec4 ty = texture( iChannel1, p256 / iResolution.xy + vec2( 0., 1. / iResolution.y ) );\n            vec3 norm = normalize( vec3(tx.x + tx.y + tx.z - sum, ty.x + ty.y + ty.z - sum, 1. / iResolution.x) );\n            c += abs( dot( norm, vec3( 0., 0., 1. ) ) ) * .2 * (t.z < .01 ? t.z*100. : 1.);\n            c.rgb += min(1., t.z * 100.) * abs(length(texture( iChannel0, p256 / iResolution.xy ).xy)*4.) * 50.;\n            //vec2 Vel = texture( iChannel0, (p256 ) / iResolution.xy ).xy;\n            //float d = texture( iChannel1, (p256 ) / iResolution.xy ).y;\n            //c.rgb *= 0.5+texture( iChannel2, mod((Vel/max(d,0.001) * iTime*0.1 + 0.01*mod(p256, 1.0)), 0.01)).rgb;\n            \n            w = p;\n        }\n        if( t.x + t.y > p.z*2.0 )\n        {\n            float sum = t.x + t.y;\n        \tvec4 tx = texture( iChannel1, p256 / iResolution.xy + vec2( 1. / iResolution.x, 0. ) );\n        \tvec4 ty = texture( iChannel1, p256 / iResolution.xy + vec2( 0., 1. / iResolution.y ) );\n            vec3 norm = normalize( vec3(tx.x + tx.y - sum, ty.x + ty.y + - sum, 20. / iResolution.x) );\n            float l = abs( dot( norm, vec3( 0., 0., 1. ) ) );\n            if( t.y > 0.01 )\n            {\n                if( w.x == 0. )\n                \tc.rg += vec2(0.5,0.4) * l * (0.95+0.1*texture( iChannel2, p256*0.1 ).r);\n                else\n                    c.rg += vec2(0.5,0.4) / (max(length( w - p ) * 35., 1.0)) * l;\n            }\n            else\n            {\n                if( w.x == 0. )\n                \tc.rgb += 0.4 * l * (0.95+0.1*texture( iChannel2, p256*0.1 ).r);\n                else\n                    c.rgb += 0.4 / (max(length( w - p ) * 35., 1.0 )) * l;\n            }\n            w = p;\n            break;\n        }\n        // a heuristic to encourage better use of render time.\n        float convergeFaster = ( p.z*2.0 - (t.x + t.y + t.w) > 0.1 ) ? 2. : 0.5;\n#ifndef FASTER_RENDER\n        p += d * 0.0025 * convergeFaster;\n#else\n        p += d * 0.0075 * convergeFaster;\n#endif\n    }\n    }\n    if( w.x == 0. )\n    {\n    \tif( mod(iTime, 30.) < 5. )\n        {\n            c = vec4( 0.3, 0.3, 0.3, 1.0 );\n        }\n    \telse if( iTime > 20. && mod(iTime, 30.) > 15. && mod(iTime, 30.) < 22.)\n        {\n            c = vec4( 0.6, 0.6, 0.8, 1. );\n        }\n        else\n        {\n            c = vec4( 0.4, 0.4, 0.9, 1. );\n        }\n    }\n    \n\tfragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// erode & deposit\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tiles = 256.;\n    if( (fragCoord.x > tiles || fragCoord.y > tiles) && !( fragCoord.x > 257.9 && fragCoord.x < 258.9 && fragCoord.y < 0.9 ))\n        discard;\n    \n    vec2 i = fragCoord / iResolution.xy;\n    \n    // h0, h1, wh, d\n    vec4 t = texture( iChannel0, i );\n    \n    if( fragCoord.x > 257.9 && fragCoord.x < 258.9 && fragCoord.y < 0.9 )\n    {\n        if( t.x <= .0 )\n        {\n            fragColor.rgb = vec3(0.5, -0.40, 1.3);\n            return;\n        }\n        fragColor = texture( iChannel0, fragCoord.xy/iResolution.xy ).rgba;\n        return;\n    }\n        \n    // Initialize terrain.\n    if( t.x <= 0. )\n    {\n        // Previously had problems with the images asynchronously loading in after initializing ran.\n        // This ensures both have been loaded in before we use them to initialize so we don't get a blank map.\n    \tfloat TestForLoadComplete = texture( iChannel2, i ).x * texture( iChannel3, i ).x;\n        if( TestForLoadComplete != 0. )\n        {\n        \tfragColor = vec4(max(0., texture( iChannel2, i ).x*0.5 + (0.8*i.y)), texture( iChannel3, i ).x*.5, 0.01, 0.);\n        \tfragColor.r += 5.;\n        \tfragColor.g = max(fragColor.g - 0.0, 0. );\n        }\n        else\n            fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n    if( fragCoord.y - 2. < 0. || fragCoord.y > 250. )\n    {\n        fragColor = vec4( 0., 0., 0., 0. );\n        return;\n    }\n        \n        \n    // vx, vy\n    vec2 v = texture( iChannel1, i ).xy;\n    v.x += texture( iChannel1, i + vec2( -1. / iResolution.x, 0. ) ).x;\n    v.y += texture( iChannel1, i + vec2( 0., -1. / iResolution.y ) ).y;\n    float s = (abs(v.x) + abs(v.y));\n    s = s - t.w * 1.5;\n    //deposit\n    {\n        float d = t.w * .01;\n        t.y += d;\n        t.z -= d;\n        t.w -= d;\n    }\n    if( t.y > 0.00001 )\t// erode l1\n    {\n        s = min( t.y, s * 0.002 );\n        t.y -= s;\n        t.z += s;\n        t.w += s;\n    }\n    else\t// erode l2\n    {\n        s = min( t.x, s * 0.0002 );\n        t.x -= s;\n        t.z += s+t.y;\n        t.w += s+t.y;\n        t.y = 0.;\n    }\n    \n    \n    if( i.y - 3. / iResolution.y < 0. )\n    {\n        t.zw = vec2(0.);\n    }\n    \n    fragColor = t;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// update flow volumes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tiles = 256.;\n    if( fragCoord.x > tiles || fragCoord.y > tiles )\n        discard;\n        \n    vec2 i = fragCoord / iResolution.xy;\n        \n    // h0, h1, wh, d\n    // vx, vy\n    \n    \n    // Initialize flow.\n    vec4 t = texture( iChannel0, i );\n    if( t.x <= 0. || fragCoord.x > tiles - 1. || fragCoord.y > tiles - 1. )\n    {\n    \tfragColor = vec4(0., 0., 0., 0.);\n        return;\n    }\n    vec2 v = texture( iChannel1, i ).zw;\n        \n    float sum = t.x + t.y + t.z;\n    \n    for( int id = 0; id < 2; id++ )\n    {\n        vec4 o;\n        if( id != 1 )\n            o = texture( iChannel0, i + vec2( 1. / iResolution.x, 0. ) );\n        else\n            o = texture( iChannel0, i + vec2( 0., 1. / iResolution.y ) );\n        float diff = sum - (o.x + o.y + o.z);\n        if( diff > 0. )\n            diff = min( diff, t.z );\n        else\n            diff = max( diff, -o.z );\n        if( id != 1 )\n        {\n            v.x += diff * 0.0025;\n        \tif( v.x > 0. )\n        \t    v.x = min( v.x, t.z*.24 );\n        \telse\n        \t    v.x = max( v.x, -o.z*.24 );\n        }\n        else\n        {\n            v.y += diff * 0.0025;\n        \tif( v.y > 0. )\n        \t    v.y = min( v.y, t.z*.24 );\n        \telse\n        \t    v.y = max( v.y, -o.z*.24 );\n        }\n    }\n    fragColor = vec4(v.xy*.998,0.,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// transport fluid and disolved material\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tiles = 256.;\n    if( fragCoord.x > tiles || fragCoord.y > tiles )\n        discard;\n        \n    vec2 i = fragCoord / iResolution.xy;\n    \n    \n    // h0, h1, wh, d\n    // vx, vy\n    vec4 t = texture( iChannel0, i );\n    vec2 to = t.zw;\n    vec2 vo = texture( iChannel1, i ).xy;\n    vec2 v = vo;\n    \n    vec2 inflow = vec2( 0. );\n    \n    if( v.x > 0. )\n    {\n        float p = v.x / max(t.z, 0.00001);\n        inflow -= abs(p * t.zw);\n    }\n    else\n    {\n        vec4 ot = texture( iChannel0, i + vec2( 1. / iResolution.x, 0. ) );\n        float p = v.x / max(ot.z, 0.00001);\n        inflow += abs(p * ot.zw);\n    }\n    if( v.y > 0. )\n    {\n        float p = v.y / max(t.z, 0.00001);\n        inflow -= abs(p * t.zw);\n    }\n    else\n    {\n        vec4 ot = texture( iChannel0, i + vec2( 0., 1. / iResolution.y ) );\n        float p = v.y / max(ot.z, 0.00001);\n        inflow += abs(p * ot.zw);\n    }\n    \n    if( i.x - 1. / iResolution.x >= 0. )\n    {\n    v = texture( iChannel1, i - vec2( 1. / iResolution.x, 0. ) ).xy;\n    if( v.x < 0. )\n    {\n        float p = v.x / max(t.z, 0.00001);\n        inflow -= abs(p * t.zw);\n    }\n    else\n    {\n        vec4 ot = texture( iChannel0, i - vec2( 1. / iResolution.x, 0. ) );\n        float p = v.x / max(ot.z, 0.00001);\n        inflow += abs(p * ot.zw);\n    }\n    }\n    \n    if( i.y - 1. / iResolution.y >= 0. )\n    {\n    v = texture( iChannel1, i - vec2( 0., 1. / iResolution.y ) ).xy;\n    if( v.y < 0. )\n    {\n        float p = v.y / max(t.z, 0.00001);\n        inflow -= abs(p * t.zw);\n    }\n    else\n    {\n        vec4 ot = texture( iChannel0, i - vec2( 0., 1. / iResolution.y ) );\n        float p = v.y / max(ot.z, 0.00001);\n        inflow += abs(p * ot.zw);\n    }\n    }\n    \n    to.xy += inflow.xy;\n    fragColor = vec4(to.xy, vo.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// reduce parts a,c->d for render and next cycle\n// and some landslides too so we get smoother erosion\n\n#define SLIP_FACTOR 0.01\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tiles = 256.;\n    if( (fragCoord.x > tiles || fragCoord.y > tiles) && !( fragCoord.x > 257.9 && fragCoord.x < 258.9 && fragCoord.y < 0.9 ) )\n        discard;\n    \n    if( fragCoord.x > 257.9 && fragCoord.x < 258.9 && fragCoord.y < 0.9 )\n    {\n        \n        vec3 value = texture( iChannel0, fragCoord.xy / iResolution.xy ).rgb;\n        if( value.x == 0.0 || iTime < 0.25)\n        {\n            fragColor.rgb = vec3(0.5, -0.30, 6.3);\n            return;\n        }\n        else\n        {\n        \tfloat key = texture( iChannel3, vec2( KEY_DOWN, 0.25 ) ).x;\n        \tif( key > .5 )\n        \t    value.y -= 0.004;\n        \tkey = texture( iChannel3, vec2( KEY_UP, 0.25 ) ).x;\n        \tif( key > .5 )\n        \t    value.y += 0.004;\n        \tkey = texture( iChannel3, vec2( KEY_RIGHT, 0.25 ) ).x;\n        \tif( key > .5 )\n        \t    value.x += 0.004;\n        \tkey = texture( iChannel3, vec2( KEY_LEFT, 0.25 ) ).x;\n        \tif( key > .5 )\n        \t    value.x -= 0.004;\n        \tfragColor = vec4(value, 1.0);\n        \treturn;\n        }\n    }\n        \n    vec2 i = fragCoord / iResolution.xy;\n        \n    // h0, h1\n    // wh, d\n    vec2 b = texture(iChannel0, i).xy;\n    vec2 c = texture(iChannel1, i).xy;\n    \n    // when a max slope is exceeded by terrain layer 1, slide some material down it\n    float s1 = texture(iChannel2,i).r * SLIP_FACTOR + SLIP_FACTOR;\n    vec2 bo = b;\n    {\n    \tfor( float j = 0.; j < 1.9; j+=1. )\n    \t{\n    \t    float si = mod(j, 2.)*2.-1.;\n    \t\tvec2 bn = texture( iChannel0, min(vec2((tiles-1.)/iResolution.x,1.),max(vec2(0.,2./iResolution.x),i+si*vec2(1./iResolution.x, 0. ))) ).xy;\n    \t\tfloat s2 = texture(iChannel2,min(vec2((tiles-1.)/iResolution.x,1.),max(vec2(0.,2./iResolution.x),i+si*vec2(1./iResolution.x, 0. )))).r * SLIP_FACTOR + SLIP_FACTOR;\n    \t\tfloat diff = (bn.x + bn.y) - (b.x + b.y);\n    \t\tif( abs(diff) > s1+s2 )\n    \t\t{\n    \t        si = ((diff > 0.) ? 1. : -1.);\n    \t\t    float a = ((diff > 0.) ? bn.y : b.y);\n    \t\t    bo.y += si * min( a * .25, abs(diff * .25) );\n    \t\t}\n    \t}\n    \tfor( float j = 0.; j < 1.9; j+=1. )\n    \t{\n    \t    float si = mod(j, 2.)*2.-1.;\n    \t\tvec2 bn = texture( iChannel0, min(vec2(1.,(tiles-1.)/iResolution.y),max(vec2(0.,2./iResolution.y),i+si*vec2(0., 1./iResolution.y ))) ).xy;\n    \t\tfloat s2 = texture(iChannel2,min(vec2(1.,(tiles-1.)/iResolution.y),max(vec2(0.,2./iResolution.y),i+si*vec2(0., 1./iResolution.y )))).r * SLIP_FACTOR + SLIP_FACTOR;\n    \t\tfloat diff = (bn.x + bn.y) - (b.x + b.y);\n    \t\tif( abs(diff) > s1+s2 )\n    \t\t{\n    \t        si = ((diff > 0.) ? 1. : -1.);\n    \t\t    float a = ((diff > 0.) ? bn.y : b.y);\n    \t\t    bo.y += si * min( a * .25, abs(diff * .25) );\n    \t\t}\n    \t}\n    }\n    \n    // rain\n    if( mod(iTime, 30.) < 5. )\n    {\n    \tc.x += 0.000010;\n    }\n    else if( iTime > 20. && mod(iTime, 30.) > 15. && mod(iTime, 30.) < 22.)\n    {\n        // evaporate a bit\n        if( c.x > 0.002 && c.x > c.y + 0.00003 )\n        {\n            c.x -= 0.000005;\n        }\n    }\n    fragColor = vec4(bo,c);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}