{
    "Shader": {
        "info": {
            "date": "1588900966",
            "description": "stolen a lot from [url]https://www.shadertoy.com/view/MdSBRc[/url].\na voxel grid with 5 tetrahedra in each voxel.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdsBzs",
            "likes": 3,
            "name": "tetrahedra tunnels",
            "published": 3,
            "tags": [
                "3d",
                "marchingtetrahedra"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 428
        },
        "renderpass": [
            {
                "code": "#define FAR 100.0\n\n#define antialiasing 16\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n#define sqr(a) (a*a)\n#define dot2(a) dot(a,a)\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 pln, float d) {\n    \n    float a = dot(ro,pln)-d;\n    float b = dot(rd,pln);\n    \n    if (a*b < 0.0 && b < 0.0) {\n        return -a/b;\n    }\n    \n    return FAR;\n}\n\nvec2 path(float time) {\n    time *= 0.1;\n    //random sine waves that move the camera\n    vec2 a = vec2(sin(time),cos(time*3.0));\n    a += vec2(sin(time*0.1)*5.0,cos(time*1.0)*3.0);\n    a *= sin(time*0.05);\n    a *= 4.0;\n    \n    return a;\n}\n\nfloat isoMap(vec3 p, vec3 ro){\n    \n    p += 0.001;\n    \n    float l;\n    \n    vec2 path1 = p.xy;\n    vec2 path2 = path(p.z)-p.xy;\n    \n    float tunnel = 7.0-smin(length(path1),length(path2), 3.0);\n    \n    l = tunnel;\n    \n    vec3 p2 = p*0.2;\n    \n    p2.x += iTime*0.1;\n    p.z += 2.0;\n    \n\tp2 = cos(p2*0.315*1.25 + sin(p2.zxy)); // 3D sinusoidal mutation.\n    \n    float n = dot(p2,vec3(1)); // Spherize. The result is some mutated, spherical blob-like shapes.\n    \n    l = smax(l,n-1.5, 3.0);\n    \n    return l;\n    \n}\n\n// Interpolating along the edge connecting vertices v1 and v2 with respect to the isovalue.\nvec3 inter(in vec3 p1, in vec3 p2, float v1, float v2){\n    // The interpolated point will fall somewhere between the vertex points p1 and p2.\n    // Obviously if the isovalue is closer to p1, then the interpolated point will be\n    // closer to p1, and vice versa.\n    return mix(p2, p1, v2/(v2 - v1));\n}\n\nfloat ray(vec3 ro, vec3 rd, inout vec3 normal, float maxdist)\n{\n    \n    vec3 fro = floor(ro);\n    vec3 lro = ro-fro;\n    vec3 srd = sign(rd);\n    vec3 ird = srd/rd;\n    float d = 0.0;\n    vec3 dists = abs((srd*0.5+0.5)-lro)*ird;\n    vec3 n = vec3(0);\n    \n    mat4x3 tetraf = mat4x3(\n        vec3( 1, 1, 1),\n        vec3(-1, 1,-1),\n        vec3(-1,-1, 1),\n        vec3( 1,-1,-1));\n    \n    vec3 p = lro-0.5;\n    vec3 flip = 1.0-mod(fro,2.0)*2.0;\n    \n    vec4 tetra1 = vec4(\n        dot(rd,tetraf[0]),\n        dot(rd,tetraf[1]),\n        dot(rd,tetraf[2]),\n        dot(rd,tetraf[3]));\n    \n    vec4 tetra3 = 1.0/max(abs(tetra1),0.001);\n    \n    vec4 tetra2 = vec4(\n        dot(ro,tetraf[0]),\n        dot(ro,tetraf[1]),\n        dot(ro,tetraf[2]),\n        dot(ro,tetraf[3]));\n    \n    vec4 tetra = abs((sign(tetra1)+1.0)-mod(tetra2,2.0))*tetra3;\n    \n    vec4 tetrac = step(0.5,vec4(\n        dot(p,tetraf[0]*flip),\n        dot(p,tetraf[1]*flip),\n        dot(p,tetraf[2]*flip),\n        dot(p,tetraf[3]*flip)));\n    \n    vec4 a = (1.0-2.0*tetrac);\n\n    mat4x3 sp = 0.5-0.5*mat4x3(\n        tetraf[0]*flip*a.x,\n        tetraf[1]*flip*a.y,\n        tetraf[2]*flip*a.z,\n        tetraf[3]*flip*a.w);\n    \n    vec4 ps = vec4(\n        isoMap(fro+sp[0], ro),\n        isoMap(fro+sp[1], ro),\n        isoMap(fro+sp[2], ro),\n        isoMap(fro+sp[3], ro));\n    \n    int i2 = 0;\n    \n    for (int i = 0; i < 400; i++)\n    {\n        \n        int index = int(dot(step(ps,vec4(0.0)),vec4(1,2,4,8)));\n            /*(ps[0] < 0.0 ? 1 : 0)\n             +(ps[1] < 0.0 ? 2 : 0)\n             +(ps[2] < 0.0 ? 4 : 0)\n             +(ps[3] < 0.0 ? 8 : 0);*/\n        \n        vec3 mask;\n        if (dists.x < dists.y)\n            if (dists.x < dists.z)\n                mask = vec3(1,0,0);\n            else\n                mask = vec3(0,0,1);\n        else\n            if (dists.y < dists.z)\n                mask = vec3(0,1,0);\n            else\n                mask = vec3(0,0,1);\n        \n        \n        vec4 maskt;\n        if (tetra.x < tetra.y)\n            if (tetra.x < tetra.z)\n                if (tetra.x < tetra.w)\n                    maskt = vec4(1,0,0,0);\n                else\n                    maskt = vec4(0,0,0,1);\n            else\n                if (tetra.z < tetra.w)\n                    maskt = vec4(0,0,1,0);\n                else\n                    maskt = vec4(0,0,0,1);\n        else\n            if (tetra.y < tetra.z)\n                if (tetra.y < tetra.w)\n                    maskt = vec4(0,1,0,0);\n                else\n                    maskt = vec4(0,0,0,1);\n            else\n                if (tetra.z < tetra.w)\n                    maskt = vec4(0,0,1,0);\n                else\n                    maskt = vec4(0,0,0,1);\n        \n        float lv = dot(dists,mask);\n        float lt = dot(maskt,tetra);\n        \n        float l = min(lv,lt);\n        \n        if (index != 0)\n        {\n            if (index != 15)\n            {\n                ivec3 v1, v2;\n                float f = -1.0;\n                if (index > 7) {\n                    f = -f;\n                    index = 15-index;\n                }\n                \n                if(index == 1)\n                {\n                    v1 = ivec3(0,0,0);\n                    v2 = ivec3(1,2,3);\n                }    \n                // Vertex 1 only is inside or outside.\n                else if(index == 2)\n                {\n                    v1 = ivec3(1,1,1);\n                    v2 = ivec3(0,3,2);\n                }\n                // Vertex 2 only is inside or outside.\n                else if(index == 4)\n                {\n                    v1 = ivec3(2,2,2);\n                    v2 = ivec3(0,1,3);\n                } \n                // Vertex 3 only is inside or outside.\n                else if(index == 7)\n                {\n                    v1 = ivec3(3,3,3);\n                    v2 = ivec3(0,1,2);\n                }\n                // Vertices 0 and 1 are inside or vertices 2 and 3 are inside.\n                else if(index == 3)\n                {\n                    v1 = ivec3(0,0,1);\n                    v2 = ivec3(2,3,3);\n                }\n                // Vertices 0 and 2 are inside or vertices 1 and 3 are inside.   \n                else if(index == 5)\n                {\n                    v1 = ivec3(0,2,0);\n                    v2 = ivec3(1,3,3);\n                } \n                // Vertices 1 and 2 are inside or vertices 0 and 3 are inside.\n                else if(index == 6)\n                {\n                    v1 = ivec3(0,1,2);\n                    v2 = ivec3(1,3,3);\n                }\n                \n        \t\tmat3 v = mat3(\n                    inter(sp[v1.x], sp[v2.x], ps[v1.x], ps[v2.x]),\n                    inter(sp[v1.y], sp[v2.y], ps[v1.y], ps[v2.y]),\n                    inter(sp[v1.z], sp[v2.z], ps[v1.z], ps[v2.z]));\n                \n                vec3 n = cross(v[1]-v[0],v[2]-v[0])*f*(+dot(tetrac,vec4(1))*2.0-1.0)*flip.x*flip.y*flip.z;\n                \n                float pln = plane(lro-v[0],rd,n,0.0);\n                \n                if (pln < l)\n                {\n                    normal = n;\n                    d += pln;\n                    return d;\n                }\n            }\n        }\n          \n        d += l;\n        lro += rd*l;\n        \n        dists -= l;\n        tetra -= l;\n        \n        int j;\n        \n        if (lv < lt)\n        {\n            normal = -mask*sign(rd);\n            \n            dists = dists+mask*ird;\n            lro -= srd*mask;\n            fro += srd*mask;\n            \n            vec3 p = lro-0.5;\n            \n            flip *= 1.0-mask*2.0;\n            \n            for (int j = 0; j < 4; j++)\n            {\n            \tsp[j] = abs(mask-sp[j]);\n            }\n            \n            j = int(abs(dot(mask,vec3(-7,-5,2))+dot(tetrac,vec4(0,1,2,3))))%4;\n            // mask.x  mask.y  mask.z\n            //  w 3     y 1     z 2   tetrac.x\n            //  z 2     x 0     w 3   tetrac.y\n            //  y 1     w 3     x 0   tetrac.z\n            //  x 0     z 2     y 1   tetrac.w\n        }\n        else\n        {\n            vec4 mask = maskt;\n            \n            if (flip.x > 0.0) {\n                mask = mask.wzyx;\n            }\n            \n            if (flip.y > 0.0) {\n                mask = mask.yxwz;\n            }\n            \n            if (flip.z > 0.0) {\n                mask = mask.zwxy;\n            }\n            \n            tetra += tetra3*maskt*2.0;\n            tetrac = abs(tetrac-mask);\n            \n            \n        \tj = int(dot(mask,vec4(0,1,2,3)));\n            // maskt.x maskt.y maskt.z maskt.w\n            //   0       1       2       3\n            \n            sp[j] = 1.0-sp[j];\n        }\n        ps[j] = isoMap(fro+sp[j], ro);\n        \n        if (d > maxdist) return maxdist;\n    }\n    \n    return d;\n    \n    \n    /*vec4 dists = vec4(\n        plane(ro,rd,vec3( 1, 1, 1),1.0),\n        plane(ro,rd,vec3( 1,-1,-1),1.0),\n        plane(ro,rd,vec3(-1, 1,-1),1.0),\n        plane(ro,rd,vec3(-1,-1, 1),1.0));\n    \n    return vec4(min(min(min(dists.x,dists.y),dists.z),dists.w),0,0,0);*/\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.131, .130, .1973)\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//shading\nvec3 shade(vec3 p, vec3 d, vec3 n, float material, float num, float dist) {\n    vec3 color = vec3(1);\n    \n    //vec3 f = floor(p*0.01+sin(p.yzx)+sin(p.zxy));\n    //color = sin(f+sin(p))*(sin(p)*0.25+0.5)+0.5;\n    \n    vec3 light = vec3(0,sin(iTime)*4.0,iTime*4.0+8.0);\n    \n    vec3 ldir = light-p;\n    float llen = length(ldir);\n    ldir /= llen;\n    \n    float shadow = dot(ldir,n)*0.8;\n    shadow /= llen*llen*0.02+1.0;\n    \n    if (shadow > 0.0) {\n        vec3 nothing;\n        float l = ray(p+ldir*0.001,ldir, nothing, llen);\n        if (l < llen) shadow *= 0.0;\n    }\n    \n    shadow = max(shadow,0.02);\n    \n    color *= shadow;\n    float fog = max(4.0-dist/FAR*4.0,0.0);\n    color *= fog;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(path(iTime*4.0),iTime*4.0);\n    \n    vec3 rd = normalize(vec3(uv,1)+0.001);\n    \n    if (length(iMouse.xy) < 50.0) {\n        vec3 lookat = vec3(path(iTime*4.0+2.0),iTime*4.0+2.0);\n        vec3 forward = normalize(lookat-ro);\n        vec3 left = normalize(cross(vec3(path(iTime*4.0+1.0),0),forward));\n        vec3 up = cross(forward,left);\n        \n        rd = rd.x*left+rd.y*up+rd.z*forward;\n        \n    } else {\n        rd.zy *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n        rd.zx *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    int id = 3;\n    float tetranum;\n    vec3 cell;\n    vec3 nor;\n    float d = ray(ro,rd, nor, FAR);\n    nor = normalize(nor);\n    \n    // Output to screen\n    vec3 sun = normalize(vec3(1));\n    vec3 col = vec3(0);\n    if (d < FAR)\n    {\n        vec3 p = ro+rd*d;\n        \n        col = shade(p, rd, nor, cell.x+cell.y*0.348+cell.z*0.483, tetranum, d);\n    } else {\n        float sunl = max(dot(sun,rd),0.0);\n        sunl = pow(sunl,100.0);\n        \n        col = vec3(0);//mix(vec3(0.2,0.2,0.8),vec3(1.2,1.0,0.2),sunl);\n    }\n    \n    \n    col = clamp(col,0.0,1.0);\n    col = pow(col,vec3(1.0/2.2));\n    fragColor = vec4(sqrt(col),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}