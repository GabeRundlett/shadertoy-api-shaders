{
    "Shader": {
        "info": {
            "date": "1560899420",
            "description": "simple test of the mandelbrot set",
            "flags": 0,
            "hasliked": 0,
            "id": "wtSGWy",
            "likes": 0,
            "name": "Mandelbrot set test - 19/06/2019",
            "published": 3,
            "tags": [
                "mandelbrot"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 403
        },
        "renderpass": [
            {
                "code": "const int MAX_ITER = 500;\n\nvec3 BASE_COLOR = vec3(205.0,100.0, 128.0) / 255.0;\n\n\nstruct complexNumber\n{\n    float real;\n    float imaginary;\n};\n\ncomplexNumber multiplyComplex(complexNumber a, complexNumber b)\n{\n\t//(x + yi) * (u + vi) = (xu - yv) + (xv + yu)i\n    \n    return complexNumber\n        (\n        \ta.real*b.real - a.imaginary*b.imaginary,\n            a.real*b.imaginary + b.real*a.imaginary\n        );\n}\n\ncomplexNumber toComplex(vec2 a)\n{\n\treturn complexNumber(a.x, a.y);\n}\n\ncomplexNumber addComplex(complexNumber a, complexNumber b)\n{\n\treturn complexNumber(a.real + b.real, a.imaginary + b.imaginary);\n}\n\nfloat modulusComplex(complexNumber a)\n{\n\treturn sqrt(a.real*a.real + a.imaginary*a.imaginary);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nconst float Epsilon = 1e-10;\n \nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + Epsilon) + Q.z);\n\treturn vec3(H, C, Q.x);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + Epsilon);\n    return vec3(HCV.x, S, HCV.z);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HUEtoRGB(in float H)\n{\n\tfloat R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B), .0, 1.);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n}\n\n//code from Unity's Mathf.PingPong\nfloat pingpong(float t, float l)\n{\n    t = mod(t, l * 2.);\n    return l - abs(t - l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 1.0/ pow(2.0, pingpong(iTime+1.0, 16.0));\n\tcomplexNumber C = toComplex(uv);\n\tC.real += 0.281717921930775;\n    C.imaginary += 0.5771052841488505;\n    \n    complexNumber Z = toComplex(vec2(.0));\n    int itn = 0;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        Z =  addComplex(multiplyComplex(Z,Z), C);\n        \n        if(modulusComplex(Z) >= 2.0) \n        {\n        \titn = i;\n            break;\n        }\n    }\n    \n    float itRatio = float(itn) / float(MAX_ITER);\n    \n    vec3 col = BASE_COLOR;\n    col = RGBtoHSV(col);\n    col.x *= itRatio;\n    col = HSVtoRGB(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}