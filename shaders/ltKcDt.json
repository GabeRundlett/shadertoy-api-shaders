{
    "Shader": {
        "info": {
            "date": "1538225641",
            "description": "this tries to make believable crepuscularity with as few hyperplanes as possible, to a point where buffering a texture for the hyperplanes becomes a hassle that you may not bother with, so you get decent bufferless crepuscularity.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltKcDt",
            "likes": 9,
            "name": "tiny crepuscularity",
            "published": 3,
            "tags": [
                "fog",
                "lighthouse",
                "crepuscularity"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 614
        },
        "renderpass": [
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//goal is to overlap noise/bayer in a way \n//that only 3-5 hyperplanes are needed for believabple crepuscularity.\n//by doing interpolation by dithering a gradient of the tapped source.\n//and hoping that no distracting hyperplane [moire] patterns EVER emerge\n//- the last one is the tricky part\n//, done by scaling the hyperplane exposure parametrically\n//, so that moire patterns bet blended into each other over parameters\n//, to make most moise patterns blur out, even wioth only 3 planes.\n//, and by rotating it a bit.\n\n//todo, learn how to evade noticable moire , by applying Galois-fields of\n//https://www.shadertoy.com/view/XsScD1\n//that clearly show moire in some cases, but less noticable moire in other cases\n\n//the average or min or max of 3 planes usually has\n//stronger moire than averaging 8 or more planes.\n\n//scaling brighness/exposure/gamma/decay nicely is a subset of that issue.\n\n//green shapes are occluders, the oval is a bit transparent\n//the purple circle is a negative-occluder, equivalent to an emmitter.\n\n/*\nad 2d crepuscular occlusion dither bayer eclipse\n//this is a very reduced version,for performance\n\nparent:https://www.shadertoy.com/view/4dyXWy\nself:https://www.shadertoy.com/view/ltsyWl\n\nInstead of reading from a bitmap,this uses one of 2 bayer matrix generators.\nParents bufferA is a subroutine here:BuffA.mainImage()<-BA()\n-no buffers(Bayer matrix bitmap is very optional)\n-generalize to be more parametric,maybe?\n*/\n#define DITHER//Dithering toggle\n#define ViewZoom 3.\n//crepuscular hyperslices ,multiplier to [n] of O(n)complexity\n#define iterCrep 3.\n//1.-fog\n#define DECAY   .8\n//anti-foggyness(is a quadratic fog cunction?)should be ~=DECAY\n#define WEIGHT   .6\n//(1-range)to spread hyperslices overshould be(length(lightSource-surface))\n#define DENSITY  .9\n//final multiplier\n#define EXPOSURE .5\n//min(iResolution.x,iResolution.y)\n#define fsaa min(iResolution.x,iResolution.y)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n//using 2 buffers,1 for a bayer matrix,one for the luminosity that gets multi sampled,would be faster\n//this is a bufferless version,calculating the same bayer matrix and luminosity many times.\n/*#define iterBayerMat 1\n#define bayer2x2(a)(4-(a).x-((a).y<<1))%4\nfloat GetBayerFromCoordLevel(vec2 pixelpos){ivec2 p=ivec2(pixelpos);int a=0//https://www.shadertoy.com/view/XtV3RG\n ;for(int i=0;i<iterBayerMat;i++){a+=bayer2x2(p>>(iterBayerMat-1-i)&1)<<(2*i);}return float(a)/float(2<<(iterBayerMat*2-1));}*///integer_bayer\nmat2 r2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\nfloat bayer2(vec2 a,vec2 n){a=mod(a*r2((sqrt(5.)*.5+.5)),iResolution.x)//i prefer the float_bayer matrix for being more transformable.\n;return fract(dot((a+n.y)*r2(n.x+n.x),a*vec2((sqrt(5.)*.5+.5),(sqrt(5.)*.5-.5))));}\nfloat bayer4(vec2 a,vec2 n){return bayer2(.5*a,n)*.25+bayer2(a,n);}float bayer8(vec2 a,vec2 n){return bayer4(.5*a,n)*.25+bayer2(a,n);}\nfloat bayer16(vec2 a,vec2 n){return bayer4(.25*a,n)*.0625+bayer4(a,n);}float bayer32(vec2 a,vec2 n){return bayer8(.25*a,n)*.0625+bayer4(a,n);}\n//float bayer64(vec2 a,vec2 n){return bayer8(.125*a,n)*.015625+bayer8(a,n);}\nfloat circle(vec2 p,float r){return smoothstep(r+.01,r-.01,length(p));}\nvec3 sun(vec2 uv){\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n    \n ;vec2 p=fra(mouse.zw)*.666;if(iMouse.z<=0.)p=vec2(sin(iTime),sin(iTime*.5)*.5)\n ;float di=distance(uv,p);vec3 res;res.x=di<=.3333?sqrt(1.-di*3.):0.;res.yz=p\n ;res.y/=(iResolution.x/iResolution.y);res.yz=(res.yz+1.)*.5;return res;}\nvec4 BA(in vec2 uv){uv=uv*2.-1.;float aspect=iResolution.x/iResolution.y;uv.x*=aspect;vec2 mousep=(iMouse.xy/iResolution.xy)*2.-1.;mousep.x*=aspect\n ;float o=.3-min(length(uv-vec2(.7,0)),.8-(length(uv-vec2(.6,.1))))//circle with non-central hole\n ;o=min(o,abs(abs((.2-abs(length(uv-mousep))))-.03)-.01)//mouse cursor circle\n ;o=smoothstep(.001,-.001,o)\n ;o=max(o,smoothstep(.001,-.001,length(uv+vec2(.5,.2))+length(uv+vec2(.5,-.2))-.6)*.5)//oval is its own smoothstep,because it is semi-transparent\n ;o-=smoothstep(.001,-.001,length(uv-vec2(0,.7))-.2)//negative occluder is an emmitterbut this union cancels out 2 types to 0\n ;vec3 light=min(sun(uv),1.);float col=max(light.x-o,0.)\n ;return vec4(col,o,light.yz);}\nvoid mainImage(out vec4 o,vec2 I){\n #ifdef DITHER\n ;float h=bayer32(I,iMouse.xz+1./iResolution.y)//larger base-bayer-matrix (with offset)\n ;vec2 J=I\n #endif\n ;I/=iResolution.xy;vec4 c=BA(I);vec2 d=(I-c.zw)*(DENSITY/iterCrep);float l=1.,n=c.x,obj=c.y\n ;for(float i=0.;i<iterCrep;i++){I-=d\n  #ifdef DITHER\n  ;float h2=bayer8(J*.5-I,iMouse.yw)//resample a small bayer matrix [iterCrep] times,without offset,to lerp,to de-patternize\n  ;float s=BA(I+d*mix(h,h2,i/iterCrep)).x\n  #else\n  ;float s=BA(I).x\n  #endif\n  ;s*=l*WEIGHT;n+=s;l*=DECAY;}\n ;o=vec4(vec3(.5,.7,.1)*obj/3.+n*EXPOSURE,1.0);}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}