{
    "Shader": {
        "info": {
            "date": "1634740940",
            "description": "simple demo of my wee quaternion library",
            "flags": 0,
            "hasliked": 0,
            "id": "ssGSDm",
            "likes": 19,
            "name": "Quaternion Kinematics",
            "published": 3,
            "tags": [
                "animation",
                "quaternion",
                "bones"
            ],
            "usePreview": 0,
            "username": "spalmer",
            "viewed": 394
        },
        "renderpass": [
            {
                "code": "#define quat vec4\n\nconst quat qidentity = quat(0,0,0,1);\n\n// quaternion from 2 unit vectors\nquat qfromto(vec3 vsrc, vec3 vdst) // construct rotation that maps vsrc to vdst\n{\n    vec3 vhalf = vsrc + vdst;\n    vhalf *= length(vdst) / length(vhalf);\n    return quat(cross(vsrc, vhalf), dot(vsrc, vhalf));\n}\n\nquat qaxisangle(vec3 axis, float rad)\t// axis should be unit length!!\n{\n    rad *= .5;\n    return quat(sin(rad) * axis, cos(rad));\n}\n\n// conjugate\nquat qrev(quat q)\n{\n    q.w = -q.w;\n    return q;\n}\n\n// quaternion composition\nquat qmul(quat a, quat b)\n{\n\tvec3 va = a.xyz, vb = b.xyz;\n\treturn quat(b * a.w) - quat(cross(vb, va) - va * b.w, dot(va, vb));\n}\n\nquat qrenormalize(quat q)\n{\n    float l2 = dot(q, q);\n\treturn l2 == 1. ? q : .5 * (3. - l2) * q;\n}\n\nvec3 qrot(quat q, vec3 r)\n{\n\tvec3 axis = q.xyz;\n\tfloat w = q.w;\n\treturn 2.*((cross(axis,r) + r * w) * w + axis * dot(axis,r)) - r;\n}\n\n#if 0\n// unused here, enjoy\nquat qlog(quat q)\n{\n\tvec3 v = q.xyz;\n\tfloat l = length(v), s = 2. * atan(l / q.w) / l;\n\treturn quat(v * s, l);\n}\n\nquat qexp(quat v)\n{\n\tvec3 v3 = v.xyz;\n\tfloat a = dot(v3, v3);\n\tif (a < 1e-7) return qidentity;\n\ta = .5 * sqrt(a);\n\treturn quat(v3 * (sin(a) * .5 / a), cos(a));\n}\n\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\nquat qslerp(quat a, quat b, float i)\n{\n    // BUG yeah it'll go around the wrong long \n    // hyper-geodesic half the time, needs bit of work\n    if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qmul(a, qexp(qlog(qmul(qrev(a), b)) * i));\n}\n#endif\n\n// not super efficient,\n// just showing how to use this\n// mini quaternion library.\nvec3 QrbitCamera(vec2 a, vec3 d)\n{\n    a.y = clamp(a.y, -.5, .5);\n    const float pi = acos(-1.);  //3.141592\n    a *= pi;\n    quat q = qidentity;\n    q = qmul(q, qaxisangle(vec3(0,1,0), 2.*a.x));\n    q = qmul(q, qaxisangle(vec3(-1,0,0), a.y));\n    q = qrenormalize(q);\n    return qrot(q, d);\n}\n\nfloat dbox(vec3 p, vec3 e)\n{\n    p = abs(p); p -= e; \n    return all(lessThan(p, vec3(0)))\n     ? max(max(p.x, p.y), p.z)\n     : length(max(p, vec3(0)));\n}\n\nvec2 scene(vec3 e)\n{\n    e.xz = abs(e.xz); // duplicate scene into quadrants\n    //if (e.x > e.z) e.xz = e.zx;\n    e.zx -= 6.;\n    float dp = e.y + .1*(cos(9.*e.x) + cos(9.*e.z));\n    vec2 r = vec2(dp, 1);\n    vec3 p0 = vec3(0), p1;\n    float a = .2 * sin(iTime * 1.7);\n    quat q = qidentity, R = quat(normalize(vec3(.5,1,-.2)) * sin(a), cos(a));\n    for (int i = 8; i-- > 0; ) {\n        p1 = p0;\n        p0 += qrot(q, vec3(0,1,0));\n        float d = dbox(qrot(qrev(q), e - .5*(p0 + p1)), vec3(.1,.4,.1)) - .1;\n        if (d < r.x) r = vec2(d, i+2);\n        q = qmul(q, R);\n        q = qrenormalize(q);\n    }\n    return r;\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    o = iMouse; // bonus: initializes o\n    vec3 e = iResolution,\n      d = normalize(vec3((p - .5 * e.xy) / e.y, 1));\n\to.xy /= e.xy; // last use of resolution, now e -> eye pos\n    if (abs(o.z) > 1.) // quality detail in lists and prior to click\n        o -= .5;\n    else\n        o.x += .1*sin(.2*iTime);    \n    d = QrbitCamera(o.xy, d); // quaternion look\n    d = normalize(d);\n    e -= e; e.y += 4.; // ray init    \n    float r = 24., t = 0.; // sphere caster\n    vec2 h;\n    for (int i = 40; \n      h = scene(e),\n      h.x *= .8,\n      t += h.x, e += h.x * d, // march\n      i-- > 0 && abs(h.x) >= .001 * t && t < r && e.y < 9.; );\n    o -= o - exp(-.06 * min(r, t)); // black fog\n    float g = (scene(e + vec3(.1)).x - scene(e).x) / length(vec3(.1)); // directed gradient\n    o.rgb *= clamp(g * .25 + .5, 0., 1.); // simple lighting\n    o.rgb *= cos(vec3(0,2,4)-1.+11.7*h.y) * .5 + .5; // albedo\n    if (e.y >= 9. || t > r) o *= 0.;\n    o = sqrt(o); // gamma\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}