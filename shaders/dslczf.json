{
    "Shader": {
        "info": {
            "date": "1687243369",
            "description": "Added wavy droplets and made it faster",
            "flags": 96,
            "hasliked": 0,
            "id": "dslczf",
            "likes": 7,
            "name": "Better Rain",
            "published": 3,
            "tags": [
                "glass",
                "heart",
                "rain",
                "drop",
                "sad",
                "window",
                "droplets",
                "drops",
                "raining",
                "rainonwindow"
            ],
            "usePreview": 1,
            "username": "ixmibrahim",
            "viewed": 300
        },
        "renderpass": [
            {
                "code": "\n#define USE_POST_PROCESSING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 c = texture(iChannel0, uv).xy;\n    float focus = texture(iChannel0, uv).z;\n    float t = texture(iChannel0, uv).w;\n    \n    \n    float normalScale = 0.5;//when background is more sharpened, make this less and make the trails more\n    vec2 e = normalScale / iResolution.xy;\n    float cx = texture(iChannel0, uv + e).x;\n    float cy = texture(iChannel0, uv + e.yx).x;\n    vec2 n = vec2(cx-c.x, cy-c.x);\n        \n        \n    vec3 col = textureLod(iChannel3, uv+n, focus).rgb;\n    \n    \n    #ifdef USE_POST_PROCESSING\n    float colFade = sin(t*.2)*.5+.5;\n    col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\n    col *= 1.-dot(uv-=.5, uv);\t\t\t\t\t\t\t// vignette\n    #endif\n    \n    \n    \n    //vec3 col = texture(iChannel0, UV+n).rgb;\n    fragColor = vec4(vec3(0.5+n,0.5), 1.);\n    fragColor = vec4(vec3(c,0), 1.);\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 12788,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ahmed-gado-1/sad-piano-alone-in-the-dark"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 20576,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/daklakwarriors/sleeping-sound-rain-and-thunder-1-hours"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Heartfelt - by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define M_PI 3.14159\n#define M_2PI 6.28318\n#define S(a, b, t) smoothstep(a, b, t)\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\nvec2 StaticDropCenter(vec2 id)\n{\n    //vec3 n = N13(id.x*106.45+id.y*3543.654);\n    //return vec3(n.x - 0.5, n.y - 0.5, n.z);\n    //return vec2(-0.3,0.0);\n    return N13(id.x*106.45+id.y*3543.654).xy - 0.5;\n}\n\nvec3 rand3(vec2 id)\n{\n    return N13(id.x*105.45+id.y*3543.654);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x);\n    \n    float r = ra - rb;\n\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 DropLayer2(vec2 uv, float t, vec2 densityScale) {\n    vec2 UV = uv;//return vec2(uv.x, fract(uv.y+0.5)-0.5); // [-0.5, 0.5]\n    vec2 a = vec2(6., 1.) * densityScale;\n    vec2 grid = a*2.;\n    \n    vec2 id = floor(uv * grid); //return fract(uv*grid); // get id of each tile in grid\n    float gridFall = N(id.x)/3. + 0.5;//gridFall=0.;// 0.75\n    uv.y += t*gridFall/a.y; //return vec2(uv.x, fract(uv.y+0.5)-0.5); // make all drops fall a uniform amount - randomize?\n    id = floor(uv * grid); //return fract(uv*grid); // get id of falling grid\n    float extraDropSpeed = N(id.x);\n    uv.y += extraDropSpeed; // shift the grid by a (constant) random vertical amount\n    \n    id = floor(uv*grid); // update ID to match the location of the shifted grid, should be unique for each grid that shows up\n    vec2 st = fract(uv*grid)-vec2(.5, 0); //return fract(uv*grid)-vec2(.5, .5); // uvs for each tile, -.5<x<.5 and 0<y<1\n    //if (abs(st.x) > .485 || abs(st.y) > .985) return vec2(.9); // debuggin\n    vec3 n = N13(id.x*35.2+id.y*2376.1); // random [0,1]\n    float x = n.x-.5; // starting horizontal position [-0.5, 0.5]\n    float lambda = UV.y*20.; // wavelength of wiggle\n    float wiggle = sin(lambda+sin(lambda)); // shape of wiggle path [-1,1]\n    x += wiggle*(.5-abs(x))*(n.z-.5); // to drop position, add wiggle with random range [-0.25, 0.25], for a total max x value [-0.75, 0.75]\n    x *= .6; // keep away from tile edge [-0.45, 0.45] (as max range is [-0.5, 0.5]\n    float ti = fract(t*(gridFall+0.1)+n.z); // time offset so they don't all fall at the same time\n    float slowStart = 0.85;\n    float y = (Saw(slowStart, ti)-.5)*.9+.5; // falling position, slow start fast end, mapped to [0.05, 0.95] to avoid tile edge - can be randomized\n    vec2 p = vec2(x, y); // drop position\n    \n    //float d = length((st-p)*a.yx);// circular distance - a.xy returns a trail\n    float dropShape = (ti > slowStart) ? -sin(M_2PI * ti/ (1.-slowStart))*.5 - .5 : 0.;\n    float d = sdEgg((st-p)*a.yx, 0., dropShape);// drop-shape distance - a.xy returns a trail\n    float diameter = N(id.x+id.y)/7.+.2; // should be limited by starting position\n    float mainDrop = S(diameter/1.5, .0, d); // draws a drop with diameter\n    \n    float r2 = S(1., y, st.y);// blends from 0/top of tile to the vertical position of the drop, which clamp at 1\n    float r = sqrt(r2);\n    float cd = abs(st.x-x); // blends from 0/horizontal position of the drop to the tile edges, which clamp at 1\n    float thickness = diameter * 0.95;\n    //float trail = S(thickness*r, thickness/1.5*r2, cd); // draws a trail when cd is between the two curves, which create an arrow shape that is 0 at the top/0 and expand as r increases/gets lower\n    float trail = S(thickness*r, 0., cd); // draws a trail when cd is between the two curves, which create an arrow shape that is 0 at the top/0 and expand as r increases/gets lower\n    float trailFront = S(-.02, .02, st.y-y); // above the drop is 1 (where the trail is), below the drop is 0\n    trail *= r2*trailFront*0.5; // remove the trail below the drop, multiplying by r2 to get a blend from 0/top to 1/bottom of the trail\n    \n    y = UV.y; // [-0.5, 0.5]\n    float trail2 = S((thickness - 0.15)*r, 0., cd); // create a thinner trail that linearly expands in width, starting at 0 and clamping at 1\n    trail2 *= trailFront*n.z; // remove the trail below the drop and randomize its intensity\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2; // indicate the droplets' positions using the sin function (which starts big then gets small) and keep them within the smaller trail\n    float rndX = N(id.x)/1.5 + 0.5;\n    float rndY = N(st.y)/40. + 0.05; // high value adds slight shimmering effect\n    y = fract(y*11.*rndX)+(st.y-.5); // create a random grid where the droplets will show up\n    float dd = length(st-vec2(x, y)); // circular distance of droplet\n    droplets = S(trail2+rndY, 0.0, dd); // droplet positions, ideally with random widths\n    float m = mainDrop + droplets*r*trailFront; // add the droplets to the drop, blending them from 0/top to 1/bottom and removing the ones that are under the drop\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.; // debugging\n    //return vec2(m, trail2 > trail ? 0. : trail);\n    return vec2(m, trail);\n}\n\nfloat StaticDrop(vec2 uv, float t, vec2 offset)\n{\n    vec2 id = floor(uv) + offset;//if (floor(uv) == vec2(-3,-0) && offset == vec2(0,-1)) return 1.;\n    vec2 center = StaticDropCenter(id)*0.8;\n    vec3 rand = rand3(id);\n    uv = fract(uv) - 0.5; // within the tile, remap the origin so it's centered \n    //if (abs(uv.x) > .485 || abs(uv.y) > .485) return 0.02; // debugging\n    float d = length((uv - offset) - center);\n    \n    float radius = 0.5 + (rand.x/2. - 0.5);\n    float drop = S(radius, 0.0, d);\n    \n    t /= 1. + 1.5*(rand.x - 0.5); // the bigger the drop the longer it stays\n    float fade = Saw(0.15, fract(t + rand.y));// b is how fast the dot appears, 1-b is how fast the dot disappears, and it fades at a radom pace (multiply instead)\n    float intensity = fract(rand.z*27.);\n    \n    return drop * fade * intensity;\n    return drop;\n}\n\nfloat StaticDrops_old(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    float drops = StaticDrop(uv, t, vec2(0,0))\n                + StaticDrop(uv, t, vec2(1,0))\n                + StaticDrop(uv, t, vec2(-1,0))\n                + StaticDrop(uv, t, vec2(0,1))\n                + StaticDrop(uv, t, vec2(0,-1))\n                + StaticDrop(uv, t, vec2(1,1))\n                + StaticDrop(uv, t, vec2(-1,1))\n                + StaticDrop(uv, t, vec2(-1,-1))\n                + StaticDrop(uv, t, vec2(1,-1));\n    \n    return drops;\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    vec2 id = floor(uv);\n    vec2 center = StaticDropCenter(id)*0.6;\n    vec3 rand = rand3(id);\n    //vec2 center = (n.xy-.5)*.7;center = (n.xy-.5)*1.0;\n    uv = fract(uv)-.5;\n    //if (abs(uv.x) > .495 || abs(uv.y) > .495) return 0.1;\n    \n    float d = length(uv-center.xy);//return d;\n    float radius = 0.3;\n    float drop = S(radius, 0.0, d);\n    //float drop = clamp(radius-d, 0.0, 1.0);\n    \n    float fade = Saw(0.10, fract(t + rand.y));// b is how fast the dot appears, 1-b is how fast the dot disappears, and it fades at a radom pace (multiply instead)\n    //float fade = saw(fract(t+n.z));\n    float intensity = fract(rand.x*27.);\n    \n    drop *= fade * intensity;\n    return drop;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = (StaticDrops(uv, t))*l0;\n    vec2 m1 = DropLayer2(uv, t, vec2(1.))*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t, vec2(1.))*l2;\n    \n    float c = s+m1.x+m2.x;//return m1;\n    //float c = max(s,max(m1.x,m2.x));\n    //float c = max(m1.x,m2.x);\n    //c = max(S(0.3, 1.0, s), max(S(0.3, 1.0, m1.x), S(0.3, 1.0, m2.x)));\n    c = S(0.3, 1.0, c);\n    \n    //return vec2(c, max(m1.y*l1, m2.y*l2));\n    return vec2(c, m1.y + m2.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    vec3 M = iMouse.xyz/iResolution.xyz;\n    float T = iTime+M.x*2.;\n    \n    float t = T*.2;\n    \n    float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;\n    //rainAmount = 1.;//\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;\n    \n    float staticDrops = S(-.5, 1., rainAmount)*2.;//staticDrops = 0.;\n    float layer1 = S(.25, .75, rainAmount);//layer1 = 1.;\n    float layer2 = S(.0, .5, rainAmount);//layer2 = 0.;\n    \n    \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n    float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    //focus = M.y;//\n    \n    fragColor = vec4(c, focus, t);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}