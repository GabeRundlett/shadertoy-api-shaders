{
    "Shader": {
        "info": {
            "date": "1595189089",
            "description": "That's FBM terrain and volumetric fog checked off on the Shadertoy achievements!",
            "flags": 0,
            "hasliked": 0,
            "id": "tlKXDz",
            "likes": 12,
            "name": "Foggy Flyover",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "terrain",
                "volume"
            ],
            "usePreview": 0,
            "username": "ruojake",
            "viewed": 771
        },
        "renderpass": [
            {
                "code": "// Foggy Flyover by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// Hash without sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// --\n\n\nconst vec2 o = vec2(1., 0.);\n\nfloat noise(vec3 p)\n{\n\tvec3 pi = floor(p);\n    vec3 pf = smoothstep(0., 1., p - pi);\n    return mix(\n        mix(\n        \tmix(hash13(pi), hash13(pi+o.xyy), pf.x),\n            mix(hash13(pi+o.yyx), hash13(pi+o.xyx), pf.x),\n            pf.z\n        ),\n        mix(\n        \tmix(hash13(pi+o.yxy), hash13(pi+o.xxy), pf.x),\n            mix(hash13(pi+o.yxx), hash13(pi+1.), pf.x),\n            pf.z\n        ),\n    pf.y);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = smoothstep(0., 1., p - pi);\n    vec2 r = mix(vec2(hash12(pi), hash12(pi+o.yx)), vec2(hash12(pi+o), hash12(pi+1.)), pf.x);\n    return mix(r.x, r.y, pf.y);\n}\n\nconst mat2 ROT = mat2(.98, -.198, .198, .98);\n\n#define sat(v) clamp(v,0.,1.)\n\nfloat fbm(vec2 p, float o)\n{\n\tfloat res = 0.;\n   \tfor(float i = 1.; i < o; i += i)\n    {\n        res += noise(p*i) / i;\n    \tp = p * ROT;\n        o -= ROT[0][0] * .001 * sign(iTime);\n    }\n    return res;\n}\n\nfloat scene(vec3 p, float o)\n{\n\tfloat res = fbm(p.xz, o) * .5;\n    res *= 2.5 - res * res;\n    return .4 * (p.y + res - 1.5);\n}\n\nvec3 normal(vec3 p, float o)\n{\n\tfloat d = fbm(p.xz, o);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        fbm(p.xz - e, o),\n        d - 0.0011,\n        fbm(p.xz - e.yx, o)));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float k)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30; ++i)\n    {\n        d = scene(ro + rd * t, 16.);\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < .001 || t >= maxDist)\n            break;\n        if (res < .001)\n        {\n        \tres = 0.;\n            break;\n        }\n    }\n    return res;\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nfloat clouds(vec3 p)\n{\n\tfloat res = noise(p * 4.) * 2.;\n    p.y -= iTime * .02;\n    res -= noise(p * 11.);\n\n    return sat(res * 4. * (1. - res));\n}\n\nvec3 material(vec3 p, vec3 n, float l, float t)\n{\n\tfloat noise0 = fbm(p.xz * 20., 32.);\n    float noise1 = fbm(p.xz * 310., 4.);\n    noise1 = 2. * noise1 - 1.;\n    float y = p.y;\n    t = sat(t * .03 - .1);\n    vec3 sunCol = vec3(1., .97, .85);\n    \n    vec3 forest = vec3(.03, .08, .01) + noise1 * .02;\n    forest += l * .1 * sunCol;\n    vec3 rock = vec3(.025) + noise1 * .01;\n    rock += l * sunCol * .3;\n    vec3 snow = vec3(.6, .6, .7);\n    snow += l * .4 * sunCol;\n    \n    vec3 res = mix(rock, forest, smoothstep(.8, .5, y + .2 * noise0) * n.y * (2. - n.y));\n    res = mix(res, snow, smoothstep(1.2 - t, 1.3 + t, y + .4 * noise0));\n    return mix(res, res * vec3(.5, .55, .9), smoothstep(.3, 0., l));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n\tvec2 m = clamp((iMouse.xy / iResolution.xy) * 2. - 1., vec2(-1.), vec2(1.));\n    if (m == vec2(-1.,-1.)) m = vec2(0.);\n    \n    vec3 tgt = vec3(m.x * 2. + 10., m.y + 1.4, 2. + iTime * .3 - max(abs(m.x), abs(m.y) * .5) * 2.);\n    vec3 ro = vec3(10.,1.5, iTime * .3);\n    \n    vec3 rd = ray(ro, tgt, uv, .8);\n    float t = 0.;\n    vec3 p;\n    \n    if (rd.y < 0.)\n    {\n        for(int i = 0; i < 90; i++)\n        {\n            p = ro + rd * t;\n            float d = scene(p, 16.);\n            t += d * (1.25 - pow(abs(rd.y), 4.) + sat(t * .1 - 1.));\n            if (abs(d) < .001 * (1.+t) || t > 30.) break;\n        }\n        t = t >= 30. ? 1000. : t;\n    }\n    else\n    {\n    \tt = 1000.;\n        p = ro + rd * t;\n    }\n    \n    float theta = .5 * 3.1415;\n    vec3 lDir = normalize(vec3(-sin(theta), .25, cos(theta)));\n    float dither = fract(13.013 * dot(fragCoord + float((iFrame & 7) * 17), vec2(.104212, .672709)));\n    \n    float maxl = .8;\n    vec3 cFog = vec3(.1,.15,.2);\n    vec4 fog = vec4(0.);\n    float ft = max(ro.y - maxl, 0.) / (-rd.y + .0001);\n    ft += dither * (.025 * ft + .1) * (1. - sat(-rd.y));\n    vec3 v = vec3(0.,iTime * -.02,0.);\n\tfloat h = 1. - abs(rd.y);\n    vec3 shadowCol = cFog * vec3(.4, .5, .7);\n    float l = 0.;\n    vec3 skyCol = mix(vec3(.7, .8, 1.), vec3(.1, .1, .4), sat(rd.y));\n    \n    vec3 col = vec3(0.);\n\tif (t < 500.)\n    {\n    \n        if(p.y <= maxl)\n            for(int i = 0; i < 35; i++)\n            {\n                float dt = .01 + h * .1;\n                ft += dt;\n\n                if (ft >= t) break;\n\n                vec3 fp = (ro + rd * ft);\n\n                if (rd.y >= 0. && fp.y > maxl) break;\n\n                float d = clouds(fp + v) * (maxl + h) * dt * 10.;\n                float fade = min(sat(maxl - fp.y), min(ft * .5, maxl - ft * .05));\n                fade *= fade;\n                d *= fade;\n                ft += min(sat(h - fade) * .03, t - ft);\n                if (d > .01)\n                {\n                    l = 0.;\n                    float s = shadow(fp, lDir, 15. - fp.y, 20.);\n                    if (s > .001)\n                    {\n                        s *= 2. - s;\n                        l = sat(s * (1. - clouds(fp + lDir * .1 + v) * 3. * fade));\n                    }\n                    float w = sat((.1 * l + .91) - fog.a);\n                    fog.rgb += mix(shadowCol, cFog + l, l) * d * w;\n                    fog.a += d * w;\n\n                    if (fog.a > .95) \n                    {\n                        fog.a = 1.;\n                        break;\n                    }\n                }\n            }\n\n        fog.rgb = mix(fog.rgb, skyCol, sat(t * .05 - .15));\n        fog.a = min(fog.a, 1.);\n\n\n        vec3 n = t < 10. ? t < 6. ? normal(p, 256.) : normal(p, 64.) : normal(p, 8.);\n        l = sat(dot(n, lDir) * .8 + .2);\n        float s = shadow(p + n * .1 + vec3(0.,.03,0.), lDir, 15., 14.);\n        float sun = smoothstep(.9995, 1., dot(rd,lDir));\t\n\n        col = rd.y <= 0. ? mix(\n            vec3(material(p, n, l * s, t)), \n            skyCol, \n            sat(t * .05 - .15)) : skyCol;\n        col += sun * 2. * smoothstep(1.,.9999, 30. - t);\n\n        col = mix(col, fog.rgb, fog.a * fog.a);\n    }\n    else col = skyCol;\n    \n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    col += (dither * .03 - .015) * col;\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}