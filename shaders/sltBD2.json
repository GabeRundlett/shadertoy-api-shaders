{
    "Shader": {
        "info": {
            "date": "1663706569",
            "description": "A base implementation of a ray tracer, use WASDQE to move, hold clic to rotate the camera\nYou can change the FOV with the up and down arrow keys\nTo switch to AZERTY controls, comment the first line in \"Common\".",
            "flags": 48,
            "hasliked": 0,
            "id": "sltBD2",
            "likes": 3,
            "name": "Smoll Ray Tracer",
            "published": 3,
            "tags": [
                "raytracing",
                "rtx"
            ],
            "usePreview": 0,
            "username": "GetItemFromBlock",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 factor = fragCoord / iResolution.xy * 2. - vec2(1,1);\n    float fov = 70. + texture(iChannel0, vec2(2.5/iResolution.x,0)).x;\n    vec3 pos = texture(iChannel0, vec2(0,0)).xyz;\n    vec2 rot = texture(iChannel0, vec2(1.5/iResolution.x,0)).zw;\n    Ray r = Ray(pos, normalize(vec3(1., factor.y * fov / 100., factor.x * fov / 100. * iResolution.x / iResolution.y)) );\n    r.dir = vec3(\n    r.dir.x * cos(radians(rot.y)) - r.dir.y * sin(radians(rot.y)),\n    r.dir.y * cos(radians(rot.y)) + r.dir.x * sin(radians(rot.y)),\n    r.dir.z);\n    r.dir = normalize(vec3(\n    r.dir.x * cos(radians(rot.x)) - r.dir.z * sin(radians(rot.x)),\n    r.dir.y,\n    r.dir.z * cos(radians(rot.x)) + r.dir.x * sin(radians(rot.x))));\n    HitRecord nearest = HitRecord(false, vec2(0,0), r.dir, vec3(0,0,0), vec3(1,1,1), 1e24);\n    lowp int type = MIRROR;\n    int iter = 0;\n    int sphereIndex = -1;\n    spheres[0].pos = pos;\n    lights[0].pos = vec3(cos(iTime*.2)*-100.,150.,sin(iTime*.2)*20.);\n    bool reversed = false;\n    while (type != 0 && iter < MAX_REF)\n    {\n        iter++;\n        int minIndex = -1;\n        vec3 tmpcol = nearest.color;\n        for (int i = 0; i < spheres.length(); i++)\n        {\n            HitRecord rec = HitSphere(r, spheres[i], .0, nearest.dist, tmpcol, reversed);\n            if (rec.hit && (!nearest.hit || rec.dist < nearest.dist))\n            {\n                sphereIndex = i;\n                nearest = rec;\n                type = spheres[i].type;\n            }\n        }\n        for (int i = 0; i < tris.length(); i++)\n        {\n            HitRecord rec = HitTriangle(r, tris[i], .0, nearest.dist, tmpcol, reversed);\n            if (rec.hit && (!nearest.hit || rec.dist < nearest.dist))\n            {\n                sphereIndex = -1;\n                nearest = rec;\n                type = tris[i].type;\n            }\n        }\n        if (!nearest.hit) break;\n        for (int i = 0; i < lights.length(); i++)\n        {\n            Ray lr = Ray(nearest.point, normalize(lights[i].pos-nearest.point));\n            vec3 norm = nearest.normal;\n            if (type == 0) norm = normalize(nearest.normal+texture(iChannel2, nearest.normal).xyz*.1-.05);\n            float factor = dot(lr.dir,norm);\n            if (factor < 0.) continue;\n            bool hit = false;\n            for (int n = 0; n < spheres.length(); n++)\n            {\n                if (sphereIndex == n) continue;\n                HitRecord rec = HitSphere(lr, spheres[n], .0001, 1e24, vec3(0,0,0), true);\n                if (rec.hit)\n                {\n                    hit = true;\n                    break;\n                }\n                \n            }\n            if (!hit) for (int n = 0; n < tris.length(); n++)\n            {\n                HitRecord rec = HitTriangle(lr, tris[n], .0001, 1e24, vec3(0,0,0), true);\n                if (rec.hit)\n                {\n                    hit = true;\n                    break;\n                }\n            }\n            if (!hit)\n            {\n                vec3 halfV = normalize(lr.dir - r.dir);\n                float deltaB = pow(max(dot(norm, halfV), 0.0), 512.);\n                nearest.color += vec3(lights[i].strength * factor*.45 + deltaB);\n            }\n        }\n        if (type != 0)\n        {\n            r.pos = nearest.point;\n            if (type == MIRROR)\n            {\n                r.dir = reflect(r.dir, nearest.normal);\n            }\n            else\n            {\n                vec3 newDir = refract(r.dir, nearest.normal, reversed ? 1.45 : 0.689655);\n                if (dot(newDir, nearest.normal) < 0.) reversed = !reversed;\n                else\n                {\n                    newDir = reflect(r.dir, nearest.normal);\n                }\n                r.dir = newDir;\n            }\n            nearest.normal = r.dir;\n            nearest.dist = 1e24;\n            nearest.hit = false;\n        }\n    }\n    if (!nearest.hit)\n    {\n        float s = pow(max(dot(normalize(lights[0].pos-pos), r.dir), 0.0), 512.);\n        fragColor = texture(iChannel1, nearest.normal)*vec4(nearest.color*.7,1.)+s;\n    }\n    else\n    {\n        fragColor = vec4(nearest.color,1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tmp = fragCoord / iResolution.xy * iChannelResolution[1].xy;\n    if (int(tmp.x) == 0 && int(tmp.y) == 0)\n    {\n        vec3 mov = vec3(texture(iChannel0, vec2(bindings[0]/256.,0.)).x*iTimeDelta -\n        texture(iChannel0, vec2(bindings[1]/256.,0.0)).x*iTimeDelta,\n        texture(iChannel0, vec2(bindings[2]/256.,0.0)).x*iTimeDelta -\n        texture(iChannel0, vec2(bindings[3]/256.,0.0)).x*iTimeDelta,\n        texture(iChannel0, vec2(bindings[4]/256.,0.0)).x*iTimeDelta -\n        texture(iChannel0, vec2(bindings[5]/256.,0.0)).x*iTimeDelta);\n        vec2 rot = texture(iChannel1, vec2(1.5/iResolution.x,0)).zw;\n        mov = vec3(\n        mov.x * cos(radians(rot.x)) - mov.z * sin(radians(rot.x)),\n        mov.y,\n        mov.z * cos(radians(rot.x)) + mov.x * sin(radians(rot.x)));\n        fragColor = texture(iChannel1, vec2(0,0)) + vec4(\n        mov*2.,\n        1);\n    }\n    else if (int(tmp.x) == 1 && int(tmp.y) == 0)\n    {\n        vec4 old = texture(iChannel1, vec2(1.5/iResolution.x,.0));\n        fragColor = vec4(\n        iMouse.x,\n        iMouse.y,\n        mod(((iMouse.z > .5 && iMouse.w < .5) ? iMouse.x - old.x : .0)*.4 + texture(iChannel1, vec2(1.5/iResolution.x,0.0)).z, 360.),\n        clamp(((iMouse.z > .5 && iMouse.w < .5) ? iMouse.y - old.y : .0)*.4 + texture(iChannel1, vec2(1.5/iResolution.x,0.0)).w, -90., 90.));\n    }\n    else if (int(tmp.x) == 2 && int(tmp.y) == 0)\n    {\n        fragColor = vec4(\n        texture(iChannel0, vec2(40./256.,0.0)).x*iTimeDelta*30. -\n        texture(iChannel0, vec2(38./256.,0.0)).x*iTimeDelta*30.,\n        0,0,1) + texture(iChannel1, vec2(2.5/iResolution.x,0));\n        fragColor.x = clamp(fragColor.x, -69.99, 180.);\n    }\n    else\n    {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define QWERTY\n\n#define OPAQUE 0\n#define MIRROR 1\n#define TRANSP 2\n\nstruct HitRecord\n{\n    bool hit;\n    vec2 UV;\n    vec3 normal;\n    vec3 point;\n    vec3 color;\n    float dist;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius2;\n    vec3 color;\n    lowp int type;\n};\n\nstruct Triangle\n{\n    vec3 A, AB, AC;\n    vec3 normal;\n    vec3 color;\n    lowp int type;\n};\n\nstruct Light\n{\n    vec3 pos;\n    float strength;\n};\n\nHitRecord HitSphere(Ray r, Sphere sp, float minimum, float maximum, vec3 colorIn, bool reverse)\n{\n    HitRecord result = HitRecord(false, vec2(0,0), vec3(0,1,0), vec3(0,0,0), vec3(1,1,1), 0.0);\n    float t0, t1;\n    vec3 L = r.pos - sp.pos;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(r.dir, L);\n    float c = dot(L,L) - sp.radius2;\n    float discr = b * b - 4.0 * a * c;\n    if (discr < 0.0)\n    {\n        return result;\n    }\n    else if (discr == 0.0)\n    {\n        t0 = - 0.5 * b / a;\n        t1 = t0;\n       }\n    else\n    {\n        float q = (b > 0.0) ? -0.5 * (b + sqrt(discr)) : -0.5 * (b - sqrt(discr));\n        t0 = q / a;\n        t1 = c / q;\n    }\n    if (reverse ? (t1 > t0) : (t0 > t1))\n    {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < minimum || t0 > maximum) {\n        return result;\n    }\n    result.hit = true;\n    result.dist = t0;\n    result.point = r.pos + r.dir * t0;\n    result.normal = normalize(result.point-sp.pos);\n    if (reverse) result.normal = -result.normal;\n    result.color = colorIn * sp.color;\n    return result;\n}\n\nHitRecord HitTriangle(Ray r, Triangle tr, float minimum, float maximum, vec3 colorIn, bool reverse)\n{\n\tHitRecord result = HitRecord(false, vec2(0,0), vec3(0,1,0), vec3(0,0,0), vec3(1,1,1), 0.0);\n    if (reverse)\n    {\n        vec3 pvec = cross(r.dir, tr.AB);\n        float det = dot(tr.AC, pvec);\n        if (det < 0.00001) return result;\n        vec3 tvec = r.pos - tr.A;\n        result.UV.x = dot(tvec, pvec);\n        if (result.UV.x < .0 || result.UV.x > det) return result;\n        vec3 qvec = cross(tvec, tr.AC);\n        result.UV.y = dot(r.dir, qvec);\n        if (result.UV.y < .0 || result.UV.y + result.UV.x > det) return result;\n        det = 1./det;\n        result.dist = dot(tr.AB, qvec) * det;\n        if (result.dist < minimum || result.dist > maximum) return result;\n        result.UV *= det;\n        result.normal = -tr.normal;\n    }\n    else\n    {\n        vec3 pvec = cross(r.dir, tr.AC);\n        float det = dot(tr.AB, pvec);\n        if (det < 0.00001) return result;\n        vec3 tvec = r.pos - tr.A;\n        result.UV.x = dot(tvec, pvec);\n        if (result.UV.x < .0 || result.UV.x > det) return result;\n        vec3 qvec = cross(tvec, tr.AB);\n        result.UV.y = dot(r.dir, qvec);\n        if (result.UV.y < .0 || result.UV.y + result.UV.x > det) return result;\n        det = 1./det;\n        result.dist = dot(tr.AC, qvec) * det;\n        if (result.dist < minimum || result.dist > maximum) return result;\n        result.UV *= det;\n        result.normal = tr.normal;\n    }\n\tresult.point = r.pos + r.dir * result.dist;\n    result.color = colorIn * tr.color;\n\tresult.hit = true;\n\treturn result;\n}\n\n#define MAX_REF 50\n\nSphere[] spheres = Sphere[] (\nSphere(vec3(0,0,0), 0.5, vec3(.85,.85,.9), MIRROR),\nSphere(vec3(4,0.1,1.2),1.0, vec3(.6,.1,.8), OPAQUE),\nSphere(vec3(3.8,-1.2,-0.8),4.0, vec3(.3,.6,.8), OPAQUE),\nSphere(vec3(5.7,0.7,-0.2),2.0, vec3(.1,.7,.4), OPAQUE),\nSphere(vec3(3.5,2.5,2.0),0.8, vec3(.85,.9,.85), TRANSP),\nSphere(vec3(3.0,3.2,-6.8),25.0, vec3(.9,.85,.85), MIRROR));\n\nTriangle[] tris = Triangle[] (\nTriangle(vec3(-1,1,4),vec3(0,-2,-2),vec3(0,-2,0),vec3(-1,-0,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,2),vec3(2,-2,0),vec3(0,-2,0),vec3(-0,-0,-1),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,1,2),vec3(0,-2,2),vec3(0,-2,0),vec3(1,-0,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,1,4),vec3(-2,-2,0),vec3(0,-2,0),vec3(-0,-0,1),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,-1,2),vec3(-2,0,2),vec3(-2,0,0),vec3(-0,-1,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,2),vec3(2,0,2),vec3(2,0,0),vec3(-0,1,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,4),vec3(0,0,-2),vec3(0,-2,-2),vec3(-1,-0,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,2),vec3(2,0,0),vec3(2,-2,0),vec3(-0,-0,-1),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,1,2),vec3(0,0,2),vec3(0,-2,2),vec3(1,-0,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,1,4),vec3(-2,0,0),vec3(-2,-2,0),vec3(-0,-0,1),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,-1,2),vec3(0,0,2),vec3(-2,0,2),vec3(-0,-1,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,2),vec3(0,0,2),vec3(2,0,2),vec3(-0,1,-0),vec3(.7,.4,.4),TRANSP),\n\nTriangle(vec3(-3,-.5,0), vec3(0,0,1), vec3(1,0,0), vec3(0,1,0), vec3(.9,.9,.9), MIRROR),\nTriangle(vec3(-2,-.5,0), vec3(-1,0,1), vec3(0,0,1), vec3(0,1,0), vec3(.9,.9,.9), MIRROR));\n\nLight[] lights = Light[] (\nLight(vec3(-100,150,50), 1.1));\n\n#ifdef QWERTY\n    float[] bindings = float[] (87.5, 83.5, 69.5, 81.5, 68.5, 65.5);\n#else\n    float[] bindings = float[] (90.5, 83.5, 69.5, 65.5, 68.5, 81.5);\n#endif",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}