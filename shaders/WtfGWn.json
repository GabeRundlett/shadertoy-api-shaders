{
    "Shader": {
        "info": {
            "date": "1555969321",
            "description": "I've been kind of obsessed with The Amazing World of Gumball lately, so I needed an outlet to channel my love. \n\nAll SDF credits iq, and masks thanks to Maarten ",
            "flags": 32,
            "hasliked": 0,
            "id": "WtfGWn",
            "likes": 68,
            "name": "⋆ The Amazing World of Gumball ⋆",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "cartoon",
                "gumball",
                "darwin"
            ],
            "usePreview": 0,
            "username": "emmasteimann",
            "viewed": 4888
        },
        "renderpass": [
            {
                "code": "// THE SCARY CSG BITS\nbool bothHighFiving = false;\nconst float fiveTime = 9.;\nconst float maxTime = 11.5;\n\n////////////////\n//  DARWIN   ///\n////////////////\n\nbool isDarwinBlinking = false;\nbool isDarwinWalking = true;\nvec4 darwin(vec2 p, inout vec4 fragColor, float modTime) {\n    float time = 3.;//2;//\n    time = (modTime-3.)*1.5;\n    \n    vec2 shadow = vec2(sdEllipse(tX(p, vec2(-0.02, -0.251)),vec2(0.1,0.007)), 26.0);\n    draw(p, shadow, fragColor);\n    \n    // ARM - LEFT\n    float armExtension = 0.;\n    vec2 aPt = tX(p, vec2(-0.06, -0.03));\n    \n    ///////////////////\n    float currentAngle = .17*cos(time*3.);\n    \n    aPt *= rot2D(currentAngle * PI);\n    \n    if (bothHighFiving) {\n        float angleAtFiveTime = .17*cos(fiveTime*2.);\n        float percentIncrease = clamp((modTime-fiveTime)/0.5, 0., 1.);\n        float desiredAngle = -.64;\n        desiredAngle = desiredAngle - currentAngle;\n        float add = desiredAngle * percentIncrease;\n        aPt *= rot2D((angleAtFiveTime +(add)) * PI);\n        armExtension = .1*percentIncrease;\n    }\n    //////////////////\n    \n    vec2 arm1 = vec2(sdLineSegmentRounded(aPt, vec2(-0.0,0.0), vec2(-0.02,-0.076-armExtension*.8), 0.03), 15.0);\n    draw(p, arm1, fragColor);\n    \n    // LEG - LEFT\n    vec2 ppt = tX(p, vec2(-0.0, -0.0));\n    vec2 legsize = vec2(0.0175,0.1);\n    if (isDarwinWalking) {\n        ppt *= rot2D(.11*sin(time*3.) * PI);\n    }\n    vec2 leg = vec2(sdBox(tX(ppt, vec2(-0.01, -0.115)), legsize),15.0);\n    \n    vec2 fpt = tX(ppt, vec2(-0.02, -0.21));\n    vec2 fptbk = fpt;\n    if (isDarwinWalking) {\n        fpt *= rot2D(.1*sin(time*3.) * PI);\n    }\n    vec2 foot = vec2(sdLineSegmentRounded(fpt, vec2(-0.05,-0.0), vec2(0.01,-0.0), 0.05), 15.0);\n    add(leg, foot);\n    draw(p, leg, fragColor);\n    vec2 wBox = vec2(sdBox(tX(fpt, vec2(0.0,0.0)), vec2(0.1,0.08)),15.0);\n    intersection(leg, wBox);\n    leg.y = 2.0;\n    draw(p, leg, fragColor);\n    wBox = vec2(sdBox(tX(fpt, vec2(0.02,0.0)), vec2(0.06,0.05)),15.0);\n    intersection(leg, wBox);\n    leg.y = 17.0;\n    draw(p, leg, fragColor);\n    vec2 spot = vec2(sdEllipse(tX(fptbk, vec2(0.01, 0.01)),vec2(0.0075,0.013)  ), 2.0);\n    draw(p, spot, fragColor);\n    \n    // LEG - RIGHT\n    ppt = tX(p, vec2(0.0, -0.0));\n    \n    if (isDarwinWalking) {\n        ppt *= rot2D(-.1*sin(time*3.) * PI);\n    }\n    leg = vec2(sdBox(tX(ppt, vec2(0.01, -0.125)), legsize),15.0);\n    fpt = tX(ppt, vec2(-0.0, -0.21));\n    fptbk = fpt;\n    if (isDarwinWalking) {\n        fpt *= rot2D(-.1*sin(time*3.) * PI);\n    }\n    foot = vec2(sdLineSegmentRounded(fpt, vec2(-0.05,-0.0), vec2(0.01,-0.0), 0.05), 15.0);\n    add(leg, foot);\n    draw(p, leg, fragColor);\n    wBox = vec2(sdBox(tX(fpt, vec2(0.0,0.0)), vec2(0.1,0.08)),15.0);\n    intersection(leg, wBox);\n    leg.y = 2.0;\n    draw(p, leg, fragColor);\n    wBox = vec2(sdBox(tX(fpt, vec2(0.02,0.0)), vec2(0.06,0.05)),15.0);\n    intersection(leg, wBox);\n    leg.y = 17.0;\n    draw(p, leg, fragColor);\n    spot = vec2(sdEllipse(tX(fptbk, vec2(0.01, 0.01)),vec2(0.0075,0.013)  ), 2.0);\n    draw(p, spot, fragColor);\n    \n    vec2 origP = p;\n    if (!bothHighFiving){\n        p = tX(p, vec2(0, cos(time*4.)*.002));\n    }\n    // HEAD\n    vec2 headP = tX(p, vec2(0.08, 0.07));\n    vec2 i = vec2(sdUnevenCapsule(headP, vec2(-0.022,-0.01), vec2(-0.093,0.0), 0.09, 0.1025), 15.0);//sdSquircle(tX(p, vec2(-0.005, 0.075)), vec2(0), 0.135, 1.8, -1.1), 21.0);\n    vec2 baseFace = vec2(sdUnevenCapsule(p, vec2(-0.03,0.0175), vec2(-0.09,0.03), 0.05, 0.065), 15.0);\n    add(i,baseFace);\n    \n    // ARM - RIGHT\n    aPt = tX(p, vec2(0.085, -0.02));\n    aPt *= rot2D(.17*sin(time*3.) * PI);\n    \n    arm1 = vec2(sdLineSegmentRounded(aPt, vec2(-0.0,0.0), vec2(0.02,-0.076), 0.03), 15.0);\n    add(i,arm1);\n    \n    vec2 tailP = tX(headP, vec2(0.07, -0.05));\n    vec2 tail = vec2(sdCircle2(tailP, 0.035), 15.0);\n    draw(p, tail, fragColor);\n    \n    draw(p, baseFace, fragColor);\n    draw(p, i, fragColor);\n    \n    vec2 mouthP = tX(headP, vec2(-0.1, -0.02));\n    vec2 mouthSlice = vec2(sdBox(tX(mouthP, vec2(-0.0, 0.035)), vec2(0.1,0.05)), 19.0);\n    vec2 mouthSlice2 = vec2(sdCircle2(tX(mouthP, vec2(-0.0, -0.035)), 0.062), 19.0);\n    vec2 mouth = vec2(sdCircle2(mouthP, 0.068), 19.0);\n    diff(mouth, mouthSlice);\n    mouth = vec2(smoothIntersection(mouth.x, mouthSlice2.x, 0.01), 19.0);\n    draw(p, mouth, fragColor);\n    \n    mouth.y = 20.0;\n    vec2 tongue = vec2(sdCircle2(tX(mouthP, vec2(0.03, -0.065)), 0.032), 20.0);\n    intersection(tongue, mouth);\n    draw(p, tongue, fragColor);\n    \n    vec2 shineP = tX(headP, vec2(0.04, 0.02));\n    shineP *= rot2D(-.4 * PI);\n    shineP.x =shineP.x*-sin(shineP.x)*25.;\n    i = vec2(sdLineSegmentRounded(shineP, vec2(0.005,0.005), vec2(-0.025,-0.005), 0.02), 21.0);\n    draw(p, i, fragColor);\n    \n    tail = vec2(sdCircle2(tX(tailP, vec2(-0.01, -0.0)), 0.015), 16.0);\n    draw(p, tail, fragColor);\n    \n    vec2 tp1 = vec2(sdLineSegment(tX(tailP, vec2(0.0, 0.0)), vec2(0.02, -0.005), vec2(0.035, -0.012), 0.0025), 6.0);\n    draw(p, tp1, fragColor);\n    \n    tp1 = vec2(sdLineSegment(tX(tailP, vec2(-0.01, -0.01)), vec2(0.025, -0.005), vec2(0.035, -0.012), 0.0025), 6.0);\n    draw(p, tp1, fragColor);\n    \n    // EYES / EYEBROWS\n    if (cos(time+10.*.9) > 0.99) {\n        isDarwinBlinking = true;\n    }\n    if (!isDarwinBlinking) {\n        // EYELASHES\n        vec2 w1 = vec2(sdLineSegment(tX(p, vec2(0.08, 0.11)), vec2(-0.01, 0.0025), vec2(0.005, 0.01), 0.0025), 6.0);\n        draw(p, w1, fragColor);\n        w1 = vec2(sdLineSegment(tX(p, vec2(0.08, 0.095)), vec2(-0.01, 0.0025), vec2(0.011, 0.01), 0.0025), 6.0);\n        draw(p, w1, fragColor);\n        \n        w1 = vec2(sdLineSegment(tX(p, vec2(-0.055, 0.11)), vec2(-0.02, -0.01), vec2(-0.0425, 0.01), 0.0025), 6.0);\n        draw(p, w1, fragColor);\n        w1 = vec2(sdLineSegment(tX(p, vec2(-0.045, 0.13)), vec2(-0.02, -0.01), vec2(-0.0405, 0.005), 0.0025), 6.0);\n        draw(p, w1, fragColor);\n        \n        i = vec2(sdCircle2(tX(p, vec2(-0.055, 0.1)), 0.038), 5.0);\n        draw(p, i, fragColor);\n        \n        i = vec2(sdCircle2(tX(p, vec2(0.0425, 0.0925)), 0.038), 5.0);\n        draw(p, i, fragColor);\n        \n        //pupil\n        float move1 =  0.025;//(0.03*abs(sin(time*2)));\n        //        float move1 =  (0.03*abs(sin(time)));\n        i = vec2(sdCircle2(tX(p, vec2(-0.002+move1, 0.09)), 0.02), 6.0);\n        draw(p, i, fragColor);\n        \n        // pupil\n        float move2 = 0.021;//(0.025*abs(sin(time*2)));\n        //        float move2 = (0.025*abs(sin(time)));\n        i = vec2(sdCircle2(tX(p, vec2(-0.0955+move2, 0.0965)), 0.02), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp = tX(p, vec2(-0.05, 0.155));\n        ebp *= rot2D(.0 * PI);\n        ebp.x =ebp.x*-sin(ebp.x)*25.;\n        i = vec2(sdLineSegmentRounded(ebp, vec2(0.005,0.005), vec2(-0.005,-0.005), 0.0075), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp2 = tX(p, vec2(0.055, 0.145));\n        ebp2 *= rot2D(-.075 * PI);\n        ebp2.x =ebp2.x*-sin(ebp2.x)*25.;\n        i = vec2(sdLineSegmentRounded(ebp2, vec2(0.005,0.005), vec2(-0.005,-0.005), 0.0075), 6.0);\n        draw(p, i, fragColor);\n    } else {\n        vec2 ebp2 = tX(p, vec2(0.03, 0.085));\n        ebp2 *= rot2D(-.075 * PI);\n        i = vec2(sdLineSegmentRounded(ebp2, vec2(0.05,0.02), vec2(-0.005,-0.005), 0.01), 6.0);\n        draw(p, i, fragColor);\n        i = vec2(sdLineSegmentRounded(ebp2, vec2(0.075,-0.0025), vec2(-0.005,-0.005), 0.01), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp3 = tX(p, vec2(-0.015, 0.095));\n        ebp3 *= rot2D(.0 * PI);\n        i = vec2(sdLineSegmentRounded(ebp3, vec2(-0.05,0.02), vec2(-0.005,-0.005), 0.01), 6.0);\n        draw(p, i, fragColor);\n        i = vec2(sdLineSegmentRounded(ebp3, vec2(-0.075,-0.0025), vec2(-0.005,-0.005), 0.01), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp4 = tX(p, vec2(0.03, 0.1));\n        ebp4 *= rot2D(.3 * PI);\n        ebp4.x =ebp4.x*-sin(ebp4.x)*25.;\n        i = vec2(sdLineSegmentRounded(ebp4, vec2(0.005,0.005), vec2(-0.003,-0.003), 0.004), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp5 = tX(p, vec2(-0.02, 0.105));\n        ebp5 *= rot2D(-.3 * PI);\n        ebp5.x =ebp5.x*-sin(ebp5.x)*25.;\n        i = vec2(sdLineSegmentRounded(ebp5, vec2(0.005,0.005), vec2(-0.003,-0.003), 0.004), 6.0);\n        draw(p, i, fragColor);\n    }\n    p = origP;\n    \n    return fragColor;\n}\n\nvec4 sceneDistance(vec2 p, inout vec4 fragColor)\n{\n    float modTime = 4.;\n    modTime = mod((iTime-4.),maxTime);\n    \n    vec2 darwinP = tX(p, vec2(0.5, -0.01));\n    if (modTime > 8.) {\n        isDarwinWalking = false;\n        darwinP = tX(p, vec2(0.2, -0.01));\n        bothHighFiving = true;\n    } else {\n        darwinP = tX(p, vec2(1.-(modTime/100.)*10., -0.01));\n    }\n    \n    darwin(darwinP, fragColor, modTime);\n    \n    if (modTime > 9.6) {\n        float percentIncrease = clamp((modTime-10.)/1.4, 0.0001, 1.);\n        float percent = 12.*percentIncrease;\n        vec2 star = vec2(sdfStar5(tX(p, vec2(-0.01, -0.01))/percent)*percent, 22.0);\n        draw(p, star, fragColor);\n    }\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    fragColor = texture(iChannel0,uv);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    sceneDistance(uv, fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// THE SCARY CSG BITS\nconst float fiveTime = 9.;\nconst float maxTime = 11.5;\n\n\nvec4 bg(vec2 p, inout vec4 fragColor) {\n    vec2 sky = vec2(sdBox(tX(p, vec2(0.0,0.25)), vec2(1.0,0.25)), 23.0);\n    draw(p, sky, fragColor);\n    \n    vec2 tpp = tX(p, vec2(-0.85,0.05));\n    tpp.x = repeat(tpp.x, 0.15);\n    vec2 tree1 = vec2(sdCircle2(tpp, 0.1), 24.0);\n    draw(p, tree1, fragColor);\n    \n    tpp = tX(p, vec2(-0.85,0.00));\n    tpp.x = repeat(tpp.x, 0.1);\n    tree1 = vec2(sdCircle2(tpp, 0.1), 24.0);\n    draw(p, tree1, fragColor);\n    \n    vec2 cloud = vec2(sdEllipse(tX(p, vec2(0.03, 0.4)),vec2(0.1,0.04)), 1.0);\n    vec2 cloud1 = vec2(sdEllipse(tX(p, vec2(0.15, 0.4)),vec2(0.1,0.04)), 1.0);\n    add(cloud, cloud1);\n    vec2 cloud2 = vec2(sdEllipse(tX(p, vec2(0.1, 0.44)),vec2(0.1,0.04)), 1.0);\n    add(cloud, cloud2);\n    draw(p, cloud, fragColor);\n    \n    vec2 clouda = vec2(sdEllipse(tX(p, vec2(-0.5, 0.3)),vec2(0.1,0.04)), 1.0);\n    vec2 clouda2 = vec2(sdEllipse(tX(p, vec2(-0.55, 0.34)),vec2(0.1,0.04)), 1.0);\n    add(clouda, clouda2);\n    draw(p, clouda, fragColor);\n    \n    vec2 cloudb = vec2(sdEllipse(tX(p, vec2(0.65, 0.3)),vec2(0.1,0.04)), 1.0);\n    draw(p, cloudb, fragColor);\n    \n    return fragColor;\n}\n\n\nvec4 sceneDistance(vec2 p, inout vec4 fragColor)\n{\n    float modTime = 4.;\n    modTime = mod((iTime-4.),maxTime);\n    bg(p, fragColor);\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    fragColor = vec4(1.0,0.94,0.67,1.0);\n    sceneDistance(uv, fragColor);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float pi = acos(-1.);\nconst float pi2 = pi * 2.;\nconst float TWO_PI = pi * 2.;\nconst float PI = acos(-1.);\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\n// distance functions: ------------------------------------------------\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    float d = length(uv - origin) - radius;\n    return d;\n}\n\n\nfloat sdCircle2 (vec2 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n    p = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n    \n    float l = ab.y*ab.y - ab.x*ab.x;\n    \n    float m = ab.x*p.x/l;\n    float n = ab.y*p.y/l;\n    float m2 = m*m;\n    float n2 = n*n;\n    \n    float c = (m2 + n2 - 1.0)/3.0;\n    float c3 = c*c*c;\n    \n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    \n    float co;\n    \n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n    \n    float si = sqrt( 1.0 - co*co );\n    \n    vec2 r = ab * vec2(co,si);\n    \n    return length(r-p) * sign(p.y-r.y);\n}\n\n\nfloat sdLineSegment(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n    vec2 rectDimensions = b - a;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    a *= rotMat;\n    b *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n    a -= halfLineWidth;\n    b += halfLineWidth;\n    return sdAxisAlignedRect(uv * rotMat, a, b);\n}\n\nfloat sdLineSegmentRounded(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n    vec2 pa = uv-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - lineWidth*0.5;\n}\n\nfloat sdSquircle(vec2 uv, vec2 origin, float radius, float power, float rot_)\n{\n    mat2 rot = rot2D(rot_);\n    vec2 v = abs((origin*rot) - (uv*rot));\n    float d = pow(v.x,power) + pow(v.y, power);\n    d -= pow(radius, power);\n    return d;\n}\n\nconst float HALF_PI = 1.57079632679;\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n    if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n    return m                       - ra;\n}\nconst int N = 4;\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        \n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;\n    }\n    \n    return s*sqrt(d);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n    \n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n    \n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                      vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                 vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n    \n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdfStar5( in vec2 p )\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    \n    const vec2 k3 = vec2(0.951056516295,  0.309016994375);\n    return dot( vec2(abs(p.x)-0.1,p.y), k3);\n}\n\n// Operators\nvec2 tX(vec2 p, vec2 t) { return p - t; }\n\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\n\nvoid add(inout vec2 d1, in vec2 d2) {\n    if (d2.x < d1.x) d1 = d2;\n}\n\nvoid intersection(inout vec2 d1, in vec2 d2) {\n    if (d1.x < d2.x) d1 = d2;\n}\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat smoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat merge(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat mergeExclude(float d1, float d2)\n{\n    return min(max(-d1, d2), max(-d2, d1));\n}\n\nfloat substract(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat intersect(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat repeat(float coord, float spacing) {\n    return mod(coord, spacing) - spacing*0.5;\n}\n\n\n// MASKS\nfloat fillMask(float distanceChange, float dist) {\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\nconst vec4 mixColors[] = vec4[](\n    vec4(1,0,1,1),\n    vec4(1,1,1,1),\n    vec4(1,1,1,1),\n    vec4(1,1,1,1),\n    vec4(1,1,1,1),\n    vec4(1,1,1,1),\n    vec4(0,0,0,1),\n    vec4(67./255.,196./255.,218./255.,1.),\n    vec4(67./255.,196./255.,218./255.,1.),\n    vec4(67./255.,196./255.,218./255.,1.),\n    vec4(195./255.,218./255.,214./255.,1.),\n    vec4(204./255.,96./255.,49./255.,1.),\n    vec4(148./255.,86./255.,71./255.,1.),\n    vec4(241./255.,217./255.,184./255.,1.),\n    vec4(88./255.,89./255.,95./255.,1.),\n    vec4(255./255.,117./255.,19./255.,1.),\n    vec4(255./255.,117./255.,19./255.,1.),\n    vec4(68./255.,188./255.,63./255.,1.),\n    vec4(238./255.,124./255.,53./255.,1.),\n    vec4(199./255.,65./255.,51./255.,1.),\n    vec4(215./255.,79./255.,89./255.,1.),\n    vec4(225./255.,178./255.,127./255.,1.),\n    vec4(255./255.,255./255.,0,1.),\n    vec4(135./255., 206./255., 235./255.,1.),\n    vec4(34./255.,139./255.,34./255.,1.),\n    vec4(1.0, 0.0, 0.0, 1.0),\n    vec4(1.0,0.94,0.67,1.0)*.8\n);\n\n// Thanks to Daedelus for his amazingly helpful comment!! :-) \nvoid draw(vec2 uv, vec2 distAndMaterial, inout vec4 fragColor)\n{\n    float dist = distAndMaterial.x;\n    int material = int(distAndMaterial.y);\n    float distanceChange = fwidth(dist) * 0.5;\n    \n    const float[27] distanceChangeStops = float[27](0.004, 0.0, 0.004, 0.015, 0.015, 0.004, 0.0, 0.0015, 0.001, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.0, 0.004, 0.0, 0.004, 0.004, 0.0, 0.006, 0.0, 0.0, 0.0, 1.);\n\tfloat uWotM8 = distanceChangeStops[material];\n    if(material == 26) {\n        fragColor = mix(fragColor, mixColors[material], blurMask(distanceChange, dist, uWotM8));\n    } else if(uWotM8!=0.0)\n    {\n        uWotM8 = outerMask(distanceChange, dist, uWotM8);\n        if(material == 3 || material == 4) {\n\t    \tfragColor = mix(fragColor, vec4(1,0,0,1), uWotM8);\n        } else {\n\t    \tfragColor = mix(fragColor, vec4(0,0,0,1), uWotM8);\n        }\n    }\n    fragColor = mix(fragColor, mixColors[material], fillMask(distanceChange, dist));\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// THE SCARY CSG BITS\nbool bothHighFiving = false;\nbool isBlinking = false;\nbool isGumballWalking = true;\nconst float fiveTime = 9.;\nconst float maxTime = 11.5;\n\n\n////////////////\n//  GUMBALL  ///\n////////////////\nvec4 gumball(vec2 p, inout vec4 fragColor, float modTime) {\n    float time = 5.;//2;//\n    time = (modTime)*1.5;\n    \n    vec2 shadow = vec2(sdEllipse(tX(p, vec2(0.03, -0.251)),vec2(0.07,0.004)), 26.0);\n    draw(p, shadow, fragColor);\n    vec2 origP = p;\n    if (!bothHighFiving){\n        p = tX(p, vec2(0, cos(time*5.)*.002));\n    }\n    // EARS\n    vec2 ear = vec2(sdUnevenCapsule(p, vec2(0.01,0.15), vec2(0.02,0.19), 0.063, 0.045), 9.0);\n    draw(p, ear, fragColor);\n    \n    ear = vec2(sdUnevenCapsule(p, vec2(-0.09,0.13), vec2(-0.12,0.17), 0.063, 0.04), 9.0);\n    draw(p, ear, fragColor);\n    \n    // HEAD\n    vec2 i = vec2(sdSquircle(tX(p, vec2(-0.005, 0.075)), vec2(0), 0.135, 1.8, -0.6), 7.0);\n    vec2 baseFace = vec2(sdUnevenCapsule(p, vec2(0.04,0.018), vec2(0.11,0.04), 0.063, 0.064), 9.0);\n    add(i,baseFace);\n    vec2 neck = vec2(sdUnevenCapsule(tX(origP, vec2(0.02, 0.0)), vec2(0.0,0.0), vec2(0.0,-0.1), 0.013, 0.02), 9.0);\n    add(i,neck);\n    draw(p, neck, fragColor);\n    draw(p, baseFace, fragColor);\n    draw(p, i, fragColor);\n    \n    // MOUTH\n    vec2 mouth = vec2(sdEllipse(tX(p, vec2(0.02, 0.045)), vec2(0.03,0.01) + vec2(0.01,0.002)  ), 10.0);\n    vec2 tri = vec2(sdTriangle( vec2(-0.03,0.03), vec2(-0.02,0.045), vec2(0.0,0.04), p), 10.0);\n    add(mouth, tri);\n    draw(p, mouth, fragColor);\n    \n    // NOSE\n    \n    vec2 nose = vec2(sdEllipse(tX(p, vec2(0.02, 0.053)), vec2(0.005,0.001) + vec2(0.01,0.002)  ), 11.0);\n    draw(p, nose, fragColor);\n    \n    // MOUTH LINE\n    vec2 mouthline = vec2(sdLineSegment(tX(p, vec2(0.02, 0.053)), vec2(0.005, -0.008), vec2(0.015, -0.02), 0.005), 6.0);\n    draw(p, mouthline, fragColor);\n    \n    // WHISKERS\n    vec2 w1 = vec2(sdLineSegment(tX(p, vec2(0.125, 0.0)), vec2(-0.01, 0.0025), vec2(0.015, -0.018), 0.0055), 6.0);\n    draw(p, w1, fragColor);\n    w1 = vec2(sdLineSegment(tX(p, vec2(0.125, 0.04)), vec2(0.01, -0.01), vec2(0.045, -0.028), 0.0055), 6.0);\n    draw(p, w1, fragColor);\n    \n    w1 = vec2(sdLineSegment(tX(p, vec2(-0.125, 0.04)), vec2(0.014, -0.045), vec2(0.035, -0.03), 0.0055), 6.0);\n    draw(p, w1, fragColor);\n    w1 = vec2(sdLineSegment(tX(p, vec2(-0.105, 0.02)), vec2(0.014, -0.045), vec2(0.035, -0.025), 0.0055), 6.0);\n    draw(p, w1, fragColor);\n    w1 = vec2(sdLineSegment(tX(p, vec2(-0.095, -0.01)), vec2(0.034, -0.035), vec2(0.045, -0.015), 0.0055), 6.0);\n    draw(p, w1, fragColor);\n    \n    // EYES / EYEBROWS\n    if (sin(time+10.*.9) > 0.99) {\n        isBlinking = true;\n    }\n    if (!isBlinking) {\n        i = vec2(sdCircle2(tX(p, vec2(-0.055, 0.095)), 0.045), 5.0);\n        draw(p, i, fragColor);\n        \n        i = vec2(sdCircle2(tX(p, vec2(0.06, 0.105)), 0.045), 5.0);\n        draw(p, i, fragColor);\n        \n        float move1 =  0.025;//(0.03*abs(sin(time*2)));\n        //        float move1 =  (0.03*abs(sin(time)));\n        i = vec2(sdCircle2(tX(p, vec2(0.06+move1, 0.105)), 0.02), 6.0);\n        draw(p, i, fragColor);\n        \n        float move2 = 0.021;//(0.025*abs(sin(time*2)));\n        //        float move2 = (0.025*abs(sin(time)));\n        i = vec2(sdCircle2(tX(p, vec2(-0.051+move2, 0.0965)), 0.02), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp = tX(p, vec2(-0.1, 0.15));\n        ebp *= rot2D(.25 * PI);\n        ebp.x =ebp.x*-sin(ebp.x)*25.;\n        i = vec2(sdLineSegmentRounded(ebp, vec2(0.005,0.005), vec2(-0.005,-0.005), 0.0075), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp2 = tX(p, vec2(0.065, 0.175));\n        ebp2.x =ebp2.x*-sin(ebp2.x)*25.;\n        i = vec2(sdLineSegmentRounded(ebp2, vec2(0.005,0.005), vec2(-0.005,-0.005), 0.0075), 6.0);\n        draw(p, i, fragColor);\n    } else {\n        vec2 ebp2 = tX(p, vec2(0.03, 0.1));\n        i = vec2(sdLineSegmentRounded(ebp2, vec2(0.05,0.02), vec2(-0.005,-0.005), 0.01), 6.0);\n        draw(p, i, fragColor);\n        i = vec2(sdLineSegmentRounded(ebp2, vec2(0.075,-0.0025), vec2(-0.005,-0.005), 0.01), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp3 = tX(p, vec2(-0.025, 0.095));\n        ebp3 *= rot2D(.07 * PI);\n        i = vec2(sdLineSegmentRounded(ebp3, vec2(-0.05,0.02), vec2(-0.005,-0.005), 0.01), 6.0);\n        draw(p, i, fragColor);\n        i = vec2(sdLineSegmentRounded(ebp3, vec2(-0.075,-0.0025), vec2(-0.005,-0.005), 0.01), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp4 = tX(p, vec2(0.03, 0.11));\n        ebp4 *= rot2D(.3 * PI);\n        ebp4.x =ebp4.x*-sin(ebp4.x)*25.;\n        i = vec2(sdLineSegmentRounded(ebp4, vec2(0.005,0.005), vec2(-0.003,-0.003), 0.004), 6.0);\n        draw(p, i, fragColor);\n        \n        vec2 ebp5 = tX(p, vec2(-0.03, 0.105));\n        ebp5 *= rot2D(-.3 * PI);\n        ebp5.x =ebp5.x*-sin(ebp5.x)*25.;\n        i = vec2(sdLineSegmentRounded(ebp5, vec2(0.005,0.005), vec2(-0.003,-0.003), 0.004), 6.0);\n        draw(p, i, fragColor);\n    }\n    \n    p = origP;\n    \n    float armExtension = 0.;\n    \n    // ARM - RIGHT\n    vec2 aPt = tX(p, vec2(0.04, -0.08));\n    float currentAngle = .16*sin(modTime*2.);\n    \n    aPt *= rot2D(currentAngle * PI);\n    \n    if (bothHighFiving) {\n        float angleAtFiveTime = .16*abs(sin(fiveTime*2.));\n        float percentIncrease = clamp((modTime-fiveTime)/0.5, 0., 1.);\n        float desiredAngle = .5;\n        desiredAngle = desiredAngle - currentAngle;\n        float add = desiredAngle * percentIncrease;\n        aPt *= rot2D((angleAtFiveTime +(add)) * PI);\n        armExtension = .1*percentIncrease;\n    }\n    \n    // HAND - RIGHT\n    \n    vec2 hPt = tX(aPt, vec2(0.005, -0.105-armExtension*.6));\n    vec2 hand = vec2(sdCircle2(hPt, 0.015), 9.0);\n    draw(p, hand, fragColor);\n    \n    vec2 f1 = vec2(sdLineSegment(tX(hPt, vec2(0.0, 0.0)), vec2(0.005, -0.0), vec2(0.012, -0.012), 0.0035), 6.0);\n    draw(p, f1, fragColor);\n    \n    f1 = vec2(sdLineSegment(tX(hPt, vec2(0.0, 0.0)), vec2(-0.003, -0.005), vec2(0.002, -0.013), 0.0035), 6.0);\n    draw(p, f1, fragColor);\n    \n    vec2 sleeveSize = vec2(0.01,0.02);\n    vec2 sleeveInSize = vec2(0.002,0.02);\n    vec2 sP = tX(aPt, vec2(-0.0025, -0.07-armExtension*.4));\n    sP *= rot2D(.05 * PI);\n    vec2 arm1 = vec2(sdLineSegmentRounded(aPt, vec2(-0.0,0.0), vec2(-0.006,-0.046-armExtension/3.), 0.02), 13.0);\n    vec2 sleeve = vec2(sdBox(sP, vec2(sleeveSize.x, sleeveSize.y+armExtension/6.)),12.0);\n    draw(p, arm1, fragColor);\n    draw(p, sleeve, fragColor);\n    sleeve = vec2(sdBox(sP, vec2(sleeveInSize.x, sleeveInSize.y+armExtension/6.)),12.0);\n    draw(p, sleeve, fragColor);\n    \n    // TAIL\n    vec2 tailPoint = tX(p, vec2(0.02, -0.15));\n    tailPoint *= rot2D((-.3-(.01*-sin(time*3.)))* PI);\n    vec2 tail = vec2(sdUnevenCapsule(tailPoint, vec2(0.0,0.0), vec2(0.0,-0.08), 0.004, 0.012), 9.0);\n    draw(p, tail, fragColor);\n    \n    // LEG - RIGHT\n    vec2 ppt = tX(p, vec2(0.0375, -0.185));\n    vec2 legsize = vec2(0.01,0.02);\n    \n    if (isGumballWalking) {\n        ppt *= rot2D(-.16*sin(time*3.) * PI);\n    }\n    \n    vec2 leg = vec2(sdBox(tX(ppt, vec2(0.00, -0.01)), legsize),14.0);\n    vec2 cuff = vec2(sdBox(tX(ppt, vec2(0.0, -0.03)), vec2(0.01,0.008)),13.0);\n    \n    // FOOT - RIGHT\n    vec2 fpt = tX(ppt, vec2(-0.004, -0.052));\n    vec2 foot = vec2(sdLineSegmentRounded(fpt, vec2(0.00,-0.0), vec2(0.015,-0.0), 0.02), 9.0);\n    draw(p, foot, fragColor);\n    \n    vec2 t1 = vec2(sdLineSegment(tX(fpt, vec2(0.01, 0.0)), vec2(0.008, -0.001), vec2(0.015, -0.008), 0.0035), 6.0);\n    draw(p, t1, fragColor);\n    \n    t1 = vec2(sdLineSegment(tX(fpt, vec2(0.01, 0.0)), vec2(-0.004, 0.0), vec2(0.006, -0.010), 0.0035), 6.0);\n    draw(p, t1, fragColor);\n    \n    draw(p, leg, fragColor);\n    draw(p, cuff, fragColor);\n    \n    \n    \n    // LEG - LEFT\n    ppt = tX(p, vec2(0.0125, -0.185));\n    if (isGumballWalking) {\n        ppt *= rot2D(.17*sin(time*3.) * PI);\n    }\n    \n    leg = vec2(sdBox(tX(ppt, vec2(0.00, -0.01)), legsize),14.0);\n    cuff = vec2(sdBox(tX(ppt, vec2(0.0, -0.03)), vec2(0.01,0.008)),13.0);\n    \n    // FOOT - LEFT\n    fpt = tX(ppt, vec2(-0.004, -0.052));\n    foot = vec2(sdLineSegmentRounded(fpt, vec2(0.00,-0.0), vec2(0.015,-0.0), 0.02), 9.0);\n    draw(p, foot, fragColor);\n    \n    t1 = vec2(sdLineSegment(tX(fpt, vec2(0.01, 0.0)), vec2(0.008, -0.001), vec2(0.015, -0.008), 0.0035), 6.0);\n    draw(p, t1, fragColor);\n    \n    t1 = vec2(sdLineSegment(tX(fpt, vec2(0.01, 0.0)), vec2(-0.004, 0.0), vec2(0.006, -0.01), 0.0035), 6.0);\n    draw(p, t1, fragColor);\n    \n    draw(p, leg, fragColor);\n    draw(p, cuff, fragColor);\n    \n    // BODY\n    vec2 torso1 = vec2(sdPoly(vec2[](vec2(0.02, -0.04),vec2(0.065, -0.04),vec2(0.06, 0.01),vec2(0.02, 0.02)), tX(p, vec2(-0.015, -0.1))), 13.0);\n    vec2 tummy = vec2(sdLineSegmentRounded(tX(p, vec2(-0.0, -0.057)), vec2(0.045,-0.1), vec2(0.008,-0.1), 0.038), 13.0);\n    add(torso1, tummy);\n    draw(p, torso1, fragColor);\n    \n    vec2 belly = vec2(sdLineSegmentRounded(tX(p, vec2(-0.0, -0.057)), vec2(0.045,-0.1), vec2(0.008,-0.1), 0.038), 14.0);\n    vec2 belSlice = vec2(sdBox(tX(p, vec2(-0.0, -0.11)), vec2(0.10,0.05)),14.0);\n    vec2 belSlice2 = vec2(sdBox(tX(p, vec2(-0.0, -0.11)), vec2(0.10,0.05)),13.0);\n    vec2 button = vec2(sdEllipse(tX(p, vec2(0.03, -0.16)), vec2(0.005,0.005) + vec2(0.01,0.002)  ), 13.0);\n    diff(button, belSlice2);\n    diff(belly, belSlice);\n    draw(p, belly, fragColor);\n    draw(p, button, fragColor);\n    \n    // PANTS LINES\n    \n    vec2 p1 = vec2(sdLineSegment(tX(p, vec2(0.03, -0.17)), vec2(0.01, 0.0015), vec2(0.015, -0.007), 0.0055), 6.0);\n    draw(p, p1, fragColor);\n    \n    p1 = vec2(sdLineSegment(tX(p, vec2(0.0, -0.17)), vec2(0.02, 0.002), vec2(0.015, -0.007), 0.0055), 6.0);\n    draw(p, p1, fragColor);\n    \n    // COLLAR\n    vec2 collar = vec2(sdPoly(vec2[](vec2(0.012, 0.0),vec2(0.065, -0.005),vec2(0.06, 0.015),vec2(0.01, 0.02)), tX(p, vec2(-0.015, -0.08))), 12.0);\n    draw(p, collar, fragColor);\n    \n    // ARM - LEFT\n    \n    aPt = tX(p, vec2(-0.0, -0.08));\n    aPt *= rot2D(.16*cos(time*2.) * PI);\n    \n    // HAND - LEFT\n    hPt = tX(aPt, vec2(0.005, -0.105));\n    hand = vec2(sdCircle2(hPt, 0.015), 9.0);\n    draw(p, hand, fragColor);\n    \n    f1 = vec2(sdLineSegment(tX(hPt, vec2(0.0, 0.0)), vec2(0.005, -0.0), vec2(0.012, -0.012), 0.0035), 6.0);\n    draw(p, f1, fragColor);\n    \n    f1 = vec2(sdLineSegment(tX(hPt, vec2(0.0, 0.0)), vec2(-0.003, -0.005), vec2(0.002, -0.013), 0.0035), 6.0);\n    draw(p, f1, fragColor);\n    \n    sP = tX(aPt, vec2(-0.0025, -0.07));\n    sP *= rot2D(.05 * PI);\n    vec2 sleeve2 = vec2(sdBox(sP, sleeveSize),12.0);\n    arm1 = vec2(sdLineSegmentRounded(aPt, vec2(-0.0,0.0), vec2(-0.006,-0.046), 0.02), 13.0);\n    draw(p, arm1, fragColor);\n    draw(p, sleeve2, fragColor);\n    sleeve2 = vec2(sdBox(sP, sleeveInSize),12.0);\n    draw(p, sleeve2, fragColor);\n    \n    \n    return fragColor;\n}\n\nvec4 sceneDistance(vec2 p, inout vec4 fragColor)\n{\n    float modTime = 4.;\n    modTime = mod((iTime-4.),maxTime);\n    \n    vec2 gumP = tX(p, vec2(-0.3, 0.0));\n    if (modTime > 8.) {\n        isGumballWalking = false;\n        gumP = tX(p, vec2(-0.2, 0.0));\n        bothHighFiving = true;\n    } else {\n        gumP = tX(p, vec2(-1.+(modTime/100.)*10., 0.0));\n    }\n    \n    gumball(gumP, fragColor, modTime);\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    fragColor = texture(iChannel0,uv);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    sceneDistance(uv, fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}