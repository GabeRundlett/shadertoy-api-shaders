{
    "Shader": {
        "info": {
            "date": "1626030098",
            "description": "License CC0: Sommarhack 2021 as a distance field\nInspired by the Sommarhack 2021 I wanted to recreate the logo as a distance field\nto enable some cool effects later",
            "flags": 0,
            "hasliked": 0,
            "id": "NtfSz2",
            "likes": 5,
            "name": "Sommarhack 2021",
            "published": 3,
            "tags": [
                "2d",
                "summerhack"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 336
        },
        "renderpass": [
            {
                "code": "// License CC0: Sommarhack 2021 as a distance field\n//  Inspired by the Sommarhack 2021 I wanted to recreate the logo as a distance field\n//  to enable some cool effects later\n//  I took some liberties with the logo so it's not an exact replica\n//  The distance field isn't perfect but doesn't look too awful\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)         dot(x, x)\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// Lots of distance fields from: https://iquilezles.org/articles/distfunctions2d\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat moon(vec2 p, float d, float ra, float rb ) {\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// Imprecise faster version\nfloat fastMoon(vec2 p, float d, float ra, float rb) {\n  float d0 = length(p) - ra;\n  float d1 = length(p-vec2(d, 0.0)) - rb;\n  return max(d0, -d1);\n}\n\nfloat roundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(DOT2(p-vec2(1,k)))  :\n           sqrt(min(DOT2(p-vec2(0,h)),\n                    DOT2(p-vec2(1,0))));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n \nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy) + pp.z;\n}\n \nfloat summerhack(vec2 p) {\n  // As the moon shapes are mostly used for cut-outs I think there is less need for exact\n  //  moon distance and therefore rely on fastMoon instead\n  vec2 op = p;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.385);\n  float d0 = circle(p0, 0.605);\n  vec2 p1 = p;\n  p1 -= vec2(0.0, -0.375);  \n  float d1 = vesica(p1, vec2(0.04, 0.569))-(mix(0.005, 0.035, smoothstep(0.1, 0.2, p1.y)));\n  \n  vec2 p2 = p;\n  p2 -= vec2(0.0, 0.4);\n  p2 = -p2.yx;\n  float d2 = fastMoon(p2, 0.075, 0.33, 0.275);\n  \n  vec2 p3 = p;\n  p3 -= vec2(0.0, 0.65);\n  float d3 = circle(p3, 0.367);\n  \n  vec2 p4 = p;\n  p4 -= vec2(0.0, 0.43);\n  float d4 = circle(p4, 0.29);\n  \n  vec2 p5 = p;\n  p5 -= vec2(-0.185, 0.12);\n  float d5 = circle(p5, 0.30);\n  \n  vec2 p6 = p;\n  p6 -= vec2(0.12, -0.19);\n  p6 *= ROT(0.65);\n  float d6 = vesica(p6, vec2(0.15, 0.024))-0.0175;\n  \n  vec2 p7 = p;\n  p7 -= vec2(0.0, 0.735);\n  p7 = -p7.yx;\n  float d7 = fastMoon(p7, 0.13, 0.68, 0.595);\n  \n  vec2 p8 = p;\n  p8 -= vec2(0.0, 0.7);\n  p8 = -p8.yx;\n  float d8 = fastMoon(p8, 0.1, 0.477, 0.4676);\n\n  vec2 p9 = p;\n  p9 -= vec2(0.25, 0.72);\n  p9.x = -p9.x;\n  float d9 = fastMoon(p9, 0.188, 0.73, 0.775);\n\n  vec2 p10 = op;\n  p10 -= vec2(0.0, 0.28);\n  p10 = p10.yx;\n  p10.x *= sign(op.x);\n  p10.x += (-sign(op.x)+1.0)*-0.0775;\n  float d10 = moon(p10, 0.045, 0.105, 0.095);\n\n  vec2 p11 = p;\n  p11 -= vec2(0.0, -0.78);\n  p11 = p11.yx;\n  float d11 = roundedCross(p11, 0.55);\n  \n  vec2 p12 = p;\n  float d12 = plane(p12, vec3(normalize(vec2(-4.0, 1.0)), 0.315));\n  \n  vec2 p13 = p;\n  p13 -= vec2(-0.05, -0.805);\n  float d13 = circle(p13, 0.175);\n\n  vec2 p14 = p;\n  p14 -= vec2(0.0, -0.88);\n  float d14 = p14.y;\n  \n  vec2 p15 = p;\n  p15 -= vec2(0.45, -0.4);\n  p15 = p15.yx;\n  float d15 = fastMoon(p15, 0.14, 0.4, 0.4);\n\n  vec2 p16 = op;\n  p16 -= vec2(-0.095, 0.323);\n  // Cheat to remove discontinuity in distance field due to hacking on d10\n  float d16 = length(p16); \n    \n  d11 = max(d11, -d12);\n  d11 = max(d11, -d13);\n  d11 = max(d11, -d14);\n  d11 = max(d11, -d15);\n\n  float dn = d3;\n  dn = min(dn, d4);\n  dn = min(dn, d2);\n  dn = min(dn, d5);\n  dn = min(dn, d6);\n  dn = min(dn, d7);\n  dn = min(dn, d8);\n  dn = min(dn, d9);\n\n  float d = d0;\n  d = max(d, -dn);\n  d = min(d, d1);\n  d = min(d, d10);\n  d = min(d, d11);\n  d = min(d, d16);\n  \n  \n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q    = fragCoord/RESOLUTION.xy;\n  vec2 p    = -1. + 2. * q;\n  p.x       *= RESOLUTION.x/RESOLUTION.y;\n  float aa  = 2.0/RESOLUTION.y;\n\n  float d = summerhack(p);  \n  float ds = summerhack(p-0.033*vec2(1.0, -1.0));\n\n  float od = abs(d-0.015)-0.0033;\n  d = min(d, od);\n\n  vec3 col  = vec3(0.1, 0.1, 0.2);\n  vec4 scol = vec4(col*0.5, smoothstep(-aa, aa, -ds)); \n  vec4 dcol = vec4(mix(vec3(1.0, 0.5, 0.5), vec3(1.0), q.y*q.y), smoothstep(-aa, aa, -d)); \n\n  col = alphaBlend(col, scol);\n  col = alphaBlend(col, dcol);\n  /* View distance field\n  if (p.x > 0.0)\n    col += 0.5*sin(300.0*d);\n  */\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}