{
    "Shader": {
        "info": {
            "date": "1672854965",
            "description": "a test shader for levelex",
            "flags": 0,
            "hasliked": 0,
            "id": "DtjGzh",
            "likes": 0,
            "name": "levelex shader",
            "published": 3,
            "tags": [
                "levelex"
            ],
            "usePreview": 0,
            "username": "hneupert",
            "viewed": 167
        },
        "renderpass": [
            {
                "code": "/*\n * This function will function like an array.\n */\nvec2 getWaveSource(int ws)\n{\n\tvec2 outp;\n\tif (ws == 0)\n\t{\n\t\toutp = vec2(-100,-100);\n\t}\n\telse if (ws == 1)\n\t{\n\t\toutp = vec2(-100,500);\n\t}\n\telse\n\t{\n\t\toutp = vec2(500,-500);\n\t}\n\treturn outp;\n}\n/*\n * Don't need an expensive square root operation.\n * This returns distance squared, not distance.\n */\nfloat distanceSq(vec2 a, vec2 b)\n{\n\tvec2 diff = a - b;\n\treturn dot(diff, diff);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int wsCount = 3;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat wavePower = 0.0;\n\tfor(int i=0; i<wsCount; i++)\n\t{\n\t\tvec2 src = getWaveSource(i);\n\t\tfloat dist = distanceSq(src, uv) / 300.0;\n\t\twavePower += sin((dist + iTime));\n\t\t\n\t}\n\tfragColor = vec4(\n\t\t0.1 + 0.1 * sin(wavePower),\n\t\t0.1 + 0.1 * sin(wavePower),\n\t\t0.1 + 0.1 * sin(wavePower),\n\t\t0.9\n\t);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}