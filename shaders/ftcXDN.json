{
    "Shader": {
        "info": {
            "date": "1639167707",
            "description": "Nyancats living on complex planetoids.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftcXDN",
            "likes": 10,
            "name": "Complex planetoids",
            "published": 3,
            "tags": [
                "nyan",
                "nyancat",
                "complex"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 379
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Complex planetoids\" created by Colling Patrik (cyperus) in 2021\n//\n// BASED ON\n// - mu6k \n//     \"Nyancat\" https://www.shadertoy.com/view/4dXGWH\n//\n////////////////////////////////////////////////////////////////////////////////\n#define CENTER\n#define COMPLEX\n\nconst float\n    period = 12., // animation loop time in seconds\n    scale  = 12.; // inside one unit\n\nvec4 stars(vec2 p, float time)\n{\n\tvec4 color = vec4(0);\n\tvec2 ps;\n\tfloat stars; float ss = 0.04, s1 = 16.;\n    \n\tfor (float i = 1.; i < 7.; i++)\n\t{\n        time /= i; ps = i*p;\n\t\tps = ps + time*vec2(1, 0) - mod(ps + vec2(time,i*s1) ,vec2(ss));\n        \n\t\tstars = noise(s1 * ps);\n\t\tif (stars > 0.97) color = vec4(1);\n\t}   \n\treturn color;\n}\n\nvec4 nyancat(vec2 z, vec2 z0, float scale, float time)\n{\n    z = scale * vec2(fract(z.x - time) , z.y); z -= z0;\n    return ((0. < z.x && z.x < 0.9) && (0. < z.y && z.y < 0.6))\n    ? texture(iChannel0, \n        vec2(40./256. * (z.x + floor(6. * fract(3. * scale * time))), z.y + 0.2 ))\n    : vec4(0.);\n}    \n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = iTime/period,\n          PI2time = PI2*time,\n          ps_t = 0.2*PI2time; // planet system t\n    vec2 uv0;      \n    \n    float pix = scale*3./R.x;\n    #ifdef CENTER\n    vec2 uv = (2.*U.xy-R.xy)/R.x; // uv.x ∈ [-1, 1.], uv.y ∈ [-R.y/R.x, R.y/R.x];\n    #else\n    vec2 uv = U.xy/R.x; // uv.x ∈ [0., 1.], uv.y ∈ [0., R.y/R.x];\n    #endif\n    \n    // planetoid system\n    float a, id;\n    #ifdef COMPLEX\n    uv *= 1.4; uv = cmul(uv,uv); uv.x -= .5+.2*cos(ps_t*.125); // (s*z)²-z0 -> z\n    uv *= 2.;  uv = crpt(uv, 1./6.*ps_t, 3, 6.*sin(ps_t*.25)); // (s*z*e^(j*a))³-z0 -> z                                           // 1/z -> z\n    uv.yx = uv.xy;                                             // continuity\n    \n    a = atan(-uv.y, uv.x) + ps_t;        // planetoid  number nyancats, spin,\n    uv = vec2(log(length(uv)), a)/PI_2;  // cartesian -> polar coords\n    id = floor(uv.y)/2.;                 // mountain color hue\n    uv.yx = 0.25 * uv.xy;\n    #endif\n    \n    // sky & ground\n    float  f_sy = 5., f_gr = 8.;\n    vec3 T = (texture(iChannel2, U.xy/R.x , 0.)).rgb; T = 0.3*pow(T,vec3(5)); // texture   \n\n    vec3 c_sy = mix(vec3(.0,.1,.7),T, sqrt(f_sy*uv.y));\n         c_sy = mix(vec3(0.,0.,0.),c_sy, sqrt(f_sy*uv.y));\n       \n         //c_sy = mix(c_sy, T.rgb, 0.2);\n    \n    vec3 c_gr = mix(texture(iChannel1, uv).rgb, vec3(1.,0.,0.), sqrt(-f_gr*uv.y));\n         c_gr = mix(c_gr.rgb, vec3(1.,1.,0.), sqrt (-f_gr*uv.y)-1.);\n    vec4 sg = vec4( uv.y >= 0. ? c_sy : c_gr ,1.);\n    \n    // stars     \n    vec4 st = stars(10. * uv, 5. * time);\n         st.a = uv.y > 0. ? st.a : 0.;\n    \n    // floor\n    float fl_height = scale *0.03;\n    vec2 fl_uv = scale * uv; // uv-transformation\n    float fl_sdf = fl_height - abs(fl_uv.y) ; // signed distance function\n    vec4 fl = vec4(0.9 * h2rgb(uv.x), S(fl_sdf, 1.5*pix)); // color, alpha\n    \n    // mountain\n    float mo_height = scale * (0.07 +  0.02 * sin(2.*a) + 0.01 * sin(7.*a));\n    mo_height = uv.y > 0. ? mo_height : 0.;\n    vec2 mo_uv = scale * uv; // uv-transformation\n    float mo_sdf = mo_height - abs(mo_uv.y); // signed distance function\n    vec4 mo = vec4(0.9 * h2rgb(id), S(mo_sdf, 1.5*pix)); // color, alpha\n\n    // ball\n    float ba_r = 0.1;\n    vec2 ba_uv = uv;\n         ba_uv = scale * vec2(fract(ba_uv.x - time), ba_uv.y ); // uv-transformation\n         ba_uv -= vec2(1.2, fl_height + ba_r + 0.2 * abs(cos(PI2time * scale)));\n    float ba_sdf = ba_r - length(ba_uv); // signed distance function\n    vec4 ba = vec4(1.2 * vec3(.8,.2,0.), S(ba_sdf, pix )); // color, alpha\n    \n    // nyancat\n    uv0 = vec2(0., fl_height);\n    vec4 na = nyancat(uv, uv0, scale, time); na.xyz *= na.xyz;// gamma,color, alpha\n    \n    // compose\n    O = vec4(0.7 *sg.rgb * sg.a, sg.a);\n    st *= 0.5;\n    O = mix(O, st, st.a);\n    mo.rgb *= 0.5;\n    O = mix(O, mo, mo.a);\n    fl.rgb *= 0.8;\n    O = mix(O, fl, fl.a);\n    O = mix(O, ba, ba.a);\n    O = mix(O, na, na.a);\n    O = vec4(O.rgb / O.a, O.a);  \n    \n    // gamma\n    O = vec4(sqrt(O.rgb), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "# define R iResolution\n\nconst float PI_2 = acos(0.), PI = 2.*PI_2, PI2 = 2.*PI;\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) // za*zb\n{\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) // 1/z\n{\n    return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) // z/w\n{\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) // z^n\n{\n    vec2 w = z;\n    for (int i = 1; i < n; i++){\n        w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) // z*e^(i*a)\n{\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) // (z*e^ia)^n-x0\n{\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// noise \n// https://www.shadertoy.com/view/4dXGWH \"Nyancat\" by mu6k\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321);\n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\n// smooth\nfloat S(float sdf, float pix)\n{\n    return smoothstep(-pix, +pix, sdf);\n}\n\n// color\nvec3 h2rgb(float h)\n{\n    return .5*(1.+cos(PI2*(h+vec3(0,1,2)/3.)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}