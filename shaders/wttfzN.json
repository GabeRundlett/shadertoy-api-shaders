{
    "Shader": {
        "info": {
            "date": "1612452515",
            "description": "inspired by bigwing's (the art of code on youtube) video",
            "flags": 0,
            "hasliked": 0,
            "id": "wttfzN",
            "likes": 24,
            "name": "fireworks with fake physics",
            "published": 3,
            "tags": [
                "simulation",
                "fireworks",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "stduhpf",
            "viewed": 9139
        },
        "renderpass": [
            {
                "code": "vec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec2 dir(float id){\n    vec2 h = hash21(id);\n    h.y*=2.*acos(-1.);\n    return h.x*vec2(cos(h.y),sin(h.y));\n}\n\n#define PARTICLES_MIN 20.\n#define PARTICLES_MAX 200.\n\nfloat bang(vec2 uv, float t,float id){\n    float o = 0.;\n    if(t<=0.){\n        return .04/dot(uv,uv);\n    }\n    float s = (sqrt(t)+t*exp2(-t/.125)*.8)*10.;\n    float brightness = sqrt(1.-t)*.015*(step(.0001,t)*.9+.1);\n    float blinkI = exp2(-t/.125);\n    float PARTICLES = PARTICLES_MIN+(PARTICLES_MAX-PARTICLES_MIN)*fract(cos(id)*45241.45);\n    for(float i=0.;i<PARTICLES;i++){\n        vec2 d = dir(i+.012*id);\n        \n        vec2 p = d*s;\n        \n        \n        vec2 h = hash21(5.33345*i+.015*id);\n        float blink = mix(cos((t+h.x)*10.*(2.+h.y)+h.x*h.y*10.)*.3+.7,1.,blinkI);\n        \n        o+=blink*brightness/dot(uv-p,uv-p);\n    }\n    return o;\n}\n\nconst float ExT = 1./4.;\n\n#define duration 2.2\n\nfloat firework(vec2 uv,float t,float id){\n    if(id<1.)return 0.;\n    vec2 h = hash21(id*5.645)*2.-1.;\n    vec2 offset = vec2(h.x*.1,0.);\n    h.y=h.y*.95;\n    h.y*=abs(h.y);\n    vec2 di = vec2(h.y,sqrt(1.-h.y*h.y));\n    float thrust = sqrt(min(t,ExT)/ExT)*25.;\n    vec2 p = offset+duration*(di*thrust+vec2(0.,-9.81)*t)*t;\n    return sqrt(1.-t)*bang(uv-p,max(0.,(t-ExT)/(1.-ExT)),id);\n}\n\n#define NUM_ROCKETS 3.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy*vec2(1.,0.))/iResolution.y;\n    vec3 col = vec3(.01,.011,.015)*0.;\n    \n    float time = .75*iTime;\n    float t = time/duration;\n    uv.y-=.65;\n    uv*=35.;\n    float m = 1.;\n    float d =0.;\n    //water\n    if(uv.y<0.){\n        const float h0 = 5.;\n        const float dcam = 1000.5;\n        \n        float y = uv.y-h0;//translated y position, to add fake earth curvature (horizon not at infinity)\n        \n        float z = dcam*h0/y;//fake depth\n        d=-40.*uv.y/(h0*dcam);\n        \n        float x = uv.x*z/dcam; //parallax-aware x coordinate\n        \n        uv+=vec2(sin((x*1.5+z*.75)*.0005-t*1.5),cos((z*2.-x*.5)*.0005-t*2.69))\n        *(sin(x*.07+z*.09+sin(x*.2-t)-t*15.)+cos(z*.1-x*(.08+.001*sin(x*.01-t))-t*16.)*.7+cos(z*.01+x*.004-t*10.)*1.7)\n        *.15*dcam/z; //waves\n        \n        float ndv = -uv.y/sqrt(dcam*dcam+uv.y*uv.y);\n        m=mix(1.,.98,pow(1.-ndv,5.));//fresnel factor\n        \n        uv.y = -uv.y;\n    }\n    //sky\n    col+=(exp2(-abs(uv.y)*vec3(1.,2.,3.)-.5)+exp2(-abs(uv.y)*vec3(1.,.2,.1)-4.))*.5;\n    \n    //land\n    if(uv.y*1.5<(uv.x-20.)*.01*(-uv.x+90.)+sin(uv.x)*cos(uv.y*1.1)*.75)\n        col*=0.;\n    \n    for(float i = 0.;i<ceil(NUM_ROCKETS);i++){\n        float T = 1.+t+i/NUM_ROCKETS; \n        \n        float id = floor(T)-i/NUM_ROCKETS; //should give a unique integer for each rocket\n        \n        vec3 color = hash31(id*.75645);\n        color/=max(color.r,max(color.g,color.b));//making colors as bright as possible\n\n        col+=firework(uv,fract(T),id)*color;\n    }\n    //col = vec3(1);\n    fragColor = vec4(m*col,1.0);\n    \n    vec4 noise = texture(iChannel0,(fragCoord)/iChannelResolution[0].xy);\n    noise = noise*255./256.+noise.w/256.;\n       //linear dithering to avoid banding (linear means less overshoot for dark pixels, so better contrast)\n    vec4 lcol = clamp(fragColor,0.,1.); //clamp input\n    vec4 gcol = pow(lcol,vec4(1./2.2)); //convert to output gamma space\n\n    vec4 gcol_f = floor(gcol*255.)/255.; //floor to get the lower bound\n\n    vec4 lcol_f = pow(     gcol_f         ,vec4(2.2)); // convert the lower bound to linear\n    vec4 lcol_c = pow(ceil(gcol*255.)/255.,vec4(2.2)); // ceil to get the upper bound, convereted to linear\n\n    vec4 x = (lcol-lcol_f)/(lcol_c-lcol_f); // get x such as lcol_f + x*(lcol_c-lcol_f) == lcol\n\n    // compare x to the noise to chose what bounding value should be selected (in gamma space)\n    fragColor = gcol_f+step(noise,x)/255.;\n    fragColor.a = d;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}