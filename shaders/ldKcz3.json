{
    "Shader": {
        "info": {
            "date": "1527199770",
            "description": "ICtCp color space showing the BT.2020 color gamut.\nI used this shadertoy to generate a diagram for my Digital Dragons 2018 talk.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ldKcz3",
            "likes": 13,
            "name": "BT.2020 in ICtCp",
            "published": 3,
            "tags": [
                "bt2020",
                "ictcp"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 1573
        },
        "renderpass": [
            {
                "code": "// BT.2020 in ICtCp\n// @P_Malin\n// https://www.shadertoy.com/view/ldKcz3\n\n// ICtCp color space showing the BT.2020 color gamut.\n// I used this shadertoy to generate a diagram for my Digital Dragons 2018 talk.\n// https://www.youtube.com/watch?v=EN1Uk6vJqRw\n// https://research.activision.com/t5/Publications/HDR-in-Call-of-Duty/ba-p/10744846\n\n#define DRAW_AXIS_LABELS 1\n\n#define SHOW_BT709 0\n\n\n#if FONT_PRINTING\n#define iChannelFont iChannel0\n#endif\n\n\n// Hack to speed up compilation on Shadertoy\n#define NO_UNROLL(X) (X + min(0,iFrame))\n#define NO_UNROLLF(X) (X + min(0.0f,float(iFrame)))\n#define NO_UNROLLU(X) (X + uint(min(0,iFrame)))\n\nfloat Linear_to_sRGB( float linearValue )\n{\n\tfloat sRGBValue = ( linearValue <= 0.0031308f ) ? 12.92f * linearValue : 1.055f * pow( linearValue, 1.0f/2.4f ) - 0.055f;\n\treturn sRGBValue;\n}\n\nvec3 Linear_to_sRGB( vec3 linearValues )\n{\n\tvec3 sRGBValues;\n    sRGBValues.r = Linear_to_sRGB( linearValues.r );\n    sRGBValues.g = Linear_to_sRGB( linearValues.g );\n    sRGBValues.b = Linear_to_sRGB( linearValues.b );\n    \n\treturn sRGBValues;\n}\n\nconst float PQ_C1 = 0.8359375f;\t\t\t// 3424.f / 4096.f;\nconst float PQ_C2 = 18.8515625f;\t\t// 2413.f / 4096.f * 32.f;\nconst float PQ_C3 = 18.6875f;\t\t\t// 2392.f / 4096.f * 32.f;\nconst float PQ_M1 = 0.159301758125f;\t// 2610.f / 4096.f / 4;\nconst float PQ_M2 = 78.84375f;\t\t\t// 2523.f / 4096.f * 128.f;\n\n#define PQ_MAX 10000.0f\n\n\n// PQ_OETF - Optical-Electro Transfer Function \n\nfloat Linear_to_PQ( float linearValue )\n{\n\tfloat L = linearValue / PQ_MAX;\n\tfloat Lm1 = pow( L, PQ_M1 );\n\tfloat X = ( PQ_C1 + PQ_C2 * Lm1 ) / ( 1.0f + PQ_C3 * Lm1 );\n\tfloat pqValue = pow( X, PQ_M2 );\n\treturn pqValue;\n}\n\nvec3 Linear_to_PQ( vec3 linearValues )\n{\n\tvec3 L = linearValues / PQ_MAX;\n\tvec3 Lm1 = pow( L.xyz, vec3( PQ_M1 ) );\n\tvec3 X = ( PQ_C1 + PQ_C2 * Lm1 ) / ( 1.0f + PQ_C3 * Lm1 );\n\tvec3 pqValues = pow( X, vec3( PQ_M2 ) );\n\treturn pqValues;\n}\n\n// PQ_EOTF - Electro-Optical Transfer Function \n\nfloat PQ_to_Linear( float pqValue )\n{\n\tfloat M = PQ_C2 - PQ_C3 * pow( pqValue, 1.0 / PQ_M2 );\n\tfloat N = max( pow( pqValue, 1.0f / PQ_M2 ) - PQ_C1, 0.0f );\n\tfloat L = pow( N / M, 1.0f / PQ_M1 );\n\tfloat linearValue = L * PQ_MAX;\n\treturn linearValue;\n}\n\nvec3 PQ_to_Linear( vec3 pqValues )\n{\n\tvec3 M = PQ_C2 - PQ_C3 * pow( pqValues, vec3(1. / PQ_M2) );\n\tvec3 N = max( pow( pqValues, vec3(1.0f / PQ_M2) ) - PQ_C1, 0.0f );\n\tvec3 L = pow( N / M, vec3(1.0f / PQ_M1) );\n\tvec3 linearValues = L * PQ_MAX;\n\treturn linearValues;\n}\n\n\n// BT.709 <-> BT.2020 Primaries\n\nvec3 Primaries_BT709_to_BT2020( vec3 linearBT709 )\n{\n\tvec3 linearBT2020 = linearBT709.rgb * \n        mat3(\n            0.6274,    0.3293,    0.0433,\n            0.0691,    0.9195,    0.0114,\n            0.0164,    0.0880,    0.8956\n        );\n\treturn linearBT2020;\n}\n\nvec3 Primaries_BT2020_to_BT709( vec3 linearBT2020 )\n{\n\tvec3 linearBT709 =  linearBT2020.rgb * \n    \tmat3 (\n             1.6605,\t-0.5877,\t-0.0728,\n            -0.1246,\t 1.1330,\t-0.0084,\n            -0.0182,\t-0.1006,\t 1.1187\n        );\n\treturn linearBT709;\n}\n\n// LMS <-> BT2020\n\nvec3 Primaries_BT2020_to_LMS( vec3 linearBT2020 )\n{\n\tfloat R = linearBT2020.r;\n\tfloat G = linearBT2020.g;\n\tfloat B = linearBT2020.b;\n\n    float L = 0.4121093750000000f * R + 0.5239257812500000f * G + 0.0639648437500000f * B;\n    float M = 0.1667480468750000f * R + 0.7204589843750000f * G + 0.1127929687500000f * B;\n    float S = 0.0241699218750000f * R + 0.0754394531250000f * G + 0.9003906250000000f * B;\n\n\tvec3 linearLMS = vec3(L, M, S);\n\treturn linearLMS;\n}\n\nvec3 Primaries_LMS_to_BT2020( vec3 linearLMS )\n{\n\tfloat L = linearLMS.x;\n\tfloat M = linearLMS.y;\n\tfloat S = linearLMS.z;\n\n\tfloat R =  3.4366066943330793f * L - 2.5064521186562705f * M + 0.0698454243231915f * S;\n\tfloat G = -0.7913295555989289f * L + 1.9836004517922909f * M - 0.1922708961933620f * S;\n    float B = -0.0259498996905927f * L - 0.0989137147117265f * M + 1.1248636144023192f * S;\n\n\tvec3 linearBT2020 = vec3(R, G, B);\n\treturn linearBT2020;\n}\n\n\n// Misc. Color Space Conversion\n\n// ICtCp <-> PQ LMS\n\nvec3 PQ_LMS_to_ICtCp( vec3 PQ_LMS )\n{\n\tfloat L = PQ_LMS.x;\n\tfloat M = PQ_LMS.y;\n\tfloat S = PQ_LMS.z;\n\n    float I  = 0.5f * L + 0.5f * M;\n    float Ct = 1.613769531250000f * L - 3.323486328125000f * M + 1.709716796875000f * S;\n    float Cp = 4.378173828125000f * L - 4.245605468750000f * M - 0.132568359375000f * S;\n\n\tvec3 ICtCp = vec3(I, Ct, Cp);\n\treturn ICtCp;\n}\n\nvec3 ICtCp_to_PQ_LMS( vec3 ICtCp )\n{\n\tfloat I  = ICtCp.x;\n\tfloat Ct = ICtCp.y;\n\tfloat Cp = ICtCp.z;\n\n\tfloat L = I + 0.00860903703793281f * Ct + 0.11102962500302593f * Cp;\n\tfloat M = I - 0.00860903703793281f * Ct - 0.11102962500302593f * Cp;\n\tfloat S = I + 0.56003133571067909f * Ct - 0.32062717498731880f * Cp;\n\n\tvec3 PQ_LMS = vec3(L, M, S);\n\treturn PQ_LMS;\n}\n\n// Linear BT2020 <-> ICtCp\n// \n// https://www.dolby.com/us/en/technologies/dolby-vision/ictcp-white-paper.pdf\n// http://www.jonolick.com/home/hdr-videos-part-2-colors\n\nvec3 LinearBT2020_to_ICtCp( vec3 linearBT2020 ) \n{\n\tvec3 LMS = Primaries_BT2020_to_LMS( linearBT2020 );\n\tvec3 PQ_LMS = Linear_to_PQ( LMS );\n\tvec3 ICtCp = PQ_LMS_to_ICtCp( PQ_LMS );\n\n\treturn ICtCp;\n}\n\nvec3 ICtCp_to_LinearBT2020( vec3 ICtCp )\n{\n\tvec3 PQ_LMS = ICtCp_to_PQ_LMS( ICtCp );\n\tvec3 LMS = PQ_to_Linear( PQ_LMS );\n\tvec3 linearBT2020 = Primaries_LMS_to_BT2020( LMS );\n\treturn linearBT2020;\n}\n\n\n\n\n\n\n\n\n\n\nstruct DrawContext\n{\n    vec2 vUV;\n    vec3 vResult;\n    float fEdgeFade;\n};\n\nDrawContext DrawContext_Init( vec2 vUV, vec3 vClearColor )\n{\n    vec2 vA = fwidth( vUV );\n    float fEdgeFade = 1.0 / max(abs(vA.x), abs(vA.y));\n    return DrawContext( vUV, vClearColor, fEdgeFade );\n}\n\nbool DrawContext_OnCanvas( DrawContext drawContext )\n{\n    vec2 vUV = drawContext.vUV;\n    if ( (vUV.x >= 0.0f) && (vUV.y >= 0.0f) && (vUV.x < 1.0f) && (vUV.y < 1.0f) ) \n    {    \n    \treturn true;\n    }\n    return false;\n}\n    \nfloat LineSmooth( DrawContext drawContext, float fDist, float fThickness )\n{\n    return clamp( (fThickness - fDist) * drawContext.fEdgeFade, 0.0, 1.0 );\n}\n\nfloat LineInfo( vec2 vUV, vec2 vA, vec2 vB, out vec2 vClosest )\n{\n    vec2 vDir = vB - vA;\n\n    float fLen = length(vDir);\n\n    float fDist = 10000.0;\n    float fSide = -1.0;\n    \n    float fEpsilon = 0.002f;\n    \n    if ( fLen < fEpsilon )\n    {\n        vClosest = vA;\n    }\n    else\n    {\n        vDir /= fLen;            \n        vec2 vOffset = vUV - vA.xy;            \n\n        float cp = vDir.x * vOffset.y - vDir.y * vOffset.x;\n        if ( cp > 0.0f )\n        {\n            fSide = 1.0;\n        }\n\n        float d = dot( vDir, vOffset );\n        d = clamp( d, 0.0, fLen );\n        vClosest = vA + vDir * d;\n    }  \n    fDist = length( vClosest - vUV );\n    \n    return fDist * fSide;\n}\n\n\nfloat LineInfo( vec2 vUV, vec2 vA, vec2 vB )\n{\n    vec2 vClosestUnused;\n    return LineInfo( vUV, vA, vB, vClosestUnused );\n}\n\nvoid DrawBlend( inout DrawContext drawContext, vec3 vColor, float fBlend )\n{\n    drawContext.vResult = mix( drawContext.vResult, vColor, clamp( fBlend, 0.0, 1.0 ) );\n}\n\nvoid DrawOutlinePoint( inout DrawContext drawContext, vec3 vOutlineColor, vec3 vColor, vec2 vPos, float fStrokeThickness, float fOutlineThickness )\n{\n    float fDist = length( drawContext.vUV - vPos );\n    \n    DrawBlend( drawContext, vOutlineColor, LineSmooth( drawContext, fDist, fStrokeThickness + fOutlineThickness) );\n    DrawBlend( drawContext, vColor, LineSmooth( drawContext, fDist, fStrokeThickness ) );  \n}\n\nvoid DrawRect( inout DrawContext drawContext, vec3 vColor, vec2 vA, vec2 vB )\n{\n    vec2 vUV = drawContext.vUV;\n    \n    if ( (vUV.x >= vA.x) && (vUV.y >= vA.y) && (vUV.x < vB.x) && (vUV.y < vB.y) ) \n    {    \n    \tdrawContext.vResult = vColor;\n    }\n}\n\nvoid DrawLine( inout DrawContext drawContext, vec3 vColor, vec2 vA, vec2 vB, float fThickness )\n{\n    DrawBlend( drawContext, vColor, LineSmooth( drawContext, abs(LineInfo( drawContext.vUV, vA, vB )), fThickness ) );\n}\n\nvoid DrawGrid( inout DrawContext drawContext )\n{\n    float fDivisions = 10.0;\n    // Grid lines\n    for ( float f = 0.0f; f < 1.0f; f += 1.0 / fDivisions )\n    {\n\t    DrawLine( drawContext, vec3(0.8), vec2(f,0), vec2(f, 1), 0.002f );    \n    \tDrawLine( drawContext, vec3(0.8), vec2(0,f), vec2(1, f), 0.002f );    \n    }\n    \n    // Diagonal\n    //DrawLine( drawContext, vec3(0.7), vec2(1,0), vec2(0, 1), 0.001f );    \n    \n    // Grid Axes\n    DrawLine( drawContext, vec3(0.5f), vec2(0,0), vec2(1.0, 0.0), 0.003f );\n    DrawLine( drawContext, vec3(0.5f), vec2(0,0), vec2(0.0, 1.0), 0.003f );            \n}\n\n\nvoid DrawICtCp( inout DrawContext drawContext )\n{        \n#if FONT_PRINTING\n    LayoutStyle style = LayoutStyle_Default();\n    style.vSize = vec2(0.03, 0.05);\n    RenderStyle renderStyle = RenderStyle_Default( vec3(0.0) );\n    \n    vec2 vPrintUV = vec2( drawContext.vUV.x, 1.0f - drawContext.vUV.y );\n    PrintState state = PrintState_InitCanvas( vPrintUV, fwidth(drawContext.vUV) );\n#endif \n    \n    bool drawPrimaryPoints = true;\n    vec3 drawPrimaryColor = vec3(0.0, 0.0, 0.0);    \n     \n    DrawRect( drawContext, vec3(0.9), vec2(0), vec2(1.0) );    \n\n    DrawGrid( drawContext );\n        \n    #if DRAW_AXIS_LABELS\n\t    style.vSize = vec2(0.03, 0.04);    \t\n    \n    \n    \tMoveTo( state, vec2( 0.0 - 0.01, 1.03 ) );\n\t    Print( state, style, iChannelFont, -1.0f, 1 );\n\n    \tMoveTo( state, vec2( 1.0 - 0.01, 1.03 ) );\n\t    Print( state, style, iChannelFont, 1.0f, 1 );\n    \n\n    \tMoveTo( state, vec2( 0.0 - 0.05, 1.0 + 0.005 ) );\n\t    Print( state, style, iChannelFont, -1.0f, 1 );\n\n    \tMoveTo( state, vec2( 0.0 - 0.05, 0.0 + 0.005 ) );\n\t    Print( state, style, iChannelFont, 1.0f, 1 );\n    \n    \n    \n    \tstyle.bItalic = true;\n    \tstyle.bBold = true;\n    \n    \tMoveTo( state, vec2( 0.5 - 0.01, 1.035 ) );\n\t    PrintCh( state, style, iChannelFont, _C );\n    \tstate.vCursorPos.y += 0.01;\n\t    PrintCh( state, style, iChannelFont, _T );\n    \n    \tMoveTo( state, vec2( -0.05, 0.5 + 0.005 ) );\n\t    PrintCh( state, style, iChannelFont, _C );\n    \tstate.vCursorPos.y += 0.01;\n\t    PrintCh( state, style, iChannelFont, _P );\n    \n    \tstyle.bBold = false;\n    \tstyle.bItalic = false;\n        \n\t#endif    \n    \n    vec3 vICtCp = vec3(1.0, drawContext.vUV - 0.5);\n    \n    vec3 vColor2020 = ICtCp_to_LinearBT2020( vICtCp );\n    \n#if SHOW_BT709\n   \tvec3 vColor709 = Primaries_BT2020_to_BT709(vColor2020);\n    vColor709 = vColor709 / max( max( vColor709.r, vColor709.g ), vColor709.b );\n    float minDist = min( vColor709.x, min( vColor709.y, vColor709.z ) );\n#else    \n    vColor2020 = vColor2020 / max( max( vColor2020.r, vColor2020.g ), vColor2020.b );\n   \tvec3 vColor709 = Primaries_BT2020_to_BT709(vColor2020);\n    float minDist = min( vColor2020.x, min( vColor2020.y, vColor2020.z ) );\n#endif\n    \n    \n            \n    vec3 vColorOut = Linear_to_sRGB( vColor709 );\n    if ( minDist >= 0.0 )\n    {\n        drawContext.vResult = vColorOut;\n    }\n\n    style.vSize = vec2(0.05, 0.08);\n    \n    vec2 vPos = vec2(0.2, 0.9 );\n    MoveTo( state, vec2(vPos.x, vPos.y ) );\n\n#if SHOW_BT709\n    uint str[] = uint[] ( _B, _T, _PERIOD, _7, _0, _9, _SP, _i, _n, _SP );\n#else    \n    uint str[] = uint[] ( _B, _T, _PERIOD, _2, _0, _2, _0, _SP, _i, _n, _SP );\n#endif    \n    \n    ARRAY_PRINT( state, style, iChannelFont, str );      \n\n    PrintCh( state, style, iChannelFont, _I );\n    PrintCh( state, style, iChannelFont, _C );\n    state.vCursorPos.y += 0.02;\n    style.vSize *= 0.75;\n    PrintCh( state, style, iChannelFont, _T );\n    style.vSize /= 0.75;\n\tstate.vCursorPos.y -= 0.02;\n    PrintCh( state, style, iChannelFont, _C );\n    state.vCursorPos.y += 0.02;\n    style.vSize *= 0.75;\n    PrintCh( state, style, iChannelFont, _P );\n    \n#if FONT_PRINTING\n\tRenderFont( state, style, renderStyle, drawContext.vResult );\n#endif\n    \n}\n\nvec3 MainDraw( vec2 vFragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vUV = vFragCoord/iResolution.xy;\n\n    float fScale = 1.1;\n    \n    // scale down around centre of square\n    vec2 vDiagramUV = (vUV - 0.5) * fScale + 0.5;\n    \n    // aspect ratio adjust\n    vDiagramUV.x *= iResolution.x / iResolution.y;\n        \n    \n    // centre image horizontally\n    vDiagramUV.x += (1.0 - (iResolution.x / iResolution.y)) / 2.0;\n    \n    vec3 vClearColor = vec3( 1.0 );\n    DrawContext drawContext = DrawContext_Init( vDiagramUV, vClearColor );\n    \n    DrawICtCp( drawContext );\n    \n    // Output to screen\n    return drawContext.vResult;    \n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    int AA = 4;\n    \n    vec4 vTotal = vec4(0.0);\n    \n    for( int iY = 0; iY < AA; iY++ )\n    {\n        for( int iX = 0; iX < AA; iX++ )            \n        {\n            vec2 vSampleCoord = vFragCoord + vec2( iX, iY ) / float(AA);\n            vec3 vColor = MainDraw( vSampleCoord );\n            vTotal += vec4( vColor, 1.0 );\n        }\n    }\n    \n    vec3 vResult = vTotal.rgb / vTotal.w;\n    \n    // Output to screen\n    vFragColor = vec4( vResult, 1.0f );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define FONT_PRINTING 1\n\n\n\n\n\n#if FONT_PRINTING\n\n///////////////////////////\n// Rect\n///////////////////////////\n\nstruct Rect\n{\n    vec2 vPos;\n    vec2 vSize;\n};      \n\nbool Inside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return all( greaterThanEqual( vPos, vMin ) ) && all( lessThan( vPos, vMax ) );\n}\n\nbool Outside( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    return any( lessThan( vPos, vMin ) ) || any( greaterThanEqual( vPos, vMax ) );\n}\n\nbool Inside( vec2 vPos, Rect rect )\n{\n    return Inside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n    \nbool Outside( vec2 vPos, Rect rect )\n{\n    return Outside( vPos, rect.vPos, rect.vPos + rect.vSize );\n}\n\nvoid RectExpand( inout Rect region, vec2 vPadding )\n{\n    // Padding\n    region.vPos -= vPadding;\n    region.vSize += vPadding * 2.0;        \n}\n\nvoid RectShrink( inout Rect region, vec2 vPadding )\n{\n    RectExpand( region, -vPadding);\n}\n\n///////////////////////////\n// Font\n///////////////////////////\n\n// Font printing based on https://www.shadertoy.com/view/ldfcDr\n\n#define AUTO_FONT_SPACING\n//#define HANDLE_EOL\n#define HANDLE_PRINT_STYLES\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au\n\n\t,_LCUB = 0x7Bu\t\t// '{'\n    ,_VERBAR = 0x7Cu\t// '|'\n    ,_RCUB = 0x7Du\t\t// '}'\n    ,_TILDE = 0x7Eu\t\t// '~'\n    \n#ifdef HANDLE_EOL       \n    ,_EOL = 0x1000u \t// End of Line - Carriage Return & Line Feed    \n#endif    \n#ifdef HANDLE_PRINT_STYLES    \n    ,_BOLDON = 0x1001u\t// Special\n    ,_BOLDOFF = 0x1002u\t// Special\n    ,_ITALON = 0x1003u\t// Special\n    ,_ITALOFF = 0x1004u\t// Special    \n#endif    \n;\n\n\nvec4 SampleCharacterTex( sampler2D sFontSampler, uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( sFontSampler, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( sampler2D sFontSampler, uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n    // Skip texture sample when not in character boundary\n    // Ok unless we have big font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( sFontSampler, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n        \n    return vSample;\n}\n\n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos( sampler2D sFontSampler, uint iChar, vec2 vUV ) \n{\n    vec4 vSample = SampleCharacterTex(sFontSampler, iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( sampler2D sFontSampler, uint iChar )\n{\n    CharExtents result;\n\n    result.left = CharVerticalPos( sFontSampler, iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( sFontSampler, iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vPixelPos;\n    \n    vec2 vLayoutStart;\n    // print position\n    vec2 vCursorPos;\n    vec2 vPixelSize;\n\n#ifdef HANDLE_EOL\n    bool EOL;\n#endif\n\n    // result\n    float fDistance;\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vLayoutStart = vPos;\n    state.vCursorPos = vPos;\n#ifdef HANDLE_EOL\n    state.EOL = false;\n#endif\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;   \n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vPixelPos = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n#ifdef HANDLE_PRINT_STYLES    \n    bool bItalic;\n    bool bBold;  \n#endif    \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(24.0f, 32.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n#ifdef HANDLE_PRINT_STYLES    \n    style.bItalic = false;\n    style.bBold = false;       \n#endif    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;   \n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f;  \n    return style;\n}\n\nconst float g_fFontDescent = 0.15f;\nconst float g_fFontAscent = 0.65f;\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vCursorPos.x = state.vLayoutStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n\tstate.vCursorPos.y += style.vSize.y * g_fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n\tstate.vCursorPos.y += style.vSize.y * (g_fFontAscent + style.fLineGap);\n}\n\n#ifdef HANDLE_EOL\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n#endif\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, sampler2D sFontSampler, const uint iChar )\n{\n#ifdef HANDLE_EOL\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n#endif\n#ifdef HANDLE_PRINT_STYLES            \n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n#endif\n    \n#ifdef HANDLE_EOL\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n#endif\n    \n    vec2 vUV = ((state.vPixelPos - state.vCursorPos) / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( sFontSampler, iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n#endif\n    \n    vec3 v = SampleCharacter( sFontSampler, iChar, vUV ).agb;\n\n#ifdef HANDLE_PRINT_STYLES    \n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n#endif    \n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;       \n    }\n    \n    state.vCursorPos.x += style.vSize.x * (extents.width + style.fAdvancement);\n}\n\n\nRect GetFontRect( PrintState state, LayoutStyle style, bool initialLineOffset )\n{\n    Rect rect;\n    \n    rect.vPos = state.vLayoutStart;\n    if ( initialLineOffset )\n    {\n    \trect.vPos.y += style.vSize.y * (style.fLineGap + g_fFontAscent);\n    }\n\trect.vPos.y -= style.vSize.y * (g_fFontAscent);\n    rect.vSize.x = state.vCursorPos.x - state.vLayoutStart.x;\n    rect.vSize.y = style.vSize.y * ( g_fFontAscent + g_fFontDescent );\n    \n    return rect;\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( PrintState state, LayoutStyle style, RenderStyle renderStyle, inout vec3 color )\n{   \n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n\n    vec3 vCol = renderStyle.vFontColor;\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n// Font print helpers\n\n// need to find a way to do this from common\nint NO_UNROLL(int X) { return X; }\nuint NO_UNROLLU(uint X) { return X; }\n\n#define ARRAY_PRINT( STATE, STYLE, SAMPLER, CHAR_ARRAY ) { for (int i=0; i< NO_UNROLL( CHAR_ARRAY.length() ); i++) PrintCh( STATE, STYLE, SAMPLER, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > NO_UNROLLU( 0u ) )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, sFontSampler, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, sFontSampler, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, sFontSampler, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, sampler2D sFontSampler, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, sFontSampler, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= NO_UNROLL( -decimalPlaces ) )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place;\n        \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, sFontSampler, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, sFontSampler, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n#endif ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}