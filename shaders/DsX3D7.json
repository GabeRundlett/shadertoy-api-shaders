{
    "Shader": {
        "info": {
            "date": "1666203432",
            "description": "Raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "DsX3D7",
            "likes": 3,
            "name": "Raymarching spehres",
            "published": 3,
            "tags": [
                "raymarching",
                "chaos"
            ],
            "usePreview": 0,
            "username": "Aaras",
            "viewed": 189
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define PI 3.1415926535897932384626433832795\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST .1\n#define SUN vec3(-5.0, 10.0, -5.0)\n#define ZOOM 1.0\n#define DISTANCE 5.0\n#define EPSILON .1\n\nmat2 Rot(float a)\n{\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\nfloat Sphere(vec3 p, vec3 o, float radius)\n{\n  return length(p - o) - radius ;\n}\nfloat Plane(vec3 p, float h)\n{\n  return p.y - h;\n}\nfloat Box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat Cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = dot(pa,ba)/dot(ba,ba);\n  return length( pa - ba*h ) - r;\n}\nvec3 RandomVector(float i) {\n    return normalize(vec3(sin(329.34+131.8*sin(722.1*i+8.23)),\n                            sin(494.34+2871.1*sin(431.1*i+415.39)),\n                            sin(757.34+9539.1*sin(161.1*i+201.39)))\n                );\n}\nfloat SmoothMin(float a, float b)\n{\n    float k = 3.0;\n    float h = pow( max( (k-abs(a-b))/k , 0.0), 3.0) * k / 6.0;\n    return min(a,b) - h;\n}\nfloat GetDist(vec3 p)\n{\n  float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;\n  p += displacement;\n  \n  float dSphere = Sphere(p, vec3(0.0, 0.0, 0.0), 2.0 + (sin(iTime*2.0) * 0.5));\n  \n  float d = dSphere;\n  \n  for(float i = 0.0; i < 3.0; i += 0.1)\n  {\n      vec3 pos = RandomVector(i) + vec3(sin(iTime+i*4.0));\n      float off = sin(iTime*5.0 + floor(i*4.0)) * 0.5 + 1.5;\n      pos *= off*2.0;\n      float dSmallSphere = Sphere(p, pos, 0.1);\n      \n      d = SmoothMin(d, dSmallSphere);\n  }\n  \n  return d;\n}\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\n  float dO = 0.0;\n  float d;\n  float minD = 10000.0;\n  vec3 p;\n  for(int i = 0; i < MAX_STEPS; i++)\n  {\n    p = ro + rd * dO;\n    d = GetDist(p);\n    if(d < minD)\n      minD = d;\n    dO += d;\n    if(abs(dO) < SURF_DIST || dO > MAX_DIST)\n      break;\n  }\n  return vec2(dO, minD);\n\n}\nvec3 GetNormal(vec3 p)\n{\n  vec2 e = vec2(.01, .0);\n  float d = GetDist(p);\n  vec3 n = vec3(\n    d - GetDist(p - vec3(e.xyy)),\n    d - GetDist(p - vec3(e.yxy)),\n    d - GetDist(p - vec3(e.yyx))\n  );\n\n  \n  return normalize(n);\n}\n\nfloat GetShadow(vec3 p, vec3 s)\n{\n  float d = RayMarch(p, s).x;\n  float ds = length(SUN - p);\n\n  return step(EPSILON, d - ds);\n}\nfloat GetLight(vec3 p)\n{\n  if ( length(p) > MAX_DIST / 2.0 )\n    return 0.0; \n  \n  vec3 s = normalize(SUN - p);\n  vec3 n = GetNormal(p);\n\n\n  float l = dot(n, s);\n  l = clamp(l, 0.0, 1.0);\n\n  p += n * SURF_DIST * 3.0;\n  float sh = 1.0;GetShadow(p, s) + .1;\n\n\n  return l * sh;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  \n  vec3 c = vec3(0.0);\n  \n  vec3 ro = vec3(0, 4, -5);\n  ro.yz *= Rot(sin(iTime) * .1);\n  ro.xz *= Rot(sin(iTime / 2.0)*PI/ 2.0);\n  \n  vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n\n  vec2 d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d.x;\n\n\n\n  c = vec3(abs(GetLight(p) + 0.5)) / 1.5;// + GetNormal(p)) * 0.5;\n\n  //c = GetNormal(p) *  pow ( ((GetLight(p) + .2) / 1.2), 2.0);\n    c *= uv.xyx + vec3(0.5);\n  fragColor = vec4(c, 1.0);\n\n  if(d.x > MAX_DIST)\n    fragColor = vec4(0.1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}