{
    "Shader": {
        "info": {
            "date": "1574793987",
            "description": "If no scrambling matrix is used between scales (i.e. original Perlin noise), the noise is exactly 0 on grid vertex (green isocurve).\nThis can be used to stochastically interpolate a mesh or polyline, still passing through control points.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wdKXzd",
            "likes": 32,
            "name": "Perlin noise vs interpolation",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "noise",
                "perlin",
                "gradient",
                "flownoise"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1184
        },
        "renderpass": [
            {
                "code": "// see also the curve cases: https://www.shadertoy.com/view/WdGXWG\n//                           https://www.shadertoy.com/view/WsGXDy\n\n// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z = 1.;\nvec2 hash( vec2 x ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(x.x+x.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(x.x)+floor(x.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                      // flow noise universal rotation direction\n    s *= iTime;                        // same rotation speed at all scales\n // s *= iTime/ _z;                    // rotation speed increase with small scale    \n    const vec2 k = vec2( .3183099, .3678794 );\n    x = x*k + k.yx + 5.;\n    return ( -1. + 2.*fract( 16. * k*fract( x.x*x.y*(x.x+x.y)) ) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 p )  //fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 4; i++, s /= 2. ) { _z = s; // for flownoise\n        v += s*noise( p ); p *= m;\n    }\n    return v;\n}\n\n// -----------------------------------------------\n\n#define S(v) smoothstep( pix, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u -.5*R ) / R.y * 8., U0=U;\n    O -= O;\n    float pix = 12./R.y;\n    \n    O -= S(abs(U.x));\n    \n\tif( U.x < 0. )          // left: noise\t\n\t\tO += noise( U ) * 1.5;\n    else\t                // right: fractal noise\n\t\tO += perlin(U);\n\n    O.r += S(fract(U0.x));  // grid\n    O.r += S(fract(U0.y));\n    O.g += S( abs(O.x) );   // isoline 0\n\n\tO = .5 + .5*O;\n    O = mix(O, vec4(0,.5,0,1), S (length(fract(U0-.5)-.5)-.05) ); // grid vertices\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}