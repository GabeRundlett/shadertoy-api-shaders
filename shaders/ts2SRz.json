{
    "Shader": {
        "info": {
            "date": "1552772645",
            "description": "Felt like metaballs again... with a retro-style non-realistic shading. Could use some Tron-esque glow. Bumps in floor come from 2D-simplex-noise. Also here on github... https://bit.ly/2W6KsvT",
            "flags": 64,
            "hasliked": 0,
            "id": "ts2SRz",
            "likes": 12,
            "name": "Retro-styled metaballs",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sound",
                "metaballs",
                "spheretracing",
                "nonrealistic"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 781
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Retro-styled non-realistic metaballs with iteration glow.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .001;\nconst int MAX_ITER = 48;\nconst float STEP_BIAS = 1.1;\n\nmat2 r2d (in float a) {\n\tfloat c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (vec2(c, s), vec2(-s, c));\n}\n\nfloat opCombine (in float d1, in float d2, in float r)\n{\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (35.);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        p *= rot;\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat scene (in vec3 p) {\n\tfloat t = 2.*iTime;\n    vec3 pBottom = p;\n    pBottom.x += 3.*iTime;\n    float bottom = pBottom.y + 1. + .25*fbm(pBottom.xz, 4);\n\n    float t4 = 2. * iTime;\n    float t5 = 2.5 * iTime;\n    float t6 = 1.75 * iTime;\n    float t7 = 2.5 * iTime;\n    float r1 = .1 + .3 * (.5 + .5 * sin (2.*t4));\n    float r2 = .1 + .25 * (.5 + .5 * sin (3.*t5));\n    float r3 = .1 + .3 * (.5 + .5 * sin (4.*t6));\n    float r4 = .1 + .25 * (.5 + .5 * sin (5.*t7));\n\n    float t1 = 1.5 * iTime;\n    float t2 = 2. * iTime;\n    float t3 = 2.5 * iTime;\n    vec3 offset1 = vec3 (-.1*cos(t1), .1, -.2*sin(t2));\n    vec3 offset2 = vec3 (.2, .2*cos(t2), .3*sin(t3));\n    vec3 offset3 = vec3 (-.2*cos(t3), -.2*sin(t3), .3);\n    vec3 offset4 = vec3 (.1, -.4*cos(t2), .4*sin(t2));\n    vec3 offset5 = vec3 (.4*cos(t1), -.2, .3*sin(t1));\n    vec3 offset6 = vec3 (-.2*cos(t3), -.4, -.4*sin(t1));\n    vec3 offset7 = vec3 (.3*sin(t2), -.6*cos(t2), .6);\n    vec3 offset8 = vec3 (-.3, .5*sin(t3), -.4*cos(t1));\n\n    float ball1 = sdSphere (p + offset1, r4);\n    float ball2 = sdSphere (p + offset2, r2);\n    float metaBalls = opCombine (ball1, ball2, r1);\n\n    ball1 = sdSphere (p + offset3, r1);\n    ball2 = sdSphere (p + offset4, r3);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);\n\n    ball1 = sdSphere (p + offset5, r3);\n    ball2 = sdSphere (p + offset6, r2);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);\n\n    ball1 = sdSphere (p + offset7, r3);\n    ball2 = sdSphere (p + offset8, r4);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);\n\n    vec3 pTop = p;\n    float top = -(pTop.y - 3.);\n\n    return min (metaBalls, min (bottom, top));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd, inout int iter) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec3 p = ro + d * rd;\n        t = scene (p);\n        if (abs (t) < EPSILON * (1. + .125*t)) break;\n        d += t*STEP_BIAS;\n        iter = i;\n    }\n\n    return d;\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d) {\n\tvec3 p = ro + d*rd;\n\tvec3 balls = p;\n\tballs.xz *= r2d (-95.*iTime);\n\tballs.zy *= r2d (63.*iTime);\n\n\n\tfloat floorPhase = cos (45.*p.x);\n\tfloat ballsPhase = cos (75.*balls.z);\n\tfloat floorMask = smoothstep (.01*d, .0025*d, (.5 + .5*floorPhase));\n\tfloat ballsMask = smoothstep (.01*d, .0025*d, (.5 + .5*ballsPhase));\n\tvec3 floorColor = mix (vec3 (.3, .3, 1.), vec3 (.0), 1. - floorMask);\n\tvec3 ballsColor = mix (vec3 (1., .3, .3), vec3 (.0), 1. - ballsMask);\n\n    // don't do material assignment like this, it's a hack and I'm lazy\n\tbool isMetaBalls = (p.y > -.75 && p.y < 1.);\n\n\tfloat brightness = 5. / pow (.25*d*d, 1.75);\n\tballsColor += vec3 (1., .2, .1)*brightness;\n\tfloorColor += vec3 (.1, .2, 1.)*brightness;\n\n\treturn isMetaBalls ? ballsColor : floorColor;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\t    \n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .5*length(fragCoord.xy/iResolution.xy*2. - 1.);\n\n    float angle = radians (300. + 30.*iTime);\n    float dist = 2.5;\n    vec3 ro = vec3 (dist*cos (angle), 2., dist*sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2. + .5*cos (iTime);\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    int iter = 0;\n    float d = raymarch (ro, rd, iter);\n\tfloat fog = 1. / (1. + d*d*.25);\n    float glow = float (iter) / float (MAX_ITER);\n    vec3 p = ro + d * rd;\n\n    vec3 col = shade (ro, rd, d) + pow (glow, 1.05) * vec3 (1.);\n\n    col *= fog;\n    col = col / (1. + col);\n    col *= .8 + .2*pow (16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n    col *= mix (1., .75, .5 + .5*cos (900.*uvRaw.y));\n    col = pow (col, vec3 (1./2.2));\n\n\tfragColor = vec4 (col, 1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 18092,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/demoscenemusic/techno-chip"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}