{
    "Shader": {
        "info": {
            "date": "1581775256",
            "description": "Shader showdown practice, coded in 25mn.",
            "flags": 0,
            "hasliked": 0,
            "id": "tttXD2",
            "likes": 1,
            "name": "Showdown practice",
            "published": 3,
            "tags": [
                "raymarching",
                "kifs"
            ],
            "usePreview": 0,
            "username": "rodgzilla",
            "viewed": 355
        },
        "renderpass": [
            {
                "code": "#define time .7 * iTime\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c); \n}\n\nvec3 kifs(vec3 p) {\n    float s = 5.;\n    float t = floor(time) + smoothstep(.3, .7, fract(time));\n    \n    for (float i = 0.; i < 5.; i++) {\n        p.xy *= rot2d(t);\n        p.yz *= rot2d(.9 * t + i * .7);\n        p = abs(p);\n        p -= s;\n        s *= .6 + .2 * sin(time / 1.5);\n//        s *= .8 +;\n    }\n    \n    return p;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p = kifs(p);\n    \n    float d = 5000.;\n   \td = min(d, sph(p, 1.));\n\n    vec3 shift = vec3(1.5 + sin(time * 5.), 0, 0);\n    shift.xy *= rot2d(time * .4);\n    shift.yz *= rot2d(time * .6);\n    d = min(d, sph(p + shift, 1. + .3 * cos(time * .7)));\n    \n    at += .05 / (.1 + d);\n    \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < 0.01 || ds > 100.) {\n            break;\n        }\n        \n        d += ds;\n        glow += .015 * at * vec3(.8, .5 * sin(time / 1.) + .5, .5 * cos(time / 5.) + .5);\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    ));\n  \n   return n;                 \n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(0, 0, -80);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0, 0, -60);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n\tvec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    vec3 col = dif * glow;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}