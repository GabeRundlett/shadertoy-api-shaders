{
    "Shader": {
        "info": {
            "date": "1570531194",
            "description": "A late shadertober. I wanted to create someting with grass and fairies.",
            "flags": 64,
            "hasliked": 0,
            "id": "WsG3zV",
            "likes": 5,
            "name": "Shadertober 07 Enchanted",
            "published": 3,
            "tags": [
                "raymarching",
                "grass",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 441
        },
        "renderpass": [
            {
                "code": "#define VOLUME 0.001\n#define PI 3.14159\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat opU(float s1, float s2) { return min(s1, s2);}\n\nvec2 opU2(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c)-0.5*c;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n\n\n\nfloat grass(vec3 p, float h, float r)\n{\n    \n    float t = sdSphere(p+vec3(0.0, -h, 0.0), r);\n    t = opU(t, sdVerticalCapsule(p, h, r*.5));\n    \n    return t;\n}\n\nvec2 map(vec3 pos)\n{\n    vec2 t = vec2(0.0,0.0);\n    \n    t.x = pos.y;\n    \n    // grass\n    float glp = max(2.0-length(pos)*.5, 0.0);\n    \n    vec3 gpos = pos + vec3(0.0, 0.0, 0.0);\n    gpos = opRep(gpos, vec3(.7, 0.0, .6));\n    vec2 gra = vec2(grass(gpos, glp+.5, glp*.15), 0.0);\n    \n    gpos = pos + vec3(0.2, 0.0, 0.0);\n    gpos.y += .5;\n    gpos = opRep(gpos, vec3(.7, 0.0, .6));\n    gra = opU2(gra, vec2(grass(gpos, glp+.5, glp*.15), 0.0));\n    \n    gpos = pos + vec3(-0.2, 0.0, 0.2);\n    gpos.z += .2;\n    gpos = opRep(gpos, vec3(.7, 0.0, .6));\n    gra = opU2(gra, vec2(grass(gpos, glp+.5, glp*.15), 0.0));\n    \n    gpos = pos + vec3(-0.1, 0.0, 0.3);\n    gpos.x += .4;\n    gpos = opRep(gpos, vec3(.7, 0.0, .6));\n    gra = opU2(gra, vec2(grass(gpos, glp+.5, glp*.15), 0.0));\n    \n    // fee du cul\n    float fTime = fract(iTime*.5);\n    vec3 fpos = pos + vec3(sin(iTime*5.), (-1.0*fTime*10.0)+.5, sin(iTime*3.));\n    vec2 fairy = vec2(sdSphere(fpos, (1.0-fTime)*.25), 1.0);\n    \n    for(int i=0;i<5;i++)\n    {\n        float ti = float(i);\n        fpos = pos + vec3(-0.0, 0.0, -2.0) + vec3(sin(ti)*2.0, 0.5, ti);\n        fpos.y += (-1.0*fTime*10.0);\n        fairy = opU2(fairy, vec2(sdSphere(fpos, (1.0-fTime)*.25), 1.0));\n    }\n    \n    t = opU2(t, gra);\n    t = opU2(t, fairy);\n    \n    return t;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    \n    if(t.x == -1.0)\n    {\n        vec2 vignetteUV = uv;\n        vignetteUV.y -= 0.2;\n        col = vec3(1.0 - length(vignetteUV))*.3;\n        \n        \n    }\n    else\n    {\n        float glp = clamp(length(pos)*.1, 0.0, 1.0);\n        vec3 N = GetNormal(ro+rd*t.x);\n        vec3 L = vec3(1.0, 1.0, 0.0);\n        float light = dot(N,L);\n        \n        if(t.y == 0.0)\n        {\n            vec3 gcol = pos.y * vec3(0.0, 0.2, 0.0);\n            gcol += vec3(light)*.2;\n            \n            col = mix(gcol, vec3(0.0), glp);\n            col.x -= pos.y*100.;\n        }\n        else if(t.y == 1.0)\n        {\n            col = vec3(1.0, 1.0, 0.0);\n        }\n        \n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime)*.1, -1.0, cos(iTime)*.1), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime*.25;\n    \n    vec3 cp = vec3(\n        sin(time), \n        1.0+sin(iTime)*.2, \n        cos(time)\n        )*(10.0+sin(iTime));\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    col = Render(cp, vd, uv);\n    \n    col.y *= screenUV.y;\n    col.y -= length(uv)-2.0*.1;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 19882,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/str8kdt/dd-forest-ambient-everlasting-wanderer-prod-str8kdt"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}