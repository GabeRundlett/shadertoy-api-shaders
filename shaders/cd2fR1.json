{
    "Shader": {
        "info": {
            "date": "1689667569",
            "description": "Just my attempt at replicating a carbon fiber-esque texture by analyzing real-life reference images. Use the mouse to move the \"light\". ",
            "flags": 0,
            "hasliked": 0,
            "id": "cd2fR1",
            "likes": 9,
            "name": "Carbon Fiber Texture",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "noise",
                "math",
                "texture",
                "perlin",
                "pattern",
                "material"
            ],
            "usePreview": 0,
            "username": "piyushslayer",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "/**\n    A quasi-realistic looking carbon fiber texture pattern based on overlapping two different sets of uv maps\n    mixed using a zigzag checkered pattern. The checkered pattern is stored in x channel of the carbon fiber\n    map. The anisotropic brushed \"metal\" look is generated by stretching two sets of perlin fbm noise along the\n    x and y axis and then mixing them using the same zigzag checkered pattern. A second map is also generated\n    that stores the heightmap for each \"weave\" in the mesh. Finally everything is mixed together using these \n    two masks with 2 distinct colors to differentiate between the horizontal and vertical weaves. Some fake lighting\n    is also added to enhance the effect of the heightmap & the anisotropic brushes on each weave of the mesh. Try playing\n    around with different settings below to customize the look of the texture. \n*/\n\n#define Saturate(x) clamp(x, 0.0, 1.0)\n\n#define WEAVE_SCALE 50.0\n#define HORIZONTAL_WEAVE_COLOR vec3(0.165,0.165,0.165) // #2A2A2A\n#define VERTICAL_WEAVE_COLOR   vec3(0.329,0.329,0.329) // #545454\n\n#define ANISOTROPIC_MASK 1\n#define ANISOTROPIC_ANIMATION 1\n#define ANISOTROPIC_THRESHOLD 0.3\n#define ANISOTROPIC_ANIMATION_SPEED 0.02\n\n#define LIGHTING 1\n#define SPECULAR 1\n\n#define DIFFUSE_SCALE 2.0\n#define SPECULAR_SCALE 0.5\n\nfloat Hash12(vec2 p, float f)\n{\n    p = abs(mod(p, f)); // we want the same random points for each subsection\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1.0 / float(0xffffffffU));\n}\n\n// Noise function by morgan3d (modified)\nfloat PerlinNoise(vec2 x, float freq) \n{\n    x *= freq; // tile\n    \n    vec2 f = fract(x);\n    x = floor(x);\n\n\tfloat a = Hash12(x, freq);\n    float b = Hash12(x + vec2(1.0, 0.0), freq);\n    float c = Hash12(x + vec2(0.0, 1.0), freq);\n    float d = Hash12(x + vec2(1.0, 1.0), freq);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat PerlinFbm (vec2 uv, float freq, int octaves)\n{\n    float amp = .5;\n    float noise = 0.;\n    \n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * PerlinNoise(uv, freq);\n        amp *= .5;\n        freq *= 2.;\n    }\n    return noise;\n}\n\nvec2 GenerateCarbonFiberMap(in vec2 uv)\n{\n    vec2 gridUv = uv * WEAVE_SCALE * vec2(1.0, iResolution.y / iResolution.x); // Scale grid row size based on aspect ratio.\n    vec2 gridId = floor(gridUv);\n    float maskScaleInverse = 0.5;\n    vec2 maskOffset = (gridUv + gridId.yx) * maskScaleInverse;\n    \n    float patternMask = mod(floor(maskOffset.x), 2.0); // zigzag pattern\n    vec2 gradients = 1.0 - abs(fract(maskOffset) - 0.5); // horizontal and vertical gradient patterns\n    gradients -= 0.5;\n    gradients = Saturate(pow(gradients, vec2(0.25)));\n    float heightMap = mix(gradients.y, gradients.x, patternMask); // mix both gradients based on the zigzag pattern\n    \n#if ANISOTROPIC_MASK\n    float anisotropicBrush = mix(PerlinFbm(uv * vec2(50.0, 0.1) + vec2(0.0, uv.x * 8.0) \n#if ANISOTROPIC_ANIMATION\n                                           + iTime * ANISOTROPIC_ANIMATION_SPEED\n#endif\n                                           , 32.0, 8), // vertical anisotropic\n                                 PerlinFbm(uv * vec2(0.1, 50.0) + vec2(uv.y * 8.0, 0.0)\n#if ANISOTROPIC_ANIMATION\n                                           + iTime * ANISOTROPIC_ANIMATION_SPEED\n#endif\n                                           , 32.0, 8), // horizontal anisotropic\n                                 patternMask);\n    heightMap = mix(anisotropicBrush * ANISOTROPIC_THRESHOLD, heightMap, heightMap);\n#endif\n    return vec2(patternMask, heightMap);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 carbonFiber = GenerateCarbonFiberMap(uv);\n    vec3 outColor = vec3(1.0);\n    \n#if LIGHTING\n    vec3 normal = normalize(vec3(dFdx(carbonFiber.y) * 2.0, dFdy(carbonFiber.y) * 2.0, carbonFiber.y)); // I've literally pulled the multiply by 2 out of my ass because it looks good. \n    vec3 lightDirection = normalize(vec3(iMouse.y < 0.5 ? vec2(iResolution.xy * 0.5) : iMouse.xy, 500.0) - vec3(fragCoord, 0.0));\n    outColor = vec3(max(0.0, dot(normal, lightDirection))) * DIFFUSE_SCALE; // diffuse \"lighting\"\n#if SPECULAR\n    vec3 r = reflect(-lightDirection, normal);\n    outColor += pow(max(0.0, dot(normalize(vec3(vec2(0.5), 1000.0) - vec3(uv, 0.0)), r)), 8.0) * SPECULAR_SCALE; // specular \"lighting\" \n#endif\n#else\n    outColor *= 2.0;\n#endif\n\n    outColor *= carbonFiber.y * mix(VERTICAL_WEAVE_COLOR, HORIZONTAL_WEAVE_COLOR, carbonFiber.x);\n    fragColor = vec4(outColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}