{
    "Shader": {
        "info": {
            "date": "1589161623",
            "description": "tried to create a smooth sine wave SDF using standard SDF building techniques like space folding and smooth min. not exactly sine, but sure looks like it. real sine (with bounding planes) on the left, fake on the right",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXBWX",
            "likes": 2,
            "name": "Fake Smooth Sine SDF",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 458
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat scene(vec2 p, bool real) {\n    float scale = mix(1., 20., sin(iTime)*.5+.5);\n    if (real) {\n        float d1 = (p.y+sin(p.x*scale))/scale/sqrt(2.);\n        return max(min(d1,p.y+1.),p.y-1.);\n    } else {\n    \tp.x = asin(sin(p.x*scale)*.9)/scale;\n    \tfloat d1 = dot(p, normalize(vec2(scale,1)));\n    \treturn -smin(1.-p.y, -smin(d1, p.y+1., 1./sqrt(scale)), 1./sqrt(scale));\n    }\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(clamp(log(abs(d)+1.0)*1.5, 0.0, 1.0));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    if (d > 0.0) {\n        //red tint\n        color *= vec3(1.0,0.56,0.4);\n    } else {\n        //blue tint\n        color *= vec3(0.4,0.9,1.0);\n        \n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=4.; mouse*=4.;\n    bool real = uv.x < 0.;\n    \n    float mousedist = scene(mouse, mouse.x < 0.);\n    fragColor = vec4(shadeDistance(scene(uv, real)), 1.);\n    if (iMouse.z > 0.) {\n        float pixelsize = 3./iResolution.y;\n        fragColor *= smoothstep(-pixelsize, pixelsize, distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}