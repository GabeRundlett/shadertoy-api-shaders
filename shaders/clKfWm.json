{
    "Shader": {
        "info": {
            "date": "1702158307",
            "description": "Some overcast clouds ",
            "flags": 0,
            "hasliked": 0,
            "id": "clKfWm",
            "likes": 52,
            "name": "Overcast clouds",
            "published": 3,
            "tags": [
                "clouds",
                "overcast"
            ],
            "usePreview": 0,
            "username": "afl_ext",
            "viewed": 663
        },
        "renderpass": [
            {
                "code": "// afl_ext 2017-2023\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// settings for the shader\n#define STEP_SIZE_SCALE 500.0 // lower means more steps\n\n#define CloudsFloor 1000.0\n#define CloudsCeil 5000.0\n\n// decide how much clouds coverage there is, this can dramatically affect performance\n// basically this shader works better when there are more than less clouds\n#define COVERAGE_START 0.02\n#define COVERAGE_END 0.23\n\n#define CLOUDS_FBM_STEPS 5\n\n#define EXPOSURE 0.5\n\n\n// this shader supports view from inside and over the clouds too, \n// give it a try by uncommenting this line\n//#define FLYING_CAMERA\n\n#ifndef FLYING_CAMERA\n    #define CAMERA_HEIGHT (200.0)\n    #define FOG_COLOR vec3(0.04)\n#endif\n#ifdef FLYING_CAMERA\n    #define CAMERA_HEIGHT (10.0 + (0.5 + 0.5 * sin(iTime * 0.2)) * 7000.0)\n    #define FOG_COLOR vec3(0.00)\n#endif\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0 || NormalizedMouse.x == 0.0) {\n    return proj * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.6);\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * ((NormalizedMouse.y * 1.5) * 2.0 - 1.0))\n    * proj;\n}\n\n// Standard 2d noise\nfloat rand2dTime(vec2 co){\n    co *= iTime;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Hash for 3d vectors\nfloat rand3d(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\n\n// 3D value noise\nfloat noise3d(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = rand3d(LBZ);\n    float l0candidate2 = rand3d(RBZ);\n    float l0candidate3 = rand3d(LTZ);\n    float l0candidate4 = rand3d(RTZ);\n\n    float l0candidate5 = rand3d(LBF);\n    float l0candidate6 = rand3d(RBF);\n    float l0candidate7 = rand3d(LTF);\n    float l0candidate8 = rand3d(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n// 3D simplex noise, cool trick\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\n\n// Sphere raytracing\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat raySphereIntersect(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    //return mix(ex.y, ex.x, step(0.0, ex.x));\n    //return max(ex.x, ex.y);\n    if(minhit < 0.0 && maxhit > 0.0)\n        return maxhit;\n    if(minhit < maxhit && minhit > 0.0)\n        return minhit;\n    return 0.0;    \n}\nfloat hitLimit = 678000.0;\nfloat higherHitLimit = 6780000.0;\n#define isHitBoolean(v) (v > 0.0 && v < hitLimit)\n#define isHitStep(v) step(0.0, v)\n\n// Clouds code\n\n#define VECTOR_UP vec3(0.0,1.0,0.0)\n\n// Pretty self explanatory FBM with some precisely adjusted behavior\nfloat cloudsFBM(vec3 p){\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<CLOUDS_FBM_STEPS;i++){\n        float x = abs(0.5 - supernoise3d(p))*2.0;\n        a += x * w;\n        p = p * 2.9;\n        w *= 0.60;\n    }\n    return a;\n}\n\n\nfloat planetradius = 6378000.1;\n    \nfloat getHeightOverSurface(vec3 p){\n    return length(p) - planetradius;\n}\n\n// this function probes the clouds densite at a point\n// returns XY\n// X = coverage of clouds at this point, \n// Y = cloud color at this point, basically incoming radiance\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSurface(pos);\n    pos -= vec3(0,planetradius,0);\n   \n    // make sure the clouds look like clouds by making the density\n    // scale with height between the layers, make it a height coefficent\n    // this coeff is 1.0 in between the layers, and 0.0 at the edges\n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n    \n    // probe the fbm with moving position so the clouds move\n    float density = cloudsFBM(pos * 0.01 * 0.021 + vec3(iTime * 0.04, 0.0, 0.0));\n    \n    // calculate the radiance\n    float scattering = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    return vec2(density * mlt, scattering);\n}\n     \nvec4 raymarchClouds(vec3 p1, vec3 p2, float randomValue){\n    // non constant step size, directly coupled to distance between points\n    // this is required to make in cloud rendering right\n    // also makes coverage calculation consistent with different distances raymarched\n    float stepsize = STEP_SIZE_SCALE / distance(p1, p2);\n    // coverage is inverted to have less calculations inside the loop\n    float coverageinv = 1.0;\n    vec3 color = vec3(0.0);\n    // start of the raymarching position is nudged by a bit with a random value to make\n    // the sampling better\n    float iter = randomValue * stepsize;\n    while(iter < 1.0 && coverageinv > 0.0){\n        vec2 density = cloudsDensity3D(mix(p1, p2, iter));\n        \n        // final coverage at point is calculated here\n        float clouds = smoothstep(COVERAGE_START, COVERAGE_END, clamp(density.x, 0.0, 1.0));\n        \n        // adjust the color taking into account the coverage left, this is basically alpha blending\n        color += clouds * max(0.0, coverageinv) * density.y;//vec3(pow(density.y * 1.0, 2.0));\n\n        // add coverage by subtracting from the inverted coverage, and subtract a bit more for fog rendering\n        coverageinv -= clouds + 0.001;\n        \n        // variable next step size\n        // if density is 0 then step should be larger to skip not interesting areas\n        // if density is higher then step lower to sample the interesting areas more\n        iter += stepsize * 0.1 + stepsize * 2.0 * max(0.0, 0.2 - density.x);\n    }\n    float coverage = 1.0 - clamp(coverageinv, 0.0, 1.0);  \n    return vec4(pow(color, vec3(2.0)) * 20.0, coverage);\n}\n\n    \n// very native rendering for the ground, shadow is basically clouds sampled directly above\n// this doesnt look that great, but at least look like something...\n// by adjusting the direction and smoothstepping the coverage, really nice sun shadows can be achieved\n// but with so high clouds coverage no light will peek through so its done like that here\nvec3 renderGround(vec3 point, float dist, float random){\n    float shadow = raymarchClouds(\n            point + vec3(0.0, CloudsFloor, 0.0), \n            point + vec3(0.0, CloudsCeil, 0.0), \n            random\n        ).x;\n\n    vec3 color = vec3(0.2, 0.2, 0.2) * vec3(0.8 + 0.2 * shadow);\n        \n    float fogIntensity = 1.0 - 1.0 / (0.001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n    \n// Straightforward, render raymarch, apply fog, alpha blend with the background, return\nvec3 renderClouds(vec3 pointStart, vec3 pointEnd, vec3 background, float dist, float random){\n    vec4 clouds = raymarchClouds(\n            pointStart,\n            pointEnd, \n            random\n        );\n    vec3 color = mix(background, clouds.xyz, clouds.a);\n    float fogIntensity = 1.0 - 1.0 / (0.0001 * dist);\n    return mix(color, FOG_COLOR, clamp(fogIntensity, 0.0, 1.0));\n}\n\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // get the ray direction\n    vec3 dir = getRay(fragCoord);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sky color as the default initial color\n    vec3 C = vec3(0.5, 0.7, 0.8);\n    \n    // random for clouds raymarching\n    float random = fract(rand2dTime(uv));\n    \n    // define clouds height and planet ground\n    Sphere sphereCeilLayer = Sphere(vec3(0), planetradius + CloudsCeil);\n    Sphere sphereFloorLayer = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphereGround = Sphere(vec3(0), planetradius);\n\n    // define camera origin relative to surface\n    vec3 origin = vec3(100.0, CAMERA_HEIGHT, 100.0);\n    // define camera origin relative to the planet\n    vec3 atmorg = vec3(0.0, planetradius, 0.0) + origin;\n    Ray ray = Ray(atmorg, dir);\n    \n    // adjust the ray hit detection if above the clouds, this could be done better\n    if(origin.y >= CloudsCeil){\n        hitLimit = higherHitLimit;\n    }\n    \n    // Intersections\n    float hitceil = raySphereIntersect(ray, sphereCeilLayer);\n    float hitfloor = raySphereIntersect(ray, sphereFloorLayer);\n    float hitGround = raySphereIntersect(ray, sphereGround);\n    \n    if(origin.y < CloudsFloor){\n        // below clouds\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            C = renderGround(groundHitPoint, hitGround, random);\n        } else {\n            vec3 cloudsPointStart = atmorg + (dir * min(hitfloor, hitceil));\n            vec3 cloudsPointEnd = atmorg + (dir * max(hitfloor, hitceil));\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, C, min(hitfloor, hitceil), random);\n        }\n    \n    } else if(origin.y >= CloudsFloor && origin.y < CloudsCeil){\n        // inside the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        vec3 cloudsPointStart = atmorg;\n        float targetDistance = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistance = max(hitfloor, hitceil);\n        } else if(isHitBoolean(hitfloor)){\n            targetDistance = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            targetDistance = hitceil;\n        }\n        vec3 cloudsPointEnd = atmorg + (dir * targetDistance);\n        C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        \n    } else if(origin.y >= CloudsCeil){\n        // above the clouds\n        vec3 background = C;\n        if(isHitBoolean(hitGround)){\n            vec3 groundHitPoint = atmorg + (dir * hitGround);\n            background = renderGround(groundHitPoint, hitGround, random);\n        }\n        float targetDistanceStart = 0.0;\n        float targetDistanceEnd = 0.0;\n        if(isHitBoolean(hitfloor) && isHitBoolean(hitceil)){\n            targetDistanceStart = hitceil;\n            targetDistanceEnd = hitfloor;\n        } else if(isHitBoolean(hitceil)){\n            raySphereIntersect(ray, sphereCeilLayer);\n            targetDistanceStart = minhit;\n            targetDistanceEnd = maxhit;\n        }        \n        if(isHitBoolean(targetDistanceStart) && isHitBoolean(targetDistanceEnd)){\n            vec3 cloudsPointStart = atmorg + (dir * targetDistanceStart);\n            vec3 cloudsPointEnd = atmorg + (dir * targetDistanceEnd);\n            C = renderClouds(cloudsPointStart, cloudsPointEnd, background, 0.0, random);\n        }\n    }\n    \n    \n    // adjust exposure, tonemap and return\n    fragColor = vec4( aces_tonemap(C * EXPOSURE * vec3(1.0, 0.9, 0.8)),1.0);      \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}