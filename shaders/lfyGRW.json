{
    "Shader": {
        "info": {
            "date": "1712462093",
            "description": "3D voxel DDA with a bunch of artifacts fixed.\n\nOriginal Branchless Voxel Raytracing fork: https://www.shadertoy.com/view/4dX3zl\nFork with UV mapping: https://www.shadertoy.com/view/ddyXDt",
            "flags": 0,
            "hasliked": 0,
            "id": "lfyGRW",
            "likes": 15,
            "name": "Multilevel 3D DDA",
            "published": 3,
            "tags": [
                "voxel",
                "dda",
                "3dda"
            ],
            "usePreview": 0,
            "username": "DapperCore",
            "viewed": 1538
        },
        "renderpass": [
            {
                "code": "const int MAX_RAY_STEPS = 64;\n\nbool block[8 * 8 * 8] = bool[](\n    true, true,  true,  true,  true,  true,  true,  true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, true,  true,  true,  true,  true,  true,  true,\n\n    true,  false, false, false, false, false, false, true,\n    false, true,  false, false, false, false, true,  false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, true,  false, false, false, false, true,  false,\n    true,  false, false, false, false, false, false, true,\n\n    true,  false, false, false, false, false, false, true,\n    false, false, false, false, false, false, false, false,\n    false, false, true,  false, false, true,  false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, true,  false, false, true,  false, false,\n    false, false, false, false, false, false, false, false,\n    true,  false, false, false, false, false, false, true,\n\n    true,  false, false, false, false, false, false, true,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, true,  true,  false, false, false,\n    false, false, false, true,  true,  false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    true,  false, false, false, false, false, false, true,\n\n    true,  false, false, false, false, false, false, true,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, true,  true,  false, false, false,\n    false, false, false, true,  true,  false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    true,  false, false, false, false, false, false, true,\n\n    true,  false, false, false, false, false, false, true,\n    false, false, false, false, false, false, false, false,\n    false, false, true,  false, false, true,  false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, true,  false, false, true,  false, false,\n    false, false, false, false, false, false, false, false,\n    true,  false, false, false, false, false, false, true,\n\n    true,  false, false, false, false, false, false, true,\n    false, true,  false, false, false, false, true,  false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, false, false, false, false, false, false, false,\n    false, true,  false, false, false, false, true,  false,\n    true,  false, false, false, false, false, false, true,\n\n    true, true,  true,  true,  true,  true,  true,  true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, false, false, false, false, false, false, true,\n    true, true,  true,  true,  true,  true,  true,  true\n);\n\n\n\nfloat sdSphere(vec3 p, float d) { \n    return length(p) - d; \n} \n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n  \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    \n\treturn d < 0.0;\n}\n\nbool getBlockVoxel(ivec3 c) {\n    return block[c.y * 8 * 8 + c.z * 8 + c.x];\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n    \n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvec3 stepMask(vec3 sideDist) {\n    // Yoinked from https://www.shadertoy.com/view/l33XWf\n    bvec3 move;\n    bvec3 pon=lessThan(sideDist.xyz,sideDist.yzx);\n\n    move.x=pon.x && !pon.z;\n    move.y=pon.y && !pon.x;\n    move.z=!(move.x||move.y);\n\n    return vec3(move);\n}\n\nvec4 traceBlock(vec3 rayPos, vec3 rayDir, vec3 iMask) {\n    rayPos = clamp(rayPos, vec3(0.0001), vec3(7.9999));\n    vec3 mapPos = floor(rayPos);\n    vec3 raySign = sign(rayDir);\n    vec3 deltaDist = 1.0/rayDir;\n    vec3 sideDist = ((mapPos - rayPos) + 0.5 + raySign * 0.5) * deltaDist;\n    vec3 mask = iMask;\n    \n    while (mapPos.x <= 7.0 && mapPos.x >= 0.0 && mapPos.y <= 7.0 && mapPos.y >= 0.0 && mapPos.z <= 7.0 && mapPos.z >= 0.0) {\n        if (getBlockVoxel(ivec3(mapPos)))\n            return vec4(floor(mapPos) / 8.0, 1.0);\n            \n       mask      = stepMask(sideDist);\n       mapPos   += mask * raySign;\n       sideDist += mask * raySign * deltaDist;\n    }\n    \n    return vec4(0.0);\n}\n\nvec4 traceWorld(vec3 rayPos, vec3 rayDir) {    \n    vec3 mapPos = floor(rayPos);\n    vec3 raySign = sign(rayDir);\n    vec3 deltaDist = 1.0/rayDir;\n    vec3 sideDist = ((mapPos-rayPos) + 0.5 + raySign * 0.5) * deltaDist;\n    vec3 mask = stepMask(sideDist);\n    \n    for (int i = 0; i < MAX_RAY_STEPS; i++) {\n       if (getVoxel(ivec3(mapPos))) {\n           vec3 mini = ((mapPos-rayPos) + 0.5 - 0.5*vec3(raySign))*deltaDist;\n           float d = max (mini.x, max (mini.y, mini.z));\n           vec3 intersect = rayPos + rayDir*d;\n           vec3 uv3d = intersect - mapPos;\n\n           if (mapPos == floor(rayPos)) // Handle edge case where camera origin is inside of block\n               uv3d = rayPos - mapPos;\n\n           vec4 hit = traceBlock(uv3d * 8.0, rayDir, mask);\n\n           if (hit.a > 0.95) \n                return hit;\n       }\n       \n       mask      = stepMask(sideDist);\n       mapPos   += mask * raySign;\n       sideDist += mask * raySign * deltaDist;\n    }\n    \n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime);\n\trayDir.xz = rotate2d(rayDir.xz, iTime);\n    \n    if (any(equal(rayDir, vec3(0.0)))) // Avoid divide by zero when rayDir element is zero\n        rayDir += vec3(equal(rayDir, vec3(0.0))) * vec3(0.00001f);\n\t    \t\n\tfragColor = traceWorld(rayPos, rayDir);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}