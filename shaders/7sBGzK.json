{
    "Shader": {
        "info": {
            "date": "1617641374",
            "description": "4k executable graphics entry for Revision 2021\n",
            "flags": 32,
            "hasliked": 0,
            "id": "7sBGzK",
            "likes": 53,
            "name": "Bull",
            "published": 3,
            "tags": [
                "procedural",
                "raymarching",
                "revision",
                "ox"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 829
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PC 4k exe graphics entry of Revision 2021\n// A more verbosed version\n// Split to more passes just for reducing some compile time here\n\n// FXAA pass\n#define REDUCE_MUL (1. / 8.)\n#define REDUCE_MIN (1. / 128.)\n#define INTENSITY 3.1\n\nfloat rgb2luma(vec4 col)\n{\n\treturn col.y *(.587 / .299) + col.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec2 eps = 1. / iResolution.xy;\n\n\tfloat topLeft   = rgb2luma(texture(iChannel0, uv + vec2(-eps.x, eps.y)));\n\tfloat topRight  = rgb2luma(texture(iChannel0, uv + eps.xy));\n\tfloat downLeft  = rgb2luma(texture(iChannel0, uv - eps.xy));\n\tfloat downRight = rgb2luma(texture(iChannel0, uv + vec2(eps.x, -eps.y)));\n\tfloat center    = rgb2luma(texture(iChannel0, uv));\n\n\tvec2 dir        = vec2((topLeft + topRight) - (downLeft + downRight),\n\t\t                  (downLeft + topLeft) - (downRight + topRight));\n\tfloat dirReduce = max((downLeft + downRight + topLeft + topRight) * REDUCE_MUL * 0.25, REDUCE_MIN);\n\tfloat dirMin    = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir             = min(vec2(INTENSITY), max(-vec2(INTENSITY), dir * dirMin)) * eps.xy;\n\n\tvec4 colA       = (texture(iChannel0, uv - .166667 * dir) + texture(iChannel0, uv + .166667 *dir)) *.5;\n\tvec4 colB       = colA *.5 + .25 * (texture(iChannel0, uv - .5 * dir) + texture(iChannel0, uv + .5 * dir));\n\tfloat LumB = rgb2luma(colB);\n\n\tif (LumB < min(center, min(min(downLeft, downRight), min(topLeft, topRight))) ||\n\t\tLumB > max(center, max(max(downLeft, downRight), max(topLeft, topRight))))\n\t\tfragColor = colA;\n\telse\n\t\tfragColor = colB;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PC 4k exe graphics entry of Revision 2021\n\n// Render cloud and grass\n\nfloat mapCloud(vec3 p)\n{\n\tp += vec3(4., 2., 20.);\n\trot2d(p.xz, .9);\n\tfloat d = 6. - length(vec3(mod(p.x, 6.) - 3., p.y, p.z)) - 3. *fbm2(p) + 2. *fbm2(p *.3);\n\td *= 1. - smoothstep(3., 6., p.y);\n\treturn clamp(d, 0., 1.);\n}\n\nvec3 renderCloud(vec3 ro, vec3 rd)\n{\n\tfloat rnd = .95 + .05* fract(sin(dot(Q, vec2(12.9898, 78.233))) *43758.5453);\n\n\tvec4 sum = vec4(rnd *sky *(exp(-length(rd.xy - vec2(.4, .4)))), 1);\n\n\tfloat t = 8.;\n\tfloat dt = .2;\n\tfor (int i = 0; i < 64 + min(0, iFrame); ++i)\n\t{\n\t\tvec3 p = ro + t * rd;\n\t\tfloat d = mapCloud(p);\n\n\t\tif (d > 0.)\n\t\t{\n\t\t\tfloat s = 0.;\n\t\t\tvec3 st = normalize(p + sunDir);\n\t\t\tvec3 sp = p;\n\t\t\tfor (int j = 0; j < 10; j++)\n\t\t\t\ts += mapCloud(sp += st);\n\n\t\t\tsum.xyz += exp(-s *.15) *d* vec3(1.5) *sunCol *(1. - d) *sum.a;\n\t\t\tsum.a *= 1. - d;\n\t\t}\n\n\t\tif (sum.a < .1 || t > 500.) break;\n\n\t\tt += dt;\n\t\tdt = max(.2, .02 *t);\n\t}\n\n\treturn sum.xyz;\n}\n\nfloat mapTerrian(vec3 p)\n{\n\tvec2 q = p.xz *.5 + vec2(3);\n\tfloat f = (.9 - 1.5* sin(p.x *.1)) *noise(q);\n\tq = q *2.11;\n\tf += .5* noise(q);\n\tq = q *2.2;\n\treturn f - .3;\n}\n\nfloat blades[8];\n\n// grass based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\nfloat mapGrass(vec3 p)\n{\n\tp.xy = vec2(p.x, p.y);\n\tfloat d = noise(p.xz *(GRASS_DENSITY + 100. *smoothstep(2.5, 3., p.z)));\n\td *= mix(1., noise(p.xz *30. - 27.), .6);\n\tint i = 7;\n\tfor (; i > 0 + min(0, iFrame); --i) blades[i] = blades[i - 1];\n\tblades[0] = d;\n\tfor (; i < 8 + min(0, iFrame); ++i) d += blades[i];\n\td /= float(i + 1);\n\td *= GRASS_H* min(1., exp(-(p.z) *.08));\n\treturn d;\n}\n\nfloat intersectGrass(vec3 ro, vec3 rd)\n{\n\tfloat t = .01;\n\tvec3 p = ro + t * rd;\n\tfor (int i = 0; i < 1000 + min(0, iFrame); ++i)\n\t{\n\t\tfloat d = p.y - mapGrass(p) - mapTerrian(p);\n\t\tif (d < .005 || t >= 10.) break;\n\t\td = max(1e-4, .04 *d* exp(t *.4));\n\t\tp += d * rd;\n\t\tt += d;\n\t}\n\n\treturn t;\n}\n\nvec3 renderGrass(vec3 ro, vec3 rd, float t, vec3 col)\n{\n\tif (t < 10.)\n\t{\n\t\tvec3 p = ro + t * rd;\n\t\tcol = vec3(4.82, 2.75, 1.18) *max(0., dot(sunDir, vec3(0, .4, 1))) *2.;\n\t\tcol = mix(col, vec3(1.2, 1, 0.5), fbm(p.xz *2.));\n\t\tcol *= smoothstep(GRASS_H *.45, GRASS_H *2., p.y - mapTerrian(p));\n\t\tcol *= pow(smoothstep(-.7, 1., fbm(p.xz)), 4.);\n\t\tfloat d = p.y - mapGrass(p) - mapTerrian(p);\n\t\tcol *= .8* clamp(d / GRASS_H, .0, 1.) + .2;\n\t\tcol *= 20.;\n\t}\n\n\treturn col;\n}\n\nvec4 scene(vec3 ro, vec3 rd)\n{\n\tvec3 col = renderCloud(ro, rd);\n\n\tfloat t = intersectGrass(ro, rd);\n\n\tcol = renderGrass(ro, rd, t, col);\n\n\tif (t < 10.)\n\t\tcol = mix(col, vec3(.82), 1.0 - exp(-.002 *t *t));\n\n\treturn vec4(col, t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 ta = vec3(-.7, 2.6, 0),\n\t\tro = vec3(-2.96, 1.21, 3.8),\n\t\trd;\n\tQ = (-iResolution.xy + 2. *fragCoord) / iResolution.y;\n\trd = cam(ro, ta) *normalize(vec3(Q.xy, 1.8));\n\tfragColor = scene(ro, rd);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PC 4k exe graphics entry of Revision 2021\n\n// Render the Bull\n\n\n#define AA 1\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat cap(vec3 p, float h, float r)\n{\n\tp.y -= clamp(p.y, 0.0, h);\n\treturn length(p) - r;\n}\n\nfloat roundCone(vec3 p, float r1, float r2, float h)\n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\n\tfloat b = (r1 - r2) / h;\n\tfloat a = sqrt(1. - b *b);\n\tfloat k = dot(q, vec2(-b, a));\n\n\tif (k < 0.) return length(q) - r1;\n\tif (k > a *h) return length(q - vec2(.0, h)) - r2;\n\n\treturn dot(q, vec2(a, b)) - r1;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 *(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k *h *(1.0 - h);\n}\n\nfloat smax(float a, float b, float k)\n{\n\treturn smin(a, b, -k);\n}\n\nfloat sabs(float x, float k)\n{\n\treturn sqrt(x *x + k) - 0.1;\n}\n\nvec3 bend(vec3 p, float k)\n{\n\tfloat c = cos(k *p.x);\n\tfloat s = sin(k *p.x);\n\treturn vec3(mat2(c, -s, s, c) *p.xy, p.z);;\n}\n\nfloat ellip(vec3 p, vec3 r)\n{\n\tfloat k0 = length(p / r);\n\treturn k0 *(k0 - 1.) / length(p / (r *r));\n}\n\nfloat cylinder(vec3 p, float h, float r)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat hoof(vec3 p)\n{\n\tp *= 6.;\n\tfloat d = cylinder(p *1.2, .7 - .4 *p.y, .4 + .2 *p.z) / 1.2 - .15;\n\tfloat d2 = box(p + vec3(0, 0, -.7), vec3(.08 - .04 *p.y, .6, .2));\n\td = smax(d, -d2, .2) / 6.;\n\treturn d;\n}\n\nfloat legs(vec3 op, float d, inout float mate)\n{\n    vec3 p=op;\n    // front left\n\t{\n\t\tp = op + vec3(.6, .5, -.6);\n\t\trot2d(p.xy, -1.6);\n\t\tfloat leg1 = cap(p, .8, .12 + .008* sin(p.x *40.));\n\n\t\tp.z += .01* sin(p.x *15. - 3.5) + .03* sin(p.y *20. - 2.);\n\t\tp.z *= 2.;\n\t\tp.z -= .1;\n\t\trot2d(p.xy, 2.);\n\t\trot2d(p.yz, -.6);\n\t\tfloat leg2 = roundCone(p + vec3(-.8, .2, 0), .2, .4, .5) / 2.;\n\t\tleg1 = smin(leg2, leg1, .16);\n\n\t\tp = op + vec3(.35, .85, -.6);\n\t\trot2d(p.xy, 1.);\n\t\tleg2 = cap(p, .4, .07 - .004* sin(p.x *50. - .5));\n\t\tleg1 = smin(leg1, leg2, .15);\n\t\td = smin(d, leg1, .06);\n\n\t\tp = op + vec3(.2, .9, -.6);\n\t\trot2d(p.xy, 1.5);\n\t\trot2d(p.xz, 1.2);\n\t\tfloat hoo = hoof(p);\n\t\tif (hoo < d) mate = HOOF;\n\t\td = smin(d, hoo, .15);\n\t}\n\n\t// front right\n\t{\n\t\tp = op + vec3(-.6, 1., 0.6);\n\t\trot2d(p.xy, .6);\n\t\tfloat leg1 = cap(p, .8, .12);\n\n\t\tp += vec3(.05, .64, 0);\n\t\tfloat leg2 = cap(p, .46, .08);\n\t\tleg1 = smin(leg1, leg2, .2);\n\n\t\tp += vec3(.1, .08, 0);\n\t\trot2d(p.xy, -.7);\n\t\trot2d(p.xz, 1.6);\n\t\tfloat hoo = hoof(p);\n\t\tif (hoo < d) mate = HOOF;\n\t\td = smin(d, hoo, .4);\n\n\t\tp = op + vec3(.6, .5, .55);\n\t\tp.z += .01* sin(p.y *15. + 2.);\n\t\tp.z *= 2.;\n\t\trot2d(p.xy, 0.4);\n\t\trot2d(p.yz, -.7);\n\t\tleg2 = roundCone(p + vec3(-.8, .2, 0), .2, .4, .5) / 2.;\n\n\t\tleg1 = smin(leg2, leg1, .2);\n\n\t\tif (leg1 < d) mate = BODY;\n\t\td = smin(d, leg1, .1);\n\t}\n\n\t// back legs\n\t{\n\t\tp = op;\n\t\tp.z *= 1.5;\n\t\tp += vec3(-2.3, 1., 0);\n\t\trot2d(p.xy, .3);\n\t\tp.z = abs(p.z) - .8;\n\t\trot2d(p.yz, -.3);\n\t\tp.z += .05* sin(p.x *15.) *(1. - smoothstep(1., 1.7, p.y)) +\n\t\t\t.02* sin(p.y *10. + 1.) *smoothstep(-1., 1., p.y);\n\t\tfloat leg2 = roundCone(p, .13, .5, 1.2) / 1.5;\n\t\td = smin(d, leg2, .15);\n\n\t\tp.z *= .5;\n\t\tp += vec3(-.08, .6, 0);\n\t\tleg2 = roundCone(p, .06, .03, .35);\n\t\td = smin(d, leg2, .3);\n\t}\n    \n    return d;\n}\n\nvec2 mapBull(vec3 p)\n{\n\tvec3 op = p;\n\tfloat d = 1e5;\n\tfloat mate = BODY;\n\n\tfloat dis2 = smoothstep(.0, 1., fbm(vec2(p.x *3., p.y *.3) *15.)) *.01 *\n\t\tsmoothstep(-.1, .2, p.y) *smoothstep(-2., -1.5, p.x) *smoothstep(3., 0., p.x);\n\n\tp.z *= 1.6;\n\tp.y -= .2;\n\trot2d(p.xy, -0.2);\n\tp.x += .03* sin(p.z *16. - 4.);\n\tp.z += .07* sin(p.x *15.) + .03* sin(p.y *15.);;\n\tfloat body = roundCone(p.yxz, 1., .6, 1.9) / 1.6;\n\td = body;\n\n\tp = op;\n\tp.z *= 1.4;\n\tp += vec3(1.4, -.2, 0);\n\trot2d(p.xy, 0.2);\n\tp.y -= .05 *(sin(p.x *6. - 1.));\n\tp.z += .1* sin(p.x *30. + 3.) *smoothstep(.5, -1., p.y);\n\tfloat neck = roundCone(p.yxz, .32, .8, 1.5) / 1.4;\n\td = smin(d, neck, .2);\n\n\tp = op + vec3(1.1, .5, 0);\n\trot2d(p.xy, 2.2);\n\tfloat head = roundCone(p.yxz - vec3(.02* sabs(sin(p.z *20.), .1) + .03, 0, 0), .12, .3, .58) / 2.;\n\thead = smin(head, cylinder(p.yzx + vec3(-.2, 0, -.65), .13, .17) / 2., .1);\n\thead = smin(head, length(vec3(p.x - .35, p.y + .05, abs(p.z) - .16)) - .1, .1);\n\thead = smin(head, length(vec3(p.x - .33, p.y - .1, abs(p.z) - .13)) - .1, .05);\n\thead = smax(head, -length(vec3(p.x - .1, p.y *2. - 0., abs(p.z) - .31)) + .1, .12);\n\n\trot2d(p.xy, -1.2);\n\tp.x *= 1.5;\n\n\tfloat jaw = roundCone(p.xyz + vec3(-.1, 0, .0), .12, .12, .5) / 2.;\n\thead = smin(head, jaw, .015);\n\td = smin(d, head, .1);\n\n\tp = op;\n\tp.z = abs(p.z) + .15;\n\tp += vec3(1.2, .62, -.24);\n\trot2d(p.xy, .7);\n\tfloat nose = roundCone(p, .04, .02, .2);\n\td = smin(d, nose, .07);\n\td = smax(d, -nose, .027);\n\n\tp = op;\n\tp.z = abs(p.z) + .13;\n\tp = p + vec3(1.45, .3, -.25);\n\tfloat eyes = (length(p* vec3(2., 1., 2.) + vec3(.2, -.2, 0)) - .3) / 2.;\n\td = smin(d, eyes, .05);\n\tp.z = abs(op.z) - .25;\n\trot2d(p.xy, .3);\n\trot2d(p.yz, .3);\n\teyes = (length(vec3(abs(p.x + .05) + .11, p.y + 0., p.z *3. + .1)) - .15) / 3.;\n\td = smax(d, -eyes, .001);\n\teyes = length(p + vec3(.04, .02, .09)) - .05;\n\tif (eyes < d) mate = EYES;\n\td = smin(d, eyes, .0);\n\n\tp = op;\n\tp.z = abs(p.z) - .14;\n\tp += vec3(1.5, .1, -.25);\n\trot2d(p.xy, 1.4);\n\tp = bend(p.yxz, -10.);\n\tp.x -= .1* sin(p.z *6.);\n\tfloat ears = ellip(p, vec3(.1 + .06* sin(p.z *20.), .02, .15));\n\n\tif (ears < d) mate = BODY;\n\td = smin(d, ears, 0.01);\n\n\tp = op + vec3(2.45, .1, 0);\n\trot2d(p.xy, .1);\n\tp.z = sabs(p.z, .1) - .7;\n\trot2d(p.xz, 1.);\n\tp.x += .3* sin(p.z *5. + 7.5);\n\tp.y -= .06* sin(p.z *7.);\n\tfloat horn = roundCone(vec3(p.x, -p.z, p.y + .1), .013, .15, .9) / 2.5;\n\tif (horn < d) mate = HORN;\n\td = min(d, horn) / 1.5;\n\n\td = legs(op,d,mate);\n\n\tp = op + vec3(-.9, .15, 0);\n\tp.z -= 0.02* sin(p.y *15. - 5.) - .02* sin(p.x *8. - 2.);\n\tfloat belly = length(p) - .7;\n\td = smin(d, belly, .3);\n\n\tfloat k = smoothstep(2.95, 3.2, op.x) *smoothstep(3.7, 3.2, op.x);\n\tp = op + vec3(-3.5, .2, -.32);\n\trot2d(p.xy, 1.2);\n\tp.x += .4* sin(p.y *4.5);\n\tp.z += .3* sin(p.y *3. + 4.);\n\tp.y += .1* sin(p.z *200.);\n\tfloat tail = roundCone(p, .023 + .06 *k, .05, 1.5) / 2.;\n\td = smin(d, tail, .1);\n\n\tp = op + vec3(-2.55, 1.7, 0);\n\tp.z = abs(p.z) - .66;\n\trot2d(p.xz, 1.3);\n\tfloat hoo = hoof(p);\n\tif (hoo < d) mate = HOOF;\n\td = smin(d, hoo, .15);\n\n\tif (mate == BODY) d -= dis2;\n\n\treturn vec2(d, mate);\n}\n\nvec2 map(vec3 p)\n{\n\trot2d(p.xy, -.11);\n\tvec2 res = mapBull((p - vec3(0, 2.68, 0)));\n\treturn res;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k)\n{\n\tfloat res = 1.;\n\tfloat t = .01;\n\tfor (int i = 0; i < 128 + min(0, iFrame); i++)\n\t{\n\t\tfloat h = map(ro + rd *t).x;\n\t\tres = min(res, k *h / t);\n\t\tt += clamp(h, .005, .1);\n\t\tif (res < .002 || t > 100.) break;\n\t}\n\n\treturn max(res, .0);\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.001*e*t).x;\n    }\n    return normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n\tfloat t = .01;\n\tvec2 res = vec2(1e5, 0);\n\tfor (int i = 0; i < 256 + min(0, iFrame); ++i)\n\t{\n\t\tif (res.x < .002 || t > 100.) break;\n\t\tres = map(ro + t *rd);\n\t\tt += res.x;\n\t}\n\n\treturn vec2(t, res.y);\n}\n\nfloat getAO(vec3 p, vec3 n)\n{\n\tfloat occ = .0;\n\tfloat sca = 1.;\n\tfor (int i = 0; i < 5 + min(0, iFrame); i++)\n\t{\n\t\tfloat h = .01 + .12* float(i) / 4.;\n\t\tfloat d = map(p + h *n).x;\n\t\tocc += (h - d) *sca;\n\t\tsca *= .95;\n\t\tif (occ > .35) break;\n\t}\n\n\treturn clamp(1. - 3. *occ, 0., 1.) *(.5 + .5 *n.y);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n\tp *= iResolution.x / 20.;\n\tp.y *= .5;\n\tp.xz *= 3.;\n\treturn (fbm(p.xy) *abs(n.z) + noise(p.xz) *abs(n.y) + noise(p.yz) *abs(n.x)) / 3.;\n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n\tvec2 e = vec2(2. / iResolution.y, 0);\n\tvec3 g = vec3(bump(p - e.xyy, n) - bump(p + e.xyy, n),\n\t\tbump(p - e.yxy, n) - bump(p + e.yxy, n),\n\t\tbump(p - e.yyx, n) - bump(p + e.yyx, n)) / (e.x *2.);\n\tg = (g - n* dot(g, n));\n\treturn normalize(n + g *weight);\n}\n\nvec3 BRDF(vec3 n, vec3 v, vec3 l, vec3 diffuse)\n{\n\tvec3 h = normalize(v + l);\n\t// biased a little to workaround shiny pixels on the contour\n\tvec3 b = normalize(cross(n, vec3(0, 1, -.3))),\n\t\tt = normalize(cross(b, n));\n\t//t+=.2*n;\n\tfloat NoV = abs(dot(n, v)) + 1e-2,\n\t\tNoL = max(dot(n, l), 0.),\n\t\tNoH = max(dot(n, h), 0.),\n\t\tLoH = max(dot(l, h), 0.),\n\t\tToV = max(dot(t, v), 0.),\n\t\tBoV = max(dot(b, v), 0.),\n\t\tToL = max(dot(t, l), 0.),\n\t\tBoL = max(dot(b, l), 0.);\n\n\tfloat at = .1688, ab = .956;\n\tfloat a2 = at * ab;\n\thighp vec3 w = vec3(ab* dot(t, h), at* dot(b, h), a2 *NoH);\n\thighp float v2 = dot(w, w);\n\tfloat w2 = a2 / v2;\n\n\tfloat vi = 0.5 / (NoL* length(vec3(at *ToV, ab *BoV, NoV)) +\n\t\tNoV* length(vec3(at *ToL, ab *BoL, NoL)));\n\n\treturn vec3(a2 *w2 *w2 *.318 *\n\t\tmin(vi, 65504.) *\n\t\t(.046 + .954* pow(1.0 - LoH, 5.0))) + diffuse *.318;\n}\n\nvec3 shading(vec3 pos, vec3 rd, vec3 n, float mateid)\n{\n\tvec3 baseCol;\n\tfloat bump = 100. / max(iResolution.x, iResolution.y);\n\n\tif (mateid == BODY)\n\t{\n\t\tfloat top = smoothstep(2.3, 3., pos.y);\n\t\tbaseCol = mix(vec3(.08) *(.5 + smoothstep(0., 1., pos.x) *smoothstep(1., 2., pos.y)), vec3(.098, .059, .004),\n\t\t\tsmoothstep(.1, .5, fbm(pos.xy *6.) *top)) *1.5;\n        // Pure black looks better?\n\t\t//baseCol = vec3(.01)*(.5+smoothstep(0.,1.,pos.x))*1.5;\n\n\t\tbump *= .3* smoothstep(3.5, 2.4, pos.y);\n\t}\n\telse if (mateid == HORN)\n\t{\n\t\tbaseCol = mix(vec3(.969, .89, .831), vec3(.216, .118, .004), fbm(vec2(pos.x *20., pos.y *30.))) *\n\t\t\tsmoothstep(-2.3, -1.9, pos.x);\n\t\tbump *= .05;\n\t}\n\telse if (mateid == HOOF)\n\t{\n\t\tbaseCol = noise(pos.xy *30.) *vec3(.506, .459, .416);\n\t\tbump *= 0.08;\n\t}\n\n\tn = bump_mapping(pos, n, bump);\n\n\tfloat ao = getAO(pos + .1 *n, n), sha = shadow(pos, sunDir, 10.);\n\n\tvec3 col = BRDF(n, -rd, sunDir, baseCol) *ao *sunCol* max(0., dot(sunDir, n)) *8. *sha +\n\t\tsunCol* max(0., dot(-sunDir, n)) *.015;\n\n\tif (mateid == EYES) col = vec3(1, .435, 0);\n\treturn col;\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv)\n{\n\tvec4 col = texture(iChannel0, uv);\n\n\tvec2 res = intersect(ro, rd);\n\tfloat t = res.x;\n\tif (t < col.w)\n\t{\n\t\tvec3 pos = ro + t * rd;\n\n\t\tvec3 n = getNormal(pos, 1.);\n\t\tcol.xyz = shading(pos, rd, n, res.y);\n\t}\n\n\tt = min(t, col.w);\n\tif (t < 10.)\n\t\tcol.xyz = mix(col.xyz, vec3(.82), 1.0 - exp(-.002 *t *t));\n\n\treturn col.xyz;\n}\n\nvec3 tonemap(vec3 x)\n{\n\tconst float a = 2.51,\n\t\tb = .03,\n\t\tc = 2.43,\n\t\td = .59,\n\t\te = .14;\n\treturn (x *(a *x + b)) / (x *(c *x + d) + e);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 ta = vec3(-.7, 2.6, 0),\n\t\tro = vec3(-2.96, 1.21, 3.8),\n\t\trd, col = vec3(0);\n\n\t#if AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++)\n\t\t{\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - .5;\n\t\t\tQ = (-iResolution.xy + 2. *(fragCoord + o)) / iResolution.y;\n    #else\n\t\t\tQ = (-iResolution.xy + 2. *fragCoord) / iResolution.y;\n    #endif\n\t\t\trd = cam(ro, ta) *normalize(vec3(Q.xy, 1.8));\n\t\t\tcol += scene(ro, rd, uv);\n    #if AA > 1\n\t\t}\n\n\tcol /= float(AA *AA);\n    #endif\n\n\tcol = tonemap(col);\n\tcol = pow(clamp(col, 0., 1.), vec3(.45));\n\tcol.z = (col.z + .1) / 1.1;\n\tcol = clamp(col *.5 + .5 *col *col *1.3, 0., 1.);\n\tcol *= .5 + .5* pow(16. *uv.x *uv.y *(1. - uv.x) *(1. - uv.y), .15);\n\tfragColor = vec4(col, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PC 4k exe graphics entry of Revision 2021\n#define PI 3.1415926535\n#define BODY 0.\n#define HOOF 1.\n#define HORN 2.\n#define EYES 3.\n#define GRASS_H 0.1\n#define GRASS_DENSITY 540.\n\nvec3 sunDir = normalize(vec3(1, 1, 1.5));\nvec3 sunCol = vec3(1, .9, .62) *1.3;\nvec3 sky = vec3(.071, .102, .129);\nvec2 Q;\n\nvoid rot2d(inout vec2 p, float t)\n{\n\tfloat ct = cos(t), st = sin(t);\n\tvec2 q = p;\n\tp.x = ct *q.x + st *q.y;\n\tp.y = -st *q.x + ct *q.y;\n}\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p *5.3983, p *5.4427));\n\tp2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x *p2.y *95.4337) *0.5 + 0.5;\n}\n\nfloat noise(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tf = f *f *(3.0 - 2.0 *f);\n\tfloat n = p.x + p.y *57.0;\n\treturn mix(mix(hash11(n + 0.0), hash11(n + 1.0), f.x),\n\t\tmix(hash11(n + 57.0), hash11(n + 58.0), f.x), f.y);\n}\n\nfloat noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\tp = p *p *(3. - 2. *p);\n\th = mix(fract(sin(h) *43758.5453), fract(sin(h + s.x) *43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec2 q)\n{\n\tfloat f = 0.0;\n\tvec3 p = vec3(q, 0);\n\tf += .5* noise(p);\n\tp = p *2.01;\n\tf += .25* noise(p);\n\tp = p *2.02;\n\tf += .125* noise(p);\n\tp = p *2.03;\n\treturn f;\n}\n\nfloat fbm2(vec3 p)\n{\n\tmat3 m = mat3(.0, .8, .6,\n\t\t-.8, .36, -.48,\n\t\t-.6, -.48, .64);\n\tfloat f = 0., s = .5;\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tf += s* noise(p);\n\t\tp = m *p *2.01;\n\t\ts *= .5;\n\t}\n\n\treturn f;\n}\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n\tvec3 f = normalize(ta - ro);\n\tvec3 r = normalize(cross(f, vec3(0, 1, 0)));\n\tvec3 u = normalize(cross(r, f));\n\treturn mat3(r, u, f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}