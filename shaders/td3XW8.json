{
    "Shader": {
        "info": {
            "date": "1571855356",
            "description": "i tried some texturing. Reflection is completly faked and wrong, but the effect is not so bad.",
            "flags": 32,
            "hasliked": 0,
            "id": "td3XW8",
            "likes": 9,
            "name": "Shadertober 23 Ancient",
            "published": 3,
            "tags": [
                "raymarching",
                "texture",
                "glow",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 651
        },
        "renderpass": [
            {
                "code": "// SHADERTOBER 23 Ancient (but quite modern in fact)\n// Poulet Vert 23-10-2019\n// thanks iq, Leon, flopine, Michael Zheng, \n\n// step 3. post effects\n\n#define TEX 0.1\n\n// Convolution matrix and functions\n// Based on Michael Zheng code : https://www.shadertoy.com/view/XlByzh\n\nmat3 blurkernel = mat3(\n .11, .11, .11,\n .11, .11, .11, \n .11, .11, .11 \n);\n\nvec3 renderSample(const int x, const int y, vec2 _fragCoor)\n{\n    vec2 uv = _fragCoor.xy;\n    uv = (uv + vec2(x, y)) / iResolution.xy;\n    return texture(iChannel0, uv).xyz;\n}\n\nvec3 aFilter(vec2 fragCoord, mat3 kernel)\n{\n vec3 sum = vec3 (0.0,0.0,0.0);;\n    \n for (int first = 0; first < 3; first++)\n {\n     for(int second = 0; second < 3; second++)\n     {\n      sum += renderSample(first-1,second-1, iResolution.xy) * kernel[first][second];\n     }\n }\n        \n return sum;\n}\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    suv.x *= iResolution.x/iResolution.y;\n    vec3 base = texture(iChannel0,uv).xyz;\n    \n    vec3 effect = aFilter(uv * iResolution.xy, blurkernel);\n    \n    base += effect * .5;\n\n    base.r -= -suv.x*.5;\n    base -= vec3(pow(length(suv), 2.0))*.5;\n    base -= random(suv)*.3* length(suv) * .4;\n    \n    base = sqrt(clamp(base, 0.0, 1.0));\n    \n    fragColor = vec4(base, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// step 1. color circles texture animation\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat circle(vec2 p, float r)\n{\n    return step(length(p), r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    uv *= 10.;\n    vec2 cells = (floor(uv)*.1)*1.5;\n    uv = fract(uv)-.5;\n    vec3 col = vec3(0.0);\n    \n    float r = random(cells);\n    \n    col = vec3(circle(uv, .5));\n    col *= palette((r+iTime), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    col *= fract(r+iTime*.1);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// step 2. 3D raymarching with texture\n#define VOLUME 0.001\n#define PI 3.14159\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 scene = vec2(0.0, 0.0);\n    \n    vec3 groundP = pos + vec3(0.0);\n    float ground = sdPlane(groundP, vec4(0.0, 2.0, 0.0, 1.0));\n    \n    float wallY = -2.5;\n    \n    vec3 leftWallP = pos + vec3(-6.0, wallY, 0.0);\n    float leftWall = sdBox(leftWallP, vec3(1.0, 5.0, 5.0));\n    \n    vec3 centerWallP = pos + vec3(0.0, wallY, 0.0);\n    float centerWall = sdBox(centerWallP, vec3(5.0, 5.0, 1.0));\n    \n    // materials\n    scene = vec2(ground, 0.0);\n    scene = opU2(scene, vec2(leftWall, 0.0));\n    scene = opU2(scene, vec2(centerWall, 1.0));\n    \n    return scene;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x) - c);\n}\n\nfloat GetLight(vec3 N, vec3 lightPos)\n{\n    return max(dot(N, normalize(lightPos)), 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(0.0);\n        \n    }\n    else\n    {    \n        vec3 N = GetNormal(pos);\n        \n        vec3 mainL = vec3(-1.0, 2.0, -2.0);\n        float mainlight = GetLight(N, mainL);\n        \n        vec2 ledFreq = vec2(.15, .17);\n        vec2 ledUV =  vec2(-pos.x+5.14, -pos.y-.5);\n        \n        if(t.y == 0.0) // fake reflection surface\n        {\n            col = vec3(mainlight) * 2.0;\n            col *= texture(iChannel0, fract(ledFreq * ledUV)).rgb;\n            col *= (.5*pos.z+1.5)*.5+sin(iTime+pos.y)*.1;\n        }\n        else if(t.y == 1.0) // led wall\n        {\n            col = texture(iChannel0, fract(ledFreq * ledUV)).rgb;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 3.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    float camY = 1.4;\n    \n    vec3 cp = vec3(0.0, camY, -8.0);\n    vec3 ct = vec3(3.4, camY, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv);\n\n    col = sqrt(clamp(col, 0.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}