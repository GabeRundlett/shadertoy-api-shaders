{
    "Shader": {
        "info": {
            "date": "1555296716",
            "description": "Name doesn't really fit, but it sounds cool :P.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsSXDt",
            "likes": 11,
            "name": "Fusion Apparatus",
            "published": 3,
            "tags": [
                "raymarching",
                "ifs",
                "glow"
            ],
            "usePreview": 0,
            "username": "zackpudil",
            "viewed": 573
        },
        "renderpass": [
            {
                "code": "mat2 rot(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat len(vec3 p, float l) {\n  vec3 q = pow(abs(p), vec3(l));\n  return pow(q.x + q.y + q.z, 1.0/l);\n}\n\nfloat len(vec2 p, float l) {\n  vec2 q = pow(abs(p), vec2(l));\n  return pow(q.x + q.y, 1.0/l);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return max(max(q.x, q.y), q.z);\n}\n\nfloat torus(vec3 p, vec2 h, float l) {\n  vec2 q = vec2(len(p, l) - h.x, p.y);\n  return len(q, l) - h.y;\n}\n\nvec2 shape(vec3 p) {\n  float a = torus(p, vec2(1, 0.2), 16.0);\n  \n  p.y = abs(p.y) - 0.2;\n  \n  float b = torus(p, vec2(1.1, 0.14), 16.0);\n\n  vec2 s = vec2(a, 1.0);  \n  vec2 t = vec2(b, 2.0);\n\n  return s.x < t.x ? s : t;\n}\n\nvec2 path(float z) {\n  return vec2(0.5*sin(0.3*z + 1.0), cos(0.6*z));\n}\n\nfloat glow = 0.0;\nvec2 de(vec3 p) {\n  float sc = 1.0;\n  \n  p.xy += path(p.z);\n  \n  vec3 op = p;\n  p.z = mod(p.z + 1.5, 3.0) - 1.5;\n  vec4 q = vec4(p*sc, 1);\n  \n  q.xyz -= 1.0;\n  \n  for(int i = 0; i < 5; i++) {\n    q.xyz = abs(q.xyz + 1.0) - 1.0;\n    q.xz *= rot(0.55);\n    q.xy *= rot(0.1);\n    \n    q *= 1.1;\n  }\n  \n  vec2 s = shape(q.xyz)/vec2(q.w*sc, 1);\n  \n  float at = mod(iTime, 100.0);\n  vec3 gop = op - vec3(0, 0, at);\n  \n  vec2 t = vec2(length(gop) - 0.1, 2.0);\n  \n  glow += 0.1/(0.01 + t.x*t.x);\n  \n  return s.x < t.x ? s : t;\n}\n\nfloat form(vec2 p) {\n  p = mod(p + 2.0, 4.0) - 2.0;\n  \n  for(int i = 0; i < 10; i++) {\n    p = abs(p)/clamp(dot(p, p), 0.5, 0.8) - vec2(0.0, 0.6);\n  }\n  \n  return smoothstep(0.5, 0.8, abs(p.y));\n}\n\nfloat mat(vec3 p, vec3 n) {\n  vec3 m = pow(abs(n), vec3(10.0));\n  \n  float x = form(p.yz);\n  float y = form(p.xz);\n  float z = form(p.xy);\n  \n  return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 bump(vec3 p, vec3 n, float bf) {\n  vec2 h = vec2(0.01, 0.0);\n  vec3 g = vec3(\n    mat(p - h.xyy, n),\n    mat(p - h.yxy, n),\n    mat(p - h.yyx, n));\n  \n  g -= mat(p, n);\n  g -= n*dot(g, n);\n  \n  return normalize(n + bf*g);\n}\n\nvec3 mat(vec3 p, vec3 n, sampler2D s) {\n  vec3 m = pow(abs(n), vec3(10.0));\n  \n  vec3 x = texture(s, p.yz).rgb;\n  vec3 y = texture(s, p.xz).rgb;\n  vec3 z = texture(s, p.xy).rgb;\n  \n  return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 bump(vec3 p, vec3 n, sampler2D s, float bf) {\n  vec2 h = vec2(0.009, 0.0);\n  \n  vec3 g = mat3(\n    mat(p - h.xyy, n, s),\n    mat(p - h.yxy, n, s),\n    mat(p - h.yyx, n, s))*vec3(0.299, 0.589, 0.114);\n  \n  g -= dot(mat(p, n, s), vec3(0.299, 0.589, 0.114));\n  g -= n*dot(g, n);\n  \n  return normalize(n + bf*g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  \n  vec3 col = vec3(0);\n  \n  float at = mod(iTime, 100.0);\n  \n  vec3 ro = vec3(0, 0, -3.0 + at);\n  ro.xy -= path(ro.z);\n  \n  vec3 la = vec3(0, 0, at);\n  la.xy -= path(la.z);\n  \n  vec3 ww = normalize(la-ro);\n  vec3 uu = cross(vec3(0, 1, 0), ww);\n  vec3 vv = cross(ww, uu);\n  vec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 1));\n  \n  float t = 0.0, m = -1.0, mx = 50.0;\n  for(int i = 0; i < 200; i++) {\n    vec2 d = de(ro + rd*t);\n    if(d.x < 0.001 || t >= mx) break;\n    t += d.x*0.75;\n    m = d.y;\n  }\n  \n  vec2 h = vec2(0.001, 0.0);\n  vec3 salb = vec3(1.00, 0.89, 0.25);\n  vec3 lp = ro + vec3(0, 0, 3);\n  \n  if(t < mx) {\n    vec3 p = ro + rd*t;\n    vec3 n = normalize(vec3(\n      de(p + h.xyy).x - de(p - h.xyy).x,\n      de(p + h.yxy).x - de(p - h.yxy).x,\n      de(p + h.yyx).x - de(p - h.yyx).x));\n   \n    vec3 alb = salb;\n    \n    vec3 ld = normalize(lp-p);\n    \n    if(m == 1.0) {\n      alb = vec3(0.1, 0.2, 0.3);\n      n = bump(p*0.25, n, 2.0);\n    } else if(m == 2.0) {\n      alb = vec3(0.3, 0.2, 0.1);\n      n = bump(p, n, iChannel0, 1.0);\n    }\n    \n    float ot = t/50.0;\n    float occ = exp2(-pow(max(0.0, 1.0 - de(p + n*ot).x/ot), 2.0));\n    float dif = max(0.0, dot(ld, n));\n    \n    float spe = pow(max(0.0, dot(reflect(-ld, n), -rd)), 16.0);\n    float fre = pow(dot(rd, n) + 1.0, 2.0);\n    \n    col = 2.0*mix(occ*(alb*(0.1 + dif) + salb*spe), alb, fre);\n  }\n  \n  col += 0.05*salb*glow;\n   \n  //col = mix(col, vec3(0.2, 0.3, 0.4), 1.0 - exp(-0.1*t));\n  //col = vec3(1)*form(uv);\n  fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}