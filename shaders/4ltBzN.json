{
    "Shader": {
        "info": {
            "date": "1583504123",
            "description": "prototype of an sdf.\narrow keys. shift and ctrl to move.\npress spacebar to set the center of the sdf test sphere.",
            "flags": 48,
            "hasliked": 0,
            "id": "4ltBzN",
            "likes": 2,
            "name": "flatrounded cube",
            "published": 3,
            "tags": [
                "3d",
                "improvement"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "vec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nfloat shape(vec3 p,float s, float r) {\n    \n    \n    vec3 p2 = abs(p);\n    //q.x is the smallest, q.z is the biggest, q.y is in the middle\n    //q reflects the sdf so i can reduce calculations\n    vec3 q = vec3(min(min(p2.x,p2.y),p2.z),0,max(max(p2.x,p2.y),p2.z));\n    q.y = p2.x+p2.y+p2.z-q.x-q.z;\n    \n    float l = q.z-s-r;\n    l = max(l,(p2.x+p2.y+p2.z-s*3.0-r)/sqrt(3.0));\n    l = max(l,((q.y+q.z-s*2.0-r)/sqrt(2.0)));\n    \n    if (l < 0.0 || q.y < s) return l;\n    \n    if (q.y-q.z+r<0.0)\n    {\n        float a = length(max(q.xy-s,vec2(0)));\n        l = length(vec2(q.z-r-s,a));\n    }\n    else if (q.x > s&&l>0.0)\n    {\n        float tri = max(dot(q,vec3(-2.0, 1.0, 1.0))-r,0.0);\n\n        tri /= sqrt(6.0);\n        \n        float tric = length(vec2(tri,(dot(p2,vec3( 1.0, 1.0, 1.0))-r-s*3.0)/sqrt(3.0)));\n        \n        l = tric;\n    }\n    \n    return l;\n}\n\nfloat scene(vec3 p) {\n    \n    vec3 q = mod(p,4.0)-2.0;\n    \n    return abs(shape(q,sin(iTime)*0.5+0.5, cos(iTime)*0.5+0.5)-0.2);\n}\n\nfloat sdftest(vec3 p) {\n    vec3 sph = getdata(sphere).xyz;\n    \n    if (sph == vec3(0)) return FAR;\n    \n    float size = scene(sph);\n    \n    return length(p-sph)-size;\n}\n\nfloat map(vec3 p) {\n    \n    float l = scene(p);\n    \n    l = min(l,abs(sdftest(p)));\n    \n    return l-0.001;\n}\n\nint getsurface(vec3 p) {\n    \n    if (scene(p) < 0.002) return 1;\n    \n    return 2;\n}\n\nvec3 getnormal(vec3 p) {\n    vec2 e = vec2(0,0.001);\n    \n    return normalize(vec3(\n        map(p+e.yxx)-map(p-e.yxx),\n        map(p+e.xyx)-map(p-e.xyx),\n        map(p+e.xxy)-map(p-e.xxy)));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    \n    float d = 0.0;\n    \n    for (int i = 0; i < 1000; i++) {\n        float l = map(ro+rd*d);\n        \n        if (l < 0.001 || d > FAR) {\n            return d;\n        }\n        \n        d += l;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = getdata(campos).xyz;\n    vec3 rd = normalize(vec3(uv,1));\n\n    vec4 rotcam = getdata(camrot);\n\n    rd.zy *= rot(rotcam.y);\n    rd.zx *= rot(rotcam.x);\n    \n    float l = march(ro,rd);\n    \n    vec3 col = -rd*0.25+0.25;\n    \n    if (l < FAR) {\n        vec3 p = ro+rd*l;\n        int id = getsurface(p);\n        vec3 n = getnormal(p);\n            \n        float a = max(0.1,dot(n,normalize(vec3(1))));\n\t\t\n        a /= (l*l*0.005+1.0);\n        \n        if (id == 1) {\n            col = n*0.5+0.5;\n        } else {\n            col = vec3(a);\n        }\n        \n        float b = max(scene(p),sdftest(p));\n        b = max(1.0-b*b*1000.0,0.0);\n        \n        col = mix(col,vec3(1),b);\n    }\n\t\n    fragColor.rgb = pow(col,vec3(1.0/2.2));    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat getkey(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\nvec4 updatedata(int index) {\n    vec4 data = getdata(index);\n    \n    vec4 iMouse2 = getdata(lastmouse);\n    \n    \n    bool refresh = iFrame == 0;\n    \n    if (index == lastmouse) {\n        return iMouse;\n    } else if (index == campos) {\n        \n        if (refresh) {\n            return vec4(vec3(0),1);\n        }\n        \n        vec4 rotcam = getdata(camrot);\n        \n        vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                         getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                         getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n        \n        move.zy *= rot(rotcam.y);\n        move.zx *= rot(rotcam.x);\n        \n        vec3 newpos = data.xyz+movespeed*move*iTimeDelta;\n        \n        data.xyz = newpos;\n        \n        return data;\n    } else if (index == camrot) {\n        \n        if (refresh) {\n            return vec4(0,0,0,0);\n        }\n        \n        if (min(iMouse2.z,iMouse.z) > 0.5) {\n            data.xy += (iMouse.xy-iMouse2.xy)/iResolution.y*sensitivity;\n        }\n        \n        return data;\n    } else if (index == sphere) {\n        \n        if (refresh) {\n            return vec4(0,0,0,0);\n        }\n        \n        if (getkey(KEY_SPACE,0) > 0.5) {\n            data = getdata(campos);\n        }\n        \n        return data;\n    }\n    \n    \n    return data;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = updatedata(coord.x+coord.y*int(iResolution.x));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define lastmouse 0\n#define campos 1\n#define camrot 2\n#define sphere 3\n\n#define pi acos(-1.0)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define sc(a) vec2(sin(a),cos(a))\n#define sqr(a) (a*a)\n\n#define FAR 100.0\n\n#define sensitivity 3.0\n#define movespeed 2.0\n\n//keyboard keys\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_RIGHT 39\n#define KEY_LEFT  37\n#define KEY_SHIFT 16\n#define KEY_CTRL  17\n#define KEY_SPACE 32\n\n//movement keys\n#define MOVE_FORW   KEY_UP\n#define MOVE_LEFT   KEY_LEFT\n#define MOVE_RIGHT  KEY_RIGHT\n#define MOVE_BACK   KEY_DOWN\n#define MOVE_UP     KEY_SHIFT\n#define MOVE_DOWN   KEY_CTRL\n\n\n\n/*\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n\tfloat tN = max(max( t1.x, t1.y ), t1.z);\n\tfloat tF = min(min( t2.x, t2.y ), t2.z);\n\n\treturn vec2(max(tN,0.0), tF);\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat smax( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//cone distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\n//cone distance modified to be more accurate at the top of the cone, not used\nfloat cone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xz);\n    \n    vec2 q2 = vec2(max(dot(vec2(-c.y,c.x),vec2(q,p.y)),0.0),\n                   dot(c,vec2(q,p.y)));\n    return length(q2)*sign(q2.y);\n    \n    if (dot(vec2(-c.y,c.x),vec2(q,p.y)) < 0.0) {\n        return dot(c,vec2(q,p.y));\n    } else {\n        return length(vec2(q,p.y));\n    }\n}\n\n//cylinder distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat cylinder( vec3 p, vec2 s)\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(max(abs(q)-s,0.0));\n}\n\n//torus distance from iq\n//https://iquilezles.org/articles/distfunctions\nfloat torus( vec3 p, float s)\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    return length(abs(q)-vec2(s,0));\n}\n\nfloat halftorus(vec3 p,float s)\n{\n    float len = abs(length(vec2(p.x,min(p.y,0.0)))-s);\n    return length(vec3(len,max(p.y,0.0),p.z));\n}\n\n//box distance by iq\n//https://iquilezles.org/articles/distfunctions\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat box2(vec3 p) {\n    return length(max(p,0.0))+min(0.0,max(max(p.x,p.y),p.z));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    return box2(abs(p)-b);\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// special cone with a bottom\nfloat cone( vec3 p, vec2 c, float bot)\n{\n    p.x = length(p.xz); //for 3d\n    \n    float l = dot(c,p.xy);\n    \n    vec2 q = p.xy-c*l;\n    \n    if (q.x < 0.0) {\n        l = length(p.xy)*sign(p.y);\n    } else if (q.y < -bot && p.x > c.y/c.x*bot) {\n        l = length(p.xy-vec2(c.y/c.x*bot,-bot));\n    } else if (l < 0.0) {\n        l = max(l,-p.y-bot);\n    }\n    \n    return l;\n}\n\nfloat pie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat pizza(vec3 p, vec2 c, float r, float h) {\n    \n    vec2 q;\n    q.y = abs(p.y)-h;\n    q.x = pie(p.xz,c,r);\n    \n    return length(max(q,0.0));\n    \n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat char(vec3 p) {\n    \n    float l = capsule(p,vec3(0,2,-1),vec3(0,2,1))-0.9;\n    //l = min(l, length(p-head)-0.5);\n    \n    vec3 headp = vec3(0,3,4);\n    \n    l = smin(l,capsule(p,vec3(0,2,1.2),headp)-0.4,0.2);\n    \n    vec3 q = p-headp;\n    q.xz *= rot(pi*0.6);\n    q.yz *= rot(pi*0.0);\n    q.xy *= rot(pi*0.65);\n    \n    float head = pizza(q-vec3(0,-0.2,-1.0),sc(0.4),1.2, 0.18)-0.05;\n    \n    head = smin(head, length(q-vec3(0,-0.3,0))-0.5,0.1);\n    \n    l = smin(l,head,0.05);\n    \n    return l;\n    \n}\n\nfloat mid(vec3 p) {\n    p = max(p,p.yzx);\n    \n    return min(min(p.x,p.y),p.z);\n}\n\nvec3 mmid(vec3 p) {\n    return   p.x<min(p.y,p.z) ? p.y<p.z ? vec3(0,1,0) : vec3(0,0,1)\n           : p.x>max(p.y,p.z) ? p.y>p.z ? vec3(0,1,0) : vec3(0,0,1)\n           : vec3(1,0,0);\n}\n\nfloat menger(vec3 p) {\n    vec3 d = abs(p)-0.5;\n    \n    for (float s = 1.0; s < 10.0; s *= 3.0) {\n        \n        vec3 f = clamp(floor((p+0.5/s)*s),1.0-s,s-1.0)/s;\n        \n        vec3 q = abs(p-f);\n        \n        q = (1.0/s)/6.0-q;\n        \n        vec3 m = vec3(greaterThan(q,max(q.yzx,q.zxy)));\n        \n        q *= 1.0-m;\n        d = max(d,q);\n    }\n    \n    \n    \n    return box2(d);\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}