{
    "Shader": {
        "info": {
            "date": "1552246302",
            "description": "for task1\nТени, ToneMap, экспоненциональный туман, окружение в виде текстурированного куб-мапа, использование конструктивной сплошной геометрии, гамма коррекция",
            "flags": 0,
            "hasliked": 0,
            "id": "WssXDS",
            "likes": 1,
            "name": "Jump",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "questina",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 512\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define SPHERE_COLOR vec3(1.,.05,.05)\n#define TORUS_COLOR vec3(0.,1.,1.)\n#define ELLIPSOID_COLOR vec3(1.,.6,.4)\n#define CAPSULE_COLOR vec3(.4,.8,1.)\n#define PLANE_COLOR vec3(1.,1.,0)\n#define HEXANDSPHERE_COLOR vec3(0.6,0.,0.3);\n#define BOX_COLOR vec3(0.38,0.17,0.05)\n#define GRAD_STEP 0.01\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){ //эллипс\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r){ //капсула\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab)/dot(ab, ab);\n    t = clamp (t, 0., 1.);\n    vec3 c = a + t*ab;\n    float d = length(p-c) - r;\n    return d;   \n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2){ //тор\n    float x = length(p.xz) - r1;\n    float y = length(p.y);\n    float d = length(vec2(x,y)) - r2;\n    return d;\n}\n\nfloat sdHexPrism(in vec3 p, in vec2 h){ //шестиугольная призма\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat opU(float d1, float d2){ //union\n    return min(d1,d2);\n}\n\nfloat opS(float d1, float d2){ //sub\n    return max(-d1,d2);\n}\n\nfloat opI(float d1, float d2){ //intersection\n    return max(d1,d2);\n}\n\nfloat sdSphere(in vec3 p, in vec4 r){ //сфера\n    return length(p-r.xyz)-r.w;\n}\n\nfloat udBox(in vec3 p, in vec3 b){ //бокс\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat HexAndSphere(in vec3 p){\n    float dh = sdHexPrism(p-vec3(-1.,1.,4.), vec2(.2,.6));\n    float ds = sdSphere(p, vec4(-1,1,4,.5));\n    return opS(dh,ds);\n}\n\nfloat GetDist(in vec3 p, out vec3 color){\n    float SphereDist = sdSphere(p,vec4(-2,1,7,0.7));\n    float PlaneDist = p.y+1.; \n    \n    float BoxDist = udBox(p, vec3(3.,0.,10.));\n    \n    float CapsuleDist = sdCapsule(p, vec3(0,1,6), vec3(1,2,6), .2);\n    \n    vec3 tor = p - vec3(3,2,6);\n   \ttor.xy *= Rot(sin(iTime)/1.2+cos(iTime)/2.+1.51);\n    float TorusDist = sdTorus(tor, 1.0, .3);\n    \n    float EllipsDist = sdEllipsoid(p-vec3(2,.5,4), vec3(1,.2,.2));\n    \n    vec3 has = p;\n    has.xy *= Rot(sin(iTime)/1.7+.6);\n    float HexAndSphereDist = HexAndSphere(has);\n    \n    float d = min(SphereDist, PlaneDist); //находим минимальное расстояние, чтобы не залезть за шар или типо того\n    d = min(d, CapsuleDist);\n    d = min(d, TorusDist);\n    d = min(d, EllipsDist);\n    d = min(d, HexAndSphereDist);\n    d = min(d, BoxDist);\n    if (d == SphereDist) {\n        float f = mod(floor(4.0 * p.z) + floor(4.0 * p.x), 2.0); //check sphere\n        color = 0.3 + f * vec3(0.6);\n    }\n    if (d == TorusDist) color = TORUS_COLOR;\n    if (d == PlaneDist) color = PLANE_COLOR;\n    if (d == CapsuleDist) color = CAPSULE_COLOR;\n    if (d == EllipsDist) color = ELLIPSOID_COLOR;\n    if (d == HexAndSphereDist) color = HEXANDSPHERE_COLOR;\n    if (d == BoxDist) color = BOX_COLOR;\n    return d;\n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, out vec3 color){\n\tfloat steps = 0.; //расстояние до точки сцены\n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*steps; //находим точку по параметрическому уравнению прямой\n        float dis = GetDist(p, color);\n        steps += dis;\n        if (steps>MAX_DIST || dis<SURF_DIST) break; //если слишком далеко или уже близко, то не считаем дальше\n    }\n    return steps;\n}\n\nvec3 gradient(in vec3 pos) {\n\tvec3 dx = vec3(GRAD_STEP,0.,0.);\n\tvec3 dy = vec3(0.,GRAD_STEP,0.);\n\tvec3 dz = vec3(0.,0.,GRAD_STEP);\n    vec3 col;\n\treturn normalize( vec3( GetDist(pos + dx, col) - GetDist(pos - dx, col),\n\t\t\t\t\t\t\tGetDist(pos + dy, col) - GetDist(pos - dy, col),\n\t\t\t\t\t\t\tGetDist(pos + dz, col) - GetDist(pos - dz, col)\t\t\t\n    ));\n}\n\nvec3 GetNormal (vec3 p){\n    return normalize(gradient(p));\n}\n\nfloat GetLight(in vec3 p){\n    vec3 col;\n    vec3 lightPos = vec3 (0,6,0); //расположение источника света\n    vec3 lightPos2 = vec3 (3,6,0);\n    lightPos.xz += vec2(cos(iTime), -sin(iTime))*2.; //двигающийся источник света\n    lightPos.zy += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p); //направляем источник света к нашей точке сцены\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n = GetNormal(p); //ищем нормаль\n    \n    float dif = clamp(dot(n, l), 0., 1.); //чтобы не зайти в цвет -1, используем clamp\n    float dif2 = clamp(dot(n,l2),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*3.,l, col);//рисуем тень\n    float d2 = RayMarch(p+n*SURF_DIST*3.,l2, col);\n    if (d < length(lightPos-p)) dif *= .1;\n    if (d2 < length(lightPos2-p)) dif2 *= .1;\n    return dif+dif2;   \n}\n\nvec3 frenel(in vec3 F,in vec3 h,in vec3 l){\n\treturn F+(1.0-F)*pow(clamp(1.0-dot(h,l),0.0,1.0),5.0);\n}\n\nvec3 ref(in vec3 p,in vec3 n,in vec3 dir,in vec3 orig){\n    float shiness = 15.0;\n    vec3 ref = reflect(dir,n); //ambient\n    vec3 Ks = vec3(0.5,0.5,0.5); //specular\n    vec3 Kd = vec3(1.,1.,1.); //diffuse\n    \n    vec3 light_pos = vec3(0,6,0);\n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    light_pos.xz += vec2(cos(iTime), sin(iTime))*2.; \n    \n    vec3 vl = normalize(light_pos - p);\n    vec3 dif = Kd*vec3( max(0.0, dot(vl, n)));\n    vec3 spec = vec3( max(0.0, dot(vl, ref)));\n    vec3 Fren = frenel(Ks, normalize(vl - dir), vl);\n    spec = pow(spec, vec3(shiness));\n    \n    vec3 res;\n    res += light_color*mix(dif, spec, Fren);\n    \n    light_pos = vec3(3,6,0);\n    light_color = vec3(1.0, 1.0, 1.0);\n    light_pos.zy += vec2(sin(iTime), cos(iTime))*2.;\n    \n    vl = normalize(light_pos - p);\n    dif = Kd*vec3( max(0.0, dot(vl,n)));\n    spec = vec3( max(0.0, dot(vl, ref)));\n    Fren = frenel( Ks, normalize(vl - dir), vl);\n    spec = pow(spec, vec3(shiness));\n    \n    res += light_color * mix(dif, spec, Fren);\n    res += texture( iChannel1, ref ).rgb * frenel( Ks, n, -dir );   \n    return res;\n}\n\nvec3 Tonemap(in vec3 p){\n    return (p*(2.5*p+0.1))/(p*(2.4*p+0.6)+0.2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; //начало координат в центре\n    \n    vec3 origin = vec3(0,3,0); //расположение камеры\n   \n    vec3 raydirection = normalize(vec3(uv.x,uv.y-.4,1)); //нормализованное направление луча\n    \n    vec3 color;\n    float dist = RayMarch(origin, raydirection, color); //находим расстояние до точки сцены\n   \n    vec3 p = origin + raydirection*dist; \n    vec3 col = ref(p, GetNormal(p), raydirection, origin);\n    float light = GetLight(p);\n\n    if (color == PLANE_COLOR){\n        fragColor = texture(iChannel1, raydirection);\n        return;\n    }\n    color = Tonemap(color);\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.02 * dist * dist)); //туман экспоненциальный\n\tcol = pow(col, vec3(1./2.2)); //гамма коррекция\n   \tfragColor = vec4(color*light*col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}