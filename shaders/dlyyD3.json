{
    "Shader": {
        "info": {
            "date": "1700730508",
            "description": "Fork of @jarble's A multiscale truchet weave pattern using triangle waves instead of trigonometric functions.\nSliders control paramters\nHorizontal controlVector x,y and z\nVertical controls logic of triangle wave (0-8)",
            "flags": 48,
            "hasliked": 0,
            "id": "dlyyD3",
            "likes": 4,
            "name": "Multiscale neonTruchet w/paramUI",
            "published": 3,
            "tags": [
                "font",
                "keyboard",
                "digits",
                "sliders",
                "widgets",
                "util"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "// Fork of \"Multiscale neon truchet\" by jarble. https://shadertoy.com/view/DtycDc\n// 2023-11-23 08:20:15\n\n\n#define triwave(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\n\nvec4 controlV;\n\nvec4 t1(vec2 c, vec2 p){\n    return triwave((.5 - length( min(p=fract(p*sign(triwave1(c*c.y))), 1.-p.yx) )) * controlV);// vec4(13,31,7,3)); //vec4(22,7,5,0));\n}\n\nbool logicControl(int logic, vec4 t_, vec4 t1_, vec4 t3_) {\n //Lots of interesting patterns here!\n switch(logic) {\n    case 0:\n       return t3_.y>t1_.y;\n    case 1:\n       return t_.y>t_.x;   //good\n    case 2:\n       return t1_.y>t1_.z;\n    case 3:\n       return 1.-t_.z>t1_.y||1.-t_.y>t1_.x||1.-t_.x>t1_.z;  //good\n    case 4:\n      return t1_.y>t_.y||t1_.z>t_.z||t1_.x>t_.x;\n    case 5:\n      return t_.y<t1_.y;\n    case 6:\n      return t_.x>t1_.x&&t_.y<t1_.x;   //good v2 also\n    case 7:\n      return t_.z>.5||t_.y>.5||t_.z>.5;\n   }\n   // default:\n   // case 8:\n      return t1_.z>t_.z||t1_.y>t_.y||t1_.z>t_.z;  //good\n   \n}\n\nvec4 triangleWave(int iterations, vec2 I)\n{\n    vec2 p = (I/1e2+iTime);\n    vec4 t_ = t1(ceil(p),p);\n    vec4 t1_ = vec4(0.),\n    t3_ = vec4(0.);\n    float scale = 1.;\n    \n    for(int i = 0; i < iterations;i++){\n        t1_ = t1(ceil(p/scale),p/scale);\n        scale *= 2.;\n        t3_ = 1.-min(t_,t1_);\n        if(logicControl(int(controlV.a), t_, t1_, t3_ ) ) {\n          t_ = 1.-t1_;\n        }\n    }\n    return t3_;\n}    \n\n\n\n\n\n\n\n\n// Fork of \"digits/sliders/kbd widgets - 2\" by FabriceNeyret2. https://shadertoy.com/view/MdKGRw\n// 2023-11-23 08:06:54\n\n// ---- digits/sliders/kbd widgets utilities ----------------------------\n// if you use it, please let a link to this shader in comments\n// for others can get the full set (possibly updated and expended).\n\n// updated version of old  https://www.shadertoy.com/view/lsXXzN\n// ----------------------------------------------------------------------\n\n// define your sliders in BufA.  value [0,1]  = UI(i).a    , i=1..16\n// define your buttons in BufA.  value {-1,1} = UI(i+16).a , i=1..16\n// get mouse position enriched by demo-mode in UI(33)\n// get prev mouse position in UI(34) (e.g.: detect move, get velocity, direction...)\n\n// see below functions for\n// - reading the keyboard\n// - drawing sliders and buttons\n// - drawing floats and digits\n// - demoing the mouse states\n\n\n// --- keyboard -----------------------------------------------------\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\nbool keyClick(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\n\n\n// --- Digit display ----------------------------------------------------\n\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\n\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat digit(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); // minus sign.\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn digit(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot) { // dot: bit 0 = bottom dot; bit 1 = top dot\n\tfloat point0 = float(dot/2),\n\t\t  point1 = float(dot)-2.*point0; \n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n\treturn 0.;\n}\n//    ... end of digits adapted from Andre\n\n#define STEPX .875\n#define STEPY 1.5\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\n\n// 2digit int + sign\nfloat display_digit(vec2 uv, float scale, float offset, int number, int dot) { // dot: draw separator\n\n\tuv = (uv-0.)/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\t\n\tfloat seg = showNum(uv,number,false);\n\toffset += 2.;\n\t\n\tif (dot>0) {\n\t\tuv.x += STEPX*offset; \n\t\tseg += dots(uv,dot);\n\t\toffset += 2.;\n\t}\n\n\t_offset = offset;\n\treturn seg;\n}\n\n// 2.2 float + sign\nfloat display_float(vec2 pos, float scale, float offset, float val) { // dot: draw separator\n\tif (display_digit( pos, scale, 0., int(val), 1)>0.) return 1.;\n    if (display_digit( pos, scale, _offset, int(fract(abs(val))*100.), 0)>0.) return 1.;\n\treturn 0.;\n}\n\n\n\n// --- sliders and mouse widgets -------------------------------------------\n\nvec2 R;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n#define Swidth  .004\n#define Sradius .02\n#define Bradius .04\n#define Mradius .02\n\nvec4 affMouse(vec2 uv)  { // display mouse states ( color )\n    vec4 mouse = UI(33);                       // current mouse pos\n    float k = length(mouse.xy/R.y-uv)/Mradius,\n          s = sign(mouse.z);\n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(s,1.-s,0,1); \n\t\n    k = length( UI(34).xy/R.y-uv)/Mradius;     // prev mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,0,1,1); \n            \n    k = length(abs(mouse.zw)/R.y-uv)/Mradius;  // drag start  mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,.4,s,1); \n\t\n\treturn vec4(0);\n}\n\n\nfloat aff_sliders(vec2 U) { // display sliders ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l/2.)<l/2. ) return 1.;\n        if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l/2.)<l/2. ) return 1.;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\n    }\n    return 0.;       \n}\n\nfloat aff_buttons(vec2 U) { // display buttons ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).y) break;\n        vec4 S = UI(i+17.);\n        float l = length(U-S.xy);\n        if (l < Bradius) \n            if (S.a>0.) return 1.; \n            else return .3+smoothstep(.7,1.,l/Bradius);\n    }\n    return 0.;\n}        \n\n\n// --------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = iResolution.xy;\n\tvec2 uv = fragCoord.xy/R.y;\n    vec4 mouse = UI(33)/R.y;\n    \n\t// display sliders and buttons \n\t{ float s = aff_sliders(uv); if (s>0.) { fragColor = s*vec4(1,.2,0,1); return;}}\n    { float b = aff_buttons(uv); if (b>0.) { fragColor = b*vec4(0,0,1,1);  return;}}\n\n\t\n\t// display counters\n\tvec2 pos ; \n\tfloat scale = 0.04;\n\t\n    \n        \n    int param1 = int(UI(1).a*PARAM1_SCALE);\n    int param2 = int(UI(2).a*PARAM2_SCALE);\n    int param3 = int(UI(3).a*PARAM3_SCALE);\n    int param4 = int(UI(4).a*PARAM4_SCALE);\n \n    int param5 = int(UI(5).a*PARAM5_SCALE);\n    \n\tpos = vec2(.7,.25);    if (display_digit( uv-pos, scale, 0., param1, 0)>0.) { fragColor=vec4(1); return;}\n\tpos.y -= STEPY*scale*2.; if (display_digit( uv-pos, scale, 0., param2, 0)>0.) { fragColor=vec4(1); return;} \n\tpos.y -= STEPY*scale*2.; if (display_digit( uv-pos, scale, 0., param3, 0)>0.) { fragColor=vec4(1); return;}\n    \n    pos = vec2(.05, .64);\n    if (display_digit( uv-pos, scale, 0., param4, 0)>0.) { fragColor=vec4(1); return;} \n\n    pos = vec2(.12, .64);\n    if (display_digit( uv-pos, scale, 0., param5, 0)>0.) { fragColor=vec4(1); return;} \n\t //pos.y -= STEPY*scale; if (display_float( uv-pos, scale, 0., mod(iTime,60.))>0.) { fragColor=vec4(1); return;} \n\n  //  // display mouse states\n  //  fragColor = affMouse(uv); if (fragColor!=vec4(0)) return; \n\t \t\n        \n   controlV = vec4( param1, param2, param3, param4); //iMouse.x/10.0, iMouse.y/10.0, iMouse.x/100.0, iMouse.y/100.0 );\n    \n        \n    fragColor= triangleWave(param5, fragCoord.xy); \n    \n    \n    \n    \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// only line 0, pixels 0 to 33 of bufA are used\n// if you need the full buffer but the .a components, you might adapt this util to use only .a \n\n#define FAKE_MOUSE 0 // fake mouse motion if no user input\n#define Sradius .02  // influence radius for sliders\n#define Bradius .04  // influence radius for buttons\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n#define add_button(x,y,v0)     { nbB++; if (U==vec2(nbB+16,0.)) O = vec4(x,y,0,v0);       }\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O = texture(iChannel0,U/R);\n    U -= .5;\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        add_slider (.15,.25,HORIZ, .5, PARAM1_INITIAL_VALUE/PARAM1_SCALE); // --- define your sliders here ---\n        add_slider (.15,.15,HORIZ, .5, PARAM2_INITIAL_VALUE/PARAM2_SCALE); // read value [0,1] in UI(i).a  , i=1..16\n        add_slider (.15,.05,HORIZ, .5, PARAM3_INITIAL_VALUE/PARAM3_SCALE); // read value [0,1] in UI(i).a  , i=1..16\n\n        add_slider (.05,.15,VERTIC,.5,PARAM4_INITIAL_VALUE/PARAM4_SCALE);\n        add_slider (.10,.15,VERTIC,.5,PARAM5_INITIAL_VALUE/PARAM5_SCALE);\n        \n     //   add_button ( .8  ,.1,  1.);          // --- define your buttons here ---\n     //   add_button ( .9  ,.1, -1.);          // read value {-1,1} in UI(i+16).a , i=1..16\n    //    add_button ( 1.  ,.1, -1.);          \n    //    add_button ( 1.1 ,.1, -1.);       /   \n        \n        if (U==vec2(0,0)) O.xy = vec2(nbS, nbB);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  // previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)<10. && m.z<=0.) { // fake mouse motion if no user input\n\t        float t = iTime;         // you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    if (U==vec2(34,0)) { O = UI(33); return; } // previous mouse state (for other shaders)\n    \n    if (iMouse.z>0. && U.y==0.) {          // --- let mouse trigers the right slider or button\n       \tvec2 M = iMouse.xy/iResolution.y;\n        if (U.x <= UI(0).x) {\n\t        vec4 S = UI(U.x);\n    \t    float l = abs(S.z);\n        \tvec2 m = iMouse.xy/iResolution.y;\n\t        if (S.z>0. && abs(M.y-S.y)<Sradius && abs(M.x-S.x-l/2.)<l/2. ) O.a = (M.x-S.x)/l;\n    \t    if (S.z<0. && abs(M.x-S.x)<Sradius && abs(M.y-S.y-l/2.)<l/2. ) O.a = (M.y-S.y)/l;\n    \t}\n        else if (UI(33).z<0. &&  U.x>16. && U.x<=16.+UI(0).y ) {\n\t        vec4 S = UI(U.x);\n            if (length(M-S.xy)<Bradius) O.a *= -1.;\n        }\n    }\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PARAM1_INITIAL_VALUE  22.0\n#define PARAM2_INITIAL_VALUE   7.0\n#define PARAM3_INITIAL_VALUE   5.0\n\n#define PARAM4_INITIAL_VALUE   0.0   //Logic 0-8\n#define PARAM5_INITIAL_VALUE   3.0   //Iterations\n\n\n#define PARAM1_SCALE  100.0        \n#define PARAM2_SCALE  100.0        \n#define PARAM3_SCALE  100.0        \n#define PARAM4_SCALE  9.0    \n#define PARAM5_SCALE  6.0    \n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}