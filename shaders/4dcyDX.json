{
    "Shader": {
        "info": {
            "date": "1520407844",
            "description": "Render orbit of the points",
            "flags": 0,
            "hasliked": 0,
            "id": "4dcyDX",
            "likes": 2,
            "name": "InversionFractalOrbit",
            "published": 3,
            "tags": [
                "schottky",
                "iis"
            ],
            "usePreview": 0,
            "username": "soma_arc",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "/*\nCreated by soma_arc 2018\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec4 getNyanCatColor(vec2 p, float time ){\n    p = clamp(p,0.0,1.0);\n\tp.x = p.x*40.0/256.0;\n    float fr = floor( mod( 20.0*time, 6.0 ) );\n\tp.x += fr*40.0/256.0;\n\treturn texture( iChannel0, p);\n}\n\nconst vec3 c1 = vec3(100, -100, 100);\nconst vec3 c2 = vec3(100, 100, 100);\nconst vec3 c3 = vec3(-100, 100, 100);\nconst vec3 c4 = vec3(-100, -100, 100);\n\nvec2 circleReflect(vec2 pos, vec3 circle){\n\treturn ((pos - circle.xy) * circle.z * circle.z)/(distance(pos, circle.xy) * distance(pos, circle.xy) ) + circle.xy;\n}\n\nconst int MAX_ITERATIONS = 30;\nvec2 reflections(vec2 pos, out int numReflect){\n\tnumReflect = 0;\n    for(int i = 0 ; i < MAX_ITERATIONS ; i++){\n\t\tbool loopEnd = true;\n        if(distance(pos, c1.xy) < c1.z) {\n            pos = circleReflect(pos, c1);\n            loopEnd = false;\n            numReflect++;\n        } else if (distance(pos, c2.xy) < c2.z) {\n            pos = circleReflect(pos, c2);\n            loopEnd = false;\n            numReflect++;\n        } else if (distance(pos, c3.xy) < c3.z) {\n        \tpos = circleReflect(pos, c3);\n            loopEnd = false;\n            numReflect++;\n        } else if (distance(pos, c4.xy) < c4.z) {\n            pos = circleReflect(pos, c4);\n            loopEnd = false;\n            numReflect++;\n        }\n\n        if(loopEnd) break;\n\t}\n    return pos;\n}\n\nconst float GAMMA = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgba) {\n\treturn vec3((min(pow(rgba.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.b, DISPLAY_GAMMA_COEFF), 1.))\n               );\n}\n\nvec3 degamma(vec3 rgba) {\n\treturn vec3((min(pow(rgba.r, GAMMA), 1.)),\n                (min(pow(rgba.g, GAMMA), 1.)),\n                (min(pow(rgba.b, GAMMA), 1.))\n               );\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 orbitPoints[12];\nint computeOrbits(vec2 pos) {\n    int numReflect = 0;\n    orbitPoints[0] = pos;\n    for(int i = 1 ; i < 12 ; i++){\n\t\tbool loopEnd = true;\n        if(distance(pos, c1.xy) < c1.z) {\n            pos = circleReflect(pos, c1);\n            loopEnd = false;\n\t\t\torbitPoints[i] = pos;\n            numReflect++;\n        } else if (distance(pos, c2.xy) < c2.z) {\n            pos = circleReflect(pos, c2);\n            loopEnd = false;\n            orbitPoints[i] = pos;\n            numReflect++;\n        } else if (distance(pos, c3.xy) < c3.z) {\n        \tpos = circleReflect(pos, c3);\n            loopEnd = false;\n            orbitPoints[i] = pos;\n            numReflect++;\n        } else if (distance(pos, c4.xy) < c4.z) {\n            pos = circleReflect(pos, c4);\n            loopEnd = false;\n            orbitPoints[i] = pos;\n            numReflect++;\n        }\n\n        if(loopEnd) break;\n\t}\n    return numReflect;\n}\n\nbool renderOrbit(vec2 pos, out vec3 col, int numOrbit){\n    col = vec3(0);\n    for(int i = 0; i <= numOrbit; i++) {\n        if(distance(pos, orbitPoints[i]) < 5.) {\n            col = vec3(0, 0, 1);//computeOrbitColor(float(i));\n            return true;\n        }\n        if(i > 0) {\n            vec2 p1 = orbitPoints[i - 1];\n            vec2 p2 = orbitPoints[i];\n            vec2 v = p2 - p1;\n            vec2 n = normalize(vec2(-v.y, v.x));\n            vec2 posP1 = pos - p1;\n            vec2 posP2 = pos - p2;\n            if(dot(posP1, posP2) < 0. &&\n               abs(dot(n, posP1)) < 1.) {\n                col = vec3(0, 1, 1);//computeOrbitColor(float(i));\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nconst float SAMPLE_NUM = 50.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 sum = vec3(0);\n    float t = iTime;\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n       \n\tfloat scale = 430.;\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\t\tvec2 mouse = ( (iMouse.xy) / iResolution.yy ) - vec2(ratio, 0.5);\n\n        position = position * scale;\n        mouse = mouse * scale;\n        \n        int numOrbit = computeOrbits(mouse);\n        vec3 col;\n        if (renderOrbit(position, col, numOrbit)) {\n        \tsum += col;\n            continue;\n        }\n        \n        int numReflect;\n        vec2 pos = reflections(position, numReflect);\n        \n        vec4 nc = getNyanCatColor((pos + vec2(30)) / 60., t);\n        if(nc.a == 1.) {\n        \tsum += degamma(nc.rgb);\n            continue;\n        }\n        \n        if(numReflect > 0) {\n        \tsum += hsv2rgb(vec3(0.01 + float(numReflect - 1) * 0.03 , 1., 1.));\n        }\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}