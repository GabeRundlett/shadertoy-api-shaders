{
    "Shader": {
        "info": {
            "date": "1681350472",
            "description": "reflecting go brrr\n\nplease tell me if u have improvements I'm still inexperienced with this type of programming\n\nworking on tri textur\n\nhttps://www.youtube.com/watch?v=Qz0KTGYJtUk\nhttps://www.shadertoy.com/view/XlXcW4\nhttps://www.shadertoy.com/view/Xltfzj",
            "flags": 32,
            "hasliked": 0,
            "id": "mdVSzK",
            "likes": 2,
            "name": "Raeytreacre",
            "published": 3,
            "tags": [
                "raytracer"
            ],
            "usePreview": 0,
            "username": "ThePlaneGuy45",
            "viewed": 230
        },
        "renderpass": [
            {
                "code": "#define blurQUAL 3.0\n#define blurDIR 16.0\n#define blurSIZE 2.0\n\n// Blur by existical, https://www.shadertoy.com/view/Xltfzj\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / iResolution.x;\n    \n    vec2 rad = blurSIZE / iResolution.xy * ratio;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    for( float i = 0.0; i < TAU; i += TAU/blurDIR ) {\n    \n\t\tfor( float j = 1.0/blurQUAL; j <= 1.0; j += 1.0/blurQUAL ) {\n        \n            vec4 add = texture(iChannel0, uv + vec2( cos(i), sin(i) ) * rad * j);\n            \n            if(dot(abs(add), add) > 0.0) {\n        \n                color += add;\n                \n            }\n            \n        }\n        \n    }\n    \n    color /= blurQUAL * blurDIR + blurSIZE;\n    \n    fragColor = color;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    if(iMouse.z > 0.0) {\n    \n        if(fragCoord.x/iResolution.x < 0.5){\n        \n            fragColor = (iMouse - vec4(iResolution.xy/2.0, 0.0, 0.0)) * 4.0;\n        \n        } else {\n        \n            fragColor = vec4(float(iFrame));\n            \n        }\n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Triangle + Sphere algorithm found in the video:\n// \"Coding Adventure: Ray Tracing\" by Sebastian Lague\n// https://www.youtube.com/watch?v=Qz0KTGYJtUk\n\nuint raySphere(in Sphere sph, inout Record rec) {\n\n    vec3 offset = rec.ray.origin - sph.center;\n    float a = 2.0 * dot(offset, rec.ray.normal);\n    float b = dot(offset, offset) - sph.radius * sph.radius;\n    float disc = a * a - 4.0 * b;\n    \n    if (disc > 0.0) {\n    \n        float s = sqrt(disc);\n        float dstNear = max(0.0,(-a-s)/2.0);\n        float dstFar = (-a+s)/2.0;\n        \n        if(dstNear < rec.dist) {\n        \n            if(dstNear > 0.0) {\n        \n                rec.intersect = (rec.ray.normal * dstNear) + rec.ray.origin;\n                rec.normal = normalize(rec.intersect - sph.center);\n                rec.dist = dstNear;\n                rec.material = sph.material;\n                rec.hit = true;\n                rec.center = (rec.intersect - sph.center - sph.radius) / sph.radius;\n                \n                return uint(0x1);\n        \n            }\n        \n        }\n        \n        return uint(0x0);\n    \n    }\n\n}\n\nuint rayTri(in Triangle tri, inout Record rec) {\n\n    vec3 ab = tri.b - tri.a;\n    vec3 ac = tri.c - tri.a;\n    vec3 normal = ab.yzx * ac.zxy - ab.zxy * ac.yzx;\n    vec3 ao = rec.ray.origin - tri.a;\n    vec3 dao = cross(ao, rec.ray.normal);\n    \n    float det = 1.0 / (-dot(rec.ray.normal, normal));\n    \n    float dist = dot(ao, normal) * det;\n    float u = dot(ac, dao) * det;\n    float v = -dot(ab, dao) * det;\n    float w = 1.0 - u - v;\n    \n    bool hit = det >= 1e-6 && dist >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;\n    \n    if(hit && dist < rec.dist) {\n    \n        rec.intersect = (rec.ray.normal * dist) + rec.ray.origin;\n        rec.normal = normalize(normal);\n        rec.dist = dist;\n        rec.material = tri.material;\n        rec.hit = true;\n        rec.center = tri.a;\n                \n        return uint(0x1);\n    \n    }\n    \n    return uint(0x0);\n\n}\n\n/*= Objects ========================================*/\n/*==================================================*/\n\nvoid distances(inout Record rec) {\n\n    raySphere(Sphere(Material(vec3(0.0, 0.0, 0.0), true, 2, vec3(0.0), 1.0, 0.0, 0.0, 0.0, vec3(1.0, 1.0, 1.0)), vec3(100.0, 120.0, 50.0), 60.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.0, 1.0), false, 0, vec3(0.0), 0.0, 0.0, 0.0, 0.0, vec3(1.0, 1.0, 1.0)), vec3(0.0, 60.0, -50.0), 50.0), rec);\n    raySphere(Sphere(Material(vec3(1.0, 1.0, 1.0), false, 0, vec3(0.0), 0.0, 0.0, 0.2, 1.0, vec3(1.0, 1.0, 1.0)), vec3(-50.0, 150.0, 0.0), 50.0), rec);\n    \n    rayTri(Triangle(Material(vec3(0.0, 1.0, 0.0), false, 0, vec3(0.0), 0.0, 0.0, 0.0, 0.0, vec3(1.0, 1.0, 1.0)), vec3(100.0, 120.0, 50.0), vec3(0.0, 60.0, -50.0), vec3(-50.0, 150.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0)), rec);\n    \n    rayTri(Triangle(Material(vec3(0.75, 0.75, 0.75), false, 0, vec3(0.0), 0.0, 0.0, 0.1, 1.0, vec3(1.0, 1.0, 1.0)), vec3(-250.0, 0.0, -250.0), vec3(-250.0, 0.0, 250.0), vec3(250.0, 0.0, -250.0), vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0)), rec);\n    rayTri(Triangle(Material(vec3(0.75, 0.75, 0.75), false, 0, vec3(0.0), 0.0, 0.0, 0.1, 1.0, vec3(1.0, 1.0, 1.0)), vec3(250.0, 0.0, 250.0), vec3(250.0, 0.0, -250.0), vec3(-250.0, 0.0, 250.0), vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0)), rec);\n}\n\n/*==================================================*/\n/*==================================================*/\n\nvoid initRay(vec2 fragCoord, inout Record rec) {\n\n    rec.ray.origin = vec3(0.0, 0.0, 0.0);\n    rec.ray.normal = normalize(vec3(fragCoord, FOCAL_LENGTH) - rec.ray.origin);\n\n}\n\nvoid initRecord(inout Record rec) {\n\n    rec.hit = false;\n    rec.dist = 10000000.0;\n\n}\n\n// Random vec3 function Copyright Â© 2017 Inigo Quilez\n// Can be found here: https://www.shadertoy.com/view/XlXcW4\n\nvec3 random(inout uvec3 state) {\n\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    \n    return vec3(state)*(1.0/float(0xffffffffU));\n\n}\n\n// Normal distrobution also found in Sebastian Lague video linked above\n\nvec3 randomNormal(vec3 normal, inout uvec3 state) {\n\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    \n    vec3 y = vec3(state)*(1.0/float(0xffffffffU));\n    \n    vec3 theta = 2.0 * PI * y;\n    vec3 rho = sqrt(-2.0 * log(y));\n    y = rho * cos(theta);\n    \n    if(dot(y, normal) < 0.0) {\n        \n        y -= y;\n        \n    }\n    \n    return y;\n    \n}\n\nfloat sech(float x) {\n\n    return 6.0 / ( exp(x) + exp(-x) );\n\n}\n\nvec3 sky(inout Record rec) {\n\n    float t = tanh(rec.ray.normal.y) * 0.5 + 0.5;\n    float d = dot(rec.ray.normal, normalize(vec3(-1.0, 1.0, 1.0)));\n    d = sech(500.0 * (1.0 - d));\n    vec3 sky =  mix(vec3(0.01, 0.12, 0.17), vec3(0.35, 0.74, 0.95), t);\n    return mix(sky, vec3(1.0, 0.93, 0.71) * SUNSTRENGTH, d);\n\n}\n\nvec4 triPlanar(sampler2D tex, vec3 offset, vec3 normal, float scale) {\n\n    vec3 blend = normalize(max(abs(normal), 0.000001));\n    float sum = blend.x + blend.y + blend.z;\n    blend /= sum;\n    vec4 x = texture(tex, offset.yz * scale);\n    vec4 y = texture(tex, offset.xz * scale);\n    vec4 z = texture(tex, offset.xy * scale);\n    return x * blend.x + y * blend.y + z * blend.z;\n\n}\n\nvec4 texturize(int id, vec3 offset, vec3 normal, float scale) {\n\n    switch(id) {\n    case 0:\n        return triPlanar(iChannel0, offset, normal, scale);\n    case 1:\n        return triPlanar(iChannel1, offset, normal, scale);\n    case 2:\n        return triPlanar(iChannel2, offset, normal, scale);\n    case 3:\n        return triPlanar(iChannel3, offset, normal, scale);\n    }\n    return vec4(0.0);\n\n}\n/*\nvec2 triUV(vec2 a, b, c, p, auv, buv, cuv) {\n\n    ac = a-c;\n    bc = b-c;\n    ca = c-a;\n    cb = c-b;\n    pc = p-c;\n    barya = (bc.y * pc.x + cb.x * pc.y) / (bc.y * ac.x + cb.x * ac.y);\n    baryb = (ca.y * pc.x + ac.x * pc.y) / (bc.y * ac.x + cb.x * ac.y);\n    baryc = 1.0 - barya - baryb;\n    uv = barya * auv + baryb * buv + baryc * cuv;\n\n}\n*/\nvec3 singleRay(in Camera cam, in vec2 fragCoord, inout uvec3 state) {\n\n    Record rec;\n    initRecord(rec);\n    initRay(fragCoord, rec);\n    \n    rec.ray.normal = normalize(rec.ray.normal + vec3(random(state).xy * 0.01, 0.0));\n    \n    rec.ray.origin += cam.position + random(state);\n    \n    rec.ray.normal.zy = vec2(\n        cos(cam.direction.y) * rec.ray.normal.z - sin(cam.direction.y) * rec.ray.normal.y,\n        sin(cam.direction.y) * rec.ray.normal.z + cos(cam.direction.y) * rec.ray.normal.y\n    );\n    rec.ray.normal.zx = vec2(\n        cos(cam.direction.x) * rec.ray.normal.z - sin(cam.direction.x) * rec.ray.normal.x,\n        sin(cam.direction.x) * rec.ray.normal.z + cos(cam.direction.x) * rec.ray.normal.x\n    );\n    \n    vec3 increment = vec3(1.0);\n    vec3 color = vec3(0.0);\n    \n    bool first = true;\n    \n    for ( int i; i < MAXBOUNCES; i++ ) {\n    \n        distances(rec);\n        \n        if(rec.hit) {\n        \n            rec.ray.origin = rec.intersect;\n            float spec = float(rec.material.glossiness > random(state).x);\n            rec.ray.normal = mix(randomNormal(rec.normal, state), reflect(rec.ray.normal, rec.normal), spec);\n            initRecord(rec);\n            \n            vec3 matColor;\n            if(rec.material.usetexture) {\n            \n                matColor = texturize(rec.material.texID, rec.center + rec.material.texOffset, rec.normal, rec.material.texScale).rgb;\n            \n            } else {\n            \n                matColor = rec.material.color;\n            \n            }\n        \n            color += (matColor * rec.material.emission) * increment;\n            increment *= mix(matColor, rec.material.clearcoatcolor, rec.material.clearcoat);\n        \n        } else {\n        \n            float mul;\n        \n            if(first) {\n            \n                mul = 1.0;\n            \n            } else {\n            \n                mul = SKYMUL;\n            \n            }\n        \n            color += sky(rec) * mul * increment;\n            \n            break;\n        \n        }\n        \n        first = false;\n    \n    }\n    \n    return color;\n\n}\n\nvec3 Trace(in Camera cam, in vec2 fragCoord, inout uvec3 state) {\n\n    vec3 color = vec3(0.0);\n    float sub = float(SAMPLES);\n    \n    for(int i; i < SAMPLES; i++) {\n    \n        vec3 result = singleRay(cam, fragCoord, state);\n        \n        if(length(result) == 0.0) {\n        \n            sub--;\n        \n        } else {\n        \n            color += singleRay(cam, fragCoord, state);\n        \n        }\n    \n    }\n    \n    if(sub > 0.0) {\n    \n        color /= sub;\n        \n    }\n    \n    return color;\n\n}\n\nCamera getCam(vec2 iMouse) {\n\n    Camera cam;\n    \n    cam.direction = vec3(iMouse.xy, 1.0);\n    cam.position = vec3(0.0, 0.0, -500.0);\n    cam.position.zy = vec2(\n        cos(cam.direction.y) * cam.position.z - sin(cam.direction.y) * cam.position.y,\n        sin(cam.direction.y) * cam.position.z + cos(cam.direction.y) * cam.position.y\n    );\n    cam.position.zx = vec2(\n        cos(cam.direction.x) * cam.position.z - sin(cam.direction.x) * cam.position.x,\n        sin(cam.direction.x) * cam.position.z + cos(cam.direction.x) * cam.position.x\n    );\n    \n    return cam;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float ratio = iResolution.y/iResolution.x;\n    \n    vec2 mouse = (texture(iChannel1, vec2(0.4, 0.5)).xy / iResolution.xy - vec2(0.5, 0.5)) * vec2(1.0, ratio);\n    vec2 coord = (fragCoord / iResolution.xy - vec2(0.5, 0.5)) * vec2(1.0, ratio);\n\n    Camera cam = getCam(mouse);\n    uvec3 state = uvec3(fragCoord, iFrame);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 old = texture(iChannel0, uv);\n    vec4 current = vec4(Trace(cam, coord, state),1.0);\n    \n    float frame = float(iFrame + 1) - texture(iChannel1, vec2(0.6, 0.5)).x;\n    \n    fragColor = vec4(frame);\n    \n    float weight = 1.0 / frame;\n    \n    if( iMouse.z > 0.0 ) {\n    \n        fragColor = current;\n    \n    } else {\n    \n        fragColor = mix(old, current, weight);\n    \n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define FOCAL_LENGTH 0.4\n#define FOCUS_LENGTH 500.0\n#define MAXBOUNCES 10\n#define SAMPLES 10\n\n#define SKYMUL 0.5\n#define SUNSTRENGTH 200.0\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\n// Most of the code is my own, except the tracing/random distribution functions.\n// I am not smart enough to make those ;-;\n// If you want to use any piece of code OTHER than those functions, please credit me.\n// If you use any other things in here, credit the original creator.\n// Links to sources in both code + description\n// - TPG\n\nstruct Material {\n\n    vec3 color;\n    bool usetexture;\n    int texID;\n    vec3 texOffset;\n    float texScale;\n    float emission;\n    float glossiness;\n    float clearcoat;\n    vec3 clearcoatcolor;\n\n};\n\nstruct Sphere {\n\n    Material material;\n    vec3 center;\n    float radius;\n\n};\n\nstruct Triangle {\n\n    Material material;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec2 auv;\n    vec2 buv;\n    vec2 cuv;\n\n};\n\nstruct Camera {\n\n    vec3 position;\n    vec3 direction;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Record {\n\n    Ray ray;\n    bool hit;\n    Material material;\n    vec3 normal;\n    vec3 intersect;\n    float dist;\n    vec3 center;\n\n};",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}