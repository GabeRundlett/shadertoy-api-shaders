{
    "Shader": {
        "info": {
            "date": "1495356173",
            "description": "A simple canyon\\gorge fly-through. Not much different to the many other examples on here, but fun to make.",
            "flags": 0,
            "hasliked": 0,
            "id": "lslfRN",
            "likes": 126,
            "name": "Dry Rocky Gorge",
            "published": 3,
            "tags": [
                "noise",
                "terrain",
                "clouds",
                "flythrough",
                "canyon",
                "gorge"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 9359
        },
        "renderpass": [
            {
                "code": "/*\n\n\tDry Rocky Gorge\n\t---------------\n\n\tThis is a very simple terrain example, and not much different to the many others on here. \n\tOverall, it's not that inspiring - After all, there are only so many ways you can render a\n\tterrain scene; Terrain, sky, fake normal-based ground coloring. Not much effort went into \n\tit. In fact, I probably spent more time choosing the ground texture and sky color than \n\tcreating the terrain. :) \n\n    I've been playing around with low-poly terrain lately, but believe it or not, using a modern\n\tmachine to emulate the way things looked on old machines isn't always as easy as you'd think. :)\n\tTherefore, I took a break and coded up a very cliche medium-level terrain fly-though.\n\n\tThe lighting is fudged in a lot of places - especially where the clouds are concerned, so I\n\twouldn't pay too much attention to it. In fact, you could ignore most of the code and just \n\tlook at the camera setup and distance function.\n\n\tThe geometry is very basic. Render a plane, carve out a squarish tube, wrap it around the\n\tcamera path, then add some noise layers to the result. Not much to it. For the terrain itself,\n\tI'd hoped to make use of IQ's gradient noise derivatives code, but speed was an issue, so I let \n\tit go. Maybe next time. :)\n\n\tThere wouldn't be much code here if it were not for the cloud layering routine that I dropped\n    in. It's only used for four layers, which meant the aesthetic returns were rather diminished, \n\tso it was hardly worth the effort.\n\n\tAnyway, I have a lot of more interesting examples than this that I hope to add at some point.\n\n\n*/\n\n#define FAR 80. // Maximum ray distance. Analogous to the far plane.\n//#define HIGHER_CAMERA // Gives a slightly more overhead view of the gorge.\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - See Nimitz's comment.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// vec3 to float hash.\nfloat hash31( vec3 p ){ return fract(sin(dot(p, vec3(157, 113, 7)))*45758.5453); }\n\n// vec3 to float hash.\nfloat hash21( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I put this together, so be \n// careful how much you trust it. :D\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll \n// swap it for something more robust later.\nfloat n2D(vec2 p) {\n \n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); //p *= p*p*(p*(p*6. - 15.) + 10.);    \n    \n\treturn dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n\n}\n \n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Straight path.\n    return vec2(sin(z*.075)*8., cos(z*.1)*.75); // Windy path.\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n//vec2 tri(in vec2 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n/*\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n*/\n\n// Basic terrain - in the form of noise layering. How it's approached depends on the desired outcome, but\n// in general you add a layer of noise, vary the amplitude and frequency, then add another layer, and so\n// on. Other additions include skewing between layers (which is done here) and attenuating the amplitudes\n// with the noise derivatives (For cost reasons, I left that out). Of course, you can do this with functions \n// other than noise, like Voronoi, sinusoidal variations, triangle noise, etc.\nfloat terrain(vec2 p){\n    \n    p /= 8.; // Choosing a suitable starting frequency.\n    \n    // Edging the terrain surfacing into a position I liked more. Not really necessary though.\n    p += .5; \n\n    // Amplitude, amplitude total, and result variables.\n    float a = 1., sum = 0., res = 0.;\n\n    // Only five layers. More layers would be nicer, but cycles need to be taken into\n    // consideration. A simple way to give the impression that more layers are being added\n    // is to increase the frequency by a larger amount from layer to layer.\n    for (int i=0; i<5; i++){\n        \n        res += n2D(p)*a; // Add the noise value for this layer - multiplied by the amplitude.\n        //res += abs(n2D3(p) - .5)*a; // Interesting variation.\n        //res += n2D3(p)*abs(a)*.8; // Another one.\n        \n        // Scaling the position and doing some skewing at the same time. The skewing isn't \n        // mandatory, but it tends to give more varied - and therefore - interesting results.\n        // IQ uses this combination a bit, so I'll assume he came up with the figures. I've \n        // tried other figures, but I tend to like these ones as well.      \n        p = mat2(1, -.75, .75, 1)*p*2.72;\n        //p *= 3.2; // No skewing. Cheaper, but less interesting.\n        \n        sum += a; // I reasoned that the sum will always be positive.\n        \n        // Tempering the amplitude. Note the negative sign - a less common variation - which\n        // was thrown in just to mix things up.\n        a *= -.5/1.7; \n    }\n    \n   \n    return res/sum; // Return the noisy terrain value.\n    \n}\n\n \n\n// The gorge terrain setup up: It's just a flat plane with a channel cut out of it, which is\n// wrapped around the camera path. Then, a few layers of simple 2D noise is added to it.\nfloat map(vec3 p){\n    \n\n    // The noise layers.\n    float trSf = terrain(p.xz);\n \n    p.xy -= path(p.z); // Wrap the gorge around the path.\n\n    // The canyon - or gorge, which consists of a mixed circle and square shape, extruded along\n    // the path. It's been stretched, lowered, then subtracted from the flat plane, before adding\n    /// the noise layers.\n    vec2 ca = abs(p.xy*vec2(1, .7) + vec2(0, -2.75)); // Stretch and lower space.\n    \n    // Smoothly carve out the gorge from the plane, then add the noise to the result.\n    float n = smax(6. - mix(length(ca), max(ca.x, ca.y), .25), p.y - 1.75, 2.) + (.5 - trSf)*4.;\n\n\n    return n; // Return the minimum hit point.\n \n}\n \n\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)) )/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding why we perform this step. It's been a while, but I vaguely recall\n    // that it's some kind of orthogonal space fix using the Gram-Schmidt process. However, \n    // all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<160; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.05 + 1.) || t>FAR) break;\n        \n        t += d*.7;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 n, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n \n    float shade = 1.;\n    float dist = .0;  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .02, .25); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .15, 1.); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(.001, -.001); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 nor){\n\n\tfloat sca = 1.5, occ = 0.;\n    \n    for(float i=0.; i<5.; i++){\n        float hr = .01 + i*.5/4.;        \n        float dd = map(nor*hr + p);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n}\n\n\n\n\n// Distance function.\nfloat fmap(vec3 p){\n\n    // Three layers of noise. More would be nicer.\n    p *= vec3(1, 4, 1)/400.;\n    \n    return n3D(p)*0.57 + n3D(p*4.)*0.28 + n3D(p*8.)*0.15;\n}\n\n// Used in one of my volumetric examples. With only four layers, it's kind of going to waste\n// here. I might replace it with something more streamlined later.\nvec4 cloudLayers(vec3 ro, vec3 rd, vec3 lp, float far){\n    \n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    rd = (rd + (hash33(rd.zyx)*0.004-0.002)); \n    // Randomizing the length also. \n    rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.04-0.02); \n    \n    // Some more randomization, to be used for color based jittering inside the loop.\n    //vec3 rnd = hash33(rd+311.);\n\n    // Local density, total density, and weighting factor.\n    float ld=0., td=0., w=0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d=1., t=0.;\n    \n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n    \n    vec4 d4 = vec4(1, 0, 0, 0);\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<4; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if(td>1. || t>far)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = fmap(sp); // Closest distance to the surface... particle.\n        //d4 = fmap(sp); // Closest distance to the surface... particle.\n        \n        //d = d4.x;\n        //sn = normalize(d4.yzw);\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        ld = (h - d) * step(d, h); \n        w = (1. - td) * ld;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        //td += w*w*8. + 1./60.; //w*w*5. + 1./50.;\n        td += w*.5 + 1./65.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 100./(1. + lDist*0.005 + lDist*lDist*0.00005);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n        \n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations.\n        //col += w*(1. + diff*.5 + spec*.5)*atten;\n \n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        col += w*(diff + vec3(1, .75, .5)*spec + .5)*atten;//*1.25;\n        \n        // Optional extra: Color-based jittering. Roughens up the grey clouds that hit the camera lens.\n        //col += (fract(rnd*289. + t*41.)-.5)*0.02;;\n\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t += max(d4.x*.5, 0.25)*100.; //* 0.75\n        // t += 0.2; // t += d*0.5;// These also work, but don't seem as efficient.\n\n    }\n    \n    //t = min(t, FAR); //24.\n    \n    return vec4(col, t);\n        \n}\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp, float t){\n\n\t\n\tfloat sun = max(dot(rd, normalize(lp - ro)), 0.0); // Sun strength.\n\tfloat horiz = pow(1.0-max(rd.y, 0.0), 3.)*.25; // Horizon strength.\n\t\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\tvec3 col = mix(vec3(.25, .5, 1)*.8, vec3(.8, .75, .7), sun*.5);//.zyx;\n    // Mixing in the sun color near the horizon.\n\tcol = mix(col, vec3(1, .5, .25), horiz);\n    \n    //vec3 col = mix(vec3(1, .7, .55), vec3(.6, .5, .55), rd.y*.5 + .5);\n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n\tcol += 0.25*vec3(1, .7, .4)*pow(sun, 5.0);\n\tcol += 0.25*vec3(1, .8, .6)*pow(sun, 64.0);\n\tcol += 0.15*vec3(1, .9, .7)*max(pow(sun, 512.0), .25);\n    \n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    col = clamp(col + hash31(rd)*0.04 - 0.02, 0., 1.);\n    \n    //return col; // Clear sky day. Much easier. :)\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n    \n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n    \n    // Give the direction ray a bit of concavity for some fake global curvature - My own dodgy addition. :)\n    //rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z + dot(rd.xy, rd.xy)*.1) ));\n \n    // If we haven't hit anything and are above the horizon point (there for completeness), render the sky.\n    \n    // Raytrace to a plane above the scene.\n    float tt = (1000. - ro.y)/(rd.y + .2);\n \n    if(t>=FAR && tt>0.){\n\n        // Trace out a very small number of layers. In fact, there are so few layer that the following\n        // is almost pointless, but I've left it in.\n        vec4 cl = cloudLayers(ro + rd*tt, rd, lp, FAR*3.);\n        vec3 clouds = cl.xyz;\n\n        // Mix in the clouds.\n        col = mix( col, vec3(1), clouds); // *clamp(rd.y*4. + .0, 0., 1.)\n    }\n    \n    return col;\n\n}\n\n \n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    //p.xy -= path(p.z);\n\n    // Object texture color.\n    vec3 tx = tex3D(iChannel0, p/8., n ); // Texture value. Pinkish limestone.\n    \n    // Hinting that there's some dry vegetation below. The flatter the surface (based on n.y), the greater \n    // the chance that something's growing on it. Physical trees would be much nicer, and I'm working on that,\n    // but for now, cheap trickery will have to suffice. :) By the way, take a look at IQ's \"Rainforest\"\n    // example for an amazing looking compromise.\n    vec3 gr = mix(vec3(1), vec3(.8, 1.3, .2), smoothstep(.5, 1., n.y)); \n    return mix(tx, tx*gr, smoothstep(.7, 1., (n.y)));\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n            // Advancing the ray origin, \"ro,\" to the new hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point.\n        vec3 sn = getNormal(sp);\n   \n        vec3 tx = sp;\n        //tx.xy -= path(tx.z);\n        sn = texBump(iChannel0, tx/2., sn, .15);\n        \n        // Shading. Shadows, ambient occlusion, etc.\n        float sh = softShadow(sp, sn, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.25)*ao;\n    \n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 3./(1. + lDist*0.005 + lDist*lDist*0.00005);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 64.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);//mix(sn, oSn, .75)\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.5 + vec3(1, .7, .5)*spec);\n\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    #ifdef HIGHER_CAMERA\n\tvec3 ro = vec3(0, 4, iTime*5.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.05, .25);  // \"Look At\" position.\n    #else\n\tvec3 ro = vec3(0, 0, iTime*5.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.04, .25);  // \"Look At\" position.\n    #endif\n \n   \n    // Light position. Set reasonably far away in the background somewhere. A sun is usually so far \n    // away that direct light is called for, put I like to give it just a bit of a point light feel.\n    vec3 lp = ro + vec3(8, FAR*.26, FAR*.52)*3.;\n    //vec3 lp = ro + vec3(0., 0, 4);\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*right + uv.y*up + forward/FOV);\n    //rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.15, 0.)) ));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/24.);\n    rd.yz *= r2(-sw.y/16.);\n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    \n    // Retrieve the background color.\n    vec3 sky = getSky(ro, rd, lp, t);\n    \n    \n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n         \n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(0., .95, t/FAR); // t/FAR; \n\n    // Blend in the sky. :)\n    vec3 fogCol = sky;//mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5);\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    \n   \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.75 + .25;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 3, 16)), sceneColor, \n                     //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    // A very simple overlay. Two linear waves - rotated at 60 degree angles - to give a dot-matrix vibe.\n    //uv = sin(uv*r2(3.14159/6.)*3.14159*iResolution.y/1.5)*.1 + 1.;\n    //sceneColor *= uv.x*uv.y;\n   \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}