{
    "Shader": {
        "info": {
            "date": "1624772995",
            "description": "Solving for the inverse kinematics of a three link robot arm. Its not much different from the inverse kinematics of a two link arm except one angle must be *arbitrary* (*as long as it makes the rest of the system valid).",
            "flags": 0,
            "hasliked": 0,
            "id": "7ljGDK",
            "likes": 16,
            "name": "Three Link IK Robot Arm",
            "published": 3,
            "tags": [
                "ik",
                "robot",
                "inversekinematics",
                "arm",
                "threelink"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 228
        },
        "renderpass": [
            {
                "code": "// All fixed! :)\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Constants (used in solving)\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\n// In: r1: float(radius 1), r2: float(radius 2), p: vec2(position of circle 2)\n// Out: vec2(intersect angle 1, intersect angle 2)\n// Return: bool(intersecting)\nbool circleCircle(in float r1, in float r2, in vec2 p, out vec2 angles) {\n    float sqDist = dot(p, p);\n\n    float mid = atan(p.y, p.x);\n    float offs = (sqDist + r1 * r1 - r2 * r2) / (2.0 * r1 * sqrt(sqDist));\n    if (abs(offs) > 1.0) return false; // Not intersecting\n    offs = acos(offs);\n\n    angles = vec2(mid - offs, mid + offs);\n    return true;\n}\n\n// In: a: vec2(origin), b: vec2(target), l1: float(link 1 length), l2: float(link 2 length)\n// Out: vec4(left handed angles, right handed angles)\n// Return: int(number of solutions)\nint ikTwoLinkAngles(in vec2 a, in vec2 b, in float l1, in float l2, out vec4 angles) {\n    vec2 ba = b - a, t;\n    if (!circleCircle(l1, l2, ba, t)) return 0; // Solve with circle-circle intersection\n    angles.xy = vec2(t.x, atan(ba.y - sin(t.x) * l1, ba.x - cos(t.x) * l1)); // Deduce second angle\n    angles.zw = vec2(t.y, atan(ba.y - sin(t.y) * l1, ba.x - cos(t.y) * l1)); // Deduce second angle\n    return 2;\n}\n\n// Out: vec4(lower bound 1, upper bound 1, lower bound 2, upper bound 2)\n// Return: int(number of boundaries)\n// Once a valid solution is chosen, the remainder can be solved with 2 link kinematics\n// Interestingly similar to factoring polynomials eh? Except easier :D\nint ikThreeLinkSolutionBounds(in vec2 a, in vec2 b, in float l1, in float l2, in float l3, out vec4 bounds) {\n    float outer = abs(l3 + l2), inner = abs(l3 - l2);\n    vec2 ba = b - a;\n    int count = 0;\n\n    float dist = length(ba);\n    if (dist < outer - l1 && (dist < l1 - inner || dist > l1 + inner)) { // All angles are solutions\n        bounds.xy = vec2(0.0, TAU);\n        return 1;\n    }\n\n    if (circleCircle(l1, outer, ba, bounds.xy)) count++; // Outer bound of solution set\n    if (circleCircle(l1, inner, ba, bounds.zw)) { // Inner bound of solution set\n        if (count == 0) bounds.xy = vec2(bounds.w, bounds.z + TAU); // Change the interpolation direction\n        else bounds = bounds.xzwy; // Sort\n        count++;\n    }\n\n    return count;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0, 0.5);\n\n    vec2 a = vec2(0.0); // Origin\n    vec2 b = mouse; // Target\n\n    // Link lengths\n    float l1 = 1.5;\n    float l2 = 0.8;\n    float l3 = 0.5;\n\n    vec4 foo;\n    if (ikThreeLinkSolutionBounds(a, uv, l1, l2, l3, foo) > 0) color.gb = vec2(0.75);\n\n    // Bound calculation\n    float R2inner = abs(l3 - l2); // Inner bound of last two links\n    float R2outer = l3 + l2; // Outer bound of last two links\n\n    float R3inner = l1 < R2inner ? abs(l1 - R2inner) : max(0.0, l1 - R2outer); // Inner bound of all three links\n    float R3outer = l1 + R2outer; // Outer bound of all three links\n\n    drawSDF(abs(sdDisk(uv, a, R3inner)), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(sdDisk(uv, a, R3outer)), vec3(1.0, 0.0, 0.0));\n\n    // Diagrams\n    float inner = abs(l3 - l2), outer = abs(l3 + l2);\n    float radius = 0.5 * (inner + outer), thickness = 0.5 * (outer - inner);\n    drawSDF(sdRing(uv, b, radius, thickness), vec3(0.2, 0.8, 0.5)); // Fill\n    drawSDF(abs(sdRing(uv, b, radius, thickness)), vec3(0.0)); // Outline\n    drawSDF(abs(sdDisk(uv, a, l1)) - 0.01, vec3(1.0, 0.5, 0.0));\n\n    // Boundary angles are crossings with the boundaries of the two final links\n    vec2 anglesInner, anglesOuter;\n    vec2 ba = b - a;\n\n    if (circleCircle(l1, inner, ba, anglesInner)) {\n        vec2 c1 = a + vec2(cos(anglesInner.x), sin(anglesInner.x)) * l1;\n        vec2 c2 = a + vec2(cos(anglesInner.y), sin(anglesInner.y)) * l1;\n        drawSDF(sdDisk(uv, c1, 0.05), vec3(0.2, 0.5, 0.8)); // Fill\n        drawSDF(abs(sdDisk(uv, c1, 0.05)), vec3(0.0)); // Outline\n        drawSDF(sdDisk(uv, c2, 0.05), vec3(0.8, 0.2, 0.5)); // Fill\n        drawSDF(abs(sdDisk(uv, c2, 0.05)), vec3(0.0)); // Outline\n    }\n\n    if (circleCircle(l1, outer, ba, anglesOuter)) {\n        vec2 c1 = a + vec2(cos(anglesOuter.x), sin(anglesOuter.x)) * l1;\n        vec2 c2 = a + vec2(cos(anglesOuter.y), sin(anglesOuter.y)) * l1;\n        drawSDF(sdDisk(uv, c1, 0.05), vec3(0.2, 0.5, 0.8)); // Fill\n        drawSDF(abs(sdDisk(uv, c1, 0.05)), vec3(0.0)); // Outline\n        drawSDF(sdDisk(uv, c2, 0.05), vec3(0.8, 0.2, 0.5)); // Fill\n        drawSDF(abs(sdDisk(uv, c2, 0.05)), vec3(0.0)); // Outline\n    }\n\n    // Compute angles\n    vec4 bounds;\n    int numBounds = ikThreeLinkSolutionBounds(a, b, l1, l2, l3, bounds);\n    if (numBounds > 0) {\n        float transition = mix(1e-4, 1.0 - 1e-4, 0.5 + 0.5 * sin(iTime)); // Precision safety\n\n        float minAngle = bounds.x, maxAngle = bounds.y;\n        float angleOfChoice = mix(minAngle, maxAngle, transition); // Choose *arbitrary* angle\n\n        vec4 otherAngles;\n        vec2 p = a + vec2(cos(angleOfChoice), sin(angleOfChoice)) * l1;\n        int numSolutions = ikTwoLinkAngles(p, b, l2, l3, otherAngles);\n        if (numSolutions > 0) {\n            vec3 angles = vec3(angleOfChoice, otherAngles.xy);\n\n            // Joint positions\n            vec2 v1 = a;\n            vec2 v2 = v1 + vec2(cos(angles.x), sin(angles.x)) * l1;\n            vec2 v3 = v2 + vec2(cos(angles.y), sin(angles.y)) * l2;\n            vec2 v4 = v3 + vec2(cos(angles.z), sin(angles.z)) * l3;\n\n            // More diagrams\n            drawSDF(abs(sdDisk(uv, v2, l2)) - 0.01, vec3(0.0, 0.4, 0.4));\n            drawSDF(abs(sdDisk(uv, v4, l3)) - 0.01, vec3(0.0, 0.4, 0.4));\n\n            vec2 otherPos = v2 - reflect(v3 - v2, normalize(v4 - v2));\n            drawSDF(sdDisk(uv, otherPos, 0.05), vec3(0.75)); // Fill\n            drawSDF(abs(sdDisk(uv, otherPos, 0.05)), vec3(0.0)); // Outline\n\n            // Links\n            drawSDF(sdLine(uv, v1, v2, 0.05), vec3(0.0));\n            drawSDF(sdLine(uv, v2, v3, 0.05), vec3(0.0));\n            drawSDF(sdLine(uv, v3, v4, 0.05), vec3(0.0));\n\n            // Joints\n            drawSDF(sdDisk(uv, v1, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v2, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v3, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v4, 0.08), vec3(0.5));\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}