{
    "Shader": {
        "info": {
            "date": "1478275633",
            "description": "Learning a bit about movement, ao and reflections during Codevember 2016",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl3XR4",
            "likes": 12,
            "name": "Walking cubes",
            "published": 3,
            "tags": [
                "raymarching",
                "cubes",
                "codevember"
            ],
            "usePreview": 0,
            "username": "xorxor",
            "viewed": 825
        },
        "renderpass": [
            {
                "code": "// Created by XORXOR, 2016\n// Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)\n//\n// Thanks to iq's articles\n// https://iquilezles.org/articles/distfunctions\n// and the Raymarching - Primitives sample\n// https://www.shadertoy.com/view/Xds3zN\n\n#define SQRT_2 1.4142135623730951\n#define HALF_PI 1.5707963267948966\n#define QUARTER_PI 0.7853981633974483\n\n#define CUBE_SIZE 0.5\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return ( d1.x < d2.x ) ? d1 : d2;\n}\n\nmat3 transform( float a, out vec2 offset )\n{\n    float c = cos( a );\n    float s = sin( a );\n    vec2 v = CUBE_SIZE * SQRT_2 * abs( vec2( cos( a + QUARTER_PI ), sin( a + QUARTER_PI ) ) );\n    offset.x = - min( abs( v.x ), abs( v.y ) );\n    offset.y = max( v.x, v.y );\n    if ( mod( a, HALF_PI ) > QUARTER_PI )\n    {\n        offset.x = - offset.x;\n    }\n    float n = floor( a / QUARTER_PI ) + 2.0;\n    offset.x += CUBE_SIZE * 2.0 * floor( n / 2.0 );\n    offset.x = mod( offset.x, 12.0 ) - 5.0;\n\n    // rotation matrix inverse\n    return mat3( c, 0, s,\n                -s, 0, c,\n                 0, 1, 0 );\n}\n\nfloat udRoundBoxT( vec3 p )\n{\n    float r = 0.1;\n    return length( max( abs( p ) - vec3( CUBE_SIZE - r ), 0.0 ) ) - r;\n}\n\nfloat hash( float n )\n{\n    return fract( sin( n ) * 4121.15393 );\n}\n\nvec2 map( vec3 p )\n{\n    vec2 plane = vec2( abs( p.y ), 1.0 );\n\n    vec2 offset = vec2( 0 );\n    mat3 t = transform( iTime * 2.0, offset );\n    vec3 q = t * ( p  - vec3( offset.x - 0.3, offset.y, -3.0 ) );\n    vec2 box = vec2( udRoundBoxT( q ), 2.0 );\n\n    mat3 t2 = transform( 4.0 + iTime * 2.5, offset );\n    vec3 q2 = t2 * ( p  - vec3( offset.x + 0.1, offset.y, 1.0 ) );\n    vec2 box2 = vec2( udRoundBoxT( q2 ), 3.0 );\n\n    mat3 t3 = transform( 2.0 + iTime * 1.2, offset );\n    vec3 q3 = t3 * ( p  - vec3( offset.x + 0.4, offset.y, -1.2 ) );\n    vec2 box3 = vec2( udRoundBoxT( q3 ), 4.0 );\n\n    mat3 t4 = transform( -1.3 + iTime * 1.75, offset );\n    vec3 q4 = t4 * ( p  - vec3( offset.x + 0.3, offset.y, 2.3 ) );\n    vec2 box4 = vec2( udRoundBoxT( q4 ), 5.0 );\n\n    return opU( opU( box, opU( box2, opU( box3, box4 ) ) ),\n                plane );\n}\n\nvec2 scene( vec3 ro, vec3 rd )\n{\n    float t = 0.1;\n    for ( int i = 0; i < 64; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        vec2 res = map( pos );\n        if ( res.x < 0.0005 )\n        {\n            return vec2( t, res.y );\n        }\n        t += res.x;\n    }\n    return vec2( -1.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 32; i++ )\n    {\n        vec2 h = map( ro + rd * t );\n        res = min( res, 2.0 * h.x / t );\n        t += h.x;\n        if ( ( h.x < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAo( vec3 pos, vec3 n )\n{\n    float occ = 0.0;\n    for ( int i = 0; i < 5; i++ )\n    {\n        float hp = 0.01 + 0.1 * float(i) / 4.0;\n        float dp = map( pos + n * hp ).x;\n        occ += ( hp - dp );\n    }\n    return clamp( 1.0 - 1.5 * occ, 0.0, 1.0 );\n}\n\nvec3 calcNormal( vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n            map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n            map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n            map( pos + eps.yyx ).x - map( pos - eps.yyx ).x );\n    return normalize( n );\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos( 6.28318 * ( c * t + d ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy )/ iResolution.y;\n    vec3 eye = vec3( 0.0, 7.0, 20.0 );\n    vec3 target = vec3( 0.0 );\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0.0, 1.0, 0.0 ) );\n    vec3 cv = cross( cu, cw );\n    mat3 cm = mat3( cu, cv, cw );\n    vec3 rd = cm * normalize( vec3( uv, 6.0 ) );\n\n    vec2 res = scene( eye, rd );\n\n    vec3 col = vec3( 0.0 );\n    if ( res.x >= 0.0 )\n    {\n        vec3 pos = eye + rd * res.x;\n        vec3 n = calcNormal( pos );\n        if ( res.y == 1.0 )\n        {\n        \tcol = vec3( 0.2 + mod( floor( pos.x ) + floor( pos.z ), 2.0 ) );\n        }\n        else\n        {\n            col = palette( ( res.y - 1.0 ) / 4.0,\n                     vec3( 0.5, 0.5, 0.5 ), vec3( 0.5, 0.5, 0.5\t),\n                     vec3( 1.0, 1.0, 1.0 ), vec3( 0.0, 0.33, 0.67 ) );\n        }\n\n        vec3 ldir = normalize( vec3( 0.5, 2.8, 4.0 ) );\n        float sh = calcShadow( pos, ldir, 0.01, 4.0 );\n        float ao = calcAo( pos, n );\n        col *= ( 0.2 + ao ) * ( 0.3 + sh );\n\n        vec3 ref = reflect( rd, n );\n        float refSh = calcShadow( pos, ref, 0.01, 4.0 );\n\n        float dif = max( dot( n, ldir ), 0.0 );\n        float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 15.0 );\n\n        col *= ( 0.3 + dif ) * ( 0.5 + refSh );\n        col += dif * sh *  spe * vec3( 1.0 );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}