{
    "Shader": {
        "info": {
            "date": "1394318071",
            "description": "Somewhere in Europe, 1892 - secret underground bases and steam-powered mechs!\n\nA fun idea that was going to be the followup to my shader \"Industry\", I made back in 2014 - It never got past the \"draft\"-stage.",
            "flags": 8,
            "hasliked": 0,
            "id": "Xd2GW3",
            "likes": 128,
            "name": "Industry II (sound)",
            "published": 3,
            "tags": [
                "tech",
                "art",
                "comic",
                "industry"
            ],
            "usePreview": 0,
            "username": "srtuss",
            "viewed": 5846
        },
        "renderpass": [
            {
                "code": "// srtuss, 2014\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat rand11(float p)\n{\n    return fract(sin(p * 591.32) * 43758.5357);\n}\n\n#define aav 16.0 / iResolution.y\n\nfloat sig(float x)\n{\n\treturn 1.0 / (1.0 + exp(-x));\n}\n\nfloat res(float x)\n{\n\tfloat fl = floor(x);\n\tfloat fr = fract(x);\n\tfloat v = fl + 1.0 / (exp((fr - 0.5) * -100.0) + 1.0);\n\tfloat ph = fract(fr - 0.5);\n\tv += sin(ph * 20.0) * 0.5 * exp(ph * -8.0);\n\treturn v;\n}\n\nvec2 rand22(vec2 p)\n{\n\tvec2 ra = (456.789 * sin(789.123 * p.xy));\n\tvec2 rb = (456.789 * cos(789.123 * p.xy));\n\treturn vec2(fract(ra.x * ra.y + p.x), fract(rb.x * rb.y + p.y));\n}\n\n#define ITS 13\n\nvec2 circuit(vec2 p)\n{\n\tp = mod(p, 2.0) - 1.0;\n\tfloat w = 1e38;\n\tvec2 cut = vec2(1.0, 0.0);\n\tvec2 e1 = vec2(-1.0);\n\tvec2 e2 = vec2(1.0);\n\tfloat rnd = 0.23;\n\tfloat pos, plane, cur;\n\tfloat fact = 0.9;\n\tfloat j = 0.0;\n\tfor(int i = 0; i < ITS; i ++)\n\t{\n\t\tpos = mix(dot(e1, cut), dot(e2, cut), (rnd - 0.5) * fact + 0.5);\n\t\tplane = dot(p, cut) - pos;\n\t\tif(plane > 0.0)\n\t\t{\n\t\t\te1 = mix(e1, vec2(pos), cut);\n\t\t\trnd = fract(rnd * 19827.5719);\n\t\t\tcut = cut.yx;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te2 = mix(e2, vec2(pos), cut);\n\t\t\trnd = fract(rnd * 5827.5719);\n\t\t\tcut = cut.yx;\n\t\t}\n\t\tj += step(rnd, 0.2);\n\t\tw = min(w, abs(plane));\n\t}\n\treturn vec2(j / float(ITS - 1), w);\n}\n\n\n#define pi 3.1415926535897932384626433832795\n#define pi2 6.283185307179586476925286766559\n\nfloat s(float x)\n{\n\treturn sin(x * 2.0 * pi);\n}\n\nvec2 invk(vec2 p, float l1, float l2)\n{\n\tfloat a1, a2;\n\t\n\tfloat g = atan(p.y, p.x);\n\tfloat l3 = length(p);\n\t\n\ta1 = acos((l1*l1 + l3*l3 - l2*l2) / (2.0 * l1*l3));\n\ta2 = acos((l1*l1 + l2*l2 - l3*l3) / (2.0 * l1*l2));\n\t\n\treturn vec2(a1 + g, a2 + pi);\n}\n\nfloat tri(float x)\n{\n\treturn abs(fract(x) * 2.0 - 1.0);\n}\n\nfloat sig2(float x)\n{\n\treturn (1.0 / (1.0 + exp(-x))) * 2.0 - 1.0;\n}\n\n\nvec2 wlk(float t)\n{\n\tvec2 o;\n\to.x = sig2((tri(t) - 0.5) * 10.0) * 0.3;\n\to.y = -0.8 + smoothstep(0.5, 1.0, tri(t - 0.3)) * 0.3;\n\treturn o;\n}\n\nfloat walkw(float t)\n{\n\tfloat fr = fract(t * 2.0);\n\tfloat fl = floor(t * 2.0);\n\treturn (sig((tri(fr * 0.5) - 0.5) * 10.0) - fl * 1.0);\n}\n\nvec2 mech(vec2 p, float t)\n{\n\tvec2 q = p;\n\tfloat mrk = 1e38;\n\t\n\tfloat v;\n\t\n\t\n\tvec2 j0, j1, j2;\n\tj0 = vec2(0.0, sin(t * 200.0) * 0.006 + pow(abs(s(t)), 8.0) * 0.1);\n\tj2 = wlk(t);\n\tvec2 ia = invk(j2 - j0, 0.5, 0.45);\n\t\n\tq -= j0;\n\tv = max(abs(q.x) - 0.35, abs(q.y) - 0.2);\n\tvec2 qq = q;\n\tq.x += 0.2;\n\tq.y += 0.1;\n\tq = rotate(q, ia.x);\n\tq.x += 0.3;\n\tv = min(v, max(abs(q.x) - 0.35, abs(q.y) - 0.12));\n\tq.x += 0.35;\n\tq = rotate(q, ia.y);\n\tq.x += 0.1;\n\tv = min(v, max(abs(q.x) - 0.36, abs(q.y) - 0.1));\n\tq.x += 0.35;\n\tq = rotate(q, pi * -0.5 - (ia.x + ia.y));\n\tq.x += 0.1;\n\tv = min(v, max(abs(q.x) - 0.03, abs(q.y) - 0.2));\n\tj2 = wlk(t + 0.5);\n\tia = invk(j2 - j0, 0.5, 0.45);\n\tq = qq;\n\tq.x += 0.2;\n\tq.y += 0.1;\n\tq = rotate(q, ia.x);\n\tq.x += 0.3;\n\tv = min(v, max(abs(q.x) - 0.35, abs(q.y) - 0.12));\n\tq.x += 0.35;\n\tq = rotate(q, ia.y);\n\tq.x += 0.1;\n\tv = min(v, max(abs(q.x) - 0.36, abs(q.y) - 0.1));\n\tq.x += 0.35;\n\tq = rotate(q, pi * -0.5 - (ia.x + ia.y));\n\tq.x += 0.1;\n\tv = min(v, max(abs(q.x) - 0.03, abs(q.y) - 0.2));\t\n\treturn vec2(v, mrk);\n}\n\nfloat guy(vec2 p, float t)\n{\n\tvec2 q, qq;\n\tp.y -= abs(sin((t + 0.6) * pi2)) * 0.15;\n\tq = rotate(p, sig(sin(t * pi2) * 2.0) * -0.9 + 0.25);\n\tq.y += 0.15;\n\tfloat v = max(abs(q.x) - 0.1, abs(q.y) - 0.3);\n\tq.y += 0.3;\n\tq = rotate(q, sig(sin((t + 0.21) * pi2) * 2.0) * 1.2);\n\tq.y += 0.3;\n\tv = min(v, max(abs(q.x) - 0.1, abs(q.y) - 0.35));\n\tq.y += 0.4;\n\tq = rotate(q, sig(sin((t + 0.3) * pi2) * 5.0 - 2.0) * 0.5);\n\tq.x -= 0.1;\n\tq.y += 0.03;\n\tv = min(v, max(abs(q.x) - 0.18, abs(q.y) - 0.05));\n\tq = rotate(p, sig(sin((t + 0.5) * pi2) * 2.0) * -0.9 + 0.25);\n\tq.y += 0.15;\n\tv = min(v, max(abs(q.x) - 0.1, abs(q.y) - 0.3));\n\tq.y += 0.3;\n\tq = rotate(q, sig(sin((t + 0.21 + 0.5) * pi2) * 2.0) * 1.2);\n\t//q = rotate(q, sig(sin((t + 0.2 + 0.5) * pi2) * 2.0) * 1.0);\n\tq.y += 0.3;\n\tv = min(v, max(abs(q.x) - 0.1, abs(q.y) - 0.35));\n\tq.y += 0.4;\n\tq = rotate(q, sig(sin((t + 0.3 + 0.5) * pi2) * 5.0 - 2.0) * 0.5);\n\tq.x -= 0.1;\n\tq.y += 0.03;\n\tv = min(v, max(abs(q.x) - 0.18, abs(q.y) - 0.05));\n\t//*/\n\tfloat ht = smoothstep(0.3, -0.3, sin(t)) * 0.1 + smoothstep(0.3, -0.3, sin(t * 3.0)) * -0.1;\n\tq = p - vec2(0.0, 0.2);\n\tq = rotate(q, 0.1 + sin(t * pi2 * 0.5) * 0.02 + ht * 0.7);\n\tq.y -= 0.3;\n\tv = min(v, max(abs(q.x) - 0.1, abs(q.y) - 0.4));\n\tqq = q;\n\tq -= vec2(0.0, 0.45);\n\tq = rotate(q, -0.2 - sin((t + 0.5) * pi2) * 0.01 + ht);\n\tq.y -= 0.25;\n\tv = min(v, max(abs(q.x) - 0.15, abs(q.y) - 0.25));\n\tq -= vec2(0.0, 0.15);\n\tv = min(v, max(abs(q.x) - 0.18, abs(q.y) - 0.1));\n\tq -= vec2(0.1, -0.09);\n\tfloat hp = t;\n\tv = min(v, max(abs(q.x) - 0.2 * (1.0 + 0.5 * sin(hp)), abs(q.y) - 0.01));\n\tfloat ap = sin(t * pi2) * -0.08;\n\tq = qq;\n\tq.x += ap;\n\tq.y -= 0.2;\n\tq = rotate(q, sig(sin((t + 0.5) * pi2) * 2.0) * 0.6 - 0.3);\n\tq.y += 0.2;\n\tv = min(v, max(abs(q.x) - 0.1, abs(q.y) - 0.3));\n\tq.y += 0.3;\n\tq = rotate(q, sig(sin((t + 0.2) * pi2) * 2.0) * -0.3);\n\tq.y += 0.2;\n\tv = min(v, max(abs(q.x) - 0.07, abs(q.y) - 0.3));\n\tq.y += 0.4;\n\tv = min(v, max(abs(q.x) - 0.3, abs(q.y) - 0.2));\n\tfloat at = 1.8 * smoothstep(0.6, 1.0, abs(fract(t * 0.1) * 2.0 - 1.0));\n\tq = qq;\n\tq.x -= ap;\n\tq.y -= 0.2;\n\tq = rotate(q, sig(sin((t) * pi2) * 2.0) * 0.6 - 0.3 - at * 0.7);\n\tq.y += 0.2;\n\tv = min(v, max(abs(q.x) - 0.1, abs(q.y) - 0.3));\n\tq.y += 0.3;\n\tq = rotate(q, sig(sin((t + 0.2 + 0.5) * pi2) * 2.0) * -0.3 - at * 0.5);\n\tq.y += 0.2;\n\tv = min(v, max(abs(q.x) - 0.07, abs(q.y) - 0.3));\n\treturn v;\n}\n\nfloat pip1(float r, vec2 p, float l)\n{\n\tfloat v = max(abs(p.x) - r, abs(p.y) - l);\n\tv = min(v, max(abs(p.x) - 0.07, abs(abs(p.y) - (l - 0.05)) - 0.02));\n\treturn v;\n}\n\nfloat pip2(float r, vec2 p, float l)\n{\n\tfloat v = max(abs(p.y) - r, abs(p.x) - l);\n\tv = min(v, max(abs(p.y) - 0.07, abs(abs(p.x) - (l - 0.05)) - 0.02));\n\treturn v;\n}\n\nfloat pip3(float r, vec2 p, float rad, vec2 d)\n{\n\tfloat v = max(max(abs(length(p) - rad) - r, p.x * d.x), p.y * d.y);\n\treturn v;\n}\n\nfloat pipeset(vec2 uv)\n{\n\tfloat v;\n\tv = pip2(0.06, uv, 0.3);\n\tv = min(v, pip3(0.05, uv - vec2(-0.3, 0.2), 0.2, vec2(1.0, 1.0)));\n\tv = min(v, pip1(0.05, uv - vec2(-0.5, 0.6), 0.4));\n\tv = min(v, pip3(0.05, uv - vec2(0.3, -0.2), 0.2, vec2(-1.0, -1.0)));\n\tv = min(v, pip1(0.05, uv - vec2(0.5, -0.6), 0.4));\n\t\n\t\n\tv = min(v, pip2(0.05, uv - vec2(0.45, 0.2), 0.5));\n\tv = min(v, pip3(0.05, uv - vec2(-0.05, 0.3), 0.1, vec2(1.0, 1.0)));\n\tv = min(v, pip1(0.05, uv - vec2(-0.15, 0.7), 0.4));\n\tv = min(v, pip3(0.05, uv - vec2(0.95, 0.0), 0.2, vec2(-1.0, -1.0)));\n\tv = min(v, pip1(0.05, uv - vec2(1.15, -0.5), 0.5));\n\t\n\t\n\tv = min(v, pip2(0.03, uv - vec2(0.2, -0.2), 0.5));\n\tv = min(v, pip3(0.03, uv - vec2(0.7, -0.3), 0.1, vec2(-1.0, -1.0)));\n\tv = min(v, pip1(0.03, uv - vec2(-0.4, -0.1), 1.1));\n\tv = min(v, pip3(0.03, uv - vec2(-0.3, -0.1), 0.1, vec2(1.0, 1.0)));\n\tv = min(v, pip1(0.03, uv - vec2(0.8, -0.8), 0.5));\n\t\n\tv = min(v, length(uv - vec2(-0.1, -0.1)) - 0.03);\n\tv = min(v, length(uv - vec2(0.2, 0.29)) - 0.03);\n\treturn v;\n}\n\nvec2 voronoi(in vec2 x)\n{\n\tvec2 n = floor(x); // grid cell id\n\tvec2 f = fract(x); // grid internal position\n\tvec2 mg; // shortest distance...\n\tfloat md = 8.0;\n\t\n\tfloat corner = 0.0;\n\t\n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 g = vec2(float(i), float(j)); // cell id\n\t\t\tvec2 o = rand22(n + g); // offset to edge point\n\t\t\tvec2 r = g + o - f;\n\t\t\t\n\t\t\tfloat d = max(abs(r.x), abs(r.y)); // distance to the edge\n\t\t\t\n\t\t\tif(d < md)\n\t\t\t{\n\t\t\t\tmd = d;\n\t\t\t\tmg = g;\n\t\t\t}\n\t\t}\n\t}\n\treturn n + mg;\n}\n\n#define SH45(p) dot(p, vec2(0.707, 0.707))\n#define SH45X(p) dot(p, vec2(-0.707, 0.707))\n\nfloat gear(vec2 q)\n{\n\tfloat a = atan(q.y, q.x);\n\tfloat l = length(q);\n\tfloat w = l + smoothstep(-0.9, 0.9, sin(a * 20.0)) * 0.1 - 1.0;\n\tw = max(w, -l + 0.7);\n\tw = min(w, l - 0.3);\n\tw = min(w, max(l - 0.8, min(abs(q.x), abs(q.y)) - 0.1));\n\treturn w;\n}\n\nvec2 layerA(vec2 uv, vec2 co, float t)\n{\t\n\t\n\tvec2 p, q;\n\tp = uv;\n\t\n\tfloat w;\n\tfloat v = guy(uv - vec2(co.x, 0.0), t * 0.6);\n\tv = min(v, guy(vec2(mod(-uv.x - t + 2.0, 30.0) - 15.0, uv.y), t * 0.6 + 0.2));\n\t\n\tw = circuit(uv / 4.0).y * 4.0;\n\t//v = min(v, w);\n\t\n\t\n\tq = uv;\n    q.x = mod(q.x + 11.11, 11.11 * 2.) - 11.11;\n    v = min(v, gear(rotate(q + vec2(1.9, 4.4), res(t) * .2 + .18)));\t\n    v = min(v, gear(rotate(q + vec2(0.005, 4.), res(t) * -.2)));\n\t\n\t\n\t\n\tq = uv * 2.0;\n\tq.x = mod(q.x, 30.0) - 15.0;\n\t\n\tvec2 qq = q;\n\tqq.y += 6.0;\n\tw = max(0.1 - min(SH45(qq), SH45X(qq)), abs(q.y + 3.0) - 0.7);\n\tv = min(v, w);\n\t\n\tq.y = mod(q.y, 2.0) - 1.0;\n\tw = min(abs(dot(q, vec2(0.707, 0.707))), abs(dot(q, vec2(-0.707, 0.707))));\n\tw = min(w, abs(abs(q.x) - 1.0) - 0.02);\n\tw = min(w, max(abs(q.x) - 0.1, abs(q.y) - 0.1));\n\tw = (w - 0.04) / 2.0;\n\t\n\tv = min(v, w);\n\t\n\tv = min(v, abs(uv.y + 1.25) - 0.1);\n\t\n\t\n\t\n\t\n\t\n\tv = smoothstep(0.0, aav, v);\n\t\n\tv = mix(0.0, v, step(abs(voronoi(uv * 0.4).y) - 2.0, 0.0));\n\treturn vec2(0.0, v);\n}\n\n\nvec2 layerC(vec2 uv, vec2 co, float t)\n{\t\n\t\n\tvec2 p, q;\n\tp = uv;\n\t\n\tfloat w;\n\tfloat v = 1e38;\n\t\n\t\n\t\n\t\n\tq = uv * 2.0;\n\tq.x = mod(q.x, 30.0) - 15.0;\n\t\n\tvec2 qq = q;\n\tqq.y += 6.0;\n\tw = max(0.1 - min(SH45(qq), SH45X(qq)), abs(q.y + 3.0) - 0.7);\n\tv = min(v, w);\n\t\n\tq.y = mod(q.y, 2.0) - 1.0;\n\tw = min(abs(dot(q, vec2(0.707, 0.707))), abs(dot(q, vec2(-0.707, 0.707))));\n\tw = min(w, abs(abs(q.x) - 1.0) - 0.02);\n\tw = min(w, max(abs(q.x) - 0.1, abs(q.y) - 0.1));\n\tw = (w - 0.04) / 2.0;\n\t\n\tv = min(v, w);\n\t\n\tv = min(v, abs(uv.y + 1.25) - 0.1);\n\t\n\t\n\t\n\tv = smoothstep(0.0, aav, v);\n\t\n\tv = mix(0.0, v, step(abs(voronoi(uv * 0.4).y) - 2.0, 0.0));\n\t\n\n\t\n\t\n\t\n\treturn vec2(0.0, (1.0 - v) * step(0.0, 7.0 + p.y));\n}\n\n\nvec2 layerD(vec2 p, float t)\n{\n\tfloat v;\n    p.x = mod(p.x + 17., 35.) - 17.;\n\tv = pipeset(p / 5.0) * 5.0;\n\t\n\tv = smoothstep(0.0, aav, v);\n\treturn vec2(0.0, v);\n}\n\n\n\nvec2 layerB(vec2 p, float t)\n{\n\tfloat v;\n\tfloat s = 8.0;\n\t\n\tvec2 q = p / s;\n\t\n\tfloat tt = t * 0.4 + 1.5;\n\tq.x += walkw(tt) * 0.6;\n\tq.x = mod(q.x, 8.0) - 4.0;\n\tv = mech(q, tt).x * s;\n\tv = smoothstep(0.0, aav, v);\n\t//v = mix(0.0, v, step(abs(voronoi(p * 0.4).y) - 2.0, 0.0));\n\treturn vec2(0.0, v);\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 n, float d, out vec3 its)\n{\n\tfloat t = -(dot(ro, n) + d) / dot(rd, n);\n\tits = ro + rd * t;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t//uv = floor(uv * 90.0) / 90.0;\n\t\n\tvec2 co = vec2(iTime * 1.0 * 1.3, 0.0);\n\t\n\t\n\tvec3 ro = vec3(co.x, 0.0, -10.0 + sin(iTime * 0.25) * 1.5);\n\t\n\tfloat s = iTime;\n\tro += (vec3(rand11(s), rand11(s - 11.11), rand11(s + 11.11)) * 2.0 - 1.0) * exp(fract(iTime * 0.8) * -10.0) * 0.2;\n\t\n\tvec3 rd = normalize(vec3(uv, 1.66));\n\trd.xz = rotate(rd.xz, sin(iTime * 0.2) * 0.04);\n\trd.yz = rotate(rd.yz, sin(iTime * 0.3) * 0.04);\n\t\n\tvec3 r; float v;\n\t\n\t// floor plane\n\tfloat d = plane(ro, rd, normalize(vec3(0.0, 1.0, 0.0)), 7.0, r);\n\t\t\n\tvec3 col = vec3(1.0);vec3(0.5, 0.4, 0.3);\n\t\n\t//float vfloor = mix(1.0, circuit(r.xz * 0.02).x * 0.9 + 0.2, exp(d * -0.03));\n\tfloat vfloor = (1.0 - exp(circuit(r.xz * 0.04).y * -100.0)) * 0.3 + 0.0;\n\t//vfloor = 0.5;\n\tvfloor = mix(1.0, vfloor, exp(d * -0.03));\n\t\n\tcol = mix(col, vec3(vfloor), step(0.0, d));\n\t\n\t// layer 4\n\tplane(ro, rd, normalize(vec3(0.0, 0.0, 1.0)), -20.0, r);\n\tv = layerC(r.xy, co, iTime).y;\n\tcol = mix(col, vec3(0.8), v);\n\t\n\t// layer 3\n\tplane(ro, rd, normalize(vec3(0.0, 0.0, 1.0)), -10.0, r);\n\tv = layerC(r.xy, co, iTime).y;\n\tcol = mix(col, vec3(0.4), v);\n\t\n\t\n\t// layer 2\n\tplane(ro, rd, normalize(vec3(0.0, 0.0, 1.0)), -8.0, r);\n\tv = layerB(r.xy, iTime).y;\n\tcol = mix(col, vec3(0.2), 1.0 - v);\n\t\n\t// layer 1\n\tplane(ro, rd, normalize(vec3(0.0, 0.0, 1.0)), 0.0, r);\n\tv = layerA(r.xy, co, iTime).y;\n\tcol = mix(col, vec3(0.0), 1.0 - v);\n\t\n\t\n\t// layer 0\n\tplane(ro, rd, normalize(vec3(0.0, 0.0, 1.0)), 1.5, r);\n\tv = layerD(r.xy, iTime).y;\n\tcol = mix(col, vec3(0.0), 1.0 - v);\n\t\n\t\n\t\n\tcol = pow(col, vec3(1.0 / 2.2));\n\t\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// srtuss, 2014\n\nfloat hash(float x)\n{\n    return (fract(cos(x * 115.5782) * 1000.0 + sin(x * 0.5782) * 333.333) - 0.5) * 1.0;\n}\n\nfloat nse(float t)\n{\n    float fl = floor(t);\n    return mix(hash(fl), hash(fl + 1.0), smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat quan(float x, float v)\n{\n    return floor(x * v) / v;\n}\n\n#define pi2 6.283185307179586476925286766559\n\nfloat engine1(float t)\n{\n    return nse(fract(t * 40.0) * 60.0);\n}\n\n\n\nfloat f1(float t, float ts, float tl, float k)\n{\n\tfloat o1 = clamp(t - ts, 0.0, tl);\n\tfloat o2 = max(t - (ts + tl), 0.0);\n\n\treturn o1 * o1 * k / (2.0 * tl) + o2 * k;\n}\n\nfloat phase(float t)\n{\n    // phase result\n    float p;\n    \n    float tb = 0.0, td = 1.0;\n    float fl = 4.0, fn = 10.6;\n    \n    p = fl * t;\n    p += f1(t, tb, 0.4, fn - fl); fl = fn; tb += 2.0;\n    fn = (13.0);\n    p += f1(t, tb, 0.05, fn - fl); fl = fn; tb += 0.05;\n    fn = (0.001);\n    p += f1(t, tb, 0.8, fn - fl); fl = fn; tb += 0.3;\n    \n    \n    \n    return p;\n}\n\n\nfloat wf2(float x)\n{\n    return nse(fract((sin(x * 300.0) * 0.001 + x) * 100.0) * 26.0);\n}\n\nfloat s(float t)\n{\n    float h = 0.7;\n    float tt = mod(t, 4.0);\n    float v = (nse(tt * 40000.0 - h) - nse(tt * 40000.0 + h));\n    v = v * 0.5 * exp(-10.0 * max(tt - 2.0, 0.0)) * exp(-40.0 * max(1.0 - tt, 0.0));\n    \n    h = 0.005;\n    v += (((engine1(t - h) + engine1(t + h))) * 0.4 + sin(t * 40.0 * pi2) * 0.2) * smoothstep(-0.1, 0.1, sin(t * 10.0)) * 0.5;\n    \n    h = 0.1;\n    v += (nse(t * 1000.0 - h) + nse(t * 1000.0 + h)) * sin(t * 20.0);\n    \n    \n    tt = mod(t, 7.0);\n    v += wf2(phase(tt) * 1.0) * exp(-1.0 * max(tt - 2.0, 0.0)) * exp(-1.0 * max(1.0 - tt, 0.0)) * 0.5;\n    \n    \n    //tt = mod(t + 3.0, 3.0);\n    //tt = pow(tt, 0.8) * 0.1 + tt;\n    //v += clamp(-1.0, 1.0, 4.0 * sin((tt + sin(tt * tt * 100.0) * 0.01) * 3000.0) * exp(max(tt, 0.0) * -10.0)) * 0.5;\n    \n    // thump\n    tt = mod(t + .1, 1.25);\n    float phs = (pow(tt, 0.5) + t) * 1.1;\n    v += clamp(-1.0, 1.0, (nse(phs * 200.0) + sin(phs * 200.0) * 0.5) * exp(max(0.04 - tt, 0.0) * -100.0) * exp(max(tt, 0.0) * -4.0) * 8.0) * 0.8;\n    \n    return v;\n}\n\nvec2 echo(float t)\n{\n    vec2 v;\n    \n    float a = 0.5, et = 0.1, fb = 0.6;\n    v = vec2(s(t));\n    v = v.yx + s(t - et) * a * vec2(1.0, 0.5); a *= fb; et += 0.2;\n    v = v.yx + s(t - et) * a * vec2(0.5, 1.0); a *= -fb; et += 0.2;\n    v = v    + s(t - et) * a * vec2(1.0, 0.5); a *= fb; et += 0.3;\n    v = v.yx + s(t - et) * a * vec2(1.0, 0.5); a *= -fb; et += 0.2;\n    v = v    + s(t - et) * a * vec2(0.5, 1.0); a *= fb; et += 0.3;\n    v = v    + s(t - et) * a * vec2(1.0, 0.5); a *= -fb; et += 0.3;\n    v = v.yx + s(t - et) * a * vec2(0.5, 1.0); a *= fb; et += 0.2;\n    v = v.yx + s(t - et) * a * vec2(1.0, 0.5); a *= -fb; et += 0.3;\n    v = v    + s(t - et) * a * vec2(1.0, 0.5); a *= fb; et += 0.4;\n    v = v.yx + s(t - et) * a * vec2(0.5, 1.0); a *= -fb; et += 0.3;\n    v = v.yx + s(t - et) * a * vec2(1.0, 0.5); a *= fb; et += 0.2;\n    \n    return v;\n}\n\n\nvec2 mainSound( in int samp,float t)\n{\n    vec2 v = vec2(0.0);\n    v = echo(t) * 0.35;\n    \n    //v = vec2();\n    \n    return vec2(v);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}