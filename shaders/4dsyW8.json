{
    "Shader": {
        "info": {
            "date": "1487969692",
            "description": "I have added the fifth band of SH functions based on iq's implementation at [url]https://www.shadertoy.com/view/lsfXWH[/url].\nBlue are positive, and red are negative.\nUse mouse for rotating the scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dsyW8",
            "likes": 16,
            "name": "0-4 Order of Spherical Harmonics",
            "published": 3,
            "tags": [
                "3d",
                "function",
                "sphericalharmonics",
                "spherical",
                "harmonics",
                "irradiance",
                "basis"
            ],
            "usePreview": 1,
            "username": "starea",
            "viewed": 2458
        },
        "renderpass": [
            {
                "code": "// Remixed by Ruofei Du\n// Added the polynomial mathematical expression for the fifth band\n// ruofei/2017\n//\n// Initially created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Five bands of Spherical Harmonics functions (or atomic orbitals if you want).\n// For reference and fun.\n\n// antialias level (try 1, 2, 3, ...)\n#define AA 1\n// change TIME to 0 to stop rotating\n#define TIME iTime\n\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.28209479177387814 // Math.sqrt(  1/Math.PI)/2\n#define k02 0.4886025119029199  // Math.sqrt(  3/Math.PI)/2\n#define k03 1.0925484305920792  // Math.sqrt( 15/Math.PI)/2\n#define k04 0.31539156525252005 // Math.sqrt(  5/Math.PI)/4\n#define k05 0.5462742152960396  // Math.sqrt( 15/Math.PI)/4\n#define k06 0.5900435899266435  // Math.sqrt( 70/Math.PI)/8\n#define k07 2.890611442640554   // Math.sqrt(105/Math.PI)/2\n#define k08 0.4570457994644658  // Math.sqrt( 42/Math.PI)/8\n#define k09 0.3731763325901154  // Math.sqrt(  7/Math.PI)/4\n#define k10 1.445305721320277   // Math.sqrt(105/Math.PI)/4\n#define k11 2.5033429417967046  // Math.sqrt(  35/Math.PI) * 3 / 4\n#define k12 1.7701307697799304  // Math.sqrt(35/2/Math.PI) * 3 / 4\n#define k13 0.9461746957575601  // Math.sqrt(   5/Math.PI) * 3 / 4\n#define k14 0.6690465435572892  // Math.sqrt( 5/2/Math.PI) * 3 / 4\n#define k15 0.10578554691520431 // Math.sqrt(   1/Math.PI) * 3 / 16\n#define k16 0.47308734787878004 // Math.sqrt(   5/Math.PI) * 3 / 8\n#define k17 0.6258357354491761  // Math.sqrt(  35/Math.PI) * 3 / 16\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SH( in int l, in int m, in vec3 s ) \n{ \n\tvec3 n = s.zxy;\n\t\n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n    if( l==3 && m==-3 ) return -k06*n.y*(3.0*n.x*n.x-n.y*n.y);\n    if( l==3 && m==-2 ) return  k07*n.z*n.y*n.x;\n    if( l==3 && m==-1 ) return -k08*n.y*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 0 ) return  k09*n.z*(5.0*n.z*n.z-3.0);\n    if( l==3 && m== 1 ) return -k08*n.x*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 2 ) return  k10*n.z*(n.x*n.x-n.y*n.y);\n    if( l==3 && m== 3 ) return -k06*n.x*(n.x*n.x-3.0*n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\n// unrolled version of the above\nfloat SH_0_0( in vec3 s ) { vec3 n = s.zxy; return  k01; }\n\nfloat SH_1_0( in vec3 s ) { vec3 n = s.zxy; return -k02*n.y; }\nfloat SH_1_1( in vec3 s ) { vec3 n = s.zxy; return  k02*n.z; }\nfloat SH_1_2( in vec3 s ) { vec3 n = s.zxy; return -k02*n.x; }\n\nfloat SH_2_0( in vec3 s ) { vec3 n = s.zxy; return  k03*n.x*n.y; }\nfloat SH_2_1( in vec3 s ) { vec3 n = s.zxy; return -k03*n.y*n.z; }\nfloat SH_2_2( in vec3 s ) { vec3 n = s.zxy; return  k04*(3.0*n.z*n.z-1.0); }\nfloat SH_2_3( in vec3 s ) { vec3 n = s.zxy; return -k03*n.x*n.z; }\nfloat SH_2_4( in vec3 s ) { vec3 n = s.zxy; return  k05*(n.x*n.x-n.y*n.y); }\n\nfloat SH_3_0( in vec3 s ) { vec3 n = s.zxy; return -k06*n.y*(3.0*n.x*n.x-n.y*n.y);   }\nfloat SH_3_1( in vec3 s ) { vec3 n = s.zxy; return  k07*n.z*n.y*n.x;                 }\nfloat SH_3_2( in vec3 s ) { vec3 n = s.zxy; return -k08*n.y*(5.0*n.z*n.z-1.0);       }\nfloat SH_3_3( in vec3 s ) { vec3 n = s.zxy; return  k09*n.z*(5.0*n.z*n.z-3.0);       }\nfloat SH_3_4( in vec3 s ) { vec3 n = s.zxy; return -k08*n.x*(5.0*n.z*n.z-1.0);       }\nfloat SH_3_5( in vec3 s ) { vec3 n = s.zxy; return  k10*n.z*(n.x*n.x-n.y*n.y);       }\nfloat SH_3_6( in vec3 s ) { vec3 n = s.zxy; return -k06*n.x*(n.x*n.x-3.0*n.y*n.y);   }\n\nfloat SH_4_0( in vec3 s ) { vec3 n = s.zxy; return  k11 * (n.x*n.y * (n.x*n.x - n.y*n.y));              }\nfloat SH_4_1( in vec3 s ) { vec3 n = s.zxy; return -k12 * (3.0*n.x*n.x - n.y*n.y) * n.y * n.z;          }\nfloat SH_4_2( in vec3 s ) { vec3 n = s.zxy; return  k13 * (n.x*n.y * (7.0*n.z*n.z-dot(n,n)) );          }\nfloat SH_4_3( in vec3 s ) { vec3 n = s.zxy; return -k14 * (n.z*n.y * (7.0*n.z*n.z-3.0*dot(n,n)) );      } \nfloat SH_4_4( in vec3 s ) { vec3 n = s.zxy;  \n        float z2 = n.z*n.z; return  k15 * (35.0 * z2*z2 - 30.0 * z2 + 3.0);  }\nfloat SH_4_5( in vec3 s ) { vec3 n = s.zxy; return -k14 * (n.z*n.x * (7.0*n.z*n.z-3.0*dot(n,n)) );      } \nfloat SH_4_6( in vec3 s ) { vec3 n = s.zxy; return  k16 * ( (n.x*n.x-n.y*n.y)*(7.0*n.z*n.z-dot(n,n)) ); }\nfloat SH_4_7( in vec3 s ) { vec3 n = s.zxy; return -k12 * n.x*n.z*(n.x*n.x-3.0*n.y*n.y);                }\nfloat SH_4_8( in vec3 s ) { vec3 n = s.zxy;  \n          float x2 = n.x*n.x, y2 = n.y*n.y; return  k17 * (x2 * (x2-3.0*y2) - y2*(3.0*x2 - y2));        }\n \nvec3 map( in vec3 p )\n{\n    vec3 p00 = p - vec3( 0.00, 3.0, 0.0);\n\tvec3 p01 = p - vec3(-1.25, 2.0, 0.0);\n\tvec3 p02 = p - vec3( 0.00, 2.0, 0.0);\n\tvec3 p03 = p - vec3( 1.25, 2.0, 0.0);\n\tvec3 p04 = p - vec3(-2.50, 0.5, 0.0);\n\tvec3 p05 = p - vec3(-1.25, 0.5, 0.0);\n\tvec3 p06 = p - vec3( 0.00, 0.5, 0.0);\n\tvec3 p07 = p - vec3( 1.25, 0.5, 0.0);\n\tvec3 p08 = p - vec3( 2.50, 0.5, 0.0);\n\tvec3 p09 = p - vec3(-3.75,-1.0, 0.0);\n\tvec3 p10 = p - vec3(-2.50,-1.0, 0.0);\n\tvec3 p11 = p - vec3(-1.25,-1.0, 0.0);\n\tvec3 p12 = p - vec3( 0.00,-1.0, 0.0);\n\tvec3 p13 = p - vec3( 1.25,-1.0, 0.0);\n\tvec3 p14 = p - vec3( 2.50,-1.0, 0.0);\n\tvec3 p15 = p - vec3( 3.75,-1.0, 0.0);\n\t\n    vec3 p16 = p - vec3(-5.00,-2.7, 0.0);\n    vec3 p17 = p - vec3(-3.75,-2.7, 0.0);\n    vec3 p18 = p - vec3(-2.50,-2.7, 0.0);\n    vec3 p19 = p - vec3(-1.25,-2.7, 0.0);\n    vec3 p20 = p - vec3( 0.00,-2.7, 0.0);\n    vec3 p21 = p - vec3( 1.25,-2.7, 0.0);\n    vec3 p22 = p - vec3( 2.50,-2.7, 0.0);\n    vec3 p23 = p - vec3( 3.75,-2.7, 0.0);\n    vec3 p24 = p - vec3( 5.00,-2.7, 0.0);\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n\td=length(p00); n=p00/d; r = SH_0_0( n ); s = SHAPE; res = s;\n\td=length(p01); n=p01/d; r = SH_1_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p02); n=p02/d; r = SH_1_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p03); n=p03/d; r = SH_1_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p04); n=p04/d; r = SH_2_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p05); n=p05/d; r = SH_2_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p06); n=p06/d; r = SH_2_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p07); n=p07/d; r = SH_2_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p08); n=p08/d; r = SH_2_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p09); n=p09/d; r = SH_3_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p10); n=p10/d; r = SH_3_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p11); n=p11/d; r = SH_3_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p12); n=p12/d; r = SH_3_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p13); n=p13/d; r = SH_3_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p14); n=p14/d; r = SH_3_5( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p15); n=p15/d; r = SH_3_6( n ); s = SHAPE; if( s.x<res.x ) res=s;\n    \n\td=length(p16); n=p16/d; r = SH_4_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p17); n=p17/d; r = SH_4_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p18); n=p18/d; r = SH_4_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p19); n=p19/d; r = SH_4_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p20); n=p20/d; r = SH_4_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p21); n=p21/d; r = SH_4_5( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p22); n=p22/d; r = SH_4_6( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p23); n=p23/d; r = SH_4_7( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p24); n=p24/d; r = SH_4_8( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t\tm = res.yz;\n        t += h*0.3;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // camera\n        float an = 0.314*TIME - 10.0*iMouse.x/iResolution.x;\n        float dist = 8.0;\n        vec3  ro = vec3(dist*sin(an),0.0,dist*cos(an));\n        vec3  ta = vec3(0.0,0.0,0.0);\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.5) * clamp(1.0-length(p)*0.5, 0.0, 1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.2,0.15), vec3(0.15,0.7,1.0), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}