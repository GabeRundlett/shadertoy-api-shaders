{
    "Shader": {
        "info": {
            "date": "1482389137",
            "description": "Our beloved Charlie! ",
            "flags": 0,
            "hasliked": 0,
            "id": "XldSWj",
            "likes": 2,
            "name": "Atlassian (old) logo",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "h3nr1x",
            "viewed": 676
        },
        "renderpass": [
            {
                "code": "#define ANTIALIAS\n\n////////////////////////////////////////////////////////////////////////////////\n// Shape configuration\n////////////////////////////////////////////////////////////////////////////////\n\nstruct charlie_body_params {\n    mat3 skew;\n\n    vec3 box_size;\n    float box_roundness;\n\n    float amp_f1;\n    float frec_f1;\n    float ang_offset1;\n    float offset_f1;\n\n    float amp_f2;\n    float frec_f2;\n    float ang_offset2;    \n    float offset_f2;    \n\n    float x_shift;\n};\n    \ncharlie_body_params create_charlie_body_params() {\n\tcharlie_body_params da_body;\n    da_body.skew = mat3( \n        \t\t\t\t 0.88, 0.16, 0.00, \n                    \t 0.04, 1.05, 0.00,\n                     \t 0.00, 0.00, 1.00 \n                       );\n\n    da_body.box_size = vec3(0.05, 0.3, 0.09);\n    da_body.box_roundness = 0.005;\n\n    da_body.amp_f1 = 0.145;\n    da_body.frec_f1 = 5.1;\n    da_body.ang_offset1 = -0.1;\n    da_body.offset_f1 = -0.03;\n\n    da_body.amp_f2 = 0.15;\n    da_body.frec_f2 = 4.8;\n    da_body.ang_offset2 = 0.1;    \n    da_body.offset_f2 = 0.0;    \n\n    da_body.x_shift = 0.055;\n    \n    return da_body;\n}\n    \n    \n////////////////////////////////////////////////////////////////////////////////\n// Distance Field (DF) Primitives\n////////////////////////////////////////////////////////////////////////////////\n\nfloat df_plane(in vec3 ray, vec3 n, vec3 p0) {\n \treturn dot(ray - p0, n);  \n}\n\nfloat df_sphere(in vec3 ray, in float radious) {\n    return length(ray) - radious;\n}\n\n// These two are from: https://iquilezles.org/articles/distfunctions\nfloat df_round_box(in vec3 ray, in vec3 size, in float roundness) {\n  \treturn length(max(abs(ray) - size, 0.0)) - roundness;\n}\n\nfloat df_triangular_prism(in vec3 ray, vec2 size) {\n    vec3 q = abs(ray);\n    return max(\n        q.z - size.y, \n        max(q.x * 0.866025 + ray.y * 0.5, -ray.y) - size.x * 0.5\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Operations\n////////////////////////////////////////////////////////////////////////////////\n\nfloat op_union(in float d1, in float d2) {\n \treturn min(d1, d2);   \n}\n\nfloat op_interception(in float d1, in float d2) {\n \treturn max(d1, d2);   \n}\n\nfloat op_complement(in float d) {\n \treturn -d;   \n}\n\nfloat op_difference(in float d1, in float d2) {\n \treturn op_interception(d1, op_complement(d2));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Individual vector operations\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 rot_z(in vec3 p, in float degs) {\n    float rads = radians(degs);\n    float c = cos(rads);\n    float s = sin(rads);\n    mat3 t = mat3(  c,   s, 0.0,\n                   -s,   c, 0.0,\n                  0.0, 0.0, 1.0);\n    return t * p;\n}\n\nvec3 rotate_vec(in vec3 angle, in vec3 v) {\n    vec3 rads = radians(angle);\n    \n    vec3 s = sin(rads); vec3 c = cos(rads);\n\n    mat3 rot_x = mat3( 1.0,  0.0,  0.0,\n                       0.0,  c.x, -s.x,\n                       0.0,  s.x,  c.x);\n\n    mat3 rot_y = mat3( c.y,  0.0,  s.y,\n                       0.0,  1.0,  0.0,\n                      -s.y,  0.0,  c.y);\n\n    mat3 rot_z = mat3( c.z,  s.z,  0.0,\n                      -s.z,  c.z,  0.0,\n                       0.0,  0.0,  1.0);\n    \n    return rot_x * rot_y * rot_z * v;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Modeling (here is where the body of Charlie gets assembled)\n////////////////////////////////////////////////////////////////////////////////\n\nfloat df_left_arm_and_leg(in vec3 ray, in charlie_body_params bp) {\n    vec3 shifted_ray = ray + vec3(bp.x_shift, vec2(0));\n    \n    vec3 l1 = bp.skew * shifted_ray + vec3(\n        bp.amp_f1 * sin(shifted_ray.y * bp.frec_f1 + bp.ang_offset1) + bp.offset_f1, \n        vec2(0.0)\n    );\n    float line1 = df_round_box(l1, bp.box_size, bp.box_roundness);\n    \n    vec3 l2 = bp.skew * shifted_ray + vec3(\n        bp.amp_f2 * sin(shifted_ray.y * bp.frec_f2 + bp.ang_offset2) + bp.offset_f2, \n        vec2(0.0)\n    );\n    float line2 = df_round_box(l2, bp.box_size, bp.box_roundness);\n\t\n    return op_difference(\n        op_union(line1, line2), \n        df_plane(ray, vec3(0, 1, 0), vec3(0.0, -0.31, 0.0))\n    );\n}\n\nfloat df_right_arm(in vec3 ray, in charlie_body_params bp) {\n    vec3 mirror_x_ray = vec3(-ray.x + bp.x_shift, ray.yz);\n    \n    float d = df_left_arm_and_leg(mirror_x_ray, bp);\n\n    return op_difference(\n        d, \n        df_plane(ray, vec3(0, 1, 0), vec3(0.0, -0.076, 0.0))\n    );\n}\n\nfloat df_left_leg(in vec3 ray, charlie_body_params bp) {\n\tvec3 mirror_x_ray = vec3(-ray.x + bp.x_shift, ray.yz);\n\n    float right_arm_and_leg = df_left_arm_and_leg(mirror_x_ray, bp);\n\n    vec3 bent_ray = ray;\n    vec3 normal = normalize(rot_z(vec3(0, 1, 0), 126.0));\n    vec3 pos = vec3(-0.17, 0.0, 0.0);\n\n    float clipping_plane = df_plane(bent_ray, normal, pos);\n    \n    return op_difference(right_arm_and_leg, clipping_plane);\n}\n\nfloat df_head(in vec3 ray) {\n    mat3 m = mat3(\n        0.75,  0.00,  0.00,\n        0.00, -1.00,  0.00,\n        0.00,  0.00,  1.00\n    );\n    vec3 t = vec3(-0.019, 0.229, 0.0);\n    return df_triangular_prism(m * ray + t, vec2(0.08, 0.09));\n}\n\nfloat df_world(in vec3 ray) {\n    vec3 r = ray + vec3(-0.03, 0.89 * cos(ray.x) - 1.31, 0.0);\n    vec3 size = vec3(0.6, 0.001, 0.01);\n    float roundness = 0.03;\n    return df_round_box(r, size, roundness);\n}\n\nfloat df_charlie(in vec3 ray, charlie_body_params bp) {\n    float left_arm_and_leg = df_left_arm_and_leg(ray, bp);\n    \n    float right_arm = df_right_arm(ray, bp);\n\n    float left_leg = df_left_leg(ray, bp);\n    \n    float head = df_head(ray);\n    \n    float world = df_world(ray);\n    \n    return op_union(\n        op_union(left_arm_and_leg, right_arm), \n        op_union(left_leg, op_union(head, world))\n    );\n}\n\nfloat model(in vec3 ray, in charlie_body_params body_params) {\n    return df_charlie(ray, body_params);\n}\n\nfloat scene_floor(in vec3 ray) {\n\tvec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 pos = vec3(0.0, -0.29, 0.0);\n    return df_plane(ray, normal, pos);\n} \n\n////////////////////////////////////////////////////////////////////////////////\n// Lighting \n////////////////////////////////////////////////////////////////////////////////\n\nvec3 normal(in vec3 p, in charlie_body_params bp) {\n    const float EPS = 0.01;\n\treturn normalize(\t\n\t\tvec3(\n\t\t\tmodel(p + vec3(EPS, 0, 0), bp) - model(p - vec3(EPS, 0, 0), bp),\n\t\t\tmodel(p + vec3(0, EPS, 0), bp) - model(p - vec3(0, EPS, 0), bp),\n\t\t\tmodel(p + vec3(0, 0, EPS), bp) - model(p - vec3(0, 0, EPS), bp)\n\t\t)\n\t);\n}\n\n// Assume all vectors are incident, that is, their points \n// (end of the arrow) are at the shading point (the point \n// on the surface of the model hit by the marched ray)\nvec4 lambertian(in vec3 light_dir, in vec3 view, in vec3 normal, in vec4 surface_color) {\n\tview = -view;\n    light_dir = -light_dir;\n    \n    float spec_factor = 1.0;\n    const vec4 light_col = vec4(1.0);\n    \n    vec4 ambient_color = vec4(surface_color.rgb / 1.5, 1.0); \n       \n\tfloat n_dot_l = max(dot(normal, light_dir), 0.0);\n    vec3 diffuse = surface_color.rgb * light_col.rgb * n_dot_l;\n\n    // vec3 reflection_vector = reflect(-light_dir, normal); \n    // vec3 specular = surface_color.rgb * pow(max(dot(reflection_vector, view), 0.0), spec_factor);\n    vec3 specular = vec3(0);\n        \n\treturn vec4(diffuse + specular, 1.0) + ambient_color;\n}\n\nvec4 lambertian_floor(in vec3 light_dir, in vec3 eye, in vec3 normal, in vec4 surface_color) {\n    const vec4 light_col = vec4(1.0);\n            \n\tfloat n_dot_l = max(dot(normal, light_dir), 0.0);\n\n    vec3 diffuse = surface_color.rgb * light_col.rgb * n_dot_l;\n        \n\treturn vec4(diffuse, 1.0) + surface_color;\n}\n\n// Again, the vector are incident (see comment two funcions above)\nfloat charlie_shadow(in vec3 shading_point, in vec3 light_pos, in charlie_body_params bp) {\n    const int MAX_STEPS = 50;\n    const float EPSILON = 0.01;\n    \n    vec3 ray = light_pos - shading_point;\n    vec3 normalized_ray = normalize(ray);\n    \n    float dist = 0.0;\n    float clarity = 1.0;\n    const float min_umbra = 0.65;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = shading_point + normalized_ray * dist;\n\n        float d = model(p, bp);\n        if (d < EPSILON) {\n\t\t\treturn min_umbra;\n        }\n\t\tclarity = min(clarity, 16.0 * d / dist);\n        dist += d;\n    }\n\n    return max(min_umbra, min(1.0, clarity));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Ray Marching \n////////////////////////////////////////////////////////////////////////////////\n\nvec4 ray_march(in vec4 default_color, \n               in vec4 hit_color, \n               in vec3 eye, \n               in vec3 ray, \n               in vec3 ray_offset, \n               in vec3 light_pos,\n               in vec3 light_dir,\n               in charlie_body_params body_params) {\n    vec3 normalized_ray = normalize(ray);\n    \n    const int MAX_STEPS = 30;\n    const float EPSILON = 0.01;\n    \n    float dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = eye + normalized_ray * dist + ray_offset;\n\n        float d = model(p, body_params);\n        if (d < EPSILON) {\n            vec3 norm = normal(p, body_params);\n            return lambertian(norm, p - eye, light_dir, hit_color);\n        }\n\n        dist += d;\n    }\n\n    const int MAX_STEPS_FLOOR = 100;    \n    const float EPSILON_FLOOR = 0.001;\n\t\n    dist = length(ray);\n    for (int i = 0; i < MAX_STEPS_FLOOR; i++) {\n        vec3 p = eye + normalized_ray * dist + ray_offset;\n\n        float d_floor = scene_floor(p);\n        if (d_floor < EPSILON_FLOOR) {\n        \tvec4 floor_color = vec4(vec3(0.8), 1.0);\n\t\t\treturn floor_color * (charlie_shadow(p, light_pos, body_params));\n        }\n        \n        dist += d_floor;\n    }\n    \n    return default_color;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Main\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n\tfloat aspect = iResolution.y / iResolution.x;\n\n    vec2 mouse_xy = ((1.0 - iMouse.xy) / iResolution.xy) - 0.5;\n    float mouse_rot_y = mouse_xy.y * 12.0 + 6.945;\n    float mouse_rot_x = mouse_xy.x * 100.0;\n    \n    vec3 eye = vec3(0.0, 0.1, -1.4);\n    vec3 near_clipping_plane = vec3((frag_coord.xy / iResolution.xy) - 0.5, -1.0);\n\n    vec3 initial_angle = vec3(mouse_rot_y, mouse_rot_x + 10.0 * iTime + 80.0, 0.0);\n    eye = rotate_vec(initial_angle, eye);\n    near_clipping_plane = rotate_vec(initial_angle, near_clipping_plane);\n\n    eye += vec3(0.0, 0.27, 0.0);\n    near_clipping_plane += vec3(0.0, 0.3, 0.0);\n    \n    vec3 ray = near_clipping_plane - eye;\n    ray.y *= aspect;\n\n    const vec4 background_color = vec4(0.9);    \n    \n    const vec4 blue_charlie = vec4(0.34117647058823529411, \n                                   0.68627450980392156862, \n                                   0.89803921568627450980, \n                                   1.0);\n\n    charlie_body_params body_params = create_charlie_body_params();\n    \n    vec3 initial_light_angle = vec3(30.0 * iTime + 120.0, 60.0 * iTime, 0.0);\n    vec3 light_pos = rotate_vec(initial_light_angle, vec3(-2.0, -6.0, 0.0));\n    vec3 light_dir = normalize(vec3(0) - light_pos);\n    \n#ifdef ANTIALIAS\n    const int NUM_SAMPLES = 4;\n    const float SAMPLE_OFFSET = 0.003;\n    float samples = 0.0;\n    vec4 avg_color = vec4(0);\n\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        vec4 color = vec4(1.0);\n    \n\t\tvec3 offset = vec3(ray) + vec3(\n            floor(samples / 2.0) * (2.0 * mod(samples, 2.0) - 1.0) * SAMPLE_OFFSET, \n            (1.0 - floor(samples / 2.0)) * (2.0 * mod(samples, 2.0) - 1.0) * SAMPLE_OFFSET, \n            0.0\n        );\n        \n\t    avg_color += ray_march(background_color, blue_charlie, eye, ray, offset, light_pos, light_dir, body_params); \n\n        samples += 1.0;\n    }\n\n    frag_color = avg_color / samples;    \n#else\n\tfrag_color = ray_march(background_color, blue_charlie, eye, ray, vec3(0), light_dir, body_params);\n#endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}