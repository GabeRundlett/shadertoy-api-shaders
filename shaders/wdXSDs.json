{
    "Shader": {
        "info": {
            "date": "1552517077",
            "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/395087279[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wdXSDs",
            "likes": 13,
            "name": "[twitch] Fractured World",
            "published": 3,
            "tags": [
                "livecoding",
                "twitch"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 816
        },
        "renderpass": [
            {
                "code": "/*\nThis shader was created live on stream!\nYou can watch the VOD here: https://www.twitch.tv/videos/395087279\n\nI use the Bonzomatic tool by Gargaj/Conspiracy:\nhttps://github.com/Gargaj/Bonzomatic\n\nWednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\nCome and watch a show!\n\n~yx\n*/\n\n#define pi acos(-1.)\n\nvec2 rotate(vec2 a, float b)\n{\n    float c=cos(b);\n    float s=sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat noise(vec3 a)\n{\n    return fract(sin(dot(a,vec3(12.341242,3.432432,17.34242)))*1435.432432);\n}\n\nfloat smoothnoise(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = fract(p);\n\n    float a=noise(fl+vec3(0,0,0));\n    float b=noise(fl+vec3(1,0,0));\n    float c=noise(fl+vec3(0,1,0));\n    float d=noise(fl+vec3(1,1,0));\n    float e=noise(fl+vec3(0,0,1));\n    float f=noise(fl+vec3(1,0,1));\n    float g=noise(fl+vec3(0,1,1));\n    float h=noise(fl+vec3(1,1,1));\n    return mix(\n        mix(\n            mix(a,b,fr.x),\n            mix(c,d,fr.x),\n            fr.y\n        ),\n        mix(\n            mix(e,f,fr.x),\n            mix(g,h,fr.x),\n            fr.y\n        ),\n        fr.z\n    );\n}\n\nfloat side=1.;\nint mat = 0;\n\nfloat orb(vec3 p)\n{\n    float d=length(p)-12.;\n\n    if (d > .5)\n        return d;\n\n    vec3 offset = vec3(0,iTime*.5,0);\n\n    float midpoint = .5+sin(iTime*.3)*.1;\n\n    float n = smoothnoise(p-offset)-midpoint;\n    side=sign(n);\n    if(side>0.){\n        p*=1.+smoothnoise(p*4.)*.01;\n        d=length(p)-12.;\n    }\n    d = max(d, .05-abs(n));\n    return d;\n}\n\nfloat shatter(vec3 p)\n{\n    float d = -1e9;\n\n    for(int i=0;i<5;++i)\n    {\n        float f=float(i)+iTime*.00001;\n        vec3 n = normalize(vec3(\n            noise(vec3(f,0,0)),\n            noise(vec3(0,f,0)),\n            noise(vec3(0,0,f))\n        )-.5);\n\n        float s=sin(iTime*.1)*.5+.7;\n        vec3 o = vec3(\n            noise(vec3(-i,0,0)),\n            noise(vec3(0,-i,0)),\n            noise(vec3(0,0,-i))\n        )*s*2.-s;\n        o*=sign(dot(o,n));\n\n        p -= o*sign(dot(p,n));\n        d = max(d,length(o)-abs(dot(p,n))+.01);\n    }\n\n    d = max(d,orb(p));\n    return d;\n}\n\nfloat scene(vec3 p)\n{\n    float d = 40.-length(p);\n    float n = smoothnoise(p+vec3(0,iTime,0));\n    d = max(d, .05-abs(n-.5));\n\n    float d2 = shatter(p);\n    mat = d<d2?0:1;\n    return min(d,d2);\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t=0.;\n    float k=0.;\n    vec3 accum=vec3(1);\n    for (int b=0;b<4;++b){\n        for(int i=0;i<100;++i){\n            k=scene(cam+dir*t);\n            t+=k;\n            if(abs(k)<.001)\n            {\n                break;\n            }\n        }\n        vec3 h=cam+dir*t;\n        vec2 o=vec2(.001,0);\n        vec3 n=normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n        if (mat == 0) {\n            return accum*(dot(n,-normalize(h))*.5+.5);\n        } else {\n            // orb\n            if (side > 0.) {\n                float fresnel = pow(1.-max(0.,dot(n,-dir)),5.);\n                accum *= fresnel;\n                cam=h+n*.01;\n                dir=reflect(dir,n);\n            } else {\n                return accum*vec3(n.y*.5+.5);\n            }\n        }\n    }\n    return accum;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-35);\n    vec3 dir = normalize(vec3(uv,1));\n\n    cam.yz = rotate(cam.yz, .3);\n    dir.yz = rotate(dir.yz, .3);\n\n    cam.xz = rotate(cam.xz, iTime*.1);\n    dir.xz = rotate(dir.xz, iTime*.1);\n\n    out_color.rgb = trace(cam,dir);\n    out_color.rgb = pow(out_color.rgb, vec3(.45));\n    out_color.rgb *= 1.-dot(uv,uv)*.4;\n    out_color.rgb = pow(out_color.rgb, vec3(1.4,1.2,1));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}