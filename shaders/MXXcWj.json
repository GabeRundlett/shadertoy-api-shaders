{
    "Shader": {
        "info": {
            "date": "1727099581",
            "description": "A try at all 16 possible binary Boolean 3D SDF operators. Even the useless ones.\nSomebody probably already did this better, or will.",
            "flags": 0,
            "hasliked": 0,
            "id": "MXXcWj",
            "likes": 11,
            "name": "16 Boolean sdf operators",
            "published": 3,
            "tags": [
                "sdf",
                "boolean",
                "operators"
            ],
            "usePreview": 1,
            "username": "dray",
            "viewed": 198
        },
        "renderpass": [
            {
                "code": "//#define NOTEXT // use if too slow\n/*\nI wanted to try all 16 binary boolean operators for 3D SDFs.\nI was inspired by https://www.shadertoy.com/view/M3fcWS @jt\n\nSome notes:\n\nThere are lots of names, symbols, and notations for these from CPU\nopcodes to biology. I chose these short ones adding\n  AInhB=A inhibits B\n  AImpB=Does A imply B?\n\n\"Not\" cases become true everywhere - limit them with \"And\".\nI discovered that the hard way.\n\nMy 3d images seem to turn inside-out to the viewer too easily.\n(Is that a Hermann von Helmholtz illusion?)\n\nI have 2 \"And\"s depending on needing reversal of colors/textures.\nThat would not be an issue for distance-only functions.\n\n3d spheres do not work where 2d circles do for Xor:\nYou cannot see inside where the difference from Or is.\nI should have known.\nIt is a bit of a patch, but I added a periodic reveal inside the\nXor to show how it is different from Or.\n\nAfter I started, I found this which was close to what I wanted, but obviously 2d:\nhttps://gist.github.com/cky26/58b28f011d512de1620719517dd7c0d4\n\nSome related ShaderToy works I found - there are surely more.\nContinuous booleans are popular.\nhttps://www.shadertoy.com/view/Xdj3Rh all 16 from IQ, not for SDFs\nhttps://www.shadertoy.com/view/Xsc3WX\nhttps://www.shadertoy.com/view/lt3BW2\nhttps://www.shadertoy.com/view/MlXXDf\nhttps://www.shadertoy.com/view/WtsyzM\nhttps://www.shadertoy.com/view/lsXyDH all 16, not SDFs\n\nI still haven't made or found better 3d text drawing\nbut borrowed the _ method for readability.\n*/\n\nstruct Hit { float d; float i; }; // d=distance to object   i=id, color or texture\n\nHit opTrue() { return Hit(0.,0.); }\nHit opFalse() { return Hit(1e20,0.); }\n\nHit opNot(Hit a) { return Hit(-a.d,a.i); }  // not compatible with opTrue\n\n// Needed these first (for De Morgans Laws & etc)\nHit opOr(Hit a,Hit b) { if (a.d < b.d) return a; else return b; } // { return a.d < b.d ? a : b; }\nHit opAndx(Hit a,Hit b) { if (a.d > b.d) return a; else return b; } // { return (a.d < b.d) ? a : b; }\nHit opAnd(Hit a,Hit b) { if (a.d > b.d) return Hit(a.d,b.i); else return Hit(b.d,a.i); }//if (a.d > b.d) return a; else return b; } // { return (a.d < b.d) ? a : b; }\n\n/* 1010 - a */\n/* 1100 - b */\n/* 0000 */ Hit opFalse(Hit a,Hit b) { return Hit(1e20,a.i); }\n/* 0001 */ Hit opNor(Hit a,Hit b) { return opNot(opOr(a,b)); }\n/* 0010 */ Hit opBInhA(Hit a,Hit b) { return opAndx(a,opNot(b)); }\n/* 0011 */ Hit opNotB(Hit a,Hit b) { return opNot(b); }\n/* 0100 */ Hit opAInhB(Hit a,Hit b) { return opAndx(opNot(a),b); }\n/* 0101 */ Hit opNotA(Hit a,Hit b) { return opNot(a); }\n/* 0110 */ Hit opXor(Hit a,Hit b) { return opAnd(opOr(a,b),opNot(opAnd(a,b))); }\n/* 0111 */ Hit opNand(Hit a,Hit b) { return opNot(opAnd(a,b)); }\n/* 1000 */ // Hit opAnd(Hit a,Hit b) { if (a.d > b.d) return a; else return b; } // { return (a.d < b.d) ? a : b; }\n/* 1001 */ Hit opEqu(Hit a,Hit b) { return opOr(opAndx(a,b),opNot(opOr(a,b))); }\n/* 1010 */ Hit opA(Hit a,Hit b) { return a; }\n/* 1011 */ Hit opBImpA(Hit a,Hit b) { return opOr(a,opNot(b)); }\n/* 1100 */ Hit opB(Hit a,Hit b) { return b; }\n/* 1101 */ Hit opAImpB(Hit a,Hit b) { return opOr(b,opNot(a)); }\n/* 1110 */ // Hit opOr(Hit a,Hit b) { if (a.d < b.d) return a; else return b; } // { return a.d < b.d ? a : b; }\n/* 1111 */ Hit opTrue(Hit a,Hit b) { return Hit(0.,a.i); }\n\n// -----------------------------------------\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n\n#define max3v(v) max(v.x,max(v.y,v.z))\n\nfloat sdBox(vec3 p,vec3 org,vec3 sz) // sdf of orthogonal box at 0, originally iq https://www.shadertoy.com/view/Xds3zN\n{\n  p=abs(p-org)-sz; // everything is symmetrical so just 3 sides need examination\n  return min(max3v(p),.0) + length(max(p,.0));\n}\n\nfloat sdSphere(vec3 p,vec3 org,float r) {\n  return distance(p,org) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// ----- text ------\n\nfloat TextSDF(vec3 p,vec3 orig,float sz,int cha) {\n    p -= orig;\n    vec3 sv = p;\n    vec3 d = abs(p) - vec3(sz*.5,sz*.5,0); // everything is symmetrical so just 3 sides need examination\n    float dst =  min(max3v(d),.0) + length(max(d,.0));\n    return dst > .1 || texelFetch( iChannel0, ivec2( (cha&15)<<6, (64*15)-(((cha>>4)&15)<<6)) + ivec2(p*64./sz+32.), 0 ).x > 0. ? dst : .03;\n}\n\nvec3 chOrg, chAdv=vec3(3.5,0,0);\n#ifdef NOTEXT\n#define ch(cc)\n#else\n#define ch(cc) \\\n  res = opOr(res,Hit(TextSDF(p,chOrg,8.,cc),1000.)); \\\n  chOrg+=chAdv;\n#endif\n\n// Map --------------------------------------------------------------\n\nHit Dist(vec3 pt) {\n\n  Hit res = opFalse();\n  \n  //float dz = 4.*sin(iTime);\n\n#define TRY(FUNC,X,Y,TXT) { \\\n  vec3 p = pt - vec3(-75+50*X,47-30*Y,10); \\\n  Hit box = Hit( sdBox(p,vec3(0,0,6),vec3(15,10,10)), 10. ); \\\n  Hit lsph = Hit( sdSphere(p,vec3(-3,0,0),8.), 5. ); \\\n  Hit rsph = Hit( sdSphere(p,vec3(3,0,0),8.), 2. ); \\\n  Hit t = FUNC(lsph,rsph); \\\n  if ((Y&1)>0) t = opAndx(t,box); \\\n  else if (Y*4+X==9||Y*4+X==11) t = opAndx(t, Hit(sdBox(p,vec3(0,0,0),vec3(15,10,clamp(6.+sin(iTime)*12.,4.5,8.))),t.i) ); \\\n  res = opOr(res,t); \\\n  chOrg=vec3(-7,-14,0); \\\n  TXT \\\n  }\n  \n  TRY(opFalse,0,0,F_ a_ l_ s_ e_)\n  TRY(opNor,0,1,N_ o_ r_)\n  TRY(opBInhA,0,2,B_ I_ n_ h_ A_)\n  TRY(opNotB,0,3,N_ o_ t_ B_)\n  TRY(opAInhB,1,0,A_ I_ n_ h_ B_)\n  TRY(opNotA,1,1,N_ o_ t_ A_)\n  TRY(opXor,1,2,X_ o_ r_)\n  TRY(opNand,1,3,N_ a_ n_ d_)\n  TRY(opAnd,2,0,A_ n_ d_)\n  TRY(opEqu,2,1,E_ q_ u_)\n  TRY(opA,2,2,A_)\n  TRY(opBImpA,2,3,B_ I_ m_ p_ A_)\n  TRY(opB,3,0,B_)\n  TRY(opAImpB,3,1,A_ I_ m_ p_ B_)\n  TRY(opOr,3,2,O_ r_) \n  TRY(opTrue,3,3,T_ r_ u_ e_)\n\n  Hit Back = Hit( 50. - pt.z, 1001. );\n  return opOr(Back,res);\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n  float dist = 0.;\n  vec3 pos;\n  Hit obj;\n  //float d1=20., d2=10.;\n  for ( int stps = 0; stps < 400; ++stps ) {\n    pos = beg + dir * dist;\n    obj = Dist( pos );\n    if ( obj.d < .01 ) break; // close enough\n    //if ( abs( (obj.d-d1) - (d2-d1) ) < obj.d\n    //if ( abs(obj.d-d1) < obj.d ) obj.d *= 1;\n    //d2 = d1; d1 = obj.d; // check if we are improving ...\n    dist += obj.d;\n    if ( pos.z>200. ) return vec4( pos, 91. ); // out of range\n  }\n  //return vec4( pos, 90. ); // report too many steps\n  return vec4( pos, obj.i ); // use best\n  \n}\n\nvec3 Normal(vec3 pt) {\n  float delta = .001; // large delta gives rounded corners\n  vec3 norm = Dist(pt).d - vec3(\n    Dist(pt-vec3(delta, 0., 0.)).d, \n    Dist(pt-vec3( 0.,delta, 0.)).d, \n    Dist(pt-vec3( 0., 0.,delta)).d );\n  return normalize( norm );\n}\n\nvec2 rot2d(vec2 inp,float ang) {\n    float s = sin(ang);\n    float c = cos(ang);\n    return vec2( inp.x * c + inp.y * s, inp.y * c - inp.x * s ); \n}\n\n/*\nvec3 camdir(vec3 dir,vec3 uvz) {\n    vec3 cd = normalize(dir);\n    vec3 cr = normalize(cross(vec3(0,1,0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    return mat3(cr, cu, cd) * normalize(uvz);\n}\n*/\n\n#define VARY(L,H,S) ((sin(S)+1.)/2.*(H-L)+L)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\n  vec2 R = iResolution.xy;\n  vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n  float fov = 1.; //VARY(.05,.5,iTime);\n  uv *= fov*.3;\n  //vec3 cam = vec3( 10.*sin(iTime), 10.*cos(iTime), -180.);\n  vec3 cam = vec3( 0,0,-200./fov);\n  vec3 camdir = vec3( uv, 1. );\n  //cam += normalize(camdir)/fov;\n\n  vec2 ms = iMouse.xy;\n  if ( ms.x > 0. ) ms = (ms+ms-R)/min(R.x,R.y); // -1 ... +1\n  ms *= 90.;\n  cam.x -= ms.x;\n  cam.y -= ms.y;\n\n\n/*\n  vec2 ms = iMouse.xy;\n  if ( ms.x > 0. ) ms = (ms+ms-R)/min(R.x,R.y); // -1 ... +1\n  ms = vec2(mod(iTime/5.,1.)/1.,.0);\n  cam.x += ms.x * -cam.x;\n  cam.y += ms.y * -cam.y;\n  camdir.x -= ms.x * 1.;\n  camdir.y -= ms.y * 1.;\n*/\n  //ms *= PI;\n  //vec2 lookat = vec2(0,240);\n  //ms=vec2(-.03);\n  //cam.xz = rot2d( cam.xz - lookat, -ms.x ) + lookat;\n  //cam.yz = rot2d( cam.yz - lookat, -ms.y ) + lookat;\n  //camdir.xz = rot2d( camdir.xz - lookat, ms.x/3. ) + lookat;\n  //camdir.yz = rot2d( camdir.yz - lookat, ms.y ) + lookat;\n  //camdir = camdir( cam\n\n  camdir = normalize( camdir );\n  vec4 hit = March( cam, camdir );\n\n  //vec3 Light = vec3( 50.+50.*sin(iTime), 50.+50.*cos(iTime*1.5), -100);\n  vec3 Light = vec3( 80, 50, -30);\n  vec3 dir = normalize( Light - hit.xyz );\n\n  //vec4 shadow = March( hit.xyz+dir*.1, dir );\n\n  vec3 norm = Normal(hit.xyz);\n  float difu = dot( norm, dir );\n  difu = .3 + .7*difu;\n  //if ( shadow.z > -10. ) difu = .2;\n\n#define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n \n if (hit.w==1001.)\n   O = vec4(.4);\n else if (hit.w==1000.)\n   O = vec4(0);\n else \n   O = color4(hit.w*.4);\n\n  O *= difu;\n\n  if ( hit.w == 90. ) O = vec4(1,1,1,1); // marching ran out of steps\n\n  O = sqrt(O);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define Sp_ ch(32) //\n#define Excl_ ch(33) // !\n#define DQuot_ ch(34) // \"\n#define Hash_ ch(35) // #\n#define Dlr_ ch(36) // $\n#define Pct_ ch(37) // %\n#define Amp_ ch(38) // &\n#define SQuot_ ch(39) // '\n#define LPar_ ch(40) // (\n#define RPar_ ch(41) // )\n#define Aster_ ch(42) // *\n#define Plus_ ch(43) // +\n#define Comma_ ch(44) // ,\n#define Minus_ ch(45) // -\n#define Period_ ch(46) // .\n#define Slash_ ch(47) // /\n#define _0_ ch(48) // 0\n#define _1_ ch(49) // 1\n#define _2_ ch(50) // 2\n#define _3_ ch(51) // 3\n#define _4_ ch(52) // 4\n#define _5_ ch(53) // 5\n#define _6_ ch(54) // 6\n#define _7_ ch(55) // 7\n#define _8_ ch(56) // 8\n#define _9_ ch(57) // 9\n#define Colo_ ch(58) // :\n#define Semi_ ch(59) // ;\n#define Lss_ ch(60) // <\n#define Eql_ ch(61) // =\n#define Gtr_ ch(62) // >\n#define Quest_ ch(63) // ?\n#define At_ ch(64) // @\n#define A_ ch(65) // A\n#define B_ ch(66) // B\n#define C_ ch(67) // C\n#define D_ ch(68) // D\n#define E_ ch(69) // E\n#define F_ ch(70) // F\n#define G_ ch(71) // G\n#define H_ ch(72) // H\n#define I_ ch(73) // I\n#define J_ ch(74) // J\n#define K_ ch(75) // K\n#define L_ ch(76) // L\n#define M_ ch(77) // M\n#define N_ ch(78) // N\n#define O_ ch(79) // O\n#define P_ ch(80) // P\n#define Q_ ch(81) // Q\n#define R_ ch(82) // R\n#define S_ ch(83) // S\n#define T_ ch(84) // T\n#define U_ ch(85) // U\n#define V_ ch(86) // V\n#define W_ ch(87) // W\n#define X_ ch(88) // X\n#define Y_ ch(89) // Y\n#define Z_ ch(90) // Z\n#define Lbrack_ ch(91) // [\n#define Bslash_ ch(92) // \\\n#define Rbrack_ ch(93) // ]\n#define Tilde_ ch(94) // ^\n#define Under_ ch(95) // _\n#define Tick_ ch(96) // `\n#define a_ ch(97) // a\n#define b_ ch(98) // b\n#define c_ ch(99) // c\n#define d_ ch(100) // d\n#define e_ ch(101) // e\n#define f_ ch(102) // f\n#define g_ ch(103) // g\n#define h_ ch(104) // h\n#define i_ ch(105) // i\n#define j_ ch(106) // j\n#define k_ ch(107) // k\n#define l_ ch(108) // l\n#define m_ ch(109) // m\n#define n_ ch(110) // n\n#define o_ ch(111) // o\n#define p_ ch(112) // p\n#define q_ ch(113) // q\n#define r_ ch(114) // r\n#define s_ ch(115) // s\n#define t_ ch(116) // t\n#define u_ ch(117) // u\n#define v_ ch(118) // v\n#define w_ ch(119) // w\n#define x_ ch(120) // x\n#define y_ ch(121) // y\n#define z_ ch(122) // z\n#define Lbrace_ ch(123) // {\n#define Bar_ ch(124) // |\n#define Rbrace_ ch(125) // }\n#define Squig_ ch(126) // ~\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}