{
    "Shader": {
        "info": {
            "date": "1598809062",
            "description": "Draw links between particles that are both in the closest 3-neighbor of each others.\nclick to see Voronoi domains and particle + Voronoi buffers.\n\nUsing Voronoï tracjing in one single buffer [url]https://shadertoy.com/view/wlcXRS[/url]\n",
            "flags": 32,
            "hasliked": 0,
            "id": "wlBBW1",
            "likes": 19,
            "name": "closest graph (Voronoi Tracking)",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "simulation",
                "particles",
                "voronoiparticlestracking"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 934
        },
        "renderpass": [
            {
                "code": "// ( previous try (private ): https://shadertoy.com/view/3lSBDR )\n// Fork of Voronoï tracking in 1-buffer https://shadertoy.com/view/wlcXRS\n// Fork of Gijs' https://shadertoy.com/view/WltSz7 that was rewording mine :-)\n\n// segment with disc ends: seamless distance to segment\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\n// === Display\n\nvoid mainImage( out vec4 O, vec2 U ){\n    \n    O = vec4(0);\n    float d,D;\n    \n    // get the id's of the 4 particles that (should be) closest.\n    ivec4 ids = getClosestS(ivec2(U)), // the 4 ids are stored in .x, .y, .z, .w\n         ids0, ids1;\n    \n#if 1 // draw the particles\n    d = distance(U,getParticle(ids[0]).xy);\n    O.b += smoothstep(1.5,0.,d-3.);          // color it\n // O += .3/(d*d);                           \n#endif \n    \n#if 0 // --- draw voronoi outlines    \n    vec2  p1 = getParticle(ids[0]).xy, // get the position of the closest particle\n\t      p2 = getParticle(ids[1]).xy; // get the position of the second closest particle\n    float r = dot( U-(p1+p2)/2. , normalize(p2-p1) );//get the distance to voronoi edge\n    O += smoothstep(2.,0.,abs(r))*.3;\n#endif \n    \n#if 1 // --- draw lines between closest points\n    vec2[4] Pos;                           // particles location, and distance to P\n    for(int i = 0; i < 4; i++)\n        Pos[i] = getParticle(ids[i]).xy;   // [ we once new these during bufA... ]\n\n    ivec2[6] link; int Nlink=0;            // all couples of particles \"each-other closest\"\n    \n    for(int i = 0; i < 3; i++) {\n        ids0 = getClosestS(ivec2(Pos[i])); // check that the \"4-closest\" relation is reciprocal\n        for( int j = i+1; j < 4; j++) {\n            ids1 = getClosestS(ivec2(Pos[j]));   // does then both know each other ?\n            for (int k = 1; k < 4; k++)          // start at 1 because 0 is itself\n#if 1\n                if ( ids0[k] == ids[j] ) {       // i sees j\n                    for (int l=1; l<4; l++)      // start at 1 because 0 is itself\n                        if( ids1[l] == ids[i] )  // j sees i too\n                            { link[Nlink++] = ivec2(i,j); break; }\n                    break; \n                }\n#else\n                if ( ids0[k] == ids[j] || ids1[k] == ids[i] )  // i sees j or the reverse\n                    { link[Nlink++] = ivec2(i,j); break; }\n#endif\n        }\n    }\n    for(int i = 0; i < Nlink; i++) {       // now we can draw the links\n        ivec2 l = link[i];\n        d = line ( U, Pos[l.x], Pos[l.y] ), \n        D = distance(  Pos[l.x], Pos[l.y] ) ,\n        O.rgb += smoothstep( 1.5, 0., d) \n     //   * step(D, vec3(40,20,10)); \n          * min( .5*vec3(40,20,10) / D , 1.);\n     //   *  ( .6 + .6 * cos( .1*D  + vec3(0,23,21)  ) );\n    }\n#endif     \n    \n    if (iMouse.z>0.) {          // --- on click, draw the particle and voronoi buffers \n        O += .3*float(ids)/float(PARTICLES); // draw voronoi around closest \n        vec2 _m = U-ofs2-iResolution2; if (max(_m.x,_m.y)<0.) // display maps\n        O += (1.-O.a) * .5* texelFetch(iChannel0, ivec2(U), 0) \n                      / ( U.x < ofs2.x ? .2*R.x: float(PARTICLES) )\n             + vec4(0,0,.3,0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Fork of my fork of Gijs' https://shadertoy.com/view/WltSz7 that was rewording mine :-)\n\n// The code is not optimized for speed; it turns out programming with integers can be slow on some GPU's.\n// The reason I still use them is readability of the code.\n\n//amount of particles\n//const int PARTICLES = 1000; \n#define PARTICLES int(R.x*R.y/800.) // 230 2300\n\n#define R iResolution.xy\n#define iResolution1 (R/4.)  // slot allocated for Particle Buffer \n#define iResolution2 (R/4.)  // slot allocated for Voronoi Buffer\n#define ofs2     vec2(iResolution1.x,0)\n\n// --- chose length of closest LIST\n//#define LIST xxxx    //  1 (not enough for repulsion & draw voronoi)\n//#define LIST xyyy    //  2\n//#define LIST xyzz    //  3\n  #define LIST xyzw    //  4\n\n// --- Particle Buffer part:\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\n// --- Voronoi Buffer part:\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\n\n//returns the ids of the four closest particles from the input\n//    if (xy != ivec2(clamp(vec2(xy),vec2(0),iResolution2)) ) return ivec4(0);\n#define getClosest(xy) /* xy: location within Voronoi Buffer */ \\\n    ivec4(texelFetch(iChannel0, ivec2(ofs2+vec2(xy)), 0).LIST) // was channel1\n\n#define getClosestS(pos) getClosest(ivec2(vec2(pos)/R *iResolution2))\n        \n//returns the location of the particle within the particle buffer corresponding with the input id \n#define locFromID(id) ivec2( (id) % int(iResolution1.x), (id) / int(iResolution1.x))\n\n//get the particle corresponding to the input id\n#define getParticle(id) texelFetch(iChannel0, locFromID(id), 0)\n\n\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n#define Nhash(h) hash(int((h)*41343.))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of my fork of Gijs' https://shadertoy.com/view/WltSz7 that was rewording mine :-)\n\nfloat distance2Particle(int id, vec2 W){ // screen coords\n    if( id < 0 ) return 1e20;\n    vec2 delta = getParticle(id).xy - W;\n    return dot( delta, delta );\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])  i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])  i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])  i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])  i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n    i = i.LIST; d = d.LIST;\n}\n\n// =========================================================\nvoid mainImage( out vec4 O, vec2 U ){\n    ivec2 I = ivec2(U);\n    if ( U+.5 == R ) O.xy = R; // store current resol to detect resol change\n    \n// === main Particle Buffer part\n  vec2 _m = U - iResolution1; \n  if (max(_m.x,_m.y)<0.) {\n        \n    //we only simulate PARTICLES amount of particles\n    int id = I.x + I.y*int(iResolution1.x);\n    if(id >= PARTICLES) return;\n    \n    vec4 prev = texelFetch( iChannel0, ivec2(U), 0 );\n    vec2  pos = prev.xy,              // screen coords\n          vel = prev.zw;              // velocity\n     \n    if(texelFetch(iChannel0, ivec2(R)-1,0).xy != R ) { // 1st run or resolution change\n        float  x = hash(id),  y = Nhash(x),  // --- pick a \"random\" starting position\n              vx = Nhash(y), vy = Nhash(vx);\n        pos = R * vec2( x, y);        // screen coordinates\n        vel = 2.* vec2(vx,vy) - 1. ;  // random velocity\n    }\n    pos += .1 * vel;                  // --- motion\n    pos = mod(pos,R);                 // wrap screen\n    \n    O = vec4(pos,vel);\n}\n\n// === main Voronoi Buffer part\n  _m = U - ofs2 - iResolution2; \n  if (U.x >= iResolution1.x && max(_m.x,_m.y) < 0.) {   \n    \n    //if(iFrame==0){ fragColor = vec4(0); return; }\n    ivec2 I = ivec2(U-ofs2);\n    vec2  W = (U-ofs2)/iResolution2 * R;\n    \n    ivec4 new = ivec4(-1);  //in this vector the four new closest particles' ids will be stored  \n    vec4  dis = vec4(1e20); //in this vector the distance to these particles will be stored \n    \n    //get all known closest particles from old self and neighbours\n    ivec4 old   = getClosest( I + ivec2( 0, 0) ),           \n          east  = getClosest( I + ivec2( 1, 0) ),\n\t      north = getClosest( I + ivec2( 0, 1) ),\n          west  = getClosest( I + ivec2(-1, 0) ),\n          south = getClosest( I + ivec2( 0,-1) );\n    //collect them in a array so we can loop over it\n    ivec4[5] candidates = ivec4[5](old, east, north, west, south); \n    \n    for(int i=0; i<5; i++)\n        for(int j=0; j<4; j++){\n            int id = candidates[i][j];\n            float dis2 = distance2Particle(id, W); // to screen\n            insertion_sort( new, dis, id, dis2 );\n        }\n    \n    for(int k = 0; k < 1; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            I.x + \n            I.y  * int(iResolution2.x) + \n            iFrame*int(iResolution2.x*iResolution2.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, W) );\n    }\n    \n    O = vec4(new);   \n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}