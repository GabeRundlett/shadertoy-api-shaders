{
    "Shader": {
        "info": {
            "date": "1608285560",
            "description": "This is raytraced, not raymarched, there is no space division, each dodecahedron is an individual.\n\nI get 30fps at 512x288 on my crummy Intel Integrated graphics, I'd be interested in how more capable GPUs do with this.\n\nMouse & up/down to navigate.",
            "flags": 48,
            "hasliked": 0,
            "id": "3sKfDt",
            "likes": 9,
            "name": "729 Rhombic Dodecahedra",
            "published": 3,
            "tags": [
                "raytrace",
                "dodecahedron",
                "rhombic",
                "trumbore",
                "moller"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 729 Rhombic Dodecahedra, Matthew Arcus, mla, 2020\n//\n// Ray tracing parallelograms - how many can we do?\n// Quite a few in fact, a fast sphere intersection test helps.\n//\n// Mouse and up/down moves around\n// 'b': blink\n// 'f': fog\n// 'r': rotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 4; // (2N+1)^3 polyhedra\nfloat maxdist = 60.0;\n\n// Ray-plane intersection:\n// Intersect p+kr with plane generated by e0,e1 at origin\n// Solve linear system: p-tr = ue0 + ve1  & return vec3(-t,u,v).\n// Uses Cramer's rule, ie. if mat3(A,B,C)*X = P then:\n// X = vec3(det(P,B,C),det(A,P,C),det(A,B,P))/det(A,B,C)\n// Determinant of mat3(A,B,C) is just the triple product:\n// dot(A,cross(B,C)) = dot(B,cross(C,A)) = -dot(C,cross(B,A)) etc.\n//\n// This is the ray-triangle intersection algorithm of Tomas MÃ¶ller and Ben Trumbore,\n// but it's of wider applicability than just to triangles. (If e0,e1 are sides of a\n// triangle, then we are in the triangle iff 0 <= u,v,1-u-v <= 1 but can generally treat\n// u and v as (possibly oblique) general coords in the plane).\n\nvec3 intersect(vec3 p, vec3 r, vec3 e0, vec3 e1, vec3 n) {\n  // Expects that n = cross(e0,e1);\n  vec3 m = cross(r,p);\n  return vec3(-dot(p,n),dot(m,e1),-dot(m,e0))/dot(r,n);\n}\n\nint hitindex = -1;\nvec3 hitnormal = vec3(0);\nbool checkparallelogram(vec3 p, vec3 r, vec3 v0, vec3 v1, vec3 v2, int index, inout vec3 amin) {\n  p -= v0; v1 -= v0; v2 -= v0;\n  vec3 normal = cross(v1,v2);\n  if (dot(normal,r) > 0.0) return false; // Back face cull\n  vec3 a = intersect(p,r,v1,v2,normal);\n  // a = vec3(t,u,v). Require 0 <= t <= amin.x and 0 <= u,v <= 1 for a parallelogram\n  bool hit = all(bvec2(all(greaterThanEqual(a,vec3(0))),\n                       all(lessThanEqual(a,vec3(amin.x,1,1)))));\n  if (!hit) return false;\n  hitindex = index;\n  hitnormal = normal;\n  amin = a;\n  return true;\n}\n\nvoid rhombic(vec3 p, vec3 r, vec3 q, int index, inout vec3 amin) {\n  p -= q;\n  if (key(CHAR_B)) {\n      float h = fhash(uint(index)^uint(4.0*iTime));\n      if (h < 0.1) return;\n  }\n  // Octahedron vertices\n  vec3 o0 = vec3(0,0,2);\n  vec3 o1 = vec3(0,0,-2);\n  vec3 o2 = vec3(0,2,0);\n  vec3 o3 = vec3(0,-2,0);\n  vec3 o4 = vec3(2,0,0);\n  vec3 o5 = vec3(-2,0,0);\n  // Cube vertices\n  vec3 c0 = vec3(1,1,1);\n  vec3 c1 = vec3(1,-1,1);\n  vec3 c2 = vec3(-1,-1,1);\n  vec3 c3 = vec3(-1,1,1);\n\n  vec3 c4 = vec3(1,1,-1);\n  vec3 c5 = vec3(1,-1,-1);\n  vec3 c6 = vec3(-1,-1,-1);\n  vec3 c7 = vec3(-1,1,-1);\n  \n  // Rhombic dodecahedron faces\n  checkparallelogram(p,r,o0,c1,c0,index,amin);\n  checkparallelogram(p,r,o0,c2,c1,index,amin);\n  checkparallelogram(p,r,o0,c3,c2,index,amin);\n  checkparallelogram(p,r,o0,c0,c3,index,amin);\n\n  checkparallelogram(p,r,o1,c7,c4,index,amin);\n  checkparallelogram(p,r,o1,c6,c7,index,amin);\n  checkparallelogram(p,r,o1,c5,c6,index,amin);\n  checkparallelogram(p,r,o1,c4,c5,index,amin);\n  \n  checkparallelogram(p,r,o4,c4,c0,index,amin);\n  checkparallelogram(p,r,o4,c1,c5,index,amin);\n  checkparallelogram(p,r,o5,c6,c2,index,amin);\n  checkparallelogram(p,r,o5,c3,c7,index,amin);\n}\n\n// Fast check for sphere intersection\nbool checksphere (vec3 p, vec3 r, vec3 centre, float radius2) {\n  p -= centre; // centre on sphere\n  float pr = dot(p,r);\n  if (pr > 0.0) return false;\n  float pp = dot(p,p);\n  return pr*pr >= pp-radius2;\n}\n\nvec3 getcolor(int hitindex) {\n  float h = fhash(uint(hitindex));\n  return hsv2rgb(vec3(h,1,1));\n}\n\nvec3 scene(vec3 p, vec3 r, vec3 light) {\n  vec3 background = vec3(1,1,0.75);\n  vec3 color = background;\n  vec3 amin = vec3(1e8,0,0);\n  float radius2 = 4.0; // Bounding sphere radius\n  for (int i = -N; i <= N; i++) {\n    for (int j = -N; j <= N; j++) {\n      for (int k = -N; k <= N; k++) {\n        vec3 centre = 4.0*vec3(i,j,k);\n        if (checksphere(p,r,centre,radius2)) {\n          int index = (i+N)+(2*N+1)*(j+N+(2*N+1)*(k+N));\n          //assert(index >= 0);\n          //assert(index < (2*N+1)*(2*N+1)*(2*N+1));\n          rhombic(p,r,centre,index,amin);\n        }\n      }\n    }\n  }\n  if (hitindex >= 0) {\n    hitnormal = normalize(hitnormal);\n    color = getcolor(hitindex);\n    //color *= texture(iChannel0,amin.yz).xyz;\n    color *= 0.4+0.6*(max(0.0,dot(hitnormal,light)));\n    if (!key(CHAR_F)) color = mix(background,color,max(0.0,maxdist-amin.x)/maxdist);\n  }\n  return color;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  float camera = -40.0;\n  camera *= exp(-0.1*float(keycount(KEY_UP)-keycount(KEY_DOWN)));\n  vec3 p = vec3(0,0,camera);\n  p = transform(p);\n  vec3 light = vec3(0,1,-1);\n  light = transform(light);\n  light = normalize(light);\n  vec3 r = vec3(uv,2);\n  r = transform(r);\n  r = normalize(r);\n\n  vec3 color = scene(p,r,light);\n  pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  outColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// common //////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat fhash(uint x) {\n   return float(ihash(x))/pow(2.0,32.0);\n}\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}