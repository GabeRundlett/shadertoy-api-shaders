{
    "Shader": {
        "info": {
            "date": "1482007643",
            "description": "This is my xmas present to the Shadertoy community.\nCloth simulation of 128x64 vertex. Wind, collision. 60fps on gtx970\nRendered as 1024x512 voxels with spatial tree. I have never seen this rendering method in Shadertoy.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "MldXWX",
            "likes": 317,
            "name": "curtain and ball",
            "published": 3,
            "tags": [
                "3d",
                "raycasting",
                "physics",
                "xmas",
                "cloth"
            ],
            "usePreview": 0,
            "username": "archee",
            "viewed": 12898
        },
        "renderpass": [
            {
                "code": "/*\n  128x64 vertex cloth simulation with collision, wind\n\n  try to guess, how it works before reading :D\n\n*/\n\n#define SIZX 128.0\n#define SIZY 64.0\n\n#define SIZYPHYS (SIZY+2.0)\n\nfloat mytime = 0.0; // timing stored in texture to deal with frame skip\n\nconst float maxextentionratio = 1.15;\n\n\nconst float ballradius = 0.99 * 64.0*0.3;\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime/3.0)*0.8));;\n}\n\nvec3 lighting(vec3 normal)\n{\n\treturn vec3(dot(normal,normalize(vec3(0.5,1.0,0.0)))*0.5+0.5);    \n}\n\nvec4 background(vec3 campos,vec3 camdir)\n{\n\treturn vec4(vec3(atan(camdir.y*8.0)*-0.5+0.5),9999.0)    ;\n}\n\nvec3 getpos(vec2 uv)\n{\n    return textureLod(iChannel1,vec2((uv+0.5)/iResolution.xy),0.0).xyz;\n}\n\n\nvec3 rotatex(vec3 v,float anglex)\n{\n\tfloat t;\n\tt =   v.y*cos(anglex) - v.z*sin(anglex);\n\tv.z = v.z*cos(anglex) + v.y*sin(anglex);\n\tv.y = t;\n\treturn v;\n}\n\nfloat anglex = 0.1;\nfloat angley = 0.0;\n\nvec3 rotcam(vec3 v)\n{\n\tfloat t;\n\tv = rotatex(v,anglex);\n\t\n\tt = v.x * cos(angley) - v.z*sin(angley);\n\tv.z = v.z*cos(angley) + v.x*sin(angley);\n\tv.x = t;\n\treturn v;\n}\n\n\nvec3 findnormal(vec2 uv)\n{\n    return normalize(cross(getpos(uv+vec2(1.0,0.0))-getpos(uv-vec2(1.0,0.0)),getpos(uv+vec2(0.0,1.0))-getpos(uv-vec2(0.0,1.0))));\n}\n\nvec4 raytrace_curtain_background_rail(vec3 campos,vec3 camdir)\n{\n    // raycast 1024*512 voxels with spatial tree\n    // note that the cloth has only 128x64 vertices, \n    // but linear filtered reading of the positions texture oversamples it\n    \n    const float minst = 1.0/8.0; // oversampling voxelgeometry by 8x8 \n    const float voxelsize = minst*0.77*maxextentionratio;\n    float mindept=999.0;\n    vec2 c = vec2(0.0,0.0);\n    vec2 minc=vec2(-1.0,-1.0);\n    float st = SIZY;\n    float levelup=0.0;\n    \n    \n    float cnt=0.0;\n    for(float i=0.0;i<5000.0;i+=1.0) // less than 200 iterations for most pixels\n    {\n        cnt+=1.0;\n            \n        vec3 wp = getpos(c);\n        \n        if (st==minst)\n        {\n        \tfloat d=length( cross(wp-campos,camdir) );\n        \tif (d<=voxelsize)\n        \t{\n                float dept = dot(camdir,wp);\n                if (dept<mindept)\n                {\n                    mindept = dept;\n                    minc = c;\n                }\n\t        }\n            \n        \tif (st==minst)            \n\t            levelup=1.0;\n        }\n        \n        vec3 boundingcenter= getpos(c.xy + vec2(st*0.5));\n\n        if (  length( cross(boundingcenter-campos,camdir) )>st*0.79*maxextentionratio )\n        {\n            levelup=1.0;\n        }\n        \n        \n        \n        if (levelup>0.0)\n        {\n            levelup=0.0;\n            \n            if ( fract(c.x/st/2.0)<0.25 )\n            {\n                c.x += st;\n            }\n            else\n            {\n                c.x -= st;            \n\n                if ( fract(c.y/st/2.0)<0.25 )\n                {\n                    c.y += st;\n                }\n                else\n                {\n                    c.y -= st;\n                    st *= 2.0;\n                    levelup=1.0;\n                }\n            }\n        }\n        else\n        {\n            \n            if (st>minst) st/=2.0;\n            \n        }\n        \n//        if (c.x>=SIZX) break;    \n        if (c.y>=SIZY) break;    \n    }\n    \n    if (minc.x>=0.0)\n    {\n        vec3 diffuse;\n        diffuse = clamp( (texture(iChannel0,vec2(minc.x/SIZX,minc.y/SIZX)).xyz-0.3)*-30.0,0.7,1.0)*1.5;\n        \n        vec3 normal = findnormal(minc);\n        \n        if ( dot(camdir,normal) < -0.1) // back side detection with antibug cheat\n        {\n            normal*=-1.0;  // backside color of curtian\n            diffuse*=vec3(0.5,0.7,1.0);\n        }\n        else\n        {\n\t\t\tdiffuse*=vec3(1.0,0.8,0.6); // front color \n        }\n        \n        mindept-=dot(campos,camdir);\n        vec3 hitpos = campos + camdir*mindept;\n        \n        // ball analitic ambient occlusion on curtian\n        float aaom = clamp( (hitpos.y-ballpos().y)/ballradius,-1.0,1.0)*0.5+0.5;\n        \n        float balld = length(hitpos-ballpos());\n        float aao = 1.0 - aaom * max(dot(normal,(hitpos-ballpos())),0.0)/balld/balld/balld*ballradius*ballradius*1.3;\n        \n//        aao = 1.0;\n        \n        return  vec4(diffuse*lighting(normal)*aao,mindept);\n        \n    }\n    else\n    {\n        vec3 dir = camdir; // quick anti aliased 3d line\n        dir.x = 0.0;\n        vec3 p2 = campos;\n        p2.x = 0.0;\n        float rod = min(length(cross(normalize(dir),p2))/0.8,1.0);\n        if (dot(dir,p2)>0.0) rod = 1.0;\n        float mul = rod;\n        return background(campos,camdir)*vec4(mul,mul,mul,1.0);\n    }\n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    mytime = float(iFrame) / 60.0;\n    mytime = getpos(vec2(0.0,SIZYPHYS)).x;\n    \n    float zoom = 1.4;\n    float zoomamt = clamp(sin((mytime)/2.0+0.5)*-3.0+1.2,0.0,1.0);\n    \n    angley = cos((mytime+2.0)*0.1)*1.3;\n    anglex = max(-0.05,-ballpos().z/SIZY*0.5);\n    \n    \n    fragColor = vec4(1.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 campos = vec3(SIZX/2.0,SIZY*0.6,SIZY*0.0);\n\tvec3 camdir = vec3((uv-0.5)*1.1,1);\n\tcamdir.y *= -iResolution.y / iResolution.x; // wide screen\n\tcamdir = normalize(rotcam(camdir));\n    zoom = 1.1 - zoomamt*0.3;\n\tcampos -= rotcam(vec3(0,0,SIZX*zoom)); // back up from subject    \n    \n    \n    vec4 res  = raytrace_curtain_background_rail(campos,camdir);\n    \n    // raytrace ball    \n    vec3 bp = ballpos();\n    \n    \n    float m = length(cross(bp-campos,camdir))/ballradius;\n    if (m<1.0)\n    {\n        float dept = dot(bp-campos,camdir) - sqrt(1.0-m*m)*ballradius;\n        vec3 hitpos = campos + camdir*dept;\n        vec3 normal = -(hitpos-bp)/ballradius;\n        if (dept < res.a)\n        {\n            res.a = dept;\n            \n            vec3 reflectedraydir = reflect(camdir,normal);\n            \n            // ball shading:\n            // raytracing the reflected curtain in the ball is very slow due to random texture access\n            \n//            vec3 reflectedcolor = raytrace_curtain_background_rail(hitpos,reflectedraydir).xyz;\n            vec3 reflectedcolor = background(hitpos,reflectedraydir).xyz;\n            \n            float f=1.0-max(dot(normal,camdir),0.0);\n            float fresnel = 0.05+0.95*f*f*f*f*f;\n            res.xyz = mix(vec3(0.5,0.05,0.1)*lighting(normal),reflectedcolor, fresnel);\n        }\n    }\n    \n    fragColor = res;\n    \n    // progress bar was aimed to hide the bugs in the beginning, such as the stretching.\n    // but it ruins the preview\n/*    const float loadtime = 2.0;\n    if (mytime<loadtime)\n    { \n        fragColor = vec4(0.0);\n        if ( uv.y>0.45 && uv.y<0.55)\n        {\n            fragColor = vec4(mytime/loadtime > uv.x ? 1.0 : 0.5);\n        }\n    }*/\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Copy the same code to all buffers and chain them.\n\n#define SIZX 130.0\n#define SIZY 66.0\nconst vec3 windvel = vec3(0.01,0.0,-0.005);\nconst float gravity = 0.0022;\nfloat mytime=0.0;\n\nvec3 getpos(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01)/iResolution.xy).xyz;\n}\nvec3 getvel(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01+vec2(SIZX,0.0))/iResolution.xy).xyz;\n}\n\nvec3 pos,vel,ovel;\nvec2 c;\n\nvoid edge(vec2 dif)\n{\n    if ( \n        (dif+c).x>=0.0 && (dif+c).x<SIZX &&\n        (dif+c).y>=0.0 && (dif+c).y<SIZY    )\n    {\n        float edgelen = length(dif);\n        vec3 posdif = getpos(dif+c)-pos;\n        vec3 veldif = getvel(dif+c)-ovel;\n\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.15); // spring\n\n        //            vel += dot(posdif,veldif)*posdif/dot(posdif,posdif)*0.33; // damper\n        vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n        //            vel += normalize(posdif)*(-0.005); // spring\n    }\n}\n\nvec3 findnormal(vec2 c)\n{\n    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));\n}\n\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime/3.0)*0.8));;\n}\n\nvoid ballcollis()\n{\n    float ballradius = 64.0*0.3;\n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    mytime = float(iFrame) / 60.0;\n    mytime = getpos(vec2(0.0,SIZY)).x;\n    \n    fragColor=vec4(0.0);\n    vec2 fc = fragCoord+0.1;\n    fc-=fract(fc);\n\n    if (fc.y>=SIZY+2.0 || fc.x>=SIZX*2.0) discard;\n    \n    c = fc;\n    c.x = fract(c.x/SIZX)*SIZX;\n\n    pos = getpos(c);\n     vel = getvel(c);\n\n    \n    \n    \n/*    vec2 edges[6];\n    edges[2]=vec2(1.0,0.0);\n    edges[3]=vec2(-1.0,0.0);\n    edges[0]=vec2(0.0,1.0);\n    edges[1]=vec2(0.0,-1.0);\n    edges[4]=vec2(1.0,1.0);\n    edges[5]=vec2(-1.0,-1.0);*/\n    \n    ovel = vel;\n    \n    edge(vec2(0.0,1.0));\n    edge(vec2(0.0,-1.0));\n    edge(vec2(1.0,0.0));\n    edge(vec2(-1.0,0.0));\n    edge(vec2(1.0,1.0));\n    edge(vec2(-1.0,-1.0));\n\n    edge(vec2(0.0,2.0));\n    edge(vec2(0.0,-2.0));\n    edge(vec2(2.0,0.0));\n    edge(vec2(-2.0,0.0));\n    edge(vec2(2.0,-2.0));\n    edge(vec2(-2.0,2.0));\n    \n    \n//    vel.x = 0.0;\n    ballcollis();\n    \n    pos += vel;\n    vel.y += gravity; // gravity\n    \n    // apply air friction\n    \n    vec3 norm = findnormal(c);\n    vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    \n    \n    if (iFrame==0 || c.y==0.0) // init\n    {\n        pos = vec3(fc.x*0.85,fc.y,fc.y*0.01);\n        vel = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(fc.x>=SIZX ? vel : pos,0.0);\n    \n    if (fc.y>=SIZY)\n    {\n        mytime += 1.0/4.0/60.0;\n        fragColor = vec4(mytime);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Copy the same code to all buffers and chain them.\n\n#define SIZX 130.0\n#define SIZY 66.0\nconst vec3 windvel = vec3(0.01,0.0,-0.005);\nconst float gravity = 0.0022;\nfloat mytime=0.0;\n\nvec3 getpos(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01)/iResolution.xy).xyz;\n}\nvec3 getvel(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01+vec2(SIZX,0.0))/iResolution.xy).xyz;\n}\n\nvec3 pos,vel,ovel;\nvec2 c;\n\nvoid edge(vec2 dif)\n{\n    if ( \n        (dif+c).x>=0.0 && (dif+c).x<SIZX &&\n        (dif+c).y>=0.0 && (dif+c).y<SIZY    )\n    {\n        float edgelen = length(dif);\n        vec3 posdif = getpos(dif+c)-pos;\n        vec3 veldif = getvel(dif+c)-ovel;\n\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.15); // spring\n\n        //            vel += dot(posdif,veldif)*posdif/dot(posdif,posdif)*0.33; // damper\n        vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n        //            vel += normalize(posdif)*(-0.005); // spring\n    }\n}\n\nvec3 findnormal(vec2 c)\n{\n    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));\n}\n\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime/3.0)*0.8));;\n}\n\nvoid ballcollis()\n{\n    float ballradius = 64.0*0.3;\n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    mytime = float(iFrame) / 60.0;\n    mytime = getpos(vec2(0.0,SIZY)).x;\n    \n    fragColor=vec4(0.0);\n    vec2 fc = fragCoord+0.1;\n    fc-=fract(fc);\n\n    if (fc.y>=SIZY+2.0 || fc.x>=SIZX*2.0) discard;\n    \n    c = fc;\n    c.x = fract(c.x/SIZX)*SIZX;\n\n    pos = getpos(c);\n     vel = getvel(c);\n\n    \n    \n    \n/*    vec2 edges[6];\n    edges[2]=vec2(1.0,0.0);\n    edges[3]=vec2(-1.0,0.0);\n    edges[0]=vec2(0.0,1.0);\n    edges[1]=vec2(0.0,-1.0);\n    edges[4]=vec2(1.0,1.0);\n    edges[5]=vec2(-1.0,-1.0);*/\n    \n    ovel = vel;\n    \n    edge(vec2(0.0,1.0));\n    edge(vec2(0.0,-1.0));\n    edge(vec2(1.0,0.0));\n    edge(vec2(-1.0,0.0));\n    edge(vec2(1.0,1.0));\n    edge(vec2(-1.0,-1.0));\n\n    edge(vec2(0.0,2.0));\n    edge(vec2(0.0,-2.0));\n    edge(vec2(2.0,0.0));\n    edge(vec2(-2.0,0.0));\n    edge(vec2(2.0,-2.0));\n    edge(vec2(-2.0,2.0));\n    \n    \n//    vel.x = 0.0;\n    ballcollis();\n    \n    pos += vel;\n    vel.y += gravity; // gravity\n    \n    // apply air friction\n    \n    vec3 norm = findnormal(c);\n    vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    \n    \n    if (iFrame==0 || c.y==0.0) // init\n    {\n        pos = vec3(fc.x*0.85,fc.y,fc.y*0.01);\n        vel = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(fc.x>=SIZX ? vel : pos,0.0);\n    \n    if (fc.y>=SIZY)\n    {\n        mytime += 1.0/4.0/60.0;\n        fragColor = vec4(mytime);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Copy the same code to all buffers and chain them.\n\n#define SIZX 130.0\n#define SIZY 66.0\nconst vec3 windvel = vec3(0.01,0.0,-0.005);\nconst float gravity = 0.0022;\nfloat mytime=0.0;\n\nvec3 getpos(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01)/iResolution.xy).xyz;\n}\nvec3 getvel(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01+vec2(SIZX,0.0))/iResolution.xy).xyz;\n}\n\nvec3 pos,vel,ovel;\nvec2 c;\n\nvoid edge(vec2 dif)\n{\n    if ( \n        (dif+c).x>=0.0 && (dif+c).x<SIZX &&\n        (dif+c).y>=0.0 && (dif+c).y<SIZY    )\n    {\n        float edgelen = length(dif);\n        vec3 posdif = getpos(dif+c)-pos;\n        vec3 veldif = getvel(dif+c)-ovel;\n\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.15); // spring\n\n        //            vel += dot(posdif,veldif)*posdif/dot(posdif,posdif)*0.33; // damper\n        vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n        //            vel += normalize(posdif)*(-0.005); // spring\n    }\n}\n\nvec3 findnormal(vec2 c)\n{\n    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));\n}\n\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime/3.0)*0.8));;\n}\n\nvoid ballcollis()\n{\n    float ballradius = 64.0*0.3;\n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    mytime = float(iFrame) / 60.0;\n    mytime = getpos(vec2(0.0,SIZY)).x;\n    \n    fragColor=vec4(0.0);\n    vec2 fc = fragCoord+0.1;\n    fc-=fract(fc);\n\n    if (fc.y>=SIZY+2.0 || fc.x>=SIZX*2.0) discard;\n    \n    c = fc;\n    c.x = fract(c.x/SIZX)*SIZX;\n\n    pos = getpos(c);\n     vel = getvel(c);\n\n    \n    \n    \n/*    vec2 edges[6];\n    edges[2]=vec2(1.0,0.0);\n    edges[3]=vec2(-1.0,0.0);\n    edges[0]=vec2(0.0,1.0);\n    edges[1]=vec2(0.0,-1.0);\n    edges[4]=vec2(1.0,1.0);\n    edges[5]=vec2(-1.0,-1.0);*/\n    \n    ovel = vel;\n    \n    edge(vec2(0.0,1.0));\n    edge(vec2(0.0,-1.0));\n    edge(vec2(1.0,0.0));\n    edge(vec2(-1.0,0.0));\n    edge(vec2(1.0,1.0));\n    edge(vec2(-1.0,-1.0));\n\n    edge(vec2(0.0,2.0));\n    edge(vec2(0.0,-2.0));\n    edge(vec2(2.0,0.0));\n    edge(vec2(-2.0,0.0));\n    edge(vec2(2.0,-2.0));\n    edge(vec2(-2.0,2.0));\n    \n    \n//    vel.x = 0.0;\n    ballcollis();\n    \n    pos += vel;\n    vel.y += gravity; // gravity\n    \n    // apply air friction\n    \n    vec3 norm = findnormal(c);\n    vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    \n    \n    if (iFrame==0 || c.y==0.0) // init\n    {\n        pos = vec3(fc.x*0.85,fc.y,fc.y*0.01);\n        vel = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(fc.x>=SIZX ? vel : pos,0.0);\n    \n    if (fc.y>=SIZY)\n    {\n        mytime += 1.0/4.0/60.0;\n        fragColor = vec4(mytime);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Copy the same code to all buffers and chain them.\n\n#define SIZX 130.0\n#define SIZY 66.0\nconst vec3 windvel = vec3(0.01,0.0,-0.005);\nconst float gravity = 0.0022;\nfloat mytime=0.0;\n\nvec3 getpos(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01)/iResolution.xy).xyz;\n}\nvec3 getvel(vec2 uv)\n{\n    return texture(iChannel1,(uv+0.01+vec2(SIZX,0.0))/iResolution.xy).xyz;\n}\n\nvec3 pos,vel,ovel;\nvec2 c;\n\nvoid edge(vec2 dif)\n{\n    if ( \n        (dif+c).x>=0.0 && (dif+c).x<SIZX &&\n        (dif+c).y>=0.0 && (dif+c).y<SIZY    )\n    {\n        float edgelen = length(dif);\n        vec3 posdif = getpos(dif+c)-pos;\n        vec3 veldif = getvel(dif+c)-ovel;\n\n        vel += normalize(posdif)*(clamp(length(posdif)-edgelen,-1.0,1.0)*0.15); // spring\n\n        //            vel += dot(posdif,veldif)*posdif/dot(posdif,posdif)*0.33; // damper\n        vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*0.10); // damper\n        //            vel += normalize(posdif)*(-0.005); // spring\n    }\n}\n\nvec3 findnormal(vec2 c)\n{\n    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));\n}\n\nvec3 ballpos()\n{\n    return vec3(128.0*0.4,64.0*0.7,64.0*(cos(mytime/3.0)*0.8));;\n}\n\nvoid ballcollis()\n{\n    float ballradius = 64.0*0.3;\n    vec3 ballpos2 = ballpos();\n    if ( length(pos-ballpos2)<ballradius)\n    {\n        vel -= normalize(pos-ballpos2)*dot(normalize(pos-ballpos2),vel);\n        vel += (normalize(pos-ballpos2)*ballradius+ballpos2-pos);\n    }\n                        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    mytime = float(iFrame) / 60.0;\n    mytime = getpos(vec2(0.0,SIZY)).x;\n    \n    fragColor=vec4(0.0);\n    vec2 fc = fragCoord+0.1;\n    fc-=fract(fc);\n\n    if (fc.y>=SIZY+2.0 || fc.x>=SIZX*2.0) discard;\n    \n    c = fc;\n    c.x = fract(c.x/SIZX)*SIZX;\n\n    pos = getpos(c);\n     vel = getvel(c);\n\n    \n    \n    \n/*    vec2 edges[6];\n    edges[2]=vec2(1.0,0.0);\n    edges[3]=vec2(-1.0,0.0);\n    edges[0]=vec2(0.0,1.0);\n    edges[1]=vec2(0.0,-1.0);\n    edges[4]=vec2(1.0,1.0);\n    edges[5]=vec2(-1.0,-1.0);*/\n    \n    ovel = vel;\n    \n    edge(vec2(0.0,1.0));\n    edge(vec2(0.0,-1.0));\n    edge(vec2(1.0,0.0));\n    edge(vec2(-1.0,0.0));\n    edge(vec2(1.0,1.0));\n    edge(vec2(-1.0,-1.0));\n\n    edge(vec2(0.0,2.0));\n    edge(vec2(0.0,-2.0));\n    edge(vec2(2.0,0.0));\n    edge(vec2(-2.0,0.0));\n    edge(vec2(2.0,-2.0));\n    edge(vec2(-2.0,2.0));\n    \n    \n//    vel.x = 0.0;\n    ballcollis();\n    \n    pos += vel;\n    vel.y += gravity; // gravity\n    \n    // apply air friction\n    \n    vec3 norm = findnormal(c);\n    vel -= norm * (dot(norm,vel-windvel)*0.05 );\n    \n    \n    if (iFrame==0 || c.y==0.0) // init\n    {\n        pos = vec3(fc.x*0.85,fc.y,fc.y*0.01);\n        vel = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    fragColor = vec4(fc.x>=SIZX ? vel : pos,0.0);\n    \n    if (fc.y>=SIZY)\n    {\n        mytime += 1.0/4.0/60.0;\n        fragColor = vec4(mytime);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}