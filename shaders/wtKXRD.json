{
    "Shader": {
        "info": {
            "date": "1582328155",
            "description": "Testing uint vs. uvec4 performance of [url]https://www.shadertoy.com/view/WttXWX[/url]\n1200x675 window,\n\nNtriple32(512,(x).r) : 29 fps  (1x hash)\nu4Ntriple32_{A,B} (512,x) : 20 fps  (4x hash)\nu4Ntriple32_C(512,x) : 18 fps  (4x hash)",
            "flags": 0,
            "hasliked": 0,
            "id": "wtKXRD",
            "likes": 6,
            "name": "Wellons triple32 hash - 1x vs 4x",
            "published": 3,
            "tags": [
                "performance",
                "hash"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 502
        },
        "renderpass": [
            {
                "code": "// testing 4x hash performance from https://www.shadertoy.com/view/WttXWX\n// --- triple32 from Chris Wellons https://nullprogram.com/blog/2018/07/31/\n\n        // --- choose one:\n  #define hashi(x)   Ntriple32(512,(x).r)\n//  #define hashi(x)   u4Ntriple32_A(512,x)\n//  #define hashi(x)   u4Ntriple32_B(512,x)\n//  #define hashi(x)   u4Ntriple32_C(512,x)\n\n  #define hash(x)  ( vec4( hashi(x) ) / vec4( 0xffffffffU ) )\n\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nuvec4 u4triple32(uvec4 x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nuint Ntriple32(int N, uint x) {\n    for (int i=0; i<N; i++) {\n        x = triple32(x);\n    }\n    return x;\n}\n\nuvec4 u4Ntriple32_A(int N, uvec4 x) {\n    for (int i=0; i<N; i++) {\n        x = u4triple32(x);\n    }\n    return x;\n}\n\nuvec4 u4Ntriple32_B(int N, uvec4 x) {\n    for (int i=0; i<N; i++) {\n        x.x = triple32(x.x);\n        x.y = triple32(x.y);\n        x.z = triple32(x.z);\n        x.w = triple32(x.w);\n    }\n    return x;\n}\n\nuvec4 u4Ntriple32_C(int N, uvec4 x) {\n    x.x = Ntriple32(N,x.x);\n    x.y = Ntriple32(N,x.y);\n    x.z = Ntriple32(N,x.z);\n    x.w = Ntriple32(N,x.w);\n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    uvec2 V = uvec2(U);\n    //float h = hash( V.x + hashi(V.y) ); // clean 2D hash\n    vec4 h = hash( uvec4(0,1,2,3)*1000000u + V.x + (V.y<<16) );  // 2D hash (should be ok too )\n    O = vec4( h );\n  //O = vec4( pow( h, 1./2.2) );        // sRGB conversion\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}