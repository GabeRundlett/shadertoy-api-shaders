{
    "Shader": {
        "info": {
            "date": "1602946172",
            "description": "Released at Assembly Online 2020\n\nhttps://www.pouet.net/prod.php?which=87088\nhttps://soundcloud.com/harppi/shroud-4kb-intro-soundtrack\n\nI hope someone finds this interesting/helpful as much of it has been thanks to others sharing their magic!",
            "flags": 96,
            "hasliked": 0,
            "id": "3sGyWw",
            "likes": 5,
            "name": "Shroud - 4k by Deliberate",
            "published": 3,
            "tags": [
                "4k",
                "volumetric",
                "fog",
                "monochrome",
                "ambient"
            ],
            "usePreview": 0,
            "username": "sndels",
            "viewed": 607
        },
        "renderpass": [
            {
                "code": "/*\n * Shroud - 4k intro by Deliberate\n * Assembly Online 2020\n * \n * code, graphics - sndels\n *          music - Harppi\n *\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 24147,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/harppi/shroud-4kb-intro-soundtrack"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// From iq\n// Not free of artifacts but usually good enough\nfloat SEED; // initialized in main\nfloat rnd() { return fract(sin(SEED++) * 43758.5453123); }\n\n// ---------------------------------- hg_sdf -----------------------------------\n// http://mercury.sexy/hg_sdf/\n\n// Utils\nfloat PI = 3.14159265;\n\n#define sat(x) clamp(x, 0., 1.)\n\nfloat sgn(float x) { return (x < 0.) ? -1. : 1.; }\n\n// Maximum/minumum elements of a vector\n\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\n\n// Geometry\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Space ops\n\nvoid pR(inout vec2 p, float a) { p = cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from\n// the origin.\nfloat pMirror(inout float p, float dist)\n{\n    float s = sgn(p);\n    p = abs(p) - dist;\n    return s;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n    float angle = 2. * PI / repetitions;\n    float a = atan(p.y, p.x) + angle / 2.;\n    float r = length(p);\n    float c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x\n    // direction (cell index would be e.g. -5 and 5 in the two halves of the\n    // cell):\n    if (abs(c) >= (repetitions / 2.))\n        c = abs(c);\n    return c;\n}\n\n// --------------------------------- GLOBALS ---------------------------------\n\n// Sync idea from KK (https://www.shadertoy.com/view/3ddGzn)\n// clang-format off\n// $000X Camera    - 1 global pan in, 2 diag outside, 4 diag inside, 8 scene pan in\n// $00X0 Light/Mat - 1 -Z, 2 inside diagonal, 4 mirror, 8 ending time hack\n// $0X00 Fade      - 0 black, 3 fade in, 5 fade out, 7 full color\n// $X000 Modifiers - 1 camera, 2 geometry0, 4 geometry1, 8 pre-ending time hack\n// clang-format on\n\n// clang-format off\nivec2 SCENES[] = ivec2[](\n    // Duration (beats), Control\n    ivec2(21,  0x0311),\n    ivec2(11,  0x0711),\n    ivec2(32,  0x0722),\n    ivec2(32,  0x0711),\n    ivec2(16,  0x0714),\n    ivec2(16,  0x1714),\n    ivec2(16,  0x2714),\n    ivec2(16,  0x3714),\n    ivec2(32,  0x6758),\n    ivec2(16,  0x6754),\n    ivec2(16,  0xE7F8),\n    ivec2(16,  0xE768),\n    ivec2(14,  0x47E2),\n    ivec2(1,   0x45E2),\n    ivec2(42, 0x0000)\n);\n// clang-format on\n\nfloat TIME_S;\nint SEQ_CODE;\nfloat SCENE_PROGRESS;\nfloat cb(int n) { return float((SEQ_CODE >> n) & 1); }\n\n// Marching\nfloat MIN_DIST = .001;\nfloat MAX_DIST = 256.;\nint MAX_STEPS = 256;\n\n// Light\nvec3 SPOT_O;\nvec3 SPOT_D;\nfloat SPOT_L = 200000.;\nfloat SPOT_CUTOFF_INNER;\nfloat SPOT_CUTOFF_OUTER;\nfloat SPOT_FALLOFF = 1.;\n\n// Fog\nfloat FOG_DENSITY = .1;\nint FOG_SAMPLES = 40;\nfloat FOG_ANISOTROPY;\nfloat FOG_DEPTH;\n\n// -------------------------------- GEOMETRY ---------------------------------\nfloat scene(vec3 p)\n{\n    vec3 rot =\n        vec3(2.140, 2.512, .753)\n      + cb(13) * vec3(8.22, 16.63, 1.5 + TIME_S * .138) // Anim 1\n      + cb(14) * vec3(0, .07, 0) * TIME_S               // Anim 2\n        ;\n\n    pModPolar(p.xy, 6.);\n    pMirror(p.y, 2.);\n    pMirror(p.x, 2.);\n    pMirror(p.z, 2.);\n    pMirror(p.x, 0.);\n    pMirror(p.y, 0.);\n    pR(p.xz, rot.x);\n    pR(p.yz, rot.y);\n    pR(p.xy, rot.z);\n    pMirror(p.y, 2.);\n    pMirror(p.x, 2.);\n    pMirror(p.z, 2.);\n    pModPolar(p.xy, 9.);\n    p -= vec3(1.634, .017, .510);\n    return fBox(p, vec3(.735, 1.446, .541));\n}\n\n// -------------------------------- MARCHING ---------------------------------\n\n// Naive sphere tracing\n// See https://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n// for details and potentially useful extensions\nfloat march(vec3 ro, vec3 rd, float tMax)\n{\n    float t = MIN_DIST;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float h = scene(ro + rd * t);\n        if (h < MIN_DIST || h > tMax)\n            break;\n        t += h;\n    }\n    if (t > tMax)\n        t = 1e38; // WebGL doesn't like the divide-by-zero INF-trick\n        // t = 1. / 0.; // INF\n    return t;\n}\n\n// From iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        scene(vec3(p + e.xyy)) - scene(vec3(p - e.xyy)),\n        scene(vec3(p + e.yxy)) - scene(vec3(p - e.yxy)),\n        scene(vec3(p + e.yyx)) - scene(vec3(p - e.yyx))));\n}\n\n// ---------------------------------- LIGHT ----------------------------------\n\n// Adapted from iq\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 p, vec3 l, float tMax, float k)\n{\n    float ret = 1.;\n    float ph = 1e20;\n    for (float t = 0.; t < tMax;) {\n        // Fudge around volume artifacts near small objects\n        float h = scene(p + l * t) + (rnd() - 0.4) / 10.;\n        if (h < .01)\n            return .0;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        ret = min(ret, k * d / max(0., t - y));\n        ph = y;\n        t += h;\n    }\n    return ret;\n}\n\nfloat evalSpot(vec3 p)\n{\n    vec3 l = SPOT_O - p;\n    float spot_dist = length(l);\n    l /= spot_dist;\n\n    // Check if we are occluded\n    float light_amount = shadow(p, l, spot_dist, 3.);\n\n    // Check if point is within cone\n    float theta = dot(l, -SPOT_D);\n    float L = 0.;\n    if (theta > SPOT_CUTOFF_INNER) {\n        // Do the radial attenuation\n        float epsilon = SPOT_CUTOFF_INNER - SPOT_CUTOFF_OUTER;\n        float i = sat(1. - (theta - SPOT_CUTOFF_OUTER) / epsilon);\n        L = SPOT_L * i / (spot_dist * spot_dist * SPOT_FALLOFF);\n    }\n\n    // Our volume absorbs light before it hits the sample location\n    // henyeyGreenstein is applied uniformly with the step_color-fudge\n    float transmittance = exp(-FOG_DENSITY * spot_dist);\n    // No dot(n, l) since we don't have a reference surface\n    return light_amount * transmittance * L;\n}\n\n// --------------------------------- VOLUME ----------------------------------\n\n// Hey look: a real phase function :D\n// http://www.pbr-book.org/3ed-2018/Volume_Scattering/Phase_Functions.html#\n// Enables anisotropic scattering on the forward/backward axis\n// (anisotropy range [-1,1])\n// Wide shots lean on forward scattering and closeups use more backward scattering.\nfloat henyeyGreenstein(vec3 l, vec3 v)\n{\n    float cos_theta = dot(l, -v);\n    return 1. / (PI * 4.) * (1. - FOG_ANISOTROPY * FOG_ANISOTROPY) /\n        pow(1. + FOG_ANISOTROPY * FOG_ANISOTROPY -\n                2. * FOG_ANISOTROPY * cos_theta,\n            3. / 2.);\n}\n\n// Volume rendering\n// Let's fudge around the real theory\n// http://www.pbr-book.org/3ed-2018/Volume_Scattering/Volume_Scattering_Processes.html#Out-ScatteringandAttenuation\nfloat volume(float t, vec3 ray_o, vec3 ray_d, float t_refl, vec3 refl_d)\n{\n    // Uniform sampling on depth range\n    float step_size = FOG_DEPTH / float(FOG_SAMPLES);\n    // Offset uniform samples to get better coverage\n    float frame_offset = step_size * rnd();\n    // Beer's law\n    // Transmittance is multiplicative so we can do this iteratively\n    float step_transmittance = exp(-FOG_DENSITY * step_size);\n    // This is not strictly correct when sampling a spotlight close to\n    // the scene but it's faster than evaluating per step\n\t// Idea sparked by loicvdb's cool gi path tracing\n\t// https://www.shadertoy.com/view/Wt3XRX\n    float step_color =\n        (1. - step_transmittance) * henyeyGreenstein(-SPOT_D, -ray_d);\n\n    float transmittance = 1.;\n    float I = 0.;\n    for (int i = 0; i < FOG_SAMPLES; ++i) {\n        float s = float(i) * step_size + frame_offset;\n        // Break on final hit\n        if (s > t && s - t > t_refl)\n            break;\n\n        // Check if we should sample on the reflection ray\n        vec3 p =\n            s > t ? (ray_o + ray_d * t) + refl_d * (s - t) : ray_o + ray_d * s;\n\n        transmittance *= step_transmittance;\n        I += step_color * transmittance * evalSpot(p);\n    }\n    return I;\n}\n\n// --------------------------------- SETUP ----------------------------------\n\nvoid initGlobals()\n{\n    // Sequencing, adapted from KK (https://www.shadertoy.com/view/3ddGzn)\n    int scene_i = 0;\n    TIME_S = iTime;\n    // Track is 140 bpm so time * 140 bpm / 60s gives bps\n    float scene_beats = TIME_S * 14. / 6.;\n    while (SCENES[scene_i].x < 255 && scene_beats >= float(SCENES[scene_i].x))\n        scene_beats -= float(SCENES[scene_i++].x);\n    SCENE_PROGRESS = sat(scene_beats / float(SCENES[scene_i].x));\n    SEQ_CODE = SCENES[scene_i].y;\n\n    // This is a dirty hack for scene time offsets\n    TIME_S -=\n        cb(15) * (scene_beats * .3 + .01)    // long flower diamond-thingy scene\n      - cb(7) * (1.2 - (TIME_S - 109.) / 2.) // ending scene\n        ;\n\n    // Globals animation\n    SPOT_O =\n        cb(4) * vec3(0, 0, 15)      // -Z\n      + cb(5) * vec3(1, -1, 1) / 2. // Inside\n        ;\n    SPOT_D = normalize(-SPOT_O);\n    SPOT_CUTOFF_INNER =\n        .96        // default\n      - cb(5) * 1. // Inside\n        ;\n    SPOT_CUTOFF_OUTER = 1.2;\n\n    FOG_DEPTH =\n        cb(4) * 30. // Light -Z\n      + cb(5) * 14. // Light inside\n      - cb(2) * 15. // Camera inside\n        ;\n    FOG_ANISOTROPY =\n        .7          // default\n      - cb(5) * 1.2 // Light inside\n        ;\n\n    // Can't remember where this is from, sorry about that :(\n    SEED = gl_FragCoord.y * gl_FragCoord.x / iResolution.x +\n           gl_FragCoord.y / iResolution.y + TIME_S;\n}\n\nvoid camRay(vec2 uv, inout vec3 ray_o, inout vec3 ray_d)\n{\n    ray_o =\n        cb(0) * vec3(0, 0, -22.5 + sin(TIME_S / 30.) * 12.) // Global z pan\n      + cb(1) * vec3(\n          vec2(-11., 4.) + vec2(2, 3) * mod(TIME_S, 100.) / 40.,\n          -6.)                                             // Close outside dutch\n      + cb(2) * vec3(-4.3, .4, -4.2 + SCENE_PROGRESS)      // Inside dutch\n      + cb(3) * vec3(0, 0, -40. + TIME_S / 4.)             // Scene z pan\n      + cb(12) * vec3(7.7 - SCENE_PROGRESS * 2., .75, -.7) // \"Modified camera\"\n        ;\n\n    uv -= .5;                                      // origin at center\n    uv /= vec2(iResolution.y / iResolution.x, 1.); // fix aspect ratio\n    ray_d = normalize(vec3(uv, .7));               // pull ray\n\n    vec3 camRot =\n        cb(2) * vec3(8. + SCENE_PROGRESS * 2., 1.7 + SCENE_PROGRESS, -4.)\n        / 10.                          // Inside dutch\n      + cb(12) * vec3(-1.2, -.52, .25) // \"Modified camera\"\n        ;\n    pR(ray_d.yz, camRot.y);\n    pR(ray_d.xz, camRot.x);\n    pR(ray_d.yx, camRot.z);\n}\n\nvoid tonemap(inout float color)\n{\n    // Rough ACES tonemap\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    color =\n        sat((color * (2.51 * color + .03)) /\n            (color * (2.43 * color + .59) + .14));\n\n    // The volume is noisy so let's do things grayscale and grain things up\n    // to lean on the whole \"artsy\" noir/vintage look\n    float brightness = max(color, .001);\n    float grain = sat(pow(rnd(), 8.) / 100.);\n    color = mix(sat(color - grain), sat(color + grain), exp(brightness));\n    grain = sat(pow(rnd(), 8.) * .15);\n    color -= grain * brightness;\n\n    // Gamma correction, of course\n    color = pow(color, .45);\n}\n\n// ---------------------------------- MAIN -----------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float color = 0.;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // \"21:9\" from 16:9\n    if (abs(uv.y - .5) < .38) {\n        initGlobals();\n\n        vec3 ray_o, ray_d;\n        camRay(uv, ray_o, ray_d);\n\n        // Trace them spheres\n        float t = march(ray_o, ray_d, MAX_DIST);\n\n        // Single bounce reflections\n        float t_refl = 0.;\n        // No need to init direction as volume won't read this when t_refl is 0\n        vec3 refl_d;\n        if (t < MAX_DIST) {\n            // Get hit parameters\n            vec3 p = ray_o + ray_d * t;\n            vec3 n = normal(p);\n\n            // Mirror scene check\n            if (cb(6) == 1.) {\n                refl_d = reflect(ray_d, n);\n                t_refl = march(p + n / 100., refl_d, MAX_DIST - t);\n            }\n        }\n\n        // Do the scattering, which is our only source of color as material is\n        // either super-duper black or a perfect mirror\n        color = volume(t, ray_o, ray_d, t_refl, refl_d);\n\n        // Tonemap before fade to get linear fade\n        tonemap(color);\n\n        // Fade in/out\n        color = mix(cb(10) * color, cb(9) * color, SCENE_PROGRESS);\n        // Black/color\n        color = cb(8) * color;\n    }\n\n    fragColor = vec4(vec3(color), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Ad-hoc \"AA\" kernel\n    // Looks kind of ok but this really is just a 2d hat function\n    fragColor = vec4(0);\n    for (int j = -1; j <= 1; ++j) {\n        for (int i = -1; i <= 1; ++i) {\n            // Clamp needed here since iChannel is f32 instead of u8\n            fragColor +=\n                max(texture(\n                    iChannel0, (fragCoord.xy + vec2(i, j)) /\n                                       iResolution.xy), vec4(0)) *\n                (4. - length(vec2(i, j)));\n        }\n    }\n    fragColor /= 28.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}