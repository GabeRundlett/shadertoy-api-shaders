{
    "Shader": {
        "info": {
            "date": "1520183089",
            "description": "Construct a Möbius transformation from a reflection and inversion. Shows construction and fixed points of transformation. The grid is the image of the square with -2 < x,y < 2.\n\nMouse changes transformation parameters, see code for key controls.",
            "flags": 16,
            "hasliked": 0,
            "id": "ldccWj",
            "likes": 34,
            "name": "Mobius Transformations",
            "published": 3,
            "tags": [
                "mobius",
                "transformation",
                "domaincoloring"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 5579
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2018 by Matthew Arcus\n//\n// Möbius transformations\n//\n// Construct a Möbius transformation from reflection in a line and\n// inversion in a circle.\n//\n// Domain coloring from https://www.shadertoy.com/view/MtjBzV by phi16\n//\n// Controls:\n//\n// Mouse x: select circle centre on x-axis\n// Mouse y: select angle of inclination of the mirror line\n// c: show construction line, circle and fixed points\n// i: toggle inversion\n// m: toggle reflection in mirror line\n// r: toggle time rotation\n// a: toggle alternative coloring\n// b: map fixed points to 0 and infinity\n//\n// Algebraically, a Möbius transformation is of the form z -> (az+b)/(cz+d)\n// but can also be constructed more geometrically as the composition of a\n// number of spherical inversions, including inversion in a sphere of\n// \"infinite\" radius, ie. reflection in a straight line - this\n// definition also generalizes well to higher dimensions.\n//\n// Here we construct a Möbius transformation from a reflection in a line\n// through the origin, and an inversion in a unit circle with its\n// centre on the x-axis. This seems sufficient to construct any Möbius\n// transformation that does not fix the point at infinity, up to\n// scaling, translation and rotation of the final image.\n//\n// Every Möbius transformation has two, possibly coincident, fixed\n// points. We show them here - if the circle and mirror line \n// intersect, then the fixed points are their points of intersection\n// (or if line is tangent to the circle, the single point of\n// tangency). If they do not intersect, the fixed points are on the\n// line through the circle centre perpendicular to the mirror.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float scale = 2.2;\nconst float grid = 4.0;\nconst float clip = 2.0;\nconst float width0 = 0.02, width1 = 0.015;\n\nconst float PI\t= 3.14159265359;\nconst float TWOPI = 2.0*PI;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\nvec2 cconj(vec2 z) {\n  return vec2(z.x,-z.y);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cconj(w))/dot(w,w);\n}\n\n// Invert p in circle, centre c, radius squared r2.\nvec2 invert(vec2 p, vec2 c, float r2) {\n    p -= c;\n    p *= r2/dot(p,p);\n    p += c;\n    return p;\n}\n\nbool keypress(int code) {\n#if __VERSION__ < 300\n    return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool showconstruction = !keypress(CHAR_C);\n    bool doinvert = !keypress(CHAR_I);\n    bool doreflect = !keypress(CHAR_M);\n    bool dorotate = !keypress(CHAR_R);\n    \n    vec2 z = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.0) {\n    \tmouse = (2.0*iMouse.xy-iResolution.xy) / iResolution.y;\n    } else {\n      mouse = vec2(cos(0.2*iTime),0.1*iTime);\n    }\n    z *= scale;\n    \n    vec2 z0 = z; // Remember untransformed point\n    \n    float r = 0.5*PI*mouse.y; // y-coord of mouse sets mirror angle\n    \n    vec2 c = vec2(scale*mouse.x,0); // x-coord of mouse sets circle centre\n    vec2 m = vec2(cos(r),sin(r));   // Normal to rotating line\n\n    // Compute the fixed points, this involves solving a\n    // quadratic, the fixed points are the (real or imaginary)\n    // solutions. For a parabolic transformation (circle and line\n    // are tangent), there is just one solution.\n      \n    // First, find the distance from the circle centre to the line\n    float s = dot(c,m);\n    // Now solve for circle centre 0, with mirror at x = -s\n    // Fixed point equation is z^2 - 2sz + 1 = 0\n    float d = s*s - 1.0;\n    float k = sqrt(abs(d));\n    vec2 w0,w1;\n    if (d >= 0.0) {\n      // Real solutions on y = 0\n      w0 = vec2(-s+k,0);\n      w1 = vec2(-s-k,0);\n    } else {\n      // Imaginary solutions on mirror line, x = -s\n      w0 = vec2(-s,k);\n      w1 = vec2(-s,-k);\n    }\n    // Move w0,w1 to correct frame of reference\n    w0 = rotate(w0,r)+c;\n    w1 = rotate(w1,r)+c;\n   \n    vec3 col;\n  \tif (doinvert) z = invert(z,c,1.0);\n    if (doreflect) z = reflect(z,m);\n\tif (keypress(CHAR_B)) z = cdiv(z-w0,z-w1);\n    if (!keypress(CHAR_A)) {\n        float t = 0.2*iTime;      // rotation, mainly for show\n    \tif (dorotate) z = rotate(z,t);\n    \t// Domain coloring is from https://www.shadertoy.com/view/MtjBzV\n    \tfloat arg = atan(z.y,z.x);\n    \tfloat len = length(z);\n    \tvec3 hue = cos(vec3(0,1,-1)*2.0/3.0*PI + arg) * 0.5 + 0.5;\n    \tfloat lum = 1.0;\n    \t// Only show grid for -2 <= x,y <= 2\n    \tif (abs(z.x) <= clip && abs(z.y) <= clip) {\n      \t\tlum *= pow(-cos(z.x * grid * TWOPI) * 0.5 + 0.502, 0.06);\n      \t\tlum *= pow(-cos(z.y * grid * TWOPI) * 0.5 + 0.502, 0.06);\n    \t}\n        col = lum*hue;\n    } else {\n\n        float t = 0.0;\n        if (dorotate) t = 8.0*iTime;\n    \tfloat arg = atan(z.y,z.x);\n\t    float len = length(z);\n    \tvec3 hue = cos(vec3(0,1,-1)*2.0/3.0*PI+arg+t/16.0) * 0.5 + 0.5;\n    \tfloat lum = 1.0;\n        float spiral = 10.0;\n#if 1\n    \tlum *= pow(-cos(spiral*(log(len) - arg)) * 0.5, 0.1);\n    \tlum *= pow(-cos(spiral*(log(len) + arg - 0.5*iTime)) * 0.5, 0.1);\n#else\n        // log here make coloring invert\n    \tlum *= pow(-cos(log(len)*16.0 + t) * 0.5 + 0.502, 0.06);\n    \tlum *= pow(-cos(arg*16.0 + t) * 0.5 + 0.502, 0.06);\n#endif\n        col = lum*hue;\n    }\n    if (showconstruction) {\n      // Now draw circle, mirror line and fixed points.\n      float t = abs(dot(z0,m));\n      t = min(t,abs(length(z0-c)-1.0));\n      t = min(t,max(abs(length(z0-w0)),width0)-width0);\n      t = min(t,max(abs(length(z0-w1)),width0)-width0);\n      // Uncomment next 2 lines to show images of 0 and 1.\n      //t = min(t,max(abs(length(z)),w0)-w0);\n      //t = min(t,max(abs(length(z-vec2(1,0))),w0)-w0);\n      float eps = width1; // 2.0*scale/iResolution.y;\n      col = mix(0.6+0.4*col,col, smoothstep(width1-eps,width1+eps,t));\n    }\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}