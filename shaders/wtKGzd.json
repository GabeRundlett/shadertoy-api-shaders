{
    "Shader": {
        "info": {
            "date": "1579660224",
            "description": "Raymarch simulation of one of those hologram toys with two parabolic mirrors.\nA ball bounces on a bright circle, but there may be more than meets the eye...\n---\nClick and drag to look inside and see the real ball\nClick again to reset view",
            "flags": 0,
            "hasliked": 0,
            "id": "wtKGzd",
            "likes": 2,
            "name": "Hologram Toy",
            "published": 3,
            "tags": [
                "raymarch",
                "mirror",
                "hologram",
                "paraboloid",
                "parabolic"
            ],
            "usePreview": 0,
            "username": "benburrill",
            "viewed": 584
        },
        "renderpass": [
            {
                "code": "/** Hologram Toy -- Ben Burrill\nRaymarch simulation of one of those hologram toys with two parabolic mirrors.\nA ball bounces on a bright circle, but there may be more than meets the eye...\n---\nClick and drag to look inside and see the real ball\nClick again to reset view\n\nI originally wrote this for glslViewer, which has a built-in stateful\ncamera.  On Shadertoy, the best I can do is fake a camera using the\niMouse uniform.  For this shader it's mostly fine, but it would be nice\nto port some of the other shaders I made to Shadertoy and some of those\nrely on the ability to zoom the camera in addition to moving it, and I\ncan't think of any way to finagle Shadertoy's uniforms into getting that\nto work.  If anyone knows of a better way to fake a camera on Shadertoy,\nI'd love to hear about it.\n*/\n\n// A thing in the scene\nstruct Thing {\n    float dist;\n    vec3 color;\n    float refl;  // How reflective the thing is\n};\n\nvoid addThing(inout Thing closest, Thing thing) {\n    if (thing.dist < closest.dist) closest = thing;\n}\n\nfloat paraboloid(vec3 p, float A, float B) {\n    /** Distance function for paraboloid y = A (x^2 + z^2) + B\n    This is an approximation.  I don't know how to get the true closest\n    distance to a paraboloid.  Using the vertical distance above the\n    paraboloid is super easy and works OK, but has some artifacts, so I\n    tried to get closer to true closest distance by making a triangle\n    with the vertical and radial distance.  This seems to converge a lot\n    better on the surface, but it's still not a true distance function.\n    */\n\n    // Shift y so paraboloid starts at origin\n    float y = p.y - B;\n    float r_sq = p.x * p.x + p.z * p.z;\n\n    // Vertical and radial distances\n    float ver = y - A * r_sq;\n    float rad = sqrt(max(y / A, 0.)) - sqrt(r_sq);\n\n    // Pretend it's a cone and find triangular altitude to surface.\n    // It still overshoots, but should be better than either ver or rad.\n    // Sign of vertical distance is ignored.  As a result, the sign of\n    // alt is positive when radially inside, not positive when y is\n    // above the paraboloid like ver is.  So making A negative doesn't\n    // turn the paraboloid inside out like it would if with ver's sign.\n    float alt = abs(ver) * rad / sqrt(ver * ver + rad * rad);\n\n    // When below the paraboloid, use vertical distance to bottom if it\n    // is farther than the altitude.\n    // Otherwise, there would be a line under the paraboloid where the\n    // distance is 0 because the radius of the paraboloid is non-real,\n    // so it is clamped to be 0.\n    return min(sign(A) * y, alt);\n}\n\nThing scene(vec3 p) {\n    float ry = 15.;\n    float y = -ry * .90;\n\n    float sr = 3.;\n    vec3 so = vec3(0., y-ry+sr + ry*(sin(iTime)+1.)/8., 0.);\n    Thing result = Thing(\n        distance(p, so) - sr,\n        // Striped ball coloring\n        (mod(floor(atan(p.z - so.z, p.x - so.x) * 5.), 2.) == 0.)?\n            vec3(1., 0.5, 0.) : vec3(0., 0.5, 0.),\n        0.\n    );\n\n    float foc = 2. * ry - sr;\n    float a = 1. / 4. / foc;\n    addThing(result, Thing(\n        max(p.y, min(paraboloid(p, a, y-ry), paraboloid(p, -a, y+ry))),\n        // Checkerboard pattern coloring\n        (mod(floor(p.x * 0.1) + floor(p.z * 0.1), 2.) == 0.)?\n            vec3(0., 0.2, 0.5) : vec3(0., 0., 0.5),\n        0.8\n    ));\n\n    return result;\n}\n\n// Derivative epsilon.  Seems like a good idea to separate this from the\n// raymarch's epsilon, even though currently they are the same...\n#define DEPS 0.001\nvec3 normal(vec3 p) {\n    /** Normal vector\n    This is pretty inefficient since it needlessly computes colors.\n    I don't really like it, but it works...\n    */\n\n    // The direction of the normal is given by the gradient of the\n    // distance function (direction where distance increases fastest).\n    return normalize(vec3(\n        scene(vec3(p.x + DEPS, p.yz)).dist - scene(vec3(p.x - DEPS, p.yz)).dist,\n        scene(vec3(p.x, p.y + DEPS, p.z)).dist - scene(vec3(p.x, p.y - DEPS, p.z)).dist,\n        scene(vec3(p.xy, p.z + DEPS)).dist - scene(vec3(p.xy, p.z - DEPS)).dist\n    ));\n}\n\n#define EPS 0.001\n#define STEPS 100\nvec3 raymarch(vec3 p, vec3 dir) {\n    float contrib = 1.;\n    vec3 color = vec3(0., 0., 0.);\n\n    for (int i = 0; i < STEPS; i++) {\n        Thing thing = scene(p);\n\n        if (abs(thing.dist) < EPS) {\n            vec3 n = normal(p);\n            vec3 light_dir = normalize(vec3(0., 1., 0.));\n\n            // Ambient lighting\n            color += contrib * (1. - thing.refl) * thing.color;\n\n            contrib *= thing.refl;\n\n            p -= 2. * EPS * dir; // back up a bit\n\n            // Reflection\n            dir -= 2. * dot(n, dir) * n;\n        }\n\n        p += thing.dist * dir;\n    }\n\n    return color;\n}\n\n#define PI 3.14159\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 sc = (fragCoord.xy/iResolution.x -\n               vec2(0.5, 0.5 * iResolution.y / iResolution.x));\n\n    vec2 drag = (iMouse.xy - abs(iMouse.zw)) / iResolution.y;\n    vec2 drag_ang = vec2(1., 0.7) + 0.5 * PI * drag;\n    drag_ang.y = drag_ang.y > 0.? drag_ang.y : 0.;\n    vec3 cam_pos = 50. * vec3(\n        cos(drag_ang.x) * cos(drag_ang.y),\n        sin(drag_ang.y),\n        sin(drag_ang.x) * cos(drag_ang.y)\n    );\n\n    // Allow camera to go upside down.  Is there a better way to do this?\n    vec3 up = drag_ang.y > 0.5 * PI? vec3(0., -1., 0.) : vec3(0., 1., 0.);\n    vec3 forward = normalize(vec3(0., 0., 0.) - cam_pos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    mat3 cam = mat3(right, up, forward);\n\n    fragColor = vec4(raymarch(\n        cam_pos, normalize(cam * vec3(sc, 1.0))\n    ), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}