{
    "Shader": {
        "info": {
            "date": "1642862167",
            "description": "Closest icosahedron vertices",
            "flags": 0,
            "hasliked": 0,
            "id": "fdXcDl",
            "likes": 21,
            "name": "Closest icosahedron vertices",
            "published": 3,
            "tags": [
                "icosahedron",
                "polyhedra"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "// Most of this is from https://www.shadertoy.com/view/ttycWW\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// iq https://www.shadertoy.com/view/4sXXRN\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Rotate on axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\nfloat boolSign(float v) {\n    return max(0., sign(v)) * 2. - 1.;\n}\n\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3                           v = vec3(PHI,1,0);\n    if (ap.x+ap.z*PHI > dot(ap,v)) v = vec3(1,0,PHI);\n    if (ap.z+ap.y*PHI > dot(ap,v)) v = vec3(0,PHI,1);\n    return v * 0.52573111 * boolSign(p);\n}\n\n// A vertex for the closest icosahedron face,\n// not necessary the closet vertex\n// from https://www.shadertoy.com/view/XtKSWc\nvec3 icosahedronVertexApprox(vec3 p) {\n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI, 1, 0);\n    vec3 plane = vec3(1, PHI, -PHI - 1.);\n    if (dot(ap, plane) < 0.) {\n        v = vec3(1, 0, PHI);\n    }\n    return v * 0.52573111 * boolSign(p);\n}\n\n// Closest dodecahedron vertex\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI);\n    vec3 v2 = vec3(0, 1, PHI + 1.);\n    vec3 v3 = v2.yzx;\n    vec3 v4 = v2.zxy;\n    if (dot(ap,v2) > dot(ap,v)) v = v2;\n    if (dot(ap,v3) > dot(ap,v)) v = v3;\n    if (dot(ap,v4) > dot(ap,v)) v = v4;\n    return v * 0.35682209 * boolSign(p);\n}\n\n// If you don't need the verts ordered closest to furthest\n#define ALLOW_ANY_ORDER\n\n// Closest icosahedron face center, and face verts\nvoid icosahedronFaceAndVerts(vec3 p, out vec3 face, out vec3 a, out vec3 b, out vec3 c) {\n    \n    #ifdef ALLOW_ANY_ORDER\n        vec3 iv = icosahedronVertexApprox(p);\n    #else\n        vec3 iv = icosahedronVertex(p);\n    #endif\n    \n    vec3 dv = dodecahedronVertex(p);\n    \n    float r = PI * 2. / 3.;\n    \n    #ifndef ALLOW_ANY_ORDER\n        float side = boolSign(dot(p, cross(iv, dv)));\n        r *= side;\n    #endif\n    \n    vec3 iv2 = erot(iv, dv, -r);\n    vec3 iv3 = erot(iv, dv, r);\n    \n    face = dv * 0.794654; // Inradius of a unit bounded icosahedron\n    a = iv;\n    b = iv2;\n    c = iv3;\n}\n\n\nvec4 opU(vec4 a, vec4 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    return b;\n}\n\nstruct Model {\n    float d;\n    vec3 col;\n};\n\nModel map(vec3 p) {\n    vec3 col = vec3(.1);\n    \n    vec4 res = vec4(1e12, 0, 0, 0);\n    \n    // All faces and verts\n    \n    vec3 iv = icosahedronVertex(p);\n    vec3 dv = dodecahedronVertex(p) * 0.794654;\n    res = opU(res, vec4(length(p - dv) - .05, vec3(.2)));\n    res = opU(res, vec4(length(p - iv) - .1, vec3(.2)));\n    \n    // Cursor\n    \n    float t = iTime;\n    vec3 p2 = vec3(sin(t), cos(t), sin(t * .5)) * 1.3;\n    res = opU(res, vec4(length(p - p2) - .05, vec3(1)));\n    \n    // Closest face and vert to cursor\n    \n    vec3 face, a, b, c;\n    icosahedronFaceAndVerts(p2, face, a, b, c);\n    res = opU(res, vec4(length(p - face) - .06, vec3(1,0,1)));\n    res = opU(res, vec4(length(p - a) - .11, vec3(1,0,0)));\n    res = opU(res, vec4(length(p - b) - .11, vec3(0,1,0)));\n    res = opU(res, vec4(length(p - c) - .11, vec3(0,0,1)));\n    res = opU(res, vec4(udTriangle(a, b, c, p) - .01, vec3(.3,.1,.3)));\n    \n    return Model(res.x, res.yzw);\n}\n\n/*\n// Stress test\nModel map(vec3 p) {\n    Model m = Model(1e12, vec3(0));\n    for (int i = 0; i < 1000; i++) {\n        Model m2 = map2(p);\n        if (m2.d < m.d) {\n            m = m2;\n        }\n    }\n    return m;\n}\n*/\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,5);\n    \n    vec2 im = iMouse.xy / iResolution.xy;\n    \n    if (iMouse.x <= 0.) {\n        im = vec2(.6,.3);\n    }\n    \n    pR(camPos.yz, (.5 - im.y) * PI / 2.);\n    pR(camPos.xz, (.5 - im.x) * PI * 2.5);\n    \n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0), vec3(0,1,0));\n    \n    float focalLength = 3.;\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, focalLength));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    Model model;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.014,.01,.02);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 100; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        model = map(rayPosition);\n        dist = model.d;\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 15.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        col = model.col;\n        vec3 nor = calcNormal(rayPosition);\n        col *= dot(vec3(0,1,0), nor) * .5 + .75;\n        float fog = 1. - exp((rayLength - 4.5) * -2.);\n        col = mix(col, bgcol, clamp(fog, 0., 1.));\n    }\n\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}