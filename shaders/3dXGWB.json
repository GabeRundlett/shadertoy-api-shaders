{
    "Shader": {
        "info": {
            "date": "1547301110",
            "description": "For once, I decided to use other people's talent to mix something together quickly:\n* Terrain raytracer by Fizzer: [url]https://www.shadertoy.com/view/XlcBRX[/url]\n* Fox model by pixelmannen: [url]https://opengameart.org/content/fox-and-shiba[/url]\n",
            "flags": 32,
            "hasliked": 0,
            "id": "3dXGWB",
            "likes": 131,
            "name": "Stop Motion Fox",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 6655
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2019\n\n// Terrain raytracer by Fizzer: https://www.shadertoy.com/view/XlcBRX\n// Fox model by pixelmannen: https://opengameart.org/content/fox-and-shiba\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    \n    // simple dof\n    const float focus = 1.5;\n\n    vec4 acc = vec4(0.0);\n    const int N = 4;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        vec4 tmp = texture( iChannel0, q + off/vec2(800.0,450.0) ); \n        float depth = tmp.w;\n        vec3  color = tmp.xyz;\n        float coc = 0.05 + 6.0*abs(depth-focus)/depth;\n        if( dot(off,off) < (coc*coc) )\n        {\n            float w = 1.0/(coc*coc); \n            acc += vec4(color*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz / acc.w;\n\n    // color greade\n    col = pow( col, vec3(0.8,0.95,1.0) ) - vec3(0.05,0.02,0.0);\n\n    // vignette\n    col *= 0.7+0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n\n    // contrast\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n\n    // noise\n    float fr = floor(iTime*24.0);\n    col *= 0.98+0.04*texture(iChannel1, q*0.5 + 0.6103398*vec2(fr*17.0,fr*131.0)).xyz;\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Simple procedural animation for the fox\n\nvec3 animate( vec3 v)\n{\n    float time = iTime+13.0;\n\ttime = floor(time*8.0)/8.0; // force 8 fps\n    \n    // breath\n    {\n      vec3 p = vec3(0.0,0.05,0.23);\n      float f = 1.0-smoothstep(0.0,0.16,length(p-v) );\n        \n      float b = 1.0 + 0.18*f*(0.5+0.5*sin(time*8.0));\n      v = p + (v-p)*b;  \n        \n    }\n\n    // tail\n    {\n        float k = v.z - (-0.18);\n        if( k<0.0 )\n        {\n\n        float bn = sin(time*0.11);\n        bn = bn*bn*bn;\n        float an = sin(time*2.0 + k*6.0 + bn*10.0 + 2.0);\n        an *= 0.5*k*an; an += 0.2;\n        float co = cos(an);\n        float si = sin(an);\n        vec2 p = vec2(0.0,-0.18);\n        v.xz = p + mat2(co,-si,si,co)*(v.xz-p);\n        }\n    }\n    \n    // head\n    {\n        float k = v.z - (+0.16);\n        if( k>0.0 )\n        {\n            \n        float an = sin(time*0.7*0.5);\n        an = an*an*an;\n        an = 1.5*k*an;\n        float co = cos(an);\n        float si = sin(an);\n        vec2 p = vec2(0.0,0.16);\n        v.xz = p + mat2(co,-si,si,co)*(v.xz-p);\n            \n\n        an = sin(time*0.5*0.5);\n        an = an*an*an;\n        an = -0.95*k*abs(an);\n        co = cos(an);\n        si = sin(an);\n        p = vec2(0.0,0.16);\n        v.yz = p + mat2(co,-si,si,co)*(v.yz-p);\n        }\n    }\n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // prepare to decode into a 64x64 texture\n    ivec2 p = ivec2(fragCoord-0.5);\n    int faceID   = (p.y/3)*64 + p.x;\n    int vertexID = p.y%3;\n    if( p.x>64 || faceID>=numFaces || vertexID>2 ) discard;\n\n    // decode\n    uint vid = getIndex(faceID,vertexID);\n    vec3 v = getVertex( vid );\n    \n    // animate\n    v = animate(v);\n    \n    // bake\n\tfragColor = vec4( v, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define AA 1 // make 2 if you have a fast computer\n\n// For once, I decided to use other people's talent to mix something together quickly:\n//\n// Terrain raytracer by Fizzer: https://www.shadertoy.com/view/XlcBRX\n// Fox model by pixelmannen: https://opengameart.org/content/fox-and-shiba\n\n\n\n\n// https://iquilezles.org/articles/intersectors\nbool boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 roo = ro - cen;\n    if( abs(roo.x)<rad.x && abs(roo.y)<rad.y && abs(roo.z)<rad.z ) return true;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\treturn ( tN < tF && tF > 0.0);\n}\n\n\n// https://iquilezles.org/articles/intersectors\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n//===========================================================================\n\nvec3 getVertex( int faceID, int vertexID )\n{\n    int row = faceID >> 6;\n    int col = faceID & 63;\n    return texelFetch( iChannel1, ivec2(col,row*3 + vertexID), 0 ).xyz;\n}\n\n// Brute force raytrace, no acceleration structure\n\n#define ZERO min(0,iFrame)\n\nbool intersectMesh( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, out vec2 oUV, out int oTri )\n{\n    ro.z += 0.5;\n    if( !boxIntersect( ro, rd, vec3(0.0), vec3(0.18,0.3,0.52) ) )\n        return false;\n        \n    bool res = false;\n    float tmin = tmax;\n    for( int i=ZERO; i<numFaces; i++ )\n    {\n\t\t// get the triangle\n        vec3 v0 = getVertex(i,0);\n        vec3 v1 = getVertex(i,1);\n        vec3 v2 = getVertex(i,2);\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x>0.0 && h.x<tmin)\n        {\n            tmin = h.x;\n            oNor = normalize(cross(v1-v0,v2-v0));;\n            oDis = tmin;\n            oUV = h.yz;\n            oTri = i;\n            res = true;\n        }\n    }\n    \n    return res;\n}\n\nbool intersectShadowMesh( in vec3 ro, in vec3 rd )\n{\n    ro.z += 0.5;\n    if( !boxIntersect( ro, rd, vec3(0.0), vec3(0.18,0.3,0.52) ) )\n        return false;\n\n    bool res = false;\n    for( int i=ZERO; i<numFaces; i++ )\n    {\n\t\t// get the triangle\n        vec3 v0 = getVertex(i,0);\n        vec3 v1 = getVertex(i,1);\n        vec3 v2 = getVertex(i,2);\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x>0.0 )\n        {\n            res = true;\n            break;\n        }\n    }\n    \n    return res;\n}\n\n\nfloat hash1( float n ) { return fract(sin(n)*158.5453123); }\n\n//===========================================================================\n\n// Terrain tracer, marches one triangle at a time, by Fizzer\nconst float minh = -2.3;\nconst float maxh = 2.23;\n\nfloat height(vec2 p)\n{\n    float f = 0.5+0.5*sin(0.3*p.x)*sin(0.3*p.y);\n    f *= mix(0.1,1.0,smoothstep(-1.0,0.0,-p.y+0.5*sin(p.x)) + smoothstep(4.0,8.0,p.y) );\n\tf = 0.95*f + 0.05*hash1( dot(p,vec2(1.0,111.1)));\n    return mix(minh, maxh, f );\n}\n\n// by Fizzer: https://www.shadertoy.com/view/XlcBRX\nvec3 intersectTerrain(vec3 o,vec3 r, out vec3 nn, out int tid)\n{\n    // Start ray at upper Y bounds\n    //if(o.y > maxh) o += r * (maxh - o.y) / r.y;\n    \n    vec2 oc = vec2(floor(o.x), floor(o.z)), c;\n    vec2 dn = normalize(vec2(-1, 1));\n    vec3 ta, tb, tc;\n\n    // Initialise the triangle vertices\n    ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\n    tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\n    if(fract(o.z) < fract(o.x))\n        tb = vec3(oc.x + 1., height(oc + vec2(1, 0)), oc.y + 0.);\n    else\n        tb = vec3(oc.x, height(oc + vec2(0, 1)), oc.y + 1.);\n\n    float t0 = 1e-4, t1;\n\n    // Ray slopes\n    vec2 dd = vec2(1) / r.xz;\n    float dnt = 1.0 / dot(r.xz, dn);\n    \n    float s = max(sign(dnt), 0.);\n    c = ((oc + max(sign(r.xz), 0.)) - o.xz) * dd;\n\n    vec3 rs = sign(r);\n\n    for(int i=ZERO; i<450; i++)\n    {  \n        t1 = min(c.x, c.y);\n\n        // Test ray against diagonal plane\n        float dt = dot(oc - o.xz, dn) * dnt;\n        if(dt > t0 && dt < t1)\n            t1 = dt;\n \n        // Test ray against triangle plane\n        vec3 hn = cross(ta - tb, tc - tb);\n        float hh = dot(ta - o, hn) / dot(r, hn);\n\n        if(hh > t0 && hh < t1)\n        {\n            // Intersection with triangle has been found\n            nn = hn;\n            \n            float s = sign(nn.y);\n            nn *= s;\n            \n            tid = int( dot(oc.xy+s,vec2(113,31)) );\n            return o + r * hh;\n        }\n\n        vec2 offset;\n        \n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\n        // and 0.0 for the far one\n        vec2 ss = step(c, c.yx);\n\n        // Get the coordinate offset of where to read the next vertex height from\n        if(dt >= t0 && dt < c.x && dt < c.y)\n        {\n            offset = vec2(1. - s, s);\n        }\n        else\n        {\n            offset = dot(r.xz, ss) > 0. ? vec2(2, 1) : vec2(-1, 0);\n\n            if(c.y < c.x)\n                offset = offset.yx;\n        }\n\n        // Get the next vertex\n        vec3 tnew = vec3(oc + offset, height(oc + offset)).xzy;\n\n        // Update the triangle vertices.\n        if(dt >= t0 && dt < c.x && dt < c.y)\n        {\n            tb = tnew;\n        }\n        else\n        {\n            // Swap vertex order based on sign of ray axis\n            if(dot(r.xz, ss) > 0.)\n            {\n                ta = tb;\n                tb = tc;\n                tc = tnew;\n            }\n            else\n            {\n                tc = tb;\n                tb = ta;\n                ta = tnew;\n            }\n\n            // Step the grid coordinates along to the next cell\n            oc.xy += rs.xz * ss;\n            c.xy += dd.xy * rs.xz * ss;\n        }\n\n        t0 = t1;\n\n        // Test if the ray left the upper Y bounds\n        if(((maxh - o.y) / r.y < t0 && r.y > 0.) || t0 > 200.)\n            break;\n    }\n    tid = -1;\n    return vec3(10000);\n}\n\n//=====================================================\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    float tottmin = 1e10;\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // camera\n        float an = -0.07*(iTime-10.0) - 0.375;\n        vec3 ro = vec3(1.5*sin(an),0.2,1.5*cos(an)-0.3);\n        vec3 ta = vec3(0.2*cos(an),0.0,.2*sin(an)-0.3);\n        vec3 of = sin(iTime+vec3(0.0,2.0,4.0));\n        ro += 0.005*of*of*of;\n        ta += 0.005*of*of*of;\n        \n        // ray\n        mat3 ca = setCamera( ro, ta, -0.05);\n        vec3 rd = normalize( ca * vec3(p,-4.0) );\n\n        // sky\n\t\tvec3 lig = normalize( vec3( 0.4,0.3,0.3) );\n        vec3 col = vec3(0.5,0.7,1.5)*1.25 - rd.y*0.6;\n        col += 6.0*vec3(3.0,1.2,0.4)*pow(clamp(dot(rd,lig),0.0,1.0),24.0);\n\n        float tmin = 1e10;\n    \n        vec3 mate = vec3(-1.0);\n        vec3 nor = vec3(0.0);\n        float occ = 1.0;\n        \n        // fox\n\t\t{\n            float t;\n            vec3 tnor;\n            vec2 uv;\n            int ttri;\n            if( intersectMesh( ro, rd, tmin, t, tnor, uv, ttri ) )\n            {\n                nor = tnor;\n                tmin = t;\n                mate = vec3(0.2,0.2,0.2);\n                mate = 0.35*vec3(0.36,0.13,0.028);\n                \n                if( ttri<126) mate = vec3(0.17);\n\t\t\t\tif( ttri>419) mate = 0.1*vec3(0.087, 0.040, 0.013);\n\n                mate *= 0.7+0.6*texture(iChannel0,uv*0.1).x;\n                #if 0\n                mate *= 0.4 + 0.6*smoothstep( 0.0, 0.05, uv.x ) * \n                                  smoothstep( 0.0, 0.05, uv.y ) * \n                                  smoothstep( 0.0, 0.05, (1.0-uv.x-uv.y) );\n                #endif\n                mate *= 0.8;\n                \n                mate *= 0.8+0.4*hash1(float(ttri));\n                \n                occ = 0.5 + 0.5*nor.y;\n            }\n        }\n        \n        {\n        // terrain\n        vec3 tnor;\n        int tid = -1;\n        vec3 pos = intersectTerrain(ro*0.5,rd, tnor, tid)/0.5;\n\t\tfloat t = length(pos-ro);\n        if( t>0.0 && t<tmin)\n        {\n            nor = normalize(tnor);\n            tmin = t;\n            vec3 pos = ro + t*rd;\n            mate = 0.14*vec3(0.8,0.9,1.0);\n            mate = mix( mate, vec3(0.025,0.02,0.015)*0.6, 1.0-smoothstep(0.9,1.0,nor.y) );\n            \n            mate *= 0.75+0.5*hash1(float(tid));\n            mate *= 0.5+texture(iChannel0,pos.xz).x;\n            \n            occ *= 0.15 + 0.85*smoothstep( 0.0, 0.35, length((pos.xz-vec2(0.0,-0.46))*vec2(1.0,0.5)) );\n        }\n        }\n\n        // shading\n        if( mate.x>-0.5  )\n        {\n            vec3 pos = ro + tmin*rd;\n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            float bou = clamp(0.3 - 0.7*nor.y,0.0,1.0);\n            float dif = clamp(dot(nor,lig ),  0.0,1.0);\n            \n            if( dif>0.001 )\n            if( length(pos.xz-vec2(-0.4,-0.4))<0.9 )\n            if( intersectShadowMesh( pos+nor*0.001, lig ) )\n                dif = 0.0;\n\n            // perform lighting/shading\n            vec3 brdf = 5.0*vec3(0.15,0.50,1.30)*occ + \n                        2.0*vec3(7.00,4.00,2.00)*dif +\n                \t\t1.0*vec3(0.60,0.65,0.70)*bou+\n                        1.0*fre*(0.5+0.5*occ);\n\n            col =  brdf * mate;\n\n            // fog\n            col = mix( col, vec3(0.7,0.9,1.5), 1.0-exp(-0.009*tmin) );\n            \n            // sun\n            col += 1.2*vec3(3.0,1.0,0.4)*pow(clamp(dot(rd,lig),0.0,1.0),16.0);\n            \n        }\n        #if AA>1\n\t\ttottmin = min(tottmin,tmin);\n        #else\n        tottmin = tmin;\n        #endif\n    \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    \n\tfragColor = vec4( tot, tottmin );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Fox model by pixelmannen: https://opengameart.org/content/fox-and-shiba\n//\n// NOT optimized for size but for speed and GLSL compilation. Otherwise, \n// this model could fit in a few hundred bytes really\n\nconst int numVertices = 290;\nconst int numFaces = 576;\n\nconst uint vertices[290] = uint[](\n 474194016U,  456372306U,  352611409U, 1003915346U,  997632126U, 1028056178U, 1012359285U, 1022864486U,\n1063764050U, 1051144299U, 1067953244U,  969343123U,  952500360U,  927354003U,  785584243U,  781389931U,\n 774033519U,  921167985U,  925333648U,  881367204U, 1044830290U, 1073188946U,  968207442U,  373581952U,\n 378821737U,  518232191U,  563316854U,  564356178U,  554918994U,  517177432U,  517177426U,  397597808U,\n 764610662U,  740491357U,  743613546U,   96613484U,   96606290U,    1245285U,   89298044U,  175384658U,\n  79914097U,    5465187U,  563317884U,  562283660U,  709059699U,  823379026U,  800305248U,  819190910U,\n 877969536U,  875891851U,  517180522U,  738414674U,  351569006U,    7574610U,     191570U,  474193989U,\n 880049234U, 1028056114U,  997632038U, 1012359215U, 1022864447U, 1051144250U, 1067953224U,  969342993U,\n 952500252U,  927353873U,  785584177U,  775078965U,  781389881U,  921167923U,  881367040U,  925333524U,\n 373581860U,  378821691U,  563316783U,  518232102U,  517177420U,  397597749U,  764610622U,  742566971U,\n 743637063U,   96613433U,    1245247U,   89297960U,    5465153U,   79914035U,  563317800U,  709059633U,\n 562283545U,  819189798U,  800305220U,  877969444U,  875891738U,  517180474U,  351568949U,  518251537U,\n 518250643U,  327376978U,  320046201U,  562288788U,  706982036U,  529968210U,  554084434U,  555106425U,\n 467011731U,  373674127U,  373624984U,  351600768U,  462755997U,  723707023U,  786839700U,  786881618U,\n 851924050U,  781551771U,  855036037U,  888589462U,  859273329U,  851940434U,  915932242U,  989311074U,\n 996652114U,  874857619U,  507730063U,  207761533U,  687205523U,  687247442U,  741788754U,  456565842U,\n 373704786U,  351650897U,  448997534U,  515069056U,  396551310U,  381872256U,  370278535U,  373422219U,\n 366061706U,  369207409U,  398579827U,  388097136U,  368183419U,  363992192U,  355579008U,  382856303U,\n 376566897U,  422716549U,  741538966U,  737264781U,  722664559U,  730978425U,  813981713U,  780341269U,\n 796070948U,  303384658U,  347428982U,  292862076U,  202548362U,  305407108U,  351600675U,  347428909U,\n 292861992U,  305407008U,  188987525U,  207754322U,  184813687U,  862336152U,  796071040U,  560236698U,\n 736498836U,  556137619U,  767726734U,  320046123U,  706981904U,  562288657U,  467011601U,  555106347U,\n 736458761U,  734256144U,  781551625U,  373674005U,  373624844U,  462755847U,  725807125U,  786839568U,\n 855035935U,  888589326U,  859273268U,  813981843U,  989311042U,  874857489U,  507729941U,  207761448U,\n 687205393U,  448997382U,  515068964U,  397599767U,  381872165U,  370278429U,  366061594U,  374470681U,\n 398579762U,  368183337U,  355578916U,  363992100U,  382856245U,  369207347U,  376566835U,  422716447U,\n 388097076U,  710014999U,  743635982U,  705827884U,  726861877U,  188987423U,  202548250U,  184813613U,\n 862336012U,  560236555U,  736498705U,  556137489U,  763526166U,  558185480U,  691365896U,  558185629U,\n 691366044U,  780341392U,  786609188U,  786613376U,  734256276U,  736458908U,  383898646U,  383898766U,\n 403811460U,  399539312U,  392218767U,  396364927U,  405822607U,  402699380U,  441454711U,  413141103U,\n 413141135U,  441454726U,  408990847U,  735105158U,  742427768U,  743560303U,  770818184U,  780255360U,\n 773890175U,  770819193U,  763480176U,  752921712U,  747753581U,  764527756U,  791682165U,  748685428U,\n 749735053U,  790633610U,  747671692U,  759212170U,  804262017U,  403811360U,  399539253U,  392218645U,\n 396364837U,  405822485U,  402699313U,  441454638U,  413141045U,  413141013U,  441454622U,  408990757U,\n 677453854U,  716306485U,  675338285U,  738309148U,  705737765U,  746693668U,  738311211U,  688972852U,\n 733071412U,  720498744U,  693162011U,  733070360U,  706748464U,  665867313U,  705699867U,  666916888U,\n 680580120U,  716177443U );\n\nconst uint faces[576] = uint[](\n  524800U,  1312771U,  2100742U,  2624521U,  1578500U,  2890252U,  4201998U,  4989969U,\n 2361876U,  5509652U,   792598U,   536599U,  7091225U,  7353881U,  7879168U,   277504U,\n 8138752U,  8929824U,  9717795U,  9717286U, 10768423U,  9718824U, 11556394U,   524312U,\n12344365U,  1054723U,  1312276U,  2100234U,  1575433U,  2626069U,  1574917U, 12869168U,\n 2889732U, 13121561U, 12084781U,   536116U,  6566954U,  7616562U,  8412175U, 10767925U,\n14174245U,  9719849U, 10775094U, 10775589U,   263223U, 14704687U, 11825199U, 15233539U,\n15732795U, 15498301U, 16545338U, 17071680U, 17860162U, 18648133U, 14973460U, 16001556U,\n16778774U, 19137608U, 19412508U, 19698716U, 19938305U, 14456833U, 19175991U, 21012046U,\n 9479249U, 21275731U, 22325287U, 21800021U, 23113302U, 14419017U, 23638573U, 16806915U,\n  815636U, 15470654U, 14972477U, 16022549U, 15234617U, 23378011U, 16809530U,  7387723U,\n13415469U, 18875486U, 19437142U, 19951197U, 23632964U, 10266677U,  9464914U, 22324308U,\n13936694U, 14198866U, 14703193U, 23883865U, 12327951U, 12082703U,  4211744U,  3940384U,\n23376964U, 17347140U, 12075041U, 13392929U, 23619152U, 20493392U, 17598542U, 20743758U,\n19709528U, 22582872U,  7115827U, 22832714U, 22589002U,  6575147U, 25178667U,  6829619U,\n11555866U, 13391898U,  7617564U,  7903260U, 19970588U,  7627776U, 16823900U, 17072220U,\n 5795931U, 16788571U,  3152433U, 12589105U,  5773360U, 14691376U, 25429044U, 25454690U,\n25974316U, 26265132U, 27053157U, 27315813U, 28103785U, 27842664U, 13643370U, 28624940U,\n29417070U, 29940849U, 30467187U,  4777485U, 30993012U, 30728306U,  1582091U,  5040243U,\n31203858U,  2158599U,  1895942U,  3469873U,  5039634U,  4989556U, 25716843U, 32030828U,\n32293474U, 31255569U, 33094268U, 27578495U, 33870464U, 34134122U, 34353760U, 34657303U,\n34876952U, 35720838U, 36508809U, 36201603U, 37296780U, 35987599U, 38078074U, 38073474U,\n35987083U, 38610029U, 39135266U, 39660633U, 39923289U, 38819891U, 39115412U, 40711321U,\n41236578U, 42024606U, 42287262U, 10041506U,  9520763U,  9238172U, 10568868U, 10569767U,\n13120131U, 33345637U, 28103322U, 40424065U, 27840617U, 29162606U, 13685867U, 29416562U,\n29942437U, 28596372U,  4725259U, 30729332U, 31517815U, 31204358U, 31518215U, 38324333U,\n 3694246U, 26300003U, 40436377U, 32036994U, 32294044U, 30992401U, 33093800U, 27590272U,\n34133124U, 27349607U, 34390138U, 34614917U, 34877471U, 36463754U, 38823457U, 44639379U,\n42545828U, 42779259U, 43069991U, 40710818U, 10044456U,  9500195U,  9254950U,   574046U,\n24691371U, 23157420U, 22851756U, 26828462U, 26528942U, 39412400U, 46738608U, 47266995U,\n47540398U, 18922676U, 45182039U, 29155511U, 48066738U, 48329913U, 31804017U, 49082993U,\n48533057U, 30731450U, 29420216U, 18642495U, 48794809U, 18184263U, 31461436U, 49313851U,\n49578588U, 48532551U, 18123962U, 24729246U, 25001141U, 25525931U, 31029317U, 32832704U,\n45704831U, 46989952U, 47547060U, 19760223U, 47285832U, 18974793U, 52268229U, 24481986U,\n53318857U, 54106828U, 50962110U, 49913537U, 53582544U, 55157430U, 55682639U, 22915123U,\n47818452U, 42052249U, 44936353U, 42547357U, 40715421U, 56141525U, 42748095U, 50111190U,\n55880407U, 56404519U, 19708610U, 45678181U, 47004831U, 47005313U, 45705395U, 33087159U,\n47234206U, 48029880U, 56714424U, 22899924U, 17075775U, 48294586U, 30994620U, 18708539U,\n49344572U, 45196470U, 23364760U, 56973485U, 33898137U, 47545537U, 44924630U, 48819269U,\n57245822U, 33384064U, 47284931U, 57498799U, 25003198U, 18974404U, 19236941U, 54631112U,\n20997844U, 55163089U, 40217303U, 25511615U, 40218151U, 55918753U, 56208033U, 55879253U,\n50088017U, 56140371U, 13178511U,    25743U, 58046144U, 58309312U, 58543716U, 58834532U,\n46507180U, 56998622U, 45200094U, 58572924U, 44416636U, 59067439U, 49136175U, 39696594U,\n59322434U, 17679426U, 59514894U, 43632142U, 44680870U, 59069606U, 57749144U, 59357336U,\n38814242U, 21080143U, 44679826U, 59843809U, 49137889U, 49079013U, 59864805U, 58771684U,\n60145892U, 58837672U, 32620712U, 46751962U, 48063706U, 55141014U, 39691414U, 38389860U,\n58294490U, 46251226U, 57212087U, 33116270U, 29678760U, 60089000U, 45202608U, 46487728U,\n 8198285U, 34881165U,    73360U,  8126608U, 34933895U, 34671239U, 51480263U, 51742919U,\n20285643U, 52730571U, 50711747U, 60621956U, 24407756U, 54573772U, 14457550U, 53505742U,\n54628445U, 40712811U, 40449643U, 42021535U, 44909214U, 41206891U, 45927549U, 26791549U,\n32820905U, 32570025U, 28425897U, 27318441U, 25216679U, 28360871U, 43892332U, 11322976U,\n58045109U, 32866523U, 45939419U, 47537371U, 58026715U, 45396063U, 24996569U, 45399769U,\n49622194U, 56720050U,  3466917U, 31726245U, 12345977U, 49045113U, 23407805U, 24163005U,\n17136344U, 48530136U, 29969011U, 56717497U, 60891879U, 61149834U, 61460711U, 61986027U,\n61676681U, 62199016U, 61460104U, 61411470U, 62771950U, 63037166U, 63035627U, 63296748U,\n63300842U, 62511858U, 63776405U, 64350357U, 65138422U, 65926393U, 65927418U, 66409619U,\n66975486U, 67502335U, 66971899U, 67241204U, 68284675U, 66713336U, 67503874U, 35195533U,\n36243089U, 36716176U, 36250344U, 38077671U, 61150445U, 63557866U, 61674217U, 62247154U,\n61414635U, 61723375U, 63036657U, 62775531U, 63297776U, 61201134U, 62514417U, 38591125U,\n67708659U, 64242940U, 64574717U, 65390327U, 63777524U, 67970818U, 67503360U, 67757812U,\n68288254U, 67501828U, 67234047U, 68290305U, 66711812U, 54397670U, 53873864U, 68554470U,\n69079816U, 53088461U, 52565253U, 60427974U, 52039370U, 68819211U, 70392587U, 69606152U,\n69082377U, 71179527U, 69867279U, 54927571U, 55452945U, 72755475U, 73543446U, 73805592U,\n74331345U, 73284380U, 75382045U, 71973655U, 75644690U, 72499994U, 73283860U, 74071328U,\n51481291U, 50958543U, 20288206U, 54366469U, 50700006U, 52563210U, 68558599U, 53874950U,\n68556047U, 53088008U, 68817164U, 70130446U, 70654216U, 69606669U, 69864715U, 71177998U,\n47817427U, 54935824U, 20849433U, 57812763U, 59387157U, 55451922U, 54932768U, 75644191U,\n71450898U, 74859292U, 74857761U, 71974685U, 74072862U, 72497441U, 68022518U, 66455286U,\n73282321U, 71970577U, 72493846U, 73279766U, 44690679U, 59593975U, 65140473U, 64876793U,\n65923317U, 66189045U, 59279128U, 72992024U, 17604377U, 73434905U, 59634426U,  4310778U,\n 4322556U,  8921340U, 57787669U, 72202517U, 74069779U, 72496403U, 66397955U, 64301602U,\n55452239U, 74293980U, 53845193U, 53058249U, 35986572U, 37819020U, 37294214U, 37035142U,\n53057221U, 52008133U, 51236039U, 52284614U, 60622983U, 60624520U,  5509130U,  2107966U );\n\nuint getIndex( int faceID, int vertexID )\n{\n    return (faces[faceID] >> (9*vertexID) ) & 511U;\n}\n\nvec3 getVertex( uint id )\n{\n    uint d = vertices[id];\n    vec3 v = vec3(ivec3(d,d>>10,d>>20)&1023) / 1023.0;\n    return v + vec3(-0.0803029,-0.26890646,-0.5770213127);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}