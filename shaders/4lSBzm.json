{
    "Shader": {
        "info": {
            "date": "1515157386",
            "description": "Mapping a square Truchet pattern onto an overlapping, interwoven hexagonal Truchet object.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lSBzm",
            "likes": 152,
            "name": "Weaved 3D Truchet",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "truchet",
                "bump",
                "weave"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 4096
        },
        "renderpass": [
            {
                "code": "/*\n\tWeaved 3D Truchet\n\t-----------------\n\t\n\tMapping a square Truchet pattern onto an overlapping, interwoven hexagonal Truchet object... \n\tor if you prefer a more lively description, it's an abstract representation of pythons. :) \n\tI can thank BigWIngs's \"Hexagonal Truchet Weaving\" example for the idea to do this.\n\n\tI produced a relatively simple scene, just to give people an idea, but it's possible to\n\tcreate some really cool organic structures this way.\n\n\tCoding the main object wasn't particularly difficult, but bump mapping the square Truchet\n\tpattern onto it was a little tiresome. I originally applied the pattern directly to the \n\tobject via the distance field equation, but I don't think slower machines would have\n\tenjoyed running it. Therefore, I took the surface pattern outside the raymarching loop and \n\tbump mapped it.\tThat, of course, added to the complexity, but sped things up considerably. \n\tMy fast machine\tcan run it in fullscreen fine, but the example was targetted toward the \n\t800 by 450 canvas -- which I'm hoping average systems will be able to run it in.\n \n\tProcedurally speaking, this is just a 3D application of a standard hexagonal weave, which \n\tI explained in my \"Arbitrary Weave\" example. For anyone interested in producing one, I'd \n\tsuggest starting with a 2D pattern, then taking it from there. Feel free to use this as a \n\tguide, but I doubt it'll be needed.\n\n\tThe comments, code and logic were a little rushed, so I'll get in and tidy it up in due \n\tcourse.\n\n\n\t2D Weaved Truchet examples:\n\n\t// The original: Much less code, so if you're trying to get a handle on how to make\n\t// a random hexagonal weave pattern, this is the one you should be looking at.\n\tBigWIngs - Hexagonal Truchet Weaving \n\thttps://www.shadertoy.com/view/llByzz\n\n\t// My version of BigWIngs's example above. The code in this particular example was\n\t// based on it.\n\tArbitrary Weave - Shane\n\thttps://www.shadertoy.com/view/MtlBDs\n\n\n*/\n\n#define FAR 15.\n\n// Just a regular hexagonal Truchet tile consisting of three small arcs.\n//#define NO_WEAVE\n\n// A geometric hack to show the hexagonal grid.\n//#define SHOW_GRID\n\nfloat objID = 0.; // Object ID - Ground: 0; Truchet: 1.\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0);\n    \n    //return vec2(sin(z * 0.15)*1.2, cos(z * 0.25)*.85); \n    \n    return vec2(sin(z * 0.15)*2.4, 0);\n}\n\n// Standard float to float hash -- Based on IQ's original.\nfloat hash(float n){ return fract(sin(n)*43758.5453); }\n\n\n// Standard vec2 to float hash -- Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.187, 289.973)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n); \n    \n    /*\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime )*.5 + .5; \n\t*/\n    \n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + vec4(.5, .5, 1, 1.5);\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + vec2(0, -.5))*s );\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw);\n    \n}\n\n\n// Very basic square Truchet routine.\nfloat sTruchet(vec2 p){\n    \n    // Unique coordinate.\n    vec2 ip = floor(p);\n    \n    float rnd = hash21(ip); // Random ID.\n\n    // Square grid. Equivalent to: p = fract(p) - .5;\n    p -= ip + .5;\n    \n    // Random tile flipping.\n    p.y *= (rnd >.5)? -1. : 1.;\n    \n    // Repeat space trick - to save rendering two arcs.\n    // I explained it in detail in my \"Square Truchet Flow\" example.\n    p = p.x>-p.y ? p : -p; \n    \n\n    // Arc(s) of thickness \".15.\"\n    float d = abs(length(p - .5) - .5) - .15;\n    \n    // Shaping it to suit individual needs.\n    return mix(max(-d, 0.)*.35, smoothstep(0., .125, d), .5);\n    \n}\n\n\n// Poloidal distance function -- The cross section of the torus. It can be cylindrical,\n// square, hexagonal, octagonal, etc. To save calculations, some of these are distance\n// bounds, rather than proper fields, so they can potentially interfere with things like \n// shadows, and so forth.\nfloat polDist(vec2 p){\n\n    return length(p);\n    \n    /*\n    // Square cross section.\n    p = abs(p);\n    return max(p.x, p.y);\n\t*/\n    \n    /*\n    // Hexagonal cross section.\n    //p = abs(p);\n    //return max(p.x*.8660254 + p.y*.5, p.y);\n\t*/\n\n    /*\n    // Octagonal cross section.\n    p = abs(p);\n    return max(max(p.x, p.y), (p.x + p.y)*.7071);\n    */\n    \n    /*\n    // Dodecahedral cross section.\n    p = abs(p);\n    vec2 p2 = p.xy*.8660254 + p.yx*.5;\n    return max(max(p2.x, p2.y), max(p.y, p.x));\n    */\n}\n\n// Toroidal distance function -- The sweeping section of the torus. It can be cylindrical,\n// square, hexagonal, octagonal, etc.\nfloat torDist(vec2 p){\n    \n    return length(p);\n    \n    /*\n    // Hexagon arcs.\n    p = abs(p);\n    return max(p.x*.8660254 + p.y*.5, p.y);\n    */\n    \n    /*\n    // Dodecahedral arcs.\n    p = abs(p);\n    vec2 p2 = p.xy*.8660254 + p.yx*.5;\n    return max(max(p2.x, p2.y), max(p.y, p.x));\n    */\n\n      \n    \n}\n\n// Shade, pattern and random ID globals. Hacked in along the way. I might tidy these up later.\nvec4 gHgt, gA, gA2, gD;\n//vec4 gRnd;\n\nvec4 Truchet(vec2 p){\n    \n    // Initialize the height vector to zero.\n    gHgt = vec4(0);\n    \n    // Scaling, translating, then converting the input to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    vec4 h = getHex(p);\n    \n    \n    #ifdef SHOW_GRID\n    // Offset hexagonal variable -- used to render the joins. You could render them using the\n    // value above, but sometimes, pixelated seem lines can appear at the hexagonal boundaries\n    // when trying to perform offset diffuse calculations... It's a long story, but creating\n    // an offset grid ensures no artefacts.\n    vec4 h2 = getHex(p - vec2(0, .8660254*2./3.));\n    #endif\n    \n    // Using the idetifying coordinate -- stored in \"h.zw,\" to produce some unique random numbers\n    // for the hexagonal grid cell.\n    vec2 rnd = hash22(h.zw + .673);\n     \n    // Store the hexagonal coordinates in \"p\" to save some writing. \"p\" tends to be the universal\n    // shader variable for \"point,\" so it reads a little better too.\n    p = h.xy;\n    \n\n    \n    // Constants used for the Truchet pattern. The arc thickness, the small are radius and the large\n    // arc radius.\n    //const float th = 0.;//.1; // Applying tube thickness outside the function.\n    const float rSm = .8660254/3.;\n    const float rLg = .8660254;\n    \n    float a; // Storage for the arc angle, which is used for height, etc.\n    \n    \n    // Randomly rotate the tile.\n    float rFactor = floor(rnd.x*6.)*3.14159265/3.;\n    p = r2(rFactor)*p;\n    \n    float hDir = rnd.y>.5? -1.: 1.;\n    \n \n    // Distance field variable, and a hacky flag to turn off pattern rendering -- Basically, to stop the \n    // portals being rendered under the joins.\n    vec4 d;\n    \n    // Utils for point storage and the UV coordinates for each of the shapes.\n    vec2 p1, p2, p3;\n    \n    \n    // DISTANCE FIELD, ID, AND TEXTURE CALCULATIONS\n    \n    // If one of the random variables is above a certain threshold, render one of the\n    // tiles. The thresholds are distributed according to how much weighting you'd like\n    // to give a certain kind of tile. For instance, I wanted more curves, so gave more\n    // weighting to the arc tiles than the straight line ones.\n    \n    \n    #ifdef NO_WEAVE\n     \n    // Small arc one.        \n    p1 = p - vec2(.5, .8660254/3.);\n    d.x = torDist(p1) - rSm;        \n\n    d.x = abs(d.x);\n    a = atan(p1.y, p1.x);\n    gA.x = a;\n    // One dot per small arc segment. Three make up a circle.\n    //gRnd.x = hash21(h.zw + floor(a/6.283*3.));\n    //a = mod(a/3.14159265, 2.) - 1.;\n\n    // Small arc two.\n    p2 = p - vec2(-.5, .8660254/3.);\n    d.y = torDist(p2) - rSm;\n\n    d.y = abs(d.y);\n    a = atan(p2.y, p2.x);\n    gA.y = a;\n    //gRnd.y = hash21(h.zw + floor(a/6.283*3.) + 7.45);\n    //a = mod(a/3.14159265, 2.) - 1.;\n\n    // Small arc three.\n    p3 = p - vec2(0, -.8660254*2./3.);\n    d.z = torDist(p3) - rSm;\n\n    d.z = abs(d.z);\n    a = atan(p3.y, p3.x);\n    gA.z = a;\n    //gRnd.z = hash21(h.zw + floor(a/6.283*3.) + 9.23);\n    //a = mod(a/3.14159265, 2.) - 1.;\n    \n    //d.xyz -= th;\n         \n         \n\t#else\n \n    // Large arc one.\n    p1 = p - vec2(1, 0); \n    a = atan(p1.y, p1.x); // Longer arc.\n    gA.x = a*3.;\n    d.x = torDist(p1) - rLg;\n    d.x = abs(d.x);\n    //gRnd.x = hash21(h.zw + floor(a/6.283*6.) + 8.71);\n    gHgt.x = (cos(a*6.) + 1.)*.05*hDir;\n    //a = mod(a/3.14159265, 2.) - 1.;\n    //hgt.x = (1. - abs(a*6.));\n    //hgt.x = smoothstep(.0, .95, hgt.x)*hDir*.1;\n\n\n\n    // Large arc two.\n    p2 = p - r2(3.14159265/3.)*vec2(1, 0);\n    a = atan(p2.y, p2.x); // Longer arc.\n    gA.y = a*3.;\n    d.y = torDist(p2) - rLg;\n    d.y = abs(d.y);\n    //gRnd.y = hash21(h.zw + floor(a/6.283*6.) + 3.87);\n    gHgt.y = -(cos(a*6.) + 1.)*.05*hDir;\n    //a = mod(a/3.14159265, 2.) - 1.;\n    //hgt.y = (1. - abs(a*6. + 2.));\n    //hgt.y = -smoothstep(.0, .95, hgt.y)*hDir*.1;\n\n\n    // Small arc.\n    p3 = p - r2(-3.14159265/3.)*vec2(0, .57735);\n    a = atan(p3.y, p3.x); // Smaller arc.\n    gA.z = a;\n    d.z = torDist(p3) - rSm;\n    d.z = abs(d.z);\n    //gRnd.z = hash21(h.zw + floor(a/6.283*3.) + 5.54);\n    //a = mod(a/3.14159265, 2.) - 1.;\n    \n    //d.xyz -= th;\n\n    \n    #endif\n    \n    \n/////\n    \n    #ifdef SHOW_GRID\n    \n    // JOINER BLOCKS\n    //\n    // The joins need to be rendered seperately using an offset hexagonal grid, due to pixelated \n    // mismatching at the hexagonal boundaries when highlighting... It's a long story... :)\n    //\n    // Three blocks, arranged in a tri blade propellor scheme. \n    //     \n    vec2 q = h2.xy;\n    float blc = abs(length(q) - .8660254/3.);// - th;\n    \n    q = r2(3.14159/6.)*q;\n    a = atan(q.y, q.x);\n    float ia = floor(a/6.283*3.) + .5;\n    q = r2(ia*6.283/3.)*q;\n    q.x -= .8660254/3.;\n        \n    q = abs(q);// - vec2(th, .04);\n    // q.x = abs(q.x - .08);// - .2;\n    \n    // Holding the joiner block distance field value in a global variable to be \n    // used elsewhere.\n    // The weird mix function gives the joins a slight pinch at the ends to feed the illusion a little more.\n    //d.w = mix(length(q) - .04, max(q.x - .15, q.y - .04), .9);\n    d.w = max(q.x - .2, q.y - .02);//\n    //d.w = length(q.xy) - .2;//.06333;//\n    //float blocks = mix(length(q) - .04, min(max(q.x - .15, q.y - .04), 0.) + length(max(q - vec2(.15, .04), 0.)), .9);\n    // The shade value (used for highlighting) has been tweaked in an unnatural way to give the reflected\n    // look I was after, but I wouldn't put too much stock in it.\n    \n    #endif\n    \n    return d;\n    \n    \n}\n\n\n\n\n// Distance field function.\nfloat m(vec3 p){\n    \n    \n    //p.xy -= path(p.z);\n    \n    //float sf = .5;//dot(sin(p*3. - cos(p.yzx*3.)), vec3(.333));\n    \n    // Moving the scene down a bit... I should probably move the camera up. :)\n    p.y += 1.5;\n    \n    \n    // The floor plane. Set roughly at the bottom of the Truchet object.\n    float fl = .25 + p.y;// + (.5 - sf)*.5;\n    \n    \n    // The hexagonal Truchet object -- weaved or otherwise.\n    const float sc = 1.;\n    vec4 d = Truchet(p.xz*sc);\n \n\t// The Truchet function above retuns the toroidal arc distances, which have the poloidal\n    // function applied to produce the torus like arcs. There are three arcs in all.\n    d.x = polDist(vec2(d.x/sc, p.y + gHgt.x));\n    d.y = polDist(vec2(d.y/sc, p.y + gHgt.y));    \n    d.z = polDist(vec2(d.z/sc, p.y + gHgt.z));  \n    \n    d.xyz -= .16/sc; // Give the torus-like arcs some thickness.\n    \n    \n    gD = d; // Storing all three distance functions above into a global to be used elsewhere.\n    \n    \n    // The Truchet object distance, which is the minimum of the three arcs.\n    float ob = min(min(d.x, d.y), d.z);\n \n    // Smoothly imprinting the Truchet object into the floor a bit. Not sure why, but it seemed\n    // like a good idea at the time. :)\n    fl = smax(fl, -ob*2., .5) - .2;\n    \n    // Hacky hexagonal grid display.\n    #ifdef SHOW_GRID\n    d.w = max(d.w/sc, p.y - .25);\n    fl = min(fl, d.w);\n    #endif\n \n    // Object ID: Either the floor or the Truchet object.\n    objID = fl<ob? 0. : 1.;\n    \n    // Return the minimum distance.\n    return min(fl, ob);\n    \n}\n\n\n// This is an exact duplicate of the distance function with some \"atan\" calculations thrown in. It's a bit\n// of a waste of code, but worth it to take the three \"atan\" calculations out of the distance function\n// loop... but such a character waste. I'll try to amalgamate some things later.\nfloat m2(vec3 p){\n    \n    \n    //p.xy -= path(p.z);\n    \n    //float sf = .5;//dot(sin(p*3. - cos(p.yzx*3.)), vec3(.333));\n    \n    // Moving the scene down a bit... I should probably move the camera up. :)\n    p.y += 1.5;\n    \n    \n    // The floor plane. Set roughly at the bottom of the Truchet object.\n    float fl = .25 + p.y;// + (.5 - sf)*.5;\n    \n    \n    // The hexagonal Truchet object - weaved or otherwise.\n    const float sc = 1.;\n    vec4 d = Truchet(p.xz*sc);\n    \n    \n    gA2.x = atan(p.y + gHgt.x, d.x/sc);\n    gA2.y = atan(p.y + gHgt.y, d.y/sc);\n    gA2.z = atan(p.y + gHgt.z, d.z/sc);\n\n\t\n\t// The Truchet function above retuns the toroidal arc distances, which have the poloidal\n    // function applied to produce the torus like arcs. There are three arcs in all.\n    d.x = polDist(vec2(d.x/sc, p.y + gHgt.x));\n    d.y = polDist(vec2(d.y/sc, p.y + gHgt.y));    \n    d.z = polDist(vec2(d.z/sc, p.y + gHgt.z));  \n    \n    d.xyz -= .16/sc; // Give the torus-like arcs some thickness.\n    \n    \n    gD = d; // Storing all three distance functions above into a global to be used elsewhere.\n    \n    \n    // The Truchet object distance, which is the minimum of the three arcs.\n    float ob = min(min(d.x, d.y), d.z);\n \n    // Smoothly imprinting the Truchet object into the floor a bit. Not sure why, but it seemed\n    // like a good idea at the time. :)\n    fl = smax(fl, -ob*2., .5) - .2;\n    \n    // Hacky hexagonal grid display.\n    #ifdef SHOW_GRID\n    d.w = max(d.w/sc, p.y - .25);\n    fl = min(fl, d.w);\n    #endif\n \n    // Object ID: Either the floor or the Truchet object.\n    objID = fl<ob? 0. : 1.;\n    \n    // Return the minimum distance.\n    return min(fl, ob);\n    \n}\n\n\n/////////\n// The bump function.\nfloat bumpFunc(vec3 p, vec3 n){\n    \n    // Place a square Truchet pattern on the ground, or the wrap it around\n    // the snake-like Truchet object.\n\n \n    \n    float d = m2(p);\n    \n    float c = 0.;\n    \n    if(objID<.5) {     \n        \n        c =  sTruchet(p.xz*6.);//*.95 +  sTruchet(p.xz*12.)*.05;\n         \n    }\n    else {\n    \n        // Obtain the nearest toroidal and poloidal angles, convert them to cylindrical\n        // coordinates, then pass them to a wrappable function. In this case, it's a simple\n        // square Truchet function.\n        float a;\n        float a2;\n\n        if(gD.x<gD.y && gD.x<gD.z){\n            a = gA.x;\n            a2 = gA2.x;\n        }\n        else if(gD.y<gD.z){\n            a = gA.y;\n            a2 = gA2.y;\n        }\n        else {\n            a = gA.z;\n            a2 = gA2.z;\n\n        }\n\n        // \"a2\" represents the toroidal axis, and \"a\" the poloidal axis. Due to the nature of the hexagonal\n        // Truchet geometry, \"a\" needs to be a multiple of 12, in most cases. \"a2\" is more flexible, but needs\n        // to be a multiple of 4, in this particular case... 6 might work with an offset.\n\n        c = sTruchet(vec2(a2*8., a*12.)/6.283);\n        //c = sTruchet(vec2(a2*12., a*24.)/6.283); // More detailed, but a little too busy.\n        \n\n        // More interesting, but a little too busy for this example.\n        //c = sTruchet(vec2(a2*8., a*12.)/6.283)*.975 + sTruchet(vec2(a2*16., a*24.)/6.283)*.025;\n\n        // For testing purposes.\n        //c = (cos(a*12.) + cos(a2*8.))*.05 + .1;\n        \n        \n    }\n   \n   \n    \n    //float c = min(min(svGd.x, svGd.y), svGd.z);\n    // Note that I could perform two returns and dispense with the float declaration,\n    // but some graphics cards used to complain. I think all of them should be\n    // fine now, but just in case.\n    return c;//*.998 + n3D(p*192.)*.002; \n\n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(1./iResolution.y, 0); \n    \n    float f = bumpFunc(p, n); // Hit point function sample.\n    \n    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.\n    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.\n    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.\n    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x*2.);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .5, 0., 2.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n\n\n////////\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 nr(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * m(p + e.xyy) + e.yyx * m(p + e.yyx) + e.yxy * m(p + e.yxy) + e.xxx * m(p + e.xxx));\n}\n*/\n\n\n// Standard normal function -- for comparison with the one below.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\tm(p + e.yyx) - m(p - e.yyx)));\n}\n\n\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing -- in a setting like this -- with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat shad(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = m(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)\n    return min(max(shade, 0.), 1.); \n}\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = m(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n\n// Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    vec3 col = pow(vec3(1.5, 1, 1)*c, vec3(1, 2.5, 12)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25 + .25); \n    \n}\n\nvoid mainImage(out vec4 fCol, vec2 fCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fCoord - iResolution.xy*.5) / iResolution.y;\n    \n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, iTime*1.);  // \"Look At\" position.\n\tvec3 o = lk + vec3(0, .3, -.25); // Camera position, doubling as the ray origin.\n\n   \n    // Light position. Set in the vicinity the ray origin.\n    vec3 l = o + vec3(0, .5, 2.);\n    \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlk.xy += path(lk.z);\n\to.xy += path(o.z);\n\tl.xy += path(l.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-o);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // r - Ray direction.\n    vec3 r = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    /////////\n    \n    // Standard raymarching routine.\n    float d, t = 0.;\n    \n    for(int i=0; i<96;i++){\n        \n        d = m(o + r*t);\n        // There isn't really a far plane to go beyond, but it's there anyway.\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n\n    }\n    \n    t = min(t, FAR);\n    \n    // Save the object ID right after the final distance function call.\n    float svID = objID;\n    \n    \n    // Set the initial scene color to black.\n    vec3 col = vec3(0);\n    \n     \n    if(t<FAR){\n    \n        // Hit point and normal at the hit point.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Bump mapping with bumped edging and curvature -- The latter isn't used here.\n        float edge2 = 0., crv2 = 1., bf = .25; \n        //if(svID<.5) bf = .5;\n        n = doBumpMap(p, n, bf, edge2, crv2); ///(1. + t/FAR*.125)\n        \n        \n        // Shadows and ambient occlusion.\n        float sh = shad(p + n*.002, l, 16., t);\n        float ao = cAO(p, n);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n \n        \n        // Texture value at the surface. Use the heighmap value above to distort the\n        // texture a bit.\n        float txSc = .5;\n        vec3 tx = tex3D(iChannel0, (p*txSc), n);\n        tx = smoothstep(.0, .5, tx);\n\n       \n        col = tx; //vec3(1)*fBm; // Initializing to the texture color.\n         \n        // Addind a sprinking of noise. The scene looks a little too clean without it.\n        float fBm = n3D(p*128.)*.66 + n3D(p*256.)*.34;\n        col *= mix(vec3(0), vec3(1), fBm*2.*.5 + .5);\n        \n \n        // Golden coloring for the Truchet and greyish coloring for the ground.\n        if(svID>.5){\n            //col *= max(1. - bumpFunc(p, n)*1.5, 0.);\n        \tcol *= mix(vec3(2, 1, .3), vec3(.1, 0, 0), bumpFunc(p, n)*1.5);\n            //col *= vec3(1, .1, .2)*1.5;\n                 \n        }\n        else {\n            //col *= max(1. - bumpFunc(p, n)*1.5, 0.);\n            col *= vec3(.8, .6, .4);\n        }\n        \n        \n        // Diffuse and specular.        \n        float df = max(dot(l, n), 0.); // Diffuse.\n        df = pow(df, 4.)*2.;\n        float sp = pow(max(dot(reflect(-l, n), -r), 0.), 32.); // Specular.\n        \n        \n\t\t// Applying some diffuse and specular lighting to the surface.\n        col = col*(df + .5*ao) + vec3(1, .97, .92)*sp*2.;\n        \n        // Add the fake environmapping. Not as good as a reflective pass, but it gives that\n        // impresssion for just a fraction of the cost.\n        vec3 em = eMap(reflect(r, n), n); // Fake environment mapping.\n        col += em*1.5;\n        \n        // Edges.\n        col *= 1. - edge2*.65; // Bump mapped edgingy.  \n        \n        // Attenuation, based on light to surface distance.    \n        col *= 1./(1. + d*d*.1);\n        \n        // Shadows and AO application.\n        col *= (sh + ao*.3)*ao;\n        \n\n        \n    }\n    \n    \n    // APPLYING FOG\n    // Blend in a bit of light fog for atmospheric effect.\n    vec3 fogCol = vec3(0);//vec3(.7, .8, 1.)*(rd.y*.5 + .5)*2.5;\n    col = mix(col, fogCol, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc.\n    \n    \n    // Vignette.\n    u = fCoord/iResolution.xy;\n    col = mix(col, vec3(0), (1. - pow(16.*u.x*u.y*(1.-u.x)*(1.-u.y), 0.25))*.5);\n    \n    // Apply some statistically unlikely (but close enough) 2.0 gamma correction. :)\n    fCol = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}