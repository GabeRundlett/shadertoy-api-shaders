{
    "Shader": {
        "info": {
            "date": "1454927534",
            "description": "go fullscreen <br/>and click a tile for new mutations, red cross for new population<br/>white square to lock a tile (exclude from mutation)<br/>green square to show in big<br/>green cross to randomly mate locked tiles",
            "flags": 32,
            "hasliked": 0,
            "id": "XdyGWw",
            "likes": 91,
            "name": "interactive evolution",
            "published": 3,
            "tags": [
                "kaliset",
                "algorithm",
                "evolutionary"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 2709
        },
        "renderpass": [
            {
                "code": "/*  Interactive Evolutionary Framework - https://www.shadertoy.com/view/XdyGWw\n    (c) 0x7e Stefan Berke\n   \tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tRender some image, animation or what-have-you from a set of parameters\n    and evolve the parameters by choosing an offspring to populate the next pool.\n\n    The pool is split into tiles on the screen. \n\tClicking a tile fills the rest of the pool with new variations. \n\tRewind or red cross resets to new, previously unseen! population\n\n  USAGE:\n\t(bottom-right) \n\tred cross =     reset pool\n\tgreen cross =   cross-breed locked tiles\n\n\t(per tile)\n\twhite square =  lock/unlock tile\n    green square =  show big\n\n  FOR CODER:\n\tEach parameter set (per tile) is a rectangle of size iResolution.x, NUM_PARAM_ROWS\n\tin the input buffer. So with one row, you have easily 200+ parameters to use. \n\tIncrease NUM_PARAM_ROWS if you need more. \n\tTo plug into this framework, defined theImage() and use the parameter() function \n\tto drive all image generation with the returned values. \n\tThe values are vec4s initialized in the range [-1,1]\n\t(range is adjustable in BufA)\n\n\tVersion 0.4\n      - cross breeding of locked tiles\n      - min/max ranges for random values\n\t  - better hashing\n\n\tVersion 0.3\n      - big display (with numbers) via green button\n\t  - single mouse-down event on click\n      - TODO only prints x component of parameters..\n\n\tVersion 0.21\n\t  - fixed anti-aliasing\n\tVersion 0.2\n      - added locking\n\n\tVersion 0.1\n\t  TODO: Cross-breeding, Undo, Favorites/Keep/Bookmark, \n\t\t    Print parameter values  \n*/\n\n#define AA 1\t\t\t\t\t\t// anti-aliasing > 1\n#define DO_PRINT 1\t\t\t\t\t// print numbers in big view ?\t\n#define SHOW_VALUES 0\t\t\t\t// show only parameter values (for debugging)\nconst int NUM_PARAM_ROWS = 1;\t\t// Number of rows of parameters for one 'tile'\nconst int NUM_TILES = 4;\t\t\t// Number of 'tiles' per screen screen height\n\n\n// ---- parameters ----\n\nint cur_tile; // (initialized in main)\n\n// returns the parameters for the current 'tile' \nvec4 parameter(in int column, in int row) \n{ \n    vec2 uv = (vec2(column+2, row + cur_tile * NUM_PARAM_ROWS)+.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv)\n    // some slight varying in time\n        + 0.006 * sin(float(column) + iTime) * vec4(1., -1., -1., 1.);\n        ;    \n}\n\n// wrapper, if you don't use rows\nvec4 parameter(in int column) { return parameter(column, 0); }\n\n// wrapper that just gives the next number\nint _P = 0;\nvec4 parameter() { return parameter(_P++); }\n\n\n\n// 8<---------8<---------8<--------8<--\n// paste your favorite algorithm here\n// and use the parameter() function above\n\n\n/* uv is in [-1, 1] */\nvec3 theImage(in vec2 uv)\n{\n\t/* Of course, the Kali set again! */\n    \n    vec3 colAcc = parameter().xyz;\n    vec3 minAcc = parameter().xyz;\n    \n    vec3 col = vec3(0.);\n    float md = 1000.;\n    // start pos + random scale and offset\n    vec3 po = vec3(uv, 0.) * 0.1 * parameter().x \n        \t  + parameter().xyz;\n    \n    const int numIter = 13;\n    for (int i=0; i<numIter; ++i)\n    {\n        // kali set (first half)\n        po = abs(po.xyz) / dot(po, po);\n        \n        // accumulate some values\n        col += colAcc * po;\n        md = min(md, abs(dot(minAcc, po)));\n    \n        // kali set (second half)\n        if (i != numIter - 1)\n        \tpo -= abs(parameter().xyz);\n        // (a different magic param for each iteration step!)\n    }\n    // average color\n    col = abs(col) / float(numIter);\n    \n    // \"min-distance stripes\" or \"orbit traps\"\n    md = pow(1. - md, 20. * abs(parameter().x));\n    col += parameter().x * vec3(md);\n    \n    // mix-in color from last iteration step\n    vec3 col2 = po * abs(dot(po, parameter().xyz));\n    col += (col2 - col) * 0.2 * abs(parameter().x);\n    \n    //col = pow(clamp(col + .9, 0., 1.), vec3(40.));\n    \n    return col;\n}\n\n\n\n// 8<---------8<---------8<--------8<--\n\n\n\n// --- ui state ---\n\n// is the given 'tile' excluded from mutation?\nbool isTileLocked(in int cur_tile) \n{\n    vec2 uv = (vec2(1, cur_tile * NUM_PARAM_ROWS) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x >= .5;\n}\n\n// returns selected tile (even if already unselected)\nint selectedTile()\n{\n    vec2 uv = (vec2(0., 1.) + .5) / iChannelResolution[0].xy;\n\treturn int(texture(iChannel0, uv).x)-1;\n}\n\n// transition for selection fade-in\nfloat selectionMorph()\n{\n    vec2 uv = (vec2(0., 2.) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x;\n}\n\n// --- number printing --- \n// from effie https://www.shadertoy.com/view/ldGGRG\n\n#define BLUR 0.1\nfloat segment(vec2 uv){//from Andre https://www.shadertoy.com/view/Xsy3zG\n\tuv = abs(uv);return (1.0-smoothstep(0.07-BLUR,0.07+BLUR,uv.x)) * (1.0-smoothstep(0.46-BLUR,0.46+BLUR,uv.y+uv.x)) ;//* (1.25 - length(uv*vec2(3.8,1.3)))\n\t//uv = abs(uv);return (1.0-smoothstep(udef[6]-udef[8],udef[6]+udef[8],uv.x)) * (1.0-smoothstep(udef[7]-udef[8],udef[7]+udef[8],uv.y+uv.x)) ;//* (1.25 - length(uv*vec2(3.8,1.3)))\n}\nfloat sevenSegment(vec2 uv,int num){\n\tuv=(uv-0.5)*vec2(1.5,2.2);\n\tfloat seg=0.0;if(num>=2 && num!=7 || num==-2)seg+=segment(uv.yx);\n\tif (num==0 || (uv.y<0.?((num==2)==(uv.x<0.) || num==6 || num==8):(uv.x>0.?(num!=5 && num!=6):(num>=4 && num!=7) )))seg += segment(abs(uv)-0.5); \n\tif (num>=0 && num!=1 && num!=4 && (num!=7 || uv.y>0.))seg += segment(vec2(abs(uv.y)-1.0,uv.x)); \n\treturn seg;\n}\n//prints a \"num\" filling the \"rect\" with \"spaces\" # of digits including minus sign\nfloat formatNum(vec2 uv, vec2 rect, float num, int spaces){//only good up to 6 spaces!\n\tuv/=rect;if(uv.x<0.0 || uv.y<0.0 || uv.x>1.0 || uv.y>1.0)return 0.0;\n\tuv.x*=float(spaces);\n\tfloat place=floor(uv.x);\n\tif(num<0.0){if(place==0.0)return segment((uv.yx-0.5)*vec2(2.2,1.5));else {num=-num;place-=1.0;uv.x-=1.0;spaces-=1;}}\n\tfloat decpnt=floor(max(log(num)/log(10.0),0.0));//how many digits before the decimal place\n\tif(decpnt==0.0 && num<1.0){place+=1.0;uv.x+=1.0;spaces+=1;}\n\tfloat period=(decpnt==float(spaces-1)?0.0:1.0-smoothstep(0.06-BLUR/2.,0.06+BLUR/2.,length(uv-vec2(decpnt+1.0,0.1))));\n\tuv.x=fract(uv.x);\n\tnum+=0.000001*pow(10.,decpnt);\n\tnum /= pow(10.,decpnt-place);\n\tnum = mod(floor(num),10.0);\n\treturn period+sevenSegment(uv,int(num));\n}\n\n// --- end number printing\n\n\n// --- other ui stuff ---\n\nfloat drawRect(in vec2 uv, in vec2 pos, in float si)\n{\n    si *= 0.9;\n    uv -= pos;\n    uv /= si;\n    float s = max( abs(uv.x), abs(uv.y) );\n    return pow(clamp(s * (1.-s) * 4., 0., 1.), 30.);\n}\n\nvec3 theImage_(in vec2 uv)\n{\n#if SHOW_VALUES\n    int par = int(50. * (uv.x * .5 + .5));\n    float p = parameter(par).x;\n    float v = smoothstep(.1, 0., abs(uv.y - p));\n    v += (uv.y > 0. && uv.y < p) || (uv.y < 0. && uv.y > p) ? .5 : 0.;\n    return vec3(0., v, 0.) + .3;\n        \n#else\n    return theImage(uv);\n#endif\n}\n\nvoid renderBig(inout vec4 fragColor, in vec2 fragCoord)\n{\n    _P = 0;\n    \n    float trans = selectionMorph();\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * 2.;\n\tvec2 tileuv = uv*(2.-trans);\n    \n    if (tileuv.x > -1. && tileuv.x < 1.\n       && tileuv.y > -1. && tileuv.y < 1.)\n    {\n#if AA <= 1\n\t\tvec3 col = theImage_(tileuv);\n#else\n        float width = iResolution.x - iResolution.y;\n        vec2 sc = vec2(2.) / width / float(AA);\n        vec3 col = vec3(0.);\n        for (int j=0; j<AA; ++j)\n        for (int i=0; i<AA; ++i)\n        {\n            _P = 0;\n            col += theImage_(tileuv + sc * vec2(float(i), float(j)));\n        }\n        col /= float(AA * AA);\n#endif\n        \n\t\t// vignette\n        float border = pow(max(abs(tileuv.x), abs(tileuv.y)), 20.);\n        col *= 1. - border;\n    \t\n        fragColor += trans * (vec4(col, 1.) - fragColor);\n\t}\n    // shadow \n    else if (tileuv.x > -1.1 && tileuv.x < 1.1\n       && tileuv.y > -1.1 && tileuv.y < 1.1)\n    {\n        float border = pow(max(abs(tileuv.x*.9), abs(tileuv.y*.9)), 15.);\n        fragColor.xyz *= mix(1., border, trans);\n    }\n#if DO_PRINT\n    // params\n    if (tileuv.x > 1. && tileuv.y > -1. && tileuv.y < 1.)\n    {\n        tileuv += vec2(-1., 1.);\n        fragColor.xyz -= .4 * trans * fragColor.xyz;\n        int P = int(tileuv.y / .1);\n        tileuv.y = mod(tileuv.y, .1);\n        tileuv.x -= .1;\n        fragColor.xyz += trans * formatNum(\n            tileuv, vec2(.6, .09)*.6, parameter(P).x, 6);\n    }\n#endif\n}\n\nvoid renderTiles(inout vec4 fragColor, in vec2 fragCoord)\n{ \n    // get per-tile uv\n    float width = iResolution.y / float(NUM_TILES);\n    vec2 tileuv = vec2(mod(fragCoord.x, width), \n                       mod(fragCoord.y, width)) \n        / iResolution.y * float(NUM_TILES) * 2.  - 1.;\n\n    // --- render ---\n\n    #if AA <= 1\n    vec3 col = theImage_(tileuv);\n    #else\n    vec2 sc = vec2(2.) / width / float(AA);\n    vec3 col = vec3(0.);\n    for (int j=0; j<AA; ++j)\n        for (int i=0; i<AA; ++i)\n        {\n            _P = 0;\n            col += theImage_(tileuv + sc * vec2(float(i), float(j)));\n        }\n    col /= float(AA * AA);\n    #endif\n\n    // vignette\n    float border = pow(max(abs(tileuv.x), abs(tileuv.y)), 20.);\n    col *= 1. - border;\n\n    // --- various indicators ---\n\n    // lock inidicator\n    if (isTileLocked(cur_tile))\n        col.xyz += border;\n\n    // put into [0,1]\n    tileuv = tileuv * .5 + .5;\n\n    // lock square\n    col.xyz += (isTileLocked(cur_tile)? 1. : .4)\n        * drawRect(tileuv, vec2(.075, .925), .15);\n\n    // display square\n    col.y += .4*drawRect(tileuv, vec2(.225, .925), .15);\n\n    fragColor = vec4(col, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    fragColor = vec4(0.);\n    \n    // determine the rendered tile index\n    cur_tile = int(uv.y * float(NUM_TILES))\n             + int(uv.x * float(NUM_TILES)) * NUM_TILES;\n\n    // disable tile rendering in background of big display\n    bool doTiles = true;\n    if (selectionMorph() > 0.99)\n    {\n        float uvw = .5*(iResolution.x - iResolution.y) / iResolution.y;\n        if (uv.x > uvw && uv.x < 1.+uvw)\n            doTiles = false;   \n    }\n    \n    if (doTiles)\n        renderTiles(fragColor, fragCoord);\n    \n    // reset dot\n    if (uv.x < 0.05 && uv.y < 0.05)\n    {\n        uv /= .05;\n        float cros = 1.-3.*min(abs(uv.x-uv.y), abs(1.-uv.x-uv.y));\n        fragColor += cros * (vec4(1., 0., 0., 1.) - fragColor);\n    }\n    else if (uv.x < 0.1 && uv.y < 0.05)\n    {\n        uv.x -= .05;\n        uv /= .05;\n        float cros = 1.-3.*min(abs(uv.x-uv.y), abs(1.-uv.x-uv.y));\n        fragColor += cros * (vec4(0., 1., 0., 1.) - fragColor);\n    }\n\n    cur_tile = selectedTile();\n    if (cur_tile >= 0 && selectionMorph() > 0.01)\n    \trenderBig(fragColor, fragCoord);\n\n    //fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* Interactive Evolutionary Framework - https://www.shadertoy.com/view/XdyGWw\n   (c) 0x7e Stefan Berke\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   This buffer renders a set of parameters \n   and applies mutation on mouse-click\n\n   (first two columns of output are used for various flags)\n*/\n\nconst int NUM_PARAM_ROWS = 1;\t\t// Number of rows of parameters for one 'tile'\nconst int NUM_TILES = 4;\t\t\t// Number of 'tiles' per screen height\nconst int NUM_TILES_ALL = 100;\t\t// for cross-breeding, set this to the maximum\n\t\t\t\t\t\t\t\t\t// number of tiles on screen\n\nconst float MUTATION_PROB = .5;\t\t// Probability of mutating one parameter\nconst float MUTATION_AMT = 0.1; \t// Maximum amount of mutation +/-\nconst float AV_NUM_PARAMS = 20.;\t// Number of parameters for a cross-breed section\n\t\t\t\t\t\t\t\t\t// This is kind of the length of a consecutive section\n\t\t\t\t\t\t\t\t\t// in the gene..\n\n// scales mutation amount by distance to clicked tile\n#define DO_SCALE\n// define for only positive values \n//#define ABSOLUTE\n//#define RANGE_MIN -1.\n//#define RANGE_MAX  1.\n\n\n\n// hashes by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\nfloat hash(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n// uniform random vec4 [-1,1]\n// (this is not state-of-the-art hashing)\nvec4 rndVec(in vec2 seed)\n{\n    return vec4(hash(seed), hash(seed+.1283), hash(seed+.7229), hash(seed+.32941)) * 2. - 1.;\n}\n\nvec4 clampVec(in vec4 v)\n{\n#ifdef ABSOLUTE\n    v = abs(v);\n#endif\n#ifdef RANGE_MIN\n    v = max(vec4(RANGE_MIN), v);\n#endif\n#ifdef RANGE_MAX\n    v = min(vec4(RANGE_MAX), v);\n#endif\n  \treturn v;\n}\n\n\n// returns the parameters for the given 'tile' \nvec4 parameter(in int column, in int row, in int cur_tile) \n{ \n    vec2 uv = (vec2(column+2, row + cur_tile*NUM_PARAM_ROWS)+.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);    \n}\n\n\n// sets random parameters\nvoid reset(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 1.) // keep ui-states\n    {\n        // clear flags\n        if (fragCoord.x < 2.)\n            fragColor = vec4(0.);\n        // init randomly\n        else\n        {\n            vec2 seed = fragCoord/1.1 + sin(iDate.zw + float(iFrame)*.1); \n            fragColor = clampVec( rndVec(seed) );    \n        }\n    }\n}\n\nvec4 mutate(in int sel_tile, in vec2 fragCoord)\n{\n    // init random mutation \n    vec2 seed = fragCoord + sin(iDate.zw);\n    vec4 mutate = vec4(0.);\n\n    #ifdef DO_SCALE\n    // scale mutation amount by tile distance\n    float amt = clamp( abs(float(sel_tile) - fragCoord.y / float(NUM_PARAM_ROWS))\n                      / float(NUM_TILES * NUM_TILES), 0.1, 1.);\n    #else\n    float amt = 1.;\n    #endif\n    // mutate with probability\n    if (hash(seed*0.12345) < MUTATION_PROB * max(.5, amt))\n        mutate = MUTATION_AMT * amt * rndVec(seed);\n\n    // copy weights from 'sel_tile' slot to all others + mutation\n    return clampVec( parameter(int(fragCoord.x-2.), \n                                   int(mod(fragCoord.y, float(NUM_PARAM_ROWS))), \n                                   sel_tile)\n                     + mutate);\n}\n\nvec4 crossBreed(in int tile1, in int tile2, in vec2 fragCoord)\n{\n    ivec2 parVec = ivec2(int(fragCoord.x-2.), \n                         int(mod(fragCoord.y, float(NUM_PARAM_ROWS))));\n  \tvec4 p1 = parameter(parVec.x, parVec.y, tile1);\n    vec4 p2 = parameter(parVec.x, parVec.y, tile2);\n    \n    vec2 seed = vec2(fragCoord.y) + sin(iDate.zw);\n    float freq = 3.14159265 / float(AV_NUM_PARAMS);\n    float mx = (.5 + .5 * sin(fragCoord.x*freq + 6.*hash(seed)));\n    mx = pow(mx, 1. + 5. * hash(seed.yx*.87));\n    mx *= hash(seed*1.31);\n    // swap dominant set\n    if (hash(seed+mx) > .5)\n    \tmx = 1.-mx;\n    return p1 + mx * (p2 - p1);\n}\n    \n\n// --- ui state ---\n\n// is the given 'tile' excluded from mutation?\nbool isTileLocked(in int cur_tile) \n{\n    vec2 uv = (vec2(1, cur_tile * NUM_PARAM_ROWS) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x >= .5;\n}\n\nint selectedTile()\n{\n    vec2 uv = (vec2(0., 0.) + .5) / iChannelResolution[0].xy;\n\treturn int(texture(iChannel0, uv).x)-1;\n}\n\nfloat selectionMorph()\n{\n    vec2 uv = (vec2(0., 2.) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x;\n}\n\nbool prevMouseDown()\n{\n    vec2 uv = (vec2(0., 3.) + .5) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).x > .5;\n} \n\n// chooses two random, non-equal, locked tiles\n// if none is locked, chooses two random tiles\nvoid selectParents(out int tile1, out int tile2, in vec2 fragCoord)\n{\n    // count number of locked tiles\n    int count = 0;\n    for (int i=0; i<NUM_TILES_ALL; ++i)\n    {\n        bool isLocked = isTileLocked(i);\n        if (isLocked)\n            ++count;\n    }\n\n    vec2 seed = sin(iDate.wz + float(iFrame)*.123 + fragCoord.y);\n\n    if (count < 1)\n    {\n        tile1 = int(hash(seed) * iResolution.y / float(NUM_PARAM_ROWS));\n        tile2 = int(hash(1.-seed*1.11341) * iResolution.y / float(NUM_PARAM_ROWS));\n        return;\n    }\n    \n    // choose index of locked tiles\n    int tilei1, tilei2;\n    if (count == 2)\n    {\n\t\ttilei1 = 0;\n        tilei2 = 1;\n    }\n    else\n    {\n        tilei1 = int(hash(seed) * float(count));\n        tilei2 = int(hash(seed*1.1311+3.) * float(count));\n    }\n    \n    tile1 = tile2 = -1;\n    \n    // select locked tiles\n\tcount = 0;\n    for (int i=0; i<NUM_TILES_ALL; ++i)\n\tif (isTileLocked(i))\n    {\n        if (count == tilei1 && tile1 < 0)\n            tile1 = i;\n    \tif (count++ == tilei2 && tile2 < 0)// || tile2 == tile1)\n        \ttile2 = i;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 pixpos = ivec2(fragCoord);\n    \n    // by default, copy previous pixel\n    vec4 pix = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy);\n    fragColor = pix;\n    \n    // currently rendered 'tile' parameters\n    int cur_tile = int(fragCoord.y) / NUM_PARAM_ROWS;\n\n\t// catch single mouse-down event\n\tbool mouseDown = false;\n    bool prevDown = prevMouseDown();\n    if (iMouse.z > .5 && !prevDown)\n    {\n        mouseDown = true;\n        if (pixpos.x == 0 && pixpos.y == 3)\n            fragColor.x = 1.;\n    }\n    else if (iMouse.z < .5 && prevDown)\n    {\n        if (pixpos.x == 0 && pixpos.y == 3)\n            fragColor.x = 0.;\n    }\n\n    // init parameters\n    if (iFrame < 2)\n    {\n\t\treset(fragColor, fragCoord);\n    }\n\telse\n        \n    // on click\n    if (mouseDown && selectedTile() < 0)\n    {\n        vec2 muv = iMouse.xy / iResolution.y;\n        \n        // clicked on reset-square?\n        if (muv.x < 0.05 && muv.y < 0.05)\n        {\n            if (!isTileLocked(cur_tile))\n            \treset(fragColor, fragCoord);\n        }\n        // clicked on sex-party square?\n        else if (muv.x < 0.1 && muv.y < 0.05)\n        {\n            if (!isTileLocked(cur_tile) && fragCoord.x >= 2.)\n            {\n                int tile1, tile2;\n                selectParents(tile1, tile2, fragCoord);\n                fragColor = crossBreed(tile1, tile2, fragCoord);\n            }\n        }\n        // per tile\n        else\n        {\n            // find 'tile' that was clicked\n            float width = iResolution.y / float(NUM_TILES);\n            int sel_tile = int(iMouse.y / width)\n                         + int(iMouse.x / width) * NUM_TILES;\n            // are we rendering the parameters for the clicked tile?\n            bool is_this_tile = cur_tile == sel_tile;\n            \n            vec2 clickuv = vec2(mod(iMouse.x, width) / width, \n                                mod(iMouse.y, width) / width);\n            \n            // clicked on top bar?\n            if (clickuv.y > .85)\n            {\n                // lock\n                if (clickuv.x < .15)\n                {                \n                    if (pixpos.x == 1 && is_this_tile)\n                    {\n                        pix.x = 1. - pix.x;\n\t                    fragColor = pix; \n                    }\n                }\n                // show\n                else if (clickuv.x < .3)\n                {\n                    if (pixpos.x == 0 && pixpos.y <= 1)\n        \t\t\t\tfragColor = vec4(float(sel_tile+1));\n                }\n            }\n            \n            // mutate\n            else\n            {\n                // don't mutate flags, locked sets or clicked tile\n                if (fragCoord.x < 2. || is_this_tile \n                    || isTileLocked(cur_tile))\n                {\n                    /* fragColor = pix; */\n                }\n                else\n                {\n                    fragColor = mutate(sel_tile, fragCoord);\n                    //fragColor = crossBreed(sel_tile, 4, fragCoord);\n                }\n            }\n        }\n    }\n    else\n        \n    // end selection click\n    if (mouseDown && selectedTile() >= 0)\n    {\n        if (pixpos.x == 0 && pixpos.y == 0)\n        {\n            fragColor = vec4(0.);\n        }\n    }\n    \n    // ui-flags\n    else if (pixpos.x == 0)\n    {\n        // selection fade-in\n        if (pixpos.y == 2)\n        {\n            float on = selectedTile() >= 0 ? 1. : 0.;\n            fragColor.x += min(1., 7.*iTimeDelta) * (on - fragColor.x);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}