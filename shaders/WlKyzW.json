{
    "Shader": {
        "info": {
            "date": "1610583808",
            "description": "Working on building a compact version of this fracture effect, suggestions very welcome.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlKyzW",
            "likes": 70,
            "name": "Buckyball Fracture",
            "published": 3,
            "tags": [
                "explode",
                "polyhedra",
                "fracture"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 1260
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate on axis, blackle\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n// Sign but returns -1 instead of 0\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3;\n    ap = abs(p);\n    v = vec3(PHI, 1, 0);\n    v2 = v.yzx;\n    v3 = v2.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    return normalize(v) * boolSign(p);\n}\n\n// Closest dodecahedron vertex\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3, v4;\n    ap = abs(p);\n    v = vec3(PHI);\n\tv2 = vec3(0, 1, PHI + 1.);\n\tv3 = v2.yzx;\n    v4 = v3.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    if (distance(ap, v4) < distance(ap, v)) v = v4;\n    return normalize(v) * boolSign(p);\n}\n\n// Second closest dodecahedron vertex\nvec3 secondDodecahedronVertex(vec3 p, vec3 iv, vec3 dv) {\n    // Find which side of the icosahedron vertex -> dodecahedron vertex line we're on\n    float side = sign(dot(p, cross(iv, dv)));\n    // Rotate dodecahedron vertex around the dodecahedron face\n    return erot(dv, iv, PI * 2. / 5. * side);\n}\n\n// The model to explode\nfloat object(vec3 p) {\n    pR(p.xz, 1.2);\n    pR(p.xy, .3);\n    float d = fBox(p, vec3(.25 - .02)) - .02;\n    d = max(d, -d - .05);\n    return d;\n}\n\n// https://iquilezles.org/articles/functions\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat map2(vec3 p) {\n\n    // Three closest vertices of a spherical pentakis dodecahedron\n    // or, three closest faces of a buckyball\n    vec3 a = icosahedronVertex(p);\n    vec3 b = dodecahedronVertex(p);\n    vec3 c = secondDodecahedronVertex(p, a, b);\n\n    float d = 1e12;\n\n    vec3 pp = p;\n    \n    // Render the nearest three fragments to get\n    // a clean distance estimation\n\n    for (int i = 0; i < 3; i++) {\n\n        // Offset space\n        float t = mod((iTime - dot(a.xy, vec2(1,-1)) / 6.) / 3., 1.);\n        float t2 = min(t * 1.85, 1.);\n        float explode = 1. - pow(1. - t2, 10.); // expand\n        explode *= 1. - pow(t2, 5.); // contract\n        t2 = max(t - .53, 0.) * 1.2;\n        float wobble = sin(expImpulse(t2, 20.) * 2.2 + pow(3. * t2, 1.5) * 2. * PI * 2. - PI) * smoothstep(.4, .0, t2) * .15;\n        float anim = wobble + explode;\n        p -= a * anim / 2.8;\n\n        // Build boundary edge of face\n        float edgeA = dot(p, normalize(b - a));\n        float edgeB = dot(p, normalize(c - a));\n        float edge = max(edgeA, edgeB);\n\n        // Intersect with object\n        d = min(d, max(object(p), edge));\n        \n        // Reset space for next iteration\n        p = pp;\n        \n        // Cycle faces for next iteration\n        vec3 aa = a;\n        a = b;\n        b = c;\n        c = aa;\n    }\n    \n    return d;\n}\n\n\nfloat map(vec3 p) {\n    if (iMouse.x > 0. && iMouse.y > 0.) {\n        pR(p.yz, (.5 - iMouse.y / iResolution.y) * PI / 2.);\n        pR(p.xz, (.5 - iMouse.x / iResolution.x) * PI * 2.);\n    }\n    return map2(p);\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,3.2);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.007);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 150; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        dist = map(rayPosition);\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 5.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        vec3 albedo = vec3(1);\n        vec3 n = calcNormal(rayPosition);\n        vec3 lp = vec3(-.5,.5,.5);\n        float l = max(dot(lp, n), 0.);\n        vec3 ld = normalize(lp - rayPosition);\n        l += .02;\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\n        float ao = calcAO(rayPosition, n);\n        col = albedo * l * mix(1., ao, .8);\n        col = mix(col, bgcol, 1.0 - exp2(-0.2 * pow(rayLength - 1., 3.)));\n    }\n\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}