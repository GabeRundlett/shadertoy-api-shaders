{
    "Shader": {
        "info": {
            "date": "1674956547",
            "description": "wasd + space and shift to move\nclick and drag mouse to turn\nx = toggle time, c = decrease time, v = increase time",
            "flags": 48,
            "hasliked": 0,
            "id": "DllXW4",
            "likes": 1,
            "name": "clouds - 183t",
            "published": 3,
            "tags": [
                "3d",
                "clouds"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 181
        },
        "renderpass": [
            {
                "code": "const int maxsteps = 128;\nconst int maxlightsteps = 4;\nconst float maxdist = 1000000.0;\nconst float gamma = 2.2;\nconst float epsilon = 0.01;\nconst float lightstep = 4.0;\nconst float lightAmount = 10.0;\nconst float shadowAmount = 1.0;\nconst float cloudcover = 0.7;\nconst float cameraFrustum = 0.5;\n\nconst Cloud cloud0 = Cloud(150.0,-0.6,2.0,50.0,-0.5,1.0,20.0,-0.5,0.5,5.0,-0.5,0.25);\nconst Cloud cloud1 = Cloud(300.0,-0.4,2.0,50.0,-0.3,1.0,20.0,-0.5,0.5,5.0,-0.5,0.25);\\\nconst Cloud cloud2 = Cloud(200.0,-0.4,2.0,50.0,-0.2,1.0,20.0,-0.3,0.5,5.0,-0.2,0.25);\nconst CloudContainer cloudsmain = CloudContainer(vec3(1000000,100,1000000), vec3(0,100,0), cloud0);\nconst CloudContainer bigcloud = CloudContainer(vec3(400,200,400), vec3(0,300,0), cloud1);\nconst CloudContainer stratus = CloudContainer(vec3(1000000,30,1000000), vec3(0,500,0), cloud2);\n\nSceneData sceneSdf(vec3 p){\n    SceneData s = smoothUnify(sdCloud(cloudsmain,p), sdCloud(bigcloud,p),128.0);\n    s = smoothUnify(s, sdCloud(stratus,p),128.0);\n    return s;\n}\n\nfloat noise(vec3 x){\n    return textureLod(iChannel1, x/30.0, 0.0).x;\n}\n\nfloat sampleDensity(vec3 p){\n    SceneData sd = sceneSdf(p);\n    Cloud c = sd.cloudType;\n    float sc = sd.dist;\n    if (sc < 0.0){\n        float s = fpow(1.0 - clamp(-sc/50.0,0.0,1.0),0.2) - 0.2;\n        float v0 = noise(p/c.s0) + c.o0 - s;\n        float v1 = noise(p/c.s1) + c.o1 - s;\n        float v2 = noise(p/c.s2) + c.o2 - s;\n        float v3 = noise(p/c.s3) + c.o3 - s;\n        float n = v0*c.w0 + v1*c.w1 + v2*c.w2 + v3*c.w3 + 3.0*cloudcover - 3.0;\n        return clamp(n, 0.0, 1.0);\n    }\n    return 0.0;\n}\n\nHit marchRay(Ray ray, vec3 lightDir){\n    float density = 0.0;\n    float t = 0.0;\n    float shadow = 0.0;\n    vec3 pos = ray.origin;\n    int itts = 0;\n    for (int i = 0; i < maxsteps; i++){\n        if (t > maxdist) break;\n        float dist = sceneSdf(pos).dist;\n        \n        if (dist > 0.1 && i < 64){\n            pos += abs(dist)*ray.direction;\n            t += abs(dist);\n        } else {\n            float dens = sampleDensity(pos);\n            float densitySmoothing = smoothstep(0.0,1.0,-density + 2.0);\n            density += dens;\n            float stepsize = (dens >= 0.5 ? 1.0 : (8.0*pow(2.0*dens-1.0,2.0) + 0.5)) + t*0.01;\n            pos += stepsize*ray.direction;\n            t += stepsize;\n            if (dens >= 0.0 && density < 2.0){\n                shadow += dens*densitySmoothing;\n                vec3 p2 = pos;\n                for (int j = 0; j < maxlightsteps; j++){\n                    p2 -= lightDir*lightstep;\n                    shadow += sampleDensity(p2)*densitySmoothing;\n                }\n            }\n        itts ++;\n        }\n    }\n    return Hit(density,shadow);\n}\n\nvec4 renderMoon(vec2 uv, float spin, float stage){\n    float l = uv.x*uv.x + uv.y*uv.y;\n    if (l < 1.0){\n        uv /= sqrt(1.0 - l) + 1.0;\n        vec2 p = vec2(uv.x - spin, uv.y);\n        float v = abs(voronoi2d(p*3.0) - 0.3) + abs(voronoi2d(p*7.0)*0.4 - 0.1) +  abs(voronoi2d(p*15.0)*0.1 - 0.05);\n        vec3 lightColor = vec3(1);\n        vec3 darkColor = vec3(0,0.05,0.1);\n        vec3 shadowColor = vec3(0,0.025,0.05);\n        vec4 col = vec4(mix(darkColor,lightColor,1.0 - v),smoothstep(1.0,0.94,l));\n        float k = (2.0*asin(mod(stage,2.0) - 1.0)/3.14159)*sqrt((1.0 - uv.y*uv.y));\n        float s = sign(mod(stage,4.0) - 2.0);\n        if (s*uv.x < s*k){\n            col.rgb = mix(col.rgb,shadowColor,smoothstep(0.0,0.1,s*(k - uv.x))*0.75);\n        }\n        return col;\n    }\n    return vec4(0);\n}\n\nvec3 renderLensFlare(vec3 rd, float density, vec3 light, vec3 position, vec3 rotation, vec2 uv, vec3 sun, float time){\n    vec3 lr = rotate3dbackwards(-light,rotation,vec3(0));\n    if (lr.z > 0.0){\n        vec2 luv = lr.xy*cameraFrustum/lr.z;\n        float ld = distance(luv,uv);\n        vec2 ln = (luv-uv)/ld;\n        float horizonfactor = 100.0*(abs(time - 0.25) - 0.235);\n                \n        //ghosts\n        vec3 ghosts = vec3(0);\n        ghosts += renderhex(uv, -luv*0.25, 1.4, vec3(0.25,0.75,0));\n        ghosts += renderhex(uv, luv*0.25, 0.5, vec3(1,0.5,0.5));\n        ghosts += renderhex(uv, luv*0.1, 1.6, vec3(1,1,1));\n        ghosts += renderhex(uv, luv*1.8, 2.0, vec3(0,0.5,0.75));\n        ghosts += renderhex(uv, luv*1.25, 0.8, vec3(1,1,0.5));\n        ghosts += renderhex(uv, -luv*1.25, 5.0, vec3(0.5,0.5,0.25));\n        ghosts += fpow(1.0 - abs(distance(luv*0.8,uv) - 0.7),0.985)*vec3(0.15,0.1,0);\n        ghosts *= clamp(horizonfactor,0.0,1.0);\n        \n        float flare = fpow(textureLod(iChannel2,ln*0.25,0.0).r,0.3)*0.04/ld*clamp(horizonfactor - 0.5,0.0,1.0)/(1.0 + max(-rd.y,0.0)*10.0);\n        float bloom = 2.0*fpow(max(1.0 - ld,0.0),0.7)*clamp(horizonfactor,0.0,1.0)/(1.0 + max(-rd.y,0.0)*10.0);\n        \n        return (ghosts/(1.0 + distance(uv,luv)) + sun*min(bloom + flare,1.0))*clamp(1.0-density,0.001,1.0);\n    }\n    return vec3(0);\n}\n\nvec3 skyColor(vec3 l, float d, float t, vec3 r, vec3 water){\n    vec3 col = vec3(0);\n    \n    vec3 starRot = rotate3d(r,vec3(-t*2.0*PI,0,0),vec3(0));\n    float starlerp = textureLod(iChannel1,starRot*10.0,0.0).r*textureLod(iChannel1,starRot*0.8,0.0).r;\n    \n    vec3 red = vec3(1.0,0.05,0.06);\n    vec3 orange = vec3(1.0,0.5,0.0);\n    vec3 yellow = vec3(1.0,0.7,0.1);\n    vec3 purple = vec3(0.5,0.2,0.4);\n    vec3 blue = vec3(0.4,0.5,1.0);\n    vec3 black = mix(vec3(0,0,0.005),vec3(1),fpow(starlerp,0.6)*3.0);\n    vec3 black2 = vec3(0.02,0.015,0.05);\n    vec3 white = vec3(0.9);\n\n    float j = smin(abs(r.y),1.0 - d,0.1);\n    float x = max(abs(abs(clamp(t,0.0,1.0)*4.0 - 2.0) - 1.0)*2.0 - 1.0,0.0);\n    vec3 fog = vec3(0);   \n    if (t > 0.5){\n        x *= 3.0;\n        if (x < 1.0){\n            fog = mix(white,yellow,x);\n        } else if (x < 2.0){\n            fog = mix(yellow,orange,x-1.0);\n        } else if (x < 3.0){\n            fog = mix(orange,red,x-2.0);\n        }\n    } else {\n        x *= 2.0;\n        if (x < 1.0){\n           fog = mix(black2,purple,x);\n        } else if (x < 2.0){\n           fog = mix(purple,red,x-1.0);\n        }\n    }\n        \n    float skylerp = clamp(abs(2.0 - abs(1.0 - 4.0*t)) - 0.5,0.0,1.0);\n    col = mix(mix(blue,black,skylerp),fog,fpow(0.7-j,0.3));\n    \n    if (t > 0.1 && t < 0.4) l *= -1.0;\n    if (dot(-l,r) < 0.0){\n        vec3 z = normalize(vec3(0,-l.z,l.y));\n        vec2 uv = vec2(dot(cross(l,z),r),dot(z,r));\n        vec4 moon = renderMoon(uv*8.0,t*5.0,t*5.0);\n        col = mix(col,moon.rgb,moon.a*clamp(1.0-10.0*(abs(t - 0.25) - 0.2),0.0,1.0));\n    }\n    \n    if (r.y < 0.0){\n       return mix(water,col,clamp(1.0+r.y*80.0,0.0,1.0));\n    }\n    \n    return col;\n}\n\n//main render\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup camera\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    float t = fract(texelFetch(iChannel0, ivec2(5,0),0).r);\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n    Ray ray = cam.ray;\n    vec3 lightDirection = vec3(0,sin(t*2.0*PI),-cos(t*2.0*PI)); //negative (0.1,0.4)\n    if (t > 0.1 && t < 0.4) lightDirection *= -1.0;\n    \n    vec3 col = vec3(0);\n    \n    //colors\n    vec3 cloudLit = texelFetch(iChannel0, ivec2(10,0),0).rgb;\n    vec3 cloudShadowed = texelFetch(iChannel0, ivec2(11,0),0).rgb;\n    vec3 water = texelFetch(iChannel0, ivec2(8,0),0).rgb;\n    vec3 sun = texelFetch(iChannel0, ivec2(9,0),0).rgb;\n    \n    float d = dot(-lightDirection,ray.direction);\n    \n    //rendering\n    Hit hit = marchRay(ray,lightDirection);\n    float cloudSun = fpow(max(d,0.0),0.9)*5.0;\n    float shadow = hit.shadow/lightAmount - cloudSun/(1.0 + hit.density);\n    float shadowIntensity = clamp(abs(1.0 - 10.0*abs(t - 0.25) + 0.5),0.0,1.0); //allows the light direction to flip without being noticed\n    vec3 cloudColor = mix(cloudLit,cloudShadowed,min(shadow*shadowAmount,1.0)*shadowIntensity + 0.5*(1.0 - shadowIntensity));\n    \n    //col = mix(renderSky(ray,sky,haze,water), cloudColor, clamp(hit.density,0.0,1.0));\n    col = mix(skyColor(lightDirection, d, t, ray.direction, water), cloudColor, clamp(hit.density,0.0,1.0));\n    col += renderLensFlare(ray.direction, hit.density, lightDirection, position, rotation, cam.uv, sun, t);\n    \n    fragColor = vec4(pow(col.rgb, vec3(1.0/gamma)),0.0); //gamma correction\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.14159265;\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.4;\nconst float moveDamping = 0.8;\nconst float far = 1000.0;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Hit {\n    float density;\n    float shadow;\n};\n\nstruct Cloud {\n    float s0;\n    float o0;\n    float w0;\n    float s1;\n    float o1;\n    float w1;\n    float s2;\n    float o2;\n    float w2;\n    float s3;\n    float o3;\n    float w3;\n};\n\nstruct CloudContainer {\n    vec3 size;\n    vec3 origin;\n    Cloud cloudType;\n};\n\nstruct SceneData {\n    float dist;\n    Cloud cloudType;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    vec2 uv;\n};\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){\n    point -= origin; //subtract pivot\n    //calculate consts\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    float cz = cos(angle.z);\n    float sz = sin(angle.z);\n    //rotate point\n    point *= mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n\n    point += origin; //add pivot\n    return point;\n}\n\n//returns a point rotated backwards in 3d (radians)\nvec3 rotate3dbackwards(vec3 point, vec3 angle, vec3 origin){\n    point -= origin; //subtract pivot\n    //calculate consts\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    float cz = cos(angle.z);\n    float sz = sin(angle.z);\n    //rotate point\n    //the transpose of the normal matrix\n    point *= mat3(\n        cy*cz, cy*sz, -sy,\n        sx*sy*cz - cx*sz, sx*sy*sz + cx*cz, sx*cy,\n        cx*sy*cz + sx*sz, cx*sy*sz - sx*cz, cx*cy\n    );\n\n    point += origin; //add pivot\n    return point;\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    Ray ray = Ray(rotate3d(uv,camRot,vec3(0)) + cameraPos, rotate3d(normalize(uv), camRot, vec3(0)));\n    return Camera(cameraPos, ray, uv.xy);\n}\n\n//math functions:\n\nvec3 planeIntersect(vec3 ro, vec3 rd, vec3 po, vec3 pd){\n    return dot(po - ro, pd)/dot(rd,pd)*rd; \n    //return -(dot(ro,pd)+po)/dot(rd,pd)*rd;\n}\n\n//puts vec a into coord space of vec b\nvec3 toVectorSpace(vec3 a, vec3 b){\n    vec3 x = normalize(vec3(-b.y,b.x, 0));\n    return vec3(dot(x,a),dot(a,b),dot(cross(x,b),a));\n}\n\nSceneData sdCloud(CloudContainer box, vec3 p){\n    vec3 d = abs(p - box.origin) - box.size;\n    return SceneData(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), box.cloudType);\n}\n\nCloud mixCloud(Cloud a, Cloud b, float k){\n    return Cloud(\n        mix(a.s0,b.s0,k),\n        mix(a.o0,b.o0,k),\n        mix(a.w0,b.w0,k),\n        mix(a.s1,b.s1,k),\n        mix(a.o1,b.o1,k),\n        mix(a.w1,b.w1,k),\n        mix(a.s2,b.s2,k),\n        mix(a.o2,b.o2,k),\n        mix(a.w2,b.w2,k),\n        mix(a.s3,b.s3,k),\n        mix(a.o3,b.o3,k),\n        mix(a.w3,b.w3,k)\n    );\n}\n\nSceneData smoothUnify(SceneData a, SceneData b, float k){\n    float h = max(k-abs(a.dist-b.dist),0.0);\n    return SceneData(min(a.dist, b.dist) - h*h*0.25/k, mixCloud(a.cloudType, b.cloudType, clamp((k-b.dist+a.dist)/k,0.0,1.0)));\n}\n\n//fakes x^n for specular effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return ((a+b) - sqrt(h*h+k))*0.5;\n}\n\nfloat smin2( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n//misc\n//https://www.shadertoy.com/view/Xd2GR3\nfloat sdHex(vec2 p){\n    p = abs(p);\n\tvec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n\treturn dot(step(q.xy,q.yx), 1.0-q.yx);\n}\n\nvec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n    uv -= p;\n    if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n        return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.3,sdHex(uv*5.0/s)));\n    }\n    return vec3(0);\n}\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat voronoi2d(vec2 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            n = smin2(n,distance(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv),8.0);\n        }\n    }\n    return n;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _x = 88;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 col = vec4(0);\n    \n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    \n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity;\n        if (position.y < -1000.0){\n            position = vec3(0,24,0);\n        }\n        if (iFrame == 0){\n            position = vec3(0,6,0);\n        }\n        col.xyz = position;\n    }\n    \n    //time\n    if (floor(fragCoord) == vec2(5,0)){\n        vec4 data = texelFetch(iChannel0, ivec2(5,0), 0);\n        float time = data.r;\n        bool doNaturalTime = data.g != 1.0;\n        bool lastXpressed = data.b == 1.0;\n        bool Xpressed = keyPressed(_x) == 1.0;\n        \n        time += (keyPressed(_v)-keyPressed(_c))*0.005;\n        \n        if (!lastXpressed && Xpressed){\n            doNaturalTime = !doNaturalTime;\n        }\n        if (doNaturalTime){\n            time += 0.0005;\n        }\n        \n        col.r = time;\n        col.g = float(!doNaturalTime);\n        col.b = float(Xpressed);\n    }\n    \n    if (floor(fragCoord.y) == 0.0 && floor(fragCoord.x) >= 8.0 && floor(fragCoord.x) <= 11.0){\n        float t = fract(texelFetch(iChannel0, ivec2(5,0), 0).r);\n        if (floor(fragCoord) == vec2(8,0)){ //water\n            vec3 blue = vec3(0.2,0.25,0.8);\n            vec3 black = vec3(0.01,0.01,0.03);\n\n            col.rgb = mix(mix(blue,black,smoothstep(0.0,0.05,t)),blue,smoothstep(0.45,0.55,t));\n        }\n        if (floor(fragCoord) == vec2(9,0)){ //sun\n            vec3 white = vec3(1.0,0.6,0.4);\n            vec3 yellow = vec3(1.0,0.8,0.2);\n        \n            col.rgb = mix(yellow,mix(yellow,white,smoothstep(0.95,0.9,t)),smoothstep(0.55,0.65,t));\n        }\n        if (floor(fragCoord) == vec2(10,0)){ //cloud lit\n            vec3 white = vec3(1.6,1.4,1.2);\n            vec3 black = vec3(0.05,0.05,0.1);\n            vec3 pink = vec3(4.0,1.0,0.3);\n        \n            col.rgb = mix(mix(pink,mix(black,pink,smoothstep(0.45,0.55,t)),smoothstep(0.0,0.05,t)),mix(white,pink,smoothstep(0.95,1.0,t)),smoothstep(0.5,0.6,t));\n        }\n        if (floor(fragCoord) == vec2(11,0)){ //cloud shadowed\n            vec3 white = vec3(0.3,0.4,0.6);\n            vec3 black = vec3(0.01,0.01,0.05);\n            vec3 pink = vec3(0.1,0.1,0.2);\n        \n            col.rgb = mix(mix(pink,mix(black,pink,smoothstep(0.45,0.55,t)),smoothstep(0.0,0.05,t)),mix(white,pink,smoothstep(0.95,1.0,t)),smoothstep(0.5,0.6,t));\n        }\n\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}