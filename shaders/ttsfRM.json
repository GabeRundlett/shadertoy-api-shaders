{
    "Shader": {
        "info": {
            "date": "1596374066",
            "description": "Try some wet ground...",
            "flags": 32,
            "hasliked": 0,
            "id": "ttsfRM",
            "likes": 34,
            "name": "Wet-Tunnel",
            "published": 3,
            "tags": [
                "reflection",
                "tunnel",
                "wet"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 992
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n#define PI 3.14159265359\n#define PI_2 6.2831\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2. * fragCoord) / iResolution.y;\n    \n    #if 1\n    vec3 acc = vec3(0);\n    \n    vec4 res = texture(iChannel0, uv);\n    vec3 col = res.xyz;\n    \n    vec2 d = vec2(res.w) * 0.01;\n    for(int i = -2; i <= 2; ++i)\n    {\n        for(int j = -2; j <=2; ++j)\n        {\n            acc += textureGrad(iChannel0, uv + vec2(float(i), float(j)) * 0.5 / iResolution.xy, dFdx(d), dFdy(d)).xyz;\n        }\n    }\n    \n    float intensity = dot(acc, vec3(.13));\n    \n    \n    col.xyz += acc/16. * intensity * .99;\n    \n    #else\n        \n   \tvec3 col = texture(iChannel0, uv).xyz;\n    #endif\n    col=tonemap(col);\n\tcol=pow(clamp(col,0.,1.0),vec3(0.45));\n  \tcol=clamp(col*0.5+0.5*col*col*1.3,0.0,1.0);\n    col*=0.5+0.5*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.7);\n    \n\tfragColor.xyz = col.xyz;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n#define PI 3.1415926535\n\nfloat hash11(float p)\n{\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash12(vec2 p)\n{\n    p=fract(p*vec2(5.3983, 5.4427));\n    p+=dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(p.x * p.y * 95.4337);\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat box2D(vec3 p, vec2 b)\n{\n    vec2 d = abs(p.xy) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\n\nfloat vline(vec3 p, float h, float r)\n{\n    p.y-=clamp(p.y, 0.0, h);\n    return length(p)-r;\n}\n\nvec3 tri(vec3 p)\n{\n    return abs(fract(p) - .5);\n}\n\nfloat triNoise(vec3 p)\n{\n    return dot(tri(p + .5 * tri(p.yzx * 1.3 + vec3(.3, .7, .1) + 0.25 * tri(p.zyx * 2.6))), vec3(0.3333));\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    vec2 uv = (p.xy + vec2(37.0, 17.0)*p.z)+f.xy;\n    vec2 rg = textureLod(iChannel0, (uv  + 0.5)/256., .0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat sphere(vec3 p)\n{\n    return length(p) - 1.;\n}\n\nint mateID = 0;\nfloat glow0 = 0., glow1 = 0.;\nbool doGlow = false;\n\nfloat lights(vec3 p, float d)\n{\n    vec3 q = p;\n    q.x = abs(q.x) - 1.15;\n    q.z = mod(q.z, 2.) - 1.;\n    float d2 = vline(q.xzy, 0.6, 0.16);\n    \n    if(d2 < d)\n    {\n    \tmateID = 4;\n    \td = d2;\n        if(doGlow) glow0 += 0.2 / (0.15 + abs(d));\n    }\n    \n    q.x = p.x;\n    d2 = vline(q.xzy - vec3(0., 0., 1.), 0.4, 0.16);\n    if(d2 < d)\n    {\n        mateID = 4;\n        d = d2;\n        if(doGlow) glow1 += 0.2 / (0.15 + abs(d));\n    }\n    \n    return d;\n}\n\nfloat tunnel(vec3 p)\n{\n    mateID = 0;\n    float d0 = 1.- length(p.xy) + triNoise(p) * 0.2;\n    float d1 = abs(p.y + 0.65);\n    \n    if(d1 < d0)\n    {\n        mateID = 1;\n        d0 = d1;\n    }\n    \n    vec3 q = p * 6.;\n    \n    vec2 f = fract(q.xz);\n    vec2 l = floor(q.xz);\n    \n    //vec2 off = smoothstep(-1.,-0.9, f) - smoothstep(0.9, 1., f);\n    //d1 -= (off.x + off.y) * 0.01;\n    \n    q.xz = mod(q.xz, vec2(1., 1.1)) - vec2(.5, .55);\n    float d2 = box(q + vec3(0., 3.97, 0.), vec3(0.2, 0.1, 0.45)*.98) / 6. - .01*noise(p*25.);\n    \n    if(d2 < d0)\n    {\n        mateID = 1;\n        d0 = d2;\n    }\n    \n    q = p * 6.;\n    q.xz = mod(q.xz + vec2(0.5, 0.5), vec2(1., 1.1)) - vec2(.5, .55);\n    \n    d2 = box(q + vec3(0., 3.97, 0.), vec3(0.2, 0.1, 0.45)*.98) / 6. - .02*noise(p*15.);;\n    \n    if(d2 < d0)\n    {\n        mateID = 1;\n        d0 = d2;\n    }\n    \n    q = p;\n    q.x = abs(q.x) - .8;\n    d2 = box2D(q + vec3(0., .7, 0.), vec2(0.175 , 0.1));\n    \n    if(d2 < d0)\n    {\n        mateID = 2;\n        d0 = d2;\n    }\n    \n    \n   \td0 = lights(p, d0);\n    \n    return d0;\n}\n\nfloat map(vec3 p)\n{\n    float d0 = tunnel(p);\n    return d0;\n}\n\nfloat mapSimple(vec3 p)\n{\n    float d0 = 1.- length(p.xy) + triNoise(p) * 0.2;\n    d0 = lights(p, d0);\n\n    return d0;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    vec2 e = vec2(0.001 * t , 0.);\n    \n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\nfloat ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i = 1.0; i <5.0 + 1.1; i++)\n    {\n        d = i / 5.;\n        r += w * (d - map(p + n * d));\n        w *= 0.5;\n    }\n    return 1.0 - clamp(r, 0., 1.);\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\nconst mat2 m=mat2(0.8,0.6,-0.6,0.8);\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=.5*noise(p); p=m*p*2.;\n    f+=.25*noise(p); p=m*p*2.;\n    f+=.125*noise(p); p=m*p*2.;\n    f+=.0625*noise(p); p=m*p*2.;\n    f+=.03125*noise(p);\n    return f/0.984375;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nvec3 reflection(vec3 p, vec3 n, vec3 rd, vec3 ro)\n{\n    rd = reflect(rd, n);\n    \n    float t = 0.01, d = 0.;\n    \n    p += 0.001 * n;\n    \n    float glow = 0.;\n    \n    doGlow = true;\n    for(int i = 0; i < 32; ++i)\n    {\n        d = mapSimple(p + t * rd);\n        \n        if(d < 0.005 || t > 20.)\n        \tbreak;\n        \n        t += d;\n    }\n    doGlow = false;\n    \n    vec3 radi = vec3(1.);\n    if(t < 20.)\n    {\n        p = p + t * rd;\n        n = normal(p, t);\n        \n        vec3 PL0 = ro + vec3(0, 0.5, 2.);\n        vec3 w0 = normalize(PL0 - p);\n        vec3 L0 = vec3(1.);\n\n        float dif = max(0., dot(n, w0));\n        float bac = max(0., dot(n, -w0));\n        float amb = 0.5 + 0.5 * n.y;\n        float spe = 0.;\n        float att = length(PL0 - p);\n        att = 1. / (att + att * att);\n\t\t\n\n    \tvec3 mate = vec3(.7);\n\n        radi = (4. * dif + .5 * bac + .5 * amb) * mate * L0 * att + spe * L0 * .25;\n\n        \n        if(mateID == 0)\n        {\n            float rho = length(p.xy);\n            float phi = asin(p.y / rho);\n\n            vec3 cy = vec3(rho, phi, p.z) * 6.;\n\n            vec2 f = fract(cy.zy) * 2. - 1.;\n            vec2 l = floor(cy.zy);\n\n            float rnd = hash12(l);\n\n            if(rnd > 0.7) radi = mix(radi, vec3(2.), 1. - smoothstep(0.4, .5, length(f)));\n        }\n    }\n        \n  \tradi += glow0 * 0.06 * vec3(1.,.5,.2);\n    radi += glow1 * 0.02 * vec3(.0,.5,1.);\n    return radi;\n}\n\nfloat ggx(float roughness, vec3 rd, vec3 W, vec3 n)\n{\n    vec3 H = normalize(W - rd);\n    float NoH = max(0., dot(n, H));\n    vec3 NxH = cross(n, H);\n    float a = roughness * roughness;\n    float b = NoH * a;\n    float c = a / ((1. - NoH * NoH) + b * b);\n    float d = c * c;\n    return d;\n}\n\nfloat schlickFresnel(vec3 rd, vec3 l)\n{\n    vec3 h = normalize(-rd + l);\n    float EdotH = max(0., dot(-rd, h));\n    return pow(max(0.0, 1.0 - EdotH), 2.0);\n}\n\nvec3 shading(vec3 p, vec3 n, vec3 ro, vec3 rd)\n{\n    vec3 PL0 = ro + vec3(0, 0.5, 2.);\n    vec3 w0 = normalize(PL0 - p);\n    vec3 L0 = vec3(1.);\n    \n    \n    float reflective = .0;\n    float roughness = 1.;\n    \n    bool hasRefl = false;\n    \n    vec3 mate = vec3(.1);\n    \n    float water = 0.;\n    float fade = 1.;\n    \n    // road, a little wet by default\n    if(mateID == 1)\n    {\n        mate = vec3(.2);\n        n=bump_mapping(p * (5. + 0.001 * iResolution.x), n, 0.02);\n        \n        // water area\n        water = smoothstep(0.0, 0.7, fbm(p.xz * 5.));\n\n        // very wet area\n        float k = smoothstep(0.1,0.9, fbm(p.zx * 10.));\n \n        // fade the lighting for water\n        fade = mix(fade, 0.3, 1. - smoothstep(0.3, 0.6, water));\n        \n        roughness = 0.8;\n        hasRefl = true;\n        \n        if(water < 0.6)\n        {\n            reflective = .5;\n            roughness = .8;\n        }\n        else if(water > 0.85)\n        {\n            roughness = mix(roughness, 0.1,  1. - smoothstep(0.0,.5,k));\n            reflective = .3;\n        }\n    }\n        \n    float occ = ao(p, n);\n\n    float tmp = map(p);\n    float dif = max(0., dot(n, w0));\n    float bac = max(0., dot(n, -w0));\n    float amb = 0.5 + 0.5 * n.y;\n    float spe = ggx(roughness, rd, w0, n) * max(0., dot(n, w0));\n    float att = length(PL0 - p);\n    att = 1. / (att + att * att * 4.);\n    float fre = schlickFresnel(rd, w0);\n    \n    \n    vec3 diffuse = (4. * dif + .5 * bac + .5 * amb + fre*fre*fre*5.) * (mate - mate * reflective) * L0 * att;\n    vec3 specular = spe * L0 * .25;\n        \n    vec3 radi = (diffuse + specular) * fade;\n       \n    // dirty\n    radi = mix(radi * vec3(smoothstep(0.1, .8, pow(fbm(p.xz * 5.), 1.))), radi, smoothstep(-1.,0.0, p.y));\n    \n    radi *= occ;    \n    \n    // dots on the wall\n    if(mateID == 0)\n    {\n        float rho = length(p.xy);\n        float phi = asin(p.y / rho);\n        \n        vec3 cy = vec3(rho, phi, p.z) * 6.;\n        \n        vec2 f = fract(cy.zy) * 2. - 1.;\n        vec2 l = floor(cy.zy);\n        \n        float rnd = hash12(l);\n        \n        if(rnd > 0.7) radi = mix(radi, vec3(2.), 1. - smoothstep(0.4, .5, length(f)));\n    }\n    \n    // smooth the normal for water area\n    if(mateID == 1)\n    {        \n        n = mix(n, normalize(vec3(0.,1.,0)*.98 + n*0.02), 1. - smoothstep(0.5, 0.8, water));\n    }\n    else if(mateID == 4)\n        radi = vec3(1.);\n    \n    // mix with reflection\n    if(hasRefl)\n    {\n      \tradi = mix(radi,  reflection(p, n, rd, ro) * reflective, fre);\n    }\n\n    return radi * 0.32;\n}\n\nfloat depth = 0.;\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float rnd = 0.9 + 0.1 * hash12(uv.xy);\n    \n    float t = 0.01, d = 1e10;\n    \n    doGlow = true;\n    for(int i = 0; i < 128; ++i)\n    {\n        d = abs(map(ro + t * rd)) * rnd;\n        if(d < 0.001 + 0.0002 * t || t > 50.)\n            break;\n        \n        t += d;\n    }\n    doGlow = false;\n    \n    \n    if(t < 50.)\n    {\n        vec3 p = ro + t * rd;\n        vec3 n = normal(p, t);\n        col = shading(p, n, ro, rd);\n    }\n    \n    depth = t;\n    \n    col += glow0 * 0.03 * vec3(1.,.5,.2);\n    col += glow1 * 0.02 * vec3(.0,.5,1.);\n    col=mix(col, vec3(0.), 1.-exp(-.04*t*t));\n\n    return col;\n}\n\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    \n    float fov = 1.5;\n    \n    float time = iTime * 1.5;\n    \n    vec3 ro = vec3(0., -.25, iTime);\n    vec3 ta = ro + vec3(0., 0., 1.);\n    \n    // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n        ro=vec3(0.,0,-2)+vec3(cos(y_rot)*cos(x_rot),cos(y_rot)*cos(x_rot),cos(y_rot)*sin(x_rot))*1.;\n     \n    vec3 rd = normalize(cam(ro, ta) * vec3(p.x, p.y, fov));\n    \n    vec3 col = scene(ro, rd, p);\n    fragColor = vec4(col, depth);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}