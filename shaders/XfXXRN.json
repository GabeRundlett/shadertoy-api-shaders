{
    "Shader": {
        "info": {
            "date": "1705001208",
            "description": "hexagonal asciiart - genuary9+10",
            "flags": 32,
            "hasliked": 0,
            "id": "XfXXRN",
            "likes": 21,
            "name": "hexagonal asciiart - genuary9+10",
            "published": 3,
            "tags": [
                "ascii"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 362
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2024\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// for genuary9+10 (ASCII-art + Hexagonal)\n//\n\n#define RED\n#define GREEN\n#define BLUE\n\n#define GRID\n#define RED_GRID\n//#define GREEN_GRID\n//#define BLUE_GRID\n\n#define XNUM int(iResolution.x/15.)\n#define YNUM int(iResolution.y/15.)\n\nvec4 getPixel(sampler2D t, int idx)\n{\n    ivec2 r=textureSize(t,0);\n    return texelFetch(t,ivec2(idx,idx/r.x)%r,0);\n}\n\nint g_side=0;\n\nfloat hexDist(vec2 c, vec2 X, vec2 Y)\n{\n    mat2 m=mat2(X,Y);\n    vec2 q=inverse(m)*c;\n    vec2 qfl=floor(q);\n    vec2 qfr=q-qfl;\n    vec2 p1=m*qfl;\n    vec2 p2=m*(qfl+vec2(1,0));\n    vec2 p3=m*(qfl+vec2(0,1));\n    if (qfr.x+qfr.y>1.) { p1=m*floor(qfl+vec2(1,1)); vec2 dum=p2; p2=p3; p3=dum; }\n    float d12=( dot(c-(p1+p2)*.5,normalize((p2-p1))) );\n    float d23=( dot(c-(p2+p3)*.5,normalize((p3-p2))) );\n    float d31=( dot(c-(p3+p1)*.5,normalize((p1-p3))) );\n    return min(abs(min(d23,-d31)),abs(min(d12,-d23)));\n}\n\nvoid  mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    VidOff=OFF1;\n    int ridx=getRegionIdx(uv,ivec2(XNUM,YNUM));\n    VidOff=OFF2;\n    int ridx2=getRegionIdx(uv,ivec2(vec2(XNUM,YNUM)/LayerSc));\n    VidOff=OFF3;\n    int ridx3=getRegionIdx(uv,ivec2(vec2(XNUM,YNUM)/LayerSc/LayerSc));\n    int idx0=ridx*NumChar;\n    int idx02=ridx2*NumChar;\n    int idx03=ridx3*NumChar;\n    float minf=100000.;\n    float maxf=0.;\n    int ch=0, ch2=0, ch3=0;\n    for(int i=0;i<NumChar;i++) {\n        float f=getPixel(iChannel0,idx0+i).x;\n        if (f<minf) { minf=f; ch=i+Char0; }\n    }\n    minf=100000.;\n    for(int i=0;i<NumChar;i++) {\n        float f=getPixel(iChannel0,idx02+i).y;\n        if (f<minf) { minf=f; ch2=i+Char0; }\n    }\n    minf=100000.;\n    for(int i=0;i<NumChar;i++) {\n        float f=getPixel(iChannel0,idx03+i).z;\n        if (f<minf) { minf=f; ch3=i+Char0; }\n    }\n    \n    VidOff=OFF1;\n    vec4 chr=charRegion(ch);\n    vec4 vidr=vidRegion(ridx,ivec2(XNUM,YNUM));\n    vec2 uvch=chr.xy+(uv-vidr.xy)/vidr.zw*chr.zw;\n    \n    VidOff=OFF2;\n    vec4 chr2=charRegion(ch2);\n    vec4 vidr2=vidRegion(ridx2,ivec2(vec2(XNUM,YNUM)/LayerSc));\n    vec2 uvch2=chr2.xy+(uv-vidr2.xy)/vidr2.zw*chr2.zw;\n    \n    VidOff=OFF3;\n    vec4 vidr3=vidRegion(ridx3,ivec2(vec2(XNUM,YNUM)/LayerSc/LayerSc));\n    vec4 chr3=charRegion(ch3);\n    vec2 uvch3=chr3.xy+(uv-vidr3.xy)/vidr3.zw*chr3.zw;\n    \n    fragColor.xyz=vec3(0);\n    #ifdef RED\n    fragColor.xyz+=textureLod(iChannel1,uvch,0.).x*vec3(1,.5,.5);\n    #endif\n    #ifdef GREEN\n    fragColor.xyz+=textureLod(iChannel1,uvch2,0.).x*vec3(.5,1,.5);\n    #endif\n    #ifdef BLUE\n    fragColor.xyz+=textureLod(iChannel1,uvch3,0.).x*vec3(.5,.5,1);\n    #endif\n    \n    vec2 Res=iResolution.xy;\n    #ifdef GRID\n    float d;\n    vec2 num0=vec2(XNUM,YNUM);\n    vec2 num=num0;\n    g_side=0;\n    d=1.-hexDist(fragCoord-vec2(.25,.5)/num*Res,vec2(1./num.x,0)*Res,vec2(.5/num.x,1./num.y)*Res);\n    #ifdef RED_GRID\n    fragColor.xyz+=clamp(d,0.,1.)*vec3(1,.5,.5)*.5;\n    #endif\n    \n    num=floor(num0/LayerSc);\n    g_side=1;\n    d=1.-hexDist(fragCoord-vec2(.5,.0)/num*Res,vec2(1./num.x,0)*Res,vec2(.5/num.x,1./num.y)*Res);\n    #ifdef GREEN_GRID\n    fragColor.xyz+=clamp(d,0.,1.)*vec3(.5,1,.5)*.6;\n    #endif\n\n    num=floor(num0/LayerSc/LayerSc);\n    g_side=2;\n    d=1.-hexDist(fragCoord-vec2(0,0)/num*Res,vec2(1./num.x,0)*Res,vec2(.5/num.x,1./num.y)*Res);\n    #ifdef BLUE_GRID\n    fragColor.xyz+=clamp(d,0.,1.)*vec3(.5,.5,1)*.7;\n    #endif\n    #endif\n    \n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2024\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// for genuary9+10 (ASCII-art + Hexagonal)\n//\n\n#define NumChar (16*6)\n#define Char0 32\n#define LayerSc 1.6\n\nvec2 VidOff=vec2(0);\n\n#define OFF1 vec2(0)\n#define OFF2 (vec2(.25,-.5)*1.)\n#define OFF3 (vec2(.25,.5)*1.)\n\nvec4 vidRegionSq(int idx, ivec2 num)\n{\n    int X=idx%num.x;\n    int Y=idx/num.x;\n    return vec4(vec2(X,Y)+VidOff,vec2(1))/vec2(num).xyxy;\n}\n\nint getRegionSqIdx(vec2 uv, ivec2 num)\n{\n    uv*=vec2(num);\n    uv-=VidOff;\n    ivec2 idx2=ivec2(uv);\n    return idx2.x+idx2.y*num.x;\n}\n\nvec4 vidRegionHex(int idx, ivec2 num)\n{\n    int X=idx%num.x;\n    int Y=idx/num.x;\n    return vec4(vec2(X,Y)+(vec2(Y%2,0)*.5-vec2(.25,0))+VidOff,vec2(1))/vec2(num).xyxy;\n}\n\nint getRegionHexIdx(vec2 uv, ivec2 num)\n{\n    uv*=vec2(num);\n    uv-=VidOff;\n    int Y=int(uv.y);\n    uv-=vec2(Y%2,0)*.5-vec2(.25,0);\n    ivec2 idx2=ivec2(uv);\n    return idx2.x+idx2.y*num.x;\n}\n\nvec4 vidRegion(int idx, ivec2 num) { return vidRegionHex(idx, num); }\n\nint getRegionIdx(vec2 uv, ivec2 num) { return getRegionHexIdx(uv, num); }\n\nvec4 charRegion(int ch)\n{\n    int X=ch%16;\n    int Y=ch/16; Y=15-Y;\n    vec4 r=vec4(vec2(X,Y),vec2(1))/16.;\n    r.xy+=1.3/16./16.;\n    r.zw*=1.-2.6/16.;\n    return r;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2024\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// for genuary9+10 (ASCII-art + Hexagonal)\n//\n\n#define XNUM int(iResolution.x/15.)\n#define YNUM int(iResolution.y/15.)\n\n\n#define CharTex iChannel0\n#define VidTex iChannel1\n\nvec4 getCol(sampler2D tex, vec2 uv)\n{ \n    vec4 c=textureLod(tex,uv,0.);\n    c.xyz= mix(textureLod(tex,uv,0.).xyz,vec3(.4,.3,.1),dot(c.xyz,vec3(-1,2.,-1)));\n    return c;\n}\n\nfloat getVal1(sampler2D tex, vec2 uv)\n{ \n    return -(getCol(tex,uv).w-1.);\n}\n\nvec3 valdot=vec3(.333);\n\nfloat getVal2(sampler2D tex, vec2 uv)\n{\n    float br=dot(getCol(tex,uv).xyz,valdot);\n    return br*br*1.4;\n}\n\nvec2 getGrad2(sampler2D tex, vec2 uv, vec2 eps)\n{\n    vec2 d=vec2(1,0);\n    return vec2(\n        getVal2(tex,uv+d.xy*eps)-getVal2(tex,uv-d.xy*eps),\n        getVal2(tex,uv+d.yx*eps)-getVal2(tex,uv-d.yx*eps)\n        )/eps;\n}\n\nfloat faltung(sampler2D tex1, sampler2D tex2, vec2 c1, vec2 s1, vec2 c2, vec2 s2 , ivec2 num)\n{\n    vec2 d1=s1/vec2(num), d2=s2/vec2(num);\n    float s=0., sg=0.;;\n    vec2 gc=getGrad2(tex2,c2+s2*.5,s2*.7);\n    for(     float y1=.5*d1.y,y2=.5*d2.y ; y1<s1.y ; y1+=d1.y,y2+=d2.y ) {\n        for( float x1=.5*d1.x,x2=.5*d2.x ; x1<s1.x ; x1+=d1.x,x2+=d2.x ) {\n            s+=abs(getVal1(tex1,c1+vec2(x1,y1))-getVal2(tex2,c2+vec2(x2,y2)));\n            vec2 eps=d2*.7;\n            vec2 g=getGrad2(tex2,c2+vec2(x2,y2),eps);\n            float lg=length(g);\n            sg+=abs(getVal1(tex1,c1+vec2(x1,y1))-lg*.0025);\n        }\n    }\n    return (length(gc)>60.)?sg:s;\n}\n\nfloat charFaltung(int ch, sampler2D tex, vec2 c, vec2 s)\n{\n    vec4 chr=charRegion(ch);\n    return faltung(CharTex,VidTex,chr.xy,chr.zw,c,s,ivec2(6));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    ivec2 s=textureSize(iChannel2,0);\n    ivec2 fc=ivec2(fragCoord);\n    int pixIdx=fc.x+fc.y*s.x;\n    int AllNum=XNUM*YNUM*NumChar;\n    if (pixIdx>AllNum) discard;\n    int ch=(pixIdx%NumChar)+Char0;\n    VidOff=OFF1;\n    vec4  vidR=vidRegion(pixIdx/NumChar,ivec2(XNUM,YNUM));\n    VidOff=OFF2;\n    vec4  vidR2=vidRegion(pixIdx/NumChar,ivec2(vec2(XNUM,YNUM)/LayerSc));\n    VidOff=OFF3;\n    vec4  vidR3=vidRegion(pixIdx/NumChar,ivec2(vec2(XNUM,YNUM)/LayerSc/LayerSc));\n    valdot=vec3(1,0,0);\n    float f=charFaltung(ch, VidTex, vidR.xy, vidR.zw);\n    valdot=vec3(0,1,0);\n    float f2=charFaltung(ch, VidTex, vidR2.xy, vidR2.zw);\n    valdot=vec3(0,0,1);\n    float f3=charFaltung(ch, VidTex, vidR3.xy, vidR3.zw);\n    fragColor = vec4(f,f2,f3,1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}