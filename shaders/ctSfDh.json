{
    "Shader": {
        "info": {
            "date": "1693973500",
            "description": "My very first shader (written by a noob)! Features a ray-cast bouncing basketball, along with shadows and reflections.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctSfDh",
            "likes": 10,
            "name": "Basketball Bounce",
            "published": 3,
            "tags": [
                "raycasting",
                "ball"
            ],
            "usePreview": 0,
            "username": "pikachuchujelly",
            "viewed": 273
        },
        "renderpass": [
            {
                "code": "#define HUGE 1000000.0\n\nvec3 ballPos;\nfloat ballRadius = 2.0;\nvec3 lightDir = normalize(vec3(1,2,-2));\n\n// computes the ray direction of a screen pixel\nvec3 perspectiveRay(vec2 pixel)\n{\n    float x = -1.0 + 2.0*(pixel.x / iResolution.x);\n    float y = 1.0;\n    float z = -1.0 + 2.0*(pixel.y / iResolution.y);\n    x *= iResolution.x / iResolution.y;\n    return normalize(vec3(x,y,z));\n}\n\nvec3 rotateYaw(vec3 v, float angle)\n{\n    return vec3(\n        v.x*cos(angle) - v.y*sin(angle),\n        v.y*cos(angle) + v.x*sin(angle),\n        v.z);\n}\n\nvec3 rotatePitch(vec3 v, float angle)\n{\n    return vec3(\n        v.x,\n        v.y*cos(angle) - v.z*sin(angle),\n        v.z*cos(angle) + v.y*sin(angle));\n}\n\nfloat calcLight(vec3 normal, vec3 rd, float shininess)\n{\n    float ambient  = 0.3;\n    float diffuse  = max(dot(-lightDir,normal), 0.0);\n    float specular = max(dot(-lightDir,reflect(rd, normal)), 0.0);\n    specular *= specular*specular*specular*specular*specular*specular*specular*specular;\n    return ambient + diffuse + specular * shininess;\n}\n\nfloat raycastSphere(vec3 ro, vec3 rd, out vec3 normal)\n{\n    vec3 sc = ballPos;  // sphere center\n    float sr = ballRadius;  // sphere radius\n\n    // Imagine a plane that is perpendicular to the ray and intersects the sphere's center.\n    // ts is the distance along the ray to that plane.\n    float ts = dot(sc-ro, rd);\n    if (ts < 0.0)\n        return HUGE;\n    // distance squared between point at ts and the sphere center\n    float r2 = (dot(sc-ro,sc-ro) - ts*ts);\n    if (r2 > sr*sr)\n        return HUGE;\n    float t = ts - sqrt(sr*sr - r2);  // distance along ray to where it intersects the sphere\n    vec3 hit = ro + rd * t;\n    normal = normalize(hit-sc);\n    return t;\n}\n\nfloat raycastFloor(vec3 ro, vec3 rd, out vec2 hit)\n{\n    if (rd.z >= 0.0)\n        return HUGE;\n    float t = -ro.z / rd.z;\n    hit = vec2(ro.x+rd.x*t, ro.y+rd.y*t);\n    return t;\n}\n\n// Returns true or false to select the pattern for the floor position\nbool checker(vec2 floorPos)\n{\n    return mod(floor(floorPos.x) + floor(floorPos.y), 2.0) < 1.0;\n}\n\n// Returns true if the floor position is in the shadow of the ball\nbool shadow(vec3 floorPos)\n{\n    vec3 dummy;\n    return raycastSphere(floorPos, -lightDir, dummy) < HUGE;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // ball physics\n    float t = fract(iTime);\n    float bounce = ceil(fract(iTime/4.0)*4.0);\n    float z = -t*(t-1.0)*50.0/bounce;\n    ballPos = vec3(0.0, 6.0*iTime, 2.0+z);\n\n    float cameraAngle = 0.5*iTime;\n    // ray origin\n    vec3 ro = rotateYaw(vec3(0,-10,4),cameraAngle);\n    ro.y += ballPos.y;\n    // ray direction\n    vec3 rd = perspectiveRay(fragCoord);\n    rd = normalize(rotateYaw(rd,cameraAngle));\n\n    // do the ray trace\n    vec2 floorHit;\n    vec3 nSphere;\n    float rt;\n    float tFloor;\n    vec3 color;\n    vec3 floorColor;\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 sky = mix(vec3(1,1,1),vec3(0,0,1),max(rd.z, 0.0));\n        color = sky;\n        if (raycastSphere(ro, rd, nSphere) < HUGE)\n        {\n            // compute rotated normal for ball pattern\n            vec3 n = rotatePitch(nSphere, ballPos.y/ballRadius);\n            if (abs(n.x) < 0.05 || abs(n.z) < 0.05\n             || abs(n.x*n.x-n.z*n.z-0.2) < 0.05)\n                color = vec3(0,0,0);  // black\n            else\n                color = vec3(1.0,0.5,0.0);  // orange\n            color *= calcLight(nSphere, rd, 0.5);\n        }\n        else if ((rt = raycastFloor(ro, rd, floorHit)) < HUGE)\n        {\n            tFloor = rt;\n            floorColor = checker(floorHit) ? vec3(0.9,0.8,0.4) : vec3(0.8,0.7,0.3);\n            if (shadow(vec3(floorHit,0)))\n                floorColor *= 0.3;\n            else\n                floorColor *= calcLight(vec3(0,0,1), rd, 0.3);\n            // now trace the reflected ray\n            ro = vec3(floorHit, 0.0);\n            rd = reflect(rd,vec3(0,0,1));\n            continue;\n        }\n        else\n            color = sky;\n        if (i == 0)\n            break;\n        else\n        {\n            // blend reflected color with floor color\n            color = mix(floorColor, color, 0.35);\n            // fade out with sky to avoid aliasing artifacts\n            float fadeStart = 20.0;\n            float fadeEnd = 40.0;\n            color = mix(color, sky, clamp((tFloor-fadeStart)/(fadeEnd-fadeStart),0.0,1.0));\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}