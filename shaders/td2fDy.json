{
    "Shader": {
        "info": {
            "date": "1590779703",
            "description": "Simple coding of holed cylinder, testing a sort of dichotomic stepping for raymarching.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "td2fDy",
            "likes": 1,
            "name": "Holed Cylinder",
            "published": 3,
            "tags": [
                "blue",
                "polar",
                "disk",
                "cylinder",
                "cordinates"
            ],
            "usePreview": 0,
            "username": "Leria",
            "viewed": 367
        },
        "renderpass": [
            {
                "code": "vec2 polar_coord(vec3 p)\n{\n    float phi = atan(p.x, p.z); //angle\n    float d_rad = length(vec2(p.x, p.z)); //delta radius\n    return vec2(d_rad*cos(phi), d_rad*sin(phi));\n}\n\nconst vec3 cam = vec3(0., 0., 10.);\nfloat uniform_step = 1.;\nvoid draw_disk(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)\n{\n    float antialiasing = 1.;\n    antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing\n    vec3 p = cam+dir*antialiasing;\n    float s = 0.;\n  \t\n    \n    for(s; s < 150.; s++)\n    {               \n        float k_step = uniform_step;\n        \n        float dist_dist = dot(p, p);\n        float dist_center = length(center-cam);\n        \n        vec2 nu = polar_coord(p-(center));\n\n        //if too far, then big step\n        \n        if(sqrt(dist_dist) < (dist_center-radius))\n        {\n        \tk_step += (sqrt(dist_dist)/2.);\n        }\n\n        //if in the shape, draw\n        else if( (length(nu) - 4. <= 0.) && (length(nu) - 1.5 >= 0.) && (distance(p.y, center.y) < 2.))\n        {\n        \tc += 0.2*vec3(0.4, 0.4, 0.6);\n        }   \n        \n        //if it will never be in the shape anymore, return;\n        if(length(p) > (dist_center+radius))\n        {\n         \tbreak;   \n        }\n        \n        p += dir*k_step;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    \n    draw_disk(normalize(vec3(uv, -1.)), vec3(0., 0., 0.), vec3(0., 1., 0.), 30., color);\n    \n    fragColor = vec4(color, 1.);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}