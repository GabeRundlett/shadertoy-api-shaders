{
    "Shader": {
        "info": {
            "date": "1725304786",
            "description": "One refactored dancer - dancing with his shadow\nHumanoid mechanics + music.\nTry for a version of https://www.shadertoy.com/view/XflfR8 for other hardware\n",
            "flags": 8,
            "hasliked": 0,
            "id": "4f2fz3",
            "likes": 7,
            "name": "Simplified Green Dancer +sound",
            "published": 3,
            "tags": [
                "mechanics",
                "music",
                "dancer"
            ],
            "usePreview": 0,
            "username": "dray",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "/*\nSee https://www.shadertoy.com/view/XflfR8 for background.\nTry to simplify and speed up things.\nThe sdf is more efficient.\nI sometimes get 30fps instead of 4 on the phone.\n*/\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define min3(A,B,C) min(A,min(B,C))\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nmat3 MAT3xz(float ANG) { return mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) ); }\nmat3 MAT3zy(float ANG) { return mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) ); }\nmat3 MAT3xy(float ANG) { return mat3( cos(ANG),sin(ANG),0, -sin(ANG),cos(ANG),0, 0,0,1 ); }\n\n// *********************************************************************************\n\nstruct DAN {\n    float luarm, ruarm;   // spread arms apart 0-3 radians\n    float lelbow, relbow; // bend elbows 0-3 radians\n    float lshoulder, rshoulder; // raise arms in front 0-3 radians\n    //float lrota, rrota; // upper arm rotation -1 - 1 radians\n    float lknee, rknee;  // bend knees 0-3 radians\n    float luleg, ruleg;  // spread legs apart 0-1.5 radians\n    float lhip, rhip;    // raise legs in front 0-3 radians\n    float spin;\n    float leanl, leanf;\n    float hop;\n    // results\n    vec3 _head, _hips; // body\n    vec3 _lshoulder,_lelbow, _lhand;\n    vec3 _rshoulder, _relbow, _rhand;\n    vec3 _lknee, _lhip, _lfoot;\n    vec3 _rknee, _rhip, _rfoot;\n    float _bottom;\n};\n\n#define DANIni(D) \\\n  D.luarm=0.; D.lelbow=0.; D.ruarm=0.; D.relbow=0.; D.luleg=0.; D.lknee=0.; D.ruleg=0.; D.rknee=0.; \\\n  D.lshoulder=0.; D.rshoulder=0.; D.lhip=0.; D.rhip=0.; \\\n  D.spin=0.; D.leanl=0.; D.leanf=0.; D.hop=0.; \\\n  /* D.lrota=0.; D.rrota=0.; */\n\n// alternative to .5-.5*cos(P)\n//float tri(float i) {  return 1. - abs( fract(i)*2. - 1. ); }\n//#define cosp(P) SS(tri((P))) \n\n#define MOVE(FLD,P,L,H) FLD=((.5-.5*cos(P))*((H)-(L))+(L));\n#define HOP(D,V0,G,T)  STDY( D.hop, max( 0., (V0)*(T) - (G)*(T)*(T) ) );\n#define STDY(FLD,VAL) FLD = (VAL);\n\n// *********************************************************************************\n\nDAN Jill;\n\nvoid animJill() {\n    DANIni(Jill);\n    HOP( Jill, 15., 40., fract(iTime*2.) )\n    MOVE(Jill.lelbow,iTime*1.,.2,1.);\n    MOVE(Jill.relbow,iTime*4.,.1,1.);\n    MOVE(Jill.lshoulder,iTime*-4.,0.,2.2);\n    MOVE(Jill.rshoulder,iTime*-1.,0.,1.8);\n    MOVE(Jill.luarm,iTime*1.,0.,.5);\n    MOVE(Jill.ruarm,iTime*3.,0.,1.5);\n    MOVE(Jill.rhip,iTime*5.,0.,1.);\n    MOVE(Jill.rknee,iTime*-7.,0.,1.);\n    MOVE(Jill.ruleg,iTime*3.,0.,1.);\n    STDY( Jill.luleg, -.075 );\n    STDY( Jill.spin, -iTime*4. );\n    MOVE(Jill.leanf,iTime*1.5,-.5,.5);\n}\n\n// -----------------------------------------------------------------------------\n\n#define DSZ 20.\n\nvoid CompDancer(inout DAN m) {\n    m._hips = vec3(0,0,0); // origin !\n    mat3 rott =  MAT3zy(m.leanf) * MAT3xz( m.spin ) /* * MAT3xy(m.leanl) */;\n    m._head = m._hips + vec3(0,.33,0)*DSZ * rott;\n\n    vec3 shoulders = mix( m._hips, m._head, .8 );\n\n    mat3 sav = rott;\n  \n    // left arm\n    m._lshoulder = shoulders - vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.lshoulder ) * MAT3xy( m.luarm ) * rott;\n    m._lelbow = m._lshoulder + vec3(0,-.14,0)*DSZ * rott;\n    rott = MAT3zy( -m.lelbow ) * rott;\n    m._lhand = m._lelbow + vec3(0,-.14,0)*DSZ * rott;\n  \n    rott = sav;\n\n    // right arm\n    m._rshoulder = shoulders + vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.rshoulder ) * MAT3xy( -m.ruarm ) * rott;\n    m._relbow = m._rshoulder + vec3(0,-.14,0)*DSZ * rott;\n    rott = MAT3zy( -m.relbow ) * rott;\n    m._rhand = m._relbow + vec3(0,-.14,0)*DSZ * rott;\n\n    rott = sav;\n\n    // left leg\n    m._lhip = m._hips - vec3(.025,0,0)*DSZ * rott;\n    rott =  MAT3xy( m.luleg - m.leanl ) * MAT3zy( -m.lhip -  m.leanf ) * rott;\n    m._lknee = m._lhip + vec3(0,-.18,0)*DSZ * rott;\n    // rott = MAT3zy( m.lknee ) * rott; // not used by Jill\n    m._lfoot = m._lknee + vec3(0,-.18,0)*DSZ * rott;\n\n    rott = sav;\n\n    // right leg\n    m._rhip = m._hips + vec3(.025,0,0)*DSZ * rott;\n    rott = MAT3xy( -m.ruleg - m.leanl ) * MAT3zy( -m.rhip  - m.leanf ) * rott;\n    m._rknee = m._rhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.rknee ) * rott;\n    m._rfoot = m._rknee + vec3(0,-.18,0)*DSZ * rott;\n\n    m._bottom = min3( m._lfoot.y, m._rfoot.y, m._hips.y-.035*DSZ/3. ) - m.hop;\n\n}\n\nfloat Dancer2(vec3 pt,DAN m) {\n    pt.y += m._bottom;\n    float dist = sdCapsule( pt, m._head, m._hips, .035*DSZ ); // body\n    float tmp;\n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); if ( tmp < dist ) dist = tmp;\n    ADD(m._lshoulder,m._lelbow,.02)\n    ADD(m._lhand,m._lelbow,.02)\n    ADD(m._rshoulder,m._relbow,.02)\n    ADD(m._rhand,m._relbow,.02)\n    ADD(m._lshoulder,m._rshoulder,.02)\n    ADD(m._lknee,m._lhip,.025)\n    ADD(m._lfoot,m._lknee,.025)\n    ADD(m._rknee,m._rhip,.025)\n    ADD(m._rfoot,m._rknee,.025)\n    return dist;\n}\n\n// Terrain -------------------------------------\n\nfloat rndd(vec2 pt) {\n  pt += vec2(13.43544,31.2434);\n  return fract( sin(mod(pt.x*pt.y,TAU)) * 89.367456 );\n}\n\n// smooth step S curve\nfloat SS(float C) { return ((C)*(C)*(3.-2.*(C))); }\n\nfloat height(vec2 pt) { // 0-1\n    vec2 f = floor(pt);\n    vec2 r = fract(pt);\n    vec2 o = vec2(1,0);\n    float xf = SS(r.x);\n    return mix(\n       mix( rndd(f), rndd(f+o), xf ), // mid points of x edges\n       mix( rndd(f+o.yx), rndd(f+o.xx), xf ),\n       SS(r.y) );\n}\n\nfloat height2(vec3 pt) { return pt.y - height(pt.xz*.03)*10. - pt.z*.3 + 5.; }\n\nfloat texture(vec2 pt) { return .5 + height(pt*50.)*.5; }\n\n// Map --------------------------------------------------------------\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n    T( Dancer2( (pt-vec3(0,0,-3)), Jill ) )\n    clr = 3.;\n    T( height2(pt) )\n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 300; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( pos.z < -80. ) return vec4( pos, 91. );\n        if ( obj.x < .01 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    animJill();\n    CompDancer(Jill);\n\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv *= .25; // field of view\n    //vec3 cam = vec3( 0., 10., -64.);\n    vec3 cam = vec3( 0.+sin(iTime*.3)*5., 10.+cos(iTime*.2)*3., -64.);\n    vec3 camdir = normalize( vec3( uv, 1. ) );\n\n    vec4 hit = March( cam, camdir );\n\n    //vec3 Light = vec3( 20., 30, -30 );\n    vec3 Light = vec3( sin(iTime)*40., 30, -30 );\n    vec3 dir = normalize( Light - hit.xyz );\n\n    vec4 shadow = March( hit.xyz+dir*.1, dir );\n\n    vec3 norm = Normal(hit.xyz);\n    float difu = dot( norm, dir );\n    difu = .3 + .7*difu;\n    if ( shadow.z > -10. ) difu = .2;\n    \n    #define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    \n    O = color4(hit.w*.4);\n    \n    // ground pattern\n    if ( hit.w == 3. ) O = mix(O,vec4(0,.3,0,1),clamp(texture(hit.xz*.1),0.,1.));\n    \n    O *= difu;\n    \n    // sky pattern\n    //if ( hit.w >= 90. ) O = vec4(.2,.4,.8,1.);\n    if ( hit.w >= 90. ) O=mix(vec4(.2,.4,.8,1.),vec4(1),clamp(height(U*vec2(.01,.1))*10.-9.,0.,1.));\n    \n    O = sqrt(O);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI (3.14159265)\n#define TAU (PI*2.)\n\n#define SINC(X) (sin(X)/(X))\n\nint inoisei(int a) {\n  a = (a * 54321) ^ (a * 14873);\n  a ^= a >> 16; // graycode\n  a ^= a >> 8;\n  a ^= a >> 4;\n  a ^= a >> 2;\n  a ^= a >> 1;\n  return a & 65535;\n}  \n\nfloat noisei(int a) {\n  return float( inoisei(a) & 65535 ) / 65536. ;\n}\n\nfloat noise(float a) { return noisei(int(a*1234.)); }\n\n#define RND0(L,H,IN) (noisei(IN)*(H-L)+L)\n#define RND(L,H,IN) (noise(IN)*(H-L)+L)\n\n#define FS iSampleRate\n\nfloat tonnos(float t,float f) {\n    float a = t*f;\n    int b = int(a);\n    return mix(noisei(b),noisei(b+1),smoothstep(0.,1.,fract(a))); // crude filter\n}\n\n\n\n#define FMT(FC,VOL,Q) max( 0., VOL - max(FC/har,har/FC) * Q )\n\nfloat voice(float time,float fc,float f1,float v1,float q1,float f2,float v2,float q2/*,float f3,float v3,float q3*/) {\n  float oo = 0.;\n  int cnt = 0;\n  for ( float har = fc; har < 12e3 && cnt++ < 30; har += fc ) {\n    oo += sin(TAU*time*har) * fc/har * ( \n      FMT(f1,v1,q1)  + FMT(f2,v2,q2)  // + FMT(f2,v2,q2)\n    );\n  }\n // oo += 1.*tonnos(FS*time*PI,f1);\n  return oo;\n}\n\nfloat voiceN3(float time,float fc1,float fc2,float fc3,float f1,float v1,float q1,float f2,float v2,float q2) {\n  return voice(time,fc1,f1,v1,q1,f2,v2,q2)+voice(time,fc2,f1,v1,q1,f2,v2,q2)+voice(time,fc3,f1,v1,q1,f2,v2,q2);\n}\n\n#define OSC(L,H,F) ((sin(TAU*gtime*(F))+1.)*.5*((H)-(L))+(L))\n\n/*\n#define F_i  SF( 290., 2200. )\n#define F_I  SF( 375., 2000. )\n#define F_u  SF( 340., 1250. )\n#define F_uu SF( 400., 1100. )\n#define F_o  SF( 425., 1000. )\n#define F_ee SF( 400., 2050. )\n#define F_cc SF( 560., 560. )\n#define F_A  SF( 690., 1400. )\n#define F_a  SF( 850., 1250. )\n#define F_ae SF( 875., 1500. )\n\n#define zSF(A,B)  A, 2.,.5, B, 2., .5 \n*/\n\n\n#define TT .5\n\n#define WHEN(T,CODE) if ( time < (T) ) { CODE; time = 10000.; } time -= (T);\n\nfloat vc1(float time,float FF) {\n\n    float f1, f2, notet, tt, fc, vc;\n\n#define SF(F,A,B) \\\n    if (fc==0.) fc=F, f1=A, f2=B; \\\n    if ( time < TT ) { \\\n        notet = TT - time; \\\n        tt = min( 1., (time)*4. ); \\\n        vc = voice( notet, \\\n            F - (fc-F)*time/2. , \\\n            mix(f1,A,tt), 5., 3.5 , \\\n            mix(f2,B,tt), 4., 3. ); \\\n        time += 1000.; \\\n    } \\\n    time -= TT; \\\n    f1 = A; \\\n    f2 = B; \\\n    fc = F; \\\n\n/*\n///WHEN(.5,vc+=.2*noisei(int(time*102312.)); )\n//WHEN(.3,vc+=voice(time,FF,4000.,2.,.2,12000.,2.,.2);)\n///WHEN(.5,vc+=voice(time,FF,690.,4.,3.,2400.,3.,2.);)\nWHEN(.5,vc+=mix(.4*noisei(int(time*102312.)),voice(time,FF,690.,4.,3.,2400.,3.,2.),time/.5);)\nWHEN(.5,vc+=voice(time,FF,690.,4.,3.,1400.,4.,3.);)\nWHEN(.5,vc+=mix(.2*noisei(int(time*102312.)),voice(time,FF,425.,4.,3.,1000.,3.,2.),time/.5);)\n*/\n\nSF( FF, 375., 2000. )\nSF( FF, 850., 1250. )\nSF( FF, 340., 1250. )\nSF( FF, 290., 2200. )\nSF( FF, 400., 1100. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 340., 1250. )\nSF( FF, 400., 1100. )\nSF( FF, 875., 1500. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\nSF( FF, 425., 1000. )\nSF( FF, 400., 2050. )\nSF( FF, 560., 560. )\nSF( FF, 690., 1400. )\n\n    return vc;\n    \n}\n\nfloat note(float time,float rep,float phs,float att,float dur,float dec) {\n  float t=mod(time-phs-att,rep);\n  return t<att ? t/att : t<att+dur ? 1. : exp(-(t-att-dur)/dec);\n}\n\nfloat rhyt(float time,float rep,float phs,float dec) {\n  return note(time,rep,phs,.0002,.0,dec);\n}\n\nfloat pat(float time,float rep,int pbt) {\n  return float((pbt>>int(mod(time,rep*16.)/rep))&1);\n}\n\nfloat ramp(float time,float rep,float lo,float hi) {\n  return fract(time/rep)*(hi-lo)+lo;\n}\n\nfloat stair(float val,float rise) {\n  return floor(val/rise)*rise;\n}\n\n#define ROUNDTO(X,Y) (round((X)/(Y))*(Y))\n\nfloat tonrmp(float time,float f1,float t1,float f2,float t2) {\n  t1=ROUNDTO(t1,f1);\n  t2=ROUNDTO(t2,f2);\n  return time<t1 ? f1 : \n    time<t2 ? f1+(f2-f1)*(time-t1)/(t2-t1)/2. :\n      f2;\n}\n\n#define w 1.\n#define h .5\n#define q .25\n#define e .125\n#define s (e/2.)\n\n// 12-tone notes\n#define C D f f\n#define D E f f\n#define E F f\n#define F G f f\n#define G A f f\n#define A 440.\n#define B A sh sh\n\n// Just intonation pitches for C, sort of\n#define JC *8./8.\n#define JD *9./8.\n#define JE *10./8.\n#define JF *11./8.\n#define JG *12./8.\n#define JA *13./8.\n#define JBb *14./8.\n#define JB *15./8.\n\n// accidentals\n#define sh * 1.05946\n#define f * 0.9438\n\nvec2 mainSound( int samp, float time )\n{\n\n//return .2*vec2(vc1(time,220.));\n\n    float vc = 0.;\n    \n   // vc += sin(TAU*time*200.)*exp(-.5*PI*time);\n    //return vec2(vc);\n   \n    //time += 52.;\n    //time += 44.;\n#if 0\n    if ( time < 22. ) {\n    \n        int secs = int(10.*TT);\n        float xtime = float(samp%(int(iSampleRate)*secs))/iSampleRate;\n\n        //xtime *= 1. + SINC(xtime*20.)*.02; // + SINC(xtime*2.)*.3;\n        \n        /*\n        int t1 = int(time)/secs%6;\n        float[] fcs=float[](220.,330.,110.,110.,55.,55.);\n        float f1=fcs[t1];\n        //float f2=fcs[t1+1];\n        float fc=f1; // tonrmp(time,f1,float(t1)+.7,f2,float(t1+1));\n        */\n\n        vc += vc1(\n          xtime,\n          //fc\n          float[](220.,330.,110.,110.,55.,55.)[int(time)/secs%6]\n        );\n\n    }\n#endif\n /*   \n    if ( time > 18. && time < 54. )\n    {\n        float yy=0.;\n        for ( float ii = 6.; ii < 11.; ++ii ) {\n            float ttime = (time+ii/6.)*2.;\n            float ntime = fract(ttime);        \n            int ndx = int(floor(ttime));\n            yy += .3*voice( ntime,\n                time<23.?80.:20.*ii,\n                RND0(250.,1000.,ndx+2+int(ii)), 4., 3.,\n                RND0(350.,2000.,ndx+4+int(ii)), 4., 3.);\n        }\n        vc = mix(vc,yy,clamp(0.,1.,(time-18.)/4.));\n       \n    }\n */\n    float xtime = time ;//- 48.;\n    if ( xtime > 0.) {\n   // vc=0.;\n        //vc *= smoothstep( 3., 0., time-20. );\n      //  vc += tonnos(time,TAU*2000.) ; // * rhyt(time,1.,0.,.5);\n        float yy=0.;  \n        if ( xtime > 8.*1. )\n        yy += tonnos(xtime, noisei(int(xtime/e)) > .5 ? 16000. : 2000.) * rhyt(xtime,e,0.,s*.7);\n        if ( xtime > 8.*0. ) {\n        yy += .8*tonnos(xtime, noisei(1+int(xtime/h)) > .5 ? 400. : 8000.) * rhyt(xtime,q,0.,s);\n        if ( xtime > 8.*2. ) {\n        yy += tonnos(xtime, stair(ramp(xtime+2.,w*2.,20000.,120.),2000.)) * rhyt(xtime,h,0.,q);\n        yy += sin(mod(time*TAU*12000.,TAU)) * rhyt(xtime,w,q+q+q,e);\n        if ( xtime > 8.*3. ) {\n\n        \n \n        xtime=mod(xtime,1.);\n        //float[] fcs=float[](1.,2.,1./2.,3./2.,2./3.,4./5.,5./4.);\n        //xtime=xtime * (1. + SINC(time*10.)*.1);\n        float fc = 880.;\n        float fc1=fc * (1. + SINC(xtime*40.)*.03*note(time,w*4.,0.,h,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc2=fc * (1. + SINC(xtime*30.)*.03*note(time,w*4.,0.,w,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc3=fc * (1. + SINC(xtime*35.)*.03*note(time,w*4.,0.,h+q,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        //yy=0.;\n        //yy += vc1( xtime, fc ) * note(time,3.*w,0.,e,e,e);\n        yy += .25*voiceN3( xtime,\n                  //fc*fcs[inoisei(int(time/4.)+1)%7],\n                  //fc*fcs[inoisei(int(time/4.)+2)%7],\n                  //fc*fcs[inoisei(int(time/4.)+3)%7],\n                  fc1, fc2*5./4., fc3*1.5,\n                  RND0(200.,1200.,int(time/4.)), //tonnos(time,1./w/8.)*1000.+250.,\n                  4., 3.,\n                  RND0(1200.,4800.,int(time/4.)), //tonnos(time+.1,1./w/8.)*3000.+350.,\n                  4., 3.)\n               * note(time,w*4.,q,q,h,q);\n               \n        } } }\n        vc = mix(vc,yy,1.);//clamp(0.,1.,(time-48.)/6.));\n    }\n    \n    return .15*vec2(vc);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}