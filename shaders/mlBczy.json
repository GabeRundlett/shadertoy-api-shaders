{
    "Shader": {
        "info": {
            "date": "1691932972",
            "description": "This is a 3D material using Directional Flow with a novel Tiling method that allows me to half the performance cost. It is also great at visualizing vector fields as a wind wave",
            "flags": 0,
            "hasliked": 0,
            "id": "mlBczy",
            "likes": 8,
            "name": "Wind Waves 3D",
            "published": 3,
            "tags": [
                "3d",
                "waves",
                "cheap",
                "tiling",
                "flowmap",
                "wind",
                "vectorfield",
                "rhombicdodecahedron"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis 3D material leverages Directional Flow with an innovative tiling technique, \neffectively reducing performance costs by half. The shader employs 4 Rhombic \nDodecahedron grid tiles for optimized sampling of 4 points in space, achieving \nTrilinear interpolation quality with only 4 samples. Importantly, as a 3D \nmaterial rather than a projected 2D material, it remains distortion-free across \nany surface.\n\nThis implementation also serves as a valuable tool for visualizing 3D vector \nfields on a surface, evoking the appearance of wind waves where vector direction \naligns perpendicular to the displayed wave. The current vector field originates \nfrom sampling a noise texture.\n\nFor a standalone quadripel Rhombic Dodecahedron Tiling technique, please visit:\nhttps://www.shadertoy.com/view/fddfRn\n\nFor a 2D variant of wind waves employing 3 samples see:\nhttps://www.shadertoy.com/view/7ddBWl\n*/\n\n// highlight the blend regions. Comment to hide\n//#define SHOWBLEND // it also helps reducing the gridscale a bit\n#define LINETHICKNESS 0.01\n\n#define GRIDSCALE 6.0\n// 1 for no contrast between samples, higher values for increased contrast\n#define CONTRAST 1.0\n\n#define twoPi           6.2831853072\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 hra = vec3(0.5, 0.5, half_sqrt2); //vector to Diagonal Edge\n    p = abs(p);\n    float pBC = max(p.x,p.y); //rigt and top edge\n    float pABC = max(dot(p, hra),pBC); //diagonal edge\n    \n    //optional 0-1 range\n    return (.5-pABC)*2.;\n}\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n    vec3 r = vec3(1.0,1.0,sqrt2);\n    vec3 h = r*.5;\n\n    vec3 a = mod(uvw, r)-h;\n    vec3 b = mod(uvw-h,r)-h;\n    \n    vec3 gvw = dot(a, a) < dot(b,b) ? a : b; //center rhom uvw\n    float edist = rhomDist(gvw); //Edge distance with range 0-1\n    //float cdist = dot(gvw, gvw); // squared distance with range 0-1\n    vec3 id = uvw-gvw; // simple ID calculation\n    \n    return tilingVal3D(gvw, id, edist);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n    tilingVal3D rohmTiling = rohmTile(uvw*gridRes + offset);\n    vec3 tiledUV = (rohmTiling.id - offset)/gridRes; //rohm pixaltion    \n    return tilingVal3D(rohmTiling.grid, tiledUV,rohmTiling.alpha);\n}\n\nvec2 rohmSinWave(vec3 uvw, vec3 offset, float gridRes, float time) {\n    // generate grid\n    tilingVal3D cell = rohmCell(uvw, offset, gridRes);\n\n    // Sample vector field/flow map\n    vec3 noise = texture(iChannel0, cell.id * 0.07).xyz;\n    vec3 flowMap = noise * 2.0 - 1.0; // Scale to -1 to 1\n    float vectorScale = 1.0;\n    flowMap *= vectorScale;\n    \n    // kind of arbitrarily chosen for what looks nice\n    float speed = length(flowMap); // Wind Speed \n    //speed = sqrt(speed); // make distribution nicer\n    vec3 dir = normalize(flowMap); // Wind Direction\n    float k = twoPi / speed; //Wave Number\n    time *= speed;\n    float amplitude = speed;   \n    \n    // scale grid to make sure largest waves are still smaller than grid\n    cell.grid *= 8.0;\n    \n    float dD = dot(cell.grid,dir); //Directional/Straight Wave\n    float wave = sin(k * (dD - time))*.5+.5; // make sin wave\n    wave *= amplitude; // apply amplitude\n\n    return vec2(wave, cell.alpha);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast, float time) {\n    vec2 a = rohmSinWave(uvw, vec3( .0, .0, .0), gridRes, time);\n    vec2 b = rohmSinWave(uvw, vec3( .5, .0, qurt_sqrt2), gridRes, time);\n    vec2 c = rohmSinWave(uvw, vec3( .0, .5, qurt_sqrt2), gridRes, time);\n    vec2 d = rohmSinWave(uvw, vec3( .0, .0, half_sqrt2), gridRes, time);\n           \n    // increase contrast\n    vec4 alpha = smoothContrast(vec4(a.y, b.y, c.y, d.y), contrast);\n        \n    // interpolate UVWs cause shadertoy doesn't have nice 3d Textures\n    vec3 col = vec3(a.x * alpha.x + b.x * alpha.y + c.x * alpha.z + d.x * alpha.w);\n\n#ifdef SHOWBLEND\n    // the edges of the alpha mask blending\n    vec4 blend = step(abs(alpha - 0.1), vec4(LINETHICKNESS));\n    col = max(max(blend.xyz,vec3(blend.w)), col);\n#else\n    // cell shading\n    float levels = 3.;\n    //col =  round(col*levels)/levels;\n    \n    col = PuBu_r(col.x); // apply colormap for blueish colors\n#endif\n    return col;\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec2 iSphere(in vec3 ro, in vec3 rd) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    //if(h <0.0) return vec2(-1.);\n    return vec2(-b - sqrt(h), h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx = mm2(iTime*.1+um.x*5.);\n    mat2 my = mm2(iTime*0.05+um.y*5.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec2 t = iSphere(ro,rd);\n    \n    vec3 colorA;\n    if (t.x > 0.) {\n    \tvec3 pos = ro+rd*t.x;\n        // Sphere mapping\n    \tcolorA = quadGrid(pos, GRIDSCALE, CONTRAST, iTime *1.0);\n        colorA *= 1.1;\n    }\n    \n    // Background mapping\n    vec3 colorB = quadGrid(rd, GRIDSCALE, CONTRAST, iTime *1.0)*0.6;\n    \n    // Smooth blending of ball with background\n    vec3 color = mix(colorA, colorB, smoothstep(0.02, 0.0, t.y));\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "//_____________________GENERIC FUNCTIONS______________________________\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n// makes PuBu_r colormap with polynimal 6\nvec3 PuBu_r(float t) {\n    const vec3 c0 = vec3(-0.006363,0.212872,0.336555);\n    const vec3 c1 = vec3(1.081919,1.510170,1.985891);\n    const vec3 c2 = vec3(-14.783872,-6.062404,-2.068039);\n    const vec3 c3 = vec3(71.020484,24.455925,-4.350981);\n    const vec3 c4 = vec3(-127.620020,-46.977973,14.599012);\n    const vec3 c5 = vec3(101.930678,41.789097,-14.293631);\n    const vec3 c6 = vec3(-30.634205,-13.967854,4.778537);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}