{
    "Shader": {
        "info": {
            "date": "1570996738",
            "description": "Another simple ray tracer",
            "flags": 0,
            "hasliked": 0,
            "id": "3sVGWV",
            "likes": 1,
            "name": "Jake's Better Raytracer",
            "published": 3,
            "tags": [
                "raytracer"
            ],
            "usePreview": 0,
            "username": "JakeLockey",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "vec3 pixCol = vec3(0.5,0.5,0.5);\n\nstruct Light{\n    vec3 pos;\n};\nLight light = Light(vec3(-5.0,0.0,10.0));\n    \nstruct Camera{\n    vec3 pos;\n    vec3 dir;\n};\nCamera Cam = Camera(vec3(-1.0,7.0,6.0),vec3(0.0,-1.0,-0.9));\n\nstruct Sphere{\n    vec3 pos;\n    float r;\n    vec3 col;\n};\nSphere S1 = Sphere(vec3(0.0,0.0,0.0),1.0,vec3(1.0,1.0,1.0));\nSphere S2 = Sphere(vec3(0.0,0.0,1.5),0.7,vec3(1.0,1.0,1.0));\nSphere S3 = Sphere(vec3(0.0,0.0,2.5),0.5,vec3(1.0,1.0,1.0));\nSphere S4 = Sphere(vec3(-0.2,0.4,2.75),0.1,vec3(0.0,0.0,0.0));\nSphere S5 = Sphere(vec3(0.2,0.4,2.75),0.1,vec3(0.0,0.0,0.0));\n\nstruct Triangle{\n    vec3 Vert1;\n    vec3 Vert2;\n    vec3 Vert3;\n    vec3 col;\n};\nTriangle T1 = Triangle(vec3(5.0,5.0,-1.0), vec3(5.0,-5.0,-1.0), vec3(-5.0,5.0,1.0), vec3(0.7,0.7,0.7));\nTriangle T2 = Triangle(vec3(5.0,-5.0,-1.0), vec3(-5.0,-5.0,1.0), vec3(-5.0,5.0,1.0), vec3(0.8,0.8,0.8));\nTriangle T3 = Triangle(vec3(-5.0,5.0,1.0), vec3(5.0,-5.0,-1.0), vec3(5.0,5.0,-1.0), vec3(0.7,0.7,0.7));\nTriangle T4 = Triangle(vec3(-5.0,5.0,1.0), vec3(-5.0,-5.0,1.0), vec3(5.0,-5.0,-1.0), vec3(0.8,0.8,0.8));\n    \nstruct SceneObjects{\n    Sphere[5] spheres;\n    Triangle[4] triangles;\n};\nSceneObjects objects;\n\nvec3 checkCollide(vec3 Origin, vec3 rayDir){\n    float closestP = -1.0;\n    int objectNum = -1;\n    int SphereOrTriangle = -1;\n    for(int i = 0; i<objects.spheres.length(); i++){\n        Sphere tempS = objects.spheres[i];\n        \n        vec3 L = (tempS.pos-Origin);\n    \tfloat tca = dot(L,rayDir);\n    \n    \n    \tif(tca<=0.0){\n    \t   \tcontinue;\n    \t}\n    \n    \tfloat d = sqrt(dot(L,L)-(tca*tca));\n    \n    \tif(d>=tempS.r && d!=0.0){\n    \t    continue;\n    \t}\n    \n    \tfloat thc = sqrt((tempS.r*tempS.r)-(d*d));\n    \tfloat distToPoint= tca-thc;\n        \n        if(i==0||closestP==-1.0){\n            closestP = distToPoint;\n            SphereOrTriangle = 0;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphereOrTriangle = 0;\n        \tobjectNum = i;\n        }\n    \t\n    }\n    \n    for(int i = 0; i<objects.triangles.length(); i++){\n        Triangle tempT = objects.triangles[i];\n        \n        vec3 normal = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n        \n        //Test if ray is parallel to plane \n        if(dot(rayDir,normal)<0.001){\n            continue;\n        }\n        \n        vec3 p0l0 = tempT.Vert1 - Origin;\n        \n        //Dist to Intersection Point on plane\n        float distToPoint = dot(p0l0,normal) / dot(rayDir,normal);\n        if(distToPoint<0.0){\n            continue;\n        }\n        \n        vec3 P = Origin + rayDir*distToPoint; //Point of intersection\n        \n        //Check to see if ray is within the triangle\n        vec3 C;\n        //edge 1\n        vec3 edge1 = tempT.Vert2 - tempT.Vert1;\n\t\tvec3 vp1 = P - tempT.Vert1;\n        C = cross(edge1,vp1);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 2\n        vec3 edge2 = tempT.Vert3 - tempT.Vert2;\n\t\tvec3 vp2 = P - tempT.Vert2;\n        C = cross(edge2,vp2);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        //edge 3\n        vec3 edge3 = tempT.Vert1 - tempT.Vert3;\n\t\tvec3 vp3 = P - tempT.Vert3;\n        C = cross(edge3,vp3);\n        if(dot(normal,C)<0.0){\n            continue;\n        }\n        \n        \n        \n        if(closestP==-1.0){\n            closestP = distToPoint;\n            SphereOrTriangle = 1;\n        \tobjectNum = i;\n        }\n        else if(distToPoint<closestP){\n            closestP = distToPoint;\n            SphereOrTriangle = 1;\n        \tobjectNum = i;\n        }\n        \n    }\n    \n    return vec3(closestP,SphereOrTriangle,objectNum);\n    \n    \n}\n\nbool checkShadow(vec3 P){\n    vec3 ray = light.pos-P;\n    vec3 rayDir = ray/length(ray);\n    //P = P-(0.00001*rayDir);\n    \n    \n    float distToPoint = checkCollide(P,rayDir).x; //Checks collison to light\n    \n    //If the ray has collided, and it is closer than the light source\n    if(distToPoint!=-1.0 && length(ray)>distToPoint){ \n        return true;\n    }\n    return false;\n}\n\nvoid castRay(vec2 xy){\n    float ratio = Cam.dir.z/length(Cam.dir.xy);\n    vec3 VertPerp = vec3(-Cam.dir.x*ratio, -Cam.dir.y*ratio, length(Cam.dir.xy));\n    vec3 yComp = VertPerp * xy.y;\n    \n    vec3 HoriPerp = vec3(Cam.dir.y,-Cam.dir.x,0.0)/length(vec3(Cam.dir.y,-Cam.dir.x,0.0));\n    vec3 xComp = HoriPerp * xy.x;\n    \n    vec3 ray = (Cam.dir*3.0)+xComp+yComp;\n    vec3 rayDir = (ray/length(ray));\n    \n    vec3 Collision = checkCollide(Cam.pos,rayDir);\n    if(Collision.x>0.0){\n        if(int(Collision.y)==0){ //Sphere\n        \tpixCol = objects.spheres[int(Collision.z)].col;\n            vec3 P1 = Cam.pos + (rayDir*Collision.x);\n        \tif(checkShadow(P1)){ //Checks if in shadow\n            \tpixCol = objects.spheres[int(Collision.z)].col/3.0;\n        \t}\n        }\n        if(int(Collision.y)==1){ //Triangle\n            Triangle tempT = objects.triangles[int(Collision.z)];\n            pixCol = tempT.col;\n            vec3 P1 = Cam.pos + (rayDir*Collision.x);\n            vec3 normal = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));\n            P1 = P1 + normal*(-0.00001);\n        \tif(checkShadow(P1)){ //Checks if in shadow\n           \t\tpixCol = objects.triangles[int(Collision.z)].col/3.0;\n        \t}\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 LookAt = vec3(0.0,0.0,0.5);\n    Cam.dir = (LookAt-Cam.pos)/length(LookAt-Cam.pos);\n    \n    light.pos = vec3(75,0.0,75);\n    //light.pos = vec3(100.0*sin(iTime/5.0),0.0,100.0-abs(100.0*sin(iTime/5.0)));\n    //S2.pos = vec3(0.0,sin(iTime)+1.0,0.0);\n    \n    T1.Vert3.z = 10.0*sin(iTime)+5.0;\n    T2.Vert2.z = T1.Vert3.z;\n    T2.Vert3.z = T1.Vert3.z;\n    T4.Vert1.z = 10.0*sin(iTime)+5.0;\n    T4.Vert2.z = T4.Vert1.z;\n    T3.Vert1.z = T4.Vert1.z;\n    \n    Sphere[5] spheres = Sphere[](S1,S2,S3,S4,S5);\n\tTriangle[4] triangles = Triangle[](T1,T2,T3,T4);\n    \n    \n    objects = SceneObjects(spheres,triangles);\n    \n    \n    vec2 xy = vec2((2.0*(iResolution.x/iResolution.y)) * fragCoord.x/iResolution.x - (iResolution.x/iResolution.y), 2.0 * fragCoord.y/iResolution.y - 1.0);\n   \t\n    vec3 col = vec3(0.5,0.5,0.5);\n    \n    castRay(xy);\n    \n    col = pixCol;\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}