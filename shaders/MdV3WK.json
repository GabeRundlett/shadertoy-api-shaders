{
    "Shader": {
        "info": {
            "date": "1456936149",
            "description": "Trying some effects with just a plane of cubes...",
            "flags": 0,
            "hasliked": 0,
            "id": "MdV3WK",
            "likes": 2,
            "name": "Playing with cubes",
            "published": 3,
            "tags": [
                "cubes",
                "raymaching"
            ],
            "usePreview": 0,
            "username": "ManuManu",
            "viewed": 624
        },
        "renderpass": [
            {
                "code": "\n\n//#define CURVE_WORLD\n\n#define FISH_EYE1 0\n#define FISH_EYE2 0\n\n\n#define NB_ITER 256\n#define FAR \t200.\n\n#define PI 3.14159265\n\n\nvec3 skyColor( vec2 uv)\n{\n    return vec3(.0);\n\tvec3 colEdge \t= vec3(.1, .5, .3);\n\tvec3 colCenter  = vec3(.0);\n\treturn mix (colEdge, colCenter, 1.-length(uv ) / .9);\n}\n\n\nfloat Mylength( vec3 pos )\n{\n\treturn max(abs(pos.x), max( abs(pos.y), abs( pos.z)) );\n}\n\n\nvec3 rotationPos( vec3 pos, float angle )\n{\n    angle = mod(angle, 2.*PI);\n    float c=cos(angle);\n    float s=sin(angle);\n    mat3 m = mat3( 1., 0., 0.,\n                   0.,  c,  s,\n                   0., -s,  c );\n    return m*pos;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// it's nicer with rounded boxes :\nfloat cubeDist( vec3 pos, float radius)\n{\n    return udBox( pos, vec3(radius)) -.6;\n}\nfloat cubeDist2( vec3 pos, float radius)\n{\n    return Mylength( pos ) - radius;\n}\n\nfloat timeBorner( float t, float t1, float t2)\n{\n    return step( t1, t ) * ( 1.-step( t2, t ));\n}\n\n// 25 seconds\nvec3 intro( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    pos.z += 65.;\n    \n    if ( t > 10.)\n    {\n        if ( t > 20.)\n            pos.z -= 65.;\n        else\n            pos.z -= mix( .0, 65., (t-10.)/10.);\n    }       \n            \n    pos = rotationPos(pos, PI*3.*cos(.3*t));\n \n    return pos;\n}\n// 50 seconds\nvec3 firstPart( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    \n    float s = .0;\n    float upperlimit =  30.*timeBorner(t, 0., 5.)+\n        \t\t\t\t20.*timeBorner(t, 5., 10.)+\n        \t\t\t\t10.*timeBorner(t, 10., 15.)+\n        \t\t\t\t03.*timeBorner(t, 15., 49.);\n    float upperlimity = 30.*timeBorner(t, 20., 23.)+\n        \t\t\t\t10.*timeBorner(t, 23., 27.)+\n        \t\t\t\t03.*timeBorner(t, 27., 42.);\n    float sint = 3.*sin( 2.*t / PI );\n    float dist = mod(2.*sint, upperlimit);\n    float disty = mod(2.*t, upperlimity);\n    float i2 = mod( i, upperlimit);\n    float j2 = mod( j, upperlimity);\n    s = PI*t * (1.-step( dist, i2) ) * step( dist, i2 +1.);\n    if ( t > 20.)\n    \ts+=PI*t * (1.-step( disty, j2) ) * step( disty, j2 +1.);\n \tpos = rotationPos( pos, s );\n    return pos;\n}\n// 40 seconds\nvec3 secondPart( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    \n    i-= 18.;\n    j-= 17.;\n\n    float s = .0;\n    const float upperlimit = 100.;\n    float dist = mod(5.*t, upperlimit); \n    s =PI*t * (1.-step( dist, i*i+j*j) );\n    if (t > 20.)\n    \tcol = mix(col1, col2, (1.-step( dist, i*i+j*j) ));\n \tpos = rotationPos( pos, s );\n    return pos;\n}\n// 70 seconds\nvec3 thirdPart( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    \n    i-= 18.;\n    j-= 17.;\n    \n\tif ( t > 35.)\n    {\n        pos.z -= mix( .0, 120., (t-35.)/35.);\n    }\n    \n    float i2 = mod( i + 15., 30.)-15.;\n    float j2 = mod( j + 15., 30.)-15.;\n\n\n    float s = .0;\n    float dist = 60. + 40.*cos(5.*t);\n    col = mix(col1, col2, (1.-step( dist, i2*i2+j2*j2) ));\n    \n\ts += sin(t+j)*sin(t+j)\t\t\t\t\t\t   * timeBorner(t, .0, 5.);\n    s += (5.*i + 8.*j + iTime) \t\t\t   * timeBorner(t, 5., 10.);\n    s += sin(t+j)*sin(t+j) * sin(t+i)*sin(t+i)\t   * timeBorner(t, 10., 15.);\n    s += sin(t + i - j )\t\t\t\t\t\t   * timeBorner(t, 15., 20.);\n    s += sin( .01*(i*i) - 5.*iTime)\t\t   * timeBorner(t, 20., 25.);\n    s += sin( .01*(j*j) - 5.*iTime)\t\t   * timeBorner(t, 25., 30.);\n    s += sin( .01*(i*i+j*j) - 2.*iTime)\t   * timeBorner(t, 30., 35.);\n \tpos = rotationPos( pos, s );\n\n    return pos;\n}\nvec3 fourthPart( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    \n    i-= 18.;\n    j-= 17.;\n    \n    pos.z -= mix( 0., 120., 1.-t/40.);\n    \n    float i2 = mod( i + 15., 30.)-15.;\n    float j2 = mod( j + 15., 30.)-15.;\n\n\n    float s = .0;\n    float dist = 60. + 40.*cos(5.*t);\n    float val1 = .5 + .5*sin( 5.*i + 8.*j + 20.* t);\n    float val2 = .5 + .5*sin( .01*(i*i+j*j) - 2.*iTime);\n    float val = mix( val1, val2, mod( t, 20.) / 20. );\n    if ( t > 20.)\n    \tval = mix( val1, val2, mod( t, 20.) );\n    col = mix(col1, col2, val);\n    \n    \n\ts += sin(t+j)*sin(t+j)\t\t\t\t\t\t   * timeBorner(t, .0, 5.);\n    s += (5.*i + 8.*j + iTime) \t\t\t   * timeBorner(t, 5., 10.);\n    s += sin(t+j)*sin(t+j) * sin(t+i)*sin(t+i)\t   * timeBorner(t, 10., 15.);\n    s += sin(t + i - j )\t\t\t\t\t\t   * timeBorner(t, 15., 20.);\n    s += sin( .01*(i*i) - 5.*iTime)\t\t   * timeBorner(t, 20., 25.);\n    s += sin( .01*(j*j) - 5.*iTime)\t\t   * timeBorner(t, 25., 30.);\n    s += sin( .01*(i*i+j*j) - 2.*iTime)\t   * timeBorner(t, 30., 35.);\n \tpos = rotationPos( pos, s );\n\n    return pos;\n}\n\nvec3 choreo( vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    col = col1;\n\n    float t;\n    vec3 p;\n    \n    // for tests :\n    //t = mod(iTime, 40.);\n\t//p = fourthPart(t, pos, i, j, col);\n    \n  \n\tt = mod(iTime, 250.);\n    if ( t < 25.)\n        p = intro( t, pos, i, j, col);\n\telse if ( t < 75.)\n\t\tp = firstPart( t-25., pos, i, j, col);\n\telse if ( t < 115.)\n\t\tp = secondPart( t-75., pos, i, j, col);\n\telse if ( t < 185.)\n\t\tp = thirdPart( t-115., pos, i, j, col);\n    else if ( t < 225.)\n\t\tp = fourthPart( t-185., pos, i, j, col);\n\telse\n        p = intro( 250.-t, pos, i, j, col);\n    return p;\n}\n\nvec4 cubes(vec3 pos )\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    pos.z -= 70.;\n\n    const float repVal = 2.;\n\n    //indexes :\n\tfloat i = float( int ( (pos.x+2.) / 4. ) );\n    float j = float( int ( (pos.y+2.) / 4.) );\n\n    \n    // repetition :\n    pos = vec3( mod( pos.x + repVal, 2.*repVal) - repVal,\n                mod( pos.y + repVal, 2.*repVal) - repVal,\n                pos.z);\n    \n    vec3 col;\n    pos = choreo( pos, i, j, col );\n    float dist = cubeDist( pos, 1.);\n    return vec4( col, dist);\n}\n\nvec4 map( vec3 pos)\n{\n\treturn cubes(pos);\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 norm)\n{\n    const int steps = 3;\n    const float delta = 0.50;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(pos + norm*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 15; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t).w;\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -= .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\t//uv.x += cos( 10.*uv.y)*1.;\n    float time = iTime;\n\n#if FISH_EYE1\n\tfloat fish_eye =  -length(uv)*1.+ .5*sin(time);\n#elif FISH_EYE2\n\tfloat fish_eye = sin(5.*uv.x + time*1.) + sin(5.*uv.y+time*.5) + 1.;\n#else\n\tfloat fish_eye =  0.;\n#endif\n\tvec3 dir = vec3( uv, 1.0 + fish_eye);\n\tdir = normalize(dir);\n\t\n#ifdef CURVE_WORLD\n\tvec3 pos = vec3( 20.*sin(time), 8.1, 20.*cos(time));\n#else\n    vec3 pos = vec3( 70.0, 70.0, .0);\n#endif // CURVE_WORLD\n\t\n\tfloat nbIterF = 0.;\n\tvec4 result;\n\tfor (int i =0; i < NB_ITER; i++)\n\t{\n\t\tresult = map( pos );\n\t\tpos += result.w * dir;\n\t\tif ( (pos.z > FAR) || (abs(result.w) < .001)) \n            break;\n\t\tnbIterF += 1.0;\n#ifdef CURVE_WORLD\n\t\tdir.xy=rot(dir.xy,result.w*0.021);\n\t\tdir.yz=rot(dir.yz,result.w*0.01);\n\t\tdir.zx=rot(dir.zx,result.w*0.01);\n#endif // CURVE_WORLD\n    }\n\tvec3 col = result.xyz;\n\tif ( pos.z> FAR ) \n\t{\n\t\tcol = skyColor(uv);\n\t}\n\telse\n\t{\n\t\tvec3 lightPos = vec3(1.* sin(3.*iTime) + 100., 8.5, 1.*cos(3.*iTime)  - 200. );\n\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\tvec3 eps = vec3( .1, .0, .0 );\n\t\tvec3 n = vec3( result.w - map( pos - eps.xyy ).w,\n\t\t\t       result.w - map( pos - eps.yxy ).w,\n\t\t\t       result.w - map( pos - eps.yyx ).w );\n\t\tn = normalize(n);\n\t\t\t\t\n\t\tfloat lambert = max(.0, dot( n, light2Pos))+.2;\n\t\tcol *= vec3(lambert);\n\t\t\n\t\n\t\t// specular : \n\t\tvec3 h = normalize( -dir + light2Pos);\n\t\tfloat spec = max( 0., dot( n, h ) );\n\t\tcol += vec3(pow( spec, 32.));\n\t\t//col *= ambientOcclusion( pos, n );\n\t\t//col *= softshadow(pos, light2Pos, .02, 5., 14. );\t\t\n\t}\n\tfragColor= vec4( col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}