{
    "Shader": {
        "info": {
            "date": "1721296306",
            "description": "Find circle intersection of a ray starting inside the circle.",
            "flags": 0,
            "hasliked": 0,
            "id": "XcXyz2",
            "likes": 1,
            "name": "Internal ray-circle intersect 2D",
            "published": 3,
            "tags": [
                "ray",
                "intersection",
                "circle",
                "internal",
                "check"
            ],
            "usePreview": 0,
            "username": "Mytino",
            "viewed": 93
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    float scale = 1000.0 / iResolution.x;\n   \n    vec2 p = (fragCoord - iResolution.xy * 0.5) * scale;\n    vec2 p0 = (abs(iMouse.zw) - iResolution.xy * 0.5) * scale;\n    vec2 to = (abs(iMouse.xy) - iResolution.xy * 0.5) * scale;\n    vec2 dir = normalize(to - p0);\n    \n    float r = 200.0;\n    \n    float a = p0.x, b = p0.y;\n    float u = dir.x, v = dir.y;\n    float t = (sqrt(-a*a*v*v + 2.0*a*b*u*v - b*b*u*u + r*r*(u*u+v*v)) - a*u - b*v) / (u*u + v*v);\n    vec2 intersection = p0 + dir * t;\n    \n    if (p.x * p.x + p.y * p.y < r * r) {\n        col = vec3(0.3);\n    }\n    \n    float colArrow = sdf_arrow(p - p0, length(to - p0), normalize(to - p0), 3.0, 1.0);\n    colArrow = smoothstep(1.5, 0.0, colArrow);\n    col += vec3(colArrow);\n    \n    if (length(p - intersection) < 8.0) col = vec3(1, 0, 0);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265358979\n#define TAU (2.0 * PI)\n\n// ------------------------------------------------------------------------------------------------\nfloat m_stretch(float point, float stretch){\n    return .5 * (sign(point) * stretch - point) * (sign(abs(point) - stretch) + 1.);\n}\n\n#define m_stretch_neg(p, st) (.5 * m_stretch(2. * p + st, st))  /* Stretch-negative: positive values are fixed */\n#define m_stretch_pos(p, st) (.5 * m_stretch(2. * p, st))  /* Stretch-positive: negative values are fixed */\n\n// A fast \"manual\" lossy rotate function by ollj.\n// Control the angle of rotation by specifying the ROTATE_PARAM constants.\n// https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nfloat ollj_rotate(vec2 uv){\n    const float ROTATE_PARAM0 = sqrt(1.);  // Try changing these!\n    const float ROTATE_PARAM1 = sqrt(.0);\n    return dot(uv, vec2(ROTATE_PARAM0 + ROTATE_PARAM1, ROTATE_PARAM0 - ROTATE_PARAM1));\n}\n\n// NOTE: Very slightly modified - Mytino.\n// Optimized arrow SDF, by ollj\n// @head_len isn't actual uv units, but the unit size depends on ROTATE_PARAMs\nfloat sdf_arrow(vec2 uv, float norm, vec2 dir, float head_height, float stem_width){\n    uv = vec2(dir.x * uv.x + dir.y * uv.y, -dir.y * uv.x + dir.x * uv.y);\n\n    norm -= head_height;  // Make sure the norm INCLUDES the arrow head\n    uv.x -= norm;  // Place the arrow's origin at the stem's base!\n\n    uv.y = abs(uv.y);\n    float head = max(ollj_rotate(uv) - head_height, -uv.x);\n\n    uv.x = m_stretch_neg(uv.x, norm);\n    uv.y = m_stretch_pos(uv.y, stem_width);\n    float stem = length(uv);\n\n    return min(head, stem);  // Join head and stem!\n}\n// ------------------------------------------------------------------------------------------------",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}