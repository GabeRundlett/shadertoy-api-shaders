{
    "Shader": {
        "info": {
            "date": "1570725039",
            "description": "Not exactly the freezing process, but it's something. Mouse y controls the melting/freezing.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sVGR3",
            "likes": 16,
            "name": "Inktober2019 04: freeze",
            "published": 3,
            "tags": [
                "drop",
                "ice",
                "melt",
                "freeze",
                "inktober",
                "shadertober",
                "inktober2019",
                "icicle"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "#define PERIOD 5.\n#define COLOR vec3(.7, .9, .9)\n#define ROUNDNESS .06\n#define DROP_SIZE .06\n#define EDGE .05\n#define GRAVITY 50.\n\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\nfloat opSU(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdIcicle(vec2 p, vec2 size) {\n    p = vec2(abs(p.x), p.y + size.y);\n    float s = dot(p, normalize(vec2(size.y, -size.x)));\n    return (dot(p, size) > 0.) ? s : length(p);\n}\n\nfloat sdFullCicle(vec2 p, vec2 q, inout float w, float offset, vec2 size, float t) {\n    p.x -= offset;\n    q.x -= offset;\n    q = mix(q, p, smoothstep(-.2, -.05, -size.y - p.y));\n    t = fract(t);\n    float d = sdIcicle(q, size) - ROUNDNESS;\n    float drop1 = - size.y - GRAVITY * t * t;\n    float drop2 = - size.y + 1. - t;\n    d = opSU(d, distance(p, vec2(0, drop1)) - DROP_SIZE, ROUNDNESS);\n    d = opSU(d, distance(p, vec2(0, drop2)) - DROP_SIZE, ROUNDNESS);\n    float arrival = t - sqrt((2. - size.y) / GRAVITY);\n    p.x = abs(p.x);\n    w += smoothstep(.1, .0, abs(arrival - .1)) *\n         cos(p.x * 20. - (arrival) * 100.) *\n\t\t smoothstep(-.1, .0, p.x - arrival) *\n         smoothstep(.4, .0, p.x) * .02;\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float color = 0.;\n    \n    float res = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / res;\n    \n    if (abs(uv.x) < .45 && uv.y < .45) {\n        float t = fract(iTime / PERIOD);\n\t    vec2 p = uv / .45;\n        p.y -= 1.;\n        \n        float melt = (iMouse.z > 0.) ? 1.4 - iMouse.y / iResolution.y * 1.3 : 1.;\n        \n        vec2 q = p;\n        q+= sin(q.yx * 5.) * .01;\n        q.x-= sin(q.y * 20.) * .005;\n        q.y-= sin(q.y * 50.) * .002;\n        \n        float d = - p.y - .1;\n        float wave = 0.;\n        \n        d = opSU(d, sdFullCicle(p, q, wave, -.75, vec2(.1, 1.2 * melt), t + .1), ROUNDNESS * 2.);\n        d = opSU(d, sdFullCicle(p, q, wave, -.4, vec2(.1, .7 * melt), t + .7), ROUNDNESS * 2.);\n        d = opSU(d, sdFullCicle(p, q, wave, -.1, vec2(.2, .2 * melt), t + .2), ROUNDNESS * 2.);\n        d = opSU(d, sdFullCicle(p, q, wave, .15, vec2(.1, .5 * melt), t + .5), ROUNDNESS * 2.);\n        d = opSU(d, sdFullCicle(p, q, wave, .5, vec2(.1, .8 * melt), t + .9), ROUNDNESS * 2.);\n        d = opSU(d, sdFullCicle(p, q, wave, .8, vec2(.1, .3 * melt), t + .4), ROUNDNESS * 2.);\n        \n        d = opS(d, d + EDGE - sin(q.y * 50.) * .004 * smoothstep(-1.2, -.2, p.y));\n        d = opSU(d, p.y + 2. - .02 + wave, ROUNDNESS);\n\n        float w = fwidth(d);\n        color = min(1.,1. + d / w);\n    }\n\n\tfragColor = vec4(mix(vec3(0), COLOR, color), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}