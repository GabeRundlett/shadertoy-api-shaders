{
    "Shader": {
        "info": {
            "date": "1631899024",
            "description": "Click and drag the spheres!\n\nThe spheres should blend together on collision. Inspired by https://www.shadertoy.com/view/tscBz8.",
            "flags": 32,
            "hasliked": 0,
            "id": "7dy3Rc",
            "likes": 9,
            "name": "Merging Spheres",
            "published": 3,
            "tags": [
                "raymarching",
                "mouse",
                "spheres",
                "smoothunion",
                "draggable"
            ],
            "usePreview": 0,
            "username": "personalizedrefrigerator",
            "viewed": 369
        },
        "renderpass": [
            {
                "code": "// MIT Licensed\n\n// Lower BLEND_K => More blending\n#define BLEND_K 0.6\n\n// Adjust number of spheres and lights in COMMON.\n\n#define SCENE_NEAR 0.3\n#define SCENE_FAR 1000.0\n#define SCENE_MIN_STEP 0.1\n\nstruct Scene\n{\n    Light[NUM_LIGHTS] lights;\n    Sphere[NUM_SPHERES] spheres;\n    \n    float near;\n    float far;\n    float min_step_size;\n};\n\nMarchResult Scene_map(in Scene scene, vec3 p)\n{\n    float res_dist = scene.far;\n    Material res_material = Material_new();\n    \n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        float dist = Sphere_sdf(scene.spheres[i], p);\n        float blend_factor = sigmoid(-BLEND_K * (dist - res_dist));\n        \n        res_material = Material_blend(scene.spheres[i].material, res_material, blend_factor);\n        res_dist = dist * blend_factor + res_dist * (1.0 - blend_factor);\n    }\n    \n    return MarchResult(res_dist, res_material);\n}\n\n// Define normal and march functions for the scene. Note that the high quality march\n// has a maximum of 100 raymarching steps.\nDEFINE_SCENE_NORMAL(Scene, Scene_normal, Scene_map)\nDEFINE_SCENE_MARCH(Scene, Scene_marchHighQuality, Scene_map, 100)\nDEFINE_SCENE_MARCH(Scene, Scene_marchLowQuality, Scene_map, 10)\n\n/// Build the scene and cast a ray.\nvec3 get_color(in Ray camera)\n{\n    Material red_material = Material_new(vec3(1.0, 0.0, 0.0), 5000.0);\n    Material white_material = Material_new();\n    Material blue_material = Material_new(vec3(0.0, 1.0, 1.0), 50.0);\n    Material green_material = Material_new(vec3(0.0, 1.0, 0.6), 200.0);\n    Material purple_material = Material_new(vec3(1.0, 0.0, 1.0), 6.0);\n    \n    Scene scene = Scene\n    (\n        Light[NUM_LIGHTS]\n        (\n            Light_new(vec3(0.0, 0.1, -0.1))\n        ),\n        Sphere[NUM_SPHERES]\n        (\n            SPHERE_NEW_FROM_IDX(0, red_material),\n            SPHERE_NEW_FROM_IDX(1, white_material),\n            SPHERE_NEW_FROM_IDX(2, blue_material),\n            SPHERE_NEW_FROM_IDX(3, green_material),\n            SPHERE_NEW_FROM_IDX(4, purple_material)\n        ),\n        \n        SCENE_NEAR,\n        SCENE_FAR,\n        SCENE_MIN_STEP\n    );\n    \n    MarchResult hit = Scene_marchHighQuality(scene, camera);\n    \n    if (hit.dist >= scene.far)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    vec3 hit_pos = Ray_at(camera, hit.dist);\n    \n    Ray normal = Scene_normal(scene, hit_pos);\n    vec3 result = vec3(0.0);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        vec3 current = vec3(0.0);\n        Light_apply(scene.lights[i], hit.material, normal, camera, scene, Scene_marchLowQuality, current);\n        result += current;\n    }\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = screen_to_world(fragCoord.xy, iResolution.xy);\n\n    // Time varying pixel color\n    vec3 col = get_color(Ray_new(vec3(0.0), vec3(uv, 1.0)));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// MIT Licensed\n\n\n/// Scene settings\n\n#define NUM_LIGHTS 1\n#define NUM_SPHERES 5\n\nfloat get_sphere_radius(int idx)\n{\n    return idx < 2 ? 5.0 : (2.0 + sin(float(idx)) / 4.0);\n}\n\n/// Get the DEFAULT position of a sphere given the current time.\n/// If the user interacts with the sphere, the sphere's position/velocity\n/// are no longer their defaults.\nvec3 get_sphere_default_position(int idx, float time)\n{\n    if (idx == 1)\n    {\n        return vec3(0.0, sin(time / 2.0) * 12.0, 50.0);\n    }\n    else if (idx == 2)\n    {\n        return vec3(sin(time / 2.0) * cos(time / 3.0) * 10.0, cos(time / 2.0) * 20.0, 50.0);\n    }\n    \n    return vec3(0.0, 0.0, 50.0);\n}\n\n///////\n\nconst float SMALL = 0.01;\n\nfloat sigmoid(float t)\n{\n    return 1.0 / (1.0 + exp(-t));\n}\n\n\nstruct Material\n{\n    vec3 color;\n    float specular_power;\n};\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    \n    // Invariant: ||direction|| = 1\n};\n\nstruct MarchResult\n{\n    float dist;\n    Material material;\n};\n\n/// [typeName:\n///   {\n///     float min_step_size;\n///     float near;\n///     float far;\n///   }\n/// ] the scene.\n/// [marchName] the name of the function.\n/// [marchMaxSteps] maximum number of raymarching steps.\n#define DEFINE_SCENE_MARCH(typeName, fnName, mapFnName, marchMaxSteps) \\\nMarchResult fnName(in typeName scene, Ray r)\\\n{\\\n    float dist = scene.near;\\\n    for (int i = 0; i < marchMaxSteps; i++)\\\n    {\\\n        vec3 pt = Ray_at(r, dist);\\\n        MarchResult current = mapFnName(scene, pt);\\\n        dist += current.dist;\\\n        \\\n        if (abs(current.dist) < scene.min_step_size)\\\n        {\\\n            return MarchResult(dist, current.material);\\\n        }\\\n        else if (dist > scene.far)\\\n        {\\\n            return MarchResult(dist, Material_new());\\\n        }\\\n    }\\\n    \\\n    return MarchResult(scene.far, Material_new());\\\n}\\\n\n/// [typeName] The type of the scene.\n/// [fnName] The name of the function to generate\n/// [mapFnName] The name of the map function to use.\n#define DEFINE_SCENE_NORMAL(typeName, fnName, mapFnName) \\\nRay fnName(in typeName scene, vec3 p) \\\n{\\\n    float dist = ( mapFnName(scene, p) ).dist;\\\n    float withdel_x = ( mapFnName(scene, p + vec3(SMALL, 0.0, 0.0)) ).dist;\\\n    float withdel_y = ( mapFnName(scene, p + vec3(0.0, SMALL, 0.0)) ).dist;\\\n    float withdel_z = ( mapFnName(scene, p + vec3(0.0, 0.0, SMALL)) ).dist;\\\n    \\\n    vec3 direction = vec3\\\n    (\\\n        withdel_x - dist,\\\n        withdel_y - dist,\\\n        withdel_z - dist\\\n    ) / SMALL;\\\n    \\\n    return Ray_new(p, direction);\\\n}\n\n\n\n/// Material\n\n/// -> Empty material\nMaterial Material_new()\n{\n    return Material(vec3(1.0), 500.0);\n}\n\nMaterial Material_new(vec3 color, float specular_power)\n{\n    return Material(color, specular_power);\n}\n\nvec3 Material_getColor(in Material m, in Light light, float brightness, float specular)\n{\n    return m.color * light.color * (brightness + pow(specular, m.specular_power));\n}\n\nMaterial Material_blend(in Material a, in Material b, float factor)\n{\n    return Material\n    (\n        a.color * factor + b.color * (1.0 - factor), \n        a.specular_power * factor + b.specular_power * (1.0 - factor)\n    );\n}\n\n/// Sphere\n\nSphere Sphere_new(in vec3 origin, float radius, in Material material)\n{\n    return Sphere(origin, radius, material);\n}\n\nSphere Sphere_new(in vec3 origin, float radius)\n{\n    return Sphere_new(origin, radius, Material_new());\n}\n\n#define SPHERE_DATA_OFFSET(idx) BALL_DATA_START_IDX + idx * BALL_DATA_SIZE\n#define SPHERE_NEW_FROM_IDX(idx, material) \\\n    Sphere_new\\\n    (\\\n        get_data\\\n        (\\\n            iChannel0,\\\n            SPHERE_DATA_OFFSET(idx) + BALL_POSITION_X_OFFSET,\\\n            SPHERE_DATA_OFFSET(idx) + BALL_POSITION_Y_OFFSET,\\\n            SPHERE_DATA_OFFSET(idx) + BALL_POSITION_Z_OFFSET\\\n        ), \\\n        get_sphere_radius(idx),\\\n        material\\\n    )\n\nfloat Sphere_sdf(in Sphere s, in vec3 p)\n{\n    return length(p - s.center) - s.radius;\n}\n\n/// Ray\n\nRay Ray_new(vec3 origin, vec3 direction)\n{\n    return Ray(origin, normalize(direction));\n}\n\nvec3 Ray_at(in Ray r, float dist)\n{\n    return r.origin + r.direction * dist;\n}\n\n/// Light\n\nLight Light_new(vec3 position, vec3 color, float intensity)\n{\n    return Light(position, normalize(color), intensity);\n}\n\nLight Light_new(vec3 position)\n{\n    return Light_new(position, vec3(1.0), 10.0);\n}\n\n/// Get the light's color contribution to a scene.\n/// [Light light]\n/// [Material material_in]\n/// [Ray normal]\n/// [vec3 camera]\n/// [Scene scene]\n/// [fn(Scene, Ray)â†’float march]\n/// [OUT vec3 out_color]\n#define Light_apply(light_in, material_in, normal_in, camera_in, scene_in, march_in, color_out) \\\n{\\\n    vec3 point = normal_in.origin;\\\n    vec3 norm = normal_in.direction;\\\n    vec3 to_light_hat = normalize(light_in.position - point);\\\n    float to_light_len = length(light_in.position - point);\\\n    \\\n    vec3 to_camera_hat = normalize(camera_in.origin - point);\\\n    \\\n    vec3 half_vec = normalize(to_light_hat + to_camera_hat);\\\n    float to_light_through_scene = march_in(scene_in, Ray(point, to_light_hat)).dist;\\\n    \\\n    float brightness = max(0.0, dot(to_light_hat, norm));\\\n    float specular = max(dot(half_vec, norm), 0.0);\\\n    \\\n    /* Shadows */\\\n    if (to_light_through_scene < to_light_len * 0.9)\\\n    {\\\n        brightness *= 0.3;\\\n        specular = 0.0;\\\n    }\\\n    \\\n    color_out = Material_getColor(material_in, light_in, brightness, specular); \\\n}\\\n\n\n/// Convert screen (0, resolution_x) x (0, resolution_y) to world coordinates.\nvec2 screen_to_world(vec2 p, vec2 resolution)\n{\n    return (p/resolution.xy - 0.5) * resolution.xy / max(resolution.x, resolution.y);\n}\n\n\n\n/// Fetching data\n\nconst int LAST_TIME_ID = 0;\nconst int LAST_MOUSE_POSITION_X_ID = 1;\nconst int LAST_MOUSE_POSITION_Y_ID = 2;\nconst int CURRENT_MOUSE_POSITION_X_ID = 3;\nconst int CURRENT_MOUSE_POSITION_Y_ID = 4;\nconst int CURRENT_MOUSE_DOWN_ID = 5;\nconst int LAST_MOUSE_DOWN_ID = 6;\nconst int BALL_TARGET_ID = 7;\nconst int BALL_DATA_START_IDX = 8;\n\nconst int BALL_POSITION_X_OFFSET = 0;\nconst int BALL_POSITION_Y_OFFSET = 1;\nconst int BALL_POSITION_Z_OFFSET = 2;\nconst int BALL_VELOCITY_X_OFFSET = 3;\nconst int BALL_VELOCITY_Y_OFFSET = 4;\nconst int BALL_DETATCH_FROM_DEFAULT_OFFSET = 5;\nconst int BALL_DATA_SIZE = 6;\n\nconst int NUM_DATA_IDS = 8 + BALL_DATA_SIZE * NUM_SPHERES;\n\nvec4 encode_float(float f)\n{\n    float sign_encode = f < 0.0 ? 0.5 : 1.0;\n    \n    f = abs(f);\n    float high = min(f / 256.0, 1.0);\n    float med = min(f * 256.0, 1.0);\n    float low = min(f, 1.0);\n    \n    return vec4(high, med, low, sign_encode);\n}\n\nfloat decode_float(vec4 d)\n{\n    float high = 0.0;\n    float med = 0.0;\n    float low = 0.0;\n    int count = 0;\n    \n    // Assuming 1 byte per channel.\n    float mx = 254.0 / 256.0;\n    \n    if (d.x < mx)\n    {\n        high = d.x * 256.0;\n        count++;\n    }\n    \n    if (d.y < mx)\n    {\n        med = d.y / 256.0;\n        count++;\n    }\n    \n    if (d.z < mx)\n    {\n        low = d.z;\n        count++;\n    }\n    \n    if (count == 0)\n    {\n        return 0.0;\n    }\n    \n    float sgn = d.w < 0.8 ? -1.0 : 1.0;\n    return sgn * (high + med + low) / float(count);\n}\n\nfloat get_data(sampler2D tex, int data_id)\n{\n    float bar_width = 1.0 / float(NUM_DATA_IDS);\n    \n    vec2 coord = vec2(float(data_id) + 0.5, 0.0) * bar_width;\n    \n    \n    vec4 tex_val = texture(tex, coord);\n    return decode_float(tex_val);\n}\n\nvec2 get_data(sampler2D tex, int data_x_id, int data_y_id)\n{\n    return vec2(get_data(tex, data_x_id), get_data(tex, data_y_id));\n}\n\nvec3 get_data(sampler2D tex, int data_x_id, int data_y_id, int data_z_id)\n{\n    return vec3(get_data(tex, data_x_id), get_data(tex, data_y_id), get_data(tex, data_z_id));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n/// Handles movement of the purple ball.\n\n#define LEFT_BOUND -0.5\n#define RIGHT_BOUND 0.5\n#define BOTTOM_BOUND -0.5\n#define TOP_BOUND 0.5\n\n// Multiplies the velocity by this every frame for some slowdown/\n// simulates friction.\n#define VELOCITY_SUSTAIN 0.999\n\n\nvoid handle_edge_bouncing(inout vec3 velocity, inout vec3 position, in vec2 bound_scaling)\n{\n    float left_bound = LEFT_BOUND * bound_scaling.x;\n    float right_bound = RIGHT_BOUND * bound_scaling.x;\n    float top_bound = TOP_BOUND * bound_scaling.y;\n    float bottom_bound = BOTTOM_BOUND * bound_scaling.y;\n    \n    if (position.x < left_bound)\n    {\n        velocity.x = abs(velocity.x);\n        position.x = left_bound;\n    }\n\n    if (position.x > right_bound)\n    {\n        velocity.x = -abs(velocity.x);\n        position.x = right_bound;\n    }\n    \n    if (position.y < bottom_bound)\n    {\n        velocity.y = abs(velocity.y);\n        position.y = bottom_bound;\n    }\n    \n    if (position.y > top_bound)\n    {\n        velocity.y = -abs(velocity.y);\n        position.y = top_bound;\n    }\n    \n    velocity.z = 0.0;\n}\n\n\n/// Returns true iff the current cell should store data for [data_id]\nbool is_data_cell(vec2 coord, int data_id)\n{\n    return int(floor(coord.x)) == data_id;\n}\n\n/// [key] Integer key to check for\n/// [value] to write out if [key] matches the current output location.\n#define SAVE_FLOAT_PROP(key, value)\\\nif (is_data_cell(uv, key))\\\n{\\\n    fragColor = encode_float(value);\\\n}\\\n\n#define INT_TO_WORLD_SCALE 50.0\n#define DATA_TX iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy * float(NUM_DATA_IDS) / iResolution.x;\n\n    vec2 next_mouse_position = screen_to_world(iMouse.xy, iResolution.xy);\n    vec2 current_mouse_position = get_data(DATA_TX, CURRENT_MOUSE_POSITION_X_ID, CURRENT_MOUSE_POSITION_Y_ID);\n    vec2 last_mouse_position = get_data(DATA_TX, LAST_MOUSE_POSITION_X_ID, LAST_MOUSE_POSITION_Y_ID);\n    \n    float current_mouse_down = get_data(DATA_TX, CURRENT_MOUSE_DOWN_ID);\n    float last_mouse_down = get_data(DATA_TX, LAST_MOUSE_DOWN_ID);\n    float next_mouse_down = iMouse.z > 0.0 ? 1.0 : 0.0;\n    \n    int ball_target_id = int(get_data(DATA_TX, BALL_TARGET_ID));\n    float last_time = get_data(DATA_TX, LAST_TIME_ID);\n    float current_time = iTime;\n    float dt = iTime - last_time;\n    \n    float max_res_dimen = max(iResolution.x, iResolution.y);\n    \n    \n    // Check for mouse intersection\n    \n    int intersects_id = -1;\n    \n    for (int ball_idx = 0; ball_idx < NUM_SPHERES; ball_idx++)\n    {\n        // Index offset.\n        int offset = BALL_DATA_START_IDX + ball_idx * BALL_DATA_SIZE;\n        \n        vec3 ball_position = get_data(DATA_TX, offset + BALL_POSITION_X_OFFSET, offset + BALL_POSITION_Y_OFFSET, offset + BALL_POSITION_Z_OFFSET);\n        float ball_radius = get_sphere_radius(ball_idx);\n        \n        ball_position /= INT_TO_WORLD_SCALE;\n        ball_radius /= INT_TO_WORLD_SCALE;\n        \n        // Check for mouse collision\n        bool mouse_in_ball = length(ball_position.xy - current_mouse_position) <= ball_radius;\n        \n        if (mouse_in_ball)\n        {\n            // Note that we're focusing on the current ball only if:\n            //    - We're not focusing on other balls (lower index than other balls to check)\n            // or - The current ball was targeted in previous updates.\n            if (ball_target_id == -1 || intersects_id == -1)\n            {\n                intersects_id = ball_idx;\n            }\n        }\n    }\n    \n    if (intersects_id != -1 && intersects_id != ball_target_id)\n    {\n        ball_target_id = intersects_id;\n    }\n    \n    // Default frag color, should we output nothing for this pixel.\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n    \n    // Update each ball.\n    for (int ball_idx = 0; ball_idx < NUM_SPHERES; ball_idx++)\n    {\\\n        int i = BALL_DATA_START_IDX + ball_idx * BALL_DATA_SIZE;\n    \n        vec3 ball_velocity = vec3(get_data(DATA_TX, i + BALL_VELOCITY_X_OFFSET, i + BALL_VELOCITY_Y_OFFSET), 0.0);\n        vec3 ball_position = get_data(DATA_TX, i + BALL_POSITION_X_OFFSET, i + BALL_POSITION_Y_OFFSET, i + BALL_POSITION_Z_OFFSET);\n        \n        ball_velocity /= INT_TO_WORLD_SCALE;\n        ball_position /= INT_TO_WORLD_SCALE;\n        \n        float detatched = get_data(iChannel0, i + BALL_DETATCH_FROM_DEFAULT_OFFSET);\n        \n        // If not under the control of the user/physics,\n        if (detatched < 0.5)\n        {\n            vec3 default_pos = get_sphere_default_position(ball_idx, iTime) / INT_TO_WORLD_SCALE;\n            ball_position = default_pos;\n        }\n        else\n        {\n            // Otherwise, we're using the ball's velocity/user interaction to update things.\n            \n            ball_velocity *= VELOCITY_SUSTAIN;\n\n            handle_edge_bouncing(ball_velocity, ball_position, iResolution.xy / max_res_dimen);\n            ball_position += ball_velocity * dt;\n        }\n        \n        bool mouse_in_ball = intersects_id == ball_idx;\n        \n        if (mouse_in_ball)\n        {\n            ball_target_id = ball_idx;\n        }\n\n        // Have we been clicked on?\n        if (current_mouse_down > 0.0 && ball_target_id == ball_idx)\n        {\n            // We're now controlled by physics!\n            detatched = 1.0;\n            \n            if (last_mouse_down < 1.0 && mouse_in_ball)\n            {\n                ball_position = vec3(current_mouse_position, ball_position.z);\n            }\n            else\n            {\n                ball_velocity *= 0.7;\n                ball_velocity += vec3(current_mouse_position - ball_position.xy, 0.0) / dt / 40.0;\n            }\n        }\n        \n        // Re-scale for saving.\n        ball_position *= INT_TO_WORLD_SCALE;\n        ball_velocity *= INT_TO_WORLD_SCALE;\n    \n        SAVE_FLOAT_PROP(i + BALL_POSITION_X_OFFSET, ball_position.x);\n        SAVE_FLOAT_PROP(i + BALL_POSITION_Y_OFFSET, ball_position.y);\n        SAVE_FLOAT_PROP(i + BALL_POSITION_Z_OFFSET, ball_position.z);\n        SAVE_FLOAT_PROP(i + BALL_VELOCITY_X_OFFSET, ball_velocity.x);\n        SAVE_FLOAT_PROP(i + BALL_VELOCITY_Y_OFFSET, ball_velocity.y);\n        SAVE_FLOAT_PROP(i + BALL_DETATCH_FROM_DEFAULT_OFFSET, detatched);\n    }\n    \n    \n    SAVE_FLOAT_PROP(LAST_TIME_ID, current_time);\n    SAVE_FLOAT_PROP(BALL_TARGET_ID, float(ball_target_id));\n    SAVE_FLOAT_PROP(LAST_MOUSE_POSITION_X_ID, current_mouse_position.x);\n    SAVE_FLOAT_PROP(LAST_MOUSE_POSITION_Y_ID, current_mouse_position.y);\n    SAVE_FLOAT_PROP(CURRENT_MOUSE_POSITION_X_ID, next_mouse_position.x);\n    SAVE_FLOAT_PROP(CURRENT_MOUSE_POSITION_Y_ID, next_mouse_position.y);\n    SAVE_FLOAT_PROP(CURRENT_MOUSE_DOWN_ID, next_mouse_down);\n    SAVE_FLOAT_PROP(LAST_MOUSE_DOWN_ID, current_mouse_down);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}