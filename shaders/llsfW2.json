{
    "Shader": {
        "info": {
            "date": "1513481526",
            "description": "A 128kb intro by Incline\nFor Demoscene at MAGfest 2018.\nCode: cxw, phrank\nMusic: makro; trad. arr. Kazimierz Sikorski; Handel\nGraphics: Incline logo by special guest Raven/NCE\nBuilt and tested on Firefox Quantum (v57)",
            "flags": 8,
            "hasliked": 0,
            "id": "llsfW2",
            "likes": 2,
            "name": "ncl02: Tribute",
            "published": 3,
            "tags": [
                "compo"
            ],
            "usePreview": 0,
            "username": "cxw",
            "viewed": 1081
        },
        "renderpass": [
            {
                "code": "// ncl02-gfx.frag by cxw/incline.  CC-BY-SA 3.0\n// https://bitbucket.org/inclinescene/ncl02\n/*\nA 128kb intro by Incline\nFor Demoscene at MAGfest 2018.\nCode: cxw, phrank\nMusic: makro; trad. arr. Kazimierz Sikorski; Handel\nGraphics: Incline logo by special guest Raven/NCE\nBuilt and tested on Firefox Quantum (v57)\n*/\n//This file is generated from ncl02.frag.in using perlpp.  DO NOT EDIT.\n//Use https://github.com/cxw42/perlpp/, branch 'defines'.\n\n\n\n//music.frag.inc: Music parameters.\n\n\n\n\n\n\n\n\n\n#define BPS (1.93333333333333334814)\n    // beats per sec = BPM/60 (110 bpm)\n#define SPB (0.51724137931034486204)\n    // sec per beat, precomputed\n#define BPP (2048.0)\n    // beats per pattern - make it longer than the song\n    // if you don't want repeats\n\n// DEBUG: where in the demo you want to start.\n#define START_OFS_SEC 0.00000000000000000000\n\n\n\n\n// Reminder: OpenGL-style coord system: +X right, +Y up, +Z toward viewer\n// CONFIG CONSTANTS STRUCTS GLOBALS ///////////////////\n// {{{1\nprecision highp int;    //play it safe.  Also covers\nprecision highp float;  //vectors and matrices.\n\n\n\n// Voxel logo and related\n#define VLOGO_ORIGIN (vec3(6.0, 1.0, -2.0))\n#define MESSAGE_Z (0.1)\n\n// Bump-mapping\n#define TEX_SCALE (0.2)\n    // iChannel0 is Lichen.\n\n// Timing &c.\n#define LOADING_FREQ (0.2)\n\n#define S_SINE_FREQ (0.02380952380952380952380952380952)\n    // 1/42.  sine letter frequency in cycles per X unit.\n#define S_SINE_GROUP_FREQ (0.03125)\n    // 1/32.  sine group frequency.  If > S_SINE_FREQ, sine gradually\n    // shifts right on screen.\n#define CYL_RADIUS (15.0)\n    // radius of the cylinder for CYL and later parts\n#define TUNNEL_ACCEL (17.0)\n    // Acceleration during TUNNEL, in x units per sec^2\n#define CUBE_FADEIN_TIME (3.0)\n    //fadein in seconds\n\n#define TWOSIDED_RATE (0.3)\n    // how fast you go back and forth\n\n#define PI (3.1415926535897932384626433832795028841971)\n    // from memory :)\n#define PI_OVER_2 (1.5707963267948966192313216916398)\n#define PI_OVER_4 (0.78539816339744830961566084581988)\n#define THREE_PI_OVER_4 (2.3561944901923449288469825374596)\n#define TWO_PI (6.283185307179586)\n#define ONE_OVER_TWO_PI (0.15915494309644431437107064141535)\n    // not from memory :) :)\n\n#define TEE_ZERO (0.001)\n#define TEE_ONE (99999999999999999999.0)\n    // +Inf => 1.0/0.0 gives \"divide by zero during constant folding\" error\n\n#define LTR_Z_THICKNESS (1.0)\n    // in voxels\n#define EPS (0.000001)\n    // Arbitrary choice\n\n#define MAX_VOXEL_STEPS (60)\n    // Empirical - gives a nice disappearing effect at the edges on my\n    // test system\n#define MAX_DIST (100.0)\n\n// Hack the camera\n#define SMALLEST_CAM_FRACTION (.00001)\n\n// }}}1\n\n// CHARSET FOR WORLD-COORDINATE LETTERS ///////////////\n// {{{1\n/*\n^ +Y\n9    00000\n8  1   2   3\n7  1   2   3\n6  1   2   3\n5    44444\n4  5       6\n3  5       6\n2 858      6\n1 88877777\n0 888\n   0 12345 6  --> +X\n(lowercase x, dot, and bang are handled separately)\n*/\n\n// Character storage\n#define NSEGS (9)\nvec4 SEG_SHAPES[NSEGS];\n    // All polys will be quads in the X-Y plane, Z=0.\n    // All quad edges are parallel to the X or Y axis.\n    // These quads are encoded in a vec4: (.x,.y) is the LL corner and\n    // (.z,.w) is the UR corner (coords (x,y)).\n\nvec4 SEG_VOXELS[NSEGS];\n    // Same deal, but voxel offsets, start->last+1\n\n// Grid parameters - 2D\n#define GRID_CHARHT (10.0)\n#define GRID_CHARWD (6.0)\n    // Size of each character\n#define GRID_PITCH (7.0)\n    //each char takes up this much space.  Margin is added on the right\n    //and is GRID_PITCH-GRID_CHARWD wide.\n#define GRID_PITCH_RECIP (0.14285714285714285714285714285714)\n    // avoid a division\n#define GRID_VPITCH (12.0)\n    // margin is added on top\n#define THICKNESS (1.0)\n    // how thick each stroke is\n\n#define GRID_XSHIFT (GRID_PITCH * 0.5)\n    // + pitch/0.5 because letters were snapping into\n    // existence at the right side of the screen.\n\n// Grid parameters - voxels.  Twice the size.\n#define VGRID_CHARHT (GRID_CHARHT*2.0)\n#define VGRID_CHARWD (GRID_CHARWD*2.0)\n#define VGRID_PITCH (GRID_PITCH*2.0)\n#define VGRID_PITCH_RECIP (GRID_PITCH_RECIP*0.5)\n#define VGRID_VPITCH (GRID_VPITCH*2.0)\n\n// For upright chars, each char (X,Y) goes from (PITCH*ofs, 0)->(.+WD,HT).\n\nvoid init_charset()\n{\n    float halft = THICKNESS*0.5;\n    float halfht = GRID_CHARHT * 0.5;\n\n    SEG_SHAPES[0] = vec4(THICKNESS, GRID_CHARHT - THICKNESS, GRID_CHARWD-THICKNESS, GRID_CHARHT);\n    SEG_SHAPES[1] = vec4(0.0,                   halfht, THICKNESS,             GRID_CHARHT - halft);\n    SEG_SHAPES[2] = vec4(GRID_CHARWD*0.5-halft, halfht, GRID_CHARWD*0.5+halft, GRID_CHARHT - halft);\n    SEG_SHAPES[3] = vec4(GRID_CHARWD-THICKNESS, halfht, GRID_CHARWD,           GRID_CHARHT - halft);\n    SEG_SHAPES[4] = vec4(THICKNESS, halfht - halft, GRID_CHARWD-THICKNESS, halfht + halft);\n    SEG_SHAPES[5] = vec4(0.0,                   halft,    THICKNESS,             halfht );\n    SEG_SHAPES[6] = vec4(GRID_CHARWD-THICKNESS, halft,    GRID_CHARWD,           halfht );\n    SEG_SHAPES[7] = vec4(THICKNESS, 0, GRID_CHARWD-THICKNESS, THICKNESS);\n    SEG_SHAPES[8] = vec4(0.0, 0.0, THICKNESS, THICKNESS); //dot\n\n    // Voxel grid #1 - not currently in use\n    //Grid_Origin = vec3(GRID_XSHIFT, 0, 0);\n    //Grid_Spacings = vec3(1.0);\n    //Grid_Spacings_Inv = vec3(1.0)/Grid_Spacings;\n\n    // TODO rewrite in terms of #defines.\n    // Z, W are +1 so can use IsPointInRectXY, which does not include the\n    // UR corner in the poly.\n    // Size has been doubled, so we can use multiples of 0.5.\n    SEG_VOXELS[0] = vec4(1.0, 9.0, 5.0,10.0)*vec4(2.0);\n    SEG_VOXELS[1] = vec4(0.0, 5.5, 1.0, 9.5)*vec4(2.0);\n    SEG_VOXELS[2] = vec4(3.0, 6.0, 4.0, 9.0)*vec4(2.0);\n    SEG_VOXELS[3] = vec4(5.0, 5.5, 6.0, 9.5)*vec4(2.0);\n    SEG_VOXELS[4] = vec4(1.0, 5.0, 5.0, 6.0)*vec4(2.0);\n    SEG_VOXELS[5] = vec4(0.0, 1.5, 1.0, 5.5)*vec4(2.0);\n    SEG_VOXELS[6] = vec4(5.0, 1.5, 6.0, 5.5)*vec4(2.0);\n    SEG_VOXELS[7] = vec4(1.0, 1.0, 6.0, 2.0)*vec4(2.0);\n    SEG_VOXELS[8] = vec4(0.0, 0.0, 2.0, 2.0)*vec4(2.0);\n\n} //init_charset\n\n// }}}1\n\n// MESSAGE ////////////////////////////////////////////\n// Syncing to music: [0.0, 2.0, 5.0, 15.344827586206895, 17.344827586206897, 29.75862068965517, 54.06896551724138, 91.3103448275862, 608.551724137931]\n// Parts and start times\n#define BLANK (0.0)\n#define BLANK_START (0.00000000000000000000)\n#define LOGOFADEIN (1.0)\n#define LOGOFADEIN_START (2.00000000000000000000)\n#define INTRO (2.0)\n#define INTRO_START (5.00000000000000000000)\n#define LOGOFADEOUT (3.0)\n#define LOGOFADEOUT_START (15.34482758620689502038)\n#define MAIN (4.0)\n#define MAIN_START (17.34482758620689679674)\n#define GREETZ (5.0)\n#define GREETZ_START (29.75862068965517082120)\n#define CREDZ (6.0)\n#define CREDZ_START (54.06896551724138078043)\n#define ENDPART (7.0)\n#define ENDPART_START (91.31034482758620640652)\n\nvec4 get_story(in float time)\n{   //returns vec4(partnum, charidx_frac, first_charidx, clip_charidx)\n    // NOTE: charidx_frac restarts at 0 each part!\n    // first_charidx and clip_charidx are with respect to the whole messge.\n    // Character indices starting with clip_charidx should not be displayed.\n    float partnum, charidx_frac, first_charidx, clip_charidx;\n    if(time<2.00000000000000000000) {\n        partnum=BLANK;\n        charidx_frac=(time-BLANK_START)*0.50000000000000000000;\n        first_charidx=0.0;\n        clip_charidx=0.0;\n    } else\n\n    if(time<5.00000000000000000000) {\n        partnum=LOGOFADEIN;\n        charidx_frac=(time-LOGOFADEIN_START)*0.33333333333333331483;\n        first_charidx=1.0;\n        clip_charidx=1.0;\n    } else\n\n    if(time<15.34482758620689502038) {\n        partnum=INTRO;\n        charidx_frac=(time-INTRO_START)*5.31666666666666731800;\n        first_charidx=2.0;\n        clip_charidx=54.0;\n    } else\n\n    if(time<17.34482758620689679674) {\n        partnum=LOGOFADEOUT;\n        charidx_frac=(time-LOGOFADEOUT_START)*0.49999999999999955591;\n        first_charidx=57.0;\n        clip_charidx=57.0;\n    } else\n\n    if(time<29.75862068965517082120) {\n        partnum=MAIN;\n        charidx_frac=(time-MAIN_START)*5.31666666666666731800;\n        first_charidx=58.0;\n        clip_charidx=120.0;\n    } else\n\n    if(time<54.06896551724138078043) {\n        partnum=GREETZ;\n        charidx_frac=(time-GREETZ_START)*5.26524822695035421560;\n        first_charidx=124.0;\n        clip_charidx=248.0;\n    } else\n\n    if(time<91.31034482758620640652) {\n        partnum=CREDZ;\n        charidx_frac=(time-CREDZ_START)*4.10833333333333339255;\n        first_charidx=252.0;\n        clip_charidx=400.0;\n    } else\n\n    if(time<608.55172413793104624347) {\n        partnum=ENDPART;\n        charidx_frac=(time-ENDPART_START)*0.00193333333333333313;\n        first_charidx=405.0;\n        clip_charidx=405.0;\n    } else\n\n    {\n        partnum=0.0;\n        charidx_frac=0.0;\n        first_charidx=0.0;\n        clip_charidx=0.0;\n    }\n\n    return vec4(partnum,charidx_frac,first_charidx,clip_charidx);\n} //get_story\n\nvec4 get_seg_vec4(float vecidx) {\n    if(vecidx>=51.0){\n        if(vecidx>=76.0){\n            if(vecidx>=89.0){\n                if(vecidx>=95.0){\n                    if(vecidx>=98.0){\n                        if(vecidx>=101.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=100.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=99.0) return vec4(187.0,123.0,178.0,211.0);\n                        if(vecidx>=98.0) return vec4(0.0,35.0,187.0,59.0);\n                    }else{\n                        if(vecidx>=97.0) return vec4(178.0,187.0,124.0,178.0);\n                        if(vecidx>=96.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=95.0) return vec4(0.0,0.0,0.0,0.0);\n                    }\n                }else{\n                    if(vecidx>=92.0){\n                        if(vecidx>=94.0) return vec4(107.0,163.0,179.0,0.0);\n                        if(vecidx>=93.0) return vec4(26.0,187.0,11.0,20.0);\n                        if(vecidx>=92.0) return vec4(178.0,0.0,35.0,123.0);\n                    }else{\n                        if(vecidx>=91.0) return vec4(219.0,234.0,187.0,211.0);\n                        if(vecidx>=90.0) return vec4(21.0,123.0,162.0,0.0);\n                        if(vecidx>=89.0) return vec4(211.0,59.0,187.0,19.0);\n                    }\n                }\n            }else{\n                if(vecidx>=82.0){\n                    if(vecidx>=85.0){\n                        if(vecidx>=88.0) return vec4(0.0,242.0,218.0,0.0);\n                        if(vecidx>=87.0) return vec4(18.0,27.0,219.0,27.0);\n                        if(vecidx>=86.0) return vec4(256.0,0.0,16.0,0.0);\n                        if(vecidx>=85.0) return vec4(178.0,0.0,123.0,162.0);\n                    }else{\n                        if(vecidx>=84.0) return vec4(35.0,235.0,0.0,187.0);\n                        if(vecidx>=83.0) return vec4(0.0,111.0,123.0,118.0);\n                        if(vecidx>=82.0) return vec4(26.0,211.0,21.0,19.0);\n                    }\n                }else{\n                    if(vecidx>=79.0){\n                        if(vecidx>=81.0) return vec4(0.0,16.0,0.0,15.0);\n                        if(vecidx>=80.0) return vec4(35.0,123.0,107.0,118.0);\n                        if(vecidx>=79.0) return vec4(20.0,0.0,59.0,114.0);\n                    }else{\n                        if(vecidx>=78.0) return vec4(19.0,124.0,30.0,0.0);\n                        if(vecidx>=77.0) return vec4(235.0,248.0,187.0,0.0);\n                        if(vecidx>=76.0) return vec4(0.0,16.0,0.0,163.0);\n                    }\n                }\n            }\n        }else{\n            if(vecidx>=63.0){\n                if(vecidx>=69.0){\n                    if(vecidx>=72.0){\n                        if(vecidx>=75.0) return vec4(163.0,162.0,235.0,185.0);\n                        if(vecidx>=74.0) return vec4(88.0,50.0,0.0,107.0);\n                        if(vecidx>=73.0) return vec4(235.0,162.0,111.0,0.0);\n                        if(vecidx>=72.0) return vec4(187.0,0.0,178.0,59.0);\n                    }else{\n                        if(vecidx>=71.0) return vec4(15.0,0.0,107.0,163.0);\n                        if(vecidx>=70.0) return vec4(0.0,19.0,26.0,219.0);\n                        if(vecidx>=69.0) return vec4(15.0,26.0,19.0,19.0);\n                    }\n                }else{\n                    if(vecidx>=66.0){\n                        if(vecidx>=68.0) return vec4(35.0,211.0,0.0,19.0);\n                        if(vecidx>=67.0) return vec4(242.0,51.0,0.0,242.0);\n                        if(vecidx>=66.0) return vec4(0.0,178.0,235.0,0.0);\n                    }else{\n                        if(vecidx>=65.0) return vec4(123.0,162.0,211.0,235.0);\n                        if(vecidx>=64.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=63.0) return vec4(0.0,0.0,0.0,0.0);\n                    }\n                }\n            }else{\n                if(vecidx>=57.0){\n                    if(vecidx>=60.0){\n                        if(vecidx>=62.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=61.0) return vec4(248.0,179.0,35.0,258.0);\n                        if(vecidx>=60.0) return vec4(162.0,0.0,235.0,35.0);\n                    }else{\n                        if(vecidx>=59.0) return vec4(178.0,21.0,19.0,123.0);\n                        if(vecidx>=58.0) return vec4(122.0,123.0,242.0,187.0);\n                        if(vecidx>=57.0) return vec4(0.0,123.0,162.0,59.0);\n                    }\n                }else{\n                    if(vecidx>=54.0){\n                        if(vecidx>=56.0) return vec4(248.0,0.0,21.0,11.0);\n                        if(vecidx>=55.0) return vec4(218.0,0.0,123.0,107.0);\n                        if(vecidx>=54.0) return vec4(26.0,123.0,162.0,162.0);\n                    }else{\n                        if(vecidx>=53.0) return vec4(21.0,26.0,21.0,248.0);\n                        if(vecidx>=52.0) return vec4(0.0,21.0,107.0,248.0);\n                        if(vecidx>=51.0) return vec4(0.0,256.0,256.0,256.0);\n                    }\n                }\n            }\n        }\n    }else{\n        if(vecidx>=25.0){\n            if(vecidx>=38.0){\n                if(vecidx>=44.0){\n                    if(vecidx>=47.0){\n                        if(vecidx>=50.0) return vec4(27.0,3.0,162.0,248.0);\n                        if(vecidx>=49.0) return vec4(114.0,179.0,0.0,30.0);\n                        if(vecidx>=48.0) return vec4(21.0,11.0,0.0,178.0);\n                        if(vecidx>=47.0) return vec4(211.0,235.0,107.0,0.0);\n                    }else{\n                        if(vecidx>=46.0) return vec4(0.0,59.0,179.0,35.0);\n                        if(vecidx>=45.0) return vec4(162.0,21.0,211.0,122.0);\n                        if(vecidx>=44.0) return vec4(218.0,0.0,59.0,235.0);\n                    }\n                }else{\n                    if(vecidx>=41.0){\n                        if(vecidx>=43.0) return vec4(187.0,234.0,187.0,35.0);\n                        if(vecidx>=42.0) return vec4(0.0,178.0,235.0,0.0);\n                        if(vecidx>=41.0) return vec4(0.0,123.0,107.0,248.0);\n                    }else{\n                        if(vecidx>=40.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=39.0) return vec4(59.0,162.0,187.0,0.0);\n                        if(vecidx>=38.0) return vec4(218.0,59.0,187.0,235.0);\n                    }\n                }\n            }else{\n                if(vecidx>=31.0){\n                    if(vecidx>=34.0){\n                        if(vecidx>=37.0) return vec4(59.0,123.0,35.0,178.0);\n                        if(vecidx>=36.0) return vec4(123.0,162.0,162.0,0.0);\n                        if(vecidx>=35.0) return vec4(0.0,178.0,235.0,0.0);\n                        if(vecidx>=34.0) return vec4(21.0,11.0,219.0,211.0);\n                    }else{\n                        if(vecidx>=33.0) return vec4(35.0,187.0,187.0,178.0);\n                        if(vecidx>=32.0) return vec4(0.0,0.0,0.0,219.0);\n                        if(vecidx>=31.0) return vec4(0.0,0.0,0.0,0.0);\n                    }\n                }else{\n                    if(vecidx>=28.0){\n                        if(vecidx>=30.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=29.0) return vec4(187.0,107.0,187.0,258.0);\n                        if(vecidx>=28.0) return vec4(111.0,235.0,211.0,163.0);\n                    }else{\n                        if(vecidx>=27.0) return vec4(107.0,0.0,248.0,187.0);\n                        if(vecidx>=26.0) return vec4(35.0,21.0,163.0,123.0);\n                        if(vecidx>=25.0) return vec4(0.0,123.0,111.0,187.0);\n                    }\n                }\n            }\n        }else{\n            if(vecidx>=12.0){\n                if(vecidx>=18.0){\n                    if(vecidx>=21.0){\n                        if(vecidx>=24.0) return vec4(235.0,35.0,178.0,114.0);\n                        if(vecidx>=23.0) return vec4(114.0,187.0,0.0,107.0);\n                        if(vecidx>=22.0) return vec4(107.0,219.0,0.0,178.0);\n                        if(vecidx>=21.0) return vec4(235.0,35.0,178.0,21.0);\n                    }else{\n                        if(vecidx>=20.0) return vec4(211.0,234.0,59.0,59.0);\n                        if(vecidx>=19.0) return vec4(51.0,27.0,3.0,0.0);\n                        if(vecidx>=18.0) return vec4(218.0,235.0,234.0,0.0);\n                    }\n                }else{\n                    if(vecidx>=15.0){\n                        if(vecidx>=17.0) return vec4(123.0,107.0,118.0,0.0);\n                        if(vecidx>=16.0) return vec4(0.0,0.0,178.0,114.0);\n                        if(vecidx>=15.0) return vec4(0.0,0.0,0.0,0.0);\n                    }else{\n                        if(vecidx>=14.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=13.0) return vec4(50.0,50.0,0.0,0.0);\n                        if(vecidx>=12.0) return vec4(107.0,248.0,0.0,50.0);\n                    }\n                }\n            }else{\n                if(vecidx>=6.0){\n                    if(vecidx>=9.0){\n                        if(vecidx>=11.0) return vec4(0.0,211.0,235.0,234.0);\n                        if(vecidx>=10.0) return vec4(107.0,107.0,179.0,162.0);\n                        if(vecidx>=9.0) return vec4(21.0,163.0,114.0,123.0);\n                    }else{\n                        if(vecidx>=8.0) return vec4(111.0,234.0,162.0,178.0);\n                        if(vecidx>=7.0) return vec4(88.0,88.0,88.0,0.0);\n                        if(vecidx>=6.0) return vec4(21.0,178.0,114.0,0.0);\n                    }\n                }else{\n                    if(vecidx>=3.0){\n                        if(vecidx>=5.0) return vec4(163.0,118.0,0.0,30.0);\n                        if(vecidx>=4.0) return vec4(211.0,0.0,242.0,123.0);\n                        if(vecidx>=3.0) return vec4(107.0,187.0,0.0,21.0);\n                    }else{\n                        if(vecidx>=2.0) return vec4(107.0,163.0,162.0,21.0);\n                        if(vecidx>=1.0) return vec4(0.0,0.0,0.0,21.0);\n                        if(vecidx>=0.0) return vec4(0.0,0.0,0.0,0.0);\n                    }\n                }\n            }\n        }\n    }\n    return vec4(0.0);\n} //get_seg_vec4\n\n#define NUM_CHARS_IN_MESSAGE (406.0)\nfloat get_seg_mask(float charidx)\n{\n    if(charidx>=NUM_CHARS_IN_MESSAGE) return 0.0; //blank at the end\n    float vecidx = charidx * 0.250000000;\n    float subidx = mod(charidx, 4.0);\n    vec4 v = get_seg_vec4(vecidx);\n    float rv = v[0];\n    rv = mix(rv, v[1], step(1.0, subidx));\n    rv = mix(rv, v[2], step(2.0, subidx));\n    rv = mix(rv, v[3], step(3.0, subidx));\n    return rv;\n} //get_seg_mask\n\n// Camera and light prototypes\n\nvoid do_cl_blank(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_logofadein(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_intro(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_logofadeout(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_main(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_greetz(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_credz(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_endpart(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\n\nvoid do_camera_light(in float partnum, in float charidx_frac,\n                        out vec3 camera_pos,\n                        out vec3 camera_look_at, out vec3 camera_up,\n                        out float fovy_deg, out vec3 light_pos)\n{   // Camera and light dispatcher\n    if(partnum>=MAIN) {\n\n        if(partnum==MAIN) {\n            do_cl_main(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==GREETZ) {\n            do_cl_greetz(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==CREDZ) {\n            do_cl_credz(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==ENDPART) {\n            do_cl_endpart(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        {\n            camera_pos=vec3(0.0,0.0,10.0);    //default\n            camera_look_at=vec3(0.0);\n            camera_up=vec3(0.0, 1.0, 0.0);\n            fovy_deg=45.0;\n            light_pos=camera_pos;\n        }\n    } else {\n\n        if(partnum==BLANK) {\n            do_cl_blank(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==LOGOFADEIN) {\n            do_cl_logofadein(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==INTRO) {\n            do_cl_intro(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==LOGOFADEOUT) {\n            do_cl_logofadeout(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        {\n            camera_pos=vec3(0.0,0.0,10.0);    //default\n            camera_look_at=vec3(0.0);\n            camera_up=vec3(0.0, 1.0, 0.0);\n            fovy_deg=45.0;\n            light_pos=camera_pos;\n        }\n    }\n} //do_camera_light\n\n\n\n// UTIL ///////////////////////////////////////////////\n// {{{1\n//mat4 my_transpose(in mat4 inMatrix)\n//\n//{\n//    // Modified from\n//    // http://stackoverflow.com/a/18038495/2877364 by\n//    // http://stackoverflow.com/users/2507370/jeb\n//    vec4 i0 = inMatrix[0];\n//    vec4 i1 = inMatrix[1];\n//    vec4 i2 = inMatrix[2];\n//    vec4 i3 = inMatrix[3];\n//\n//    vec4 o0 = vec4(i0.x, i1.x, i2.x, i3.x);\n//    vec4 o1 = vec4(i0.y, i1.y, i2.y, i3.y);\n//    vec4 o2 = vec4(i0.z, i1.z, i2.z, i3.z);\n//    vec4 o3 = vec4(i0.w, i1.w, i2.w, i3.w);\n//\n//    mat4 outMatrix = mat4(o0, o1, o2, o3);\n//\n//    return outMatrix;\n//}\n\nvoid lookat(in vec3 in_eye, in vec3 in_ctr, in vec3 in_up,\n            out mat4 view, out mat4 view_inv)\n{\n    // From Mesa glu.  Thanks to\n    // http://learnopengl.com/#!Getting-started/Camera\n    // and https://www.opengl.org/wiki/GluLookAt_code\n\n    vec3 forward, side, up;\n\n    forward=normalize(in_ctr-in_eye);\n    up = in_up;\n    side = normalize(cross(forward,up));\n    up = cross(side,forward);   // already normalized since both inputs are\n        //now side, up, and forward are orthonormal\n\n    mat4 orient, where;\n\n    // Note: in Mesa gluLookAt, a C matrix is used, so the indices\n    // have to be swapped compared to that code.\n    vec4 x4, y4, z4, w4;\n    x4 = vec4(side,0);\n    y4 = vec4(up,0);\n    z4 = vec4(-forward,0);\n    w4 = vec4(0,0,0,1);\n    orient = transpose(mat4(x4, y4, z4, w4));\n\n    where = mat4(1.0); //identity (1.0 diagonal matrix)\n    where[3] = vec4(-in_eye, 1);\n\n    view = (orient * where);\n\n    // Compute the inverse for later\n    view_inv = mat4(x4, y4, z4, -where[3]);\n    view_inv[3][3] = 1.0;   // since -where[3].w == -1, not what we want\n        // Per https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations ,\n        // M_{view->world}\n} //lookat\n\nvoid gluPerspective(in float fovy_deg, in float aspect,\n                    in float near, in float far,\n                    out mat4 proj, out mat4 proj_inv)\n{   // from mesa glu-9.0.0/src/libutil/project.c.\n    // Thanks to https://unspecified.wordpress.com/2012/06/21/calculating-the-gluperspective-matrix-and-other-opengl-matrix-maths/\n\n    float fovy_rad = radians(fovy_deg);\n    float dz = far-near;\n    float sin_fovy = sin(fovy_rad);\n    float cot_fovy = cos(fovy_rad) / sin_fovy;\n\n    proj=mat4(0);\n    //[col][row]\n    proj[0][0] = cot_fovy / aspect;\n    proj[1][1] = cot_fovy;\n\n    proj[2][2] = -(far+near)/dz;\n    proj[2][3] = -1.0;\n\n    proj[3][2] = -2.0*near*far/dz;\n\n    // Compute the inverse matrix.\n    // http://bookofhook.com/mousepick.pdf\n    float a = proj[0][0];\n    float b = proj[1][1];\n    float c = proj[2][2];\n    float d = proj[3][2];\n    float e = proj[2][3];\n\n    proj_inv = mat4(0);\n    proj_inv[0][0] = 1.0/a;\n    proj_inv[1][1] = 1.0/b;\n    proj_inv[3][2] = 1.0/e;\n    proj_inv[2][3] = 1.0/d;\n    proj_inv[3][3] = -c/(d*e);\n} //gluPerspective\n\nvoid compute_viewport(in float x, in float y, in float w, in float h,\n                        out mat4 viewp, out mat4 viewp_inv)\n{\n    // See https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations#Viewport_Transformation\n    // Also mesa src/mesa/main/viewport.c:_mesa_get_viewport_xform()\n\n    viewp = mat4(0);\n    // Reminder: indexing is [col][row]\n    viewp[0][0] = w/2.0;\n    viewp[3][0] = x+w/2.0;\n\n    viewp[1][1] = h/2.0;\n    viewp[3][1] = y+h/2.0;\n\n    // assumes n=0 and f=1,\n    // which are the default for glDepthRange.\n    viewp[2][2] = 0.5;  // actually 0.5 * (f-n);\n    viewp[3][2] = 0.5;  // actually 0.5 * (n+f);\n\n    viewp[3][3] = 1.0;\n\n    //Invert.  Done by hand.\n    viewp_inv = mat4(1.0);\n    viewp_inv[0][0] = 2.0/w;    // x->x\n    viewp_inv[3][0] = -1.0 - (2.0*x/w);\n\n    viewp_inv[1][1] = 2.0/h;    // y->y\n    viewp_inv[3][1] = -1.0 - (2.0*y/h);\n\n    viewp_inv[2][2] = 2.0;      // z->z\n    viewp_inv[3][2] = -1.0;\n\n}  //compute_viewport\n\n// https://www.opengl.org/wiki/Compute_eye_space_from_window_space\n\nvec4 wts(in mat4 modelviewproj, in mat4 viewport,\n                in vec3 pos)\n{   // world to screen coordinates\n    vec4 clipvertex = modelviewproj * vec4(pos,1.0);\n    vec4 ndc = clipvertex/clipvertex.w;\n    vec4 transformed = viewport * ndc;\n    return transformed;\n} //wts\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec4 WorldRayFromScreenPoint(in vec2 scr_pt,\n    in mat4 view_inv,\n    in mat4 proj_inv,\n    in mat4 viewp_inv)\n{   // Returns world coords of a point on a ray passing through\n    // the camera position and scr_pt.\n\n    vec4 ndc = viewp_inv * vec4(scr_pt,0.0,1.0);\n        // z=0.0 => it's a ray.  0 is an arbitrary choice in the\n        // view volume.\n        // w=1.0 => we don't need to undo the perspective divide.\n        //      So clip coords == NDC\n\n    vec4 view_coords = proj_inv * ndc;\n        // At this point, z=0 will have become something in the\n        // middle of the projection volume, somewhere between\n        // near and far.\n    view_coords = view_coords / view_coords.w;\n        // Keepin' it real?  Not sure what happens if you skip this.\n    //view_coords.w = 0.0;\n        // Remove translation components.  Note that we\n        // don't use this trick.\n    vec4 world_ray_point = view_inv * view_coords;\n        // Now scr_pt is on the ray through camera_pos and world_ray_point\n    return world_ray_point;\n} //WorldRayFromScreenPoint\n\nvec3 hsv2rgb(vec3 c) {\n    // by hughsk, from https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl .\n    // All inputs range from 0 to 1.\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat scalesin(in float bot, in float top, in float x)\n{   //rescale [-1,1] to [bot, top]\n    return mix(bot, top, clamp((x+1.0)*0.5, 0.0, 1.0));\n}\n\n\n\n// }}}1\n\n// VOXEL MARCHING\n// {{{1\n\n// GLSL implementation by cxw.\n// Origial by http://gamedev.stackexchange.com/users/8806/maxim-kamalov , aka\n// dogfuntom, https://gist.github.com/dogfuntom .\n// See http://gamedev.stackexchange.com/questions/47362/cast-ray-to-select-block-in-voxel-game#comment188335_49423\n// Modified from https://gist.github.com/cc881c8fc86ad43d55d8.git\n// Heavily based on:\n// http://gamedev.stackexchange.com/a/49423/8806\n\n// Variables for voxel marching\nstruct VM2State {\n    // Parameters\n    vec3 origin;\n    vec3 direction;\n    vec3 world_min;\n    vec3 world_max;\n\n    // Internals\n    vec3 curr;      //where we are now - was x, y, z vars\n    vec3 stepdir;   //was step[XYZ]\n    vec3 tMax;\n    vec3 tDelta;\n    float max_t;\n}; //VM2State\n\n\n\n/// Handle edge cases when initializing marching\nfloat intbound(float s, float ds)\n{\n    // Some kind of edge case, see:\n    // http://gamedev.stackexchange.com/questions/47362/cast-ray-to-select-block-in-voxel-game#comment160436_49423 :\n        // \"The edge case is where a coordinate of the ray origin is an\n        //integer value, and the corresponding part of the ray direction is\n        //negative. The initial tMax value for that axis should be zero, since\n        //the origin is already at the bottom edge of its cell, but it is\n        //instead 1/ds causing one of the other axes to be incremented instead.\n        //The fix is to write intfloor to check if both ds is negative and s is\n        //an integer value (mod returns 0), and return 0.0 in that case. â€“\n        //codewarrior Dec 24 '14 at 12:00\"\n\n    // by http://gamedev.stackexchange.com/users/57468/codewarrior\n    bool sIsInteger = (fract(s)==0.0);  //TODO check against epsilon?\n    if (ds < 0.0 && sIsInteger)\n        return 0.0;\n\n    return (\n        ( (ds > 0.0) ? (ceil(s) - s) : (s - floor(s)) )\n            // I don't need intbound_ceil here since I make sure origin\n            // always has a fractional part using hack_camera().\n        /\n        abs(ds)\n    );\n} //intbound\n\nbool VM2_init(out VM2State state,\n    in vec3 origin, in vec3 direction, in float max_dist,\n    in vec3 world_min, in vec3 world_max)\n{ //The initialization portion of VM2_raycast (q.v.).\n  //Returns true if successful.\n\n    if(length(direction)==0.0) {\n        return false;   // *** EXIT POINT ***\n    }\n\n    state.origin = origin;\n    state.direction = direction;\n    state.world_min = world_min;     // TODO? make sure they are ints?\n    state.world_max = world_max;\n\n    state.curr = floor(origin);\n    state.stepdir = sign(direction);\n\n    state.tMax.x = intbound(origin.x, direction.x);\n    state.tMax.y = intbound(origin.y, direction.y);\n    state.tMax.z = intbound(origin.z, direction.z);\n\n    state.tDelta.x = state.stepdir.x / direction.x;\n    state.tDelta.y = state.stepdir.y / direction.y;\n    state.tDelta.z = state.stepdir.z / direction.z;\n\n    state.max_t = max_dist / length(direction);\n\n    \n\n    return true;\n} //VM2_init\n\n//DEBUG: these are floats.  For production, change them back to int.\n#define VM2_HIT (1.0)\n#define VM2_NOTYET (-1.0)\n#define VM2_DONE (0.0)\n\nvec4 VM2_step(inout VM2State state,\n                out vec3 voxel, out vec3 hitpoint, out vec3 normal,\n                out float hit_t)\n{ //returns:\n  // VM2_HIT    if we hit a voxel in the world;\n  // VM2_NOTYET if we have not yet reached the world; or\n  // VM2_DONE   if we have traced off the end of the world or have gone\n  //            too far along the ray.\n  // If VM2_HIT, voxel and normal are filled in:\n  //    voxel       coordinates of the voxel we're in\n  //    hitpoint    The actual point where the ray hit the voxel\n  //    normal      normal of the voxel at hitpoint\n\n    vec3 ret_normal;    //value to be returned\n\n    // Go to the next voxel.\n    //DEBUG: The *0.05's below are to rescale for visibility, and are debug.\n    if (state.tMax.x < state.tMax.y) {\n        if (state.tMax.x < state.tMax.z) {\n            if (state.tMax.x > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.x += state.stepdir.x;    // Update which cube we are now in.\n            hit_t = state.tMax.x;               // Record where we hit the cube\n            state.tMax.x += state.tDelta.x;\n                // Adjust state.tMax.x to the next X-oriented crossing\n            ret_normal = vec3(-state.stepdir.x, 0.0, 0.0);\n                // Record the normal vector of the voxel we just entered.\n        } else {\n            if (state.tMax.z > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.z += state.stepdir.z;\n            hit_t = state.tMax.z;\n            state.tMax.z += state.tDelta.z;\n            ret_normal = vec3(0.0, 0.0, -state.stepdir.z);\n        }\n    } else {\n        if (state.tMax.y < state.tMax.z) {\n            if (state.tMax.y > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.y += state.stepdir.y;\n            hit_t = state.tMax.y;\n            state.tMax.y += state.tDelta.y;\n            ret_normal = vec3(0.0, -state.stepdir.y, 0.0);\n        } else {\n            if (state.tMax.z > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.z += state.stepdir.z;\n            hit_t = state.tMax.z;\n            state.tMax.z += state.tDelta.z;\n            ret_normal = vec3(0.0, 0.0, -state.stepdir.z);\n        }\n    } //end conditionals\n\n    // Check if we're past the world\n    if( (state.stepdir.x>0.0) ?\n        (state.curr.x>=state.world_max.x) : (state.curr.x<state.world_min.x) )\n        return vec4(1.0,0.0,0.0,VM2_DONE);\n    if( (state.stepdir.y>0.0) ?\n        (state.curr.y>=state.world_max.y) : (state.curr.y<state.world_min.y) )\n        return vec4(0.0,1.0,0.0,VM2_DONE);\n    if( (state.stepdir.z>0.0) ?\n        (state.curr.z>=state.world_max.z) : (state.curr.z<state.world_min.z) )\n        return vec4(0.0,0.0,1.0,VM2_DONE);\n\n    // Check if we're not yet at the world.\n    // TODO in VM2_init, fast-forward to the boundary of the world so that\n    // this case never happens.\n    if( (state.stepdir.x>0.0) ?\n        (state.curr.x<state.world_min.x) : (state.curr.x>=state.world_max.x) )\n        return vec4(0.5,0.0,0.0,VM2_NOTYET);\n    if( (state.stepdir.y>0.0) ?\n        (state.curr.y<state.world_min.y) : (state.curr.y>=state.world_max.y) )\n        return vec4(0.0,0.5,0.0,VM2_NOTYET);\n    if( (state.stepdir.z>0.0) ?\n        (state.curr.z<state.world_min.z) : (state.curr.z>=state.world_max.z) )\n        return vec4(0.0,0.0,0.5,VM2_NOTYET);\n\n    // If we made it here, we are in a voxel cell.\n    voxel = state.curr;\n    hitpoint = state.origin + hit_t*state.direction;\n    normal = ret_normal;\n    return vec4(voxel,VM2_HIT);     //voxel is debug\n} //VM2_step\n\n// }}}1\n\n// GEOMETRY HIT-TESTING ///////////////////////////////\n// {{{1\n\n\n\n/// Faster routine for the special case of the main text\nvec3 HitZZero(vec3 camera_pos, vec3 rayend)\n{   // Find where the ray meets the z=0 plane.  The ray is\n    // camera_pos + t*(rayend - camera_pos) per Hook.\n    float hit_t = -camera_pos.z / (rayend.z - camera_pos.z);\n    return (camera_pos + hit_t * (rayend-camera_pos));\n} //HitZZero\n\n/// HitZZero(), but using a direction vector.\nvoid HitZZeroDir(in vec3 camera_pos, in vec3 ray_dir,\n                out vec3 hit_pos, out float hit_t)\n{   // Find where the ray meets the z=0 plane.  The ray is\n    // camera_pos + t*(rayend - camera_pos) per Hook.\n    hit_t = -camera_pos.z / ray_dir.z;\n    hit_pos = (camera_pos + hit_t * ray_dir);\n} //HitZZeroDir\n\n/// HitZZeroDir(), but for z<>0\nvoid HitZDir(in vec3 camera_pos, in vec3 ray_dir, in float z,\n                out vec3 hit_pos, out float hit_t)\n{   // Find where the ray meets the z=0 plane.  The ray is\n    // camera_pos + t*(rayend - camera_pos) per Hook.\n    hit_t = (z-camera_pos.z) / ray_dir.z;\n    hit_pos = (camera_pos + hit_t * ray_dir);\n} //HitZDir\n\n// --- IsPointInRectXY ---\n// All polys will be quads in the X-Y plane, Z=0.\n// All quad edges are parallel to the X or Y axis.\n// These quads are encoded in a vec4: (.x,.y) is the LL corner and\n// (.z,.w) is the UR corner (coords (x,y)).  The UR corner is not\n// inclued in the poly.\n\nbool IsPointInRectXY(in vec4 poly_coords, in vec2 world_xy_of_point)\n{\n    // return true if world_xy_of_point is within the poly defined by\n    // poly_coords in the Z=0 plane.\n    // I.e., xy >= poly_coords.xy, and xy < poly_coords.zw.\n    // I can test in 2D rather than 3D because all the geometry\n    // has z=0 and all the quads are planar.\n\n    float x_test, y_test;\n    x_test = step(poly_coords.x, world_xy_of_point.x) *\n            (1.0 - step(poly_coords.z, world_xy_of_point.x));\n        // step() is 1.0 if world.x >= poly_coords.x\n        // 1-step() is 1.0 if world.x < poly_coords.z\n    y_test = step(poly_coords.y, world_xy_of_point.y) *\n            (1.0 - step(poly_coords.w, world_xy_of_point.y));\n\n    return ( (x_test>=0.9) && (y_test >= 0.9) );\n        // Not ==1.0 because these are floats!\n\n} //IsPointInRectXY\n\n\n\n// }}}1\n\n// TEXT RENDERING /////////////////////////////////////\n// {{{1\n\n// Text-rendering internal parameters\n#define LETTER_EPSILON (0.001)\n    // small enough for our purposes.\n#define SIDE_LETTERS (4)\n    // How many letters to render on each side of the current one.\n    // Set to fill the screen at the desired aspect ratio and orientation.\n\n\n\nbool is_in_basic_message(in vec2 in_pt,\n    in float first_charidx, in float clip_charidx,\n    in vec2 text_origin)\n{   // returns true iff world_xy_of_point is the message for this part,\n    // which begins with first_charidx at text_origin,\n    // upright in the z=0 plane.\n\n    vec2 pt = in_pt - text_origin;     // adjust for where the text is\n\n    float nchars = (clip_charidx-first_charidx);\n        //not ()+1 because clip_charidx is one past the last char to show.\n    if( (pt.x<0.0) || (pt.x>=nchars*GRID_PITCH) ) {\n        return false;   //outside - can't hit\n    }\n\n    if( (pt.y<0.0) || (pt.y>GRID_CHARHT*GRID_VPITCH) ) {\n        return false;   //ditto\n    }\n\n    // Which letter are we in?  There can be only one.\n    float ltridx = floor(pt.x/GRID_PITCH);\n    float ofs = ltridx * GRID_PITCH;\n    vec2 shifted_pt = pt - vec2(ofs,0.0);   // with respect to the letter\n    float mask = get_seg_mask(first_charidx + ltridx);\n\n    // Early exit on spaces\n    if(mask <= LETTER_EPSILON) {\n        return false;\n    }\n\n    // check each segment in turn\n    for(int seg_idx=0; seg_idx<NSEGS; ++seg_idx) {\n        if(mod(mask, 2.0)>LETTER_EPSILON) {\n            // Where is this segment of this letter?\n            vec4 theshape = SEG_SHAPES[seg_idx];\n\n            // Check if we are in the segment\n            if(IsPointInRectXY(theshape, shifted_pt)) {\n                return true;    // as soon as we're in a segment,\n            }                   // we don't need to check any others\n\n        } //endif this segment is in mask\n\n        mask = floor(mask * 0.5);\n            //move to next bit and drop fractional part\n\n        // Early exit when you run out of segments\n        if(mask<=LETTER_EPSILON) {\n            return false;       // no more chances\n        }\n    } //foreach segment\n\n    return false;\n} //is_in_basic_message\n\n// }}}1\n\n// VOXEL LOGO /////////////////////////////////////////\n// {{{1\n\n// Voxel-Logo parameters.  Note: Voxels are every 1 unit at present.\n#define VLOGO_HEIGHT (8.0)\n#define VLOGO_Y_MAX (VLOGO_HEIGHT - 1.0)\n#define VLOGO_WIDTH (7.0)\n#define VLOGO_X_MAX (VLOGO_WIDTH - 1.0)\n#define VLOGO_THICKNESS (1.0)\n    // along the X axis\n\n/// Determine whether the ray from #ray_origin in #ray_direction hits the Incline logo.\n/// The logo is in the X = #logo_origin.x plane, beginning at #logo_origin.yz.\n///\n/// @return {bvec2} (did_hit, was_error)\n/// did_hit is true on hit.  If true, _voxel_ holds the grid coordinates of\n/// the voxel that was hit, _hitpoint_ holds the actual point hit, and\n/// _normal_ is the normal of the voxel face that was hit.\n/// was_error is true on error.\n///\n/// The Incline logo by Raven/NCE is:\n///\n/// 7 # # # # # # #\n/// 6 #           #\n/// 5 # #   #   # #\n/// 4   #       #\n/// 3   #   #   #\n/// 2 # #   #   # #\n/// 1 #           #\n/// 0 # # # # # # #\n///\n///   0 1 2 3 4 5 6\n///\nbvec2 voxel_is_in_logo(\n    in vec3 ray_origin, in vec3 ray_direction,\n    in vec3 logo_origin,\n    out vec3 voxel, out vec3 hitpoint, out vec3 normal,\n    out float hit_t)\n{\n\n    //Retval storage, so we don't trash the out parameters if there's no hit.\n    vec3 ret_voxel, ret_hitpoint, ret_normal;\n    float ret_hit_t;\n\n    // TODO RESUME HERE double the size of the logo so it fills the screen\n    // better during the intropart\n\n    // Setup voxel marching\n    bool ok;\n    VM2State state;\n    ok = VM2_init(state, ray_origin, ray_direction, MAX_DIST,\n        //world_min\n        logo_origin,\n        //world_max - last+1\n        logo_origin + vec3(VLOGO_THICKNESS, VLOGO_HEIGHT, VLOGO_WIDTH)\n    );\n\n    if(!ok) return bvec2(false, true);\n        // *** EXIT POINT *** can't init => can't hit\n\n    // Run the marching loop.  At each voxel, check the mask for only\n    // the letter that voxel might be in.\n    for(int step_idx=0; step_idx<MAX_VOXEL_STEPS; ++step_idx) {\n        vec4 hit = VM2_step(state, ret_voxel, ret_hitpoint, ret_normal,\n                                    ret_hit_t);\n\n        if(hit.w == VM2_DONE) return bvec2(false, false); // *** EXIT POINT ***\n\n        if(hit.w == VM2_NOTYET) continue;     // to the next voxel step\n\n        // If we got here, we are in a voxel that is in the world.\n        bool did_hit = false;\n\n        // Don't test X, because the \"are we in the world\" test covers that.\n        // We just need to test Z across the width and Y across the height.\n        // Also, shift from voxel coordinates into logo-relative coords.\n        float x = ret_voxel.z - logo_origin.z;\n        float y = ret_voxel.y - logo_origin.y;\n\n        // Sanity check.  Do we need this?\n        if(x < 0.0 || y<0.0 || x>VLOGO_X_MAX || y>VLOGO_Y_MAX) continue;\n\n        /// Distance from the closest edges in X and Y\n        float xe = min(x, abs(VLOGO_X_MAX - x));\n        float ye = min(y, abs(VLOGO_Y_MAX - y));\n\n        // All four corners are symmetrical, so check those first.\n        if( (xe <= 2.1) && (ye <= 2.1) ) {    // it's a corner.\n            // The 0.1 is just in case of roundoff.\n            did_hit = (\n                (xe <= 0.1) ||   // left edge\n                (ye <= 0.1) ||   // bottom edge\n                // the one that's at (1,2) in the LL corner\n                (\n                    (xe >= 0.9) && (xe <= 1.1) &&\n                    (ye >= 1.9) && (ye <= 2.1)\n                )\n            );\n        } else {                            // it's not a corner\n\n            if( (xe>=2.9) && (xe<= 3.1) ) {   // cells (3,0)->(7,0)\n                did_hit = (\n                    (ye<=0.1) ||    // first and last row\n                    ( (ye>=1.9) && (ye<=2.1) ) ||   // top and bot of \"i\"\n                    ( (y>=2.9) && (y<=3.1) )        // other part of \"i\"\n                        // ** NOTE ^ y, not ye, since this dot breaks\n                        //           vertical symmetry.\n                );\n            } else {                        // cells (0,3)->(6,4)\n                did_hit = (\n                    (xe >= 0.9) &&\n                    (xe <= 1.1)\n                );\n            }\n        }\n\n\n        if(did_hit) {\n           // A hit!  A very palpable hit.\n           voxel = ret_voxel;\n           hitpoint = ret_hitpoint;\n           normal = ret_normal;\n           hit_t = ret_hit_t;\n           return bvec2(true, false);   // did hit; no error\n        }\n\n    } //for each voxel step\n\n    return bvec2(false, false);     // didn't hit, but no error.\n} //voxel_is_in_logo\n\n\n\n\n\n// }}}1\n\n// BUMP MAPPING ///////////////////////////////////////\n// {{{1\n\nvec3 bump_normal(in sampler2D unit_wave, in vec2 tex_coord)\n{\n// https://stackoverflow.com/a/5284527/2877364 by\n// https://stackoverflow.com/users/607131/kvark\n    //float center = texture(iChannel0, hitlocn.xy * TEX_SCALE).ggg;\n    const vec2 size = vec2(2.0,0.0);\n    const ivec3 off = ivec3(-1,0,1);\n\n    vec4 wave = texture(unit_wave, tex_coord);\n    float s11 = wave.x;\n    float s01 = textureOffset(unit_wave, tex_coord, off.xy).x;\n    float s21 = textureOffset(unit_wave, tex_coord, off.zy).x;\n    float s10 = textureOffset(unit_wave, tex_coord, off.yx).x;\n    float s12 = textureOffset(unit_wave, tex_coord, off.yz).x;\n    vec3 va = normalize(vec3(size.xy,s21-s01));\n    vec3 vb = normalize(vec3(size.yx,s12-s10));\n    //vec4 bump = vec4( cross(va,vb), s11 );\n    //The result is a bump vector: xyz=normal, a=height\n    return cross(va,vb);\n} //bump_normal\n\n// }}}1\n\n// CAMERA AND LIGHT ///////////////////////////////////\n// {{{1\n\n// --- Helpers ---\n\n#define GAMMA (2.2)\n#define ONE_OVER_GAMMA (0.45454545454545454545454545454545)\n\nvec3 phong_color(\n    in vec3 pixel_pos, in vec3 normal, in vec3 camera_pos,      // Scene\n    in vec3 light_pos, in vec3 ambient_matl,                    // Lights\n    in vec3 diffuse_matl, in vec3 specular_matl,                // Lights\n    in float shininess)                                         // Material\n{   // Compute pixel color using Blinn-Phong shading with a white light.\n    // Modified from\n    // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    // Normal must be normalized on input.  All inputs are world coords.\n    // Set shininess <=0 to turn off specular highlights.\n    // Objects are one-sided.\n\n    vec3 light_dir = normalize(light_pos - pixel_pos);\n    vec3 eye_dir = normalize(camera_pos - pixel_pos);\n\n    if(dot(light_dir, eye_dir) < 0.0) {\n        return ambient_matl;       // Camera behind the object\n    }\n\n    float lambertian = max(0.0, dot(light_dir, normal));        // Diffuse\n\n    float specular = 0.0;\n    if((lambertian > 0.0) && (shininess > 0.0)) {               // Specular\n        vec3 reflectDir = reflect(-light_dir, normal);\n        float specAngle = max(dot(reflectDir, eye_dir), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    lambertian = pow(lambertian, ONE_OVER_GAMMA);\n    specular = pow(specular, ONE_OVER_GAMMA);\n\n    vec3 retval = ambient_matl + lambertian*diffuse_matl +\n        specular*specular_matl;\n\n    return clamp(retval, 0.0, 1.0);     // no out-of-range values, please!\n\n} //phong_color\n\nhighp vec3 pos_clelies(in float the_time, in float radius)\n{   //Clelies curve\n    //thanks to http://wiki.roblox.com/index.php?title=Parametric_equations\n    vec3 pos; float m = 0.8;\n    highp float smt = sin(m*the_time);\n    pos.x = radius * smt*cos(the_time);\n    pos.y = radius * smt*sin(the_time);\n    pos.z = radius * cos(m*the_time);\n    return pos;\n} //camerapos\n\n/// Get the position of moving text in the main parts.\nvoid get_text_origin(\n    //in float partnum,\n    in float charidx_frac, out vec3 text_origin\n    //out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n    //out vec3 light_pos\n    )\n{\n    text_origin = vec3(-charidx_frac*GRID_PITCH-5.0, 0.0, 0.0);\n        // Origin moves to the left, so the view pans to the right.\n}\n\n// --- Per-part routines referenced above ---\n\nvoid do_cl_nop(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{\n    camera_pos = vec3(0.0,0.0,10.0);    //default\n    camera_look_at = vec3(0.0);\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 45.0;\n    light_pos = camera_pos;\n} //do_cl_nop\n\nvoid do_cl_main(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{\n    // Old lines - for moving camera\n    //camera_pos = vec3(charidx_frac*GRID_PITCH-5.0, GRID_CHARHT*0.5, 10.0);\n    //camera_look_at = vec3(camera_pos.x+3.0, GRID_CHARHT*0.5,0);\n\n    // New lines - for use with moving text\n    camera_pos = vec3(-5.0, GRID_CHARHT*0.5, 10.0);\n    camera_look_at = vec3(-5.0+3.0, GRID_CHARHT*0.5,0);\n\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 45.0;\n    light_pos = camera_pos;\n    light_pos.y += 4.0 * sin(charidx_frac);\n} //do_cl_main\n\nvoid do_cl_intro(in float pn, in float cf, out vec3 camera_pos, out vec3 cla, out vec3 cu, out float fovy_deg, out vec3 light_pos) {\n    do_cl_main(pn, cf, camera_pos, cla, cu, fovy_deg, light_pos);\n    fovy_deg = 39.0;    // a bit tighter for the intro, so we can see\n                        // the logo better.\n    light_pos = camera_pos; // TODO improve this later.\n} //do_cl_intro\n\n\n\n\nvoid do_cl_blank(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_intro(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_logofadein(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_intro(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_logofadeout(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_intro(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_greetz(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_intro(pn, cf, cp, cla, cu, fd, lp); }\n\n\nvoid do_cl_credz(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{\n    camera_pos = vec3(0.0, GRID_CHARHT*0.5, 10.0);\n    camera_look_at = vec3(0.0, GRID_CHARHT*0.5,0);\n        // Letters straight on, centered on the tripples\n\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 35.0;\n    light_pos = camera_pos;\n    light_pos.y += 4.0 * sin(charidx_frac);\n} //do_cl_main\n\nvoid do_cl_endpart(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_main(pn, cf, cp, cla, cu, fd, lp); }\n\n\n//void do_cl_xport(in float partnum, in float charidx_frac, out vec3 camera_pos,\n//     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n//     out vec3 light_pos)\n//{ //static camera\n//    camera_pos = vec3(/*charidx_frac*/\n//        floor(XPORT_NCHARS/2.0)*GRID_PITCH+GRID_PITCH*0.3, GRID_CHARHT*0.5 + 0.5, 10.0);\n//    camera_look_at = vec3(camera_pos.x, GRID_CHARHT*0.5,0);\n//    camera_up = vec3(0.0, 1.0, 0.0);\n//    fovy_deg = 68.0;\n//    light_pos = camera_pos;\n//} //do_cl_xport\n//\n//void do_cl_line2(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_s_plain(pn, cf, cp, cla, cu, fd, lp); }\n//\n//void do_cl_line3(in float partnum, in float charidx_frac, out vec3 camera_pos,\n//     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n//     out vec3 light_pos)\n//{ //For the voxel part.\n//    camera_pos = vec3(charidx_frac*VGRID_PITCH-5.0, VGRID_CHARHT*0.5+0.5, 20.0);\n//    camera_look_at = vec3(camera_pos.x-0.5, VGRID_CHARHT*0.5,0.0);\n//\n//    camera_up = vec3(0.0, 1.0, 0.0);\n//    fovy_deg = 45.0;\n//    light_pos = vec3(\n//        camera_pos.x + VGRID_PITCH*sin(TWO_PI*0.125*charidx_frac),\n//        camera_pos.y+6.0,\n//        camera_pos.z-2.0\n//    );\n//} //do_cl_line3\n//\n//void do_cl_howto(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_line3(pn, cf, cp, cla, cu, fd, lp); }\n//\n//void do_cl_endpart(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\n\n\n\n/// Make sure the camera is never at an integer coordinate.\n/// TODO someday --- fix the voxel marcher ;)\nvec3 hack_camera(vec3 camera_pos)\n{\n    return vec3(    fract(camera_pos.x) >= SMALLEST_CAM_FRACTION ?\n        camera_pos.x :\n        (\n            (abs(camera_pos.x) - fract(camera_pos.x) +\n                    SMALLEST_CAM_FRACTION)\n            *\n            sign(camera_pos.x)\n        )\n,     fract(camera_pos.y) >= SMALLEST_CAM_FRACTION ?\n        camera_pos.y :\n        (\n            (abs(camera_pos.y) - fract(camera_pos.y) +\n                    SMALLEST_CAM_FRACTION)\n            *\n            sign(camera_pos.y)\n        )\n,     fract(camera_pos.z) >= SMALLEST_CAM_FRACTION ?\n        camera_pos.z :\n        (\n            (abs(camera_pos.z) - fract(camera_pos.z) +\n                    SMALLEST_CAM_FRACTION)\n            *\n            sign(camera_pos.z)\n        )\n);\n}\n\n\n// }}}1\n\n// ARTISTRY ///////////////////////////////////////////\n// {{{1\n\nbool do_voxel_logo(\n    in vec3 camera_pos, in vec3 raydir_norm, in vec3 logo_origin,\n    // Outputs - only updated if it hits.\n    out vec3 wc_pixel, out vec3 wc_normal,\n    out vec3 ambient_matl, out vec3 diffuse_matl,\n    out float shininess,\n    out float voxel_hit_t)\n{\n    bool did_hit = false;\n    vec3 voxel, hitpoint, normal;\n    float hit_t;\n    bvec2 hit_status = voxel_is_in_logo(\n        camera_pos, raydir_norm, logo_origin,\n        // Outputs\n        voxel, hitpoint, normal, hit_t\n    );\n\n    bool did_hit_voxel = hit_status.x;\n    //bool was_error = hit_status.y;\n\n    //if(was_error) {\n    //    diffuse_matl = vec3(1.0, 0.0, 0.0);\n    //} else\n    if(did_hit_voxel) {\n        did_hit = true;\n        wc_pixel = hitpoint;\n        wc_normal = normal;\n        voxel_hit_t = hit_t;\n        ambient_matl = vec3(0.1, 0.1, 0.1);\n        diffuse_matl = vec3(0.2, 0.3, 0.8);\n\n        shininess = 25.0;\n    }\n\n    return did_hit;\n\n} // do_voxel_logo\n\nvoid do_tripples(in float the_time, in vec2 fragCoord, in vec2 iResolution,\n                    out vec3 diffuse_matl)\n{\n    float zoom = 1.3*(the_time + 1.);  // Zoom-out factor.\n    vec2 v = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * zoom;  // Center on <0,0>.\n    float r = dot(v,v);  // Distance from the center squared.\n    diffuse_matl = vec3(mod(floor(r - the_time), 2.));  // Color based\n} //do_tripples()\n\n// }}}1\n\n// MAIN ///////////////////////////////////////////////\n// {{{1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init\n    float the_time = iTime + START_OFS_SEC; //0.5*mod(iGlobalTime, 16.0)+S_PLAIN_START;\n    //the_time += (CREDZ_START - 3.0); //DEBUG\n\n    // Loop the text by looping the time!\n    if(the_time >= ENDPART_START) {\n        the_time -= ENDPART_START;\n            // the excess, which is looped from MAIN_START to ENDPART_START\n        the_time = mod(the_time, ENDPART_START - MAIN_START);\n            // where we are in the loop\n        the_time += MAIN_START;\n            // since we don't loop from t=0\n    }\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    init_charset();\n\n#if 0\n    // Grayscale ramp for reference\n    if(fragCoord.y<10.0) {\n        fragColor = vec4(vec3(fragCoord.x/iResolution.x),1.0);\n        return; //EXIT POINT\n    }\n#endif\n\n    // --- Story ---\n    vec4 story = get_story(the_time);\n    float partnum=story[0], charidx_frac=story[1];\n    float first_charidx=story[2], clip_charidx=story[3];\n\n    // --- Camera and light ---\n    vec3 camera_pos, camera_look_at, camera_up, light_pos;\n    float fovy_deg;\n\n    do_camera_light(partnum, charidx_frac,\n        camera_pos, camera_look_at, camera_up, fovy_deg, light_pos);\n    camera_pos = hack_camera(camera_pos);\n\n    // Camera processing\n    mat4 view, view_inv;\n\n\n\n    lookat(camera_pos, camera_look_at, camera_up,\n            view, view_inv);\n\n    mat4 proj, proj_inv;\n    //fovy_deg = 25.0;    //DEBUG\n    gluPerspective(fovy_deg, iResolution.x/iResolution.y, 1.0, 10.0,\n                    proj, proj_inv);\n\n    mat4 viewport, viewport_inv;\n    compute_viewport(0.0, 0.0, iResolution.x, iResolution.y,\n                        viewport, viewport_inv);\n\n    // --- Geometry ---\n\n    vec3 rayend = WorldRayFromScreenPoint(fragCoord,\n                                    view_inv, proj_inv, viewport_inv).xyz;\n    vec3 raydir_norm = normalize(rayend - camera_pos);\n\n    // Each part determines world coords of the hit, normal at the\n    // hit point, and base color of the geometry.\n\n    vec3 wc_pixel;  // world coords of this pixel\n    vec3 wc_normal; // ditto for the normal\n    vec3 ambient_matl = vec3(0.1);\n    vec3 diffuse_matl = vec3(0.0);\n        // material - light is always white.  Alpha is always 1.\n    float shininess = 4.0;  //Phong shininess\n    bool did_hit = false;   //if not did_hit, just use _diffuse_.\n\n    if ((partnum == BLANK) || (partnum == ENDPART)) {    // black screens\n        diffuse_matl = vec3(0.0);\n\n    }\n\n    else if((partnum == LOGOFADEIN) || (partnum == LOGOFADEOUT) ) {\n        float voxel_hit_t;\n        did_hit = do_voxel_logo(\n            camera_pos, raydir_norm,\n            VLOGO_ORIGIN,\n            // Outputs\n            wc_pixel, wc_normal, ambient_matl, diffuse_matl, shininess,\n            voxel_hit_t\n        );\n\n        float fade =\n            smoothstep(LOGOFADEIN_START, INTRO_START, the_time) *\n            (1.0 - smoothstep(LOGOFADEOUT_START, MAIN_START, the_time));\n        ambient_matl *= fade;\n        diffuse_matl *= fade;\n    }\n\n    else { // scrollers\n        bool did_hit_message=false, did_hit_voxel=false;\n\n        // Message outputs\n        float message_hit_t;\n        vec3 message_hit_locn;\n\n        // Voxel outputs\n        float voxel_hit_t;\n        vec3 vwc_pixel, vwc_normal, vambient_matl, vdiffuse_matl;\n        float vshininess;\n\n        // Do the message\n\n        vec3 text_origin;\n        get_text_origin(charidx_frac, text_origin);\n            // The letters move, not the camera\n\n        HitZDir(camera_pos, raydir_norm, MESSAGE_Z,\n            message_hit_locn, message_hit_t);\n            // message_hit_locn is where it hits z=MESSAGE_Z,\n            // where the letters are.  For now, ignore text_origin.z.\n\n        did_hit_message = is_in_basic_message(message_hit_locn.xy, first_charidx,\n                            clip_charidx, text_origin.xy);\n\n        // Also try the logo, during the intropart and on the right\n        // half of the screen\n        if((partnum == INTRO) && (uv.x>=0.5) ) {\n            did_hit_voxel = do_voxel_logo(\n                camera_pos, raydir_norm,\n                VLOGO_ORIGIN,\n                // Outputs\n                vwc_pixel, vwc_normal, vambient_matl, vdiffuse_matl, vshininess,\n                voxel_hit_t\n            );\n        } //endif trying the voxel\n\n        // Painter's algorithm (sort of)\n        if(did_hit_message && did_hit_voxel) {\n            if(message_hit_t < voxel_hit_t) {\n                did_hit_voxel = false;\n            } else {\n                did_hit_message = false;\n            }\n        }\n\n        // Now at most one of message or voxel was hit.\n\n        if(did_hit_message) {\n            did_hit = true;\n            wc_pixel = message_hit_locn;\n            wc_normal = vec3(0.0,0.0,-1.0 + 2.0*step(0.0, camera_pos.z));\n                // normal Z is -1 if camera_pos.z<0.0, and +1 otherwise.\n                // This benefits TWOSIDED.\n\n            // Perturb the normal by bump-mapping\n            wc_normal = normalize(\n                wc_normal + bump_normal(iChannel0,\n                                            message_hit_locn.xy * TEX_SCALE)\n            );\n\n            if(partnum == CREDZ) {\n                did_hit = false;\n                diffuse_matl = vec3(0.1);\n            } else {\n                ambient_matl = vec3(0.2, 0.2, 0.1);\n                diffuse_matl = vec3(0.6,0.6,0.3);\n                shininess = 50.0;\n            }\n\n        } else if(did_hit_voxel) {\n            did_hit = true;\n            wc_pixel = vwc_pixel;\n            wc_normal = vwc_normal;\n            ambient_matl = vambient_matl;\n            diffuse_matl = vdiffuse_matl;\n            shininess = vshininess;\n\n        } else if(partnum == CREDZ) {\n            // During the credz, we didn't hit the message.  Therefore,\n            // add a background (Tripples).\n            do_tripples(the_time - CREDZ_START, fragCoord.xy, iResolution.xy,\n                        diffuse_matl);\n//            float zoom = 1.3*(the_time - CREDZ_START + 1.);  // Zoom-out factor.\n//            vec2 v = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * zoom;  // Center on <0,0>.\n//            float r = dot(v,v);  // Distance from the center squared.\n//            diffuse_matl = vec3(mod(floor(r - the_time), 2.));  // Color based\n\n            // Fade the background out\n            diffuse_matl *= (1.0 - smoothstep(ENDPART_START-2.0, ENDPART_START,\n                                    the_time));\n        }\n        // else diffuse is the default (0,0,0).\n\n    }\n\n    // --- Lighting ---\n    // Phong shading based on the Geometry section's output values\n\n    if(did_hit) {               // a hit\n        vec3 rgb = phong_color(\n            wc_pixel, wc_normal, camera_pos, light_pos,\n            ambient_matl, diffuse_matl, vec3(1.0), shininess);\n\n        fragColor = vec4(rgb, 1.0);\n    } else {                    // no hit - just use diffuse_matl\n        fragColor = vec4(diffuse_matl, 1.0);\n    }\n\n} //mainImage\n\n// }}}1\n\n// vi: set ts=4 sts=4 sw=4 et ai foldmethod=marker foldenable foldlevel=0: //\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ncl02-msx.frag by cxw/incline.  CC-BY-SA 3.0\n// https://bitbucket.org/inclinescene/ncl02\n//This file is generated from ncl02-msx.frag.in using perlpp.  DO NOT EDIT\nprecision highp int;precision highp float;\n\n//music.frag.inc: Music parameters.\n\n\n\n\n\n\n\n\n\n#define BPS (1.93333333333333334814)\n    // beats per sec = BPM/60 (110 bpm)\n#define SPB (0.51724137931034486204)\n    // sec per beat, precomputed\n#define BPP (2048.0)\n    // beats per pattern - make it longer than the song\n    // if you don't want repeats\n\n// DEBUG: where in the demo you want to start.\n#define START_OFS_SEC 0.00000000000000000000\n\n\n\n\n// Manual sync\n#define MUSIC_START_TIME (0.0) //(0.75)\n    // how long to wait before starting the music\n\n#define MUSIC_DURATION_SEC (180.0)\n    // ShaderToy only generates 3min of music\n\n// Dynamics - how much the first beat of the measure differs from the\n// rest of the measure.\n#define DYN_EXP (2.0)\n\n// Computed parameters //////////////////////////////////////////////////\n#define PATTERN_DURATION_SEC (SPB * BPP)\n    // = SPP = S/B * B/P\n\n// Constants ////////////////////////////////////////////////////////////\n#define PI (3.1415926535897932384626433832795028841971)\n    // from memory :)\n#define TWO_PI (6.283185307179586)\n#define ONE_OVER_TWO_PI (0.15915494309644431437107064141535)\n    // not from memory :) :)\n#define HALF_PI (1.5707963267948966192313216916398)\n#define ONE_OVER_HALF_PI (0.63661977236758134307553505349006)\n\n// Utils ////////////////////////////////////////////////////////////////\nfloat rand(float n){    // http://shadertoy.wikia.com/wiki/Noise\n    return fract(cos(n*89.42)*343.42);\n}\n\n\n// Triangle /////////////////////////////////////////////////////////////\n\nfloat do_tri(in float time, in float freq_hz, in float period_sec)\n{ // additively synthesize something vaguely like an NES triangle\n    float phase_rad = mod(time, period_sec) * TWO_PI * freq_hz;\n    float phase_within_quadrant = mod(phase_rad, HALF_PI);\n    float phase_at_quadrant_start = phase_rad - phase_within_quadrant;\n    float ramp_start = sin(phase_at_quadrant_start);\n    float ramp_end = sin(phase_at_quadrant_start + HALF_PI);\n\n    float pct = phase_within_quadrant * ONE_OVER_HALF_PI;\n    float retval = mix(ramp_start, ramp_end, pct);\n\n    retval += 0.2*cos(TWO_PI * freq_hz * time);             // sag/rise\n    //retval += 0.05*sin(32.0 * TWO_PI * freq_hz * time);   // steps\n        // Sounds less harsh on my machine without this.\n\n    retval *= 0.9;      //leave a bit of room\n    retval += 0.006;    //DC balance (sort of)\n\n    return retval;\n} //do_tri\n\n// Square ///////////////////////////////////////////////////////////////\n\n#define MELODY_RAMP_TIME_SEC (0.02)\n    // Attack time\n#define MELODY_RAMPDOWN_TIME_SEC (0.05)\n    // Release time\n\nfloat do_square(in float time, in float freq_hz, in float period_sec)\n{ // synthesize a square wave\n    float phase_01 = mod(time, period_sec) * freq_hz;\n        // phase, from 0 to 1 in each cycle.  mod(time,period) gives us\n        // time in units of periods, then *freq gives 0..1\n    float whichpart = sign(0.5-phase_01);   // square -1 to 1\n        // positive in the first half of the cycle; negative in the second\n    float retval = (1.0 + whichpart) * 0.5; // square 0 to 1\n\n    return retval;\n} //do_square\n\n// Song data ////////////////////////////////////////////////////////////\n\n// Tuning, including REST for consistency\n#define F_REST (0.000)\n#define P_REST (0.00000000000000000000)\n#define F_C4 (261.630)\n#define P_C4 (0.00382219164468906468)\n#define F_D4 (293.660)\n#define P_D4 (0.00340529864469113919)\n#define F_E4 (329.630)\n#define P_E4 (0.00303370445651184647)\n#define F_F4 (349.230)\n#define P_F4 (0.00286344243048993483)\n#define F_G4 (392.000)\n#define P_G4 (0.00255102040816326510)\n#define F_A4 (440.000)\n#define P_A4 (0.00227272727272727262)\n#define F_B4 (466.160)\n#define P_B4 (0.00214518620216234751)\n#define F_C5 (523.250)\n#define P_C5 (0.00191113234591495451)\n#define F_D5 (587.330)\n#define P_D5 (0.00170262033269201279)\n#define F_E5 (659.250)\n#define P_E5 (0.00151687523701175570)\n#define F_F5 (698.460)\n#define P_F5 (0.00143172121524496741)\n#define F_G5 (783.990)\n#define P_G5 (0.00127552647355195863)\n#define F_A5 (880.000)\n#define P_A5 (0.00113636363636363631)\n#define F_B5 (987.770)\n#define P_B5 (0.00101238142482561731)\n#define F_C6 (1046.500)\n#define P_C6 (0.00095556617295747726)\n#define F_D6 (1174.660)\n#define P_D6 (0.00085131016634600639)\n\n// LUT function from integer pitch number to freq and period\nvec2 notefreq(in float pitch_num)\n{\n    vec2 retval = vec2(F_REST, P_REST);\n\n    retval = mix(retval, vec2(F_REST,P_REST), step(0.0, pitch_num));\n    retval = mix(retval, vec2(F_C4,P_C4), step(1.0, pitch_num));\n    retval = mix(retval, vec2(F_D4,P_D4), step(2.0, pitch_num));\n    retval = mix(retval, vec2(F_E4,P_E4), step(3.0, pitch_num));\n    retval = mix(retval, vec2(F_F4,P_F4), step(4.0, pitch_num));\n    retval = mix(retval, vec2(F_G4,P_G4), step(5.0, pitch_num));\n    retval = mix(retval, vec2(F_A4,P_A4), step(6.0, pitch_num));\n    retval = mix(retval, vec2(F_B4,P_B4), step(7.0, pitch_num));\n    retval = mix(retval, vec2(F_C5,P_C5), step(8.0, pitch_num));\n    retval = mix(retval, vec2(F_D5,P_D5), step(9.0, pitch_num));\n    retval = mix(retval, vec2(F_E5,P_E5), step(10.0, pitch_num));\n    retval = mix(retval, vec2(F_F5,P_F5), step(11.0, pitch_num));\n    retval = mix(retval, vec2(F_G5,P_G5), step(12.0, pitch_num));\n    retval = mix(retval, vec2(F_A5,P_A5), step(13.0, pitch_num));\n    retval = mix(retval, vec2(F_B5,P_B5), step(14.0, pitch_num));\n    retval = mix(retval, vec2(F_C6,P_C6), step(15.0, pitch_num));\n    retval = mix(retval, vec2(F_D6,P_D6), step(16.0, pitch_num));\n\n    return retval;\n}\n\n// Score\n// Poland is Not Yet Lost.  Transcribed by cxw from\n// https://web.archive.org/web/20170617055023/http://www.mkidn.gov.pl/media/docs/06_dwa_glosy.pdf.\n\nvec4 get_song_data_melody(in float beat_in_pattern)\n{\n    vec4 retval; //(pitchnum, dynamics, startbeat, endbeat)\n        // frequency < 1.0 => no sound\n    retval = vec4(0.0);     // by default, no sound\n    retval = mix(retval, vec4(0.0, 1.000, 0.000, 3.867), step(0.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 3.867, 9.667), step(3.867, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 9.667, 29.667), step(9.667, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 29.667, 33.533), step(29.667, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 33.533, 34.283), step(33.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 34.283, 34.533), step(34.283, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 34.533, 35.533), step(34.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 35.533, 36.533), step(35.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 36.533, 37.283), step(36.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 37.283, 37.533), step(37.283, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 37.533, 38.033), step(37.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 38.033, 38.533), step(38.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 38.533, 39.033), step(38.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 39.033, 39.471), step(39.033, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 39.471, 39.533), step(39.471, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 39.533, 40.283), step(39.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 40.283, 40.533), step(40.283, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 40.533, 42.033), step(40.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 42.033, 42.533), step(42.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 42.533, 43.533), step(42.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 43.533, 44.533), step(43.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 44.533, 45.533), step(44.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 45.533, 46.283), step(45.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 46.283, 46.533), step(46.283, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 46.533, 47.533), step(46.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 47.533, 48.533), step(47.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 48.533, 49.283), step(48.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 49.283, 49.533), step(49.283, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 49.533, 50.033), step(49.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 50.033, 50.533), step(50.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 50.533, 51.033), step(50.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 51.033, 51.471), step(51.033, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 51.471, 51.533), step(51.471, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 51.533, 52.283), step(51.533, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 52.283, 52.533), step(52.283, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 52.533, 54.033), step(52.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 54.033, 54.533), step(54.033, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 54.533, 55.533), step(54.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 55.533, 56.533), step(55.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 56.533, 57.533), step(56.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 57.533, 58.533), step(57.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 58.533, 60.033), step(58.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 60.033, 60.533), step(60.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 60.533, 61.033), step(60.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 61.033, 61.533), step(61.033, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 61.533, 63.408), step(61.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 63.408, 63.533), step(63.408, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 63.533, 64.283), step(63.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 64.283, 64.533), step(64.283, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 64.533, 65.533), step(64.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 65.533, 66.033), step(65.533, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 66.033, 66.533), step(66.033, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 66.533, 67.533), step(66.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 67.533, 69.408), step(67.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 69.408, 69.533), step(69.408, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 69.533, 70.033), step(69.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 70.033, 70.533), step(70.033, beat_in_pattern));\n    retval = mix(retval, vec4(11.0, 0.900, 70.533, 72.033), step(70.533, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 0.900, 72.033, 72.533), step(72.033, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 0.900, 72.533, 73.033), step(72.533, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 73.033, 73.533), step(73.033, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 73.533, 75.471), step(73.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 75.471, 75.533), step(75.471, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 75.533, 76.033), step(75.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 76.033, 76.533), step(76.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 76.533, 78.033), step(76.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 78.033, 78.533), step(78.033, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 78.533, 79.533), step(78.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 79.533, 80.533), step(79.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 80.533, 81.533), step(80.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 81.533, 82.533), step(81.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 82.533, 84.033), step(82.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 84.033, 84.533), step(84.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 84.533, 85.033), step(84.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 85.033, 85.533), step(85.033, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 85.533, 87.408), step(85.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 87.408, 87.533), step(87.408, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 87.533, 88.283), step(87.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 88.283, 88.533), step(88.283, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 88.533, 89.533), step(88.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 89.533, 90.033), step(89.533, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 90.033, 90.533), step(90.033, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 90.533, 91.533), step(90.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 91.533, 93.408), step(91.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 93.408, 93.533), step(93.408, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 93.533, 94.033), step(93.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 94.033, 94.533), step(94.033, beat_in_pattern));\n    retval = mix(retval, vec4(11.0, 0.900, 94.533, 96.033), step(94.533, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 0.900, 96.033, 96.533), step(96.033, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 0.900, 96.533, 97.033), step(96.533, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 97.033, 97.533), step(97.033, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 97.533, 99.471), step(97.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 99.471, 99.533), step(99.471, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 99.533, 100.033), step(99.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 100.033, 100.533), step(100.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 100.533, 102.033), step(100.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 102.033, 102.533), step(102.033, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 102.533, 103.533), step(102.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 103.533, 104.533), step(103.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 104.533, 176.533), step(104.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 176.533, 1176.533), step(176.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 1176.533, 1177.533), step(1176.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 1177.533, 1177.533), step(1177.533, beat_in_pattern));\n    return retval;\n} //get_song_data_melody()\n\nvec4 get_song_data_harmony(in float beat_in_pattern)\n{\n    vec4 retval; //(pitchnum, dynamics, startbeat, endbeat)\n        // frequency < 1.0 => no sound\n    retval = vec4(0.0);     // by default, no sound\n    retval = mix(retval, vec4(0.0, 1.000, 0.000, 3.867), step(0.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 3.867, 9.667), step(3.867, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 9.667, 29.667), step(9.667, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 29.667, 33.533), step(29.667, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 33.533, 34.283), step(33.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 34.283, 34.533), step(34.283, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 34.533, 35.533), step(34.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 35.533, 36.533), step(35.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 36.533, 37.283), step(36.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 37.283, 37.533), step(37.283, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 37.533, 38.533), step(37.533, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 38.533, 39.033), step(38.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 39.033, 39.533), step(39.033, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 39.533, 40.283), step(39.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 40.283, 40.533), step(40.283, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 40.533, 41.033), step(40.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 41.033, 41.533), step(41.033, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 41.533, 42.533), step(41.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 42.533, 43.533), step(42.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 43.533, 44.533), step(43.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 44.533, 45.533), step(44.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 45.533, 46.283), step(45.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 46.283, 46.533), step(46.283, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 46.533, 47.533), step(46.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 47.533, 48.533), step(47.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 48.533, 49.283), step(48.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 49.283, 49.533), step(49.283, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 49.533, 50.533), step(49.533, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 50.533, 51.033), step(50.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 51.033, 51.533), step(51.033, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 51.533, 52.283), step(51.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 52.283, 52.533), step(52.283, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 52.533, 53.033), step(52.533, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 53.033, 53.533), step(53.033, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 53.533, 54.033), step(53.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 54.033, 54.533), step(54.033, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 54.533, 55.533), step(54.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 55.533, 56.533), step(55.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 56.533, 57.533), step(56.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 57.533, 58.533), step(57.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 58.533, 59.033), step(58.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 59.033, 59.533), step(59.033, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 59.533, 60.533), step(59.533, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 60.533, 61.033), step(60.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 61.033, 61.533), step(61.033, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 61.533, 63.033), step(61.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 63.033, 63.533), step(63.033, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 63.533, 64.283), step(63.533, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 64.283, 64.533), step(64.283, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 64.533, 65.033), step(64.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 65.033, 65.533), step(65.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 65.533, 66.033), step(65.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 66.033, 66.533), step(66.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 66.533, 67.033), step(66.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 67.033, 67.533), step(67.033, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 67.533, 69.533), step(67.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 69.533, 70.033), step(69.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 70.033, 70.533), step(70.033, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 70.533, 71.033), step(70.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 71.033, 71.533), step(71.033, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 71.533, 72.533), step(71.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 72.533, 73.533), step(72.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 73.533, 74.033), step(73.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 74.033, 74.533), step(74.033, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 74.533, 75.033), step(74.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 75.033, 75.533), step(75.033, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 75.533, 76.033), step(75.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 76.033, 76.533), step(76.033, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 76.533, 77.033), step(76.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 77.033, 77.533), step(77.033, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 77.533, 78.033), step(77.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 78.033, 78.533), step(78.033, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 78.533, 79.533), step(78.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 79.533, 80.533), step(79.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 80.533, 81.533), step(80.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 81.533, 82.533), step(81.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 82.533, 83.033), step(82.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 83.033, 83.533), step(83.033, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 83.533, 84.533), step(83.533, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 84.533, 85.033), step(84.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 85.033, 85.533), step(85.033, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 85.533, 87.033), step(85.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 87.033, 87.533), step(87.033, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 87.533, 88.283), step(87.533, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 88.283, 88.533), step(88.283, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 88.533, 89.033), step(88.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 89.033, 89.533), step(89.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 89.533, 90.033), step(89.533, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 90.033, 90.533), step(90.033, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 90.533, 91.033), step(90.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 91.033, 91.533), step(91.033, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 91.533, 93.533), step(91.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 93.533, 94.033), step(93.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 94.033, 94.533), step(94.033, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 94.533, 95.033), step(94.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 95.033, 95.533), step(95.033, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 95.533, 96.533), step(95.533, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 96.533, 97.533), step(96.533, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 97.533, 98.033), step(97.533, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 98.033, 98.533), step(98.033, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 98.533, 99.033), step(98.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 99.033, 99.533), step(99.033, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 99.533, 100.033), step(99.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 100.033, 100.533), step(100.033, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 100.533, 101.033), step(100.533, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 101.033, 101.533), step(101.033, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 101.533, 102.033), step(101.533, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 102.033, 102.533), step(102.033, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 102.533, 103.533), step(102.533, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 103.533, 104.533), step(103.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 104.533, 176.533), step(104.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 176.533, 1176.533), step(176.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 1176.533, 1177.533), step(1176.533, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 1177.533, 1177.533), step(1177.533, beat_in_pattern));\n    return retval;\n} //get_song_data_harmony()\n\n#define START_SECS_0 (0.00000000000000000000)\n#define START_BEATS_0 (0.00000000000000000000)\n#define START_SECS_1 (2.00000000000000000000)\n#define START_BEATS_1 (3.86666666666666669627)\n#define START_SECS_2 (5.00000000000000000000)\n#define START_BEATS_2 (9.66666666666666607455)\n#define START_SECS_3 (15.34482758620689502038)\n#define START_BEATS_3 (29.66666666666666429819)\n#define START_SECS_4 (17.34482758620689679674)\n#define START_BEATS_4 (33.53333333333333143855)\n#define START_SECS_5 (29.75862068965517082120)\n#define START_BEATS_5 (57.53333333333333143855)\n#define START_SECS_6 (54.06896551724138078043)\n#define START_BEATS_6 (104.53333333333333143855)\n#define START_SECS_7 (91.31034482758620640652)\n#define START_BEATS_7 (176.53333333333333143855)\n#define START_SECS_8 (608.55172413793104624347)\n#define START_BEATS_8 (1176.53333333333330301684)\nvec4 get_song_data_jingle_voice1(in float beat_in_pattern)\n{\n    vec4 retval; //(pitchnum, dynamics, startbeat, endbeat)\n        // frequency < 1.0 => no sound\n    retval = vec4(0.0);     // by default, no sound\n    // ** Dynamics => sustain control\n    retval = mix(retval, vec4(0.0, 0.100, 0.000, 3.867), step(0.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 1.000, 3.867, 9.867), step(3.867, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 9.867, 13.867), step(9.867, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 1.000, 13.867, 14.867), step(13.867, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 1.000, 14.867, 15.867), step(14.867, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.100, 15.867, 35.867), step(15.867, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 1.000, 35.867, 35.867), step(35.867, beat_in_pattern));\n    return retval;\n} //get_song_data_jingle_voice1()\n\nvec4 get_song_data_jingle_voice2(in float beat_in_pattern)\n{\n    vec4 retval; //(pitchnum, dynamics, startbeat, endbeat)\n        // frequency < 1.0 => no sound\n    retval = vec4(0.0);     // by default, no sound\n    // ** Dynamics => sustain control\n    retval = mix(retval, vec4(0.0, 0.100, 0.000, 3.867), step(0.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 1.000, 3.867, 19.367), step(3.867, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 0.100, 19.367, 39.367), step(19.367, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 1.000, 39.367, 39.367), step(39.367, beat_in_pattern));\n    return retval;\n} //get_song_data_jingle_voice2()\n\n\n\n\n// Tuning, including REST for consistency (credz part)\n#define CF_REST (0.000)\n#define CP_REST (0.00000000000000000000)\n#define CF_C4 (277.180)\n#define CP_C4 (0.00360776390792986491)\n#define CF_D4 (293.660)\n#define CP_D4 (0.00340529864469113919)\n#define CF_E4 (329.630)\n#define CP_E4 (0.00303370445651184647)\n#define CF_F4 (369.990)\n#define CP_F4 (0.00270277575069596473)\n#define CF_G4 (392.000)\n#define CP_G4 (0.00255102040816326510)\n#define CF_A4 (440.000)\n#define CP_A4 (0.00227272727272727262)\n#define CF_B4 (493.880)\n#define CP_B4 (0.00202478334818174477)\n#define CF_C5 (554.370)\n#define CP_C5 (0.00180384941465086502)\n#define CF_D5 (587.330)\n#define CP_D5 (0.00170262033269201279)\n#define CF_E5 (659.250)\n#define CP_E5 (0.00151687523701175570)\n#define CF_F5 (739.990)\n#define CP_F5 (0.00135136961310287971)\n#define CF_G5 (783.990)\n#define CP_G5 (0.00127552647355195863)\n#define CF_A5 (880.000)\n#define CP_A5 (0.00113636363636363631)\n#define CF_B5 (987.770)\n#define CP_B5 (0.00101238142482561731)\n#define CF_C6 (1108.730)\n#define CP_C6 (0.00090193284208057870)\n#define CF_D6 (1174.660)\n#define CP_D6 (0.00085131016634600639)\n\n// LUT function from integer pitch number to freq and period\n// (credz part, whence _c_notefreq)\nvec2 cnotefreq(in float pitch_num)\n{\n    vec2 retval = vec2(CF_REST, CP_REST);\n\n    retval = mix(retval, vec2(CF_REST,CP_REST), step(0.0, pitch_num));\n    retval = mix(retval, vec2(CF_C4,CP_C4), step(1.0, pitch_num));\n    retval = mix(retval, vec2(CF_D4,CP_D4), step(2.0, pitch_num));\n    retval = mix(retval, vec2(CF_E4,CP_E4), step(3.0, pitch_num));\n    retval = mix(retval, vec2(CF_F4,CP_F4), step(4.0, pitch_num));\n    retval = mix(retval, vec2(CF_G4,CP_G4), step(5.0, pitch_num));\n    retval = mix(retval, vec2(CF_A4,CP_A4), step(6.0, pitch_num));\n    retval = mix(retval, vec2(CF_B4,CP_B4), step(7.0, pitch_num));\n    retval = mix(retval, vec2(CF_C5,CP_C5), step(8.0, pitch_num));\n    retval = mix(retval, vec2(CF_D5,CP_D5), step(9.0, pitch_num));\n    retval = mix(retval, vec2(CF_E5,CP_E5), step(10.0, pitch_num));\n    retval = mix(retval, vec2(CF_F5,CP_F5), step(11.0, pitch_num));\n    retval = mix(retval, vec2(CF_G5,CP_G5), step(12.0, pitch_num));\n    retval = mix(retval, vec2(CF_A5,CP_A5), step(13.0, pitch_num));\n    retval = mix(retval, vec2(CF_B5,CP_B5), step(14.0, pitch_num));\n    retval = mix(retval, vec2(CF_C6,CP_C6), step(15.0, pitch_num));\n    retval = mix(retval, vec2(CF_D6,CP_D6), step(16.0, pitch_num));\n\n    return retval;\n}\n\n// Score\n// Christmas, CM.  Transcribed by cxw from Harmonia Sacra, 1812,\n// arr. from Handel.  https://hymnary.org/media/fetch/106008\n\nvec4 get_song_data_credz_voice1(in float beat_in_pattern)\n{\n    vec4 retval; //(pitchnum, dynamics, startbeat, endbeat)\n        // frequency < 1.0 => no sound\n    retval = vec4(0.0);     // by default, no sound\n    retval = mix(retval, vec4(0.0, 1.000, 0.000, 3.000), step(0.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 3.000, 3.750), step(3.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 3.750, 4.000), step(3.750, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 4.000, 5.000), step(4.000, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 5.000, 6.000), step(5.000, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 6.000, 7.000), step(6.000, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 7.000, 8.000), step(7.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 8.000, 9.000), step(8.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 9.000, 9.750), step(9.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 9.750, 10.000), step(9.750, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 10.000, 10.938), step(10.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 10.938, 11.000), step(10.938, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 11.000, 11.750), step(11.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 11.750, 12.000), step(11.750, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 12.000, 12.938), step(12.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 12.938, 13.000), step(12.938, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 13.000, 13.938), step(13.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 13.938, 14.000), step(13.938, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 14.000, 15.000), step(14.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 15.000, 15.500), step(15.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 15.500, 15.938), step(15.500, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 15.938, 16.000), step(15.938, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 1.000, 16.000, 17.000), step(16.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 17.000, 18.938), step(17.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 18.938, 19.000), step(18.938, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 19.000, 19.500), step(19.000, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 19.500, 20.000), step(19.500, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 1.000, 20.000, 21.000), step(20.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 21.000, 22.000), step(21.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 22.000, 22.938), step(22.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 22.938, 23.000), step(22.938, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 23.000, 23.938), step(23.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 23.938, 24.000), step(23.938, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 1.000, 24.000, 25.000), step(24.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 25.000, 25.500), step(25.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 25.500, 26.000), step(25.500, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 26.000, 27.000), step(26.000, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 27.000, 27.500), step(27.000, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 27.500, 28.000), step(27.500, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 1.000, 28.000, 29.000), step(28.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 29.000, 30.000), step(29.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 30.000, 31.000), step(30.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 31.000, 32.000), step(31.000, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 1.000, 32.000, 33.000), step(32.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 33.000, 35.000), step(33.000, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 0.900, 35.000, 36.000), step(35.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 36.000, 37.000), step(36.000, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 37.000, 38.000), step(37.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 38.000, 39.000), step(38.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 39.000, 40.000), step(39.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 40.000, 43.000), step(40.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 43.000, 44.000), step(43.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 1.000, 44.000, 47.000), step(44.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 47.000, 47.750), step(47.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 47.750, 48.000), step(47.750, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 48.000, 49.000), step(48.000, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 49.000, 50.000), step(49.000, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 50.000, 51.000), step(50.000, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 0.900, 51.000, 52.000), step(51.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 52.000, 53.000), step(52.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 53.000, 53.750), step(53.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 53.750, 54.000), step(53.750, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 54.000, 54.938), step(54.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 54.938, 55.000), step(54.938, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 55.000, 55.750), step(55.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 55.750, 56.000), step(55.750, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 56.000, 56.938), step(56.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 56.938, 57.000), step(56.938, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 57.000, 57.938), step(57.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 57.938, 58.000), step(57.938, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 58.000, 59.000), step(58.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 59.000, 59.500), step(59.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 59.500, 59.938), step(59.500, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 59.938, 60.000), step(59.938, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 1.000, 60.000, 61.000), step(60.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 61.000, 62.938), step(61.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 62.938, 63.000), step(62.938, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 63.000, 63.500), step(63.000, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 63.500, 64.000), step(63.500, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 1.000, 64.000, 65.000), step(64.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 65.000, 66.000), step(65.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 66.000, 66.938), step(66.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 66.938, 67.000), step(66.938, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 67.000, 67.938), step(67.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 67.938, 68.000), step(67.938, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 1.000, 68.000, 69.000), step(68.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 69.000, 69.500), step(69.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 69.500, 70.000), step(69.500, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 70.000, 71.000), step(70.000, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 71.000, 71.500), step(71.000, beat_in_pattern));\n    retval = mix(retval, vec4(8.0, 0.900, 71.500, 72.000), step(71.500, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 1.000, 72.000, 73.000), step(72.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 73.000, 74.000), step(73.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 74.000, 75.000), step(74.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 75.000, 76.000), step(75.000, beat_in_pattern));\n    retval = mix(retval, vec4(7.0, 1.000, 76.000, 77.000), step(76.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 77.000, 79.000), step(77.000, beat_in_pattern));\n    retval = mix(retval, vec4(10.0, 0.900, 79.000, 80.000), step(79.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 80.000, 81.000), step(80.000, beat_in_pattern));\n    retval = mix(retval, vec4(9.0, 0.900, 81.000, 82.000), step(81.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 82.000, 83.000), step(82.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 83.000, 84.000), step(83.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 84.000, 87.000), step(84.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 87.000, 88.000), step(87.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 1.000, 88.000, 1088.000), step(88.000, beat_in_pattern));\n    return retval;\n} //get_song_data_credz_voice1()\n\nvec4 get_song_data_credz_voice2(in float beat_in_pattern)\n{\n    vec4 retval; //(pitchnum, dynamics, startbeat, endbeat)\n        // frequency < 1.0 => no sound\n    retval = vec4(0.0);     // by default, no sound\n    retval = mix(retval, vec4(0.0, 1.000, 0.000, 3.000), step(0.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 3.000, 3.750), step(3.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 3.750, 4.000), step(3.750, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 4.000, 5.000), step(4.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 5.000, 6.000), step(5.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 6.000, 6.500), step(6.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 6.500, 7.000), step(6.500, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 7.000, 8.000), step(7.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 8.000, 9.000), step(8.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 9.000, 9.750), step(9.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 9.750, 10.000), step(9.750, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 10.000, 10.938), step(10.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 10.938, 11.000), step(10.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 11.000, 11.938), step(11.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 11.938, 12.000), step(11.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 12.000, 12.938), step(12.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 12.938, 13.000), step(12.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 13.000, 13.938), step(13.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 13.938, 14.000), step(13.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 14.000, 14.500), step(14.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 14.500, 15.000), step(14.500, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 15.000, 15.500), step(15.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 15.500, 15.938), step(15.500, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 15.938, 16.000), step(15.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 16.000, 17.000), step(16.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 17.000, 18.938), step(17.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 18.938, 19.000), step(18.938, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 19.000, 20.000), step(19.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 20.000, 20.500), step(20.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 20.500, 21.000), step(20.500, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 21.000, 22.000), step(21.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 22.000, 23.000), step(22.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 23.000, 24.000), step(23.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 24.000, 24.938), step(24.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 24.938, 25.000), step(24.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 25.000, 25.938), step(25.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 25.938, 26.000), step(25.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 26.000, 27.000), step(26.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 27.000, 28.000), step(27.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 1.000, 28.000, 29.000), step(28.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 29.000, 30.000), step(29.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 30.000, 30.938), step(30.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 30.938, 31.000), step(30.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 31.000, 31.938), step(31.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 31.938, 32.000), step(31.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 32.000, 35.000), step(32.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 35.000, 36.000), step(35.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 1.000, 36.000, 37.000), step(36.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 37.000, 37.750), step(37.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 37.750, 38.000), step(37.750, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 38.000, 39.000), step(38.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 39.000, 40.000), step(39.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 40.000, 43.000), step(40.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 43.000, 44.000), step(43.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 1.000, 44.000, 47.000), step(44.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 47.000, 47.750), step(47.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 47.750, 48.000), step(47.750, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 48.000, 49.000), step(48.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 49.000, 50.000), step(49.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 50.000, 50.500), step(50.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 50.500, 51.000), step(50.500, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 51.000, 52.000), step(51.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 52.000, 53.000), step(52.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 53.000, 53.750), step(53.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 53.750, 54.000), step(53.750, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 54.000, 54.938), step(54.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 54.938, 55.000), step(54.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 55.000, 55.938), step(55.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 55.938, 56.000), step(55.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 56.000, 56.938), step(56.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 56.938, 57.000), step(56.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 57.000, 57.938), step(57.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 57.938, 58.000), step(57.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 58.000, 58.500), step(58.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 58.500, 59.000), step(58.500, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 59.000, 59.500), step(59.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 59.500, 59.938), step(59.500, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 59.938, 60.000), step(59.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 60.000, 61.000), step(60.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 61.000, 62.938), step(61.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 62.938, 63.000), step(62.938, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 0.900, 63.000, 64.000), step(63.000, beat_in_pattern));\n    retval = mix(retval, vec4(6.0, 1.000, 64.000, 64.500), step(64.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 0.900, 64.500, 65.000), step(64.500, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 65.000, 66.000), step(65.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 66.000, 67.000), step(66.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 67.000, 68.000), step(67.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 68.000, 68.938), step(68.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 68.938, 69.000), step(68.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 69.000, 69.938), step(69.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 69.938, 70.000), step(69.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 70.000, 71.000), step(70.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 71.000, 72.000), step(71.000, beat_in_pattern));\n    retval = mix(retval, vec4(5.0, 1.000, 72.000, 73.000), step(72.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 0.900, 73.000, 74.000), step(73.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 74.000, 74.938), step(74.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 74.938, 75.000), step(74.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 75.000, 75.938), step(75.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 75.938, 76.000), step(75.938, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 76.000, 79.000), step(76.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 79.000, 80.000), step(79.000, beat_in_pattern));\n    retval = mix(retval, vec4(4.0, 1.000, 80.000, 81.000), step(80.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 81.000, 81.750), step(81.000, beat_in_pattern));\n    retval = mix(retval, vec4(3.0, 0.900, 81.750, 82.000), step(81.750, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 0.900, 82.000, 83.000), step(82.000, beat_in_pattern));\n    retval = mix(retval, vec4(1.0, 0.900, 83.000, 84.000), step(83.000, beat_in_pattern));\n    retval = mix(retval, vec4(2.0, 1.000, 84.000, 87.000), step(84.000, beat_in_pattern));\n    retval = mix(retval, vec4(0.0, 0.900, 87.000, 88.000), step(87.000, beat_in_pattern));\n    return retval;\n} //get_song_data_credz_voice2()\n\n\n\n\n// Melody ///////////////////////////////////////////////////////////////\n\n#define MELODY_RAMP_TIME_SEC (0.02)\n    // Attack time\n#define MELODY_RAMPDOWN_TIME_SEC (0.05)\n    // Release time\n\n\n\n\nfloat do_melody(in float beat_in_pattern, in float time)\n{ //time is the global time\n\n    // Get the current note (which may be a rest)\n    vec4 note = get_song_data_melody(beat_in_pattern);\n\n    \n    // Unpack the note\n    float pitchnum = note[0];\n    float freq_hz, period_sec;\n\n    {\n        vec2 fp = notefreq(pitchnum);\n        freq_hz = fp[0];\n        period_sec = fp[1];\n    }\n\n    float dynamics = pow(note[1], DYN_EXP);\n\n    float start_beat = note[2] ;\n        // should be <= beat_in_pattern\n    float end_beat = note[3] ;\n                                    // note covers [start_beat, end_beat)\n    float time_in_note =\n        max(0.0, time - (start_beat * SPB));\n\n\n\n    if(freq_hz<1.0) return 0.0;     //early bail on rests\n\n    //Make the sound.\n    float wave = do_square(time, freq_hz, period_sec);\n\n    // Envelope - smooth transition at beginning and end of note.\n\n    //attack\n    float envelope = smoothstep(0.0, MELODY_RAMP_TIME_SEC, time_in_note);\n\n    // release\n    float end_time = end_beat * SPB;\n    envelope *= (1.0 - smoothstep(end_time - MELODY_RAMPDOWN_TIME_SEC,\n                                    end_time, time_in_note));\n\n    return wave * envelope * dynamics;\n} //do_melody\n\n// Harmony //////////////////////////////////////////////////////////////\n\n#define HARMONY_RAMP_TIME_SEC (0.02)\n    // Attack time\n#define HARMONY_RAMPDOWN_TIME_SEC (0.05)\n    // Release time\n\nfloat do_harmony(in float beat_in_pattern, in float time)\n{ //time is the global time\n\n    // Get the current note (which may be a rest)\n    vec4 note = get_song_data_harmony(beat_in_pattern);\n\n    \n    // Unpack the note\n    float pitchnum = note[0];\n    float freq_hz, period_sec;\n\n    {\n        vec2 fp = notefreq(pitchnum);\n        freq_hz = fp[0];\n        period_sec = fp[1];\n    }\n\n    float dynamics = pow(note[1], DYN_EXP);\n\n    float start_beat = note[2] ;\n        // should be <= beat_in_pattern\n    float end_beat = note[3] ;\n                                    // note covers [start_beat, end_beat)\n    float time_in_note =\n        max(0.0, time - (start_beat * SPB));\n\n\n\n    if(freq_hz<1.0) return 0.0;     //early bail on rests\n\n    //Make the sound.\n    float wave = do_tri(time, freq_hz, period_sec);\n\n    // Envelope - smooth transition at beginning and end of note.\n\n    //attack\n    float envelope = smoothstep(0.0, HARMONY_RAMP_TIME_SEC, time_in_note);\n\n    // release\n    float end_time = end_beat * SPB;\n    envelope *= (1.0 - smoothstep(end_time - HARMONY_RAMPDOWN_TIME_SEC,\n                                    end_time, time_in_note));\n\n    return wave * envelope * dynamics;\n} //do_harmony\n\n// Jingle ///////////////////////////////////////////////////////////////\n\n// part names, since gen-msx doesn't know them yet.\n#define START_BLANK START_SECS_0\n#define START_LOGOFADEIN START_SECS_1\n#define START_INTRO START_SECS_2\n#define START_LOGOFADEOUT START_SECS_3\n#define END_LOGOFADEOUT START_SECS_4\n#define START_MAIN START_SECS_4\n#define START_GREETZ START_SECS_5\n#define START_CREDZ START_SECS_6\n#define START_ENDPART START_SECS_7\n\n// Duration of the fadeout at the end of the logo\n#define JFADE_TIME (5.0)\n\n// How sharp the release is\n#define ATTACK_EXP (1.0)\n\n#define LFO_FREQ_HZ (3.5)\n\n// Jingle is adapted from one by makro\n\nvec2 do_jingle(in float beat_in_pattern, in float time)\n{\n    vec4 voice1 = get_song_data_jingle_voice1(beat_in_pattern);\n    vec4 voice2 = get_song_data_jingle_voice2(beat_in_pattern);\n\n    float v1=0.0, v2=0.0;   // Output vars\n\n    \n\n    if(voice1[0]>=1.0) {    // Render voice 1\n        \n    // Unpack the note\n    float v1_pitchnum = voice1[0];\n    float v1_freq_hz, v1_period_sec;\n\n    {\n        vec2 v1_fp = notefreq(v1_pitchnum);\n        v1_freq_hz = v1_fp[0];\n        v1_period_sec = v1_fp[1];\n    }\n\n    float v1_dynamics = pow(voice1[1], DYN_EXP);\n\n    float v1_start_beat = voice1[2] ;\n        // should be <= beat_in_pattern\n    float v1_end_beat = voice1[3] ;\n                                    // note covers [start_beat, end_beat)\n    float v1_time_in_note =\n        max(0.0, time - (v1_start_beat * SPB));\n\n\n                float v1_note_duration =\n            ((v1_end_beat - v1_start_beat)*SPB);\n\n        // map time to 0 at the start of the note, 1 at the end\n        float v1_note_pct =\n            v1_time_in_note / v1_note_duration;\n\n        // Sag the curve in the middle so the release is sharper,\n        // if that's what the note calls for.\n\n        // TODO RESUME HERE - this makes the strength of the release depend\n        // on the duration of the note.  Fix this.\n\n        float v1_envelope = exp(-v1_time_in_note * voice1[1]\n                                    * ATTACK_EXP);\n            // invar[1] = dynamics\n            // dynamics=0 => constant volume.\n            // as dynamics increases, the release gets sharper.\n\n        v1 = v1_envelope * do_square(time, v1_freq_hz, v1_period_sec);\n    }\n\n    float gain;\n    if(voice2[0]>=1.0) {    // Render voice 2, plus LFO\n        \n    // Unpack the note\n    float v2_pitchnum = voice2[0];\n    float v2_freq_hz, v2_period_sec;\n\n    {\n        vec2 v2_fp = notefreq(v2_pitchnum);\n        v2_freq_hz = v2_fp[0];\n        v2_period_sec = v2_fp[1];\n    }\n\n    float v2_dynamics = pow(voice2[1], DYN_EXP);\n\n    float v2_start_beat = voice2[2] ;\n        // should be <= beat_in_pattern\n    float v2_end_beat = voice2[3] ;\n                                    // note covers [start_beat, end_beat)\n    float v2_time_in_note =\n        max(0.0, time - (v2_start_beat * SPB));\n\n\n                float v2_note_duration =\n            ((v2_end_beat - v2_start_beat)*SPB);\n\n        // map time to 0 at the start of the note, 1 at the end\n        float v2_note_pct =\n            v2_time_in_note / v2_note_duration;\n\n        // Sag the curve in the middle so the release is sharper,\n        // if that's what the note calls for.\n\n        // TODO RESUME HERE - this makes the strength of the release depend\n        // on the duration of the note.  Fix this.\n\n        float v2_envelope = exp(-v2_time_in_note * voice2[1]\n                                    * ATTACK_EXP);\n            // invar[1] = dynamics\n            // dynamics=0 => constant volume.\n            // as dynamics increases, the release gets sharper.\n\n        v2 = v2_envelope * do_tri(time, v2_freq_hz, v2_period_sec);\n\n        float effect_gain = abs(sin(TWO_PI*LFO_FREQ_HZ*time));\n        gain = mix(1.0, effect_gain, v2_note_pct);\n            // ramp dry to wet linearly\n    } else {\n        gain = 1.0;\n    }\n\n    // Global fade at the end of the jingle\n    gain = gain * (1.0 - smoothstep(END_LOGOFADEOUT-JFADE_TIME, END_LOGOFADEOUT, time));\n    return vec2(v1, v2) * gain;\n} //do_jingle\n\n// Credz part ///////////////////////////////////////////////////////////\n\n#define START_BEATS_CREDZ START_BEATS_6\n#define END_SECS_CREDZ START_SECS_7\n\nvoid do_credz(in float beat_in_pattern, in float time,\n                out float L, out float R)\n{\n    float v1=0.0, v2=0.0;\n\n    vec4 voice1 =\n        get_song_data_credz_voice1(beat_in_pattern - START_BEATS_CREDZ);\n    vec4 voice2 =\n        get_song_data_credz_voice2(beat_in_pattern - START_BEATS_CREDZ);\n\n    if(voice1[0] >= 1.0) {\n        \n    // Unpack the note\n    float v1_pitchnum = voice1[0];\n    float v1_freq_hz, v1_period_sec;\n\n    {\n        vec2 v1_fp = cnotefreq(v1_pitchnum);\n        v1_freq_hz = v1_fp[0];\n        v1_period_sec = v1_fp[1];\n    }\n\n    float v1_dynamics = pow(voice1[1], DYN_EXP);\n\n    float v1_start_beat = voice1[2] +START_BEATS_CREDZ;\n        // should be <= beat_in_pattern\n    float v1_end_beat = voice1[3] +START_BEATS_CREDZ;\n                                    // note covers [start_beat, end_beat)\n    float v1_time_in_note =\n        max(0.0, time - (v1_start_beat * SPB));\n\n\n        v1 = do_square(time, v1_freq_hz, v1_period_sec);\n    }\n\n    if(voice2[0] >= 1.0) {\n        \n    // Unpack the note\n    float v2_pitchnum = voice2[0];\n    float v2_freq_hz, v2_period_sec;\n\n    {\n        vec2 v2_fp = cnotefreq(v2_pitchnum);\n        v2_freq_hz = v2_fp[0];\n        v2_period_sec = v2_fp[1];\n    }\n\n    float v2_dynamics = pow(voice2[1], DYN_EXP);\n\n    float v2_start_beat = voice2[2] +START_BEATS_CREDZ;\n        // should be <= beat_in_pattern\n    float v2_end_beat = voice2[3] +START_BEATS_CREDZ;\n                                    // note covers [start_beat, end_beat)\n    float v2_time_in_note =\n        max(0.0, time - (v2_start_beat * SPB));\n\n\n        v2 = do_tri(time, v2_freq_hz, v2_period_sec);\n    }\n\n    // Global fade at the end of the jingle\n    float gain =\n        (1.0 - smoothstep(END_SECS_CREDZ-JFADE_TIME, END_SECS_CREDZ, time));\n    L = v1 ;// * gain;\n    R = v2 ;// * gain;\n} //do_credz\n\n// mainSound( in int samp,) //////////////////////////////////////////////////////////\n\nvec2 mainSound( in int samp, float time )\n{\n    float t = time + START_OFS_SEC;\n\n    //t += START_CREDZ - 3.0; //DEBUG\n\n    if(t < MUSIC_START_TIME) { return vec2(0.0); }\n    t -= MUSIC_START_TIME;\n        //because I had better luck not starting right at t=0.\n\n    float music_t = t;\n        // was mod(t, PATTERN_DURATION_SEC); //within one pattern\n        // but I'm not actually repeating a pattern.\n    float beat_in_pattern = mod(music_t*BPS, BPP);\n    float time_in_beat = mod(music_t, SPB);\n\n    float L=0.0, R=0.0;\n\n    if(t < END_LOGOFADEOUT) {            // Jingle\n        vec2 result = do_jingle(beat_in_pattern, music_t);\n        L = result.x;\n        R = result.y;\n    } else if(t < START_CREDZ) {         // Regular music\n        L = do_melody(beat_in_pattern, music_t);            //mono\n        R = do_harmony(beat_in_pattern, music_t);           //mono\n    }\n    else if(t < MUSIC_DURATION_SEC) {    // Credits part\n        do_credz(beat_in_pattern, music_t, L, R);\n    }\n\n    return vec2(    // a bit of stereo separation\n        mix(L, R, 0.25),\n        mix(L, R, 0.75)\n    );\n\n} //mainSound\n\n// vi: set ts=4 sts=4 sw=4 et ai: //\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}