{
    "Shader": {
        "info": {
            "date": "1551034990",
            "description": "Shader made for the Cookie Fanzine #001.\nhttps://twitter.com/CookieDemoparty/status/1098933599817089025\n\nYou can use the mouse to explore this shader.\nShader is non-dependent of time, so you can hit pause to avoid GPU consumption.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsfSWr",
            "likes": 26,
            "name": "Etching",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 1,
            "username": "lsdlive",
            "viewed": 1100
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nStatic image generated with sphere-tracing algorithm for the printed Cookie Fanzine #001.\nhttps://twitter.com/CookieDemoparty/status/1098933599817089025\n\nYou can use the mouse to explore this shader.\n\n\nGeometries are generated with sphere-tracing algorithm:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nMore about triplanar mapping:\nhttps://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/\n\nSome notation:\nro: ray origin\np: position (usually in world space)\nn: normal\nrd: ray direction from eye to position on the surface (eye or view vector)\nld: light direction\n\n*/\n\n// Put this to 3, slow down the GPU, but give better results,\n// mainly because of the use of non-screenspace dithering.\nconst int ANTIALIAS = 3;\n\n#define luma(c) (c.r * .299 + c.g * .587 + c.b * .114)\n\nvec3 palette(float x) {\n\treturn mix(\n\t\tmix(vec3(.009, .01, .042), vec3(.55, .42, .53), smoothstep(.23, .4, x)),\n\t\tmix(vec3(.83, .81, .88), vec3(.93, .88, .93), smoothstep(.44, .5, x)),\n\t\tx\n\t);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\t// Explained here why you still get an anti-clockwise rotation with this matrix:\n\t// https://www.shadertoy.com/view/wdB3DW\n\treturn mat2(c, s, -s, c);\n}\n\nvoid apply_transform(inout vec3 p) {\n\tif (iMouse.z > 0.) {\n\t\tp.xz *= r2d(-iMouse.x*10. / iResolution.x);\n\t\tp.xy *= r2d(-iMouse.y*10. / iResolution.y);\n\t}\n\telse {\n\t\tp.xz *= r2d(2.8);\n\t}\n}\n\nvec3 re(vec3 p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\nvoid amod2(inout vec2 p, float d) {\n\t// should be atan(p.y, p.x) but I had this function for a while\n\t// and putting parameters like this add a PI/6 rotation.\n\tfloat a = re(vec3(atan(p.x, p.y)), d).x; \n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp = abs(p) - d;\n\tif (p.y > p.x)p = p.yx;\n}\n\n// chamfer minimum from hglib\n// http://mercury.sexy/hg_sdf/\nfloat cmin(float a, float b, float k) {\n\treturn min(min(a, b), (a - k + b) * sqrt(.5));\n}\n\n// signed cross\nfloat sc(vec3 p, float s) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - s;\n}\n\n// octahedron\nfloat od(vec3 p, float s) {\n\treturn dot((p), normalize(sign(p))) - s;\n}\n\n// box\nfloat box(vec3 p, vec3 b) {\n\tb = abs(p) - b;\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\n}\n\nfloat de(vec3 p) {\n\tapply_transform(p);\n\n\n\tp.xy *= r2d(3.14 / 2.);\n\n    \n    // Plane in the background\n\tvec3 q = p;\n\tp.xy *= r2d(3.14 / 4.);\n\tfloat m = .25;\n\tp.z = mod(p.z - m * .5, m) - m * .5;\n\tp.xy += 4.5;\n\tfloat b1 = box(p, vec3(.02, 23.5, .1));\n\n\n    // Two spheres\n\tp = q;\n    p -= vec3(0, .3, .6);\n\tfloat sph1 = length(p) - .3;\n    p -= vec3(-.1, .4, 1.5);\n\tfloat sph2 = length(p) - .05;\n\n    // Fractal shape\n\tp = q;\n\tmo(p.xz, vec2(2.8));\n\tmo(p.xy, vec2(1.2));\n\n\tmo(p.xz, vec2(2.03, .3));\n\tp.xy *= r2d(3.14 / 2.2);\n\n\tmo(p.xz, vec2(.5, .4));\n\tamod2(p.xz, 8.);// experimental value, should be 6.28/n\n\n    // Construct the main shape\n\tfloat d = od(p, .7);\n\td = cmin(d, sc(p, .03), .3);\n\td = max(d, box(p, vec3(4)));\n\n\t// Add other shapes\n\td = min(d, b1);\n\td = min(d, sph1);\n\td = min(d, sph2);\n\n\treturn d;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\treturn normalize(vec3(\n\t\tde(p + e.xyy) - de(p - e.xyy),\n\t\tde(p + e.yxy) - de(p - e.yxy),\n\t\tde(p + e.yyx) - de(p - e.yyx)\n\t));\n}\n\n// dithering\nfloat tex2D(vec2 uv) {\n\tfloat res_pixelate = 40.; // = iResolution (pixelated)\n\tvec2 pix_coord = floor(uv * res_pixelate); // = fragCoord (pixelated)\n\tuv = pix_coord / res_pixelate;\n\n\t// if you use bayer texture, don't forget to put \"nearest\" in the options\n\treturn texture(iChannel0, pix_coord / 8.).r;\n}\n\n// triplanar\nfloat tex3D(vec3 p, vec3 n) {\n\tfloat blend_exponent = 32.;\n\tvec3 weight = pow(abs(n), vec3(blend_exponent));\n\tweight /= (weight.x + weight.y + weight.z);\n\n\treturn\n\t\ttex2D(p.yz) * weight.x +\n\t\ttex2D(p.zx) * weight.y +\n\t\ttex2D(p.xy) * weight.z;\n}\n\n// from iq\nfloat calculate_ao(vec3 p, vec3 n) {\n\tconst float AO_SAMPLES = 5.;\n\tfloat r = 0., w = 1., d;\n\n\tfor (float i = 1.; i < AO_SAMPLES + 1.1; i++) {\n\t\td = i / AO_SAMPLES;\n\t\tr += w * (d - de(p + n * d));\n\t\tw *= .5;\n\t}\n\n\treturn 1. - clamp(r, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0, 0, -3);\n\tvec3 col = vec3(0);\n\n\tfor (int j = 0; j < ANTIALIAS; j++) {\n\t\tfor (int i = 0; i < ANTIALIAS; i++) {\n\t\t\tvec2 off = vec2(float(i), float(j)) / float(ANTIALIAS);\n\n\t\t\tvec2 uv = (fragCoord.xy + off) / iResolution.xy - .5;\n\t\t\tuv.x *= iResolution.x / iResolution.y;\n\n\t\t\t// it was faster to move the frame like this for the composition\n\t\t\tuv -= vec2(.4, .08);\n\n            vec3 rd = normalize(vec3(uv, .6 - length(uv)));// cheap lens distortion\n            vec3 p;\n            \n\t\t\tfloat t = 0., tmax = 25.;\n\t\t\tfor (float i = 0.; i < 1.; i += .01) {\n\t\t\t\tp = ro + rd * t;\n\t\t\t\tfloat d = de(p);\n\t\t\t\tif (d < .001 || t > tmax)\n                    break;\n\t\t\t\tt += d;\n\t\t\t}\n\n\t\t\tvec3 c = vec3(.4, .1, .1);\n\t\t\tif (t <= tmax) {\n\t\t\t\tvec3 n = normal(p);\n                vec3 ld = normalize(vec3(1, 1, -3));\n\t\t\t\tfloat dotNL = max(0., dot(n, ld));\n\t\t\t\tfloat ao = calculate_ao(p, n);\n\n\t\t\t\tapply_transform(p);\n\t\t\t\tapply_transform(n);\n\n\t\t\t\tfloat dither_pattern = tex3D(p, n);\n\n\t\t\t\tvec3 albedo = vec3(smoothstep(-.5, 1., n.y),\n\t\t\t\t\tsmoothstep(-1., 1., n.y),\n\t\t\t\t\tsmoothstep(-.2, 1., n.y));\n\n\t\t\t\tc = albedo * ao * (.5 * dotNL + .5);\n\t\t\t\tc = step(dither_pattern, c);\n\t\t\t\tc = palette(luma(c));\n\t\t\t}\n\n\t\t\tcol += c;\n\n\t\t}\n\t}\n\tcol /= float(ANTIALIAS * ANTIALIAS);\n\n\t// gamma\n\tcol = pow(col, vec3(.4545));;\n\t// vignetting\n\tvec2 q = fragCoord / iResolution.xy;\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\n\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}