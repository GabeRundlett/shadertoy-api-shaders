{
    "Shader": {
        "info": {
            "date": "1499028361",
            "description": "A simple shader animating the Julia fractal/set.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sSBRz",
            "likes": 1,
            "name": "Julia 9001",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "johannesCmayer",
            "viewed": 240
        },
        "renderpass": [
            {
                "code": "//#define animateIterations\n//#define zoom\n//#define animateColor\n//#define constantCoordinate\n#define GenerateJuliaSet\n#define AnimateJulia\nfloat juliaRealMax = .8;\nfloat juliaRealMin;\nfloat juliaImagenaryMax = .8;\nfloat juliaImagenaryMin;\n\n#define t iTime / 5.\n\n#define maxIterationsC 500.\nfloat minIterationsC = 10.;\n\nvec2 offset = vec2(0., 0.);\n\nstruct Coordinates\n{\n    float real;\n    float imagenary;\n};\n\nstruct FracOutput\n{\n    float iterations;\n    float real;\n    float imaginary;\n};\n    \nFracOutput JuliaFunc(float maxIterations, Coordinates coordinates, Coordinates fixedpoint)\n{\n    float real = coordinates.real;\n    float imaginary = coordinates.imagenary;\n    \n    float iterations = 0.;    \n    \n   \tfor (float i = 0.; i < maxIterations; i++)\n    {\n        iterations++;\n                        \n        if (pow(real, 2.) + pow(imaginary, 2.) > 4.)                    \n            return FracOutput(iterations, real, imaginary);\n               \n        float temp = real;\n        real = real * real - imaginary * imaginary + fixedpoint.real;\n        imaginary = 2. * temp * imaginary + fixedpoint.imagenary;        \n    }\n    \n    return FracOutput(iterations, real, imaginary);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef animateIterations\n    float maxIterations = maxIterationsC * abs(sin(iTime)) + minIterationsC;    \n    #else\n    float maxIterations = maxIterationsC;\n    #endif\n        \n    Coordinates coordinates;\n  \n    #ifdef constantCoordinate\n    coordinates.real = 1. / 100.;\n    coordinates.imagenary = 1. / 100.;\n    #else\n    coordinates.real = (fragCoord.x - iResolution.x / 2. + offset.x) / (iResolution.x / 4.);\n    coordinates.imagenary = (fragCoord.y - iResolution.y / 2. + offset.y) / (iResolution.y / 4.);\n    #endif\n    \n    #ifdef zoom\n    coordinates.real /= (sin(iTime * 0.1) * 1000.);\n    coordinates.imagenary /= (sin(iTime * 0.1) * 1000.);\n    #endif\n    \n    Coordinates fixedPoint;\n    fixedPoint.real = (sin(t * 1.33) * juliaRealMax - juliaRealMin) + juliaRealMin;\n    fixedPoint.imagenary = (sin(t) * juliaImagenaryMax - juliaImagenaryMin) + juliaImagenaryMin;\n    \n    FracOutput ret = JuliaFunc(maxIterations, coordinates, fixedPoint);\n         \n    vec4 color;\n    \n    if (ret.iterations >= maxIterations)\n        //color = vec4(abs(sin(t * 1000.) / 100.), 0., 0., 1.);\n        color = vec4(abs(ret.real),abs(ret.imaginary),0.8,1.);\n        else\n    \tcolor = vec4(ret.iterations / 16., ret.iterations / 32., ret.iterations / 8., 1.);\n    \n    #ifdef animateColor\n    fragColor = color;\n    #else\n    fragColor = color;\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}