{
    "Shader": {
        "info": {
            "date": "1630614110",
            "description": "A simple Buffer feedback test. MODE 0 for classic Game of Life. MODE 1 for experiment with food availability, MODE 2 for the Anneal algorithm. See: https://en.wikipedia.org/wiki/Life-like_cellular_automaton",
            "flags": 32,
            "hasliked": 0,
            "id": "fdt3DS",
            "likes": 4,
            "name": "ConwaysGameOfLife+Others",
            "published": 3,
            "tags": [
                "automata",
                "cellular",
                "buffer",
                "gameoflife"
            ],
            "usePreview": 0,
            "username": "hjd3481",
            "viewed": 237
        },
        "renderpass": [
            {
                "code": "//See BufferA for the main code\n\n//seems that the 'wrap' mode does not save with the shader. \n// to use the pan and zoom, de-select and re-select \"repeat\" for \n// the \"wrap\" option in the iChannel0 settings, then set the below to 1.\n#define PANANDZOOM 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv= fragCoord/iResolution.xy;\n    \n    //whole numbers will keep regular pixel-scaling.\n    float zoom = 2.0;\n\n#if PANANDZOOM  \n    zoom =  mix(4.0,1.0,sin(iTime*0.051221)*0.5+0.5);\n    \n    uv -= 0.5;\n    \n    uv.x += zoom * fract( iTime*0.0213 );\n    uv.y += zoom * sin( iTime*0.0137 )*0.5;\n       \n#endif\n\n    uv /= zoom; //zoom in    \n\n    vec3 buff = texture( iChannel0, uv ).rgb;\n    \n    //mix in colours based on the raw data-buffer.\n    \n    vec3 col = vec3(0.1);\n    \n    col = mix( col, vec3(0.04,0.5,0.1), buff.y ); //food\n    \n    col = mix( col, vec3(1.0,0.75,0.1), float((buff.x > 0.9)) ); //age / alive\n    \n    fragColor.rgb = col;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define C_TL 0\n#define C_T  1\n#define C_TR 2\n#define C_L  3\n#define C_C  4\n#define C_R  5\n#define C_BL 6\n#define C_B  7\n#define C_BR 8\n        \n/////////////////////////////////////////////////////////////////        \n//Settings\n    \n//https://en.wikipedia.org/wiki/Life-like_cellular_automaton\n    \n//0 : Conways Game of Life (B3/S23)\n//1 : custom experiment \"hunger\"\n//2 : ANNEAL (B4678/S35678)\n\n#define CONWAY 0\n#define HUNGER 1\n#define ANNEAL 2\n\n//change this to try different algorithms\n//Restart the timer (rewind) the shader to re-generate the starting noise\n#define MODE 1\n\n//Increase this to slow down the frames per second of the sim.\n//Set to 1 for no delay (same fps as render)\n#define TICKDELAY 2\n\n/////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvCell = floor( fragCoord );\n    \n      \n    if( iFrame == 0 )\n    {\n        //just use the seconds to alter the hash, change this to a fixed number for repeat runs of the same seed\n        vec2 seed = vec2( iDate.w );\n        const float invOccupancy = 0.5; //increase to reduce starting living cells. start with 50-50%\n        \n        float cellStartValue = step( invOccupancy, hash12(uvCell + seed) );\n        float startFoodValue = mix( 0.8, 1.0, hash12(uvCell + seed * vec2(11.011331,9.753111))); \n        fragColor = vec4( vec3(cellStartValue, startFoodValue, 0.0 ), 1);\n        \n        return;\n    }\n    \n  \n    \n    vec2 uvFull = (fragCoord/iResolution.xy);    \n    vec3 cO = texture( iChannel0, uvFull).rgb;  \n    vec3 col = cO;\n    \n    //only perform the operation on the source data once every n frames, this slows our in-game framerate verses our draw refresh-rate\n    //increase the tickDelay to slow the update-speed, set to zero for realtime.\n    if(iFrame % TICKDELAY == 0) \n    {\n    \n \n        vec3 cell[9];\n\n        cell[C_TL] = texture( iChannel0, ( (fragCoord+vec2(-1.0,+1.0)) /iResolution.xy) ).rgb;  \n        cell[C_T ] = texture( iChannel0, ( (fragCoord+vec2(0.0,+1.0)) /iResolution.xy) ).rgb;  \n        cell[C_TR] = texture( iChannel0, ( (fragCoord+vec2(+1.0,+1.0)) /iResolution.xy) ).rgb;\n        \n        cell[C_L] = texture( iChannel0, ( (fragCoord+vec2(-1.0,0.0)) /iResolution.xy) ).rgb;  \n        cell[C_C] = cO;\n        cell[C_R] = texture( iChannel0, ( (fragCoord+vec2(+1.0,0.0)) /iResolution.xy) ).rgb;  \n        \n        cell[C_BL] = texture( iChannel0, ( (fragCoord+vec2(-1.0,-1.0)) /iResolution.xy) ).rgb;  \n        cell[C_B ] = texture( iChannel0, ( (fragCoord+vec2(0.0,-1.0)) /iResolution.xy) ).rgb;  \n        cell[C_BR] = texture( iChannel0, ( (fragCoord+vec2(+1.0,-1.0)) /iResolution.xy) ).rgb; \n\n        int numNeighbours = 0 ;\n        for(int i=0; i < 9; ++i)\n        {\n            //dont count ourselves - we can include oursleves and alter numbers below as an optimisation but its here for \n            // completeness / so our code more closely matches documentation\n            if(i != C_C)\n            {\n                // bool(float) is true for all non-zero values.\n                // int(bool) just turns the logical 'true' and 'false' into integer '1' and '0' respectively.\n                numNeighbours += int(bool(cell[i].x));\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////\n#if MODE == CONWAY\n        /////////////////////////////////////////////////////////////////\n        //conways game of life     \n\n        //test cell\n        col = vec3(0);\n        if( bool(cell[C_C].x) ) //is our cell alive? (float to bool -> 0.0 = false, otherwise true ).\n        {\n            if(numNeighbours == 2 || numNeighbours == 3) // < 2 underpopulation > 3 opverpopulation. 2 or 3, survive\n            {\n                col = vec3(1);\n            }\n        }\n        else //dead\n        {\n           if(numNeighbours == 3 ) //== 3 reproduction\n           {\n               col = vec3(1);\n           }\n        }\n        \n        /////////////////////////////////////////////////////////////////\n#elif MODE == HUNGER\n        /////////////////////////////////////////////////////////////////\n\n        float alive = cO.x;\n        float food = cO.y;\n        \n        //age\n        alive = max( 0.0, alive - 0.1 ); //\n        \n        //grow food back\n        food += 0.016;\n        \n        //test cell\n        if( bool(cell[C_C].x)  ) //is alive\n        {\n        \n            food -= 0.15; //eat food\n            food -= float(numNeighbours) * 0.05; //crowding reduced food faster\n           \n            if(numNeighbours < 0) //2 underpopulation\n            {\n                alive = 0.0;\n            }\n            else if(numNeighbours > 3 ) //3 overpopulation\n            {\n                alive = 0.0;\n            }\n            else   if(food < 0.1 )//starve\n            {\n               alive = 0.0;\n            }\n                      \n        }\n        else //dead\n        {        \n           if(numNeighbours == 2 ) //3 reproduction\n           {\n               if(food > 0.25) //need starting food\n                   alive = 1.0;\n           }\n        }\n\n\n        col.x = alive;\n        col.y = clamp( food, 0.0, 1.0 );\n        col.z = 0.0;\n        \n        /////////////////////////////////////////////////////////////////\n#elif MODE == ANNEAL\n        /////////////////////////////////////////////////////////////////\n\n        //test cell\n        col = vec3(0);\n        if( bool(cell[C_C].x) ) //is our cell alive?\n        {\n            if(numNeighbours == 3 || numNeighbours == 5 || numNeighbours == 6 || numNeighbours == 7 || numNeighbours == 8) //survive\n            {\n                col = vec3(1);\n            }\n        }\n        else //dead\n        {\n           if(numNeighbours == 4 || numNeighbours == 6 || numNeighbours == 7 || numNeighbours == 8 ) //birth\n           {\n               col = vec3(1);\n           }\n        }\n\n        /////////////////////////////////////////////////////////////////\n#endif\n        \n    }\n    \n       \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI \t\t3.1415926535897932384626433832795\n#define TWOPI \t6.283185307179586476925286766559\n#define HALFPI \t1.5707963267948966192313216916398\n#define TORAD \t0.01745329251994329576923690768489\n#define INVPI \t0.31830988618379067153776752674503\n#define INVTWOPI 0.15915494309189533576888376337251\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}