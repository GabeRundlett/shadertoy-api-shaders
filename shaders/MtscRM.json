{
    "Shader": {
        "info": {
            "date": "1504144999",
            "description": "mouse.xy visualizes a point and nearest points on the quadratic spline.\nsegments of different  background colors tell which one of the 3 points is closest.\n\nmy take on \"distance to cubic spline/bezier\"\nhttps://www.shadertoy.com/view/MdXBzB",
            "flags": 0,
            "hasliked": 0,
            "id": "MtscRM",
            "likes": 4,
            "name": "euclidean cubic bezier",
            "published": 3,
            "tags": [
                "bezier",
                "spline",
                "cubic",
                "euclidean",
                "fwidth",
                "analysis"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1080
        },
        "renderpass": [
            {
                "code": "//grandparent: https://www.shadertoy.com/view/ltXSDB \n// by Adam Simmons, T21 and others\n//parent:      https://www.shadertoy.com/view/MdXBzB\n// by Tom'2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nMouse.xy visualizes a point and nearest points on the quadratic spline.\nThe Segments of different  background colors tell which one of the 3 points is closest.\nThe Polynomial on the left shows root solving, \n which has 3 local extrema, one for each background-segment.\n 2 local minima define nearest points on the bezier.\nThe 3rd root is a local maxima (an antiderivative is displayed), it can be ignored.\n due to getting the SHORTEST EUCLIDEAN LENGTH to a spline. \n The required root solving simplifies to a polinimial of -1 degree less.\nThe segment-border-cases are also nice 2nd derivative border cases.\nBut we do not care for the 2nd derivative here. \n This could nicely turn the borders into isolines|splines.\n*/\n\n//1 <- draw lines for visualization\n//2 <- do a 2nd pass for \"better\" visualisation lines\"\n#define LinesToNearest 1\n\n//show local minima of cubic solver\n#define PlotPolinomial 1\n\n//Define background colors of 3 segments, showing nearest. \nconst vec3 rcol0 = vec3(1,1,0);\nconst vec3 rcol1 = vec3(0,1,1);//3rd color is differential of the other 2\n\n/*\nmy take on \"distance to cubic spline/bezier\"\n\nbetter compatibility, no longer using arrays.\nfixed some silly parts,removed stuff that was not going anywhere any day soon.\n\nIhis is me than code golfing and namespace changing. \nIt is utilizing \"bisymmetry\" principle mostly for performance.\n\nWhere https://www.shadertoy.com/view/MdXBzB is hunting ghosts\n...in an attempt to prove that ghosts do not exist which is NOT how analysis works!\nMy bisymmetry approach simply does not care for nonexisting cases or unused values.\nMy bisymmetery principle is concerned with undefined,arbitiary, cases.\n\nlogical extension is to split any more complex spline into quadradic beziers, \nto calculate a min() distance to them.\n2 bezier ControlVectors are where the 2ndDerivative =0\n3rd ControlVectors is line_line_intersection of the tangents at other 2 CV.\nif(point is [outside of the triangle of the ControlVectors])Distance==spheres at the 2CV.\n*/\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\nfloat sumv(vec2 a){return a.x+a.y;}\nfloat sumv(vec3 a){return dot(vec3(1),a);}\n#define miv(a) -mav(-(a))\n//#define u2(a) ((a)*2.-1.)\n//#define u5(a) ((a)*.5+.5)\n//seesaw wave\n//#define saw(a) a=abs(u2(fract(a)))\n#define dd(a) dot(a,a)\n//perpendicular ==90deg rotation, relevant for distance to line\nvec2 perp(vec2 a){return vec2(-a.y,a.x);}\n//return [perpendicular dot product], relevant for distance to line\nfloat dotp(vec2 a,vec2 b){return dot(perp(a),b);}\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n//#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n#define sat(a) clamp(a,0.,1.)\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\n//v0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//return squared distance of [u] to line_segment, from [a] to [b]\nv0 segment(v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}\n/*\n#define grid(u) mav(abs(u2(fract(u))))\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n/**/\n//return distance of p to line segment from a to b\n\n//draw dual-domain-cubic y=f(x) function for visualisation; u=fragment; m=mouse.xy\nfloat plotDistance(vec2 U,vec2 m,vec2 a,vec2 b,vec2 c){\n vec2 p=U/iResolution.x;p=vec2(p.x*8.-1.,p.y*32.-2.);\n float w=p.y-dd(a-m+(2.*(b-a)+(a-b*2.+c)*p.x)*p.x);\n return smoothstep(fwidth(w),.0,abs(w));}//here fwidth() is good enough estimation.\n\n//special cubic solver, skips 3rd solution==n-m;\nvec2 solveCubic2(vec3 a){float p=a.y-a.x*a.x/3.,p3=p*p*p,q=a.x*(2.*a.x*a.x-9.*a.y)/27.\n +a.z,d=q*q+4.*p3/27.;if(d>.0){vec2 x=(vec2(1,-1)*sqrt(d)-q)/2.;\n  return vec2(sumv(sign(x)*pow(abs(x),vec2(1./3.)))-a.x/3.);}\n float v=acos(-sqrt(-27./p3)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);\n return vec2(m+m,-n-m)*sqrt(-p/3.)-a.x/3.;}//3rd solution would be= vec2(...,n-m)*...\n\n//return distance to cubic bezier; l=matrix of 1 or 2 nearest points on bezier.\n//r=local minima of solveCubic2(), to select the correct l.\nfloat Bezier2(vec2 A,vec2 B,vec2 C,vec2 p,out mat2 l,out vec3 r){  \n //B=mix(B+vec2(1e-4),B,abs(sign(B*2.-A-C)));//catch 3 colinear control vectors\n vec2 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p,\n t=solveCubic2(vec3(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b)),\n s=vec2(dd(d+(c+b*t.x)*t.x),dd(d+(c+b*t.y)*t.y));r=sqrt(s.xyx);r-=miv(r);\n l=mat2(vec2((c+b*t.x)*t.x+A),vec2((c+b*t.y)*t.y+A));return sqrt(miv(s));}\n\n\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 p=(2.*U.xy-iResolution.xy)/iResolution.y;\n vec2 m=mix((2.*iMouse.xy-iResolution.xy)/iResolution.y,\n vec2(cos(iTime),0),step(iMouse.z,.0));\n float fsaa=2./iResolution.y;//2 pixel wide AntiAliasing/Blur.\n    \n //set bezier-quadratic control_vector inputs\n vec2 A=vec2(.3,-.9),C=-A,B=vec2(-1);\n //Get signed distance to bezier curve and some other visualisation stuff.\n vec3 rf;mat2 rt;float bez=Bezier2(A,B,C,p,rt,rf);\n     \n //O distance isolines\n rf=sat((1.-rf*.5/fsaa));\n vec3 c=(rcol0*rf.y+rcol1*rf.x)/sumv(rf);\n O=vec4(c*.6,1);//distance field all color background    \n //O distance isolines\n O*=1.+smoothstep(.02+fsaa*28.,.02,abs(fract(22.*bez+.5)-.5))*.5;\n //bezier curve\n O=mix(vec4(1),O,smoothstep(-.01,.01,bez-.02) ); \n //O cubic polynomial:\n #if PlotPolinomial>0\n  O=max(O,plotDistance(U,m,A,B,C));   \n #endif\n    \n #if LinesToNearest>0\n   //2nd pass on the hardest function for slighly better lines, not worth it.\n  #if LinesToNearest>1\n   Bezier2(A,B,C,m,rt,rf);\n  #endif\n  //root points to mouse cursor:\n  float pd=min(segment(p,m,rt[0]),segment(p,m,rt[1]));    \n  O=mix(O,vec4(1),(1.-smoothstep(.002,.002+fsaa,sqrt(pd)))*.5);\n #endif\n //O gamma correct\n O=sqrt(O);\n}\n\n/*\n// Find the signed distance from a point to a bezier curve without clamping\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p, out vec3 r){\n //B=mix(B+vec2(1e-4),B,abs(sign(B*2.-A-C)));//prevent 3 colinear points\n vec2 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p;\n vec3 t=solveCubic(vec3(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b));\n vec2 tt=vec2(dd(d+(c+b*t.x)*t.x),dd(d+(c+b*t.y)*t.y));\n vec3 rd=sqrt(vec3(tt            ,dd(d+(c+b*t.x)*t.x)));\n r=rd-miv(rd);return sqrt(miv(tt));\n}\n //O Make negative sign slightly lighter\n //O=mix(O,vec4(1),(-s+1.)*.05);//broken\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}