{
    "Shader": {
        "info": {
            "date": "1625421836",
            "description": "License CC0: Retro cube effect with twist\nWe made a retro demo some time ago and wanted a version of the classic Amiga effect:\nMusic: Hyperbased by Firefox: https://soundcloud.com/firefox-amigamus",
            "flags": 64,
            "hasliked": 0,
            "id": "flfXDn",
            "likes": 31,
            "name": "Retro cube effect with twist",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "retro"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 719
        },
        "renderpass": [
            {
                "code": "// License CC0: Retro cube effect with twist\n//  We made a retro demo some time ago and in one of the effects\n//  We wanted to recreate the classic \"Amiga Cube that intersects a translucent plane\"\n//  But having accesss to a few more Teraflops than the Amiga we wanted to add a bit of a twist to it\n//  Music: Hyperbased by Firefox: https://soundcloud.com/firefox-amigamusician/hyperbased\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            (iTime+155.0)\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(a)         (0.5+0.5*cos(a))\n#define PSIN(a)         (0.5+0.5*sin(a))\n#define L2(x)           dot(x, x)\n#define SCA(a)          vec2(sin(a), cos(a))\n#define MISS            1E6\n#define BTIME(n)        (n*beat+start)\n\n#define CUBE_TOLERANCE       0.0001\n#define CUBE_MAX_RAY_LENGTH  8.0\n#define CUBE_MAX_RAY_MARCHES 80\n#define CUBE_NORM_OFF        0.0005\n\nconst float beat            = 0.48;\nconst float start           = 41.1;\nconst float bounce_freq     = 0.5/beat;\n\nconst mat2 rot0             = ROT(0.00);\nconst vec3 std_gamma        = vec3(2.2);\n\nconst float cube_begin      = BTIME(240.0); // ~156\nconst float cube_flash0     = BTIME(334.0);\nconst float cube_flash1     = BTIME(335.0);\nconst float cube_end        = BTIME(336.0);\n\n// GLOBAL MUTABLES\n\nvec4  cube_g_plane       = vec4(normalize(vec3(1.0, 0.0, 0.0)), 0.0);\nfloat cube_g_pw          = 0.0;\nmat2 cube_g_rotxy        = rot0;\nmat2 cube_g_rotxz        = rot0;\nmat2 cube_g_rotxw        = rot0;\nmat2 cube_g_rotyw        = rot0;\nmat2 cube_g_rotzw        = rot0;\n\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat plane(vec3 p, vec4 plane) {\n  return dot(plane.xyz, p)+plane.w;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// -----------------------------------------------------------------------------\n// CUBE\n// -----------------------------------------------------------------------------\n\nvec2 cube_mengerSponge(vec4 p) {\n  float db = box(p, vec4(1.0));\n  if(db > .125) vec2(db, db);\n\n  float d_ = db;\n  float res = d_;\n\n  float s = 1.0;\n  for(int m = 0; m < 4; ++m) {\n    float ss = 0.75;\n    vec4 a = mod(p*s, 2.0)-1.0;\n    s *= 3.0;\n    vec4 r = abs(1.0 - 3.0*abs(a));\n\n    float da = max(max(r.x,r.y),r.w);\n    float db = max(max(r.y,r.z),r.w);\n    float dc = max(max(r.z,r.x),r.w);\n    float dd = max(max(r.z,r.x),r.y);\n    float df = length(r)-2.16;\n\n    float du = da;\n    du = min(du, db);\n    du = min(du, dc);\n    du = pmin(du, dd, ss); // Soften the edges a bit\n    du = max(du, -df);\n    du -= 1.0;\n    du /= s;\n\n    res = max(res, du);\n  }\n\n  return vec2(db, res);\n}\n\nfloat cube_intersectTransformPlane(vec3 ro, vec3 rd) {\n  return rayPlane(ro, rd, cube_g_plane);\n}\n\nfloat cube_dtransformPlane(vec3 p) {\n  return plane(p, cube_g_plane);\n}\n\nfloat cube_df(vec3 p) {\n  float dp = cube_dtransformPlane(p);\n  const float s = 1.0/3.0;\n  p /= s;\n  p.xy *= cube_g_rotxy;\n  p.xz *= cube_g_rotxz;\n  vec4 pp = vec4(p, cube_g_pw);\n  pp.xw *= cube_g_rotxw;\n  pp.yw *= cube_g_rotyw;\n  pp.zw *= cube_g_rotzw;\n\n  // TODO: Optimize\n  vec2 dms = cube_mengerSponge(pp);\n\n  float d0 = dms.x*s;\n  float d2 = d0;\n  d0 = max(dp, d0);\n\n  float d1 = dms.y*s;\n  d1 = max(-dp, d1);\n  return max(d2, pmin(d0, d1, 0.05));\n}\n\nfloat cube_rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < CUBE_MAX_RAY_MARCHES; i++) {\n    float d = cube_df(ro + rd*t);\n    if (d < CUBE_TOLERANCE || t > CUBE_MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 cube_normal(vec3 pos) {\n  vec2  eps = vec2(CUBE_NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = cube_df(pos+eps.xyy) - cube_df(pos-eps.xyy);\n  nor.y = cube_df(pos+eps.yxy) - cube_df(pos-eps.yxy);\n  nor.z = cube_df(pos+eps.yyx) - cube_df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat cube_softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = cube_df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 cube_transformPlane(vec3 ro, vec3 rd, vec4 plane, out float ttp) {\n  vec3 tnor = plane.xyz;\n  float t = rayPlane(ro, rd, plane);\n  ttp = t;\n  if (t < 0.0) return vec3(0.0);\n  vec3 tp = ro + t*rd;\n  float td = cube_df(tp);\n  td -= 0.025;\n  float otd = td;\n  td = abs(td)- 0.005;\n  const vec3 tup = vec3(0.0, 1.0, 0.0);\n  vec3 txx = normalize(cross(tnor, tup));\n  vec3 tyy = (cross(tnor, txx));\n  vec2 tp2 = vec2(dot(txx, tp), dot(tyy, tp));\n  float a  = mix(0.0, PI/4.0 + 0.5*(TIME-BTIME(288.0)), smoothstep(BTIME(288.0), BTIME(292.0), TIME));\n  tp2 *= ROT(a);\n  float tpd = box(tp2, 0.6*vec2(4.0/3.0, 1.0));\n  float taa = 0.001;\n  mod2(tp2, vec2(0.125));\n  float tpgd = min(abs(tp2.x), abs(tp2.y));\n  tpgd = max(tpgd, -otd);\n  tpgd = max(tpgd, tpd);\n  float tgd = tpd;\n  tgd -= 0.0125;\n  tgd = abs(tgd)- 0.005;\n  tgd = min(tgd, td);\n\n  const vec3 greenGlow = vec3(1.25, 2.0, 1.25);\n  const vec3 redGlow = vec3(2.0, 1.25, 1.5);\n  vec3 tcol = vec3(0.0125);\n  tcol += greenGlow*exp(-max(tpgd, 0.0)*900.0);\n  tcol += greenGlow*(1.0-abs(dot(rd, tnor)))*0.2*PSIN(500.*tp2.y);\n  tcol = mix(vec3(0.0), tcol, smoothstep(-taa, taa, -(tpd-0.025)));\n  tcol += redGlow*exp(-max(tgd, 0.0)*100.0);\n  return tcol;\n}\n\nvec3 cube_render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 2.0*vec3(1.5, 3.0, 1.0);\n\n  float alpha   = 0.05*TIME;\n  vec3 tnor     = normalize(vec3(1.0, 0.0, 0.0));\n  tnor.xy       *= ROT(PI*(1.0-cos(sqrt(0.3)*max(TIME-BTIME(296.0), 0.0))));\n  tnor.xz       *= ROT(PI*(1.0-cos(sqrt(0.15)*max(TIME-BTIME(304.0), 0.0))));\n\n  float tm      = -0.5*(cos((2.0*TAU/(4.0/beat))*max(TIME-BTIME(292.0), 0.0)));\n  tm  = mix(0.75 , tm, smoothstep(BTIME(272.0), BTIME(288.0), TIME));\n  tm  = mix(-0.75, tm, smoothstep(BTIME(248.0), BTIME(272.0), TIME));\n  tm  = mix(-3.0 , tm, smoothstep(BTIME(244.0), BTIME(248.0), TIME));\n\n  vec4 plane    = vec4(tnor, tm);\n\n  cube_g_plane       = plane;\n  cube_g_rotxy       = ROT(TIME);\n  cube_g_rotxz       = ROT(TIME*sqrt(0.5));\n  cube_g_pw          = 0.5*cos(alpha*sqrt(2.0));\n  cube_g_rotxw       = ROT(alpha);\n  cube_g_rotyw       = ROT(alpha*sqrt(0.5));\n  cube_g_rotzw       = ROT(alpha*sqrt(2.0));\n\n//  tnor.xy *= g_rotxy;\n  // background color\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = cube_rayMarch(ro, rd, iter);\n  float tp;\n  vec3 tcol = cube_transformPlane(ro, rd, plane, tp);\n  tcol = mix(vec3(0.0), tcol, float(tp < t));\n\n  float ifade = 1.0-tanh_approx(2.0*float(iter)/float(CUBE_MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;\n  vec3 nor = vec3(0.0, 1.0, 0.0);\n\n  vec3 color = vec3(0.0);\n\n  float dp   = -(ro.y+1.)/rd.y;\n\n  if (dp > 0.0 && dp < t) {\n    // Ray intersected plane\n    t   = dp;\n    pos = ro + t*rd;\n    nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(100.0, 10.0, m)*dp), 1.0);\n    color = 2.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n  } else if (t < CUBE_MAX_RAY_LENGTH) {\n    // Ray intersected object\n    nor        = cube_normal(pos);\n    vec3 hsv   = (vec3(-0.2+0.25*t, 1.0-ifade, 1.0));\n    color = hsv2rgb(hsv);\n  } else {\n    // Ray intersected sky\n    return (skyCol)*ifade+tcol;\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = cube_softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n  float f = exp(-20.0*(max(t-3.0, 0.0) / CUBE_MAX_RAY_LENGTH));\n\n  return (mix(skyCol, col , f))*ifade+tcol;\n}\n\nvec3 cube_effect(vec2 p, vec2 q) {\n  float m = smoothstep(BTIME(264.0), BTIME(272.0), TIME);\n  float tm = TIME-BTIME(264.0);\n  // camera\n  vec3 ro = mix(1.0, 0.6, m)*vec3(2.0, 0, 0.2)+vec3(0.0, 0.25, 0.0);\n  ro.xz *= ROT(mix(0.0, tm*0.25, m));\n  ro.yz *= ROT(-(1.0-PCOS(tm*0.25*sqrt(0.5)))*0.25);\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return cube_render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = cube_effect(p, q);\n\n  col = postProcess(col, q);\n  col = mix(vec3(1.0), col, smoothstep(cube_begin+0.25, cube_begin+1.5, TIME));\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 27716,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/firefox-amigamusician/hyperbased"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}