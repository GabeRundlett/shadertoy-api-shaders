{
    "Shader": {
        "info": {
            "date": "1678036185",
            "description": "A simple MIS test on shaderToy \nKey up and down to change the center ball's roughness\nKey left and right to rotate the balls\nKey 1 2 3 to change integrator\nUsing PBRT3 as my guide",
            "flags": 48,
            "hasliked": 0,
            "id": "ds3GWs",
            "likes": 1,
            "name": "MisToy2336",
            "published": 3,
            "tags": [
                "raytracing",
                "mis"
            ],
            "usePreview": 0,
            "username": "feiqi3",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n\nfloat phase,frameInit;\n\n\nbool KeyDown(int ascii)\n{\n    return texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.1;\n}\n\nvoid getGlob()\n{\n    vec4 Glob= texelFetch(iChannel1,ivec2(0,0),0);\n    phase = Glob.x;\n    frameInit = Glob.y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    //if(KeyDown(KEY_UP)){\n    //    col = vec3(1);\n    //}\n    getGlob();\n    vec3 curFrame= texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    float mFrame = max(1.,float(iFrame) - frameInit);\n    curFrame = (curFrame)/(mFrame);\n    fragColor = vec4(pow(curFrame,vec3(.4545)),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Inspired by  mplanck  https://www.shadertoy.com/view/lsV3zV \n\n\nconst int STEPMAX = 250;\nconst float START = 0.1;\nconst float END = 1600.;\nconst highp float EPS = 0.001; \nconst int bounces = 3;\n\n#define PI 3.1415926\n#define PI2 6.2831853\n#define IPI 0.3183098865475127436930335989018\n#define IPI2 0.1591549432737563718465167994509\n\nvec2 seed = vec2(0.);\n\nvec2 mos2polar(vec2 mosPos,vec2 res){\n  vec2 tmp = (mosPos) / res.xy;\n  tmp = normalize( tmp - vec2(.5) );\n  return tmp;\n}\n\nvec3 hash3;\nvec2 hash2;\nfloat hash1;\n\n//https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    vec2 ret = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    seed = ret;\n    return ret;\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    float ret = fract((p3.x + p3.y) * p3.z);\n    seed = vec2(ret * 123.456);\n    return ret;\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+33.33);\n    vec3 ret = fract((p3.xxy+p3.yzz)*p3.zyx);\n    seed = ret.xz;\n    return ret;\n}\n\nstruct record{\n    //Hit time \n    float t;\n    //Hit point \n    highp vec3 p;\n    //Normal in hitPoint\n    highp vec3 nor;\n    //MatInfo\n    int mat;\n};   \n\n\nvec2 usdf(vec2 a,vec2 b){\n    return a.x < b.x ? a : b;\n}\n\nstruct ray{\n    vec3 ro;\n    vec3 rd;\n};\n\n//Different from the common cartesian-coord where axis z is vertical    \n//Here axis-y stands for the vertical one\nvec3 polar_to_cartesian(float sinTheta, \n                        float cosTheta, \n                        float sinPhi,\n                        float cosPhi)\n{\n    return vec3(sinTheta * cosPhi,\n                cosTheta,\n                sinTheta * sinPhi);\n}\n\nfloat CosThetapdf(vec3 surfnor,vec3 liDir){\n    return abs(dot(surfnor,liDir)) / PI;\n}\n\nmat3 getViewMat(vec3 eye,vec3 lookAt,vec3 up){\n    vec3 w = normalize(lookAt - eye);\n    vec3 u = normalize(cross(up,w));\n    vec3 v = normalize(cross(w,u));\n    return mat3(\n    u,\n    v,\n    -w\n    );\n}\n\n//T B N\n//From https://www.shadertoy.com/view/lsV3zV\nvoid calc_binormals(vec3 normal,\n                    out vec3 tangent,\n                    out vec3 binormal)\n{\n    if (abs(normal.x) > abs(normal.y))\n    {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    }\n    else\n    {\n        tangent = normalize(vec3(0., normal.z, -normal.y));\n    }\n    \n    binormal = cross(normal, tangent);\n}\n\n//Sample function\n//PBRTV3 13.6.4\n/**************************************************************/\n\n//Malley's Method  \nvec3 sampleCos(out float cosTheta){\n    vec2 rand = hash21(seed.y * seed.x);\n    float r = sqrt(rand.x);\n    float theta = (PI2 * rand.y);\n    vec2 d = vec2(r * cos(theta),r * sin(theta));\n    float z = sqrt(max(0.,1.- d.x*d.x - d.y*d.y));\n    cosTheta = cos(theta);\n    vec3 lightDir = vec3(d.x,z,d.y);\n    cosTheta = dot(lightDir,vec3(0,1,0));\n    return lightDir;\n}\n\nvec3 cosWeighted(in vec3 nor,out float cosTheta){\n    vec3 dir = sampleCos(cosTheta);\n    vec3 ti,bi;\n    calc_binormals(nor,ti,bi);\n    return dir * nor + dir * bi + dir * ti;\n}\n\n//From pbrtv3 13.6.4\n//sample point in model coord.\nvec3 uniformSampleCone(float cosThetaMax){\n    vec2 rand = hash21(seed.x * seed.y);\n    float cosTheta = 1. - rand.x + rand.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = rand.x * PI2;\n    return polar_to_cartesian(sinTheta,cosTheta,sin(phi),cos(phi));\n}\n\n\n//From pbrtv3 14.2.1\n//@surfP: surface from shading point \n//@LightC: light sphere center \n//@LightR: Sphere radius\n//@ret.xyz: sampleDir in WORLD coord\n//@ret.w: PDF\nvec4 sampleSphereLight(vec3 surfP,vec3 lightC,float lightR){\n    vec3 ldir =(lightC - surfP);\n    vec3 no = normalize(ldir);\n    vec3 ti,bi;\n    calc_binormals(no,ti,bi);\n    \n    float distSqure = dot(ldir,ldir);\n    float r2 = lightR * lightR;\n    float sin2Max = r2 / distSqure ;\n    float cos2Max = max(0.,1. - sin2Max);\n    float cosMax = sqrt(cos2Max);\n    //in Model coord   \n    vec3 sampleDir = uniformSampleCone(cosMax);\n    //To world coord\n    sampleDir = ti * sampleDir.x + no * sampleDir.y + bi * sampleDir.z;\n    //From pbrtv3 13.6.4\n    float pdf = IPI2 / (1. - cosMax);\n    return vec4(sampleDir,pdf);\n}\n/**************************************************************/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define AA 1\n//#define BG\nconst float FOV = 60.;\n\nfloat phase = 0.;\nfloat frameInit = 0.;\nfloat alpha;\nfloat type;\nstruct material{\n    vec2 emit; // x : intense ,y isLight => 0 :is a light , other val: not a light \n    vec3 albedo;\n    float roughNess;\n};\n\nmaterial moonMat,sunMat,earthMat,defaultMat;\n\n#define matInfo(a,x) int(a)==x\n\nvec3 MoonPos = vec3(0);\nvec3 SunPos = vec3(0);\n\nconst int lights = 2;\n\n//1. Moon 2. Sun\nvec4 lightPos[2];\nfloat lightR[2] = float[2](2.5,3.5);\nvec3 lightLEmit[2] = vec3[2](vec3(.84,.925,.941) * 115.,vec3(1.,0.,0.) * 117.);\nvec3 Rs[2] = vec3[2](vec3(.97,.84,.57),vec3(.3,.3,.3));\n\nvoid initiatePos(){\n    seed = hash32(vec2(iTime,iFrame) * gl_FragCoord.xy).xy;\n    MoonPos = vec3(14.*sin(phase *.533),0.,10.+14.*cos(phase*.533)) ;\n    lightPos[0] = vec4(MoonPos,2.);\n    moonMat.emit = vec2(1,0);\n    moonMat.albedo = vec3(.84,.925,.941);   \n    moonMat.roughNess = 1.;\n    //Sun Pos Here\n    //三维空间中球的参数方程\n    float sin_theta = sin(phase * .333 + 3.14);\n    float cos_theta = cos(phase * .333+ 3.14);\n\n    const vec3 earth_pos = vec3(0,0,10);\n    const vec3 sun_a = vec3(0,0.707107,-0.707107); \n    const vec3 sun_b = vec3(-0.816497,0.408248,0.408248);\n    SunPos = vec3(\n    cos_theta*sun_a.x + sin_theta*sun_b.x,\n    cos_theta*sun_a.y + sin_theta*sun_b.y,\n    cos_theta*sun_a.z + sin_theta*sun_b.z\n    );\n    sunMat.emit = vec2(2,0);\n    sunMat.albedo = vec3(1.,0.,0.);\n    sunMat.roughNess = 1.;\n    lightPos[1] = vec4(earth_pos + 10. * SunPos,3.);\n    \n    earthMat.emit = vec2(0,10);\n    earthMat.albedo = vec3(.7294,.807,.921);\n    //TODO: a changable roughness\n    earthMat.roughNess = alpha;\n    \n    defaultMat.emit = vec2(0,5);\n    defaultMat.albedo = vec3(.6);\n    defaultMat.roughNess = .05;\n}\n\nvoid initHash(vec2 p){\n    hash2 = hash21(p.x + p.y + float(iFrame));\n    hash3 = hash32(p+vec2(iTime));\n    hash1 = hash12(p+vec2(iTime));\n}\n\nconst vec3 camPos = vec3(0,0,-5);\nconst vec3 lookAt = vec3(0,0,1);\nconst vec3 Up = vec3(0,1,0);\n\n//Material   \n/**************************************************************/\nmaterial matMatch(int mat){\n    if(matInfo(mat,1)){\n        return earthMat;\n    }else if(matInfo(mat,2)){\n        return moonMat;\n    }else if(matInfo(mat,3)){\n        return sunMat;\n    }else if(matInfo(mat,4)){\n        return defaultMat;\n    }\n    return defaultMat;   \n}\n\n//TODO: brdf  \n\n/**************************************************************/\n\n//SDF\n/**************************************************************/\n\n//@p: samplePoint  \n//@c: Center  \n//@r: radius\n//@out: sdf\nfloat sphere( vec3 p,vec3 c, float r) \n{    \n    return length(p - c) - r; \n}\n\n//sdf wrapper with mat info\nvec2 sphe(vec3 p,vec3 c, float r,float mat){\n    return vec2(length(p - c) - r,mat);\n}\n/**************************************************************/\n\n//SDF Object\n/**************************************************************/\nvec2 shpr_earth(vec3 samp){\n    return sphe(samp,vec3(0,0,10),2.,1.);\n}\nvec2 shpr_moon(vec3 samp){\n    return sphe(samp,lightPos[0].xyz,lightR[0],2.);\n}\nvec2 shpr_under(vec3 samp){\n    return sphe(samp,vec3(0,-350,0),340.,4.);\n}\nvec2 shpr_sun(vec3 samp){\n    return sphe(samp,lightPos[1].xyz,lightR[1],3.);\n}\nvec2 shpr_outer(vec3 samp){\n    return sphe(samp,vec3(0,0,0),200.,4.);\n}\n/**************************************************************/\n\n//SDF Functions \n/**************************************************************/\n// @p, samplePoint in world space\n// @out.x float - distancs \n// @out.y int - material ID   \nvec2 map(vec3 p){\n    return usdf(shpr_earth(p),usdf(shpr_moon(p),usdf(shpr_sun(p),shpr_under(p))));\n}\n\nvec3 calcNormal( in vec3 p ){ // for function f(p)\n    const float h = 0.0003; // replace by an appropriate value\n    const vec2 k = vec2(1,-1)*0.5773;\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n} \n\n\nbool intersection(in ray r,inout record rec){\n    float t = START;\n    for(int i = 0; i < STEPMAX; i++){\n        vec3 p = vec3(r.ro + t * r.rd);\n        vec2 dis = map(p);\n        if(dis.x < EPS){\n            rec.p = p;\n            rec.t = t;\n            rec.mat = int(dis.y);\n            rec.nor = calcNormal(rec.p);\n            return true;\n        }\n        t += dis.x;\n        if(t > END){\n            return false;\n        }\n    }\n    return false;\n}    \n/**************************************************************/\n                    \n//Ray functions \n/**************************************************************/\nvec3 getRay(float fov_degree,vec2 fragCoord,vec2 imgSize){\n    mat3 camMat = getViewMat(camPos,lookAt,Up);\n    vec2 img_center = imgSize / 2.;\n    float z_cam = ((imgSize.y/2.)/tan(radians(fov_degree)/2.)); \n    return normalize(vec3(fragCoord,0.) - vec3(img_center,z_cam));\n}\n\nray Ray(vec3 ro,vec3 rd){\n    ray ret;\n    ret.ro = ro;\n    ret.rd=rd;\n    return ret;\n}\n\nray getCamRay(vec2 fragCoord,vec2 jitter){\n// z > 0 : into screen , z < 0 outof screen\n   mat3 vMat = getViewMat(camPos,lookAt,Up);\n   vec3 dir =vMat*getRay(FOV,fragCoord+jitter,iResolution.xy);  \n   ray ret;\n   ret.ro = camPos;   \n   ret.rd = normalize(dir);\n   return ret;\n}\n\n//Visibility test   \nfloat visTest(ray a,int tarMat){\n    record rec; \n    if(!intersection(a,rec)){\n        return 0.;\n    }\n    if(matInfo(rec.mat,tarMat))\n        return 1.;\n    return 0.;\n}\n\n//PBR shits\n/**************************************************************/\n\n\n//NDF for GGX\n//Wh is the half vector among wi and wo\nfloat GGX_NDF(float roughness,float nDotWh){\n    float ret = roughness*roughness;\n    float tmp=  ( (ret - 1.)*nDotWh*nDotWh+1. ); \n    ret = ret * nDotWh / (tmp *tmp) * IPI;\n    return ret;\n}\n\nfloat GGXLambda(float alpha,float tan_theta2){\n    float lambda = -1. + sqrt(1.+alpha * alpha * tan_theta2);\n    lambda = lambda / 2.;\n    return lambda;\n}\n\n//Geometry term for ggx\nfloat GGX_G1(vec3 wi,float alpha,float tan_theta2){\n    float lambda = GGXLambda(alpha,tan_theta2);\n    return 1. / (1. + lambda);\n}\n\n//G2: height-field seperate type\nfloat GGX_G(vec3 wi,vec3 wo,vec3 nor,float alpha){\n    float iDotN = dot(wi,nor);\n    iDotN *= iDotN;\n    float tanI2 = (1. - iDotN) / iDotN;//tanTheta\n    float wiG1 = GGX_G1(wi,alpha,tanI2);\n\n    float oDotN = dot(wo,nor);\n    oDotN *=oDotN;\n    float tanO2 = (1. - oDotN) / oDotN;\n    float woG1 = GGX_G1(wo,alpha,tanO2);\n    return woG1 * wiG1;\n}\n//A more accurate G2 Form\nfloat GGX_G2(vec3 wi,vec3 wo,vec3 nor,float alpha){\n    float iDotN = dot(wi,nor);\n    iDotN *= iDotN; //Cos2Theta\n    float tanI2 = (1. - iDotN) / iDotN;//tan2Theta\n    float lambdaWi = GGXLambda(alpha,tanI2);\n    \n    float oDotN = dot(wo,nor);\n    oDotN *=oDotN;\n    float tanO2 = (1. - oDotN) / oDotN;\n    float lambdaWo = GGXLambda(alpha,tanO2);\n    return 1./(1. + lambdaWi + lambdaWo);\n}\n\n//Shlick's approximation\nvec3 frenell(vec3 Rs,float cosTheta){\n    float pow5 = (1. - cosTheta);\n    pow5 *= pow5 * pow5 * pow5 * pow5;\n    return Rs + (1.-Rs) * pow5;\n}\n\nvec3 sampleBRDF(float alpha){\n    vec2 rand2 = hash21(seed.x*seed.y + iTime);\n    \n    float phi = rand2.x * PI2;\n    float theta = acos(sqrt((1.0f - rand2.y)/\n                          ((alpha*alpha - 1.0f) * rand2.y + 1.0f)\n                         ));\n    return normalize(polar_to_cartesian(sin(theta),cos(theta),sin(phi),cos(phi)));\n}\n\n//MicroFacet BRDF : Cook-Torrancce Model \n//From PBRTv3 8.4\n//Assuming that wi and wo are outGoing vectors\nvec3 microFacetBRDF(vec3 wi,vec3 wh,vec3 wo,vec3 Rs,float alpha,vec3 nor){\n    float ndotwh = dot(nor,wh);\n    float wiDotN = dot(wi,nor);\n    vec3 GF = GGX_G(wi,wo,nor,alpha) * frenell(Rs,dot(wo,nor));\n    //DGF / 4pi / pdf       \n    //pdf = D(wh) * dot(nor,wh) / 4(dot(wi,wh))\n    //res : GF * (dot(wi,wh)) / (PI * dot(nor,wh) ) * cosTheta\n    return GF * IPI * dot(wi,wh) /( dot(nor,wh) * dot(nor,wo));\n}\n\nvec3 cookTorrance(vec3 albedo,float alpha,vec3 nor,vec3 wh,vec3 wi,vec3 wo,float cosTheta,vec3 rs){\n    float nDotWh = dot(wh,nor);\n    float D = GGX_NDF(alpha,nDotWh);\n    float G = GGX_G2(wi,wo,nor,alpha);\n    vec3 F = frenell(rs,dot(wo,nor));\n    return (D * G * F) *.25 / (dot(wi,nor) * dot(wo,nor));\n}\n\n\nfloat GGXPdf(float alpha,vec3 wh,vec3 nor,vec3 wi ){\n    float nDotWh = dot(wh,nor);\n    float D = GGX_NDF(alpha,nDotWh);\n    float cosTheta = dot(wi,nor);\n    float wh2wi = .25/dot(wi,wh);\n    return D * cosTheta * wh2wi;\n}\n\n//Wo is in vector\nvec3 getBrdf(out vec3 wh,vec3 wo,out vec3 wi,vec3 nor,float alpha,vec3 albedo,vec3 rs){\n    wh = sampleBRDF(alpha);\n    wi = reflect(wo,nor);\n    float cosTheta = dot(wi,nor);\n    vec3 brdf = cookTorrance(albedo,alpha,nor,wh,wi,-wo,cosTheta,rs);\n    return brdf;\n}\n\n/**************************************************************/\n\n\n\n\n//return vis and sampleDir      \nfloat sampleLight(int LightNo,record rec,out float pdf,out vec3 wi){\n    vec3 light = lightPos[LightNo].xyz;\n    int mat = int(lightPos[LightNo].w);\n    float r = lightR[LightNo];\n    vec4 sampleDir = sampleSphereLight(rec.p,light,r);\n    wi = sampleDir.xyz;\n    wi = normalize(wi);\n    pdf = sampleDir.w;\n    // p - .05 wi can get a better effect\n    ray testR = Ray(rec.p - 0.05 * wi,wi);    \n    float vis = visTest(testR,mat);\n    return vis;\n}\n\n\n//Uniform sample all lights    \n//From pbrtv3 14.3\nvec3 caclDirectLightLi(record rec,vec3 wo,material matCur){\n    vec3 Li = vec3(0.);\n    for(int i = 0;i < lights;++i){\n        //Li from Light is hardCoded\n        vec3 emit = lightLEmit[i];\n        vec3 wi;\n        float pdf;\n        float vis = sampleLight(i,rec,pdf,wi);\n        vec3 wh =normalize( -wo + wi);\n        wi = normalize(wi);\n        float cosTheta = dot(rec.nor,wi);\n        vec3 brdf = \n        cookTorrance(matCur.albedo,matCur.roughNess,rec.nor,wh,wi,-wo,cosTheta,Rs[0]);\n        \n        //vec3 brdf_lambertian =matCur.albedo * IPI; // Lambertian brdf\n        Li +=emit * brdf * vis * cosTheta / pdf;\n    }\n    //Li dvd lightNum   \n    \n    return Li / float(lights);\n}\n\n\n\nvec3 DirectLightIntegrator(vec2 fragCoord){\n    ray initRay = getCamRay(fragCoord,hash21(seed.x*seed.y));\n    record rec;\n    bool isHit = intersection(initRay,rec);\n    if(!isHit) return vec3(0);\n    material mat = matMatch(rec.mat);\n    if(mat.emit.y < 1.){\n    //if target is a LIGHT \n    //return its albedo     \n        return mat.albedo;\n    }\n    //else caculate its light      \n    return caclDirectLightLi(rec,initRay.rd,mat);\n}\n\nvec3 BRDFCalc(material mat,record rec,inout ray mray){\n    vec3 wh = sampleBRDF((mat.roughNess));\n    vec3 ti,bi;\n    calc_binormals(rec.nor,ti,bi);\n    wh = (wh.x * ti + wh.y*rec.nor + wh.z*bi);\n    vec3 wo = (mray.rd);\n    vec3 wi = reflect(wo,wh);\n        \n    //New ray\n    mray.ro = rec.p;\n    mray.rd = (wi);\n        \n    float cosTheta = dot(rec.nor,wi);\n    //get brdf at cur intersection  \n    vec3 brdf = cookTorrance(mat.albedo,mat.roughNess,rec.nor,wh,wi,-wo,cosTheta,Rs[0]);\n    float pdf = GGXPdf(mat.roughNess,wh,rec.nor,wi);\n    return brdf * cosTheta / pdf;\n}\n\nvec3 BRDFSampleIntergrator(vec2 fragCoord){\n    ray mray = getCamRay(fragCoord,vec2(seed.x * seed.y));\n    vec3 LiArray[bounces];\n    record rec;\n    bool flag = false;\n    int endBounces = bounces;\n    for(int i = 0; i<bounces;++i){\n        if(!intersection(mray,rec)){\n               return vec3(0.);\n        }   \n        material mat = matMatch(rec.mat);\n        if(mat.emit.y <.9){\n            endBounces = i;\n            flag = true;\n            LiArray[i] = mat.emit.x * mat.albedo;\n            break;\n        }\n        vec3 wh = sampleBRDF((mat.roughNess));\n        vec3 ti,bi;\n        calc_binormals(rec.nor,ti,bi);\n        wh = (wh.x * ti + wh.y*rec.nor + wh.z*bi);\n        vec3 wo = (mray.rd);\n        vec3 wi = reflect(wo,wh);\n        \n        //New ray\n        mray.ro = rec.p;\n        mray.rd = (wi);\n        \n        float cosTheta = dot(rec.nor,wi);\n        //get brdf at cur intersection  \n        vec3 brdf = cookTorrance(mat.albedo,mat.roughNess,rec.nor,wh,wi,-wo,cosTheta,Rs[0]);\n        float pdf = GGXPdf(mat.roughNess,wh,rec.nor,wi);\n        LiArray[i] = brdf * cosTheta / pdf;\n\n    }\n     if(endBounces==0){\n         return LiArray[0];\n     }\n     if(!flag){\n         return vec3(0);\n     }\n     //LiArray[endBounces] should be the light which the ray hit\n     for(int i = endBounces -1 ;i >= 0;i --){\n         LiArray[i] = LiArray[i + 1] * LiArray[i];\n     }\n     return LiArray[0];\n}\n\n//power heuristic, from pbrtv3 13.10\n//pow2\nfloat powerHeuristic(float pa,float pb){\n    return pa * pa / (pa * pa + pb * pb); \n}\n\n\n//@ret.w : pdf\nvec4 sampleOneLight(record rec,vec3 wo,material matCur){\n    int tarLight = int(step(.5,hash12(seed.xy + vec2(iTime))));\n    vec3 emit = lightLEmit[tarLight];\n    vec3 wi;\n    float pdf;\n    float vis = sampleLight(tarLight,rec,pdf,wi);\n    vec3 wh =normalize( -wo + wi);\n    wi = normalize(wi);\n    float cosTheta = dot(rec.nor,wi);\n    vec3 brdf = \n    cookTorrance(matCur.albedo,matCur.roughNess,rec.nor,wh,wi,-wo,cosTheta,Rs[0]);\n    vec4 Li =vec4(emit * brdf * vis * cosTheta / pdf,pdf);\n    return Li;\n}\n\nvec3 MISIntegrator(vec2 fragCoord){\n    ray mray = getCamRay(fragCoord,vec2(seed.x * seed.y));\n    vec4 LiArray[bounces];\n    LiArray[0] = vec4(0);\n    vec4 DirectLight[bounces];\n    record rec;\n    bool flag = false;\n    int endBounces = bounces;\n    for(int i = 0; i<bounces;++i){\n        LiArray[i] = vec4(0);\n        DirectLight[i] = vec4(0);\n        if(!intersection(mray,rec)){\n        #ifdef BG\n               LiArray[i].xyz = 1.2*texture(iChannel2,mray.rd).xyz;\n        #else\n               LiArray[i].xyz = vec3(0);\n        #endif\n        \n               endBounces = i;\n               break;\n        }   \n        material mat = matMatch(rec.mat);\n        //if HIT Light\n        if(mat.emit.y <.9){\n            endBounces = i;\n            flag = true;\n            LiArray[i].xyz = mat.emit.x * mat.albedo;\n            break;\n        }\n        //Sample Brdf\n        vec3 wh = sampleBRDF((mat.roughNess));\n        vec3 ti,bi;\n        calc_binormals(rec.nor,ti,bi);\n        wh = (wh.x * ti + wh.y*rec.nor + wh.z*bi);\n        vec3 wo = (mray.rd);\n        vec3 wi = reflect(wo,wh);\n        //New ray\n        mray.ro = rec.p;\n        mray.rd = (wi);\n        float cosTheta = dot(rec.nor,wi);\n        //get brdf at cur intersection  \n        vec3 brdf = cookTorrance(mat.albedo,mat.roughNess,rec.nor,wh,wi,-wo,cosTheta,Rs[0]);\n        float pdf = GGXPdf(mat.roughNess,wh,rec.nor,wi);\n        LiArray[i].xyz = brdf * cosTheta;\n        LiArray[i].w = pdf;\n        \n        //sample lights\n        DirectLight[i] = sampleOneLight(rec,wo,mat);\n    }\n     if(endBounces==0){\n         return LiArray[0].xyz;\n     }\n\n     //LiArray[endBounces] should be the light that ray hit\n     for(int i = endBounces -1 ;i >= 0;i --){\n         float pa = powerHeuristic(LiArray[i].w,DirectLight[i].w);\n         float pb = powerHeuristic(DirectLight[i].w,LiArray[i].w);\n         LiArray[i].xyz = LiArray[i + 1].xyz * LiArray[i].xyz * pa / LiArray[i].w\n         + DirectLight[i].xyz * pb / DirectLight[i].w;\n     }\n     return LiArray[0].xyz;\n}\n\nvoid getGlob(){\n    vec4 Glob= texelFetch(iChannel0,ivec2(0,0),0);\n    phase = Glob.x;\n    frameInit = Glob.y;\n    type = Glob.w;\n    alpha = Glob.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    getGlob();\n    initiatePos();\n    vec3 col = vec3(0.);\n    for(int i = 0;i < AA;++i){\n      vec2 jitter = hash21(seed.y * seed.x) -.5;\n      if(type < .5)\n          col += DirectLightIntegrator(fragCoord+jitter*2.*.075);\n      else if(type < 1.5)\n          col += BRDFSampleIntergrator(fragCoord+jitter*2.*.075);\n      else if(type < 2.5)\n          col += MISIntegrator(fragCoord+jitter*2.*.075);\n  }    \n    col = col/float(AA);\n    vec3 lastFrame = texture(iChannel1,fragCoord.xy/iResolution.xy).xyz;\n    float frames =max(.9,float(iFrame) - frameInit);\n    if(frames > 1.){\n        col +=lastFrame;\n    }\n    fragColor = vec4(col,1.);\n}    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Store Some info here   \n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_ONE = 49;\nconst int KEY_TWO = 50;\nconst int KEY_THREE = 51;\n\nfloat FramInit = .0;\nfloat Phase = 0.;\nfloat Alpha = 0.;\nfloat Type = 0.;\nvoid getGlob(){\n    vec4 Glob= texelFetch(iChannel0,ivec2(0,0),0);\n    FramInit = Glob.y;\n    Phase = Glob.x;\n    Alpha = Glob.z;\n    Type = Glob.w;\n}\n\nbool KeyDown(int ascii){\n    return texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.2;\n}\n\nvoid KeyProcess(){\n    bool flag = false;\n    if(KeyDown(KEY_RIGHT)){\n        flag = true;\n        Phase+=.05;\n    }\n    if(KeyDown(KEY_LEFT)){\n        flag = true;\n        Phase -= .05;\n    }\n    if(KeyDown(KEY_ONE)){\n        flag = true;\n        Type = 0.;\n    }\n    if(KeyDown(KEY_TWO)){\n        flag = true;\n        Type = 1.;\n    }\n    if(KeyDown(KEY_THREE)){\n        flag = true;\n        Type = 2.;\n    }\n    if(KeyDown(KEY_UP)){\n        flag = true;\n        Alpha += .01;\n    }\n    if(KeyDown(KEY_DOWN)){\n        flag = true;\n        Alpha -= .01;\n        Alpha = max(.005,Alpha);\n    }\n    if(flag){\n        FramInit = float(iFrame);\n    }\n}\n\nbool this_pixel_is_in_the_range(vec2 fragCoord, vec2 r0, vec2 r1)\n{\n    return (step(r0.y-.2, fragCoord.y) * step(fragCoord.y, r1.y+1.2) * \n            step(r0.x-.2, fragCoord.x) * step(fragCoord.x, r1.x+1.2)) > .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (!this_pixel_is_in_the_range(fragCoord, vec2(0., 0.), vec2(1., 0.)))\n    {\n        discard;\n    }\n\n    getGlob();\n    \n    \n    KeyProcess();\n    \n    fragColor = vec4(Phase,FramInit,Alpha,Type);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}