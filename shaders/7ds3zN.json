{
    "Shader": {
        "info": {
            "date": "1615827365",
            "description": "4 players version ( no computer yet ).\nTry to put as many pieces (indeed, as many squares), via diagonal connection since your base corner.\nMouse: pick piece.\n←→: rotate  piece. ↑↓: symmetrize.    SPACE: play the piece.\nC: force next color.",
            "flags": 48,
            "hasliked": 0,
            "id": "7ds3zN",
            "likes": 14,
            "name": "blokus game",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "// === Blokus game ==============================================================\n// https://en.wikipedia.org/wiki/Blokus\n// https://www.google.com/search?q=blokus&tbm=isch\n\ninclude\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 I = vec3(-1,0,1); \n    vec4 s = vec4(0);\n    U = grid(U);\n    \n    if ( min(U.x,U.y) > 0. && max(U.x,U.y) < 20. ) {    // --- draw board\n        O = color[int(C(U).x)];\n#define mine(d) C(U+I.d).x == T(STATE).x\n        if ( C(U).x == 0.                               // show licit places\n             &&  ( mine(xx) || mine(zx) || mine(xz) || mine(zz) )\n             && !( mine(xy) || mine(zy) || mine(yx) || mine(yz) )\n           ) O += .2 + .2*sin(12.*iTime);\n    } \n    else { \n        O = vec4(.5);\n        float N = pick(U);                              // --- draw available pieces\n        if (N >= 0. ) { \n            int n = int (s.w = N ), c = int(T(STATE).x); \n            if ( T(vec2(n,STATE))[c-1] > 0. ) {         // is available\n                u -= vec2(hand[n]%16,hand[n]>>4);       // pieces aligned in Bbox\n                if (n==14) s.z = 1., u.x-=2.,u.y++;     // the long bar is overfill :-)\n                if ( draw( u, s ) > 0. )\n                    draw( u+2.*pix, s ) > 0. ? O = color[c] : O--; // draw or shadow\n            }\n        }\n    }    \n    vec2 F = fract(U);                                  // --- general grid\n    if ( min(F.x,F.y) < pix ) O = vec4(.3);\n\n    int k = int(4.*fract(U.x+.5));                      // --- display score\n    if ( U.x > 20.5 && U.x < 21.5 && U.y>0. && U.y*89./20. < T(STATE+1.)[k] )\n        O = color[k+1];\n    \n    U -= grid(iMouse.xy); F = fract(U);                 // --- draw candidate piece\n    s = T(STATE); \n    if ( min(F.x,F.y) > pix && s.w >= 0. ) O += draw(U,s);\n /* if ( draw(U,s) > 0. && min(F.x,F.y) > pix )         // show licit handles\n        O = draw(U+I.xy,s)+ draw(U+I.zy,s) != 2. && draw(U+I.yx,s) + draw(U+I.yz,s) != 2.\n               ? vec4(.8,.8,1,0) : vec4(1); */\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R             iResolution.xy\n#define T(U)          texelFetch(iChannel0, ivec2(U), 0 )\n#define C(U)          T(U+1.)                              // cell offsetet because of margin\n#define keyDown(a)  ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n//#define grid(U)      22.* ( U - vec2((R.x-R.y)*.5,0) ) / R.y\n#define grid(U)        22.* ( U - vec2( R.x-R.y , 0  ) ) / R.y - vec2(0,1)\n#define pix            22./R.y\n\n// --- data structure ---\n// [1,20]×[1,20] : O.x = color [1,4] + margin ( for start position at angles )\n// (STATE,STATE) : current state: .x = color, .y = sym, .z = rotation, .w = piece\n// (STATE+1,STATE+1) : current score for each player ( .xyzw )\n// ([1,20],STATE)    : piece availability for each player (.xyzw )\n\n#define                STATE 24.5\n\n// --- list of piece shapes ( 4 × n bits ) and their handle position ( = x + 4y )\nint piece[21]  = int[]( 1, 3, 7, (3<<4)+1, (3<<4)+3, \n                       (2<<4)+7, 15, (1<<4)+7, (3<<4)+6, (8<<4)+15, \n                       (2<<8)+(2<<4)+7, (4<<8)+(4<<4)+7, (7<<4)+12, (1<<8)+(7<<4)+4, 69905,\n                       (2<<8)+(3<<4)+3, (3<<8)+(6<<4)+4, (3<<8)+(2<<4)+3, (3<<8)+(6<<4)+2,\n                       (2<<8)+(7<<4)+2, (4<<4) + 15\n                      );\nint size[21]  = int[] ( 1, 2, 3,3, 4,4,4,4,4, 5,5,5,5,5,5,5,5,5,5,5,5 );\nint hand[21]  = int[] ( 0,0,1,16,16,  1,1,1,1,16,  17,3,19,17,32, 17,17,17,17,17,3 );\n\n// --- start handle and color of each player\nvec2 start[4] = vec2[](          vec2(20), vec2(20,-1), vec2(-1), vec2(-1,20) );\nvec4 color[5] = vec4[]( vec4(0), vec4(0,0,1,1), vec4(1,1,0,1), vec4(1,0,0,1), vec4(0,1,0,1) );\n\n\n// because Common are stupidely not really includes\n#define include                                                         \\\n                                                                        \\\nfloat draw(vec2 P, vec4 s ) {   /* --- draw a piece (screen or data) */ \\\n    vec2 I = floor(P);                                                  \\\n    int  n = int(s.w),                                                  \\\n        x = int(I.x), y = int(I.y),                                     \\\n        r = int(mod(s.z,4.)), _x;                                       \\\n    if ( r > 1 ) x = -x, y = -y, r-=2;        /* rotation & symmetry */ \\\n    if ( r > 0 ) _x=x, x = y, y = -_x;                                  \\\n    if ( s.y > 0. ) x = -x;                                             \\\n    x += hand[n]%16, y += hand[n]>>4;             /* handle position */ \\\n    return float(      x>=0 && y>=0 && x<4 && y<5                       \\\n                  && ( piece[n]>>(4*y+x) ) % 2 == 1 );                  \\\n}                                                                       \\\n                                                                        \\\nvec2 u;                                                                 \\\nfloat pick(vec2 U) {          /* --- pick a piece slot (left margin) */ \\\n    if (U.x > -16. && U.x<-1. && floor(U.y)!=17.) {                     \\\n        u = U + vec2( 16,  U.y<1. || U.y>18. ? 0 : 1 );                 \\\n        vec2 BB = vec2(5,3), V = floor( u / BB );                       \\\n        u = mod(u, BB);                  /* out position within slot */ \\\n        return V.x + 3.*V.y;                                            \\\n    }                                                                   \\\n    else return -1.;                                                    \\\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "include \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 M = round(grid(iMouse.xy));\n    vec4 s = T(STATE);\n    vec3 I = vec3(-1,0,1); \n    O = T(U);                                         // restore state\n    bool play = false; \n    if ( keyDown(32) && s.w >= 0. ) {                 // --- user want to play here: check validity\n        bool pb = false, cn = false;\n        for (int k = 0; k<49; k++) {                  // check region of candidate piece\n            vec2 P = M + vec2(k%7-3,k/7-3);           // loop size to optimize\n #define mine(d) C(P+I.d).x == s.x \n            if ( draw( P-0.-M,  s ) > 0. ) {          // piece want to cover cell k\n                pb = pb || C(P).x > 0.                                   // non-free case\n                        || min(P.x,P.y) < 0. || max(P.x,P.y) > 19.       // out of board\n                        || mine(xy) || mine(zy) || mine(yx) || mine(yz); // tangents same color\n                cn = cn || mine(xx) || mine(zx) || mine(xz) || mine(zz); // contact with color tree\n            }\n        }\n        play = cn && !pb;\n    }\n   \n    if ( U==vec2(STATE) ) {                                        // --- basic user actions\n        if (iFrame<1)    O = vec4(3,0,0,-1); \n        if (play)        O = vec4( mod(O.x,4.)+1.,0,0,-1);         // valid play: next player\n        if (keyDown(67)) O.x = mod(O.x,4.)+1.;                     // current color\n     // if (keyDown(32)) O.w = mod(O.w+1.,21.),O.z = 0., O.y = 0.; // select piece \n        if (keyDown(37)) O.z++;                                    // rotate\n        if (keyDown(39)) O.z--;\n        if (keyDown(38)||keyDown(40)) O.y = 1.-O.y;                // symmetry\n        \n        float n = pick(M);                                         // pick a piece\n        if (n>=0. && iMouse.w>0. && T(vec2(n,STATE))[int(s.x)-1] > 0. ) \n            O.w =  n, O.z = 0., O.y = 0.;\n    }\n    if ( U==vec2(STATE+1.) && play )                               // score += piece size\n        O[int(s.x)-1] += float(size[int(s.w)]);\n    \n    if ( U.y == STATE && U.x < 21. ) {                             // --- list of available piece\n        if (iFrame<1)    O = vec4(1); \n        if ( iMouse.w > 0. ) {                                     // click\n            float n = pick(M);            \n            int    c = int(s.x)-1;\n            if ( U.x-.5==s.w && n >= 0. ) O[c] = 1.;               // put back the prev piece\n            if ( U.x-.5== n  && O[c]>0. ) O[c] = 0.;               // pick the new one\n        }\n    }\n    if ( min(U.x,U.y) > 0. && max(U.x,U.y) < 21. && play )         // --- play the piece\n         O.x += draw( U-1.-M , s ) * s.x;\n         \n    if (iFrame<1) for(int k=0; k<4; k++)                           // --- start positions\n                      if (U-.5==start[k]+1.) O.x = float(k+1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}