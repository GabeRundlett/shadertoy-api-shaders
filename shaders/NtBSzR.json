{
    "Shader": {
        "info": {
            "date": "1626870781",
            "description": "Planet moon system. Moon rotating around planet and planet rotating around a source planet.\nLight source is now external.  \n",
            "flags": 0,
            "hasliked": 0,
            "id": "NtBSzR",
            "likes": 2,
            "name": "Planet Moon System",
            "published": 3,
            "tags": [
                "space"
            ],
            "usePreview": 0,
            "username": "napsternxg",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat sphereDist(vec3 p, vec4 s){\n    float dSphere = length(p - s.xyz) - s.w;\n    return dSphere;\n}\n\n\nfloat getDist(vec3 p){\n    float dO = p.y;\n    float d = dO;\n    \n    vec4 s = vec4(0, 1, 10, 1);\n    //s.xz += vec2(sin(iTime), cos(iTime));\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    //s = vec4(0, 1, 6, 1);\n    s.xz += 5.*vec2(sin(0.2*iTime), cos(0.2*iTime));\n    s.w = 0.5;\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    s.xyz += 1.*vec3(-sin(iTime), 0, cos(iTime));\n    //s.xz *= 5.;\n    s.w = 0.3;\n    //s.xz += vec2(sin(iTime), cos(iTime));\n    dO = sphereDist(p, s);\n    d = min(dO, d);\n    \n    \n    \n    return d; \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + dO*rd;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n\n}\n\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(.01, 0);\n    float d = getDist(p);\n    vec3 n = d - vec3(\n        getDist(p -e.xyy), \n        getDist(p -e.yxy), \n        getDist(p -e.yyx)\n    );\n    return normalize(n);\n}\n\n\nfloat getLight(vec3 p){\n\n    //vec3 lightSource = vec3(10.*sin(iTime), 1., 3.*cos(iTime));\n    vec3 lightSource = vec3(0., 3., 6.);\n    //lightSource.xz += vec2(cos(iTime), sin(iTime));\n    vec3 l = normalize(lightSource - p);\n    vec3 n = getNormal(p);\n    float dif = clamp(dot(l, n), 0., 1.);\n    \n    float d = RayMarch(p + n*SURF_DIST*3., l);\n    if(d < length(p-lightSource)) dif *= 0.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv -= 0.5; \n    //float aspectRatio = iResolution.x/iResolution.y;\n    //uv.x *= aspectRatio;\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    \n    vec3 p = ro + d*rd;\n    \n    float dif = getLight(p);\n    \n    //col = getNormal(p);\n    //col = vec3(d/6.);\n    col = vec3(dif, dif*dif, dif*dif*dif);\n    //vec3 plane = vec3(uv.x, 0., 0.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}