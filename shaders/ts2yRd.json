{
    "Shader": {
        "info": {
            "date": "1587235903",
            "description": "The 12 non-hexagonal wallpaper groups, with colouring.\n\nSee code for controls.",
            "flags": 48,
            "hasliked": 0,
            "id": "ts2yRd",
            "likes": 3,
            "name": "Coloured Wallpaper",
            "published": 3,
            "tags": [
                "wallpaper"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 483
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Coloured Wallpaper. Generate the 12 non-hexagonal wallpaper groups, and\n// use symmetries to generate a consistent colouring.\n// Matthew Arcus (mla), 2020\n//\n// <mouse>: change offset into texture\n// <up>/<down>: zoom in/out\n// <page up>/<page down>: number of colours, 1-8\n// <left>/<right>: select groups, default cycles through them all\n// c: colouring of regions\n// e: enlarge texture\n// r: use equilateral rhombus for basic tile\n// o: offset into texture\n// 1-6: draw various grid lines\n// \n////////////////////////////////////////////////////////////////////////////////\n\nbool docolor = true;\nbool dolines = true;\nfloat scale = 2.2;\nint ncolors = 5;\nfloat lod = 1.0;\n\nfloat PI = 3.141592654;\n\n// Map to lattice separately as it's useful to have the\n// resulting intermediate point.\nvec2 lattice(vec2 z, out ivec2 index) {\n  vec2 z1 = round(0.5*z);\n  index = ivec2(z1);\n  z -= 2.0*z1;\n  return z;\n}\n\nvoid try(inout vec2 z, inout int index, bool test, vec2 z1) {\n  index = (index << 1) | int(test);\n  if (test) z = z1;\n}\n\nvoid try(inout float x, inout int index, bool test, float x1) {\n  index = (index << 1) | int(test);\n  if (test) x = x1;\n}\n\nbool alert = false;\n\n// Wallpaper groups - also Conway's orbiform notation.\nint p1 = 1; // o\nint p2 = 2; // 2222\nint pm = 3; // **\nint pg = 4; // xx\nint cm = 5; // *x\nint pmm = 6; // *2222\nint pmg = 7; // 22*\nint pgg = 8; // 22x\nint cmm = 9; // 2*22\nint p4 = 10; // 442\nint p4m = 11; //*442\nint p4g = 12; // 4*2\n\n// How many bits for the index.\nint nbits[12] = int[](0,1,1,1,1,2,2,2,2,2,3,3);\n\nvec2 wallpaper(vec2 z, int type, out int index) {\n  index = 0;\n  if (type == p1) {\n    // Nothing to do\n  } else if (type == p2 || type == pgg) {\n    // 2-fold rotation\n    try(z,index,z.x < 0.0,-z); // Rotate 180 about 0\n    if (type == pgg) {\n      // (viii) reflect up, glide, then reflect back - pgg\n      bool p = z.y < 0.0;\n      if (p) z.y = -z.y;\n      try(z,index,z.x+z.y > 1.0,vec2(1.0-z.x,z.y-1.0));\n      if (p) z.y = -z.y;\n    }\n  } else if (type == pm || type == pmg) {\n    try(z.x,index,z.x < 0.0,-z.x); // Reflect in x=0 - pm\n    if (type == pmg) {\n      // (vii) reflect in x, then rotate about (0.5,0) - pmg\n      try(z,index,z.y < 0.0, vec2(1.0-z.x,-z.y));\n    }\n  } else if (type == pg) {\n    try(z,index,z.x < 0.0, vec2(z.x+1.0,-z.y)); // Glide along y=0\n  } else if (type == cm || type == cmm) {\n    try(z,index,z.x+z.y < 0.0,-z.yx); // reflect in x+y=0\n    if (type == cmm) {\n      // (ix) also reflect in x = y - cmm\n      try(z,index,z.y > z.x,z.yx);\n    }\n  } else if (type == pmm || type == p4m) { // Rhomboid\n    index |= 2*int(z.x < 0.0) + int(z.y < 0.0); // 2 bits\n    z = abs(z); // (vi) reflect quadrants - pmm\n    if (type == p4m) {\n      // (xi) 4 reflection axes - p4m\n      try(z,index,z.x + z.y > 1.0, 1.0-z.yx); // Reflect in x+y=1\n    }\n  } else if (type == p4 || type == p4g) {\n    // 4-fold rotation\n    // (x) rotate quadrants - p4\n    index |= 2*int(z.x < 0.0) + int(z.y < 0.0);\n    if (z.x < 0.0) { z = -z; } // Rotate 180 about 0\n    if (z.y < 0.0) z = vec2(-z.y,z.x); // Rotate 90 about 0\n    if (type == p4g) {\n      // (xii) additionally: reflect in x+y=1 - p4g\n      try(z,index,z.x+z.y > 1.0,1.0-z.yx); // Reflect in x+y=1\n    }\n  } else {\n    alert = true;\n  }\n  return z;\n}\n\nfloat linedist(vec2 pos, vec2 a, vec2 b) {\n  vec2 pa = pos - a;\n  vec2 ba = b - a;\n  float h = dot(pa, ba) / dot(ba, ba);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nvec3 indexcolor(int index) {\n  index = mymod(index, ncolors);\n  vec3 col = vec3(0);\n  if (index == 0) col = vec3(1,0,0);\n  if (index == 1) col = vec3(1,1,0);\n  if (index == 2) col = vec3(0,1,0);\n  if (index == 3) col = vec3(0,0,1);\n  if (index == 4) col = vec3(0,1,1);\n  if (index == 5) col = vec3(1,0,1);\n  if (index == 6) col = vec3(1);\n  if (index == 7) col = vec3(0.5);\n  return 0.5+0.5*col;\n}\n\nbool dooffset = true;\nbool doenlarge = true;\n\nvec3 getcolor(vec2 z, int type, ivec4 ivector) {\n  vec2 offset = vec2(0);\n  if (dooffset) offset += vec2(sin(0.1*iTime),sin(0.123*iTime));\n  if (iMouse.x > 0.0) {\n    offset += 2.0*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  }\n  vec2 uv = 0.5*z-0.5+offset;\n  if (doenlarge) uv *= 0.5;\n  vec4 tt = textureLod(iChannel0,uv,lod);\n  if (!docolor) return tt.xyz;\n  // Generate a colour from the index. Lots of ways this could\n  // be done, eg. just use z and w so whole tile gets same colour.\n  int index = 0;\n  int n = nbits[type];\n  if (n == 3) {\n    index = ivector.x;\n    // xor the top bit (bit 3) with the other bits\n    index ^= -((index>>2)&1);\n    index &= 3;\n    // offset for the tile\n    index += ivector.z + ivector.w;\n  } else {\n    index = ((ivector.z + ivector.w)<<n) - ivector.x;\n  }\n  vec3 color = indexcolor(index);\n  color *= length(tt.xyz);\n  return color;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_C = 67;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_H = 72;\nconst int CHAR_M = 77;\nconst int CHAR_O = 79;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel3, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nbool key(int key) {\n  return texelFetch(iChannel2,ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  int type = mymod(keycount(KEY_RIGHT)-keycount(KEY_LEFT),13);\n  if (type == 0) type = 1+int(0.2*iTime)%12;\n  ncolors = 1+mymod(5+keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP),8);\n  docolor = !key(CHAR_C);\n  dooffset = !key(CHAR_O);\n  doenlarge = key(CHAR_E);\n  scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  lod = log2(scale*iChannelResolution[0].y/iResolution.y);\n  if (doenlarge) lod -= 1.0;\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  mat2 m = mat2(1);\n  //m = mat2(-0.8,0.5,0.8,0.5);\n  // Use rhombus for basic tile - not all groups work with this.\n  if (key(CHAR_R)) m = 0.5*mat2(1,sqrt(3.0),-1,sqrt(3.0));\n  z = inverse(m)*z;\n  ivec4 index;\n  vec2 z0 = z;\n  z = lattice(z,index.zw);\n  vec2 z1 = m*z;\n  z = wallpaper(z,type,index.x);\n  z = m*z;\n  //if (z != z0) alert = true; // Show region\n  vec3 col = getcolor(z,type,index);\n  if (dolines) {\n    // Draw various grid lines.\n    float d = 1e8;\n    vec2 p = m*vec2(1,1);\n    vec2 q = m*vec2(1,-1);\n    vec2 r = m*vec2(-1,-1);\n    vec2 s = m*vec2(-1,1);\n    vec2 pq = 0.5*(p+q);\n    vec2 rs = 0.5*(r+s);\n    vec2 qr = 0.5*(q+r);\n    vec2 sp = 0.5*(s+p);\n    if (!key(CHAR_0+1)) {\n      d = min(d,linedist(z1,p,q));\n      d = min(d,linedist(z1,q,r));\n      d = min(d,linedist(z1,r,s));\n      d = min(d,linedist(z1,s,p));\n    }\n    if (key(CHAR_0+2)) d = min(d,linedist(z1,pq,rs));\n    if (key(CHAR_0+3)) d = min(d,linedist(z1,qr,sp));\n    if (key(CHAR_0+4)) d = min(d,linedist(z1,p,r));\n    if (key(CHAR_0+5)) d = min(d,linedist(z1,q,s));\n\n    if (key(CHAR_0+6)) {\n      d = min(d,linedist(z1,pq,qr));\n      d = min(d,linedist(z1,qr,rs));\n      d = min(d,linedist(z1,rs,sp));\n      d = min(d,linedist(z1,sp,pq));\n    }\n\n    col *= smoothstep(0.01,0.02,d);\n  }\n  if (alert) col *= 0.6;\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel2,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel3,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}