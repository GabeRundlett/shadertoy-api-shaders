{
    "Shader": {
        "info": {
            "date": "1485854657",
            "description": "Using absolute sum of 3d perlin noise to generate electric field. Coloring could be much better, give suggestions.\n\nRef:\n- https://iquilezles.org/\n- https://www.shadertoy.com/user/candycat",
            "flags": 0,
            "hasliked": 0,
            "id": "4tySWK",
            "likes": 69,
            "name": "[ #02 ] - Electric field",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "lightning",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "Yrai",
            "viewed": 4291
        },
        "renderpass": [
            {
                "code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define res_          iResolution\n#define time_         iTime\n#define detail_steps_ 13\n\n#define mod3_      vec3(.1031, .11369, .13787)\n\n\nvec3  hash3_3(vec3 p3);\nfloat perlin_noise3(vec3 p);\nfloat noise_sum_abs3(vec3 p);\nvec2  domain(vec2 uv, float s);\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = domain(fragCoord, 2.5);\n   \t\n    float electric_density = .9;\n    float electric_radius  = length(p) - .4;\n    float velocity = .1;\n    \n    float moving_coord = sin(velocity * time_) / .2 * cos(velocity * time_);\n    vec3  electric_local_domain = vec3(p, moving_coord);\n    float electric_field = electric_density * noise_sum_abs3(electric_local_domain); \n    \n    vec3 col = vec3(107, 148, 196) / 255.;\n \tcol += (1. - (electric_field + electric_radius));\n    for(int i = 0; i < detail_steps_; i++) {\n    \tif(length(col) >= 2.1 + float(i) / 2.)\n            col -= .3;\n    }\n    col += 1. - 4.2*electric_field;\n    \n    float alpha = 1.;\n    fragColor = vec4(col, alpha);\n}\n\n\nvec3 hash3_3(vec3 p3) {\n\tp3 = fract(p3 * mod3_);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n}\n\nfloat perlin_noise3(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3. - 2. * pf);\n    \n    return \tmix(\n    \tmix(\n            mix(\n                dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),\n                w.x),\n    \tw.z),\n        mix(\n            mix(\n                dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),\n                w.x),\n     \tw.z),\n\tw.y);\n}\n\n\nfloat noise_sum_abs3(vec3 p) {\n    float f = 0.;\n    p = p * 3.;\n    f += 1.0000 * abs(perlin_noise3(p)); p = 2. * p;\n    f += 0.5000 * abs(perlin_noise3(p)); p = 3. * p;\n\tf += 0.2500 * abs(perlin_noise3(p)); p = 4. * p;\n\tf += 0.1250 * abs(perlin_noise3(p)); p = 5. * p;\n\tf += 0.0625 * abs(perlin_noise3(p)); p = 6. * p;\n    \n    return f;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2.*uv.xy-res_.xy) / res_.y*s;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}