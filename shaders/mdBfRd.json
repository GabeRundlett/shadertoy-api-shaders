{
    "Shader": {
        "info": {
            "date": "1690199806",
            "description": "Simpler variant of Directional Flow use to hide the repeating Tiling by rotating cells in random directions that uses only 1 texture sample, a cheap dither, and 1 cheap hash. ",
            "flags": 0,
            "hasliked": 0,
            "id": "mdBfRd",
            "likes": 4,
            "name": "Texture Tiling Hider Dithered ",
            "published": 3,
            "tags": [
                "hexagon",
                "barycentric",
                "flow",
                "pattern",
                "hex",
                "directional",
                "dodecahedron",
                "vectorfield",
                "stochastic",
                "direction",
                "rohmbic",
                "rhom"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a simple variant of the Square Directional Flow. This one simply doesn't move.\nIt is a great way to create a non repeating tiling. It uses dithering to interpolate\nUVs and is there able to only use 1 texture lookup.  \nThis uses 1 cheap hash call, 1 cheap dither, and 1 texture lookup.\n\nDirectional Flow animates and rotates a texture in multiple directions with \na flowmap. This means that water wave textures can flow in multiple directions \nat the same time, while the waves point in the right direction. This is not \npossible with trational flow animation, which either has only one wind \ndirection or stretches the texture with temporal blending. The Directional Flow\ndoes this by blending in the spatial dimension. \n\nThe earliest iteration of directional flow I could find is from 2010:\nhttps://www.rug.nl/society-business/centre-for-information-technology/research/hpcv/publications/watershader/\nBut CatlikeCoding's version is much better explained, so I recommend reading \nit as a guide:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n*/\n\n//#define RepeatTiling\n//#define ShowGrid\n//#define AnimatedDither\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n\treturn vec2(q) * SMALLESTFLOAT;\n}\n\n// \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n// https://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n// valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nfloat ScreenSpaceDither12(vec2 vScreenPos)\n{\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iTime); \n    return fract( vDither / 103.0);\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal \n{\n    vec2 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec2 id;         // ID values\n    float edgeDist;  // Edge distance from the cell's center to its boundaries\n};\n\n// Square tiling function\ntilingVal squareTile(vec2 uv) {\n    vec2 grid = fract(uv) - 0.5;   // the cell coordinates in the grid\n\n    vec2 distanceFromCenter = abs(grid);\n    float edgeDist = (0.5 - max(distanceFromCenter.x, distanceFromCenter.y)) * 2.0;\n\n    vec2 id = uv - grid;  // ID values for the cell\n\n    return tilingVal(grid, id, edgeDist);  // make tilingVal struct\n}\n\n// Rhombus tiling function\ntilingVal rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;    \n    vec2 grid = dot(a,a) < dot(b,b) ? a : b; //UV centered in cell\n    \n    vec2 ma = abs(a);\n    vec2 mb = abs(b);\n    float eDist = (max(ma.x+ma.y,mb.x+mb.y)-0.5)*2.; //Edge Distance\n    \n    // adding tiny offset to prevent floating point errors\n    vec2 id = uv - grid  + 0.0000001; //ID values\n    return tilingVal(grid, id, eDist);  // make tilingVal struct\n}\n\n// rotates and animates texture in flowmap direction \nvec3 directionalTex (vec2 uv, vec2 flowMap, vec2 duvdx, vec2 duvdy) {\n    vec2 direction = normalize(flowMap); // normalize for rotation\n    uv = mat2x2(direction.y, direction.x, -direction.x, direction.y)*uv; // rotate UVs\n    \n    uv += flowMap; // offset\n    \n    // scale UVs so the entire texture is visible in a tile\n    // the proper range is ~1-3 and artists don't read, so this is hard set to\n    uv *= 2.0; \n    \n    return textureGrad(iChannel0, uv, duvdx, duvdy).xyz; // sample texture\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// 3 Grids blending between each other with each tile having a unique rotation and offset\nvec3 squareDirectionalNoiseDither(vec2 uv, float gridRes, float contrast, vec2 fragCoord) {\n    #ifdef RepeatTiling    \n        uv = fract(uv); // repeating UVs is sometimes useful\n        // needs to be a hole number or tiling won't be seamless\n        gridRes = floor(gridRes);\n    #endif    \n    \n    uv *= gridRes; // scalue UVs to gridres\n    \n    tilingVal A = squareTile(uv); // grid A\n    tilingVal B = squareTile(uv + vec2(0.5)); // grid B offset to corner of grid A\n    tilingVal C = rhomTile(uv); // grid C\n    \n    //All edgeDist added = 1 -> so we can skip the more expensive C calculation\n    vec3 alpha = vec3(A.edgeDist, B.edgeDist, 1.-(A.edgeDist + B.edgeDist)); \n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    #ifdef AnimatedDither\n        // smooth contrast creates artifacts in the dither. Clamp on the dither removes it\n        float dither = clamp(ScreenSpaceDither12(fragCoord), 0.01, 0.99);\n    #else\n        // static dither\n        float dither = InterleavedGradientNoise(fragCoord);\n    #endif\n    \n    // add prime number to avoid 0 which hash doesn't like\n    A.id = A.id + 181.;    \n    #ifdef RepeatTiling\n        // mod for repeating at UV=1\n        B.id = mod(B.id, gridRes) + 691.;\n        // also multiply by 2 as hash rounds UVs, adding ti\n        C.id = mod(C.id, gridRes)*2. + 353.);\n    #else\n        B.id = B.id + 691.;\n        C.id = C.id * 2. + 353.;\n    #endif\n\n    // \"interpolate\" the UVs using dither\n    float sumXY = alpha.x + alpha.y;\n    vec2 ditherId;\n    vec2 ditherGrid;\n    if (alpha.x > dither) {\n        ditherId = A.id;\n        ditherGrid = A.grid;\n    } else if (1.-alpha.z > dither) {\n        ditherId = B.id;\n        ditherGrid = B.grid;\n    } else {\n        ditherId = C.id;\n        ditherGrid = C.grid;\n    }\n        \n    // Sample Noise using dithered ID\n    vec2 noise = hash22(ditherId)*2.-1.;\n    \n    // Mip caculation as the automatic ones don't work\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );\n    \n    // rotate and offset then sample texture using dithered UVs. \n    // !!! Auto Mips must be disabled, but computed values still work\n    vec3 col = directionalTex(ditherGrid, noise, duvdx, duvdy);\n    \n    #ifdef ShowGrid\n        float lineThickness = 0.05; // must be smaller than 0.1\n        vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n        return max(mask, col);\n    #else\n        return col;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // rectangular UVs\n    vec2 uv = fragCoord/iResolution.y;    \n    // uv *= 2.; // to better see repeating tilings\n    \n    float gridRes = 2.;\n    float contrast = 4.; //1 no contrast, higher values increase contrast\n\n    vec3 col = squareDirectionalNoiseDither(uv, gridRes, contrast, fragCoord);\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}