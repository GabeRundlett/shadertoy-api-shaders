{
    "Shader": {
        "info": {
            "date": "1457309810",
            "description": "A \"sunset dome\" I made a while ago recycled to test water reflections.",
            "flags": 0,
            "hasliked": 0,
            "id": "ld3XRr",
            "likes": 36,
            "name": "Dirty Water",
            "published": 3,
            "tags": [
                "sunset",
                "water",
                "pbr"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 7058
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : Dec 2015\n// Modified : Jan 2016\n//\n// For this shader, a \"sunset dome\" I made a while ago was recycled to test Image-Based Lighting\n// PBR materials (water reflection). Not much effort was invested in the wave movement (sines), the focus\n// was rather on shimmering/reflection.\n//\n// Still a lot of room for improvement, most notably:\n//  -IBL PBR Material is expensive\n//  -Sampling pattern artifacts\n//  -Rocky formation look like bad CG from the '80s :). I need to improve my generative\n//   modeling skills.\n//  -Water surface lighting missing over reflexions.\n//  -Sky dome does not look good in some angles. Need to work on this too.\n//  -Fog, lens flares, etc.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\n\n//----------------------\n// Constants / enums\nconst float BUMP_MAP_UV_SCALE = 0.020;\nconst float MAX_DIST = 2000.0;\nconst float PI = 3.14159;\nconst vec3 LColor = vec3(1,0.95,0.7)*0.25;\nconst int MATERIALID_NONE      = 0;\nconst int MATERIALID_FLOOR     = 1;\nconst int MATERIALID_SKY       = 2;\nconst int MATERIALID_STONE     = 3;\nconst int MATERIALID_WATER     = 4;\nconst int MATERIALID_B         = 5;\nconst int MATERIALID_C         = 6;\nconst int MATERIALID_D         = 7;\nconst int DEBUG_RAYLEN  = 0;\nconst int DEBUG_GEODIST = 1;\nconst int DEBUG_NORMAL  = 2;\nconst int DEBUG_MATUVW  = 3;\nconst int DEBUG_MATID   = 4;\nconst int DEBUG_ALPHA   = 5;\nconst float fWaterVariation = 0.35;\nconst float fMinWaterHeight = 0.0;\n\n//----------------------\n// Camera\nstruct Cam { vec3 R; vec3 U; vec3 D; vec3 o; }; //Right, Up, Direction, origin\nCam    CAM_animate(vec2 uv, float fTime);\nvec3   CAM_getRay(Cam cam, vec2 uv);\n\n//----------------------\n// sampling functions\nfloat SAMPLER_trilinear(vec3 p); //Volumetric function\nvec3 SAMPLER_triplanarChannel1(vec3 p, vec3 n); //Surface triplanar projection\nvec3 NOISE_roughnessMap(vec3 p, float rayLen);\n\n// color conversion\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//----------------------\n// Analytic Intersections\nfloat RAYCAST_plane(vec3 o, vec3 d, vec3 po, vec3 pn)\n{\n    return dot(po-o,pn)/dot(d,pn); \n}\nfloat RAYCAST_floor(vec3 ro, vec3 rd)\n{\n\tfloat t = RAYCAST_plane(ro,rd,vec3(0,0,0),vec3(0,1,0));\n    return (t<0.0)?MAX_DIST:t;\n}\n\nfloat RAYCAST_sphere(vec3 o, vec3 d, vec3 c, float r)\n{\n    vec3 dn = d;\n    dn = normalize(dn);\n\tfloat a = RAYCAST_plane(o,d,c,normalize(d));\n    vec3 p1 = o+a*d;\n    vec3 vp1c = p1-c;\n    float dc2 = dot(vp1c,vp1c);//norm2\n    float r2 = r*r;\n    if( dc2 < r2)\n    {\n        //float fDepth2 = sqrt(r2-dc2);\n        return a+sqrt(r2-dc2);\n\t}\n    return -1.;\n}\n\nvec3 SKY_grad(float h, float fTime)\n{\n    //Gradient values sampled from a reference image.\n    const vec3 r1 = vec3(195./255.,43./255.,6./255.);\n\tconst vec3 r2 = vec3(228./255.,132./255.,28./255.);\n\tconst vec3 bg1 = vec3(168./255.,139./255.,83./255.);\n\tconst vec3 bl1 = vec3(86./255.,120./255.,147./255.);\n\tconst vec3 bl2 = vec3(96./255.,130./255.,158./255.);\n\tconst vec3 bl3 = vec3(96./255.,130./255.,218./255.);\n    \n    h = h-h*0.25*sin(fTime);\n    vec3 c;\n    if(h<0.25)\n        c = mix(r1,r2,4.*h);\n    else if(h<0.5)\n        c = mix(r2,bg1,4.*(h-0.25));\n    else\n    \tc = mix(bg1,bl2,2.*(h-0.5));\n    \n    float light = 1.0+0.25*sin(fTime);\n    return mix(c,bl3,0.25+0.25*sin(fTime))*light;\n}\n\nvec3 SKY_main(vec3 p, float fTime, bool addSun)\n{\n    vec3 sunPos = vec3(0.,sin(fTime),cos(fTime));\n    fTime = -1.95;\n    \n    p = normalize(p);\n    vec3 nSunPos = normalize(sunPos);\n        \n    //Pseudo - Rayleight scattering (daylight blue)\n    float anlgePosSun_FromOrigin = acos(dot(p,nSunPos));\n    anlgePosSun_FromOrigin = clamp(anlgePosSun_FromOrigin,0.,PI);\n    float posAngle = asin(p.y);\n    \n    float fAtmosphereThickness = 2.0;\n    float fTraversalDistance = 0.35*cos(sqrt(clamp(12.3*posAngle,0.0,100.0))-0.8)+0.65;\n    \n    float dayV = 0.25+0.666*(0.3+fTraversalDistance)*(dot(p,nSunPos)+1.0)/2.0;\n    float dayS = 0.9-fTraversalDistance/1.60;\n    float dayH = mix(0.61,0.65,p.y);\n    \n    vec3 day = hsv2rgb(vec3(dayH,dayS,dayV));\n    vec3 gradS = SKY_grad(0.75-0.75*dot(p,nSunPos)*clamp(1.0-3.0*p.y,0.0,1.0)*fTraversalDistance,fTime);\n    vec3 gradF = (gradS+day)/2.0;\n    \n    if(addSun)\n    {\n\t\t//1/x for rapid rise close from d=0\n\t\t//2^abs(x) for soft long range ramp down\n        float d = length(sunPos-p)*10.;\n    \tfloat I = 0.015/abs(d)+pow(2.,-abs(d*2.))*0.4;\n    \tvec3 c = vec3(255./255.,213./255.,73./255.);\n\t    gradF += c*I*2.0;\n    }\n        \n    //Distribute the excess R light on other components\n    if(gradF.x > 1.0)\n        gradF = gradF + vec3(0,(gradF.x-1.0)/1.5,(gradF.x-1.0)/0.75);\n   \treturn gradF;\n}\n\n//------------------------------------------------------\n// Water stuff\n//------------------------------------------------------\n#define remap_01(a) (0.5+0.5*a)\nfloat WATER_height(vec2 p,float fTime)\n{\n    const float HF_I = 0.005;\n    const float HF_F1 = 6.01;\n    const float HF_F2 = 7.27;\n    fTime = -fTime;\n    return fMinWaterHeight+fWaterVariation*(0.495+0.495*sin(length(p-vec2(12,-5))+fTime*1.5)\n               /* +0.15+0.15*sin(3.0*length(p-vec2(3,-12))+sin((iTime/10.0)*0.05+2.0)*iTime*-1.)*/\n                +HF_I*remap_01(sin(HF_F1*(length(p-vec2(2.5,-2.5))+fTime))))\n                +HF_I*remap_01(sin(HF_F2*(length(p-vec2(5,-25))+fTime)));\n}\nfloat WATER_heightLF(vec2 p,float fTime)\n{\n    fTime = -fTime;\n    return fMinWaterHeight+fWaterVariation*(0.495*remap_01(sin(length(p-vec2(0,0))+fTime*1.5)));\n}\nvec3 WATER_normal(vec3 p,float fTime)\n{\n    float eps = 0.1;\n    float h = WATER_height(p.xz,fTime);\n    vec3 px = p+vec3(eps,0,0);\n    vec3 pz = p+vec3(0,0,eps);\n    vec3 vx = vec3(eps,WATER_height(px.xz,fTime)-h,0  );\n    vec3 vz = vec3(  0,WATER_height(pz.xz,fTime)-h,eps);\n    vec3 n = normalize(cross(vz,vx));\n    return mix(n,vec3(0,1,0),clamp(abs(p.z)/75.0,0.,1.));\n}\nvec3 WATER_intersec(vec3 o, vec3 d, float fTime)\n{   \n    //Initialize at average water height.\n    float avgWaterHeight = fMinWaterHeight+fWaterVariation*0.5;\n    float t = RAYCAST_plane(o,d,vec3(0,avgWaterHeight,0),vec3(0,1,0));\n    if(t<0.0)\n        return vec3(MAX_DIST);\n    vec3 p = o+t*d; \n    float rLen = 1.0/abs(d.y);\n    for(int i=0; i < 10; ++i)\n    {\n        float h = WATER_heightLF(p.xz, fTime);\n        float dist = p.y-h;\n        p += d*dist;\n        if(abs(dist)<0.001) //refine until acceptable.\n            break;\n    }\n    return p;\n}\n\n//------------------------------------------------------\n// Geometry stuff\n//------------------------------------------------------\n\nfloat DF_cube( vec3 p, vec3 size );\nfloat DF_sphere( vec3 p, float rad );\nfloat DF_merge( float d1, float d2 );\nfloat DF_smoothMerge( float d1, float d2, float d3, float k );\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nstruct DF_out\n{\n    float d;\n    int matID;\n};\n\n//::DF_composition\nDF_out DF_composition( in vec3 pos, const bool addNoise )\n{\n    const float noiseStrength = 0.3;\n    const float isoContour = 0.2;\n    const float xRepeatDist = 7.0;\n    float repeatedX = (fract(pos.x/xRepeatDist+0.5)-0.5)*xRepeatDist;\n    float randomSeed = pos.x-repeatedX;\n    if(abs(pos.x) < xRepeatDist*1.5)\n    \tpos.x = repeatedX+((pos.x<xRepeatDist/2.0)?0.:1.);\n    \n    //Rotation matrix\n    const mat3 rx45 = mat3(1.000,+0.000,0.000,\n\t                       0.000,+0.707,0.707,\n\t                       0.000,-0.707,0.707);\n    const mat3 rz45 = mat3(+0.707,0.707,0.000,\n\t                       -0.707,0.707,0.000,\n\t                       +0.000,0.000,1.000);\n    const mat3 rxrz45 = rx45*rz45; //Computed at compile time.\n    \n    vec3 pos_rx_rz = rxrz45*pos;\n\tfloat sd_water  = 10000.0;\n    vec3 objectCenter = vec3(0,1,abs(pos.x)/4.0);\n    pos-=objectCenter;\n    \n    vec3 randomPos = vec3(2.5*sin(randomSeed*8.3),6.0,2.5*sin(randomSeed*2.2));\n    float randomRad = float(0.95+0.25*sin(randomSeed*8.3));\n    \n    //Explanation: https://iquilezles.org/articles/distfunctions\n    float sd_cube = DF_cube(pos_rx_rz-rxrz45*randomPos, vec3(1,1,1)*0.9 );\n    float sd_cylA = sdCappedCylinder(pos-vec3(0,3.5,0),vec2(randomRad*1.25+0.2*sin(0.5*pos.y-1.9),2.1));\n    float sd_cylB = sdCappedCylinder(pos,              vec2(0.6,4.1));\n\tfloat sd_sphere = DF_sphere(pos    -vec3(0.0,1.1,1.0), 0.1 );\n    float dMin = DF_smoothMerge(sd_cylA,sd_cube,sd_cylB, 1.3);\n    dMin = min(sd_water,dMin);\n    \n    DF_out dfOut;\n    dfOut.d = dMin-isoContour;\n    dfOut.matID = MATERIALID_STONE;\n    \n    if(addNoise)\n    {\n    \tfloat mainFreq = 0.005;\n\t\tpos *= mainFreq;\n    \tfloat distNoiseA = 0.500*(-0.5+SAMPLER_trilinear(1.00*pos*vec3(1.0,5.0,1.0)));\n    \tfloat distNoiseB = 0.250*(-0.5+SAMPLER_trilinear(2.01*pos*vec3(0.8,2.0,1.2)+distNoiseA*0.02));\n    \tfloat distNoise = noiseStrength*(distNoiseA+distNoiseB);\n        dfOut.d = dMin-isoContour+distNoise;\n    }\n    \n    return dfOut;\n}\n\nvec3 DF_gradient( in vec3 p )\n{\n\tconst float eps = 0.01;\n\tvec3 grad = vec3(DF_composition(p+vec3(eps,0,0),true).d-DF_composition(p-vec3(eps,0,0),true).d,\n                     DF_composition(p+vec3(0,eps,0),true).d-DF_composition(p-vec3(0,eps,0),true).d,\n                     DF_composition(p+vec3(0,0,eps),true).d-DF_composition(p-vec3(0,0,eps),true).d);\n\treturn grad;\n}\n\nstruct rayMarchOut\n{\n\tfloat rayLen;\n    float geoDist;\n    vec3 hitPos;\n    bool bReflect;\n};\n\n//::RAYMARCH_reflect\nrayMarchOut RAYMARCH_reflect( vec3 o, vec3 dir, float reflectLen, vec3 reflectDir )\n{\n    rayMarchOut rmOut;\n        \n    //Learned from Inigo Quilez DF ray marching :\n    //https://iquilezles.org/articles/raymarchingdf\n    float tmax = 100.0;\n\tfloat precis = 0.0001;\n    float t = 0.1;\n    float dist = MAX_DIST;\n    rmOut.bReflect = false;\n    vec3 p = vec3(0);\n    for( int i=0; i<40; i++ )\n    {\n        p = o+dir*t;\n\t    dist = DF_composition( o+dir*t,true).d;\n        //This here allows the bouncing on water surface in a single ray marching loop\n        if(t>reflectLen && !rmOut.bReflect)\n        {\n            o=o+reflectLen*dir;\n            dir = reflectDir;\n            t=0.0;\n            rmOut.bReflect = true;\n        }\n        \n        if( abs(dist)<precis || t>tmax ) break;\n        t += dist;\n    }\n    \n    rmOut.rayLen = (t<tmax&&dist<0.1)?t:MAX_DIST;\n    rmOut.geoDist = dist;    \n    rmOut.hitPos = p;\n    return rmOut;\n}\n\nstruct TraceData\n{\n    float rayLen;\n    vec3  rayDir;\n    float geoDist;\n    vec3  normal;\n    int   matID;\n    bool  bReflect;\n    float fReflectDist;\n    vec3  vReflectNormal;\n};\n\nTraceData new_TraceData()\n{\n    TraceData td;\n    td.rayLen = 0.;\n    td.rayDir = vec3(0);\n    td.geoDist = 0.;\n    td.normal = vec3(0);\n    td.matID = MATERIALID_NONE;\n    td.bReflect = false;\n    td.fReflectDist = 0.0;\n    return td;\n}\n\nvec3 MAT_distanceFieldIsolines(vec2 uv);\n\nvec3 horizonColor(vec3 o, vec3 d, float fTime, bool addSun)\n{\n    float fSphereRad = 200.0;\n    vec3 spherePos = vec3(0,0,0);\n    float b = RAYCAST_sphere(o,d,spherePos,fSphereRad);\n    vec3 ph = o+b*d;\n    return SKY_main(ph/fSphereRad,fTime,addSun);\n}\n\nvec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01, bool addSun)\n{\n    return pow(horizonColor(vec3(0), sampleDir, 0.10, addSun),vec3(2.2));\n}\n\n#define saturate(a) clamp(a,0.0,1.0)\nvec3 MAT_integrateHemisphere(vec3 normal)\n{\n    //FIXME : Invalid for surfaces facing up.\n    vec3 up = vec3(0,1,0.00);\n    vec3 right = normalize(cross(up,normal));\n    up = cross(normal,right);\n\n    vec3 sampledColour = vec3(0,0,0);\n    float index = 0.;\n    float phi = 0.;\n    const int nMERIDIANS = 3;\n    const int nPARALLELS = 3;\n    for(int i = 0; i < nMERIDIANS; ++i)\n    {\n        float theta = 0.0;\n        for(int j=0; j < nPARALLELS; ++j)\n        {\n            vec3 temp = cos(phi) * right + sin(phi) * up;\n            vec3 sampleVector = cos(theta) * normal + sin(theta) * temp;\n            vec3 linearGammaColor = PBR_HDRCubemap(sampleVector,0.0, false);\n            //<FIXME HACK : reduce lightness when the vector direction is down>\n\t\t\tlinearGammaColor *= saturate(1.0-dot(sampleVector+vec3(0,-0.3,0),vec3(0,-1,0)));\n            sampledColour += linearGammaColor * \n                                      cos(theta) * sin(theta);\n            index ++;\n            theta += 0.5*PI/float(nPARALLELS);\n        }\n        phi += 2.0*PI/float(nMERIDIANS);\n    }\n\n    return vec3( PI * sampledColour / index);\n}\n\nconst float F_DIELECTRIC_WATER   = 1.33; //@550nm\n\n//#define saturate(a) clamp(a,0.0,1.0)\nvec3 PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, vec3 ior_n, vec3 ior_k, const bool metallic, const bool bIBL)\n{\n    //<http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n    \n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n     //<Distribution Term>\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D_ABL = 1.0; //Distribution term is externalized from IBL version\n    if(!bIBL)\n        D_ABL = (NdotH>0.)?alpha2/(PI*den*den):0.0; //GGX Distribution.\n\t//</Distribution>\n    \n    //<Fresnel Term>\n    vec3 F;\n    if(metallic)//(TODO: Fix binary condition with a material layering strategy).\n    {\n        //<Source : http://sirkan.iit.bme.hu/~szirmay/fresnel.pdf p.3 above fig 5>\n        float cos_theta = 1.0-NdotV;//REVIEWME : NdotV or NdotL ?\n        F =  ((ior_n-1.)*(ior_n-1.)+ior_k*ior_k+4.*ior_n*pow(1.-cos_theta,5.))\n\t\t                 /((ior_n+1.)*(ior_n+1.)+ior_k*ior_k);\n        //</http://sirkan.iit.bme.hu/~szirmay/fresnel.pdf p.3 above fig 5>\n    }\n    else\n    {\n        //Fresnel Schlick Dielectric formula\n        vec3 F0 = abs ((1.0 - ior_n) / (1.0 + ior_n));\n  \t\tF = F0 + (1.-F0) * pow( 1. - VdotH, 5.);\n    }\n    //</Fresnel>\n    \n    //<Geometric term>\n    //<Source : Real Shading in Unreal Engine 4 2013 Siggraph Presentation>\n    //https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59\n    float k = bIBL?(roughness*roughness/2.0):(roughness+1.)*(roughness+1.)/8.; //Schlick model (IBL) : Disney's modification to reduce hotness (ABL)\n    float Gl = max(NdotL,0.)/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    //</Real Shading in Unreal Engine 4 2013 Siggraph Presentations>\n    //</Geometric term>\n    \n    //Two flavors of the PBR equation seen pretty much everywhere (IBL/ABL).\n    //Note : Distribution (D) is externalized from IBL version, see source link.\n    //Personal addition : This parameter softens up the transition at grazing angles (otherwise too sharp IMHO).\n    float softTr = 0.1; // Valid range : [0.001-0.25]. Will reduce reflexivity on edges if too high.\n    //Personal addition : This parameter limits the reflexivity loss at 90deg viewing angle (black spot in the middle?).\n    float angleLim = 0.15; // Valid range : [0-0.75] (Above 1.0, become very mirror-like and diverges from a physically plausible result)\n    //<Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    if(bIBL)\n        return (F*G*(angleLim+sinT)/(angleLim+1.0) / (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr)); //IBL\n    else\n        return D_ABL*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\t//ABL\n    //<Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n}\n\n//Arbitrary axis rotation (around u, normalized)\nmat3 rotateAround( vec3 u, float t )\n{\n    //From wikipedia\n    float c = cos(t);\n    float s = sin(t);\n    //  _        _   _           _     _                    _ \n    // |_px py pz_| | m11 m21 m31 |   | px*m11+py*m21+pz*m31 |\n    //              | m12 m22 m32 | = | px*m12+py*m22+pz*m32 |\n    //              |_m13 m23 m33_|   |_px*m13+py*m23+pz*m33_|\n    return mat3(  c+u.x*u.x*(1.-c),     u.x*u.y*(1.-c)-u.z*s, u.x*u.z*(1.-c)+u.y*s,\n\t              u.y*u.x*(1.-c)+u.z*s, c+u.y*u.y*(1.-c),     u.y*u.z*(1.-c)-u.x*s,\n\t              u.z*u.x*(1.-c)-u.y*s, u.z*u.y*(1.-c)+u.x*s, c+u.z*u.z*(1.-c) );\n}\n\n#define MOD3 vec3(.1031,.11369,.13787)\nvec2 hash22(vec2 p) //From DaveHoskin's hash without sine\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec3 PBR_jitterSample(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    //Importance sampling section:\n    //<http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    range = atan( roughness*sqrt(e1)/sqrt(1.0-e1) );\n\tfloat phi = 2.0*3.14159*e2;\n\t//<http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    \n    //FIXME : Invalid for surfaces facing up.\n\tvec3 up = vec3(0,1,0); //arbitrary\n\tvec3 tAxis = cross(up,sampleDir);\n\tmat3 m1 = rotateAround(normalize(tAxis),range);\n\tmat3 m2 = rotateAround(normalize(sampleDir), phi);\n        \n\treturn sampleDir*m1*m2;\n}\n\nvec3 PBR_visitSamples(vec3 V, vec3 N, float roughness, bool metallic, vec3 ior_n, vec3 ior_k )\n{\n    vec3 vCenter = reflect(-V,N);\n    \n    //<Randomized Samples>\n    float randomness_range = 0.75; //Cover only the closest 75% of the distribution. Reduces range, but improves stability.\n    float fIdx = 0.0;              //valid range = [0.5-1.0]. Note : it is physically correct at 1.0.\n    const int iter_rdm = 5;\n    const float w_rdm = 1.0/float(iter_rdm);\n    vec3 totalRandom = vec3(0.0);\n    for(int i=0; i < iter_rdm; ++i)\n    {\n        //Random jitter\n        //There is a scaling issue here, where scaling impacts noise precision.\n        vec2 jitter = hash22(fIdx*100.0+vCenter.xy*100.0+fract(iTime)*0.001);\n    \tfloat range = 0.;    \n        vec3 sampleDir = PBR_jitterSample(vCenter, roughness, jitter.x*randomness_range, jitter.y, range);\n        vec3 sampleColor = PBR_HDRCubemap(sampleDir,range/0.29,true);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*w_rdm;\n    \ttotalRandom += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    //</Randomized Samples>\n    \n    //<Fixed Samples : less physically correct, but more stable>\n    //https://www.shadertoy.com/view/4dt3Dj\n    fIdx = 0.0;\n    const int iter_fixed = 15;\n    const float w_fixed = 1.0/float(iter_fixed);\n    vec3 totalFixed = vec3(0.0);\n    for(int i=0; i < iter_fixed; ++i)\n    {\n        //Stable pseudo-random jitter (to improve stability with low sample count)\n        //Beware here! second component controls the sampling pattern \"swirl\", and it must be choosen \n        //             so that samples do not align by doing complete 360deg cycles at each iteration.\n        vec2 jitter = vec2( clamp(w_fixed*fIdx,0.0,0.50),\n                            fract(w_fixed*fIdx*1.25)+3.14*fIdx);\n        float range = 0.;\n        vec3 sampleDir = PBR_jitterSample(vCenter, roughness, jitter.x, jitter.y, range);\n        vec3 sampleColor = PBR_HDRCubemap(sampleDir,range/0.29,true);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic,true)*w_fixed;\n        totalFixed += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    //</Fixed Samples>\n    \n    return (totalRandom*float(iter_rdm)+totalFixed*float(iter_fixed))/(float(iter_rdm)+float(iter_fixed));\n}\n\nfloat RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )\n{\n    //(45deg: sin/cos = 1:1)\n    float minAperture = 1.0; \n    float t = 0.0;\n    float dist = MAX_DIST;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 p = o+L*t; //Sample position = ray origin + ray direction * travel distance\n        float dist = DF_composition( p, false ).d;\n        float curAperture = dist/t; //Aperture ~= cone angle tangent (sin=dist/cos=travelDist)\n        minAperture = min(minAperture,curAperture);\n        \n        t += dist;\n    }\n    \n    //The cone width controls shadow transition. The narrower, the sharper the shadow.\n    return saturate(minAperture/coneWidth); //Range = [0.0-1.0] : 0 = shadow, 1 = fully lit.\n}\n\nfloat RAYMARCH_DFAO( vec3 o, vec3 N, float isoSurfaceValue)\n{\n    //Variation of : https://www.shadertoy.com/view/Xds3zN\n    //Interesting reads:\n    //https://docs.unrealengine.com/latest/INT/Engine/Rendering/LightingAndShadows/DistanceFieldAmbientOcclusion/index.html#howdoesitwork?\n    //Implementation notes:\n    //-Doubling step size at each iteration\n    //-Allowing negative distance field values to contribute\n    //-Not reducing effect with distance (specific to this application)\n    float MaxOcclusion = 0.0;\n    float TotalOcclusion = 0.0;\n    const int nSAMPLES = 4;\n    float stepSize = 0.11/float(nSAMPLES);\n    for( int i=0; i<nSAMPLES; i++ )\n    {\n        float t = 0.01 + stepSize;\n        //Double distance each iteration (only valid for small sample count, e.g. 4)\n        stepSize = stepSize*2.0;\n        float dist = DF_composition( o+N*t, true ).d-isoSurfaceValue;\n        //Occlusion factor inferred from the difference between the \n        //distance covered along the ray, and the distance from other surrounding geometry.\n        float occlusion = saturate(t-dist);\n        TotalOcclusion += occlusion;//Not reducing contribution on each iteration\n        MaxOcclusion += t;\n    }\n    \n    return saturate(1.0-TotalOcclusion/(MaxOcclusion));\n}\n\nfloat MAT_processRoughness(float fRoughness, vec3 matColor, TraceData traceData, vec3 pos, vec3 N)\n{\n    if(traceData.matID==MATERIALID_WATER)\n    {\n        float fClamp = iMouse.y/iResolution.x;\n    \tfRoughness = clamp((fRoughness)*1.0,fClamp,3.0)-fClamp; \n    \tfRoughness *= 0.25;\n        //distance fade\n        fRoughness *= (1.0-saturate(traceData.rayLen/95.0));\n        fRoughness += 0.15*saturate(traceData.rayLen/25.0);\n    }\n    else if(traceData.matID==MATERIALID_STONE)\n    {\n        float heightFromWater = pos.y-(fMinWaterHeight+fWaterVariation);\n        float texRoughness = 0.05+smoothstep(0.3,0.6,matColor.g);\n        float inRoughness = smoothstep(0.3,0.7,fRoughness);\n\t\tfRoughness = (texRoughness+inRoughness)*0.5;\n        \n        fRoughness += 0.3*heightFromWater;\n        fRoughness *= (0.2+0.8*inRoughness);\n        fRoughness -= 0.6*(1.0-dot(N,vec3(0,1,0)));\n    }\n    return fRoughness;\n}\n\nvec3 MAT_getRoughnessPos(const int matID, vec3 surfacePos )\n{\n    vec3 lookupPos = vec3(0);\n    if(matID==MATERIALID_WATER)\n    {\n        lookupPos = vec3(surfacePos.xz*0.35-0.2*iTime,0).xzy;\n    }\n    else if(matID==MATERIALID_STONE)\n    {\n        lookupPos = vec3(surfacePos.xyz*0.2);\n    }\n    return lookupPos;\n}\n\n//::MAT_apply\nvec4 MAT_apply(vec3 pos, TraceData traceData)\n{\n    //Water reflection case : replace the material\n    if(traceData.bReflect && traceData.fReflectDist < 1000.0)\n    {\n        vec3 dReflect = reflect(traceData.rayDir,traceData.normal);\n        traceData.rayLen = traceData.fReflectDist;\n        traceData.normal = traceData.vReflectNormal;\n        pos  = pos+traceData.fReflectDist*dReflect;\n        traceData.matID = MATERIALID_STONE;\n    }\n    \n    //L should bind with light position\n    vec3 L = normalize(vec3(0,0.2,1));\n    vec3 N = traceData.normal;\n    vec3 V = normalize(-traceData.rayDir);\n    float dfss = (traceData.matID==MATERIALID_SKY)?1.0:RAYMARCH_DFSS( pos+L*0.01, L, 0.2);\n    \n    //<Material parameters>\n    vec3 vDiff = vec3(0);\n    float dfao = 1.0;\n    vec3 matColor = vec3(1);\n    float LI = 1.0;\n\tif(traceData.matID==MATERIALID_WATER)\n    {\n        LI = 0.5;\n        //distance stabilization\n        N = mix(N,vec3(0,1,0),0.9*saturate(traceData.rayLen/25.0));\n    }\n    else if(traceData.matID==MATERIALID_STONE)\n    {\n        LI = 2.0;\n        matColor = SAMPLER_triplanarChannel1(pos*0.5,traceData.normal);\n            \n        vDiff = matColor*MAT_integrateHemisphere(N);\n        dfao = RAYMARCH_DFAO( pos, N, 0.02);\n        vDiff *= (0.5+0.25*dfss);\n    }\n    //<Material parameters>\n    \n    vec3 roughness_lookupPos = MAT_getRoughnessPos(traceData.matID,pos);\n    vec3 tex = NOISE_roughnessMap(roughness_lookupPos*306., traceData.rayLen);\n    float fRoughness = (tex.x+tex.y+tex.z)/3.0;\n    fRoughness = MAT_processRoughness(fRoughness, matColor, traceData, pos, N);\n    \n    //Single light & Image based lighting\n    vec3 I_L = PBR_Equation(V, L, N, fRoughness*0.5, vec3(1)*F_DIELECTRIC_WATER, vec3(0), false, false);\n    vec3 I_IBL = PBR_visitSamples(V, N, fRoughness, false, vec3(1)*F_DIELECTRIC_WATER, vec3(0));\n    \n    if(traceData.matID==MATERIALID_STONE)\n    {\n        if(traceData.bReflect)\n        {\n            LI *= 0.05;\n\t\t}\n    }\n    \n    vec3 col = matColor*dfss*(LColor*I_L)\n            +  LI*matColor*I_IBL*(0.5+0.5*dfss) //Remove half the Image-Based lighting in the shadow.\n            +  vDiff;\n    col *= dfao;\n    \n    if(traceData.matID==MATERIALID_STONE)\n    {\n        if(traceData.bReflect)\n        {\n            col *= 0.6;\n\t\t}\n    }\n    \n    if(traceData.matID==MATERIALID_WATER)\n    {\n        //<normal-based edge antialiasing>\n        //When the normal direction \n        vec3 backgroundColor = PBR_HDRCubemap(traceData.rayDir, 0.0,true).xyz;\n        float aaAmount = 0.02;\n        if(dot(N,traceData.rayDir) > -aaAmount)\n        {\n            float smoothFactor = 1.0-clamp(-dot(N,traceData.rayDir)/(aaAmount), 0.0, 1.0);\n            col.rgb = mix(col.rgb, backgroundColor, smoothFactor);\n        }\n        //</normal-based edge antialiasing>\n    }\n    else if(traceData.matID==MATERIALID_SKY)\n    {\n        return PBR_HDRCubemap(traceData.rayDir, 0.0,true).xyzz;\n    }\n    \n    return vec4(col,1);\n}\n\nTraceData TRACE_getFront(const in TraceData tDataA, const in TraceData tDataB)\n{\n    if(tDataA.rayLen<tDataB.rayLen)\n    {\n        return tDataA;\n    }\n    else\n    {\n        return tDataB;\n    }\n}\n\n//o=origin, d = direction\n//::TRACE_geometry\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    TraceData skyInfo;\n    skyInfo.rayLen  = MAX_DIST-1.0;\n    skyInfo.rayDir  = d;\n\tskyInfo.geoDist = 0.0;\n\tskyInfo.normal  = -d; //Shere center\n\tskyInfo.matID   = MATERIALID_SKY;\n    \n    TraceData waterInfo;\n    vec3 pWater = WATER_intersec(o, d, iTime);\n    waterInfo.rayDir  = d;\n    waterInfo.rayLen  = length(pWater-o);\n    waterInfo.geoDist = 0.0;//waterHeight(;\n    waterInfo.normal  = WATER_normal(pWater,iTime);\n    waterInfo.matID   = MATERIALID_WATER;\n    waterInfo.bReflect = false;\n\n    vec3 dReflect = reflect(waterInfo.rayDir,waterInfo.normal);\n\trayMarchOut rmOut = RAYMARCH_reflect( o, d, waterInfo.rayLen, dReflect );\n    vec3 dfHitPosition = rmOut.hitPos;\n\tvec3 DF_normal = normalize(DF_gradient(dfHitPosition));\n    \n    if(rmOut.bReflect)\n    {\n        waterInfo.bReflect = true;\n        waterInfo.fReflectDist = rmOut.rayLen;\n        waterInfo.vReflectNormal = DF_normal;\n        return TRACE_getFront(skyInfo,waterInfo);\n    }\n    else\n    {\n        TraceData terrainInfo;\n    \tterrainInfo.rayDir     = d;\n    \tterrainInfo.rayLen     = rmOut.rayLen;\n    \tterrainInfo.geoDist    = rmOut.geoDist;\n    \tterrainInfo.normal     = normalize(DF_gradient(dfHitPosition));\n    \tterrainInfo.matID = MATERIALID_STONE;\n        return TRACE_getFront(TRACE_getFront(skyInfo,terrainInfo),waterInfo);\n    }\n}\n\nvec3 TRACE_debug(TraceData traceData, int elemID)\n{\n    if(elemID==DEBUG_RAYLEN)  return vec3(log(traceData.rayLen)*0.1);\n    if(elemID==DEBUG_GEODIST) return vec3(traceData.geoDist);\n    if(elemID==DEBUG_NORMAL)  return traceData.normal;\n    if(elemID==DEBUG_MATID)   return traceData.matID==MATERIALID_WATER?vec3(1):\n                                     vec3(traceData.matID==MATERIALID_FLOOR?1:0,\n                                          traceData.matID==MATERIALID_B?1:0,\n                                          traceData.matID==MATERIALID_SKY?1:0);\n    return vec3(0);\n}\n\nvec3 POST_ProcessFX(vec3 c, vec2 uv)\n{\n    //Vignetting\n    float lensRadius = 0.65;\n    uv /= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    float cos4 = cos2*cos2;\n    c *= cos4;\n    \n    //Gamma\n    c = pow(c,vec3(0.4545));\n    return c;\n}\n\n//::main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    \n    //[Insert supersampling logic here]\n    Cam cam = CAM_animate(uv,iTime);\n    vec3 d = CAM_getRay(cam,uv);\n    \n    vec3 c = vec3(0);\n    TraceData geometryTraceData = TRACE_geometry(cam.o, d);\n    //fragColor.rgb = TRACE_debug(geometryTraceData, DEBUG_RAYLEN); return; //OK\n    //fragColor.rgb = TRACE_debug(geometryTraceData, DEBUG_GEODIST); return; //OK\n    //fragColor.rgb = TRACE_debug(geometryTraceData, DEBUG_NORMAL); return; //OK\n    //fragColor.rgb = TRACE_debug(geometryTraceData, DEBUG_MATID); return; //OK\n    \n    vec3 ptGeo = cam.o+d*geometryTraceData.rayLen;\n    c = MAT_apply(ptGeo,geometryTraceData).rgb;\n    \n    //No supersampling required for most PostProcessFX.\n    c = POST_ProcessFX(c,uv);\n    \n    fragColor = vec4(c,1.0);\n}\n\n//----------------------\n// Camera\n//::CAM\nCam CAM_lookAt(vec3 at, float fPitch, float dst, float rot) \n{ \n    Cam cam;\n    cam.D = vec3(cos(rot)*cos(fPitch),sin(fPitch),sin(rot)*cos(fPitch));\n    cam.U = vec3(-sin(fPitch)*cos(rot),cos(fPitch),-sin(fPitch)*sin(rot));\n    cam.R = cross(cam.D,cam.U); cam.o = at-cam.D*dst;\n    return cam;\n}\nCam CAM_mouseLookAt(vec3 at, float dst)\n{\n    vec2 res = iResolution.xy; vec2 spdXY = vec2(15.1416,4.0);\n    float fMvtX = (iMouse.x/res.x)-0.535;\n    if(fMvtX>0.3) dst *= (1.0+(fMvtX-0.3)/0.03);\n    else if(fMvtX<-0.3) dst *= (1.0-(fMvtX+0.3)/(-0.2));\n\t//fMvtX += iTime*0.0250;//Auto turn\n    return CAM_lookAt(at,spdXY.y*((/*iMouse.y*/0.40)-0.5),dst,spdXY.x*fMvtX);\n}\nCam CAM_animate(vec2 uv, float fTime)\n{\n    float targetDistance = 12.5;\n    vec3 cam_tgt = vec3(-0.2,2,-0.1);\n    Cam cam = CAM_lookAt(cam_tgt, -0.05, targetDistance, 1.3+0.1*sin(iTime*0.1));\n    if(iMouse.z > 0.0) //Mouse button down : user control\n    {\n    \tcam = CAM_mouseLookAt(cam_tgt, targetDistance);\n    }\n    return cam;\n}\n\nvec3 CAM_getRay(Cam cam,vec2 uv)\n{\n    uv *= 1.6;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\nvec3 SAMPLER_triplanarChannel1(vec3 p, vec3 n)\n{\n    //Idea from http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\n    //Figure 1-23 Triplanar Texturing\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return ( abs(n.x)*texture(iChannel1,p.zy).xyz\n            +abs(n.y)*texture(iChannel1,p.zx).xyz\n            +abs(n.z)*texture(iChannel1,p.xy).xyz)/fTotal;\n}\nfloat SAMPLER_trilinear(vec3 p)\n{\n    const float TEXTURE_RES = 256.0; //Noise texture resolution\n    p *= TEXTURE_RES;   //Computation in pixel space (1 unit = 1 pixel)\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    vec3 t = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)\n    t = (3.0 - 2.0 * t) * t * t; //interpolant easing function : linear->cubic\n    vec2 layer_translation = -pixCoord.y*vec2(37.0,17.0)/TEXTURE_RES; //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels -> this is no keypad smashing, but the actual translation embedded in the noise texture).\n    vec2 layer1_layer2 = texture(iChannel0,layer_translation+(pixCoord.xz+t.xz+0.5)/TEXTURE_RES,-100.0).xy; //Note : +0.5 to fall right on pixel center\n    return mix( layer1_layer2.x, layer1_layer2.y, t.y ); //Layer interpolation (trilinear/volumetric)\n}\nvec4 SAMPLER_trilinearWithDerivative(vec3 p)\n{\n    //To be honest, this is rather complex for the benefit it provides. Could have used something much simpler\n    //for the roughness texture.\n\n    //See : https://iquilezles.org/articles/morenoise\n\tconst float TEXTURE_RES = 256.0; //Noise texture resolution\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels)\n    //(37x17)-> this value is the actual translation embedded in the noise texture, can't get around it.\n\t//Note : shift is different from g to b layer (but it also works)\n    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)/TEXTURE_RES;\n    vec2 c1 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)/TEXTURE_RES,-100.0).rg;\n    vec2 c2 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)/TEXTURE_RES,-100.0).rg; //+x\n    vec2 c3 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)/TEXTURE_RES,-100.0).rg; //+z\n    vec2 c4 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)/TEXTURE_RES,-100.0).rg; //+x+z\n    vec3 x = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)\n    vec3 x2 = x*x;\n    vec3 t = (6.*x2-15.0*x+10.)*x*x2; //Ease function : 6x^5-15x^4+10^3\n        \n    //Lower quad corners\n    float a = c1.x; //(x+0,y+0,z+0)\n    float b = c2.x; //(x+1,y+0,z+0)\n    float c = c3.x; //(x+0,y+1,z+0)\n    float d = c4.x; //(x+1,y+1,z+0)\n    //Upper quad corners\n    float e = c1.y; //(x+0,y+0,z+1)\n    float f = c2.y; //(x+1,y+0,z+1)\n    float g = c3.y; //(x+0,y+1,z+1)\n    float h = c4.y; //(x+1,y+1,z+1)\n    \n    //Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.\n    float za = ((a+(b-a)*t.x)*(1.-t.y)\n               +(c+(d-c)*t.x)*(   t.y));\n    float zb = ((e+(f-e)*t.x)*(1.-t.y)\n               +(g+(h-g)*t.x)*(   t.y));\n    float value = (1.-t.z)*za+t.z*zb;\n    \n    //Derivative scaling (depends on texture lookup).\n    //There is definitely a pattern here.\n\t//This could be factorized/optimized but I fear it would make it cryptic.\n    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)\n               +((f-e)+t.y*(e-f-g+h))*(   t.z);\n    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)\n               +((g-e)+t.x*(e-f-g+h))*(   t.z);\n    float sz =  zb-za;\n    \n    //Ease-in ease-out derivative : (6x^5-2x^3)' = 6x-6x^2\n    vec3 d_xyz = (30.*x2-60.*x+30.)*x2;\n    \n    return vec4(value,\n\t            d_xyz.x*sx, //Derivative x scaling\n                d_xyz.y*sy,\n                d_xyz.z*sz);\n}\n//:NOISE_roughnessMap\nvec3 NOISE_roughnessMap(vec3 p, float rayLen)\n{\n    float f = iTime;\n    const mat3 R1  = mat3(0.500, 0.000, -.866,\n\t                     0.000, 1.000, 0.000,\n                          .866, 0.000, 0.500);\n    const mat3 R2  = mat3(1.000, 0.000, 0.000,\n\t                      0.000, 0.500, -.866,\n                          0.000,  .866, 0.500);\n    const mat3 R = R1*R2;\n    p *= BUMP_MAP_UV_SCALE;\n    p = R1*p;\n    vec4 v1 = SAMPLER_trilinearWithDerivative(p);\n    p = R1*p*2.021;\n    vec4 v2 = SAMPLER_trilinearWithDerivative(p);\n    p = R1*p*2.021+1.204*v1.xyz;\n    vec4 v3 = SAMPLER_trilinearWithDerivative(p);\n    p = R1*p*2.021+0.704*v2.xyz;\n    vec4 v4 = SAMPLER_trilinearWithDerivative(p);\n    \n    return (v1+0.5*(v2+0.25)\n\t          +0.4*(v3+0.25)\n\t          +0.6*(v4+0.25)).yzw;\n}\n\nfloat DF_sphere( vec3 p, float size )\n{\n\treturn length(p)-size;    \n}\n\nfloat DF_cube( vec3 p, vec3 size )\n{\n    vec3 dEdge = abs(p)-size; //distance to cube edge, along each axis\n    float internalDist = max(dEdge.x,max(dEdge.y,dEdge.z)); \n    float externalDist = length(max(dEdge,vec3(0))); \n    return externalDist+min(internalDist,0.0);\n}\n\nfloat DF_merge( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat DF_smoothMerge( float d1, float d2, float d3, float k )\n{\n    return -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3))/k;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}