{
    "Shader": {
        "info": {
            "date": "1644503281",
            "description": "SerenityOS tribute\n\nThis fork includes better anti-aliasing at the cost of performance. Increase ANTIALIAS_SIZE for better AA with worse performance.",
            "flags": 0,
            "hasliked": 0,
            "id": "sdsfR8",
            "likes": 2,
            "name": "SerenityOS Intro (Better AA)",
            "published": 3,
            "tags": [
                "sdf",
                "yinyang",
                "serenityos"
            ],
            "usePreview": 0,
            "username": "kleinesFilmroellchen",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "// SerenityOS Ladyball, fragment shader by movAX13h, Feb. 2022\n// thanks to iq for sdCappedTorus and polynomial smooth min\n// thanks to IWBTShyGuy and Shane for support\n\n#define REFLECTION\n#define ANTIALIAS\n#define ANTIALIAS_SIZE 2\n#define ANTIALIAS_POINT_COUNT ((2*ANTIALIAS_SIZE+1) * (2*ANTIALIAS_SIZE+1))\n\n// --\n#define resolution iResolution\n#define mouse iMouse\n\n#define pih 1.5707963267949\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat time;\nvec3 sunPos;\nvec3 sun;\nfloat focus;\nfloat far;\n\nstruct Hit\n{\n\tfloat d;\n\tfloat ref;\n\tfloat spec;\n};\n\n    \nHit scene(vec3 p)\n{\n\tvec3 q = p;\n    \n\tHit h = Hit(1.0e6, 0.1, 0.2);\n    p.zy = rotate(p.zy, 0.7); // tilt\n    p.xy = rotate(p.xy, -3.0*iTime); // spin\n\n\t// yin-yang\n\tfloat a = max(sdCappedTorus(p, vec2(1.0, 0.0), 0.5, 0.4), sdSphere(p, 0.42));    \n    float b = sdSphere(p, 0.4);\n\th.d = smin(a, b, 0.01);\n    \n    // dots\n    float c = sdSphere(p-vec3(0.4, 0.0, 0.0), 0.14);\n    c = min(c, sdSphere(p-vec3(0.21, 0.32, 0.0), 0.1));\n    c = min(c, sdSphere(p-vec3(-0.1, 0.4, 0.0), 0.06));\n    c = max(c, sdSphere(p, 0.43));\n    h.d = smin(h.d, c, 0.01);\n    \n\treturn h;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\n\nvec3 colorize(const vec3 ray, const float spec, const vec3 n, const vec3 dir, const in vec3 lightPos)\n{\n    // determine color based on radius\n    float r = length(ray); // because we know object is at origin\n    vec3 col = vec3(0.0);\n    float red = smoothstep(0.4, 0.41, r)*smoothstep(0.43, 0.416, r);\n    col = mix(col, vec3(0.871,0.047,0.008), red);\n\n\tfloat diffuse = 0.2*max(0.0, dot(n, lightPos));\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = spec*pow(max(0.0, dot(ref, lightPos)), 3.5);\n\treturn (col + diffuse * vec3(0.9) +\tspecular * vec3(1.0));\n}\n\nvec3 tex3D(vec3 dir)\n{\n    return texture(iChannel0, dir).gbr;\n}\n\nvec3 march(in vec2 fragCoord) \n{   \n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) / resolution.y;\n\t\n\tfloat d = 6.0;\n\tfloat t = 1.2*sin(time*0.1+35.0) ;\n\tvec3 cp = vec3(d*cos(t), 0.8+sin(0.2*time), d*sin(t)); // circle center\n    \n\tif (mouse.x > 10.0)\n\t{\n\t\tvec2 mrel = 3.0*(mouse.xy/resolution.xy-0.5);\n\t\td = 8.0;\n        focus = 9.0 + 4.0*mrel.y;\n\t\tcp = vec3(d*cos(-mrel.x*pih), 6.0, d*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t// raymarch scene    \n    for(int i=0; i < 110; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d*0.8;\n\t\tray += dir * h.d*0.8;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist/far);\n\tvec3 n = normal(ray);\n    \n\tcol = colorize(ray, h.spec, n, dir, sun)*m;\n    \n\tif (dist < far && h.d < 0.0001)\n\t{\t\n        #ifdef REFLECTION\n\t\t// MIRROR (from obj to reflected normal direction)\t\t\n\t\tHit h2;\n\t\tdir = reflect(dir, n);\n\t\tvec3 neb = tex3D(dir);\n\t\t\n\t\tvec3 ray2 = ray + dir*0.008;\n\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 35; i++) \n\t\t{\n\t\t\th2 = scene(ray2 + dir*dist);\n\t\t\tdist += h2.d;\n\t\t\tif (h2.d < 0.001) break;\n\t\t}\n\n\t\tif (dist > far) col += h.ref*neb;\n\t\telse col += h.ref*colorize(ray2, h2.spec, normal(ray2+dir*dist), dir, sun)*(1.0 - dist/far);\n\t\t#endif\n\t}\n\telse col = tex3D(dir);\n    \n    return col;\n}   \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{    \n    time = iTime + 7.0;\n\tsunPos = vec3(10.0, 15.0, -10.0);\n\tsun = normalize(sunPos);\n\tfocus = 9.0+2.0*cos(0.35*time);\n\tfar = 30.0;    \n    \n    // simple anti-aliasing\n    #ifdef ANTIALIAS\n    vec3 col = vec3(0.0);\n    for(int i = -ANTIALIAS_SIZE; i <= ANTIALIAS_SIZE; ++i)\n    {\n        for(int j = -ANTIALIAS_SIZE; j <= ANTIALIAS_SIZE; ++j)\n        {\n            col += march(fragCoord+vec2(i,j)/float(ANTIALIAS_SIZE));\n        }\n    }\n    col /= float(ANTIALIAS_POINT_COUNT);\n    #else\n    vec3 col = march(fragCoord);\n    #endif    \n      \n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.7; \n\tcol = pow(col, vec3(1.0 / 2.2)); // gamma\t\n\t\n\tfragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}