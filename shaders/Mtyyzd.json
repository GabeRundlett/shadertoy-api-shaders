{
    "Shader": {
        "info": {
            "date": "1537384724",
            "description": "It's a tutorial about how to render into \"Stucture Buffer\". Also we call it gemeotry buffer.\nStore PBR textures,like Albedo,Normal,Specular,Roughness,Depth map...etc!\nYep!You can do deferred shading and postprocessing!\nDrag your mouse and hang out.:D",
            "flags": 32,
            "hasliked": 0,
            "id": "Mtyyzd",
            "likes": 25,
            "name": "Struct Buffer #Alpha",
            "published": 3,
            "tags": [
                "filter",
                "pbr",
                "idea",
                "structbuffer"
            ],
            "usePreview": 1,
            "username": "834144373",
            "viewed": 1520
        },
        "renderpass": [
            {
                "code": "/*\nAbout Stucture Buffer:\n\tIt's a tutorial about how to render into \"Stucture Buffer\".\n\tAnd it just like you do in CUDA. \n\tAlso we call it gemeotry buffer.\n\n\tBufferA: Compress Struct Buffer\n\t\tis Rendering Four Images,ImgA/ImgB/ImgC/ImgD,compress into xyz channels,\n\t\tand a vec2(16bits,16bits) compress into w channels.\n\tImage: Decompress Struct Buffer\n\t\tis Decompress these Images and another extra information.\n\nWhat can you do now:\n    1.Store PBR textures,like Albedo,Normal,Specular,Roughness,Depth map...etc!\n    2.Yep!You can really do deferred shading and postprocessing!\n\nOther:\n\tDrag your mouse and hang out.:D\n\t\n\thum...It's just alpha version,so you can imagine some varietal version.\n*/\nstruct StructBuffer{\n    vec3 imgA;\n    vec3 imgB;\n    vec3 imgC;\n    vec3 imgD;\n    mediump vec2 other;\n};\n\nStructBuffer GetStructBuffer(vec4 data){\n\tStructBuffer Buffer;\n    uvec4 stream = floatBitsToUint(data);\n    vec4 imgAllData[3];\n    for(int i=0;i<3;i++){\n    \timgAllData[i] = vec4((uvec4(stream[i])>>ivec4(24,16,8,0))&0xFFu)/255.;\n    }\n    mat4x3 imgStream = mat4x3(imgAllData[0],imgAllData[1],imgAllData[2]);\n    Buffer.imgA = imgStream[0];\n    Buffer.imgB = imgStream[1];\n    Buffer.imgC = imgStream[2];\n    Buffer.imgD = imgStream[3];\n    Buffer.other = unpackHalf2x16(stream.w);\n\treturn Buffer;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    ivec2 iU = ivec2(U);\n\tvec4 col = texelFetch(iChannel0,iU,0);\n    \n    StructBuffer buffer = GetStructBuffer(col);\n    float id = floor((U.x*1.55-U.y/3.5)/R.x*4.)-1.;\n\tif(id == 0.)\n    \tC.rgb = buffer.imgA; //Albedo Map (Delighting Texture)\n    else if(id == 1.)\n        C.rgb = buffer.imgB; //Normal Map\n    else if(id == 2.)\n\t\tC.rgb = buffer.imgC; //Luminance Map\n    else if(id == 3.)\n        C.rgb = buffer.imgD; //Specular Map\n\telse\n        C.rgb = vec3(0.821);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\nconst ivec2 MOUSE_COORD = ivec2(0);\n\nvec4 GetValue(sampler2D _tex,ivec2 coord){return texelFetch(_tex,coord,0);}\nbool IsCoord(ivec2 iU,ivec2 coord){return all(equal(iU,coord));}\n\nstruct ControlInfo{\n\tvec2 position;\n    bool dataLock;\n};\nControlInfo MouseDrag(out vec2 Store,ivec2 iU,ivec2 coord){\n    #define MouseTex iChannel1\n    #define Scale 32767.\n\tuvec2 data = floatBitsToUint(GetValue(MouseTex,coord).zw);\n\tmediump vec4 MousePos = vec4(unpackSnorm2x16(data.x),unpackSnorm2x16(data.y))*Scale,tmpMousePos = vec4(MousePos.xy,0.,0.);\n    iMouse.z>0. ? tmpMousePos.xy+=tmpMousePos.zw=iMouse.xy-iMouse.zw : tmpMousePos.xy=MousePos.xy+=MousePos.zw;\n    ControlInfo info;\n    info.position = tmpMousePos.xy;\n    info.dataLock = IsCoord(iU,coord);\n    if(info.dataLock)Store=uintBitsToFloat(uvec2(packSnorm2x16(fract(MousePos.xy/Scale)),packSnorm2x16(tmpMousePos.zw/Scale)));\n    return info;\n}\n\n\n//--------------Store Struct Buffer-------------------\nstruct StructBuffer{\n    vec3 imgA;\n    vec3 imgB;\n    vec3 imgC;\n    vec3 imgD;\n    mediump vec2 other;\n};\nvec4 StoreStructBuffer(StructBuffer buffer){\n    mat3x4 stream = mat3x4(buffer.imgA,buffer.imgB,buffer.imgC,buffer.imgD);\n    vec4 store;\n    /*------store.xyz all RGB 8bits images--------*/\n    for(int i=0;i<3;i++){\n    \tuvec4 data = (uvec4(stream[i]*255.+.5)&0xFFu)<<ivec4(24,16,8,0);\n        store[i] = uintBitsToFloat(data.x|data.y|data.z|data.w);\n    }\n    /*-----store.w other 2x16bits float values------*/ \n    store.w = uintBitsToFloat(packHalf2x16(buffer.other));\n    return store;\n}\n//----------------------------------------------------\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    ivec2 iU = ivec2(U);\n    ControlInfo mouseInfo = MouseDrag(C.zw,iU,MOUSE_COORD);\n    if(!mouseInfo.dataLock){\n        StructBuffer Buffer;\n        iU = iU-ivec2(mouseInfo.position);\n        \n        vec3 Texcolor = TexelFetch_Mirror(iChannel0,iU,0);\n        vec3 Luminance = vec3(GetLuminance(Texcolor));\n        \t\t\n        Buffer.imgA = Texcolor + (1.- Luminance)/6.;\n        Buffer.imgB = FastNormalFilter(iChannel0,iU,0.55)/2.+0.5;\n    \tBuffer.imgC = Luminance;\n        Buffer.imgD = smoothstep(1.,0.,Luminance*1.6);\n        Buffer.other = U/R;\n        C = StoreStructBuffer(Buffer);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n//-------------------------YCoCg----------------------------\n/*\n Y = R/4 + G/2 + B/4\nCo = R/2 - B/2\nCg =-R/4 + G/2 - B/4\n*/\nvec3 RGB2YCoCg(vec3 RGB) {\n\tvec3 YCoCg;\n\tYCoCg.x = RGB.r / 4. + RGB.g / 2. + RGB.b / 4.;\n\tYCoCg.y = RGB.r / 2. - RGB.b / 2.;\n\tYCoCg.z = -RGB.r / 4. + RGB.g / 2. - RGB.b / 4.;\n\treturn YCoCg;\n}\n/*\n R = Y + Co - Cg\n G = Y + Cg\n B = Y - Co - Cg\n*/\nvec3 YCoCg2RGB(vec3 YCoCg) {\n\tvec3 RGB;\n\tRGB.r = YCoCg.x + YCoCg.y - YCoCg.z;\n\tRGB.g = YCoCg.x + YCoCg.z;\n\tRGB.b = YCoCg.x - YCoCg.y - YCoCg.z;\n\treturn RGB;\n}\n//-----------------------Sampler----------------------\nivec2 iU_Mirror(sampler2D _tex,ivec2 iU,int lod){\n\tivec2 size = textureSize(_tex,lod);\n    return abs(((iU/size)&1)*(size-1)-(iU%size));\n}\nvec3 TexelFetch_Mirror(sampler2D _tex,ivec2 iU,int lod){\n    return texelFetch(_tex,iU_Mirror(_tex,abs(iU),0),lod).rgb;\n}\n//------------------------PBR Texture Filters--------------------------\nfloat GetLuminance(vec3 col){\n\treturn dot(col,vec3(0.2126729,0.7151522,0.0721750));\n}\n/*\n\tReference:\n\thttps://web.eecs.umich.edu/~sugih/courses/eecs487/lectures/26-BumpMap+ProcTex.pdf\n\thttps://squircleart.github.io/shading/normal-map-generation.html\n\tTangent Space Normal Maps\n\tNote: I just use forward finite difference enough for fast\n*/\n\n#define GetTextureLuminance(_Tex,iU) GetLuminance(TexelFetch_Mirror(_Tex,iU,0))  \nvec3 FastNormalFilter(sampler2D _tex,ivec2 iU,float strength){\n\tconst ivec2 e = ivec2(1,0);\n    float p00 = GetTextureLuminance(_tex,iU);\n    float p10 = GetTextureLuminance(_tex,iU + e.xy);\n    float p01 = GetTextureLuminance(_tex,iU + e.yx);\n    /* Orgin calculate \n    vec3 ab = vec3(1.,0.,p10-p00);\n    vec3 ac = vec3(0.,1.,p01-p00);\n    vec3 n = cross(ab,ac);\n    n.z *= (1.-strength);\n    return normalize(n);\n\t*/\n\tvec2 dir = p00-vec2(p10,p01);\n    return normalize(vec3(dir,1.-strength));\n}\nvec3 SuperFastNormalFilter(sampler2D _tex,ivec2 iU,float strength){\n    float p00 = GetTextureLuminance(_tex,iU);\n    return normalize(vec3(-dFdx(p00),-dFdy(p00),1.-strength));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}