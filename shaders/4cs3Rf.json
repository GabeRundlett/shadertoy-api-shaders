{
    "Shader": {
        "info": {
            "date": "1703301163",
            "description": "\n\nhexagon test",
            "flags": 0,
            "hasliked": 0,
            "id": "4cs3Rf",
            "likes": 12,
            "name": "  hexagon test",
            "published": 3,
            "tags": [
                "2d",
                "test",
                "hexagon"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 196
        },
        "renderpass": [
            {
                "code": "//por jorge2017a2\n//hexagon test\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n//22-dic_2023\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n\n\n//art_of_code\nconst vec2 D = vec2(1, 1.73); // hexagon diagonal\nconst vec2 R = D * 0.5; // hexagon radius\n\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    uv *= 4.+2.0*sin(iTime);\n    \n       //repetir hexdiz\n     vec2 a = mod(uv, D) - R;\n    vec2 b = mod(uv-R, D) - R;\n    // smarter than compiler, hehe\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    vec2 p=gv;\n\nvec2 pos,med;\nfloat d1;\nvec3 colc;\nvec3 colc1,colc2,colc3;\n\npos=vec2(0.01,0.31); //spalmer, \n//pos=vec2(0.0,0.28);\nmed=vec2(0.71, 0.41)*0.65;\nd1= sdRhombus( p-pos, med);\n\ncolc=vec3(0.5,0.6,0.2);\ncol=DrawFigBorde(colc, col, d1);\n\n\n\npos=vec2(-0.06,0.13);\nmed=vec2(0.71, 0.41)*0.65;\n//rotar\nfloat ang = -60.0 * PI / 180.0;\nvec2 pr = Rotate(p-pos, med, ang);\nfloat d2 = sdRhombus(pr- pos, med);\ncolc=vec3(0.8,0.3,0.2);\ncol=DrawFigBorde(colc, col, d2);\n\n\n//-----------\n pos=vec2(0.077,-0.41);\n med=vec2(0.71, 0.41)*0.69;\n//rotar\nang = 60.0 * PI / 180.0;\npr = Rotate(p-pos, med, ang);\nfloat d3 = sdRhombus(pr- pos, med);\ncolc=vec3(0.2,0.3,0.8);\ncol=DrawFigBorde(colc, col, d3);\n//-----------\n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}