{
    "Shader": {
        "info": {
            "date": "1523195947",
            "description": "A section through an omnitruncated 120-cell.\n\nVariation of [url]https://www.shadertoy.com/view/4sVcDG[/url]\n\nMouse to rotate, up and down arrows to zoom.",
            "flags": 48,
            "hasliked": 0,
            "id": "4sKyWy",
            "likes": 18,
            "name": "Polychoron Section",
            "published": 3,
            "tags": [
                "4d",
                "slice",
                "section",
                "polytope",
                "polychoron"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 700
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2018 by Matthew Arcus\n//\n// Sections of a Polychoron (an omnitruncated 120-cell, I believe).\n//\n// https://en.wikipedia.org/wiki/Runcinated_120-cells\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define NOKEYS (__VERSION__ < 300)\n//#define NOKEYS 1\n\nbool doinvert = false;\n\nconst vec3 Face0Color = vec3(1,0,0);\nconst vec3 Face1Color = vec3(0,1,0);\nconst vec3 Face2Color = vec3(0,0,1);\nconst vec3 Face3Color = vec3(1,1,0);\nconst vec3 Face4Color = vec3(1,0,1);\nconst vec3 Face5Color = vec3(0,1,1);\nconst vec3 EdgeColor = vec3(0.1,0.1,0.1);\n\nconst float PI\t= 3.14159265359;\nconst float TWOPI = 2.0 * PI;\n\n//#define DEBUG\n#if !defined DEBUG\n#define assert(x) 0\n#else\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n// Approximate equality. Used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n#endif\n\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\n// Given mirror planes PQRS, angles are PQ,QR,RP,PS,QS,RS\n// Pick your symmetry group\n#if 0\n// Hypercube\nconst int PQ = 4, QR = 3, RP = 2;\nconst int NFOLDS = 4;\n#elif 0\n// 24-cell\nconst int PQ = 3, QR = 4, RP = 2;\nconst int NFOLDS = 6;\n#else\n// 120- & 600-cell\nconst int PQ = 5, QR = 3, RP = 2;\nconst int NFOLDS = 15;\n#endif\n\nconst int PS = 2, QS = 2, RS = 3;\n\n// Normals to mirror planes\nvec4 planes[4];\n\n// p is the \"tetrahedron point\"\nvec4 tpoint;\n\n// Dihedral angle between two faces with normals n,m\n// Assume the normals are pointing inwards\nfloat dihedral(vec4 n, vec4 m) {\n  return PI - acos(dot(n,m));\n}\n\nfloat dihedral(int x) {\n  return -cos(PI/float(x));\n}\n\nvoid init(vec4 quad) {\n  // Convert parameters to actual dihedral angles\n  float A = dihedral(PQ);\n  float B = dihedral(QR);\n  float C = dihedral(RP);\n  float D = dihedral(PS);\n  float E = dihedral(QS);\n  float F = dihedral(RS);\n  // Now construct 4 mirror planes satisfying those constraints\n  vec4 P = vec4(1,0,0,0);\n  // Q = [a,b,0,0], P.Q = A\n  float a = A;\n  assert(a*a < 1.0);\n  float b = sqrt(1.0 - a*a);\n  vec4 Q = vec4(a,b,0,0);\n  // R = [c,d,e,0]\n  // R.P = C = c\n  // Q.R = B = ac + bd\n  float c = C, d = (B-a*c)/b;\n  assert(c*c + d*d < 1.0);\n  float e = sqrt(1.0 - c*c - d*d);\n  vec4 R = vec4(c,d,e,0);\n#if __VERSION__ >= 300\n  // The easy way\n  mat3 mm = inverse(mat3(P.xyz,Q.xyz,R.xyz));\n  vec3 S3 = vec3(D,E,F)*mm;\n#else\n  vec3 X = cross(Q.xyz,R.xyz);\n  vec3 Y = cross(R.xyz,P.xyz);\n  vec3 Z = cross(P.xyz,Q.xyz);\n\n  // S3 = iX + jY + kZ\n  // P.S = P.S3 = D = iP.X\n  // Q.S = Q.S3 = E = jQ.Y\n  // R.S = R.S3 = F = kR.Z\n  \n  float i = D/dot(P.xyz,X);\n  float j = E/dot(Q.xyz,Y);\n  float k = F/dot(R.xyz,Z);\n\n  vec3 S3 = i*X+j*Y+k*Z;\n#endif\n  // We might have dot(u,u) = 1, in which case the fundamental region\n  // is 3 dimensional and we have an infinite 3d honeycomb. We don't\n  // do honeycombs here so exclude this case.\n  assert(dot(S3,S3) < 1.0-1e-4);\n\n  float w = sqrt(1.0 - dot(S3,S3));\n  vec4 S = vec4(S3,w);\n  assert(eq(dihedral(P,Q),PI/float(PQ)));\n  assert(eq(dihedral(Q,R),PI/float(QR)));\n  assert(eq(dihedral(R,P),PI/float(RP)));\n  assert(eq(dihedral(P,S),PI/float(PS)));\n  assert(eq(dihedral(Q,S),PI/float(QS)));\n  assert(eq(dihedral(R,S),PI/float(RS)));\n\n  planes[0] = P;\n  planes[1] = Q;\n  planes[2] = R;\n  planes[3] = S;\n  \n  mat4 m = inverse(mat4(P,Q,R,S));\n\n  // Now I want to solve the \"quadriplanar\" equations:\n  // given vec4(x,y,z,w), find p with:\n  // p.P = x, p.Q = y, p.R = z, p.S = w\n  tpoint = normalize(quad*m); // Note order!\n}\n\nvec4 fold(vec4 pos) {\n  for (int i = 0; i < NFOLDS; i++) {\n    //pos -= 2.0*min(0.0,dot(pos,P))*P;\n    pos.x = abs(pos.x);\n    for (int j = 1; j < 4; j++) {\n      pos -= 2.0*min(0.0,dot(pos,planes[j]))*planes[j];\n    }\n  }\n  return pos;\n}\n\n// Perpendicular distance from p to segment a in direction r\n// r should be normalized\nfloat segment(vec4 p, vec4 a, vec4 r) {\n  vec4 pa = p - a;\n  float h = min(0.0,dot(pa, r));\n  float d = length(pa - h*r);\n  return d;\n}\n\n// Perpendicular distance from p to plane spanned by R and S\nfloat pdist(vec4 p, vec4 R, vec4 S) {\n  // p = aR + bS + X where R.X = S.X = 0\n  // p.R = aR.R + bS.R\n  // p.S = aR.S + bS.S\n  mat2 m = inverse(mat2(1,dot(R,S),dot(R,S),1));\n  vec2 t = vec2(dot(p,R),dot(p,S))*m;\n  float a = min(0.0,t.x), b = min(0.0,t.y);\n  vec4 X = p - a*R - b*S;\n  return length(X);\n}\n\nvec4 lquat, rquat;\n\nvoid qinit() {\n  vec3 laxis = vec3(1,0,0);\n  vec3 raxis = vec3(0,1,0);\n  float t = iTime + 1.0;\n  float ltheta = 0.1*t;\n  float rtheta = 0.123*t;\n  lquat = normalize(vec4(sin(ltheta)*laxis,cos(ltheta)));\n  rquat = normalize(vec4(sin(rtheta)*raxis,cos(rtheta)));\n}\n\nvec3 transform(in vec3 p);\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec4 iproject(vec3 pos) {\n  float t = iTime;\n  // Slice parallel to z-plane.\n  float k = 0.95*sin(0.1*t);\n  vec4 pos4 = vec4(pos,k);\n  // Arbitrary rotations just look a mess so just return\n  // the slice position. More can be done here I expect.\n  //pos4.xw = rotate(pos4.xw, -0.033*iTime);\n  return pos4;\n  // Two sided quaternion multiplication\n  // All R4 rotations can be constructed from\n  // a quaternion pair.\n  //return qmul(lquat,qmul(pos4,rquat));\n  // One sided quaternion multiplication\n  //return qmul(pos4,rquat);\n}\n\nfloat face(vec4 p, vec4 q, vec4 R, vec4 S) {\n  // Perpendicular distance from p to the plane containing q\n  // and spanned by R and S, ie. points q + aR + bS\n  // Want perp distance to (R,S) plane, then subtract perp distance of q\n  return pdist(p-q,R,S);\n}\n\nfloat scene(vec4 pos4) {\n  float d = 1e8;\n  pos4 = fold(pos4);\n  float fwidth = 0.01;\n  float ewidth = 0.02;\n  float pwidth = 0.04;\n  for (int i = 0; i < 4; i++) {\n    d = min(d,segment(pos4,tpoint,planes[i])-ewidth);\n    for (int j = i+1; j < 4; j++) {\n      d = min(d,face(pos4,tpoint,planes[i],planes[j])-fwidth);\n    }\n  }\n  return d;\n}\n\nvec3 color(vec4 pos4) {\n  float k,d = 1e8;\n  pos4 = fold(pos4);\n  float fwidth = 0.01;\n  float ewidth = 0.02;\n  float pwidth = 0.04;\n  int col = -1;\n  for (int i = 0; i < 4; i++) {\n    d = min(d,segment(pos4,tpoint,planes[i])-ewidth);\n  }\n  int icol = 0;\n  for (int i = 0; i < 4; i++) {\n    for (int j = i+1; j < 4; j++,icol++) {\n      float k = face(pos4,tpoint,planes[i],planes[j])-fwidth;\n      if (k < d) { d = k; col = icol; }\n    }\n  }\n  if (col == 0) return Face0Color;\n  if (col == 1) return Face1Color;\n  if (col == 2) return Face2Color;\n  if (col == 3) return Face3Color;\n  if (col == 4) return Face4Color;\n  if (col == 5) return Face5Color;\n  return EdgeColor;\n}\n\nfloat polyhedron(vec3 pos) {\n  float k = 1.0;\n  if (doinvert) k = dot(pos,pos);\n  pos /= k;\n  vec4 pos4 = iproject(pos);\n  float d = scene(pos4);\n  return k*d;\n}\n\nvec3 getColor(vec3 pos){\n  float k = 1.0;\n  if (doinvert) k = dot(pos,pos);\n  pos /= k;\n  vec4 pos4 = iproject(pos);\n  return 0.8*color(pos4)+0.2;\n}\n\nfloat map(vec3 p) {\n  return polyhedron(p);\n}\n\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                        map(p + e.yxy) - map(p - e.yxy),\n                        map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 20.0;\n  const float precis = 0.001;\n  float h = precis * 2.0;\n  float t = 0.0;\n  float res = -1.0;\n  for(int i = 0; i < 256; i++) {\n      if (h < precis || t > maxd) break;\n      h = map(ro + rd * t);\n      if (doinvert) h *= 0.5;\n      t += h;\n    }\n  if (t < maxd) res = t;\n  return res;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  p.yz = rotate(p.yz,iTime * 0.125);\n  p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_X = 88;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#if NOKEYS\nbool keypress(int code) {\n  return false;\n}\n\nint keycount(int key) {\n  return 0;\n}\n#else\nbool keypress(int code) {\n    return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  //if (NOKEYS == 0) doinvert = keypress(CHAR_I);\n\n  init(vec4(1));\n  qinit();\n  \n  vec2 p = fragCoord.xy / iResolution.xy;\n  // Now both coords are in (0,1)\n  p = 2.0*p-1.0;\n  p *= iResolution.xy/iResolution.y;\n  vec3 col = vec3(0.3 + p.y * 0.1);\n  vec3 ro = vec3(0.0, 0.0, -2.0);\n  vec3 rd = vec3(p, 2.0);\n  vec3 li = vec3(0.5, 1.0, -3);\n  ro.z *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n#if 1\n  ro = transform(ro);\n  rd = transform(rd);\n  li = transform(li);\n#endif\n  rd = normalize(rd);\n  li = normalize(li);\n  float t = march(ro, rd);\n  if (t > 0.0) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col = getColor(pos) * diffuse;\n    col = pow(col, vec3(0.4545));\n  }\n#if defined DEBUG\n  if (alert) col = vec3(1,0,0);\n#endif\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}