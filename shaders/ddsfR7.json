{
    "Shader": {
        "info": {
            "date": "1688588766",
            "description": "With the recent influx of posts I wanted to try myself at some shaders as well, this was the first thing I could come up with.\n\nChanges:\nAdded some noise to the SDFs & introduced a slow color gradient with complementary colors",
            "flags": 0,
            "hasliked": 0,
            "id": "ddsfR7",
            "likes": 11,
            "name": "Magic Sigil",
            "published": 3,
            "tags": [
                "wip",
                "glow",
                "magic",
                "sigil"
            ],
            "usePreview": 0,
            "username": "shlynz",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926536\n#define LINE_INTENSITY .5\n#define GLOW_INTENSITY 1.1\n#define COLOR_CHANGE_SPEED .1\n\n/* TODOs:\n * - implement more shapes (tri-, penta-, hexa-, octagon)\n * - reduce brightness blow-out of bright colors\n */\n\nfloat noise21(vec2 p){\n    return fract(sin(p.x*100.+p.y*8943.)*5647.);\n}\n\nfloat smoothNoise(vec2 uv){\n    vec2 localUv = smoothstep(.0, 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bottomLeft = noise21(id);\n    float bottomRight = noise21(id+vec2(1.,.0));\n    float bottom = mix(bottomLeft, bottomRight, localUv.x);\n\n    float topLeft = noise21(id+vec2(.0,1.));\n    float topRight = noise21(id+vec2(1.,1.));\n    float top = mix(topLeft, topRight, localUv.x);\n\n    return mix(bottom, top, localUv.y);\n}\n\nfloat smoothNoiseLayers(vec2 uv, float amountOfLayers){\n    float result = .0;\n    float sumOfAmplitudes = .0;\n    float frequency = 4.;\n    float amplitude = 1.;\n    for(float i = .0; i < amountOfLayers; i++){\n        result += smoothNoise(uv*frequency)*amplitude;\n        sumOfAmplitudes += amplitude;\n        frequency *= 2.;\n        amplitude /= 2.;\n    }\n    return result/sumOfAmplitudes;\n}\n\nvec2 rotateUv(vec2 uv, float rotation){\n    vec2 cosVal = uv * cos(rotation);\n    vec2 sinVal = uv * sin(rotation);\n    return vec2(cosVal.x +sinVal.y, cosVal.y -sinVal.x);\n}\n\nvec2 remapRotateUv(vec2 uv, vec2 newOrigin, float rotation){\n    vec2 newPoint = rotateUv(newOrigin, rotation);\n    vec2 movingUv = uv -newPoint;\n    return movingUv;\n}\n\nfloat glowyOutline(float sdfValue, vec2 point){\n    float noiseOffset = .5-smoothNoiseLayers(point +(iTime *.2), 5.);\n    sdfValue += noiseOffset * .02;\n    noiseOffset *= .1;\n    return pow(.01 *(LINE_INTENSITY +noiseOffset) /abs(sdfValue), 1. /(GLOW_INTENSITY +noiseOffset));\n}\n\nvec3 runeCircle(vec2 point, float size, vec3 color){\n    float sdf = length(point) -size;\n    return color *glowyOutline(sdf, point);\n}\n\nvec3 runeSquare(vec2 point, float size, vec3 color){\n    vec2 dist = abs(point) -vec2(size);\n    float outerDistance = length(max(dist, .0));\n    float innerDistance = min(max(dist.x, dist.y), .0);\n    float sdf = outerDistance +innerDistance;\n    return color *glowyOutline(sdf, point);\n}\n\nvec3 getColor(){\n    return .5 +.5 *cos(iTime *COLOR_CHANGE_SPEED +vec3(0, 2, 4));\n}\n\nvec3 getComplementaryColor(){\n    vec3 color = getColor();\n    float minVal = min(color.r, min(color.g, color.b));\n    float maxVal = max(color.r, max(color.g, color.b));\n    return vec3(maxVal - minVal)-color;\n}\n\nvec3 glowySeal(vec2 uv){\n    float piFourth = PI /4.;\n    \n    float randomBrightnessReduction = .9 +smoothNoiseLayers(uv +iTime, 5.) *.1;\n    vec3 col = getColor() * randomBrightnessReduction;\n    vec3 inverseCol = getComplementaryColor() * randomBrightnessReduction;\n    \n    vec3 finalColor = vec3(.0);\n    finalColor += runeSquare(rotateUv(uv, iTime), .6, col);           // outer square\n    finalColor += runeSquare(rotateUv(uv, iTime +piFourth), .6, col); // outer square (offset)\n    finalColor += runeSquare(rotateUv(uv, -iTime), .35, inverseCol);  // inner square\n    finalColor += runeCircle(uv, .7, col);                            // outer circle\n    finalColor += runeCircle(uv, .42, inverseCol);                    // inner circle\n    for(float i = .0; i < 8.; i++){                                   // small circles on the outside\n        finalColor += runeCircle(remapRotateUv(uv, vec2(.6), -iTime -piFourth *i), .15, col);\n    }\n                    \n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy *2. -1.;\n    uv.x *= iResolution.x /iResolution.y;\n    fragColor = vec4(glowySeal(uv), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}