{
    "Shader": {
        "info": {
            "date": "1464607164",
            "description": "Emulating a Voronoi pattern in under a tweet.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdKXDD",
            "likes": 78,
            "name": "One Tweet Cellular Pattern",
            "published": 3,
            "tags": [
                "voronoi",
                "code",
                "cellular",
                "minimal",
                "tweet",
                "golf",
                "novelty"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 3275
        },
        "renderpass": [
            {
                "code": "/*\n\n\tOne Tweet Cellular Pattern\n\t--------------------------\n\n\tEmulating a Voronoi pattern in under a tweet... or if I were to \n    oversell it a bit, the world's smallest Voronoi algorithm. :) \n    Thanks to Coyote, it's now resolution independent, plus there's \n    movement. :)\n\n\tThe pattern is pretty convincing, all things considered. Note \n    that there are no hash calls, no loops, etc. Bypassing hash calls,\n    loops, and so forth, minimizes instruction count considerably,\n    which makes things extremely fast and efficient, especially when \n    translating to the 3D environment.\n\n\tConceptually speaking, I think this is about as minimal as it \n    gets... Having said that, it wouldn't surprise me if some crazy \n    coder on Shadertoy dreams up a better way. :)\n\n    \n    Related Example:\n    \n\t// 3D Practical usage. More than one tweet. :)\n\tCellular Lattice - Shane\n\thttps://www.shadertoy.com/view/XsKXRh\n\n*/\n\n// Coyote got it down to 124 chars, and with movement, but I'm wasting \n// some of it on resolution independency for better thumbnails. :)\n\n// Coyote has slimmed it down even further, and managed to initiate \"o\" \n// in a more reliable way. If it's not quite readable, look at the two \n// versions below.\n\n#define F o = min(o, length(fract(p *= mat2(7, -5, 5, 7)*.1) - .5)/.6)\nvoid mainImage(out vec4 o, vec2 p){    \n    \n    p = p/iResolution.y*7. + (o = iDate).w;\n    \n    F; F; F;\n}\n\n// The original is below, if the following is too esoteric.\n\n/*\n// Wrappable, repeat distance metric.\n#define f length(fract(p *= mat2(7, -5, 5, 7)*.1) - .5)\n\nvoid mainImage(out vec4 o, vec2 p){\n    \n    // Screen coordinates and movement.\n    //p = p/65. + iDate.w; // 124 character version.\n    p = p/iResolution.y*7. + iDate.w;\n    \n    // Very cheap wrappable cellular tiles.\n    o = o - o + min(min(f, f), f)/.6;\n}\n*/\n\n\n\n/*\n// Wrappable, repeat distance metric. It's faster to perform \n// the dot product and take the square root later, but we're \n// character saving.\n\n#define f(p) length(fract(p/70.) - .5)\n\nvoid mainImage(out vec4 o, vec2 p){\n\t \n    // Movement. Just take the \"70\" out of the \"define\" above.\n    //p = p/70. + iDate.w; \n    \n    // Used to rotate cells with slight warping.\n    mat2 m = mat2(7, -5, 5, 7)*.1;\n    \n    // Very cheap wrappable cellular tiles.\n    o += min(min(f(p), f(p*m)), f(p*m*m))/.6 - o;\n    \n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}