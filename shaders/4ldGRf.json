{
    "Shader": {
        "info": {
            "date": "1470612311",
            "description": "My attempt to combine techniques from [url=https://www.shadertoy.com/view/ll2SWd]Above the clouds[/url] and [url=https://www.guerrilla-games.com/read/the-real-time-volumetric-cloudscapes-of-horizon-zero-dawn]Real-Time Volumetric Cloudscapes[/url]",
            "flags": 16,
            "hasliked": 0,
            "id": "4ldGRf",
            "likes": 118,
            "name": "Volumetric cloud",
            "published": 3,
            "tags": [
                "clouds",
                "volumetric",
                "scattering",
                "twisted"
            ],
            "usePreview": 1,
            "username": "Duke",
            "viewed": 7139
        },
        "renderpass": [
            {
                "code": "// \"Volumetric cloud\" by Duke\n// https://www.shadertoy.com/view/4ldGRf\n//-------------------------------------------------------------------------------------\n// Based on \"Above the clouds\" (https://www.shadertoy.com/view/ll2SWd)\n// \"Volumetric explosion\" (https://www.shadertoy.com/view/lsySzd)\n// and other previous shaders.\n// Also was useful\n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and IQ's \"Clouds\" (https://www.shadertoy.com/view/XslGRr) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n// Comment this string to see another type of clouds\n#define TWISTED\n// Comment this string to make cloud less dense\n#define DENSE\n\n#define DITHERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n    return noise(p*.06125)*.75+ noise(p*.125)*.325 + noise(p*.4)*.2;\n}\n\n// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Sphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 2.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = -mod(iTime * 0.2,-2.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricCloud(vec3 p)\n{\n    float final = Sphere(p,4.);\n    #ifdef TWISTED\n    float tnoise = noise(p*0.5);\n    //final += tnoise * 1.75;\n    final += SpiralNoiseC(p.zxy*0.3132*tnoise+333.)*3.25;\n    #else\n    final += SpiralNoiseC(p*0.35+333.)*3.0 + fbm(p*50.)*1.25;\n    #endif\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tfloat VolCloud = VolumetricCloud(p/0.5)*0.5; // scale\n\treturn VolCloud;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 26.;\n\tfloat delta = b*b - c;\n\tif(delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\nfloat HGPhase( float cosAngle, float g)\n{\n\tfloat g2 = g * g;\n\treturn (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * cosAngle, 1.5);\n}\n\nfloat BeerLaw(float DenSample, float DenCoef)\n{\n   return exp( -DenSample * DenCoef);\n}\n         \nfloat PowderEff(float DenSample, float cosAngle, float DenCoef, float PowderCoef)\n{\n   float Powder = 1.0 - exp(-DenSample * DenCoef * 2.0);\n   Powder = clamp(Powder * PowderCoef, 0.0, 1.0);\n   return mix(1.0, Powder, smoothstep(0.5, -0.5, cosAngle));\n}\n\n// Utility function that maps a value from one range to another.\nfloat Remap(float original_value, float original_min, float original_max, float new_min, float new_max)\n{\n\treturn new_min + (((original_value - original_min) / (original_max - original_min)) * (new_max - new_min));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n    \n   \t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -8.+key*1.6);\n    \n    R(rd.yz, -pi*3.93);\n    R(ro.yz, -pi*3.93);\n    R(rd.xz, iMouse.x*0.008*pi);\n    R(ro.xz, iMouse.x*0.008*pi);\n   \n    // ld, td: local, total density \n    // w: weighting factor\n    float ld=0., td=0., w;\n\n    // t: length of the ray\n    // d: distance function\n    float d=1., t=0.;\n   \n    // Distance threshold\n    const float h = .225;\n    \n    vec3 sundir = normalize( vec3(-1.0,0.75,1.0) );\n   \n    // background sky     \n    vec3 colSky = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n    float sun = clamp(dot(sundir,rd), 0.0, 1.0);\n    colSky += 0.25 * vec3(1.0,.6,0.1) * pow(sun, 8.0) + 2.0 * vec3(1.0,.6,0.1) * pow(sun, 3000.0);\n    colSky = clamp(colSky, 0.0, 1.1);\n    \n    vec4 sum = vec4(0.0);\n   \n    // Cloud color\n    const vec3 CloudBaseColor = vec3(0.52, 0.67, 0.82);\n    const vec3 CloudTopColor = vec3(1.0);\n   \n    #ifdef DITHERING\n    vec2 posd = ( fragCoord.xy / iResolution.xy );\n    vec2 seed = posd + fract(iTime);\n    t = (1. + 0.2*rand(seed*vec2(100.)));\n    #endif \n    \n    float d_remaped = 0.0;\n\n    float min_dist = 0.0, max_dist = 0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist * step(t, min_dist);    \n    \n    // rm loop\n    for (int i=0; i<64; i++)\n    {\n        vec3 pos = ro + t*rd;\n       \n        // Loop break conditions.\n        if(td>0.9875 || d<0.0006*t || t>12. || t>max_dist || sum.a > 0.99) break;\n       \n        // evaluate distance function\n        d = map(pos);\n      \n        d_remaped = Remap(max(d,-2.), -2., h, h, 1.0);\n\n        // check whether we are close enough\n        if (d<h) \n        {\n            // compute local density and weighting factor \n            ld = h - (1.0 - d_remaped);\n          \n            w = (1. - td) * ld;   \n     \n            // accumulate density\n            #ifdef DENSE\n            td += w + 1./200.;\n            #else\n            td += w * 1./200.;\n            #endif\n\t\t\t\n            const float dShiftStep = 0.2; \n            float dShift = map(pos + dShiftStep * sundir);\n            float fld = clamp((ld - (h - max(dShift, 0.0))) / (dShiftStep * 2.), 0.0, 1.0);\n         \n            vec3 lin = mix(CloudTopColor, CloudBaseColor, -fld) * .85;\n         \n            // this part based on \"Real-Time Volumetric Cloudscapes\" by Andrew Schneider\n            const float FwdSctG = 0.2;\n            const float BckwdSctG = -0.02;\n            const float HGCoef = .1;\n            const float DenCoef = .75;\n            const float PowderCoef = 1.3;\n            \n            float cosAngle = dot(rd, sundir);\n            float FwdSctHG = HGPhase(cosAngle, FwdSctG);\n            float BckwdSctHG = HGPhase(cosAngle, BckwdSctG);\n            float TotalHGPhase = (HGCoef * FwdSctHG) + ((1. - HGCoef) * BckwdSctHG);\n\t\t\t\n            #ifdef DENSE\n            vec4 col = vec4(lin * TotalHGPhase * BeerLaw(fld*ld, DenCoef) * PowderEff(exp(-d), cosAngle, DenCoef, PowderCoef) + colSky * 0.05, d_remaped);\n            #else\n            vec4 col = vec4(lin * TotalHGPhase * BeerLaw(fld*ld, DenCoef) * PowderEff(exp(-d), cosAngle, DenCoef, PowderCoef) + colSky * 0.05, exp(-d_remaped));\n            #endif\n            \n            // front to back blending\n            #ifdef DENSE\n            col.a *= 0.185;\n            #else\n            col.a *= 0.175;\n            #endif\n            col.rgb *= col.a;\n            sum += col*(1.0-sum.a);\n        }\n      \n        td += 1./150.; // 1./80.;\n       \n        // enforce minimum stepsize\n        d = max(d, 0.1);\n      \n        #ifdef DITHERING\n        // add in noise to reduce banding and create fuzz\n        posd.y*=120.;\n        posd.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(posd.y,-posd.x+0.5*sin(4.*iTime+posd.y*4.0))).r);\n        #endif \n     \n        // step forward\n        t += max(d * 0.19, 0.02);\n    }\n \n    sum = clamp( sum, 0.0, 1.0 );\n    \n    }\n        \n    sum.xyz = colSky * (1.0-sum.w) + sum.xyz;\n    \n    // small color adjustment\n    sum.xyz *= 1. / exp( ld * 0.05 ) * .85;\n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*clamp(sum.xyz,0.0,1.0));\n   \n    fragColor = vec4(sum.xyz,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}