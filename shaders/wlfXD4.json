{
    "Shader": {
        "info": {
            "date": "1562888767",
            "description": "testing",
            "flags": 0,
            "hasliked": 0,
            "id": "wlfXD4",
            "likes": 2,
            "name": "Marching on",
            "published": 3,
            "tags": [
                "gettingthere"
            ],
            "usePreview": 0,
            "username": "PsyPhi",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n//Shapes\n\n    float sdTorus( vec3 p, vec2 r )\n\t{\n\t\tfloat x = length(p.xz)-r.x; //distance from the xz of p to the center of the tourus - the radius of the tourus\n\t\treturn length(vec2(x, p.y))-r.y;\n    }\n\n\tfloat dBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p)-s, 0.));\n    }\n\n\tfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n        \n        float t = dot(ab, ap) / dot(ab, ab);\n        t = clamp(t, 0., 1.);\n        \n        vec3 c = a + t*ab;\n        return length(p-c)-r;\n    }\n\n\n//Shape unions\n\nfloat opUnion( float d1, float d2 ) //Merges two objects\n{\n    return min(d1,d2);\t\t\t\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )  //smooth merges two objects\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n    \n    \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// Distance calculations\n\nfloat GetDist(vec3 p)// function for calculating distance. This is where the atual objects are coded\n{\n    \n    \n    vec3 obj1 = vec3(0, sin(iTime)*1.5-0.5, 6); //object 1 location\n    vec3 obj2 = vec3(0,0,6); //object 1 location\n    vec3 obj3 = vec3(0,sin(iTime)*1.5-2.,6); //object 1 location  \n    \n    vec4 s = vec4(obj1, 1); //this genirates a sphere (x,y,z,radius)\n    \n    float cap = sdCapsule(p, vec3(2,2.-sin(iTime)*2.,6),  vec3(4,1.5,6), 0.5); // sphere 1 position, shpere2 postion, radius. \n    float cap2 = sdCapsule(p, vec3(-2,2.-sin(iTime)*2.,6),  vec3(-4,1.5,6), 0.5);\n    float cap3 = sdCapsule(p, vec3(0,2.-sin(iTime)*2.,4),  vec3(0,1.5,2), 0.5);\n    float cap4 = sdCapsule(p, vec3(0,2.-sin(iTime)*2.,4),  vec3(0,1.5,2), 0.5);\n    \n    float tor = sdTorus(p-obj2, vec2(sin(iTime)*3., 0.5)); //change the vec2 to change the shape. x increases the hole, and y increases the diameter\n    float box = dBox(p-obj3, vec3(0.5));\n    \n    float sphereDist = length(p-s.xyz)-s.w; // length from origin is ray position - the pos of the shpere - the radious of the sphere\n    float planeDist = p.y; // this genirates the floor plane. it is calculated by seeing how high the ray is from the ground.\n\n    \n    \n    float shapeMix = opSmoothUnion(sphereDist, planeDist, 1.0);\n    shapeMix = opSmoothUnion(shapeMix, tor, 0.75);\n    shapeMix = opSmoothSubtraction(box, shapeMix, 0.7);\n    shapeMix = opSmoothSubtraction(cap, shapeMix, 0.7);\n    shapeMix = opSmoothSubtraction(cap2, shapeMix, 0.7);\n    shapeMix = opSmoothSubtraction(cap3, shapeMix, 0.7);\n    shapeMix = opSmoothSubtraction(cap4, shapeMix, 0.7);\n    \n\tfloat d = min(sphereDist, planeDist); // which object is the ray closer to? ** you need to add any other objects in the scene to this line **\n       \n    return shapeMix;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat dO=0.0; // dO is the distance to the origin\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd*dO; //current ray postion. Move in the direction of the ray (rd), by the distance the object is from the origin (dO or camera)\n        float ds = GetDist(p); //calculates distance the currenmt ray position is from the object\n        dO += ds;\t\t\t//moves the current ray position by the distance it is from the object\n        if(dO>MAX_DIST || ds<SURF_DIST) break; // has the ray position moved past the max distance, or gotten close enough to the object to stop?\n        \n    }\n    \n    return dO;\n        \n}\n\nvec3 GetNormal(vec3 p)\n{\n \tfloat d = GetDist(p);\n    vec2 e = vec2( 0.1,0);\n    \n    vec3 n = d - vec3        //this moves 0.1 in eash direction from the point and takes a distance sample used to calculate the slope of the surface\n        (\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n \tvec3 lightPos = vec3(0.,5,3); //postion of the light source\n    lightPos.xy += vec2(sin(iTime), cos(iTime))*2.;\n \tvec3 l = normalize(lightPos-p); //at direction is the surface from the light source\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l),0.,1.); //diffrence in angle between the normal and light vectors. clamps to 0 and 1 to prevent neg numbers\n    \n    //Shadows\n    float d = RayMarch(p+n*SURF_DIST*2., l);    //raymarch from the point towards the light. the n*SURF_DIST moves it just far enough away from the surface so that it does not stop the march due to already being at a surface.\n    if(d<length(lightPos-p))\t//Does the ray hit an object before hiting the light?\n    \t{\n            dif *= 0.1;\t\t\t//If so make the point 10 times darker.\n        }\n    \n    return dif;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //Camera\n    vec3 ro = vec3(0,5,-1.5); //Ray origin. Edit this to change the camera position.\n    vec3 rd = normalize(vec3(uv.x, uv.y-.7, 1)); //Ray direction. Normalize function returns the direction with a lenth of 1. edit this to change the direction the camera is facing\n\n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd * d; //location that the raymarch function determined is the surface\n    \n    float dif = GetLight(p);// dif mean defused light\n    \n//    dif /=6.0;  //brings the distance value into the visable range?? used for testing REMOVE\n\tcol = vec3(dif);\n    col = getNormal(p);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}