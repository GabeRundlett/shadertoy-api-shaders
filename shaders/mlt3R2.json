{
    "Shader": {
        "info": {
            "date": "1682939825",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n1st of may, 1st of may....",
            "flags": 0,
            "hasliked": 0,
            "id": "mlt3R2",
            "likes": 18,
            "name": "Year of Truchets #016",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "tiles",
                "truchetcore"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Year of Truchets #016\n    05/01/2023  @byt3 - (it's Gonna Be May) - m3chanic\n    \n    Just a mix of things laying around on the shader floor scrapped together \n    with some reflections and love.. \n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609,47.983)))*43758.5453);}\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e - b), 0.0, 1.0); }\n\n//@iq shapes\nfloat box( vec3 p, vec3 s ) {\n    p = abs(p)-s;\n    return length(max(p,0.))+min(max(p.x, max(p.y, p.z)),0.)-.025;\n}\nfloat box( vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat cap( vec3 p, float r, float h ) {\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nfloat vcap( vec3 p, float h, float r ) {\n    p.y -= clamp(p.y,0.,h);\n    return length(p) - r;\n}\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nconst float rep = 14.;\nconst float hrep = rep/2.;\nconst float angle = 2.*PI/rep;\nconst float angfl = angle/2.;\n\nfloat polar(inout vec2 p)  {\n    float a = atan(p.y, p.x) + angfl;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angfl;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (hrep)) ? abs(c) : c;\n} \n\nfloat column(vec3 q) {\n    q.y += 1.4;\n    vec3 p = vec3(q.x,abs(q.y)-2.35,q.z);\n    float b = cap(q.xzy,2.,1.1);\n    float c = box(p,vec3(1.35,.25,1.35))-.005;\n    polar(q.xz);\n    float g = vcap(q-vec3(1.1,-1.25,0),2.5,.175);\n    return min(c,max(b,-g));\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0),speed=vec3(0);\nmat2 r45,r25;\n\nconst float size = 5.;\nconst float hlf = size/2.;\nconst vec3  grid = vec3(1,1,1);\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    vec2 id = floor((p.xz+hlf)/size);\n    vec2 q = mod(p.xz+hlf,size)-hlf;\n    \n    vec3 q2 = p+vec3(hlf,0,hlf);\n    vec2 ip = floor((q2.xz+hlf)/size);\n    q2.xz = mod(q2.xz+hlf,size)-hlf;\n    \n    float chk = mod(ip.y + ip.x,2.) * 2. - 1.;\n    float hs = hash21(id);\n    if(hs>.5) q.x*=-1.;\n\n    vec2 d2 = vec2(length(q-hlf), length(q+hlf));\n    vec2 gx = d2.x<d2.y ? vec2(q-hlf) : vec2(q+hlf);\n\n    vec3 r = vec3(gx.x,p.y,gx.y);\n    vec3 t = vec3(q.x,p.y,q.y);\n    float tk = .35+.15*sin(p.x*.4+T*2.94);\n    \n    float d3 = box(r,vec3(size));\n    float d4 = trs(r,vec2(hlf,tk));\n\n    if(hs>.75) d4 = min(length(t.yz)-tk,length(t.yx)-tk);\n\n    if(hs>.075 && hs<.1) d4 = min(length(vec3(abs(t.x)-hlf,t.yz))-tk,length(vec3(t.yx,abs(t.z)-hlf))-tk);\n\n    if(hs<.075) d4 = min(length(t.yx)-tk, length(vec3(abs(t.x)-hlf,t.yz))-tk);\n    \n    d3=max(d3,d4);\n\n    if(d3<res.x){\n        float rs=fract(hs*432.32);\n        res = vec2(d3,rs<.65?4.:3.);\n        hit = p; \n        gid = vec3(id,1);\n    }\n\n    float rs=hash21(ip*432.32);\n    float cl = column(q2-vec3(0,2,0));\n    if(cl<res.x &&chk>.5 && rs>.5){\n        res = vec2(cl,5.);\n        hit = t;\n        gid=vec3(ip.xyx);\n    }\n    \n    \n    float fl = p.y+2.;\n    if(fl<res.x){\n        res = vec2(fl,2.);\n        hit = p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.4:ray.x;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(float t) {\n    return .45 + .35*cos(PI2*t*(vec3(.12,.47,.92)+vec3(.88,.97,.85))); \n}\n\nvec4 FC = vec4(.65,.75,.75,0);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,110);\n    hitPoint = hit;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-5,20,-15);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.05);\n        vec3 hp = hitPoint*vec3(-1.,1,1);\n \n        float diff = clamp(dot(n,l),.1,.95);\n        \n        float shdw = 1.;\n        for( float t = .01; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 25.*h/t);\n            t += h;\n            if( shdw < MIN_DIST || t > 25. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.35);\n\n        // materials\n        if(m==2.){\n            h = vec3(.25);//hue((311.-hp.x)*.005);\n            \n            vec2 k = fract(hp.xz*.1)-.5;\n            vec2 f = fract(hp.xz*1.)-.5;\n            if(k.x*k.y>0.) f = k;\n             \n            if(f.x*f.y>0.) {\n                h=vec3(.1); \n                ref = h;\n            }\n        }\n        if(m==3.){\n            h = hue((321.-hp.x)*.005);\n            ref = h*.35;\n        }\n        if(m==4.){\n            h = vec3(.05);\n            ref = vec3(.15);\n        }\n        if(m==5.){\n            h = vec3(.95);\n            h = hue( (sid.x*.02)+(sid.y*.05)+(hp.y*.01) );\n            ref = vec3(0);\n        }\n        \n        C = (diff*h);\n        C = mix(FC.rgb,C,exp(-.0000095*d*d*d));\n        \n        ro = p+n*.0001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r45=rot(-.685);\n    mat2 r25=rot(-.685+.1*sin(T*.25));\n    speed = vec3(T*.75,0,0);\n    float zoom = 15.;\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*zoom,-(zoom+10.));\n    vec3 rd = vec3(0.,0.,1.);\n    \n    ro.yz*=r45,ro.xz*=r25;\n    rd.yz*=r45,rd.xz*=r25;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0),ref=vec3(0), fil=vec3(1);\n    float d = 0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n    C = clamp(C,vec3(.01),vec3(1));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}