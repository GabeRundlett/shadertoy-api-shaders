{
    "Shader": {
        "info": {
            "date": "1540071429",
            "description": "fork of\nhttps://www.shadertoy.com/view/4dtSRn\nits has a few functional differences , noting tragic, all unintended translation errors.",
            "flags": 32,
            "hasliked": 0,
            "id": "XttBRB",
            "likes": 7,
            "name": " Reusable drag and drop B",
            "published": 3,
            "tags": [
                "mouse",
                "template",
                "drop",
                "drag",
                "util",
                "widget",
                "reusable"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 712
        },
        "renderpass": [
            {
                "code": "// Inspired by https://www.shadertoy.com/view/MdKGRw\n// This is a reusable drag and drop framework.\n//  * Drag objects around by clicking on them.\n//  * Add new objects by clicking in space.\n//  * Delete objects by dragging them to the red square.\n\n#define BufA(x) texture(iChannel0,(vec2(x, 0.)+.5)/iResolution.xy)\n\nfloat mi(float a,float b){return min(a,b);\n    ;}\n\n\n\nvoid drawDragDots(inout vec4 s,vec2 U,inout vec2 e\n){for(float i=0.;i<maxCount;++i\n ){if(i>=s.y)break//bound by number of instantiated UIDots\n  ;float f=length(U-BufA(i).xy)\n  ;e=vec2(mix(e.x,i,step(f,e.y)),mi(f,e.y))\n ;}}\n\nvec3 dotColor(vec4 s,float r\n){if (r==s.x)return mix(vec3(.5,1,1),vec3(0,1,0),step(0.,s.z))\n ;return vec3(.5,.5,1);}\n\n\n\nvoid MainEntry(inout vec4 o,vec2 U,vec4 s){\n ;vec3 c=vec3(1)\n ;float r=0.,d=UiDotRadius+UiDotBorder \n ;vec2 e=vec2(r,d)\n ;drawDragDots(s,U,e)  \n ;if(e.y<UiDotRadius+UiDotBorder//this smoothstep is not pretty.\n ){;e.y-=UiDotRadius\n   ;c=mix(vec3(0),dotColor(s,e.x),smoothstep(0.,1.,-e.y-UiDotBorder*.5))//center to black\n   ;c=mix(vec3(1),c,smoothstep(0.,1.,-(e.y-UiDotBorder*.5)))//to outsie\n  ;} \n  ;if(inRect(U, deleteRect))c=mix(c,vec3(1,0,0),.3)\n  ;o=vec4(c,1.)\n ;}\n\nvoid mainImage(out vec4 o, in vec2 u\n){vec4 s=BufA(statePos)\n ;MainEntry(o,u,s) ;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//reusable drag+drop buffer\n//ichan0 is self\n\n//parent: https://www.shadertoy.com/view/4dtSRn\n\n// Drag and drop framework\n// https://www.shadertoy.com/view/4dtSRn\n// by mhnewman\n//\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\n\n\n\nvoid rToD(float d,inout float r,inout vec4 state,inout float f,inout vec4 o,vec4 center,vec4 m\n){if(d<r\n ){r=d\n  ;state.x=f\n  ;o=center-m;}}\n\nvoid  KlickLoop(inout vec4 state,vec4 o,vec4 m\n){float r=clickPointRadius+1.\n ;for(float i=0.;i<maxCount;++i\n ){float f=i\n  ;if(f>=state.y)break\n  ;vec4 center=texture(iChannel0,vec2(.5+f,.5)/iResolution.xy)\n  ;rToD(length(m.xy-center.xy),r,state,f,o,center,m);\n ;}    \n ;if(r>clickPointRadius)state.xy=mix(vec2(2.*statePos,state.y),state.yy+vec2(0,1),step(state.y,statePos))\n ;}\n\nvoid branchi(inout vec4 fragColor, vec2 p,float statePos,vec4 state,vec2 U\n){if(p.x==statePos)fragColor=vec4(2.*statePos,state.y-1.,iMouse.z,1)\n ;else if(p.x<state.x)fragColor=texture(iChannel0, U/iResolution.xy)\n ;else fragColor=texture(iChannel0,(U+vec2(1,0))/iResolution.xy)\n ;}\n\nvoid mainImage(out vec4 fragColor,in vec2 U\n){vec2 p=U-.5\n ;if(p.y>0.||p.x>offsetPos){fragColor=vec4(0);return;}\n ;if (iFrame==0\n ){float count=0.//init\n  ;addObject(.2*iResolution.x,.2*iResolution.y)//3 dots exist from frame0:\n  ;addObject(.2*iResolution.x,.8*iResolution.y)\n  ;addObject(.8*iResolution.x,.8*iResolution.y)\n  ;if(p.x==statePos)fragColor=vec4(2.*statePos,count,0.,0.);return;}\n ;vec4 state=texture(iChannel0,vec2(.5+statePos,.5)/iResolution.xy)\n ;vec4 o=texture(iChannel0,vec2(.5+offsetPos,.5)/iResolution.xy)\n ;     if(max(state.z,-iMouse.z)<0.)KlickLoop(state,o,iMouse)\n ;else if(min(state.z,-iMouse.z)>0.&&inRect(iMouse.xy,deleteRect)\n ){branchi(fragColor,p,statePos,state,U);return\n ;}if(p.x==statePos)fragColor=vec4(state.xy,iMouse.z,state.w)\n ;else if(p.x==offsetPos)fragColor=o\n ;else if(p.x==state.x&&iMouse.z>0.)fragColor=iMouse+o\n ;else fragColor=texture(iChannel0,U/iResolution.xy)\n ;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\nconst float maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1.\nconst float UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst float statePos = maxCount;\nconst float offsetPos = maxCount + 1.;\nconst vec4 deleteRect=vec4(0.,0.,40.,40.);\n\nfloat mi(vec4 a){return min(min(a.x,a.y),min(a.z,a.w));}\n//original was halfOpen ]interval], while this is [closed]\nbool inRect(vec2 pos, vec4 rect\n){rect.xyzw-=pos.xyxy\n ;return min(rect.z-rect.x,rect.y-rect.w)<mi(rect) ;}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}