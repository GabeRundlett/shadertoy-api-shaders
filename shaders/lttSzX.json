{
    "Shader": {
        "info": {
            "date": "1480971401",
            "description": "I needed to reach the next level, after being at ShaderToy for a year now. Doing a 4D/quaternion julia-set ray-marcher seemed fitting. Pretty intense math... uff! Happy with the result so far. The mouse moves the camera.\nhttp://blog.macslow.org/?p=161",
            "flags": 0,
            "hasliked": 0,
            "id": "lttSzX",
            "likes": 14,
            "name": "quaternion julia set",
            "published": 3,
            "tags": [
                "fractal",
                "julia",
                "4d",
                "quaternion",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 2675
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 4D/quaternion raymarching-renderer for julia-sets\n//\n// Copyright 2016 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// I never thought I'd get to this level, when I joined ShaderToy last year.\n// But reading, trying, failing and trying again (and standing on the shoulders\n// of giants like iq and others) helped me get the grip on many aspects of\n// computer graphics, I always wanted to touch and implement myself, but never\n// dared until recently... so this shader is also to be understood as a small\n// hommage to the demo-scene community as a whole... thanks folks!\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// go and play with the components of c at line 187 to look at other julia-sets\n\n#define ESCAPE_DISTANCE   10.\n#define BOUNDING_DOMAIN_SIZE  3.\n#define VICINITY           .00001 \n#define MAX_ITERATIONS     9\n#define INTERSECTION_DEPTH 96\n#define EPSILON            .003\n#define SHADOWS            true\n\nvec4 qMult (vec4 q1, vec4 q2)\n{\n\tvec4 r;\n\n    r.x   = q1.x * q2.x - dot (q1.yzw, q2.yzw);\n\tr.yzw = q1.x * q2.yzw + q2.x * q1.yzw + cross (q1.yzw, q2.yzw);\n\n    return r;\n}\n\nvec4 qSquare (vec4 q)\n{\n\tvec4 r;\n\n    r.x   = q.x*q.x - dot (q.yzw, q.yzw);\n\tr.yzw = 2.*q.x*q.yzw;\n\n    return r;\n}\n\nvoid iterateIntersect (inout vec4 q,\n                       inout vec4 qp,\n                       vec4 c)\n{\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n\t    qp = 2.0 * qMult (q, qp);\n    \tq = qSquare (q) + c;\n    \tif (dot (q, q) > ESCAPE_DISTANCE) {\n            break;\n        }\n    }\n}\n\nvec3 normal (vec3 p, vec4 c)\n{\n\tvec3 N;\n    vec4 qP = vec4 (p, .0);\n\tfloat gradX;\n    float gradY;\n    float gradZ;\n\tvec4 gx1 = qP - vec4 (VICINITY, .0, .0, .0);\n\tvec4 gx2 = qP + vec4 (VICINITY, .0, .0, .0);\n    vec4 gy1 = qP - vec4 (.0, VICINITY, .0, .0);\n    vec4 gy2 = qP + vec4 (.0, VICINITY, .0, .0);\n    vec4 gz1 = qP - vec4 (.0, .0, VICINITY, .0);\n    vec4 gz2 = qP + vec4 (.0, .0, VICINITY, .0);\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n\t\tgx1 = qSquare (gx1) + c;\n\t\tgx2 = qSquare (gx2) + c;\n\t\tgy1 = qSquare (gy1) + c;\n\t\tgy2 = qSquare (gy2) + c;\n\t\tgz1 = qSquare (gz1) + c;\n\t\tgz2 = qSquare (gz2) + c;\n\t}\n\n\tgradX = length (gx2) - length (gx1);\n\tgradY = length (gy2) - length (gy1);\n\tgradZ = length (gz2) - length (gz1);\n\tN = normalize (vec3 (gradX, gradY, gradZ));\n\treturn N;\n}\n\nfloat intersectQJulia (inout vec3 rO,\n                       inout vec3 rD,\n                       vec4 c,\n                       float epsilon)\n{\n\tfloat dist;\n    float dummy = .0;\n    for (int i = 0; i < INTERSECTION_DEPTH; ++i)\n\t{\n\t\tvec4 z = vec4 (rO, .0);\n\t\tvec4 zp = vec4 (1., .0, .0, .0);\n\t\titerateIntersect (z, zp, c);\n\n\t\tfloat normZ = length (z);\n\t\tdist = .5 * normZ * log (normZ) / length (zp);\n\t\trO += rD * dist;\n        if (dist < epsilon || dot (rO, rO) > BOUNDING_DOMAIN_SIZE) {\n\t        break;\n        }\n\t}\n\n\treturn dist;\n}\n\nvec3 shade (vec3 light, vec3 eye, vec3 pt, vec3 N)\n{\n\tvec3 diffuse = vec3 (1., .45, .25);\n\tconst float specularExponent = 10.;\n\tconst float specularity = .45;\n\tvec3 L = normalize (light - pt);\n    vec3 E = normalize (eye - pt);\n\tfloat NdotL = dot (N, L);\n\tvec3 R = L - 2. * NdotL * N;\n\tdiffuse += abs (N) * .3;\n\n    return diffuse * max (NdotL, .0) + specularity * pow (max (dot (E,R),.0), specularExponent);\n}\n\nvec3 intersectSphere (vec3 rO, vec3 rD)\n{\n\tfloat B, C, d, t0, t1, t;\n\tB = 2. * dot (rO, rD);\n\tC = dot (rO, rO) - BOUNDING_DOMAIN_SIZE;\n\td = sqrt (B * B - 4. * C);\n\tt0 = (-B + d) * .5;\n\tt1 = (-B - d) * .5;\n\tt = min (t0, t1);\n\trO += t * rD;\n\treturn rO;\n}\n\nmat3 camera (vec3 ro, vec3 target, float cr)\n{\n    vec3 cw = normalize (target - ro);\n    vec3 cp = vec3 (sin (cr), cos (cr), .0);\n    vec3 cu = normalize (cross (cw, cp));\n    vec3 cv = normalize (cross (cu, cw));\n    return mat3 (cu, cv, cw);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uvRaw = fragCoord.xy / iResolution.xy;\n    vec2 uv = uvRaw;\n    uv = uv * 2. - 1.;\n    uv *= vec2 (iResolution.x / iResolution.y, 1.);\n    uvRaw *= (iResolution.x / iResolution.y, 1.);\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (.5 + 3.5 * cos (6. * mouse.x),\n                     -2. + 4. * sin (mouse.y),\n                     .5 + 3.5 * sin (6. * mouse.x));\n    vec3 aim = vec3 (.0, .0, .0);\n    mat3 ca = camera (eye, aim, .0);\n    float u = ((fragCoord.x / iResolution.x) * 2. - 1.) * (iResolution.x / iResolution.y);\n    float v = ((fragCoord.y /iResolution.y)* 2. - 1.);\n    vec3 rO = eye;\n    vec3 rD = normalize (ca * vec3 (u, -v, 2.));\n\n    // play with these components to select 3D-slices through the 4D julia-set\n    vec4 c = vec4 (-.2, .6, .5 * cos (iTime), .125 * sin (iTime));\n    //vec4 c = vec4 (-.137, -.63, -.475, -.046);\n\t//vec4 c = vec4 (-.125, -.256, .847, .0895);\n    //vec4 c = vec4 (-.445, .339, -.0889, -.562);\n    \n    vec3 light1 = vec3 (cos (iTime) * 2., 12., sin (iTime) * 15.);\n    vec3 light2 = vec3 (cos (iTime) * (-3.), -6., sin (iTime) * (-10.));\n\tconst vec4 backgroundColor = vec4 (.3, .3, .3, .0);\n\tvec4 color;\n\n    color = backgroundColor;\n\n    rD = normalize (rD);\n\trO = intersectSphere (rO, rD);\n\n    float dist = intersectQJulia (rO, rD, c, EPSILON);\n\tif(dist < EPSILON) {\n\t\tvec3 N = normal (rO, c);\n\t\tcolor.rgb = shade (light1, rD, rO, N);\n\t\tcolor.rgb += shade (light2, rD, rO, N);\n\t\tcolor.a = 1.;\n\t\tif (SHADOWS) {\n\t\t\tvec3 L = normalize (light1 - rO);\n\t\t\trO += N * EPSILON * 2.;\n\t\t\tdist = intersectQJulia (rO, L, c, EPSILON);\n            if (dist < EPSILON) {\n\t\t\t\tcolor.rgb *= .4;\n            }\n\t\t}\n\t}\n\n    // gamma-correction, tint, vingette\n    color.rgb = .2 * color.rgb + .8 * sqrt (color.rgb);\n    color.rgb *= vec3 (.9, .8, .7);\n    color.rgb *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n\tfragColor = color;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}