{
    "Shader": {
        "info": {
            "date": "1726735067",
            "description": "light",
            "flags": 0,
            "hasliked": 0,
            "id": "4XlcDX",
            "likes": 1,
            "name": "mosaic and light",
            "published": 3,
            "tags": [
                "light",
                "mosaic"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 64
        },
        "renderpass": [
            {
                "code": "mat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n\n}\n#define PI 3.14159265359\n#define S 4.\n// the wave amplitude\n#define A 1.9\n// the wave lenght\n#define WAVEL 1.1\n\n\n// taken from thebookofshaders.com\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n// taken from thebookofshaderx.com\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec2 cartesianToPolar(vec2 cartesian) {\n    float r = length(cartesian);          \n    float theta = atan(cartesian.y, cartesian.x); \n    return vec2(r, theta);  \n    \n}\n\nfloat Star(vec2 uv, float flare) {\n    float d = length(uv);\n    // the cirle of the star\n    float m = 0.05/d;\n    \n    float rays = max(0.,1.-abs(uv.x * uv.y*1000.));\n    m += rays;\n    uv *= Rot(3.1415/4.);\n    rays = max(0.,1.-abs(uv.x * uv.y*1000.));\n    m += rays * .3;\n    return m;\n}\n\nfloat HexDist(vec2 p){\n    p = abs(p);\n    float c = dot(p, normalize(vec2(1, 1.73)));\n    c= max(c,p.x);\n    return c;\n}\n\nvec4 HexCoord(vec2 uv){\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(fract(uv), r) - h;\n    vec2 b = mod(fract(uv) - h, r) - h;\n    \n    vec2 gv;\n    if(length(a) < length(b))\n        gv = a;\n    else \n        gv = b;\n        \n    \n    float x = atan(gv.x, gv.y);\n    float y = 0.2 - HexDist(gv);\n    vec2 id = uv - gv;\n    return vec4(x, y, id.x, id.y);\n}\n\nfloat pattern(vec2 uv, float t){\n   float speed = 0.5;\n   return sin(uv.x * uv.x + uv.y * uv.y + t * speed);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv *= 3.;\n    \n     vec2 uv2 = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec4 hc = HexCoord(uv*uv);\n    \n    float c = smoothstep(0.02, 0.05, hc.y *  pattern(vec2(hc.z, hc.w), iTime) );\n\n   \n    //uv = cartesianToPolar(uv);\n    vec2 wave1Center = vec2(-1., -0.5);\n    //vec2 wave2Center = vec2(1., 0.5);\n    wave1Center= vec2(0.);\n    \n    float disFromWave1Center = distance(uv, wave1Center);\n    //float disFromWave2Center = distance(uv, wave2Center);\n    \n    float wave1 =  A * sin(disFromWave1Center / WAVEL - iTime / WAVEL);\n    //float wave2 =  A * sin(disFromWave2Center / WAVEL - iTime / WAVEL) ;\n \n    uv = uv + uv * (wave1+c) / WAVEL;\n    vec3 col = vec3(0);\n    \n    col += Star(uv, 0.5);\n    col *= Star(uv2, 1.5);\n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}