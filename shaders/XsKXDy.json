{
    "Shader": {
        "info": {
            "date": "1466793852",
            "description": "a tribute to (=cheap immitation of) john carpenters epic movie theme song \"assault on precinct 13\"",
            "flags": 8,
            "hasliked": 0,
            "id": "XsKXDy",
            "likes": 15,
            "name": "assault on precinct 13",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "movie",
                "carpenter",
                "assault"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 1317
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// john carpenters epic movie theme song \"assault on precinct 13\"\n\n\nint getDigitMask(int d)\n{\n    if(d==0x0) return 0x00EAAAE;\n    if(d==0x1) return 0x004C444;\n    if(d==0x2) return 0x00E2E8E;\n    if(d==0x3) return 0x00E2E2E;\n    if(d==0x4) return 0x00AAE22;\n    if(d==0x5) return 0x00E8E2E;\n    if(d==0x6) return 0x00E8EAE;\n    if(d==0x7) return 0x00E2222;\n    if(d==0x8) return 0x00EAEAE;\n    if(d==0x9) return 0x00EAE2E;\n    if(d==0xa) return 0x004AAEA;\n    if(d==0xb) return 0x00CACAC;\n    if(d==0xc) return 0x0068886;\n    if(d==0xd) return 0x00CAAAC;\n    if(d==0xe) return 0x00E8C8E;\n    if(d==0xf) return 0x00E8C88;\n    return -1;\n}\n\n\n#define O_ 0x10\n#define I_ 0x11\n#define Z_ 0x12\n#define M_ 0x13\n#define H_ 0x14\n#define S_ 0x15\n#define G_ 0x16\n#define L_ 0x17\n#define X_ 0x18\n#define Q_ 0x19\n#define A_ 0x1A\n#define B_ 0x1B\n#define C_ 0x1C\n#define D_ 0x1D\n#define E_ 0x1E\n#define F_ 0x1F\n#define J_ 0x21\n#define N_ 0x22\n#define W_ 0x23\n#define K_ 0x24\n#define U_ 0x25\n#define P_ 0x26\n#define V_ 0x27\n#define T_ 0x28\n#define Y_ 0x29\n#define R_ 0x2A\n#define dot_ 0x30\n#define dot2_ 0x31\n#define space_ 0x32\n#define minus_ 0x33\n\nint getLetterMask(int d)\n{\n    if(d==O_) return 0x004AAA4; // O\n    if(d==I_) return 0x00E444E; // I\n    if(d==Z_) return 0x00E248E; // Z\n    if(d==M_) return 0x00AEEAA; // M\n    if(d==H_) return 0x00AAEAA; // H\n    if(d==S_) return 0x00E8E2E; // S\n    if(d==G_) return 0x00E8AAE; // G\n    if(d==L_) return 0x008888E; // L\n    if(d==X_) return 0x00EAEAE; // X\n    if(d==Q_) return 0x004AAA6; // q\n    if(d==A_) return 0x004AAEA; // A\n    if(d==B_) return 0x00CACAC; // B\n    if(d==C_) return 0x0068886; // C\n    if(d==D_) return 0x00CAAAC; // D\n    if(d==E_) return 0x00E8C8E; // E\n    if(d==F_) return 0x00E8C88; // F\n    if(d==J_) return 0x00E222C; // J\n    if(d==N_) return 0x00CAAAA; // N\n    if(d==W_) return 0x00AAEEA; // W\n    if(d==K_) return 0x00AAEAA; // K\n    if(d==U_) return 0x00AAAAE; // U\n    if(d==P_) return 0x00CAAC8; // P\n    if(d==V_) return 0x00AAAA4; // V\n    if(d==T_) return 0x00E4444; // T\n    if(d==Y_) return 0x00AAE44; // Y\n    if(d==R_) return 0x00CAACA; // R\n    if(d==dot_) return 0x0000004; // .\n    if(d==dot2_) return 0x0004004; // :\n    if(d==space_) return 0x0000000; // _\n    if(d==minus_) return 0x0000E00; // _\n    return getDigitMask(d);\n}\n\n\nvoid drawLetter(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getLetterMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nvoid drawText(mat4 str, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    for(int i=0;i<4;i++)\n    {\n        bool breakIt=false;\n        for(int j=0;j<4;j++)\n        {\n            if(int(str[i][j])<0) { breakIt=true; break; }\n            drawLetter(int(str[i][j]),pos+size*vec2(4.0*float(i*4+j),0),size,fragColor,fragCoord);\n        }\n        if(breakIt) break;\n    }\n}\n\nvoid drawDigit(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getDigitMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nint getDigit(int n, int d)\n{\n    return int(mod(float(n)/pow(10.0,float(d)),10.0));\n}\n\nint getDigitF(float f, int d)\n{\n    if(d<0) return int(mod(f/pow(0.1,float(-d)),10.0));\n    return int(mod(f/pow(10.0,float(d)),10.0));\n}\n\nvoid drawInt(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    for(int i=0;i<100;i++) { if(n2-1>=n) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        if(i==dn) break;\n        drawDigit(getDigit(n,dn-1-i), pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\n\nvoid drawFloat(float f, int dotnum, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    if(f<0.0) { f=-f; drawLetter(minus_, pos, size, fragColor, fragCoord); pos+=vec2(4.0*size,0); }\n    for(int i=0;i<100;i++) { if(float(n2-1)>=f) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        int d;\n        if      (i<dn)  d=getDigitF(f,dn-1-i);\n        else if (i==dn) d=dot_;\n        else if (i>dn)  d=getDigitF(f,dn-1-i+1);\n        if(i==dn+dotnum+1) break;\n        drawLetter(d, pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\n#define Res vec2(iResolution.xy)\n\nvec3 maskRGBGrid(vec3 col, vec2 coord,vec2 scrRes)\n{\t\n    if(fract(coord.x/Res.x*scrRes.x)<0.33) return col*vec3(1,0,0);\n    if(fract(coord.x/Res.x*scrRes.x)<0.66) return col*vec3(0,1,0);\n    return col*vec3(0,0,1);\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float offTime=120.;\n    float offdt=iTime-offTime;\n    float s=iResolution.x*0.013;\n    s*=fermi(offdt/0.07)+0.7*exp(-offdt*offdt/0.1/0.1);\n    vec2 c=iResolution.xy*0.5;\n    float l1=10.0;\n    float l2=11.0;\n    vec4 col=vec4(0.0);\n    vec2 coord = (fragCoord-c);\n    coord+=dot(coord,coord)*coord/iResolution.x/iResolution.x*0.9;\n    coord+=c;\n    float coordOffX=0.0;\n    vec2 scrRes=vec2(150,120)*3.0;\n    if(Res.y/1.7<scrRes.y) scrRes*=Res.y/1.7/scrRes.y;\n    coordOffX+=1.0*sin(iTime*40.0+70.0*coord.y/Res.x)*Res.x*0.002;\n    coordOffX-=1.5*sin(iTime*60.0+500.0*coord.y/Res.x)*Res.x*0.002;\n    //coord+=vec2(coordOffX,0);\n    vec2 coordQ = floor(coord/Res*scrRes)*Res/scrRes;\n    coordQ+=vec2(coordOffX,0);\n    drawText(mat4(A_,S_,S_,A_, U_,L_,T_,space_, O_,N_,-1,0, 0,0,0,0), c+vec2(-s*4.*0.5*l1, s*0.0), s, col,coordQ);\n    drawText(mat4(P_,R_,E_,C_, I_,N_,C_,T_,space_,1,3,-1, 0,0,0,0),   c+vec2(-s*4.*0.5*l2,-s*6.0), s, col,coordQ);\n    //coord-=vec2(coordOffX,0);\n    col*=vec4(1.,0.0,0.0,1);\n    col+=vec4(0.15);\n    // pixel mask\n    //col.xyz=maskRGBGrid(col.xyz,coord,scrRes);\n    // cathod ray mask\n    col*=clamp(1.0*(0.5+0.5*sin(3.3*scrRes.y*coord.y/iResolution.y)),0.0,1.0);\n    // time-mask\n    float ferm=fermi(offdt/0.07);\n    float d=length(coord-c);\n    col+=0.015*exp(-d*d/4.0/Res.x/Res.x/ferm/ferm)/(ferm)*mix(sin(iTime*300.0),1.0,(1.0-ferm));\n    if(coord.x<Res.x*0.05) col=vec4(0);\n    if(coord.y<Res.y*0.05) col=vec4(0);\n    if(coord.x>Res.x*0.95) col=vec4(0);\n    if(coord.y>Res.y*0.95) col=vec4(0);\n    fragColor=col;\n    if(iFrame<100)\n       drawText(mat4(S_,O_,U_,N_, D_,dot_,dot_,dot_, -1,0,0,0, 0,0,0,0), vec2(10,10), 2., fragColor,fragCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// john carpenters epic movie theme song \"assault on precinct 13\"\n\n#define T 2.7\n#define HT 1.059463094\n#define A4 (440.)\n#define B4 (440.*HT*HT)\n#define C4 (440.*HT*HT*HT)\n#define D4 (440.*HT*HT*HT*HT*HT)\n#define E4 (440.*HT*HT*HT*HT*HT*HT*HT)\n#define F4 (440.*HT*HT*HT*HT*HT*HT*HT*HT)\n#define G4 (440.*HT*HT*HT*HT*HT*HT*HT*HT*HT*HT)\n\n#define A0 (A4/16.)\n#define B0 (B4/16.)\n#define C0 (C4/16.)\n#define D0 (D4/16.)\n#define E0 (E4/16.)\n#define F0 (F4/16.)\n#define G0 (G4/16.)\n\n#define A1 (A4/8.)\n#define B1 (B4/8.)\n#define C1 (C4/8.)\n#define D1 (D4/8.)\n#define E1 (E4/8.)\n#define F1 (F4/8.)\n#define G1 (G4/8.)\n\n#define A2 (A4/4.)\n#define B2 (B4/4.)\n#define C2 (C4/4.)\n#define D2 (D4/4.)\n#define E2 (E4/4.)\n#define F2 (F4/4.)\n#define G2 (G4/4.)\n\n#define A3 (A4/2.)\n#define B3 (B4/2.)\n#define C3 (C4/2.)\n#define D3 (D4/2.)\n#define E3 (E4/2.)\n#define F3 (F4/2.)\n#define G3 (G4/2.)\n\n#define A5 (A4*2.)\n#define B5 (B4*2.)\n#define C5 (C4*2.)\n#define D5 (D4*2.)\n#define E5 (E4*2.)\n#define F5 (F4*2.)\n#define G5 (G4*2.)\n\nfloat rand(float x){\n    //return 2.0*(texture(iChannel0,vec2(x*44000.0+0.5,0.5)/iChannelResolution[0].xy).x-0.5);\n    return fract(sin(mod(x*10.0,10.0)*12.9898)*43758.5453)*2.0-1.0;\n}\n\nvec2 boing(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 1.0*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.6*sin(6.2831*(1.975*f*t+ph))\n                    +0.3*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*(exp(-8.0*t)+0.1*exp(-t*3.0)),-1.,1.)\n    );\n}\n\nvec2 brumm(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 0.6*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.8*sin(6.2831*(1.975*f*t+ph))\n                    +0.4*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*exp(-1.0*t),-1.,1.)\n    );\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(x));\n}\n\nvec2 bbbbb(float f1, float f2, float t)\n{\n    // X       X       X       X\n    // a _ a a c a\n    return \n    \t  boing(f1,t-T*0./16.,.0)*fermi((t-T*2./16.)/0.01)\n        + boing(f1,t-T*2./16.,.0)*fermi((t-T*3./16.)/0.01)\n        + boing(f1,t-T*3./16.,.0)*fermi((t-T*4./16.)/0.01)\n        + boing(f2,t-T*4./16.,.4)*fermi((t-T*5./16.)/0.01)\n        + boing(f1,t-T*5./16.,.0);\n}\n\nvec2 tich(float f,float t)\n{\n    float c=0.;\n    float a=0.;\n    for( int i=-512; i<512; i++ )\n    { \n        float t2=float(i)/44000.0;\n        float w=float(128)/44000.0;\n        w=1.0/f;\n        float s=exp(-t2*t2/w/w)*t2/w;\n        //a+=rand(t-t2)*cos(-6.2831*f*(t-t2))*s; c+=s; \n        a+=rand(t-t2)*s; c+=s*s;\n    }\n    a/=sqrt(c);\n    //a=rand(t);\n    a*=(0.5+0.5*sin(2300.*t))*(0.8+0.2*sin(800.*t))*exp(-25.0*mod(t,T/16.));\n    return 1.0*vec2(clamp(a,-1.0,1.0));\n}\n\nvec2 bumm(float f,float t)\n{\n    if(t<0.0) return vec2(0.);\n    return 2.0*vec2(sin(6.2831*f*t)*exp(-18.0*t));\n}\n\nfloat feep(float f1, float f2,float t)\n{\n \tfloat a=clamp(sin(f1*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n \treturn clamp(a*exp(0.5*t-4.0)*(fermi((t-T*3.5)/T/0.15)),-1.0,1.0);\n}\n\n// iq's polynomial smooth min function\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat feep2Map(float t)\n{\n    return smin(t,0.689*(t-T*(3.5+0.05))+T*(3.5-0.05),0.3);\n}\n\nfloat chordMaj(float f, float oct, float t) // FIXME: not really a major chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\nfloat chordMin(float f, float oct, float t) // FIXME: not really a minor chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    //t+=T*4.*3.0;\n    vec2 boingLine = \n         bbbbb(A1,C1,mod(t-T*0.,T*4.))\n        +bbbbb(C1,E1,mod(t-T*1.,T*4.))\n        +bbbbb(G0,G0,mod(t-T*2.,T*4.))\n        +bbbbb(A1,C1,mod(t-T*3.,T*4.));\n    if(t<T*4.) boingLine=vec2(0);\n    vec2 tichLine = tich(20000.0*sin(3.435346/T*6.2831*t),mod(t,T*4.0));\n    //tichLine*=dot(tichLine,tichLine);\n    //return tichLine*0.2;\n    vec2 bummLine = \n         bumm(50.,mod(t-T/8.*0.,T))\n        +bumm(50.,mod(t-T/8.*1.,T))\n        +bumm(70.,mod(t-T/8.*2.,T))\n        +bumm(50.,mod(t-T/8.*4.,T));\n    vec2 brummLine = vec2(\n         brumm(A1,mod(t-T*0.,T*4.),0.)\n        +brumm(C1,mod(t-T*1.,T*4.),0.)\n        +brumm(G0,mod(t-T*2.,T*4.),0.)\n        +brumm(A1,mod(t-T*3.,T*4.),0.)\n        );\n    if(t<T*4.*3.0) brummLine=vec2(0);\n    vec2 feepLine = vec2(feep(8100.,0.0,mod(t,T*4.)));\n    //return feepLine;\n    if(t<T*4.*3.0) feepLine=vec2(0);\n    if(t>T*4.*4.0) feepLine=vec2(0);\n    vec2 feepLine2 = vec2(feep(8100.,0.0,feep2Map(mod(t,T*4.))));\n    //return feepLine2;\n    if(t<T*4.*4.0) feepLine2=vec2(0);\n    if(t>T*4.*5.0) feepLine2=vec2(0);\n    vec2 chordLine = vec2(\n         chordMin(A0,5.,mod(t-T*0.,T*4.))\n        +chordMaj(C0,5.,mod(t-T*1.,T*4.))\n        +chordMaj(G0,4.,mod(t-T*2.,T*4.))\n        +chordMin(A0,5.,mod(t-T*3.,T*4.))\n    );\n    if(t<T*4.*5.0) chordLine=vec2(0);\n    if(t>T*4.*7.0) chordLine=vec2(0);\n    vec2 chordLine2 = vec2(\n         chordMin(A0,6.,mod(t-T*0.,T*4.))\n        +chordMaj(A0,6.,mod(t-T*1.,T*4.))\n        +chordMaj(A0,6.,mod(t-T*2.,T*4.))\n        +chordMaj(G0,5.,mod(t-T*2.5,T*4.))\n        +chordMin(A0,6.,mod(t-T*3.,T*4.))\n    );\n    if(t<T*4.*7.0) chordLine2=vec2(0);\n    if(t>T*4.*9.5) chordLine2=vec2(0);\n    if(t>T*4.*9.0) boingLine=vec2(0);\n    if(t>T*4.*10.0) brummLine=vec2(0);\n    if(t>T*4.*11.0) tichLine=vec2(0);\n    if(t>T*4.*11.0) bummLine=vec2(0);\n    //if(t>T*4.*10.0) brummLine=vec2(0);\n    //return chordLine2;\n    return (\n         boingLine*.2\n        +tichLine *.12\n        +bummLine *.6\n        +brummLine*.2\n        +feepLine *.3\n        +feepLine2 *.3\n        +chordLine *.12\n        +chordLine2 *.12 )*0.5\n        ;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}