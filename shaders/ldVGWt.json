{
    "Shader": {
        "info": {
            "date": "1457148482",
            "description": "Started out playing around with stacked cubes, one thing led to another, then I couldn't resist the bad pun. Thank you to Shane for the incredibly well-commented code, a real blessing for beginners.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldVGWt",
            "likes": 11,
            "name": "La Cage Fool's Au",
            "published": 3,
            "tags": [
                "raymarch",
                "reflections",
                "hgsdf"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 1082
        },
        "renderpass": [
            {
                "code": "/*\n\t\"La Cage Fool's Au\"  by wjbgrafx\n\t\n\tbased on\n\thttps://www.shadertoy.com/view/4dt3zn\t\n\tRaymarched Reflections   Uploaded by Shane on 2015-Nov-17\n\n\tAdditional sources\n\t------------------\t\n\tHG_SDF GLSL Library for building signed distance bounds by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\n\tCamera rotation matrix function\n\tFrom\t\"Simple test/port of Mercury's SDF library to WebGL\"\n\thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\t\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n#define PI_4\t\t\t\t\t0.78539816339744830961566084581988\n\n#define FAR                     45.0\n#define MAX_RAY_STEPS           150\n#define MAX_REF_STEPS           30\n\n#define CAM_DIST\t\t\t\t18.0\n#define CAM_POS                 vec3( 0.0, 0.0, -CAM_DIST )\n#define CAM_FOV_FACTOR          4.0\n#define LOOK_AT                 vec3( 0.0 )\n#define LIGHT_POS               vec3( 0.0, 20.0, -10.0 )\n#define LIGHT_ATTEN\t\t\t\t0.001\n\n\n//------------------------------------------------------------------------------\n// Function declarations\n//----------------------\nmat4 createCamRotMatrix();\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is used to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions);\nfloat fSphere(vec3 p, float r);\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r);\n// Cone with correct distances to tip and base circle. \n// Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height);\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height);\n\nfloat vmax(vec3 v);\nvec3 rotateX(vec3 p, float a);\nvec3 rotateY(vec3 p, float a);\nvec3 rotateZ(vec3 p, float a);\n\n//------------------------------------------------------------------------------\n// Based on fBox from HG_SDF\nfloat diamondCube(vec3 p, float side)\n{\n\tp = rotateX( p, PI_4 - 0.17 );\n\tp = rotateZ( p, PI_4 );\n\tvec3 d = abs(p) - vec3( side );\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map(vec3 p)\n{    \n\tfloat objID = 1.0;\n\tvec2 ground = vec2( fDisc( p - vec3( 0.0, -2.25, 0.0 ), 5.0 ), objID );      \n\n\t//---------------------\n\tpModPolar( p.xz, 8.0 );\n\t// Move the cube tower that was positioned at the origin out to the edge\n\t// of the disc.\n\tp.x -= 4.5;\n\t//---------------------\n\n\tobjID = 3.0; \n\tvec2 cone = vec2( fCone( p - vec3( 0.0, -2.25, 0.0 ), 0.15, 0.5 ), objID );\n\t\n\tobjID = 2.0;\n\tvec3 p0 = rotateY( p, iTime ); \n\tvec2 cube1 =                                 \n\t          vec2( diamondCube( p0 - vec3( 0.0, -1.34, 0.0 ), 0.25 ), objID );\n\n\tvec3 p1 = rotateY( p, iTime * -0.9 );\n\tvec2 cube2 =                              \n\t          vec2( diamondCube( p1 - vec3( 0.0, -0.555, 0.0 ), 0.2 ), objID );\t\n\t\n\tvec3 p2 = rotateY( p, iTime * 0.8 );\n\tvec2 cube3 = \n\t          vec2( diamondCube( p2 - vec3( 0.0, 0.06, 0.0 ), 0.15 ), objID );\t\n\t\n\tvec3 p3 = rotateY( p, iTime * -0.7 );\n\tvec2 cube4 =                                 \n\t           vec2( diamondCube( p3 - vec3( 0.0, 0.496, 0.0 ), 0.1 ), objID );\t\n\t\n\tvec3 p4 = rotateY( p, iTime * 0.6 );\n\tvec2 cube5 =\n\t          vec2( diamondCube( p4 - vec3( 0.0, 0.75, 0.0 ), 0.05 ), objID );\t\n\n\t//---------------------------------------------------\n\t\n\t// Move x-position closer to original origin to position torus.\n\t// p.x is now at -3.25\n\tp.x += 1.25;\n\tobjID = 3.0;\n\tvec2 hoop = vec2( fTorus( p.yzx, 0.1, 3.5 ), objID );\n\t\n\t// Move x-position beyond original origin to squeeze the sphere into more\n\t// of an ellipsoid shape. p.x is now at +0.35.\n\tp.x += 3.6;\n\tobjID = 4.0;\n\tvec2 ball = vec2( fSphere( p, 1.05 ), objID );\n\t\n\tobjID = 3.0;\n\tvec2 ball2 = vec2( fSphere( p - vec3( 0.0, 3.0, 0.0 ), 0.7 ), objID );\n\t\n\t// Move first ring of coins out from center.\n\t// x-position is now at -2.0;\n\tp.x -= 2.35;\n\tvec3 p5 = rotateY( p, iTime * 4.0 );\n\tobjID = 2.0;\n\tvec2 coin1 = vec2( \n\t         fCylinder( p5.yzx - vec3( -1.95, 0.0, 0.0 ), 0.3, 0.02 ), objID );\n\t\t\n\t// Move second ring of coins farther out and offset from first ring.\n\t// x-position is now at -3.25;\n\tp.x -= 1.25;\n\tp.z -= 0.75;\n\tobjID = 3.0;\n\tvec3 p6 = rotateY( p, iTime * 3.0 );\n\tvec2 coin2 = vec2( \n\t         fCylinder( p6.yzx - vec3( -1.95, 0.0, 0.0 ), 0.3, 0.02 ), objID );\n\t\t\n\t//---------------------------------------------------\n\t\n\tvec2 closest = ground.s < cone.s ? ground : cone;\n\tclosest = closest.s < cube1.s ? closest : cube1;\n\tclosest = closest.s < cube2.s ? closest : cube2;\n\tclosest = closest.s < cube3.s ? closest : cube3;\n\tclosest = closest.s < cube4.s ? closest : cube4;\n\tclosest = closest.s < cube5.s ? closest : cube5;\n\tclosest = closest.s < hoop.s ? closest : hoop;\n\tclosest = closest.s < ball.s ? closest : ball;\n\tclosest = closest.s < ball2.s ? closest : ball2;\n\tclosest = closest.s < coin1.s ? closest : coin1;\n\tclosest = closest.s < coin2.s ? closest : coin2;\n\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  \n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// \"k\" is a fade-off factor to control how soft the shadows are. Smaller values \n// give a softer penumbra, and larger values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    const int maxIterationsShad = 24;     \n    vec3 rayDir = ( lightPos - rayOrig );\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( maxIterationsShad );\n    \n    rayDir /= end;\n\n    for ( int i = 0; i < maxIterationsShad; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n        dist += min( h, stepDist * 2.0 ); \n        \n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // Added 0.5 to the final shade value, which lightens the shadow a bit. \n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID )\n{    \n    vec3 col = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t    if ( fract( dot( floor( p * 2.0 ), vec3( 0.5 ) ) ) > 0.001 ) \n\t    {\n\t    \tcol = vec3( 0.0 );\n\t    }\n\t}\n\telse if ( objNum == 2.0 ) // cubes\n\t{\n\t\tcol = vec3( 1.0, 0.9, 0.5 );\n\t}\n\telse if ( objNum == 3.0 ) // rings\n\t{\n\t\tcol = vec3( 0.9, 0.9, 1.0 );\n\t}\n\telse if ( objNum == 4.0 ) // ball\n\t{\n\t\tcol = vec3( 1.0, 1.0, 0.7 );\n\t}\n\n    return col;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID )                                                               \n{    \n    // Light direction vector.\n    vec3 lDir = LIGHT_POS - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor( sp, distID );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + vec3( 1.0, 0.6, 0.2 ) *\n                                                          spec * 2.0 ) * atten;  \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n \tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n    vec3 lightPos = LIGHT_POS;\n\tvec3 sceneColor = vec3( 0.0 );\n\t   \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = vec3( 0.0 );\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( FAR * 0.9, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID ) * 0.35;\n\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    sceneColor *= fog;\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n    \n}\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// \thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n\t}\n\telse\n\t{\n\t\tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange;\n\t}\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = 0.5 * ( sin( iTime * 0.1 ) + 1.0 );\n\t}\n\telse\n\t{\n        ang = ( 2.0 * iMouse.y - iResolution.y * 1.5 ) * rotRange;\n\t}\n\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n//------------------------------------------------------------------------------\n// The following code is excerpted from:\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n//------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}