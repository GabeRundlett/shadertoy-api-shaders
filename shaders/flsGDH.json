{
    "Shader": {
        "info": {
            "date": "1622014331",
            "description": "exploring domain repetition",
            "flags": 0,
            "hasliked": 0,
            "id": "flsGDH",
            "likes": 27,
            "name": "\"Closest Neighbour\" Boundaries",
            "published": 3,
            "tags": [
                "domainrepetition",
                "closest",
                "neighbour",
                "domainrep"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 871
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is further explorations in how domain repetition works\n//and under what scenarios a naively domain repeated object might fail to be an SDF\n\n//this is a visualization of how the closest neighbour SDF inside a domain changes as those SDFs change\n//if we imagine a point within a domain, we can ask \"what is the closest neighbouring SDF?\"\n//in this case, we have 6 boxes in the immediate neighbouring domains.\n//as we move a point within the central domain around, the closest box to that point will change\n//we can visualze the boundaries at which a point stops being closest to one box, and starts being closest to a different box\n//inside the middle box of this shader is such a visualization\n//as the dimensions of the neighbouring boxes change, the shape of the boundaries change.\n\n//when the boxes are perfect cubes, we can model the boundaries with\n//the \"face\" function in this shader: https://www.shadertoy.com/view/Wl3fD2\n//see also the youtube video: https://youtu.be/I8fmkLK1OKg\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p)-d;\n    return length(max(p,0.)) + min(0.,max(max(p.x,p.y),p.z));\n}\n\nfloat obj(vec3 p) {\n    return box(p, vec3(.25,.25,.25+sin(iTime)*.24)) - .01;\n}\n\nbool sort(inout float a, inout float b) {\n    if (b < a) {\n        float tmp = a;\n        a = b; b = tmp;\n        return true;\n    }\n    return false;\n}\n\nint gid;\nfloat scene(vec3 p) {\n    float u = obj(p - vec3(0,0,1));\n    float d = obj(p - vec3(0,0,-1));\n    float e = obj(p - vec3(0,1,0));\n    float w = obj(p - vec3(0,-1,0));\n    float n = obj(p - vec3(1,0,0));\n    float s = obj(p - vec3(-1,0,0));\n    \n    gid = 0;\n    if (sort(u,d)) gid = 1;\n    sort(d,e);\n    sort(e,w);\n    sort(w,n);\n    sort(n,s);\n    \n    if (sort(u,d)) gid = 2;\n    sort(d,e);\n    sort(e,w);\n    sort(w,n);\n    \n    if (sort(u,d)) gid = 3;\n    sort(d,e);\n    sort(e,w);\n    \n    if (sort(u,d)) gid = 4;\n    sort(d,e);\n    \n    if (sort(u,d)) gid = 5;\n    \n    float closest = u;\n    float secondclosest = d;\n    float boundary = (abs(closest-secondclosest)-.01)/2.;\n    boundary = max(boundary, box(p, vec3(.5)));\n    \n    return min(closest,boundary);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.0001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 palette( float t )\n{\n    return cos(t+vec3(0,1.8,3.2))*.4+.6;\n}\n\nvec3 shade(vec3 p, vec3 cam) {\n    float fid = float(gid);\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    float fact = length(sin(r*3.5)*.5+.5)/sqrt(3.0);\n    return palette(fid)*(fact*.5 + pow(fact,5.)*4.*fres);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 cam = normalize(vec3(.8,uv));\n    vec3 init = vec3(-2.5,0,0);\n    float yrot = .2;\n    float zrot = iTime/2.;\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    \n    \n    vec3 col = vec3(0);\n    float atten = .7;\n    float k = 1.;\n    for (int i = 0; i < 200; i++ ) {\n        float dist = scene(p);\n        p += cam*dist*k;\n        if (dist*dist < 1e-7) {\n            col += shade(p, cam)*atten;\n            atten *= .7;\n            p += cam*.005;\n            k = sign(scene(p));\n        }\n        if(distance(p,init)>100.)break;\n    }\n    vec3 spec = shade(p, cam);\n    fragColor = vec4(sqrt(smoothstep(0.,1.,col)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}