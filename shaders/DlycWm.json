{
    "Shader": {
        "info": {
            "date": "1700297869",
            "description": "This is a set of transitions that are manipulations of planes in space. It's a forced perspective out of laziness and because it looks a little better somehow.",
            "flags": 0,
            "hasliked": 0,
            "id": "DlycWm",
            "likes": 7,
            "name": "Plane Transition Collection",
            "published": 3,
            "tags": [
                "transitioncollection"
            ],
            "usePreview": 0,
            "username": "wilkie",
            "viewed": 243
        },
        "renderpass": [
            {
                "code": "// License: MIT\n\nconst float mirror_intensity = 0.25;\n\nconst float stack_rotate_time = 0.2;\nconst float stack_lift_time = 0.1;\nconst float stack_shuffle_time = 0.1;\nconst float stack_rotate = 0.385;\nconst float stack_lift_amount = 0.65;\n\nvec4 box(sampler2D tx, vec2 pos, vec2 size, vec2 uv, float rot, float dy) {\n    float z = 0.25;\n    size.x *= abs(rot - 1.0);\n    float arot = 1.0 - abs(rot - 1.0);\n    float dir = (2.0 * step(rot, 1.0)) - 1.0;\n    float amtx = (uv.x - pos.x + size.x / 2.0) / size.x;\n    amtx = (abs(step(1.0, rot) - amtx) - 0.5) * 2.0;\n    float amty = z * size.y * arot * amtx;\n    size.y += amty;\n    pos.y += dy + dy * amty * 1.6;\n    vec2 uvBox = (uv - pos + size / 2.0) / size;\n    vec4 result = vec4(texture(tx, uvBox).rgb, 1.0);\n    result *= step(0.0, uvBox.x) * step(uvBox.x, 1.0);\n    result *= step(uvBox.y, 1.0) * step(0.0, uvBox.y);\n    float d = clamp(size.x + 0.25, 0.0, 1.0);\n    result *= vec4(d, d, d, 1.0);\n    \n    pos.y -= dy * 2.0;\n    uvBox = (uv - pos + size / 2.0) / size;\n    vec4 mirror = vec4(texture(tx, abs(uvBox)).rgb, 1.0);\n    mirror *= step(0.0, uvBox.x) * step(uvBox.x, 1.0);\n    mirror *= step(uvBox.y, 0.0) * step(-1.0, uvBox.y);\n    uvBox = (1.0 - abs(uvBox));\n    mirror *= vec4(uvBox.y, uvBox.y, uvBox.y, 1.0);\n    mirror *= vec4(d, d, d, 1.0) * mirror_intensity;\n    return result + mirror;\n}\n\n#define PI 3.1415926\n\nvec4 rotate_out(vec4 result, float time, vec2 uv) {\n    time *= 1.5;\n    vec2 size = vec2(1.0 * abs(cos(time * PI)), 1.0 * abs(cos(time * PI)));\n    vec2 pos = vec2(0.5, 0.5);\n    float rot = 1.0 - abs(cos(time * PI));\n    pos.x += rot / 2.0;\n\n    vec4 first = box(iChannel1, pos, size, uv, rot, 0.0);\n    result = result * (1.0 - min(first.a, 1.0));\n    result += first * step(2.0, mod(time * 2.0 + 1.0, 4.0));\n    result += box(iChannel0, pos, size, uv, rot, 0.0) * step(mod(time * 2.0 + 1.0, 4.0), 2.0);\n    return result;\n}\n\nvec4 rotate_in(vec4 result, float time, vec2 uv) {\n    time *= 2.0;\n    \n    // The amount to pull it back before rotating the next plane in\n    float amt = 0.385;\n    float rot = abs(mod(time * 2.0, 2.0) - 1.0) * amt * 2.0;\n    \n    // Scene 1 rotation\n    float rot1 = min(rot, amt);\n    vec2 pos = vec2(0.5, 0.5);\n    pos.x += rot1 / 2.0;\n    vec2 size = vec2(1.0 - rot1, 1.0 - rot1);\n    vec4 first = box(iChannel1, pos, size, uv, rot1, 0.0);\n    \n    // Scene 2 rotation\n    float rot2 = max(rot + 2.0 * (1.0 - amt), 2.0 - amt);\n    pos = vec2(0.5, 0.5);\n    pos.x -= (2.0 - rot2) / 2.0;\n    size = vec2(abs(1.0 - rot2), abs(1.0 - rot2));\n    vec4 second = box(iChannel0, pos, size, uv, rot2, 0.0);\n    \n    // Form the result\n    result = result * (1.0 - min(first.a + second.a, 1.0));\n    \n    // Position first over second if rotation is in an early position\n    result += (first + second * (1.0 - first.a)) * step(rot, amt);\n    \n    // Position second over first if rotation is in a later position\n    result += (second + first * (1.0 - second.a)) * step(amt, rot);\n        \n    return result;\n}\n\nvec4 rotate_stack(vec4 result, float time, vec2 uv) {\n    // The amount to pull it back before rotating the next plane in\n    float amt = stack_rotate_time;\n    float lift = stack_lift_time;\n    float shift = stack_shuffle_time;\n    \n    float rot_amt = stack_rotate;\n    float lift_y = stack_lift_amount;\n    \n    float period = amt * 2.0 + shift + lift * 2.0;\n    \n    float t0 = mod(time * 2.0, period * 2.0);\n    float t = mod(t0, period);\n    \n    // Scene 1 rotation\n    float rot = ((min(t, amt) / amt) * rot_amt) * step(t, amt + lift * 2.0 + shift);\n    rot += max(0.0, (amt - (t - amt - lift * 2.0 - shift)) / amt * rot_amt) * step(amt + lift * 2.0 + shift, t);\n    \n    t -= amt;\n    \n    // Lifting\n    float lift1 = step(0.0, t) * (min(t, lift) / lift * lift_y);\n    \n    // Shift time\n    float t2 = t - lift;\n    \n    // (Working ahead... putting it back down)\n    float t3 = t - lift - shift;\n    vec2 pos = vec2(0.5, 0.5);\n    pos.x += step(0.0, t2) * (min(t2, shift) / shift * 0.05);\n    pos.y += step(0.0, t2) * (min(t2, shift) / shift * 0.05);\n    lift1 -= step(0.0, t3) * (min(t3, lift) / lift * lift_y);\n    vec2 size = vec2(1.0 - rot, 1.0 - rot) * (1.0 - step(0.0, t2) * (min(t2, shift) / shift * 0.1));\n    vec4 first = box(iChannel0, pos, size, uv, rot, lift1) * step(t0, period);\n    first += box(iChannel1, pos, size, uv, rot, lift1) * step(period, t0);\n    \n    t -= lift;\n    float swapped = t;\n    \n    // Scene 2 rotation\n    pos = vec2(0.5, 0.5);\n    pos.x += 0.05 - step(0.0, t) * (min(t, shift) / shift * 0.05);\n    pos.y += 0.05 - step(0.0, t) * (min(t, shift) / shift * 0.05);\n    size = vec2(1.0 - rot, 1.0 - rot) * (0.9 + step(0.0, t) * (min(t, shift) / shift * 0.1));\n    vec4 second = box(iChannel1, pos, size, uv, rot, 0.0) * step(t0, period);\n    second += box(iChannel0, pos, size, uv, rot, 0.0) * step(period, t0);\n    \n    // Form the result    \n    // Position first over second if rotation is in an early position\n    result = result * (1.0 - min(first.a + second.a, 1.0));\n    result += (first + second * (1.0 - first.a)) * step(swapped, 0.0);\n    \n    // Position second over first if rotation is in a later position\n    result += (second + first * (1.0 - second.a)) * step(0.0, swapped);\n        \n    return result;\n}\n\nvec4 rotate(vec4 result, float time, vec2 uv) {\n    time *= 2.0;\n    vec2 pos = vec2(0.5, 0.5);\n    float rot = mod(time * 2.0, 2.0);\n    vec2 size = 0.7 + 0.3 * vec2(1.0 * abs(cos(PI * time)));\n\n    vec4 first = box(iChannel1, pos, size, uv, rot, 0.0);\n    result = result * (1.0 - min(first.a, 1.0));\n    result += first * step(2.0, mod(time * 2.0 + 1.0, 4.0));\n    result += box(iChannel0, pos, size, uv, rot, 0.0) * step(mod(time * 2.0 + 1.0, 4.0), 2.0);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = iTime * 0.25;\n\n    vec4 result = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n    \n    float stack_period = stack_rotate_time * 2.0 + stack_shuffle_time + stack_lift_time * 2.0;\n    \n    time = mod(time, (2.0 / 1.5) + 0.5 + 1.0 + stack_period);\n    \n    // Output to screen (too lazy to step the ifs, lol)\n    if (time < 2.0 / 1.5) {\n        fragColor = rotate_out(result, time, uv);\n    }\n    else {\n        time -= 2.0 / 1.5;\n        if (time < 0.5) {\n            fragColor = rotate_in(result, time, uv);\n        }\n        else {\n            time -= 0.5;\n            if (time < 1.0) {\n                fragColor = rotate(result, time, uv);\n            }\n            else {\n                time -= 1.0;\n                fragColor = rotate_stack(result, time, uv);                \n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}