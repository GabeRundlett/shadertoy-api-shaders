{
    "Shader": {
        "info": {
            "date": "1527632244",
            "description": "Figuring out this audio synthesis stuff. ",
            "flags": 9,
            "hasliked": 0,
            "id": "ldtfDs",
            "likes": 10,
            "name": "Audio Synthesis Jam",
            "published": 3,
            "tags": [
                "simple",
                "sound"
            ],
            "usePreview": 0,
            "username": "stellartux",
            "viewed": 751
        },
        "renderpass": [
            {
                "code": "vec4 imageStuff(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord/iResolution.xy) - .5);\n\tconst float off = sqrt(2.);\n    // Time varying pixel color\n    vec3 col = vec3(noise(floor(iTime * uv.x)), noise(floor(iTime * uv.y + off*sign(uv.x))), noise(floor(iTime + off * sign(uv.y)) ));\n\n    // Output to screen\n    return vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = imageStuff(fragColor, fragCoord);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) \n{\n\tfragColor = imageStuff(fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// unlicense\n\nconst float TEMPO = 120.;\nconst float TAU = 6.283185307179586476925286766559;\nconst float INVROOT2 = inversesqrt(2.);\n\n// melodies stored in arrays\nconst int melodyLength = 16;\nconst int melody[melodyLength] = int[](60, 67, 64, 67, 69, 65, 67, 60,\n                                 55, 67, 65, 67, 60, 57, 64, 55);\nconst int basslineLength = 4;\nconst int bassline[basslineLength] = int[](36, 43, 45, 41);\n\n// envelope synthesis\nfloat impulse(float time, float k){\n    float h = k*fract(time);\n    return h*exp(1.0-h);\n}\nfloat envelope (float time) {\n    return clamp(impulse(time, 20.), 0., 1.);\n}       \nfloat envelope (float time, float delay) {\n    return clamp(impulse(fract(time + delay), 20.), 0., 1.);\n}         \n\n// utility functions for \n// converting midi notes to frequencies\nfloat midiToFreq (float midiNote) {\n\treturn 13.75 * exp2((midiNote - 9.) / 12.);\n}\nfloat midiToFreq (int midiNote) {\n    // I don't know if I'm too lazy or not lazy enough\n\treturn midiToFreq(float(midiNote));\n}\n// and normalising phase angles\nfloat normPhase(float time, float freq) {\n    return fract(time * freq);\n}\nfloat normPhase(float time, float freq, float delay) {\n    return fract(time * freq + delay);\n}\n\n// waveform synthesis\nfloat sinewave (float time, int note, float delay) {\n\treturn sin(TAU*(midiToFreq(note)*time)) * envelope(time, delay);\n}\nfloat sinewave (float time, int note) {\n\treturn sinewave(time,note,0.);\n}\n\nfloat squarewave (float time, int note, float delay) {\n\treturn step(normPhase(time, midiToFreq(note)), .5) * envelope(time, delay) * INVROOT2;\n}\nfloat squarewave (float time, int note) {return squarewave(time, note, 0.);}\n\nfloat trianglewave (float time, int note, float delay) {\n    float angle = normPhase(time, midiToFreq(note), delay + .25);\n    if (angle < .5) return mix(1.,-1., angle * 2.) * envelope(time, delay);\n    else return mix(-1., 1., (angle - .5) * 2.) * envelope(time, delay);\n}   \n\n// play the notes on each instrument\nfloat mainMelody(float time){\n    if (time < .0) {return 0.;}\n    else {\t\n        float beat = time * TEMPO / 60.;\n        float signal = sinewave(time, melody[int(beat) % melodyLength + 1]);\n        signal += sinewave(time, melody[int(beat) % melodyLength], .375);\n        signal += sinewave(time, melody[int(beat) % melodyLength], .75);\n        signal /= 3.;\n        return signal;\n    };\n}  \nfloat bass(float time) {\n    if (time < .0) {return 0.;}\n    else {\t\n        float signal = 0.;\n        float beat = time * TEMPO / 60.;\n        if (bassline[int(beat) % basslineLength] > 0) {\n            signal = squarewave(time, bassline[int(beat / 8.) % basslineLength], .75);\n        }       \n       \tsignal = smoothstep(-1., 1., signal);\n        signal *= .3;\n        return signal;\n    }\n}\nfloat triangles(float time) {\n    if (time < .374) return 0.;\n    else {\n        float signal = 0.;\n        int beat = int(time * TEMPO / 30.);\n        // work out the notes procedurally instead of\n        // using arrays like the other instruments\n        bool cb = (beat % 32) <= 16;\n        bool ed = (beat % 32) <= 24;\n        signal += trianglewave(time, cb ? 60 : 59, 0.);\n        signal += trianglewave(time, ed ? 64 : 62, 0.);\n        signal += trianglewave(time, cb ? 60 : 59, 0.375);\n        signal += trianglewave(time, ed ? 64 : 62, 0.375);\n        signal /= 4.;\n        return signal;\n    }\n}\nfloat hihats(float time) {\n    if (time < .0) return 0.;\n    float beat = time * TEMPO / 60.;\n    const float env = 30.;\n    float signal = noise(beat) * clamp(impulse(beat, env), 0., 1.);\n    signal += noise(beat) * clamp(impulse(beat + .25, env), 0., .3);\n    signal += noise(beat) * clamp(impulse(beat + .5, env), 0., .3);\n    signal += noise(beat) * clamp(impulse(beat + .75, env), 0., .3);\n    signal /= 3.;\n\treturn signal;\n}\n\n// put all the instruments together\nvec2 mainSound( in int samp,float time) {\n    time -= .25;\n    float signal = hihats(time);\n    time -= 2.;\n    signal += mainMelody(time);\n    time -= 8.;\n    signal += triangles(time);\n    time -= 8.;\n\tsignal += bass(time);\n    signal /= 4.;\n    return vec2( signal);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "float rand(float time) {return fract(sin(time) * 43758.5453123);}\nfloat noise(float time) {return rand(rand(time));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}