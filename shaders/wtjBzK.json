{
    "Shader": {
        "info": {
            "date": "1599409560",
            "description": "Version of [url]https://www.shadertoy.com/view/WllfDf[/url] with different constraints.\n\nPress SPACE to reset simulation.\nCLICK to attract end of pendulum.",
            "flags": 48,
            "hasliked": 0,
            "id": "wtjBzK",
            "likes": 30,
            "name": "Spring simulation",
            "published": 3,
            "tags": [
                "simulation",
                "interactive",
                "physics",
                "pendulum",
                "spring",
                "euler"
            ],
            "usePreview": 0,
            "username": "zduny",
            "viewed": 891
        },
        "renderpass": [
            {
                "code": "void drawSpring(in vec2 fragCoord, in vec2 p0, in vec2 p1, in vec2 thickness,\n                in int loops, in vec4 color, inout vec4 outputColor) {\n  if (sdSegment(fragCoord, p0, p1) > thickness.x) {\n    return;\n  }\n\n  vec2 d = p1 - p0;\n  if (length(d) < 0.001) {\n    return;\n  }\n\n  vec2 dir = normalize(d);\n  vec2 per = vec2(dir.y, -dir.x);\n\n  vec2 st = d / float(loops * 2);\n  vec2 last = p0 + per * thickness.x / 2.0 + st / 2.0;\n  vec2 sw = -thickness.x * per;\n  float th = thickness.y;\n\n  drawSegment(fragCoord, p0, last, th, color, outputColor);\n\n  for (int i = 0; i < loops * 2 - 1; i++) {\n    vec2 next = last + st + sw;\n    sw = -sw;\n    drawSegment(fragCoord, last, next, th, color, outputColor);\n    last = next;\n  }\n\n  drawSegment(fragCoord, last, p1, th, color, outputColor);\n}\n\nvoid drawPendulum(in vec2 fragCoord, inout vec4 outColor) {\n  float totalMass = 0.0;\n  for (int i = 0; i < rods; i++) {\n    totalMass += masses[i];\n  }\n\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  vec2 previous = anchor;\n  for (int i = 0; i <= rods; i++) {\n    vec2 position;\n    if (i < rods) {\n      position = anchor + ballData(STORAGE, i).xy * scale;\n      drawSpring(\n          fragCoord, previous, position,\n          vec2(0.8 * scale, clamp(0.5 * stiffnesses[i], 0.05, 0.12) * scale), 9,\n          vec4(vec3(0.0), 1.0), outColor);\n    }\n\n    float radius = i == 0 ? 0.05 : 0.4 * pow(masses[i - 1] / totalMass, 0.6);\n    vec3 color = i == 0 || black ? vec3(0.0) : palette[(i - 1) % colors];\n\n    drawDisk(fragCoord, previous, (radius + 0.1) * scale, vec4(vec3(0.0), 1.0),\n             outColor);\n    drawDisk(fragCoord, previous, radius * scale, vec4(color, 1.0), outColor);\n\n    previous = position;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  fragColor = texture(iChannel1, uv);\n\n  drawPendulum(fragCoord, fragColor);\n\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int rods = 3;\nconst vec2 center = vec2(0.0, 5.3);\nconst float[] lengths = float[](3.0, 3.0, 3.0, 2.5, 3.0, 4.0);\nconst float[] angles = float[](-70.0, -30.0, 70.0, 0.0, 0.0, 0.0);\nconst float[] masses = float[](1.0, 1.0, 2.0, 1.0, 1.0, 1.0);\nconst float[] stiffnesses = float[](0.08, 0.08, 0.08, 0.08, 0.08, 0.08);\nconst float[] dampings = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\nconst bool continuous = true;\nconst bool black = false;\nconst int colors = 6;\nconst vec3[] palette =\n    vec3[](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0),\n           vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0));\nconst float fade = 0.03;\nconst int iterations = 20;\nconst float damping = 1.0;\nconst vec2 g = vec2(0.0, -20.0);\n\n#define STORAGE iChannel0\nconst ivec2 resolutionDataLocation = ivec2(0, 2);\n\n#define KEY_SPACE 32\nbool isKeyPressed(in sampler2D keyboard, in int keyCode) {\n  return texelFetch(keyboard, ivec2(keyCode, 1), 0).x > 0.0;\n}\n\nvec4 ballData(in sampler2D storage, in int index) {\n  return texelFetch(storage, ivec2(index, 0), 0);\n}\n\nvec2 previousBallPosition(in sampler2D storage, int index) {\n  return texelFetch(storage, ivec2(index, 1), 0).xy;\n}\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvoid drawDisk(in vec2 fragmentCoordinates, in vec2 center, in float radius,\n              in vec4 color, inout vec4 outputColor) {\n  float d = distance(fragmentCoordinates, center);\n  float a = 1.0 - clamp(d - radius + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define KEYBOARD iChannel1\n\nconst float pi = 3.1416;\n\nbool saveResolutionData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == resolutionDataLocation) {\n    vec4 previousResolutionData = texelFetch(STORAGE, fragCoord, 0);\n    vec2 oldResolution = previousResolutionData.xy;\n    fragColor = vec4(iResolution.xy, oldResolution);\n\n    return true;\n  }\n\n  return false;\n}\n\nbool isMousePressed() { return iMouse.z > 0.0; }\n\nvoid euler(inout vec4 current, in float timeDelta) {\n  current.zw += g * timeDelta;\n  current.xy += current.zw * timeDelta;\n}\n\nvec2 hookesLaw(in vec2 anchorPosition, in vec2 massPosition,\n               in float springLength, float stiffness) {\n  vec2 toAnchor = anchorPosition - massPosition;\n  if (length(toAnchor) < 0.0001) {\n    return vec2(0.0);\n  }\n\n  float x = length(toAnchor) - springLength;\n\n  return stiffness * x * normalize(toAnchor);\n}\n\nbool initialization(in ivec2 fragCoord, out vec4 fragColor) {\n  if (iFrame > 0 && !isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    return false;\n  }\n\n  if (fragCoord.x > rods || fragCoord.y > 1) {\n    return false;\n  }\n\n  vec2 position = vec2(0.0);\n  float angle = pi / 2.0;\n  for (int i = 0; i < rods; i++) {\n    angle += angles[i] * pi / 180.0;\n    position += vec2(sin(angle), cos(angle)) * lengths[i];\n    vec4 data = vec4(position, vec2(0.0));\n    if (fragCoord.x == i) {\n      fragColor = data;\n    }\n  }\n\n  return true;\n}\n\nbool simulation(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord.x > rods || fragCoord.y > 1) {\n    return false;\n  }\n\n  if (fragCoord.y == 1) {\n    fragColor = ballData(STORAGE, fragCoord.x);\n    return true;\n  }\n\n  vec4[rods] data;\n  for (int i = 0; i < rods; i++) {\n    data[i] = ballData(STORAGE, i);\n  }\n\n  for (int s = 0; s < iterations; s++) {\n    float timeDelta = min(iTimeDelta, 0.1) / float(iterations);\n\n    for (int i = 0; i < rods; i++) {\n      euler(data[i], timeDelta);\n    }\n\n    // Constraints\n    for (int i = 0; i < rods; i++) {\n      vec4 previous = i > 0 ? data[i - 1] : vec4(0.0);\n\n      // Spring\n      vec2 force =\n          hookesLaw(previous.xy, data[i].xy, lengths[i], stiffnesses[i]);\n      vec2 impulse = (force / masses[i]);\n      data[i].zw += impulse;\n\n      if (i > 0) {\n        data[i - 1].zw -= (force / masses[i - 1]);\n      }\n\n      // Damper\n      vec2 toAnchor = previous.xy - data[i].xy;\n      if (length(toAnchor) > 0.0001) {\n        toAnchor = normalize(toAnchor);\n        vec2 velocityDelta = previous.zw - data[i].zw;\n        float relativeVelocity = dot(velocityDelta, toAnchor);\n        vec2 damping = dampings[i] * relativeVelocity * toAnchor;\n        data[i].zw += damping;\n        if (i > 0) {\n          data[i - 1].zw -= damping;\n        }\n      }\n    }\n  }\n\n  float damp = damping;\n  if (isMousePressed()) {\n    float scale = iResolution.y / 20.0;\n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.0) / scale - center;\n    vec2 toMouse = mouse - data[rods - 1].xy;\n    float magnitude = length(toMouse);\n    if (magnitude > 0.1) {\n      data[rods - 1].zw += normalize(toMouse) * magnitude;\n      damp = 0.96;\n    }\n  }\n\n  if (damp < 1.0) {\n    for (int i = 0; i < rods; i++) {\n      data[i].zw *= damp;\n    }\n  }\n\n  int i = fragCoord.x;\n  fragColor = data[i];\n\n  return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  ivec2 iFragCoord = ivec2(fragCoord);\n\n  if (saveResolutionData(iFragCoord, fragColor)) {\n    return;\n  }\n\n  if (initialization(iFragCoord, fragColor)) {\n    return;\n  }\n\n  simulation(iFragCoord, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define KEYBOARD iChannel2\n\nbool resolutionChanged() {\n  vec4 resolutionData = texelFetch(STORAGE, resolutionDataLocation, 0);\n  return resolutionData.xy != resolutionData.zw;\n}\n\nvoid drawTrials(in vec2 fragCoord, inout vec4 outColor) {\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  for (int i = 0; i < rods; i++) {\n    vec2 position = anchor + ballData(STORAGE, i).xy * scale;\n    vec3 color = black ? vec3(0.0) : palette[i % colors];\n    if (continuous) {\n      vec2 previous = anchor + previousBallPosition(STORAGE, i).xy * scale;\n      drawSegment(fragCoord, position, previous, 0.14 * pow(scale, 0.7),\n                  vec4(color, 1.0), outColor);\n    } else {\n      drawDisk(fragCoord, position, 0.11 * pow(scale, 0.7), vec4(color, 1.0),\n               outColor);\n    }\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec4 background = vec4(vec3(0.85), 1.0);\n  if (iFrame == 0 || resolutionChanged() || isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    fragColor = background;\n  } else {\n    fragColor = mix(texture(iChannel1, uv), background, fade);\n  }\n  drawTrials(fragCoord, fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}