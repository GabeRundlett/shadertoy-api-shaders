{
    "Shader": {
        "info": {
            "date": "1531061288",
            "description": "A simple sample for sphere raycasting, using intersections instead of raymarching, with UV calc.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sVfWt",
            "likes": 4,
            "name": "Sphere raycast",
            "published": 3,
            "tags": [
                "ray",
                "sphere",
                "cast"
            ],
            "usePreview": 0,
            "username": "0xAA55",
            "viewed": 509
        },
        "renderpass": [
            {
                "code": "\nfloat PI = 3.1415926535897932384626;\nvec3 eyepos = vec3(0.0, 0.0, -5.0);\nvec2 yawpitch = vec2(0, 0);\n\nstruct sphere_t\n{\n    vec3 p;\n\tfloat radius;\n    mat3 r;\n};\n\nmat3 rot_x(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cang,-sang),\n        vec3(0.0, sang, cang)\n    );\n}\n\nmat3 rot_y(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, 0.0, sang),\n        vec3(  0.0, 1.0, 0.0),\n        vec3(-sang, 0.0, cang)\n    );\n}\n\nmat3 rot_z(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, sang, 0.0),\n        vec3(-sang, cang, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat3 rot_axis(vec3 v, float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3\n        (\n            (1.0 - cang) * v.x * v.x + cang,\n            (1.0 - cang) * v.x * v.y - sang * v.z,\n            (1.0 - cang) * v.x * v.z + sang * v.y\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.y * v.x + sang * v.z,\n            (1.0 - cang) * v.y * v.y + cang,\n            (1.0 - cang) * v.y * v.z - sang * v.x\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.z * v.x - sang * v.y,\n            (1.0 - cang) * v.z * v.y + sang * v.x,\n            (1.0 - cang) * v.z * v.z + cang\n        )\n    );\n}\n    \nmat3 rot_yaw_pitch_roll(vec3 ypr)\n{\n    return rot_z(ypr.z) * rot_x(ypr.y) * rot_y(ypr.x);\n}\n\nbool sphere_raycast(sphere_t sphere, vec3 orig, vec3 dir, out vec3 castpoint, out vec3 normal, out vec2 uv, out float intersect_dist, inout bool isfrominside)\n{\n\tvec3 o = orig;\n\tvec3 d = dir;\n\tvec3 c = sphere.p;\n\tfloat r = sphere.radius;\n    float rsq = r * r;\n    mat3 rot_mat = sphere.r;\n\t\n\tbool isinside = false;\n\n    vec3 o2c = c - o;\n    float distsq = dot(o2c, o2c);\n    float o2cdp = dot(o2c, d);\n    float c2raysq = max(0., distsq - o2cdp * o2cdp);\n    if(c2raysq > rsq) return false;\n    float foo = sqrt(rsq - c2raysq);\n    float dist1 = o2cdp - foo;\n    float dist2 = o2cdp + foo;\n    if(distsq < rsq) isinside = true;\n    if(isinside && !isfrominside) return false;\n\n    if(isfrominside) intersect_dist = dist2;\n    else intersect_dist = dist1;\n    \n    if(!isfrominside && intersect_dist < 0.) return false;\n    \n\tcastpoint = o + d * intersect_dist;\n    vec3 nor = (castpoint - c) / r;\n    normal = nor;\n    if(isfrominside) normal = -normal;\n\tisfrominside = isinside;\n\t\n    vec3 uvn = nor * rot_mat;\n\tuv.x = (atan(uvn.z, uvn.x) / PI) * .5 + .5;\n\tuv.y = (atan(uvn.y, length(uvn.xz)) / PI) * .5 + .5;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    vec2 mouse_rotation = ((iMouse.xy / iResolution.y) * 2. -1.) * PI;\n    if(length(iMouse.xy) < 0.000001) mouse_rotation = vec2(0);\n    \n\tvec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y);\n    mat3 viewmat = rot_yaw_pitch_roll(vec3(yawpitch, 0));\n    \n    mat3 rot_m = rot_yaw_pitch_roll(vec3(iTime * .3, iTime * .2, iTime * .1));\n    \n    vec3 ray = normalize(vec3(xy, 1)) * viewmat;\n    vec3 eyepos = vec3(0., 0., -5.) * viewmat;\n    \n    vec4 color = vec4(.2, .5, 1., 1.);\n    \n    vec3 castpnt, castnormal;\n    vec2 castuv;\n    float castdist;\n    bool isfrominside = false;\n\n    sphere_t sph = sphere_t(vec3(0, 0, 0), 1., rot_m);\n    \n    isfrominside = false;\n    // if(xy.x > 0.)isfrominside = true;\n    if(sphere_raycast(sph, eyepos, ray, castpnt, castnormal, castuv, castdist, isfrominside))\n\t{\n        // color = vec4(castdist - 4. + sin(iTime) * .5);\n        // color = vec4(castnormal * .5 + .5, 1.);\n        color = texture(iChannel0, castuv);\n        // color = texture(iChannel0, castnormal);\n        // color = vec4(castuv, 0., 1.);\n\t}\n    \n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}