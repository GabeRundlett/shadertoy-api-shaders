{
    "Shader": {
        "info": {
            "date": "1530609651",
            "description": "An implementation of xoroshiro64** (http://xoshiro.di.unimi.it/) that generates two uniform unsigned ints at the same time (instead of one in a non-SIMD implementation).",
            "flags": 0,
            "hasliked": 0,
            "id": "MdVBWK",
            "likes": 8,
            "name": "SIMD xoroshiro64**",
            "published": 3,
            "tags": [
                "noise",
                "random",
                "simd",
                "hash",
                "prng",
                "xoroshiro",
                "xoroshiro64"
            ],
            "usePreview": 0,
            "username": "VinceTavernier",
            "viewed": 752
        },
        "renderpass": [
            {
                "code": "// SIMD Implementation of xoroshiro64**\n//\n// next2 generates two uniformly distributed unsigned ints (32 bits),\n// with a 4*32 bits state. The state must be seeded so it is not\n// everywhere zero.\n//\n// Note that using correlated values as seeds (such as pixel coordinates)\n// results in correlated sequences in the generator output. This is why\n// seeds should be hashed before being used for a PRNG.\n//\n// Reference implementation by David Blackman and Sebastiano Vigna:\n//   http://xoshiro.di.unimi.it/\n//   http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n\nuvec2 rotl2(uvec2 x, int k) {\n    return (x << k) | (x >> (32 - k));\n}\n\n// Generates 2 uniform integers, updates the state given as input\nuvec2 next2(inout uvec4 s) {\n    uvec2 s0 = s.xz;\n    uvec2 s1 = s.yw;\n    uvec2 rs = rotl2(s0 * 0x9E3779BBu, 5) * 5u;\n    \n    s1 ^= s0;\n    s.xz = rotl2(s0, 26) ^ s1 ^ (s1 << 9);\n    s.yw = rotl2(s1, 13);\n    \n    return rs;\n}\n\n// Converts a vector of unsigned ints to floats in [0,1]\nvec4 tofloat(uvec4 u) {\n    //Slower, but generates all dyadic rationals of the form k / 2^-24 equally\n    //return vec4(u >> 8) * (1. / float(1u << 24));\n\n    //Faster, but only generates all dyadic rationals of the form k / 2^-23 equally\n    return uintBitsToFloat(0x7Fu << 23 | u >> 9) - 1.;\n}\n\n// Simple coordinate hash\nvoid hash(inout uvec4 x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = (x >> 16) ^ x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Seed the generator: this requires setting 4 uints\n    //  int pixel coords\n    uvec4 s = uvec4(fragCoord, 0, 0);\n    //  Enumerate all pixels in row-major order\n    s.x = 4u * (s.y * uint(iResolution.x) + s.x);\n    s.yzw = s.x + uvec3(1, 2, 3);\n    //  Hash coordinates used in the state\n    //  This is what decorrelates the different parts of the state\n    hash(s);\n\n    // Generate random numbers, output as float\n    fragColor = tofloat(uvec4(next2(s),next2(s)));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}