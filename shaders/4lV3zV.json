{
    "Shader": {
        "info": {
            "date": "1475645762",
            "description": "Directional light constrained to oriented box + other goodies.\nDrag mouse to rotate camera.\nThis to answer: http://computergraphics.stackexchange.com/questions/4067/special-directional-light-type\nBlog post coming soon!",
            "flags": 0,
            "hasliked": 0,
            "id": "4lV3zV",
            "likes": 11,
            "name": "Directional Light Box",
            "published": 3,
            "tags": [
                "light"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 1320
        },
        "renderpass": [
            {
                "code": "// for antialiasing. Does stratified/jittered sampling in a 4x4 grid\n#define SAMPLES_PER_PIXEL 16\n\n//----- light params\nvec3 lightAmbient\t\t\t\t= vec3(0.1,0.1,0.1);\n\nvec4 directionalLightRotationAxisAngle = vec4(normalize(vec3(0.2, 0.0, 1.0)), 2.15);\nvec3 directionalLightSourcePosition    = vec3(-1.5, 0.5, 0.0);\nvec2 directionalLightExtents           = vec2(1.0, 1.0);\nfloat directionalLightSoften           = 1.0/8.0;  //  How much the shadow softens over distance. Smaller value = sharper shadow.\nvec3 directionalLightColor             = vec3(1.0, 1.0, 1.0);\nvec2 directionalLightTextureMADD       = vec2(1.0, 0.4);\nfloat directionalLightUVDistanceScale  = 0.2; // How much the uv scales over distance. uv /= (1.0 + localPos.y * directionalLightUVDistanceScale);\nfloat directionalLightFalloff          = 0.08; // Controls light attenuation over distance. multiplied by distance^2\n\n//----- camera\n#define mouse (iMouse.xy / iResolution.xy)\nvec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n#define angleX (3.14 + 6.28 * mouse.x)\n#define angleY ((mouse.y * 3.90) - 0.4)\n#define cameraPos\t((vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 16.0)\n\n#define cameraFwd  (normalize(cameraAt - cameraPos))\n#define cameraLeft  (normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0))))\n#define cameraUp   (normalize(cross(cameraLeft, cameraFwd)))\n\nfloat cameraViewWidth\t= 6.0;\n#define cameraViewHeight\t(cameraViewWidth * iResolution.y / iResolution.x)\nfloat cameraDistance\t= 6.0;  // intuitively backwards!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\nfloat GetMode ()\n{\n    return iTime;\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in mat4 boxTransform, in mat4 inverseBoxTransform, in vec3 boxHalfSizes, out vec2 uv ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (boxTransform*vec4(rayDirection,0.0)).xyz;\n\tvec3 roo = (boxTransform*vec4(rayOrigin,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxHalfSizes;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\tvec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n\t// texture coordinates \n\tvec3 uaxis = vec3(1.0,0.0,0.0);\n\tvec3 vaxis = vec3(0.0,1.0,0.0);\n\t\n\tif (abs(normal.x) > 0.9)\n\t{\n\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\n\t}\n\telse if (abs(normal.y) > 0.9)\n\t{\n\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\t\t\n\t}\n    \n    vec3 relPoint = roo + rdd * timeNear;\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis) * 0.25,\n\t\tdot(relPoint, vaxis) * 0.25\n\t);    \n\n    // convert to ray space\n\t\n\tnormal = (inverseBoxTransform * vec4(normal,0.0)).xyz;\n\n\treturn vec4( timeNear, normal );\n}\n\n\n//============================================================\n// matrix functions from https://www.shadertoy.com/view/ld23DV\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n*/\n\n//============================================================\n// returns t and normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere, out vec2 uv)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    // NOTE: this will report a miss if ray starts inside the sphere.\n\tfloat collisionTime = -b - sqrt(discr);\n    \n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz);\n    \n    // texture coordinates are just the angular part of spherical coordiantes of normal\n    uv = vec2\n\t(\n\t\tatan(normal.z, normal.x),\n\t\tacos(normal.y)\n\t);\n    \n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\nvec4 GetDirectionalLightRotationAxisAngle ()\n{\n    // mode >= 5.0 starts moving and rotating light source\n    float time = GetMode() - 5.0;\n    time = max(time, 0.0);\n    \n    vec4 ret = directionalLightRotationAxisAngle;\n    ret.xyz += vec3(sin(time * 0.1), sin(time * 0.7), sin(time * 0.3));\n    ret.xyz = normalize(ret.xyz);\n    ret.w += time * 0.66;\n        \n    return ret;\n}\n\n//============================================================\nvec3 GetDirectionalLightSourcePosition ()\n{\n    // mode >= 5.0 starts moving and rotating light source\n    float time = GetMode() - 5.0;\n    time = max(time, 0.0);\n    float canMove = step(5.0, GetMode());\n\n    vec3 ret = directionalLightSourcePosition;\n    \n    ret += vec3(sin(time * 0.83) + 1.0 * canMove, sin(time * 1.1), sin(time * 0.1));\n    \n    return ret;\n}\n\n//============================================================\nmat4 GetDirectionalLightMatrixInverse ()\n{\n    vec4 rotAxisAngle = GetDirectionalLightRotationAxisAngle();\n    vec3 trans = GetDirectionalLightSourcePosition();\n\tmat4 rot = rotationAxisAngle(rotAxisAngle.xyz, rotAxisAngle.w );\n\tmat4 tra = translate( trans.x, trans.y, trans.z );\n\treturn tra * rot; \n}\n\n//============================================================\nmat4 GetDirectionalLightMatrix ()\n{\n    vec4 rotAxisAngle = GetDirectionalLightRotationAxisAngle();\n    vec3 trans = GetDirectionalLightSourcePosition();\n\tmat4 rot = rotationAxisAngle(rotAxisAngle.xyz, -rotAxisAngle.w );\n\tmat4 tra = translate( -trans.x, -trans.y, -trans.z );\n\treturn rot * tra;     \n}\n\n//============================================================\nvec3 WorldSpaceToDirectionalLightSpace (vec3 worldPosition)\n{\n\tvec3 localPosition = (GetDirectionalLightMatrix() * vec4(worldPosition, 1.0)).xyz; \n    localPosition.xz /= directionalLightExtents;\n    return localPosition;\n}\n\n//============================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec4 hitInfo, inout vec3 hitDiffuse, inout vec3 hitEmissive, inout vec4 hitSpecular, inout bool hitSomething, in bool shadowRay)\n{\n    vec4 info = hitInfo; \n    vec2 uv;\n    \n    // a blue box\n    mat4 rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), 1.0);\n    mat4 tra = translate( -0.5, 0.0, 0.0 );\n    mat4 txi = tra * rot; \n    mat4 txx = inverse( txi );    \n    info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(0.25), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitDiffuse = vec3(0.2, 0.2, 0.9);\n        hitEmissive = vec3(0.0);\n        hitSpecular = vec4(1.0, 1.0, 1.0, 10.0);\n        hitInfo = info;\n        hitSomething = true;\n    }\n    \n    // the floor\n    txi = translate( 0.0, -0.25, 0.0 );\n    txx = inverse( txi );    \n    info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(10.0, 0.01, 10.0), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        float checkerBoard = (mod(floor(uv.x * 10.0) + floor(uv.y * 10.0), 2.0) < 1.0 ? 1.0 : 0.4);        \n        hitDiffuse = vec3(checkerBoard);\n        hitEmissive = vec3(0.0);\n        hitSpecular = vec4(1.0, 1.0, 1.0, 1000.0);\n        hitInfo = info;\n        hitSomething = true;        \n    }    \n\n    // a red ball\n    info = RayIntersectSphere(rayPos, rayDir, vec4(0.5, 0.25, 0.25, 0.5), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitDiffuse = vec3(0.9, 0.2, 0.2);\n        hitEmissive = vec3(0.0);\n        hitSpecular = vec4(1.0, 1.0, 1.0, 100.0);\n        hitInfo = info;\n        hitSomething = true;        \n    }    \n    \n    // a green ball\n    info = RayIntersectSphere(rayPos, rayDir, vec4(-0.75, -0.125, -0.5, 0.125), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitDiffuse = vec3(0.2, 0.9, 0.2);\n        hitEmissive = vec3(0.0);\n        hitSpecular = vec4(1.0, 1.0, 1.0, 100.0);\n        hitInfo = info;\n        hitSomething = true;        \n    }     \n    \n    // a magenta box\n    rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), 1.9);\n    tra = translate( -0.1, -0.125, -1.0 );\n    txi = tra * rot; \n    txx = inverse( txi );    \n    info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(0.125), uv);\n    if (info.x > 0.0 && info.x < hitInfo.x) {\n        hitDiffuse = vec3(0.9, 0.2, 0.9);\n        hitEmissive = vec3(0.0);\n        hitSpecular = vec4(1.0, 1.0, 1.0, 10.0);\n        hitInfo = info;\n        hitSomething = true;\n    }    \n\n    // test the light source\n    txi = GetDirectionalLightMatrixInverse();\n    txx = GetDirectionalLightMatrix();        \n\tinfo = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(directionalLightExtents.x, 0.001, directionalLightExtents.y), uv);    \n    \n    // if ever a shadow ray hits the light source as the closest intersection, return a miss, so we don't get shadows from behind the light source!\n    if (shadowRay)\n    {\n        if (info.x > 0.0 && info.x < hitInfo.x) {\n            hitDiffuse = vec3(0.0);\n            hitEmissive = vec3(0.0);\n            hitSpecular = vec4(0.0);\n            hitInfo = vec4(1000.0, -cameraFwd);\n            hitSomething = false;        \n        }        \n    }\n    // else if we are not doing a shadow ray, and the mode is >= 4, then we want to show the light source as an object\n    else if (GetMode() >= 4.0)\n    {\n        if (info.x > 0.0 && info.x < hitInfo.x) {\n            vec3 lightpos = WorldSpaceToDirectionalLightSpace(rayPos+rayDir*info.x);\n            vec2 lightuv = vec2(-lightpos.x, lightpos.z);\n            hitDiffuse = vec3(0.0);\n            float backSideBlack = step(0.0, lightpos.y);            \n            hitEmissive = clamp((texture(iChannel0, lightuv*0.5+0.5).rgb * directionalLightTextureMADD.x + directionalLightTextureMADD.y) * backSideBlack, 0.0, 1.0);\n            hitSpecular = vec4(1.0, 1.0, 1.0, 1000.0);\n            hitInfo = info;\n            hitSomething = true;        \n        }    \n    }\n}\n\n//============================================================\nvec3 LightBoxShadow (in vec3 position) {\n    \n    float shade = 1.0;\n\n    // calculate whether or not the position is inside of the light box\n    vec2 uv;\n\tvec3 localPos;    \n    if (GetMode() >= 1.0)\n    {\n        // get position in light space and get uv\n        localPos = WorldSpaceToDirectionalLightSpace(position);\n    \tuv = localPos.xz;\n        uv.x *= -1.0;\n        \n        // apply scaling of uv over distance to fake projection\n        uv /= (1.0 + localPos.y * directionalLightUVDistanceScale);\n        \n        // set shade to 1 if it's inside, 0 if it's outside        \n    \tshade = float(abs(uv.x) < 1.0 && abs(uv.y) < 1.0);\n        \n        // if it is behind the light source, don't light it!\n        shade *= step(0.0, localPos.y);\n        \n        // apply distance attenuation\n        shade *=  1.0 - clamp(directionalLightFalloff * localPos.y * localPos.y, 0.0, 1.0);        \n    }\n    \n    // soften shadows over a distance\n\tif (GetMode() >= 2.0)\n    {\n        float softenDistance = clamp(localPos.y * directionalLightSoften, 0.01, 0.99);\n    \tfloat softenX = smoothstep(1.0, 1.0 - softenDistance, abs(uv.x));\n    \tfloat softenY = smoothstep(1.0, 1.0 - softenDistance, abs(uv.y));\n    \tshade = shade * softenX * softenY;\n    }\n    \n    // apply texture to light if we should!\n    if (GetMode() >= 3.0)\n    {\n        uv = uv*0.5+0.5;\n        return clamp((texture(iChannel0, uv).rgb * directionalLightTextureMADD.x + directionalLightTextureMADD.y) * shade, 0.0, 1.0);\n    }\n    \n    return vec3(shade);\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    mat4 dirLightMat = GetDirectionalLightMatrixInverse();\n    vec3 directionalLightReverseDir = -dirLightMat[1].xyz;\n    \n    vec3 finalColor = vec3(0.0);\n    for (int i = 1; i <= SAMPLES_PER_PIXEL; ++i)\n    {\n        // calculate stratified subpixel jitter in a 4x4 grid\n        float x = mod(float(i)-1.0, 4.0);\n        float y = mod(floor(float(i) / 4.0), 4.0);\n        vec2 jitter = hash21(float(i)) / 4.0;\n        jitter.x += x / 4.0;\n        jitter.y += y / 4.0;\n        \n        // set up the camera\n        vec2 percent = ((fragCoord.xy+jitter) / iResolution.xy) - vec2(0.5,0.5);  \n        vec3 rayPos;\n        vec3 rayTarget;\n\n        // if the mouse button is down\n        if( iMouse.z > 0.0 ) {\n            rayTarget = (cameraFwd * cameraDistance)\n                      + (cameraLeft * percent.x * cameraViewWidth)\n                      + (cameraUp * percent.y * cameraViewHeight);\n\n            rayPos = cameraPos;\n        }\n        // else handle the case of the mouse button not being down\n        else {\n            rayPos = normalize(vec3(0.0,1.0,-4.0)) * 16.0;\n            vec3 f = normalize(cameraAt - rayPos);\n            vec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n            vec3 u = normalize(cross(l,f));\n\n            rayTarget = (f * cameraDistance)\n                      + (l * percent.x * cameraViewWidth)\n                      + (u * percent.y * cameraViewHeight);\t\t\n        }    \n\n        vec3 rayDir = normalize(rayTarget - rayPos);\n\n        // Trace our ray\n        vec3 hitDiffuse = vec3(0.0);  // rgb\n        vec3 hitEmissive = vec3(0.0); // rgb\n        vec4 hitSpecular = vec4(0.0); // rgb, spec power\n        vec4 hitInfo = vec4(1000.0, -cameraFwd);  // distance, normal \n        bool hitSomething = false;\n        TraceRay(rayPos, rayDir, hitInfo, hitDiffuse, hitEmissive, hitSpecular, hitSomething, false);\n\n        // calculate how much the pixel is in shadow by other objects. 0 is full shadow, 1 is no shadow.\n        vec3 shadowRayPos = rayPos + rayDir * hitInfo.x;        \n        vec3 shadowRayDir = directionalLightReverseDir;\n        vec3 shadowHitDiffuse = vec3(0.0);\n        vec3 shadowHitEmissive = vec3(0.0);\n        vec4 shadowHitSpecular = vec4(0.0);\n        vec4 shadowHitInfo = vec4(1000.0, -directionalLightReverseDir); \n        bool shadowHitSomething = false;  \n        TraceRay(shadowRayPos, shadowRayDir, shadowHitInfo, shadowHitDiffuse, shadowHitEmissive, shadowHitSpecular, shadowHitSomething, true);\n        vec3 shadow = vec3(float(!shadowHitSomething));\n        \n        // calculate how much the pixel is in shadow by the light, and multiply that in to the previous shadow value.\n        shadow *= LightBoxShadow(shadowRayPos);\n\n        // shade our pixel based on what was hit, if anything. Ambient, diffuse, specular. Apply shadow to diffuse and specular contributions.\n        vec3 pixelColor = hitEmissive + hitDiffuse * lightAmbient;\n        float dp = clamp(dot(hitInfo.yzw, directionalLightReverseDir), 0.0, 1.0);\n        pixelColor += hitDiffuse * dp * directionalLightColor * shadow;\n        vec3 reflection = reflect(directionalLightReverseDir, hitInfo.yzw);\n        dp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n        pixelColor += hitSpecular.xyz * pow(dp, hitSpecular.w) * directionalLightColor * shadow;\n        \n\t\t// incrementally average our pixel color in\n        finalColor = mix(finalColor, pixelColor, 1.0 / float(i));\n    }\n    \n    // output final gamma corrected color\n\tfragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}