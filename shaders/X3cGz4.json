{
    "Shader": {
        "info": {
            "date": "1716133818",
            "description": "do 3d coords transform in fragment shader & it's not recommended...",
            "flags": 0,
            "hasliked": 0,
            "id": "X3cGz4",
            "likes": 8,
            "name": "Rasterized cube",
            "published": 3,
            "tags": [
                "cube",
                "rasterize"
            ],
            "usePreview": 0,
            "username": "liuming",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "const vec4 color1 = vec4(.0, .52, .96, 1.);\nconst vec4 color2 = vec4(.0, .82, .67, 1.);\nconst vec4 background = vec4(.0, .0, .0, 1.);\nconst float linewidth = 0.01;\nconst float L = 1000.;\nconst int[] indices = int[](0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.x;\n    vec4 c = background;\n\n    vec3 eye = vec3(0, 0, L*(3. + sin(iTime)));\n    vec3 center = vec3(0, 0, 0);\n    vec3 up = vec3(0, 1, 0);\n    mat4 viewMatrix = lookAt(eye, center, up);\n\n    float fovy = PI / 4.;\n    float aspect = iResolution.x / iResolution.y;\n    float near = .01;\n    float far = L * 3.;\n    mat4 projectMatrix = perspective(fovy, aspect, near, far);\n    float left = -L * 2. * aspect;\n    float right = L * 2. * aspect;\n    float bottom = -L * 2.;\n    float top = L * 2.;\n    //mat4 projectMatrix = ortho(left, right, bottom, top, near, far);\n    mat4 viewportMatrix = mat4(iResolution.x, 0, 0, -0.5 * iResolution.x, 0, iResolution.y, 0, -0.5 * iResolution.y, 0, 0, 1, 0, 0, 0, 0, 1);\n    \n    float cosB = cos(iTime);\n    float sinB = sin(iTime);\n    mat4 rotateYMatrix = mat4(cosB, 0, sinB, 0, 0, 1, 0, 0, -sinB, 0, cosB, 0, 0, 0, 0, 1);\n    viewMatrix = viewMatrix * rotateYMatrix;\n    \n    vec3 p1 = vec3(-L * .5, -L * .5, L * .5);\n    vec3 p2 = vec3(-L * .5, L * .5, L * .5);\n    vec3 p3 = vec3(L * .5, L * .5, L * .5);\n    vec3 p4 = vec3(L * .5, -L * .5, L * .5);\n    vec3 p5 = vec3(-L * .5, -L * .5, -L * .5);\n    vec3 p6 = vec3(-L * .5, L * .5, -L * .5);\n    vec3 p7 = vec3(L * .5, L * .5, -L * .5);\n    vec3 p8 = vec3(L * .5, -L * .5, -L * .5);\n    vec3 p[8] = vec3[](p1, p2, p3, p4, p5, p6, p7, p8);\n    vec2 s[8];\n    for(int i=0; i<8; i++){\n        vec2 sp = toViewPort(p[i], viewMatrix, projectMatrix, viewportMatrix) / iResolution.x;\n        s[i] = sp;\n    }\n    for(int i=0; i<24; i+=2){\n        vec2 s1 = s[indices[i]];\n        vec2 s2 = s[indices[i+1]];\n        float d = sdf_segment(uv, s1, s2, linewidth);\n        c = mix(c, color1, smoothstep(.0, fwidth(d), d));\n    }\n    fragColor = c;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592653\n#define EPSILON 1e-6\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n  mat4 m = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n  float x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  float eyex = eye[0];\n  float eyey = eye[1];\n  float eyez = eye[2];\n  float upx = up[0];\n  float upy = up[1];\n  float upz = up[2];\n  float centerx = center[0];\n  float centery = center[1];\n  float centerz = center[2];\n  if (abs(eyex - centerx) < EPSILON && abs(eyey - centery) < EPSILON &&\n      abs(eyez - centerz) < EPSILON) {\n    return m;\n  }\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1. / sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n  if (len < EPSILON) {\n    x0 = .0;\n    x1 = .0;\n    x2 = .0;\n  } else {\n    len = 1. / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n  if (len < EPSILON) {\n    y0 = .0;\n    y1 = .0;\n    y2 = .0;\n  } else {\n    len = 1. / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n  m[0][0] = x0;\n  m[0][1] = y0;\n  m[0][2] = z0;\n  m[1][0] = x1;\n  m[1][1] = y1;\n  m[1][2] = z1;\n  m[2][0] = x2;\n  m[2][1] = y2;\n  m[2][2] = z2;\n  m[3][0] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  m[3][1] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  m[3][2] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  return m;\n}\n\nmat4 perspective(float fovy, float aspect, float near, float far) {\n  mat4 m = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n  float f = 1. / tan(fovy / 2.);\n  float nf = 1. / (near - far);\n  m[0][0] = f / aspect;\n  m[1][1] = f;\n  m[2][2] = (far + near) * nf;\n  m[2][3] = -1.;\n  m[3][2] = 2. * far * near * nf;\n  return m;\n}\n\nmat4 ortho(float left, float right, float bottom, float top, float near, float far) {\n  mat4 m = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n  float lr = 1. / (left - right);\n  float bt = 1. / (bottom - top);\n  float nf = 1. / (near - far);\n  m[0][0] = -2. * lr;\n  m[1][1] = -2. * bt;\n  m[2][2] = 2. * nf;\n  m[3][0] = (left + right) * lr;\n  m[3][1] = (top + bottom) * bt;\n  m[3][2] = (far + near) * nf;\n  return m;\n}\n\nvec2 toViewPort(vec3 p, mat4 viewMatrix, mat4 projectMatrix,\n                mat4 viewportMatrix) {\n  vec4 position = projectMatrix * viewMatrix * vec4(p, 1.0);\n  vec4 screen = viewportMatrix * (position / position.w);\n  return vec2(floor(screen.x), floor(screen.y));\n}\n\nfloat sdf_segment(vec2 p, vec2 a, vec2 b, float w) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), .0, 1.);\n  float d = .5 * w - length(pa - ba * h);\n  return d;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}