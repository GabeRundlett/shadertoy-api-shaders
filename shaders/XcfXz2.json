{
    "Shader": {
        "info": {
            "date": "1706218554",
            "description": "I'm not sure where the sand goes. Maybe there's sand volcanoes somewhere?",
            "flags": 0,
            "hasliked": 0,
            "id": "XcfXz2",
            "likes": 19,
            "name": "Sand Pit",
            "published": 3,
            "tags": [
                "heightmap",
                "march"
            ],
            "usePreview": 0,
            "username": "TheBen27",
            "viewed": 379
        },
        "renderpass": [
            {
                "code": "const float MAX_DIST = 50.0;\nconst float PI = 3.14159;\n// #define ANTIALIAS\n\nfloat height(vec2 xz) {\n    float waves = 0.35 * sin(0.5 * (xz.x + xz.y));\n    vec2 offset = vec2(0.5, iTime * 0.1);\n    float softness = smoothmap(length(xz), 0.0, 12.0, 3.0, 2.0);\n    float dunes = 1.5 * pow(angleVoronoi(xz, vec2(24.0,0.7), offset, 0.1),softness);\n    \n    float sl = dot(xz, xz);\n    float flattening = smoothstep(9.0, 64.0, sl);\n    float depression = pow(1.0 - smoothstep(0.0,72.0,sl), 0.5) * -4.0;\n    float sinkhole = pow(1.0 - smoothstep(0.0,32.0,sl), 2.0) * -12.0;\n    \n    return depression + sinkhole + flattening * (waves + dunes);\n}\n\nfloat heightFine(vec2 xz) {\n    float flattening = smoothstep(16.0, 64.0, dot(xz, xz));\n    return height(xz) + flattening * 0.125 * angleVoronoi(xz, vec2(50.0,2.0), vec2(0.0), 0.4);\n}\n\nfloat heightNormal(vec2 xz) {\n    float baseHeight = heightFine(xz);\n    float scale = 0.0025;\n    float disp = scale * \n        angleVoronoiSharp(\n            xz,\n            25.0 * vec2(16.0, 1.0),\n            vec2(0.0, iTime * 0.5)\n    ) - (scale * 0.5);\n    return baseHeight + disp;\n}\n\nfloat marchHeightmap(vec3 ro, vec3 rd) {\n    // discard ray if it'll never hit the terrain\n    // (max heights of each step)\n    const float maxHeight = 0.35 + 1.5 + 0.125 + 0.0025;\n    float endHeight = ro.y + rd.y * MAX_DIST;\n    if (endHeight > maxHeight) {\n        return MAX_DIST;\n    }\n    \n    // coarse march\n    float stepSize = MAX_DIST / 300.0;\n    float dist;\n    for (dist = 0.0; dist < MAX_DIST; dist += stepSize) {\n        vec3 pos = ro + rd * dist;\n        float sampledHeight = height(pos.xz);\n        if (pos.y < sampledHeight) {\n            break;\n        }\n    }\n    \n    if (dist >= MAX_DIST) {\n        return dist;\n    }\n    \n    // step back and march fine\n    // this technique fails on thin edges, since the coarse march\n    // misses them entirely, but is a good tradeoff of quality versus speed\n    float fineStepSize = stepSize / 15.0;\n    float fineDist;\n    for (\n        fineDist = dist - stepSize;\n        fineDist < dist;\n        fineDist += fineStepSize\n    ) {\n        vec3 pos = ro + rd * fineDist;\n        float sampledHeight = height(pos.xz);\n        if (pos.y < sampledHeight) {\n            break;\n        }\n    }\n    \n    return fineDist;\n}\n\nvec3 normal(vec2 xz) {\n    // https://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map\n    const vec2 eps = vec2(0.005, 0.0);\n    float x = heightNormal(xz - eps) - heightNormal(xz + eps);\n    float z = heightNormal(xz - eps.yx) - heightNormal(xz + eps.yx);\n    float dist = eps.x * 2.0;\n    x /= dist;\n    z /= dist;\n    return normalize(vec3(x, 1.0, z));\n}\n\nvec3 sky(vec3 dir) {\n    // angle\n    float theta = (atan(dir.z, dir.x) / PI) * 0.5 + 0.5;\n    float phi = acos(dir.y) / PI;\n    \n    // general color\n    vec3 side = vec3(0.89,0.68,0.47);\n    vec3 top = vec3(0.25, 0.18, 0.13);\n    \n    vec3 skyColor = mix(top, side, phi * 2.0);\n    \n    // stars\n    vec2 coords = vec2(theta, phi);\n    float fade = distance(coords, vec2(0.75,0.3));\n    fade = smoothstep(0.3,0.075,fade) * 0.8;\n    \n    coords *= 500.0;\n    coords += iTime * vec2(0.1,0.05);\n    \n    float stars = voronoiSharp(coords);\n    stars = 1.0 - smoothstep(0.0, 0.1, stars);\n    \n    vec3 fadeColor = mix(\n        vec3(0.05,0.05,0.06),\n        vec3(1.0),\n        stars\n    );\n    \n    return mix(skyColor, fadeColor, fade); // vec3(1.0 - smoothstep(0.0,0.1,stars));\n}\n\nvec3 shade(\n    vec3 rd,\n    float depth,\n    vec3 pos,\n    vec3 norm\n) { \n    if (depth >= MAX_DIST) {\n        return sky(rd);\n    }\n    \n    vec3 sunDir = normalize(vec3(1.0,1.0,1.0));\n    float fog = smoothstep(5.0, MAX_DIST, depth);\n    \n    vec3 sunColor = smoothmap13(\n        dot(norm, sunDir),\n        -1.0,\n        1.0,\n        0.25 * vec3(0.73, 0.26, 0.08),\n        vec3(0.96, 0.5, 0.2)\n    );\n    \n    vec3 heightColor = smoothmap13(\n        pos.y,\n        0.0,\n        2.0,\n        vec3(0.7,0.6,0.6),\n        vec3(1.0)\n    );\n    \n    vec3 diffuseColor = sunColor * heightColor;\n    \n    float specularFactor = pow(max(0.0, dot(reflect(rd, norm), sunDir)), 4.0);\n    vec3 specularColor = vec3(0.15, 0.1, 0.1) * specularFactor;\n    \n    float holeFactor = smoothstep(-10.0, -4.0, pos.y);\n    vec3 holeColor = 0.3 * vec3(0.7,0.3,0.1);\n    \n    vec3 baseColor = diffuseColor + specularColor;\n    return mix(holeColor, mix(baseColor, sky(rd), fog), holeFactor);\n}\n\nvoid cameraRay(vec2 uv, out vec3 ro, out vec3 rd) {\n    float z = -1.0 + 0.25 * sin(uv.x * 3.14159);\n    ro = vec3(0.0, 0.0, z);\n    rd = normalize(vec3(2.0 * (uv - 0.5), 0.0) - ro);\n    \n    ro.y = 3.0;\n    ro.z -= 10.0;\n}\n\nvec3 mainSample(vec2 uv) {\n    vec3 ro, rd;\n    cameraRay(uv, ro, rd);\n    \n    float depth = marchHeightmap(ro, rd);\n    \n    vec3 pos = ro + rd * depth;\n    \n    vec3 col = shade(rd, depth, pos, normal(pos.xz));\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    #ifdef ANTIALIAS\n    vec3 offset = vec3(0.5 / iResolution.xy, 0.0);\n    vec3 color = mainSample(uv);\n    color += mainSample(uv + offset.xz);\n    color += mainSample(uv + offset.zy);\n    color += mainSample(uv + offset.xy);\n    color *= 0.25;\n    fragColor = vec4(color, 1.0);\n    #else\n    fragColor = vec4(mainSample(uv), 1.0);\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "mat2 rot(float amt) {\n    float c = cos(amt);\n    float s = sin(amt);\n    return mat2(c,-s,s,c);\n}\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n#if 1\n// this is inexplicably faster than the other branch on my machine\nfloat voronoi(vec2 uv, float softness) {\n    vec2 pos = uv;\n    vec2 innerPos = mod(pos, 1.0);\n    vec2 index = floor(pos);\n \n    float minDistance;\n    #define smc(a,b) sminCubic(a,b,softness)\n    minDistance = distance(innerPos, vec2(-1.0, -1.0) + hash22(index + vec2(-1.0, -1.0)));\n    minDistance = smc(minDistance, distance(innerPos, vec2(-1.0,  0.0) + hash22(index + vec2(-1.0,  0.0))));\n    minDistance = smc(minDistance, distance(innerPos, vec2(-1.0,  1.0) + hash22(index + vec2(-1.0,  1.0))));\n    \n    minDistance = smc(minDistance, distance(innerPos, vec2(0.0, -1.0) + hash22(index + vec2(0.0, -1.0))));\n    minDistance = smc(minDistance, distance(innerPos, vec2(0.0,  0.0) + hash22(index + vec2(0.0,  0.0))));\n    minDistance = smc(minDistance, distance(innerPos, vec2(0.0,  1.0) + hash22(index + vec2(0.0,  1.0))));\n    \n    minDistance = smc(minDistance, distance(innerPos, vec2(1.0, -1.0) + hash22(index + vec2(1.0, -1.0))));\n    minDistance = smc(minDistance, distance(innerPos, vec2(1.0,  0.0) + hash22(index + vec2(1.0,  0.0))));\n    minDistance = smc(minDistance, distance(innerPos, vec2(1.0,  1.0) + hash22(index + vec2(1.0,  1.0))));\n    return smoothstep(0.0, 1.0,minDistance);\n}\n#else\n// IQ's smooth voronoi\nfloat voronoi( in vec2 x, float w )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tfloat md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash22( n + g );\n\n        // distance to cell\t\t\n\t\tfloat d = length(g - f + o);\n        \t\n\t\tfloat h = smoothstep( -1.0, 1.0, (md-d)/w );\n\t    md   = mix( md,     d, h ) - h*(1.0-h)*w/(1.0+3.0*w);\n    }\n\t\n\treturn smoothstep(0.0, 1.0, md);\n}\n#endif\n\n\nfloat smoothmap(float x, float inMin, float inMax, float outMin, float outMax) {\n    return mix(outMin, outMax, smoothstep(inMin, inMax, x));\n}\n\nvec3 smoothmap13(float x, float inMin, float inMax, vec3 outMin, vec3 outMax) {\n    return mix(outMin, outMax, smoothstep(inMin, inMax, x));\n}\n\nfloat fmod(float x, float m) {\n    return x - m * floor(x / m);\n}\n\nfloat angleVoronoi(vec2 uv, vec2 scale, vec2 offset, float smoothness) {\n    float theta = 0.5 + atan(uv.y, uv.x) / (2.0 * acos(-1.0));\n    float phi = length(uv);\n    vec2 auv = vec2(theta, phi);\n    auv += offset;\n    \n    vec2 pos = auv * scale;\n    vec2 innerPos = mod(pos, 1.0);\n    vec2 index = floor(pos);\n \n    float minDistance = 1e3;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 offset = vec2(float(x), float(y));\n            vec2 cellPos = offset + hash22(\n                vec2(\n                    fmod(index.x + offset.x, scale.x),\n                    index.y + offset.y\n                )\n            );\n            float cellDistance = distance(innerPos, cellPos);\n            minDistance = sminCubic(minDistance, cellDistance, smoothness);\n        }\n    }\n    return minDistance;\n}\n\nfloat angleVoronoiSharp(vec2 uv, vec2 scale, vec2 offset) {\n    float theta = 0.5 + atan(uv.y, uv.x) / (2.0 * acos(-1.0));\n    float phi = length(uv);\n    vec2 auv = vec2(theta, phi);\n    auv += offset;\n    \n    vec2 pos = auv * scale;\n    vec2 innerPos = mod(pos, 1.0);\n    vec2 index = floor(pos);\n \n    float minDistance = 1e3;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 offset = vec2(float(x), float(y));\n            vec2 cellPos = offset + hash22(\n                vec2(\n                    fmod(index.x + offset.x, scale.x),\n                    index.y + offset.y\n                )\n            );\n            float cellDistance = distance(innerPos, cellPos);\n            minDistance = min(minDistance, cellDistance);\n        }\n    }\n    return minDistance;\n}\n\nfloat voronoiSharp(vec2 uv) {\n    vec2 pos = uv;\n    vec2 innerPos = mod(pos, 1.0);\n    vec2 index = floor(pos);\n \n    float minDistance = 1e4;\n    for (float x = -1.0; x <= 1.0; x += 1.0) {\n        for (float y = -1.0; y <= 1.0; y += 1.0) {\n            vec2 offset = vec2(x, y);\n            vec2 cellPos = hash22(index + offset);\n            vec2 diff = innerPos - (cellPos + offset);\n            float sd = dot(diff, diff);\n            minDistance = min(minDistance, sd);\n        }\n    }\n    return sqrt(minDistance);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}