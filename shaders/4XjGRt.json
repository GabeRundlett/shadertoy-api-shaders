{
    "Shader": {
        "info": {
            "date": "1708737267",
            "description": "Seen a caustic shader today, decided to implement something myself.\nIt is this https://medium.com/@evanwallace/rendering-realtime-caustics-in-webgl-2a99a29a0b2c but manually looping over the triangles",
            "flags": 32,
            "hasliked": 0,
            "id": "4XjGRt",
            "likes": 21,
            "name": "Mesh caustics",
            "published": 3,
            "tags": [
                "wave"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 362
        },
        "renderpass": [
            {
                "code": "//This is not exactly fast in fragment shaders, better to use the rasterizer\n\nvec3 renderCausticsPatch(vec2 p, vec2 tile)\n{\n    vec2 x00 = B(tile).xy;\n    vec2 x01 = B(tile + vec2(0.0, caustics_scale)).xy;\n    vec2 x10 = B(tile + vec2(caustics_scale, 0.0)).xy;\n    vec2 x11 = B(tile + vec2(caustics_scale)).xy;\n    vec2 xmin = min(min(x00,x01),min(x10,x11));\n    vec2 xmax = max(max(x00,x01),max(x10,x11));\n    if(any(lessThan(p, xmin)) || any(greaterThan(p,xmax))) return vec3(0.0);\n    vec2 a = invBilinear(p, x00, x10, x11, x01);\n    if(a.x < 0.0) return vec3(0.0); \n    return textureLod(iChannel2, tile/R + caustics_scale/R * a, 1.0).xyz;\n}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec2 tile0 = caustics_scale * floor(U / caustics_scale);\n    vec3 col = vec3(0.0);\n    for(int i = -range; i <= range; i++)\n    for(int j = -range; j <= range; j++)\n    {\n        vec2 tile = tile0 + vec2(i,j) * caustics_scale;\n        if(tile.x < 0.0 || tile.y < 0.0 || tile.x >= R.x || tile.y >= R.y) continue;\n        if(distance(tile, U) > MAX_DIST + 1.5*caustics_scale) continue;\n        col += renderCausticsPatch(U, tile); \n    }\n    Q.xyz = tanh(2.0*col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n\n//a way to sample pixels shorthand \n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Bl(U) textureLod(iChannel1,(U)/R, 1.0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n//the time step\n#define dt 0.5\n\n//caustics quad tile size in pixels\n#define caustics_scale 5.0\n//wave height\n#define height_scale 0.75\n//index of refraction\n#define IOR 1.4\n//distance to plane where caustic is projected\n#define water_depth 1500.0\n//loop radius over how many caustic quads\n#define range 6\n\n#define MAX_DIST (float(range) * caustics_scale)\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    if( w<0.0 ) return vec2(-1.0);\n    w = sqrt( w );\n\n    // will fail for k0=0, which is only on the ba edge \n    float v = 2.0*k0/(-k1 - w); \n    if( v<0.0 || v>1.0 ) v = 2.0*k0/(-k1 + w);\n\n    float u = (h.x - f.x*v)/(e.x + g.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n    return vec2( u, v );\n}\n\nvec2 rclamp(vec2 x, float maxr)\n{\n    float l = length(x);\n    return (l > maxr) ? maxr * x / l : x;\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate(w);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float generateWave(vec2 pos) {\n    return sin(pos.x * -0.7210 + pos.y * -0.6589 - 0.0303) +\n           sin(pos.x * -0.4157 + pos.y * -0.8699 - 2.9255) +\n           sin(pos.x * -0.2673 + pos.y * 0.8978 + 2.5718) +\n           sin(pos.x * -0.0879 + pos.y * 0.9313 - 1.5156) +\n           sin(pos.x * 0.5704 + pos.y * 0.6168 + 1.0212) +\n           sin(pos.x * -0.6007 - pos.y * 0.3908 - 1.1831) +\n           sin(pos.x * 0.0285 - pos.y * 0.8047 + 0.1261) +\n           sin(pos.x * 0.1848 + pos.y * 0.3685 + 0.2935) +\n           sin(pos.x * -0.9071 - pos.y * 0.1197 - 1.9801) +\n           sin(pos.x * 0.2151 - pos.y * -0.7559 + 2.9505);\n}\n\nvoid mainImage( out vec4 field, in vec2 pos )\n{\n    //THE field consists of 2 values\n    //x component - is the amplitude\n    //y component - is the speed with which the amplitude changes, ie velocity\n    //zw - unused\n    \n    //load the previous frame field state in this pixel\n    field = A(pos);\n \n    //wave simulation HERE\n       \n    //average of the neighbor pixels\n    vec4 avg = 0.25*(A(pos+vec2(0,1))+A(pos-vec2(0,1))+A(pos+vec2(1,0))+A(pos-vec2(1,0)));\n    \n    // the average of the amplitude around minus the amplitude here \n    //is the force actig on this pixel amplitude\n    float force = avg.x-field.x; \n    \n    //velocity update first\n    field.y += dt*force; //velocity += force * time step\n    \n    //field amplitude update then\n    field.x += dt*field.y; //position += velocity*time step\n\n    //initial conditions\n    if (iFrame < 1) {\n        //set initial amplitude for which we want to know its future state\n    \tfield.x = generateWave(pos*0.1) * exp(-0.00001*dot(pos-0.5*R,pos-0.5*R));\n        field.y = 0.;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//compute vertex offsets of the caustic mesh\n\nvec3 normal(vec2 p)\n{\n    float s = 1.0;\n    vec3 a = vec3(0,s,height_scale*A(p+vec2(0,s)).x);\n    vec3 b = vec3(0,-s,height_scale*A(p+vec2(0,-s)).x);\n    vec3 c = vec3(s,0,height_scale*A(p+vec2(s,0)).x);\n    vec3 d = vec3(-s,0,height_scale*A(p+vec2(-s,0)).x);\n    return normalize(cross(a-b, c-d));\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec3 n = normal(p);\n    vec3 l = vec3(0,0,1);\n    vec3 r = refract(l, n, 1.0/IOR);\n    vec3 ro = vec3(p, water_depth + height_scale*A(p).x);\n    //bottom intersection\n    vec2 i = p + rclamp(ro.z * r.xy/r.z, float(range) * caustics_scale);\n    c = vec4(i, 0, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//compute the concentration of light in this point of the light front\n\nvoid mainImage( out vec4 col, in vec2 p )\n{\n    float s = 1.0;//caustics_scale;\n    vec2 a = A(p+vec2(0,s)).xy;\n    vec2 b = A(p+vec2(0,-s)).xy;\n    vec2 c = A(p+vec2(s,0)).xy;\n    vec2 d = A(p+vec2(-s,0)).xy;\n    float area = 0.5*length(cross(vec3(a - b, 0), vec3(c - d, 0)));\n    col.xyz =  spectral_zucconi6(p.x/R.x) / (area*area + 0.5) ;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}