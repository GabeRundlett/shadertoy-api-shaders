{
    "Shader": {
        "info": {
            "date": "1458737531",
            "description": "Moving a camera through a fractal object.",
            "flags": 0,
            "hasliked": 0,
            "id": "4s3SRN",
            "likes": 273,
            "name": "Fractal Flythrough",
            "published": 3,
            "tags": [
                "fractal",
                "camera",
                "spline",
                "menger",
                "curve",
                "catmullrom"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 30987
        },
        "renderpass": [
            {
                "code": "/*\n\n\tFractal Flythrough\n\t------------------\n\n\tMoving a camera through a fractal object. It's a work in progress.\n\n\tI was looking at one of Dr2's shaders that involved moving a camera through a set of way points (set\n\tout on the XZ plane), and thought it'd be cool to do a similar 3D version. The idea was to create a\n\trepetitive kind of fractal object, give the open space nodes a set random direction, create some \n\tspline points, then run a smooth camera through them. Simple... right? It always seems simple in my\n\thead, but gets progressively harder when I try it in a shader. :)\n\n\tI've run into that classic up-vector, camera flipping problem... At least, I think that's the problem? \n\tAnyway, I'm hoping the solution is simple, and that someone reading this will be able to point me in \n\tthe right direction.\n\n\tFor now, I've set up a set of 16 random looping points that the camera seems reasonably comfortable \n\twith. Just for the record, the general setup works nicely, until the camera loops back on itself in \n\tthe YZ plane. I'm guessing that increasing the number of way points may eradicate some of the\n    intermittent camera spinning, but I figured I'd leave things alone and treat it as a feature. :)\n\n\tBy the way, I was thankful to have Otavio Good's spline setup in his \"Alien Beacon\" shader as a \n\treference. On a side note, that particular shader is one of my all time favorites on this site.\n\n\tThe rendering materials are slightly inspired by the Steampunk genre. Timber, granite, brass, etc. \n\tIt needs spinning turbines, gears, rivots, and so forth, but that stuff's expensive. Maybe later. \n\tTambako\tJaguar did a really cool shader in the Steampunk aesthetic. The link is below.\n\n\tBesides camera path, there's a whole bunch of improvements I'd like to make to this. I've relied on\n\tocclusion to mask the fact that there are no shadows. I'm hoping to free up some cycles, so I can put\n\tthem back in. I'd also like to add extra detail, but that also slows things down. As for the comments,\n\tthey're very rushed, but I'll tidy those up as well.\n\n\tReferences:\n\n\tAlien Beacon - Otavio Good\n\thttps://www.shadertoy.com/view/ld2SzK\n\n    Steampunk Turbine - TambakoJaguar\n    https://www.shadertoy.com/view/lsd3zf\n    \n    // The main inspiration for this shader.\n\tMandelmaze in Daylight - dr2\n    https://www.shadertoy.com/view/MdVGRc\n\n*/\n\nconst float FAR = 50.0; // Far plane.\n\n// Used to identify individual scene objects. In this case, there are only three: The metal framework, the gold\n// and the timber.\nfloat objID = 0.; // Wood = 1., Metal = 2., Gold = 3..\n\n// Simple hash function.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n// Common formula for rounded squares, for all intended purposes.\nfloat lengthN(in vec2 p, in float n){ p = pow(abs(p), vec2(n)); return pow(p.x + p.y, 1.0/n); }\n\n\n// The camera path: There are a few spline setups on Shadertoy, but this one is a slight variation of\n// Otavio Good's spline setup in his \"Alien Beacon\" shader: https://www.shadertoy.com/view/ld2SzK\n//\n// Spline point markers (\"cp\" for camera point). The camera visits each point in succession, then loops\n// back to the first point, when complete, in order to repeat the process. In case it isn't obvious, each \n// point represents an open space juncture in the object that links to the previous and next point.\n// Of course, running a camera in a straight line between points wouldn't produce a smooth camera effect, \n// so we apply the Catmull-Rom equation to the line segment.\nvec3 cp[16];\n\nvoid setCamPath(){\n    \n    // The larger fractal object has nodes in a 4x4x4 grid.\n    // The smaller one in a 2x2x2 grid. The following points\n    // map a path to various open areas throughout the object.\n    const float sl = 2.*.96;\n    const float bl = 4.*.96;\n    \n    cp[0] = vec3(0, 0, 0);\n    cp[1] = vec3(0, 0, bl);\n    cp[2] = vec3(sl, 0, bl);\n    cp[3] = vec3(sl, 0, sl);\n    cp[4] = vec3(sl, sl, sl);\t\n    cp[5] = vec3(-sl, sl, sl);\t\n    cp[6] = vec3(-sl, 0, sl);\n    cp[7] = vec3(-sl, 0, 0);\n    \n    cp[8] = vec3(0, 0, 0);\t\n    cp[9] = vec3(0, 0, -bl);\n    cp[10] = vec3(0, bl, -bl);\t\n    cp[11] = vec3(-sl, bl, -bl);\n    cp[12] = vec3(-sl, 0, -bl);\n    cp[13] = vec3(-sl, 0, 0);\n    cp[14] = vec3(-sl, -sl, 0);\n    cp[15] = vec3(0, -sl, 0); \n    \n    // Tighening the radius a little, so that the camera doesn't hit the walls.\n    // I should probably hardcode this into the above... Done.\n    //for(int i=0; i<16; i++) cp[i] *= .96;\n    \n}\n\n// Standard Catmull-Rom equation. The equation takes in the line segment end points (p1 and p2), the\n// points on either side (p0 and p3), the current fractional distance (t) along the segment, then\n// returns the the smooth (cubic interpolated) position. The end result is a smooth transition \n// between points... Look up a diagram on the internet. That should make it clearer.\nvec3 Catmull(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n\n    return (((-p0 + p1*3. - p2*3. + p3)*t*t*t + (p0*2. - p1*5. + p2*4. - p3)*t*t + (-p0 + p2)*t + p1*2.)*.5);\n   \n}\n \n// Camera path. Determine the segment number (segNum), and how far - timewise - we are along it (segTime).\n// Feed the segment, the appropriate adjoining segments, and the segment time into the Catmull-Rom\n// equation to produce a camera position. The process is pretty simple, once you get the hang of it.\nvec3 camPath(float t){\n    \n    const int aNum = 16;\n    \n    t = fract(t/float(aNum))*float(aNum);\t// Repeat every 16 time units.\n    \n    // Segment number. Range: [0, 15], in this case.\n    float segNum = floor(t);\n    // Segment portion. Analogous to how far we are alone the individual line segment. Range: [0, 1].\n    float segTime = t - segNum; \n    \n    \n    if (segNum == 0.) return Catmull(cp[aNum-1], cp[0], cp[1], cp[2], segTime); \n    \n    for(int i=1; i<aNum-2; i++){\n        if (segNum == float(i)) return Catmull(cp[i-1], cp[i], cp[i+1], cp[i+2], segTime); \n    }\n    \n    if (segNum == float(aNum-2)) return Catmull(cp[aNum-3], cp[aNum-2], cp[aNum-1], cp[0], segTime); \n    if (segNum == float(aNum-1)) return Catmull(cp[aNum-2], cp[aNum-1], cp[0], cp[1], segTime);\n\n    return vec3(0);\n    \n}\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// https://iquilezles.org/articles/smin\nfloat sminP( float a, float b, float s ){\n\n    float h = clamp( 0.5+0.5*(b-a)/s, 0.0, 1.0 );\n    return mix( b, a, h ) - s*h*(1.0-h);\n}\n\n// Creating the scene geometry.\n//\n// There are two intertwined fractal objects. One is a gold and timber lattice, spread out in a 4x4x4\n// grid. The second is some metallic tubing spread out over a 2x2x2 grid. Each are created by combining\n// repeat objects with various operations. All of it is pretty standard.\n//\n// The code is a little fused together, in order to save some cycles, but if you're interested in the \n// process, I have a \"Menger Tunnel\" example that's a little easier to decipher.\nfloat map(in vec3 q){\n\n    \n///////////\n\n    // The grey section. I have another Menger example, if you'd like to look into that more closely.\n    // Layer one.\n \tvec3 p = abs(fract(q/4.)*4. - 2.);\n \tfloat tube = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 4./3. - .015;// + .05;\n    \n\n    // Layer two.\n    p = abs(fract(q/2.)*2. - 1.);\n \t//d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);// + .025\n \ttube = max(tube, sminP(max(p.x, p.y), sminP(max(p.y, p.z), max(p.x, p.z), .05), .05) - 2./3.);// + .025\n   \n///////\n    // The gold and timber paneling.\n    //\n    // A bit of paneling, using a combination of repeat objects. We're doing it here in layer two, just\n    // to save an extra \"fract\" call. Very messy, but saves a few cycles... maybe.\n    \n    //float panel = sminP(length(p.xy),sminP(length(p.yz),length(p.xz), 0.25), 0.125)-0.45; // EQN 1\n    //float panel = sqrt(min(dot(p.xy, p.xy),min(dot(p.yz, p.yz),dot(p.xz, p.xz))))-0.5; // EQN 2\n    //float panel = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.5; // EQN 3\n    float panel = sminP(max(p.x, p.y),sminP(max(p.y, p.z),max(p.x, p.z), .125), .125)-0.5; // EQN 3\n    \n\n    // Gold strip. Probably not the best way to do this, but it gets the job done.\n    // Identifying the gold strip region, then edging it out a little... for whatever reason. :)\n    float strip = step(p.x, .75)*step(p.y, .75)*step(p.z, .75);\n    panel -= (strip)*.025;     \n    \n    // Timber bulge. Just another weird variation.\n    //float bulge = (max(max(p.x, p.y), p.z) - .55);//length(p)-1.;//\n    //panel -= bulge*(1.-step(p.x, .75)*step(p.y, .75)*step(p.z, .75))*bulge*.25;    \n    \n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(fract(q*2.)*.5 - .25);\n    float pan2 = min(p.x, min(p.y,p.z))-.05;    \n    \n    // Combining the two entities above.\n    panel = max(abs(panel), abs(pan2)) - .0425;    \n/////////\n    \n    // Layer three. 3D space is divided by three.\n    p = abs(fract(q*1.5)/1.5 - 1./3.);\n \ttube = max(tube, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 2./9. + .025); // + .025 \n\n\n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p = abs(fract(q*3.)/3. - 1./6.);\n \ttube = max(tube, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./9. - .035); //- .025 \n    \n\n    \n    \n    // Object ID: Equivalent to: if(tube<panel)objID=2; else objID = 1.; //etc.\n    //\n    // By the way, if you need to identify multiple objects, you're better off doing it in a seperate pass, \n    // after the raymarching function. Having multiple \"if\" statements in a distance field equation can \n    // slow things down considerably.\n        \n    //objID = 2. - step(tube, panel) + step(panel, tube)*(strip);\n    objID = 1.+ step(tube, panel) + step(panel, tube)*(strip)*2.;\n    //objID = 1. + step(panel, tube)*(strip) + step(tube, panel)*2.;\n    \n\n    return min(panel, tube);\n    \n    \n}\n\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    for(int i = 0; i < 92; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return t;\n}\n\n\n// The reflections are pretty subtle, so not much effort is being put into them. Only 16 iterations.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0.;\n    for(int i=0; i<16; i++){\n        float d = map(ro + rd*t);\n        if (d < .0025*(t*.25 + 1.) || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*/\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    float speed = iTime*0.35 + 8.;\n    \n    // Initiate the camera path spline points. Kind of wasteful not making this global, but I wanted\n    // it self contained... for better or worse. I'm not really sure what the GPU would prefer.\n    setCamPath();\n\n    \n\t// Camera Setup.\n    vec3 ro = camPath(speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(speed + .5);  // \"Look At\" position.\n    vec3 lp = camPath(speed + .5) + vec3(0, .25, 0); // Light position, somewhere near the moving camera.\n   \n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.57; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n        // Unit direction ray.\n    vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    \n    // Raymarch the scene.\n    float t = trace(ro, rd);\n    \n    // Initialize the scene color.\n    vec3 col = vec3(0);\n    \n    // Scene hit, so color the pixel. Technically, the object should always be hit, so it's tempting to\n    // remove this entire branch... but I'll leave it, for now.\n    if(t<FAR){\n        \n        // This looks a little messy and haphazard, but it's really just some basic lighting, and application\n        // of the following material properties: Wood = 1., Metal = 2., Gold = 3..\n    \n        float ts = 1.;  // Texture scale.\n        \n        // Global object ID. It needs to be saved just after the raymarching equation, since other \"map\" calls,\n        // like normal calculations will give incorrect results. Found that out the hard way. :)\n        float saveObjID = objID; \n        \n        \n        vec3 pos = ro + rd*t; // Scene postion.\n        vec3 nor = calcNormal(pos); // Normal.\n        vec3 sNor = nor;\n        \n        \n        // Apply some subtle texture bump mapping to the panels and the metal tubing.\n        nor = texBump(iChannel0, pos*ts, nor, 0.002); // + step(saveObjID, 1.5)*0.002\n    \n        // Reflected ray. Note that the normal is only half bumped. It's fake, but it helps\n        // taking some of the warping effect off of the reflections.\n        vec3 ref = reflect(rd, normalize(sNor*.5 + nor*.5)); \n         \n        \n\t\tcol = tex3D(iChannel0, pos*ts, nor); // Texture pixel at the scene postion.\n        \n        \n        vec3  li = lp - pos; // Point light.\n        float lDist = max(length(li), .001); // Surface to light distance.\n        float atten = 1./(1.0 + lDist*0.125 + lDist*lDist*.05); // Light attenuation.\n        li /= lDist; // Normalizing the point light vector.\n        \n        float occ = calcAO( pos, nor ); // Occlusion.\n\t\t\n        float dif = clamp(dot(nor, li), 0.0, 1.0); // Diffuse.\n        dif = pow(dif, 4.)*2.;\n        float spe = pow(max(dot(reflect(-li, nor), -rd), 0.), 8.); // Object specular.\n        float spe2 = spe*spe; // Global specular.\n        \n        float refl = .35; // Reflection coefficient. Different for different materials.\n\n            \n\n        // Reflection color. Mostly fake.\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n        // effort is being put in.\n        float rt = refTrace(pos + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        float rSaveObjID = objID; // IDs change with reflection. Learned that the hard way. :)\n        vec3 rsp = pos + ref*rt; // Reflected surface hit point.\n        vec3 rsn = calcNormal(rsp); // Normal at the reflected surface. Too costly to bump reflections.\n        vec3 rCol = tex3D(iChannel0, rsp*ts, rsn); // Texel at \"rsp.\"\n        vec3 rLi = lp-rsp;\n        float rlDist = max(length(rLi), 0.001);\n        rLi /= rlDist;\n        float rDiff = max(dot(rsn, rLi), 0.); // Diffuse light at \"rsp.\"\n        rDiff = pow(rDiff, 4.)*2.;\n        float rAtten = 1./(1. + rlDist*0.125 + rlDist*rlDist*.05);\n        \n        if(rSaveObjID>1.5 && rSaveObjID<2.5){\n            rCol = vec3(1)*dot(rCol, vec3(.299, .587, .114))*.7 + rCol*.15;//*.7+.2\n            //rDiff *= 1.35;\n        }\n        if(rSaveObjID>2.5){\n             //float rc = dot(rCol, vec3(.299, .587, .114));\n             vec3 rFire = pow(vec3(1.5, 1, 1)*rCol, vec3(8, 2, 1.5));//*.5+rc*.5;\n             rCol = min(mix(vec3(1.5, .9, .375), vec3(.75, .375, .3), rFire), 2.)*.5 + rCol;         \n        }\n        \n        rCol *= (rDiff + .35)*rAtten; // Reflected color. Not accurate, but close enough.         \n        \n        \n        \n        // Grey metal inner tubing.\n        if(saveObjID>1.5 && saveObjID<2.5){ \n\t\t\t\n            // Grey out the limestone wall color.\n            col = vec3(1)*dot(col, vec3(.299, .587, .114))*.7 + col*.15;\n            \n            refl = .5;\n            //dif *= 1.35;\n            //spe2 *= 1.35;\n            \n        }         \n        \n        // Gold trimming properties. More effort should probably be put in here.\n        // I could just write \"saveObjID == 3.,\" but I get a little paranoid where floats are concerned. :)\n        if(saveObjID>2.5){\n\n            // For the screen image, we're interested in the offset height and depth positions. Ie: pOffs.zy.\n            \n            // Pixelized dot pattern shade.\n            //float c = dot(col, vec3(.299, .587, .114));\n            \n            vec3 fire = pow(vec3(1.5, 1, 1)*col, vec3(8, 2, 1.5));//*.5+c*.5;\n            col = min(mix(vec3(1, .9, .375), vec3(.75, .375, .3), fire), 2.)*.5 + col;//\n            \n            refl = .65;\n            //dif *= 1.5;\n            //spe2 *= 1.5;\n            \n        }\n        \n     \n        // Combining everything together to produce the scene color.\n        col = col*(dif + .35  + vec3(.35, .45, .5)*spe) + vec3(.7, .9, 1)*spe2 + rCol*refl;\n        col *= occ*atten; // Applying occlusion.\n       \n        \n    }\n\n    \n    // Applying some very slight fog in the distance. This is technically an inside scene...\n    // Or is it underground... Who cares, it's just a shader. :)\n    col = mix(min(col, 1.), vec3(0), 1.-exp(-t*t/FAR/FAR*20.));//smoothstep(0., FAR-20., t)\n    //col = mix(min(col, 1.), vec3(0), smoothstep(0., FAR-35., t));//smoothstep(0., FAR-20., t)\n    \n    \n    \n    // Done.\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}