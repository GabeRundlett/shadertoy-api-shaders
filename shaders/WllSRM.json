{
    "Shader": {
        "info": {
            "date": "1562434247",
            "description": "\"Sausage powered turbine\" - Shader showdown practice session 014.\nLive coded on Twitch with 25 minutes time limit.\nPracticing live on TWITCH every Tuesdays around 21:00 UK time.\nhttps://www.twitch.tv/evvvvil_",
            "flags": 0,
            "hasliked": 0,
            "id": "WllSRM",
            "likes": 7,
            "name": "[TWITCH] Sausage powered turbine",
            "published": 3,
            "tags": [
                "time",
                "demoscene",
                "abstract",
                "glow",
                "mechanic",
                "limit",
                "live",
                "battle",
                "shadershowdown",
                "turbine",
                "gloss",
                "industrial",
                "twitch",
                "sausage"
            ],
            "usePreview": 0,
            "username": "evvvvil",
            "viewed": 753
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\"Sausage-powered turbine\" - Shader Showdown practice session 014\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Live coding shader software used is BONZOMATIC https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 21:00 UK time I practise live on TWITCH.\n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\n// \"Prodigal? Fuck that, nautical. Teachin' bitches how to swim\" - Death Grips \n\nvec2 s,e=vec2(.00035,-.00035);float t,tt,g1,g2,sig=1.,b;vec3 np,bp,cp,dp;//Some fucking globals, about as exciting as the tory leadership contest\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}//box function stolen from UNC because UNC knows best how GPU really feel inside\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //Simple rotate function, small and useful, like a midget in an elevator shaft\nvec2 fb(vec3 p,float s)\t//Fucking bits function which makes the fucking bit/piece it is a base shape which we clone and repeat to create the whole geometry in mp function\n{\n  vec2 h,t=vec2(bo(abs(p)-vec3(0,0,2),vec3(2,0.5,0.5)),6.+s);//Couple of dumb fucking boixes spread out with absolute symetry\n  t.x=max(-bo(abs(p)-vec3(0,0,2),vec3(1.8,0.25,1)),t.x);//Get yer fucking shovels out broskis!\n  t.x=max(-bo(abs(p)-vec3(0,0,2),vec3(1.8,1,0.25)),t.x);//These two lines are just for digging holes... so we can see the yellow bit inside white boxes\n  t.x=min(bo(abs(p)-vec3(2.6,0,0),vec3(0.25,0.25,2)),t.x);//Even dumber white boxes for the other side of piece\n  h=vec2(bo(abs(p)-vec3(2.6,0,2),vec3(0.6)),3.+s);//Now we start a new group of shapes uin the same material id , these are black corner boxes\n  h.x=min(bo(abs(p)-vec3(2.6,0,2),vec3(0.2,8,0.2)),h.x);//And some nice big black poles \n  t=(t.x<h.x)?t:h;//Merge both group of shapes from both material ID into one single geometrical coloured orgy\n  h=vec2(bo(abs(p)-vec3(0,0,2),vec3(2,0.15,0.15)),5.+s);//Bring in the neon fucking  lights, because everybody loves a glow, even your weird and miserable uncle\n  g2+=0.1/(0.1+h.x*h.x*10.);//This is glow trick by Balkhan, pass the distance field of shape into a float variable and add to colour at the end with multiplkier, see last few lines\n  t=(t.x<h.x)?t:h;//Another geometry fucking merger, it's a geomtry orgy I tell you, grab a dildo and go down the red tunnel.\n  return t;\n}\nvec2 mp( vec3 p ) //This is the main MAP function where all geometry is made/defined. It's centre stage broski, bit like a drunken Trappist monk at an AA meeting\n{\n  np=bp=cp=dp=p;//Yeah i know, fucking ludicrous, but hey creating loads of new positions for each different inner an doutter bits\n  np.xz*=r2(-tt*0.2);//They all will rotate alternately in the opposite direction, This is where we rotate one way...\n  bp.xz*=r2(tt*0.2);//...or another. It's like being drunk but while retaining your handsome charm. Well I fucking do anyways, you guys need to either: drink more or be more handsome.\n  for(int i=0;i<5;i++){//Technique is to create more complex positions and pass them to fucking bit function fb, there fore taking imsple piece and making lots of geometry from it\n    np=abs(np)-vec3(2.3+(6.-float(i)*2.4),3,4.2);//So we have a loop and in the loop we push apart positions with abs symstery and rotate a bit, making it more interesting\n    np.xz*=r2(.3925);//a bit of rotate won't hurt you little fucker.\n    bp=abs(bp)-vec3(4,4,3.9);//Bp is for outter bit of scene which rotate the other way\n    bp.xz*=r2(.3925);//Yeah, nah rotate won't hurt you either, bitch.\n  }\n  vec2 h,t=fb(np,0.);//Here passs along to fb the new position np, to create more complex geometry based on simple piece in fb\n  t.x=max(t.x,-(length(vec3(p.x,0,p.z))-0.9));//We're removing the inner bit of central rotating piece so we can put a smaller piece inside\n  bp.yz*=r2(0.785);bp=abs(bp*0.5-1.)-vec3(4.5);//We tweak bp: rotate it all 90 degree to change it look compare to central piece and makie it more interesting and we abs symetry it to push it out\n  h=fb(bp,10.);//Here we pass the next new position bp to the fb function again reusing simple piece but this time looks way different, it's an interesting technique, I'm not just some antagonistic wanker, broh.\n  t=(t.x<h.x)?t:h;//We merge central main piece and outter bits\n  cp.y=mod(cp.y,10.)-5.;//Now we create the central inner bits with simple version of fb but repeated on y axis also twisted and rotated\n  cp.xz*=r2(sin(p.y*0.4)*0.4+tt*2.);//here we twist and rotate the central inner piece  along the Y axis\n  h=fb(cp,20.);h.x*=0.7;//Once again we create now the central inner piece by passing the new position above cp\n  t=(t.x<h.x)?t:h;//Merge the whole scene with the new central inner bits\n  dp.y=0.;dp.xz*=r2(sin(p.y*0.5)*0.5-tt*5.);//Final piece of puzzle is simple pseudo transparent spinning tall white box\n  h=vec2(bo(dp,vec3(0.5)+sin(p.y*0.5+tt*5.)*.2),30);//We create new position dp which simply has twist and rotat eon y axis in similar way we did inner bits but it rotate the other way\n  g1+=0.1/(0.1+h.x*h.x*10.);//We pass the result of tall spinnig white box to a varible to make glow effect later, see last few lines. Distance glow made by Balkhan, thankx to him.\n  t=(t.x<h.x)?t:h;//merge all that shit up again.\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(0.1);//Near plane because when you're young you're always naive and we ain't got time for that shit here\n  for(int i=0;i<128;i++){//Main loop de loop \n    h=mp(ro+rd*t.x);//Marching forward like any good fascist army: without any care for culture theft\n      if(h.x<.0001*sig||t.x>70.) {\n      if(h.y<30.) break;//Very naive and brutal material based pseudo \"transparency\"\n        t.x+=0.5;//If material id is over 29 then we push ray forward and keep going, wishing for the best \n        continue;//Brutal but only very short amount of code but kinda works. It's good for shadershowdown as very short.\n      }\n      t.x+=h.x;t.y=h.y;//Push forward, remember material id. This is where we pass material ID so we can color it after\n  }  \n  return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);//boilerplate code to get uvs in BONZOMATIC live coding software i use.\n    \n    tt=mod(iTime,62.83);//Time variable is modulo'ed to avoid ugly artifact. Float precision and all that shit, this should solve that. Not very glamourous but, neither are you.\n    b=sin(tt*0.2-0.5)*39.;//Camera animation variable\n    vec3 ro=vec3(cos(tt*0.1)*b-2.,4.1,sin(tt*0.1)*b+2.),//Ro=ray origin=camera position because everything is relative to a view point, even mothers lying to their sons about being handsome\n    cw=normalize(vec3(0)-ro),\n    cu=normalize(cross(cw,vec3(cos(tt*0.2-0.5),1,0))),//Oh yeah nice little roation along the z axis to giv eit that nice nauseous camera feel \n    cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,0.5)),co,fo,//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n    ld=normalize(vec3(0.3,0.5,-0.5));//ld=light direction\n    co=fo=vec3(0,.1,.2)-rd.y*0.3+vec3(0.5)*(1.-(length(uv)-0.2));//By default the bakcground and fog colour is subtle gradient on y axis and a subtle vignette. Not everything has to be hardcore broh.\n    s=tr(ro,rd);t=s.x;//This is where we shoot the fucking rays to get the fucking scene. Like a 19th century french painter but withouth the absinth addiction and more gpu power\n\n    if(t>0.){//If t>0 then we must have hit some geometry so let's fucking shade it. \n        //We hit some geometry so let's get the current position (po) and build some normals (no). You do the Maths while I reload this vaporizer.\n        vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),\n        \n        //LIGHTING MICRO ENGINE BROSKI \n        al=vec3(1,0.5,0.);//al = Albedo = base colour.        \n        //Change colour depending on material id, it's like art school but with the pretentious post-modern essays justifying the lack of technique\n        if(s.y<5.) al=vec3(0);//albedo is black with material ID less 5\n        if(s.y>5.) al=vec3(1);//albedo becomes white with material Id above 5\n        //Messy i know but i typed that shit fast and i can copy and paste it easy, so yeah, who gives a shit\n        float spo=exp2(10.*texture(iChannel0,vec2(np.x,dot(np.yz,vec2(0.5)))/vec2(6,10)).r);//TRICK nice pseudo triplanar uv mapping in one line by nusan_fx! Thankx NUSAN wicked!\n    \t//More on the above: it creates a nice gloss map as spo is \"specular power\", its not used in albedo or diffuse please note so purely gloss map \n        if(s.y<5.) al=vec3(0);//albedo is black with material ID less 5\n        if(s.y>5.) al=vec3(1);//albedo becomes white with material Id above 5\n    \tif(s.y>10.) spo=exp2(10.*texture(iChannel0,vec2(bp.x,dot(bp.yz,vec2(0.5)))/vec2(6,10)).r);//We have to recalculate the gloss map for outter bits as uv are based on np and outter is based on bp\n    \tif(s.y<15.&&s.y>6.)al=vec3(0);//More from above: Hence why the material ID mess we're in at this point, but remember this is typed in 25 minutes and it can easily be copied and pasted so it is badily designed for that fast typing purpose\n    \tif(s.y>20.) spo=exp2(10.*texture(iChannel0,vec2(cp.x,dot(cp.yz,vec2(0.5)))/vec2(6,10)).r);//Again we have to recalculate the gloss map as it's based on np and the centrall inner bits are made with cp, otherwise texture will slide\n    \tif(s.y<25.&&s.y>16.)al=vec3(0);//I know lame it means i have to redefine black and white material again and again but remember it is fast to copy and paste and type. Stop giving me shit anyways, make your own fucking shader hahaha.\n    \n        float dif=max(0.,dot(no,ld)),//dif=diffuse because i ain't got time to cook torrance\n        fr=pow(1.+dot(no,rd),4.),//Nice fresnel to blend geometry in background with background reflections\n        aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),//aor=ambient occlusion range, ao = ambient occlusion\n        sss=smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),//sss=subsurface scatterring made by tekf from the wax shader, big up tekf! https://www.shadertoy.com/view/lslXRj\n        sp=.5*pow(max(dot(reflect(-ld,no),-rd),0.),spo);//Sp=specualr, sotlen from Shane.\n        co=mix(sp+al*(.8*ao+0.2)*(dif+sss),fo,min(fr,.5));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n        co=mix(co,fo,1.-exp(-.00003*t*t*t));//Fog soften things, but it won't save you against your addictions, \"dishipline\" will.\n    }//We add glow at the end with co+g1*0.07 also a yellow coloured glow with vec3(1,0.5,0)*g2*0.05\n  \tco+=g1*0.07+vec3(1,0.5,0)*g2*0.05;//simple distance based glow where we take the result of any shape and add it to g then at end add to co. Trick is from Balkhan thankx to him again.\n    fragColor = vec4(pow(co+g1*0.03,vec3(0.45)),1);//Cheap tone mapping, even cheaper than your taste in interior design.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}