{
    "Shader": {
        "info": {
            "date": "1572729960",
            "description": "This is my first try with 3d and RayMarch for creating the primitives. The code includes render, skybox, lighting, soft shadows, diffuse light and reflections, hope you like it!!. Please leave a comment or recomendations so i can improve my code.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wd3SDB",
            "likes": 8,
            "name": "RayMarch/Sphere Tracing Demo",
            "published": 3,
            "tags": [
                "3d",
                "reflection",
                "raymarch",
                "materials",
                "3dproyection"
            ],
            "usePreview": 0,
            "username": "sirArthurDayne",
            "viewed": 584
        },
        "renderpass": [
            {
                "code": "//I Make this Raymarch proyect for learning 3d computer graphics. This code can be use and modify by anyone.\n//The code was wrote on GLSL and Kodelife IDE, then i make the port to ShaderToy.\n//Please leave a comment o suggestion so i can improve and make better 3d graphics.\n\n//Material var\n float reflectionFactor = 0.0;\n\n\nfloat MaxComp(in vec3 pos)\n{\n    return max(pos.x, max(pos.y, pos.z));\n}\n\n\nvoid Rotate(inout vec2 pos, float angle)\n{\n    pos = vec2(pos.x * cos(angle) + pos.y * sin(angle), - pos.x * sin(angle) + pos.y * cos(angle));\n}\n\nfloat DSphere(in vec3 pos, in float radius)\n{\n    return length(pos) - radius;\n}\n\n\nfloat DBox(in vec3 pos, in vec3 b)\n{\n    vec3 di = abs(pos) - b;\n    float mc = MaxComp(di);\n    return min(mc, length(max(di, 0.0)));\n}\n\n\n//soft min that allows object to fuse into the other \nfloat Smin(float a, float b, float k)\n{\n//when the object are far, the return value is 'a' or 'b' \n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res)/k;\n}\n\n//Holds all the geometries that will be render to screen\nfloat DistanceEstimator(in vec3 pos)\n{\n    float sphere1 = DSphere(pos, 0.62);\n    float box = DBox(pos, vec3(0.5));\n    //float holeBox = max(box, -sphere1);\n    for(int i = 0; i < 12; i++)\n    {\n        vec3 offset = vec3(2.0 * sin(iTime *0.25), 0.0, 2.0 * cos(iTime));\n        Rotate(offset.xz, float(i));\n        float sphere2 = DSphere(pos - sin(iTime*0.3) * offset , 0.15);\n        sphere1 = Smin(sphere1, sphere2, 10.0);\n    }\n    float boxBase = DBox(pos - vec3(0.0, -0.50, 0.5 * cos(iTime)), vec3(0.9, 0.1, 1.0)); \n    float scene_obj =  min(boxBase, sphere1);\n    if (scene_obj == boxBase) reflectionFactor = 0.7;\n    else reflectionFactor = 0.3;\n    \n    return scene_obj;\n}\n\nvec3 normal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);//epsilon: small number to work with\n    vec3 nor;\n    //finds the ratio of change(slope) in x,y,z... similar to derivative \n    nor.x = DistanceEstimator(pos + eps.xyy) - DistanceEstimator(pos - eps.xyy);\n    nor.y = DistanceEstimator(pos + eps.yxy) - DistanceEstimator(pos - eps.yxy);\n    nor.z = DistanceEstimator(pos + eps.yyx) - DistanceEstimator(pos - eps.yyx);\n    return normalize(nor);\n}\n\n#define LIGHT_POS_1 20.0*vec3(-0.3, 0.15, 1.0)\n#define LIGHT_POS_2 20.0*vec3(-0.33, -0.2, -1.0)\n#define LIGHT_COL_1 vec3(1.0, 7.0/8.0, 3.0/4.0)\n#define LIGHT_COL_2 vec3(1.0, 3.0/4.0, 7.0/8.0)\n\nfloat saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\n\n\n//allows to make a visible sun\nvec3 getSkyColor(in vec3 rd)\n{\n    vec3 lightDir1 = normalize(LIGHT_POS_1);\n    vec3 lightDir2 = normalize(LIGHT_POS_2);\n    float ld1 = max(dot(lightDir1, rd), 0.0);\n    float ld2 = max(dot(lightDir2, rd), 0.0);\n    vec3 final = vec3(0.125);\n    \n    //skybox color\n    //if ((rd.y > abs(rd.x)) && (rd.y > abs(rd.z * 0.25))) final = vec3(2.0) * rd.y;\n    //float roundBox = length(max(abs(rd.xz/max(0.0, rd.y)) - vec2(0.9, 4.0), 0.0)) - 0.1;\n    //final += vec3(0.8) * pow(saturate(1.0 - roundBox * 0.5), 6.0);\n    \n    const float SUN_INSTENSITY = 200.0;\n    const float SUN_REFLECTION_OBJECT = SUN_INSTENSITY /2.0;\n    \n    //sun1\n    final += pow(LIGHT_COL_1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 10.0);\n    final += LIGHT_COL_1 * pow(ld1, SUN_REFLECTION_OBJECT);\n    //sun2\n    final += pow(LIGHT_COL_2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 10.0);\n    final += LIGHT_COL_2 * pow(ld2, SUN_INSTENSITY);\n    \n    return final;\n}\n\n\n\n#define MAX_TOLERANCE 0.001\n#define MAX_RAY_LENGTH 32.0\n#define MAX_RAY_MARCHES 144.0\n#define VIOLET vec3(0.50, 0.0, 0.8);\n#define DARK_BLUE vec3(0.20, 0.0, 1.0);\n#define WHITE vec3(1.0)    \n\n\n//ro: ray origin\n//rd: ray direction(normalize vector)\n\n//RAYMARCHING: a form to implement raytracing\nfloat RayMarch(in vec3 ro, in vec3 rd)\n{\n    float distanceOrigin = 0.1;\n    for(int i = 0; i < int(MAX_RAY_MARCHES); i++)\n    {\n        vec3 pos = ro + distanceOrigin * rd;\n        float distance = DistanceEstimator(pos);\n        if (distance < MAX_TOLERANCE || distanceOrigin > MAX_RAY_LENGTH) break;//miss the ray\n        distanceOrigin += distance;//add shortest distance\n    }\n    return distanceOrigin;\n}\n\n//post proccessing\n//ld: ligth direction\nfloat DiffuseLighting(in vec3 nor, in vec3 ld)\n{\n    //the result tends to 1 if the normal and ligth are are pointing the same way\n    return max(dot(nor,ld), 0.0);\n}\n\n//allows to show the origin of the ligth source on screen\nfloat Specular(in vec3 nor, in vec3 ld, in vec3 rd)\n{\n    return pow(max(dot(reflect(ld, nor), rd),0.0), 75.0);\n}\n\n//basic shadows\nfloat SoftShadow(in vec3 pos, in vec3 ld, float mint, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 32; i++)\n    {\n        //applies shadow base on the geometry render\n        float distance = DistanceEstimator(pos + ld*t); \n        res = min(res, k*distance/t);\n        t += max(distance, mint*0.2);\n    }\n    return clamp(res, 0.25, 1.0);\n}\n\n\n//render: call the raymarch function, base on result compute a color\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    vec3 skyColor = mix(vec3(0.8, 0.8, 1.0) * 0.3, vec3(0.8, 0.8, 1.0)*0.6, rd.y * 0.75 + 0.25);\n    vec3 sphereColor =  vec3(0.75, 0.70, 1.00);\n    vec3 aggregateColor = vec3(0.0);\n    vec3 lightPosition =  vec3(1.5, 3.0, -1.0) * -2.0;\n\n   \n    float agregateReflectionFactor = 1.0;\n    \n    //applies refractions by recalculate point(RAYTRACING MAGIC)\n    for(int i =0; i < 3; i++)\n    {\n        float t = RayMarch(ro, rd);//distance to object    \n        //ray intersect object\n        if (t < MAX_RAY_LENGTH) \n        {\n            //diffuse ligth contact the surface of object\n            vec3 position = ro + t * rd; \n            vec3 lightDir = normalize(position - lightPosition);\n            float d = DiffuseLighting(normal(position), lightDir);//ambient light\n            //specular lighting\n            //float spec = Specular(normal(position), lightDir, rd);\n            //add shadows \n            float shadow = SoftShadow(position, lightDir, 0.01, 16.0);\n            //get sky reflection(easy way) \n            vec3 reflectionDir =  reflect(rd, normal(position));\n            \n            aggregateColor += agregateReflectionFactor * reflectionFactor * sphereColor * d * shadow;\n            agregateReflectionFactor *= 1.0 - reflectionFactor;\n            ro = position;\n            rd = reflectionDir;\n        }\n        else\n        {\n            aggregateColor += agregateReflectionFactor * getSkyColor(rd);//ray missed\n            break;\n        }\n        \n    }\n    \n    return aggregateColor;\n}\n\nvec3 tonemapping(in vec3 col)\n{   \n    return col / (1.0 + col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 outputColor = vec3(0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\t\n   //camera setup\n    vec3 ro = vec3(5.0, 2.0, 2.0);   \n    \n    //rotation especcify the axis view\n    Rotate(ro.xz, iTime*0.25);\n    \n    vec3 ww = normalize(vec3(0.0, -1.0, 0.0)-ro);//z\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));//x\n    vec3 vv = normalize(cross(ww,uu));//y\n    \n    //ray direction\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.5 * ww);   \n    //get distance to object\n    outputColor = Render(ro + vec3(0.25, 0.25, 0.0), rd);\n    // Output to screen\n    fragColor = vec4(outputColor,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}