{
    "Shader": {
        "info": {
            "date": "1487071987",
            "description": "Landscapes defined on a grid",
            "flags": 32,
            "hasliked": 0,
            "id": "4dlczH",
            "likes": 25,
            "name": "Scrolling Terrain",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "landscape"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1418
        },
        "renderpass": [
            {
                "code": "// \"Scrolling Terrain\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Cycles through height functions described in \"Terrain Explorer\"; terrain height\n  precomputation on a grid is faster than on-the-fly while raymarching, but height\n  resolution is limited by grid spacing (mouse enabled).\n*/\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\n\nvec3 hbSize, rdSign, vnBlk, ltDir;\nvec2 qcHit, qgHit, gShift;\nfloat tCur, dstFar, gSize;\nint idObj;\nconst float pi = 3.14159;\n\nfloat SurfDst (vec3 p)\n{\n  vec2 cg;\n  float h;\n  qgHit = (p.xz + 0.5) * (gSize - 1.);\n  cg = floor (qgHit);\n  if (min (cg.x, cg.y) >= 0. && max (cg.x, cg.y) < gSize - 1.) {\n    qcHit = cg;\n    qgHit -= cg;\n    h = mix (mix (Loadv4 (cg).x, Loadv4 (cg + vec2 (0., 1.)).x, qgHit.y),\n       mix (Loadv4 (cg + vec2 (1., 0.)).x,\n       Loadv4 (cg + vec2 (1.)).x, qgHit.x), qgHit.x);\n  } else h = 0.;\n  return p.y - h;\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = SurfDst (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, 0.4 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (SurfDst (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return (max (abs (p.x), abs (p.z)) < 0.5 * (1. - 1. / (gSize - 1.))) ? dHit : dstFar;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (SurfDst (p + e.xxx), SurfDst (p + e.xyy),\n     SurfDst (p + e.yxy), SurfDst (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat BBoxDf (vec3 p)\n{\n  float w;\n  w = 0.5 * (1. - 1. / (gSize - 1.));\n  p.y -= 0.07;\n  return max (PrBoxDf (p, vec3 (w, 0.07, w)),\n     - PrBox2Df (p.xz, vec2 (w - 0.01)));\n}\n\nfloat BBoxRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = BBoxDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 BBoxNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (BBoxDf (p + e.xxx), BBoxDf (p + e.xyy),\n     BBoxDf (p + e.yxy), BBoxDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen, rsLen;\n  vec3 eWid;\n  float dMin, d;\n  dMin = dstFar;\n  sLen = vec4 (hbSize + 0.005, 0.);\n  rsLen = vec4 (sLen.xyz * rdSign, 0.);\n  eWid = vec3 (0.002);\n  p.y -= 0.07;\n  d = min (min (\n     PrBoxDf (p - rsLen.xww, eWid + sLen.wyz),\n     PrBoxDf (p - rsLen.wyw, eWid + sLen.xwz)),\n     PrBoxDf (p - rsLen.wwz, eWid + sLen.xyw));\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  p = abs (p);\n  d = min (min (\n     PrBoxDf (p - sLen.wyz, eWid + sLen.xww),\n     PrBoxDf (p - sLen.xwz, eWid + sLen.wyw)),\n     PrBoxDf (p - sLen.xyw, eWid + sLen.wwz));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  ro.y -= 0.07;\n  v = ro / rd;\n  tp = (hbSize + 0.005) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat BlkHitSil (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  ro.y -= 0.07;\n  v = ro / rd;\n  tp = (hbSize + 0.01) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  col = vec3 (0.1, 0.2, 0.4) + 0.2 * (1. - max (rd.y, 0.)) +\n     0.1 * pow (max (dot (rd, ltDir), 0.), 16.);\n  col = mix (col, vec3 (0.8), clamp (0.2 + Fbm2 (0.02 *\n     (ro.xz + 2. * tCur + rd.xz * (100. - ro.y) / max (rd.y, 0.001))) * rd.y, 0., 1.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec3 col)\n{\n  vec3 vn, rs;\n  float dstSurf, dstBBox, dstFrm, spec, f, h;\n  if (BlkHitSil (ro, rd) < dstFar) {\n    dstBBox = BBoxRay (ro, rd);\n    if (dstBBox < dstFar) {\n      if (SurfDst (ro + dstBBox * rd) > 0.) dstBBox = dstFar;\n    }\n    dstSurf = SurfRay (ro, rd);\n    rdSign = sign (rd);\n    dstFrm = ObjRay (ro, rd);\n    if (dstSurf < min (min (dstFrm, dstBBox), dstFar)) {\n      ro += dstSurf * rd;\n      h = 90. * ro.y;\n      rs = ro;\n      rs.xz += gShift / gSize;\n      if (h < 0.85) {\n        rd = reflect (rd, VaryNf (51. * rs, vec3 (0., 1., 0.), 0.5));\n        col = 0.8 * SkyCol (ro, rd);\n      } else {\n        vn = VaryNf (107. * rs, SurfNf (ro), 10.);\n        f = 0.1 + 0.9 * smoothstep (0.3, 0.7, Fbm2 (43. * rs.xz));\n        col = mix (mix (vec3 (0.2, 0.35, 0.1), vec3 (0.1, 0.3, 0.15), f),\n           mix (vec3 (0.3, 0.25, 0.2), vec3 (0.35, 0.3, 0.3), f),\n           smoothstep (1., 3., h));\n        col = mix (vec3 (0.4, 0.3, 0.2), col, smoothstep (0.2, 0.6, abs (vn.y)));\n        col = mix (col, vec3 (0.75, 0.7, 0.7), smoothstep (5., 8., h));\n        col = mix (col, vec3 (1.), smoothstep (7., 9., h) *\n           smoothstep (0., 0.5, abs (vn.y)));\n        spec = mix (0.1, 0.5, smoothstep (8., 9., h));\n        col = col * (0.2 + 0.1 * vn.y + 0.7 * max (dot (vn, ltDir), 0.)) +       \n           spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);\n        col = pow (col, vec3 (0.8));\n      }\n    } else if (min (dstFrm, dstBBox) < dstFar) {\n      if (dstBBox < dstFrm) {\n        ro += rd * dstBBox;\n        vn = BBoxNf (ro);\n        col = vec3 (0.5, 0.5, 0.3);\n        col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +       \n           0.15 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n      } else if (dstFrm < dstFar) {\n        ro += rd * dstFrm;\n        vn = ObjNf (ro);\n        vn = VaryNf (201. * ro, vn, 2.);\n        if (idObj == 1) col = vec3 (0.4, 0.4, 0.3);\n        else if (idObj == 2) col = vec3 (0.6, 0.6, 0.4);\n        col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n           0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n      }\n    }\n    if (BlkHit (ro, rd) < dstFar) col = mix (col,\n       vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vnBlk, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vnBlk))), 64.),\n       pow (1. - abs (dot (rd, vnBlk)), 5.));\n    col = clamp (col, 0., 1.);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 512.) ? 512. : ((canvas.y >= 256.) ? 256. : 128.);\n  gShift = Loadv4 (vec2 (0., 0.)).yz;\n  hbSize = vec3 (0.5, 0.07, 0.5);\n  az = pi * sin (2. * pi * mod (0.005 * tCur, 1.));\n  el = cos (2. * az);\n  el = 0.15 * pi + 0.15 * pi * el * el;\n  if (mPtr.z > 0.) {\n    el = clamp (el - 2. * mPtr.y, 0.05 * pi, 0.4 * pi);\n    az -= 6. * mPtr.x;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = vec3 (0., 0., -6. * hbSize.z) * vuMat;\n  rd = normalize (vec3 (uv, 5.8)) * vuMat;\n  dstFar = 8. * hbSize.z;\n  ltDir = normalize (vec3 (1., 1., -1.)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd, vec3 (0., 0., 0.2 + 0.1 * uv.y)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.75);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return textureLod (txBuf, (vId + 0.5) / txSize, 0.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Scrolling Terrain\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 gShift;\nfloat tCur, nStep, gSize, grType, fWav, aWav, hFac;\nconst mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\nconst float pi = 3.14159;\n\nfloat GrndHt1 (vec2 p)\n{\n  vec2 q;\n  float f, wAmp;\n  q = p;\n  f = 0.;\n  wAmp = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= aWav;\n    q *= fWav * qRot;\n  }\n  return min (5. * Noisefv2 (1.4 * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt2 (vec2 p)\n{\n  vec3 v;\n  vec2 q, t;\n  float wAmp, f;\n  q = p;\n  wAmp = 1.;\n  t = vec2 (0.);\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    v = Noisev3v2 (q);\n    t += v.yz;\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= aWav;      \n    q *= fWav * qRot;\n  }\n  return min (5. * Noisefv2 (1.4 * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt3 (vec2 p)\n{\n  vec2 q, t, ta, v;\n  float wAmp, pRough, f;\n  q = p;\n  wAmp = 0.3;\n  pRough = 1.;\n  f = 0.;\n  for (int j = 0; j < 3; j ++) {\n    t = q + 2. * Noisefv2 (q) - 1.;\n    ta = abs (sin (t));\n    v = (1. - ta) * (ta + abs (cos (t)));\n    v = pow (1. - v, vec2 (pRough));\n    f += (v.x + v.y) * wAmp;\n    q *= fWav * qRot;\n    wAmp *= aWav;\n    pRough = 0.7 * pRough + 0.2;\n  }\n  return min (5. * Noisefv2 (1.4 * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt4 (vec2 p)\n{\n  vec3 v;\n  vec2 q, t;\n  float wAmp, b, sp, f;\n  q = p;\n  wAmp = 1.;\n  t = vec2 (0.);\n  f = 0.;\n  sp = 0.;\n  for (int j = 0; j < 4; j ++) {\n    v = Noisev3v2 (q);\n    t += pow (abs (v.yz), vec2 (5. - 0.5 * sp)) - smoothstep (0., 1., v.yz);\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= - aWav * pow (0.7, sp);\n    q *= fWav * qRot;\n    ++ sp;\n  }\n  b = 0.5 * (0.5 + clamp (f, -0.5, 1.5));\n  return 3. * f / (b * b * (3. - 2. * b) + 0.5) + 1.;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float ht;\n  p *= 10.;\n  if      (grType == 1.) ht = GrndHt1 (p);\n  else if (grType == 2.) ht = GrndHt2 (p);\n  else if (grType == 3.) ht = GrndHt3 (p);\n  else if (grType == 4.) ht = GrndHt4 (p);\n  ht = max (ht, 0.);\n  return hFac * ht;\n}\n\nvec2 TrackPath ()\n{\n  vec2 gp;\n  float s, t, cCount;\n  t = nStep * 0.002;\n  s = mod (t, 11.);\n  if (s < 7.) gp = (s < 4.) ? vec2 (0., s) : vec2 (s - 4., 4.);\n  else gp = (s < 9.) ? vec2 (3., 11. - s) : vec2 (12. - s, 2.);\n  cCount = floor (t / 11.);\n  if (mod (cCount, 2.) == 0.) gp.x *= -1.;\n  else gp.x -= 1.;\n  gp.y += 2. * cCount;\n  return gp;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec2 canvas, pxIv, s;\n  float todCur, grTypeB;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  todCur = iDate.w;\n  gSize = (canvas.y >= 512.) ? 512. : ((canvas.y >= 256.) ? 256. : 128.);\n  pxIv = floor (fragCoord);\n  if (max (pxIv.x, pxIv.y) >= gSize) discard;\n  if (iFrame <= 5) {\n    grTypeB = 1. + mod (floor (todCur), 4.);\n    nStep = 100. * grTypeB;\n  } else {\n    nStep = Loadv4 (vec2 (0., 0.)).w;\n    grTypeB = Loadv4 (vec2 (1., 0.)).w;\n  }\n  ++ nStep;\n  grType = 1. + mod (grTypeB + floor (nStep / 5500.), 4.);\n  fWav = 2.;\n  aWav = 0.5;\n  hFac = 0.015;\n  gShift = floor (gSize * TrackPath ());\n  s = (pxIv + gShift) / gSize;\n  stDat = vec4 (GrndHt (s), 0., 0., 0.);\n  if (pxIv.y == 0.) {\n    if (pxIv.x == 0.) stDat.yzw = vec3 (gShift, nStep);\n    else if (pxIv.x == 1.) stDat.yzw = vec3 (0., 0., grTypeB);\n  }\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 s, t;\n  vec2 ip, fp, u;\n  ip = floor (p);\n  fp = fract (p);\n  u = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  s = vec4 (t.y - t.x, t.w - t.z, t.z - t.x, t.x - t.y + t.w - t.z);\n  return vec3 (t.x + s.x * u.x + s.z * u.y + s.w * u.x * u.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (s.xz + s.w * u.yx));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return textureLod (txBuf, (vId + 0.5) / txSize, 0.0);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}