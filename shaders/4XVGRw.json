{
    "Shader": {
        "info": {
            "date": "1717430231",
            "description": "it's a duck, fr",
            "flags": 0,
            "hasliked": 0,
            "id": "4XVGRw",
            "likes": 8,
            "name": "signed distance duck",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "duck"
            ],
            "usePreview": 0,
            "username": "dottedboxguy",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "//thxs to iq for the SDFs and a few other things\n\n#define MAXSTEP 1024\n#define MAXDIST 20.0\n#define MINDIST 0.001\n\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\nfloat opUnion( float d1, float d2 ){\n    return min(d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 ){\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( in float d1, in float d2, in float k ){\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( in float d1, in float d2, in float k ){\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.yz), p.x );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdSphere(in vec3 p, in float r){\n    return length(p) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBody(in vec3 p){\n    vec3 p_cap = p;\n    vec3 offset_main = vec3(.18, 0., 0.);\n    float d = sdCapsule(p_cap, -offset_main, offset_main, .5);\n    vec3 p_box = p - vec3(.5, .0, .5);\n    d = opSmoothSubtraction(sdRoundBox(p_box, vec3(.7 , 1., .3), .1), d, .8);\n    float h_r = .3;\n    vec3 p_head = p - vec3(.25, .0, .3);\n    d = opSmoothUnion(d, sdSphere(p_head, h_r), .05);\n    \n    return d;\n}\n\nfloat sdBeak(in vec3 p){\n    return sdRoundCone(p - vec3(.5, .0, .28), .1, .05, .12);\n}\n\nfloat sdEyes(in vec3 p){\n    vec3 p_e = p;\n    p_e -= vec3(.5, .1, .42);\n    return opUnion(sdSphere(p_e, 0.05), sdSphere(p_e-vec3(0., -.2, 0.), 0.05));\n}\n\nfloat sdGlowyBits(in vec3 p){\n    vec3 p_e = p;\n    p_e -= vec3(.5, .14, .45);\n    return opUnion(sdSphere(p_e, 0.05), sdSphere(p_e-vec3(.015, -.205, 0.), 0.05));\n}\n\nfloat sdDuckie(in vec3 p, out vec3 color){\n    vec3 dp = p*rotate_z(iTime-3.);\n    float d_body = sdBody(dp);\n    float d_beak = sdBeak(dp);\n    color = mix(vec3(.929, .784, .125), vec3(.992, .322, .255), clamp(30.*(d_body-d_beak+.01), 0., 1.));\n    float d_duck = opSmoothUnion(d_body, d_beak, .01);\n    float d_eyes = sdEyes(dp);\n    color = mix (color, vec3(.1), clamp(80.*(d_duck-d_eyes), 0., 1.));\n    float d_glow = opIntersection(sdGlowyBits(dp), d_eyes);\n    color = mix (color, vec3(.9), clamp(80.*(d_duck-d_glow), 0., 1.));\n    return d_duck;\n    //return d_beak;\n    //return sdRoundBox(p, vec3(.7 , 1., .3), .0);\n}\n\nfloat map(in vec3 p, out vec3 color){\n    //float d = sdSphere(p, 1.5);\n    float d = sdDuckie(p, color);\n    //color = vec4(gridTexture(color.yw));\n    return d;\n}\n\nvec3 render(in vec3 p, in vec2 fragCoord){\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 dir = normalize(vec3(uv.x, 1.0, uv.y));\n    vec3 color = vec3(0.);\n    float init_d =  map(p + dir, color);\n    float d = init_d;\n    float t = d;\n    \n    for (int i = 0; i < MAXSTEP; i++){\n        if (d < MINDIST*init_d){\n            return color;\n        }\n        else if (t > MAXDIST){\n            return vec3(1.);\n        }\n        d = map(p + dir*t, color);\n        t += d;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //vec3 p = vec3(cos(iTime), -4.0, sin(iTime));\n    //vec3 p = vec3(0.);\n    vec3 p = vec3(0., -5. + cos(8.*iTime), 0.);\n    //vec3 p = vec3(0., -5., 0.);\n \n    vec3 col = render(p, fragCoord).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}