{
    "Shader": {
        "info": {
            "date": "1708934389",
            "description": "Innovative shader enabling endless noise scaling with a single texture sample.",
            "flags": 32,
            "hasliked": 0,
            "id": "4XS3zt",
            "likes": 8,
            "name": "One Tap Infinite Fractal Tiling",
            "published": 3,
            "tags": [
                "fractal",
                "voronoi",
                "noise",
                "texture",
                "fast",
                "zoom",
                "cheap",
                "worley",
                "tiling",
                "infinite",
                "scaling",
                "octave"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 440
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \\\"Software\\\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI wrote this experiment for cost-effective fractal noise scaling. The concept involves \nusing a texture's four channels to store noise of varying grid sizes for blending, \nto zoom in or out infinitly. \n\nSeveral variations have been implemented, including using unique seeds per layer or \nremoving the highest octave. The last channel can be a tiling version of the first, \nenabling indefinite noise scaling.\n\nDespite limitations with texture size and too large LACUNARITY causing visible \nresolution switches, these can be managed by keeping the texture smaller on screen \nand bakeing then noise into an actual texture with MIP-levels.\n\nThis technique is an efficient way to add detailed noise of different scales, such as \nto terrain, ensuring there's always larger noise applying variation regardless of \ndistance. It works with any noise function, like Voronoi, Perlin or Alligator, with \nsome modifications probably grayscale textures too.\n\nThe shader has several controls: the mouse’s x-axis controls the zoom while the \ny-axis controls the fractal height, with additional settings in the global parameters \nat the top of the Common code.\n\nAdditional reading material:\n\nHere is my ShaderToy implementation of Alligator noise that also works with this: \nhttps://www.shadertoy.com/view/4fX3D8\n\nAlternatively, a cheap non-repeating quasi Voronoi using Penrose tiling: \nhttps://www.shadertoy.com/view/NscBWM\n*/\n\n// Generates a Zigzag pattern of bilinear weights where height = 0-1 \n// See: https://www.desmos.com/calculator/lxwa15kiqz\nvec4 zigZagBilinear (float height) {\n    // Generate weights\n    float a = clamp(1. - 3. * height, 0., 1.);\n    float b = clamp(1. - abs(1. - 3. * height), 0., 1.);\n    float d = clamp(3. * height - 2., 0., 1.);\n    float c = 1. - a - b - d; // Because sum(weights) = 1\n    \n    // Join and return weights\n    return vec4(a, b, c, d);\n}\n\n// Makes it so the fractal level stays is approriet for any distance, for use in game\n// See https://www.desmos.com/calculator/k9frm4j29c\nfloat levelFromDistance(float dist, float fractalScale) {    \n    // UVs and Distance should be roughly the same scale, usually cm \n    // unless you want fractal be scaled up or down\n    \n    // Can be made constant since fractalScale doesn't change once the texture is baked\n    float oneOverLog = 1. / log(fractalScale); \n    \n    // level of the fractal. log_fractalScale(distance)\n    return log(dist) * oneOverLog; \n}\n\n// Defines a struct to hold the fractal parameters\nstruct fractal { vec4 weights; float scale;  float mipOffset; };\n\n// Generate parameters to sample a texture\nfractal fractalParameters(float level, float fractalScale) {\n    \n    // Index of which grid we are on, to scale the UVs\n    float id = floor(level);\n    \n    // Repeating 0-1 scale for which channel to select\n    float grid = level - id;\n    \n    // Generate Bilinear weights from a 0-1 range for blending channels\n    vec4 weights = zigZagBilinear(grid);\n    \n    // Scale for UVs so channel A switches seamlessly to channel R\n    float scale = pow(fractalScale, id);\n    \n    // Can be made constant since fractalScale doesn't change once the texture is baked\n    float logtwo = log2(fractalScale); \n    \n    // Offset for the mip level\n    float mipOffset = id * logtwo;\n\n    // Return struct cause 6 floats don't fit otherwise\n    return fractal(weights,scale,mipOffset);\n}\n\n// Samples Noise Texture and blends them based on level\nfloat FractalNoiseSample(sampler2D sam, vec2 uv, float level, float fractalScale) {\n    \n    // Generate the parameters for the \n    fractal params = fractalParameters(level, fractalScale);\n\n    // Get the mip level from the current unscaled parameters + fractal offset\n    // It is really hard to get this higher than 0, so could be a constant 0\n    float mipLevel = getMipLevel(sam, uv) + params.mipOffset;\n    \n    // Scale the UVs to the current fractal level\n    vec2 scaledUV = uv * params.scale;\n\n    // Bilinear weights from a 0-1 range for blending channels\n    vec4 weights = params.weights;\n    \n    // Optional contrast so the channels are easier to separate with the mouse\n    //weights = smoothContrast(weights, 1.6);\n    \n    // Sample Noise Texture. Fract only used because we sample buffer, else pointless\n    // Technically buffers don't have mips, but when you use a proper texture you need it\n    vec4 noiseTex = textureLod(iChannel0, fract(scaledUV), mipLevel);\n    \n    // Bilinear interpolation between the channels\n    float noise = noiseTex.x * weights.x +\n                  noiseTex.y * weights.y +\n                  noiseTex.z * weights.z +\n                  noiseTex.w * weights.w;\n                  \n    #ifdef UNIQUE\n        // Modified version of FabriceNeyret2 https://www.shadertoy.com/view/4dcSDr \n        float squaredAlphaSum = dot(weights, weights);       \n\n        // Sampling mips lowest level to get the mean. Can be a constant if known.\n        float mean = 0.5; //textureLod(iChannel0, uv, 12.).x; \n\n        // Variance restoration with normalization (very visible in the Stars)\n        noise = mean + (noise - mean) / sqrt(squaredAlphaSum);\n    #endif\n    // If we have octaves in the channels we don't need to correct the variance\n    \n    return noise;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Square UVs with (0.5,0.5) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5;\n        \n    // Apply a 1.1 scale on coordinates (0.5,0.5)\n    uv = (uv - 0.5) * 1.1 + 0.5;\n\n    // Index of which grid we are on, to scale the UVs\n    float fractalScale = fractalScale(LACUNARITY);\n\n    // If the mouse was not clicked, animate\n    float level;\n    float zoom = 1.;\n    vec2 cursor;\n    if (iMouse.x > 0.0) {\n        // Scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls the height of the noise slice\n        level = mix(-0.25, 1.25, mouse.x);\n        \n        // Mouse controls zoom with steps\n        float steps = 9.0;\n        zoom = pow(fractalScale, mix(-1.0, 1.0, floor(mouse.y * steps) / (steps - 1.)));\n        \n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse2 = iMouse.xy / iResolution.y;\n        vec2 coords = fragCoord / iResolution.y;\n        \n        // Generate Mouse coursor, x = mouse color, y = mouse weight \n        float mouseSize = 0.015;\n        float mouseDist = length(coords - mouse2); \n        float aa = fwidth(mouseDist); // cheap anti-aliasing factor\n        cursor.x = smoothstep(mouseSize*0.5 + aa, mouseSize*0.5 - aa, mouseDist);\n        cursor.y = smoothstep(mouseSize + aa, mouseSize - aa, mouseDist);\n        \n    } else {           \n        // Animated height of the noise slice, with \\\"optional\\\" fract against float errors\n        level = fract(iTime * 0.2); \n        \n        // Animated zoom in\n        //float stairs = floor(level-0.5)+smoothstep(0.4, 0.6, fract(level-0.5));\n        zoom = pow(fractalScale, level);\n    }\n    \n    // Apply zoom on coordinates (0,0) point\n    uv /= zoom;\n    \n    // Sample the fractal noise\n    float noise = FractalNoiseSample(iChannel0, uv, level, fractalScale);\n    \n    // Apply cosmetic colormap to grayscale noise\n    vec3 color = inferno(noise);\n\n    // Add lines on the smaller tiling of the grid\n    #ifdef SHOWGRID        \n        // Scale UV\n        vec2 fractalUV = uv * pow(fractalScale, floor(level));\n    \n        // Calculate anti-aliasing effect\n        vec2 uvFwidth = fwidth(fractalUV);\n        float aa = max(uvFwidth.x, uvFwidth.y) *3.;\n    \n        // Add lines on the edges of the grid\n        vec2 grid = abs(fract(fractalUV) * 2.0 - 1.0);\n        color *= smoothstep(THICKNESS -aa, THICKNESS +aa, 1.-max(grid.x, grid.y));  \n    #endif\n    \n    // Add mouse cursor\n    color = mix(color, vec3(cursor.x), cursor.y);\n\n    // Return to the screen\n    fragColor = vec4(color, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// GENERATE NOISE TEXTURE ________________________________________________________________\n\n// This function calculates the sum of grid sizes across all octaves in a procedural noise generation process.\nfloat sumGridSizes(float gridSize, int octaves, float lacunarity) {\n\n    // Loop over all octaves\n    float sum = 0.0;\n    for (int n = 0; n < octaves; ++n) {\n    \n        // Add the grid size of the current octave to the sum\n        sum += gridSize * pow(lacunarity, float(n));\n    }\n    \n    // Return the total sum\n    return sum;\n}\n\n// Generates a channel-packed noise texture for fractal noise scaling\nvec4 fractalNoiseGen(vec2 position, float gridsize, int octaves, float lacunarity, float persistence) {\n    \n    // Initialize the \"constants\" \n    uvec2 seed = uvec2(421); // Can be any positive integer\n    float fracScale = fractalScale(lacunarity);\n    \n    // Initialize the variables \n    // For Amplitude math, see: https://www.desmos.com/calculator/xgqeepapwn\n    vec4 amplitude = vec4(1);\n    vec4 amplitudeSum = vec4(0);  \n    float activeGridSize = gridsize;\n    uvec2 activeSeed = seed;\n    vec4 result = vec4(0);  \n    \n    // Whether each layer is unique or just fades out octaves\n    #ifdef UNIQUE\n        // Loop over the 4 color channels\n        for (int i = 0; i < 4; ++i) {\n        \n            #ifdef FRACTAL\n                // Reset the noise ever 3 octaves except for the first one\n                if((i-1) % 3 == 2 && i != 0) {\n                    position *= fracScale;\n                    activeGridSize = gridsize;                    \n                    activeSeed = seed;\n                }\n            #endif\n            \n            // Generate noise using the noise function and assign it to the current color component\n            result[i] = octaveNoise(position, activeGridSize, octaves, lacunarity, persistence, activeSeed);\n            \n            // Increase frequency for the next octave\n            activeGridSize *= lacunarity;\n            \n            // Update the seed with the sum of grid sizes for all octaves so nothing repeats\n            activeSeed += uvec2(sumGridSizes(activeGridSize, octaves, lacunarity));\n            \n        }    \n    #else\n        // For each Octave + 3\n        for(int i = 0; i < octaves + 3; ++i) {\n        \n            #ifdef FRACTAL\n                // Reset the noise ever 3 octaves except for the first one\n                if((i-1) % 3 == 2 && i != 0) {\n                    position *= fracScale;\n                    activeGridSize = gridsize;                    \n                    activeSeed = seed;\n                }\n            #endif\n            \n            // Sample noise\n            float noise = voronoi(position, uint(activeGridSize), activeSeed);\n            \n            // Add noise to all results where the octave is not skipped\n            for(int j = 0; j < 4; ++j) {\n\n                // If the octave index is smaller than the channel index\n                if(i >= j && i < octaves + j) {\n                \n                    // Apply amplitude and store noise\n                    result[j] += noise * amplitude[j];\n                    \n                    // Add up amplitude to normalize result later\n                    amplitudeSum[j] += amplitude[j];\n                    \n                    // Decrease amplitude for the next octave\n                    amplitude[j] *= persistence;\n                }\n            }\n           \n            // Increase frequency for the next octave\n            activeGridSize *= lacunarity;\n            \n            // Change seed/offset noise so it is unique for the next octave\n            activeSeed += uvec2(activeGridSize);\n        }\n\n        // Normalize the result to 0-1 range\n        result /= (amplitudeSum);        \n    #endif\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Generate Noise Texture and store in buffer, if you can bake into proper texture with mips\n    fragColor = fractalNoiseGen(uv, GRIDSIZE, OCTAVES, LACUNARITY, PERSISTENCE);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// GLOBAL CONSTANTS____________________________________________________\n\n// Number of noise Layers, value range 1-inf\n#define OCTAVES 8\n\n// Size of the noise cells, value range 1-inf\n#define GRIDSIZE 4.0\n\n// Scaling of successive octaves, value range 1-inf\n#define LACUNARITY 1.7\n\n// Amplitude reduction of each successive octave, value range 0-1\n#define PERSISTENCE 0.6\n\n// Enable repeating Tiling\n#define TILING\n\n// Enable to show how the results look with unique noise layers for each grid\n//#define UNIQUE\n\n// Enable for infinite scaling, makes the last channel a tiling of the first\n#define FRACTAL\n\n// Enable to show debug-lines for the grid outlines\n#define SHOWGRID\n#define THICKNESS 0.01 // of the debug-lines\n\n// GENERIC FUNCTIONS ___________________________________________________\n\n// makes inferno colormap with polynimal 6\nvec3 inferno(float t) {\n    const vec3 c0 = vec3(0.000129,0.001094,-0.041044);\n    const vec3 c1 = vec3(0.083266,0.574933,4.155398);\n    const vec3 c2 = vec3(11.783686,-4.013093,-16.439814);\n    const vec3 c3 = vec3(-42.246539,17.689298,45.210269);\n    const vec3 c4 = vec3(78.087062,-33.838649,-83.264061);\n    const vec3 c5 = vec3(-72.108852,32.950143,74.479447);\n    const vec3 c6 = vec3(25.378501,-12.368929,-23.407604);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/629sxxdp5g\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n// Finds the fractal UV scale after applying lacunarity three times\nfloat fractalScale(float lacunarity) {\n    return floor(pow(lacunarity, 3.0));\n}\n\n// MIP FUNCTIONS ____________________________________________________________\n\n// Function to calculate the mip level and the maximum mip level for a texture\n// Based on Unreal Engines ComputeMipLevel Material Function \nfloat getMipLevel(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));\n\n    // Scale the partial derivatives by the texture size\n    vec2 scaledDDX = duvdx * texSize;\n    vec2 scaledDDY = duvdy * texSize;\n\n    // Find the largest rate of change\n    float maxDDLength = max(dot(scaledDDX, scaledDDX), dot(scaledDDY, scaledDDY));\n\n    // Calculate the mip level based on the rate of change\n    return log2(sqrt(maxDDLength));\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\nfloat getMipLevel(sampler2D sam, vec2 uv) {\n    // Mip calculation for testing\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n    \n    // Caculate Mip level\n    return getMipLevel(sam, uv, duvdx, duvdy);\n}\n\n// NOISE FUNCTIONS ______________________________________________________\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n\treturn vec2(q) * SMALLESTFLOAT;\n}\n\n// Function to generate Voronoi noise\nfloat voronoi(vec2 position, uint gridSize, uvec2 seed) {\n\n    #ifdef TILING\n        // Modulo operation may have floating point errors with negative values,\n        // which can break tiling. This fix should be sufficient, hopefully ...\n        position = abs(position + 421.);\n    #endif\n\n    // Scale the position by the grid size\n    position *= float(gridSize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec2 cellCoords = floor(position); // Integer coordinates\n    vec2 fractionalCoords = position - cellCoords; // Fractional coordinates\n    \n    // Initialize the minimum distance to a large value\n    float minSquaredDistance = 8.0;\n    \n    // Loop over the 3x3 grid of cells around the current cell\n    for (int offsetX = -1; offsetX <= 1; offsetX++) {\n        for (int offsetY = -1; offsetY <= 1; offsetY++) {\n            // Calculate the offset vector\n            vec2 offset = vec2(offsetX, offsetY);          \n            \n            // Current cell coordinates\n            vec2 cell = cellCoords + offset;\n\n            #ifdef TILING\n                // This makes the noise repeat between positions 0 and 1\n                cell = mod(cell, float(gridSize));\n            #endif\n   \n            // Generate a random offset for the current cell\n            vec2 randomOffset = hash22(cell + vec2(seed));\n            \n            // Calculate the squared distance to the point in the neighboring cell\n            vec2 diff = fractionalCoords - offset - randomOffset;\n            float squaredDistance = dot(diff, diff);\n            \n            // Update the minimum squared distance\n            minSquaredDistance = min(minSquaredDistance, squaredDistance);\n        }\n    }\n    \n    // Take the square root of the minimum squared distance before returning    \n    return sqrt(minSquaredDistance); \n    // * INV_SQRT_TWO; should be normalized to 0-1 range but ugly and too dark\n}\n\n// Noise with octaves Voronoi in this case\nfloat octaveNoise(vec2 position, float gridsize, int octaves, float lacunarity, float persistence, uvec2 seed) {\n        \n    // Initialize the variables    \n    // For amplitude math, see: https://www.desmos.com/calculator/xgqeepapwn\n    float amplitude = 1.0;\n    float amplitudeSum = 0.0;\n    float result = 0.0;\n    \n    // For each octave\n    for(int i = 0; i < octaves; ++i) {\n        // Sample noise and apply amplitude\n        result += voronoi(position, uint(gridsize), seed) * amplitude;\n        \n        // Add up amplitude to normalize the result later\n        amplitudeSum += amplitude;\n        \n        // Decrease amplitude for the next octave\n        amplitude *= persistence;\n        \n        // Increase frequency for the next octave\n        gridsize *= lacunarity; \n        \n        // Change seed/offset noise so it is unique for the next octave\n        seed += uvec2(gridsize);\n    }\n    \n    // Normalize the result to the 0-1 range\n    result /= amplitudeSum;\n\n    return result;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}