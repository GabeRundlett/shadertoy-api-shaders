{
    "Shader": {
        "info": {
            "date": "1557080432",
            "description": "A modified shader implementation of the Kuwahara filter with some subtle motion.",
            "flags": 32,
            "hasliked": 0,
            "id": "tlX3RX",
            "likes": 41,
            "name": "Painted London",
            "published": 3,
            "tags": [
                "kuwahara",
                "painting",
                "oil"
            ],
            "usePreview": 1,
            "username": "Blokatt",
            "viewed": 3394
        },
        "renderpass": [
            {
                "code": "/*\n\tPainted London.\n\tBy @blokatt.\n\t21/03/19\n\tLast updated: 20/06/19\n\n\tMedian pass.\n*/\n\n#define comp(a, b, c) (v[a].c > v[b].c)\n#define swap(a, b, c) temp = v[b].c; v[b].c = v[a].c; v[a].c = temp;\n#define cmpswap(x, y) if (comp(x, y, r)){ swap(x, y, r)}; if (comp(x, y, g)){ swap(x, y, g)}; if (comp(x, y, b)){ swap(x, y, b)};\n\nvec3 kuwahara(vec2 uv) {\n    return texture(iChannel0, uv).rgb;\n}\n\nvec3 medianSub(vec3 v[9]){\n    float temp;  \n        \n    cmpswap(0, 1); \n    cmpswap(3, 4); \n    cmpswap(6, 7); \n    \n    cmpswap(1, 2); \n    cmpswap(4, 5); \n    cmpswap(7, 8); \n    \n    cmpswap(0, 1); \n    cmpswap(3, 4); \n    cmpswap(6, 7); \n    cmpswap(2, 5); \n    \n    cmpswap(0, 3); \n    cmpswap(1, 4); \n    cmpswap(5, 8); \n    \n    cmpswap(3, 6); \n    cmpswap(4, 7); \n    cmpswap(2, 5); \n    \n    cmpswap(0, 3); \n    cmpswap(1, 4); \n    cmpswap(5, 7); \n    cmpswap(2, 6); \n    \n    cmpswap(1, 3); \n    cmpswap(4, 6); \n    \n    cmpswap(2, 4); \n    cmpswap(5, 6); \n    \n    cmpswap(2, 3); \n    \n    return v[4];\n}\n\nvec3 median(in vec2 uv){\n\tvec2 pixel = 1. / iResolution.xy;\n    vec4 o = vec4(pixel.x, 0., pixel.y, -pixel.y); \n    vec3 n[9];\n    n[0] = kuwahara(uv - o.xz);  \n    n[1] = kuwahara(uv - o.yz);\n    n[2] = kuwahara(uv + o.xw);\n    n[3] = kuwahara(uv - o.xy);\n    n[4] = kuwahara(uv + o.xy);\n    n[5] = kuwahara(uv - o.xw);\n    n[6] = kuwahara(uv + o.yz);\n    n[7] = kuwahara(uv + o.xz);     \n    n[8] = kuwahara(uv);  \n    return medianSub(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = median(uv);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tPainted London.\n\tBy @blokatt.\n\t21/03/19\n\tLast updated: 20/06/19\n\n\tKuwahara pass.\n*/\n\n\n#define BRUSH_SIZE 5.0\n#define WINDOW_SIZE 7\n#define DEPTH_PER_CHANNEL 64\nconst int REGION_SIZE = (WINDOW_SIZE + 1) / 2;\nconst int REGION_N = REGION_SIZE * REGION_SIZE;\n\nvec3 contrast(vec3 col, float contrast) {\n\treturn (col - .5) * 1.2 + .5;\n}\n    \nmat2 rotate(float a){\n\treturn mat2(\n        cos(a), -sin(a),\n        sin(a), cos(a)\n    );\n}\n\nfloat rand(vec2 uv){\n\treturn fract(sin(dot(vec2(12.9898,78.233), uv)) * 43758.5453123);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 tex(vec2 uv){\n    uv -= .5;    \n    //uv *= 1. - (sin(iTime * .25) * .5 + .5) * .4;\n    uv += .5;\n    vec4 col = texture(iChannel0, uv);\n    float depth = float(DEPTH_PER_CHANNEL);\n    \n    col.r = floor(col.r * depth) / depth;\n    col.g = floor(col.g * depth) / depth;\n    col.b = floor(col.b * depth) / depth;      \n    col.a = rgb2hsv(col.rgb).b;\n    \n\treturn col;\n}\n\nfloat regionMeanValue(vec4 vals[REGION_N]) {\n    float sum = 0.0;\n    \n    for (int i = 0; i < REGION_N; ++i){\n        sum += vals[i].a;\n    }\n    return sum / float(REGION_N);\n}\n\nvec3 regionMean(vec4 vals[REGION_N]) {\n    vec3 sum = vec3(0);\n    for (int i = 0; i < REGION_N; ++i){\n        sum += vals[i].rgb;\n    }\n    return vec3(sum / float(REGION_N));\n}\n\nfloat regionStandardDeviation(vec4 vals[REGION_N], float mean) {\n    float sum = 0.;    \n    \n    for (int i = 0; i < REGION_N; ++i){       \n        float val = vals[i].a - mean;\n        sum += val * val;\n    }\n    return sqrt(sum / float(REGION_N - 1));\n    \n}\n\nvec3 kuwahara(vec2 uv) {\n    vec4 p = vec4(dFdx(uv.x), dFdy(uv.y), -dFdy(uv.y), 0.);\n    \n    // 5x5    \n    /*\n    A  A  AB   B  B\n\tA  A  AB   B  B\n\tAC AC ABCD BD BD    \t\n\tC  C  CD   D  D    \t\n\tC  C  CD   D  D    \t\n\t*/\n    float angle = iTime;\n    \n    mat2 a = rotate(uv.x + uv.y + rand(uv) + angle) * (BRUSH_SIZE * (sin(iTime * 2.) * .5 + .5));\n    \n    vec4 regVal[REGION_N];\n    for (int y = 0; y < REGION_SIZE; ++y){\n        for (int x = 0; x < REGION_SIZE; ++x){\n        \tregVal[y * REGION_SIZE + x] = tex(uv + a * vec2(-p.x * float(x), -p.y * float(y)));\n        }\n    \n    }\n\n    float meanValueA = regionMeanValue(regVal);\n    vec3 meanA = regionMean(regVal);    \n    float standardDeviationA = regionStandardDeviation(regVal, meanValueA);\n    \n    for (int y = 0; y < REGION_SIZE; ++y){\n        for (int x = 0; x < REGION_SIZE; ++x){\n        \tregVal[y * REGION_SIZE + x] = tex(uv + a * vec2(p.x * float(x), -p.y * float(y)));\n        }   \n    }\n    \n  \n    float meanValueB = regionMeanValue(regVal);\n    vec3 meanB = regionMean(regVal);    \n    float standardDeviationB = regionStandardDeviation(regVal, meanValueB);\n    \n    for (int y = 0; y < REGION_SIZE; ++y){\n        for (int x = 0; x < REGION_SIZE; ++x){\n        \tregVal[y * REGION_SIZE + x] = tex(uv + a * vec2(-p.x * float(x), p.y * float(y)));\n        }   \n    }\n  \n    float meanValueC = regionMeanValue(regVal);\n    vec3 meanC = regionMean(regVal);    \n    float standardDeviationC = regionStandardDeviation(regVal, meanValueC);\n    \n    for (int y = 0; y < REGION_SIZE; ++y){\n        for (int x = 0; x < REGION_SIZE; ++x){\n        \tregVal[y * REGION_SIZE + x] = tex(uv + a * vec2(p.x * float(x), p.y * float(y)));\n        }   \n    }\n    \n    float meanValueD = regionMeanValue(regVal);\n    vec3 meanD = regionMean(regVal);    \n    float standardDeviationD = regionStandardDeviation(regVal, meanValueD);\n    \n    float mostHomogeneous = min(standardDeviationA, min(standardDeviationB, min(standardDeviationC, standardDeviationD)));\n    vec3 outMean = vec3(0);\n    if (mostHomogeneous == standardDeviationA) outMean = meanA;\n    if (mostHomogeneous == standardDeviationB) outMean = meanB;\n    if (mostHomogeneous == standardDeviationC) outMean = meanC;\n    if (mostHomogeneous == standardDeviationD) outMean = meanD;\n    \n    return outMean;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n \n    vec3 col = kuwahara(uv);\n       \n    col = contrast(col, 1.2);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}