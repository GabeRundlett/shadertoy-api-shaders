{
    "Shader": {
        "info": {
            "date": "1690059835",
            "description": "floating ghost =D",
            "flags": 0,
            "hasliked": 0,
            "id": "csBfWy",
            "likes": 3,
            "name": "Floating Ghost",
            "published": 3,
            "tags": [
                "raymarching",
                "ghost"
            ],
            "usePreview": 0,
            "username": "bronson113",
            "viewed": 142
        },
        "renderpass": [
            {
                "code": "#define C(x) clamp(x, 0.0, 1.0)\n\n// To control the scean with a mouse, change the 0 to 1\n#define MOUSE 0\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \nvec2 opUnion(vec2 a, vec2 b){\n    return (a.x<b.x)?a:b;\n}\n// SDF of line segment -> capsul\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Droplet -> line segment, but one side with r = 0 and anthoer side with r = r\nfloat sdDroplet( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r*h;\n}\n\n// Mouth shape\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w )\n{\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}\n\nvec2 DistGhost(vec3 location, float time){\n    float k = .01; //roundness\n    vec2 res;\n    \n    // body\n    float radial_change = cos(atan(location.x/location.z)*20.+time*10.+cos(location.y*3.+1.7)*10.);\n    float to_ground = exp(-(location.y+0.5)*10.);\n    float r = 0.48+.02*(radial_change)*C(to_ground)+0.05*to_ground;\n    float dBody = sdCapsule(location, vec3(0., .5, 0.), vec3(0., -.5, 0.), r);\n\n    // eye hole\n    float dEyeH1 = sdCapsule(location, vec3(0.45, .45, 0.2), vec3(0.45, 0.2, 0.2), 0.05);\n    float dEyeH2 = sdCapsule(location, vec3(0.45, .45, -0.2), vec3(0.45, 0.2, -0.2), 0.05);\n    dBody = max(dBody, -dEyeH1);\n    dBody = max(dBody, -dEyeH2);\n    \n    //mouth hole\n    float dMouth = sdCapsule(location, vec3(0.47, -.13, 0.13), vec3(0.47, -.13, -0.13), 0.02);\n    dBody = opSmoothSubtraction(dBody, dMouth, k);\n    \n    // float\n    float dFloat = location.y + 0.45 + 0.01*sin(radial_change);\n    dBody = max(dBody, -dFloat);\n    res = vec2(dBody, 1.0);\n    \n    \n    // eye\n    float dEye1 = sdCapsule(location, vec3(0.41, .45, 0.19), vec3(0.41, 0.19, 0.19), 0.04);\n    float dEye2 = sdCapsule(location, vec3(0.41, .45, -0.19), vec3(0.41, 0.19, -0.19), 0.04);\n    float dEye = min(dEye1, dEye2);\n    res = opUnion(res, vec2(dEye, 2.0));\n    \n    // mouth\n    float dMouth2 = sdVesicaSegment(location, vec3(0.43, -.13, -0.13), vec3(0.43, -.13, 0.13), 0.05);\n    res = opUnion(res, vec2(dMouth2, 3.0));\n    \n    // water droplet\n    float dDrop = sdDroplet(location, vec3(0.42, -.11, -0.1), vec3(0.465, -.18, -0.1), 0.02);\n    res = opUnion(res, vec2(dDrop, 4.0));\n    \n    \n    \n    return res;\n}\n\nvec2 Dist(vec3 location, float time){    \n    float offset = pow(abs(sin(time*.6)), 2.)*3.-5.;\n    vec2 dGhost = DistGhost(location + vec3(0., offset, 0.)*.1, time);\n    \n    float dFloor = location.y + 0.50;\n    vec2 res = opUnion(dGhost, vec2(dFloor, 0.0));\n    \n    return res;\n}\n\n// get the gradiant of the distant -> normal vector of that \"surface\"\nvec3 Norm(vec3 location, float time){\n/* small step in all direction as our Normal\n    vec2 diff = vec2(0.0005, 0);\n    return normalize( vec3( Dist(location + diff.xyy, time) - Dist(location - diff.xyy, time), \n                            Dist(location + diff.yxy, time) - Dist(location - diff.yxy, time),\n                            Dist(location + diff.yyx, time) - Dist(location - diff.yyx, time)));\n*/\n// https://iquilezles.org/articles/normalsSDF/\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Dist(location+0.0005*e,time).x;\n    }\n    return normalize(n);    \n}\nfloat RayMarching(vec3 ro, vec3 rd, float time){\n    // distant traveled\n    float t = 0.; \n    float maxt = 20.;\n    // ray marching\n    for(float i=0.; i<1000. && t < maxt; i+=1.){\n        // currect location\n        vec3 loc = ro + t*rd;\n        // distant to surface\n        float d = Dist(loc, time).x;\n        \n        // we hit a surface\n        if(d < 0.000001) break;\n        \n        // otherwise march forward\n        t += d;\n    }\n    // max distant: 20, return -1 if didn't hit\n    return t>maxt?-1.:t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float time = iTime;\n\n\n   // camera\t\n\n#if MOUSE==1\n    float an = 10.57*iMouse.x/iResolution.x;\n    float bn = iMouse.y/iResolution.y*1.57;\n    vec3  ta = vec3( 0.0, 0.5, 0.0);                         // pointing at\n    float zoom = 1.;\n    vec3  ro = ta + zoom*vec3( 1.3*cos(an), sin(bn)*2.-0.5, 1.3*sin(an) ); // camera location\n#else\n    float an = time*.392;\n    vec3  ta = vec3( 0.0, 0.5, 0.0);                         // pointing at\n    float zoom = sin(time*.234)*0.5+2.;\n    vec3  ro = ta + zoom*vec3( 1.3*cos(an), sin(an*0.3)*0.4, 1.3*sin(an) ); // camera location\n#endif \n    // frame\n\tvec3 cw = normalize(ta-ro);    // vector pointing toward target\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) ); // vector pointing up\n\tvec3 cv =          ( cross(cu,cw) ); // vector pointing right\n\n    vec3 rd = normalize( p.x*cu + p.y*cv + 1.8*cw ); // actual ray direction from frame\n    \n    \n    // distant to surface\n    float t = RayMarching(ro, rd, time);\n    \n    // sky\n    vec3 col = vec3(0.1, 0.05, 0.03) - max(rd.y,0.0)*0.6;\n    \n    // if we hit something with 20 unit\n    if(t > 0.){\n        // point we hit\n        vec3 loc = ro + rd*t;\n        // normal of that surface\n        vec3 nor = Norm(loc, time);\n        \n        vec2 res = Dist(loc, time);\n        // object color\n        col = vec3(0.0);\n        if(res.y < 0.5){\n            col = vec3(0.03, .12, 0.04);\n        } else if (res.y < 1.5){\n            col = vec3(0.3);\n        } else if (res.y < 2.5){\n            col = vec3(0.01);\n        } else if (res.y < 3.5){\n            col = vec3(.247, .086, .049);\n        } else if (res.y < 4.5){\n            col = vec3(.124, .202, .235);\n        }\n        \n        vec3 lightin = vec3(0.);\n        // moon at 10. 10. -5.\n        vec3 moon_loc = vec3(10., 10., -5.);\n        vec3 moon_dir = normalize(moon_loc-loc);\n        float moon_diffuse = C(dot(moon_dir, nor));\n        \n        //shadow\n        float can_see_moon = step(RayMarching(loc+0.001*moon_dir, moon_dir, time), 0.);\n        \n        // sky\n        float sky_diffuse = C(dot(normalize(vec3(0., 1., 0.)), nor));\n        float sky_diffuse2 = C(dot(normalize(vec3(0., 1., 1.)), nor));\n        \n        // general bounced light\n        float bounced = C(dot(normalize(vec3(0., -1., 0.)), nor));\n        \n        \n        lightin += vec3(5., 5., 4.) * moon_diffuse * can_see_moon;\n        lightin += vec3(0.2, 0.1, .5) * sky_diffuse;\n        lightin += vec3(0.1, 0.15, .25) * sky_diffuse2;\n        lightin += vec3(0.6, 0.4, 0.2) * bounced;\n        col *= lightin;\n        col = mix( col, vec3(0.7,0.4,0.3), 1.0-exp( -0.0001*pow(t, 3.) ) );\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}