{
    "Shader": {
        "info": {
            "date": "1629750658",
            "description": "Inspired by @byt3_m3chanic's experiments with log polar mapping. I still have some more ideas I might try with it. ",
            "flags": 0,
            "hasliked": 0,
            "id": "7dc3D8",
            "likes": 16,
            "name": "Return from space",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "space",
                "logpolar"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 410
        },
        "renderpass": [
            {
                "code": "#define STEPS 200.0\n#define MDIST 150.0\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\nvec3 glow;\n\nvec2 pmodp(vec2 p, float x){\n    float a = atan(p.y,p.x);\n    a = mod(a-x/2.,x)-x/2.;\n    return vec2 (cos(a),sin(a))*length(p);\n}\nfloat vSeg(vec3 p, float h, float r){\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p)-r;\n}\n\nvec2 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    vec3 po = p;\n    float t= mod(iTime,999.);\n    p.xz*=rot(t*0.2);\n\n    //Log-polar mapping from\n    //https://www.osar.fr/notes/logspherical/\n    vec2 p2 = p.xz;\n    float r = length(p2);\n    p2 = vec2(log(r),atan(p2.y,p2.x));  \n    float scl = 12.0/pi;\n    \n    t*=0.65;\n    p2.x+=t;\n    float yoff = 20.5;\n\n    //p.y+=t*scl*(2.0/3.0)*yoff;\n    \n    p2 *= scl;\n    \n    vec2 id = vec2(floor((p2.x)/1.5)+0.5,floor(p2.y/1.5)+0.5);\n    \n    p2 = pmod(p2,1.5);\n\n    p.y-=sin(id.y+t)*0.75;\n    p.y-=sin(id.x+t*2.5)*0.75;\n    \n    float dSpd = 10.0;\n    float uSpd = 15.0;\n    \n    //apply up/down warp-in motion\n    float ring =smoothstep(6.0,9.0,id.x-t*scl*(2.0/3.0))*yoff*dSpd*floor(mod(id.x,2.0));\n          ring -= smoothstep(6.0,9.0,id.x-t*scl*(2.0/3.0))*yoff*uSpd*floor(mod(id.x+1.0,2.0));\n    p.y -= ring;\n    \n    float mul = r/(scl);\n    \n    vec3 p3 = vec3(p2.x, p.y/mul,p2.y);\n     \n    //======BEGIN NON-DOMAIN WARPED SDF======  \n    \n    //Boxes\n    a.x = box(p3,vec3(0.6,0.6+0.15,0.6));\n    a.x = max(a.x,-box(p3,vec3(3.0,0.3,0.3)));\n    //a.x-=0.1;\n    \n    //anti overstep artifact hidden stuff\n        vec3 d = abs(p3)-1.0;\n        float outerBox = max(d.x,d.z);    \n        if(length(po.xz)>0.1) a.x = min(-outerBox,a.x);\n    \n    //=======END NON-DOMAIN WARPED SDF=======\n    a.x*=mul;\n    \n    //if(length(po.xz)<0.3) a.x = 0.1;\n    a.x = max(a.x,(length(p.xz)-20.0));\n    a.x = max(a.x,-(length(p.xz)-0.3)); //this ended up being useless\n    \n    p = po;\n    //GLOWY BEAM THING\n    b.x = length(p.xz)-0.8-sin(p.y-t*10.0)*0.2-sin(p.y*0.3-t*20.0)*0.2-abs(p.y)*0.2;\n    glow+=vec3(0.529,0.400,1.000)*0.1/(0.1+b.x*b.x);\n    \n    a =(a.x<b.x)?a:b;\n    \n    //ROTATING SEGMENTS\n    p.zx*=rot(t);\n    float alpha = atan(p.z,p.x);\n    p.y = abs(p.y)-9.0;\n    p.xz = pmodp(p.zx,pi/16.);\n    p-=vec3(17,sin(alpha*3.0-t)*2.0,0);\n    p.xy*=rot(alpha*1.5-t*3.0);\n    p.y+=2.;\n    \n    b.x = vSeg(p, 4.0,0.4);\n    b.y = 3.0;\n    a =(a.x<b.x)?a:b;\n\n    return a;\n}\n\n\nvec3 norm(vec3 p, float s){\n    vec2 e= vec2(s,0);\n    return normalize(vec3(\n    map(p+e.xyy).x,map(p+e.yxy).x,\n    map(p+e.yyx).x)-vec3(map(p-e.xyy).x,\n    map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime,999.);\n    vec3 ro = vec3(0,2.0+14.0*sin(t),-29.0);\n    \n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.7+uv.x*r+uv.y*cross(f,r));\n    \n    float dO, shad;\n    bool hit = false;\n    vec2 d; vec3 p;\n    \n    for(float i = 0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+= d.x*0.85;\n        \n        if(abs(d.x)<0.005){\n            shad = i/STEPS;\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST; break;\n        }\n    }\n    if(hit){\n        vec3 n = norm(p,0.02);\n        float edge = length(n-norm(p,0.12))*min(1.0,length(p)*0.2);\n        //edge =smoothstep(0.,0.15,edge);\n        \n        if(d.y == 1.0) col = vec3(0.388);\n        if(d.y == 2.0) col = vec3(0.502,0.000,1.000);\n        if(d.y == 3.0) col = vec3(0.388);\n        \n        //Shamelessly stealing blackle's lighting techniques \n        float ao = smoothstep(-.1,.1,map(p+n*.1).x)*\n                   smoothstep(-.3,.3,map(p+n*.3).x)*\n                   smoothstep(-.7,.7,map(p+n*.7).x);\n        vec3 r = reflect(rd, n);\n        float diff = length(sin(n*3.)*.7+.3)/sqrt(3.);\n        float spec = length(sin(r*3.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*.95;\n        col = col*pow(diff,3.0) + pow(spec, 12.)*fres*vec3(0.463,0.490,0.898);\n        col*=ao;\n        \n        if(d.y == 1.0)col+=smoothstep(0.,0.1,edge)*vec3(0.188,0.804,0.910);\n        if(d.y == 3.0)col+=smoothstep(0.,0.15,edge)*vec3(0.659,0.188,0.910)*10.0;\n    }\n\n    col = mix(col,mix(vec3(0.075),vec3(0.),length(uv)),dO/MDIST);\n    col+=glow*0.6;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}