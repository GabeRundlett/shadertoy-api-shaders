{
    "Shader": {
        "info": {
            "date": "1605387755",
            "description": "The result of an ultra-quick coding session.\nA reproduction of a common image.",
            "flags": 0,
            "hasliked": 0,
            "id": "WscBzB",
            "likes": 19,
            "name": "Generations (<2.3Kb)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "chess",
                "reproduction",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 13102
        },
        "renderpass": [
            {
                "code": "// Generations (4K)\n//\n// The result of an ultra-quick coding session.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 123 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define N\tnormalize\n\nstruct H {\n\tfloat d;\n\tvec3 mat;\n\tfloat spe;\n};\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat B(vec3 p, vec3 b) { return length(max(abs(p) - b, 0.)); }\n\nfloat cap(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat P(vec3 p) {\n\tp.y -= 3.2;\n\tfloat d = max(length(p.xz) - .3, p.y);\n\td = smin(d, length(p) - .8, .1);\n\tp.y += 1.05;\n\td = smin(d, cap(p, .75, .07), .5);\n\tp.y += 1.5;\n\td = smin(d, cap(p, .75, .12), .5);\n\tp.y += .4;\n\treturn smin(d, cap(p, .9, .2), .4);\n}\n\nfloat K(vec3 p) {\n\tp.y -= 1.85;\n\tfloat d = cap(p, .4 - .14 * cos(p.y * 1.4 - .8), 2.);\n\tp.y--;\n\td = smin(d, cap(p, .7, .1), .2);\n\tp.y += 2.;\n\td = smin(d, cap(p, .7, .1), .2);\n\tp.y += .5;\n\td = smin(d, cap(p, 1., .3), .1);\n\tp.xz *= mat2(.76484, -.64422, .64422, .76484);\n\tp.y -= 4.;\n\treturn min(min(d, B(p, vec3(.5, .2, .1))), B(p, vec3(.2, .5, .1)));\n}\n\nH map(vec3 p) {\n\tH h = H(P(p * 1.2), vec3(.8), 20.);\n\tfloat gnd = length(p.y);\n\tif (gnd < h.d) {\n\t\th.d = gnd;\n\t\th.mat = vec3(.2);\n\t}\n\n\treturn h;\n}\n\nvec3 no(vec3 p, float t) {\n\tvec2 e = vec2(.5773, -.5773) * t * .003;\n\treturn N(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\nfloat sha(vec3 p) {\n\tvec3 rd = N(vec3(-8, 8, -8) - p);\n\tfloat res = 1.,\n\t      t = .5;\n\tfor (float h, i = 0.; i < 32.; i++) {\n\t\th = K(p + rd * t);\n\t\tres = min(res, 150. * h / t);\n\t\tt += h;\n\t\tif (res < .01 || t > 20.) break;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, H data) {\n\tvec3 l = N(vec3(-8, 8, -8) - p),\n\t     n = no(p, d);\n\tfloat ao = dot(vec3(ao(p, n, .2), ao(p, n, .5), ao(p, n, 2.)), vec3(.2, .3, .5)),\n\t      primary = max(0., dot(l, n)),\n\t      bounce = max(0., dot(l * vec3(-1, 0, -1), n)) * .1,\n\t      spe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(l, n))), data.spe));\n\tprimary *= mix(.4, 1., sha(p));\n\treturn data.mat * ((primary + bounce) * ao + spe) * vec3(2, 1.6, 1.4) * exp(-length(p) * .1);\n}\n\nvec3 rgb(vec3 ro, vec3 rd) {\n\tvec3 p;\n\tfloat d = .01;\n\tH h;\n\tfor (float steps = 0.; steps < 45.; steps++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\tif (d > 64.) return vec3(0);\n\t\td += h.d;\n\t}\n\n\treturn applyLighting(p, rd, d, h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec3 f, r,\n\t     ro = vec3(2, 5, -10),\n\t     col = vec3(0),\n\t     R = iResolution;\n\tro.yz *= mat2(.98007, -.19867, .19867, .98007);\n\tf = N(vec3(2, 4, 0) - ro);\n\tr = N(cross(vec3(0, 1, 0), f));\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = ((fc + vec2(dx, dy) * .5) - .5 * R.xy) / R.y;\n\t\t\tcol += rgb(ro, N(f + r * uv.x + cross(f, r) * uv.y));\n\t\t}\n\t}\n\n\tcol = pow(col / 4., vec3(.45));\n\tvec2 q = fc.xy / R.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}