{
    "Shader": {
        "info": {
            "date": "1719411838",
            "description": "Variations on [url=https://www.shadertoy.com/view/XljGDy]Sphere - fog density[/url] by iq.\nMouse click selects density function. From left to right:\n1/sqrt(1-r^2), 1, sqrt(1-r^2), (1-r^2), (1-r^2)^2, (1-r^2)^3, (1-r^2)^4, exp(-r^2).",
            "flags": 0,
            "hasliked": 0,
            "id": "M3dXRB",
            "likes": 8,
            "name": "Variations on sphere fog density",
            "published": 3,
            "tags": [
                "volumetric",
                "fog",
                "analytical",
                "erf"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 132
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Variations on iq's \"Sphere - fog density\"\n//     https://www.shadertoy.com/view/XljGDy\n// using different density functions.\n\n// Sometimes you want (e.g. for rendering of soft particles or\n// whatever) to compute an integral on a line (or a ray/segment\n// thereof) in a spherically symmetric scalar field f(|r|). Integral\n// on a line depends only on the impact parameter b\n// (https://en.wikipedia.org/wiki/Impact_parameter), i.e. the\n// shortest distance between the line and the center of the\n// field (r=0). The integral on a segment/ray also depends\n// on the integration bound(s).\n// One popular choice for the field is the gaussian function:\n//     f(r) = exp(-r^2)\n// where the complete (on (-∞;+∞)) and incomplete integrals are\n//     K(b)   = sqrt(π)   * exp(-b^2)\n//     I(b,t) = sqrt(π)/2 * exp(-b^2) * erf(t)\n// respectively, where erf is the error function (https://en.wikipedia.org/wiki/Error_function).\n// Here t is the signed distance from the closest (to r=0) point (on the line),\n// e.g. t=0 at |r|=b.\n// This can be easily adapted to arbitrary amplitude/radius/center\n// by transforming (translate and scale) to the canonical representation\n// above, and scaling the result, e.g.\n//     f(r) = A*exp(-((r-p)/R)^2).\n// yields\n//     K(b)   = A*R * sqrt(π)   * exp(-b^2)\n//     I(b,t) = A*R * sqrt(π)/2 * exp(-b^2) * erf(t/R)\n// with t again being the signed distance from the closest point (to p).\n// There are several implementations of this approach on Shadertoy, e.g.:\n//     https://www.shadertoy.com/view/WtByzV - \"Gaussian Distributed Fog\" by blackle\n//     https://www.shadertoy.com/view/3d23RG - \"Spherical Volumetric Fog\" by Klems\n//     https://www.shadertoy.com/view/3d23RG - \"Foggy sphere\" by skythedragon\n// This, however, needs an erf() function, which in GLSL is not built-in,\n// and also has infinite support (i.e. f(r) is not zero anywhere, though\n// it does fall off rather fast: exp(-11.0*11.0)==0.0 in float32).\n// Sometimes you want a simpler function, that is explicitly local,\n// i.e. is 0 outside of some finite region.\n// One such function is\n//     f(r) = 1-r^2\n// for |r|<1 (and f(r)=0 outside). This function is\n// presented in \"Sphere - fog density\" by iq:\n//     https://www.shadertoy.com/view/XljGDy\n// See also:\n//     https://iquilezles.org/articles/spherefunctions/\n// This works, although the sphere's boundary is somewhat visible,\n// which may or may not be what you want.\n// This shader provides a generalization\n//     f(r) = (1-r^2)^n\n// for |r|<1 (and, again, f(r)=0 outsie).\n// Note that as per\n//     https://www.shadertoy.com/view/4csXDM - \"(1-x^2)^k\"\n// this converges to exp(-r^2) (with appropriate scaling of\n// argument/result) for n→∞.\n// Denoting c=1-b^2, the general solution (for n>-1) is\n//     K(b)   = sqrt(π) * c^(n+1/2) * Γ(n+1)/Γ(n+3/2)\n// where Γ is the Gamma function\n// (https://en.wikipedia.org/wiki/Gamma_function), and\n//     I(b,t) = t * c^n * ₂F₁(1/2,-n;3/2;t^2/c)\n// where ₂F₁ is the Gauss's hypergeometric function\n// (https://en.wikipedia.org/wiki/Hypergeometric_function).\n// That is, however, somewhat hairy (in part simply due to\n// hypergeometric function being quadravariate), and not tackled here.\n// This shader instead focuses on a few specific values of n.\n// The expressions are:\n//   n  |  K(b)           | I(b,t)\n// -----+-----------------+----------------------------------------------\n// -1/2 |    π            | atan(t/sqrt(c-t^2))\n//   0  |    2   *c^(1/2) | t\n//  1/2 |   π/2  *c       | (t*sqrt(c-t^2)+c*atan(t/sqrt(c-t^2)))/2\n//   1  |   4/3  *c^(3/2) | c*t-t^3/3\n//   2  |  16/15 *c^(5/2) | c^2*t-2/3*c*t^3+t^5/5\n//   3  |  32/35 *c^(7/2) | c^3*t-c^2*t^3+3/5*c*t^5-t^7/7\n//   4  | 256/315*c^(9/2) | c^4*t-4/3*c^3*t^3+6/5*c^2*t^5-4/7*c*t^7-t^9/9\n// Again, this can be easily adapted to arbitrary amplitude/radius/center,\n// by transforming to the canonical representation above, and scaling the result.\n// Note that perceived size may differ depending on n (and is different again\n// for the gaussian). As per https://www.shadertoy.com/view/4csXDM,\n// the 1D standard deviation (which can be one measure of perceived size) is\n//     σ(n) = 1/sqrt(2*n+3)\n// and\n//     σ    = 1/sqrt(2)\n// for the gaussian.\n//\n// See also:\n//     https://www.shadertoy.com/view/4csXDM - \"(1-x^2)^k\"\n//     https://www.shadertoy.com/view/ml3yWj - \"Approximations of erf(x)\"\n//     https://www.shadertoy.com/view/lcBXDW - \"Gabor blobs\"\n//     https://www.shadertoy.com/view/4XSGzW - \"Gaussian airmass\"\n\n#define NEG_HALF (-1)\n#define POS_HALF (-2)\n#define GAUSS    (-3)\n\nconst float pi=3.14159265358979;\n\n// Super-crude approximation of error function\n// from https://www.shadertoy.com/view/ml3yWj\n// #define erf(x) tanh(1.2*(x))\n#define erf(x) tanh((x)*(1.128776206+(x)*(x)*0.100709669))\n\nfloat K(int method,float b)\n{\n    float c=1.0-b*b,c2=c*c,c3=c*c2,c4=c2*c2;\n    float q=sqrt(max(c,0.0));\n    switch(method)\n    {\n        case NEG_HALF: return pi;\n        case 0:        return 2.0*q;\n        case POS_HALF: return 0.5*pi*c;\n        case 1:        return 4.0/3.0*c*q;\n        case 2:        return 16.0/15.0*c2*q;\n        case 3:        return 32.0/35.0*c3*q;\n        case 4:        return 256.0/315.0*c4*q;\n        case GAUSS:    return sqrt(pi)*exp(-b*b);\n    }\n    return 0.0;\n}\n\nfloat I(int method,float b,float t)\n{\n    float c=1.0-b*b,c2=c*c,c3=c*c2,c4=c2*c2;\n    float t2=t*t;\n    float q=sqrt(max(c-t2,0.0));\n    switch(method)\n    {\n        case NEG_HALF: return atan(t/q);\n        case 0:        return t;\n        case POS_HALF: return 0.5*(t*sqrt(q)+c*atan(t/sqrt(q)));\n        case 1:        return t*(c-t2/3.0);\n        case 2:        return t*(c2-t2*(2.0/3.0*c-t2/5.0));\n        case 3:        return t*(c3-t2*(c2-t2*(3.0/5.0*c-t2/7.0)));\n        case 4:        return t*(c4-t2*(4.0/3.0*c3-t2*(6.0/5.0*c2-t2*(4.0/7.0*c-t2/9.0))));\n        case GAUSS:    return 0.5*sqrt(pi)*exp(-b*b)*erf(t);\n    }\n    return 0.0;\n}\n\nfloat I(int method,vec3 ro,vec3 rd,vec4 s,float l,float h)\n{\n    vec3 r=(ro-s.xyz)/s.w;\n    float b=length(r-dot(r,rd)*rd);\n    l=l/s.w+dot(r,rd);\n    h=h/s.w+dot(r,rd);\n    float c=1.0-b*b;\n    if(method!=GAUSS)\n    {\n        if(c<=0.0) return 0.0;\n        l=max(l,-sqrt(c));\n        h=min(h,+sqrt(c));\n        if(l>h) return 0.0;\n    }\n    // Similar to https://www.shadertoy.com/view/XljGDy\n    // we normalize so that line through center\n    // integrates to 1 for sphere of radius 1 (or\n    // characteristic size 1, for GAUSS).\n    return s.w*(I(method,b,h)-I(method,b,l))/K(method,0.0);\n}\n\n#define NUM_METHODS 8\n\n// sRGB<->linear conversions, from https://en.wikipedia.org/wiki/SRGB\n// NOTE: in floating point (1.055-1.0)!=0.055, but whatever.\n\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\nvec3 srgb2linear(vec3 rgb)\n{\n    return mix(rgb/12.92,pow((rgb+0.055)/1.055,vec3(2.4)),step(0.04045,rgb));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    const int methods[NUM_METHODS]=int[NUM_METHODS](NEG_HALF,0,POS_HALF,1,2,3,4,GAUSS);\n    vec3 ro=vec3(0,0,2.5);\n    vec3 rd=normalize(vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,-1.5));\n    vec3 L=vec3(0.25,0.75,1);\n    vec4 s=vec4(sin(vec3(0.7,0.5,0.9)*iTime),1.25);\n    vec3 col=vec3(0.25);\n    vec2 uv=vec2(0);\n    float depth=1e7;\n    const vec4[5] plane=vec4[5](\n        vec4(+1,0,0,1),\n        vec4(-1,0,0,1),\n        vec4(0,+1,0,1),\n        vec4(0,-1,0,1),\n        vec4(0,0,+1,1)\n    );\n    vec3 n=vec3(0);\n    vec3 r=ro;\n    float t=0.0;\n    // Walls.\n    for(int i=0;i<5;++i)\n    {\n        t=-dot(plane[i],vec4(ro,1))/dot(rd,plane[i].xyz);\n        if(t>0.0&&t<depth)\n        {\n            depth=t;\n            r=ro+t*rd;\n            uv.x=r[(i/2+1)%3];\n            uv.y=r[(i/2+2)%3];\n            n=plane[i].xyz;\n        }\n    }\n    // Square bar.\n    // Half-bar, really, since we don't render back faces.\n    for(int i=0;i<2;++i)\n    {\n        float w=0.125;\n        vec3 N=vec3(+0.5,-0.5,sqrt(0.5));\n        if(i==1) N.xy=N.yx;\n        t=-dot(vec4(N,-w),vec4(ro,1))/dot(N,rd);\n        if(t>0.0&&t<depth)\n        {\n            r=ro+t*rd;\n            if(abs(dot(N.yxz,r))<w*1.005)\n            {\n                depth=t;\n                uv=0.5*(r.xz+r.yz);\n                n=N;\n            }\n            else r=ro+depth*rd;\n        }\n    }\n    // Round bar.\n    vec3 c=vec3(0,0,0.5),d=normalize(vec3(-1,+1,0));\n    float w=0.125;\n    vec3 P=rd-dot(rd,d)*d,Q=(ro-c)-dot(ro-c,d)*d;\n    float A=dot(P,P),B=dot(P,Q),C=dot(Q,Q)-w*w;\n    if(B*B-A*C>0.0)\n    {\n        t=(-B-sqrt(B*B-A*C))/A;\n        if(t<depth)\n        {\n            depth=t;\n            r=ro+t*rd;\n            n=normalize((r-c)-dot(r-c,d)*d);\n            uv*=0.0;\n            uv.x=dot(r,d);\n            uv.y=w*asin(dot(r-c,normalize(vec3(+1,+1,0)))/w);\n        }\n    }\n    uv=0.5*uv+0.5;\n    col=srgb2linear(texture(iChannel0,uv).xyz);\n    col*=2.0/dot(r-L,r-L)*(0.03125+max(0.0,dot(n,-normalize(r-L))));\n    col*=1.0+0.5*step(fragCoord.y,0.125*iResolution.y)*sign(sin(pi*float(NUM_METHODS)*fragCoord.x/iResolution.x));\n    if(fragCoord.y<0.125*iResolution.y&&int(float(NUM_METHODS)*fragCoord.x/iResolution.x)==int(float(NUM_METHODS)*iMouse.x/iResolution.x))\n        col.x*=2.5;\n    float a=I(methods[int(float(NUM_METHODS)*abs(iMouse.x)/iResolution.x)],ro,rd,s,0.0,depth);\n    col=mix(col,0.5+0.5*sin(vec3(2,4,6)+iTime),1.0-exp(-a));\n    col=linear2srgb(col);\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}