{
    "Shader": {
        "info": {
            "date": "1721012497",
            "description": "Illustrates the bilinear fix for radiance cascades. The forking fix can also be enabled. The original radiance cascades approach can be seen if both are disabled.",
            "flags": 0,
            "hasliked": 0,
            "id": "4clcWn",
            "likes": 11,
            "name": "Radiance Cascades Diagram",
            "published": 3,
            "tags": [
                "global",
                "illumination",
                "bilinear",
                "radiance",
                "cascade",
                "fix",
                "cascades"
            ],
            "usePreview": 0,
            "username": "Mytino",
            "viewed": 633
        },
        "renderpass": [
            {
                "code": "// Disable these to see classic V1 radiance cascades.\n#define BILINEAR_FIX_ENABLED (true)\n#define FORKING_FIX_ENABLED (false)\n\n// Tests:\n#define CIRCLE_PROJECTION_FIX_ENABLED (false)\n\n#define CELL_SIZE_C0 (iResolution.y * 0.1) // Change this to resize the diagram.\n#define CELL_COUNT_C0_X (8)\n#define CELL_COUNT_C0_Y (8)\n\n#define CASCADE_COUNT (2)\n#define CASCADE_START (0) // Set this to 1 to hide cascade 0 for example.\n\n#define LENGTH_C0 (CELL_SIZE_C0 * 0.5)\n#define DIR_COUNT_C0 (4.0)\n\n#define DIR_COUNT_MULTIPLIER (4.0)\n#define RAY_INTERVAL_LENGTH_MULTIPLIER (4.0)\n#define PROBE_SPACING_MULTIPLIER (2.0)\n\n// Ringing testbed - Places a light in the middle (pausing, 16x16 CELL_COUNT_C0_X/Y and 2 cascades recommended).\n// NOTE: Only works with PROBE_SPACING_MULTIPLIER = 2.0.\n#define RINGING_TESTBED_ENABLED (0) // Set to 1 to enable.\n#define INTENSITY_FACTOR (6.5)\n#define LIGHT_POS_MIN ((vec2(CELL_COUNT_C0_X, CELL_COUNT_C0_Y) * 0.5 - vec2(0.3)) * CELL_SIZE_C0)\n#define LIGHT_POS_MAX ((vec2(CELL_COUNT_C0_X, CELL_COUNT_C0_Y) * 0.5 + vec2(0.3)) * CELL_SIZE_C0)\n\n#define DRAW_ALL_ARROWS (RINGING_TESTBED_ENABLED == 0)\n#define MOUSEOVER_SHOW_CLOSEST_PROBES_NxN (1.0)\n#define ONLY_SHOW_TOP_RIGHT_QUADRANT (false)\n#define ONLY_SHOW_ARROWS_FOR_CLOSEST_INTERPOLATED_PROBE (false) // Keep this at false if using the ringing testbed.\n#define MAKE_ALL_ARROWS_FULLY_OPAQUE (false)\n\n// Extra conditionals to see only one cascade with the difference:\n#define BILINEAR_FIX_ENABLED_C0 (true)\n#define FORKING_FIX_ENABLED_C0 (true)\n#define BILINEAR_FIX_ENABLED_C1 (true)\n#define FORKING_FIX_ENABLED_C1 (true)\n#define BILINEAR_FIX_ENABLED_C2 (true)\n#define FORKING_FIX_ENABLED_C2 (true)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 gridSize = CELL_SIZE_C0 * vec2(CELL_COUNT_C0_X, CELL_COUNT_C0_Y);\n    float cellSizeC1 = CELL_SIZE_C0 * PROBE_SPACING_MULTIPLIER;\n    \n    vec2 worldOffset = -round(vec2(iResolution) * 0.5 - gridSize * 0.5);\n    vec2 pos = fragCoord + worldOffset;\n    vec2 mouse = iMouse.xy + worldOffset;\n\n    vec3 col = vec3(0.8, 0.8, 0.8);\n    \n    // Calculate arrow color (and fluence if testbed is enabled).\n    vec4 allArrowsCol = vec4(0.0);\n    float[CELL_COUNT_C0_X * CELL_COUNT_C0_Y * CASCADE_COUNT] radianceArray;\n    for (int l = 0; l < CELL_COUNT_C0_X * CELL_COUNT_C0_Y * CASCADE_COUNT; l++) radianceArray[l] = 100.0;\n    \n    for (int cInt = CASCADE_COUNT - 1; cInt >= CASCADE_START; cInt--) { // Cascade\n        float c = float(cInt);\n        float dirCount = DIR_COUNT_C0 * pow(DIR_COUNT_MULTIPLIER, c);\n        float dirCountLower = round(dirCount / DIR_COUNT_MULTIPLIER);\n        float cellSize = CELL_SIZE_C0 * pow(PROBE_SPACING_MULTIPLIER, c);\n        float cellSizeUpper = cellSize * PROBE_SPACING_MULTIPLIER;\n        vec3 arrowCol = cInt == 0 ? vec3(1.0, 0.3, 0.3) : cInt == 1 ? vec3(0.3, 0.6, 1.0) : vec3(0.3, 0.6, 0.3);\n        bool bilinearFixEnabled = BILINEAR_FIX_ENABLED && (cInt != 0 || BILINEAR_FIX_ENABLED_C0) && (cInt != 1 || BILINEAR_FIX_ENABLED_C1) && (cInt != 2 || BILINEAR_FIX_ENABLED_C2);\n        bool forkingFixEnabled = FORKING_FIX_ENABLED && (cInt != 0 || FORKING_FIX_ENABLED_C0) && (cInt != 1 || FORKING_FIX_ENABLED_C1) && (cInt != 2 || FORKING_FIX_ENABLED_C2);\n        vec2 probeCount = round(gridSize / cellSize);\n        \n        float tStart = cInt == 0 ? 0.0 : LENGTH_C0 * pow(RAY_INTERVAL_LENGTH_MULTIPLIER, c - 1.0);\n        float tEnd = LENGTH_C0 * pow(RAY_INTERVAL_LENGTH_MULTIPLIER, c);\n        \n        for (float x = 0.0; x < probeCount.x; x++) {\n        for (float y = 0.0; y < probeCount.y; y++) {\n            \n            vec2 probePos = (vec2(x, y) + vec2(0.5)) * cellSize;\n            \n            // Draw-related\n            vec2 mouseDelta = (mouse - probePos) / cellSize;\n            float gap = MOUSEOVER_SHOW_CLOSEST_PROBES_NxN / 2.0;\n            bool drawArrow = true;\n            if ((iMouse.z > 0.0 || !DRAW_ALL_ARROWS) && (mouseDelta.x >= gap || mouseDelta.y >= gap || mouseDelta.x < -gap || mouseDelta.y < -gap)) {\n                if (RINGING_TESTBED_ENABLED == 1) drawArrow = false; else continue;\n            }\n            \n            float dirCountToAverage = cInt == 0 ? DIR_COUNT_C0 : DIR_COUNT_MULTIPLIER;\n            float radianceSum = 0.0;\n            for (float d = 0.0; d < dirCount; d++) { // Directions\n                \n                int dInt = int(d);\n                float angle = (d + 0.5) / dirCount * TAU;\n                vec2 dir = vec2(cos(angle), sin(angle));\n                float angleLower = (floor(d / dirCountToAverage) + 0.5) / dirCountLower * TAU;\n                vec2 dirLower = vec2(cos(angleLower), sin(angleLower));\n                vec2 posStart = probePos + (forkingFixEnabled ? dirLower : dir) * tStart;\n                \n                if (ONLY_SHOW_TOP_RIGHT_QUADRANT && (dir.x < 0.0 || dir.y < 0.0)) { if (RINGING_TESTBED_ENABLED == 1) drawArrow = false; else continue; }\n                vec2 cellPosUpperClosest = floor(probePos / cellSizeUpper);\n                #if (RINGING_TESTBED_ENABLED == 1)\n                    int tileSizeUpper = int(round(cellSizeUpper / CELL_SIZE_C0));\n                    int dirIndexUpper = dInt;\n                    vec2 probePosUpperTopLeft = (floor((probePos - cellSize) / cellSizeUpper) + 0.5) * cellSizeUpper;\n                    vec2 weight = (probePos - probePosUpperTopLeft) / (cellSize * PROBE_SPACING_MULTIPLIER);\n                #endif\n                \n                for (int b = 0; b < (ONLY_SHOW_ARROWS_FOR_CLOSEST_INTERPOLATED_PROBE ? 1 : 4); b++) { // Bilinear interpolation\n                    \n                    vec2 offset01 = vec2(b % 2, b / 2);\n                    vec2 cellPosUpper = ONLY_SHOW_ARROWS_FOR_CLOSEST_INTERPOLATED_PROBE ? cellPosUpperClosest : (floor((probePos - cellSize) / cellSizeUpper) + offset01);\n                    vec2 probePosUpper = (cellPosUpper + 0.5) * cellSizeUpper;\n                    vec2 posEnd = (bilinearFixEnabled ? probePosUpper : probePos) + dir * tEnd;\n                    \n                    if (CIRCLE_PROJECTION_FIX_ENABLED) {\n                        float a = posStart.x - probePosUpper.x, e = posStart.y - probePosUpper.y;\n                        float u = dir.x, v = dir.y, r = tEnd;\n                        float t = (sqrt(-a*a*v*v + 2.0*a*e*u*v - e*e*u*u + r*r*(u*u+v*v)) - a*u - e*v) / (u*u + v*v);\n                        posEnd = posStart + dir * max(t, tStart);\n                    }\n                    \n                    vec3 finalArrowCol = arrowCol;\n                    #if (RINGING_TESTBED_ENABLED == 1)\n                        float weightRel = (offset01.x == 1.0 ? weight.x : (1.0 - weight.x)) * (offset01.y == 1.0 ? weight.y : (1.0 - weight.y));\n                        ivec2 storedPosUpper = ivec2(cellPosUpper) * tileSizeUpper + ivec2(dirIndexUpper / tileSizeUpper, dirIndexUpper % tileSizeUpper);\n                        int arrayIndexUpper = (cInt + 1) * CELL_COUNT_C0_X * CELL_COUNT_C0_Y + storedPosUpper.y * CELL_COUNT_C0_X + storedPosUpper.x;\n                        bool ignoreRadiance = cInt >= CASCADE_COUNT - 1 || any(lessThan(storedPosUpper, ivec2(0))) || storedPosUpper.x >= CELL_COUNT_C0_X || storedPosUpper.y >= CELL_COUNT_C0_Y;\n                        float radianceUpper = ignoreRadiance ? 0.0 : radianceArray[arrayIndexUpper];\n                        float radianceLower = intersectLight(posStart, posEnd, LIGHT_POS_MIN, LIGHT_POS_MAX);\n                        radianceSum += (radianceLower + radianceUpper) * weightRel;\n                        if (radianceLower > 0.0) finalArrowCol *= 2.5;\n                    #endif\n                    if (RINGING_TESTBED_ENABLED == 0 || (RINGING_TESTBED_ENABLED == 1 && drawArrow)) {\n                        float arrow = sdf_arrow(pos - posStart, length(posEnd - posStart), normalize(posEnd - posStart), 3.0, 1.0);\n                        allArrowsCol = mix(allArrowsCol, vec4(finalArrowCol, 1.0), smoothstep(1.5, 0.0, arrow) * (all(equal(cellPosUpper, cellPosUpperClosest)) ? 1.0 : (MAKE_ALL_ARROWS_FULLY_OPAQUE ? 1.0 : 0.25)));\n                    }\n                }\n                \n                #if (RINGING_TESTBED_ENABLED == 1)\n                    if ((dInt % int(dirCountToAverage)) == int(dirCountToAverage) - 1) {\n                        int tileSize = int(round(cellSize / CELL_SIZE_C0));\n                        int dirIndex = dInt / int(dirCountToAverage);\n                        ivec2 storedPos = ivec2(x, y) * tileSize + ivec2(dirIndex / tileSize, dirIndex % tileSize);\n                        int arrayIndexLower = cInt * CELL_COUNT_C0_X * CELL_COUNT_C0_Y + storedPos.y * CELL_COUNT_C0_X + storedPos.x;\n                        radianceArray[arrayIndexLower] = radianceSum / dirCountToAverage;\n                        radianceSum = 0.0;\n                    }\n                #endif\n            }\n        }}\n    }\n    \n    // Draw:\n    \n    if (all(lessThan(pos, gridSize)) && all(greaterThan(pos, vec2(0.0)))) {\n        #if (RINGING_TESTBED_ENABLED == 1)\n            ivec2 cellPos = ivec2(floor(pos / CELL_SIZE_C0));\n            float fluence = radianceArray[0 + cellPos.y * CELL_COUNT_C0_X + cellPos.x] * INTENSITY_FACTOR;\n            col = vec3(fluence);\n            col += any(lessThan(abs(pos - round(pos / CELL_SIZE_C0) * CELL_SIZE_C0), vec2(1.0))) ? 0.02 : 0.0; // Small grid\n            col += any(lessThan(abs(pos - round(pos / cellSizeC1) * cellSizeC1), vec2(1.0))) ? 0.02 : 0.0; // Large grid\n            col = mix(col, vec3(1.0, 1.0, 0.0), float(all(greaterThanEqual(pos, LIGHT_POS_MIN)) && all(lessThan(pos, LIGHT_POS_MAX)))); // Light source\n        #else\n            col *= any(lessThan(abs(pos - round(pos / CELL_SIZE_C0) * CELL_SIZE_C0), vec2(1.0))) ? 0.96 : 1.0; // Small grid\n            col *= any(lessThan(abs(pos - round(pos / cellSizeC1) * cellSizeC1), vec2(1.0))) ? 0.8 : 1.0; // Large grid\n        #endif\n    }\n    \n    // Add arrow graphics.\n    col = col * (1.0 - allArrowsCol.a) + allArrowsCol.rgb;\n    \n    if (all(lessThan(pos, gridSize)) && all(greaterThan(pos, vec2(0.0)))) {\n        #if (RINGING_TESTBED_ENABLED == 0)\n            col *= smoothstep(1.5, 2.0, length(pos - (floor(pos / CELL_SIZE_C0) + 0.5) * CELL_SIZE_C0)); // Small probe\n            col *= smoothstep(7.0, 8.0, length(pos - (floor(pos / cellSizeC1) + 0.5) * cellSizeC1)); // Large probe\n        #endif\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265358979\n#define TAU (2.0 * PI)\n\n// ------------------------------------------------------------------------------------------------\nfloat m_stretch(float point, float stretch){\n    return .5 * (sign(point) * stretch - point) * (sign(abs(point) - stretch) + 1.);\n}\n\n#define m_stretch_neg(p, st) (.5 * m_stretch(2. * p + st, st))  /* Stretch-negative: positive values are fixed */\n#define m_stretch_pos(p, st) (.5 * m_stretch(2. * p, st))  /* Stretch-positive: negative values are fixed */\n\n// A fast \"manual\" lossy rotate function by ollj.\n// Control the angle of rotation by specifying the ROTATE_PARAM constants.\n// https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nfloat ollj_rotate(vec2 uv){\n    const float ROTATE_PARAM0 = sqrt(1.);  // Try changing these!\n    const float ROTATE_PARAM1 = sqrt(.0);\n    return dot(uv, vec2(ROTATE_PARAM0 + ROTATE_PARAM1, ROTATE_PARAM0 - ROTATE_PARAM1));\n}\n\n// NOTE: Very slightly modified - Mytino.\n// Optimized arrow SDF, by ollj\n// @head_len isn't actual uv units, but the unit size depends on ROTATE_PARAMs\nfloat sdf_arrow(vec2 uv, float norm, vec2 dir, float head_height, float stem_width){\n    uv = vec2(dir.x * uv.x + dir.y * uv.y, -dir.y * uv.x + dir.x * uv.y);\n\n    norm -= head_height;  // Make sure the norm INCLUDES the arrow head\n    uv.x -= norm;  // Place the arrow's origin at the stem's base!\n\n    uv.y = abs(uv.y);\n    float head = max(ollj_rotate(uv) - head_height, -uv.x);\n\n    uv.x = m_stretch_neg(uv.x, norm);\n    uv.y = m_stretch_pos(uv.y, stem_width);\n    float stem = length(uv);\n\n    return min(head, stem);  // Join head and stem!\n}\n// ------------------------------------------------------------------------------------------------\n\nfloat LengthSq(vec2 v) { return dot(v, v); }\nfloat Pow2(float v) { return v * v; }\n\nfloat intersectLight(vec2 rayStart, vec2 rayEnd, vec2 boxPosMin, vec2 boxPosMax) {\n    vec2 dir = normalize(rayEnd - rayStart);\n    vec2 t = (vec2(boxPosMin.x, boxPosMax.x) - rayStart.x) / dir.x; float tMin = min(t.x, t.y), tMax = max(t.x, t.y);\n    t = (vec2(boxPosMin.y, boxPosMax.y) - rayStart.y) / dir.y; tMin = max(tMin, min(t.x, t.y)); tMax = min(tMax, max(t.x, t.y));\n    if (tMax < tMin || (tMin < 0.0 && tMax < 0.0) || tMin > length(rayEnd - rayStart)) return 0.0;\n\treturn 1.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}