{
    "Shader": {
        "info": {
            "date": "1546068067",
            "description": "Yet another shader to visualize the Mandelbrot set. I wanted to see what it would look like if I rendered the borders, where the number of iterations required increases.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsfGDr",
            "likes": 7,
            "name": "Mandelbrot Borders",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "mandelbrot",
                "mandel"
            ],
            "usePreview": 0,
            "username": "g4b0r",
            "viewed": 555
        },
        "renderpass": [
            {
                "code": "// Created by Gabor Nagy (gabor.nagy@me.com)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// December 28, 2018\n//\n// Yet another shader to visualize the Mandelbrot set. I wanted to see what it would \n// look like if I rendered the borders, where the number of iterations required \n// increases.\n\n#define AA 2\n#define MAX_ITERATIONS 750\n\n#define BACKGROUND_COLOR vec3(.95,.95,.95)\n#define MANDELBROT_COLOR vec3(1., .5, 0.)\n#define OUTLINE_COLOR vec3(0.,0.,1.)\n\n// Calculates the iterations needed to escape the mandelbrot set.\nint mandelbrot(vec2 uv)\n{    \n    vec2 c = uv;    \n    vec2 z = vec2(.0, .0);\n    \n    for(int i=0; i<MAX_ITERATIONS; i++)\n    {       \n    \tz = vec2( (z.x*z.x)-(z.y*z.y), 2.0*z.x*z.y) + c;\n\t\tif(dot(z,z) > 4.0)\n\t\t{\n            return i;\n\t\t}\n    }\n    return MAX_ITERATIONS;\n}\n\n// Maps from pixel coordinates to mandelbrot coordinates, and handles zooming.\nvec2 calculateUV(vec2 p) {\n\tvec2 uv = (vec2(p.x, p.y) / iResolution.xy) * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Zoom in and out as a function of iTime from -1. to 8.\n    float zoom = 8. - (cos(iTime / 3.) * 4.5 + 4.5); \n    uv *= 1. / exp(zoom);\n\n    // Zoom somewhere interesting.\n    uv.x -= 0.98990;\n    uv.y -= 0.30934;\n\n    return uv;\n}\n\n// Calculates the pixel color at point p.\nvec3 render(vec2 p) {\n\n\tvec3 color = BACKGROUND_COLOR;\n    \n    int iterations = mandelbrot(calculateUV(p));\n    \n    if (iterations == MAX_ITERATIONS) {\n        // We're inside the mandelbrot set.\n        color = MANDELBROT_COLOR;\n    } else {\n        \t    \n        // Calculate the iterations needed nearby.\n        int left = mandelbrot(calculateUV(p+vec2(-1.0,0.)));\n    \tint top = mandelbrot(calculateUV(p+vec2(0.,1.0)));\n        \n\t\t// Looks like abs() doesn't work for int on iOS.\n        float iterationJump = max(abs(float(left - iterations)), \n                                  abs(float(top - iterations)));\n\n        if (iterationJump > 0.) {\n            // If the iteration change is greater than zero, we're on a border.\n    \t\tcolor = OUTLINE_COLOR - vec3(min(.7, float(iterationJump) / 40.));\n    \t}    \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    for( int m=0; m<AA; m++ ) {\n        for( int n=0; n<AA; n++ ) {\n\t\t\tvec2 p = fragCoord + (vec2(float(m),float(n)) / float(AA) - 0.5);\n    \t\tcolor += render(p);\n        }\n    }\n    \n    color /= float(AA*AA);\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}