{
    "Shader": {
        "info": {
            "date": "1533712689",
            "description": "Attempt to understand [url]https://www.shadertoy.com/view/4l2cRW[/url] implementation of \"bicapsule\" distance.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttyzs",
            "likes": 5,
            "name": "Distance to BiCapsule",
            "published": 3,
            "tags": [
                "distance",
                "capsule",
                "bicapsule"
            ],
            "usePreview": 0,
            "username": "notlion",
            "viewed": 574
        },
        "renderpass": [
            {
                "code": "// Adaptation of: https://www.shadertoy.com/view/4l2cRW\nfloat distanceToBiCapsule(vec2 pos, vec2 a, vec2 b, float r1, float r2) {\n    //Standard line segment closest point\n    vec2 ba = b - a;\n    float baMagnitude = length(ba);\n    float alpha = (dot(pos - a, ba) / dot(ba, ba));\n    vec2 capsuleSegmentPos = mix(a, b, alpha);\n    \n    //Calculate the offset along segment according to the slope of the bicapsule\n    float pointSphereRadius = r1 - r2; //This collapses the problem into finding the tangent angle for a point/sphere\n    float exsecantLength = ((baMagnitude / abs(pointSphereRadius)) - 1.0) * baMagnitude;\n    float tangentAngle =  acos(1.0 / (exsecantLength + 1.0)); //This is also known as the \"arcexsecant\" function\n    float tangentOffset = length(capsuleSegmentPos - pos) / tan(tangentAngle); //This is adjacent / tan(theta) = opposite\n    tangentOffset *= sign(pointSphereRadius); //Allows it to handle r2 > r1 as well\n    \n    //And back to classic capsule closest point (with lerped radii)\n    float clampedOffsetAlpha = clamp(alpha - tangentOffset, 0.0, 1.0);\n    vec2 bicapsuleSegmentPos = mix(a, b, clampedOffsetAlpha);\n    float bicapsuleRadius = mix(r1, r2, clampedOffsetAlpha);\n    return distance(pos, bicapsuleSegmentPos) - bicapsuleRadius;\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n    vec2 v0 = vec2(cos(iTime * 0.363), sin(iTime * 0.327)) * 0.3;\n    vec2 v1 = vec2(cos(iTime * 0.271), sin(iTime * 0.271)) * 0.6;\n    float r0 = 0.2 + cos(iTime * 0.381) * 0.1;\n    float r1 = 0.2 + sin(iTime * 0.331) * 0.1;\n    \n    float d = distanceToBiCapsule(uv, v0, v1, r0, r1);\n    //float d = distance(p, uv);\n    \n    float stripe = smoothstep(0.4, 0.6, abs(fract(d * 10.0) * 2.0 - 1.0));\n    fragColor = vec4((vec3(stripe) * 0.4 + 0.8) * vec3(d * 0.1, 1.0 - d * 0.5, d * 0.2), 1.0);\n    \n    fragColor.rgb -= smoothstep(0.9, 1.0, min(distance(uv, v0) / r0, distance(uv, v1) / r1)) * 0.25;\n    \n    fragColor.rgb *= mix(0.3, 1.0, smoothstep(0.0, 0.01, d));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}