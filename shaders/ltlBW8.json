{
    "Shader": {
        "info": {
            "date": "1572879419",
            "description": "Traversal of a 2d voronoi grid with refraction. Code and visuals are based on the regular grid analogous shader [url=https://www.shadertoy.com/view/ltXBz7] 2D Grid Traversal w/ Refraction [/url].\n\nThe mouse can be used to point the ray.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltlBW8",
            "likes": 25,
            "name": "Voronoi Traversal w/ Refraction",
            "published": 3,
            "tags": [
                "voronoi",
                "refraction",
                "traversal"
            ],
            "usePreview": 0,
            "username": "glk7",
            "viewed": 673
        },
        "renderpass": [
            {
                "code": "// Created by genis sole - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float w = 2.;\n\nconst float PI = 3.1416;\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n                          dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//From https://iquilezles.org/articles/voronoilines\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    vec2 ml = vec2(0.0);\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(r-mr,r-mr)>0.00001 ) {\n            vec2 l = normalize(r-mr);\n            float d = dot( 0.5*(mr+r), l );\n            if (md > d) { \n        \t\tmd = d;\n                ml = l;\n            }\n        }           \n    }\n\n    return vec3(md, n+mg);\n}\n\n//From https://www.shadertoy.com/view/MtyGWK\nvoid voronoi_s(in vec2 x, inout vec2 n,  inout vec2 f, \n                          inout vec2 mg, inout vec2 mr) {\n\n    n = floor(x);\n    f = fract(x);\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(i,j);\n\t\tvec2 o = hash2(n + g);\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if (d < md) {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }  \n}\n\nvec3 voronoi_n(vec2 rd, vec2 n,  vec2 f, \n               inout vec2 mg, inout vec2 mr) {\n    float md = 1e5;\n    vec2 cmg = mg;\n    vec2 cmr = mr;\n    vec2 ml = vec2(0.0);\n    \n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = cmg + vec2(i,j);\n\t\tvec2 o = hash2(n + g);\n\t\tvec2 r = g + o - f;\n\n    \tvec2 l = r-cmr;\n        \n        if(dot(rd, l) > 1e-5) {\n            float d = dot(0.5*(cmr+r), l)/dot(rd, l);\n            \n            if (d < md) {\n                md = d;\n                mg = g;\n                mr = r;\n                ml = l;\n            }\n        }   \n    }\n    \n    return vec3(md, normalize(ml));\n}\n\nfloat grid(vec2 uv, float e, float v) \n{\n    return smoothstep(0.0, w*e, v);\n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn smoothstep(0.07, 0.07 + w*e, length(uv - p)); \n}\n\nfloat segment(vec2 uv, float e, vec2 d, vec2 p, float l) \n{\n    return max(1.0 - min(step(0.0, dot(d, uv - p)), \n                         step(0.0, dot(d, p + d*l - uv))),\n   \t\t       smoothstep(0.015, 0.015 + w*e, abs(dot(vec2(-d.y, d.x), p - uv))));\n}\n\nfloat refract_index(vec2 c) \n{\n    c -= vec2(7.0, 6.0);\n    const float r = 3.0;  \n    return dot(c, c) > r*r ? 1.0 : 2.7;\n}\n\nvec2 traversal(vec2 uv, float e, vec2 uvv, vec2 ro, vec2 rd) \n{   \n    vec2 v = vec2(1.0);\n    \n    vec2 i = vec2(0.0), f = vec2(0.0);\n    vec2 mg = vec2(0.0), mr = vec2(0.0);\n    \n    voronoi_s(ro, i, f, mg, mr);\n    \n    float refri = refract_index(i + mg);    \n    \n    vec2 p = ro;\n    for( int s = 32; s > 0; --s ){\n        \n        //Draw cell and point.\n       \tvec2 c = abs(i + mg - uvv);\n        float cc = 1.0 - step(0.0, -(c.x + c.y));\n        v = min(v, vec2(point(uv, e, p), cc));\n\n        vec2 pmg = mg;\n    \tvec3 vor = voronoi_n(rd, i, f, mg, mr);\n        \n        v.x = min(v.x, segment(uv, e, rd, p, vor.x)); // Draw segment.\n        \n       \tp += rd*vor.x;\n        \n        //Refraction part.\n        #if 1\n        float nrefri = refract_index(i + mg);\n        \n        vec2 reflrd = reflect(rd, -vor.yz);\n        rd = refract(rd, -vor.yz, refri/nrefri);\n        \n        float t = step(0.0, -dot(rd, rd));\n       \trefri = mix(nrefri, refri, t);\n        rd += reflrd*t;\n        mg = mix(mg, pmg, t);\n        #endif\n        \n        vec2 o = mr - mg + f;\n        vec2 ip = floor(p);\n        f = fract(p);\n        \n        mg += i - ip;\n        mr = mg + o - f;\n        i = ip;\n    }\n    \n    v.x = min(v.x, point(uv, e, p)); \n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 25.0 / iResolution.x;\n    vec2 offset = vec2(5.0, 3.0);\n\tvec2 uv = fragCoord.xy*e - offset;\n    \n    vec2 ro = vec2(3.8, 1.2);\n    \n    vec2 rd = (length(iMouse.xy) < 10.0)\n        \t? normalize(vec2(1.0, sin(iTime*0.2) + 1.5))\n    \t\t: normalize(iMouse.xy*e - offset - ro);\n    \n    \n    vec3 v = voronoi(uv);\n    float ri = refract_index(v.yz);\n    vec3 c = vec3(1.0 - step(0.0, 1.0 - ri), 0.2, \n                  step(0.0, 1.0 - ri)) + 0.3;\n    \n    vec2 t = traversal(uv, e, v.yz, ro, rd);\n    c += (1.0 - t.y) * 0.2;\n    c *= t.x;\n    c *= grid(uv, e, v.x);\n    \n\tfragColor = vec4(pow(clamp(c, 0.0, 1.0), vec3(0.4545)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}