{
    "Shader": {
        "info": {
            "date": "1708269814",
            "description": "a building inspired by the nagakin capsule tower in japan.",
            "flags": 0,
            "hasliked": 0,
            "id": "XXjGR1",
            "likes": 15,
            "name": "sdf architecture 2",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "sympou",
            "viewed": 198
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n\n#define maxDist 10.\n#define maxIter 100\n\nfloat rayMarch( vec3 ro, vec3 rd, float tMax ) {\n\n    float t = 0.;\n    int i = 0;\n\n    while ( i < maxIter && t < tMax ) {\n\n        float r = abs( getDist( ro + rd*t ) );\n\n        if ( r <= t*0.001 ) break;\n        t += r;\n        i ++;\n    }\n    \n    return t;\n}\n\nvec3 distance_field_normal(vec3 pos) {\n    vec2 eps = vec2(0.0001,0.0);\n    float nx = getDist(pos + eps.xyy);\n    float ny = getDist(pos + eps.yxy);\n    float nz = getDist(pos + eps.yyx);\n    return normalize(vec3(nx, ny, nz) - getDist(pos));\n}\n\nvec3 render( vec3 ro, vec3 rd ) {\n\n    const vec3 flrCol  = vec3(.75 );\n    const vec3 objCol  = vec3( 0.8 );\n    const vec3 skyCol  = vec3(.2,  .5,  1. );\n    const vec3 skyCol2 = skyCol*0.35 + 0.65;\n\t\n    //        \n    \n    float floorDist = - ro.z / rd.z;\n    float maxDist2  = (floorDist>0.) ? min(maxDist, floorDist) : maxDist;\n    float objDist   = rayMarch( ro, rd, maxDist2 );\n            \n    if ( floorDist < 0. && objDist > maxDist2 ) {\n    \n        //sky\n        float sun   = rd.z;\n        float horiz = pow(max(1.-abs(rd.z),0.),25.0);\n        float light = sun + horiz - horiz * sun ;\n        return sqrt(mix(skyCol, skyCol2, light));\n        \n    } \n\n    vec3 hit, nor, col;\n    float specularity, closestDist;\n\n    if (objDist < maxDist2 && (floorDist < 0. || objDist < floorDist) ) {\n\n        //object\n        hit = ro + rd*objDist;\n        nor = distance_field_normal(hit);\n        col = objCol;\n        specularity = 0.25;\n        closestDist = objDist;            \n\n    } else {\n\n        //floor\n        hit = ro + rd*floorDist;\n        nor = vec3(0.,0.,1.);\n        col = flrCol;\n        specularity = 0.;\n        closestDist = floorDist;\n\n    }\n\n    float diffuse  = max(nor.z*0.45 + 0.55, 0.0);\n    float specular = pow( max( -2.*nor.z*dot(rd, nor) + rd.z, 0.0), 5.0);\n\n    vec3 finalCol = ( col + specular*specularity ) * diffuse ;\n\n    finalCol *= ao(hit, nor);\n\n    finalCol = mix(skyCol2, finalCol, exp(-closestDist*0.005));\n    \n    //finalCol = vec3(ao(hit, nor));\n\n    return sqrt(finalCol);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy    - iResolution.xy) / iResolution.y;\n    \n    float ang1 = iTime*0.2 - m.x*2.;\n    float ang2 = - PI*0.525;// -m.y - PI*0.27;\n    \n    vec2 cs1  = vec2(cos(ang1),sin(ang1));\n    vec2 cs2  = vec2(cos(ang2),sin(ang2));\n    mat2 rot1 = mat2(cs1.yxx,-cs1.y);\n    mat2 rot2 = mat2(cs2.yxx,-cs2.y);\n   \n    vec3 ro = vec3( 0., 3.5, 0.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) ).xzy;\n\n    rd.yz *= rot2;\n    ro.yz *= rot2;\n    \n    ro.z += 1.;\n    \n    rd.xy *= rot1;\n    ro.xy *= rot1;\n    \n    ////\n    \n    vec3 finalCol = render( ro, rd );\n            \n    fragColor = vec4( finalCol, 1.);\n      \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926535\n#define SQRT2 1.41421356237\n\nfloat getDist(vec3 p) {\n    \n    // parameters :\n\n    int iterations  = 3;\n    float finalSize = 0.5;\n    float roundness = 0.5;\n    vec3 offset = vec3(3.5,4.5,2.);\n    float ang = 1.625;\n\n    //\n\n    float size = finalSize;\n\n    // precomputed value for rotations\n    vec2 sc = vec2(sin(ang*PI),-cos(ang*PI))*SQRT2;\n      \n    p.z = abs(2.*size - p.z) - size;\n    size *= 0.5;\n    \n    for ( int i = 0; i++ < iterations; ) {\n        \n        //diagonal symmetry\n        p.xy = (p.x>p.y) ? p.xy : p.yx;\n\n        //simplified rotation + symmetry\n        p.xy -= min(dot(p.xy,sc),0.)*sc;\n\n        //diagonal symmetry\n        p.xz = (p.x>p.z) ? p.xz : p.zx; \n\n        size *= 0.5;\n        p = abs(p.yzx) - offset*size;\n    }\n    p.y -= size*0.5;\n\n    //\n        \n    vec3 q = abs(p) - vec3(2.-roundness)*size;\n    float t2 = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - roundness*size;\n    \n    t2 = abs(t2 + 0.5*size) - 0.5*size;\n    \n    //return max( t2, size - length(p.xz) );\n    return max( t2, -max(length(p.xz) - size,-p.y) );\n        \n}\n\nfloat getDistAndFloor(vec3 p) {\n    return min(getDist(p),p.z);\n}\n\n//custom ambient occlusion\nfloat ao(vec3 p, vec3 n) {\n    float range = 0.09;\n    float res  = clamp(getDistAndFloor(p + n*range   ) / range       , 0., 0.5) * 0.7\n               + clamp(getDistAndFloor(p + n*range*2.) / range * 0.5 , 0., 0.5) * 0.2\n               + clamp(getDistAndFloor(p + n*range*4.) / range * 0.25, 0., 0.5) * 0.1;\n    \n    return (res*1.5 + 0.25) * min(0.5+0.5*length(p-vec3(0.,0.,0.7)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}