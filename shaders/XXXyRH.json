{
    "Shader": {
        "info": {
            "date": "1725803399",
            "description": "Neon Pyramid Visualizer by Orblivius",
            "flags": 0,
            "hasliked": 0,
            "id": "XXXyRH",
            "likes": 4,
            "name": "Neon Pyramid Viz",
            "published": 3,
            "tags": [
                "fft",
                "audio",
                "neon",
                "pyramid"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 121
        },
        "renderpass": [
            {
                "code": "// Neon Pyramid Visualzier by 0rblivius\n\n// Source: https://shadertoy.com/view/4Xfyz8 \n//         https://www.shadertoy.com/view/stsXDl \n//         https://www.shadertoy.com/view/MdS3Rw\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n// ray marching\nconst int max_iterations = 128;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.01;\nconst float clip_far = 1000.0;\n\n// ao\nconst int   ao_iterations = 5;\nconst float ao_step = 0.2;\nconst float ao_scale = 1.46;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nconst float GOLDEN = 1.6180339887499;\n\nconst float r = 1.0 * 2.0 * 1.414214 / 1.732051;\nconst vec2 h = vec2( r, 0.01 );\nconst vec2 h2 = h * vec2( 0.73, 4.0 );\n\nconst vec3 cc0 = vec3( 0.333333, -0.333333, -0.333333 );\nconst vec3 cx0 = vec3( 0.707107, 0.000000, 0.707107 );\nconst vec3 cy0 = vec3( 0.408248, 0.816496, -0.408248 );\nconst vec3 cz0 = vec3( -0.577350, 0.577350, 0.577350 );\n\t\t\nconst vec3 cc1 = vec3( -0.333333, -0.333333, 0.333333 );\nconst vec3 cx1 = vec3( 0.707107, 0.000000, 0.707107 );\nconst vec3 cy1 = vec3( -0.408248, 0.816496, 0.408248 );\nconst vec3 cz1 = vec3( -0.577350, -0.577350, 0.577350 );\n\t\t\nconst vec3 cc2 = vec3( -0.333333, 0.333333, -0.333333 );\nconst vec3 cx2 = vec3( 0.707107, 0.707107, 0.000000 );\nconst vec3 cy2 = vec3( -0.408248, 0.408248, 0.816496 );\nconst vec3 cz2 = vec3( 0.577350, -0.577350, 0.577350 );\n\t\t\nconst vec3 cc3 = vec3( 0.333333, 0.333333, 0.333333 );\nconst vec3 cx3 = vec3( 0.000000, 0.707107, -0.707107 );\nconst vec3 cy3 = vec3( -0.816496, 0.408248, 0.408248 );\nconst vec3 cz3 = vec3( 0.577350, 0.577350, 0.577350 );\n\nconst vec3 c0 = vec3( 0.333333, 0.333333, -0.333333 );\nconst vec3 x0 = vec3( 0.572061, 0.218508, 0.790569 );\nconst vec3 y0 = vec3( -0.582591, 0.786715, 0.204124 );\nconst vec3 z0 = vec3( -0.577350, -0.577350, 0.577350 );\n\nconst vec3 c1 = vec3( 0.206011, -0.539344, 0.000000 );\nconst vec3 x1 = vec3( 0.572061, 0.218508, 0.790569 );\nconst vec3 y1 = vec3( -0.738528, -0.282093, 0.612372 );\nconst vec3 z1 = vec3( 0.356822, -0.934172, 0.000000 );\n\nconst vec3 c2 = vec3( -0.539344, 0.000000, -0.206011 );\nconst vec3 x2 = vec3( -0.218508, 0.790569, 0.572061 );\nconst vec3 y2 = vec3( -0.282093, -0.612372, 0.738528 );\nconst vec3 z2 = vec3( 0.934172, 0.000000, 0.356822 );\n\nconst vec3 c3 = vec3( 0.000000, 0.206011, 0.539344 );\nconst vec3 x3 = vec3( -0.790569, 0.572061, -0.218508 );\nconst vec3 y3 = vec3( -0.612372, -0.738528, 0.282093 );\nconst vec3 z3 = vec3( -0.000000, 0.356822, 0.934172 );\n\n// distance function\n\n// iq's Signed Triangular Prism distance function\nfloat dist_triXY( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.7);\n}\n\nfloat dist_tri( vec3 v, vec3 c, vec3 x, vec3 y, vec3 z ) {\n\tv -= c;\t\n  \n\tv = vec3( dot( v, (x) ), dot( (v), y ), dot( v, z ) );\n\treturn ( dist_triXY( v, h  ), dist_triXY( v, h2 ) );\n}\n\nfloat dist_field( vec3 v ) {\n\tfloat b0, b1, b2, b3, b4;\n\t\n\t// cube\n\n\tfloat k = 1.+texture(iChannel0, vec2(0.1,0.0)).r;\n    float r = 1.+1.3*texture(iChannel0, vec2(0.25,0.0)).r;\n    float t = 1.+1.3*texture(iChannel0, vec2(0.5,0.0)).r;\n    float w = 1.+1.3*texture(iChannel0, vec2(0.75,0.0)).r;\n\t// xyz\n\t{\n        v.zx = -v.zx;\t\n    \n\t\tfloat d0 = dist_tri( v/k, c0*k, x0*k, y0*k, z0*k );\n\t\tfloat d1 = dist_tri( v/r, c1*r, x1*r, y1*r, z1*r );\n\t\tfloat d2 = dist_tri( v/t, c2*t, x2*t, y2*t, z2*t );\n\t\tfloat d3 = dist_tri( v/w, c3*w, x3*w, y3*w, z3*w );\n\t\tb1 = min( min( d0, d1 ), min( d2, d3 ) );\n\t}\n\t\n\t\n\t// yz\n\t\n\n\t\n\treturn b1;\n}\n\n// ao\nfloat ao( vec3 v, vec3 n ) {\n\tfloat sum = 0.0;\n\tfloat att = 1.0;\n\tfloat len = ao_step;\n\tfor ( int i = 0; i < ao_iterations; i++ ) {\n\t\tsum += ( len - dist_field( v + n * len ) ) * att;\n\t\t\n\t\tlen += ao_step;\n\t\t\n\t\tatt *= 0.5;\n\t}\n\t\n\treturn max( 1.0 - sum * ao_scale, 0.0 );\n}\n\n\n// get gradient in the world\nvec3 gradient( vec3 v ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( v + dx ) - dist_field( v - dx ),\n\t\t\tdist_field( v + dy ) - dist_field( v - dy ),\n\t\t\tdist_field( v + dz ) - dist_field( v - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// shadow\nfloat shadow( vec3 v, vec3 light ) {\n\tvec3 lv = v - light;\n\tfloat end = length( lv );\n\tlv /= end;\n\t\n\tfloat depth = ray_marching( light, lv, 0.0, end );\n\t\n\treturn step( end - depth, 0.02 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( -15,-15,-15 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, 3.0 );\n\t\t\n\t\tfinal += ( diffuse * 0.1 + specular * 0.9 ) ; \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3(15,15,15);\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, 3.0 );\n\t\t\n\t\tfinal += ( diffuse * 0.1 + specular  * 0.9 ); \n\t}\n\n\tfinal += ao( v, n ) * vec3( .1 );\n\t\n\treturn final;\n}\n\n// pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\nmat3 matRotate( vec3 xyz ) {\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n    \n    return mat3(    co.y*co.z,                co.y*si.z,               -si.y,\n                    si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,\n                    co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y );\n}\n\nvec3 aces(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\nvec3 hueShift(vec3 col, float shift){\nvec3 m = vec3(cos(shift), -sin(shift) * .57735, 0);\nm = vec3(m.xy, -m.y) + (1. - m.x) * .33333;\nreturn mat3(m, m.zxy, m.yzx) * col;\n}\n\n\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec4 OX=vec4(0);\n    vec3 n1,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=2.;\n        ++i<20.;\n        OX.xyz+=mix(vec3(0.5,0.2,1.),H(g*.1),.28)*3./e/8e3\n    )\n    {\n        n1=g*d;\n   \n   float snd = texture(iChannel0, vec2(i/80.,0.25)).r+\n            texture(iChannel0, vec2(i/100.+0.01,0.25)).r;\n            \n    for(float j=0.;j<10.;j++){\n    n1.y+=iTime;\n    j+=iTime+length(n1);\n     n1.xz*=mat2(cos(j),sin(j),-sin(j),cos(j) );\n          }\n        a=30.;\n        n1=mod(n1-a,a*2.)-a;\n        s=5.+snd*snd;\n  \n   \n        for(float i=0.;i++<10.;){\n      \n            n1=.3-abs(n1);\n          n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.7+sin(iTime*.04)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    10.*3.,\n                    120,\n                    8.*5.\n                 );\n         }\n         g+=e=length(n1.yxz)/s;\n    }\n \n          \n          \n          \n    O=vec4(0,0,0,1);\n    vec4 O2=vec4(O.rgb,1.);\n    vec3 dir = ray_dir( 45.0, iResolution.xy, C.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 4.4 );\n\n\t// rotate camera\n\t//mat3 rot = rot3xy( vec2( -DEG_TO_RAD * 30.0, iTime ) );\n    mat3 rot2 = matRotate( vec3(  DEG_TO_RAD * 10.0, iTime*.5, iTime*.4 ));\n\tdir = rot2 * dir;\n\teye = rot2 * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tO2 = vec4( 0.0, 0.0, 1.0, 1.0 );\n    } else if (depth > 0.0) {\n\t\t// shading\n\t\tvec3 pos = eye + dir * depth;\n\t\tvec3 n = gradient( pos );\n\t\tO2 = vec4( shading( pos, n, eye ) * 2.0, 1.0 );\n    }\n    vec3 p;\n    q = vec3(0);\n    r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1)); \n    \n   float snd = 0.0;\n    for(float i=0.,a,s,e,g=0.;\n        ++i<60.;\n        O.xyz+=mix(vec3(.5,.6,.7),H(g*1.1*d),.9)/e/8e2\n    )\n    {\n        p=g*d;\n        snd = texture(iChannel0, vec2(i/60.,0.25)).r+\n            texture(iChannel0, vec2(i/100.+0.01,0.25)).r;\n        p.z += iTime*10.;\n        a=20.;\n        p=mod(p-a,a*2.)-a;\n        s=5.;\n        for(int i=0;i++<8;){\n            p=0.5-abs(p);\n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            s*=e=1.7+sin(iTime*.011)*.15;\n            p=abs(p)*e-\n                vec3(\n                    5.*3.,\n                    150,\n                    (6.*snd+8.)*5.\n                 )*(O2.xyz*2.);\n         }\n         g+=e=length(p.xyzz)/s;\n    }\n    O.rgb=(hueShift(O.rgb*O.rgb,-iTime*.2) + \n               0.2 * hueShift(OX.rgb*OX.rgb,iTime*.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}