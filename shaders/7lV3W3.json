{
    "Shader": {
        "info": {
            "date": "1638468367",
            "description": "same as the 2d version...",
            "flags": 0,
            "hasliked": 0,
            "id": "7lV3W3",
            "likes": 7,
            "name": "islandshapes3d",
            "published": 3,
            "tags": [
                "sdf",
                "bezier",
                "island",
                "extrude"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "// island 3d (extrude) - added the colouring from the 2d version + 3 islands\n//\n// This is basically a fork of the Original SDF Quadratic Bézier Shape here: https://www.shadertoy.com/view/ftdGDB\n// slightly modified to produce random Island shapes from a vec2 seed value.\n// Golf anyone? :)\n\n// Author: Thomas Stehle\n// Title: SDF Quadratic Bézier Shape\n//\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Signed distance function for a shape made out of quadratic\n// Bézier curves in the tradition of iq's series such as this\n// one: https://www.shadertoy.com/view/MlKcDD.\n//\n// The only real contribution of this shader is that it postpones\n// the call to the costly Bézier SDF up until the point it has\n// identified the closest segment of the control polygon.\n// So instead of iterating over all Bézier curves, we iterate\n// over the line segments of the control polygon and identify the\n// closest segment. We then call the Bézier SDF for this segment\n// only. This approach is correct since quadratic Bézier curves\n// are always contained in the triangle formed by its three\n// control points.\n// Constants\nconst int CAPACITY = 8; // Control polygon capacity\nconst float INF   = 1.0 / 0.0;\nconst float SQRT3 = 1.732050807568877;\n\n// Cross-product of two 2D vectors\nfloat cross2(in vec2 a, in vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\n\n// Clamp a value to [0, 1]\nfloat saturate(in float a) {\n    return clamp(a, 0.0, 1.0);\n}\nvec3 saturate(in vec3 a) {\n    return clamp(a, 0.0, 1.0);\n}\n\n// Minimum of the absolute of two values\nfloat abs_min(float a, float b) {\n    return abs(a) < abs(b) ? a : b;\n}\n\n// SDF for a line segment\nfloat sdf_line(in vec2 p, in vec2 a, in vec2 b) {\n    float h = saturate(dot(p - a, b - a) /\n                       dot(b - a, b - a));\n    return length(p - a - h * (b - a));\n}\n\n// Like the SDF for a line but partitioning space into positive and negative\nfloat sdf_line_partition(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = saturate(dot(pa, ba) / dot(ba, ba));\n    vec2 k = pa - h * ba;\n    vec2 n = vec2(ba.y, -ba.x);\n    return (dot(k,n) >= 0.0) ? length(k) : -length(k);\n}\n\n// Signed distance to a quadratic Bézier curve\n// Mostly identical to https://www.shadertoy.com/view/MlKcDD\n// with some additions to combat degenerate cases.\nfloat sdf_bezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    const float EPSILON = 1e-3;\n    const float ONE_THIRD = 1.0 / 3.0;\n\n    // Handle cases where points coincide\n    bool abEqual = all(equal(A, B));\n    bool bcEqual = all(equal(B, C));\n    bool acEqual = all(equal(A, C));\n    \n    if (abEqual && bcEqual) {\n        return distance(pos, A);\n    } else if (abEqual || acEqual) {\n        return sdf_line_partition(pos, B, C);\n    } else if (bcEqual) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    // Handle colinear points\n    if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < EPSILON) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) * ONE_THIRD;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if (h >= 0.0) {\n        // One root\n        h = sqrt(h);\n        vec2 x = 0.5 * (vec2(h, -h) - q);\n        vec2 uv = sign(x) * pow(abs(x), vec2(ONE_THIRD));\n        float t = saturate(uv.x + uv.y - kx) + EPSILON;\n        vec2 q = d + (c + b*t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0*b*t, q);\n    } else {\n        // Three roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0)) * ONE_THIRD;\n        float m = cos(v);\n        float n = sin(v) * SQRT3;\n        vec3 t = saturate(vec3(m+m,-n-m,n-m)*z-kx) + EPSILON;\n        vec2 qx = d + (c+b*t.x)*t.x;\n        float dx = dot(qx, qx);\n        float sx = cross2(c+2.0*b*t.x, qx);\n        vec2 qy = d + (c+b*t.y)*t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c+2.0*b*t.y, qy);\n        res = (dx < dy) ? dx : dy;\n        sgn = (dx < dy) ? sx : sy;\n    }\n    \n    return sign(sgn) * sqrt(res);\n}\n\n// Signed distance to a segment of a control polygon\nfloat sdf_control_segment(in vec2 p, in vec2 A, in vec2 B, in vec2 C) {\n    return abs_min(sdf_line(p, A, B), sdf_line(p, B, C));\n}\n\n\n// Signed distance to a quadratic Bezier shape made from a given control polygon\nfloat sdf_bezier_shape(in vec2 p, in vec2 controlPoly[CAPACITY])\n{\n    // Determine closest segment in control polygon\n    vec2 closest[3];\n    \n    // Signed distance to a control polygon\n    // Identifies and returns distance to the closest segment.\n    // Cycle through segments and track the closest\n    float d = INF;\n    float ds = 0.0;\n\n    // First n-2 segments\n    vec2 c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    vec2 prev = c;\n    for (int i = 1; i < CAPACITY - 1; ++i) {\n        prev = c;\n        c = 0.5 * (controlPoly[i] + controlPoly[i+1]);\n        ds = sdf_control_segment(p, prev, controlPoly[i], c);\n        if (abs(ds) < abs(d)) {\n            closest[0] = prev;\n            closest[1] = controlPoly[i];\n            closest[2] = c;\n            d = ds;\n        }\n    }\n\n    // Last-but-one segment\n    prev = c;\n    c = 0.5 * (controlPoly[CAPACITY-1] + controlPoly[0]);\n    ds = sdf_control_segment(p, prev, controlPoly[CAPACITY-1], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[CAPACITY-1];\n        closest[2] = c;\n        d = ds;\n    }\n\n    // Last segment\n    prev = c;\n    c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    ds = sdf_control_segment(p, prev, controlPoly[0], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[0];\n        closest[2] = c;\n        d = ds;\n    }\n    // d = distance to outer control polygon\n    // Refine by determining actual distance to curve of closest segment\n    return sdf_bezier(p, closest[0], closest[1], closest[2]);\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat remap(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdIsland(vec2 p,vec2 seed)\n{\n    // Control polygon shape\n    vec2 controlPoints[CAPACITY];\n    \n    float tt1 = seed.x;\n    float tt2 = seed.y;\n    for (int i=0;i<8;i++)\n    {\n        float a = ((-6.28)/8.0) * float(i);\n        float x = sin(a)*1.4;\n        float y = cos(a);\n        vec2 pos = vec2(x,y);\n        vec2 hash = hash2(pos+vec2(tt1*0.15,tt1*0.35));\n        hash = 0.5+sin(tt2+sin(hash*151.45))*0.5;\n        float rad = 0.65+(hash.x*0.6);\n        rad -= hash.y*0.55;\n        controlPoints[i] = vec2(x,y)*rad;\n    }\n    // Distance to shape\n    return sdf_bezier_shape(p, controlPoints);\n}\n\nfloat opExtrusion( in vec3 p, float dd, in float h )\n{\n    float d = dd;\n    vec2 w = vec2( d, abs(p.y) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec3 GetWater(vec2 p)\n{\n    const vec3 col = vec3(0.02,.3,.55);\n    const mat3 _m = mat3(-2.0,-1.0,2.0, 3.0,-2.0,1.0, 1.0,2.0,2.0);\n    vec4 d = vec4(iDate*.22);\n    d.xy = p;\n    d.xyw *=_m*.5;\n    float v1 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.4;\n    float v2 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.3;\n    float v3 = length(.5-fract(d.xyw));\n    float v = pow(min(min(v1,v2),v3), 7.)*15.;\n    return col+vec3(v,v,v);\n}\n\nfloat basemat;\n\nvec3 GetCol(float mat,vec3 pos)\n{\n    if (mat<=1.0)\n    {\n        float sandline = abs(sin(fract(22.0*(pos.z+sin(pos.x*6.0)*0.02))));\n        sandline = (1.0-step(sandline,0.5))*0.05;\n        vec3 sandcol =  vec3(0.9,0.85,0.2);  \n        return sandcol+=sandcol*sandline;    \n    }\n    else if (mat<=2.0)\n    {\n        float grassline = 0.5+sin(fract(5.0*(pos.x-pos.z*1.2))*6.28)*0.5;\n        grassline = smoothstep(0.35,0.65,grassline)*0.4;\n        vec3 grasscol = vec3(0.05,0.6,0.05);\n        return grasscol += grasscol*grassline;\n    }\n    return GetWater(pos.xz);\n}\n\nfloat map( in vec3 pos )\n{\n    vec2 seed = vec2(floor(iTime*0.25),fract(iTime*0.2)*6.28);\n    float dd1 = sdIsland(pos.xz,seed);\n    \n    float height = 0.05;\n    float d1 = opExtrusion(pos,dd1,height)-0.04;\n\n    height = 0.025;\n    float d2 = opExtrusion(pos+vec3(0.0,0.1,0.0),dd1-0.2,height)-0.02;\n    \n    basemat = 0.5;\n    if (d2>d1)\n      basemat = 1.5;\n    d1 = smin(d1,d2,0.05);\n    \n    float wd = pos.y+0.15;\n    \n    if (wd<d1)\n        basemat=2.5;\n    \n    d1 = smin(d1,wd,0.25);\n    \n    return d1;\n}\n\n\n    \n// https://iquilezles.org/articles/normalsSDF\n#define ZERO (min(iFrame,0))\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n//        n += e*map(pos+0.0005*e);\n        n += e*map(pos+0.05*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n    \n    \n#define AA 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n        float an =0.0;//0.25*iTime;\n    float hh = mix(0.75,1.5, 0.5+sin(iTime)*0.5);\n    \n\tvec3 ro = vec3( 3.*cos(an), hh, 3.*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 20.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        vec3 col = vec3(0.4,0.5,0.9);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            vec3 basecol = GetCol(basemat,pos);\n            col = vec3(0.1,0.1,0.1)*amb + basecol*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}