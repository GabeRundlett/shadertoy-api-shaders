{
    "Shader": {
        "info": {
            "date": "1714254925",
            "description": "water/atmosphere stuff.  based on shaders from folks much smarter than me - thank you :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4fdSzf",
            "likes": 24,
            "name": "drifting",
            "published": 3,
            "tags": [
                "water",
                "sky",
                "atmosphere"
            ],
            "usePreview": 0,
            "username": "acoo",
            "viewed": 473
        },
        "renderpass": [
            {
                "code": "// https://www.shadertoy.com/view/XlXGzB - sky\n// https://www.shadertoy.com/view/MdXyzX - water\n\n#if HW_PERFORMANCE == 0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n#define ZERO (min(iFrame,0))\n#define PI 3.14159265358979323846\n\n// General Parameters\nconst float CameraHeight = 1.5;\nconst float FOV = 60.0;\nconst bool SunAnimation = false;\nconst bool BobberAnimation = true;\n\n// Wave Parameters\nconst float BeckmanSpecular = 0.98;   // Higher values tighten the specular range.\nconst float FresnelFactor = 8.0;\nconst float WaterDepth = 1.0;\nconst float DragMultiplier = 0.38; // Changes how much waves pull on the water.\nconst int RaymarchSteps = 16;\nconst int RaymarchNormalSteps = 32;\n\n\n// Atmosphere Parameters\nconst int AtmosphereViewSteps = 64; \nconst int AtmosphereLightSteps = 32;\nconst float SunLightPower = 25.0; // sun light power, 10.0 is normal\nconst float SunIntensity = 8.0; // sun intensity for sun\nconst float G = 0.98; // Light concentration for HG phase function - lower for hazier/dispersed effect\nconst float Haze = 0.1;\n\n// Atmosphere Constants\nconst float PlanetRadius = 6360e3; // Planet radius 6360e3 actual 6371km\nconst float AtmosphereRadius = 6380e3; // Atmosphere radius 6380e3 troposphere 8 to 14.5km\nconst vec3 PlanetCenter = vec3(0.0, -PlanetRadius, 0.0);\nconst float Hr = 8e3;   // Rayleigh scattering top //8e3\nconst float Hm = 1.3e3; // Mie scattering top //1.3e3\n\n// -------------------- Helpers ---------------------\nfloat sphere_intersect(in vec3 p, in vec3 d, in float R) \n{\n\tvec3 v = p - PlanetCenter;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n\nfloat plane_intersect(vec3 origin, vec3 direction, vec3 point, vec3 normal) \n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 999999.0); \n}\n\n\nmat3 rotate_angle_axis(vec3 axis, float angle) \n{\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n// -------------------- Helpers ---------------------\n\n\n// -------------------- PostFX ----------------------\nvec3 aces_tonemap(vec3 color) \n{  \n    mat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n    );\n    mat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n    );\n    vec3 v = m1 * color;  \n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n// -------------------- PostFX ----------------------\n\n\n// -------------------- Atmosphere ---------------------\nvoid calculate_particle_densities(in vec3 pos, out float rayleigh, out float mie) \n{\n\tfloat h = length(pos - PlanetCenter) - PlanetRadius;\n\trayleigh =  exp(-h/Hr);\n\tmie = exp(-h/Hm) + Haze;\n}\n\nvoid scatter(vec3 ro, vec3 rd, vec3 lp, out vec3 col, out vec3 scat, in float t) \n{\n    vec3 mie_constant = vec3(21e-6); // Standard Mie distribution \n    vec3 rayleigh_constant = vec3(5.8e-6, 13.5e-6, 33.1e-6); // Standard Rayleigh distribution\n\n\tfloat L = sphere_intersect(ro, rd, AtmosphereRadius);\t\n\tfloat mu = dot(rd, lp);\n\tfloat opmu2 = 1.0 + mu * mu;\n\tfloat rayleigh_phase = 0.0596831 * opmu2;\n    \n    // HG phase functions for Mie scattering\n    const float g2 = G * G;\n    const float s = 0.999;\n\tfloat mie_phase = 0.1193662 * (1.0 - g2) * opmu2 / ((2.0 + g2) * pow(1.0 + g2 - 2.0 * G * mu, 1.5));\n    float sun_phase = 0.1193662 * (1.0 - s) * opmu2 / ((2.0 + s) * pow(1.0 + s - 2.0 * s * mu, 1.5));\n\t\n    // Optical depth for mie and rayleigh particles\n\tfloat depth_rayleigh = 0.0, depth_mie = 0.0;\n    \n    // Rayleigh and Mie scattering distributions\n\tvec3 R = vec3(0.0), M = vec3(0.0);\n\t\n\tfloat view_step_size = L / float(AtmosphereViewSteps);\n\tfor (int i = 0; i < AtmosphereViewSteps; ++i) \n    {\n\t\tfloat l = float(i) * view_step_size;\n\t\tvec3 sample_p_view = (ro + rd * l);\n\n\t\tfloat density_rayleigh, density_mie;\n        \n\t\tcalculate_particle_densities(sample_p_view, density_rayleigh, density_mie);\n        \n\t\tdensity_rayleigh *= view_step_size; \n        density_mie *= view_step_size;\n        \n\t\tdepth_rayleigh += density_rayleigh;\n\t\tdepth_mie += density_mie;\n\n\t\tfloat to_light_isect = sphere_intersect(sample_p_view, lp, AtmosphereRadius);\n\t\tif (to_light_isect > 0.0) \n        {\n\t\t\tfloat light_step_size = to_light_isect / float(AtmosphereLightSteps);\n\t\t\tfloat depth_rayleigh_light = 0.0, depth_mie_light = 0.0;\n            \n\t\t\tfor (int j = 0; j < AtmosphereLightSteps; ++j) \n            {\n\t\t\t\tfloat ls = float(j) * light_step_size;\n\t\t\t\tvec3 sample_p_light = sample_p_view + lp * ls;\n                \n\t\t\t\tfloat density_rayleigh_light, density_mie_light;\n\t\t\t\tcalculate_particle_densities(sample_p_light, density_rayleigh_light, density_mie_light);\n                \n\t\t\t\tdepth_rayleigh_light += density_rayleigh_light * light_step_size;\n\t\t\t\tdepth_mie_light += density_mie_light * light_step_size;\n\t\t\t}\n\n\t\t\tvec3 absorption = exp(-(rayleigh_constant * (depth_rayleigh_light + depth_rayleigh) + mie_constant * (depth_mie_light + depth_mie)));\n\t\t\tR += absorption * density_rayleigh;\n\t\t\tM += absorption * density_mie;\n\t\t} \n\t}\n\n    col = SunLightPower * M * mie_constant * mie_phase;            // Mie scattering\n    col += SunLightPower * R * rayleigh_constant * rayleigh_phase; // Rayleigh scattering\n\n    col += SunIntensity * M * mie_constant * sun_phase;            // Sun\n    scat = 0.01 * mie_constant * depth_mie;\n}\n// -------------------- Atmosphere ---------------------\n\n\n// -------------------- Waves ---------------------\nvec2 wave_dx(vec2 position, vec2 direction, float frequency, float timeshift) \n{\n// Calculates wave value and its derivative, for the wave direction, position in space, wave frequency and time\n\n  float x = dot(direction, position) * frequency + timeshift;\n  float wave = exp(sin(x) - 1.0);\n  float dx = wave * cos(x);\n  return vec2(wave, -dx);\n}\n\n// Calculates waves by summing octaves of various waves with various parameters\nfloat calculate_wave_at_p(vec2 position, int iterations) \n{\n  float iter = 0.0; // this will help generating well distributed wave directions\n  float frequency = 1.0; // frequency of the wave, this will change every iteration\n  float time_mult = 2.0; // time multiplier for the wave, this will change every iteration\n  float weight = 1.0;// weight in final sum for the wave, this will change every iteration\n  float sum_of_values = 0.0; // will store final sum of values\n  float sum_of_weights = 0.0; // will store final sum of weights\n  \n  for(int i=0; i < iterations; i++) \n  {\n    vec2 p = vec2(sin(iter), cos(iter));\n    vec2 wave_data = wave_dx(position, p, frequency, iTime * time_mult);\n\n    // Shift position around according to wave drag and derivative of the wave\n    position += p * wave_data.y * weight * DragMultiplier;\n\n    sum_of_values += wave_data.x * weight;\n    sum_of_weights += weight;\n\n    // Modify next octave\n    weight = mix(weight, 0.0, 0.2);\n    frequency *= 1.18;\n    time_mult *= 1.07;\n\n    // Add some kind of random value to make next wave look random too\n    iter += 1232.399963;\n  }\n  \n  return sum_of_values / sum_of_weights;\n}\n// -------------------- Waves ---------------------\n\n\n// -------------------- March ----------------------\nfloat march(vec3 camera, vec3 start, vec3 end, float depth) \n{\n    vec3 p = start;\n    vec3 dir = normalize(end - start);\n\n    for(int i=0; i < 64; i++) \n    {\n        float wave_height = calculate_wave_at_p(p.xz, RaymarchSteps) * depth - depth;\n        if(wave_height + 0.1 > p.y) \n           return distance(p, camera);\n\n        p += dir * (p.y - wave_height);\n    }\n\n    return distance(start, camera);\n}\n\n// Calculate normal at point by calculating the height at the pos and 2 additional points very close to pos\nvec3 normal(vec2 p, float e, float depth) \n{\n  vec2 ex = vec2(e, 0);\n  float wave_height = calculate_wave_at_p(p.xy, RaymarchNormalSteps) * depth;\n  vec3 a = vec3(p.x, wave_height, p.y);\n  return normalize(\n    cross(\n      a - vec3(p.x - e, calculate_wave_at_p(p.xy - ex.xy, RaymarchNormalSteps) * depth, p.y), \n      a - vec3(p.x, calculate_wave_at_p(p.xy + ex.yx, RaymarchNormalSteps) * depth, p.y + e)\n    )\n  );\n} \n// -------------------- March ----------------------\n\n\n// -------------------- Stars ----------------------\nfloat hash21(vec2 p) \n{\n    p = fract(p*vec2(123.34,234.34));\n    p += dot(p, p+23.43);\n    return fract(p.x*p.y);\n}\n\n\nfloat star_layer(vec2 p, float seed) \n{\n    float t = iTime * 2.0 + seed;\n    vec2 id = floor(p);\n    vec2 gv = fract(p) - 0.5;\n    \n    float n = hash21(id);\n    float x = fract(n * 12.32);\n    float y = fract(n * 123.32);\n    vec2 offs = vec2(x,y) - 0.5;\n    \n    float d = length(gv - offs * 0.9);\n    float m = smoothstep(0.01, 0.0, d);\n    \n    m *= pow(sin(t + n * 6.2832)* 0.5 + 0.5, 3.0);\n    return m;\n}\n// -------------------- Stars ----------------------\n\n\nvec3 render(vec2 uv) \n{\n    vec2 mouse = (iMouse.xy - iResolution.xy * 0.5) / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0)\n        mouse = vec2(0.0, -0.1);\n    \n    float fov_rads = tan(radians(FOV));\n    \n    float x = (sin(iTime * 0.5) + cos(iTime * 0.5)) * 0.5 + 0.5;\n    vec3 ro = BobberAnimation \n        ? vec3(iTime * 0.1, mix(CameraHeight, CameraHeight - WaterDepth, x), 1.0)\n        : vec3(iTime * 0.1, CameraHeight, 1.0);\n\n    mat3 rot = rotate_angle_axis(vec3(1.0, 0.0, 0.0), -0.18);\n    vec3 rd =  rot * normalize(vec3(uv, fov_rads / -2.5));\n    vec3 lp = iMouse.z > 0.0 || !SunAnimation\n        ? rot * normalize(vec3(mouse.xy, fov_rads / -2.5))\n        : rot * normalize(vec3(sin(iTime * 0.1) * 0.9, cos(iTime * 0.1) * 0.9, fov_rads / -2.5));\n\n    if (rd.y >= 0.0) \n    {\n        vec3 sky_color = vec3(0.0);\n        vec3 sky_scattering = vec3(0.0);\n        scatter(ro, rd, lp, sky_color, sky_scattering, iTime);\n        sky_color += sky_scattering;\n        \n        float offset = dot(rd, vec3(10.0));\n        float stars = star_layer(uv * 10.0, offset);\n        stars += star_layer(uv * 17.0+ 3.1, offset);\n        stars += star_layer(uv * 23.+23.1, offset);\n        stars *= smoothstep(0.0, -0.2, lp.y);\n        return sky_color + stars; \n    }\n    \n    vec3 water_plane_high = vec3(0.0, 0.0, 0.0);\n    vec3 water_plane_low = vec3(0.0, -WaterDepth, 0.0);\n\n    // Calculate intersections and reconstruct positions.\n    float high_plane_hit = plane_intersect(ro, rd, water_plane_high, vec3(0.0, 1.0, 0.0));\n    float low_plane_hit = plane_intersect(ro, rd, water_plane_low, vec3(0.0, 1.0, 0.0));\n    vec3 high_hit_p = ro + rd * high_plane_hit;\n    vec3 low_hit_p = ro + rd * low_plane_hit;  \n\n    float d = march(ro, high_hit_p, low_hit_p, WaterDepth);\n    vec3 water_hit_p = ro + rd * d;\n\n    vec3 N = normal(water_hit_p.xz, 0.01, WaterDepth);\n    // Smooth the normal with distance to avoid disturbing high frequency noise.\n    N = mix(N, vec3(0.0, 1.0, 0.0), 0.88 * min(1.0, sqrt(d * 0.01) * 0.9));\n    vec3 L = normalize(lp);\n    vec3 V = normalize(-rd);\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n\n    // Specular reflection lighting coefficients\n    float fresnel = (0.04 + (1.0 - 0.04) * (pow(1.0 - max(0.0, dot(-N, rd)), FresnelFactor)));\n    float k = 0.0;\n\n    float tan_a = length(cross(N, H)) / NdotH;\n    float cos_a = NdotH;\n    float m2 = BeckmanSpecular * BeckmanSpecular;\n    float tana2 = tan_a * tan_a;\n    float cosa4 = pow(abs(cos_a), 4.0);\n    k = exp(-tana2 / m2) / (PI * m2 * cosa4) * 0.1;\n    \n    // Diffuse lighting coefficents & SSS\n    float diff = max(0.0, dot(N, L));\n    vec3 sss = vec3(0.0293, 0.0698, 0.1717) * 0.1 * (1.0 + (water_hit_p.y + WaterDepth) / WaterDepth);\n\n    // Environment reflection\n    vec3 R = normalize(reflect(rd, N));\n    R.y = abs(R.y);\n    vec3 water_reflect = vec3(0.0);\n    vec3 water_scat = vec3(0.0);\n\n    scatter(ro, R, lp, water_reflect, water_scat, iTime);\n    water_reflect += water_scat;\n    vec3 diffuse_scatter = (water_scat + sss) * diff;\n\n    vec3 spec_reflection = water_reflect * k + fresnel * water_reflect;\n    \n    float offset = dot(rd * d, vec3(10.0));\n    float stars = star_layer(rd.xz * 10.0, offset);\n    stars += star_layer(rd.xz * 17.0 + 3.1, offset);\n    stars += star_layer(rd.xz * 23.0 + 23.1, offset);\n    stars *= smoothstep(0.0, -0.2, lp.y);\n\n    return spec_reflection + diffuse_scatter + stars * 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 p = ((fragCoord + o) - iResolution.xy * 0.5)/iResolution.y;\n#else    \n        vec2 p = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n#endif\n\n        vec3 color = render(p);\n        color = aces_tonemap(color);\n\n        tot += color;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4(tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}