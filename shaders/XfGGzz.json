{
    "Shader": {
        "info": {
            "date": "1712304610",
            "description": "I am attempting to write a shader that utilizes a list of points to color a 2D shape composed of cubic Bezier curves. However, it seems to be coloring only specific portions of the shape, determined by the orientation of the object.\n\nCan anyone assist me?",
            "flags": 0,
            "hasliked": 0,
            "id": "XfGGzz",
            "likes": 1,
            "name": "Filling Cubic Bezier 2D Shape.",
            "published": 3,
            "tags": [
                "bezier",
                "cubic",
                "filling",
                "cubicbezier"
            ],
            "usePreview": 1,
            "username": "Prienast",
            "viewed": 139
        },
        "renderpass": [
            {
                "code": "/*\nExact distance to cubic bezier curve by computing roots of the derivative(s)\nto isolate roots of a fifth degree polynomial and Halley's Method to compute them.\n*/\nconst float eps = .000005;\nconst int halley_iterations = 8;\n\n//lagrange positive real root upper bound\n//see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(a0,a1,a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn max_max + max_max2;\n}\n\n//lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(-a0,a1,-a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn -max_max - max_max2;\n}\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0] = min(roots[0],min(roots[1],roots[2]));\n\ttmp[1] = max(roots[0],min(roots[1],roots[2]));\n\ttmp[2] = max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\nvoid sort_roots4(inout vec4 roots){\n\tvec4 tmp;\n\n\tvec2 min1_2 = min(roots.xz,roots.yw);\n\tvec2 max1_2 = max(roots.xz,roots.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\ttmp[0] = min(min1_2.x,min1_2.y);\n\ttmp[1] = min(maxmin,minmax);\n\ttmp[2] = max(minmax,maxmin);\n\ttmp[3] = max(max1_2.x,max1_2.y);\n\n\troots = tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n\treturn f;\n}\n\n//halley's method\n//basically a variant of newton raphson which converges quicker and has bigger basins of convergence\n//see http://mathworld.wolfram.com/HalleysMethod.html\n//or https://en.wikipedia.org/wiki/Halley%27s_method\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n        if(old_num!=num){\n            if(old_num == 0){\n                s[0] = tmp[0];\n                s[1] = tmp[1];\n            }\n            else{//old_num == 2\n                s[2] = tmp[0];\n                s[3] = tmp[1];\n            }\n        }\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\nfloat cubic_bezier_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\t//switch points when near to end point to minimize numerical error\n\t//only needed when control point(s) very far away\n\t//#if 0\n\tvec2 mid_curve = parametric_cub_bezier(.5,p0,p1,p2,p3);\n\tvec2 mid_points = (p0 + p3)/2.;\n\n\tvec2 tang = mid_curve-mid_points;\n\tvec2 nor = vec2(tang.y,-tang.x);\n\n\tif(sign(dot(nor,uv-mid_curve)) != sign(dot(nor,p0-mid_curve))){\n\t\tvec2 tmp = p0;\n\t\tp0 = p3;\n\t\tp3 = tmp;\n\n\t\ttmp = p2;\n\t\tp2 = p1;\n\t\tp1 = tmp;\n\t}\n\t//#endif\n\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n    \n    //compute polynomial describing distance to current pixel dependent on a parameter t\n\tfloat bc6 = dot(a3,a3);\n\tfloat bc5 = 2.*dot(a3,a2);\n\tfloat bc4 = dot(a2,a2) + 2.*dot(a1,a3);\n\tfloat bc3 = 2.*(dot(a1,a2) + dot(a0,a3));\n\tfloat bc2 = dot(a1,a1) + 2.*dot(a0,a2);\n\tfloat bc1 = 2.*dot(a0,a1);\n\tfloat bc0 = dot(a0,a0);\n\n\tbc5 /= bc6;\n\tbc4 /= bc6;\n\tbc3 /= bc6;\n\tbc2 /= bc6;\n\tbc1 /= bc6;\n\tbc0 /= bc6;\n    \n    //compute derivatives of this polynomial\n\n\tfloat b0 = bc1 / 6.;\n\tfloat b1 = 2. * bc2 / 6.;\n\tfloat b2 = 3. * bc3 / 6.;\n\tfloat b3 = 4. * bc4 / 6.;\n\tfloat b4 = 5. * bc5 / 6.;\n\n\tvec4 c1 = vec4(b1,2.*b2,3.*b3,4.*b4)/5.;\n\tvec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;\n\tvec2 c3 = vec2(c2[1],2.*c2[2])/3.;\n\tfloat c4 = c3[1]/2.;\n\n\tvec4 roots_drv = vec4(1e38);\n\n\tint num_roots_drv = solve_quartic(c1,roots_drv);\n\tsort_roots4(roots_drv);\n\n\tfloat ub = upper_bound_lagrange5(b0,b1,b2,b3,b4);\n\tfloat lb = lower_bound_lagrange5(b0,b1,b2,b3,b4);\n\n\tvec3 a = vec3(1e38);\n\tvec3 b = vec3(1e38);\n\n\tvec3 roots = vec3(1e38);\n\n\tint num_roots = 0;\n    \n\t//compute root isolating intervals by roots of derivative and outer root bounds\n    //only roots going form - to + considered, because only those result in a minimum\n\tif(num_roots_drv==4){\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) > 0.){\n\t\t\ta[0]=lb;\n\t\t\tb[0]=roots_drv[0];\n\t\t\tnum_roots=1;\n\t\t}\n\n\t\tif(sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1])) != sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[2]))){\n            if(num_roots == 0){\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=roots_drv[2];\n                num_roots=1;\n            }\n            else{\n            \ta[1]=roots_drv[1];\n\t\t\t\tb[1]=roots_drv[2];\n                num_roots=2;\n            }\n\t\t}\n\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[3]) < 0.){\n            if(num_roots == 0){\n                a[0]=roots_drv[3];\n                b[0]=ub;\n                num_roots=1;\n            }\n            else if(num_roots == 1){\n                a[1]=roots_drv[3];\n                b[1]=ub;\n                num_roots=2;\n            }\n            else{\n                a[2]=roots_drv[3];\n                b[2]=ub;\n                num_roots=3;\n            }\n\t\t}\n\t}\n\telse{\n\t\tif(num_roots_drv==2){\n\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) < 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=ub;\n\t\t\t}\n\t\t\telse if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1]) > 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum_roots=2;\n\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\n\t\t\t\ta[1]=roots_drv[1];\n\t\t\t\tb[1]=ub;\n\t\t\t}\n\n\t\t}\n\t\telse{//num_roots_drv==0\n\t\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\n\t\t\tvec2 roots_trd_drv=vec2(1e38);\n\t\t\tint num_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t\tnum_roots=1;\n\n\t\t\ta[0]=lb;\n\t\t\tb[0]=ub;\n\t\t}\n        \n        //further subdivide intervals to guarantee convergence of halley's method\n\t\t//by using roots of further derivatives\n\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\t\tsort_roots3(roots_snd_drv);\n\n\t\tint num_roots_trd_drv=0;\n\t\tvec2 roots_trd_drv=vec2(1e38);\n\n\t\tif(num_roots_snd_drv!=3){\n\t\t\tnum_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t}\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(i < num_roots){\n\t\t\t\tfor(int j=0;j<3;j+=2){\n\t\t\t\t\tif(j < num_roots_snd_drv){\n\t\t\t\t\t\tif(a[i] < roots_snd_drv[j] && b[i] > roots_snd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_snd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tif(j < num_roots_trd_drv){\n\t\t\t\t\t\tif(a[i] < roots_trd_drv[j] && b[i] > roots_trd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_trd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat d0 = 1e38;\n\n    //compute roots with halley's method\n    \n\tfor(int i=0;i<3;i++){\n\t\tif(i < num_roots){\n\t\t\troots[i] = .5 * (a[i] + b[i]);\n\n            for(int j=0;j<halley_iterations;j++){\n\t\t\t\troots[i] = halley_iteration5(b0,b1,b2,b3,b4,roots[i]);\n            }\n\t\t\t\n\n            //compute squared distance to nearest point on curve\n\t\t\troots[i] = clamp(roots[i],0.,1.);\n\t\t\tvec2 to_curve = uv - parametric_cub_bezier(roots[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,dot(to_curve,to_curve));\n\t\t}\n\t}\n\n\treturn sqrt(d0);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\n#define setX(f) if (f>=0. && f<=1. && (pow(1.0 - f, 3.0) * a.x + 3.0 * pow(1.0 - f, 2.0) * f * b.x + 3.0 * (1.0 - f) * pow(f, 2.0) * c.x + pow(f, 3.0) * d.x)>X) odd=!odd;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord/iResolution.xy)-0.5;\n    vec3 col = vec3(0.0);\n    \n    //Array of Points\n    //Example: Only colored halve of the Shape.\n    //vec2 points[13] = vec2[13](vec2(-0.019059, -0.138985), vec2(-0.004383, -0.092896), vec2(0.130600, -0.025998), vec2(0.131997, 0.016893), vec2(0.150349, 0.083669), vec2(0.020245, 0.063541), vec2(-0.023880, 0.167949), vec2(-0.086191, 0.083313), vec2(-0.162270, 0.066590), vec2(-0.174937, 0.012071), vec2(-0.180603, -0.064884), vec2(-0.057583, -0.048424), vec2(-0.019059, -0.138985));\n\n    //Example: Only colores the outline.\n    vec2 points[13] = vec2[13](vec2(-0.128753, -0.095351), vec2(-0.085785, -0.073139), vec2(0.056966, -0.121282), vec2(0.088283, -0.091942), vec2(0.148477, -0.057700), vec2(0.042247, 0.020064), vec2(0.084873, 0.125093), vec2(-0.019033, 0.109308), vec2(-0.084654, 0.151278), vec2(-0.132162, 0.121684), vec2(-0.190585, 0.071275), vec2(-0.091957, -0.004073), vec2(-0.128753, -0.095351));\n\n    //Example: This is the expected result. If this would be the result in all direction I would be happy af;\n    //vec2 points[13] = vec2[13](vec2(-0.113397, -0.108439), vec2(-0.073697, -0.080808), vec2(0.074117, -0.109906), vec2(0.101336, -0.076730), vec2(0.156547, -0.034925), vec2(0.041075, 0.028309), vec2(0.069627, 0.138004), vec2(-0.031330, 0.108790), vec2(-0.101868, 0.141837), vec2(-0.145106, 0.106294), vec2(-0.196449, 0.048691), vec2(-0.088830, -0.013139), vec2(-0.113397, -0.108439));\n\n    //Example: Some weird Lines.\n    //vec2 points[13] = vec2[13](vec2(-0.116850, 0.136278), vec2(-0.100436, 0.090779), vec2(-0.166799, -0.044468), vec2(-0.141798, -0.079346), vec2(-0.115707, -0.143495), vec2(-0.024741, -0.048324), vec2(0.073825, -0.104294), vec2(0.071737, 0.000784), vec2(0.121914, 0.060365), vec2(0.098774, 0.111329), vec2(0.056422, 0.175832), vec2(-0.031155, 0.087883), vec2(-0.116850, 0.136278));\n\n    //Example: Also some weird Lines.\n    //vec2 points[13] = vec2[13](vec2(0.057764, -0.117235), vec2(0.047430, -0.069983), vec2(0.130879, 0.055445), vec2(0.110644, 0.093288), vec2(0.093149, 0.160294), vec2(-0.009461, 0.077810), vec2(-0.099878, 0.146167), vec2(-0.111523, 0.041716), vec2(-0.169048, -0.010806), vec2(-0.152758, -0.064355), vec2(-0.119188, -0.133834), vec2(-0.020880, -0.058068), vec2(0.057764, -0.117235));\n\n                      \n    float direc = 1e38;  \n    bool odd = false; //odd means it is inside;\n    float  root1, root2, root3, A,B,C,D, X,Y;\n    \t\n\tfor(int i = 0; i < (13-3); i += 3)\n\t{\n\t\tvec2 a = points[i]; // Begin of the Line\n\t\tvec2 b = points[i + 1]; // Controll Point 1.\n\t\tvec2 c =  points[i + 2]; // Controll Point 2.\n\t\tvec2 d =  points[i + 3]; // End of the Line. This Point is used again in the next Iteration.\n\t\t\n\t\tdirec = min(direc, cubic_bezier_dis(uv,a,b,c,d)); // Bezier cubic line.\n        \n        // Filling using the setX function. That is useing the Method of ray casting.\n        // https://en.wikipedia.org/wiki/Point_in_polygon\n        \n        X = uv.x;\n\t\tY = uv.y;\n    \n        A = d.y - 3.0 * c.y + 3.0 * b.y - a.y;\n        B = 3.0 * c.y - 6.0 * b.y + 3.0 * a.y;\n        C = 3.0 * b.y - 3.0 * a.y;\n        D = a.y - Y;\n    \n        float Q = (3. * A * C - B * B) / (9. * A * A);\n        float R = (9. * A * B * C - 27. * A * A * D - 2. * B * B * B) / (54. * A * A * A);\n        float discriminant = Q * Q * Q + R * R;\n    \n        if (discriminant > 0.) {\n          float sqrt_discriminant = sqrt(discriminant);\n          float S = cbrt(R + sqrt_discriminant);\n          float T = cbrt(R - sqrt_discriminant);\n\n          root1 = -B / (3. * A) + S + T;\n          root2 = -B / (3. * A) - (S + T) / 2.;\n          root3 = -B / (3. * A) - (S + T) / 2.;\n\n          setX(root1);\n          setX(root2);\n          setX(root3);\n        }\n    }\n    \n    float s = 1.0;\n    \n    if(odd) // if odd == inside.\n    {\n        s *= -1.0;\n    }\n    \n    float dist = s*sqrt(direc);\n    col = vec3(clamp(dist/0.069010416666666671, 0.0, 1.0));\n                      \n    // Coloring Corner and Control Points (Red = Corner, Green Control)\n    for(int i = 0; i < 13; i++)\n    {\n        if(distance(uv, points[i]) < 0.005)\n        {\n            if(mod(float(i), 3.) == 0.)\n            {\n                col = vec3(1.0, 0.0, 0.0);\n            }\n            else{\n                col = vec3(0.0, 1.0, 0.0);\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}