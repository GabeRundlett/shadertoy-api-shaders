{
    "Shader": {
        "info": {
            "date": "1704691456",
            "description": "SDF level of detail (quadtree-ish) tests. I'm sure this is doable in a loop, but breaking it out helped me figure out what to do. Not perfect, but good enough for now. The circle follows mouse position.",
            "flags": 0,
            "hasliked": 0,
            "id": "4f2GWK",
            "likes": 8,
            "name": "SDF LOD Grid",
            "published": 3,
            "tags": [
                "sdf",
                "lod",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "tristanantonsen",
            "viewed": 201
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592653592\n#define WHITE vec3(1.0)\n#define PINK vec3(254., 11.,128.) / 255.\n#define DARKBLUE vec3(22., 14., 215.) / 255.\n#define LIGHTBLUE vec3(0., 249., 251.) / 255.\n\n// SDF functions \nfloat Circle(vec2 p, vec2 c, float r) {\n    return length(p-c) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n\n// Main mapping function\nfloat map(vec2 p) {\n\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y / 2.0;\n\n    float d = Circle(p, m, 0.25);\n    //d = opSmoothUnion(d, Circle(p, vec2(-m.x, m.y), 0.25), 0.15);\n    d = opSmoothUnion(d, Circle(p, vec2(0.,-10), 9.65), 0.15);\n    \n    return d;\n    \n}\n\n// Shading the SDF\nvec4 fieldShading(float d, float inMin, float inMax, float contour) {\n\n    float f = 2.;\n    vec4 prettyColor = vec4(0.0);\n    \n    float fac = 0.5 * sin(f * d - 2.0 * iTime) + 0.5;\n    \n    vec3 outerField = mix(LIGHTBLUE, vec3(0.), smoothstep(0., inMax, d));\n    vec3 innerField = mix(DARKBLUE, PINK, smoothstep(0., abs(inMin), abs(d)));\n    \n    vec4 outerColor = vec4(outerField, 1.);\n    vec4 innerColor = vec4(innerField, 1.);\n\n    \n    vec4 fragColor = mix(innerColor, outerColor, smoothstep(-0.5, 0.5, d * 250.) );\n    \n    if (contour > 0.) {\n    \n        float c = 0.5 * sin(250. * contour * d - PI / 2.) + 0.5;\n    \n        fragColor = mix(vec4(1.0), fragColor, smoothstep(0., 0.2, 5. * c));\n    }\n    return fragColor;\n}\n\n// Grid functions\nvec4 drawGrid(vec2 p, vec4 col, float gridSize) {\n    float pixelSize = 1. / iResolution.x;\n    p += gridSize * 0.5;\n    float vl = mod(p.x, gridSize) / gridSize - 0.5;\n    float hl = mod(p.y, gridSize) / gridSize - 0.5;\n\n    float cx = sign(mod(p.x, gridSize) / gridSize - 0.5);\n    float cy = sign(mod(p.y, gridSize) / gridSize - 0.5);\n    \n\n    float lineWidth = pixelSize * 5. / gridSize;\n    \n    col.xyz = mix(vec3(1.), col.xyz, smoothstep(0.,lineWidth, abs(vl)));\n    col.xyz = mix(vec3(1.), col.xyz, smoothstep(0.,lineWidth, abs(hl)));\n    \n    return col;\n}\n\n// Rounding a number to an interval\nvec2 roundInterval(vec2 value, float interval) {\n\n    vec2 halfInterval = vec2(interval * 0.5);\n    \n    return halfInterval + (value - mod(value + halfInterval, interval));\n}\n\n// This works because it assumes the geometry is made of SDFs.\n// If it were discrete data only, for example, it would be more difficult to test wether\n// or not geometry is \"contained\" within each square\n// Here are some shaders that I referenced:\n// https://www.shadertoy.com/view/lljSDy\n// https://www.shadertoy.com/view/MlffW8\n// https://www.shadertoy.com/view/ddXBW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution .xy)/iResolution.y;\n    \n    float d = map(uv);\n\n    fragColor = fieldShading(d, -0.1, 0.75, 0.);\n    \n    // Level of detail (LOD) scales\n    float lod1 = 0.05;\n    \n    // animated visual\n    lod1 += 0.0375 * sin(0.5 * iTime);\n    \n    float lod2 = lod1 * 2.;\n    float lod3 = lod1 * 4.;\n    float lod4 = lod1 * 8.;\n    \n    // distances at different levels of detail\n    // Samples are in the center of each square\n    float d1 = map(roundInterval(uv-lod1*0.5, lod1) + lod1*0.5);\n    float d2 = map(roundInterval(uv-lod2*0.5, lod2) + lod2*0.5);\n    float d3 = map(roundInterval(uv-lod3*0.5, lod3) + lod3*0.5);\n    float d4 = map(roundInterval(uv-lod4*0.5, lod4) + lod4*0.5);\n    \n    // set to true for adaptive grid on boundary only\n    bool boundaryOnly = true;\n    \n    // filtering checks\n    float halfDiag = sqrt(2.)/2.;\n    float check2 = lod2 * halfDiag;\n    float check3 = lod3 * halfDiag;\n    float check4 = lod4 * halfDiag;\n\n    // Just helpers for visualization\n    float sign1 = sign(d1);\n    float sign2 = sign(d2);\n    float sign3 = sign(d3);\n    float sign4 = sign(d4);\n    if (boundaryOnly) { d1 = abs(d1), d2 = abs(d2), d3 = abs(d3), d4 = abs(d4);}\n    \n    \n    // At each level of detail (scale), if the value of the SDF\n    // at the pixel is less than half the diagonal of the square,\n    // we assume that the square does not need to be subdivided\n    // otherwise, use a smaller grid (subdivide)\n    \n\n    float field;\n    \n    if (d2 < check2) {\n        field = d1 * sign1;\n        fragColor = drawGrid(uv, fragColor, lod1);\n        \n    } else if (d3 < check3) {\n        field = d2 * sign1;\n        fragColor = drawGrid(uv, fragColor, lod2);\n                \n    } else if (d4 < check4) {\n        field = d3 * sign1;\n        fragColor = drawGrid(uv, fragColor, lod3);\n        \n    } else {\n        field = d4 * sign1;\n        fragColor = drawGrid(uv, fragColor, lod4);\n    };\n    \n    // half & half visualization\n    if (uv.x > 0.0) { fragColor = fieldShading(field, -0.1, 0.75, 0.); };\n        \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}