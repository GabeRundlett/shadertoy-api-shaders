{
    "Shader": {
        "info": {
            "date": "1621110874",
            "description": "Analytically detecting collisions between a simple ball trajectory between a line and a circle.\nBox collision detection is just a combination of lines I guess.",
            "flags": 0,
            "hasliked": 0,
            "id": "fsBXDc",
            "likes": 11,
            "name": "2D Ball Early Collision Detect",
            "published": 3,
            "tags": [
                "2d",
                "ball",
                "analytic",
                "collisiondetection",
                "early"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 232
        },
        "renderpass": [
            {
                "code": "// Utilities\n#define drawSDF(dist, col, opacity) color = mix(color, col, smoothstep(unit, 0.0, dist) * opacity)\n\n// Closest points\nvec2 closestInfLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    vec2 local = ba * dot(pa, ba) / dot(ba, ba);\n    return a + local + normalize(pa - local) * t;\n}\n\nvec2 closestSegment(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    vec2 local = ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return a + local + normalize(pa - local) * t;\n}\n\nvec2 closestCircle(in vec2 p, in vec2 o, in float r) {\n    return o + normalize(p - o) * r;\n}\n\n// SDFs\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba)) - t;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdCircle(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\n// Normals\nvec2 norInfLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return normalize(pa - ba * dot(pa, ba) / dot(ba, ba)) - t;\n}\n\nvec2 norSegment(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return normalize(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nvec2 norCircle(in vec2 p, in vec2 o, in float r) {\n    return normalize(p - o);\n}\n\n// Trajectory of a ball at constant velocity with constant downward gravitational force\n// In such a simple case, all that is needed is to integrate the force over time and\n// distort the starting (linear) trajectory by it\nvec2 posTrajectory(in vec2 p0, in vec2 v0, in float t, in float g) {\n    vec2 lin = p0 + v0 * t;\n    return vec2(lin.x, lin.y - 0.5 * g * t * t);\n}\n\n// Ball velocity (derivative of position)\nvec2 velTrajectory(in vec2 p0, in vec2 v0, in float t, in float g) {\n    return vec2(v0.x, v0.y - g * t);\n}\n\n// 2D collision between simple ball trajectory and a circle\n// Requires solving a quartic\nfloat circleCollision(in vec2 p0, in vec2 v0, in float br, in vec2 co, in float cr, in float g) {\n    p0 -= co; cr += br;\n    float qa = 0.25 * g * g;\n    float qb = -g * v0.y;\n    float qc = dot(v0, v0) - g * p0.y;\n    float qd = 2.0 * dot(p0, v0);\n    float qe = dot(p0, p0) - cr * cr;\n    qb /= qa; qc /= qa; qd /= qa; qe /= qa;\n\n    float bb = qb * qb;\n    float p = qc - 0.375 * bb;\n    float q = qd - 0.5 * qb * qc + 0.125 * bb * qb;\n    float r = qe - 0.25 * qb * qd + 0.0625 * bb * qc - 0.01171875 * bb * bb;\n\n    // Cubic solving\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    if (lambda < 0.0) return -1.0;\n    float sqrtLambda = sqrt(lambda);\n    float pLambda = 2.0 * (p + lambda), qLambda = 2.0 * q / sqrtLambda;\n\n    // Smallest positive root (found experimentally)\n    float bar = lambda - pLambda + qLambda;\n    if (bar > 0.0) return -(sqrtLambda + sign(qe) * sqrt(bar)) * 0.5 - 0.25 * qb;\n\n    float foo = lambda - pLambda - qLambda;\n    if (foo > 0.0) return +(sqrtLambda - sign(qe) * sqrt(foo)) * 0.5 - 0.25 * qb;\n\n    return -1.0;\n}\n\n// 2D collision between simple ball trajectory and an infinite line\n// Requires solving a quadratic\nfloat infLineCollision(in vec2 p0, in vec2 v0, in float r, in vec2 a, in vec2 b, in float t, in float g) {\n    vec2 pa = p0 - a, ba = b - a, offset = normalize(pa - ba * dot(pa, ba) / dot(ba, ba)) * (t + r);\n    float slope = ba.y / ba.x;\n    a += offset, b += offset;\n    float qa = 0.5 * g, qb = slope * v0.x - v0.y, qc = slope * (p0.x - a.x) - p0.y + a.y;\n    float h = qb * qb - 4.0 * qa * qc;\n    if (h < 0.0) return -1.0;\n    return -0.5 * (sign(qc) * sqrt(h) + qb) / qa;\n}\n\n// 2D collision between simple ball trajectory and a line segment\n// (combination of infinite line and circular caps)\nfloat segmentCollision(in vec2 p0, in vec2 v0, in float r, in vec2 a, in vec2 b, in float t, in float g) {\n    float tColl = infLineCollision(p0, v0, r, a, b, t, g); // Time of collision\n    if (sdSegment(posTrajectory(p0, v0, tColl, g), a, b, t) > r + 0.001) { // Need a small error margin\n        float tCollCap1 = circleCollision(p0, v0, r, b, t, g);\n        if (tCollCap1 > 0.0) tColl = tCollCap1;\n        float tCollCap2 = circleCollision(p0, v0, r, a, t, g);\n        if (tCollCap2 > 0.0 && (tCollCap1 < 0.0 ? true : tCollCap2 < tCollCap1)) tColl = tCollCap2;\n        if (tCollCap1 < 0.0 && tCollCap2 < 0.0) tColl = -1.0;\n    }\n\n    return tColl;\n}\n\n// Distance to simple ball trajectory (for rendering purposes)\nfloat sdTrajectory(in vec2 p, in vec2 p0, in vec2 v0, in float tEnd, in bool term, in float g) {\n    vec2 q = p0 - p;\n    float t3 = 0.5 * g * g;\n    float t2 = -1.5 * g * v0.y;\n    float t1 = dot(v0, v0) - q.y * g;\n    float t0 = dot(q, v0);\n\n    t2 /= t3, t1 /= t3, t0 /= t3;\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = -2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0;\n        return length(p - posTrajectory(p0, v0, term ? clamp(root, 0.0, tEnd) : max(0.0, root), g));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = 2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0;\n        roots = term ? clamp(roots, 0.0, tEnd) : max(roots, 0.0);\n        vec2 p1 = p - posTrajectory(p0, v0, roots.x, g);\n        vec2 p2 = p - posTrajectory(p0, v0, roots.y, g);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before mouse interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        float time = 0.5 * iTime;\n        mouse = vec4(1.5 * cos(time), 1.5 * sin(time), 0.0, 0.0);\n    }\n\n    // Gravity, ball start, ball velocity, ball radius\n    float g = 1.0;\n    vec2 p0 = mouse.zw;\n    vec2 v0 = mouse.xy - mouse.zw;\n    float r = 0.15;\n\n    // Line vertices and thickness\n    vec2 a1 = vec2(-2.5, 0.0);\n    vec2 b1 = vec2(-1.0, -1.0);\n    float t1 = 0.1;\n\n    // Infinite line vertices and thickness\n    vec2 a2 = vec2(1.0, -1.0);\n    vec2 b2 = vec2(0.0, -1.25);\n    float t2 = 0.01;\n\n    // Circle position and radius\n    vec2 co = vec2(1.0, 0.5);\n    float cr = 0.25;\n\n    // Draw objects\n    drawSDF(sdInfLine(uv, a2, b2, t2), vec3(0.0), 1.0);\n    drawSDF(sdSegment(uv, a1, b1, t1), vec3(0.0), 1.0);\n    drawSDF(sdCircle(uv, co, cr), vec3(0.0), 1.0);\n\n    // Draw trajectory\n    drawSDF(sdTrajectory(uv, p0, v0, 1000.0, false, g) - 0.01, vec3(0.0, 0.0, 1.0), 1.0);\n\n    // Combine collisions\n    float tColl = infLineCollision(p0, v0, r, a2, b2, t2, g); // Time of collision\n    float tColl2 = segmentCollision(p0, v0, r, a1, b1, t1, g);\n    if (tColl2 > 0.0 ? (tColl > 0.0 ? tColl2 < tColl : true) : false) tColl = tColl2;\n    tColl2 = circleCollision(p0, v0, r, co, cr, g);\n    if (tColl2 > 0.0 ? (tColl > 0.0 ? tColl2 < tColl : true) : false) tColl = tColl2;\n\n    vec2 pColl = posTrajectory(p0, v0, tColl, g); // Collision point\n    drawSDF(sdTrajectory(uv, p0, v0, tColl, tColl > 0.0, g) - 0.01, vec3(1.0, 0.0, 0.0), 1.0);\n\n    // Get normal of closest object to hit\n    float dInfLine = sdInfLine(pColl, a2, b2, t2);\n    float dSegment = sdSegment(pColl, a1, b1, t1);\n    float dCircle = sdCircle(pColl, co, cr);\n\n    float closest = min(dInfLine, min(dSegment, dCircle)); vec2 hit, nor;\n    if (dInfLine == closest) hit = closestInfLine(pColl, a2, b2, t2), nor = norInfLine(pColl, a2, b2, t2);\n    if (dSegment == closest) hit = closestSegment(pColl, a1, b1, t1), nor = norSegment(pColl, a1, b1, t1);\n    if (dCircle == closest) hit = closestCircle(pColl, co, cr), nor = norCircle(pColl, co, cr);\n\n    // Show collision and next bounce\n    if (tColl > 0.0) drawSDF(sdCircle(uv, pColl, r), vec3(1.0, 0.9, 0.0), 1.0);\n    drawSDF(sdTrajectory(uv, pColl, reflect(velTrajectory(p0, v0, tColl, g), nor), 1000.0, false, g) - 0.01, vec3(0.0, 0.0, 1.0), 0.25);\n    drawSDF(sdSegment(uv, hit, hit + 0.5 * nor, 0.001), vec3(1.0, 0.0, 1.0), 1.0);\n    drawSDF(sdCircle(uv, hit, 0.05), vec3(0.0, 1.0, 0.0), 1.0);\n\n    // Vignette\n    uv *= 0.25;\n    float dd = dot(uv, uv);\n    color -= 0.5 * dd * dd;\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}