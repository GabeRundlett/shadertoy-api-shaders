{
    "Shader": {
        "info": {
            "date": "1609236162",
            "description": "This is a modification and explanation of Cyclic Noise, which is created by nimitz.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tcyD7",
            "likes": 43,
            "name": "Cyclic Noise Explanation",
            "published": 3,
            "tags": [
                "noise",
                "warp",
                "cyclic",
                "cyclicnoise"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 1352
        },
        "renderpass": [
            {
                "code": "// Cyclic noise is created by nimitz.\n// He uses it a lot, like in here: https://www.shadertoy.com/view/wl3czN\n// I just rewrote his code, renamed some variables and tried to explain it a bit.\n\n// Left is vanilla \n// Right is the derivative, fed into a pallete\n\n// The basic structure of the loop is like an fbm.\n// You are stacking octaves of noise.\n// But the noise itself is generated in an interesting way:\n// You do something like a 1-tap dot prodcut (Perlin,Simplex) noise inside of a sinewave lattice.\n// Then you apply some rotation and scale, and repeat. \n\n\n// Turbulent noise is \n// 1.-abs(noise)\n//#define TURBULENT\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.5;\n    const int octaves = 8;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    #ifdef TURBULENT\n    return 1. - abs(noise)*0.5;\n    #else\n    return (noise*0.25 + 0.5);\n    #endif\n}\n\n\nfloat get(vec2 uv){\n    float noise = cyclicNoise(vec3(uv*10.,iTime));\n    float noiseb = cyclicNoise(vec3(uv*10. - 3.,iTime) - noise*1.);\n\n    return noiseb*pow(max(noise,0.),1.) - (1.-  noise)* (abs(noise)*.4 );\n}\n\n// Bruteforce derivative. \n// You could calculate this analyticall inside of cyclicNoise() \n// if you wished to do so, and it would be much cheaper \nvec2 derivative(vec2 uv, float eps){\n    vec2 t = vec2(eps,0);\n    return vec2(\n        get(uv + t.xy) - get(uv - t.xy),\n        get(uv + t.yx) - get(uv - t.yx)\n        );\n}\n\n// iq pallete: https://iquilezles.org/articles/palettes\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0);\n    \n    if(fragCoord.x > iResolution.x/2.){\n        float noise = get(uv);\n        vec2 dxdy = derivative(uv,0.003).xy;\n        col += pal(0.5,0.5,vec3(1,2,4),1.,dxdy.x*19. + iTime )*pow(max(noise,0.),0.9);\n    \n    } else {\n        float noise = cyclicNoise(vec3(uv*10.,iTime));\n        col += pal(0.5,0.5,vec3(1,2,4),1.,noise + iTime )*pow(max(noise,0.),0.9);\n    \n    }\n    \n    // gamma correction\n    col = pow(max(col,0.),vec3(0.4545));\n    //col = pow(abs(col),vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}