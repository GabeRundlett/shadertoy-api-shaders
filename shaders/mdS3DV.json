{
    "Shader": {
        "info": {
            "date": "1668295313",
            "description": "An expanding star cluster in the 4-D spacetime described by Greg Egan in his Orthogonal series. Different wavelengths have a different angle relative to the observer's time, leading to the spectral star trails.",
            "flags": 32,
            "hasliked": 0,
            "id": "mdS3DV",
            "likes": 10,
            "name": "4D Riemmanian star cluster",
            "published": 3,
            "tags": [
                "raymarching",
                "4d",
                "orthogonal"
            ],
            "usePreview": 0,
            "username": "A_Toaster",
            "viewed": 357
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture( iChannel0, uv ).xyz * 2.5;\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Uncomment the line below for a camera accelerating constantly, which makes a traces a circular arc through spacetime\n// #define ZOOM_CAM\n\n// Uncomment the line below to enable camera orbiting\n#define ORBIT_CAM\n\n// Uncomment for a cluster of stars orthogonal to the camera's time dimension\n// #define ORTHOGONAL_STAR_DIR\n// Uncomment for a cluster of stars with random 4D directions\n// #define RANDOM_STAR_DIR\n// (By default, star directions are all near (0, 0, 0, 1) )\n\n\n// For a more complete explaination of the physics/geometry of Riemmanian spacetime,\n// see http://gregegan.net/ORTHOGONAL/ORTHOGONAL.html\n//\n// The universe rendered here is mostly accurate to the one described by Greg Egan, with one exception:\n// Every star in this scene emits light in every direction, including the direction\n// opposite its own arrow of time.\n//\n// This scene shows a universe with 4 dimensions, much like our own, except that there is no special\n// \"time\" dimension. Objects are free to move in any direction (Always with a velocity of 1).\n// For any given observer, their direction of motion dictates their own arrow of time.\n//\n// Stars are modelled as infinitely long spherical prisms. Because these prisms aren't parallel,\n// I couldn't use the standard tricks like domain repetition to speed up rendering.\n// \n// One consequence of this universe is that the speed of light depends on its wavelength (which\n// depends on its orientation relative to you). This creates the streaks seen behind the stars.\n// For the sake of accuracy, rendering is done by sampling light is sampled at a few different \n// wavelength ranges. This also contributes to slow rendering.\n//\n// Another consequence is that a constantly accelerating object will eventually have a direction\n// orthogonal to its original direction, which would appear to a stationary observer like moving at an\n// infinite velocity. To see what a field of infinite-velocity (orthogonal) stars would look like,\n// uncomment the line \"#define ORTHOGONAL_STAR_DIR\".\n//\n// An object that keeps accelerating beyond this point will eventually loop around to the same 4D\n// coordinates that it started at. Uncomment \"#define ZOOM_CAM\" to see the perspective of such an object.\n//\n// One aspect which is not modelled is that this universe must be a finite, compact manifold thanks to\n// the properties of light waves. This could likely be modelled by domain repitition, but care would\n// have to be taken to ensure that every star loops back to its original position after exactly one lap.\n//\n// I will likely revisit this rendering scheme with different 4D geometry in the future.\n\n// Turn up if your system can handle it\n#define N_STARS 16\n\nconst float FIELD_OF_VIEW = 1.2;\n\n// camera directions\nconst vec4 FWD_4 = vec4(1., 0., 0., 0.);\nconst vec4 UP_4 = vec4(0., 0., 1., 0.);\n\n// raymarching questions\nconst float MAX_DIST = 200.;\nconst float EPS = 0.01;\nconst float GLOW_DIST = 1.;\n#define MAX_ITERATIONS 20\n\n// cluster settings\nconst float CLUSTER_SIZE = 20.;\nconst float CLUSTER_RAND_VEL = 0.4;\n#ifdef ORTHOGONAL_STAR_DIR\nconst vec4 CLUSTER_FUTURE = vec4(1., 0., 0., 0.);\n#else\nconst vec4 CLUSTER_FUTURE = vec4(0., 0., 0., 1.);\n#endif\nconst float STAR_SIZE = 0.01;\n\n\n// projection operator\nvec4 proj(vec4 u, vec4 v) {\n    return (u * dot(u,v)) / dot(u, u);\n}\n\n// Calculate a vector orthogonal (but not orthonormal) to three other 4-vectors\nvec4 cross4(vec4 u, vec4 v, vec4 t){\n    return vec4(\n        ( u.w * v.z - u.z * v.w) * t.y + (-u.w * v.y + u.y * v.w) * t.z + (-u.y * v.z + u.z * v.y) * t.w,\n        (-u.w * v.z + u.z * v.w) * t.x + ( u.w * v.x - u.x * v.w) * t.z + ( u.x * v.z - u.z * v.x) * t.w,\n        ( u.w * v.y - u.y * v.w) * t.x + (-u.w * v.x + u.x * v.w) * t.y + (-u.x * v.y + u.y * v.x) * t.w,\n        ( u.y * v.z - u.z * v.y) * t.x + (-u.x * v.z + u.z * v.x) * t.y + ( u.x * v.y - u.y * v.x) * t.z\n    \n    );\n}\n\n// Returns a 4-d ray direction orthogonal to the time vector given a set of camera parameters.\nvec4 camera_spacelike_dir(vec2 uv, vec4 cameraDirection, vec4 cameraUp, vec4 cameraFuture) {\n    \n\tuv = uv * FIELD_OF_VIEW;\n    \n    // Up/fwd vec orthogonal to future\n    vec4 fut = cameraFuture;\n    vec4 up_vec = normalize(cameraUp - proj(fut, cameraUp));\n    vec4 fwd_vec = normalize(cameraDirection - proj(fut, cameraDirection));\n    // Right vec orthogonal to all other directions\n    vec4 right_vec = normalize(cross4(up_vec, fwd_vec, fut));\n    \n    vec4 spacelike_dir = normalize(fwd_vec + uv.y * up_vec + uv.x * right_vec);\n    \n    return spacelike_dir;\n}\n\n// Returns 4-d ray direction given a spacelike direction and a velocity in the timelike direction.\nvec4 camera(vec4 spacelike_dir, vec4 cameraFuture, float futureVel) {\n    vec4 timelike_dir = cameraFuture * futureVel;\n    \n    return normalize(spacelike_dir + timelike_dir);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 rand(int i) {\n    return vec4(\n        rand(vec2(float(i), 2.)),\n        rand(vec2(float(i), 12.)),\n        rand(vec2(float(i), 112.)),\n        rand(vec2(float(i), 1112.))\n    );\n}\n\n// 4D star cluster SDF\n// SDF between a cluster and a dispersing line of light of different wavelengths.\n// 'elongation' is a vector from the point at one end of the spectrum to the other.\nfloat sdCluster (vec4 p, vec4 elongation) {\n    float dist = MAX_DIST;\n    for(int i=0; i < N_STARS; i++) {\n        #ifdef RANDOM_STAR_DIR\n        vec4 star_future = normalize(rand(i + 9874) - vec4(0.5));\n        #else\n        vec4 star_future = normalize(CLUSTER_FUTURE + (rand(i + 9874) - vec4(0.5)) * CLUSTER_RAND_VEL);\n        #endif\n\n        vec4 star_pos = (rand(i) - vec4(0.5)) * CLUSTER_SIZE;\n        \n        vec4 pa = p - star_pos;\n        \n        // Elongate along elongation vector\n        vec4 orth_elongation = elongation - proj(star_future, elongation);\n        float t2 = dot(pa, orth_elongation)/dot(orth_elongation, orth_elongation);\n        pa = pa - clamp(t2, -1., 0.) * orth_elongation;\n        \n        // Elongate (infinitely) along star future\n        float t1 = dot(pa, star_future)/dot(star_future, star_future);\n        pa = pa - t1 * star_future;\n        \n        \n        \n        \n        // Calculate distance to star\n        dist = min(dist, length(pa) - STAR_SIZE);\n        \n    }\n    return dist;\n}\n\nfloat raymarch4d(vec4 spacelike_rd, vec4 ro, vec4 future_vec, float lower_vel, float upper_vel) {\n\n    vec4 lower_ray_dir = camera(spacelike_rd, future_vec, lower_vel);\n    vec4 upper_ray_dir = camera(spacelike_rd, future_vec, upper_vel);\n    vec4 elongation_vec = upper_ray_dir - lower_ray_dir;\n    \n    vec4 ray_pos = ro;\n    float l = 0.;\n    float d = 0.;\n    float min_dist = MAX_DIST;\n    // Raymarching loop\n    for(int i = 0; i < MAX_ITERATIONS; i++){\n        d = sdCluster(ray_pos + l * lower_ray_dir, l * elongation_vec);\n        min_dist = min(min_dist, d);\n        if (d < EPS) {\n            // Hit star\n            min_dist = 0.;\n            break;\n        }\n        l += d;\n        if (l > MAX_DIST) {\n            break;\n        }\n    }\n    \n    // 1.0 for direct hit, 0.0 for complete miss\n    float a = clamp((GLOW_DIST - min_dist) / GLOW_DIST, 0., 1.);\n    // (poor) simulation of exponential decay\n    return pow(a, 10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cam_uv = ((fragCoord/iResolution.xy) - vec2(0.5)) * vec2(iResolution.x / iResolution.y, 1.);\n    \n    // Calculate camera position & direction. The requires 3 orthogonal vectors to define in 4d.\n    \n    \n    #ifdef ZOOM_CAM\n    \n    float radius = 4.;\n    float center = 0.;\n    \n    vec4 future = vec4(0., -sin(iTime/radius), 0., cos(iTime/radius));\n    vec4 ray_pos = vec4(0., center + radius * cos(iTime/radius), 0., radius * sin(iTime/radius));\n    \n    vec4 fwd = vec4(0., -cos(iTime/radius), 0., -sin(iTime/radius));\n    vec4 camera_d = camera_spacelike_dir(cam_uv, fwd, UP_4, future);\n    #else\n    #ifdef ORBIT_CAM\n    float orbit_rate = 0.05; // radians/sec\n    #else\n    float orbit_rate = 0.; // radians/sec\n    #endif\n    \n    float orbit_radius = CLUSTER_SIZE * 1.5;\n    \n    vec4 fwd = vec4(sin(iTime * orbit_rate), cos(iTime * orbit_rate), 0., 0.);\n    vec4 future = normalize(vec4(0., 0.0, 0., 1.));\n    vec4 camera_d = camera_spacelike_dir(cam_uv, fwd, UP_4, future);\n    vec4 ray_pos = fwd * orbit_radius * -1. - future * iTime;\n    #endif\n    \n    \n    // Raymarch 4 different wavelength/velocity ranges\n    float r = raymarch4d(camera_d, ray_pos, future, 0.58, 0.65); // Red light is slowest (Pointed most towards the camera's future)\n    float g = raymarch4d(camera_d, ray_pos, future, 0.51, 0.59);\n    float b = raymarch4d(camera_d, ray_pos, future, 0.46, 0.54);\n    float v = raymarch4d(camera_d, ray_pos, future, 0.44, 0.48); // Violet light is fastest\n    \n    // Wavelength range colors\n    vec3 r_col = vec3(0.8, 0., 0.);\n    vec3 g_col = vec3(0., 0.5, 0.);\n    vec3 b_col = vec3(0., 0., 0.6);\n    vec3 v_col = vec3(0.25, 0., 0.7);\n    // Additively mix final color\n    vec3 col = r * r_col + g * g_col + b * b_col + v * v_col;\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}