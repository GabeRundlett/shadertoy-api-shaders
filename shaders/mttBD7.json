{
    "Shader": {
        "info": {
            "date": "1701327200",
            "description": "A live demonstration of the usefulness of exponential mapping for mixing rotations.\nA full explanation is given here: https://thenumb.at/Exponential-Rotations/",
            "flags": 0,
            "hasliked": 0,
            "id": "mttBD7",
            "likes": 2,
            "name": "Exponential Mapping for Rotation",
            "published": 3,
            "tags": [
                "mapping",
                "rotation",
                "exponential",
                "matrices",
                "quaternions"
            ],
            "usePreview": 0,
            "username": "toomuchvoltage",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   A re-work of https://www.shadertoy.com/view/dlBGRc to demonstrate the usefulness\n   of exponential mapping for interpolating rotations.\n   Full explanation found here: https://thenumb.at/Exponential-Rotations/\n\n   Covered under the MIT license:\n\n   Copyright (c) 2023 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n//#define HIRES\n\nbool rayBoxIntersectTime (vec3 l1,vec3 invm,vec3 bmin,vec3 bmax, out float tMin, out float tMax)\n{\n\tvec3 bmin_l1 = (bmin - l1)*invm;\n\tvec3 bmax_l1 = (bmax - l1)*invm;\n\tvec3 minVec = min (bmin_l1, bmax_l1);\n\tvec3 maxVec = max (bmin_l1, bmax_l1);\n\n\tfloat tmin = max(max(minVec.x, minVec.y), minVec.z);\n\tfloat tmax = min(min(maxVec.x, maxVec.y), maxVec.z);\n\n\tbool retVal = ((tmax >= tmin) && (tmin < 1.0) && (tmax > 0.0));\n\ttMin = tmin;\n\ttMax = tmax;\n\treturn retVal;\n}\n\nuint countSetBits(uint n)\n{\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\nuint countSetBitsBefore(uint n, uint comp)\n{\n    uint beforeMask = comp ^ (comp - 1u); // See: https://realtimecollisiondetection.net/blog/?p=78\n    n &= (~beforeMask);\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\n#ifdef HIRES\nconst vec3 grid0Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid0Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\nuint svoObject0[480] = uint[](128u,2210513095u,3479298144u,1206382640u,2955944416u,2948644703u,3759157328u,4287565583u,3759675512u,2139587772u,802340674u,3188982804u,141045714u,2138838076u,868254667u,3286638110u,504914401u,2400088239u,4111435140u,25231882u,717225475u,1058011896u,3229678206u,2130212960u,2131742716u,1009857343u,2275802654u,3097205408u,547535824u,2192417534u,3288236371u,3896412222u,505289727u,4279177016u,4043288476u,2021159043u,2386045908u,708321408u,3052425285u,4261731647u,2600436334u,1905893279u,4231802947u,3476757529u,3877378112u,1105215936u,34434u,4289098691u,3288284978u,4058111969u,1368453360u,4030781552u,2018533408u,540094515u,863606808u,301587464u,2349928471u,3958414079u,1086318151u,2701128451u,61471098u,2156002367u,62979548u,3180696977u,2123695444u,358083563u,1106362448u,272611232u,1587628053u,2095138053u,3746421117u,802705685u,17108991u,944109840u,2236852288u,1090600768u,3208819995u,1789041304u,2577271807u,4244787370u,4078985120u,265989392u,626174633u,277056386u,2952430954u,532654112u,573780048u,4286382072u,404256888u,2308730983u,4027342703u,3436158974u,2146558435u,2551187007u,867382067u,865704345u,2576993484u,3704409341u,3258775938u,3176781832u,2297956543u,3808397308u,71073779u,4062383231u,4001299939u,3858923261u,4294504910u,2281914348u,3370546118u,1063543298u,537132546u,4261943487u,4271477196u,4224646856u,3292938240u,272650234u,4016187103u,4133678343u,4080218316u,3476239359u,3120287513u,2441110503u,4294757583u,4090285104u,553641598u,4193511022u,2294243840u,2818752010u,1848374463u,3254062863u,2127319104u,2682678906u,2545967183u,3435708155u,4231000385u,432095607u,285339157u,284091511u,1148523596u,1145953754u,626850341u,3632174440u,359142741u,1118551722u,2863275440u,1521198420u,1252047863u,717509418u,3288667447u,1947428677u,3120952896u,1094996991u,1600391359u,1428034056u,16427093u,542637738u,1119939523u,3764511729u,4050662903u,4002366143u,130351256u,410541068u,1010581182u,515774602u,737923627u,3004883152u,1509530008u,2144597893u,4231843327u,3263414787u,1106579704u,410548344u,2084322364u,809377310u,403708943u,235416312u,1731735602u,3482858001u,3677724u,166411u,4256956382u,4232957900u,3451073271u,1986419065u,4052775731u,858829601u,2441190596u,1288490207u,4268161167u,1449650319u,1009265720u,1162105604u,4116665695u,4114841579u,3926179344u,2856591392u,4126637728u,938539692u,67170282u,357892821u,39127072u,1874417153u,2105410472u,717184855u,1470217045u,1428347733u,571195218u,3158670264u,1079326545u,1072002912u,1604612128u,680036493u,3712343713u,1440621329u,286263846u,1713861618u,4144182067u,4169136513u,2174327168u,4026721826u,601629663u,4084412932u,4208664577u,85018111u,2945462233u,4110471175u,4286675613u,3793592382u,2151743801u,2155977084u,4169173120u,717083454u,3154037963u,3003960254u,1637456281u,2670775436u,3436157319u,3060164556u,4088607539u,3996247560u,434274295u,717079091u,1787128459u,4164421880u,257162247u,3278619619u,3275833600u,1052572127u,3781082648u,2693315316u,341137392u,804388289u,3519082624u,262318170u,99517628u,787753794u,2906981461u,83750360u,653103197u,2554865794u,2750130721u,3876522510u,4117868073u,2155911579u,2880295434u,2916137919u,2831494024u,3577881349u,871633902u,1738041274u,1731343139u,848857241u,2564676733u,3808693497u,2974916321u,7540787u,858995097u,2417596816u,2155881986u,645005824u,359751649u,823902198u,1639497159u,4292310531u,2818932589u,830078335u,4294246389u,2635153856u,44739310u,552586956u,3186548104u,3860437401u,2582842572u,3436181894u,1718085244u,3274912563u,1047109219u,3059754667u,2113579688u,4146775159u,684012417u,3185398955u,1420475220u,1414874165u,1363219957u,1079339767u,2102744389u,1413815632u,366826968u,357914485u,1467193481u,2592717738u,2732401341u,179015024u,2411672478u,568205431u,1362022673u,785458779u,1717003460u,1103939548u,3809811491u,1440483938u,1646683955u,926936271u,2579996262u,1741474824u,4002152450u,570564978u,863502128u,3493413888u,2855251616u,2050484286u,536879654u,1648291565u,3366878410u,2925648319u,3882300403u,858915737u,2583200137u,3426431964u,4243502958u,2724621994u,3903335624u,2343400104u,1463636000u,2157835338u,2847797764u,1512267499u,1587762346u,335902077u,1410509800u,3755666049u,706029661u,2170508670u,33166762u,948444056u,2595470683u,3041042603u,2297890824u,4151451042u,998733074u,3977315069u,306673526u,1145324621u,4248974685u,3405070562u,40265331u,785182542u,4186334822u,1727842172u,3471343616u,499u,1357113102u,284424167u,3884189752u,4056380211u,590590777u,2156501401u,2631716047u,993058526u,2107101574u,3707808442u,4203227235u,3812451259u,3256942850u,2677709668u,163029666u,4196412085u,4155116048u,2868572290u,2947481239u,3356977160u,747284398u,2726734856u,2864641032u,547417086u,2776108975u,2852240829u,1153389611u,3716223248u,270268584u,2943355891u,4228260522u,5584208u,272098427u,2272765032u,462565435u,3287848969u,4194171908u,1308099677u,4087566845u,290458114u,118698865u,59898265u,2172700672u,11u,2290648947u,3208630076u,3234740275u,2678056550u,1712855483u,860142112u,3450012993u,1138225127u,337383764u,3791279575u,3244245119u,3059112932u,67235856u,2941298647u,2231728215u,4161258114u,3286278176u,2431680288u,4289712893u,41780485u,8213547u,3492795408u,635461281u,4272287920u,2968533048u,947420220u,1072201707u,4095726655u,1363230741u,218369513u,2112387719u,2919545868u,3158299634u,1040326207u,4192304903u,125730528u,4034981951u,1078985600u,2180641853u,1069596736u,4229930976u,1616934975u,941621248u,0u,2282245244u,4039911032u,2036729363u,187826218u,3170083338u,418434846u,1045493886u,2123921535u,3912681479u,2865489930u,36173420u,2302931796u,3205692963u,4193787455u,2575403127u,4160876624u,4030787824u,2021154816u,0u,0u);\n#else\nconst vec3 grid0Min = vec3 (-4.00, -4.00, -4.00);\nconst vec3 grid0Max = vec3 (4.00, 4.00, 4.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\nuint svoObject0[304] = uint[](1052696u,404241420u,202117616u,270000383u,2414872600u,2021648262u,116657212u,1070856002u,509478378u,336916560u,4280307135u,2423814248u,2106053692u,1010579521u,3256871445u,4269151568u,274069423u,3237995263u,2265437170u,4089692931u,4194171361u,3783360943u,732929282u,1420431477u,4030070746u,2140676349u,126945219u,3285173239u,3888111390u,471918478u,242322062u,1086341601u,3768705505u,4042322160u,3230294630u,2141139762u,818925336u,295506050u,2206614275u,3282108800u,366276676u,1609359359u,4286079078u,1726373503u,1009259519u,4196479902u,504756729u,2677869226u,135491603u,4048780943u,4027064294u,1643764743u,4094430195u,4107046674u,1719010746u,1143644200u,2867592847u,3892979843u,2880002027u,3129551370u,44705952u,2884287275u,2914126370u,2884336802u,4010322464u,2157966426u,538619314u,4891290u,2550920895u,4207911431u,2863722564u,73819750u,1644566394u,2951383799u,265818130u,3188338223u,4037010920u,2139155072u,4286622599u,2944931960u,2021654463u,1010326588u,1010581502u,504391422u,505290271u,3893575404u,3473886222u,1905892825u,2556899532u,3435978648u,4019256576u,4279238054u,1719171168u,2066742048u,808466457u,2415929824u,3154083993u,3220044996u,1538252029u,3202770531u,2254727123u,51634113u,872126872u,1659738554u,4020808328u,2854232639u,2707392488u,89844230u,117666755u,3947500937u,1467984426u,2935312125u,1476952746u,2852825771u,2720180906u,716528565u,1474472490u,4004183432u,2852661384u,2291907492u,3409624131u,3105362329u,2622233807u,3153899344u,3208703760u,269819205u,286259576u,2105080326u,26281968u,1023407043u,33800689u,20977141u,4126220005u,4195350787u,4290527981u,318506755u,3280142592u,348144860u,4232070768u,1071504313u,3061709759u,3737858867u,590560867u,507091359u,859783118u,3485177740u,3865494625u,4294773487u,147630711u,2286239813u,4290724067u,3825179920u,437234178u,2876635105u,2702159618u,4245312835u,3286937278u,522066804u,44612266u,2175732527u,4039069943u,1091779497u,3042409316u,1466081826u,4008414890u,3884746792u,2290654139u,3025128244u,1306106329u,2644090060u,3752972223u,3706654992u,3810334720u,572531263u,4045291239u,1896038398u,3981809473u,67120096u,2692759520u,3154115583u,4106801122u,262671365u,4457597u,3401293258u,3114130627u,3007034174u,1637456379u,3878735054u,4109342822u,3429292539u,3718282626u,4208796245u,1575720317u,1628504533u,1353428923u,1432185488u,715910081u,1440044373u,1431385973u,1067869248u,2538038357u,1646438955u,3996380810u,871279144u,2308684723u,617329196u,3275329945u,2165621956u,3435654689u,3486257390u,4010806880u,644245095u,842015539u,807536243u,254279742u,251649983u,403177532u,3927826174u,3929398511u,3486317792u,2389075462u,1615278867u,4046664602u,2140772798u,2881137375u,581089876u,68515157u,1365112289u,3741629023u,3751829410u,1410684277u,1094800887u,2707382111u,95049128u,1343241143u,2757229205u,1538269218u,581857262u,937986175u,2156406922u,2820403756u,3283857452u,1339627793u,3650899020u,3439320067u,4243467093u,3624822374u,1644562227u,857932288u,8718u,1062274844u,2028019454u,1719034782u,2134324087u,1858868213u,3831503860u,1098268330u,350885346u,169406671u,448688354u,3200134079u,1075836320u,2695904938u,99227114u,168885872u,2733671102u,168435700u,536191226u,4197095352u,2283466923u,3218128203u,3625547900u,471612670u,4264431580u,3218206977u,2699591709u,1296301069u,266344478u,3890718695u,4027342835u,3019105232u,4244701440u,17u,391188377u,2174644323u,2409614536u,2167619532u,3393283093u,1542931716u,159243640u,2112454140u,273013823u,1820195669u,3578872064u,353308431u,3886415751u,2181457907u,4226008003u,839074113u,1075055887u,2273805830u,126075843u,50397184u,0u);\n#endif\nuint readBitsSVO0 (uint bitLoc, uint numBits) {\n    uint wordLoc = bitLoc / 32u;\n    uint leftToRead = (32u - (bitLoc % 32u));\n    if (numBits <= leftToRead) {\n        uint shiftToMask = leftToRead - numBits;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - numBits);\n        masker <<= shiftToMask;\n        uint value = (svoObject0[wordLoc] & masker);\n        value >>= shiftToMask;\n        return value;\n    } else {\n        uint bottomBits = numBits - leftToRead;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - leftToRead);\n        uint topNum = (svoObject0[wordLoc] & masker);\n        uint bottomMasker = 0xFFFFFFFFu;\n        uint bottomShifter = uint(32u - bottomBits);\n        bottomMasker <<= bottomShifter;\n        uint value = (svoObject0[wordLoc + 1u] & bottomMasker);\n        uint bottomNum = (value >> bottomShifter);\n        return ((topNum << bottomBits) | bottomNum);\n    }\n}\n\nbool readLeafSVO0 (vec3 samplePos, vec3 sampleDir, out vec3 skipPos) {\n    skipPos = vec3 (10000.0);\n    if ( any(lessThan(samplePos, grid0Min)) || any(greaterThan(samplePos, grid0Max)) ) return false;\n    uvec3 topBrickPos = uvec3 (samplePos - grid0Min);\n    uint topBrickId = topBrickPos.z + topBrickPos.y * uint(grid0Range.x) + topBrickPos.x * uint(grid0Range.y) * uint(grid0Range.z);\n    uint streamReadPos = 0u;\n    for (int i = 0; i < int(topBrickId); i++) {\n        uint isOcc = readBitsSVO0 (streamReadPos, 1u);\n        streamReadPos += 1u;\n        if (isOcc == 1u) {\n            uint countMidBricks = countSetBits (readBitsSVO0 (streamReadPos, 8u));\n            streamReadPos += (8u + countMidBricks * 8u);\n        }\n    }\n    uint topBrick = readBitsSVO0 (streamReadPos, 1u);\n    if (topBrick == 0u) {\n        vec3 topBrickMin = grid0Min + vec3 (topBrickPos);\n        vec3 topBrickMax = topBrickMin + vec3 (1.0);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, topBrickMin, topBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    streamReadPos += 1u;\n    uint midBricks = readBitsSVO0 (streamReadPos, 8u);\n    streamReadPos += 8u;\n    vec3 topBrickMinCorner = grid0Min + vec3 (topBrickPos);\n    vec3 sampleRelativeToTopBrick = fract (samplePos);\n    uint checkMidBrickBit = 0x80u;\n    vec3 sampleRelativeToMidBrick = sampleRelativeToTopBrick;\n    vec3 midBrickPos = vec3 (0.0);\n    if ( sampleRelativeToTopBrick.x > 0.5 ) {\n        sampleRelativeToMidBrick.x -= 0.5;\n        midBrickPos.x = 0.5;\n        checkMidBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToTopBrick.y > 0.5 ) {\n        sampleRelativeToMidBrick.y -= 0.5;\n        midBrickPos.y = 0.5;\n        checkMidBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToTopBrick.z > 0.5 ) {\n        sampleRelativeToMidBrick.z -= 0.5;\n        midBrickPos.z = 0.5;\n        checkMidBrickBit >>= 1u;\n    }\n    if ( (midBricks & checkMidBrickBit) == 0u ) {\n        vec3 midBrickMin = grid0Min + vec3 (topBrickPos) + midBrickPos;\n        vec3 midBrickMax = midBrickMin + vec3 (0.5);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, midBrickMin, midBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    uint skipMidBricks = countSetBitsBefore (midBricks, checkMidBrickBit);\n    streamReadPos += (8u * skipMidBricks);\n    uint finalMidBrick = readBitsSVO0 (streamReadPos, 8u);\n    uint checkVoxelBrickBit = 0x80u;\n    if ( sampleRelativeToMidBrick.x > 0.25 ) {\n    checkVoxelBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToMidBrick.y > 0.25 ) {\n        checkVoxelBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToMidBrick.z > 0.25 ) {\n        checkVoxelBrickBit >>= 1u;\n    }\n    if ( (checkVoxelBrickBit & finalMidBrick) != 0u ) return true;\n    skipPos = samplePos + sampleDir * 0.25;\n    return false;\n}\n\nbool traceRaySVO0(vec3 p1, vec3 p2, out vec3 hitPos) {\n    vec3 m = p2 - p1;\n    float hitMin, hitMax;\n    if ( !rayBoxIntersectTime (p1, vec3(1.0)/m, grid0Min, grid0Max, hitMin, hitMax) ) {\n        hitPos = vec3 (-1.0);\n        return false;\n    }\n    \n    hitMin += 0.00001;\n    hitMax -= 0.00001;\n    vec3 curPos = p1 + hitMin * m;\n    vec3 curDir = normalize (m);\n    vec3 skipPos = vec3 (0.0);\n    for (int i = 0; i != 100; i++) {\n        if (readLeafSVO0 (curPos, curDir, skipPos)) {\n            hitPos = curPos;\n            return true;\n        }\n        if ( skipPos == vec3(10000.0) ) break;\n        curPos = skipPos;\n    }\n    return false;\n}\n\n// ===================== HELPER UTILS =====================\n\n#define M_PI 3.1415926535\n\nvoid toLog (mat3 mat, out vec3 axis, out float angle)\n{\n    float matTrace = mat[0][0] + mat[1][1] + mat[2][2];\n    angle = acos ((matTrace - 1.0) / 2.0);\n    float sinAngle = sin(angle);\n    if ( abs(sinAngle) < 0.0001 )\n        if (sinAngle < 0.0)\n            sinAngle = -0.0001;\n        else\n            sinAngle = 0.0001;\n    axis = (1.0 / (2.0 * sinAngle)) * vec3 (mat[1][2] - mat[2][1], mat[2][0] - mat[0][2], mat[0][1] - mat[1][0]); // Column major\n}\n\nvoid toExp (vec3 axis, float angle, out mat3 mat)\n{\n    mat3 ident = mat3(1.0), crossMat, crossMat2;\n    crossMat[0] = vec3 (0.0, axis.z, -axis.y);\n    crossMat[1] = vec3 (-axis.z, 0.0, axis.x);\n    crossMat[2] = vec3 (axis.y, -axis.x, 0.0);\n    crossMat2 = crossMat * crossMat;\n    mat = ident + sin(angle) * crossMat + (1.0 - cos(angle)) * crossMat2;\n    mat[0] = normalize (mat[0]);\n    mat[1] = normalize (mat[1]);\n    mat[2] = normalize (mat[2]);\n}\n\nvoid slerp(float startAngle, vec3 startAxis, float endAngle, vec3 endAxis, float t, out float curAngle, out vec3 curAxis) {\n\t// Calculate angle between them.\n\tfloat cosHalfTheta = startAngle * endAngle + dot (startAxis, endAxis);\n\t// if qa=qb or qa=-qb then theta = 0 and we can return qa\n\tif (abs(cosHalfTheta) >= 1.0){\n\t\tcurAngle = startAngle;\n        curAxis = startAxis;\n\t\treturn ;\n\t}\n\t// Calculate temporary values.\n\tfloat halfTheta = acos(cosHalfTheta);\n\tfloat sinHalfTheta = sqrt(1.0 - cosHalfTheta*cosHalfTheta);\n\t// if theta = 180 degrees then result is not fully defined\n\t// we could rotate around any axis normal to qa or qb\n\tif (abs(sinHalfTheta) < 0.001){ // fabs is floating point absolute\n\t\tcurAngle = (startAngle * 0.5 + endAngle * 0.5);\n\t\tcurAxis = (startAxis + endAxis) * 0.5;\n\t\treturn ;\n\t}\n\tfloat ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n\tfloat ratioB = sin(t * halfTheta) / sinHalfTheta; \n\t//calculate Quaternion.\n\tcurAngle = (startAngle * ratioA + endAngle * ratioB);\n\tcurAxis.x = (startAxis.x * ratioA + endAxis.x * ratioB);\n\tcurAxis.y = (startAxis.y * ratioA + endAxis.y * ratioB);\n\tcurAxis.z = (startAxis.z * ratioA + endAxis.z * ratioB);\n}\n\nvoid fromQuat (vec3 axis, float angle, out mat3 mat)\n{\n\tmat[0] = normalize (vec3(1.0 - 2.0 * (axis.y * axis.y + axis.z * axis.z), 2.0 * (axis.x * axis.y + axis.z * angle), 2.0 * (axis.x * axis.z - axis.y * angle)));\n\tmat[1] = normalize (vec3(2.0 * (axis.x * axis.y - axis.z * angle), 1.0 - 2.0 * (axis.x * axis.x + axis.z * axis.z), 2.0 * (axis.y * axis.z + axis.x * angle)));\n\tmat[2] = normalize (vec3(2.0 * (axis.x * axis.z + axis.y * angle), 2.0 * (axis.y * axis.z - axis.x * angle), 1.0 - 2.0 * (axis.x * axis.x + axis.y * axis.y)));\n}\n\nvoid toQuat (mat3 mat, out vec3 axis, out float angle)\n{\n    float tr = mat[0][0] + mat[1][1] + mat[2][2];\n    if (tr > 0.0) { \n        float S = sqrt(tr+1.0) * 2.0; // S=4*qw \n        angle = 0.25 * S;\n        axis.x = (mat[1][2] - mat[2][1]) / S;\n        axis.y = (mat[2][0] - mat[0][2]) / S; \n        axis.z = (mat[0][1] - mat[1][0]) / S; \n    } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) { \n        float S = sqrt(1.0 + mat[0][0] - mat[1][1] -  mat[2][2]) * 2.0; // S=4*qx \n        angle = (mat[1][2] - mat[2][1]) / S;\n        axis.x = 0.25 * S;\n        axis.y = (mat[1][0] + mat[0][1]) / S; \n        axis.z = (mat[2][0] + mat[0][2]) / S; \n    } else if (mat[1][1] > mat[2][2]) { \n        float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0; // S=4*qy\n        angle = (mat[2][0] - mat[0][2]) / S;\n        axis.x = (mat[1][0] + mat[0][1]) / S; \n        axis.y = 0.25 * S;\n        axis.z = (mat[2][1] + mat[1][2]) / S; \n    } else { \n        float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0; // S=4*qz\n        angle = (mat[0][1] - mat[1][0]) / S;\n        axis.x = (mat[2][0] + mat[0][2]) / S;\n        axis.y = (mat[2][1] + mat[1][2]) / S;\n        axis.z = 0.25 * S;\n    }\n}\n\n#define SINE_DIVIDER ((sin(iTime) + 1.0) * 0.5)\n#define USE_QUAT_SLERP (fetchUV.x > SINE_DIVIDER)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fetchUV = fragCoord.xy / iResolution.xy;\n    vec2 uvDenorm =(fetchUV - vec2 (0.5)) * 2.0;\n    vec3 curEye = vec3 (0.0, 3.0, 20.0);\n    vec3 curLook = normalize (-curEye);\n    vec3 curSide = normalize (cross (vec3 (0.0, 1.0, 0.0), curLook));\n    vec3 curUp = cross (curLook, curSide) * (iResolution.y / iResolution.x);\n    vec3 curDir = curLook + curSide * uvDenorm.x + curUp * uvDenorm.y;\n    vec3 curEndSight = curEye + curDir * 1000.0;\n    vec3 curSightSeg = curEndSight - curEye;\n    \n    mat3 startMat, endMat, curMat;\n    startMat[0] = normalize (vec3 (103.0, 25.0, 905.0));\n    startMat[1] = normalize (cross (normalize (startMat[0] + vec3 (30.0, 200.0, 0.45)), startMat[0]));\n    startMat[2] = cross (startMat[1], startMat[0]);\n    endMat[0] = normalize (vec3 (13.0, -555.0, 15.0));\n    endMat[1] = normalize (cross (normalize (endMat[0] + vec3 (-1000.0, 2.0, 0.45)), endMat[0]));\n    endMat[2] = cross (endMat[1], endMat[0]);\n    vec3 startAxis, endAxis, curAxis;\n    float startAngle, endAngle, curAngle;\n    \n    if (fetchUV.x > SINE_DIVIDER - 0.002 && fetchUV.x < SINE_DIVIDER + 0.002)\n    {\n        fragColor = vec4 (1.0, 1.0, 0.0, 1.0);\n        return ;\n    }\n    else if (USE_QUAT_SLERP)\n    {\n        toQuat (mat3(1.0), startAxis, startAngle);\n        toQuat (endMat * inverse(startMat), endAxis, endAngle);\n\n        slerp (startAngle, startAxis, endAngle, endAxis, max (iTime, 0.0001), curAngle, curAxis);\n\n        fromQuat (curAxis, curAngle, curMat);\n    }\n    else\n    {\n        toLog (endMat * inverse(startMat), curAxis, curAngle);\n        curAngle *= max (iTime, 0.0001);\n        toExp (curAxis, curAngle, curMat);\n    }\n    curMat *= startMat;\n\n    curEye = inverse(curMat) * curEye;\n    curSightSeg = inverse(curMat) * curSightSeg;\n    \n    vec3 hitPos = vec3(0.0);\n    bool rt;\n    rt = traceRaySVO0(curEye, curSightSeg, hitPos);\n    if ( !rt ) {\n        if ( hitPos == vec3 (-1.0) ) fragColor = vec4 (0.5, 0.5, 0.5, 1.0);\n        else fragColor = vec4(0.0);\n     }\n    else fragColor = vec4 (length(curMat * (hitPos - curEye)) * (USE_QUAT_SLERP ? vec4 (0.05, 0.0, 0.0, 1.0) : vec4 (0.0, 0.0, 0.05, 1.0)));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}