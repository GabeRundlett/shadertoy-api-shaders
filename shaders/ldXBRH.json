{
    "Shader": {
        "info": {
            "date": "1494972118",
            "description": "Ok, guys... hummm, I know, I am a little bit late.\n\nPlease use mouse to look around.\nAdvised music for this shader: Carbon Based Lifeforms",
            "flags": 64,
            "hasliked": 0,
            "id": "ldXBRH",
            "likes": 18,
            "name": "Boreal Spring",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "raymarching",
                "transparency",
                "christmas",
                "particles",
                "aurora",
                "greatings"
            ],
            "usePreview": 1,
            "username": "ocb",
            "viewed": 1957
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Boreal Spring\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n// the main process is divided in several parts\n// 1- find the outbound of a ray: Sky or Ground\n// 2- the scenery is divided in sectors (or cells)\n//    the getNextCell() return each cells crossed by ray\n//    so only few object are consider for raytracing\n//    this allow to maintain good perfos with thousands of trees\n//    2D demo + explaination of getNextCell() here: https://www.shadertoy.com/view/XdffRN\n// 3- finally raytrace fairy lights wich are not linked to a cell\n//    fairy lights are raytraced twice for transparency purpose.\n\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000000.\n\n#define maxTreeH 130.\n#define maxHill 300.\n#define cellH 430. \t/*treeH + maxHill*/\n#define cellD 100.\n#define maxCell 200\n#define TREE_DENSITY (abs(fract(cell.x/10.)-.5)*abs(fract(cell.y/10.)-.5))*10.\n\n// object name\n#define GND -1\n#define SKY -1000\n\n#define REDL 1\n#define MAGL 2\n#define BLUL 3\n#define YELL 4\n\n#define COTTA 10\n#define WALL 11\n#define ROOF 12\n\n#define TREE 20\n#define CHRISTREE 21\n\n#define SNOWMAN 40\n#define BELLY 41\n#define HEAD 42\n#define HAT 43\n#define NOZ 44\n\n// ground parameters precalculated for perfo\n#define SHIFT 0.\n#define AMP 1.\n#define P1 .003\n#define P2 .0039999  /* P1*1.3333 */\n#define P3 .0059661  /* P1*1.9887 */\n\n#define DP2 .0039999 /*.00199995  /* AMP * P2 */\n#define DP3 .0059661 /*.00298305  /* AMP * P3 */\n\n#define NRM 4.   /* (1. + AMP + SHIFT) * 2. */\n\n\nint hitObj = SKY;\nfloat T = INFINI;\n\n// object global\n// Camera pos\nvec3 camPos;\n// Ambiance light direction\nvec3 lightRay;\n// lights\nvec3 redO, magO, bluO, yelO;\nfloat redR, magR, bluR, yelR;\n// cotta\nvec3 wallO, roofO;\nfloat wallR, roofR, roofH;\nvec2 cottaCell;\n\n// snowpeople\nvec3 belO, hedO, hatO, nozO;\nfloat belR, hedR, hatH, hatR, nozH, nozR;\nvec2 snowmanCell;\n\n//tree\nvec3 treeO;\nfloat treeR, treeH;\n\n//Christmas tree\nvec3 CtreeO;\nfloat CtreeR, CtreeH;\nvec2 CtreeCell;\n\n\n\nfloat rand1 (in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\nfloat rand2 (in vec2 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st.xy,vec2(12.9898,8.233))) * 43758.5453123+time);\n}\n\n// ground height\nfloat ground(in vec2 p){\n    float len = max(1.,0.0001*length(p));\n    float hx = max(0., (sin(P1*(p.x+p.y)) + AMP*sin(P2*p.x+PIdiv2) + SHIFT) );\n    float hy = max(0., (sin(P1*(p.y+.5*p.x)) + AMP*sin(P3*p.y+PIdiv2) + SHIFT));\n    return maxHill*(hx+hy)/NRM/len;\n}\n\n// returning ground normal for a position p\n// derivation of the ground function\nvec3 getGndNormal(in vec2 p, in float h) {\n    if(h<.001) return vec3(0.,1.,0.);\n    else{\n        float len = max(1.,0.0005*length(p));\n        float dx = maxHill*( P1*cos(P1*(p.x+p.y)) + DP2*cos(P2*p.x+PIdiv2) )/NRM;\n        float dy = maxHill*( P1*cos(P1*(p.y+.5*p.x)) + DP3*cos(P3*p.y+PIdiv2) )/NRM;\n        return normalize(cross( vec3(1.,dx/len,0.), vec3(0.,dy/len,1.) ));\t\t// divided by len: We may call that \"normal fog\"\n    }\n}\n\n//************ Ray marching to find ground impact ********\nfloat gndRayTrace(in vec3 p, in vec3 ray){\n    float t = 0.;\n    float contact = .5;\n    float dh = p.y - ground(p.xz);\n    if(dh<contact) return .0001;\n    for(int i=0; i<100;i++){\n        t += dh;\t\t\t// t = dh/length(ray) but ray normalized\n        p += dh*ray;\n        if(p.y >= cellH && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n        dh = p.y - ground(p.xz);\n        if(abs(dh)<contact)break;\n    }\n    return t;\n}\n\n//********** raytracing for simple primitives *********\nfloat sfcImpact(in vec3 p, in vec3 ray, float h){\n    float t = (h-p.y)/ray.y;\n    if (t <= 0.001) t = INFINI;\n    return t;\n}\n\nfloat sphereImpact(in vec3 pos, in vec3 sphO, in float sphR, in vec3 ray){\n    float t = INFINI;\n    vec3 d = sphO - pos;\n    float dmin = 0.;\n    float b = dot(d, ray);\n    \n    if (b >= 0.){\t// check if object in frontside first (not behind screen)\n        float a = dot(ray,ray);\n        float c = dot(d,d) - sphR*sphR;\n    \tfloat disc = b*b - c;\n    \tif (disc >= 0.){\n        \tfloat sqdisc = sqrt(disc);\n            float t1= (b + sqdisc)/a;\n            float t2= (b - sqdisc)/a;\n        \tt = min(t1,t2) ;\n        \tif (t <= 0.001){\n                t = max(t1,t2);\n                if (t <= 0.001) t = INFINI;\n            } \n        }\n    }\n    return t;\n}\n\nfloat coneImpact(in vec3 pos, in vec3 coneO, in float coneH, in float coneR, in vec3 ray){\n    float t = INFINI, dmin=0.;\n    vec3 d = coneO - pos;\n    float Dy = coneH + d.y;\n    float r2 = coneR*coneR/(coneH*coneH);\n    float b = dot(d.xz, ray.xz);\n    \n    float a = dot(ray.xz,ray.xz);\n    float c = dot(d.xz,d.xz) - r2*Dy*Dy;\n    float c1 = -b + r2*Dy*ray.y;\n    float disc = c1*c1 - (a - r2*ray.y*ray.y) * c;\n    if (disc >= 0.){\n        float sqdis = sqrt(disc);\n        float t1 = (-c1 + sqdis)/(a - r2*ray.y*ray.y);\n        float t2 = (-c1 - sqdis)/(a - r2*ray.y*ray.y);\n\n        float ofc = -ray.y*t1 + Dy;\n        t1 *= step(0.,ofc)*(1.-step(coneH,ofc));\n        if (t1 <= 0.001) t1 = INFINI;\n\n        ofc = -ray.y*t2 + Dy;\n        t2 *= step(0.,ofc)*(1.-step(coneH,ofc));\n        if (t2 <= 0.001) t2 = INFINI;\n\n        t = min(t1,t2);\n    }\n    \n\treturn t;\n}\n\n\n//******* TEXTURES AND COLORS *********\n\nvec3 skyGlow(in vec3 ray){\n    if(ray.y>=0.)return vec3(.5*max(ray.x+.7,0.)*(.8-max(0.,ray.y)), .35,.4)*(1.-ray.y)*(ray.x+1.5)*.4;\n    else return vec3(0.);\n}\n\nvec3 snowColor(in vec3 pos){\n    vec3 col = vec3(.7,.7,.75)+vec3(.05,.05,.05)*rand2(floor(pos.xz*10.), 0.);\n    col += vec3(1.,.7,.8)*step(.997,rand2 (floor(pos.xz*20.), 0.));\n    return col;\n}\n\n\n// Ctree light on ground \nvec3 CtreeColor(in vec3 pos){\n    return .5*vec3(.5,.5,1.)*min(1.,30./length(pos-CtreeO-vec3(0.,CtreeH/2.,0.)));\n}\n\n// fairylight on ground\nvec3 lightColor(in vec3 pos){\n    vec3 color = vec3(0.);\n    color.r += min(1.,5./length(pos-redO));\n    color.rb += min(1.,5./length(pos-magO));\n    color.b += min(1.,10./length(pos-bluO));\n    color.rg += min(1.,3./length(pos-yelO));\n    return color;\n}\n\n// cotta window\nvec3 window(in float angl, in vec3 pos){\n    float dh = pos.y-wallO.y-.25*wallR;\n    float an = fract(3.*angl/PI)-.5;\n    return vec3(1.,.5,.0)*(smoothstep(-.9,-.8,-abs(abs(dh)-1.))*( smoothstep(-.04,-.03,-abs(abs(an)-.04)))+.2*(1.-smoothstep(.0,.4,abs(an))));\n    \n}\n\n// window light on ground\nvec3 winLitcolor(vec3 pos){\n    float r = length(pos.xz-wallO.xz)*.01;\n    if (r<2.5){\n    \tfloat a= fract(3.*atan(pos.z- wallO.z,pos.x - wallO.x)/PI)-.5;\n    \treturn vec3(1.,.5,.0)*.3*smoothstep(-2.,-.0,-r)*smoothstep(.1,.8,r)*smoothstep(-.5,-.0,-abs(a))*smoothstep(-60.,.0,-pos.y+wallO.y);\n    }\n    else return vec3(0.);\n}\n\nvec3 stars(in float a,in vec3 ray){\n    vec2 star = vec2(a,ray.y*.7)*30.;\n    vec2 p = floor(star);\n    if(rand2(p,0.)>.97){\n        vec2 f = fract(star)-.5;\n    \treturn  vec3(.7*smoothstep(0.,.3,abs(fract(iTime*.3+3.*a)-.5))*ray.y * (smoothstep(-.01,-.0,-abs(f.x*f.y))+max(0.,.1/length(f)-.2)));\n    }\n\telse return vec3(0.);\n}\n\n// northern light\nvec3 boreal(in float a,in vec3 ray){\n    vec3 col = vec3(0.);\n    float b = .03*(asin(clamp(6.*a+12.,-1.,1.))+PIdiv2);\n    float c = .2*(asin(clamp(-.2*a*abs(a)-1.67222,-1.,1.))+2.042);\n    float d = .05*(a+1.)*(asin(clamp(a-1.,-1.,1.))+PIdiv2);\n    float rebord = smoothstep(1.83333,1.9,-a);\n    float rebord2 = smoothstep(-2.,-1.9,-a);\n    float var1 = (sin(1./(a+2.2)+a*30. + iTime)+1.)/4.+.5;\n    float var2 = (sin(a*10. - iTime)+1.)/4.+.5;\n    float var3 = (sin(1./(a+.04)+a*10. + iTime)+1.)/4.+.5;\n    col += 2.5*vec3(0.292,ray.y,0.1)*var1*smoothstep(b,b+.5*ray.y,ray.y)*smoothstep(-b-.9*ray.y,-b,-ray.y)*rebord;\n    col += 1.*vec3(.6-ray.y,.5*ray.y,0.15)*var2*smoothstep(c,c+.07,ray.y)*smoothstep(-c-.5,-c,-ray.y)*rebord;\n    col += 2.5*vec3(0.292,ray.y,0.1)*var3*smoothstep(d,d+.5*ray.y,ray.y)*smoothstep(-d-.9*ray.y,-d,-ray.y)*rebord2;\n\treturn col;\n}\n\nvec3 skyColor(in vec3 ray){\n    float a = atan(ray.z,ray.x);\n    vec3 color = skyGlow(ray);\n    color += stars(a,ray);\n    color += boreal(a, ray);\n    return color;\n}\n\nvec3 groundColor(in vec3 pos, in vec3 ray, in vec3 norm){\n    float len = length(camPos.xz-pos.xz);\n    float dir = max(0.,dot(-lightRay,norm));\n    vec3 color = snowColor(pos*.5)*(.9*dir+.1);\n    color *= .5+.5*pos.y/maxHill;\n    ray = reflect(ray, norm);\n    ray.y = max(0.,ray.y);\n    color = mix(.9*skyGlow(ray),color,.7);\n    color *= 1.-atan(len/10000.)/PIdiv2;\n    color += vec3(.4*max(ray.x+.7,0.), .35,.4)*(ray.x+1.5)*.4*atan(len/20000.)/PIdiv2;\n    color += .8*lightColor(pos);\n    color += winLitcolor(pos);\n    color += CtreeColor(pos);\n\treturn color;\n}\n\n//************* COTTA FUNCTIONS ************\nvec3 roofColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float an = atan((p.z - roofO.z),(p.x - roofO.x));\n    float lim = 4.*(.2*sin(6.*an)+1.1);\n    vec3 tile = (smoothstep(.0,.9, abs(fract(p.y)-.5))+smoothstep(0.,.7,abs(fract(20.*an+step(1., mod(p.y,2.0)) * 0.5)-.5)))*vec3(0.380,0.370,0.207);\n    vec3 color = step(-p.y+roofO.y,-lim)*snowColor(p*5.) + step(p.y-roofO.y,lim)*tile;\n    float h = ground(p.xz);\n    vec3 gndNorm = getGndNormal(p.xz, h);\n    color *= (dot(gndNorm, -lightRay)+.7)/1.;\n    color *= ((dot(lightRay,norm)+1.)*.3 + .05);\n    color += .8*lightColor(p);\n    return color;\n}\n\nvec3 wallColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float angl = atan((p.z - wallO.z),(p.x - wallO.x));\n    float lim =  1.3*(sin(2.*angl)+1.5);\n    vec3 tile = (smoothstep(0.,.5,abs(fract(p.y)-.5))+smoothstep(0.,.1,abs(fract(2.*angl)-.5)))*vec3(0.320,0.296,0.225);\n    vec3 color = step(p.y,lim)*snowColor(p*5.) + step(-p.y,-lim)*tile;\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += window(angl, p);\n    color += .8*lightColor(p);\n    return color;\n}\n\nbool cottaImpact(in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    float tr = coneImpact(p, roofO, roofH, roofR, ray);\n    float tw = sphereImpact(p, wallO, wallR, ray);\n    float t = min(tr,tw);\n    if(t<T){\n        T=t;\n        p += t*ray;\n        impact = true;\n        if(t == tr){\n            hitObj = ROOF; \n            vec3 norm = normalize(vec3(p.x - roofO.x,roofR*roofR/(roofH*roofH)*(roofH + roofO.y - p.y),p.z-roofO.z));\n            color += roofColor(p, ray, norm);\n        }\n        else{\n            hitObj = WALL;\n            vec3 norm = normalize(p-wallO);\n            color += wallColor(p, ray, norm);\n        }\n    }\n    \n    // twinkeling garland \n    float R = roofR+.5, H = 1.;\n    for(int i = 0; i<47; i++){\n        float fi = float(i);\n        float v = fi/50.;\n        float dh = H*(1.+sin(6.*v*TwoPI));        \n        vec3 bulb = vec3(roofO.x + R*sin(v*TwoPI), roofO.y+dh-.5 ,roofO.z + R*cos(v*TwoPI));\n\t\tfloat d = length(cross((bulb-p), ray));\t\t// no bulbs impact. Distance ray to point for halo effect\n        if (!(impact && dot(bulb-p,ray)>=0.)){\t\t// No bulbs behind object\n            color.rgb += max(0.,.15/d-.005)*(sin(2.*iTime-fi)+1.000)/2.;\n            color.r += max(0.,.15/d-.005)*(sin(2.*iTime+fi)+1.)/2.;\n        }\n    }\n    return impact;\n}\n\n//***************** SNOWMAN FUNTIONS *******************\nvec3 bellyColor(in vec3 p, in vec3 ray, in vec3 norm, in vec3 belly){\n    vec3 color = snowColor(norm*30.);\n    color -= vec3(0.016,0.515,0.525)*step(.1,abs(p.z-belO.z));\n    color -= vec3(0.016,0.515,0.525)*step(-.1,-abs(p.z-belO.z))*step(-belO.x,-p.x);\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color *= (1.-step(-.5,-abs(p.z-belly.z))*step(0.,p.x-belly.x)* step(.9, fract((p.y-belly.y)*.4)));\n    color += lightColor(p);\n    return color;\n}\n\nvec3 headColor(in vec3 p, in vec3 ray, in vec3 norm, in vec3 head){\n    vec3 color = snowColor(norm*30.);\n    color -= vec3(0.016,0.515,0.525)*step(-hedO.y+.4*exp(p.x-hedO.x-2.),-p.y);\n    color -= (1.-step(.3,length(head.yz+vec2(1.5,1.5)-p.yz)))*step(hedO.x,p.x);\n    color -= (1.-step(.3,length(head.yz+vec2(1.5,-1.5)-p.yz)))*step(hedO.x,p.x);\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 hatColor(in vec3 p, in vec3 ray, in vec3 norm){\n    vec3 color = snowColor(p*5.);\n    color -= step(.5,fract(p.y*.4))*vec3(0.016,0.515,0.525);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 nozColor(in vec3 p, in vec3 ray, in vec3 norm){\n    vec3 color = vec3(0.475,0.250,0.002);\n    color *= ((dot(vec3(0.,1.,0.),norm)+1.)*.4 + .2);\n    color += lightColor(p);\n    return color;\n}\n\n\nbool caracterImpact(in vec3 p, in vec3 ray,inout vec3 color){\n    bool impact = false;\n    float tbel = sphereImpact(p, belO, belR, ray);\n    float thed = sphereImpact(p, hedO, hedR, ray);\n    float that = coneImpact(p, hatO, hatH, hatR, ray);\n    float tnoz = coneImpact(vec3(-p.y,p.x,p.z), vec3(-nozO.y,nozO.x,nozO.z), nozH, nozR, vec3(-ray.y,ray.x,ray.z));\n    float t = min(min(min(tbel,thed),that),tnoz);\n    if(t<T){\n        T=t;\n        p += t*ray;\n        impact = true;\n        hitObj = SNOWMAN;\n        if(t == tbel){\n            vec3 norm = normalize(p - belO);\n            color += bellyColor(p, ray, norm, belO);\n        }\n        else if(t == thed){\n            vec3 norm = normalize(p - hedO);\n            color += headColor(p, ray, norm, hedO);\n        }\n        else if(t == that){\n            vec3 norm;\n            norm.xz = p.xz - hatO.xz;\t// simplified norm for hat. (perfo)\n            norm.y = 0.;\n            norm = normalize(norm);\n            color += hatColor(p, ray, norm);\n        }\n        else{\n            vec3 norm;\n            norm.yz = p.yz - nozO.yz;\n            norm.x = 0.;\n            norm = normalize(norm);\n            color += nozColor(p, ray, norm);\n        }\n    }\n    return impact;\n}\n\n\n//**************** TREE FUNCTIONS *********************\nvec3 treeColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float lim = 40.*(.05*sin(.6*p.x)+.5);\n    vec3 color = step(-p.y+treeO.y,-lim)*snowColor(fract(p*5.)) + step(p.y-treeO.y,lim)*vec3(0.000,0.320,0.317);\n    color *= ((dot(lightRay,norm)+1.)*.3 + .05);\n    vec3 r = reflect(ray,norm);\n    r.y = abs(r.y);\n    color += step(-p.y+treeO.y,-lim)*.7*skyGlow(r)*(treeO.y+10.)/maxHill;\n    color *= .6+.4*p.y/maxHill;\n    color += .8*lightColor(p);\n    color += 1.9*winLitcolor(p)*max(0.,dot(-normalize(p-wallO),norm));\n    color *= 1.-atan(length(camPos-p)/5000.)/PI*2.;\n\treturn color;\n}\n\n// create tree, if there is one (treeDensity)\nbool getTree(in vec2 cell,inout vec3 treeO, inout float treeH, inout float treeR){\n    bool treeOk = bool(step(TREE_DENSITY,rand2(cell*1.331,1.)));\t\t\t// check if object, depending cell coords\n        if (treeOk){ \n            treeH = (.5*rand2(cell*3.86,0.)+.5)*maxTreeH;\n            treeR = .15*treeH;\n            float lim = (1.-2.*treeR/cellD);\n            treeO = vec3(lim*(rand2(cell*2.23,0.) - 0.5) + cell.x, 0., lim*(rand2(cell*1.41,0.) -0.5)  + cell.y) *cellD;\n            treeO.y += ground(treeO.xz)-10.;\n        }\n    return treeOk;\n}\n\nbool treeImpact(in vec2 cell, in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    bool tree = getTree(cell,treeO, treeH, treeR);\n    if(tree){\n        float t = coneImpact(p, treeO, treeH, treeR, ray);\n        if(t<T){\n            T=t;\n            hitObj = TREE;\n            impact = true;\n            p += t*ray;\n            vec3 norm = normalize(vec3(p.x - treeO.x,treeR*treeR/(treeH*treeH)*(treeH + treeO.y - p.y),p.z-treeO.z));\n            color += treeColor(p, ray, norm);\n        }\n    }\n    \n    return impact;\n}\n\n//************** Christmas tree *******************\nbool CtreeImpact(in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    \n    float t = coneImpact(p, CtreeO, CtreeH, CtreeR, ray);\n        if(t<T){\n            T=t;\n            hitObj = CHRISTREE;\n            impact = true;\n            p += t*ray;\n            vec3 norm = normalize(vec3(p.x - CtreeO.x,CtreeR*CtreeR/(CtreeH*CtreeH)*(CtreeH + CtreeO.y - p.y),p.z-CtreeO.z));\n            treeO.y = CtreeO.y;\n            color += treeColor(p, ray, norm);\n        }\n    \n    // twinkeling garland\n    float R = CtreeR+1., H = CtreeH+5.;\n    for(int i = 0; i<47; i++){\n        float fi = float(i);\n        float v = rand1(fi*1.87);\n        float dh = H*fract(fi*.02);\n        float r = R*(H-dh)/H;\n        vec3 bulb = vec3(CtreeO.x + r*sin(fi*v), CtreeO.y+dh+5. ,CtreeO.z + r*cos(fi*v));\n\t\tfloat d = length(cross((bulb-p), ray));\t\t\t// no bulbs impact. Distance ray to point for halo effect\n        if (!(impact && dot(bulb-p,ray)>=0.)){\t\t\t// hidden face\n            color.rgb += max(0.,.15/d-.005)*(sin(2.*iTime-fi)+1.)/2.;\n            color.b += max(0.,.15/d-.005)*(sin(2.*iTime+fi)+1.)/2.;\n            \n        }\n        if(impact){\n            float c = .05/length(p-bulb);\n            color += vec3(c,c,4.*c);\n        }\n    }\n\n    return impact;\n}\n\n\n//********************** FAIRY LIGHTS FUNCTIONS ******************\nvec3 fairyReflect(in vec3 ray,in vec3 norm){\n    vec3 r = reflect(ray,norm);\n    r.y = abs(r.y);\n    return skyGlow(r);\n}\n\n// set fairy lights colors\nvec3 fairyLight(in vec3 ray,in vec3 pos,in int hitObj){\n    float cs;\n    vec3 norm;\n    vec3 refl;\n    vec3 col=vec3(0.);\n    if (hitObj == REDL){\n        col.r += .05;\n        norm = normalize(redO-pos);\n        col += .5*fairyReflect(ray,norm);\n\t\tcs = dot(ray,norm);\n        col.r += .2*smoothstep(-1.,0.,-cs);\n    \tcol.r += exp(30.*(cs-1.));\n    }\n    else if (hitObj == MAGL){\n        col.rb += .05;\n        norm = normalize(magO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col.rb += .2*smoothstep(-1.,0.,-cs);\n    \tcol.rb += exp(30.*(cs-1.));\n    }\n    else if (hitObj == BLUL){\n        col += .05*vec3(0.,.3,1.);\n        norm = normalize(bluO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col += vec3(0.,.3,1.)*.3*smoothstep(-1.,0.,-cs);\n    \tcol += vec3(0.,.3,1.)*exp(30.*(cs-1.));\n    }\n\telse if (hitObj == YELL){\n        col.rg += .05;\n        norm = normalize(yelO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col.rg += .2*smoothstep(-1.,0.,-cs);\n    \tcol.rg += exp(30.*(cs-1.));\n    }\n    return col;\n}\n\n// Ray-trace fairy lights taking into account transparency\nfloat lightTrace(in vec3 pos, in vec3 ray,inout int hitLit, in int trans){\n    float t = INFINI, tp; \t\n    \n    if(trans != REDL){\n    \t\ttp = sphereImpact(pos, redO, redR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = REDL;\n    \t\t}\n        }\n    if(trans != MAGL){\n    \t\ttp = sphereImpact(pos, magO, magR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = MAGL;\n    \t\t}\n        }\n    if(trans != BLUL){\n    \t\ttp = sphereImpact(pos, bluO, bluR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = BLUL;\n    \t\t}\n        }\n    if(trans != YELL){\n    \t\ttp = sphereImpact(pos, yelO, yelR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = YELL;\n    \t\t}\n        }\n\n    return t;\n}\n\n//**************************** KEY FUNCTION!! find the next cells crossed by the ray ******************\nvec2 getNextCell(in vec2 p, in vec2 v, in vec2 cell){\n    vec2 d = sign(v);\n\tvec2 dt = ((cell+d*.5)*cellD-p)/v;\n    d *= vec2( step(dt.x-0.02,dt.y) , step(dt.y-0.02,dt.x) );\t\t// -0.020 to avoid cell change for epsilon inside\n    return cell+d;\n}\n\n//*************** cal the set of functions depending on particular cell *************\nbool checkCell(in vec2 cell, in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    if(cell == cottaCell) impact = cottaImpact(p, ray, color);   \n    else if(cell == snowmanCell) impact = caracterImpact(p, ray, color);\n    else if(cell == CtreeCell) impact = CtreeImpact(p, ray, color);\n    else impact = treeImpact(cell, p, ray, color);\n    return impact;\n}\n\n//*************** Lights path and camera tracking *******************************\nvec3 circle(in float ti, in vec3 obj){\n    return vec3(80.*cos(ti*TwoPI) + obj.x, 0., 80.*sin(ti*TwoPI) + obj.z);\n}\n\nvec3 freetrack(in float time){\n    return vec3(1500.*cos(time*.05), 0., 1600.*sin(time*.15));\n}\n\nvec3 transfer(in vec3 tr1, in vec3 tr2, in float dti){\n    return tr1*(1.+cos(dti*.25*PI))/2. + tr2*(1.+cos(dti*.25*PI+PI))/2.;\n}\n\nvec3 getTrac(in float time){\n    float ti = 23.*fract(time*.01);\n    vec3 track;\n    \n    if(ti<1.) track = circle(ti,wallO);\n    else if(ti<5.) track = transfer(circle(ti,wallO), freetrack(time), ti-1.);\n    else if(ti<10.) track = freetrack(time);\n    else if(ti<14.) track = transfer(freetrack(time), circle(ti,hedO), ti-10.);\n    else if(ti<15.) track = circle(ti,hedO);\n    else if(ti<19.) track = transfer(circle(ti,hedO), circle(ti,CtreeO), ti-15.);\n    else track = transfer(circle(ti,CtreeO), circle(ti,wallO), ti-19.);\n    \n    return track;\n}\n\nvec3 getCam(in float time, in vec3 track){\n    float ti = 23.*fract(time*.01);\n    vec3 cam;\n    \n    if(ti<1.) cam = wallO;\n    else if(ti<5.) cam = transfer(wallO, track, ti-1.);\n    else if(ti<10.) cam = track;\n    else if(ti<14.) cam = transfer(track, hedO, ti-10.);\n    else if(ti<15.) cam = hedO;\n    else if(ti<19.) cam = transfer(hedO, CtreeO, ti-15.);\n    else cam = transfer(CtreeO, wallO, ti-19.);\n    \n    return cam;\n}\n\n\n//**********************************************************************************\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // object def\n    \n    //cotta\n    wallO = vec3(400.,4.,-600.);\n    wallO.y += ground(wallO.xz);\n    wallR = 20.;\n    roofO = wallO+vec3(0.,8.,0.);\n    roofH = 42.;\n    roofR = 22.;\n    cottaCell = vec2(4.,-6.);   //floor(wallO.xz/cellD + .5);\n    \n    //SnowMan\n    belO = vec3(200.,4.,100.);\n    belR = 10.;\n    belO.y = ground(belO.xz);\n    hedO = belO+vec3(0.,13.,0.);\n    hedR = 5.;\n    hatO = belO+vec3(0.,16.,0.);\n    hatH = 15.;\n    hatR = 3.8;\n    nozO = belO+vec3(4.,13.,0.);\n    nozH = 4.;\n    nozR = .8;\n    snowmanCell = vec2(2.,1.);\t\t//floor(belO.xz/cellD + .5);\n    \n    //Christmas tree\n\tCtreeO.xz = vec2(1200.,-600.);\n\tCtreeO.y = ground(CtreeO.xz)-5.;\n    CtreeH = 100.;\n    CtreeR = 15.;\n\tCtreeCell = vec2(12.,-6.);\n    \n    //light\n    vec3 trac = getTrac(iTime);\n    trac.y += ground(trac.xz)+15.;\n    vec3 tracb = getTrac(iTime-.5);\n    tracb.y = ground(tracb.xz)+1.;\n    redO = trac + vec3(20.*sin(iTime*2.),5.*sin(iTime*3.),10.*cos(iTime*2.));\n    redR = 3.;\n    magO = trac +vec3(10.*sin(1.+iTime*2.),4.*sin(1.6+iTime*3.),15.*cos(1.+iTime*2.));\n    magR = 3.;\n    bluO = trac +vec3(10.*sin(5.+iTime*3.),2.*sin(3.+iTime*2.),10.*cos(5.+iTime*3.));\n    bluR = 3.;\n    yelO = tracb +vec3(30.*sin(iTime*3.),abs(15.*sin(iTime*4.)+4.),20.*cos(iTime*3.));\n    yelR = 1.;\n    \n    //vec3 camTarget = trac;\n    //vec3 camTarget = tracb;\n    //vec3 camTarget = wallO*(1.+sin(u_time*.2))/2. + trac*(1.+sin(u_time*.2+PI))/2.;\n    //vec3 camTarget = redO;\n    //vec3 camTarget = bluO;\n    //vec3 camTarget = yelO;\n    //vec3 camTarget = (trac+wallO)/2.;\n    //vec3 camTarget = wallO;\n    //vec3 camTarget = roofO;\n    //vec3 camTarget = hedO;\n    //vec3 camTarget = CtreeO+vec3(0.,50.,0.);\n    vec3 camTarget = getCam(iTime, trac);\n    \n    // camera def\n    float \tfocal = 1.;\n    \n    float   rau = 500.,        \n    \t\talpha = 1.8,\n    \t\ttheta = .25;\n    \n    if(iMouse.z != 0.){\n            rau = 500.*(sin(iTime*.15)+1.)+40.,\n    \t\talpha = iMouse.x/iResolution.x*4.*PI;\n    \t\ttheta = iMouse.y/iResolution.y*PI/2.-.00001;\t\n    }\n    \n    camPos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha)) + camTarget;\n\tcamPos.y = max(ground(camPos.xz)+20.,camPos.y);\t\t//anti-collision\n    \n    vec3 pos = camPos;\n    \n    vec3 ww = normalize( camTarget - pos );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n    \n\tlightRay = vec3(1.,0.,0.);\t// global var\n\tvec3 GNDnorm = vec3(0.);\n    \n    vec3 color = vec3(.0);\n        \n    vec2 cell, outCell;\n    vec3 p = pos;\n    \n    // first step getting boundarry of interesting areas\n    // find exit cell\n    T = gndRayTrace(pos, N_ray);\n    if(T<INFINI){\n        hitObj = GND;\n        vec3 tp = pos+T*N_ray;\n        cell = floor(tp.xz/cellD + .5);\n        outCell = getNextCell(pos.xz,N_ray.xz,cell);\n    }\n    else if(pos.y<cellH){\n        T = sfcImpact(pos, N_ray, cellH);\n        if(T<INFINI){\t\t\t\t\t\t\t\t\t// hitObj = SKY already default value\n            vec3 tp = pos+T*N_ray;\n            cell = floor(tp.xz/cellD + .5);\n            outCell = getNextCell(pos.xz,N_ray.xz,cell);\n            T = INFINI;\t\t\t\t\t\t\t\t\t// T consistant with SKY\n        }\n    }\n    else outCell = floor(pos.xz/cellD + .5);\n\t\n    //if cam above ceiling, find entry cell\n    if(pos.y>=cellH){\n        float t = sfcImpact(pos, N_ray, cellH);\n        if(t<INFINI) p = pos+t*N_ray;\n    }\n    \n    \n    // follow the ray across cells (and if object in cell, raytrace only the current cell)\n    // until:\n    // ray has reached the outCell (i.e. cell where the ray hit ground or ceiling)\n    // or ray has impact object\n    // or ray has reach the maxCell (calculation must end)\n    bool objImpact = false;\n    cell = floor(p.xz/cellD + .5);\n    if(cell != outCell){\n        for(int i=0; i<maxCell;i++){\n            objImpact = checkCell(cell, pos, N_ray, color);\n            if(objImpact) break;\n            cell = getNextCell(pos.xz,N_ray.xz,cell);\n            if(cell == outCell) break;\n        } \n \t}\n    \n    vec3 finalPos = pos + T*N_ray;\n    \n    // if impact, hitObj is TREE, CHRSTREE, COTTA OR SNOWMAN, color already set\n    // finally, if no impact, closing the scenery: SKY or GND\n    \n    if(hitObj == SKY) color += skyColor(N_ray);\n    else if(hitObj == GND){\n        GNDnorm = getGndNormal(finalPos.xz,finalPos.y);\n        color += 1.3*groundColor(finalPos, N_ray, GNDnorm);\n    }\n    \n    \n\t// particles flying around snowman.\n    // done in global because halo light propagates on multiple cells\n    // first line: check if ray enter a radius around snowman vertical axis\n    // to do calulation only in the environement of particules (here radius = 50.)\n    if( (abs(N_ray.z*(belO.x-pos.x) - N_ray.x*(belO.z-pos.z)) <50.) && (dot(belO-pos, N_ray)>=0.) ){\n    \tfloat len_fp_p = length(T*N_ray);\n        if(len_fp_p > length(belO-pos)-cellD){\n            float H = 200., R = 15.;\n            for(int i = 0; i<47; i++){\n                float fi = float(i);\n                float ti = -iTime+fi;\n                float dh = H*pow(fract(ti*.02),4.);\n                float r = R*(H-dh)/H;\t\t// for cone figure\n                float v = rand1(fi);\n                vec3 bulb = vec3(belO.x + r*sin(ti*v), belO.y+dh ,belO.z + r*cos(ti*v));\n                vec3 b_p = bulb-pos;\n                vec3 b_fp = bulb-finalPos;\n                float d;\n                if(len_fp_p<length(b_p)) d = length(b_fp);\n    \t\t\telse d = length(cross((b_p), N_ray));\n                if (!(hitObj == SNOWMAN && dot(b_fp,N_ray)>=0.)){\n                    color += max(0.,.15/d-.003)*rand1(fi);\n                }\n            }\n        }\n    }\n    \n    // Finally dealing with fairy lights, totally independant of cells. Done in global\n    int lightNbr;\n    float tlit;\n    // intercept lights\n    tlit = lightTrace(pos,N_ray,lightNbr,0);\t\t// 0 means no transparency requested\n    \n    if(tlit<T){\n        hitObj = lightNbr;\n        vec3 trpos = pos + tlit*N_ray; \n        // adding fairy lights\n    \tcolor += fairyLight(N_ray, trpos, hitObj);\n        \n        tlit = lightTrace(pos,N_ray,lightNbr,hitObj);\t\t// hitObj means transparency requested for this obj\n        if(tlit<INFINI){\t\t\t\t\t\t\t\t\t// to make visible the fairy light behind\n            trpos = pos + tlit*N_ray;\n        \tcolor += fairyLight(N_ray, trpos, lightNbr);\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 10818,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kevyfastswing/betula-pendula-and-init-short-mix"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}