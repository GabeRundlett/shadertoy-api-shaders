{
    "Shader": {
        "info": {
            "date": "1657585032",
            "description": "Simple spherical harmonic visualization for illustrative purposes",
            "flags": 0,
            "hasliked": 0,
            "id": "7sKBzR",
            "likes": 5,
            "name": "Spherical Harmonic Visualization",
            "published": 3,
            "tags": [
                "visualization",
                "spherical",
                "harmonics"
            ],
            "usePreview": 0,
            "username": "BeardThings",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\n#define L 2\n#define M 0\n//#define POLYNOMIAL\n#define DISTANCE 2.0\n\nint factorial(int v)\n{\n    int t = 1;\n    for(int i = 2; i < v; i++)\n    {\n        t *= i;\n    }\n    return t;\n}\n\n// Adapted from https://patapom.com/blog/SHPortal/\n// \"Evaluate an Associated Legendre Polynomial P(l,m,x) at x\n// For more, see “Numerical Methods in C: The Art of Scientific Computing”, Cambridge University Press, 1992, pp 252-254\" \nfloat P(int l, int m, float x )\n{\n    float pmm = 1.0;\n    \n    float somx2 = sqrt((1.0-x)*(1.0+x));\n    float fact = 1.0;\n    for ( int i=1; i<=m; i++ ) {\n        pmm *= (-fact) * somx2;\n        fact += 2.0;\n    }\n    \n    if( l == m )\n        return pmm;\n\n    float pmmp1 = x * (2.0*float(m)+1.0) * pmm;\n    if ( l == m+1 )\n        return pmmp1;\n\n    float pll = 0.0;\n    for ( float ll=float(m+2); ll<=float(l); ll+=1.0 ) {\n        pll = ( (2.0*ll-1.0)*x*pmmp1-(ll+float(m)-1.0)*pmm ) / (ll-float(m));\n        pmm = pmmp1;\n        pmmp1 = pll;\n    }\n\n    return pll;\n}\n\n\nfloat K(int l, int m)\n{\n    float n = float((2*l+1)*factorial(l - m));\n    float d = 4.0 * PI * float(factorial(l + m));\n    return sqrt(n/d);\n}\n\nfloat y(int l, int m, float cosTheta, float phi)\n{\n    float v = K(l, abs(m)) * P(l, abs(m), cosTheta);\n    if(m != 0)\n        v *= sqrt(2.0);\n    \n    if(m > 0)\n        v *= cos(float(m)*phi);\n    if(m < 0)\n        v *= sin(float(-m)*phi);\n    \n    return v;\n}\n\nvec3 RayDirection(in vec3 \tforward,\n                  in float \tfocalDistance,\n                  in vec3 \tright,\n                  in vec3 \tup,\n                  in vec2 \tscreenSpaceCoord,\n                  in float \taspectRatioXOverY)\n{\n    return normalize(forward * focalDistance + \n                     right * screenSpaceCoord.x * aspectRatioXOverY +\n                     up * screenSpaceCoord.y);\n}\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\nfloat SDF(vec3 p, out vec3 c)\n{\n    vec3 d = normalize(p);\n    float cosTheta = d.y;\n    float phi = atan(d.z,d.x);\n\n    float r = y(L,M,cosTheta,phi);\n    \n#ifdef POLYNOMIAL\n    r = 1.5*y(0,0,cosTheta,phi);\n    r += 0.2*y(1,-1,cosTheta,phi);\n    r += -0.8*y(1,0,cosTheta,phi);\n    r += 0.1*y(1,1,cosTheta,phi);\n#endif // POLYNOMIAL\n    \n    float sphereIntersect = Sphere(p, abs(r));\n    \n    c = mix(vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0),sign(r)*0.5+0.5);\n    return sphereIntersect;\n}\n\nvec3 Norm(vec3 p)\n{\n    const float cEps = 0.01;\n \n    vec3 c;\n\treturn normalize\n\t(\tvec3\n\t\t(\tSDF(p + vec3(cEps, 0, 0),c\t) - SDF(p - vec3(cEps, 0, 0),c),\n\t\t\tSDF(p + vec3(0, cEps, 0),c\t) - SDF(p - vec3(0, cEps, 0),c),\n\t\t\tSDF(p + vec3(0, 0, cEps),c\t) - SDF(p - vec3(0, 0, cEps),c)\n\t\t)\n\t);\n}\n\nvec4 Sample(vec3 o, vec3 direction)\n{\n    vec4 fc;\n    \n    float d = 0.0;\n    for(float i = 0.; i < 64.; ++i)\n    {\n        vec3 pos = o + direction * d;\n\n        vec3 c;\n        float sdf = SDF(pos, c);\n        d += sdf*0.25;\n        \n        fc = vec4(direction.xy*0.5+0.5, 1.0, 1.0) *0.5;\n        \n        const float EPSILON = 0.01;\n        if(sdf < EPSILON)\n        {   \n            fc.rgb = c*(dot(Norm(pos), vec3(0.707,0.707,0.0))*0.5+0.5);\n            break;\n        }\n        \n        if(d > 30.)\n        {\n            break;\n        }\n    }\n    \n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\t\n    const float height = 0.0;\n    vec3 o = vec3(sin(iTime), 0.0, -cos(iTime)) * DISTANCE;\n    \n    vec3 f = normalize(-o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = RayDirection(f, \n                                  2.0, \n                                  r, \n                                  u, \n                                  screenSpace, \n                                  iResolution.x / iResolution.y);\n    \n    fragColor = Sample(o, direction);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}