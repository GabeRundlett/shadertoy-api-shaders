{
    "Shader": {
        "info": {
            "date": "1539557492",
            "description": "Stan is back yeah!",
            "flags": 0,
            "hasliked": 0,
            "id": "MldBDH",
            "likes": 7,
            "name": "southParkStan",
            "published": 3,
            "tags": [
                "cartoon",
                "character",
                "southpark",
                "stan"
            ],
            "usePreview": 0,
            "username": "spacegoo",
            "viewed": 756
        },
        "renderpass": [
            {
                "code": "//COLOR DEF:\n\n//general colors:\nconst vec4 COLOR_BLACK=vec4(0.,0.,0.,1.);\nconst vec4 COLOR_WHITE=vec4(1.,1.,1.,1.);\nconst vec4 COLOR_SKIN=vec4(0.99, 0.86, 0.71, 1.);\n\n//Stan specific colors:\nconst vec4 COLOR_STANSHIRT=vec4(0.62, 0.37, 0.32, 1.);\nconst vec4 COLOR_STANBLUE=vec4(0.31, 0.38, 0.62, 1.);\nconst vec4 COLOR_STANRED=vec4(0.84, 0.12, 0.25, 1.);\n\n//ANTIALIASING:\nconst float AA=0.001;\n\n    \n    \n//MATH UTILS:\nfloat side(vec2 ptA, vec2 ptB, vec2 ptX){\n    mat2 m=mat2(ptX-ptA, ptB-ptA);\n\treturn determinant(m);\n}\n\n//ANALOGOUS GLSL STEP FUNC\n//BUT ADD ANTIALIASING\nfloat stepAA1(float edge, float val){\n    //return step(edge, val);\n\treturn smoothstep(edge-AA, edge+AA, val);\n}\nvec2 stepAA2(vec2 edge, vec2 val){\n    //return step(edge, val);\n\treturn smoothstep(edge-vec2(AA,AA), edge+vec2(AA,AA), val);\n}\n\n\n//GEOMETRIC TEST FUNCTIONS:\n//return 0.0 if outside, 1.0 if inside\n//test if inside a rectangle which center is ctr and dims are wh:\nfloat isInRect(vec2 co, vec2 ctr, vec2 wh){\n    vec2 mn=stepAA2(ctr-0.5*wh,co);\n    vec2 mx=stepAA2(co,ctr+0.5*wh);\n    return mn.x*mn.y*mx.x*mx.y;\n} \n\n//test if inside an ellipse defined by center, size along axis and long axis angle theta:\nfloat isInEllipse(vec2 co, vec2 ctr, vec2 halfWh, float theta){\n    float c=cos(theta), s=sin(theta);\n    vec2 coCtr=mat2(c,s,-s,c)*(co-ctr);\n    vec2 elvec=coCtr/halfWh;\n    return stepAA1(dot(elvec, elvec), 1.0);\n}\n\nfloat isInCircle(vec2 co, vec2 ctr, float radius){\n    return stepAA1(distance(co, ctr), radius);\n}\n\nfloat isUnderCurve(vec2 co, vec2 ptA, vec2 ptB, float curvature){\n    float dAB=distance(ptA,ptB);\n    float d=distance(co,ptA)*distance(co,ptB)/(dAB*dAB);\n    vec2 n=normalize(ptB-ptA);\n    vec2 co2=co-curvature*n.yx*d;\n    return stepAA1(0.0, side(ptA, ptB, co2));\n}\n\nfloat isOnHztCurve(vec2 co, vec2 ptA, vec2 ptB, float curvature, float lineWidth){\n    float dAB=distance(ptA,ptB);\n    float d=distance(co,ptA)*distance(co,ptB)/(dAB*dAB);\n    vec2 n=normalize(ptB-ptA);\n    vec2 co2=co-curvature*n.yx*d;\n    float r=stepAA1(abs(side(ptA, ptB, co2)), lineWidth );\n    vec2 mn=min(ptA, ptB)-vec2(lineWidth,lineWidth);\n    vec2 mx=max(ptA, ptB)+vec2(lineWidth,lineWidth);\n    vec2 isOverMn=stepAA2(mn, co);\n    vec2 isUnderMx=stepAA2(co, mx);\n    return r*isOverMn.x*isUnderMx.x;\n}\n\nfloat isOnVtCurve(vec2 co, vec2 ptA, vec2 ptB, float curvature, float lineWidth){\n    float dAB=distance(ptA,ptB);\n    float d=distance(co,ptA)*distance(co,ptB)/(dAB*dAB);\n    vec2 n=normalize(ptB-ptA);\n    vec2 co2=co-curvature*n.yx*d;\n    float r=stepAA1(abs(side(ptA, ptB, co2)), lineWidth );\n    vec2 mn=min(ptA, ptB)-vec2(lineWidth,lineWidth);\n    vec2 mx=max(ptA, ptB)+vec2(lineWidth,lineWidth);\n    vec2 isOverMn=stepAA2(mn, co);\n    vec2 isUnderMx=stepAA2(co, mx);\n    return r*isOverMn.y*isUnderMx.y;\n}\n\n\n//draw Stan in a square where co.x and .y are in [-1,1]:\nvec4 drawStan(in vec2 co){\n    //init output as background color (transparent)\n    vec4 col=vec4(0.,0.,0.,0.);\n    \n    //BODY:\n    //PANTS:\n    col=mix(col, COLOR_STANBLUE, isInRect(co, vec2(0.,-0.89), vec2(0.86,0.17)));\n    \n    //SHIRT:\n    //main part of the shirt\n    float isShirt=1.-isUnderCurve(co, vec2(-0.48,-0.8), vec2(0.48,-0.8), -0.24);\n    isShirt*=isUnderCurve(co, vec2(-0.48,-0.8), vec2(-0.41,-0.5), 0.02);\n    isShirt*=1.0-isUnderCurve(co, vec2(0.48,-0.8), vec2(0.41,-0.5), 0.02);\n    isShirt*=step(co.y,0.0);\n    col=mix(col, COLOR_STANSHIRT, isShirt);\n    \n    //sleeves:\n    float isSleeveRight=isUnderCurve(co, vec2(-0.61,-0.7), vec2(-0.43,-0.24), -0.18);\n    isSleeveRight*=1.0-isUnderCurve(co, vec2(-0.48,-0.8), vec2(-0.4,-0.5), 0.02);\n    isSleeveRight*=step(-0.7,co.y);\n    isSleeveRight*=step(co.y, 0.0);\n    col=mix(col, COLOR_STANSHIRT, isSleeveRight);\n    \n    float isSleeveLeft=1.0-isUnderCurve(co, vec2(0.56,-0.7), vec2(0.38,-0.24), 0.18);\n    isSleeveLeft*=isUnderCurve(co, vec2(0.42,-0.8), vec2(0.35,-0.5), 0.02);\n    isSleeveLeft*=step(-0.7,co.y);\n    isSleeveLeft*=step(co.y, 0.0);\n    col=mix(col, COLOR_STANSHIRT, isSleeveLeft);\n    \n    //collar:\n    float isCollar=isUnderCurve(co, vec2(-0.42,-0.23), vec2(0.385,-0.25), -0.6);\n    isCollar*=1.-isUnderCurve(co, vec2(-0.5,-0.28), vec2(0.45,-0.30), -0.6);\n    col=mix(col, COLOR_STANRED, isCollar);\n    \n    //arms borders:\n    col=mix(col, COLOR_BLACK, isOnVtCurve(co, vec2(0.36,-0.52), vec2(0.4,-0.7), 0.0, 0.001)); //left arm\n    col=mix(col, COLOR_BLACK, isOnVtCurve(co, vec2(-0.41,-0.52), vec2(-0.45,-0.7), 0.0, 0.001));//right arm\n    \n    //zip:\n    col=mix(col, COLOR_BLACK, isOnVtCurve(co, vec2(0.01,-0.4), vec2(-0.01,-0.86), 0.0, 0.004));\n    \n    //buttons:\n    col=mix(col, COLOR_BLACK, isInCircle(co, vec2(-0.06, -0.51), 0.018));\n    col=mix(col, COLOR_BLACK, isInCircle(co, vec2(-0.062, -0.65), 0.018));\n    col=mix(col, COLOR_BLACK, isInCircle(co, vec2(-0.065, -0.78), 0.018));\n    \n    //gloves:\n    col=mix(col, COLOR_STANRED, isInCircle(co, vec2(-0.51, -0.7), 0.095)); //right\n    col=mix(col, COLOR_STANRED, isInCircle(co, vec2(0.48, -0.715), 0.095)); //left\n    \n    //thumbs:\n    col=mix(col, COLOR_BLACK, isInCircle(co, vec2(-0.45, -0.65), 0.042)); //right contour\n    col=mix(col, COLOR_STANRED, isInCircle(co, vec2(-0.45, -0.65), 0.035)); //right\n    \n    col=mix(col, COLOR_BLACK, isInCircle(co, vec2(0.4, -0.69), 0.042)); //left contour\n    col=mix(col, COLOR_STANRED, isInCircle(co, vec2(0.4, -0.69), 0.035)); //left contour\n    \n    //feet:\n    float isFootLeft=isUnderCurve(co, vec2(-0.05,-0.98), vec2(0.47,-0.98), 0.2);\n    isFootLeft*=step(-0.98, co.y)*step(co.x,0.47)*step(-0.05,co.x)*step(co.y, -0.9);\n    col=mix(col, COLOR_BLACK, isFootLeft);\n    \n    float isFootRight=1.-isUnderCurve(co, vec2(0.05,-0.98), vec2(-0.47,-0.98), -0.2);\n    isFootRight*=step(-0.98, co.y)*step(co.x,0.05)*step(-0.47,co.x)*step(co.y, -0.9);\n    col=mix(col, COLOR_BLACK, isFootRight);\n    \n    \n    \n    //HEAD:\n    \n    //head skin:\n    col=mix(col, COLOR_SKIN, isInCircle(co, vec2(0.0,0.20), 0.62));\n    \n    //hat:\n    float isHat=isInCircle(co, vec2(0.0,0.22), 0.635);\n    isHat*=1.-isUnderCurve(co, vec2(-0.63,0.38), vec2(0.63,0.38), 0.3);\n    col=mix(col, COLOR_STANBLUE, isHat);\n    \n    float isHatBand=isUnderCurve(co, vec2(-0.63,0.39), vec2(0.63,0.39), 0.3);\n    isHatBand*=1.-isUnderCurve(co, vec2(-0.63,0.26), vec2(0.63,0.26), 0.3);\n    isHatBand*=isInRect(co, vec2(0.,0.26), vec2(1.26, 1.0));\n    col=mix(col, COLOR_STANRED, isHatBand);\n    \n    //pompom:\n    col=mix(col, COLOR_STANRED, isInCircle(co, vec2(-0.05,0.85), 0.13));\n    \n    //mouth\n    col=mix(col, COLOR_BLACK, isOnHztCurve(co, vec2(-0.1,-0.28), vec2(0.1,-0.28), 0.09, 0.001));\n    \n    //right eye iris:\n    col=mix(col, COLOR_WHITE, isInEllipse(co, vec2(-0.17,0.14), vec2(0.2,0.16), -0.9));\n    //left eye iris:\n    col=mix(col, COLOR_WHITE, isInEllipse(co, vec2(0.17,0.14), vec2(0.2,0.16), 0.9));\n    //right eye pupil:\n    col=mix(col, COLOR_BLACK, isInCircle(co, vec2(-0.10,0.13), 0.02));\n    //left eye pupil:\n    col=mix(col, COLOR_BLACK, isInCircle(co, vec2(0.10,0.13), 0.02));\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //viewport coord, between -1 and 1:\n    vec2 vpCo = 2.0*fragCoord.xy/iResolution.xy - vec2(1.,1.);\n    float aspectRatio=iResolution.x/iResolution.y;\n    \n    //a character is defined in a square, where co goes from -1 to 1\n    vec2 co=vec2(vpCo.x*aspectRatio, vpCo.y);\n    \n    vec2 coAbs=abs(co);\n    if(max(coAbs.x, coAbs.y)>1.0) {\n        discard;\n    }\n\n    vec4 stanCol=drawStan(co);\n\n    fragColor=stanCol;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}