{
    "Shader": {
        "info": {
            "date": "1593182337",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "WtXcWX",
            "likes": 20,
            "name": "Day 189",
            "published": 3,
            "tags": [
                "mograph",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 431
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day whatHHHbbb\" by jeyko. https://shadertoy.com/view/WlsyDj\n// 2020-06-26 10:11:00\n\n// I will rename these eventually!\n// I have no idea what day of my daily challenge it is tho\n\n// Super awesome bayered motion blur from yx https://www.shadertoy.com/view/wsfcWX\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n#define motionBlurSteps 10 + min(0,iFrame)\n\n#define moblur\n\n#define tri(j) asin(sin(j))\n\n#define timeStep (1./60.)\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from iq\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec4 p, in vec4 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,max(p.z,p.w)));\n}\n\n#define pmod(p,j) mod(p - 0.5*(j),(j)) - 0.5*(j)\n\n\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat eass(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n// oh no\n#define smease(p,g) ease(p, 1.5, 1.24, 0.76, 1.)\n \n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nconst float speed = 0.28;\nfloat[] scenes = float[8](4.2*speed,4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed, 4.2*speed); \n\nfloat sumScenes (float cnt){\n\tfloat sum = 0.;\n    for(float i = 0.; i <= cnt; i++){\n    \tsum += scenes[int(i)];\n    }\n    return sum;\n}\n\nvec3 get(vec2 uv, float t){\n\n    vec3 col = vec3(0);\n       \n    float d = 10e6;\n    \n    uv *= 0.85;\n    \n    \n    //t += sumScenes(2.)- 0.2;\n    \n    t = mod(t, sumScenes(7.)  );\n    \n    vec2 triW = vec2(0.2,0.2)*1.;\n    \n    float its = 4.;\n    float scene = 0.;\n    \n    if(t < scenes[0]){\n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[0]*1.,2.);\n\n        float envb = 1.-smease(t/scenes[0]*1.,3.);\n\n        vec4 q = vec4(p,1,1);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        for(float i = 0.; i <= its; i++){\n        \tvec2 b = p;\n            b.y += 0.2*enva;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n        }\n        d = min(d,dt); \n\n        d = abs(d);\n        \n    } else if(t < sumScenes(1.)){\n        scene = 1.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        for(float i = 0.; i <= its; i++){\n        \tvec2 b = p;\n            b.y += 0.2;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q) -envb*0.1,0.1);\n\n        float db = sdBox(q,vec4(0.03));\n\n\n        dt = mix(dt,max(dt,db),enva);\n\n\n        d = min(d,dt); \n\n        //d /= dpp;\n            \n\n    }   else if(t < sumScenes(2.)){\n        scene = 2.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.2 + 0.2*enva;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.+ 0.125*enva,+ 0.125*enva,0,0) ,0.1);\n\n        \n        \n        float db = sdBox(abs(q),vec4(0.03 + 0.01*enva));\n\n\n        dt = mix(dt,max(dt,db),1.);\n\n\n        d = min(d,dt); \n\n        //d /= dpp;\n\n\n    }   else if(t < sumScenes(3.)){\n        scene = 3.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.2,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.2,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        p.xy *= rot(2.*pi*enva);\n        \n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.4 + envother*envb*3. ;\n\t\t\t\n            for(int j = 0; j < 2; j++){\n            \tb *= rot(0.5*pi*enva);\n            \tb = mix(b,abs(b),enva);\n            \tb -= 0.1*enva;\n            }\n            //b.x += 0.2;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n            \n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.125,0.125,0,0) - 0.02*enva,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.5*0.015*enva,0.0)) ,enva);\n        \n\n        dt = mix(dt,max(dt,db),1.);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n\n            \n\n    }     else if(t < sumScenes(4.)){\n        scene = 4.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.2,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.2,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.4;\n\t\t\t\n            for(int j = 0; j < 2; j++){\n            \tb *= rot(0.5*pi);\n            \tb = mix(b,abs(b),1.);\n            \tb -= 0.1; //+ enva*0.1;\n            }\n            b.x -= 0.1*enva;\n            //b.x += 0.2;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n            \n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.125,0.125,0,0) - 0.02,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.0075,0.0)) ,1.);\n        \n\n        dt = mix(dt,max(dt,db),1.);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n            \n\n    }     else if(t < sumScenes(5.)){\n        scene = 5.;\n\t\tt -= sumScenes(scene - 1.);\n       \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.2,2.);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.2,3.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.4;\n\t\t\t\n            for(int j = 0; j < 2; j++){\n            \tb *= rot(0.5*pi - 0.25*pi*enva);\n            \tb = mix(b,abs(b),1.);\n            \tb -= 0.1;\n            }\n            b.x -= 0.1;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n            \n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.125,0.125,0,0) - 0.02,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.0075,0.0)) ,1.);\n        \n\n        dt = mix(dt,max(dt,db),1.);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n               \n\n    } else if(t < sumScenes(6.)){\n        scene = 6.;\n\t\tt -= sumScenes(scene - 1.);\n        \n      \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.1,1.4);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.1,2.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            b.y += 0.4;\n\t\t\t\n            for(int j = 0; j < 2; j++){\n            \tb *= rot(0.25*pi - 0.25*pi*enva);\n            \tb = mix(b,abs(b),1.);\n            \tb -= 0.1;\n            }\n            b.x -= 0.1 - 0.3*enva;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n        \t\n            \n        }\n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q)  - vec4(0.125,0.125,0,0)*(1. - enva)  - 0.02 - 0.02*enva,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.0075,0.0)) ,1.);\n        \n\n        dt = mix(dt,max(dt,db),1.);\n\n        d = min(d,dt); \n\n        //d /= dpp;\n\n    } else if(t < sumScenes(7.)){\n        scene = 7.;\n\t\tt -= sumScenes(scene - 1.);\n        \n        vec2 p = uv;\n\n\n        float enva = smease(t/scenes[int(scene)]*1.1,1.4);\n\n        float envb = 1.-smease(t/scenes[int(scene)]*1.1,2.);\n\n        float envother = smoothstep(0.,1.,enva - dot(uv,uv)/8.);\n \n        vec4 q = vec4(p,1,1);\n\n        q.wz *= rot(0.25*pi);\n        q.wy *= rot(0.25*pi);\n        q.xy *= rot(0.25*pi);\n        \n\t\tfloat dt = 10e5;\n\t\t\n        //p *= rot(0.25*pi*enva);\n        \n        //p = abs(p) - 0.4;\n        for(float i = 0.; i <= its; i++){\n        \t\n            vec2 b = p;\n            \n            b.y += 0.4 - 0.4*enva;\n                \n            //b.y -= 0.*enva;\n\t\t\t\n        \tb *= rot(1.*pi*enva);\n            for(int j = 0; j < 2; j++){\n            \tb = mix(b,abs(b),1. - enva);\n            \tb -= 0.1 - 0.1*enva;\n            }\n            b.x += 0.2 - 0.2*enva ;\n            \n            dt = min(dt,sdTri(b,triW));\n            \n            p *= rot(tau*i/its);\n            \n        }\n        \n        \n        \n        \n        //q = pmod(q,(0.1 ));\n\n        q = pmod(abs(q) - 0.04 ,0.1 );\n\n        \n        float db = sdBox(abs(q),vec4(0.04));\n\n\t\tdt = mix(dt, abs(pmod(dt  + 0.0075,0.0)) ,1. - enva);\n        \n\n        dt = mix(dt,max(dt,db),1. - enva);\n\n        d = min(d,dt); \n\n    }\n    \n    \n    d = abs(d) - 0.001;\n    \n    col = mix(col,vec3(1.),smoothstep(dFdx(uv.x),0.,d));\n    //col = 1. - col;\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    \n    #ifdef moblur\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += get(uv,time);\n    }\n    col/=float(motionBlurSteps);\n    #else\n    col += get(uv,iTime);\n    #endif\n    //col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    //col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    //col = 1. - col;\n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}