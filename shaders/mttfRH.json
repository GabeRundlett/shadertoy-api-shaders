{
    "Shader": {
        "info": {
            "date": "1701794218",
            "description": "Attempt at a 3D volumetric density plot of 4D split quaternion (2D matrix) fractal. Tensor fractal?\nClick & Drag!\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "mttfRH",
            "likes": 11,
            "name": "Matrix Fractal II",
            "published": 3,
            "tags": [
                "fractal",
                "math",
                "4d",
                "orbit",
                "quaternion",
                "matrix",
                "hyperbolic",
                "split",
                "chaotic"
            ],
            "usePreview": 0,
            "username": "domrally",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "/*\nby Dom Mandy in 2023\n*/\n\n\n/*\npastel colors\nhttps://www.shadertoy.com/view/mltyRN\n*/\nvec3 palette(float l, float h) { return l + 1.4 * l * vec3(.7874, .2848, .9278) * cos(h - vec3(0, 2.1, 4.2)); }\n\n\nvoid mainImage(out vec4 pixel, vec2 v) {\n    vec2 i = iResolution.xy;\n    v = (v + v - i) / i.y;\n\n    float t = mix(iTime / 9., -iMouse.x / 180., max(0., sign(iMouse.z)));\n    vec3 ray = normalize(vec3(0, -1, 2)),\n         eye = 1.6 * vec3(v, -1);\n\n    float a = t + atan(eye.z, eye.x),\n          b = t + atan(ray.z, ray.x);\n    eye.xz = length(eye.xz) * vec2(cos(a), sin(a));\n    ray.xz = length(ray.xz) * vec2(cos(b), sin(b));\n    \n    vec3 point = eye;\n    t = 1.6 * .02;\n    float density, k, m = 9.;\n    mat2 M;\n    for (; k++ < 100.; ) {\n        const mat2[4] basis = mat2[](\n            mat2(1),\n            mat2(0, 1, -1, 0),\n            mat2(0, 1, 1, 0),\n            mat2(1, 0, 0, -1)\n        );\n\n        float i, f, d;\n        mat2 F, D = basis[0] + basis[1] + basis[2] + basis[3], C = F = point.y * basis[0] + point.x * basis[2] + point.z * basis[3];\n        C += .5 * cos(iTime / 2.) * basis[1];\n        for (; i++ < 3.;) {\n            D = D * F + F * D;\n            F = F * F + C;\n            if ((f = abs(determinant(F))) > 2.) break;\n            if ((m = min(m, f)) == f) M = F;\n        }\n        vec2 G = log(abs(F[0])),\n             H = log(abs(F[1]));\n\n        point += ray * t;\n        density += 1. / (1. + 999. * smoothstep(0., 2., abs(determinant(mat2(G, H) * F / D))));\n    }\n    float hue = atan(M[0].y, M[0].x);\n\n    pixel.rgb = pow(palette(smoothstep(0., 99., density), hue), vec3(1) / 2.2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}