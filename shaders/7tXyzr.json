{
    "Shader": {
        "info": {
            "date": "1647673474",
            "description": " create a sphere in the 3D world!",
            "flags": 0,
            "hasliked": 0,
            "id": "7tXyzr",
            "likes": 2,
            "name": "sphere! blinn-phone",
            "published": 3,
            "tags": [
                "3d",
                "sphere"
            ],
            "usePreview": 0,
            "username": "fl0a1e",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "// ----------------------------------------------------\n// my 2nd shader!\n// I'll create a 3D sphere in this shader\n// and i'll use a simple light shading on the surface.\n// refer to iq!\n// \n// you can learn more in below project:\n// https://www.shadertoy.com/view/Xl2XWt\n//\n// or\n// https://www.shadertoy.com/view/Xds3zN\n//\n// about texture\n// https://www.shadertoy.com/view/sdj3Rc\n//\n// how amazing the raymarching is!\n// -----------------------------------------------------\n\n\n\n\n// PI\n// SSAA\n// GAMMA\n// focal length\n#define PI 3.1415926\n#define AA 2\n#define INV_GAMMA 0.454545\n#define FOCAL  3.5f      \n\n// p is the point in 3D world\nfloat sdSphere(in vec3 p, in float r){\n    return length(p)-r;\n}\n\n\n// return minimum distance to surface\nfloat map(in vec3 pos){\n    float res = sdSphere( pos-vec3(0.0, 0.0, 0.0), 0.1);\n    return res;\n}\n\n\n\n// return distance to surface of each ray\nfloat raycast(in vec3 cameraPos, in vec3 rayDir) {\n    float res = -1.0;\n    \n    // minimum and maximum distance ray traveled\n    float minDist =1.0;\n    float maxDist = 30.0;\n    \n    // raymarching\n    float dist = minDist;\n    for(int i = 0; i < 40 && dist < maxDist; i++) {   // \"i\" means the frequency of sphere tracking.\n    \n        float temp = map(cameraPos + rayDir * dist);\n        if( abs(temp) < 0.0001 ) {    // if close enough to the surface\n            res = dist;\n            break;\n        }\n        dist += temp; // Sphere Tracking, so we need to add minimum distance to Surface for speed up function.\n    }\n    return res;\n}\n\n\n// light shader need normal.\n// calculate normal by using gradient.\n// but here I use the function from iq\n// https://www.shadertoy.com/view/Xds3zN\n// inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\nvec3 calcNormal(in vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n      \n    }\n    return normalize(n);\n}\n\n\nvec3 render(in vec3 cameraPos, in vec3 rayDir, in vec2 uv) {\n    \n    vec3 col;\n    \n    // raycast scene(raymarching!)\n    float res = raycast(cameraPos, rayDir);\n    \n    // render sphere\n    if(res > 0.){\n        \n        vec3 pos = cameraPos + rayDir * res;\n        vec3 nor = calcNormal(pos);    // normal\n        \n        // blinn phong\n        {\n        vec3 sunPos = vec3(15.0 * cos(iTime), 15.0, 10.0 * sin(iTime));\n        \n        \n        // texture    \n        vec2 polarUV = vec2(atan(pos.x*800., pos.z*450.)/PI, 4.*pos.y);\n        vec3 t = texture(iChannel0, polarUV).rgb;\n        \n        \n        vec3 ambientColor = 2.* t;\n        vec3 diffuseColor = 2.* t;\n        vec3 specColor = vec3(0.5, 0.5, 0.5);\n        vec3 lightColor = vec3(1.0, 1.0, 1.0);\n        vec3 lightDir =  normalize(sunPos - pos);\n        float lambertian = max(dot(lightDir, nor), 0.0);\n        float shininess = 16.0;\n        float specular = 0.0;\n        float lightPower = 15.0;\n        \n        \n        vec3 halfDir = normalize(lightDir - rayDir);\n        float specAngle = max(dot(halfDir, nor), 0.0);\n        specular = pow(specAngle, shininess);\n        \n        \n        col = ambientColor +\n              diffuseColor * lambertian * lightColor * lightPower / length(sunPos - pos)*length(sunPos - pos) +\n              specColor * specular * lightColor * lightPower / length(sunPos - pos)*length(sunPos - pos);\n        }\n        \n    } else {\n        // background\n        col = vec3(0.01);\n    }\n    return col;\n}\n\n\n\n// create our camera!\n// each parameter means:ray origin, target and camera rotation\n// \n// I think that it's so-called \"billboard\". \n// we can calculate the coordinates centered on our camera.\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr) {\n    vec3 cw = normalize(ta - ro); // the direction our camera watched\n    // calculate the x&y-axis centered on camera.\n    vec3 cu= normalize( cross(cw,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 cv=          ( cross( cu, cw ) );  \n\n    return mat3(cu, cv, cw);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot;\n    \n    // init camera\n    // Attention, z-axis points out of the screen!\n    vec3 cameraPos = vec3(3.*sin(iTime), 0.5, 3.0*cos(iTime));\n    // camera orientation\n    vec3 cameraOrit = vec3(0., 0., 0.2);\n    // create camera\n    // camera-to-world transformation\n    mat3 camera = setCamera(cameraPos, cameraOrit, 0.);\n    \n    // SSAA\n    // get uv for each pixel\n    #if AA > 1\n    for(int i = 0; i < AA; i++)\n    for(int j = 0; j < AA; j++){\n        \n        vec2 offset = (vec2(i,j)/float(AA)) - 0.5;\n        vec2 uv = ((fragCoord+offset)-0.5*iResolution.xy)/iResolution.x;\n    \n    #else \n        vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    #endif\n        \n        // ray direction\n        vec3 rayDir = camera * normalize( vec3(uv,FOCAL) );\n        \n        // render our world\n        // return color of each pixel\n        vec3 col = render(cameraPos, rayDir, uv);\n        \n        // gamma\n        col = pow( col, vec3(INV_GAMMA) );\n        \n        tot += col;\n        \n    \n    #if AA > 1\n        tot /= float(AA*AA);\n    }\n    #endif\n    \n    \n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}