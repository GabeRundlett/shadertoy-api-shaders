{
    "Shader": {
        "info": {
            "date": "1522697351",
            "description": "Continued the concept in my speedshading. Still a simple effect, but much nicer looking. Antialiasing is done by picking samples in a line that is oriented orthogonally to the spike pattern, thus getting good effect for relatively few samples.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVcRV",
            "likes": 5,
            "name": "Spiky zoom",
            "published": 3,
            "tags": [
                "2d",
                "zoom",
                "antialiasing"
            ],
            "usePreview": 0,
            "username": "NohatCoder",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "float rnd(float a, float i, float arms){\n    //const float arms=20.;\n    float i1=mod(floor(a*arms),arms)+mod(i*12.672,2236.77621);\n    float i2=mod(floor(a*arms+1.),arms)+mod(i*12.672,2236.77621);\n\n    float i11=mod(cos(i1*mod(i1,3.)*.00632)*356.9,1.);\n    float i22=mod(cos(i2*mod(i2,3.)*.00632)*356.9,1.);\n    float span=mod(a*arms,1.);\n    return i22*span+i11*(1.-span);\n}\n\nvec3 col(float i){\n    if(cos(i*i)<-.98){\n        return (1.+cos(acos(-1.)*vec3(mod(cos(i*.045621)*2341.,1.),mod(cos(i*.085601)*2311.,1.),mod(cos(i*.049691)*2141.,1.))))*.5;\n    }\n    else{\n        float phase=mod(floor(i/20.),3.);\n        float mixx=mod(i,20.)/20.;\n        vec3 c1;\n        vec3 c2;\n        if(phase<.5){\n            c1=vec3(0.,0.,0.);\n            c2=vec3(1.,0.6,0.);\n        }\n        else if(phase<1.5){\n            c1=vec3(1.,0.6,0.);\n            c2=vec3(0.,0.3,1.);\n        }\n        else{\n            c1=vec3(0.,0.3,1.);\n            c2=vec3(0.,0.,0.);\n        }\n        return c1*(1.-mixx)+c2*mixx;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.yy;\n    \n    // Output to screen\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    float angle=atan(uv.y,uv.x)/acos(-1.)/2.;\n    \n    float layer=floor(iTime/2.);\n    float zoom=mod(iTime/2.,1.);\n    float pixelsize=1./iResolution.y;\n    float stepsclose=floor(log(length(uv))/log(1.2));\n    float aa;\n    for(aa=1.;aa<14.;aa++){\n        float a=aa+stepsclose;\n        float zooma=pow(1.2,a+zoom);\n        vec2 uvzoom=uv/zooma;\n        float bend=.6-length(uvzoom);\n        float pixelsize2=pixelsize/length(uv)*.05;\n        float angle2=mod(angle+bend*bend*bend*bend*.4*sin((a-layer)*.3+iTime),1.);\n        float b;\n        float cover=0.;\n        for(b=-2.;b<=2.;b++){\n            float h=rnd(mod(angle2+b*pixelsize2,1.),a-layer,floor(60.*(1.2+sin(0.0774*(a-layer)))))*.5+.1;\n            if(h<length(uvzoom)){\n                cover+=0.2;\n                //fragColor = vec4(vec3(a+zoom)*.02+.2,1.0);\n            }\n        }\n        fragColor = vec4(col(a-layer),1.0)*cover+fragColor*(1.-cover);\n    }\n\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}