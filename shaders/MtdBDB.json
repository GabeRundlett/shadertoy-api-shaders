{
    "Shader": {
        "info": {
            "date": "1541094820",
            "description": "Super simplified fluid algorithm based on kinetic theory. See code for an explanation.\nAll the physics is summed up in 4 lines. Evolves rapidly at 60fps even in full screen",
            "flags": 32,
            "hasliked": 0,
            "id": "MtdBDB",
            "likes": 70,
            "name": "Rapidly Evolving Fluid",
            "published": 3,
            "tags": [
                "fluid",
                "dynamics",
                "physics"
            ],
            "usePreview": 0,
            "username": "wyatt",
            "viewed": 2042
        },
        "renderpass": [
            {
                "code": "/*  Hello! Let me try to explain how this works.\n\tIt took me a long time to undertand this stuff\n\tso bare with me.\n\t\n\tLets start with the ideal gass law:\n\tPV = nRT\n\tTemperature is actually the kinetic energy of particles\n\tSo without really getting into it, nRT is the total KE of the system\n\tSo that means PV equals the kinetic energy of a system\n\n\tWe could arrive at this conclusion in another way as well\n\n\tP = F/A         (Pressure is force per area)\n\tP = F/A * d/d   (here we multiply by 1 in the form of another spacial dimension)\n\tP = F*d / V     (Area * Length = Volume)\n\tP = E / V\t\t(Force * distance = Work)\n\tPV = E  --> P = E/V\n\t\n\tSo, it follows that pressure is kinetic energy per volume\n\t\n\tSo lets think of any fluid as a large sum of particles\n\tthat are continuously banging into each other.\n\tHow can you possibly keep track of all that?!\n\tWell, we can represent different forms of kinetic energy.\n\tSpecifically chaotic kinetic energy and ordered kinetic energy\n\n\tso we have 4 channels to work with, so we could have :\n\nr(x)\tx direction KE\ng(y)\ty direction KE\nb(z)\tand chaotic KE (which is pressure)\na(w)\tink to move around\n\n\tSince the medium is moving though itself, any time we\n\twant to find out about one of these values, we\n\thave to look them up where they used to be.\n\n\tSo if I am a pixel and I want to know about my state\n\tI have to look up the velocity where I am and then\n\tsubtract it from my current location to make a good\n\tguess of where I was last. In code this looks like this:\n\n\tU = my position\n\tT(U).xy = velocity where I am now\n\tU - T(U).xy = where I probably was last\n\t\n\tNow we want to find out how my pressure (which is\n\talso my internal kinetic energy) has changed since\n\tthe last state of the fluid.\n\n\tSince the last time we knew the state of the\n\tfluid, each part of the fluid as interacted with its\n\tneighbors. When one region of space interacts with\n\tanother, it is kind of like they collided with each\n\tother. Their energies talk to each other in three\n\tsignificant ways : \n\t\n1.\tOrdered energy is lost to chaos: A change in \n\t\tthe separation between two regions\n\t\tcorresponds to a linear change in volume.\n\t\tA linear change in volume corresponds to a\n\t\tlinear change in pressure.\n\n2.  The two regions completely exchange pressure.\n\t \tThink of this as two billiards balls smacking \n\t\ttogether and trading energies. Or like energy\n\t\ttraversing a newton's cradle. Remember, pressure\n\t\tis actually kinetic energy per volume.\n\n3.  Chaotic energy is converted into ordered energy.\n\t\tThe space accelerates in the direction of the\n\t\tgradient of pressure. Theres are a lot of ways\n\t\tto think about this : \n\t\n\t\t\ta. A particle sliding down an energy wave\n\n\t\t\tb. The gradient of energy is a force\n\n\t\t\tc. Pressure is like pushing outwards, \n\t\t\t\tif you have an uneven push, there \n\t\t\t\twill be an acceleration. \n\n\t\nConclusion : \n\t\n-\tThe space moves each frame according to the ordered\n\tenergy in the space. Ordered energy makes change!\n\n-\tSome ordered energy is lost to chaos when the the\n\tgeometry of the space is strained.\n\n-\tDirectional changes in chaos turn into ordered energy\n\n-\tChaos is continuously traded around like a hot potato\n\t\n\t\nSee Buffer A,B,C, or D and see the function \"X\"\n\tto see how this looks in code!\n\n\n\n:D Wyatt\n\n*/\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    U = U/iResolution.xy;\n    vec4 g = texture(iChannel0,U,1.);\n   \tC.xyz = cos(.5-3.*g.w*vec3(1,2,3));\n    C = C*sqrt(max(C,0.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 R;float N;// R is resolution, N is number of samples\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);}//Samples previous field state\nfloat X (vec2 U0, vec2 U, vec2 U1, inout vec4 Q, in vec2 r) {\n    vec2 V = U + r, u = T(V).xy,\n         V0 = V - u,\n         V1 = V + u;\n    float P = T (V0).z, rr = length(r);\n    Q.xy -= r*(P-Q.z)/rr/N;\n    return (0.5*(length(V0-U0)-length(V1-U1))+P)/N;\n    /* This is the interaction function\n\t\tU1 is my current position\n\t\tU is my previous position\n\t\tQ is my previous state\n\t\tr is the relativity between me and my neighbor\n    \tV1 is my neighbor's current position\n\t\tV is my neighbor's previous position\n\t\tP is my neighbors pressure\n\t\tQ.z is my previous pressure\n\t\trr is the distance between me and my neighbor\n\t\tr*(P-Q.z)/rr/N is this interaction's contribution\n\t\t\tto the my velocity. It is the gradient of\n\t\t\tthe pressure between me and my neighbor\n\t\tlength(V0-U0)-length(V1-U1) is the space contraction between\n\t\t\tthe next and the previous state. Because pressure\n\t\t\tis energy per volume. If the volume contracts\n\t\t\tthere must be a higher energy density. If\n\t\t\tthe space expands, the energy is disipated\n\t\t\tover a larger area.\n\t\tI add P because I completely trade pressures \n\t\t\twith my neighbors. This is why the best\n\t\t\tsampling patterns are like checkerboards.\n\t\t\tevery other point in space should interact\n\t\t\tso that there is a feedback system.\n\t\t\tThe physical explanation of this is that\n\t\t\tthe fluid is kind of like many billiards\n\t\t\tballs. When two billiards balls collide,\n\t\t\tthey completely swap energies.\n\t\tI divide the outputs by N to average each interaction.\n    */\n}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 U0 = U - T(U).xy, // get previous state\n         U1 = U + T(U).xy; // get next state\n \tfloat P = 0.; Q = T(U0);\n \tN = 4.;// checkerboard sampling pattern\n    P += X (U0,U,U1,Q, vec2( 1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0,-1) );\n \tP += X (U0,U,U1,Q, vec2(-1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0, 1) );\n \tQ.z = P;\n \t\n \t// Init and Walls\n \tif (iFrame < 1) Q = vec4(0);\n    if (U.x < 1.||U.y < 1.||R.x-U.x < 1.||R.y-U.y < 1.) Q.xy *= 0.;\n    //This Jet setup will cause pressure to always increase in the system\n \tif (length(U-vec2(0,0.5*R.y)) < 4.) {Q.xy= Q.xy*.9+.1*vec2(.5,0);; Q.w = 1.;}\n    if (length(U-vec2(R.x,0.5*R.y)) < 4.) {Q.xy= Q.xy*.9+.1*vec2(-.5,0);; Q.w = 1.;}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 R;float N;// R is resolution, N is number of samples\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);}//Samples previous field state\nfloat X (vec2 U0, vec2 U, vec2 U1, inout vec4 Q, in vec2 r) {\n    vec2 V = U + r, u = T(V).xy,\n         V0 = V - u,\n         V1 = V + u;\n    float P = T (V0).z, rr = length(r);\n    Q.xy -= r*(P-Q.z)/rr/N;\n    return (0.5*(length(V0-U0)-length(V1-U1))+P)/N;\n    /* This is the interaction function\n\t\tU1 is my current position\n\t\tU is my previous position\n\t\tQ is my previous state\n\t\tr is the relativity between me and my neighbor\n    \tV1 is my neighbor's current position\n\t\tV is my neighbor's previous position\n\t\tP is my neighbors pressure\n\t\tQ.z is my previous pressure\n\t\trr is the distance between me and my neighbor\n\t\tr*(P-Q.z)/rr/N is this interaction's contribution\n\t\t\tto the my velocity. It is the gradient of\n\t\t\tthe pressure between me and my neighbor\n\t\tlength(V0-U0)-length(V1-U1) is the space contraction between\n\t\t\tthe next and the previous state. Because pressure\n\t\t\tis energy per volume. If the volume contracts\n\t\t\tthere must be a higher energy density. If\n\t\t\tthe space expands, the energy is disipated\n\t\t\tover a larger area.\n\t\tI add P because I completely trade pressures \n\t\t\twith my neighbors. This is why the best\n\t\t\tsampling patterns are like checkerboards.\n\t\t\tevery other point in space should interact\n\t\t\tso that there is a feedback system.\n\t\t\tThe physical explanation of this is that\n\t\t\tthe fluid is kind of like many billiards\n\t\t\tballs. When two billiards balls collide,\n\t\t\tthey completely swap energies.\n\t\tI divide the outputs by N to average each interaction.\n    */\n}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 U0 = U - T(U).xy, // get previous state\n         U1 = U + T(U).xy; // get next state\n \tfloat P = 0.; Q = T(U0);\n \tN = 4.;// checkerboard sampling pattern\n    P += X (U0,U,U1,Q, vec2( 1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0,-1) );\n \tP += X (U0,U,U1,Q, vec2(-1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0, 1) );\n \tQ.z = P;\n \t\n \t// Init and Walls\n \tif (iFrame < 1) Q = vec4(0);\n    if (U.x < 1.||U.y < 1.||R.x-U.x < 1.||R.y-U.y < 1.) Q.xy *= 0.;\n    //This Jet setup will cause pressure to always increase in the system\n \tif (length(U-vec2(0,0.5*R.y)) < 4.) {Q.xy= Q.xy*.9+.1*vec2(.5,0);; Q.w = 1.;}\n    if (length(U-vec2(R.x,0.5*R.y)) < 4.) {Q.xy= Q.xy*.9+.1*vec2(-.5,0);; Q.w = 1.;}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 R;float N;// R is resolution, N is number of samples\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);}//Samples previous field state\nfloat X (vec2 U0, vec2 U, vec2 U1, inout vec4 Q, in vec2 r) {\n    vec2 V = U + r, u = T(V).xy,\n         V0 = V - u,\n         V1 = V + u;\n    float P = T (V0).z, rr = length(r);\n    Q.xy -= r*(P-Q.z)/rr/N;\n    return (0.5*(length(V0-U0)-length(V1-U1))+P)/N;\n    /* This is the interaction function\n\t\tU1 is my current position\n\t\tU is my previous position\n\t\tQ is my previous state\n\t\tr is the relativity between me and my neighbor\n    \tV1 is my neighbor's current position\n\t\tV is my neighbor's previous position\n\t\tP is my neighbors pressure\n\t\tQ.z is my previous pressure\n\t\trr is the distance between me and my neighbor\n\t\tr*(P-Q.z)/rr/N is this interaction's contribution\n\t\t\tto the my velocity. It is the gradient of\n\t\t\tthe pressure between me and my neighbor\n\t\tlength(V0-U0)-length(V1-U1) is the space contraction between\n\t\t\tthe next and the previous state. Because pressure\n\t\t\tis energy per volume. If the volume contracts\n\t\t\tthere must be a higher energy density. If\n\t\t\tthe space expands, the energy is disipated\n\t\t\tover a larger area.\n\t\tI add P because I completely trade pressures \n\t\t\twith my neighbors. This is why the best\n\t\t\tsampling patterns are like checkerboards.\n\t\t\tevery other point in space should interact\n\t\t\tso that there is a feedback system.\n\t\t\tThe physical explanation of this is that\n\t\t\tthe fluid is kind of like many billiards\n\t\t\tballs. When two billiards balls collide,\n\t\t\tthey completely swap energies.\n\t\tI divide the outputs by N to average each interaction.\n    */\n}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 U0 = U - T(U).xy, // get previous state\n         U1 = U + T(U).xy; // get next state\n \tfloat P = 0.; Q = T(U0);\n \tN = 4.;// checkerboard sampling pattern\n    P += X (U0,U,U1,Q, vec2( 1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0,-1) );\n \tP += X (U0,U,U1,Q, vec2(-1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0, 1) );\n \tQ.z = P;\n \t\n \t// Init and Walls\n \tif (iFrame < 1) Q = vec4(0);\n    if (U.x < 1.||U.y < 1.||R.x-U.x < 1.||R.y-U.y < 1.) Q.xy *= 0.;\n    //This Jet setup will cause pressure to always increase in the system\n \tif (length(U-vec2(0,0.5*R.y)) < 4.) {Q.xy= Q.xy*.9+.1*vec2(.5,0);; Q.w = 1.;}\n    if (length(U-vec2(R.x,0.5*R.y)) < 4.) {Q.xy= Q.xy*.9+.1*vec2(-.5,0);; Q.w = 1.;}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 R;float N;// R is resolution, N is number of samples\nvec4 T ( vec2 U ) {return texture(iChannel0,U/R);}//Samples previous field state\nfloat X (vec2 U0, vec2 U, vec2 U1, inout vec4 Q, in vec2 r) {\n    vec2 V = U + r, u = T(V).xy,\n         V0 = V - u,\n         V1 = V + u;\n    float P = T (V0).z, rr = length(r);\n    Q.xy -= r*(P-Q.z)/rr/N;\n    return (0.5*(length(V0-U0)-length(V1-U1))+P)/N;\n    /* This is the interaction function\n\t\tU1 is my current position\n\t\tU is my previous position\n\t\tQ is my previous state\n\t\tr is the relativity between me and my neighbor\n    \tV1 is my neighbor's current position\n\t\tV is my neighbor's previous position\n\t\tP is my neighbors pressure\n\t\tQ.z is my previous pressure\n\t\trr is the distance between me and my neighbor\n\t\tr*(P-Q.z)/rr/N is this interaction's contribution\n\t\t\tto the my velocity. It is the gradient of\n\t\t\tthe pressure between me and my neighbor\n\t\tlength(V0-U0)-length(V1-U1) is the space contraction between\n\t\t\tthe next and the previous state. Because pressure\n\t\t\tis energy per volume. If the volume contracts\n\t\t\tthere must be a higher energy density. If\n\t\t\tthe space expands, the energy is disipated\n\t\t\tover a larger area.\n\t\tI add P because I completely trade pressures \n\t\t\twith my neighbors. This is why the best\n\t\t\tsampling patterns are like checkerboards.\n\t\t\tevery other point in space should interact\n\t\t\tso that there is a feedback system.\n\t\t\tThe physical explanation of this is that\n\t\t\tthe fluid is kind of like many billiards\n\t\t\tballs. When two billiards balls collide,\n\t\t\tthey completely swap energies.\n\t\tI divide the outputs by N to average each interaction.\n    */\n}\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 U0 = U - T(U).xy, // get previous state\n         U1 = U + T(U).xy; // get next state\n \tfloat P = 0.; Q = T(U0);\n \tN = 4.;// checkerboard sampling pattern\n    P += X (U0,U,U1,Q, vec2( 1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0,-1) );\n \tP += X (U0,U,U1,Q, vec2(-1, 0) );\n \tP += X (U0,U,U1,Q, vec2( 0, 1) );\n \tQ.z = P;\n \t\n \t// Init and Walls\n \tif (iFrame < 1) Q = vec4(0);\n    if (U.x < 1.||U.y < 1.||R.x-U.x < 1.||R.y-U.y < 1.) Q.xy *= 0.;\n    //This Jet setup will cause pressure to always increase in the system\n \tif (length(U-vec2(0,0.5*R.y)) < 4.) {Q.xy= Q.xy*.9+.1*vec2(.8,0);; Q.w = 1.;}\n    if (length(U-vec2(R.x,0.5*R.y)) < 4.) {Q.xy= Q.xy*.9+.1*vec2(-.8,0);; Q.w = 1.;}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}