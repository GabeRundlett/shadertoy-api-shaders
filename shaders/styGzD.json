{
    "Shader": {
        "info": {
            "date": "1637244928",
            "description": "\"Texture Generation with Ultra-Compact Neural Cellular Automata\" supplementary material\nNCA-588 rule generating \"Mondrian\" pattern.\nSee \"Buffer A\" for perception code and \"Buffer B\" for the update rule.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "styGzD",
            "likes": 9,
            "name": "micro Texture NCA (588 params)",
            "published": 3,
            "tags": [
                "ca"
            ],
            "usePreview": 0,
            "username": "Anony",
            "viewed": 829
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int W = int(iResolution.x) / 3;\n    vec2 p = fragCoord.yx;\n    p /= 2.0;\n    p.x = mod(p.x, float(W));\n \n    fragColor = texture(iChannel0, p/iResolution.xy)+0.5;\n    //fragColor = texture(iChannel1, fragCoord.xy/iResolution.xy)+0.5;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Perception phase\n\nint W;\nint band;\nivec2 pos;\n\nvec4 R(int dx, int dy) {\n    vec2 p = vec2((pos.x+dx+W)%W+W*band, pos.y+dy);\n    return texture(iChannel0, (p+0.5)/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    W = int(iResolution.x) / 3;\n    pos = ivec2(fragCoord.xy);\n    band = pos.x / W;\n    pos.x %= W;\n    \n    vec4 prev = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    if (band == 2) {\n        fragColor = R(-1, 1)+R(-1, 0)*2.0+R(-1,-1)\n                   -R( 1, 1)-R( 1, 0)*2.0-R( 1,-1);\n    } else if (band == 1) {\n        fragColor = R( 1, 1)+R( 0, 1)*2.0+R(-1, 1)\n                   -R( 1,-1)-R( 0,-1)*2.0-R(-1,-1);\n    } else {\n        fragColor = R(1,1)+R(1,-1)+R(-1,1)+R(-1,-1)\n              +2.0*(R(0,1)+R(0,-1)+R(1,0)+R(-1,0))-12.0*R(0, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Update phase\n\nvec4 update(float band, vec4 y[6]) {\n  #define M mat4\n  #define F(i,_a,_b) {M a=_a,b=_b; vec4 yi=y[i]; dx+=G(0)+G(1)+G(2)+G(3);}\n  //#define G(i) yi[i]*((yi[i]>0.0)?a[i]:b[i])\n  #define G(i) (yi[i]*a[i]+abs(yi[i])*b[i])\n  vec4 dx;\n  if (band == 0.) { dx = vec4(17,3,-17,15);\n    F(0, M(-32,13,-9,20,-3,-58,6,27,2,21,-39,-5,-10,-9,4,-41), M(11,14,2,-34,-1,6,51,-26,-9,-41,-15,-19,9,14,9,-3));\n    F(1, M(6,-1,-5,4,-5,4,-1,5,-12,13,15,26,0,4,0,0), M(-16,-8,-10,4,1,13,18,-3,-6,-2,-2,3,14,-9,-7,-19));\n    F(2, M(-3,8,7,7,12,-4,-7,-11,2,-2,-5,1,-2,-2,-2,0), M(-7,-12,-8,0,-11,2,4,12,-17,2,21,10,12,3,4,-10));\n    F(3, M(23,4,-1,6,-24,11,0,4,7,-1,14,0,-4,8,-4,40), M(2,-1,0,-7,-3,2,0,2,2,1,0,10,11,10,10,-10));\n    F(4, M(-12,-17,-14,-13,6,7,7,-1,19,17,10,14,4,11,8,10), M(-4,-7,-8,3,-4,6,6,-1,3,0,-6,7,-3,-1,0,-5));\n    F(5, M(10,14,12,13,-9,-16,-13,-12,5,3,5,-9,-9,-15,-16,6), M(-1,-1,1,-3,-12,-8,-7,6,-13,0,3,0,4,4,5,5));\n  } else if (band == 1.) { dx = vec4(12,0,-2,-7);\n    F(0, M(-10,15,11,-2,6,21,-1,12,18,9,-10,16,-27,-12,-3,19), M(-13,16,-21,4,-5,-23,-3,5,-13,-38,-6,19,2,23,2,9));\n    F(1, M(-81,11,10,11,-6,-70,2,11,21,12,-52,-2,24,-7,-10,-68), M(0,1,-6,-7,20,3,24,15,-12,-6,-4,0,15,-10,-16,8));\n    F(2, M(-3,7,-7,5,12,0,18,0,-7,-12,2,-6,-8,15,2,-6), M(10,-4,29,-2,8,0,13,1,-5,14,12,-5,-15,16,-26,1));\n    F(3, M(-2,4,4,2,4,4,3,2,7,-1,-3,5,0,2,16,4), M(0,-3,-2,-1,4,-1,2,1,1,3,1,2,-3,-5,-3,3));\n    F(4, M(-21,-5,-19,-13,-1,-24,8,2,-10,11,33,-1,-9,2,-1,7), M(2,2,1,-2,-3,-3,17,24,-4,-2,2,-2,10,-6,1,-6));\n    F(5, M(2,10,2,2,-12,2,-18,-8,5,-6,3,7,-8,-7,0,0), M(-1,-1,3,1,-5,0,-9,-1,-7,8,-2,-4,-3,4,-1,-4));\n  } else { dx = vec4(-18,9,-2,27);\n    F(0, M(22,-20,17,19,13,-14,-9,7,-4,-4,-15,-2,-4,9,-16,19), M(0,-28,-6,-12,23,-30,-3,5,-3,37,41,-2,16,-6,-21,3));\n    F(1, M(-4,-1,-2,-3,3,-8,-1,-14,-6,-15,-11,10,1,-11,-15,-2), M(-9,1,-1,-16,3,11,-4,1,9,-2,-21,-11,0,-8,17,11));\n    F(2, M(-63,26,2,10,-22,-56,7,4,3,-8,-60,6,0,-2,-2,-66), M(-2,-17,-9,-20,-6,-3,-16,-13,-26,-25,-9,7,23,-9,0,-7));\n    F(3, M(7,1,2,5,3,3,-4,5,-1,0,-9,-2,9,18,-1,0), M(1,0,1,2,0,3,1,2,-4,-1,-5,-1,4,0,-4,2));\n    F(4, M(-7,3,16,-12,4,6,-8,4,7,1,-11,10,11,2,-10,12), M(-6,1,4,-9,-2,6,-4,1,15,5,6,5,-1,2,0,-3));\n    F(5, M(24,7,-6,-3,-12,-30,10,0,-4,1,4,14,-6,4,4,-31), M(-7,4,0,10,16,4,1,-8,-7,-3,-10,-6,15,5,4,3));\n  }\n  #undef M\n  #undef F\n  #undef G\n  return dx/500.0;\n}\n\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float W = floor(iResolution.x / 3.);\n    vec2 pos = fragCoord.xy;\n    pos.x = mod(pos.x, W);\n    float band = floor(fragCoord.x / W);\n    \n    if(iFrame==0) {\n      fragColor = hash43(vec3(fragCoord, iFrame))-0.5;\n      return;\n    }\n    \n    vec4 y[6];\n    for (int i=0; i<3; ++i) {\n      vec2 p = vec2(pos.x+W*float(i), pos.y)/iResolution.xy;\n      y[i] = texture(iChannel1, p);\n      y[3+i] = texture(iChannel0, p);\n      \n    }\n    vec4 x = (band==0.) ? y[0] : ((band==1.) ? y[1] : y[2]);\n    vec4 dx = update(band, y);\n\n    //vec4 mask = floor(hash43(vec3(fragCoord, iFrame)) + 0.5);\n    fragColor = clamp(x + dx, -1.5, 1.5);//*mask;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}