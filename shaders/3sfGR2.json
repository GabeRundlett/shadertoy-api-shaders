{
    "Shader": {
        "info": {
            "date": "1549033565",
            "description": "Two series of non-convex uniform polyhedra.\n\n't' to change series\n'd' for duals\n's' for snubs",
            "flags": 16,
            "hasliked": 0,
            "id": "3sfGR2",
            "likes": 12,
            "name": "Some Non-Convex Polyhedra",
            "published": 3,
            "tags": [
                "polyhedra",
                "uniform",
                "nonconvex"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 498
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Some non-convex polyhedra.\n//\n// Created 2019 by Matthew Arcus.\n//\n// Controls:\n// Mouse changes orientation\n// s: show snub\n// d: show dual\n// r: show fundamental region\n// t: select 3 3 5/2 or 5 5/2 2\n//\n// Non-convex polyhedra turn out to be quite hard to raymarch, at least using\n// the standard methods (eg. see https://www.shadertoy.com/view/MlSBDz of which\n// this is a derivation). Faces don't have a clear inside and outside, or can be\n// behind the origin.\n//\n// Here are a couple that work without too much trouble - we extend the\n// fundamental region for the Wythoff construction by reflecting one of the\n// mirrors to a new position. Folding is done as normal with the mirrors\n// for the icosahedral symmetry group, but when constructing the scene in the\n// fundamental region, we have to consider several reflected images.\n//\n// The two Schwarz triangles are 3 3 5/2 and 5 5/2 2. See:\n// https://en.wikipedia.org/wiki/List_of_uniform_polyhedra_by_Schwarz_triangle\n//\n// The Wythoff construction:\n// https://en.wikipedia.org/wiki/Wythoff_construction\n//\n// Schwarz triangles including the snub case:\n// https://en.wikipedia.org/wiki/File:Wythoff_construction-pqr.png\n//\n// Derived in part from knighty's Wythoff construction DE shader:\n// https://www.shadertoy.com/view/XlX3zB, with substantial modifications\n// to handle duals, snubs, prisms and some very basic non-convex polyhedra.\n//\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90; // rotation\n\n// Choices here are: (2,2),(2,3),(2,4),...,(3,3),(3,4),(3,5) (and opposite)\nfloat P = 2.0, Q = 3.0, R = 5.0;\n\nint nonconvex = 0;\n\n// Number of iterations of folding loop\n// 5 iterations is enough to get up to (2 3 5) or (2 2 10)\nint NFOLDS = 5;\n\nbool dofaces = true;\nbool dodualfaces = false;\nbool doregion = false;\nbool snubify = false;\n\nconst vec3 Face0Color = vec3(0.8,0,0);\nconst vec3 Face1Color = vec3(0.8,0.7,0);\nconst vec3 Face2Color = vec3(0.1,0,0.6);\nconst vec3 SnubColor = vec3(0,0.5,0.0);\nconst vec3 DualColor0 = vec3(0.7,0.7,0.1);\nconst vec3 DualColor1 = vec3(0.1,0.1,0.1);\n\nconst float PI\t= 3.14159265359;\nconst float TWOPI = 2.0 * PI;\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\n// Approximate equality. Used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat edgedistance(vec3 pos, vec3 X) {\n  assert(eq(length(X),1.0));  // Use dot(X,X)?\n  return length(pos-dot(pos,X)*X);\n}\n\nfloat raydistance(vec3 pos, vec3 q, vec3 r) {\n  float s = max(0.0, dot(pos-q,r));\n  return distance(pos,q+s*r);\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a,max(b,c));\n}\n\nfloat min3(float a, float b, float c) {\n  return min(a,min(b,c));\n}\n\n// Geometric globals\n\n// A,B,C are the mirror planes\n// a,b,c are triangle corners or trihedron edge\n// vectors or face normals\nvec3 A,B,C,a,b,c;\nvec3 A0,B0,C0;\nvec3 tri2bary;\n\n// Could use a matrix here\nvec3 applybary(vec3 bary, vec3 p, vec3 q, vec3 r) {\n  return bary.x*p+bary.y*q+bary.z*r;\n}\n\nvec3 refla(vec3 p) { return p - 2.0*dot(p,A)*A; } // Fold about A plane\nvec3 reflb(vec3 p) { return p - 2.0*dot(p,B)*B; } // Fold about B plane\nvec3 reflc(vec3 p) { return p - 2.0*dot(p,C)*C; } // Fold about C plane\n\n// Planes are represented as vec4s: (a,b,c,d) where p = (x,y,z) is\n// in plane just when (x,y,z,-1).(a,b,c,d) = 0\n\n// For our vec4 plane representations\nvec4 refla(vec4 p) { return vec4(refla(p.xyz),p.w); }\nvec4 reflb(vec4 p) { return vec4(reflb(p.xyz),p.w); }\nvec4 reflc(vec4 p) { return vec4(reflc(p.xyz),p.w); }\n\nvec4 makeplane(vec3 p, vec3 q, vec3 r) {\n  vec3 n = cross(q-p,r-p);\n  //assert(length(n) > 1e-3);\n  n = normalize(n);\n  float k = dot(p,n);\n  // Fix so that away from origin is +ve distance\n  // Not sure I need this. Want the \"natural\" way round.\n  if (k < 0.0) { k = -k; n = -n; }\n  return vec4(n,k);\n}\n\n// Find bary coords of point whose 3 reflections form an equilateral triangle.\n// Fairly standard application of 2-dimensional Newton-Raphson.\n// It's pretty silly doing this in a fragment shader - the coords only\n// depend on the triangle so we could just have a lookup table.\nvec2 eval(vec2 s) {\n  vec3 t = applybary(vec3(s,1.0-s.x-s.y),a,b,c);\n  vec3 p0 = refla(t);\n  vec3 q0 = reflb(t);\n  vec3 r0 = reflc(t);\n  float d0 = distance(p0,q0);\n  float d1 = distance(q0,r0);\n  float d2 = distance(r0,p0);\n  return vec2(d1-d0,d2-d1);\n}\n\nmat2 jacobian(vec2 s, float eps) {\n  // f(a+eps) = f(a-eps) + 2*eps*f'(a) => f'(a) =  (f(a+eps)-f(a-eps))/(2*eps)\n  vec2 e = vec2(eps,0);\n  vec2 s0 = eval(s+e.xy);\n  vec2 s1 = eval(s-e.xy);\n  vec2 s2 = eval(s+e.yx);\n  vec2 s3 = eval(s-e.yx);\n  // df[0]/da df[0]/db\n  // df[1]/da df[1]/db\n  // Column major!\n  return mat2(s0-s1,s2-s3)/(2.0*eps);\n}\n\nvec2 refine(vec2 s) {\n  // 0 = f(a+dx) = f(a)+M(dx)\n  // f(a) = -M(dx)\n  // dx = -inv(M)(f(a))\n  mat2 m = inverse(jacobian(s,1e-6));\n  vec2 t = eval(s);\n  vec2 dx = m*t;\n  return s-dx;\n}\n\nvec3 getsnub() {\n  // Solve f(a,b,c) = g(a,b,c) = h(a,b,c)\n  // Here f,g,h are distances to 3 sides of triangle. a,b,c are bary coords\n  // In fact, we can set a+b+c = 1, so only 2 variables really.\n  // Have a vector quantity: [f-g,h-g], which we want to set to [0,0].\n  // f(x+dx) = f(x) + F(dx)\n  // ie. f(x) + F(dx) = 0 => dx = -inv(F)(f(x))\n  // We need a decent starting point, here the middle of the triangle\n  vec2 s = vec2(0.333,0.333);\n  // A few iterations is enough\n  for (int i = 0; i < 4; i++) {\n    s = refine(s);\n  }\n  //assert(length(eval(s)) < 1e-3); // Check we have a solution\n  vec3 res = vec3(s,1.0-s.x-s.y);\n  return res;\n}\n\nvoid init() {\n  // Setup folding planes\n  float p = PI/P, q = PI/Q, r = PI/R;\n  A0 = vec3(1,0,0);\n  // A.B = -cos(p)\n  B0 = vec3(-cos(p),sin(p),0);\n  // A.C = -cos(r)\n  float x = -cos(r);\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  float y = -(cos(p)*cos(r)+cos(q))/sin(p);\n  // |C| = 1\n  float z = sqrt(1.0-x*x-y*y);\n  C0 = vec3(x,y,z);\n  A = A0;\n  B = B0;\n  C = C0;\n  if (nonconvex == 0) {\n    A = reflect(C0,A0);\n  } else if (nonconvex == 1) {\n    B = reflect(A0,reflect(C0,B0));\n#if 0\n  } else if (nonconvex == 2) {\n    B = reflect(C0,B0);\n  } else if (nonconvex == 3) {\n    // This one doesn't work so well, some planes end up the wrong side\n    // of the origin, which breaks some assumptions somewhere so some\n    // things don't work and some other things do...\n    A = reflect(A0,reflect(C0,A0));\n#endif\n  }\n  a = cross(B,C);\n  b = cross(C,A);\n  c = cross(A,B);\n  // Weights to convert trilinear (distance from region planes) to barycentric\n  // (weighted sum of triangle vertices).\n  tri2bary = vec3(length(a),length(b),length(c));\n  a = normalize(a);\n  b = normalize(b);\n  c = normalize(c);\n  //assert(dot(a,b) > 0.0);\n  //assert(dot(b,c) > 0.0);\n  //assert(dot(c,a) > 0.0);\n  if (snubify) {\n    // For snubs we need to use special values to ensure that the\n    // snub triangles are equilateral (for trilinear coords (1,1,1)).\n    tri2bary = getsnub();\n  }\n}\n\n// Could use an ivec3 and count different types of flip\nvec3 fold(vec3 pos, out int flips) {\n  // We want to know the number of actual reflections made\n  // so keep track of that in flips.\n  flips = 0;\n  for (int i = 0; i < NFOLDS; i++) {\n    float k;\n    k = dot(pos,A0);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*A0;\n    k = dot(pos,B0);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*B0;\n    k = dot(pos,C0);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*C0;\n  }\n  return pos;\n}\n\n// p is the \"triangle point\"\n// pa,pb,pc is its reflection in the 3 walls\nvec3 p,pa,pb,pc;\n\n// These vec4s represent planes, xyz is a normal,\n// w is -ve distance from the origin, so we can find\n// distance of p from plane q with dot(vec4(p,1),q):\n//\n// aplane, bplane, cplane are the face planes\n// bplaneB is reflection of bplane in side B.\n// tplane is snub triangle for this region\n// tplaneA, tplaneB, tplaneC are the snub triangle planes for the three\n// adjacent regions (across planes A,B,C respectively).\n\nvec4 aplane, bplane, cplane,bplaneB;\nvec4 tplane, tplaneA, tplaneB, tplaneC;\n\nvoid initp(vec3 tri) {\n  p = applybary(tri2bary*tri,a,b,c);\n  if (true) {\n    //p = normalize(p);\n    float scale = min3(edgedistance(p,A),\n                       edgedistance(p,B),\n                       edgedistance(p,C));\n    p /= scale;\n    if (snubify) {\n      // Centre of triangle edges should be at 1 for snub\n      scale = 0.5*length(refla(p)+reflb(p));\n      p /= scale;\n    }\n  }\n  aplane = vec4(a,dot(p,a)); // Face planes\n  bplane = vec4(b,dot(p,b));\n  cplane = vec4(c,dot(p,c));\n  //assert(abs(aplane.w) < 1.0 || abs(bplane.w) < 1.0 || abs(cplane.w) < 1.0);\n  pa = refla(p);\n  pb = reflb(p);\n  pc = reflc(p);\n  //assert(eq(length(p+pa),2.0) || eq(length(p+pb),2.0) || eq(length(p+pc),2.0) );\n  if (snubify) {\n    bplaneB = reflb(bplane);\n    // Now work out the 3 corners of the snub triangles\n    tplane = makeplane(refla(p),reflb(p),reflc(p));\n    //assert(tplane.w > 0.0);\n    // The snub triangles can coincide with the normal faces\n    // so move them in slightly to avoid clashes.\n    tplane.w -= 0.0001;\n    tplaneA = refla(tplane);\n    tplaneB = reflb(tplane);\n    tplaneC = reflc(tplane);\n  }\n}\n\nvec3 paa,pbb,pcc;\nvoid scenesetup() {\n  paa = normalize(pa); //pa/dot(pa,pa);\n  pbb = normalize(pb); //pb/dot(pb,pb);\n  pcc = normalize(pc); //pc/dot(pc,pc);\n}\n\nfloat faces(vec3 pos, bool parity) {\n  if (snubify && parity) pos = reflect(pos,B);\n  vec4 pos4 = vec4(pos,-1);\n  // Signed distance from 3 planes\n  float d = -1e8;\n  d = max(d,dot(pos4,aplane));\n  d = max(d,dot(pos4,bplane));\n  d = max(d,dot(pos4,cplane));\n  if (!snubify) return d;\n  // Distance from reflection of b in B.\n  d = max(d,dot(pos4,reflb(bplane))); //FIXME\n  // Distance from snub triangles\n  d = max(d,dot(pos4,tplaneA));\n  d = max(d,dot(pos4,tplaneB));\n  d = max(d,dot(pos4,tplaneC));\n  return d;\n}\n\nfloat colorfaces(vec3 pos, bool parity, inout int col) {\n  // This should agree with the snubify check below.\n  if (snubify && parity) pos = reflect(pos,A0);\n  vec4 pos4 = vec4(pos,-1);\n  // Distance from 3 planes\n  float d0, d = -1e8;\n  d0 = dot(pos4,aplane);\n  if (d0 > d) { d = d0; col = 0; }\n  d0 = dot(pos4,bplane);\n  if (d0 > d) { d = d0; col = 1; }\n  d0 = dot(pos4,cplane);\n  if (d0 > d) { d = d0; col = 2; }\n  if (!snubify) return d;\n  d0 = dot(pos4,refla(aplane));\n  if (d0 > d) { d = d0; col = 0; }\n  d0 = max3(dot(pos4,tplaneA),\n            dot(pos4,tplaneB),\n            dot(pos4,tplaneC));\n  if (d0 > d) { d = d0; col = 3; }\n  return d;\n}\n\nfloat dualfaces(vec3 pos, bool parity) {\n  if (snubify && parity) pos = reflect(pos,B);\n  float r = 1.0/length(p);\n  if (!snubify) {\n    return dot(pos,p)-r; // Nice 'n' easy, p defines surface\n  } else {\n    pos = reflb(pos);\n    // Almost as easy, reflect triangle point in each side,\n    // then use to define surface.\n    float d0 = dot(pos,paa)-r;\n    float d1 = dot(pos,pbb)-r;\n    float d2 = dot(pos,pcc)-r;\n    float d = max3(d0,d1,d2);\n    return d;\n  }\n}\n\nfloat colordualfaces(vec3 pos, bool parity, inout int col) {\n  //col = (!snubify && parity) ? 5 : 4;\n  col = 4;\n  return dualfaces(pos,parity);\n}\n\nfloat scene(vec3 pos, bool parity) {\n  float d = 1e8;\n  if (dodualfaces) {\n    d = min(d,dualfaces(pos,parity));\n    if (nonconvex == 0) {\n      d = min(d,dualfaces(reflect(pos,A0),!parity));\n    } else if (nonconvex == 1) {\n      d = min(d,dualfaces(reflect(pos,B0),!parity));\n      d = min(d,dualfaces(reflect(reflect(pos,B0),reflect(C0,B0)),parity));\n#if 0\n    } else if (nonconvex == 2) {\n      d = min(d,dualfaces(reflect(pos,B0),!parity));\n    } else if (nonconvex == 3) {\n      vec3 pos1 = reflect(pos,A0);\n      vec3 C1 = reflect(C0,A0);\n      vec3 pos2 = reflect(pos1,C1);\n      d = min(d,dualfaces(pos1,!parity));\n      d = min(d,dualfaces(pos2,parity));\n      d = min(d,dualfaces(reflect(pos2,reflect(B0,C1)),!parity));\n#endif\n    }\n  }\n  if (dofaces) {\n    d = min(d,faces(pos,parity));\n    if (nonconvex == 0) {\n      d = min(d,faces(reflect(pos,A0),!parity));\n    } else if (nonconvex == 1) {\n      d = min(d,faces(reflect(pos,B0),!parity));\n      d = min(d,faces(reflect(reflect(pos,B0),reflect(C0,B0)),parity));\n#if 0\n    } else if (nonconvex == 2) {\n      d = min(d,faces(reflect(pos,B0),!parity));\n    } else if (nonconvex == 3) {\n      vec3 pos1 = reflect(pos,A0);\n      vec3 C1 = reflect(C0,A0);\n      vec3 pos2 = reflect(pos1,C1);\n      d = min(d,faces(pos1,!parity));\n      d = min(d,faces(pos2,parity));\n      d = min(d,faces(reflect(pos2,reflect(B0,C1)),!parity));\n#endif\n    }\n  }\n  return d;\n}\n\nfloat colorscene(vec3 pos, bool parity, out int col) {\n  float d = 1e8, d0;\n  int col0;\n  if (dodualfaces) {\n    d0 = colordualfaces(pos,parity,col0);\n    if (d0 < d) {\n      d = d0;\n      col = col0;\n    }\n  }\n  if (dofaces) {\n    d0 = colorfaces(pos,parity,col0);\n    if (d0 < d) {\n      d = d0;\n      col = col0;\n    }\n    if (nonconvex == 0) {\n      d0 = colorfaces(reflect(pos,A0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n    } else if (nonconvex == 1) {\n      d0 = colorfaces(reflect(pos,B0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n      d0 = colorfaces(reflect(reflect(pos,B0),reflect(C0,B0)),parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n#if 0\n    } else if (nonconvex == 2) {\n      d0 = colorfaces(reflect(pos,B0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n    } else if (nonconvex == 3) {\n      d0 = colorfaces(reflect(pos,A0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n      d0 = colorfaces(reflect(pos,C0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n      d0 = colorfaces(reflect(reflect(pos,C0),reflect(B0,C0)),parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n#endif\n    }\n  }\n  return d;\n}\n\nfloat polyhedron(vec3 pos) {\n  int flips;\n  vec3 pos0 = pos;\n  pos = fold(pos,flips);\n  bool parity = flips%2 == 1;\n  float d = 1e8;\n  d = min(d,scene(pos,parity));\n  if (doregion) {\n    d = max(d,dot(pos0,A));\n    d = max(d,dot(pos0,B));\n    d = max(d,dot(pos0,C));\n  }\n  return d;\n}\n\nvec3 getcolor(vec3 pos){\n  vec3 pos0 = pos;\n  int flips;\n  pos = fold(pos,flips);\n  bool parity = flips%2 == 1;\n  int col = 10;\n  float d = colorscene(pos,parity,col);\n  assert(col >= 0);\n  if (doregion) {\n    float d0 = d;\n    d = max(d,dot(pos0,A));\n    d = max(d,dot(pos0,B));\n    d = max(d,dot(pos0,C));\n    if (d != d0) col = 6;\n  }\n  if (col == 0) return Face0Color;\n  if (col == 1) return Face1Color;\n  if (col == 2) return Face2Color;\n  if (col == 3) return SnubColor;\n  if (col == 4) return DualColor0;\n  if (col == 5) return DualColor1;\n  if (col == 6) return vec3(1);\n  //assert(false);\n  return vec3(1);\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p) {\n  return polyhedron(p);\n}\n\n// We should be able to do this analytically from the plane hit.\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                        map(p + e.yxy) - map(p - e.yxy),\n                        map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 5.0;\n  const float precis = 0.001;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 64; i++) {\n    if (t > maxd) return -1.0;\n    float h = map(ro+rd*t);\n    h = max(h,0.0);\n    t += 0.5*h;\n    if (h < precis) break;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (!keypress(CHAR_Z)) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\n#if 1\nvec3 circuit[] = vec3[]\n  (vec3(1,1,1),vec3(1,1,1),vec3(1,0,0),vec3(1,0,0),\n   vec3(1,1,0),vec3(1,1,0),vec3(0,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,1,1),vec3(0,0,1),vec3(0,0,1),\n   vec3(1,0,1),vec3(1,0,1),vec3(1,0,0),vec3(1,0,0),\n\n   vec3(1,1,1),vec3(1,1,0),vec3(1,1,1),vec3(0,1,0),\n   vec3(1,1,1),vec3(0,1,1),vec3(1,1,1),vec3(0,0,1),\n   vec3(1,1,1),vec3(1,0,1),\n\n   vec3(1,1,1),vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,0,1),vec3(1,0,1),vec3(1,0,0));\n#else\nvec3 circuit[] = vec3[]\n  (vec3(1,1,1),vec3(1,0,0),\n   vec3(1,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,0,1),\n   vec3(1,0,1),vec3(1,0,0),\n\n   vec3(1,1,1),vec3(1,1,0),vec3(1,1,1),vec3(0,1,0),\n   vec3(1,1,1),vec3(0,1,1),vec3(1,1,1),vec3(0,0,1),\n   vec3(1,1,1),vec3(1,0,1),\n\n   vec3(1,1,1),vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,0,1),vec3(1,0,1),vec3(1,0,0));\n#endif\n\nconst int nsteps = circuit.length();\n\nvec3 gettri(float t) {\n  int i = int(floor(t))%nsteps;\n  return mix(circuit[i],circuit[(i+1)%nsteps],mod(t,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dodualfaces = keypress(CHAR_D);\n  dofaces = !dodualfaces;\n  snubify = keypress(CHAR_S);\n  doregion = keypress(CHAR_R);\n  nonconvex = keypress(CHAR_T) ? 0 : 1;\n#if 0\n  // Debug settings.\n  snubify = false;\n  dofaces = true;\n  dodualfaces = !dofaces;\n  doregion = false;\n#endif\n\n  vec2 p = (2.0*fragCoord.xy - iResolution.xy)/ iResolution.y;\n  p.y = -p.y;\n  p *= 0.5;\n  vec3 col = vec3(0,0,(1.0 - fragCoord.y/iResolution.y) * 0.3);\n  vec3 ro = vec3(0.0, 0.0, -4.0);\n  vec3 rd = vec3(p, 2.0);\n  vec3 li = vec3(0.5, 0.8, -3.0);\n  ro = transform(ro);\n  rd = transform(rd);\n  li = transform(li);\n  li = normalize(li);\n  rd = normalize(rd);\n  init();\n  vec3 tri = gettri(0.5*iTime);\n  if (snubify) tri = vec3(1);\n  initp(tri);\n  scenesetup();\n  float t = march(ro, rd);\n  if (t > 0.0) {\n    vec3 pos = ro+t*rd;\n    vec3 n = calcNormal(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col = getcolor(pos) * diffuse;\n    col = pow(col, vec3(0.4545));\n  }\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}