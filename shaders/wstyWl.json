{
    "Shader": {
        "info": {
            "date": "1602017968",
            "description": "A simple nebula rendered using some volumetric noise and a hacky voronoi starfield - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wstyWl",
            "likes": 28,
            "name": "dust02",
            "published": 3,
            "tags": [
                "voronoi",
                "volumetric",
                "nebula",
                "starfield",
                "wavelet"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 1355
        },
        "renderpass": [
            {
                "code": "// simple nebula rendered using some volumetric noise and a hacky voronoi starfield - Del 06/10/2020\n// this shader is purely used for baking a procedural cubemap texture, please ignore the hackery & lack of speed - a realtime version would require some baked noise textures.\n// WaveletNoise by BigWigs, Voronoi by IQ.\n\nvec3 erot(vec3 p, vec3 ax, float ro)\n{\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<3.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// starfield hack :)\nfloat stars(vec3 pp1)\n{\n    float f;\n    vec3 vv = voronoi(pp1);\n    f = vv.x;\n    float size = abs(sin((vv.z*32.3215))*9.0);\n    f = 1.0-(f*(19.0+size));\n  \tfloat twink = 0.5+sin(f+iTime*1.3+vv.z)*0.5;\n    f = clamp(f+(twink*0.2),0.0,1.0);\n   \treturn f;\n}\n\n#define brightness -7.\n#define saturation 0.95\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*0.8,1.);\n\tfloat time=iTime*0.04;\n\n\t//rotation\n    vec2  mm = iMouse.xy/iResolution.xy;\n\tfloat a1=0.5+(mm.x*0.5);\n\tfloat a2=0.8+(mm.y*0.8);\n    \n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,.75);\n\tfrom+=vec3(time*1.8,time,-5.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t// volumetric\n\tfloat s=0.1;\n    float fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<25; r++)\n    {\n\t\tvec3 p=from+s*dir*.5;\n\t\tvec3 p2 = p*2.9;\n\t\tfloat a = WaveletNoise(p2, 0.0, 1.9)*2.0 - 1.0;\n\t\ta *= a * a;\n\t\tv += vec3(s, s*s, s*s*s*s)* a * brightness * fade;\n\t\tfade *= 0.905;\n\t\ts += 0.032*1.55;\n\t}\n\n    // Star hack\n    float f = 1.0;\n    vec3 pp1=from+dir*1.1;\n\tf = stars(pp1*20.0);\n    pp1=from+dir*1.35;\n\tf = max(f,stars(pp1*20.0));\n    pp1=from+dir*1.7;\n\tf = max(f,stars(pp1*20.0));\n    \n\tv=mix(vec3(length(v)),v,saturation);\n    v = clamp(v.gbr*0.01,vec3(0.0),vec3(1.0));\n    v+=v*f;\t// dirty starblend\n\tfragColor = vec4(v,1.);\t\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}