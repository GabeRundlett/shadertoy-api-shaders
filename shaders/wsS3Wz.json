{
    "Shader": {
        "info": {
            "date": "1548597945",
            "description": "a fork of iq's [url=https://www.shadertoy.com/view/4tKBWy]Boxes traced[/url] without a stack.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsS3Wz",
            "likes": 6,
            "name": "many boxes",
            "published": 3,
            "tags": [
                "3d",
                "bvh"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "//fork of iq's Boxes traced\n//https://www.shadertoy.com/view/4tKBWy\n\n#define LEVELS 14\n#define STEPS 3000\n#define FAR 100.0\n\n#define ZERO min(0,iFrame)\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvec2  hash2( float n ) { return fract(sin(vec2(n,n+3.0))*vec2(43758.5453123,22578.1459123)); }\nfloat hash2( vec2 x )  { return fract(sin(dot(x,vec2(12.353,31.71))*43758.5453123)); }\n\n//https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid random(out vec3 dcen, out vec3 drad, in int id, in int level) {\n    dcen = hash(uvec3(id,level,uint(iMouse.x))).xyz;\n    drad = hash(uvec3(id,level,uint(iMouse.y))).xyz;\n    drad = drad*0.4+0.5;\n}\n\nvoid generate(inout vec3 cen, inout vec3 rad, in int id, in int level) {\n    vec3 dcen;\n    vec3 drad;\n\n    random(dcen,drad, id, level);\n\n    vec3 dp = dcen*2.0-1.0;\n\n    vec3 ncen = cen;\n    vec3 nrad = rad;\n    nrad = nrad*drad;\n    ncen += dp*(rad-nrad);\n\n    rad = nrad;\n    cen = ncen;\n}\n\nvoid backgenerate(inout vec3 cen, inout vec3 rad, in int id, in int level) {\n    vec3 dcen;\n    vec3 drad;\n\n    random(dcen,drad, id, level);\n\n    vec3 dp = dcen*2.0-1.0;\n\n    vec3 pcen = cen;\n    vec3 prad = rad;\n    prad = rad/drad;\n    pcen -= dp*(prad-rad);\n\n    rad = prad;\n    cen = pcen;\n}\n\nvec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 ird, in vec3 cen, in vec3 rad, out vec3 nor) \n{\n    vec3 n = ird*(cen-ro);\n    vec3 k = abs(ird)*rad;\n\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n    float tN = max(max( t1.x, t1.y ),t1.z);\n    float tF = min(min( t2.x, t2.y ),t2.z);\n\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n\n    nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nbool boxIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird, in vec3 cen, in vec3 rad ) \n{\n    vec3 n = ird*(cen-ro);\n    vec3 k = abs(ird)*rad;\n\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    return tN<tF && tF>0.0;\n}\n\nvec3 ibox = vec3(2,1,2);\n\nvec3 cityIntersect( in vec3 ro, in vec3 rd, in vec3 ird, inout float tmax, out int id2, out int i)\n{\n    vec3 res = vec3(-1.0);\n    vec3 cen = vec3(0);\n    vec3 rad = ibox;\n    int level = 0;\n    int id = 0;\n\n    bool subdivide = true;\n\n    for( i=ZERO; i<STEPS; i++ )\n    {\n        if (subdivide) {\n            vec3 nor;\n            vec2 tmp = boxIntersect( ro, rd, ird, cen, rad, nor);\n\n            // intersect node\n            if( tmp.y>0.0 && tmp.x < tmax)\n            {\n                // if leaf\n                if(level == LEVELS)\n                {\n                    tmax = tmp.x;\n                    res = nor;\n                    id2 = id;\n\n                    subdivide = false;\n                }\n                // else, test a child node of even id number\n                else\n                {\n\n                    level++;\n                    //even id number\n                    id *= 2;\n                    generate(cen,rad,id,level);\n                }\n            }\n            // pop next node from the stack\n            else\n            {\n                subdivide = false;\n            }\n        } else {\n            if (level == 0) {\n                break;\n            }\n            //going up nodes until there is an untested node,\n            //if the id number is even id+1 is not tested,\n            //if level is 0 every node is tested, and the ray hasn't hit anything\n            if (id/2*2 != id) {\n\n                backgenerate(cen,rad,id,level);\n\n                id/=2;\n                level--;\n            } else {\n                backgenerate(cen,rad,id,level);\n                //uneven id number\n                id++;\n                generate(cen,rad,id,level);\n                subdivide = true;\n            }\n        }\n    }\n\n    return res;\n}\n\nbool cityIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird )\n{\n    bool res = false;\n\n    // start with the root\n    vec3 cen = vec3(0);\n    vec3 rad = ibox;\n    int level = 0;\n    int id = 0;\n\n    bool subdivide = true;\n    \n    for( int i=ZERO; i<STEPS; i++ )\n    {\n        // intersect node\n        if (subdivide) {\n        if( boxIntersectAny( ro, rd, ird, cen, rad ) )\n        {\n            // if leaf\n            if( level == LEVELS )\n            {\n                res = true;\n                break;\n            }\n            // else, generate child of even id\n            else\n            {\n                level++;\n                //even id number\n                id *= 2;\n                generate(cen,rad,id,level);\n            }\n        }\n        // pop next node from the stack\n        else\n        {\n            subdivide = false;\n        }\n        } else {\n            if (level == 0) {\n                break;\n            }\n            //going up nodes until there is an untested node,\n            //if the id number is even id+1 is not tested,\n            //if level is 0 every node is tested, and the ray hasn't hit anything\n            if (id/2*2 != id) {\n\n                backgenerate(cen,rad,id,level);\n\n                id/=2;\n                level--;\n            } else {\n                backgenerate(cen,rad,id,level);\n                //uneven id number\n                id++;\n                generate(cen,rad,id,level);\n                subdivide = true;\n            }\n        }\n    }\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    float seed = texelFetch( iChannel2, ivec2(fragCoord)&255, 0 ).x;\n\n    float t = iTime*0.2;\n\n    vec3 ro = vec3(-sin(t),0.5,-cos(t));\n    vec3 rd = normalize(vec3(uv,1));\n    rd.yz *= rot(-0.7);\n    rd.xz *= rot(t);\n    vec3 ird = 1.0/rd;\n\n    float tmin = FAR;\n    int id;\n    int i;\n    vec3 res = cityIntersect( ro, rd, ird, tmin, id,i);\n    \n    vec3 col= vec3(0);\n    if (tmin < FAR) {\n\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = res;\n\n        //random color, based on box id\n        col = hash(uvec3(id,ZERO,ZERO));\n\n        //direction to light\n        vec3 light = normalize(vec3(1));\n\n        float diffuse = clamp(dot(nor,light),0.2,1.0);\n\n        //shadow\n        if (cityIntersectAny(pos+nor*0.01,light,1.0/light)) {\n            diffuse = 0.2;\n        }\n\n        col *= diffuse;\n\n    } else {\n        //some random background\n        col += clamp(dot(rd,normalize(vec3( 1.0, 0.5,-0.7))),0.0,1.0)*vec3(0.8,0.3,0.4);\n        col += clamp(dot(rd,normalize(vec3(-1.0, 0.8,-0.1))),0.0,1.0)*vec3(0.2,0.9,0.4);\n        col += clamp(dot(rd,normalize(vec3( 0.0,-0.3, 0.9))),0.0,1.0)*vec3(0.8,0.6,0.4);\n        col += clamp(dot(rd,normalize(vec3( 0.0,-0.3,-0.9))),0.0,1.0)*vec3(0.8,0.3,0.8);\n        col *= 0.5;\n        col += 0.2;\n    }\n    fragColor = vec4(col, 1);\n\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}