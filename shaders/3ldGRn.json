{
    "Shader": {
        "info": {
            "date": "1575465721",
            "description": "see discussion https://twitter.com/Bananaft/status/1202202291367006209\nsee also https://www.shadertoy.com/view/tl3GR8",
            "flags": 0,
            "hasliked": 0,
            "id": "3ldGRn",
            "likes": 3,
            "name": "post: HDR color spill (tonemap)",
            "published": 3,
            "tags": [
                "post",
                "tonemap",
                "exposure",
                "spill",
                "crosstalk"
            ],
            "usePreview": 0,
            "username": "hornet",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "\n// RGB with sRGB/Rec.709 primaries to CIE XYZ\nvec3 RGBToXYZ(vec3 c)\n{\n    const mat3x3 mat = mat3x3(\n        0.4124564,  0.3575761,  0.1804375,\n        0.2126729,  0.7151522,  0.0721750,\n        0.0193339,  0.1191920,  0.9503041\n    );\n    return c * mat; //hlsl: mul(mat, c);\n}\nvec3 XYZToRGB(vec3 c)\n{\n    const mat3x3 mat = mat3x3(\n         3.24045483602140870, -1.53713885010257510, -0.49853154686848090,\n        -0.96926638987565370,  1.87601092884249100,  0.04155608234667354,\n         0.05564341960421366, -0.20402585426769815,  1.05722516245792870\n    );\n    return c * mat; //hlsl: mul(mat, c);\n}\n// Converts XYZ tristimulus values into cone responses for the three types of cones in the human visual system, matching long, medium, and short wavelengths.\n// Note that there are many LMS color spaces; this one follows the ICtCp color space specification.\nvec3 XYZToLMS(vec3 c)\n{\n    const mat3x3 mat = mat3x3(\n        0.3592,  0.6976, -0.0358,\n        -0.1922, 1.1004,  0.0755,\n        0.0070,  0.0749,  0.8434\n    ); \n    return c*mat; //hlsl: mul(mat, c);\n}\nvec3 LMSToXYZ(vec3 c)\n{\n    const mat3x3 mat = mat3x3(\n         2.07018005669561320, -1.32645687610302100,  0.206616006847855170,\n         0.36498825003265756,  0.68046736285223520, -0.045421753075853236,\n        -0.04959554223893212, -0.04942116118675749,  1.187995941732803400\n    );\n    return c*mat; //hlsl: mul(mat, c);\n}\n\nconst float PQ_constant_N = (2610.0 / 4096.0 / 4.0);\nconst float PQ_constant_M = (2523.0 / 4096.0 * 128.0);\nconst float PQ_constant_C1 = (3424.0 / 4096.0);\nconst float PQ_constant_C2 = (2413.0 / 4096.0 * 32.0);\nconst float PQ_constant_C3 = (2392.0 / 4096.0 * 32.0);\n\n// PQ (Perceptual Quantiser; ST.2084) encode/decode used for HDR TV and grading\nvec3 linearToPQ(vec3 linearCol, const float maxPqValue)\n{\n    linearCol /= maxPqValue;\n\n    vec3 colToPow = pow(linearCol, vec3(PQ_constant_N) );\n    vec3 numerator = PQ_constant_C1 + PQ_constant_C2*colToPow;\n    vec3 denominator = 1.0 + PQ_constant_C3*colToPow;\n    vec3 pq = pow(numerator / denominator, vec3(PQ_constant_M) );\n\n    return pq;\n}\n\nvec3 PQtoLinear(vec3 linearCol, const float maxPqValue)\n{\n    vec3 colToPow = pow(linearCol, vec3(1.0 / PQ_constant_M) );\n    vec3 numerator = max(colToPow - PQ_constant_C1, 0.0);\n    vec3 denominator = PQ_constant_C2 - (PQ_constant_C3 * colToPow);\n    vec3 linearColor = pow(numerator / denominator, vec3(1.0 / PQ_constant_N) );\n\n    linearColor *= maxPqValue;\n\n    return linearColor;\n}\n\n\n// RGB with sRGB/Rec.709 primaries to ICtCp\nvec3 RGBToICtCp(vec3 c)\n{\n    c = RGBToXYZ(c);\n    c = XYZToLMS(c);\n    // 1.0f = 100 nits, 100.0f = 10k nits\n    c = linearToPQ(max( vec3(0.0), c), 100.0);\n\n    // Convert PQ-LMS into ICtCp. Note that the \"S\" channel is not used,\n    // but overlap between the cone responses for long, medium, and short wavelengths\n    // ensures that the corresponding part of the spectrum contributes to luminance.\n\n    const mat3x3 mat = mat3x3(\n        0.5000,  0.5000,  0.0000,\n        1.6137, -3.3234,  1.7097,\n        4.3780, -4.2455, -0.1325\n    );\n\n    return c*mat; //hlsl: mul(mat, c);\n}\n\nvec3 ICtCpToRGB(vec3 c)\n{\n     const mat3x3 mat = mat3x3(\n        1.0,  0.00860514569398152,  0.11103560447547328,\n        1.0, -0.00860514569398152, -0.11103560447547328,\n        1.0,  0.56004885956263900, -0.32063747023212210\n    );\n    c = c*mat; //hlsl: mul(mat, col);\n\n    // 1.0f = 100 nits, 100.0f = 10k nits\n    c = PQtoLinear(c, 100.0);\n    c = LMSToXYZ(c);\n    return XYZToRGB(c);\n}\n\n\n// Aplies exponential (\"Photographic\") luma compression\nfloat rangeCompress(float x)\n{\n    return 1.0 - exp(-x);\n}\n\nfloat rangeCompress(float val, float threshold)\n{\n    float v1 = val;\n    float v2 = threshold + (1.0 - threshold) * rangeCompress((val - threshold) / (1.0 - threshold));\n    return val < threshold ? v1 : v2;\n}\n\nvec3 rangeCompress(vec3 val, float threshold)\n{\n    return vec3(\n        rangeCompress(val.x, threshold),\n        rangeCompress(val.y, threshold),\n        rangeCompress(val.z, threshold));\n}\n\n\n\n//note: ref https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/gdc-highdynamicrange.pptx\n//\n//note: this function is expensive.\n//This is why we bake it down into a LUT (ideally the same LUT we use for grading, to make it free).\n//This is the hue-preserving version used for screenshots in this article, itâ€™s very ad-hoc but hopefully interesting to play with.\nvec3 applyHuePreservingShoulder(vec3 col)\n{\n    vec3 ictcp = RGBToICtCp(col);\n\n    // Hue-preserving range compression requires desaturation in order to achieve a natural look. We adaptively desaturate the input based on its luminance.\n    float saturationAmount = pow(smoothstep(1.0, 0.3, ictcp.x), 1.3);\n    col = ICtCpToRGB(ictcp * vec3(1.0, vec2(saturationAmount)));\n\n    // Only compress luminance starting at a certain point. Dimmer inputs are passed through without modification.\n    float linearSegmentEnd = 0.25;\n\n    // Hue-preserving mapping\n    float maxCol = max(col.x, max(col.y, col.z));\n    float mappedMax = rangeCompress(maxCol, linearSegmentEnd);\n    vec3 compressedHuePreserving = col * mappedMax / maxCol;\n\n    // Non-hue preserving mapping\n    vec3 perChannelCompressed = rangeCompress(col, linearSegmentEnd);\n\n    // Combine hue-preserving and non-hue-preserving colors. Absolute hue preservation looks unnatural, as bright colors *appear* to have been hue shifted.\n    // Actually doing some amount of hue shifting looks more pleasing\n    col = mix(perChannelCompressed, compressedHuePreserving, 0.6);\n\n    vec3 ictcpMapped = RGBToICtCp(col);\n\n    // Smoothly ramp off saturation as brightness increases, but keep some even for very bright input\n    float postCompressionSaturationBoost = 0.3 * smoothstep(1.0, 0.5, ictcp.x);\n\n    // Re-introduce some hue from the pre-compression color. Something similar could be accomplished by delaying the luma-dependent desaturation before range compression.\n    // Doing it here however does a better job of preserving perceptual luminance of highly saturated colors. Because in the hue-preserving path we only range-compress the max channel,\n    // saturated colors lose luminance. By desaturating them more aggressively first, compressing, and then re-adding some saturation, we can preserve their brightness to a greater extent.\n    ictcpMapped.yz = mix(ictcpMapped.yz, ictcp.yz * ictcpMapped.x / max(1e-3, ictcp.x), postCompressionSaturationBoost);\n\n    col = ICtCpToRGB(ictcpMapped);\n\n    return col;\n}\n\n\nvec3 adjust_out_of_gamut_EA(vec3 x)\n{\n    return applyHuePreservingShoulder(x);\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\n//note: https://modelviewer.dev/examples/tone-mapping\nvec3 CommerceToneMapping( vec3 color ) \n{\n    const float startCompression = 0.8 - 0.04;\n    const float desaturation = 0.15;\n\n    float x = min(color.r, min(color.g, color.b));\n    float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n    color -= offset;\n\n    float peak = max(color.r, max(color.g, color.b));\n    if (peak < startCompression) return color;\n\n    float d = 1. - startCompression;\n    float newPeak = 1. - d * d / (peak + d - startCompression);\n    color *= newPeak / peak;\n\n    float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n    return mix(color, newPeak * vec3(1, 1, 1), g);\n}\n\nvec3 adjust_out_of_gamut_KHR(vec3 x)\n{\n    return CommerceToneMapping( x );\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\n\n// http://cdn2.gran-turismo.com/data/www/pdi_publications/PracticalHDRandWCGinGTS_20181222.pdf\n// https://gist.github.com/shakesoda\n// note: can be optimized into lut (compute can gen it)\nfloat GTTonemap(float x)\n{\n\tconst float m = 0.22; // linear section start\n\tconst float a = 1.0;  // contrast\n\tconst float c = 1.33; // black brightness\n\tconst float P = 1.0;  // maximum brightness\n\tconst float l = 0.4;  // linear section length\n\tconst float l0 = ((P-m)*l) / a; // 0.312\n\tconst float S0 = m + l0; // 0.532\n\tconst float S1 = m + a * l0; // 0.532\n\tconst float C2 = (a*P) / (P - S1); // 2.13675213675\n\tfloat L = m + a * (x - m);\n\tfloat T = m * pow(x/m, c);\n\tfloat S = P - (P - S1) * exp(-C2*(x - S0)/P);\n\tfloat w0 = 1.0 - smoothstep(0.0, m, x);\n\tfloat w2 = (x < m+l) ? 0.0 : 1.0;\n\tfloat w1 = 1.0 - w0 - w2;\n\treturn float(T * w0 + L * w1 + S * w2);\n}\n\n// this costs about 0.2-0.3ms more than aces, as-is\nvec3 adjust_out_of_gamut_GT(vec3 x)\n{\n\treturn vec3(\n\t\tGTTonemap(x.r),\n\t\tGTTonemap(x.g),\n\t\tGTTonemap(x.b)\n\t);\n}\n\n//note: https://twitter.com/CasualEffects/status/1202259676001427458\nvec3 adjust_out_of_gamut_sat(vec3 src)\n{\n    // Fix out-of-gamut saturation\n    // Maximumum channel:\n    float m = max(max(src.r, src.g), src.b);\n\n    // Normalized color when the maximum channel exceeds 1.0\n    src *= 1.0 / max(1.0, m);\n\n    if (m > 1.0) {\n        // When very bright, aggressively roll back intensity\n        // to avoid the following desaturation pass for highlights\n        // and emissives.\n        m = pow(m, 0.2);\n    }\n    // Fade towards white when the max is bright (like a light saber core)\n    src = mix(src, vec3(1.0), min(0.9, pow(2.0 * max(0.0, m - 0.85), 3.0)));\n    \n    return src;\n}\n\nvec3 adjust_out_of_gamut_lerp(vec3 c)\n{\n    float lum = dot(c, vec3(1.0/3.0));\n    float t = smoothstep( 0.0, 1.0, lum );\n    return mix( c, vec3(lum), t);\n}\n\nvec3 adjust_out_of_gamut_remap(vec3 c)\n{\n    const float BEGIN_SPILL = 0.5;\n    const float END_SPILL = 1.0;\n    const float MAX_SPILL = 0.8; //note: <=1\n    \n    float lum = dot(c, vec3(1.0/3.0));\n    //return mix( c, vec3(lum), min(lum,1.0));\n    \n    float t = (lum-BEGIN_SPILL) / (END_SPILL-BEGIN_SPILL);\n    t = clamp( t, 0.0, 1.0 );\n    //t = smoothstep( 0.0, 1.0, t );\n    t = min(t, MAX_SPILL); //t *= MAX_SPILL;\n    \n    return mix( c, vec3(lum), t );\n}\n\nfloat smootherstep(float edge0, float edge1, float x)\n{\n\tx = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n\treturn x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n}\n\nvec3 adjust_out_of_gamut_maxcomp(vec3 c)\n{\n    const float BEGIN_SPILL = 0.9;\n    const float END_SPILL = 3.0;\n    const float MAX_SPILL = 0.5; //note: <=1\n    \n    float mc = max(c.r, max(c.g, c.b));\n    float t = MAX_SPILL * smootherstep( 0.0, END_SPILL-BEGIN_SPILL, mc-BEGIN_SPILL );\n    return mix( c, vec3(mc), t);\n}\n\n\n/*\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n*/\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\n//note: from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted( vec3 color )\n{\n    mat3x3 ACESInputMat;\n    ACESInputMat[0] = vec3(0.59719, 0.35458, 0.04823);\n    ACESInputMat[1] = vec3(0.07600, 0.90834, 0.01566);\n    ACESInputMat[2] = vec3(0.02840, 0.13383, 0.83777);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tmat3x3 ACESOutputMat;\n    ACESOutputMat[0] = vec3(1.60475, -0.53108, -0.07367);\n\tACESOutputMat[1] = vec3(-0.10208,  1.10813, -0.00605);\n\tACESOutputMat[2] = vec3(-0.00327, -0.07276,  1.07602);\n\n    color = ACESInputMat * color;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = ACESOutputMat * color;\n\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nfloat HermiteInterpolation(vec2 p1, vec2 p2, float d1, float d2, float x) {\n    float x1 = p1.x;\n    float y1 = p1.y;\n    float x2 = p2.x;\n    float y2 = p2.y;\n    \n    // Calculate the normalized parameter t in the range [0, 1]\n    float t = (x - x1) / (x2 - x1);\n    \n    // Hermite basis functions\n    float h00 = (1.0 + 2.0 * t) * (1.0 - t) * (1.0 - t);\n    float h10 = t * (1.0 - t) * (1.0 - t);\n    float h01 = t * t * (3.0 - 2.0 * t);\n    float h11 = t * t * (t - 1.0);\n    \n    // Calculate the interpolated value\n    float interpolatedValue = h00 * y1 + h10 * (x2 - x1) * d1 + h01 * y2 + h11 * (x2 - x1) * d2;\n    \n    return interpolatedValue;\n}\n\nfloat tonemap_linpoly3( float x )\n{\n    float m = iMouse.z > 0.0 ? iMouse.x / iResolution.x : 1.0;\n    float WHITE_CLIP = 4.0 * m;\n    //ret *= (1.0 / tonemap_linexp( WHITE_CLIP ) );\n\n    const float l = 0.6; //note: value is linear up to this\n    const float d1 = 1.0;\n    const float d2 = 0.0;\n    \n    float x1 = l;\n    float y1 = l;\n    float x2 = WHITE_CLIP;\n    float y2 = 1.0;\n    \n    float p = HermiteInterpolation( vec2(x1,y1), vec2(x2,y2), d1, d2, x );\n    \n    if ( x > WHITE_CLIP ) return 1.0;\n    \n    return (x<l) ? x : p;   \n}\nvec3 linPoly3Tonemap( vec3 c )\n{\n    //note: this causes weird fluctuations, because polynomial...\n    return vec3( tonemap_linpoly3( c.r ),\n                 tonemap_linpoly3( c.g ),\n                 tonemap_linpoly3( c.b ) );\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nfloat remap01( float x, float i0, float i1 )\n{\n    return clamp( (x-i0) / (i1-i0), 0.0, 1.0 );\n}\n\n//note: reference https://www.desmos.com/calculator/8gsdanfrpu\n//      (from https://www.activision.com/cdn/research/HDR_in_Call_of_Duty.pptx )\nfloat tonemap_exp( float x )\n{\n    return 1.0 - exp(-x);\n}\nfloat tonemap_linexp_noclip( float x )\n{\n    const float l = 0.6; //note: value is linear up to this\n    const float c0 = 1.0-l;\n    const float rcp_c0 = 1.0 / c0;\n    const float c1 = l*rcp_c0;\n\n    return (x<l) ? x : l + c0 * tonemap_exp( x * rcp_c0 - c1 );\n}\nfloat tonemap_linexp( float x )\n{\n    const float l = 0.6; //note: value is linear up to this\n\n    float ret = tonemap_linexp_noclip( x );\n\n    float m = iMouse.z > 0.0 ? iMouse.x / iResolution.x : 0.5;\n    float WHITE_CLIP = 4.0 * m;\n    ret *= 1.0 / tonemap_linexp_noclip( WHITE_CLIP );\n\n    //float ret2 = ret * 1.0 / tonemap_linexp_noclip( WHITE_CLIP );\n    //float t = remap01( x, l, WHITE_CLIP );\n    //return mix( ret, ret2, t );\n\n    return ret;\n}\n\nvec3 linExpTonemap( vec3 color )\n{\n    return vec3( tonemap_linexp( color.r ),\n                 tonemap_linexp( color.g ),\n                 tonemap_linexp( color.b ) );\n}\n\nvec3 linExpTonemap_hue( vec3 color )\n{\n\tvec3 vHueShifted = linExpTonemap( color );\n\n\tfloat fLuma = max(color.r, max(color.g, color.b));\n    //float fLuma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tvec3 vHue = color / fLuma;\n\tfloat vTonemapLuma = tonemap_linexp( fLuma );\n\tvec3 vHuePreserved = vHue * vTonemapLuma;\n            \n\tfloat fHuePreservingFactor = 0.25; //iMouse.z > 0.0 ? iMouse.x / iResolution.x : 0.5; //TODO: tweak\n\tvec3 ret = mix( vHueShifted, vHuePreserved, fHuePreservingFactor);\n        \n    return ret;\n}\n\n//////////////////////////////////////////////////////////////////////////\n\n\n\nvec3 adjust_out_of_gamut(vec3 c)\n{\n\n\n    //return adjust_out_of_gamut_sat(c);\n\t//return adjust_out_of_gamut_lerp(c);\n    //return adjust_out_of_gamut_remap(c);\n    //return adjust_out_of_gamut_maxcomp(c);\n    //return adjust_out_of_gamut_GT(c);\n    //return adjust_out_of_gamut_EA(c);\n    //return adjust_out_of_gamut_KHR(c);\n    //return linPoly3Tonemap( c );\n    //\n    //return linExpTonemap(c);\n    return linExpTonemap_hue(c);\n    \n    \n    \n    \n    //return ACESFitted( c );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord/iResolution.xy;\n\n    const float HDR_MULTIPLIER = 4.0;\n\n    vec3 c;\n    if ( ssuv.y > 0.0/8.0 ) c = vec3( ssuv.x, 0, 0 );\n    if ( ssuv.y > 1.0/8.0 ) c = vec3( 0, ssuv.x, 0 );\n    if ( ssuv.y > 2.0/8.0 ) c = vec3( 0, 0, ssuv.x );\n    if ( ssuv.y > 3.0/8.0 ) c = ssuv.x * vec3( 0.7, 0.6, 0.5 );\n    if ( ssuv.y > 4.0/8.0 ) c = ssuv.x * vec3( 0.5, 0.7, 0.6 );\n    if ( ssuv.y > 5.0/8.0 ) c = ssuv.x * vec3( 0.5, 0.6, 0.7 );\n    if ( ssuv.y > 6.0/8.0 ) c = ssuv.xxx;\n    if ( ssuv.y > 7.0/8.0 )\n    {\n        vec2 luv = vec2( ssuv.x, 8.0*ssuv.y-7.0 );\n        luv.y *= 1.5;\n        \n\t\t//note: grid\n        fragColor.rgb = vec3(0.25);\n        fragColor.rgb *= 1.0-0.4*step( abs(luv.y-0.5), dFdy(luv.y) );\n        fragColor.rgb *= 1.0-0.4*step( abs(luv.y-1.5), dFdy(luv.y) );\n        fragColor.rgb += 0.05*step( abs(luv.y-1.0), dFdy(luv.y) );\n        fragColor.rgb += 0.05*step( abs(HDR_MULTIPLIER*luv.x-1.0), dFdx(HDR_MULTIPLIER*luv.x) );\n        \n        //note: plot curve\n        {\n            vec3 col = HDR_MULTIPLIER * vec3(luv.x,0,0);\n            //vec3 col = hsv2rgb( vec3(0.1*iTime, 0.5, luv.x) );\n            vec3 f = adjust_out_of_gamut( col );\n            vec3 s = step( abs(luv.yyy-f), vec3(dFdy(luv.y)) );\n            fragColor.rgb += s;\n        }\n        \n        //note: plot derivative\n        {\n            float dx = dFdx(luv.x);\n            float v_m1 = adjust_out_of_gamut( HDR_MULTIPLIER * vec3(luv.x - dx,0,0).rrr ).r;\n            float v_p1 = adjust_out_of_gamut( HDR_MULTIPLIER * vec3(luv.x + dx,0,0).rrr ).r;\n            float dfdx = abs(v_p1-v_m1)/(2.0*dx);\n            const float SCL = 0.25;\n            vec3 s = step( abs(luv.yyy - SCL * dfdx), vec3(dFdy(luv.y)) );\n            fragColor.rgb += 0.25 * s;\n        }\n        \n        return;\n    }\n    \n    c *= HDR_MULTIPLIER;\n\tc = adjust_out_of_gamut(c);\n    //fragColor = vec4( c, 1.0 ); return;\n        \n    vec4 rnd = texture( iChannel0, fragCoord / vec2(textureSize(iChannel0,0).xy) );\n    fragColor.rgb = pow( c, vec3(1.0/2.4) ) + (rnd.x+rnd.y-1.0 ) / 255.0;\n    fragColor.a = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}