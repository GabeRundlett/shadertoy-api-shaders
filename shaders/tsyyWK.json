{
    "Shader": {
        "info": {
            "date": "1603741153",
            "description": "License CC0: Freistil in Colors\n  Created for twitch streamer FullStackLive just for fun\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tsyyWK",
            "likes": 10,
            "name": "Freistil in colors",
            "published": 3,
            "tags": [
                "3d",
                "grid"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 473
        },
        "renderpass": [
            {
                "code": "// License CC0: Freistil in Colors\n//  Created for twitch streamer FullStackLive just for fun\n\n// Heavily inspired by \"Grid of Cylinders\" and while I understood how it worked\n//  in concept I didn't get the math so I had to resort to pen and paper to recreate it :)\n\n// Cylinder intersection by IQ: https://iquilezles.org/articles/intersectors\n// SDFs by IQ: https://iquilezles.org/articles/distfunctions2d\n// Smooth min by IQ: https://iquilezles.org/articles/smin\n\nconst float globalHeight    = 2.75;\nconst float eps             = 1E-4;\nconst float miss            = -1E6;\nconst float delta           = 1.0 ;\n\nconst vec3 lightPos1        = 100.0*vec3(2.0, .35, -1.0);\nconst vec3 lightPos2        = 100.0*vec3(-2.0, 3.0, 1.0);\nconst vec3 lightCol1        = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2        = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nconst vec3 lightDir1        = normalize(lightPos1);\nconst vec3 lightDir2        = normalize(lightPos2);\nconst float pi              = 3.14159654;\nconst float tau             = 2.0*pi;\n\nfloat hash1(vec2 n) { \n  return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); \n}\n\nvec2 mod2_1(inout vec2 x) {\n  vec2 n = floor(x+0.5);\n  x = fract(x+0.5)-0.5;\n  return n;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p)-(b - r);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat tanh_approx(float z) {\n  float z2 = z*z;\n  // z / (1 + z2/(3 + z2/(5 + z2/(7 + ...))))\n  return clamp(z / (1.0 + z2/(3.0+ z2/5.0)), -1.0, 1.0);\n}\n\nvec2 freistil_logo(vec2 p) {\n  vec2 mp = p;\n  vec2 mn = mod2_1(mp);\n  vec2 amp = abs(mp);\n\n  const float lw = 0.03;\n  \n  float d0 = circle(mp, 0.40);\n  vec2 d1 = -(amp-(0.5)) - lw;\n  float d3 = pmin(d1.x, d1.y, 0.1);\n  float d4 = box(p, vec2(3.0/2.0+lw), 0.1);\n\n\n  float d = 1E6;\n  d = (mn.x + mn.y) == 1.0 || mn.y == -1.0 ? d0 : d;\n  d = min(d, d3);\n  d = max(d, d4);\n  return vec2(d, d4);\n}\n\nfloat height(vec2 x, float t) {\n  vec2 n = x;\n  vec2 p = (x) * 0.025;\n  vec2 f = freistil_logo(p)-0.02;\n  float d = f.x;\n  float fh = max(tanh_approx(-d*5.0), 0.0);\n  float nh = hash1(n)*mix(0.35, 1.0, psin(iTime+max(10.0*f.y, 0.0)));\n  float m = 1.0-smoothstep(-0.1, 0.125, f.y);\n  return globalHeight*mix(nh, fh, 0.9*m);\n}\n\nvec4 cylinder(vec3 ro, vec3 rd, vec3 pa, vec3 pb, float ra) {\n  vec3 ba     = pb-pa;\n\n  vec3  oc    = ro - pa;\n\n  float baba  = dot(ba,ba);\n  float bard  = dot(ba,rd);\n  float baoc  = dot(ba,oc);\n   \n  float k2    = baba            - bard*bard;\n  float k1    = baba*dot(oc,rd) - baoc*bard;\n  float k0    = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n  float h     = k1*k1 - k2*k0;\n    \n  if (h<0.0) return vec4(miss);\n  h = sqrt(h);\n    \n  float t = (-k1-h)/k2;\n\n  // body\n  float y = baoc + t*bard;\n  if (y>0.0 && y<baba) return vec4(t, (oc+t*rd - ba*y/baba)/ra);\n   \n  // caps\n  t = (((y<0.0) ? 0.0 : baba) - baoc)/bard;\n  if (abs(k1+k2*t)<h) return vec4(t, ba*sign(y)/sqrt(baba));\n\n  return vec4(miss);\n}\n\nvec4 gridTrace(vec3 ro, vec3 rd, float initial, const int max_iter) {\n  float t = initial;\n\n  vec2 x = 0.5*(1.0 + sign(rd.xz));\n  vec2 y = 1.0/rd.xz;\n  \n  float mt = (-globalHeight - ro.y)/rd.y;\n\n  for (int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + t*rd;\n    vec2 n = floor(p.xz);\n    vec2 m = fract(p.xz);\n\n    float h = height(n, t);\n    float dt = (h - p.y)/rd.y;\n    vec3 tp = p + dt*rd;\n    \n    if (p.y < -globalHeight) {\n      return vec4(mt, vec3(0.0, 1.0, 0.0));\n    }\n    \n    float hh = hash1(n+100.0);\n    \n    if (n == floor(tp.xz)||h > p.y) {\n      vec3 lp = vec3(m.x, p.y, m.y);\n      vec4 c = cylinder(lp, rd, vec3(0.5, -globalHeight, 0.5), vec3(0.5, h, 0.5), 0.35 + 0.145*hh);\n      float tt = t + c.x;\n      \n      if (mt >= 0.0 && tt > mt) {\n        return vec4(mt, vec3(0.0, 1.0, 0.0));\n      }\n      \n      if (c.x >= 0.0) {\n        return vec4(tt, c.yzw);\n      }\n    }\n\n    vec2 z = (x - fract(p.xz))*y;\n    t += min(z.x, z.y) + eps;\n  }\n  \n  return vec4(miss);\n}\n\nvec3 skyColor(vec3 rayDir) {\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n  final += 1.0*pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += 1.0*lightCol1 * pow(ld1, 200.0);\n  return final;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.125);\n  \n  float dup = (1.025*globalHeight - ro.y)/rd.y;\n  vec3 upp = ro + rd*dup;\n\n  vec3 sky = skyColor(rd);\n\n  if (dup > 0.0) {\n    vec4 dgt  = gridTrace(ro, rd, dup, 40);\n    float t   = dgt.x;\n    vec3 nor  = dgt.yzw;\n    vec3 gtp  = ro + rd*t;\n\n    vec2 n = floor(gtp.xz);\n    vec2 m = fract(gtp.xz);\n    float h = height(n, t);\n    float l2 = dot(gtp.xz, gtp.xz);\n\n    vec4 dst  = gridTrace(gtp + nor*0.01, lightDir1, 0.0, 8);\n\n    vec3 refl     = reflect(rd, nor);\n    vec3 reflCol  = skyColor(refl);\n\n    vec3 refr     = refract(rd, nor, 1.25);\n\n    \n    float dif1 = max(dot(lightDir1, nor), 0.0);  \n    float dif2 = max(dot(lightDir2, nor), 0.0);  \n    \n    vec3 baseCol = pow(vec3(0.5 + 0.5*sin(iTime + 0.1*vec3(n, n.x + n.y)/(1.0+0.0000125*l2)))*mix(vec3(1.0), vec3(0.125), tanh(abs(2.0*h))), vec3(1.0, 1.5, 0.5)/(1.0+0.00005*l2));\n\n    float shade = dst.x > miss ? tanh_approx(0.25*dst.x) : 1.0;\n\n    dif1 *= shade;\n    if (dgt.x > miss) {\n      col += baseCol*0.75*mix(0.125, 1.0, sqrt(dif1 + dif2));\n      col += 0.5*sqrt(reflCol)*mix(1.0, shade, max(dot(refl, lightDir1), 0.0));\n      if (refr != vec3(0.0)) {\n        col += 0.3*vec3(1.0)*pow(max(dot(refr, rd), 0.0), 100.0);\n      }\n    } else {\n      col = sky;\n    }\n    \n    float mm = 1.0-max(dot(rd, vec3(0.0, -1.0, 0.0)), 0.0);\n    mm*=mm;\n    col = mix(col, sky, mm*(1.0-exp(-0.0125*max(t-100.0, 0.0))));\n  } else {\n    col = sky;\n  }\n\n  return col;\n}\n\nvec3 pos(float time) {\n  float m1 = smoothstep(0.0, 10.0, time);\n  float m2 = smoothstep(13.0, 30.0, time);\n  float h = mix(10.0, 25.0, m1);\n  vec3 p1 = vec3(15.0*time-250.0, h, 0.5);\n  const float r = 100.0;\n  time *= 0.2;\n  float h2 = mix(25.0, 350.0, m2);\n  vec3 p2 = vec3(-r*sin(time), h2, -r*cos(time));\n  return mix(p1, p2, m2);\n}\n\nvec3 dpos(float time) {\n  float m = smoothstep(0.0, 10.0, time);\n  vec3 dp = (pos(time + delta) - pos(time - delta))/(2.0*delta);\n  rot(dp.xy, mix(1.0, 0.5, m)); \n  return dp;\n}\n\nvec3 ddpos(float time) {\n  vec3 ddp = (dpos(time + delta) - dpos(time - delta))/(2.0*delta);\n  return ddp;\n}\n\nvec3 dir(vec3 ro, float time) {\n  vec3 dpos =  normalize(dpos(time));\n  vec3 la = normalize(vec3(0.0)-ro);\n  float m = smoothstep(13.0, 20.0, time);  \n  return normalize(mix(dpos, la, m));\n}\n\nvec3 up(float time) {\n  vec3 ddp = ddpos(time);  \n  vec3 up = normalize(vec3(0.0, 1.0, 0.0) + 0.1*ddp);\n  float m = 0.5*(tanh(time - 11.0)+1.0);\n  rot(up.yz, m*tau);\n  return up;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n//  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n  p.x *= iResolution.x/ iResolution.y;\n  \n  float aa = 2.0/iResolution.y;\n\n  float tm = mod(iTime, 35.0);\n  vec3 ro  = pos(tm);\n  vec3 dir = dir(ro, tm);\n  vec3 up = up(tm);\n\n  vec3 ww = dir;\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = render(ro, rd);\n  \n  float ss1 = smoothstep(28.00, 35.0, tm);\n  float ss2 = smoothstep(33.0, 35.0, tm);\n  float ss3 = smoothstep(28.00, 31.40, tm);\n  float scale = 0.22+0.1*ss1;\n\n  vec2 lp = p;\n  rot(lp, -0.5*(1.0-tanh((tm-30.0))));\n  vec2 df = freistil_logo(lp/scale)*scale;\n  vec3 col2 = mix(vec3(1.0), vec3(ss2*ss2), smoothstep(-aa, aa, -df.x));\n  col = mix(col, col2, ss3*ss3);\n  \n  float fadeIn = 1.0 - smoothstep(0.0, 3.0, tm);\n  col += fadeIn;\n\n  col = postProcess(col, q);\n    \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}