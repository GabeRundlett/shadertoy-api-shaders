{
    "Shader": {
        "info": {
            "date": "1527513252",
            "description": "watercolor painting with pencil predraw\noriginal version here (better outlines): [url]https://www.shaderoo.org/?shader=1Fh9sQ[/url]\n...basically just simplified pencil-predraw because no geometry possible here",
            "flags": 32,
            "hasliked": 0,
            "id": "4sKfRR",
            "likes": 57,
            "name": "aquarellic",
            "published": 3,
            "tags": [
                "effect",
                "painting"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 4238
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// aquarelle with pencil predraw\n// derived from shaderoo version: https://www.shaderoo.org/?shader=1Fh9sQ\n// ...basically just simplified pencil-predraw because no geometry possible here\n\n// final mixing and some paper-ish noise\n\nvec4 getRand(vec2 pos)\n{\n    vec2 tres = vec2(textureSize(iChannel1,0));\n    vec4 r=texture(iChannel1,pos/tres/sqrt(iResolution.x/600.)*vec2(1,1));\n    return r;\n}\n\n\nvec4 paintCol(vec2 uv)\n{\n    //return vec4(1);\n    vec3 c=texture(iChannel2,uv).xyz;\n    float m = dot(vec3(.333),c);\n    c=(c-m)*1.5+m;\n    c=clamp(.3+.8*c,0.,1.);\n    return vec4(c,1);\n}\n\nvec4 lineCol(vec2 uv)\n{\n    vec4 col=vec4(0);\n    col+=clamp(1.*(1.-textureLod(iChannel3,uv,0.))*11.-1.9,0.,4.);\n    col+=clamp(1.*(1.-textureLod(iChannel3,uv,3.5))*9.-.7,0.,4.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = iResolution.x/600.;\n    //vec4 r = getRand(fragCoord*1.3)-.5;\n    vec4 r = getRand(fragCoord*1.1)-getRand(fragCoord*1.1+vec2(1,-1)*1.5);\n    vec4 r2 = getRand(fragCoord*.015)-.5+getRand(fragCoord*.008)-.5;\n    vec4 pc=paintCol(fragCoord/iResolution.xy);\n    vec2 g=texture(iChannel0,fragCoord/iResolution.xy,3.+log(sc)/log(2.)).zw;\n    vec4 lc=lineCol((fragCoord+normalize(g)*2.*sc)/iResolution.xy).xxxx*(1.25-.5*r.y);\n    vec4 c = 1.-.15*(1.-.7*pow(dot(pc.xyz,vec3(.333)),1.))*lc;\n    c*=pc;\n    //c=1.-.3*lc;\n    //float s=sin(fragCoord.y/iResolution.y*3.1416*15.);\n    //c-=.15*exp(-s*s*300.);\n    fragColor = c*(.95+.06*r.xxxx+.06*r-.0*r2.x);\n    //fragColor = c;\n    vec2 scoord=(fragCoord-.5*iResolution.xy)/iResolution.x;\n    float vign = 1.-.3*dot(scoord,scoord);\n    //vign-=dot(exp(-sin(fragCoord/iResolution.xy*3.14)*vec2(20,10)),vec2(1,1));\n    vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*40.);\n    vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*20.);\n    //fragColor.xyz=vec3(dot(vec3(.33),fragColor.xyz))*vec3(0.7,0.8,1.)*1.2;\n    fragColor *= vign;\n    //fragColor=lineCol(fragCoord/iResolution.xy);\n    //fragColor = texture(iChannel0,fragCoord/iResolution.xy,2.);\n\n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// aquarelle with pencil predraw\n\n// preparing the input vid\n\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c1=texture(iChannel0,uv);\n    vec4 c2=texture(iChannel1,(uv+.0*sin(vec2(0,1.6)+iTime))*.1).xxxz*.2+.7;\n    //c2 = vec4(1);\n    fragColor = mix(c1,c2,clamp(dot(c1.xyz,vec3(-2.5,4.7,-2.5)),0.,1.));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// aquarelle with pencil predraw\n\n// some gradient precalcs\n\n#define ImageTex iChannel0\n\n//#define Res0 vec2(textureSize(iChannel0,0))\n\n#define Res0 (iResolution.xy)\n\nvec4 getCol(vec2 pos, float lod)\n{\n    vec2 tres = vec2(textureSize(ImageTex,0));\n    // use max(...) for fitting full image or min(...) for fitting only one dir\n    vec2 tpos = (pos-.5*Res0.xy)*min(tres.y/Res0.y,tres.x/Res0.x);\n    vec2 uv = (tpos+tres*.5)/tres;\n    //uv = pos/tres;\n    vec2 mask = step(vec2(-.5),-abs(uv-.5));\n    return textureLod(ImageTex,uv,lod)*mask.x*mask.y;\n}\n\nfloat getVal(vec2 pos, float lod)\n{\n    return dot(getCol(pos,lod).xyz,vec3(1)/3.);\n}\n\nvec2 getGrad(vec2 pos, float eps, float lod)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy,lod)-getVal(pos-d.xy,lod),\n        getVal(pos+d.yx,lod)-getVal(pos-d.yx,lod)\n        )/eps/2.;\n}\n\nvec2 getGradDiv(vec2 pos, float eps,float lod)\n{\n    vec2 g=getGrad(pos,eps,lod);\n    vec2 ng=normalize(g);\n    vec2 g2=getGrad(pos+eps*ng,eps,lod);\n    return ng*dot(g2-g,ng)/eps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0,0,0,0);\n    float ssc=(vec2(textureSize(iChannel0,0)).x/800.);\n    float sc=1.;\n    for(int i=0;i<5;i++)\n    {\n        fragColor.xy+=ssc*20.*sc*getGradDiv(fragCoord,1.5*sc,float(i)+log(ssc)/8.).xy;\n        //fragColor.zw+=10.*getGrad(fragCoord,.5*sc,float(i)).xy;\n        sc*=2.;\n    }\n    fragColor.zw=20.*getGrad(fragCoord,1.5,0.).xy*ssc;\n    //fragColor+=.5;\n    //fragColor.xyz=vec3(0)+150.*length(getGradDiv(fragCoord,1.5).xy);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// aquarelle with pencil predraw\n\n// trying to resemble watercolors\n\n#define Res  iResolution.xy\n#define Res0 vec2(596,336)\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#define PI 3.14159265358979\n\n//#define GREEN_SCREEN\n\nvec4 cquant(vec4 c, ivec4 q)\n{\n    return floor(c*vec4(q)+.5)/vec4(q);\n}\n\nvec4 getRand(vec2 pos) \n{\n    vec2 uv=pos/Res1;\n    return texture(iChannel1,uv);\n}\n\nvec4 getCol(vec2 pos)\n{\n    vec2 uv=pos/Res0;\n    vec4 c1 = texture(iChannel0,uv);\n    vec4 c2 = vec4(1.5); // bright white on greenscreen\n    float d = clamp(dot(c1.xyz,vec3(-0.5,1.0,-0.5)),0.0,1.0);\n    //return mix(c1,c2,1.8*d);\n    //ignore greenscreen\n    #ifdef GREEN_SCREEN\n    return cquant(mix(c1,c2,1.8*d),ivec4(4,4,4,1000));\n    #else\n    float sc=600./iResolution.x;\n    float rnd=getRand(pos*.2*sc).x-.5;\n    float vign = clamp(1.2-pow(dot(uv-.5,uv-.5)*3.2,2.)+.2*rnd,0.,1.);\n    return mix(vec4(1),c1,vign);\n    return cquant(c1,ivec4(50,16,16,1000));\n    #endif\n}\n\nvec2 getGrad(vec2 pos,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        dot((getCol(pos+d.xy)-getCol(pos-d.xy)).xyz,vec3(.333)),\n        dot((getCol(pos+d.yx)-getCol(pos-d.yx)).xyz,vec3(.333))\n    )/delta;\n}\n\nfloat htPattern(vec2 pos)\n{\n    float p;\n    float r=getRand(pos*.4/.7*1.).x;\n  \tp=clamp((pow(r+.3,2.)-.45),0.,1.);\n    return p;\n}\n\nfloat getVal(vec2 pos, float level)\n{\n    return length(getCol(pos).xyz)+0.0001*length(pos-0.5*Res0);\n    return dot(getCol(pos).xyz,vec3(.333));\n}\n    \nvec4 getBWDist(vec2 pos)\n{\n    return vec4(smoothstep(.9,1.1,getVal(pos,0.)*.9+htPattern(pos*.7)));\n}\n\n#define SampNum 24\n\n#define N(a) (a.yx*vec2(1,-1))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc=600./iResolution.x;\n    vec2 pos=((fragCoord-Res.xy*.5)*min(Res0.x/Res.x,Res0.y/Res.y))+Res0.xy*.5;\n    pos=fragCoord/iResolution.xy*Res0.xy;\n    vec2 pos1=pos;\n    vec2 pos2=pos;\n    vec3 col=vec3(0);\n    float cnt=0.;\n    for(int i=0;i<1*SampNum;i++)\n    {   \n        // gradient for wash effect (white on green screen)\n        vec2 gr1=getGrad(pos1,2.0)+.03*(getRand(pos1).xy-.5);\n        vec2 gr2=getGrad(pos2,2.0)+.03*(getRand(pos2).xy-.5);\n        float gr1l=length(gr1);\n        float gr2l=length(gr2);\n\n        float fact=float(i)/float(SampNum);\n\n        // colors + wash effect on gradients:\n        // color gets lost from dark areas\n        pos1+=normalize(mix(gr1,N(gr1),15.*length(gr1)))/(1.+15.*length(gr1));\n        // to bright areas\n        pos2-=normalize(mix(gr2,-N(gr2),15.*length(gr2)))/(1.+15.*length(gr2));\n        \n        //float f1=smoothstep(-.2,.2,1.-2.*fact)*2.-1.;\n        float f1=-.25*fact;\n        //float f1=1.-2.*fact;\n        float f2=fact; \n        //col+=f1*(getCol(pos1).xyz+.6*(getRand(pos1*4.*(1.+gr1l)).xyz-.5));\n        //col+=f2*(getCol(pos2).xyz+.6*(getRand(pos2*4.*(1.+gr2l)).xyz-.5));\n        col+=f1*(getCol(pos1).xyz+.05*(getRand(pos1/4./(1.+gr1l)).xyz-.5));\n        col+=f2*(getCol(pos2).xyz+.05*(getRand(pos2/4./(1.+gr2l)).xyz-.5));\n        \n        cnt+=f1+f2;\n    }\n    // normalize\n    col/=cnt;\n    col=clamp(col,0.,1.);\n\tfragColor = vec4(col,1.0);\n\t//fragColor = cquant(texture(iChannel0,fragCoord/iResolution.xy),ivec4(4,4,4,1000));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// aquarelle with pencil predraw\n// not as fine-lined as in the original: https://www.shaderoo.org/?shader=1Fh9sQ\n\n// trying to resemble pencil sketch outlines\n\nvec4 getRand(vec2 pos)\n{\n    vec2 tres=vec2(textureSize(iChannel1,0));\n    return texture(iChannel1,pos/tres.xy);\n}\n\nvec4 getCol(vec2 pos)\n{\n    return texture(iChannel0,pos/iResolution.xy);\n}\n\nfloat getVal(vec2 pos)\n{\n    return clamp(dot(getCol(pos).xyz,vec3(.333)),0.,1.);\n}\n\nvec2 getGrad(vec2 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy)-getVal(pos-d.xy),\n        getVal(pos+d.yx)-getVal(pos-d.yx)\n        )/eps/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c=vec3(0);\n    \n    float sc=iResolution.x/600.;\n    \n    vec2 g=texture(iChannel2,fragCoord/iResolution.xy,3.).zw;\n    \n    float tFact=0.;\n    int NUM=4;\n    for(int i=0;i<NUM;i++)\n    {\n        vec4 r1 = getRand(fragCoord*.05/sc+float(i)*vec2(113,17)+iTime*tFact);\n        vec4 r2 = getRand(fragCoord*.10/sc+float(i)*vec2(113,17)+iTime*tFact);\n        vec4 rm = getRand(fragCoord*.06/sc+float(i/2)*vec2(113,17)+iTime*tFact);\n        vec2 offs=(r2.xy-.5)*4.+(r1.xy-.5)*7.;\n        float m = clamp((rm.z-.5)*10.+.5,0.,1.);\n        m=((i%2==0)?m:(1.-m));\n        //m=1.;\n        c+= 5.*pow(length(getGrad(fragCoord+offs*sc,.3*sc))*sc,0.7)*m;\n        c-=10.*pow(length(getGrad(fragCoord+offs*sc,.3*sc))*sc,1.9)*m;\n    }\n    c/=float(NUM);\n    \n    float vign = 1.-pow(length(fragCoord/iResolution.xy-.5)*1.5,8.);\n    \n    fragColor.xyz=1.-c*vign;\n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}