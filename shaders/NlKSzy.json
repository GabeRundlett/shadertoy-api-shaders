{
    "Shader": {
        "info": {
            "date": "1641029428",
            "description": "Attaching a double sided Truchet weave to the triangle cells of a subdivided icosahedron.",
            "flags": 32,
            "hasliked": 0,
            "id": "NlKSzy",
            "likes": 72,
            "name": "Icosahedral Double Weave",
            "published": 3,
            "tags": [
                "bezier",
                "map",
                "truchet",
                "pattern",
                "icosahedron",
                "spherical",
                "polyhedron",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1512
        },
        "renderpass": [
            {
                "code": "/*\n\n    Icosahedral Double Weave\n    ------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    //\n    // See Buffer A for an explanation.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Icosahedral Double Weave\n    ------------------------\n    \n    Quite some time ago, BigWIngs constructed a Truchet pattern consisting of\n    segments that entered and exited from two points on each side of a repeat \n    polygon cell, which I thought was pretty awesome. He also cube mapped the \n    results. After that, a lot of people, including myself, produced a heap of \n    variations. I coded an icosahedral one not long afterwards, but Flockaroo, \n    who codes a lot faster than me, was able to post one straight away, so my \n    version has sat around gathering pixel dust on my hard-drive, as they say. :)\n    \n    Anyway, I dusted off the code not long ago, addressed a few problems that \n    had been bugging me, prettied it up a bit, and now it's done... two years\n    after starting. :D You can never be sure, but as far as I can tell, \n    everything should line up perfectly with no fudge figures, etc. I've \n    rendered it in a similar style to BigWIngs's cube-mapped original to pay \n    hommage, but put some of my own touches in as well. \n    \n    Producing one of these patterns, or any icosahedral cell based pattern,\n    comes down to how easily you can uniquely identify and obtain the cell \n    information from one of the individual polygons. There are three main ways \n    to go about it: Brute force iteration, folding space, and spherical \n    coordinates. Each have their merits, but I went with the latter.\n    \n    Working with polyhedra, spherical coordinates, etc, can be a little tricky \n    and offputting, and attaching Beziers can add to the confusion, so \n    unfortunately, there aren't a lot of working examples to refer to. However, \n    if you are new but interested in this kind of thing, I'd suggest looking at \n    Flockaroo's examples.\n    \n    The algorithm I hacked together to produce the icosahedral cell information \n    is reasonbly fast and it works, but it could definitely be improved. It's \n    not as fast as Flockaroo's new function, and it would have been nice to drop \n    that in, but I think there are some wrapping issues that would need to be \n    ironed out first. TDHooper has a really promising algorithm based on folding \n    techniques, but I wasn't able to use it to correctly produce the cell \n    information I was after. Mattz also has some nicely written stuff, but I \n    haven't really had a chance to peruse through it.\n    \n    Once you have the triangle information, it's a matter of randomly connecting\n    the entry and exit points with curves. I was hoping to find a better way,\n    but unfortunately was forced to use piecewise Bezier curves. They get the job \n    done, but I'll be looking for something better when producing more \n    sophisticated examples. \n   \n\n    \n\n\tInspired by:\n    \n    // The original: I'd imagine BigWIngs is pretty busy these days being\n    // YouTube code famous, and all that, but I hope he still finds time \n    // for more posts. :)\n    Cube-mapped Double Quad Truchet - BigWIngs\n    https://www.shadertoy.com/view/wlSGDD\n    \n\t// I think Flockaroo produced this from inception in a day. It takes me \n    // that long just to choose a color. :D\n    tri truch ballala  - flockaroo\n\thttps://www.shadertoy.com/view/tl23DK\n    \n    // In terms of aesthetics and sheer technical ability, this would\n    // have to be one of my favorites.\n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n// Color: Green 0, Pinkish Red: 1, Blue: 2.\n#define COLOR 0\n\n// I've called it a scheme because I plan to expand on it, but for now\n// it's just a representation of the amount of subdisions, which is \n// one, two or none at all. The latter looks pretty boring, but allows\n// you to study the pattern and joins more closely.\n//\n// No subdivsions: 0, One subdivision: 1, Two subdivisions: 2.\n#define SCHEME 2\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n*/\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n    \n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3.);\n    p.yz *= rot2(iTime/6.); \n    \n    return p;\n    \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    float wall = -(length(p - sphPos - vec3(0, 0, -(16. - 2.))) - 16.);\n     // Flat plane back wall.\n    //float wall = -p.z + 2.;\n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(q) - .5;\n    \n \n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, 1e5, 1e5);\n    \n    // Shortest distance.\n    return  min(sph, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n///////\n\n/* \n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r){\n\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n \n\n// IQ's polynomial-based smooth minimum function.\nvec3 smin( vec3 a, vec3 b, float r){\n\n   vec3 f = max(1. - abs(b - a)/r, 0.);\n   return min(a, b) - r*.25*f*f;\n}\n*/\n/////////\n\n\n\n// vec4 swap.\n//void swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout vec4 a, inout vec4 b){ a = a + b; b = a - b; a = a - b; }\n\n \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : - 1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n\n\n    return q;\n}\n\n\n\n\n/////////\n\n// IQ's line distance formula.\nfloat distLine(vec3 p, vec3 a, vec3 b){\n\n    //return abs(dot(cross(a, b)/length(a - b), normalize(p)));\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Standard cubic Bezier interpolation.\nvec4 bezierT(in float t){ \n    float u = 1. - t;\n    return vec4(u*u*u, t*u*u*3., t*t*u*3., t*t*t);\n}\n\n// Cubic Bezier spline -- Not cheap, unfortunately, but thankfully,\n// it's good enough for this example. I was hoping there'd be a better way,\n// but so far, it appears to be the only way.\nfloat distSpline(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n\n    // Distance.\n    float d = 1e5, t = 0.;\n    \n    mat4x3 m43 = mat4x3(p0, p1, p2, p3);\n    \n    // It's not absolutely necessary, but I'm mapping the points\n    // to the surface of the sphere as I go along.\n    vec3 bc1 = normalize(p0)*.5;//normalize(m43*bezierT(0.))*.5;\n\n    // Several lines to approximate a smooth curve. Ouch! :) It's being called\n    // outside the raymarching loop, so we can get away with it.\n    const int N = 16;\n    for(int i = 0; i<N; i++){    \n        vec3 bc2 = m43*bezierT(float(i + 1)/float(N));\n        bc2 = normalize(bc2)*.5; // Mapping to the surface of the sphere.\n        d = min(d, distLine(p, bc1, bc2));\n        bc1 = bc2;\n    }\n   \n    return d;\n}\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n#if SCHEME == 0\nconst float scale = 1./2.;\n#elif SCHEME == 1\nconst float scale = 1./2.5;\n#else\nconst float scale = 1./3.;\n#endif\n\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n\nfloat gTri;\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle. These have been expanded 3 fold to \n    // account for GPU inaccuracies when dealing with irrational numbers. On a GPU, \n    // \"1./3.\" and \"1. - 2./3.\" are not the same thing, but they need to be for hash \n    // logic to work. However \"1.\" and \"3. - 2.\" are precisely the same.\n    if(gTri<0.){\n        vID = vec2[3](vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = vec2[3](vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.;//(v[0] + v[1] + v[2])/3.;//\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n     // Centered ID.\n    vec2 ctrID = vID[2]; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;\n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n \n \n \n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n\n//////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .5, -2);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        // General scene color.\n        //\n        \n        #if COLOR == 0\n        vec3 lCol = vec3(.45, .9, .2);\n        lCol = mix(lCol.zyx, lCol, clamp(rd.y*2. + 1., 0., 1.));\n        #elif COLOR == 1\n        vec3 lCol = vec3(1.75, .12, .35);\n        lCol = mix(lCol, vec3(1.2, .7, .1), clamp(rd.y*2. + .8, 0., 1.)*.2);\n        #else\n        vec3 lCol = mix(vec3(.2, .6, 1.5), vec3(.1, .9, .7), clamp(rd.y*2. + 1., 0., 1.)*.5);\n        #endif\n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            vec3[3] gVert, gVertID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, gVertID, rad);\n   \n            gVert[0] = sphericalToWorld(gVertID[0]);//vec3(0, rad, 0);\n            gVert[1] = sphericalToWorld(gVertID[1]);\n            gVert[2] = sphericalToWorld(gVertID[2]);\n            \n            \n            vec3[3] v = gVert, vID = gVertID;\n            \n            // Edge mid points, edge tangents and exit and entry points.\n            vec3[3] vE, vN;\n            vec3[6] vE2;\n            \n            // Edge mid points.\n            vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n            vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n            vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n             \n            \n            /////\n            #if SCHEME > 0\n            // Triangle subdivision, if desired.\n            //\n            // Number of subdivisions.\n            #if SCHEME == 1\n            const int subDivNum = 1;\n            #else\n            const int subDivNum = 2;\n            #endif\n            //\n            // There'd be faster ways to do this, but this is\n            // relatively cheap, and it works well enough.\n            for(int i = 0; i<subDivNum; i++){\n            \n                // Create three line boundaries within the triangle to \n                // partition into four triangles. Pretty standard stuff.\n                // By the way, there are other partitionings, but this \n                // is the most common. At some stage, I'll include some\n                // others, like the three triangle version connecting the \n                // center to the vertices.\n                //\n                if(dot(lq, cross(vE[0], vE[1]))>0.){\n                    v[0] = vE[0]; v[2] = vE[1];\n                }\n                else if(dot(lq, cross(vE[1], vE[2]))>0.){\n                    v[0] = vE[2]; v[1] = vE[1];\n                }\n                else if(dot(lq, cross(vE[2], vE[0]))>0.){\n                    v[1] = vE[0]; v[2] = vE[2];\n                }\n                else {\n                    v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n                }\n                \n                // Recalculating the edge mid-vectors for the next iteration.\n                vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n                vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n                vE[2] = normalize(mix(v[2], v[0], .5))*rad;                \n            }\n            #endif\n            /////    \n            \n  \n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness.\n            vec3 ctr = normalize((v[0] + v[1] + v[2]))*rad;\n            // The unique cell ID, which is used for randomness, etc.\n            vec3 id = ctr;\n            \n \n\n\n            // Icosahedral cell boundary.\n            //\n            // Rendering lines on a sphere is a little different to those on a plane.\n            // Lines between points translate to great arcs between points. This is\n            // just three triangle edge borders. I normally do these individually, but\n            // discovered this matrix short cut in on of Mattz's examples. Quite obvious...\n            // once someone else did it. :)\n            mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n            vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n            \n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            float line = min(min(ep.x, ep.y), ep.z) - .0035;\n \n            \n            \n            // Calculating the tangent vectors for each edge, as well as the two\n            // entry and exit points on each side of the mid-edge point. All are\n            // used to produce the random curves within each triangle cell.\n            for(int i = 0; i<3; i++){\n                \n                // Edge tangent vectors.\n                vN[i] = normalize(cross(v[(i + 1)%3] - v[i], v[i]));\n                // Cheap shortcut, but not quite accurate.\n                //vN[i] = normalize(mix(v[(i + 2)%3], vE[i], .95) - vE[i]);\n                // Due to the spherical correction in the Bezier function,\n                // this could be used.\n                //vN[i] = normalize(v[(i + 2)%3] - vE[i]);\n                \n                // Edge entry points -- One on each side of the mid point.\n                float mOffs = .5/2.6; // Edge mid point offset.\n                vE2[i*2] = normalize(mix(v[i], v[(i + 1)%3], .5 - mOffs))*rad;\n                vE2[i*2 + 1] = normalize(mix(v[i], v[(i + 1)%3], .5 + mOffs))*rad;\n\n            } \n\n            \n\n            // Shuffling the 6 array points and normals by shuffling an array of indices. I \n            // think this is the Fisher–Yates method, but don't quote me on it. It's been a \n            // while since I've used a shuffling algorithm, so if there are inconsistancies, etc,\n            // feel free to let me know -- It seems to work though, so that's a good sign. :)\n            //\n            // For various combinatorial reasons, some non overlapping tiles will probably be \n            // rendered more often, but generally speaking, the following should suffice.\n            //\n            // Indices for randomization.\n            int[6] iRnd = int[6](0, 1, 2, 3, 4, 5);\n            //int[6] iRnd = int[6](0, 2, 4, 1, 3, 5);\n            //\n            for(int i = 5; i>0; i--){\n\n                // Using the cell ID and shuffle number to generate a unique random number.\n                float fi = float(i);\n\n                // Random number for each triangle: The figure \"id\" is unique for\n                // each triangle, and \"id + fi/24.\" should be unique for each iteration.\n                float rs = hash31(id + fi/24. + .0273);\n\n                // Other array point we're swapping with.\n                //int j = int(floor(mod(rs*6e6, fi + 1.)));\n                // I think this does something similar to the line above, but if not, let us know.\n                int j = int(floor(rs*(fi + .9999)));\n                //swap(iRnd[i], iRnd[j]);\n                // Swap.\n                int tmp = iRnd[i]; iRnd[i] = iRnd[j]; iRnd[j] = tmp;\n\n            } \n\n            // Rendering the spline curves between entry and exit points. There are six\n            // alltogether. We're indexing into random indices, and that creates the \n            // randomness, strangely enough. :)\n            vec3 ln = vec3(1e5);\n            for(int i = 0; i<3; i++){\n                \n                // Two random indices pointing to random entry and exit points.\n                int iR = iRnd[(i*2)];\n                int iRN = iRnd[(i*2 + 1)%6];\n\n                // How far we wish to nudge out the second Bezier point in the direction\n                // of the edge normal... That's an artform in its own right, which is\n                // just another way to say, I'm guessing. :)\n                float ndg = length(vE2[iR] - vE2[iRN])/2.5;\n                //if(ndg<.001) ndg *= 2.;\n                // Based purely on observation, exit and entry points on the same edge \n                // need the tangent points edged out more. \n                if(iR/2 == iRN/2) ndg *= 2.;//length(vE2[iR])/6. + length(vE2[iRN])/6.;\n                \n                // Take four points and render a spline curve. Rendering spline curves\n                // is simple enough, but if you're not sure\n                ln[i] = distSpline(lq, vE2[iR], vE2[iR] + vN[iR/2]*ndg, \n                                       vE2[iRN] + vN[iRN/2]*ndg, vE2[iRN]); \n\n\n            }\n\n            // Give the edge some thickness.\n            #if SCHEME > 1\n            ln -= .01;\n            #else\n            ln -= .02;\n            #endif\n            \n            \n            \n            // Rendering the vertices, borders and Bezier curvers.\n            \n            \n            // Smoothing factor.\n            float sf = .003; \n            \n            // Initial background color.\n            texCol = vec3(.05); \n            \n            // Cell border lines.\n            texCol = mix(texCol, vec3(.2), (1. - smoothstep(0., sf*2., line ))*.35);\n            texCol = mix(texCol, vec3(.0), (1. - smoothstep(0., sf, line))*.9);\n            \n            // Cell vertices.\n            vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            float vert = min(min(v3.x, v3.y), v3.z) - .01;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert - .005))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .005));\n            texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .005));\n\n \n            // Rendering the bezier curves themselves. \n            for(int i = 0; i<3; i++){\n                //float sh = max(.15 - ln[i]/.01, 0.);\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., ln[i] - .01))*.5);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, ln[i] - .0085));\n                texCol = mix(texCol, lCol*1.2, 1. - smoothstep(0., sf, ln[i]));\n                #if SCHEME <= 1\n                texCol = mix(texCol, lCol/2.6, 1. - smoothstep(0., sf, abs(ln[i] + .011) - .0025));\n                #else\n                texCol = mix(texCol, lCol/2.6, 1. - smoothstep(0., sf, ln[i] + .006));\n                #endif\n            }\n            \n    \n            \n        }\n        else if(objID==1){ \n        \n            //  Wall.\n            \n            \n            // Texture coordinates and normal.\n            vec3 txP = sp;\n            vec3 txN = sn;\n            \n            // Rotating the pattern for a different perspective.\n            //txP.xy *= rot2(3.14159/6.);\n         \n            // Intial background color.\n            texCol = vec3(.04);\n            \n            // Cell coordinate, ID and triangle orientation id.\n            // Cell vertices and vertex ID.\n            vec2[3] v, vID;\n\n            // Returns the local coordinates (centered on zero), cellID, the \n            // triangle vertex ID and relative coordinates.\n            vec4 p4 = getTriVerts(txP.xy, vID, v);\n            vec2 p = p4.xy;\n            vec2 id = p4.zw;\n            float tri = gTri;\n            vec2 triID = id;// + (vID[0] + vID[1] + vID[2])/3.;\n            \n            // Smoothing factor.\n            float sf = .003;\n            \n            // Nearest vertex ID.\n            float vert = 1e5;\n            \n            vec2 vertID;\n            for(int i = 0; i<3; i++){\n                float vDist = length(p - v[i]);\n                if(vDist<vert){\n                    vert = vDist;\n                    vertID = id + vID[i];\n                }\n            }\n            \n            \n            \n            vert -= .0275;\n             \n            // Border triangles, bump highlights, etc. It was made up on the spot, and\n            // I'm pretty sure there'd be better ways to do it. 3D bump mapping would\n            // be better, but I'm keeping things simple and cheaper.\n            vec2 q = p*vec2(1, tri);\n            float tr = (max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3. + .01)/1.;\n            float trr = length(q);\n            q -= ld.xy*.005*(tri<0.? vec2(1) : vec2(1, -1));\n            //float tr2 = (max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3. + .01)/1.;\n            float trr2 = length(q);\n            //float b = max(tr2 - tr, 0.)/.005;\n            float b2 = max(trr2 - trr, 0.)/.005;\n       \n            // Blinking vertex color.\n            float rndVert = hash21(vertID);\n            float rnd = smoothstep(.9, .97, sin(rndVert*6.2831 + iTime)*.5 + .5);\n            lCol = mix(vec3(.1), lCol, rnd);\n            \n            // Triangle pattern.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., tr - .005))*.5);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, tr - .005))*.9);\n            texCol = mix(texCol, vec3(.05) + vec3(.2, .4, 1)*lCol*b2*.3, 1. - smoothstep(0., sf, tr));\n            texCol = mix(texCol, texCol/2.5, 1. - smoothstep(0., sf, abs(tr + .025) - .005));\n         \n            // Vertices.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., vert - .015))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .015));\n            texCol = mix(texCol, lCol, 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .015));\n\n            \n            // Last minite 2D simplex weave pattern: Create 3 arcs about each vertex\n            // point, then randomly render each over one another. I have one of these\n            // on Shadertoy somewhere.\n            vec3 v3 = vec3(length(p - v[0]), length(p - v[1]), length(p - v[2])); \n            //vert = min(min(v3.x, v3.y), v3.z) - .01;\n            //\n            // Random rotation.\n            float rndI = hash21(id);\n            if(rndI<.333) v3 = v3.yzx;\n            else if(rndI<.666) v3 = v3.zxy;\n            \n            // Arc distance fields.\n            float sl = length(v[0] - v[2])/2.;\n            vec3 arc = abs(v3 - sl) - .025;\n            // Double arc: Cool, but a little busy for this example.\n            //arc = abs(arc - .025) - .025; \n            \n            // Rendering the arc shadows, stroke, main layer, etc, over the top of one another.\n            for(int i = 0; i<3; i++){\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., arc[i] - .01))*.35);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, arc[i] - .01));\n                texCol = mix(texCol, vec3(.07), 1. - smoothstep(0., sf, arc[i]));\n                texCol = mix(texCol, vec3(.07)/2.6, 1. - smoothstep(0., sf, arc[i] + .015));\n            }\n \n            \n        }\n        /*\n        // Extra objects.\n        else if(objID==2){ \n\n            texCol = vec3(1);\n        }\n        else { // Wall.\n   \n            texCol = vec3(1);\n        }\n        */\n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .5, .2)*spec*freS*sh*2. + vec3(.2, .4, 1)*fre*sh);\n \n\n\n            // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(aCol, 0.), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}