{
    "Shader": {
        "info": {
            "date": "1572810624",
            "description": "Green chicken is flying in shaderland",
            "flags": 0,
            "hasliked": 0,
            "id": "wddXWS",
            "likes": 3,
            "name": "Shadertober 31 Ripe",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "chicken",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 422
        },
        "renderpass": [
            {
                "code": "// Final SHADERTOBER 31 Ripe (actually, it's GREEN CHICKEN)\n// Poulet Vert 03-11-2019\n// thanks everyone for your advices, tricks, functions\n// i learned a lot and it's because of this great community\n\n#define VOLUME 0.001\n#define PI 3.14159\n\n//MICROSOFT PAINT COLORS ftw\n#define black   vec3(0.0, 0.0, 0.0)\n#define white   vec3(1.0, 1.0, 1.0)\n#define gray1   vec3(0.4980, 0.4980, 0.4980)\n#define gray2   vec3(0.7647, 0.7647, 0.7647)\n#define brown1  vec3(0.5333, 0.0, 0.0823)\n#define brown2  vec3(0.7254, 0.4784, 0.3411)\n#define red1    vec3(0.9294, 0.1098, 0.1411)\n#define red2    vec3(1.0, 0.6823, 0.7882)\n#define orange1 vec3(1.0, 0.4980, 0.1529)\n#define orange2 vec3(1.0, 0.7882, 0.0549)\n#define yellow1 vec3(1.0, 0.9490, 0.0)\n#define yellow2 vec3(0.9372, 0.8941, 0.6901)\n#define green1  vec3(0.7098, 0.9019, 0.1137)\n#define green2  vec3(0.1333, 0.6941, 0.2980)\n#define cyan1   vec3(0.0, 0.6352, 0.9098)\n#define cyan2   vec3(0.6, 0.8509, 0.9176)\n#define blue1   vec3(0.2470, 0.2823, 0.8)\n#define blue2   vec3(0.4392, 0.5725, 0.7450)\n#define purple1 vec3(0.6392, 0.2862, 0.6431)\n#define purple2 vec3(0.7843, 0.7490, 0.9058)\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opP2( vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : max(d1, d2);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// iq based line function\nfloat sdLine( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Scene setup\nvec2 map(vec3 p)\n{\n    \n    // world\n    vec3 gp = p;\n    gp.xy *= rot(p.z*.02+sin(iTime)*.5);\n    vec3 wp = gp + vec3(0.0, -.5, 0.0);\n    wp = opRep(wp, vec3(1.0));\n    float world = sdBox(wp, vec3(1.0));\n    \n    vec3 swp = gp + vec3(0.0, -.5, 0.0);\n    swp = opRep(swp, vec3(0.0, 0.0, 2.0));\n    float sworld = sdBox(swp, vec3(2.0));\n    world = max(world, -sworld);\n    \n    // particules\n    vec3 pp = p + vec3(1.0, 0.0, 0.0);\n    pp.xy *= rot(iTime+p.z);\n    pp.z += iTime*5.0;\n    pp.y += sin(iTime);\n    pp = opRep(pp, vec3(0.0, 0.0, 5.0));\n    float pb = sdBox(pp, vec3(.1));\n    \n    pp = p + vec3(-1.0, 0.0, .5);\n    pp.xy *= rot(iTime+p.z);\n    pp.z += iTime*5.0;\n    pp.y += sin(iTime);\n    pp = opRep(pp, vec3(0.0, 0.0, 5.0));\n    pb = min(pb, sdBox(pp, vec3(.1)));\n    \n    // body\n    vec3 b = p + vec3(0.0);\n    b.xy *= rot(sin(p.y+iTime)*.5);\n    float body = sdVerticalCapsule(b, 1.0, .5);\n    vec3 shl = b + vec3(0.0, -.0, 0.0);\n    \n    // left arm\n    vec3 la = shl + vec3(-.4, -0.7, 0.0);\n    la.x -= sin(la.y*5.+iTime*5.0)*.1;\n    vec3 l1l = vec3(.75, .75, 0.0);\n    float l1 = sdLine(la, vec3(0.0, 0.0, 0.0), l1l);\n    l1 -= 0.1;\n    float larm = l1;\n    \n    // right arm\n    vec3 ra = shl + vec3(.4, -0.7, 0.0);\n    ra.x += sin(ra.y*5.+iTime*5.0)*.1;\n    vec3 r1l = vec3(-.75, .75, 0.0);\n    float r1 = sdLine(ra, vec3(0.0, 0.0, 0.0), r1l);\n    r1 -= 0.1;\n    float rarm = r1;\n    \n    // left foot\n    vec3 lf = b + vec3(.3, .3, 0.0);\n    lf.x += sin(lf.y*5.0+iTime*5.0)*.1;\n    vec3 lf1l = vec3(-.5, -.5, 0.0);\n    float lf1 = sdLine(lf, vec3(0.0, 0.0, 0.0), lf1l);\n    lf1 -= 0.2;\n    float lleg = lf1;\n    \n    // right foot\n    vec3 rf = b + vec3(-.3, .3, 0.0);\n    rf.x += sin(rf.y*5.0+1.0+iTime*5.0)*.1;\n    vec3 rf1l = vec3(.5, -.5, 0.0);\n    float rf1 = sdLine(rf, vec3(0.0, 0.0, 0.0), rf1l);\n    rf1 -= 0.2;\n    float rleg = rf1;\n    \n    // rooster top\n    vec3 roo = b + vec3(0.0, -1.5, -0.2);\n    float rooster = sdSphere(roo, .2);\n    roo = b + vec3(0.0, -1.5, 0.0);\n    rooster = min(rooster, sdSphere(roo, .25));\n    roo = b + vec3(0.0, -1.5, 0.2);\n    rooster = min(rooster, sdSphere(roo, .2));\n    \n    // eyes du cul\n    vec3 be = b + vec3(0.0, -.95, -0.4);\n    vec3 ep = be + vec3(0.2, 0.0, 0.0);\n    float eyes = sdSphere(ep, .15);\n    ep = be + vec3(-0.2, 0.0, 0.0);\n    eyes = min(eyes, sdSphere(ep, .15));\n    vec3 se = be + vec3(0.0, -.3, 0.0);\n    float subEye = sdSphere(se, .35);\n    eyes = max(eyes, -subEye);\n    \n    // pupil\n    vec3 pup = be + vec3(0.2, 0.0, -0.2);\n    float pupi = sdSphere(pup, .04);\n    pup = be + vec3(-0.2, 0.0, -0.2);\n    pupi = min(pupi, sdSphere(pup, .04));\n    \n    // mouth\n    vec3 mp = b + vec3(0.0, -0.7, -0.5);\n    float mouth = sdSphere(mp, .3);\n    mp = b + vec3(0.0, -1.0, -0.5);\n    mouth = max(mouth, -sdSphere(mp, .4));\n    body = max(body, -mouth);\n    \n    // materials\n    vec2 scene = vec2(body, 0.0);\n    scene = opU2(scene, vec2(larm, 0.0));\n    scene = opU2(scene, vec2(rarm, 0.0));\n    scene = opU2(scene, vec2(lleg, 0.0));\n    scene = opU2(scene, vec2(rleg, 0.0));\n    scene = opU2(scene, vec2(rooster, 1.0));\n    scene = opU2(scene, vec2(eyes, 2.0));\n    scene = opU2(scene, vec2(pupi, 3.0));\n    \n    scene = opP2(scene, vec2(mouth, 4.0));\n    \n    scene = opU2(scene, vec2(world, 5.0));\n    scene = opU2(scene, vec2(pb, 6.0));\n    \n    return scene; \n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x) - c);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv, float time)\n{\n    \n    \n    // map stuffs\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 nor = GetNormal(pos);\n    vec3 light = vec3(sin(time), 1.0, cos(time));\n    float l = clamp(dot(nor, light), 0.0, 1.0);\n    \n    if(t.x == -1.0)\n    {\n            \n        col = black;\n    }\n    else\n    {   \n        if(t.y==0.0)\n        {\n            col = mix(green1, green2, step(l, .5));\n        }\n        else if(t.y==1.0)\n        {\n            col = mix(red1, brown1, step(l, .5));\n        }\n        else if(t.y==2.0)\n        {\n            col = mix(white, gray2, step(l, .1));\n        }\n        else if(t.y==3.0)\n        {\n            col = black;\n        }\n        else if(t.y==4.0)\n        {\n            col = mix(purple2, purple1, step(l, .5));\n        }\n        else if(t.y==5.0)\n        {\n            col = mix(blue1, blue2, step(fract(pos.z*.2+iTime), .5));\n            \n        }\n        else if(t.y==6.0)\n        {\n            col = mix(yellow1, orange1, step(l, .5));\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime * 5.0;\n    \n    \n    vec3 cp = vec3(0.0, 0.0, 5.0);\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    vd.xy *= rot(iTime);\n    \n    vec3 col = Render(cp, vd, uv, time);\n    \n    col.b -= uv.y*.5;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}