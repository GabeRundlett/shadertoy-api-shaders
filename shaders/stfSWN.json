{
    "Shader": {
        "info": {
            "date": "1625922030",
            "description": "A bunch of rotating arcs\nRendered: https://twitter.com/icylava_/status/1413845208052031493",
            "flags": 0,
            "hasliked": 0,
            "id": "stfSWN",
            "likes": 5,
            "name": "ðŸ”´ Circular ðŸ”´",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "icylavah",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "#define EPSILON (0.001)\n#define MAX_DEPTH (1000.0)\n#define MIN_DEPTH (EPSILON * 2.0)\n#define RINGS (20)\n#define PI (3.14159265359)\n#define TAU (PI * 2.0)\n#define LINE_THICKNESS (0.012)\n\nvec3 rgb2lab(vec3 c);\nvec3 lab2rgb(vec3 c);\n\n// https://gist.github.com/onedayitwillmake/3288507\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nvec3 pointMultiply(vec3 point, mat4 matrix) {\n    return (matrix * vec4(point, 0.0)).xyz;\n}\n\nfloat sphereSDF(vec3 point) {\n    return length(point) - 0.2;\n}\n\nfloat arcSDF(vec3 point, float radius, float angle1, float angle2) {\n    point = pointMultiply(point, rotationX(radians(30.0)));\n    float sizeD = LINE_THICKNESS;\n    float angle = mod(atan(point.z, point.x), TAU);\n    if(angle1 > angle2) angle2 += TAU;\n    if(angle1 > angle) angle += TAU;\n    if(angle >= angle1 && angle <= angle2) {\n        return min(\n            length(vec3(cos(angle1), 0.0, sin(angle1)) * radius - point) - sizeD,\n            length(vec3(cos(angle2), 0.0, sin(angle2)) * radius - point) - sizeD\n        );\n    }\n    float r = radius;\n    return length(normalize(vec3(point.x, 0.0, point.z)) * r - point) - sizeD;\n}\n\nfloat sceneSDF(vec3 point) {\n    float dist = MAX_DEPTH;\n    \n    for(int i = 0; i < RINGS; i++) {\n        float angle1 = fract(iTime * 1.0 - float(i) / float(RINGS) * 2.0) * TAU;\n        float angle2 = mod(angle1 + PI * 0.75, TAU);\n        dist = min(dist, arcSDF(point, 1.0 + float(i) / 10.0, angle1, angle2));\n    }\n    \n    point = pointMultiply(point, rotationX(radians(30.0)));\n    point = pointMultiply(point, rotationY(-TAU * iTime / 32.0));\n    point = (fract(point * 0.05) / 0.05) - 10.0;\n    dist = min(dist, sphereSDF(point));\n    \n    return dist;\n}\n\n#define C1 (rgb2lab(vec3(0.3, 0.7, 0.8)))\n#define C2 (rgb2lab(vec3(0.9, 0.2, 0.4)))\n#define C3 (rgb2lab(vec3(0.3, 0.5, 0.6)))\nvec3 colorField(vec3 point) {\n    float lerp = length(pointMultiply(point, rotationX(radians(30.0))).xz);\n    lerp = (lerp - 1.0) / (float(RINGS - 1) / 10.0);\n    lerp = max(0.0, lerp);\n    if(lerp > 1.1) return lab2rgb(C3);\n    lerp = pow(lerp, 1.0);\n    return lab2rgb(C1 * (1.0 - lerp) + C2 * lerp);\n}\n\nfloat march(vec3 from, vec3 dir) {\n    float depth = MIN_DEPTH;\n    for(int i = 0; i < 256; i++) {\n        float nearest = sceneSDF(from + dir * depth);\n        if(nearest < EPSILON) return depth;\n        depth += nearest;\n        if(depth > MAX_DEPTH) return MAX_DEPTH;\n    }\n    return depth;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(0.0, -0.35, 10.0);\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float depth = march(pos, dir);\n    float upness = smoothstep(-0.3, 0.3, dot(dir, vec3(0.0, 1.0, 0.0)));\n    vec3 background = vec3(0.1, 0.0, 0.2);\n    if(depth > MAX_DEPTH - EPSILON) {\n        fragColor = vec4(pow(background, vec3(2.2)), 1.0);\n        return;\n    }\n    vec3 hitPos = pos + dir * depth;\n    //vec3 lightPos = vec3(cos(iTime * 6.28 / 2.0) * 4.5, sin(iTime * 6.28 / 2.0) * 4.5, 1.0);\n    //vec3 color = background * 0.5;\n    //color += vec3(0.98, 0.1, 0.4);\n    vec3 color = colorField(hitPos);\n    fragColor = vec4(pow(color, vec3(2.2)), 1.0);\n}\n\n\n//CIE L*a*b* (CIELAB, L* for lightness, a* from green to red, b* from blue to yellow)\n//Source: https://gist.github.com/mattatz/44f081cac87e2f7c8980 (HLSL)\nvec3 rgb2xyz(vec3 c){\n\tvec3 tmp=vec3(\n\t\t(c.r>.04045)?pow((c.r+.055)/1.055,2.4):c.r/12.92,\n\t\t(c.g>.04045)?pow((c.g+.055)/1.055,2.4):c.g/12.92,\n\t\t(c.b>.04045)?pow((c.b+.055)/1.055,2.4):c.b/12.92\n\t);\n\tmat3 mat=mat3(\n\t\t.4124,.3576,.1805,\n\t\t.2126,.7152,.0722,\n\t\t.0193,.1192,.9505\n\t);\n\treturn 100.*(tmp*mat);\n}\nvec3 xyz2lab(vec3 c){\n\tvec3 n=c/vec3(95.047,100.,108.883),\n\t     v=vec3(\n\t\t(n.x>.008856)?pow(n.x,1./3.):(7.787*n.x)+(16./116.),\n\t\t(n.y>.008856)?pow(n.y,1./3.):(7.787*n.y)+(16./116.),\n\t\t(n.z>.008856)?pow(n.z,1./3.):(7.787*n.z)+(16./116.)\n\t);\n\treturn vec3((116.*v.y)-16.,500.*(v.x-v.y),200.*(v.y-v.z));\n}\nvec3 rgb2lab(vec3 c){\n\tvec3 lab=xyz2lab(rgb2xyz(c));\n\treturn vec3(lab.x/100.,.5+.5*(lab.y/127.),.5+.5*(lab.z/127.));\n}\nvec3 lab2xyz(vec3 c){\n\tfloat fy=(c.x+16.)/116.,\n\t      fx=c.y/500.+fy,\n\t      fz=fy-c.z/200.;\n\treturn vec3(\n\t\t 95.047*((fx>.206897)?fx*fx*fx:(fx-16./116.)/7.787),\n\t\t100.   *((fy>.206897)?fy*fy*fy:(fy-16./116.)/7.787),\n\t\t108.883*((fz>.206897)?fz*fz*fz:(fz-16./116.)/7.787)\n\t);\n}\nvec3 xyz2rgb(vec3 c){\n\tmat3 mat=mat3(\n\t\t3.2406,-1.5372,-.4986,\n\t\t-.9689, 1.8758, .0415,\n\t\t .0557, -.2040,1.0570\n\t);\n\tvec3 v=(c/100.0)*mat,\n\t     r=vec3(\n\t\t(v.r>.0031308)?((1.055*pow(v.r,(1./2.4)))-.055):12.92*v.r,\n\t\t(v.g>.0031308)?((1.055*pow(v.g,(1./2.4)))-.055):12.92*v.g,\n\t\t(v.b>.0031308)?((1.055*pow(v.b,(1./2.4)))-.055):12.92*v.b\n\t);\n\treturn r;\n}\nvec3 lab2rgb(vec3 c){return xyz2rgb(lab2xyz(vec3(100.*c.x,2.*127.*(c.y-.5),2.*127.*(c.z-.5))));}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}