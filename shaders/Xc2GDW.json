{
    "Shader": {
        "info": {
            "date": "1704236432",
            "description": "Infinite neon grid\n\nPart of the RBBS PC Demo \"Melodicis Tropicis\"\nSee https://www.pouet.net/prod.php?which=95796",
            "flags": 32,
            "hasliked": 0,
            "id": "Xc2GDW",
            "likes": 6,
            "name": "Infinite neon grid",
            "published": 3,
            "tags": [
                "grid",
                "infinite",
                "neon"
            ],
            "usePreview": 0,
            "username": "oemfoe",
            "viewed": 172
        },
        "renderpass": [
            {
                "code": "float saw(float x) {\n    return abs(x - floor(x) - 0.5);\n}\n\nmat2 rot2D(float r) {\n    return mat2(\n        cos(r), sin(r),\n        -sin(r), cos(r)\n    );\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hashfeed(float x) {\n    return floor((x+1.)/2.);\n}\n\nfloat hashfade(float x) {\n    return abs(x/2. - floor(x/2.) - 0.5) * 2.;\n}\n\nconst float PI = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv0 = uv;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 px = 1./iResolution.yy;\n    vec2 pxIso = 1.5/iResolution.yy;\n    vec3 col = vec3(0., 0., 0.);\n    vec4 pos = vec4(\n        float(int(32. * saw(iTime / 4.))), \n        float(int(0.)), \n        float(int(32. * cos(iTime / 3.))), \n        float(int(24. * sin(iTime)))\n    );\n    vec4 rect = vec4(\n        min(pos.x, pos.z),\n        min(pos.y, pos.w),\n        max(pos.x, pos.z),\n        max(pos.y, pos.w)\n    );\n    float thick = 0.1 + 4. * (0.5 + 0.5 * sin(iTime / 2.));\n    float grid = 0.02;\n    uv -= 0.5;\n    uv.x *= aspect;\n    \n    vec2 uvIso = uv;\n    \n    uvIso.y *= 2.;\n    uvIso = rot2D(PI / 4.) * uvIso;\n    \n    float isoMix = 0.5 + 0.5 * clamp(8. * sin(iTime), -1., 1.);\n    \n    uv = mix(uv, uvIso, isoMix);\n    px = mix(px, pxIso, isoMix);\n    \n    \n    uv += mod(iTime / 200., 0.25);\n    \n    \n    if (mod(uv.x, grid) <= px.x || mod(uv.y, grid) <= px.y) {\n        col = vec3(.1, .1, .1);\n        \n    }\n    \n    if (abs(uv.x / grid - pos.x) * thick < 1.) {\n        col += (1. - abs(uv.x / grid - pos.x) * thick) * vec3(1., 0., 0.) * clamp(0.5 + 0.5 * cos(iTime * 4. + uv.y * 5.), 0., 1.);\n    }\n    if (abs(uv.y / grid - pos.y) * thick < 1.) {\n        col += (1. - abs(uv.y / grid - pos.y) * thick) * vec3(1., 1., 0.) * clamp(0.5 + 0.5 * sin(iTime * 3. + uv.y * 5.), 0., 1.);\n    }\n    if (abs(uv.x / grid - pos.z) * thick < 1.) {\n        col += (1. - abs(uv.x / grid - pos.z) * thick) * vec3(0., 0., 1.) * clamp(0.5 + 0.5 * cos(iTime * 2. + uv.y * 3.), 0., 1.);\n    }\n    if (abs(uv.y / grid - pos.w) * thick < 1.) {\n        col += (1. - abs(uv.y / grid - pos.w) * thick) * vec3(1., 0., 1.) * clamp(0.5 + 0.5 * sin(iTime * 1. + uv.y * 3.), 0., 1.);\n    }\n    \n    \n    if (false)\n    {\n        if (uv.x / grid > rect.x &&\n            uv.y / grid > rect.y &&\n            uv.x / grid < rect.z &&\n            uv.y / grid < rect.w)\n            col += vec3(0.2);\n    }\n    \n    vec3 fire = vec3(1., 0.2, 0.);\n    \n    if (true)\n    {\n        \n        for (int i = 0; i < 50; i++) {\n            float inp = iTime * 10. + float(i) * 1.;\n            vec2 hpos = hash21(hashfeed(inp)) * 2. - 1.;\n            fire = hash31(hashfeed(inp) * 5.398978);\n            \n            if (uv.x / grid > floor(hpos.x / grid) &&\n                uv.y / grid > floor(hpos.y / grid) &&\n                uv.x / grid < floor(hpos.x / grid) + 1. &&\n                uv.y / grid < floor(hpos.y / grid) + 1.\n            ) {\n                col += fire * hashfade(inp);\n                \n            }\n            \n            col += clamp(\n                (4. - max(\n                    abs(uv.x / grid - floor(hpos.x / grid) - .5),\n                    abs(uv.y / grid - floor(hpos.y / grid) - .5)\n                    \n                    \n                ) * 4.) / 4., 0., 1.) * fire;\n            \n        }\n    }\n    \n    if (true)\n    {\n        vec2 dim = vec2(rect.z - rect.x, rect.w - rect.y);\n        float ra = dim.x / dim.y;\n        vec2 uvr = vec2(\n            (uv.x / grid - rect.x) / (rect.z - rect.x),\n            (uv.y / grid - rect.y) / (rect.w - rect.y)\n        );\n        uvr -= 0.5;\n        if (dim.x > dim.y)\n            uvr.x *= ra;\n        else\n            uvr.y /= ra;\n        uvr.x /= aspect;\n        \n        uvr += 0.5;\n        vec4 texel = texture(iChannel0, uvr);\n        if (length(texel.rgb) > 0.)\n            col = texel.rgb;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float E = 0.001;\nconst float PI = 3.14159;\n\n\nfloat sphere(vec3 p, float radius){\n    return length(p) - radius;\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nmat3 rotY(float r) {\n    return mat3(\n        cos(r), 0., sin(r),\n        0., 1., 0.,\n        -sin(r), 0., cos(r)\n    );\n}\n\nfloat scene(vec3 p) {\n    float bolleke = sphere(p, 1.);\n    \n    p = rotY(iTime) * p;\n    \n    float blokske = box(p, vec3(1., 1., 1.));\n    return blokske;\n}\n\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + E, p.y, p.z)) - scene(vec3(p.x - E, p.y, p.z)),\n        scene(vec3(p.x, p.y + E, p.z)) - scene(vec3(p.x, p.y - E, p.z)),\n        scene(vec3(p.x, p.y, p.z + E)) - scene(vec3(p.x, p.y, p.z - E))\n    ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = fragCoord/iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    uv -= 0.5;\n    uv.y /= aspect;\n    \n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ld = vec3(cos(iTime), sin(iTime), -1.);\n    float t = 0.0;\n    float d = 0.0;\n    vec3 c = vec3(0.000,0.000,0.000);\n    for (int i = 0; i < 64; i++){\n        vec3 p = ro + t * rd;\n        d = scene(p);\n        if (d < E) {\n            // hit\n            vec3 n = normal(p);\n            float l = smoothstep(0.0, 1.0, dot(n, ld));\n            c = vec3(l * 0.8 + 0.2) * col;\n            break;\n        }\n        t += d;\n    }\n    \n    // float wave = texelFetch(iChannel0, ivec2(int(512.0 * uv2.x), 1.), 0).x;\n    \n    // Output to screen\n    fragColor = vec4(c /* + texture(iChannel0, uv2).xxx*/, 1.0);\n    \n    //if (abs(wave - uv2.y) < 0.002)\n    //    fragColor = vec4(1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}