{
    "Shader": {
        "info": {
            "date": "1724505567",
            "description": "source https://www.shadertoy.com/view/llB3zw https://www.shadertoy.com/view/4fsBDs",
            "flags": 0,
            "hasliked": 0,
            "id": "XclfDs",
            "likes": 0,
            "name": "bubbles fbm noise",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "bubbles",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 132
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n// Galaxy morphology based on http://iopscience.iop.org/0004-637X/783/2/138/pdf/0004-637X_783_2_138.pdf\n\nfloat zoom=1.;\nconst float arms = 2.;\nconst float winding = 9.;\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nconst mat2 m2 = mat2(.8,.6,-.6,.8);\n\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=2.;\n\tfor( int i=0; i< 4; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.0;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/4.;\n}\n\nfloat noise(in vec3 p)\n{\n   \n\tp*=2.;\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p.xy=m2*p.xy;\n        p=p.zxy*f+.6;     \n        f*=1.15;\n        res+=sin(p.y+1.3*sin(1.2*p.x)+1.7*sin(1.7*p.z));\n\t}        \t\n\treturn res/3.;\n\n}\n\n\nfloat fbmdisk( vec3 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += abs(noise( p*(f) ))/f;       \n\t    f +=f;\n        \n\t}\n\treturn 1.2/(.07+r);\n}\n\n\nfloat fbmgal( vec3 p ) {\n    \n    p=p*4.;\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += noise( p*(20.+3.*f) )/f; \n        p.xz*=m2;\n\t    f +=1.;\n        \n\t}\n\treturn pow(abs(r),4.);\n}\n\n\n\nfloat fbmdust( vec3 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += 1./abs(noise( p*(f) ))/f;       \n\t    f +=f;\n        \n\t}\n\treturn pow(abs(1.-1./(.01+r)),4.);\n}\n\n\nfloat theta(float r, float wb, float wn){\n\treturn atan(exp(1./r)/wb)*2.*wn;\n}\n\nfloat arm(float n, float aw, float wb, float wn,vec2 p){\n    float t = atan(p.y,p.x);\n    float r = length(p);    \n\treturn pow(1.-.15*sin((theta(r,wb,wn)-t)*n),aw)*exp(-r*r)*exp(-.07/r);\n}\n\n\nfloat bulb(vec2 p){\n    float r = exp(-dot(p,p)*1.2);\n    p.y-=.2;\n\treturn 1.*(r+2.*exp(-dot(p,p)*16.));\n}\n\n\nfloat map(in vec3 p) {\n\tvec2 q=p.xz;\n    vec3 res= vec3(0.);\n\tfloat a= arm(arms,6.,.7,winding,q);\n    float r = max(a,bulb(q));\n    return 4.*exp(-28.*(abs(p.y)-r/16.));\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd)\n{\n    float t = 1.5;\n    float dt = .065;\n    vec3 col= vec3(0.);\n    float c = 0.,s=0.,d=0.;\n    for( int i=0; i<44; i++ )\n\t{\n        t+=dt*exp(-2.*c*s);\n        if(t>6.)break;\n        vec3 pos = ro+t*rd;\n        \n        c = map(pos);\n        if(c>.2){\n        s = fbmdisk(pos*102.)/3.;\n        d = fbmdust(pos*4.)/4.;\n            c*=d;}\n        //col = .98*col+ .05*vec3(c*c*c, c*c, c);\t\n        col = .98*col+ .02*vec3(c*c, 1.2*c*s,1.5* s)*c;\n        \n    }    \n    return col;\n}\n\n#define time iTime\n#define resolution iResolution.xy\n\n\n#define iterations 11\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    \n    vec2 uv2=fragCoord.xy/iResolution.xy-0.5;\n\tvec2 uv =uv2 * 2.5;\n    \n vec3 dir=vec3(uv*zoom,1.);\n vec3 from=vec3(1.,.5,0.5);\n\t\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.02),sin(iTime*0.02),-sin(iTime*0.02),cos(iTime*0.02));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n  \n    vec3 ro = zoom*vec3(2.)*v*.013;\n    ro.yz*=rot(10.);\n\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n      \n\n\t// raymarch\n    vec3 col = raymarch(ro,rd);\n    float g = .4*fbmgal(rd);\n    col +=.3*vec3(g*g*g, g*g*1.3, 1.5*g);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col*vec3(0.,.2,3.)*5., 1.0 );\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}