{
    "Shader": {
        "info": {
            "date": "1615590049",
            "description": "I know it's not an original idea\nWanted to challenge myself to build something interactive\n\nGameplay:\n A, D - move cue\n Q (hold and release) - hit\n R - restart\nCamera:\n Left, Right - rotate camera\n W - top view\nMisc:\n G - glass balls\n  T - surface texture",
            "flags": 48,
            "hasliked": 0,
            "id": "7df3RH",
            "likes": 34,
            "name": "Pool with glass balls",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "game",
                "pool"
            ],
            "usePreview": 0,
            "username": "kosmaks",
            "viewed": 846
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST (40.)\n#define MIN_DIST (0.005)\n#define MAX_STEPS (300)\n//#define SHOW_STATE\n\n#define PIX(x, y) d = smin(d, distance(vp, vec2((x), (y))) - 0.02, 0.1)\n\n#define LIGHT0 (vec3(-5., 20., 0.))\n#define LIGHT1 (vec3(5., 20., 0.))\n\n// Materials\n\nstruct Material {\n    vec3 reflection;\n    vec3 diffuse;\n    vec4 specular;\n    vec4 refraction;\n};\n\nconst Material mFloor = Material(\n    vec3(0.05),\n    vec3(0.1),\n    vec4(0.),\n    vec4(0.)\n);\n\nconst Material mWhiteBall = Material(\n    vec3(0.),\n    vec3(0.6),\n    vec4(vec3(0.5), 50.),\n    vec4(0.)\n);\n\nconst Material mBall = Material(\n    vec3(0.1),\n    vec3(0.3, 0.3, 0.8),\n    vec4(vec3(0.6), 50.),\n    vec4(0.)\n);\n\nconst Material mTableWood = Material(\n    vec3(0.),\n    vec3(0.52, 0.37, 0.26),\n    vec4(vec3(1.), 50.),\n    vec4(0.)\n);\n\nconst Material mTableSteel = Material(\n    vec3(1.),\n    vec3(0.),\n    vec4(1.),\n    vec4(0.)\n);\n\nconst Material mTablePocket = Material(\n    vec3(0.),\n    vec3(0.1),\n    vec4(0.),\n    vec4(0.)\n);\n\nconst Material mTable = Material(\n    vec3(0.),\n    vec3(0.3, 0.4, 0.1),\n    vec4(0.),\n    vec4(0.)\n);\n\nconst Material mCue = Material(\n    vec3(0.),\n    vec3(0.52, 0.37, 0.26) * 0.3,\n    vec4(vec3(1.), 40.),\n    vec4(0.)\n);\n\nconst Material mGlass = Material(\n    vec3(0.),\n    vec3(0.1),\n    vec4(vec3(0.6), 30.),\n    vec4(vec3(0.9), 0.45)\n);\n\n// Utilities\n\n#define T3D(s) (vec3((s).x, 0., (s).y))\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinder(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca,ca),dot(cb, cb)) );\n}\n\nfloat intSphere(vec3 ro, vec3 rd, vec3 p, float r, out vec3 touch, out vec3 outN) {\n    vec3 tc = ro - p;\n    float tcl = length(tc);\n    float b = 2. * dot(tc, rd);\n    float c = tcl * tcl - r * r;\n    float uu = b*b - 4. * c;\n    \n    float dist = -1.;\n    if (uu >= 0.) {\n        float sq = sqrt(uu);\n        dist = (-b - sq) / 2.;\n        if (dist < 0.) {\n            dist = (-b + sq) / 2.;\n        }\n    }\n    \n    if (dist > EPS) {\n        touch = ro + rd * dist;\n        outN = normalize(touch - p);\n    } else {\n        dist = MAX_DIST + 1.;\n    }\n    \n    return dist;\n}\n\n// Objects\n\nfloat objCue(vec3 p, out Material m) {\n    vec2 ballVel = sampleVel(iChannel0, 0.).xy;\n    if (length(ballVel) > EPS) return MAX_DIST;\n\n    m = mCue;\n    float radius = BALL_RADIUS * rTableSize;\n    \n    p -= rTableZeroBase;\n    \n    // Cue at the ball\n    p -= T3D((samplePos(iChannel0, 0.) * rTableSize)) + \n        vec3(0., rTableHeight + radius, 0.);\n\n    \n    float angle = getCueAngle(sampleCueDir(iChannel0));\n    p = qRotate(p, qCreateRotation(vec3(0., 1., 0.), angle));\n    \n    p = qRotate(p, qCreateRotation(vec3(0., 0., 1.), 1.57));\n    p = qRotate(p, qCreateRotation(vec3(0., 0., 1.), 0.2));\n        \n    // Cue at the tip\n    float power = getCueOffset(sampleHitPowerRaw(iChannel0));\n    p -= vec3(0., -rCueDim.z - radius - power * 1., 0.);\n    \n    return sdCappedCone(p, rCueDim.z, rCueDim.x, rCueDim.y);\n}\n\nfloat objTable(vec3 p, out Material m) {\n    m = mTable;\n        \n    vec3 size = -rTableZeroBase;\n    vec3 absp = vec3(abs(p.x), p.y, abs(p.z));\n    \n    float rThirdBorder = rBorderSize * 0.33;\n    if (\n        p.y < rTableHeight - EPS ||\n        absp.z > size.z - rThirdBorder ||\n        absp.x > size.x - rThirdBorder\n    ) {\n        m = mTableWood;\n    }\n    \n    if (p.y > rTableHeight - rTableThickness && (\n        distance(absp.xz, size.xz) < rBorderSize\n    )) {\n        m = mTableSteel;\n    }\n    \n    // Table top\n    float d = sdRoundBox(\n        absp - vec3(0., rTableHeight, 0.), \n        size + vec3(0., rTableThickness, 0.),\n        0.2\n    );\n    \n    d = smax(d, -sdBox(\n        absp - vec3(0., rTableHeight + rTableThicknessHalf + 0.2, 0.), \n        size + vec3(-rBorderSize, rTableThicknessHalf + 0.2, -rBorderSize)\n    ), 0.1);\n    \n    \n    // Pockets\n    vec3 cp = absp + rTableZeroBase;\n    float rPocketRadius = POCKET_RADIUS * rTableSize;\n    float pd = sdCylinder(cp + T3D(POCKET0) * rTableSize, rPocketRadius);\n    pd = min(pd, sdCylinder(cp + T3D(POCKET1) * rTableSize, rPocketRadius));\n    if (-pd > d) {\n        m = mTablePocket;\n        d = -pd;\n    }\n    \n    // Footer\n    d = min(d, sdBox(\n        absp - vec3(0., rTableHeight - rTableFooterHeight - rTableThickness, 0.), \n        size + vec3(0., rTableFooterHeight, 0.)\n    ));\n     \n     \n    // Legs\n    vec3 legPos = vec3(\n        size.x * 0.9, \n        rTableHeightHalf - rTableThicknessHalf, \n        size.z * 0.8);\n    vec3 legSize = rTableSize * \n        vec3(0.015, 0., 0.015) + \n        vec3(0., rTableHeightHalf - rTableThicknessHalf, 0.);\n    d = min(d, sdRoundBox(absp - legPos, legSize, 0.2));\n    \n    if (isToggled(iChannel1, KEY_T) && abs(p.y - rTableHeight) < 0.1) {\n        float tex = texture(iChannel2, p.xz / 10.).x;\n        tex = tex * 0.5 + 0.5;\n        m.diffuse *= tex;\n    }\n    \n    return d;\n}\n\n// Ray marching\n\nfloat marching_getDist(vec3 p, out Material m) {\n    float td, d = p.y;\n    m = mFloor;\n    Material tm;\n    \n    td = objCue(p, tm);\n    if (td < d) { d = td; m = tm; }\n    \n    td = objTable(p, tm);\n    if (td < d) { d = td; m = tm; }\n    \n    return d;\n}\n\nvec3 marching_getNormal(vec3 p) {\n    Material m;\n    float dist = marching_getDist(p, m);\n    vec2 e = vec2(0.01, 0.);\n    vec3 n = dist - vec3(\n        marching_getDist(p - e.xyy, m),\n        marching_getDist(p - e.yxy, m),\n        marching_getDist(p - e.yyx, m));\n    return normalize(n);\n}\n\nfloat marching_castRay(vec3 ro, vec3 rd, out Material m, out vec3 touch, out vec3 n) {\n    float totalDist = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = marching_getDist(next, m);\n        totalDist += d;\n        if (abs(d) < MIN_DIST || totalDist > MAX_DIST) break;\n        if (i == MAX_STEPS - 1) totalDist = MAX_DIST + 1.;\n    }\n    \n    if (totalDist < MAX_DIST) {\n        touch = ro + totalDist * rd;\n        n = marching_getNormal(touch);\n    }\n    \n    return totalDist;\n}\n\nfloat marching_softShadow(vec3 ro, vec3 rd, float k, float maxD) {\n    Material m;\n    float totalDist = 0.2;\n    float res = 1.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = marching_getDist(next, m);\n        res = min(res, k * d / totalDist);\n        if (abs(d) < MIN_DIST) return 0.;\n        totalDist += d;\n        if (totalDist > maxD) break;\n    }\n    \n    return clamp(res, 0., 1.);\n}\n\n// Intersection for spheres\n\nfloat inter_castRay(vec3 ro, vec3 rd, out Material m, out vec3 touch, out vec3 n) {\n    vec3 tt, tn;\n    float td, d = MAX_DIST + 1.;\n    Material tm;\n    float y = rTableHeight + rBallRadius;\n    \n    Material mOther = mBall;\n    if(isToggled(iChannel1, KEY_G)) {\n        mOther = mGlass;\n    }\n    \n    for (int i = 1; i < BALL_COUNT_I; ++i) {\n        float iFloat = float(i);\n        bool visible = sampleVel(iChannel0, iFloat).z < 0.5;\n        if (!visible) continue;\n        vec2 pos = samplePos(iChannel0, iFloat) * rTableSize;\n        vec3 pos3 = vec3(pos.x, y, pos.y) + rTableZeroBase;\n        td = intSphere(ro, rd, pos3, rBallRadius, tt, tn);\n        if (td < d) { m = mOther; d = td; touch = tt; n = tn; };\n    }\n    \n    vec2 pos = samplePos(iChannel0, 0.) * rTableSize;\n    vec3 pos3 = vec3(pos.x, y, pos.y) + rTableZeroBase;\n    td = intSphere(ro, rd, pos3, rBallRadius, tt, tn);\n    if (td < d) { m = mWhiteBall; d = td; touch = tt; n = tn; };\n    \n    return d;\n}\n\nfloat inter_softShadow(vec3 ro, vec3 rd, float k, float d) {\n    vec3 t, n;\n    Material m;\n    float res = 1.;\n    float y = rTableHeight + rBallRadius;\n    \n    for (int i = 0; i < BALL_COUNT_I; ++i) {\n        float iFloat = float(i);\n        bool visible = sampleVel(iChannel0, iFloat).z < 0.5;\n        if (!visible) continue;\n        vec2 pos = samplePos(iChannel0, iFloat) * rTableSize;\n        vec3 pos3 = vec3(pos.x, y, pos.y) + rTableZeroBase;\n        \n        float a = dot(pos3 - ro, rd);\n        if (a < 0.01 || a > d) continue;\n        vec3 p = ro + a * rd;\n        \n        float dist = max(0., distance(p, pos3) - rBallRadius);\n        res = min(res, k * dist / a);\n    }\n    \n    return res;\n}\n\nfloat castRay(vec3 ro, vec3 rd, out Material m, out vec3 touch, out vec3 n) {\n    float d = MAX_DIST + 1.;\n    vec3 tt, tn;\n    float td;\n    Material tm;\n    \n    td = marching_castRay(ro, rd, tm, tt, tn);\n    if (td < d) { d = td; m = tm; touch = tt; n = tn; };\n    \n    td = inter_castRay(ro, rd, tm, tt, tn);\n    if (td < d) { d = td; m = tm; touch = tt; n = tn; };\n    \n    return d;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k, float d) {\n    float res = 1.;\n    res = min(res, marching_softShadow(ro, rd, k, d));\n    res = min(res, inter_softShadow(ro, rd, k / 2., d));\n    return res;\n}\n\n// Main\n\nvec3 pointLightCast(vec3 p, vec3 n, vec3 point) {\n    vec3 ld = normalize(point - p);\n    float fact = dot(n, ld);\n    if (fact <= 0.) return vec3(0.);\n    \n    vec3 lo = p + n * MIN_DIST * 5.;\n    Material m;\n    vec3 touch, tn;\n    float dist = softShadow(lo, ld, 4., MAX_DIST);\n    float ao = softShadow(lo, n, 2., 0.2) * 0.7 + 0.3;\n    \n    float power = exp(-distance(point, p) * 0.05);\n    \n    return vec3(fact) * ao * (dist * 0.7 + 0.3) * power * 2.;\n}\n\nvec3 traceScene(vec3 ro, vec3 rd, inout float seed) {\n    float d;\n    Material m;\n    vec3 touch, n;\n    vec3 rad = vec3(0.);\n    vec3 scaler = vec3(1.);\n    \n    for (int i = 0; i < 4; ++i) {\n        d = castRay(ro, rd, m, touch, n);\n        \n        if (d >= MAX_DIST) {\n            rad += vec3(0., 0., 0.1);\n            break;\n        } else {\n            vec3 diffuse = pointLightCast(touch, n, LIGHT0);\n            diffuse += pointLightCast(touch, n, LIGHT1);\n            rad += scaler * m.diffuse * diffuse;\n\n            vec3 ambient = vec3(0.1);\n            rad += scaler * m.diffuse * ambient;\n\n            if (m.specular != vec4(0.)) {\n                float specular = dot(reflect(normalize(touch - LIGHT0), n), -rd);\n                specular = max(0., specular);\n                rad += scaler * m.specular.xyz * pow(specular, m.specular.w);\n            }\n\n            if (m.refraction != vec4(0.)) {\n                float s = sign(dot(rd, n));\n                ro = touch + n * MIN_DIST * 2. * s;\n                rd = refract(rd, n * -s, m.refraction.w);\n                scaler *= m.refraction.xyz;\n            } else if (m.reflection != vec3(0.)) {\n                ro = touch + n * MIN_DIST * 2.;\n                rd = reflect(rd, n);\n                scaler *= m.reflection;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return rad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float vpWindow = 2. / iResolution.y;\n    vec2 vpShift = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 vp = fragCoord * vpWindow - vpShift;\n    \n#ifdef SHOW_STATE\n    fragColor = vec4(texture(iChannel0, fragCoord.xy / iResolution.xy).xyz, 1.0);\n    return;\n#endif\n\n    float seed = fract(sin(fragCoord.x * 3.132 + fragCoord.y * 1.33)) * 100. + iTime;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 camOffset = T3D(samplePos(iChannel0, 0.) * rTableSize) + rTableZeroBase;\n    \n    float rot = sampleRot(iChannel0) * 6.28;\n    vec3 ro =  sampleCamPos(iChannel0);\n    vec3 target = sampleCamTarget(iChannel0);\n    vec3 rd = getInitialRD(vp, ro, target, 2.5);\n    \n    vec3 totalRad = traceScene(ro, rd, seed);\n    \n    col = totalRad;\n    \n    \n    bool gameOver = sampleVel(iChannel0, 0.).z > 0.5;\n    if (gameOver) {\n        col.g = 0.;\n        \n        vp += vec2(0.7, -0.2);\n        \n        float d = 100.;\n        PIX(0., 0.); PIX(0.1, 0.); PIX(0.2, 0.);\n        PIX(0., -0.1);\n        PIX(0., -0.2); PIX(0.13, -0.2);\n        PIX(0., -0.3);\n        PIX(0., -0.4);\n        \n        PIX(0.4, 0.); PIX(0.5, 0.); PIX(0.6, 0.);\n        PIX(0.4, -0.1); PIX(0.6, -0.1);\n        PIX(0.4, -0.2); PIX(0.5, -0.2); PIX(0.6, -0.2);\n        PIX(0.4, -0.3); PIX(0.6, -0.3);\n        PIX(0.4, -0.4); PIX(0.6, -0.4);\n        \n        PIX(0.8, 0.); PIX(0.9, 0.); PIX(1., 0.);\n        PIX(0.9, -0.1);\n        PIX(0.9, -0.2);\n        PIX(0.9, -0.3);\n        PIX(0.8, -0.4); PIX(0.9, -0.4); PIX(1., -0.4);\n        \n        PIX(1.2, 0.); \n        PIX(1.2, -0.1);\n        PIX(1.2, -0.2);\n        PIX(1.2, -0.3);\n        PIX(1.2, -0.4); PIX(1.3, -0.4); PIX(1.4, -0.4);\n        \n        if (d < 0.) {\n            col = vec3(0.9, 0.2, 0.3);\n        } else if (d < 0.02) {\n            col = vec3(1.);\n        }\n    }\n    \n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 getInitialPos(float ballId) {\n#ifdef DEBUG_BALLS\n    if (ballId > 0.5) return vec2(0.3, 0.25);\n    return vec2(0.1, 0.045);\n#endif\n\n    float xo = sqrt(3.*BALL_RADIUS*BALL_RADIUS) + 0.001;\n    float yo = BALL_RADIUS + 0.001;\n    vec2 first = vec2(0.7, 0.25);\n    if (ballId > 9.5) return first + vec2(3. * xo, 3. * yo);\n    if (ballId > 8.5) return first + vec2(3. * xo, -3. * yo);\n    if (ballId > 7.5) return first + vec2(3. * xo, yo);\n    if (ballId > 6.5) return first + vec2(3. * xo, -yo);\n    if (ballId > 5.5) return first + vec2(2. * xo, -2. * yo);\n    if (ballId > 4.5) return first + vec2(2. * xo, 2. * yo);\n    if (ballId > 3.5) return first + vec2(2. * xo, 0.);\n    if (ballId > 2.5) return first + vec2(xo, -yo);\n    if (ballId > 1.5) return first + vec2(xo, yo);\n    if (ballId > 0.5) return first;\n    return vec2(0.1, 0.25);\n}\n\nvec3 getInitialVel(float ballId) {\n#ifdef DEBUG_BALLS\n    if (ballId > 0.5) return vec3(0.);\n    return vec3(\n        normalize(getInitialPos(1.) - getInitialPos(0.)) * 0.04,\n        0.\n    );\n#endif\n\n    return vec3(0.);\n}\n\nvec2 nextPos(vec2 curPos, vec3 curVel) {\n    return curPos + curVel.xy;\n}\n\nvec3 nextVel(float ballId, vec2 curPos, vec3 curVel) {\n    if (curVel.z > 0.5) {\n        return curVel;\n    }\n\n    int ballIdInt = int(ballId);\n    vec2 curNext = nextPos(curPos, curVel);\n    \n    float pocketDist = 100.;\n    pocketDist = min(pocketDist, distance(curPos, POCKET0));\n    pocketDist = min(pocketDist, distance(curPos, POCKET1));\n    pocketDist = min(pocketDist, distance(curPos, POCKET2));\n    pocketDist = min(pocketDist, distance(curPos, POCKET3));\n    pocketDist = min(pocketDist, distance(curPos, POCKET4));\n    pocketDist = min(pocketDist, distance(curPos, POCKET5));\n    if (pocketDist < SCORE_DIST) {\n        return vec3(0., 0., 1.);\n    }\n    \n    vec2 lo = vec2(BORDER_SIZE);\n    vec2 hi = TABLE_SIZE - lo;\n    \n    if (curNext.x - BALL_RADIUS <= lo.x) \n        return vec3(abs(curVel.x), curVel.y, 0.) * BALL_ACCEL;\n    if (curNext.x + BALL_RADIUS >= hi.x) \n        return vec3(-abs(curVel.x), curVel.y, 0.) * BALL_ACCEL;\n    if (curNext.y - BALL_RADIUS <= lo.y) \n        return vec3(curVel.x, abs(curVel.y), 0.) * BALL_ACCEL;\n    if (curNext.y + BALL_RADIUS >= hi.y) \n        return vec3(curVel.x, -abs(curVel.y), 0.) * BALL_ACCEL;\n    \n    vec2 newVel = vec2(0.);\n    vec2 shift = vec2(0.);\n    float fact = 0.;\n    \n    for (int i = 0; i < BALL_COUNT_I; ++i) {\n        if (ballIdInt == i) continue;\n        \n        float iFloat = float(i);\n        vec3 neighVel = sampleVel(iChannel0, iFloat);\n        if (neighVel.z > 0.5) continue;\n        \n        vec2 neighPos = samplePos(iChannel0, iFloat);\n        vec2 neighNext = nextPos(neighPos, neighVel);\n        float dist = distance(neighNext, curNext);\n        if (dist <= 2.*BALL_RADIUS) {\n            vec2 n = normalize(neighNext - curNext) * BALL_RADIUS;\n            vec2 center = 0.5 * (neighNext - curNext) + curNext;\n            \n            vec2 p1 = center - n;\n            vec2 p2 = center + n;\n            \n            float m = BALL_M;\n            float M = m + m;\n            vec2 cc = p1 - p2;\n            float d = length(cc); d *= d;\n            vec2 v1 = curVel.xy, v2 = neighVel.xy;\n            \n            newVel += (v1 - 2. * m / M * dot(v1 - v2, p1 - p2) / d * (p1 - p2)) * HIT_DECCEL;\n            shift += (p1 - curNext);\n            fact += 1.;\n        }\n    }\n    \n    if (fact <= EPS) {\n        newVel = curVel.xy;\n    } else {\n        newVel /= fact;\n    }\n    \n    if (ballIdInt == 0) {\n        float hitPower = getHitPower(sampleHitPowerRaw(iChannel0)) * 0.05;\n        if (hitPower > EPS) {\n            shift += getCueDir(sampleCueDir(iChannel0)) * hitPower;\n        }\n    }\n    \n    return vec3(newVel * BALL_ACCEL + shift, 0.);\n}\n\nvec3 getCameraPos(bool isInitial) {\n    float rot = sampleRot(iChannel0) * 6.28 + 1.57;\n    vec2 ball2d = isInitial ? getInitialPos(0.) : samplePos(iChannel0, 0.);\n    vec3 ball = vec3(ball2d.x, 0., ball2d.y) * rTableSize + rTableZeroBase;\n    vec3 res = vec3(-10., 14., -10.);\n    res *= vec3(sin(rot), 1., cos(rot));\n    res += ball;\n    return res;\n}\n\nvec3 getCameraTarget(bool isInitial) {\n    vec2 ball = isInitial ? getInitialPos(0.) : samplePos(iChannel0, 0.);\n    return vec3(ball.x, 0., ball.y) * rTableSize + rTableZeroBase +\n        vec3(0., rTableHeight * 1.1, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0., 0., 0., 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    bool isInitial = iFrame == 0 || \n        !sampleInitFlag(iChannel0) || \n        isPressed(iChannel1, KEY_R);\n    \n    vec2 cell = getGridCell(uv);\n    \n    if (cell.y >= 4. || cell.x < 0.) return;\n    \n    // Camera animations\n    \n    if (CLOSE(cell.x, 0.) && CLOSE(cell.y, 3.)) { // camera position\n        vec3 res;\n        if (isInitial) {\n            res = getCameraPos(true);\n        } else {\n            res = sampleCamPos(iChannel0);\n            vec3 next = sampleCamPosNext(iChannel0);\n            res += (next - res) * 0.1;\n        }\n        \n        \n        fragColor = vec4(res, 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 1.) && CLOSE(cell.y, 3.)) { // camera position to animate to\n        vec3 res;\n        if (!isInitial && isToggled(iChannel1, KEY_W)) {\n            res = vec3(0., 30., -1.);\n        } else {\n            res = getCameraPos(isInitial);\n        }\n        fragColor = vec4(res, 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 2.) && CLOSE(cell.y, 3.)) { // camera target\n        vec3 res;\n        if (isInitial) {\n            res = getCameraTarget(true);\n        } else {\n            res = sampleCamTarget(iChannel0);\n            vec3 next = sampleCamTargetNext(iChannel0);\n            res += (next - res) * 0.2;\n        }\n        \n        \n        fragColor = vec4(res, 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 3.) && CLOSE(cell.y, 3.)) { // camera target to animate to\n        vec3 res;\n        \n        if (!isInitial && isToggled(iChannel1, KEY_W)) {\n            res = vec3(0., rTableHeight, 0.);\n        } else {\n            res = getCameraTarget(isInitial);\n        }\n        \n        fragColor = vec4(res, 1.);\n        return;\n    }\n    \n    // Write init flag\n    \n    if (CLOSE(cell.x, 1.) && CLOSE(cell.y, 2.)) {\n        fragColor = vec4(1.);\n        return;\n    }\n    \n    // Writing keyboard state\n    \n    if (CLOSE(cell.x, 3.) && CLOSE(cell.y, 2.)) { // Cue rotation\n        float res = isInitial ? 0.001 : sampleCueDir(iChannel0);\n        \n        if (!isInitial) {\n            if (isPressed(iChannel1, KEY_A)) {\n                res -= 0.003;\n            } else if (isPressed(iChannel1, KEY_D)) {\n                res += 0.003;\n            }\n        }\n        \n        fragColor = vec4(mod(res, 1.), 0., 0., 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 0.) && CLOSE(cell.y, 2.)) { // View rotation\n        float res = isInitial ? 0. : sampleRot(iChannel0);\n        \n        if (!isInitial) {\n            if (isPressed(iChannel1, KEY_RIGHT_ARROW)) {\n                res -= 0.007;\n            } else if (isPressed(iChannel1, KEY_LEFT_ARROW)) {\n                res += 0.007;\n            }\n        }\n        \n        fragColor = vec4(mod(res, 1.), 0., 0., 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 2.) && CLOSE(cell.y, 2.)) { // Hit power\n        vec2 res = isInitial ? vec2(0.) : sampleHitPowerRaw(iChannel0);\n\n        if (!isInitial) {\n            \n            vec2 ballVel = sampleVel(iChannel0, 0.).xy;\n            if (length(ballVel) <= EPS) {\n                if (isPressed(iChannel1, KEY_Q)) {\n                    res.x += 0.007;\n                    res.y = 1.;\n                } else if (res.y > EPS) {\n                    res.y = 0.;\n                } else if (res.x > EPS) {\n                    res.x = 0.;\n                }\n            }\n        }\n        \n        fragColor = vec4(mod(res.x, 1.), res.y, 0., 1.);\n        return;\n    }\n    \n    // Writing game state\n    \n    if (cell.y >= 2. || cell.x >= BALL_COUNT || cell.x < 0.) return;\n       \n    vec3 res = vec3(0.);\n    bool isVelocity = cell.y >= 1.;\n    float ballId = cell.x;\n    \n    vec3 curVel;\n    vec2 curPos;\n    if (!isInitial) {\n        curVel = sampleVel(iChannel0, ballId);\n        curPos = samplePos(iChannel0, ballId);\n    }\n    \n    if (isVelocity) {\n        if (isInitial) {\n            res = getInitialVel(ballId);\n        } else {\n            res = nextVel(ballId, curPos, curVel);\n        }\n        \n        res = res * 0.5 + 0.5;\n    } else {\n        if (isInitial) {\n            res.xy = getInitialPos(ballId);\n        } else {\n            res.xy = nextPos(curPos, curVel);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(res, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define EPS (0.0001)\n#define CLOSE(x, y) (abs(x - y) < EPS)\n\n#define GRID_SIZE (100.)\n#define GRID_CELL (1. / GRID_SIZE)\n#define GRID_HALF vec2(GRID_CELL * 0.5)\n\n#ifdef DEBUG_BALLS\n#define BALL_COUNT (2.)\n#define BALL_COUNT_I (2)\n#else\n#define BALL_COUNT (11.)\n#define BALL_COUNT_I (11)\n#endif\n\n#define BALL_RADIUS (0.015)\n#define BALL_M (BALL_RADIUS * BALL_RADIUS)\n#define BALL_ACCEL (0.98)\n#define HIT_DECCEL (0.95)\n\n#define TABLE_SIZE (vec2(1., 0.5))\n\n#define POCKET_RADIUS (BALL_RADIUS * 1.8)\n#define SP (POCKET_RADIUS)\n#define LP (POCKET_RADIUS * 1.14)\n#define BORDER_SIZE (POCKET_RADIUS)\n#define POCKET0 (vec2(LP))\n#define POCKET1 (vec2(0.5, 0.) * TABLE_SIZE + vec2(0., SP))\n#define POCKET2 (vec2(1., 0.)  * TABLE_SIZE + vec2(-LP, LP))\n#define POCKET3 (vec2(0., 1.)  * TABLE_SIZE + vec2(SP, -SP))\n#define POCKET4 (vec2(0.5, 1.) * TABLE_SIZE + vec2(0., -SP))\n#define POCKET5 (vec2(1., 1.)  * TABLE_SIZE - vec2(LP))\n#define SCORE_DIST (POCKET_RADIUS * 0.8)\n\n\nconst float rTableSize = 20.;\nconst float rTableHeight = 8.;\nconst float rTableHeightHalf = rTableHeight / 2.;\nconst float rBorderSize = BORDER_SIZE * rTableSize;\nconst float rTableThickness = 0.02 * rTableSize;\nconst float rTableThicknessHalf = rTableThickness / 2.;\nconst float rTableFooterHeight = 0.05 * rTableSize;\nconst vec3 rCueDim = vec3(0.007, 0.002, 0.3) * rTableSize;\nconst vec3 rTableZeroBase = vec3(\n    -TABLE_SIZE.x * rTableSize / 2., \n    0., \n    -TABLE_SIZE.y * rTableSize / 2.\n);\nconst float rBallRadius = rTableSize * BALL_RADIUS;\n\n\n// State accessors\n\nvec2 getGridCell(vec2 uv) {\n    vec2 scaled = uv * GRID_SIZE;\n    vec2 vertex = floor(scaled);\n    vec2 center = vertex + 0.5;\n    return distance(scaled, center) < 0.5 ? vertex : vec2(-1.);\n}\n\nvec4 sampleAtIndex(sampler2D tex, vec2 index) {\n    return texture(tex, index / GRID_SIZE + GRID_HALF);\n}\n\nbool sampleInitFlag(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(1., 2.)).x > 0.5;\n}\n\nvec2 sampleHitPowerRaw(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(2., 2.)).xy;\n}\n\nfloat sampleRot(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(0., 2.)).x;\n}\n\nvec2 samplePos(sampler2D tex, float ballId) {\n    return sampleAtIndex(tex, vec2(ballId, 0.)).xy;\n}\n\nvec3 sampleVel(sampler2D tex, float ballId) {\n    vec3 raw = sampleAtIndex(tex, vec2(ballId, 1.)).xyz;\n    return raw * 2. - 1.;\n}\n\nfloat sampleCueDir(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(3., 2.)).x;\n}\n\nvec3 sampleCamPos(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(0., 3.)).xyz;\n}\n\nvec3 sampleCamPosNext(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(1., 3.)).xyz;\n}\n\nvec3 sampleCamTarget(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(2., 3.)).xyz;\n}\n\nvec3 sampleCamTargetNext(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(3., 3.)).xyz;\n}\n\nconst vec3 UP = vec3(0., 1., 0.);\n\nvec3 getInitialRD(vec2 vp, vec3 origin, vec3 target, float d) {\n    vec3 forward = normalize(target - origin);\n    vec3 right = normalize(cross(UP, forward));\n    vec3 up = cross(forward, right);\n    return normalize(d * forward + right * vp.x + up * vp.y);\n}\n\nfloat getCueAngle(float source) {\n    return source * 6.28;\n}\n\nvec2 getCueDir(float source) {\n    float angle = getCueAngle(source);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat getCueOffset(vec2 source) {\n    return abs(sin(source.x * 3.1415));\n}\n\nfloat getHitPower(vec2 source) {\n    if (source.x > EPS && source.y < EPS) {\n        return getCueOffset(source);\n    }\n    \n    return 0.;\n}\n\n// Quaternions\n\nstruct Quat { vec4 value; };\n\nQuat qCreateRotation(vec3 axis, float angle) {\n    float ah = angle / 2.;\n    return Quat(vec4(axis.xyz * sin(ah), cos(ah)));\n}\n\nvec3 qRotate(vec3 v, Quat q) {\n    vec3 temp = cross(q.value.xyz, v) + q.value.w * v;\n    return v + 2. * cross(q.value.xyz, temp);\n}\n\n// Keyboard helpers\n\n#define KEY_LEFT_ARROW (37.0)\n#define KEY_RIGHT_ARROW (39.0)\n#define KEY_Q (81.0)\n#define KEY_A (65.0)\n#define KEY_D (68.0)\n#define KEY_W (87.0)\n#define KEY_G (71.0)\n#define KEY_T (84.0)\n#define KEY_R (82.0)\n\nbool isPressed(sampler2D tex, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.25);\n    float key = texture(tex, uv).r;\n    return key > 0.0;\n}\n\nbool isToggled(sampler2D tex, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.75);\n    float key = texture(tex, uv).r;\n    return key > 0.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}