{
    "Shader": {
        "info": {
            "date": "1659286048",
            "description": "potato  ",
            "flags": 32,
            "hasliked": 0,
            "id": "fttyR8",
            "likes": 39,
            "name": "Day 955",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 658
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    C *= 0.;\n    \n    float sc = 1./(1.+max(15.*float(lightMode == 1.)*max(sin(iTime*2.),0.)*sin(iTime*0.5),0.));\n    \n    float md = 14.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(iTime*md)),hash11(ceil(iTime*md)),fract(iTime*md)),0.5)*0.5;\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    float db = sdBox(nuv,vec2(0.26,0.26));\n    \n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    \n    if(db > 0.){\n        //b = 1.-step(b,vec4(0.4,0.1,0.4,1));\n        b *= 0.1;\n        //b = 1.-b;\n    }\n\n    \n    C += a - b ;\n    C *= Td(uv);\n    \n    vec3 n = hash33(vec3(U,mod(iTime,200.)));\n    vec3 nb = hash33(vec3(U,mod(iTime,5200.)));\n    //C = mix(C,n.xyzx,n.xyzz);\n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    C = mix(C,1.-C,smoothstep(dFdx(nuv.x),0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    C = max(C,vec4(0.01));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define lightMode float(fract(iTime*0.1) <0.5 )\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 12.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2 + idx)),14.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 4. - hash11(idx)*4.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvec3 map(vec3 p){\n    vec3 d = vec3(0);\n    \n    p *= 3.;\n    vec3 op = p;\n    float att = 1.;\n    for(float i = 0.; i < 3.; i++){\n        \n        p = abs(p);\n        p *= 1.5;\n        \n        p -= 0.4;\n        if(lightMode==0.)\n            p /= clamp(dot(p,p),-.5,2.4);\n        \n        \n        p += sin(dot(p,cos(p*1. + i + iTime)))*att*0.4;\n        p.yz *= rot(1.6 + i*0.);\n        p.xy *= rot(4.6);\n        \n        \n        \n        d += exp(-abs(dot(op.xx,p.xy))*80.)*att*3.;\n        //d += abs(dot(sin(p*1.),cos(p*1.5 + 15.)))*att;\n        att *= 0.7;\n    }\n    //d = clamp(d,0.,1.);\n    //d = max(d,0.);\n    d *= 1.4;\n//d = 1.-abs(d);\n    //d = abs(d);\n    //d = clamp(d,0.,1.);\n    //d = max(d,0.);\n    //d = mix(vec3(1,0.5,1)*0.1,vec3(1,1.5,1),d*5.);\n    \n    //d = mix(vec3(1.4,0.1,0.4),vec3(0,0.4,0.2),d*0.5)*d;\n    d = (0.5 + 0.5*sin(vec3(1,2,5)*1. - cos(d*29.)*0. + 4. + d.x*0.4))*d*1.;\n    //d = exp(d*1000.);\n    //d = pow(d,vec3(5.));\n    return d;\n}\n\nvec3 getMarch(vec3 ro, vec3 rd, vec2 uv){\n\n    vec3 col = vec3(0);\n    \n    float iters = 510.;\n    float maxD = 10. + 5.*float(sin(iTime));\n    vec3 accum = vec3(0);\n    //float stepSz = 1./iters*maxD*mix(0.99,1.,hash23(vec3(uv*2000.,110.)).x);\n            \n    //ro -= rd * hash23(vec3(uv*2000.,510. + iTime*0.)).x*1./iters*maxD;\n    float dith = texture(iChannel1,gl_FragCoord.xy/vec2(textureSize(iChannel1,0).xy*2)).x;\n    dith = step(dith,0.5);\n    ro -= rd * dith * 11./iters*maxD;\n    //ro -= rd * hash23(vec3(uv*2000.,510. + iTime*0.)).x*1./iters*maxD;\n    \n    vec3 p = ro;\n    \n    float t = 0.;\n    float stepSz = 1./iters*maxD;\n    for(float i = 0.; i < iters; i++){\n        vec3 d = map(p);\n        \n        accum += d*stepSz*(1.-dot(accum,accum));\n        stepSz = 1./iters*maxD*mix(1.,0.5,exp(-dot(d,d)*44.));\n    \n        if(dot(accum,accum) > 0.8 || t > maxD)\n            break;\n        t += stepSz;\n        p += rd*stepSz;\n    }\n    \n    //col += accum;\n    col = mix(col,accum,dot(accum,accum)*15.);\n    //col = mix(col,accum,pow(dot(accum,accum)*4.,1.)*144.);\n    \n    col = col/(2. + col*0.7)*1.4;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(0,0,-2);\n    ro.xy *= rot((iTime*0.8 + sin(iTime*1.7)*0.6)*0.1);\n    ro.xz *= rot((iTime + sin(iTime*1.4))*0.2);\n    ro.xz *= rot(iMouse.x/iResolution.x);\n    ro.yz *= rot(iMouse.y/iResolution.x);\n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    \n    col = getMarch(ro, rd, uv);\n    \n    {\n        for(float i = 0.; i < 40.; i++){\n            vec3 dotPos = hash31(i + 20.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            lp *= rot(exp(-fract(iTime*sin(i) + sin(i)*20.)*4.)*pi);\n            float d = max(\n                min(abs(lp.x),abs(lp.y)),\n                sdBox(lp,vec2(0.01))\n                ) - 0.0001 - 0.001*pow(abs(sin(i + iTime)),5.);\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n            col += smoothstep( 1./R.x, 0. , d);\n        }\n        \n        for(float i = 0.; i < 40. - 30.*lightMode; i++){\n            vec3 dotPos = max(hash31(i + 100.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n\n            float sc = 8. + sin(i)*5.;\n            lp *= sc;\n            //uv *= 2.;\n\n            float td = text(lp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.47 , true, i);\n            \n            //col = mix(col,vec3(1),smoothstep(0.4*fwidth(td)*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n            col = mix(col,vec3(1),smoothstep(0.4*0.01*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n\n        }\n        for(float i = 0.; i < 10.; i++){\n            vec3 dotPos = max(hash31(i + 1200.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            lp *= 17.4;\n\n            float md = 0.3;\n            float id = floor(lp.y/md);\n            if(id < 2. || id > 9. + sin(i)*20.)\n                continue;\n            lp.y = mod(lp.y,md);\n            float td = textb(lp, float[4*4](\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,96.,96.,96.\n                ), -0.5 , 0.2 , false, 0., 0.47 , true, id + i*20. + floor(iTime*10.));\n            col = mix(col,vec3(1),smoothstep(0.04,0.,td - 0.0));\n        }\n        \n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n\n        \n    \n    }\n    \n    uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float td = sdBox(uv - (max(hash31(floor(iTime*1.)).xy,0.2)*1. - 0.75)*2., vec2(0.1,0.001));\n    \n    \n    if(td < 0.){\n        col = 1.-col;\n    }\n\n    //col = mix(col,1.-col,smoothstep(0.,fwidth(td),td));\n    //vec3 rd = normalize(vec3(uv,1));\n    \n    \n    \n    \n    if((envb(iTime) < 0.1))\n        col = luma(col)*vec3(1);\n\n    \n    //col = 1.- col;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\n\nfloat text(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy*(1. ) ;\n    uv += vec2(.6,0)*float(fract(iTime*14.2) < 0.4)*float(fract(iTime*2.2) < 0.1);\n    vec2 t = 1./R.xy;\n    vec4 l = vec4(\n        luma(Ta(uv + vec2(t.x,0)))-luma(Ta(uv - vec2(t.x,0))) +\n        luma(Ta(uv + vec2(0,t.y)))-luma(Ta(uv - vec2(0,t.y)))\n    );\n    //l = abs(l);\n    \n    \n    if(fract(iTime) < 0.1)\n        C = vec4(step((l.x),0.04));\n    else\n        C = vec4(1);\n    \n    uv = (U - 0.5*R.xy)/R.y;\n\n    if((lightMode==0.)){\n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n        float md = 0.1;\n        float id = floor(p.y/md);\n        p.y = mod(p.y,md);\n        float td = text(p, float[4*4](\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,96.,96.,96.\n            ), -0.5 , 0.2 , false, 0., 0.47 , true, id);\n        C = mix(C,vec4(0),smoothstep(0.01,0.,td - 0.02));\n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// dither\n/*\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n*/\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + int(fract(iTime*0.1) < 0.2)))).x;\n    \n    \n    float quant = 3.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    vec3 currColHsv = rgb2hsv(s.xyz);\n    s = hsv2rgbSmooth(currColHsv*vec3(1,0.2,1.) + vec3(0.3,0.,0.)).xyzz;\n    \n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n\n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n   \n\n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x)];\n    //char += 112. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 oU = U;\n    float sc = 4. + 4.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    uv.x = abs(uv.x);\n    \n    uv.x -= 0.4;\n    vec2 t = 1./R.xy;\n    \n    \n    \n    vec2 prevP = vec2(0);\n    \n    float d = 10e4;\n    for(float i = 0.; i < 10.; i++){\n        vec2 k = vec2(sin(i*0.7 + sin(iTime + i)), cos(i*1.5 + iTime)*2.)*0.1;\n            \n            \n            \n        d = min(d,sdSegment(uv,k,prevP) - 0.004 - noise(vec3(i+iTime + sin(iTime + i),uv*5.))*0.01);\n        \n        \n        prevP = k;\n    }\n   \n   float od = d;\n   d = abs(d);\n   C *= 0.;\n   //C += 1.; // epic lol\n   \n   \n   if(lightMode == 1.)\n       C += 1.;\n   else\n       C= mix(C,1.-C,smoothstep(0.,fwidth(d),d - 0.004));\n   \n   if(od < 0.)\n       return;\n   \n    sc = 3. + 2.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   u.x -= .5;\n   u*=2. + floor((hash11(floor(iTime/3.))*4.));\n   u.x /= 1.5;\n   \n   //u += 1./3.;\n   if(u.x < 1. && u.y < 1. && u.x > 0. && u.y > 0. && lightMode == 0.)\n       C -= 1.- texture(iChannel1,u);\n    \n    \n    sc = 2.;\n    U = floor(U/sc)*sc;   \n    uv = (U-R.xy*0.5)/R.y;\n    \n    float pxsz = 0.001;\n    float tt =10e5;\n    for(float i = 0.; i < 0.; i++){\n        float m = sin(iTime*0.4 + sin(iTime)+i);\n        tt = min(tt,text(uv + vec2(0,sin(i+ m)*0.1), float[8](135.,130.,121.,119.,120.,132.,117.,130.), 0.04 +m*0.5 , 0.5 , true, 0.004, 0.3 + 0.1*sin(iTime+i*0.4), false));\n    }\n    {\n        float m = sin(iTime*0.4 + sin(iTime));\n        vec2 p = uv + vec2(0.7,-0.2);\n        //p *= rot(0.5*pi);\n        p.x += (iTime + sin(iTime))*0.3;\n        p.x = pmod(p.x,6.);\n        tt = min(tt,text(p, float[8](128.,127.,132.,113.,132.,117.,1117.,1130.), 0.01 +m*0.4 , 0.4 , true, 0.0001, 0.4 + 0.*sin(iTime*0.3 + 0.4), true));\n    }   \n             \n            \n    C = mix(C,(0.6-C) ,smoothstep(pxsz + 0.01,0., tt - 0.01));\n    \n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}