{
    "Shader": {
        "info": {
            "date": "1719680593",
            "description": "sphere\noriginals https://www.shadertoy.com/view/Nsy3Dy\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XXtSWX",
            "likes": 4,
            "name": "sphere of  fractal",
            "published": 3,
            "tags": [
                "fractal",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\n\n\n\n#define PI acos(-1.)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.05,fwidth(val-thre)))\n\n#define TRYPOPHOBIA 0\n\n// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTet(vec3 p, float r) {\n    const vec3 c = normalize(vec3(1.,-1.,1.));\n    return max(max(max(dot(p, c.xxx) - r, dot(p, c.yyx) - r), dot(p, c.xyy) - r), dot(p, c.yxy) - r);\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\n// assumes normalized axis\nmat3 makeRotation(vec3 axis,float angle) {\n    \n    float c = cos(angle), s = sin(angle);\n    float mc = 1. - c;\n    float sz = s * axis.z;\n    float sy = s * axis.y;\n    float sx = s * axis.x;\n    float mx = mc * axis.x;\n    float my = mc * axis.y;\n    float mz = mc * axis.z;\n    \n    return mat3(c + mx * axis.x,\n                mx * axis.y - sz,\n                mx * axis.z + sy,\n                mx * axis.y + sz,\n                c + my * axis.y,\n                my * axis.z - sx,\n                mx * axis.z - sy,\n                my * axis.z + sx,\n                c + mz * axis.z);\n}\n\n// -----------------\n\nmat3 innerRotation;\n\nfloat d(vec3 position) {\n    position = rX(position, iTime * 0.0);\n    float fScale = 0.79 + sin(iTime * 0.0) * 0.013;\n    float accumulatedScale = 1.;\n    \n    for(int i = 0; i < 8; i++) {\n        position = abs(position);\n        position *= fScale;\n        accumulatedScale *= fScale;\n        position -= (0.0137 + 0.001 );\n        position = innerRotation * position;\n    }\n    float cutoutAmount = pow(sin(iTime * 0.0), 4.);\n    #if TRYPOPHOBIA\n    float innerCutout = sdTet(-position,0.003 + cutoutAmount * 0.009);\n    #else\n    float innerCutout = sdSphere(position, 0.014 + cutoutAmount * 0.002);// sdSphere(position, 0.009 + cutoutAmount * 0.007);\n    #endif\n    float outerCrop = sdSphere(position, 0.021 + sin(iTime * 0.00 + 2.) * 0.003);\n    return opInt(opSub(sdTet(position, 0.01), innerCutout), outerCrop) / accumulatedScale;\n}\n\n\n\n// soft shadows also using iq’s technique — https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 origin, vec3 direction, float sharpness) {\n    const float maxDistance = 2.;\n    float amount = 1.;\n    float totalDistance = 0.;\n    for(int i = 0; i < 70; i++) {\n        float localDistance = d(origin);\n        amount = min(amount, 0.5 + 0.5 * localDistance / (sharpness * totalDistance));\n        if (localDistance < 0.) break;\n        origin += direction * max(0.002, localDistance);\n    }\n    \n    amount = max(amount, 0.);\n    return amount * amount * (3. - 2. * amount);\n    \n}\n\n\n#define ANTIALIASING_SAMPLES 3\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n      vec2 uv =  C/iResolution.xy-0.5;\n \n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    \n    \n    vec2 uv2 = 2.0 * (C.xy / iResolution.xy - 0.5);\n   \n    \n    innerRotation = makeRotation(normalize(vec3(1.,2.,-3.)), iTime * 0.1 + sin(iTime * 0.0) * 0.1);\n    \n\n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.05*exp(-.45*i*i*e))\n    {\n    \n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .57)) * 1.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n  \n        p=g*d-vec3(0.,.0,1.1);\n        p=R(p,normalize(vec3(1,-2,2)),iTime);\n        s=4.;\n   \n        vec4 q=vec4(p*innerRotation,0.20+0.051*cos(iTime));\n                q.xzy*=innerRotation;\n                 q.xy*=ma;\n\t\tfor(int j=0;j++<8;)\n\n            q=abs(q),\n               \n            q=q.x<q.y?q.zwxy:q.zwyx,\n            s*=e=1.15/min(dot(q,q),0.54),\n            \n            q=q*e-vec4(1,4,.8,3);\n           \n        g+=e=min(\n            length(q.w+q.x)/s,\n            length(cross(q.yzw,normalize(vec3(1,1,1))))/s-.0002\n        );\n    }\n    O=pow(O,vec4(5));\n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}