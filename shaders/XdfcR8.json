{
    "Shader": {
        "info": {
            "date": "1486890676",
            "description": "Use WASD or ARROWS to control the car, SPACE to boost. (work in progress...)",
            "flags": 48,
            "hasliked": 0,
            "id": "XdfcR8",
            "likes": 26,
            "name": "Drifting simulator",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "signeddistancefield"
            ],
            "usePreview": 0,
            "username": "daltostronic",
            "viewed": 2591
        },
        "renderpass": [
            {
                "code": "#define ARRAY_MAX 50\n#define vPlayer 0.0\n#define vPlayerVel 1.0\n#define vScore 2.0\n#define vHighScore 3.0\n#define vIdleTime 4.0\n#define vCheckpoint 5.0\n#define vMoveCam 6.0\n\nvec4 get(in float id)\n{\n    vec2 re = vec2(id, .0);\n    return texture(iChannel3, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 player = get(vPlayer);\n    vec2 cam = player.xy * get(vMoveCam).x / (iResolution.xy * 0.5);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = mix(texture(iChannel0, uv) * texture(iChannel1, fract(uv + cam)), texture(iChannel0, uv), texture(iChannel2, uv).x);\n\t//fragColor = texture(iChannel2, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define IN_DEVELOPMENT_CAMERA_MOVEMENT 0.0\n\n// main logic\n\n#define ARRAY_MAX 50\n#define vPlayer 0.0\n#define vPlayerVel 1.0\n#define vScore 2.0\n#define vHighScore 3.0\n#define vIdleTime 4.0\n#define vCheckpoint 5.0\n#define vMoveCam 6.0\n\n// ===\n\n#define zero vec2(0.0, 0.0)\n#define one vec2(1.0, 1.0)\n#define right vec2(1.0, 0.0)\n#define up vec2(0.0, 1.0)\n\n#define PI 3.14159265359\n\n// ===\n\nvec2 rot(vec2 p, float a)\n{\n    mat2 r = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return p * r;\n}\n\n// ===\n\n\nfloat isInside(vec2 p, vec2 c) { vec2 d = abs(p - 0.5 - c) - 0.5; return -max(d.x, d.y); }\n\nvec4 get(in float id)\n{\n    vec2 re = vec2(id, .0);\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\nvoid setValue(in float id, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 re = vec2(id, .0);\n    fragColor = (isInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\nvec4 getarr(in float id, in int i)\n{\n    vec2 re = vec2(id + float(i), .0);\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\nvoid setArray(in float id, in vec4[ARRAY_MAX] va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    for (int i = 0; i < ARRAY_MAX; ++i)\n    {\n        vec2 re = vec2(id + float(i), .0);\n        fragColor = (isInside(fragCoord, re) > 0.0) ? va[i] : fragColor;\n    }\n}\n\n#define set(id, va) setValue(id, va, fragColor, fragCoord)\n#define setarr(id, va) setArray(id, va, fragColor, fragCoord)\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\n\nfloat getKey(float key)\n{\n    return texture(iChannel1, vec2(key, 0.25)).x;\n}\n\n// ===\n\nvec2 loopPos(vec2 p)\n{\n    vec2 r = iResolution.xy * 1.15;\n\treturn fract((p + r * 0.5) / r) * r - r * 0.5;\n}\n\n// ===\n\nvec2 pseudoRandomLocation()\n{\n    float t = iTime * 10.0;\n    return iResolution.xy * 0.4 * vec2(sin(10.0 * t), cos(8.0 * t));\n}\n\n// ===\n\n#define speed 5.5\n#define accel 0.02\n#define rotSpeed 0.2125\n#define driftThreshold 0.175\n#define maxIdleTime 1.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float sp = mix(speed, speed * 1.5, getKey(KEY_SPACE));\n    \n    float aX = -getKey(KEY_A) + getKey(KEY_D) -getKey(KEY_LEFT) + getKey(KEY_RIGHT);\n    float aY = -getKey(KEY_S) + getKey(KEY_W) -getKey(KEY_DOWN) + getKey(KEY_UP);\n    \n    aX *= iTimeDelta * 45.0;\n    aY *= iTimeDelta * 45.0;\n    \n    vec4 vel = get(vPlayerVel);\n    \n    set(vMoveCam, vec4(IN_DEVELOPMENT_CAMERA_MOVEMENT));\n    \n    vec4 player = get(vPlayer);\n    aX = abs(aX) > 0.0 ? mix(player.w, aX, 0.5) : player.w * 0.925;\n    \n    float playerRot = player.z - aX * rotSpeed / max(5.0, length(vel.xy));\n\n    vel.xy = mix(vel.xy, rot(up, -playerRot) * aY * sp, accel);\n    \n    float drift = clamp(abs(dot(rot(up, -playerRot), normalize(get(vPlayerVel).xy))), 0.0, 1.0);\n    float sc = get(vScore).x + (1.0 - drift > driftThreshold && length(vel.xy) > 2.0 ? 1.0 : 0.0);\n    set(vIdleTime, vec4((1.0 - drift > driftThreshold && length(vel.xy) > 2.0 ? 0.0 : get(vIdleTime).x + iTimeDelta)));\n    \n    float g = length(player.xy - get(vCheckpoint).xy);\n    set(vCheckpoint, g < 40.0 ? vec4(pseudoRandomLocation(), 0.0, 0.0) : vec4(get(vCheckpoint).xy, 0.0, 0.0));\n    sc = g < 40.0 && iFrame > 1 ? sc + 500.0 : sc;\n    \n    float hsc = get(vHighScore).x;\n    float idle = get(vIdleTime).x;\n    set(vScore, idle > maxIdleTime ? vec4(0.0) : vec4(clamp(sc, 0.0, 999999.0)));\n    set(vHighScore, idle > maxIdleTime ? (sc > hsc && sc > 1.0 ? vec4(sc) : vec4(hsc)) : vec4(hsc));\n    \n    player.xy = loopPos(player.xy);\n    set(vPlayer, vec4(player.xy + vel.xy, playerRot, aX));\n    \n    set(vPlayerVel, vec4(vel.xy, mix(vel.z, sp, accel), 0.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// rendering\n\n#define ARRAY_MAX 50\n#define vPlayer 0.0\n#define vPlayerVel 1.0\n#define vScore 2.0\n#define vHighScore 3.0\n#define vIdleTime 4.0\n#define vCheckpoint 5.0\n#define vMoveCam 6.0\n\n// ===\n\nvec4 get(in float id)\n{\n    vec2 re = vec2(id, .0);\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec4 getarr(in float id, in int i)\n{\n    vec2 re = vec2(id + float(i), .0);\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\n// ===\n\n#define zero vec2(0.0, 0.0)\n#define one vec2(1.0, 1.0)\n#define right vec2(1.0, 0.0)\n#define up vec2(0.0, 1.0)\n\n#define PI 3.14159265359\n\n// ===\n\nfloat sum(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat diff(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat symdiff(float a, float b)\n{\n    return sum(diff(a, b), diff(b, a));\n}\n\n// ===\n\nvec2 rot(vec2 p, float a)\n{\n    mat2 r = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return p * r;\n}\n\n// ===\n\n// function by if https://www.shadertoy.com/view/MddGzf\nfloat digit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n    data = n < 9.5 ? 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0 : data;\n    data = n < 8.5 ? 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0 : data;\n    data = n < 7.5 ? 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0 : data;\n    data = n < 6.5 ? 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0 : data;\n    data = n < 5.5 ? 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0 : data;\n    data = n < 4.5 ? 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0 : data;\n    data = n < 3.5 ? 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0 : data;\n    data = n < 2.5 ? 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0 : data;\n    data = n < 1.5 ? 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0 : data;\n    data = n < 0.5 ? 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0 : data;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\n// ===\n\nfloat circle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat square(vec2 p, float r)\n{\n    float v = max(p.x - r, -p.x - r);\n    float h = max(p.y - r, -p.y - r);\n    return max(v, h);\n}\n\nfloat rect(vec2 p, vec2 r)\n{\n    float v = max(p.x - r.x, -p.x - r.x);\n    float h = max(p.y - r.y, -p.y - r.y);\n    return max(v, h);\n}\n\nfloat triangle(vec2 p, float a, float r)\n{\n    float b = -p.y - r;\n    float sl = -rot(p, -a * 0.5).x - r;\n    float sr = rot(p, a * 0.5).x - r;\n    return max(max(b, sl), sr);\n}\n\n// ===\n\nfloat fill(float dist)\n{\n    return clamp(-dist, 0.0, 1.0);\n}\n\nfloat outline(float dist, float width)\n{\n    float a = clamp(dist + width, 0.0, 1.0);\n    float a2 = clamp(dist, 0.0, 1.0);\n    return a - a2;\n}\n\n// ===\n\nfloat sdf(vec2 p)\n{\n    float c1 = circle(p, 50.0);\n    float c2 = circle(p - right * 50.0, 50.0);\n    \n    float s = 0.0;\n    s = diff(c1, c2);\n    s = square(p, 50.0);\n    s = sum(triangle(p, PI / 5.0, 50.0), circle(p + up * 25.0, 50.0));\n    \n    return s;\n}\n\nfloat player(vec2 p)\n{\n    vec4 player = get(vPlayer);\n    float s = 0.5;\n    \n    p = rot(p - player.xy, player.z) - up * 5.0;\n    float r = rect(p, vec2(15.0, 30.0) * s);\n    float r2 = rect(p + up * 5.0, vec2(10.0, 14.0) * s);\n    float r3 = rect(p + up * 6.0, vec2(8.0, 12.0) * s);\n    float t = triangle(p + up * 30.0 * s, PI / 8.0, 25.0 * s);\n    return diff(sum(diff(r, r2), r3), -t);\n}\n\nfloat road(vec2 p)\n{\n    float scale = 0.75;\n    float s = 0.0;\n    float c1 = circle(p + right * iResolution.x * 0.25 * scale, iResolution.y * 0.5 * scale);\n    float c2 = circle(p - right * iResolution.x * 0.25 * scale, iResolution.y * 0.5 * scale);\n    s = sum(c1, c2);\n    float c3 = circle(p + right * iResolution.x * 0.25 * scale, iResolution.y * 0.2 * scale);\n    float c4 = circle(p - right * iResolution.x * 0.25 * scale, iResolution.y * 0.2 * scale);\n    float inner = sum(c3, c4);\n    s = diff(s, inner);\n    return s;\n}\n\nfloat asterisk(vec2 p)\n{\n    const float divs = 12.0;\n    float x = max(p.x - 5.0, -p.x - 5.0);\n    for (int i = 1; i < int(divs); ++i)\n    {\n    \tvec2 v = rot(p, float(i) * PI / divs);\n        float a = max(v.x - 5.0, -v.x - 5.0);\n        x = min(x, a);\n    }\n\n    return x;\n}\n\nfloat roadpaint(vec2 p)\n{\n    float scale = 0.75;\n    float s = 0.0;\n    float cro = circle(p - right * iResolution.x * 0.25 * scale, iResolution.y * 0.36 * scale);\n    float cri = circle(p - right * iResolution.x * 0.25 * scale, iResolution.y * 0.345 * scale);\n    float clo = circle(p + right * iResolution.x * 0.25 * scale, iResolution.y * 0.36 * scale);\n    float cli = circle(p + right * iResolution.x * 0.25 * scale, iResolution.y * 0.345 * scale);\n    float ar = asterisk(p - right * iResolution.x * 0.25 * scale);\n    float al = asterisk(p + right * iResolution.x * 0.25 * scale);\n    \n    float r = diff(diff(cro, cri), ar);\n    float l = diff(diff(clo, cli), al);\n    \n    s = sum(r, l);\n\n    return s;\n}\n\nfloat posts(vec2 p, float s)\n{\n    float r = 10.0;\n    float dst = 110.0;\n    float d = circle(p, r * s);\n    \n    d = sum(d, circle(p - vec2(dst, dst), r * s));\n    d = sum(d, circle(p - vec2(-dst, dst), r * s));\n    d = sum(d, circle(p - vec2(dst, -dst), r * s));\n    d = sum(d, circle(p - vec2(-dst, -dst), r * s));\n    return d;\n}\n\n// ===\n\nvec4 draw(vec4 sceneColor, vec4 objectColor, float dist)\n{\n    vec4 c = mix(sceneColor, objectColor, fill(dist));\n    c = mix(c, vec4(0.0), outline(dist, 2.5));\n    return c;\n}\n\n// ===\n\nfloat dist(in vec2 pos, in float size, in vec2 fragCoord)\n{\n    float dist;\n    dist = distance(fragCoord.xy, pos);\n\tdist = size / pow(dist, 2.0);\n    return dist;\n}\n#define dst(pos, size) dist(pos, size, fragCoord)\n\n// ===\n\nfloat bass()\n{\n    return log2(.5+texture(iChannel1, vec2(1./iChannelResolution[1].x,0)).x);\n}\n\nfloat treble()\n{\n    return texture(iChannel1, vec2(0.0)).x*2.0-1.0;\n}\n\n// ===\n\nvec4 drawscore(vec2 p, float score)\n{\n    vec4 c = vec4(0.0);\n    for (int i = 0; i < 6; ++i)\n    {\n        float dig = score;\n        float dd = pow(10.0, float(5 - i));\n        dig = mod(floor(dig / dd), 10.0);\n\t\tc += vec4(digit(dig, (p - vec2(125.0 + float(i) * 20.0, 110.0)) * 0.05));\n    }\n    \n    return c;\n}\n\nfloat checkpoint(vec2 p)\n{\n    return circle(p, 20.0);\n}\n\n// ===\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = fragCoord.xy - iResolution.xy * 0.5;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 pl = get(vPlayer);\n    vec2 cam = pl.xy * get(vMoveCam).x;\n    p += cam;\n    float d = sdf(p);\n    vec4 c = vec4(0.2);\n    c = texture(iChannel2, texture(iChannel3, uv * 3.0).rb);\n    c = c * 0.4;\n    \n    //c = draw(c, vec4(0.5, 0.5, 0.5, 1.0), road(p));\n    //c = draw(c, vec4(1.0, 1.0 , 1.0, 1.0), roadpaint(p));\n    \n    vec4 red = vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 white = vec4(1.0);\n    \n    c = draw(c, red, posts(p, 1.0));\n    c = mix(c, white, fill(posts(p, 0.65)));\n    c = mix(c, red, fill(posts(p, 0.55)));\n    c = mix(c, white, fill(posts(p, 0.5)));\n    c = mix(c, red, fill(posts(p, 0.35)));\n    c = mix(c, white, fill(posts(p, 0.2)));\n    c = mix(c, red, fill(posts(p, 0.05)));\n    \n    c = draw(c, vec4(sin(iTime * 5.0), sin(iTime * 10.0), sin(iTime * 15.0), 1.0), checkpoint(p - get(vCheckpoint).xy));\n    \n    c += drawscore(p - cam, get(vScore).x);\n    float hs = get(vHighScore).x;\n    c += hs > 1.0 ? drawscore(p + up * 25.0 - cam, hs) : vec4(0.0);\n    \n    float neon = 0.0;//dst(rot(pl.xy, -pl.z) + iResolution.xy * 0.5 + up * 20.0, 50.0);\n    neon += dst(pl.xy + iResolution.xy * 0.5 + up * 0.0 - cam, 50.0 + 250.0 * treble());\n    c = mix(c, vec4(1.0, 0.0, 1.0, 1.0), neon);\n    c = mix(c, vec4(bass(), 1.0, 1.0, 1.0), dst(pl.xy + iResolution.xy * 0.5 + up * 0.0 - cam, 10.0 + 150.0 * clamp(treble(), 0.0, 1.0)));\n    \n    c = draw(c, vec4(uv, 1.0, 1.0), player(p));\n    \n\tfragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// visuals\n\n#define ARRAY_MAX 50\n#define vPlayer 0.0\n#define vPlayerVel 1.0\n#define vScore 2.0\n#define vHighScore 3.0\n#define vIdleTime 4.0\n#define vCheckpoint 5.0\n#define vMoveCam 6.0\n\n// ===\n\n#define zero vec2(0.0, 0.0)\n#define one vec2(1.0, 1.0)\n#define right vec2(1.0, 0.0)\n#define up vec2(0.0, 1.0)\n\n#define PI 3.14159265359\n\n// ===\n\nvec4 get(in float id)\n{\n    vec2 re = vec2(id, .0);\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec4 getarr(in float id, in int i)\n{\n    vec2 re = vec2(id + float(i), .0);\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\n// ===\n\n\nvec2 rot(vec2 p, float a)\n{\n    mat2 r = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return p * r;\n}\n\nfloat circle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat square(vec2 p, float r)\n{\n    float v = max(p.x - r, -p.x - r);\n    float h = max(p.y - r, -p.y - r);\n    return max(v, h);\n}\n\nfloat rect(vec2 p, vec2 r)\n{\n    float v = max(p.x - r.x, -p.x - r.x);\n    float h = max(p.y - r.y, -p.y - r.y);\n    return max(v, h);\n}\n\nfloat fill(float dist)\n{\n    return clamp(-dist, 0.0, 1.0);\n}\n\n// ===\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = fragCoord.xy - iResolution.xy * 0.5;\n\n    vec4 c = vec4(1.0);\n    float s = 0.5;\n\n    vec4 player = get(vPlayer);\n    \n    vec2 ws = vec2(2.5, 5.0) * s;\n    float drift = clamp(abs(dot(rot(up, -player.z), normalize(get(vPlayerVel).xy))), 0.0, 1.0);\n    vec2 pp = rot(p - player.xy, player.z) - up * 10.0;\n    c = mix(c, vec4(0.0), fill(rect(pp - vec2(14.5, 12.0) * s, ws)));\n    c = mix(c, vec4(0.0), fill(rect(pp - vec2(14.5, -30.0) * s, ws)));\n    c = mix(c, vec4(0.0), fill(rect(pp - vec2(-14.5, 12.0) * s, ws)));\n    c = mix(c, vec4(0.0), fill(rect(pp - vec2(-14.5, -30.0) * s, ws)));\n    c = mix(c, vec4(1.0), sqrt(drift));\n    \n    fragColor = c * mix(texture(iChannel2, uv), vec4(1.0), 0.0025);\n    fragColor = mix(vec4(1.0), fragColor, clamp(float(iFrame), 0.0, 1.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// rendering\n\n#define ARRAY_MAX 50\n#define vPlayer 0.0\n#define vPlayerVel 1.0\n#define vScore 2.0\n#define vHighScore 3.0\n#define vIdleTime 4.0\n#define vCheckpoint 5.0\n#define vMoveCam 6.0\n\n// ===\n\nvec4 get(in float id)\n{\n    vec2 re = vec2(id, .0);\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvec4 getarr(in float id, in int i)\n{\n    vec2 re = vec2(id + float(i), .0);\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\n// ===\n\n#define zero vec2(0.0, 0.0)\n#define one vec2(1.0, 1.0)\n#define right vec2(1.0, 0.0)\n#define up vec2(0.0, 1.0)\n\n#define PI 3.14159265359\n\n// ===\n\nfloat sum(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat diff(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat symdiff(float a, float b)\n{\n    return sum(diff(a, b), diff(b, a));\n}\n\n// ===\n\nvec2 rot(vec2 p, float a)\n{\n    mat2 r = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return p * r;\n}\n\n// ===\n\nfloat circle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat square(vec2 p, float r)\n{\n    float v = max(p.x - r, -p.x - r);\n    float h = max(p.y - r, -p.y - r);\n    return max(v, h);\n}\n\nfloat rect(vec2 p, vec2 r)\n{\n    float v = max(p.x - r.x, -p.x - r.x);\n    float h = max(p.y - r.y, -p.y - r.y);\n    return max(v, h);\n}\n\nfloat triangle(vec2 p, float a, float r)\n{\n    float b = -p.y - r;\n    float sl = -rot(p, -a * 0.5).x - r;\n    float sr = rot(p, a * 0.5).x - r;\n    return max(max(b, sl), sr);\n}\n\n// ===\n\nfloat fill(float dist)\n{\n    return clamp(-dist, 0.0, 1.0);\n}\n\nfloat outline(float dist, float width)\n{\n    float a = clamp(dist + width, 0.0, 1.0);\n    float a2 = clamp(dist, 0.0, 1.0);\n    return a - a2;\n}\n\n// ===\n\nfloat sdf(vec2 p)\n{\n    float c1 = circle(p, 50.0);\n    float c2 = circle(p - right * 50.0, 50.0);\n    \n    float s = 0.0;\n    s = diff(c1, c2);\n    s = square(p, 50.0);\n    s = sum(triangle(p, PI / 5.0, 50.0), circle(p + up * 25.0, 50.0));\n    \n    return s;\n}\n\nfloat player(vec2 p)\n{\n    vec4 player = get(vPlayer);\n    vec2 cam = player.xy * get(vMoveCam).x;\n    p += cam;\n    float s = 0.5;\n    \n    p = rot(p - player.xy, player.z) - up * 5.0;\n    float r = rect(p, vec2(15.0, 30.0) * s);\n    float r2 = rect(p + up * 5.0, vec2(10.0, 14.0) * s);\n    float r3 = rect(p + up * 6.0, vec2(8.0, 12.0) * s);\n    float t = triangle(p + up * 30.0 * s, PI / 8.0, 25.0 * s);\n    return diff(sum(diff(r, r2), r3), -t);\n}\n\n// ===\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = fragCoord.xy - iResolution.xy * 0.5;\n    \n    float d = sdf(p);\n    vec4 c = vec4(0.0);\n    \n    c = vec4(fill(player(p)));\n    \n\tfragColor = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 loop(vec2 p, vec2 r)\n{\n    return fract((p + r * 0.5) / r) * r - r * 0.5;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}