{
    "Shader": {
        "info": {
            "date": "1608001946",
            "description": "Mesh effect I used in my [url=https://www.shadertoy.com/view/3dVBWK]\"Underground Flythrough\"[/url] shader. I am not sure how great it is (I don't think the facets are perfectly flat) but it may be useful to someone.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsKfDV",
            "likes": 12,
            "name": "SDF to Mesh",
            "published": 3,
            "tags": [
                "sdf",
                "mesh",
                "mesheffect",
                "sdftomesh"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 767
        },
        "renderpass": [
            {
                "code": "/*\n\"SDF to Mesh\" by oneshade\n\nAfter watching The Art of Code's (BIgWings) video about value noise,\nI started playing around with it and designed a 3D variant. I found\nthat if I removed the smooth remapping of local coordinates I got a\ncool mesh effect. It reminds me of nimitz's \"Triangulator\" shader\n(https://www.shadertoy.com/view/lllGRr) except the facets aren't always\ntriangles and it works on more than just heightmaps. I don't think\nthe facets are always perfectly planar though (take a cube for example).\n\nAlso reminds me a lot of marching cubes.\n*/\n\n// Mesh resolution:\n#define res vec3(1.0, 1.0, 1.0)\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\nfloat mapScene(in vec3 p) {\n    return length(p) - 2.0;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nfloat mapSceneMesh(in vec3 p) {\n    vec3 cell = floor(p / res) * res;\n    vec3 local = fract(p / res);\n\n    float ldb = mapScene(cell);                           // Left, Down, Back\n    float rdb = mapScene(cell + vec3(res.x, 0.0, 0.0));   // Right, Down, Back\n    float ldf = mapScene(cell + vec3(0.0, 0.0, res.z));   // Left, Down, Front\n    float rdf = mapScene(cell + vec3(res.x, 0.0, res.z)); // Right, Down, Front\n    float lub = mapScene(cell + vec3(0.0, res.y, 0.0));   // Left, Up, Back\n    float rub = mapScene(cell + vec3(res.xy, 0.0));       // Right, Up, Back\n    float luf = mapScene(cell + vec3(0.0, res.yz));       // Left, Up, Front\n    float ruf = mapScene(cell + res);                     // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nvec3 getNormalMesh(in vec3 p) {\n    return normalize(vec3(mapSceneMesh(p + vec3(0.001, 0.0, 0.0)) - mapSceneMesh(p - vec3(0.001, 0.0, 0.0)),\n                          mapSceneMesh(p + vec3(0.0, 0.001, 0.0)) - mapSceneMesh(p - vec3(0.0, 0.001, 0.0)),\n                          mapSceneMesh(p + vec3(0.0, 0.0, 0.001)) - mapSceneMesh(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float dt = 0.0;\n\n    bool mesh = mod(floor(iTime), 2.0) == 1.0;\n\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = mapScene(p);\n        if (mesh) {\n            d = mapSceneMesh(p);\n        }\n\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            if (mesh) {\n                n = getNormalMesh(p);\n            }\n\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(COS_15, -SIN_15, SIN_15, COS_15);\n            n.xz *= mat2(c, -s, s, c);\n\n            fragColor.rgb = hue2rgb(0.5 * p.y);\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(0.05, 0.0, abs(fract(p.x) - 0.05)) + smoothstep(0.05, 0.0, abs(fract(p.z) - 0.05)));\n            fragColor.rgb *= max(0.0, dot(n, l));\n            break;\n        }\n\n        if (d > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}