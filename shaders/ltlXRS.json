{
    "Shader": {
        "info": {
            "date": "1439006613",
            "description": "It works on Firefox but not Chrome.\nZakum, a boss from the game Maplestory. High quality pictures/video of the path trace coming soon.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltlXRS",
            "likes": 5,
            "name": "[SIG15] Zakum",
            "published": 3,
            "tags": [
                "raymarch",
                "trace",
                "path",
                "sig15",
                "maplestory"
            ],
            "usePreview": 1,
            "username": "public_int_i",
            "viewed": 635
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2015     http://etahn.com/     https://twitter.com/EthanShulman\n//This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n//   Don't want to wait for the path traced version? Here's some pictures of it at high quality\n// https://pbs.twimg.com/media/CL1rB_gUsAE5ekS.jpg\n\n\n\n//Thanks to P_Mali for the scanline idea\n\n//Still need to make the non-path traced version look decent\n\n\n\n#define FOV_SCALE_X 2.4\n#define FOV_SCALE_Y 2.4\n\n\n#define TRACE_ITER 256\n#define EPSILON .1\n#define NORMAL_EPSILON .0002\n\n\n//enable PATH_TRACE to enable the scanline path traced version\n//32 paths and 12 sub paths is the recommended settings for highest quality\n\n#define PATH_TRACE\n#define PATHS 6\n#define SUB_PATHS 8\n\n#define LINES_PER_SECOND 5.\n\n\n#define EMISSIVE_SCALE 1.\n#define SPECULAR_SCALE 1.\n#define OUTPUT_SCALE 1.7\n\n#define SLIDE_WAIT 7.\n\n//#define CUSTOM_VIEW CameraView(vec3(36.,12.,-145.), vec2(1.6,.2));\n\n\n\nconst vec3 GAMMA = vec3(1.14);\n\n\n\nstruct CameraView {\n    vec3 location;\n    vec2 rotation;\n};\nstruct Mat {\n    vec3 color,specular,emissive;\n    float glossySpecular,clearSpecular,roughness;\n};\n\nvec3 lightDir = normalize(vec3(20.,10.,4.));\n\nCameraView currentView() {\n    int viewId = int(mod(floor(iTime*LINES_PER_SECOND/(iResolution.y+LINES_PER_SECOND*SLIDE_WAIT)), 6.));\n    if (viewId == 0) {\n        return CameraView(vec3(100.,20.,20.), vec2(3.3,0.));\n    }\n    if (viewId == 1) {\n        return CameraView(vec3(65.,20.,70.), vec2(3.7,0.));\n    }\n    if (viewId == 2) {\n        return CameraView(vec3(36.,12.,-145.), vec2(1.6,.2));\n    }\n    if (viewId == 3) {\n        return CameraView(vec3(-40.,70.,-60.), vec2(1.1,-.6));\n    }\n    if (viewId == 4) {\n        return CameraView(vec3(70.,55.,12.), vec2(3.6,0.));\n    }\n    if (viewId == 5) {\n        return CameraView(vec3(30.,90.,0.), vec2(0.,3.94));\n    }\n    \n    return CameraView(vec3(0.),vec2(0.));\n}\n\nfloat length_man(in vec2 uv) {\n    return abs(uv.x)+abs(uv.y);\n}\nfloat voronoi(in vec2 uv) {\n    vec2 lp = abs(uv)*10.;\n    vec2 sp = fract(lp)-.5;\n    lp = floor(lp);\n    \n    float d = 1.;\n    \n    for (int x = -1; x < 2; x++) {\n        for (int y = -1; y < 2; y++) {\n            \n            vec2 mp = vec2(float(x),float(y));\n            vec2 p = lp+mp;\n            \n            d = min(d,length(sp-mp));\n            \n        }\n    }\n    \n    return d;\n}\n\nvec2 rot(in vec2 p, float a) {\n    float ss = sin(a);\n    float sc = cos(a);\n    return vec2(p.x*sc - p.y*ss,\n                p.y*sc + p.x*ss);\n}\nvec3 rot(in vec3 p, vec2 r) {\n    vec3 rp = p;\n    rp.xy = rot(p.xy,r.x);\n    rp.yz = rot(rp.yz,r.y);\n    return rp;\n}\n\n//iq's awesome polynomial smooth min https://iquilezles.org\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat length2(in vec3 p) {\n    const float ln =  2.;\n    return pow( pow(p.x,ln)+\n                pow(p.y,ln)+\n                pow(p.z,ln),\n               \n                1./ln);\n}\nfloat length8(in vec3 p) {\n    const float ln = 8.;\n    return pow( pow(p.x,ln)+\n                pow(p.y,ln)+\n                pow(p.z,ln),\n               \n                1./ln);\n}\nfloat length2(in vec2 p) {\n    const float ln =  2.;\n    return pow( pow(p.x,ln)+\n                pow(p.y,ln),\n               \n                1./ln);\n}\nfloat length8(in vec2 p) {\n    const float ln = 8.;\n    return pow( pow(p.x,ln)+\n                pow(p.y,ln),\n               \n                1./ln);\n}\n\n\n//distance functions\n//from iq's site https://iquilezles.org/articles/distfunctions\nfloat roundBox(in vec3 p, in vec3 boxExt, in float round) {//unsigned\n    return length(max(abs(p)-boxExt,0.0))-round;\n}\nfloat box(in vec3 p, in vec3 boxExt) {//unsigned\n    return length(max(abs(p)-boxExt,0.0));\n}\nfloat sdBox( vec3 p, vec3 b ) {//signed\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdRoundBox( vec3 p, vec3 b , float r ) {//signed\n  vec3 d = abs(p) - b;\n  return (min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)))-r;\n}\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n\nfloat fruit(in vec3 rp) {//actually its an eye but too lazy to change function name\n    return length(rp-vec3(36.,2.4,0.))-3.;\n}\n\nfloat gold(in vec3 rp) {\n    \n    vec3 rrp = rp-vec3(0.,68.,0.);\n    float ang = floor( clamp(atan(rrp.y,rrp.z), -3., 3.4) *(5.) )*.2+.075  ;\n    rrp.yz = rot(rrp.yz,ang);\n    \n    float d = \n        max(-min(rp.y-68., sdTorus82((rp-vec3(0.,68.,0.)).yxz,vec2(5.,6.))),\n            \n            min(sdTorus82((rp-vec3(0.,68.,0.)).yxz,vec2(10.,5.5)),\n               roundBox(rrp-vec3(0.,0.,17.),vec3(2.,.4,2.),.4)));//rock hat\n    \n    vec3 crp = rp-vec3(-20.,20.,0.);\n    crp.yz = rot(crp.yz,.75*sign(rp.z));\n    crp = vec3(crp.xy,\n                    mod(abs(crp.z),8.)-4.);\n    crp = rot(crp,vec2(rp.z/15.,0.));\n    \n    d = min(d, \n            sdTorus82(crp,vec2(4.,1.)));\n    \n    return d;\n}\n\nfloat lava(in vec3 rp) {    \n    return smin(  smin(2.+rp.y,\n                       sdCapsule(rp,vec3(-100.,0.,50.),vec3(-100.,200.,60.), 48.), 24.),\n                \n                smin(sdCapsule(rp,vec3(32.,13.,140.),vec3(32.,-20.,80.), 24.),\n                     sdCapsule(rp,vec3(32.,13.,140.),vec3(32.,150.,140.), 24.) ,\n                     24.), 24. );\n}\n\nfloat rock(in vec3 rp) {\n    float zSign = sign(rp.z);\n    vec3 frpz = vec3(rp.xy,rp.z*zSign);\n    \n    //body\n    float d = min(length(max(abs(rp)-vec3(20.,4.,35.),0.))-1.,\n                  length(max(abs(rp-vec3(0.,4.,0.))-vec3(18.,4.,23.),0.))-1.);//base blocks\n    \n    \n    d = min(d, length(max(abs(rp)-vec3(10.,40.,14.),0.))-1.);//middle body block\n    \n    \n    d = min(d, length(max(abs(frpz-vec3(0.,32.,17.5))-vec3(5.,12.,2.5),0.))-1.);//right forearm\n    d = min(d, \n            max(-sdRoundBox( vec3(frpz.x,mod(abs(frpz.y),4.)-2.,frpz.z)-vec3(20.0,0.,14.5), vec3(2.,.1,2.), .2),\n                roundBox( frpz-vec3(7.5,20.,17.5),vec3(10.5,2.,1.), 3.)));//right lower arm\n    \n    float littleArmsSign = ceil(clamp(max(0.,rp.y-30.),0.,1.));\n    float littleGuyArmsRep = abs(frpz.y-36.);\n    d = min(d, \n             max(-sdRoundBox( vec3(frpz.x,littleGuyArmsRep,mod(abs(frpz.z+2.5),4.)-2.)-vec3(20.-littleArmsSign*7.,25.5,0.), vec3(2.,2.,.16), .2),\n                 roundBox(vec3(frpz.x,littleGuyArmsRep,frpz.z)-vec3(7.-littleArmsSign*7.,25.,18.-littleArmsSign*9. ),vec3(12.,max(0.,1.4-pow(max(0.,(rp.x-(16.8-littleArmsSign*7.))*.5),1.1)),3.8-littleArmsSign*1.4),1.)));//feet + little guy arms\n    \n        \n    //head \n    float bigEyeBlock = sdBox(rp-vec3(9.,47.,9.7*zSign), vec3(4.,6.,4.));\n    \n\tfloat bh = max( -min(bigEyeBlock, sdBox(rp-vec3(8.,44.,0.),vec3(3.1,2.,20.))),\n        \t\t\tlength(max(abs(rp-vec3(0.,50.,0.))-vec3(7.9,7.,10.),0.))-3.);//big guy face\n    \n    \n    bh = min(bh,\n                 sdTorus82( ( rp-vec3(9., 49., 9.7*zSign) ).yxz,vec2(2.4,1.)));//big guy 2 eyes\n    \n    vec3 teethLoc = mod(abs(rp-vec3(11.,42.,0.)), vec3(0.,0.,7.))-vec3(0.,0.,3.5);\n    teethLoc.y = rp.y-42.;//xy;\n    float teethZ = floor(abs(rp.z)/7.);\n    teethLoc.yz = rot(teethLoc.yz,teethZ*-.7);\n    \n    bh = min(bh, \n             max(sdBox(rp-vec3(9.,44.,0.), vec3(10., 10., 14.5)),\n                  (length(teethLoc*vec3(1., .5+max(0.,-teethLoc.y),1.))-(1.4+teethZ*.6))  ));//  , vec3(1.,1.5,1.), 1.) ));//teeth\n             \n    bh = min(bh,\n              max(sdBox(rp-vec3(9.,44.,0.), vec3(10., 10., 9.)),\n                  (length( (mod(abs(rp-vec3(11.,46.,3.5)), vec3(0.,0.,7.))-vec3(0.,0.,3.5))*vec3(1., .5+max(0.,rp.y-46.),1.) )-1.5))*.5);             \n    \n    d = min(d,bh);        \n        \n        \n    d = min(d,\n            max(-(rp.y-(68.)), sdTorus82((rp-vec3(0.,68.,0.)).yxz,vec2(5.,5.))));//rock hat\n    \n    \n    \n    //arms\n    vec3 armLoc = rp-vec3(-13.,20.,0.);\n        \n    armLoc.z = abs(armLoc.z);\n    armLoc.yz = rot(armLoc.yz,.1);\n    //float armAng = floor(armLoc.y/20.)*.1;\n    armLoc.y = mod(abs(armLoc.y+27.),18.)-9.; //mod(armLoc,vec3(7.,8.,30.));//-vec3(7.,8.,30.)/2.;\n    \n    //float armAng = floor(atan(armLoc.y,armLoc.z)*2.+iTime)*.6;\n    //armLoc.yz = rot(armLoc.yz,armAng);\n    \n    float ad = min(sdCapsule(armLoc,vec3(0.,4.,15.),vec3(0.,-3.,25.),5.),\n                   sdCapsule(armLoc,vec3(0.,-3.,25.),vec3(0.,-3.,35.),5.));\n    \n    //fingers\n    float fd = smin(sdCapsule(armLoc,vec3(3.,-2.,35.),vec3(6.,2.,42.), 1.5),\n                    sdCapsule(armLoc,vec3(6.,2.,42.),vec3(6.,1.,44.), 1.8),\n                   .7);\n    \n    armLoc.y = mod(abs(armLoc.y+2.6),10.)-5.;\n    fd = min(fd,\n             \n             smin(sdCapsule(armLoc,vec3(-2.,-2.,35.),vec3(-1.,-2.,42.), 1.1),\n                  sdCapsule(armLoc,vec3(-2.,-2.,42.),vec3(0.,-1.,44.), 1.2),\n                   .7));\n    \n    \n    d = min( max(sdBox(rp-vec3(0.,20.,0.),vec3(50.,44.,100.)),\n                 smin(ad,fd,2.4)) ,d);\n    \n    \n    \n    //little guy on head\n    \n    float eyeBlock = sdBox(rp-vec3(14.,61.5,3.7*zSign), vec3(2.,3.,1.6));\n    \n\tfloat lg = max( -min(eyeBlock, sdBox(rp-vec3(8.,59.,0.),vec3(20.,1.,20.))),\n        \t\t\troundBox((rp-vec3(6.,61.,0.)), vec3(8.,5.5,4.), 1.));//little guy face\n    \n    lg = max(-sdBox(rp-vec3(6.,61.5,4.8*zSign), vec3(6.,3.,.5)),\n                   lg);\n    \n    lg = min(lg,\n             max(eyeBlock,\n                 sdTorus82( ( ( mod(abs(rp-vec3(14., 1.3, 1.94)),vec3(0.,3.,3.6))-vec3(0.,1.5,1.8) ) ).yxz,vec2(1.,.3))));//little guys 4 eyes\n    \n    \n    d = min(d,lg);\n    \n    \n    \n    //cave\n    float cd = max( -sdBox(rp-vec3(30.,0.,0.),vec3(20.,36.,160.)),\n                   \trp.y-500. );\n    cd = max( -(length(rp)-140.),\n             cd );\n    \n    \n    d = min(d, cd);\n    \n    d = min(d, length(max(abs(rp-vec3(33.,-3.,0.))-vec3(13.,2.,200.), 0.)));\n    \n    \n    return d;\n}\n\nfloat df(in vec3 rp) {\n    return min(rock(rp), \n               min(lava(rp), \n                   min(gold(rp), fruit(rp))));\n}\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df(rp+ne)-df(rp-ne),\n                          df(rp+ne.yxz)-df(rp-ne.yxz),\n                          df(rp+ne.yzx)-df(rp-ne.yzx)));\n}\n\n\n#define lamb(l,n) max(dot(l,n),0.)\n\n\n\n//AMBIENT OCCLUSION\n\n#define AO_ITERATIONS 8\n#define AO_PRECISION 1.\n#define AO_INTENSITY 0.5\n#define AO_ATTEN 0.3\n\nfloat ao(in vec3 p, in vec3 norm) {\n\tfloat sum = 0.0;\n\tfloat atten = 1.0;\n\tfloat s = AO_PRECISION;\n    \n    float d;\n    \n\tfor (int i = 0; i < AO_ITERATIONS; i++) {\n        d = df(p+norm*s);\n        \n\t\tsum += (s-d)*atten;\t\t\n\t\ts += AO_PRECISION;\t\n\t\tatten *= AO_ATTEN;\n\t}\n\t\n\treturn 1.0-max(0.0,sum*AO_INTENSITY);\n}\n\n\n\n\nMat trace(inout vec3 rp, in vec3 rd) {\n        \n    float d;\n    for (int i = 0; i < TRACE_ITER; i++) { \n        if ((d = df(rp)) < EPSILON) break; \n       \n        rp += d*rd;\n    }\n    \n    Mat mat;\n    if(rock(rp) < EPSILON) {\n        \n        mat = Mat(vec3(.46, .4, .3),//diffuse color\n                  vec3(.4),//specular\n                  vec3(0.), //emissive\n                  0., //glossy specular strength\n                  0., //clear specular\n                  1. //roughness\n                  );\n        \n    } else if(lava(rp) < EPSILON) {\n\n        float vor = voronoi(rp.xz/100. + vec2(cos( cos(rp.x/4.) *2. + cos(rp.z/20.345)*9.),\n                                          \t\tcos(  cos(rp.z/4.) *2. +  cos(rp.x/20.235)*6.))*.03 );\n\n        float lavaAm = clamp(1.-pow(vor,3.)*2.-.2, 0., 1.);\n        float oneLavaAm = 1.-lavaAm;\n        mat = Mat(vec3(.46, .4, .3)*oneLavaAm,//diffuse color\n                  vec3(.4)*oneLavaAm,//specular\n                  mix(vec3(2.53, 1.76, .56)*.52, vec3(3., 1.76, .56)*.38, cos(length(cos(rp/12.)+cos(rp/3.)*.3)*10.)*.5+.5 )*lavaAm, //emissive\n                  0.6*oneLavaAm, //glossy specular strength\n                  0., //clear specular\n                  0.7*oneLavaAm //roughness\n                  );\n                \n    } else if (gold(rp) < EPSILON) {\n        \n        mat = Mat(vec3(2.55, 2.04, .40)*.4,//diffuse color\n                  vec3(2.55, 2.04, 1.)*.4,//specular\n                  vec3(0.), //emissive\n                  1.4, //glossy specular strength\n                  .7, //clear specular \n                  0.2 //roughness\n                  );\n        \n    } else if (fruit(rp) < EPSILON) {\n        \n        mat = Mat(vec3(2.23, .57, .25)*.4,//diffuse color\n                  vec3(1.,.9,.8),//specular\n                  vec3(2.23, .57, .25)*.2, //emissive\n                  2., //glossy specular strength\n                  .2, //clear specular \n                  0. //roughness\n                  );\n        \n    } else {\n        \n        mat = Mat(vec3(0.),//diffuse color\n                  vec3(0.),//specular\n                  vec3(0.), //emissive\n                  0., //specular strength\n                  0., //clear specular\n                  0. //roughness\n                  );\n    \n    }\n                  \n    return mat;\n}\n\nvec3 hemiray(in vec3 n, in vec3 rp, float fi) {\n    //vec3 rpfi = rp*fi;\n    vec3 rpfi = cos(rp*fi*4.435643)*124.324556798;\n    vec3 rd = normalize(vec3( cos(rpfi.x*rpfi.y),\n                              cos(rpfi.y*rpfi.z),\n                              cos(rpfi.z*rpfi.x) ));\n        \n    return rd*sign(dot(n,rd));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef PATH_TRACE\n        \n    if (floor(fragCoord.y) != floor(mod(iTime*LINES_PER_SECOND,(iResolution.y+LINES_PER_SECOND*SLIDE_WAIT)))) discard;\n    \n    #endif\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n\n    \n    vec3 rp,rd;\n    \n    rd = vec3(1.,0.,0.);\n    vec3 rr = cross(vec3(0.,1.,0.),rd);\n    rd = normalize(rd + uv.x*FOV_SCALE_X*rr + uv.y*FOV_SCALE_Y*cross(rd,rr));\n\n    CameraView view;\n    #ifdef CUSTOM_VIEW\n\tview = CUSTOM_VIEW;\n    #else\n    view = currentView();    \n    #endif\n    \n    rp = view.location;\n    rd.xy = rot(rd.xy,view.rotation.y);\n    rd.xz = rot(rd.xz,view.rotation.x);\n    \n    \n    \n    \n    Mat m = trace(rp,rd);\n    \n    \n    #ifdef PATH_TRACE\n    \n    vec3 c = m.emissive*float(PATHS)*EMISSIVE_SCALE;\n    vec3 n = normal(rp);\n    vec3 startLoc = rp+n*EPSILON;\n    \n    vec3 reflDir = reflect(rd,n);\n    rd = reflDir;\n    \n    float trig = 1.;//clear reflection indicator\n    for (int i = 0; i < PATHS; i++) {\n\t\t//rd = hemiray_reflect(n,rp,rd,m.roughness,float(i));\n        rp = startLoc;\n        Mat rm = trace(rp,rd);\n        \n        float trigPath = max(0.,trig*float(PATHS)*SPECULAR_SCALE);\n        float notTrigPath = max(0.,-trig);\n        \n        float fres = clamp(dot(reflDir,rd)+m.roughness, 0., 1.);\n        vec3 emSpec1 = rm.emissive*m.specular;\n        c += rm.emissive*m.color*notTrigPath+ //first hit diffuse lit by second hit\n             emSpec1*m.glossySpecular*fres*notTrigPath+ //first hit rough specular reflecting second hit emission\n             emSpec1*m.clearSpecular*trigPath; //first hit clear specular reflecting second hit emissive\n        \n        vec3 n2 = normal(rp);\n        vec3 startLoc2 = rp+n2*EPSILON;\n        float trig2 = 1.;\n        rd = reflect(rd,n2);\n        for (int i2 = 0; i2 < SUB_PATHS; i2++) {\n            //rd = hemiray_reflect(n2,rp,rd,m.roughness,float(i*PATHS)+float(i2));\n            \n            Mat rm2 = trace(rp,rd);\n            \n            float trig2Path = max(0.,trig2*float(PATHS)*SPECULAR_SCALE);\n            float notTrig2Path = max(0.,-trig)*notTrigPath;\n            \n            vec3 emColor = rm2.emissive*rm.color;\n            vec3 emSpec2 = m.color*rm2.emissive*rm.specular;\n            vec3 emSpec22 = emColor*m.specular;\n            c += emColor*m.color*notTrig2Path+\n                 emSpec2*rm.glossySpecular*notTrig2Path*clamp(dot(reflDir,rd)+rm.roughness , 0., 1. )+\n                 emSpec2*rm.clearSpecular*trig2Path+ \n                emSpec22*rm.glossySpecular*fres*notTrig2Path+\n                emSpec22*rm.clearSpecular*trig2Path;\n           \n            \n            //rd = hemiray(normal(rp),rp,float(i));\n            rd = reflect(rd,normal(rp));\n            Mat rm3 = trace(rp,rd);\n            \n            vec3 ec2 = rm3.emissive*rm2.color;\n            vec3 rmc = rm.color*m.color;\n            c += ec2*rmc*notTrig2Path+\n                 rmc*rm3.emissive*rm2.specular*rm2.glossySpecular*notTrig2Path /** max(0.,(dot(reflDir,rd)-(1.-rm.roughness)))*/ +\n                 ec2*rm.color*m.specular*rm2.glossySpecular*notTrig2Path*fres;\n            \n            if (trig2 > 0.) {\n                trig2 = -1.;\n            } else {\n                rd = hemiray(n2,rp,float(i*PATHS)+float(i2));\n                rp = startLoc2;\n            }\n\n            \n            //vec3 ec = rm2.emissive*rm.color;\n            //c += (ec*m.color) + (ec*rm.specular);\n            /*vec3 startLoc2 = rp;\n            vec3 n2 = normal(rp);\n            for (int i2 = 0; i2 < PATHS; i2++) {\n                rd = hemiray(n2,float(i*PATHS)+float(i2));\n                rp = startLoc2;\n\n                Mat rm2 = trace(rp,rd);\n\n            }*/\n        }\n        \n        if (trig > 0.) {\n            trig = -1.;\n        } else {\n        \trd = hemiray(n,rp,float(i));\n        }\n    }\n    \n    \n    fragColor = vec4(\n                      pow(c*(1./float(PATHS))*OUTPUT_SCALE, GAMMA)\n                          ,1.);\n    \n    #else\n    \n    vec3 c = m.color;\n        \n    vec3 n = normal(rp);\n    rp += n*.02;\n    c = max(0.,.2*ao(rp,n) + \n          max(0.,dot(lightDir,n)))*c;\n    \n    c += pow(max(0.,dot(reflect(rd,n),lightDir)), (1.-m.roughness)*32.+1.)*(m.clearSpecular+m.glossySpecular)*m.specular;\n    \n    c += m.emissive;\n    \n    fragColor = vec4(c,1.);\n    \n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}