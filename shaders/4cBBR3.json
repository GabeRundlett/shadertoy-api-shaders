{
    "Shader": {
        "info": {
            "date": "1725685973",
            "description": "fusion simulator",
            "flags": 48,
            "hasliked": 0,
            "id": "4cBBR3",
            "likes": 7,
            "name": "MagneticContainment",
            "published": 3,
            "tags": [
                "fusionsimulator"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 116
        },
        "renderpass": [
            {
                "code": "/* keyboard commands ==============================\n\n<Spc>    : Reset Flux\n<Q>,<W>  : adjust Magnet strength\n<A>,<S>  : adjust speed of injected ions\n<Z>,<X>  : adjust ion strength\n\n ================================================= */\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    ivec2 I = ivec2(U);\n    vec4 backgroundPixel = texelFetch(iChannel1,I,0);\n    \n    if(backgroundPixel.w > 0.) { \n        O = backgroundPixel;\n        \n        // magnet wires colored according to nearby flux strength ----------\n        if(length(O.xyz - GOLD_COLOR) < 0.5) {\n            vec2 center = iResolution.xy * 0.5;\n            \n            // average flux level in front of magnet\n            float total = 0.;\n            for(float ratio = 0.5;ratio < 0.9;ratio += 0.1) {\n                vec2 fPixel = center + (U - center) * ratio;\n                vec2 fGrid = fPixel / iResolution.xy;  // 0 ... 1\n                ivec2 G = ivec2(int(float(GRIDX) * fGrid.x),int(float(GRIDY) * fGrid.y));\n                vec4 fluxCell = texelFetch(iChannel0,G,0);\n                if(fluxCell.z > 0.3)\n                    total += fluxCell.z;\n            }\n            O.xyz = jetColorMap(total * 0.2);\n        }\n        \n        // grey wires ----------\n        if(length(O.xyz - SILVER_COLOR) < 0.5) O += sin(iTime * 0.7) * 0.2;\n    }\n    else {  // flux\n        vec2 U2 = U / iResolution.xy;  // 0 ... 1\n        ivec2 G = ivec2(int(float(GRIDX) * U2.x),int(float(GRIDY) * U2.y));\n        vec4 fluxCell = texelFetch(iChannel0,G,0);\n        \n        O.xyz = jetColorMap(1. - sin(fluxCell.z * PI));        \n    }\n    \n/* debug display of magnets and ions\n    getSettings(iChannel0);\n    for(int i=MAGNETCOUNT-3;i<MAGNETCOUNT;++i) \n        drawCircle(magnet[i].xy,10.,vec3(1.),O,U);\n    for(int i=0;i<IONCOUNT;++i) \n        drawCircle(ion[i].xy,5.,vec3(1.,1.,0.),O,U);\n*/\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void initializeIons(inout vec4 O, vec2 U) {\n    vec2 center = iResolution.xy * 0.5;\n    float angle = 0.;\n    float deltaAngle = PI2 / float(MAGNETCOUNT-3);\n    int index = 0;\n    \n    for(int i=0;i<MAGNETCOUNT-3;++i) {\n        magnet[index].x = center.x + cos(angle) * center.x * 0.85; // position\n        magnet[index].y = center.y + sin(angle) * center.y * 0.85;\n        magnet[index].z = settings[0].x; // strength\n        angle += deltaAngle;\n        ++index;\n    }\n   \n    for(int i=0;i<3;++i) {\n        magnet[index].x = center.x * 0.7 + float(i) * center.x * 0.3;\n        magnet[index].y = center.y;\n        magnet[index].z = settings[0].x * 3.;\n        magnet[index].w = float(i) * 2.; // movement angle\n        ++index;\n    }\n    \n    for(int i=0;i<IONCOUNT;++i) {\n    \n        // start all ions 'off sceen' so they are injected\n    \n        ion[i].x = -200.; // center.x - random(U) * 30.;\n        ion[i].y = center.y - 50. + float(i) * 10. + random(U) * 10.;\n        ion[i].z = settings[0].y  + random(U) * 0.1;\n        ion[i].w = 0.;\n    }\n    \n    saveSettings(O,U);\n}\n\n\nvoid initialize(inout vec4 O, vec2 U) {\n    ivec2 I = ivec2(U);    \n    if(I.x >= GRIDX || I.y > GRIDY) return;\n\n    settings[0].x = 10.;   // magnet strength\n    settings[0].y = 0.0006; // ion X velocity\n    settings[0].z = 8.;  // ion strength\n    settings[0].w = 1.;   // boolean: was a setting changed?\n    \n    initializeIons(O,U);\n}\n\n// ----------------------------------------------------------\n\nvoid updateFlux(inout vec4 O, vec2 U) {\n    if(U.x >= float(GRIDX) || U.y >= float(GRIDY)) return;    \n\n    vec2 G = vec2(iResolution.x * U.x / float(GRIDX), iResolution.y * U.y / float(GRIDY));\n    \n    O.z = 0.;\n    \n    for(int i=0;i<IONCOUNT;++i) {\n        vec2 delta = G - ion[i].xy;\n        float len = length(delta);   // * 0.13;\n        if(len > 0.) {\n            float amount = settings[0].z / len;  // ion strength\n            if(O.z + amount < 1.0)\n                O.z += amount;\n            else break;\n        }\n    }\n}\n\n// ----------------------------------------------------------\n\nvoid updateIons(inout vec4 O, ivec2 I) {\n    int index = I.x - MAGNETCOUNT;\n    \n    if(index >= 0 && index < IONCOUNT) {        \n        for(int m=0;m<MAGNETCOUNT;++m) {\n            vec2 dd = ion[index].xy - magnet[m].xy; \n            float rs = dd.x * dd.x + dd.y * dd.y;\n\n            if(rs > 0.) {\n                float v = (magnet[m].z / rs) / sqrt(rs);\n                ion[index].zw += v * dd;      // update delta x,y\n                \n                const float maxDelta = 0.2;\n                ion[index].z = clamp(ion[index].z,-maxDelta,maxDelta);\n                ion[index].w = clamp(ion[index].w,-maxDelta,maxDelta);\n                \n                ion[index].xy += ion[index].zw; // update position\n                \n                // off screen?\n                if(ion[index].x < 0. || ion[index].x > iResolution.x ||\n                   ion[index].y < 0. || ion[index].y > iResolution.y) {\n                   ion[index].xy = vec2(iResolution.x * 0.1,iResolution.y * 0.5);\n                   ion[index].zw = vec2(settings[0].y + random(O.xy) * 0.3, 0.);\n                   break;\n                }\n            }\n        }\n    }\n\n    // center 3 magnets are moving\n    if(I.x < MAGNETCOUNT) {\n        float x1 = iResolution.x * 0.3;\n        float x2 = iResolution.x * 0.7;\n        float y1 = iResolution.y * 0.4;\n        float y2 = iResolution.y * 0.6;\n        const float speed = 2.;\n        for(int i=MAGNETCOUNT-3;i<MAGNETCOUNT;++i) {\n            magnet[i].xy += vec2(cos(magnet[i].w) * speed,sin(magnet[i].w) * speed);\n            if(magnet[i].x < x1) { magnet[i].x = x1; magnet[i].w += 1.57; }\n            if(magnet[i].x > x2) { magnet[i].x = x2; magnet[i].w += 1.57; }\n            if(magnet[i].y < y1) { magnet[i].y = y1; magnet[i].w += 1.57; }\n            if(magnet[i].y > y2) { magnet[i].y = y2; magnet[i].w += 1.57; }\n        } \n    }    \n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    getSettings(iChannel0);\n    \n    if(iFrame < 1) {\n        initialize(O,U);\n        return;\n    }\n    if(keyClick(32,iChannel3)) {\n        initializeIons(O,U);\n        return;\n    }\n    \n    ivec2 I = ivec2(U);        \n    O = texelFetch(iChannel0,I,0);\n    vec4 old = settings[0];\n    if(getKeyState(81,iChannel3)) settings[0].x = clamp(settings[0].x - 2.,MIN_MAGNET,MAX_MAGNET); // Q\n    if(getKeyState(87,iChannel3)) settings[0].x = clamp(settings[0].x + 2.,MIN_MAGNET,MAX_MAGNET); // W\n    if(getKeyState(65,iChannel3)) settings[0].y = clamp(settings[0].y - 0.002,MIN_VELOCITY,MAX_VELOCITY); // A\n    if(getKeyState(83,iChannel3)) settings[0].y = clamp(settings[0].y + 0.002,MIN_VELOCITY,MAX_VELOCITY); // S\n    if(getKeyState(90,iChannel3)) settings[0].z = clamp(settings[0].z - 0.1,MIN_STRENGTH,MAX_STRENGTH); // Z\n    if(getKeyState(88,iChannel3)) settings[0].z = clamp(settings[0].z + 0.1,MIN_STRENGTH,MAX_STRENGTH); // X\n    settings[0].w = (old != settings[0]) ? 1. : 0.;\n    \n    updateIons(O,I);\n    updateFlux(O,U);\n    saveSettings(O,U);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GRIDX  250 // cell grid size\n#define GRIDY  (GRIDX * 720 / 1280)\nconst int MAGNETCOUNT = 41; \nconst int IONCOUNT = 32;\nconst int SETTINGSCOUNT = 1;\nconst float MIN_MAGNET = 1.;\nconst float MAX_MAGNET = 100.;\nconst float MIN_VELOCITY = 0.0002;\nconst float MAX_VELOCITY = 0.2;\nconst float MIN_STRENGTH = 0.5;\nconst float MAX_STRENGTH = 10.;\n\nconst float PI = acos(-1.);\nconst float PI2 = PI * 2.;\n\nconst vec3 GOLD_COLOR = vec3(255./255.,215./255.,0./255.) * 0.6;\nconst vec3 SILVER_COLOR = vec3(113./255.,121./255.,126./255.) * 1.5;\nconst vec3 BRASS_COLOR = vec3(225./255.,193./255.,110./255.);\nconst vec3 RED_COLOR = vec3(1.,0.,0.);\n\nvec4 magnet[MAGNETCOUNT];\nvec4 ion[IONCOUNT];\nvec4 settings[SETTINGSCOUNT];\n\n// ----------------------------------------------------------\n\nvoid getSettings(sampler2D channel) { \n    ivec2 addr = ivec2(0,GRIDY);\n    \n    for(int i=0;i<MAGNETCOUNT;++i) {\n        magnet[i] = texelFetch(channel,addr,0);\n        ++addr.x;\n    }\n    for(int i=0;i<IONCOUNT;++i) {\n        ion[i] = texelFetch(channel,addr,0);\n        ++addr.x;\n    }\n    for(int i=0;i<SETTINGSCOUNT;++i) {\n        settings[i] = texelFetch(channel,addr,0);\n        ++addr.x;\n    }\n}\n\nvoid saveSettings(inout vec4 O, in vec2 U) {\n    ivec2 I = ivec2(U);\n    ivec2 addr = ivec2(0,GRIDY);\n\n    for(int i=0;i<MAGNETCOUNT;++i) {\n        if(addr == I) {\n            O = magnet[i];\n            return;\n        }\n        \n        ++addr.x;\n    }\n    \n    for(int i=0;i<IONCOUNT;++i) {\n        if(addr == I) {\n            O = ion[i];\n            return;\n        }\n        \n        ++addr.x;\n    }\n\n    for(int i=0;i<SETTINGSCOUNT;++i) {\n        if(addr == I) {\n            O = settings[i];\n            return;\n        }\n        \n        ++addr.x;\n    }\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n    return (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n   \nbool getKeyClick(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n\n// ----------------------------------------------------------\n\nvec3 jetColorMap(float t) { // 0 ... 1\n //   t = pow(t,2.6);\n // if(t > 0.9) t = 1. - t * 0.1; //return vec3(t);\n    return clamp(vec3(1.5) - abs(4.0 * vec3(t) + vec3(-3., -2., -1.)), vec3(0.), vec3(1.));\n}\n\n// ----------------------------------------------------------\n// https://www.shadertoy.com/view/MtfGWM\n\nfloat random(vec2 c) { return fract(sin(dot(vec2(1.317 - c.x,19.753 + c.y),c))*413.7972); } // 0...1\n\n// ----------------------------------------------------------\n    \nvoid rectangle(float x1,float y1,float xs,float ys,vec3 color, inout vec4 O, vec2 U) {\n    float x2 = x1 + xs, y2 = y1 + ys;\n    if(U.x >= x1 && U.x < x2 && U.y >= y1 && U.y < y2)\n        O = vec4(color,0.6);\n}\n\n// ----------------------------------------------------------\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n\n    vec2 ae = pt-lineP1;\n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid drawLine(vec2 p1,vec2 p2, float width, vec3 color,inout vec4 O,vec2 U) {\n    float d = ptLineDistance(U,p1,p2);\n    \n    if(d < width) {\n        float d2 = ptLineDistance(U - vec2(-width * 0.5,width * 0.5),p1,p2);\n        O.xyz = color - vec3(d2 / (width * 2.5));\n        O.w = 1.;\n    }\n    if(abs(d - width)< 1.) O = vec4(0.,0.,0.,1.);\n}\n\nvoid fluxLine(vec2 p1,vec2 p2, float width, inout vec4 O,vec2 U) {\n    float d = ptLineDistance(U,p1,p2);\n\n    if(d < width) {\n        float d2 = ptLineDistance(U - vec2(-width * 0.5,width * 0.5),p1,p2);\n        O = vec4(0.);\n    }\n}\n\n// ----------------------------------------------------------\n\nvoid drawCircle(vec2 pt, float radius, vec3 color,inout vec4 O,vec2 U) {\n    float d = length(U-pt);\n    if(d < radius) {\n        float d2 = length(U - vec2(-radius * 0.3,radius * 0.3) - pt);\n        O.xyz = color - vec3(d2 / (radius * 3.5));\n        O.w = 1.; // mark as populated pixel\n    }\n    if(abs(d - radius) < 0.5) O = vec4(0.,0.,0.,1.);\n}\n\nvoid drawCircle2(vec2 pt, float radius, float thickness, vec3 color,inout vec4 O,vec2 U) {\n    float d = length(U-pt);\n    if(abs(d - radius) < thickness) O = vec4(0.,0.,0.,1.);\n    if(abs(d - radius) < thickness*0.6) O = vec4(color,1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 pCenter,pt,p1,p2,center;\nfloat width,thick,angle;\nvec3 color;\n\nvec2 rotatePoint(vec2 p) {\n    vec2 delta = pCenter - p;\n    float dist = length(delta);\n    float a = atan(delta.y,delta.x) + angle; \n    return pCenter + vec2(cos(a)*dist,sin(a)*dist);\n}\n\nvoid rotLine(inout vec4 O, vec2 U) {\n    drawLine(rotatePoint(p1),rotatePoint(p2),thick,color,O,U);\n}\n\n// -------------------------------------------\n\nvoid drawMagnet(vec2 pc,float ang,inout vec4 O, vec2 U) {\n    width = iResolution.x * 0.04;\n    thick = 5.; //iResolution.x * 0.02;\n    float t2 = thick * 1.5;\n    \n    pCenter = pc;\n    pt = pCenter - vec2(0.,t2 * 3.);\n    angle = ang;\n    p1 = pt + vec2(-width * 0.5,0.);\n    p2 = p1 + vec2(width,0.);\n    color = GOLD_COLOR;    \n    \n    for(int i=0;i<9;++i) {\n        rotLine(O,U);\n        p1.y += t2;\n        p2.y += t2;\n    }    \n    vec2 p3 = p1;\n    \n    p1 = pt + vec2(-width * 0.3,t2);\n    p2 = p1 + vec2(0.,t2*30.);\n    thick = 3.;\n    color = RED_COLOR;\n    rotLine(O,U);\n    p1 = pt + vec2(width * 0.3,t2);\n    p2 = p1 + vec2(0.,t2*30.);\n    rotLine(O,U);\n\n    width *= 1.3;\n    thick *= 1.2;\n    color = SILVER_COLOR;\n    p1 = pt + vec2(-width * 0.5,t2);\n    p2 = p1 + vec2(width,0.);\n    rotLine(O,U);\n    p1 += vec2(0,t2*8.);\n    p2 = p1 + vec2(width,0.);\n    rotLine(O,U);\n\n    //drawCircle(pCenter,5.,vec3(1.),O,U);\n}\n\n// -------------------------------------------\n\nvoid drawRing(float dist,inout vec4 O, vec2 U) {\n    float rx = center.x * dist;\n    float ry = center.y * dist;\n    vec2 lastPt;\n\n    for(int i=0;i<=24;++i) {\n        float a = float(i) * PI2 / 24.;\n        lastPt = pt;\n        pt = vec2(center + vec2(cos(a) * rx,sin(a) * ry));\n        if(i > 0)\n            drawLine(lastPt,pt,10.,SILVER_COLOR,O,U);\n    }\n}\n\n// -------------------------------------------\n\nvoid barChart(vec2 pt1,float value,float vMin,float vMax,inout vec4 O, vec2 U) {\n    float width = iResolution.x * 0.1;\n    vec2 pt2 = pt1 + vec2(width,0.);\n    drawLine(pt1,pt2,5.,vec3(0.,1.,0.),O,U);\n\n    float ratio = clamp((value - vMin)/(vMax-vMin),0.001,1.);\n    pt2 = pt1 + vec2(width * ratio,0.);\n    drawLine(pt1,pt2,5.,vec3(1.,0.,0.),O,U);\n}\n\nvoid drawBarCharts(inout vec4 O, vec2 U) {\n    rectangle(7.,5.,iResolution.x * 0.13,50.,vec3(0.5),O,U);\n    barChart(vec2(20.,45.),settings[0].x,MIN_MAGNET,MAX_MAGNET,O,U);\n    barChart(vec2(20.,30.),settings[0].y,MIN_VELOCITY,MAX_VELOCITY,O,U);\n    barChart(vec2(20.,15.),settings[0].z,MIN_STRENGTH,MAX_STRENGTH,O,U);\n}\n\n// -------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 U) {\n    O = texelFetch(iChannel1,ivec2(U),0);\n    if(iFrame == 0) {\n        O = vec4(0.);\n        \n        // solid gray coloring of screen edges\n        center = iResolution.xy * 0.5;\n        vec2 delta = U - center;\n        angle = atan(delta.y,delta.x);\n        vec2 oval = vec2(cos(angle)*center.x * .97, sin(angle)*center.y * .9);\n        float ovalDist = length(oval);\n        float dist = length(delta);    \n        if(dist >= ovalDist)\n            O = vec4(0.6);\n        if(abs(dist - ovalDist) < 1.)\n            O = vec4(0.,0.,0.,1.);\n\n        // rings of wires surround flux chamber\n        for(float dd = 0.9;dd < 1.2; dd += 0.09)\n            drawRing(dd,O,U);\n\n        // ring of magnets  surround flux chamber\n        float rx = center.x * 0.9;\n        float ry = center.y * 0.9;    \n        for(int i=0;i<24;++i) {\n            float a = float(i) * PI2 / 24.;\n            drawMagnet(center + vec2(cos(a) * rx,sin(a) * ry),a + PI * 0.5,O,U);\n        }\n\n        // ion injection tube\n        p1 = vec2(0.,center.y);\n        p2 = p1 + vec2(center.x * 0.25,0.);    \n        fluxLine(p1,p2,10.,O,U);\n        p1 = vec2(0.,center.y * 0.95);\n        p2 = p1 + vec2(center.x * 0.25,0.);    \n        drawLine(p1,p2,5.,SILVER_COLOR,O,U);\n        p1.y += center.y * 0.1;\n        p2.y = p1.y;\n        drawLine(p1,p2,5.,SILVER_COLOR,O,U);\n\n        drawBarCharts(O,U);\n    }\n    \n    // update barcharts if settings were changed\n    getSettings(iChannel0);\n    if(settings[0].w > 0.)\n        drawBarCharts(O,U);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}