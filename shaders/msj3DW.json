{
    "Shader": {
        "info": {
            "date": "1697354170",
            "description": "For testing cubic equation solvers. Image is the Euclidean plane, showing solver accuracy at each point (see header for coordinate to equation conversion). Use mouse to select point for numeric display.",
            "flags": 16,
            "hasliked": 0,
            "id": "msj3DW",
            "likes": 10,
            "name": "Cubic Solver Test",
            "published": 3,
            "tags": [
                "solver",
                "cubic",
                "equation"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////\n//\n// Cubic Solver Test, mla 2023\n//\n// Testing some solvers for depressed cubics: x³+px+q = 0\n// \n// Implements several versions of the usual analytic solver, also \n// for comparison Kahan's semi-iterative solver, which produces pretty \n// good results across the board. dcubic1 is a fairly standard trigonometric\n// solver. dcubic2 and dcubic3 use a complex cube root operation that\n// can be refined with Newton-Raphson to reduce errors from trig functions.\n// nrcubic is the solver from Numerical Recipes.\n//\n// Shader shows complex plane/ℝ² under (inverse of) map z -> z/(1-z²),\n// that maps the entire plane to the unit disc. Color indicates accuracy\n// of solution, red most accurate, magenta least.\n//\n// For position pos = (x,y), roots are a, b±√c, where a = x, c = y.\n// For depressed cubics, sum of roots = 0, so b = -a/2.\n// If y < 0 then only one real root, else three real roots (maybe coincident).\n\n// Numeric solution shown for mouse selection (x,y) if in the image:\n// p q\n// error\n// input roots 1-3\n// found roots 1-3\n// \n// 'c': don't refine complex cube root in dcubic2 & dcubic3\n// 'k': use semi-iterative Kahan solver\n// 'p': polish final roots with one round of Newton-Raphson\n// 's': scale projection\n// 't': no projection\n// 'z': zoom in\n//\n//////////////////////////////////////////////////////////////////////\n\n//#define DCUBIC dcubic1\n#define DCUBIC dcubic2\n//#define DCUBIC dcubic3\n//#define DCUBIC nrcubic\n\n// A proper sign function that returns 1 for sign(0) (even -0)\nfloat sgn(float x) {\n  if (x < 0.0) return -1.0;\n  else return 1.0;\n}\n\nvec2 ccuberoot(vec2 z) {\n  // Complex cube root. \n  float r = length(z);\n  z /= r;\n  float t = carg(z)/3.0;\n  vec2 u = vec2(cos(t),sin(t));\n  if (!key(CHAR_C)) {\n    // Newton-Raphson refinement\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return cuberoot(r)*u;\n}\n\n// cuberoots of 1.\nconst vec2 omega = 0.5*vec2(-1,sqrt(3.0));\nconst vec2 omega2 = omega*vec2(1,-1);\n\n// Standard depressed cubic solver. This works OK, but\n// GPU trig functions often aren't all that accurate which\n// can cause problems.\nint dcubic1(float p, float q, out vec3 roots) {\n  p /= 3.0;\n  float h = q*q + 4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = -0.5*(q+sgn(q)*r); // Largest root of quadratic\n    float t = cuberoot(u);\n    roots[0] = t - p/t;\n    return 1;\n  } else {\n    float theta = atan(r,-q); // 0 <= theta < PI\n    float k = 2.0*sqrt(abs(p));\n    roots = k*cos((theta+PI*vec3(0,-2,2))/3.0);\n    // And we return them in order\n    assert(roots[0] >= roots[1]);\n    assert(roots[1] >= roots[2]);\n    return 3;\n  }\n}\n\n// Annotated and with a different way of doing the multiple roots\n// case (uses Newton-Raphson to get more accurate complex cube root).\nint dcubic2(float p, float q, out vec3 roots) {\n  // Divide p immediately by 3 to make life easier later\n  p /= 3.0;\n  // Now we are solving x³+3px+q = 0\n  // Put x = u+v and get x³ = u³+v³+3xuv\n  // Substitute in original equation and get:\n  // u³+v³+3(uv+p)x + q = 0\n  // Now we seek u,v such that uv+p = 0, so then:\n  // uv = -p ie. u³v³ = -p³ and u³+v³ = -q\n  // This gives a quadratic equation with roots u,v:\n  // t²+qt-p³ = 0\n  // Discriminant is h = q²+4p³\n  float h = q*q+4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = 0.5*(-q-sgn(q)*r); // Largest root\n    float t = cuberoot(u);\n    roots[0] = t - p/t;\n    return 1;\n  } else {\n    // Again we have v = -p/u = -pu'/|u|² where u' is conjugate of u\n    // So given u³ = 0.5(-q ± sqrt(-(q²+4p³))i) = 0.5*(-q ± ri)\n    // |u³|² = |u|²³ = 0.25(q²-q²-4p³) = -p³\n    // So |u|² = -p, so v = u' and u = √|p|(cos θ + i sin θ) with θ = atan(±r,-q)/3\n    // Since u,v are complex conjugates their sum is just twice their\n    // real parts, and using polar coordinates, Re(r,θ) = r cos θ\n    float k = sqrt(abs(p));\n    float theta = atan(r,-q)/3.0;\n    vec2 z = vec2(cos(theta),sin(theta));\n    if (!key(CHAR_C)) {\n      // Newton-Raphson to refine the complex cube root.\n      // This will compensate nicely for any trig inaccuracy.\n      // Want z³-t = 0, and |t| = 1\n      vec2 t = vec2(-q,r)/(2.0*k*k*k);\n      vec2 z2 = cmul(z,z);\n      z -= cdiv(cmul(z,z2)-t,3.0*z2);\n    }\n    float x0 = z.x, x2 = rmul(z,omega), x1 = -x0-x2;\n    // Note that roots add up to 0 for reduced cubic.\n    roots = 2.0*k*vec3(x0,x1,x2); // Just want the real parts here\n    // Check the roots are in order\n    assert(roots[0] >= roots[1]);\n    assert(roots[1] >= roots[2]);\n    return 3;\n  }\n}\n\n// Super simple solution, just to illustrate the idea.\n// Actually, this one produces pretty good results, though since\n// it's more complex arithmetic, it might be a little slower\nint dcubic3(float p, float q, out vec3 roots) {\n  p /= 3.0;\n  float B = q, C = -p*p*p;\n  float D = B*B-4.0*C;\n  if (D > 0.0) {\n    // The 2 complex cube roots don't lead to real solutions\n    float u = cuberoot(0.5*(-B-sgn(B)*sqrt(D)));\n    roots[0] = u-p/u;\n    return 1;\n  } else {\n   // But here, 3 complex cube roots all lead to real solutions\n    vec2 u0 = ccuberoot(0.5*vec2(-B,sqrt(-D)));\n    vec2 u1 = cmul(omega,u0);\n    vec2 u2 = cmul(omega2,u0);\n    roots.x = (u0-p*cinv(u0)).x;\n    roots.y = (u1-p*cinv(u1)).x;\n    roots.z = (u2-p*cinv(u2)).x;\n    if (roots.y < roots.z) roots.yz = roots.zy;\n    return 3;\n  }\n}\n\n// Numerical Recipes algorithm for solving cubic equations.\n// Single root is OK, but upper half vulnerable to\n// trig inaccuracies.\nint nrcubic(float p, float q, out vec3 x) {\n  float b = p, c = q;\n  // solve x^3 + bx + c = 0\n  float Q = -b/3.0;\n  float R = 0.5*c;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = R/sqrt(Q3);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    x[0] = -2.0*S*cos(theta/3.0);\n    x[1] = -2.0*S*cos((theta+2.0*PI)/3.0);\n    x[2] = -2.0*S*cos((theta+4.0*PI)/3.0);\n    return 3;\n  } else {\n    float A = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),1.0/3.0);\n    float B = A == 0.0 ? 0.0 : Q/A;\n    x[0] = A+B;\n    return 1;\n  }\n}\n\nfloat cbrt(float x) {\n  return sign(x)*pow(abs(x),1.0/3.0);\n}\n\n// The Kahan cubic algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint kahansolve(float C, float D, out vec3 res) {\n  float A = 1.0, B = 0.0;\n  float X,b1,c2;\n  //assert(abs(D) > 1e-6);\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      // 5 iterations does the job\n      for (int i = 0; i < 5; i++) {\n        X = x0;\n        // We only need b1,c2 at the end for deflation\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        x0 -= (q/dq);\n      }\n      eval(X,A,B,C,D,q,dq,b1,c2); // Get c1, c2\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\nfloat error(float x, float y) {\n  return abs(x-y)/(abs(x)+abs(y));\n}\n\nvec3 sort(vec3 a) {\n  if (a.y > a.x) a.xy = a.yx;\n  if (a.z > a.y) a.yz = a.zy;\n  if (a.y > a.x) a.xy = a.yx;\n  return a;\n}\n\nfloat polish(float x, float p, float q) {\n  // A single round should be enough\n  for (int i = 0; i < 1; i++) {\n    float x2 = x*x;\n    float t = x2+p;\n    x -= (x*t+q)/(t+2.0*x2);\n  }\n  return x;\n}\n\nint dcubic(float p, float q, out vec3 roots) {\n  if (key(CHAR_K)) return kahansolve(p,q,roots);\n  return DCUBIC(p,q,roots);\n}\n\nint getdata(vec2 pos, out vec2 coeffs, out vec3 inroots, out vec3 roots, out float err) {\n  if (pos == vec2(0)) {\n    // An exact triple root generates NaN\n    roots = vec3(0), err = 0.0; coeffs = vec2(0);\n    return 3;\n  }\n  float a = pos.x;\n  float b = -0.5*a;\n  float c = pos.y;\n  coeffs = vec2(2.0*a*b+b*b-c, -a*(b*b-c));\n  float p = coeffs.x, q = coeffs.y;\n  int nroots = dcubic(p,q,roots);\n  assert(nroots == 1+2*int(c >= 0.0)); // This can happen, what to do?\n  for (int i = 0; i < nroots; i++) {\n    if (key(CHAR_P)) roots[i] = polish(roots[i],p,q);\n    assert(!isnan(roots[i]));\n  }\n  err = 0.0;\n  if (nroots == 1) {\n    err = error(a,roots[0]);\n    inroots.x = a;\n  } else {\n    vec3 test = vec3(a,b-sqrt(c),b+sqrt(c));\n    test = sort(test);\n    inroots = test;\n    roots = sort(roots);\n    err = max(err,error(test[0],roots[0]));\n    err = max(err,error(test[1],roots[1]));\n    err = max(err,error(test[2],roots[2]));\n  }\n  return nroots;\n}\n\nbool gethudval(int row, int col, vec2 pos, out float x) {\n  vec2 coeffs; vec3 inroots, roots; float err;\n  int nroots = getdata(pos,coeffs,inroots,roots,err);\n  if (row == 0) {\n    if (col == 0) { x = coeffs[0]; return true; }\n    if (col == 1) { x = coeffs[1]; return true; }\n  }\n  if (row == 1) {\n    if (col == 0) { x = err; return true; }\n  }\n  for (int i = 0; i < nroots; i++) {\n    if (col == i && row == 2) { x = inroots[nroots-1-i]; return true; }\n    if (col == i && row == 3) { x = roots[nroots-1-i]; return true; }\n  }\n  return false;\n}\n\nfloat hud(vec2 fragCoord, vec2 pos) {\n  const int digits = 7, nrows = 15, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  int column = cellindex.x;\n  int row = nrows-cellindex.y-1; // Reverse order of rows\n  float x;\n  if (!gethudval(row,column,pos,x)) return 0.0;\n  \n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  float uvscale = 0.5/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = printfloat(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c > 0) {\n    float charstart = charwidth*float(charpos); // character start\n    uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  }\n  vec4 t = textureGrad(iChannel0,uv,dx,dy);\n  if (c > 0) return t.x;\n  return 0.0;  \n}\n\n\nbool map(inout vec2 z) {\n  if (!key(CHAR_T)) {\n    if (length(z) > 1.0) return false;\n    // Inverse stereographic followed by gnomonic projection.\n    z /= 1.0-dot(z,z);\n  } else {\n    z *= 2.0;\n  }\n  if (key(CHAR_S)) z *= exp(0.2*iTime);\n  return true;\n}\n\nvec3 getcolor(vec2 pos) {\n  if (!map(pos)) return vec3(1,1,0.8);\n  vec2 coeffs; vec3 inroots, roots; float err;\n  int nroots = getdata(pos,coeffs,inroots,roots,err);\n  vec3 color = h2rgb(0.9*2.0*atan(1000.0*sqrt(err))/PI);\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0);\n  vec2 pos = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 mouse = vec2(0);\n  bool showmouse = iMouse.x > 0.0;\n  if (showmouse) {\n    mouse = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    if (key(CHAR_Z)) {\n      float zoom = 4.0;\n      pos = 0.25*pos + 0.75*mouse;\n    }\n  }\n  vec3 color = getcolor(pos);\n  vec2 mpos = mouse;\n  if (showmouse && map(mpos)) {\n    color = mix(color,vec3(0),hud(fragCoord,mpos));\n  }\n  if (alert) color.rb = vec2(1);\n  fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat cuberoot(float x) {\n  return sign(x)*pow(abs(x),1.0/3.0); // Sign OK here though\n}\n\n// Complex arithmetic\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\n// Just return real part of zw\nfloat rmul(vec2 z, vec2 w) {\n  return z.x*w.x-z.y*w.y;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\nconst int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\nconst int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n\nint printfloat(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return 0;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  const int SPACE = 0x20;\n  if (isinf(x)) {\n    if (x < 0.0) CHAR(MINUS);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    if (1.0/x < 0.0) CHAR(MINUS);\n    CHAR(ZERO);\n  } else {\n    if (x < 0.0) CHAR(MINUS) // No semicolon!\n    else CHAR(SPACE);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have our (correctly rounded) integer representation\n    // together with the correct exponent.\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return 0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}