{
    "Shader": {
        "info": {
            "date": "1643934344",
            "description": "Electromagnetic Potential from charges, magnets, and current loops. \nThe radial component of the field appears from the probability of a random ray hitting the source...",
            "flags": 32,
            "hasliked": 0,
            "id": "7sSyzd",
            "likes": 27,
            "name": "Magnets",
            "published": 3,
            "tags": [
                "physics",
                "magnet"
            ],
            "usePreview": 0,
            "username": "wyatt",
            "viewed": 518
        },
        "renderpass": [
            {
                "code": "Main\n    Q = vec4(1);\n    vec3 p = vec3(0,0,-2);\n    vec3 d = normalize(vec3((U-.5*R)/R.y,1));\n    p.xz *= ei(.2*sin(iTime));\n    d.xz *= ei(.2*sin(iTime));\n    \n    for (float i = 0.; i < 30.; i++) {\n    \n        p += d*map(p);\n    \n    }\n    vec3 no = normal(p);\n    \n    float C; vec3 P,J;\n    info(p,C,P,J,Q);\n    if (Q.w < 0.) {\n        Q = A(p.xy*.5*R.y+.5*R);\n        Q /= float(I);\n        if (length(Q.xyz)>0.)\n        Q.xyz = length(Q.xyz)*(.5-.5*sin(3.*atan(Q.x,Q.y)+vec3(1,2,3)));\n        else Q.xyz = vec3(1);\n        Q += vec4(-Q.w,abs(Q.w),Q.w,0);\n        Q = 1.-.8*atan(.4*Q);\n        Q *= 1.3*exp(-.7*dot(p.xy,p.xy));\n        vec2 w = fwidth(p.xy);\n        Q *= 1.-.25*smoothstep(1.-.5*w.x,1.,cos(10.*p.x));\n        Q *= 1.-.25*smoothstep(1.-.5*w.y,1.,cos(10.*p.y));\n        Q *= 1.-.25*smoothstep(1.-10.*w.x,1.,cos(100.*p.x));\n        Q *= 1.-.25*smoothstep(1.-10.*w.y,1.,cos(100.*p.y));\n    \n        \n        vec3 q = p;\n        for (float i = 0.; i < 10.; i++) {\n            q += d*map2(q);\n\n        }\n        \n        vec4 color = vec4(0);\n        info(q,C,P,J,color);\n        vec3 li = normalize(light_pos-q);\n        vec3 nor= normal(q);\n        if (length(color)>.1&&color.w>0.) Q += Q*color*(dot(nor,li));\n    \n    }\n    d = normalize(light_pos-p);\n    Q *= .5+.5*dot(no,d);\n    p += 1e-3*d;\n    for (float i = 0.; i < 15.; i++) {\n        p += d*map(p);\n    }\n    //Q *= exp(-.1*length(p-light_pos));\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "Main\n\n    Q = A(U);\n    vec3 p = vec3(2.*(U-.5*R)/R.y,0);\n    float C; vec3 P,J; vec4 q;\n    \n    vec3 d = rand(vec4(U,I,T));\n    vec4 h = hash44(vec4(U,I,T));\n    p += .1/60.*d*h.w;\n    for (float i = 1.; i < 80.; i++) {\n        p += 1./60.*(d);\n        info (p,C,P,J,q);\n        Q.w += C;\n        Q.xyz += cross(P,d)+J;\n    }\n    \n    \n    if (iFrame < 0) Q = vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 R; float T; int I;\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U) { R=iResolution.xy; T=iTime; I=iFrame;\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi 3.14159265359\n#define light_pos vec3(1,1,-3)\n#define tri_pos vec3(.3,.1,.03)\n#define tri_mat mat3( \\\n   0.9174312, -0.2873479,  0.2752294,\\\n   0.2873479,  0.0000000, -0.9578263,\\\n   0.2752294,  0.9578263,  0.0825688 )\n#define rec_pos vec3(-.5,.2,-.1)\n#define rec_mat mat3(\\\n   0.0253286,  0.9891455,  0.1447403,\\\n   0.9408970,  0.0253286, -0.3377445,\\\n  -0.3377445,  0.1447403, -0.9300424 \\\n)\n#define sph_pos vec3(-.5,-.5,-.1)\n#define sph_mat mat3(1)\n#define bal_pos vec3(-.9,-.3,-.05)\n#define bal_mat mat3(1)\n#define tor_pos vec3(.9,-.2,-.04)\n#define tor_mat mat3(\\\n   0.9523810, -0.0999419,  0.2880662,\\\n   0.2904181,  0.0095238, -0.9568524,\\\n   0.0928862,  0.9949477,  0.0380952 \\\n)\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return abs(dot(p,n))-h;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat map (vec3 p) {\n    float tri = sdTriPrism((p-tri_pos)*tri_mat,vec2(.2,.7));\n    float rec = sdBox((p-rec_pos)*rec_mat,vec3(.1,.2,.3));\n    float plane = sdPlane(p,vec3(0,0,1),0.001);\n    float sphere = sdSphere((p-sph_pos)*sph_mat,.2);\n    float ball = sdSphere((p-bal_pos)*bal_mat,.1);\n    float torus = sdTorus((p-tor_pos)*tor_mat,vec2(.5,.05));\n    float light = sdSphere(p-light_pos,.1);\n    return min(tri,min(plane,min(rec,min(sphere,min(torus,min(light,ball))))));\n}\nfloat map2 (vec3 p) {\n    float tri = sdTriPrism((p-tri_pos)*tri_mat,vec2(.2,.7));\n    float rec = sdBox((p-rec_pos)*rec_mat,vec3(.1,.2,.3));\n    float plane = sdPlane(p,vec3(0,0,1),0.001);\n    float sphere = sdSphere((p-sph_pos)*sph_mat,.2);\n    float ball = sdSphere((p-bal_pos)*bal_mat,.1);\n    float torus = sdTorus((p-tor_pos)*tor_mat,vec2(.5,.05));\n    float light = sdSphere(p-light_pos,.1);\n    return min(tri,min(rec,min(sphere,min(torus,min(light,ball)))));\n}\nvoid info (vec3 p, out float C, out vec3 P, out vec3 J, out vec4 color) {\n    C = 0.; J = vec3(0); color = vec4(0);\n    vec3 tri = (p-tri_pos)*tri_mat;\n    vec3 rec = (p-rec_pos)*rec_mat;\n    vec3 sph = (p-sph_pos)*sph_mat;\n    vec3 tor = (p-tor_pos)*tor_mat;\n    vec3 bal = (p-bal_pos)*bal_mat;\n    float dtri = sdTriPrism(tri,vec2(.2,.7));\n    float drec = sdBox(rec,vec3(.1,.2,.3));\n    float dplane = sdPlane(p,vec3(0,0,1),0.001);\n    float dsphere = sdSphere(sph,.2);\n    float dlight = sdSphere(p-light_pos,.1);\n    float dtorus = sdTorus(tor,vec2(.5,.05));\n    float dball = sdSphere(bal,.1);\n    float d = 1e9;\n    if (dtri < d) {\n        d = dtri;\n        float t = dot(p-tri_pos,tri_mat[2]);\n        if (t > 0.) color = vec4(1,0,0,1);\n        else color = vec4(.2);\n        P = tri_mat[2];\n        C = 0.;\n        J = vec3(0);\n    }\n    if (dplane < d) {\n        d = dplane;\n        color = vec4(1,1,1,-1);\n        J = vec3(0);\n        C = 0.;\n        P = vec3(0);\n    }\n    if (drec < d) {\n        d = drec;\n        float t = dot(p-rec_pos,rec_mat[2]);\n        if (t > 0.) color = vec4(1,.25,0,1);\n        else color = vec4(.1,.1,.7,1);\n        P = rec_mat[2];\n        C = .3;\n        J = vec3(0);\n    }\n    if (dsphere < d) {\n        d = dsphere;\n        color = vec4(0,.6,.8,1);\n        C = -.5;\n        J = vec3(0);\n        P = vec3(0);\n    }\n    if (dlight < d) {\n        d = dlight;\n    }\n    if (dtorus < d) {\n        d = dtorus;\n        color = vec4(1,.6,.0,1);\n        J = 10.*cross(tor_mat[2],p-tor_pos);\n        C = 0.;\n        P = vec3(0);\n    }\n    if (dball < d) {\n        d = dball;\n        color = vec4(1,.2,.3,1);\n        C = 2.;\n        J = vec3(0);\n        P = vec3(0);\n    }\n    if (d>1e-3) {\n        color = vec4(0);\n        P = vec3(0);\n        C = 0.;\n        J = vec3(0);\n    }\n}\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-3,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n    ));\n}\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec3 rand(vec4 p) {\n    vec4 h = hash44(p);\n    float theta = 2. * pi * h.x;\n    float phi = acos(1. - 2. * h.y);\n    return vec3(sin(phi) * cos(theta),\n                sin(phi) * sin(theta),\n                cos(phi) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}