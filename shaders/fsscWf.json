{
    "Shader": {
        "info": {
            "date": "1642817782",
            "description": "Saw this done in Blender / Geometry nodes and wanted to see if I could make it in a shader! [url]https://twitter.com/frktnv/status/1484167941025316867[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "fsscWf",
            "likes": 32,
            "name": "Soothing Movement ",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "spheres",
                "replication"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Soothing Movement | Twitter Replication\n    01/18/22 @byt3_m3chanic \n    \n    Saw this done in Blender / Geometry nodes and wanted to see if \n    I could make it in a shader! https://twitter.com/frktnv/status/1484167941025316867\n\n    Using ABS to mirror movement - not sure I have it totally correct. Still stumped on\n    how to do the coloring as in the tweet... but I like the movement.\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .001\n#define MAX_DIST    175.\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat lsp(float b,float e,float t) { return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t=t-1.)*t*t+1.; }\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat capp( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global\nvec3 hp,hitPoint;\nfloat tmod,ga1,ga2,ga3,ga4,ga5;\nmat2 rpi,rnp,rg1,rg2,rg3,rg4,rg1a,rg2a,rg3a,rg4a;\n\nconst float scale = 4.;\nconst float quad = scale/2.;\nconst float cell = quad/2.;\nconst float spce = cell/2.;\nconst vec2 l = vec2(scale,scale);\nconst vec2 s = l*2.;\n\nvec2 map(vec3 q3) {\n    q3.y+=1.5;\n    q3.x+=T*.4;\n    vec2 res = vec2(1e5,0.);\n\n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n    \n    float ld=1e5,lf=1e5,lb=1e5,bx=1e5;\n    \n    // Multi Tap distance map picked up from @Shane\n    // https://www.shadertoy.com/view/WtffDS\n    for(int i = 0; i<4; i++) {\n    \n        ct = ps4[i]/2. -  ps4[0]/2.;\t// Block center.\n        p = q3.xz - ct*s;\t\t\t\t// Local coordinates. \n        ip = floor(p/s) + .5;\t\t\t// Local tile ID. \n        p -= (ip)*s; \t\t\t\t\t// New local position.\t\t   \n        vec2 idi = (ip + ct)*s;\t\t\t// Correct position & tile ID.\n\n        vec3 q = vec3(p.x,q3.y,p.y);\n\n        vec3 q1 = vec3(p.x+cell,q3.y,p.y+cell);\n        q1.xz=abs(abs(q1.xz)-scale)-quad;\n \n        if(tmod<1.){\n            q1.z+=ga1*quad;\n            q1.yz*=rg2;\n        }else if(tmod<2.){\n            q1.z+=quad;\n            q1.x+=ga2*quad;\n            q1.yz*=rnp;\n            q1.yx*=rg3;\n\n        }else if(tmod<3.){\n            q1.z-=quad;\n            q1.x-=quad;\n            q1.z+=ga3*quad;\n            q1.yz*=rg2a;\n        } else {\n            q1.x+=quad;\n            q1.x-=ga4*quad;\n            q1.yx*=rpi;\n            q1.yx*=rg3a;\n        }\n\n        float s1 = length(q1)-.65;\n\n        s1=max(box(q1+vec3(spce,0,spce),vec3(.5,1,.5)),s1);\n        ld = min(ld,s1);\n\n        if(ld<res.x) {\n            res = vec2(ld,1.);hp=q1;\n        }\n\n        q.xz=abs(abs(q.xz)-quad)-cell;\n        lb = min( capp(q,.05,1.), bx); \n        lb = min( capp(q,.05,1.), lb);\n    }\n\n    if(lb<res.x) {\n        res = vec2(lb,5.);\n        hp=q3;\n    }\n        \n    float fx = q3.y+.575;\n    if(fx<res.x) {\n        res = vec2(fx,6.);\n        hp=q3;\n    }\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        t.x *= .8;\n        if(t.x<1e-4) hit = true;\n        d += t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>175.) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p, hit, 128);\n    d = ray.x;\n    m = ray.y;\n    hitPoint = hp;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-1.5,8,-2.5);\n        vec3 l = normalize(lpos);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        float t=.025;\n        for( int i =0; i<16; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h * .9;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 11.);\n        fresnel = mix(.0, .9, fresnel);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(view, ret), 0.), 24.);\n\n        vec3 h = vec3(.5);\n\n        \n        if(m==1.) {\n           vec2 uv = fract((hitPoint.xz+cell)*spce)-.5;\n           //vec2 id = floor((hitPoint.xz+cell)/quad);\n           h=vec3(0.004,0.322,0.616);\n           \n           //if(mod(id.x+id.y,2.)<1.) h = (fl.x<fl.y)?vec3(0.180,0.761,0.216):vec3(0.180,0.569,0.761);\n           float cir=length(uv)-.25;\n           cir=abs(abs(abs(abs(cir)-.04)-.02)-.01)-.0045;\n           \n           cir=smoothstep(.0011,.001,cir);\n           h=mix(h,vec3(1.000,0.584,0.000),cir);\n           ref = clamp(h-fresnel,vec3(0),vec3(1));\n        }\n        if(m==5.) {\n            h=vec3(.3);\n            ref = clamp(vec3(.3)-fresnel,vec3(0),vec3(1));\n        }\n\n        if(m==6.) {\n            vec2 uv = fract(hitPoint.xz*.5)-.5;\n            h=vec3(0.796,0.737,0.584);\n            ref=vec3(.0);\n            if(uv.x*uv.y>0.) {\n                h = vec3(.2);\n                ref = clamp(h-fresnel,vec3(0),vec3(1));\n           }\n        }\n\n\n        RC = h * diff + min(spec,shdw);\n        if(bnc<2) RC = mix(RC,vec3(.05), 1.-exp(-.0025*d*d*d));\n        \n        ro = p+n*.1;\n        rd = reflect(rd,n);\n        \n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nconst vec3 FC = vec3(0.149,0.157,0.173);\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    tmod = mod(T*.5,4.);\n    float t1 = lsp(0.0, 1.0, tmod);\n    ga1 = eoc(t1);\n    ga1 = ga1*ga1*ga1;\n\n    float t2 = lsp(1.0, 2.0, tmod);\n    ga2 = eoc(t2);\n    ga2 = ga2*ga2*ga2;\n    \n    float t3 = lsp(2.0, 3.0, tmod);\n    ga3 = eoc(t3);\n    ga3 = ga3*ga3*ga3;\n\n    float t4 = lsp(3.0, 4.0, tmod);\n    ga4 = eoc(t4);\n    ga4 = ga4*ga4*ga4;\n    \n    rpi = rot(PI);\n    rnp = rot(-PI);\n\n    rg2 = rot(-ga1*PI);\n    rg3 = rot(ga2*PI);\n\n    rg2a = rot(-ga3*PI);\n    rg3a = rot(ga4*PI);\n\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    float zoom = 5.;\n    vec3 ro = vec3(uv*zoom,-zoom-2.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    mat2 rx =rot(.58);\n    mat2 ry =rot(-.68);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0., f = 0.;\n    bool hit = false;\n \n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    C = mix(C,vec3(.05), 1.-exp(-.00015*fA*fA*fA));\n    C = mix(C,FC,smoothstep(0.,1.,f*0.015));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}