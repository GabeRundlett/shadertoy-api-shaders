{
    "Shader": {
        "info": {
            "date": "1633013312",
            "description": "dipole based field rendered with revised affine arithmetic. ",
            "flags": 0,
            "hasliked": 0,
            "id": "fstSWn",
            "likes": 8,
            "name": "Isozig (RAA)",
            "published": 3,
            "tags": [
                "raymarching",
                "dipole",
                "raa",
                "winding"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 452
        },
        "renderpass": [
            {
                "code": "// uncomment for simple interactive six point demo\n//#define TEST_SIXAXIS\n\n\n#define MAX_LEVEL 16u\n#define MAX_STEPS 100\n\n// revised affine form of rank 1\nstruct raf1 {\n    float x0;\n    float x1;\n    float e;\n};\n\nstruct raf1x3 {\n    raf1 x;\n    raf1 y;\n    raf1 z;\n};\n\nraf1 ra_const(float x) {\n    return raf1(x, 0.0, 0.0);\n}\nfloat ra_radius(raf1 a) {\n    return abs(a.x1) + a.e;\n}\nvec2 ra_interval(raf1 a) {\n    float r = ra_radius(a);\n    return vec2(a.x0 - r, a.x0 + r);\n}\n\nraf1 ra_add(raf1 a, raf1 b) {\n\treturn raf1(a.x0 + b.x0, a.x1 + b.x1, a.e + b.e);\n}\nraf1 ra_add(raf1 a, float b) {\n\treturn raf1(a.x0 + b, a.x1, a.e);\n}\nraf1 ra_add(float a, raf1 b) {\n\treturn raf1(a + b.x0, b.x1, b.e);\n}\nraf1x3 ra_add(raf1x3 a, vec3 b) {\n\treturn raf1x3(ra_add(a.x,b.x),ra_add(a.y,b.y),ra_add(a.z,b.z));\n}\n\nraf1 ra_sub(raf1 a, raf1 b) {\n\treturn raf1(a.x0 - b.x0, a.x1 - b.x1, a.e + b.e);\n}\nraf1 ra_sub(raf1 a, float b) {\n\treturn raf1(a.x0 - b, a.x1, a.e);\n}\nraf1 ra_sub(float a, raf1 b) {\n\treturn raf1(a - b.x0, -b.x1, b.e);\n}\nraf1x3 ra_sub(raf1x3 a, vec3 b) {\n\treturn raf1x3(ra_sub(a.x,b.x),ra_sub(a.y,b.y),ra_sub(a.z,b.z));\n}\n\nraf1 ra_neg(raf1 a) {\n\treturn raf1(-a.x0, -a.x1, a.e);\n}\n\nraf1 ra_mul(raf1 a, raf1 b) {\n    float s = abs(a.x1);\n    float t = abs(b.x1);\n    float w = dot(a.x1, b.x1);\n    float u = s;\n    float v = t;\n    return raf1(\n        a.x0 * b.x0 + 0.5 * w,\n        a.x0 * b.x1 + a.x1 * b.x0,\n        a.e * b.e\n        + b.e * (abs(a.x0) + u)\n        + a.e * (abs(b.x0) + v)\n        + u * v\n        - 0.5 * dot(s, t));\n}\nraf1 ra_mul(raf1 a, float b) {\n    return raf1(\n        a.x0 * b,\n        a.x1 * b,\n        a.e * abs(b));\n}\nraf1 ra_mul(float a, raf1 b) {\n    return ra_mul(b, a);\n}\nraf1x3 ra_mul(raf1 a, vec3 b) {\n\treturn raf1x3(ra_mul(a,b.x),ra_mul(a,b.y),ra_mul(a,b.z));\n}\n\nraf1 ra_rcp(raf1 a) {\n    vec2 i = ra_interval(a);\n    float i0i1 = i[0]*i[1];\n    if (i0i1 < 0.0) {\n        return raf1(1.0/a.x0, 0.0, 1.0/0.0);\n    } else {\n        vec2 ab = 1.0 / i;\n        float h = sign(i[0]) / sqrt(i0i1);\n        float c = (ab[0]+ab[1]) * 0.5;\n        float nalpha = ab[0] * ab[1];\n        float alpha = -nalpha;\n        float zeta = c + h;\n        float delta = abs(c-h);\n        return raf1(\n            alpha * a.x0 + zeta,\n            alpha * a.x1,\n            nalpha * a.e + delta);\n    }\n}\n\nraf1 ra_div(raf1 a, raf1 b) {\n    return ra_mul(a, ra_rcp(b));\n}\n\nraf1 ra_pow2(raf1 a) {\n    float w = 0.5 * a.x1 * a.x1;\n    return raf1(\n        a.x0 * a.x0 + w,\n        2.0 * a.x0 * a.x1,\n        a.e * (1.0 + 2.0 * (abs(a.x0) + abs(a.x1))) + w);\n}\n\nraf1 ra_dot(raf1x3 a, raf1x3 b) {\n    return ra_add(ra_add(ra_mul(a.x, b.x),ra_mul(a.y, b.y)),ra_mul(a.z, b.z));\n}\n\nraf1 ra_dot(raf1x3 a, vec3 b) {\n    return ra_add(ra_add(ra_mul(a.x, b.x),ra_mul(a.y, b.y)),ra_mul(a.z, b.z));\n}\n\nraf1 ra_dot(raf1x3 a) {\n    return ra_add(ra_add(ra_pow2(a.x),ra_pow2(a.y)),ra_pow2(a.z));\n}\n\nraf1 ra_sqrt(raf1 x) {\n    vec2 i = ra_interval(x);\n    if (i[1] < 0.0) return ra_const(0.0);\n    i[0] = max(i[0], 0.0);\n    vec2 sq = sqrt(i);\n    float c = sq[1] + sq[0];\n    float h = sq[1] - sq[0];\n    float alpha = 1.0 / c;\n    float dzeta = c / 8.0 + 0.5 * sq[0] * sq[1] / c;\n    float delta = h * h / (8.0 * c);\n    return raf1(\n        alpha * x.x0 + dzeta,\n        alpha * x.x1,\n        alpha * x.e + delta);\n}\n\nraf1 ra_length(raf1x3 a) {\n    return ra_sqrt(ra_dot(a));\n}\n\nraf1 ra_abs (raf1 a) {\n    vec2 i = ra_interval(a);\n    if (i[0]*i[1] >= 0.0) {\n        return raf1(abs(a.x0), a.x1 * sign(a.x0), a.e);\n    } else {\n    #if 0\n        // keep ambiguous case in a box\n        vec2 j = abs(i);\n        i = (i[0]>=0.0)?j:(i[1]<0.0)?j.yx:vec2(0.0,max(j[0],j[1]));\n        return raf1((i[0]+i[1])*0.5, 0.0, (i[1]-i[0])*0.5);\n    #else\n        vec2 ab = abs(i);\n        float alpha = (ab[1] - ab[0]) / (i[1] - i[0]);\n        float zeta = (ab[0] - i[0] * alpha) * 0.5;\n        float delta = zeta;\n\n        return raf1(\n            alpha * a.x0 + zeta,\n            alpha * a.x1,\n            abs(alpha) * a.e + delta);\n\t#endif\n    }\n}\n\n// crude approximation for min/max\n// there are more opportunities for truncation here, as only\n// the overlapping parallelogram and either one or both top parts (max)\n// or bottom parts (min) of each argument need to be bounded.\n// e.g. if all minimum values of a are above the minimum values of b,\n// regardless of any overlapping, only a needs to be considered for max(a,b).\n\nraf1 ra_max(raf1 a, raf1 b) {\n    vec2 ia = ra_interval(a);\n    vec2 ib = ra_interval(b);\n    if (ia[0] >= ib[1])\n        return a;\n    else if (ib[0] >= ia[1])\n        return b;\n    else {\n\t    return ra_mul(ra_add(ra_add(a,b),ra_abs(ra_sub(a, b))),0.5);\n    }\n}\n\nraf1 ra_min(raf1 a, raf1 b) {\n    vec2 ia = ra_interval(a);\n    vec2 ib = ra_interval(b);\n    if (ia[1] <= ib[0])\n        return a;\n    else if (ib[1] <= ia[0])\n        return b;\n    else {\n\t    return ra_mul(ra_sub(ra_add(a,b),ra_abs(ra_sub(a, b))),0.5);\n    }\n}\n\nraf1 ra_zero(raf1 x, raf1 y) {\n    float dxdy = x.x1 / y.x1;\n    return raf1(x.x0 - dxdy * y.x0, dxdy * y.e, 0.0);\n}\n\nvec2 get_range(uint c, uint level) {\n#if 1\n    float r = exp2( -float(level) );\n    const float k = exp2( -float(MAX_LEVEL) );\n    float center = (float(c)*k) * 2.0 - 1.0 + r;\n#else\n    float r = 1.0 / float(1u << level);\n    float center = (float(c) / float(1u << MAX_LEVEL)) * 2.0 - 1.0 + r;\n#endif\n    center += 1.0;\n    return vec2(center, r);\n}\n\nuint find_lsb(uint value) {\n#if 1\n    // findLSB() hack\n    return uint(log2(float(value & -value)));\n#else\n    // with GL4, this loop can be replaced with\n    // a single use of findLSB()\n    uint count = 0u;\n    for (uint i = 0u; i < MAX_LEVEL; ++i) {\n        if ((value & 1u) != 0u)\n            break;\n        count += 1u;\n        value >>= 1u;\n    }\n    return count;\n#endif\n}\n\nuint lowest_level(uint p) {\n    uint used_levels = min(MAX_LEVEL, find_lsb(p));\n    return MAX_LEVEL - used_levels;\n}\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nconst float PI = 3.14159265359;\n\nraf1 ra_dipole(raf1x3 p, vec3 n, float a) {\n    raf1 u = ra_dot(p, -n*a);\n    raf1 v = ra_dot(p);\n    v = ra_mul(v, ra_sqrt(v));\n    return ra_div(u, v);\n}\n\nraf1 ra_map( raf1x3 p ) {\n#if 0\n    p.y = ra_add(p.y, 0.3);\n    raf1 d = ra_const(0.0);\n    const int N = 80;\n    float u = sin(iTime)*0.5+0.5;\n    for (int i = 0; i < N; ++i) {\n        float x = float(i);\n        float a = x * 2.39996322972865332;\n        vec2 n = vec2(cos(a), sin(a));\n        float r = (x + 1.0) / float(N);\n        float h = mix(x / float(N), 1.0 - x / float(N),u);\n        float A = r*0.2;//pow(r,2.5)*0.3;//4.0 * PI 1 r * r / 8.0;\n        d = ra_add(d, ra_dipole(ra_sub(p, vec3(n.x*r, h, n.y*r)), normalize(vec3(n.x, u*2.0-1.0, n.y)), A));\n    }\n    \n    return ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n#elif defined(TEST_SIXAXIS)\n    float r = 0.5;\n    float a = 4.0 * PI * r * r / 6.0 * (iMouse.y / iResolution.y) * 4.0;\n    raf1 d = ra_dipole(ra_sub(p, vec3(r, 0.0, 0.0)), normalize(vec3(cos(iTime), sin(iTime), 0.0)), a);\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(-r, 0.0, 0.0)), normalize(vec3(-1.0, 0.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, r, 0.0)), normalize(vec3(0.0, 1.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, -r, 0.0)), normalize(vec3(0.0, -1.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, r)), normalize(vec3(0.0, 0.0, 1.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, -r)), normalize(vec3(0.0, 0.0, -1.0)), a));\n\n    return ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n#else\n    const int N = 8;\n    float A = 4.0 * PI * 0.25 / float(N) * 0.25;\n\n    raf1 d = ra_const(0.0);\n    for (int i = 0; i < N; ++i) {\n        float q = float(i)/float(N);\n        float a = q * 2.0 * PI;\n        float w0 = sin(a*3.0 + 0.1*iTime*2.0*PI);\n        float ae = a + w0*2.0*PI;\n        float s = sin(a);\n        float c = cos(a);\n        d = ra_add(d, ra_dipole(ra_sub(p, vec3(c, s, 0.0)*0.5), normalize(vec3(cos(ae), sin(ae), 0.0)), A*(w0*0.5+0.5)*8.0));\n    }    \n    //d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, -0.5)), normalize(vec3(0.0, 0.0, 1.0)), A*32.0));\n    \n    d = ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n    return d;\n#endif\n}\n\nraf1x3 ra_grad(vec3 pos, vec3 eps) {\n    return raf1x3(raf1(pos.x, eps.x, 0.0), raf1(pos.y, eps.y, 0.0), raf1(pos.z, eps.z, 0.0));\n}\n\nvec3 gradient( in vec3 pos ) {\n    const float eps = 0.001;\n\n    return -normalize(vec3(ra_map(ra_grad(pos, vec3(eps,0,0))).x1,\n                     ra_map(ra_grad(pos, vec3(0,eps,0))).x1,\n                     ra_map(ra_grad(pos, vec3(0,0,eps))).x1));\n}\n\nfloat calcIntersectionRA( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n    float threshold = get_range(0u, MAX_LEVEL).y;        \n    uint p = 0u;\n    uint level = 0u;\n    float maxd = 10.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        steps = i;\n        const uint topstep = 1u << MAX_LEVEL;\n        if (p >= topstep)\n            break;\n        vec2 rc = get_range(p, level);\n        raf1 t = raf1(rc.x, rc.y, 0.0);\n        raf1 d = ra_map(ra_add(ra_mul(t, rd * maxd), ro));\n        uint stepsz = topstep >> level;\n        // visualize interval\n        vec2 iv = ra_interval(d);\n        // interval crosses zero?\n        bool hit = (iv.x*iv.y < 0.0);\n        if (hit) {\n            // if we have prematurely reached our\n            // desired precision, exit early                \n            if ((d.e <= threshold) || (level == MAX_LEVEL)) {\n                vec2 pr = ra_interval(ra_zero(raf1(rc.x,rc.y,0.0), d));\n                return maxd * (pr[0]+pr[1])/2.0;\n            }\n            // reached maximum precision\n            if (level == MAX_LEVEL)\n                break;\n        }\n        if (hit && (level < MAX_LEVEL)) {\n            level += 1u;\n        } else {\n            p += stepsz;\n            level = lowest_level(p);\n        }\n    }\n    return -1.0;\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, out vec3 normal, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n    vec2 m = (-resolution.xy + 2.0*iMouse.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n\n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,6.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    float w = (iMouse.z > 0.5)?m.x:0.0;\n\n\t// raymarch\n    float t = calcIntersectionRA( ro, rd, 1.0 / resolution, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        normal = -gradient(position);\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float dist;\n    float dist_inner;\n    float dist_outer;\n\n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    vec3 normal;\n    int steps;\n    bool hit = dorender(dist, steps, pos, normal, fragCoord, resolution, 1.0);\n\n    fragColor = vec4(vec3(0.0),1.0);\n#if 0\n    if (hit) {\n        vec3 nor = calcNormal(pos);\n        fragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n    }\n#else\n    vec3 c2 = normhue(float(steps)/float(MAX_STEPS));\n    ivec3 p = ivec3(pos*10.0);\n    c2 = mix(c2, vec3(float((p.x ^ p.y ^ p.z) % 3)/2.0), 0.1);    \n\n    fragColor = vec4(normal*0.5+0.5,1.0);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}