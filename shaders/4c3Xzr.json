{
    "Shader": {
        "info": {
            "date": "1713653942",
            "description": "2D pattern kata. Public domain.\nBrushing up my skills without looking at other people's code.",
            "flags": 0,
            "hasliked": 0,
            "id": "4c3Xzr",
            "likes": 47,
            "name": "2D patterns 1: triangle & square",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "triangle",
                "patterns",
                "antialiasing",
                "hexagon",
                "rectangle",
                "rhombus"
            ],
            "usePreview": 0,
            "username": "rrrola",
            "viewed": 416
        },
        "renderpass": [
            {
                "code": "// 2D pattern kata. Public domain.\n// Brushing up my skills without looking at other people's code.\n\n// Constraints:\n// - fully deterministic (no hashing or noise)\n// - rectangular or triangular grids\n// - only two color channels\n// - needs antialiasing (smoothsteps are fine)\n// - WebGL 1 compatible, 60 fps on my old notebook\n// - 2 kB\n\nvoid mainImage(out vec4 o, vec2 x) {\n    vec3 t = iTime * vec3(.1, .316, 1),\n         rot = vec3(cos(t.x), sin(t.x), -sin(t.x));\n    mat2 R = mat2(rot.xzyx),\n         RT = mat2(rot.xyzx);  // slow rotation and its inverse\n    \n    float W = 15. / iResolution.y;  // antialiasing filter width\n\n    vec2 u = (x+x-iResolution.xy)/iResolution.y,  // rect coordinates, y:-1..1\n         r = R*5.*u + t.z,  // transformed rect coordinates (scale, rotation, shift)\n         rr = round(r),\n         h = .5*mat2(2,-1, 0,sqrt(3.)) * r;  // transformed hex coordinates: → x, ↖ y\n    vec3 H = vec3(h, h.x+h.y),  // add third hex direction ↗ z=x+y\n         rH = round(H);\n\n    vec3 i;  // moving hex stripes, used for patterns 1 and 3\n    {\n      vec3 I = fract(H);\n      float f = fract(t.x);\n      i = smoothstep(f   , f   +W, I) - smoothstep(f+.5, f+.5+W, I)\n        + smoothstep(f-1., f-1.+W, I) - smoothstep(f-.5, f-.5+W, I);\n    }\n\n    // Duotone color.\n    vec2 c;\n\n    // Borders between patterns.\n    float Q = .5*iResolution.x/iResolution.y,  // half of x\n          P = floor(u.x/Q)+2. + 4.*(floor(u.y)+1.);  // pattern index 0..7\n    if (any(lessThan(abs(vec3(u, abs(u.x)-Q)), vec3(.01)))) c = vec2(0);\n\n    // Circles over squares.\n    else if (P==0.) {\n        // circles: additive outer radius, covering inner radius\n        float cw = length(r - rr);\n        vec2 C = smoothstep(cw, cw+W, vec2(.25, .35) + .125*sin(t.z));\n\n        // squares: scaled by sqrt(2) - antialiasing filter needs to be wider\n        float sw = .5 + .25*sin(t.y);\n        vec2 s = fract(R*R*(5.*sqrt(2.))*u + t.z),  // rotate even more, scale\n             S = smoothstep(sw, sw+W*sqrt(2.), s) + smoothstep(W*sqrt(2.), 0., s);\n        \n        c = 1. - vec2((1.-C.x)*min(S.x,S.y), C.y); }  // combine\n    \n    // Rhombi sliding around each other, sometimes forming Czech flag cubes.\n    else if (P==1.) {\n        vec3 d = i.xyz*(1.-i.yzx); c = d.yx + d.z; }\n\n    // Rectangular grid with a gradient that's always vertical.\n    else if (P==2.) {\n        vec2 s = r - rr,  // local coords have 0 in the center\n             aa = smoothstep(.45,.45+W, s) + smoothstep(-.5+W,-.5, s);\n        float S = max(aa.x, aa.y);\n        c = vec2(S, max(S, smoothstep(-.2,.7, (RT*s).y))); }  // unrotate the gradient\n\n    // Sliding triangular stripes.\n    else if (P==3.) {\n        c = vec2(2.*i.xy + i.z)/3.; }\n    \n    // Right triangles and hexagons. Similar to the sliding rhombi, but rectangular.\n    else if (P==4.) {\n        vec3 m = fract(vec3(r, r.x+r.y) + t.x),\n             WW = vec3(W,W,sqrt(2.)*W),  // diagonal antialias is wider\n             j = smoothstep(vec3(.5),.5+WW, m) + smoothstep(WW,vec3(0), m);\n        c = vec2(max(max(j.x,j.y),j.z), min(min(j.x,j.y),j.z)); }\n    \n    // Cute migrating blobs on a hexagonal grid.\n    else if (P==5.) {\n        vec3 i = H - rH;  // local coords have 0 in the center\n        float q = mod(rH.x + rH.z, 3.),  // cell index: select from 3 colors\n              w = .4 + .1*sin(t.z + (30. + 10.*sin(t.x))*u.y),  // warp radius\n              s = 2.*(RT*i.xz).y + 1.;  // unrotate shading\n        c = s * smoothstep(w+W, w, length(i)) * vec2(q<2.?1:0, q<1.?0:1); }  // antialias, color\n    \n    // Glowing triangular mesh.\n    else if (P==6.) {\n        float L = (length(fract(H) - .5) - .25) * 1.75;  // map to ~ 0..1\n        c = pow(vec2(L), 3.+2.*cos(t.xy)); }  // modify glow exponent 1..5\n\n    // Stairs and waves with fading echoes.\n    else if (P==7.) {\n        vec2 f = r - rr;\n        float q = mod(rr.x + rr.y, 4.);  // rectangular cell index\n        \n        c = vec2(1,0);\n        float l;  // get continuous stair- or wave field based on cell index, assign color\n        if      (q<1.) { l = min(f.x,f.y)+.5; }\n        else if (q<2.) { l = max(f.x,f.y)+.5; }\n        else if (q<3.) { c=c.yx; l = length(f-.5); }\n        else           { c=c.yx; l = 1. - length(f+.5); }\n\n        vec4 p = .5 + .35*sin(vec4(t.z, floor(t.z)-vec3(0,1,2))),  // main moving line + static echo (floor)\n             d = vec4(3, vec3(3,2,1)-fract(t.z))/3.,  // keep 3 echoes: get narrower and fade away\n             w = .075*d,  // width\n             v = d*d * smoothstep(p-w-W,p-w, vec4(l)) * smoothstep(p+w+W,p+w, vec4(l));  // intensity\n        c *= max(max(max(v.x,v.y),v.z),v.w); }\n\n    o = vec4(13,8,4,0);\n    o = sqrt(o*c.x + o.zyxw*c.y + 1.) / 4.;  // orange + blue palette\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}