{
    "Shader": {
        "info": {
            "date": "1725796608",
            "description": "https://www.lizardcube.com",
            "flags": 0,
            "hasliked": 0,
            "id": "X3syRr",
            "likes": 5,
            "name": "LizardCube Logo",
            "published": 3,
            "tags": [
                "logo",
                "unity"
            ],
            "usePreview": 0,
            "username": "Karp",
            "viewed": 87
        },
        "renderpass": [
            {
                "code": "float CubeMask(vec2 uv,float size, float roundness, float blurLvl)\n{\n    return Clamp01((sdHexagon(RotateUV(uv, 30.0), size * 0.5)-roundness)*blurLvl);\n}\nfloat CubeFaceMask(vec2 uv, float size, float angle, float offset, float roundness, float blurLvl)\n{\n    float sdf = sdRhombus(RotateUV(uv, angle) - vec2(.0, offset), vec2(.8,.46) * size);\n    return Clamp01((sdf - roundness) * blurLvl);\n}\nfloat ParallelogramMask(vec2 uv, vec2 size, float bend, float roundness, float blurLvl)\n{\n    float sdf = sdParallelogram(uv, size.x, size.y, bend);\n    return Clamp01((sdf - roundness) * blurLvl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Parameter\n    float time = iTime * 1.;\n    float size = .8;\n    float blurLvl = 100.0;\n\n    //Color\n    vec3 white = Color255(250,250,250);\n    vec3 black = Color255(005,005,005);\n    \n    // UV manipulation\n    vec2 uv  = AspectRatioUV(fragCoord, iResolution.xy);\n    uv.y += cos(time* 0.5) * 0.1;\n    uv.x += sin(time* 2.0) * 0.15;\n    uv = RotateUV(uv, (sin(time* 2.0) * 6.) +(cos(time* 1.) * 5.));\n    \n    //BackGround\n    vec3 pixel = white;\n    \n    //Cube\n    pixel = mix(black, pixel, CubeMask(uv, size , .1,  blurLvl));\n    \n    vec2 mirrorUV = vec2(abs(uv.x), uv.y);\n    mirrorUV = RotateUV(mirrorUV, 90.);\n    mirrorUV += vec2(.4 - max(.0,sin(time * 2.23456)) * .3, .0);\n    \n    float tongue  = ParallelogramMask(mirrorUV, vec2(.2,.075), .125, .0, blurLvl);\n    pixel = mix( black, pixel, tongue);\n    \n    pixel = mix(white, pixel, CubeMask(uv, size * .75, .1,  blurLvl));\n    \n    float leftSquare  = CubeFaceMask(uv, .45, 120.0, .25, .04, blurLvl);\n    float rightSquare = CubeFaceMask(uv, .45, 240.0, .25, .04, blurLvl);\n    pixel = mix( black, pixel, leftSquare);\n    pixel = mix( black, pixel, rightSquare);\n    \n    leftSquare  = CubeFaceMask(uv, .45, 120.0, .235, .01, blurLvl);\n    rightSquare = CubeFaceMask(uv, .45, 240.0, .235, .01, blurLvl);\n    pixel = mix( white, pixel, leftSquare);\n    pixel = mix( white, pixel, rightSquare);\n    \n    mirrorUV = vec2(abs(uv.x), uv.y);\n    mirrorUV = RotateUV(mirrorUV, 90.);\n    mirrorUV += vec2( .125, .175);\n    \n    float eye  = ParallelogramMask(mirrorUV, vec2(.09 * max(.0,min(1.,mod(time * 0.93658, 5.))),.0075), -.015, .0025, blurLvl);\n    pixel = mix( black, pixel, eye);\n    \n    //pixel = vec3(mirrorUV, .0);\n\tvec4 result = vec4(pixel.xyz, 1.0);\n\tfragColor = result;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n//UV\nvec2 AspectRatioUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = vec2( fragCoord.xy - 0.5*resolution.xy );\n    // [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tuv = 2.0 * uv.xy / resolution.y;\n    // AspectRatio = 1920 / 1080 = 1.778\n    // [-0.5*iResolution.x, 0.5*iResolution.x] ->[-1.778, 1.778]\n\t// [-0.5*iResolution.y, 0.5*iResolution.y] ->[-1, 1]\n    \n    return uv;\n}\nvec2 RotateUV(inout vec2 uv, float angle)\n{\t\n\tangle = angle * PI / 180.0;\n    return uv * mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\n\n//Color \nvec3 Color255(int R, int G, int B)\n{\n    return vec3(float(R)/255.0, float(G)/255.0, float(B)/255.0);\n}\nfloat Clamp01( in float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n// Regular Hexagon - exact from https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n// Parallelogram - exact from https://www.shadertoy.com/view/7dlGRf\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n// Rhombus - exact from IQ (https://www.shadertoy.com/view/XdXcRB)\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\nfloat sdBox( in vec2 pos, in vec2 box )\n{\n    vec2 dist = abs(pos)-box;\n    return length(max(dist,0.0)) + min(max(dist.x,dist.y),0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}