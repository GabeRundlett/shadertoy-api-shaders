{
    "Shader": {
        "info": {
            "date": "1500296892",
            "description": "More specifically, this is bump mapped, hashless, 3-Tap 2nd order cellular pattern. The pattern isn't perfect, but you get what you pay for. :D",
            "flags": 0,
            "hasliked": 0,
            "id": "MsSfWh",
            "likes": 14,
            "name": "[SH17A] 3 Tap 2nd Order Voronoi",
            "published": 3,
            "tags": [
                "voronoi",
                "bump",
                "cellular",
                "tweet"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1610
        },
        "renderpass": [
            {
                "code": "/*\n\n\t3 Tap 2nd Order Voronoi\n\t-----------------------\n\n\tNot really an entry per se, but it wouldn't be Shadertoy without a cliche Voronoi example, so I\n\tcoded one up. :)\n\n\tThis particular one is a bump mapped, hashless, 3-Tap 2nd order cellular pattern. OK, it isn't \n\tVoronoi in the strictest sense, but it's produced with a custom algorithm designed to give the \n\tsame feel.\n\n\tThe standard Voronoi algorithm requires a little too much information. Loops, cell positions,\n\tdistance checks, and some kind of workable two dimensional hash function. Someone could probably \n\tfit it into two tweets, but I don't imagine there'd be much room left for anything else.\n\n\tThis pattern was produced using a different method, which involves plotting repeat points on warped, \n\trotational layers, then finding the desired first and second order distances. The resultant pattern \n\tisn't perfect - that's for sure, but the algorithm takes up considerably less space, which leaves \n\troom for some very cheap bump mapping, coloring, etc.\n\n\tI'd originally raymarched this, but there wasn't enough room left to pretty it up, so instead, I \n\topted to perform some very cheap two-sample bump mapping and coloring. By the way, if someone could \n\tremove some characters and apply some environment mapping, that'd be great. :D\n\n*/\n\n\n// Declaring some floats globally for global access - Basically, the opposite of what you're supposed \n// to with shader code. It wouldn't make Ollj happy. :D\n\n// I tried to give them intuitive one letter names. In order: Closest distance, second closest distance,\n// current distance, storage for the function value (y-x), and an out-of-place looking global loop counter... \n// Bad programming practice at its finest. :)\nfloat x, y, d, f, i;\n\n// Self contained, hashless, 3 Tap, 2nd Order Voronoi function. Not written for speed due to character\n// restrictions, but at 3 taps, it's not going to be slow anyway.\nvoid v(vec2 p){\n    \n    // The trick here is to plot a wrapped cell point, rotate space, plot another, repeat the process for \n    // the final point, then determine the closest and second closest with some max\\min trickery. Simple, \n    // but quite effective. I've left a few details out, but that's the general idea.\n    x = y = i = 2.;\n    while(i++<5.) d = length(fract(p *= mat2(7, -5, 5, 7)*.1) - .5)/.6, y = max(x, min(y, d)), x = min(x, d);\n   \n}\n\nvoid mainImage(out vec4 o, vec2 u){    \n    \n    // Moving screen coordinates.\n    u = u/iResolution.y*5. + iTime;\n    \n    // Call the function. \"v\" for Voronoi.\n    v(u);\n    // Storing the \"Y - X\" distance (similar to the cool beveled looking one, Y*Y - X*X). To make it \n    // slighty more interesting, I've added an additional sinusoidal term to give the illusion that the \n    // pattern is lit via some kind of grated mechanism which causes a subtle interference pattern. I \n    // used the second order distance only for that - to match the cell structure.\n    f = y - x - sin(y*80.)/80.; \n    \n    // Take a second nearby sample.\n    v(u-.05);\n    \n    // Calculating the sample difference, which in effect provides a gradient bump value. It's a cheap way \n    // to bump things and is based, in part, on directional derivative lighting. IQ wrote an article about \n    // it, which should be easy enough to find. I've stored the value in \"i\" to save characters.\n    i = max(y - x - f, 0.); \n    \n    // Apply a colored gradient (ramped up for a bit of shine) to the Voronoi (with interfernce) value.\n    o = f + vec4(10, 6, 2, 1)*i*i*i*20. + .03; // Very subtle global ambience on the end.\n    \n    // Backing off the green with a duller gradient to give a sunrise hue, or the lamest SSS effect ever. :D\n    o.y -= i; \n    \n} \n\n/*\n// Red and blue highlights, but I couldn't find a way to make it fit. :)\nvoid mainImage(out vec4 o, vec2 u){    \n    \n    // Moving screen coordinates.\n    u = u/iResolution.y*5. + iTime;\n    \n    // Call the function. \"v\" for Voronoi.\n    v(u);\n    // Storing the \"Y - X\" distance (similar to the cool beveled looking one, Y*Y - X*X). To make it \n    // slighty more interesting, I've added an additional sinusoidal term to give the illusion that the \n    // pattern is lit via some kind of grated mechanism which causes a subtle interference pattern. I \n    // used the second order distance only for that - to match the cell structure.\n    f = y - x + sin(y*80.)/1e2; \n    \n    // Take a second nearby sample.\n    v(u-.05);\n    \n    // Calculating the sample difference, which in effect provides a gradient bump value. It's a cheap way \n    // to bump things and is based, in part, on directional derivative lighting. IQ wrote an article about \n    // it, which should be easy enough to find. I've stored the value in \"i\" to save characters.\n    i = max(y - x - f, 0.); \n    x = max(f - y + x, 0.); \n    \n    o = vec4(9, 6, 2, 1);\n    // Apply a colored gradient (ramped up for a bit of shine) to the Voronoi (with interfernce) value.\n    o = f + (o*i*i*i + o.zyxw*x*x*x)*20. + .03; // Very subtle global ambience on the end.\n    \n    // Backing off the green with a duller gradient to give a sunrise hue, or the lamest SSS effect ever. :D\n    o.y -= i; \n    \n} \n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}