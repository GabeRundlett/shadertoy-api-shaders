{
    "Shader": {
        "info": {
            "date": "1714677779",
            "description": "4D geometry kata. Public domain.\nHere's how to get the 2D and 3D orthographic projections of a 4D cube.\nThe 3D projection can be raytraced or used as a distance function for raycasting.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfcSWX",
            "likes": 15,
            "name": "4D cube projections",
            "published": 3,
            "tags": [
                "refraction",
                "cube",
                "shadow",
                "projection",
                "4d",
                "tesseract",
                "gem"
            ],
            "usePreview": 0,
            "username": "rrrola",
            "viewed": 246
        },
        "renderpass": [
            {
                "code": "// 4D geometry kata. Public domain.\n\n// Here's how to get the 2D and 3D orthographic projections of a 4D cube.\n// The 3D projection can be raytraced or used as a distance function for raycasting.\n\n// The 2D projection of a 4D cube can be represented as the intersection of \"fat lines\",\n// each corresponding to one of the edges of the 4D cube\n// and wide enough to contain all of the projected vertices of the cube.\n// There are four possible edge directions, so there will be four bands (X,Y,Z,W).\n\n// We'll do something similar when projecting the 4D cube to 3D,\n// only the bands will be \"fat planes\" and there will be six of them,\n// each corresponding to one of the six possible face orientations (XY,XZ,XW,YZ,YW,ZW).\n\n\n// Reflection and refraction:\n//   https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// Bivectors:\n//   https://en.wikipedia.org/wiki/Exterior_algebra\n\n// v2 (2024-05-03): bugfix (fill exit normals, fix IOR handling)\n\n\n// You can test both raytracing and raycasting (sphere tracing).\n#define RAYCAST 0\n#define RAYTRACE 1\n//#define RENDERING_METHOD RAYCAST\n#define RENDERING_METHOD RAYTRACE\n\n// When raytracing, we'll make the 3D projection refractive for some extra eye candy.\n#define IOR 1.6               // Index of refraction of the gem, assume it's > 1. (The outside IOR is 1.)\n#define ABSORB vec3(.4,.5,.1) // Absorption coefficients for Beer's law. Control the color of the gem.\n#define BOUNCES 4\n\n\n// Bivectors encode the orientation and area of a 2D parallelogram in n-D space.\n\n// 4D vectors have a \"line basis\" X,Y,Z,W - they're oriented lines with a length,\n// 4D bivectors have a \"plane basis\" XY,XZ,XW,YZ,YW,XZ - they're oriented planes with an area.\n\n// You can get the components of the bivector by projecting it to all the planes in the basis.\n\n// In 3D, vectors (X,Y,Z) and bivectors (YZ,ZX,XY) are dual, so they're usually unified -\n// with some caveats like different transformation rules (because bivectors transform like planes, not lines).\n// When unified this way, the wedge product becomes the cross product.\n// (But we can do that only in 3D.)\n\nstruct bivec3 { float yz,zx,xy; };           // chosen so that the dual is x,y,z\nstruct bivec4 { float xy,xz,xw,yz,yw,zw; };  // lexicographic\n\n\n// Bivectors can be created from two vectors - sides of the parallelogram - with the exterior product.\n// It's also called the \"wedge product\" because it's written B = a∧b or B = a^b.\n\n// In 2D there's only one possible plane orientation (XY), so I'll just make it a float.\n// The value is the signed area of the parallelogram with the sides \"a\" and \"b\".\nfloat wedge(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; }\n\n// Wedge product in 4D.\nbivec4 wedge(vec4 a, vec4 b) {\n  return bivec4(wedge(a.xy,b.xy),\n                wedge(a.xz,b.xz),\n                wedge(a.xw,b.xw),\n                wedge(a.yz,b.yz),\n                wedge(a.yw,b.yw),\n                wedge(a.zw,b.zw));\n}\n\n// Scalar product of two bivectors. Intuitively, \"how much they have in common\".\n// Used for projection.\nfloat Dot(bivec4 A, bivec4 B) { return -A.xy*B.xy - A.xz*B.xz - A.xw*B.xw - A.yz*B.yz - A.yw*B.yw - A.zw*B.zw; }\n\n// Normalize a bivector so that its area is 1.\nbivec3 Normalize(bivec3 B) { vec3 r = normalize(vec3(B.yz,B.zx,B.xy)); return bivec3(r.x,r.y,r.z); }\n\n// Wedging can be continued.\n// Trivectors encode the orientation and volume of a 3D parallelepiped (skewed prism) in n-D space.\n// \"a^B\" is what you get when you make a stroke with the parallelogram brush \"B\" along the length of vector \"a\".\n\n// In 3D there's only one possible trivector orientation, so I'll just make it a float again.\nfloat wedge(vec3 a, bivec3 B) { return dot(a, vec3(B.yz,B.zx,B.xy)); }\n\n\n// Orthonormal 4D basis.\nvec4 X,Y,Z,W;\nbivec4 YZ,ZX,XY;  // There are six planes in the basis, but we'll only need these three.\n\n// Project a vector|bivector onto the PQ plane or onto the XYZ space.\n// Assume the basis is orthogonal and normalized. We don't want to get too familiar with dual bases.\nvec2 proj2(vec4 v, vec4 P, vec4 Q) { return vec2(dot(v,P), dot(v,Q)); }\nvec3 proj3(vec4 v) { return vec3(dot(v,X), dot(v,Y), dot(v,Z)); }\nbivec3 proj3(bivec4 B) { return bivec3(Dot(B,YZ), Dot(B,ZX), Dot(B,XY)); }\n\n// Project a 4D cube to a 2D plane PQ.\n// For each edge orientation X,Y,Z,W, return a negative number when \"u\" is inside the corresponding band.\nvec4 cube4to2(vec2 u, vec4 P, vec4 Q) {\n  // Project edge directions.\n  // (We actually want to project their duals (1-forms),\n  //  but we can handwave it a little since everything is orthogonal and we don't care about lengths.)\n  vec2 dx = proj2(vec4(1,0,0,0), P,Q);\n  vec2 dy = proj2(vec4(0,1,0,0), P,Q);\n  vec2 dz = proj2(vec4(0,0,1,0), P,Q);\n  vec2 dw = proj2(vec4(0,0,0,1), P,Q);\n\n  // Compute projected band widths.\n  // For each orientation, find the edge with this orientation that is furthest from the origin.\n  // (Each orientation corresponds to 8 edges, but we can test only 4 because of symmetry.)\n  // I project the center of each edge, but any point on the edge would do.\n  float bx = 0.;\n  float by = 0.;\n  float bz = 0.;\n  float bw = 0.;\n  for (int i=-1; i<=1; i+=2) for (int j=-1; j<=1; j+=2) {\n    bx = max(bx, abs(wedge(proj2(vec4(0,i,j,1), P,Q), dx)));\n    by = max(by, abs(wedge(proj2(vec4(i,0,j,1), P,Q), dy)));\n    bz = max(bz, abs(wedge(proj2(vec4(i,j,0,1), P,Q), dz)));\n    bw = max(bw, abs(wedge(proj2(vec4(i,j,1,0), P,Q), dw)));\n  }\n  \n  // Test if we're inside the band corresponding to the projected edge directions.\n  return vec4(abs(wedge(u,dx)) - bx,\n              abs(wedge(u,dy)) - by,\n              abs(wedge(u,dz)) - bz,\n              abs(wedge(u,dw)) - bw);\n}\n\n\n// Project a 4D cube to the 3D space XYZ.\n// For each face orientation XY,XZ,XW,YZ,YW,ZW, return a negative number when \"u\" is inside the corresponding band.\nbivec4 cube4to3(vec3 u) {\n  // Project face orientations.\n  // Normalize them since we want to use them in a distance function.\n  bivec3 dxy = Normalize(proj3(bivec4(1.,0.,0.,0.,0.,0.)));\n  bivec3 dxz = Normalize(proj3(bivec4(0.,1.,0.,0.,0.,0.)));\n  bivec3 dxw = Normalize(proj3(bivec4(0.,0.,1.,0.,0.,0.)));\n  bivec3 dyz = Normalize(proj3(bivec4(0.,0.,0.,1.,0.,0.)));\n  bivec3 dyw = Normalize(proj3(bivec4(0.,0.,0.,0.,1.,0.)));\n  bivec3 dzw = Normalize(proj3(bivec4(0.,0.,0.,0.,0.,1.)));\n\n  // Compute projected band widths.\n  // For each orientation, find the face with this orientation that is furthest from the origin.\n  // (Each orientation corresponds to 4 face, but we can test only 2 because of symmetry.)\n  // I project the center of each face, but any point on the face would do.\n  float bxy = 0.;\n  float bxz = 0.;\n  float bxw = 0.;\n  float byz = 0.;\n  float byw = 0.;\n  float bzw = 0.;\n  for (int i=-1; i<=1; i+=2) {\n    bxy = max(bxy, abs(wedge(proj3(vec4(0,0,i,1)), dxy)));\n    bxz = max(bxz, abs(wedge(proj3(vec4(0,i,0,1)), dxz)));\n    bxw = max(bxw, abs(wedge(proj3(vec4(0,i,1,0)), dxw)));\n    byz = max(byz, abs(wedge(proj3(vec4(i,0,0,1)), dyz)));\n    byw = max(byw, abs(wedge(proj3(vec4(i,0,1,0)), dyw)));\n    bzw = max(bzw, abs(wedge(proj3(vec4(i,1,0,0)), dzw)));\n  }\n  \n  // Test if we're inside the band corresponding to the projected face orientations.\n  return bivec4(abs(wedge(u,dxy)) - bxy,\n                abs(wedge(u,dxz)) - bxz,\n                abs(wedge(u,dxw)) - bxw,\n                abs(wedge(u,dyz)) - byz,\n                abs(wedge(u,dyw)) - byw,\n                abs(wedge(u,dzw)) - bzw);\n}\n\n// Signed distance function of the 3D projection of the 4D cube.\nfloat f(vec3 p) {\n  bivec4 B = cube4to3(p);\n  return max(max(max(max(max(B.xy,B.xz),B.xw),B.yz),B.yw),B.zw);\n}\n\n\n\n// Sort two values in place: [a, b] = [min(a,b), max(a,b)]\nvoid sort(inout float a, inout float b) {\n  float tmp = min(a,b); b = max(a,b); a = tmp;\n}\n\n// Intersect a ray and the 4D cube projected to 3D.\n// If there was a hit, return true and fill the entry|exit position\n// and entry|exit face orientation (= unnormalized normal).\nbool ray_cube4to3(vec3 o,vec3 d, out vec3 p0, out vec3 p1, out bivec3 n0, out bivec3 n1) {\n  // Project face orientations.\n  bivec3 dxy = proj3(bivec4(1.,0.,0.,0.,0.,0.));\n  bivec3 dxz = proj3(bivec4(0.,1.,0.,0.,0.,0.));\n  bivec3 dxw = proj3(bivec4(0.,0.,1.,0.,0.,0.));\n  bivec3 dyz = proj3(bivec4(0.,0.,0.,1.,0.,0.));\n  bivec3 dyw = proj3(bivec4(0.,0.,0.,0.,1.,0.));\n  bivec3 dzw = proj3(bivec4(0.,0.,0.,0.,0.,1.));\n\n  // Compute projected band widths.\n  float bxy = 0.;\n  float bxz = 0.;\n  float bxw = 0.;\n  float byz = 0.;\n  float byw = 0.;\n  float bzw = 0.;\n  for (int i=-1; i<=1; i+=2) {\n    bxy = max(bxy, abs(wedge(proj3(vec4(0,0,i,1)), dxy)));\n    bxz = max(bxz, abs(wedge(proj3(vec4(0,i,0,1)), dxz)));\n    bxw = max(bxw, abs(wedge(proj3(vec4(0,i,1,0)), dxw)));\n    byz = max(byz, abs(wedge(proj3(vec4(i,0,0,1)), dyz)));\n    byw = max(byw, abs(wedge(proj3(vec4(i,0,1,0)), dyw)));\n    bzw = max(bzw, abs(wedge(proj3(vec4(i,1,0,0)), dzw)));\n  }\n  \n  // Try to hit the intersection of all six bands.\n  // The bands are convex, so a ray-band intersection is an interval [t0, t1] and we just intersect all the intervals.\n  //   Ray:  v = o + d*t; t>0  // assume t>0\n  //   Band: abs(v^D) < B      // D = plane bivector (dual of the normal), B = band width\n  //         (o + d*t)^D = ±B\n  //         o^D + d^D * t = ±B\n  //         [t0, t1] = [min, max] of (±B - o^D) / d^D\n  float t0_max = -100., t1_min = 100.;\n  float t0, t1;\n  float den;\n\n  n0 = n1 = bivec3(0.,0.,1.);  // init normals to be sure\n  const float EPS = 1e-6;\n  \n  den = wedge(d, dxy);\n  if (abs(den) > EPS) {  // If the face is \"too perpendicular\" to the projection plane, just ignore it.\n    t0 = (bxy - wedge(o, dxy)) / den;\n    t1 = (-bxy - wedge(o, dxy)) / den;\n    sort(t0, t1);\n    if (t0 > t0_max) { t0_max = t0; n0 = dxy; }  // update entry point|normal?\n    if (t1 < t1_min) { t1_min = t1; n1 = dxy; }  // update exit point|normal?\n  }\n  // All six bands are done this way.\n  den = wedge(d,dxz); if (abs(den) > EPS) { t0 = (bxz - wedge(o,dxz)) / den; t1 = (-bxz - wedge(o,dxz)) / den; sort(t0,t1); if (t0>t0_max) { t0_max = t0; n0 = dxz; } if (t1<t1_min) { t1_min = t1; n1 = dxz; } }\n  den = wedge(d,dxw); if (abs(den) > EPS) { t0 = (bxw - wedge(o,dxw)) / den; t1 = (-bxw - wedge(o,dxw)) / den; sort(t0,t1); if (t0>t0_max) { t0_max = t0; n0 = dxw; } if (t1<t1_min) { t1_min = t1; n1 = dxw; } }\n  den = wedge(d,dyz); if (abs(den) > EPS) { t0 = (byz - wedge(o,dyz)) / den; t1 = (-byz - wedge(o,dyz)) / den; sort(t0,t1); if (t0>t0_max) { t0_max = t0; n0 = dyz; } if (t1<t1_min) { t1_min = t1; n1 = dyz; } }\n  den = wedge(d,dyw); if (abs(den) > EPS) { t0 = (byw - wedge(o,dyw)) / den; t1 = (-byw - wedge(o,dyw)) / den; sort(t0,t1); if (t0>t0_max) { t0_max = t0; n0 = dyw; } if (t1<t1_min) { t1_min = t1; n1 = dyw; } }\n  den = wedge(d,dzw); if (abs(den) > EPS) { t0 = (bzw - wedge(o,dzw)) / den; t1 = (-bzw - wedge(o,dzw)) / den; sort(t0,t1); if (t0>t0_max) { t0_max = t0; n0 = dzw; } if (t1<t1_min) { t1_min = t1; n1 = dzw; } }\n  \n  // If all the intervals overlap, we have a hit.\n  p0 = o + d*t0_max;\n  p1 = o + d*t1_min;\n  if (wedge(d,n0) > 0.) { n0.yz = -n0.yz; n0.zx = -n0.zx; n0.xy = -n0.xy; }  // reorient the normals towards us\n  if (wedge(d,n1) > 0.) { n1.yz = -n1.yz; n1.zx = -n1.zx; n1.xy = -n1.xy; }\n  return t0_max < t1_min;\n}\n\n\n// Hit the three background planes. Draw a 2D projection of the 4D cube on them (with the bands).\nvec3 background(vec3 O, vec3 d) {\n  // Band colors.\n  const vec3 cX = vec3(.5,.1,0),\n             cY = vec3(.2,.3,0),\n             cZ = vec3(0,.3,.2),\n             cW = vec3(0,.1,.5);\n\n  vec4 P, Q;  // projection directions\n\n  // Intersect with the YZ, ZX and XY planes.\n  float t, t_min = 1e5;\n  vec2 u;     // 2D coordinates on the plane\n  vec2 dist;  // distances to the other planes\n  t = (-4. - O.x) / d.x; if (t>0. && t<t_min) { t_min = t; u = (O + t*d).yz; P = Y; Q = Z; dist = vec2(-u.x, u.y)+4.; }\n  t = ( 4. - O.y) / d.y; if (t>0. && t<t_min) { t_min = t; u = (O + t*d).zx; P = Z; Q = X; dist = vec2( u.x, u.y)+4.; }\n  t = (-4. - O.z) / d.z; if (t>0. && t<t_min) { t_min = t; u = (O + t*d).xy; P = X; Q = Y; dist = vec2( u.x,-u.y)+4.; }\n  \n  if (t_min > 400.) return vec3(6);  // bright light behind the camera\n\n  // approximate ambient occlusion\n  dist = .5 + .5 * (dist / (dist + 1.));\n  float ao = dist.x * dist.y;\n  \n  // draw the four bands: bands that are \"more perpendicular\" to the projection plane are smeared out more\n  vec4 c = cube4to2(u, P,Q);\n  c = smoothstep(-0.03, 0.03, c);\n\n  // also draw the projected cube vertices as bright dots\n  float D = 10.;\n  for (int x=-1; x<=1; x+=2) for (int y=-1; y<=1; y+=2) for (int z=-1; z<=1; z+=2) for (int w=-1; w<=1; w+=2) {\n    vec2 p = proj2(vec4(x,y,z,w), P,Q);\n    D = min(D, distance(p,u));\n  }\n\n  return mix(ao * max(vec3(smoothstep(.08,.04,D)),  // vertices\n                      vec3(.1,0,.1) + c.x*cX + c.y*cY + c.z*cZ + c.w*cW),  // bands\n             vec3(6),  // bright light behind the camera\n             smoothstep(0.,400.,t_min));  // blend\n}\n\n// Accumulate bounces inside the 4D cube projected to 3D.\nvec3 bounce_inside(vec3 p, vec3 d) {\n  vec3 p0,p1;\n  bivec3 N0,N1;\n  vec3 C = vec3(0);    // accumulated light\n  vec3 mul = vec3(1);  // multiplier\n  for (int i=0; i<BOUNCES; i++) {\n    ray_cube4to3(p,d, p0,p1,N0,N1);\n    vec3 beer = exp(-ABSORB * distance(p, p1));   // absorption: Beer's law\n    p = p1;                                       // exit point\n    vec3 n = normalize(vec3(N1.yz,N1.zx,N1.xy));  // exit normal\n    float c = -dot(d,n);                  // cos(θ_i)\n    float sin2_t = (IOR*IOR)*(1.-c*c);    // sin²(θ_t)\n    if (sin2_t < 1.) {  // sin²(θ_t) > 1 is total internal reflection: R = 1, no refraction\n      float cos_t = sqrt(abs(1. - sin2_t));    // cos(θ_t)\n\n      float k = 1. - cos_t;               // 1 - cos(θ_t)\n      float R0 = (IOR-1.) / (IOR+1.); R0 *= R0;\n      float R = R0 + (1.-R0) * k*k*k*k*k; // reflection coefficient (Schlick's approximation)\n\n      C += beer * mul * (1.-R) * background(p, IOR * d + (IOR*c - cos_t) * n);  // refract to the outside\n      mul *= R;\n    }\n    mul *= beer;\n    d += 2.*c*n;  // reflect inside the gem\n  }\n  return C + mul;\n}\n\n\nvoid mainImage(out vec4 o, vec2 x) {\n  // rotate the 4D basis\n  {\n    float a = iTime*.2500; mat2 Ra = mat2(cos(a),-sin(a), sin(a),cos(a));\n    float b = iTime*.3090; mat2 Rb = mat2(cos(b),-sin(b), sin(b),cos(b));\n    float c = iTime*.3535; mat2 Rc = mat2(cos(c),-sin(c), sin(c),cos(c));\n    float d = iTime*.4571; mat2 Rd = mat2(cos(d),-sin(d), sin(d),cos(d));\n    X = vec4(1,0,0,0); X.yz *= Ra; X.wx *= Rb; X.zw *= Rc; X.xy *= Rd; X.wy *= Rb; X.zx *= Rc; \n    Y = vec4(0,1,0,0); Y.yz *= Ra; Y.wx *= Rb; Y.zw *= Rc; Y.xy *= Rd; Y.wy *= Rb; Y.zx *= Rc; \n    Z = vec4(0,0,1,0); Z.yz *= Ra; Z.wx *= Rb; Z.zw *= Rc; Z.xy *= Rd; Z.wy *= Rb; Z.zx *= Rc; \n    W = vec4(0,0,0,1); W.yz *= Ra; W.wx *= Rb; W.zw *= Rc; W.xy *= Rd; W.wy *= Rb; W.zx *= Rc; \n\n    // compute also the part of the 4D bivector basis\n    YZ = wedge(Y,Z);\n    ZX = wedge(Z,X);\n    XY = wedge(X,Y);\n  }\n\n  // screen coordinates: y is -1..1.\n  vec2 r = iResolution.xy, screen = (x+x-r)/r.y;\n\n  // camera position and ray direction (Y is forward and Z is up just to mess with you).\n  vec3 O = vec3(6, -6, 4);\n  { float a = iTime*.5; O.x += .5*cos(a); O.y += .5*sin(a); }  // subtly move the camera\n  vec3 p = O;\n  vec3 d = normalize(vec3(screen.x, 2, screen.y));\n  float vignette = 2.*d.y*d.y*d.y*d.y;  // compute vignetting before camera rotation (natural: cos⁴(θ))\n  { float a = radians(30.); d.yz = mat2(cos(a),-sin(a), sin(a),cos(a)) * d.yz; }  // rotate camera down 30°\n  { float a = radians(-45.); d.xy = mat2(cos(a),-sin(a), sin(a),cos(a)) * d.xy; }  // rotate camera left 45°\n  \n  #if RENDERING_METHOD == RAYCAST\n    float L;\n    for (int i=0; i<80; i++) {\n      L = f(p);\n      p += L*d;\n      if (L<1e-5 || L>12.) break;  // bailout if close enough or too far\n    }\n    bool hit3d = (L < .1);\n    vec3 n;\n    if (hit3d) {\n      // estimate the normal: tetrahedron technique from https://iquilezles.org/articles/normalsSDF/\n      vec2 J = vec2(1,-1), e = 1e-4*J;\n      n = normalize(J.xxx*f(p+e.xxx) + J.xyy*f(p+e.xyy) + J.yxy*f(p+e.yxy) + J.yyx*f(p+e.yyx));\n    }\n  \n    vec3 C;\n    if (hit3d) {  // the 3D projection was hit\n      float c = -dot(d,n);  // cos(θ_i)\n      float k = 1.-c;       // 1 - cos(θ_i);\n      float R0 = (1.-IOR) / (1.+IOR); R0 *= R0;\n      float R = R0 + (1.-R0) * k*k*k*k*k;  // reflection coefficient (Schlick's approximation)\n      vec3 dif = vec3(.2,0,.6) * max(0., n.z);\n      vec3 spe = vec3(.6,.4,.2) * pow(max(0., n.z), 4.);\n      C = dif + spe + R*background(p, d + 2.*c*n);\n    }\n    else {\n      C = background(O, d);\n    }\n  #elif RENDERING_METHOD == RAYTRACE\n    bivec3 N0,N1;\n    vec3 p0,p1;\n    \n    vec3 C;\n    if (ray_cube4to3(p,d, p0,p1,N0,N1)) {  // the 3D projection was hit\n      p = p0;                                       // entry point\n      vec3 n = normalize(vec3(N0.yz,N0.zx,N0.xy));  // entry normal\n      float c = -dot(d,n);                   // cos(θ_i)\n      float sin2_t = 1./(IOR*IOR)*(1.-c*c);  // sin²(θ_t)\n      float cos_t = sqrt(1. - sin2_t);       // cos(θ_t)\n\n      float k = 1. - c;                      // 1 - cos(θ_i);\n      float R0 = (1.-IOR) / (1.+IOR); R0 *= R0;\n      float R = R0 + (1.-R0) * k*k*k*k*k;  // reflection coefficient (Schlick's approximation)\n\n      C = R * background(p, d + 2.*c*n)  // reflect to the background\n        + (1.-R) * bounce_inside(p, 1./IOR * d + (1./IOR*c - cos_t) * n);  // refract to the inside of the gem\n    }\n    else {\n      C = background(O, d);\n    }\n  #endif\n\n  o = vec4(sqrt(C * vignette), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}