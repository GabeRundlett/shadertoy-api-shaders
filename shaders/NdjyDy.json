{
    "Shader": {
        "info": {
            "date": "1696750979",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "NdjyDy",
            "likes": 5,
            "name": "spqr decal tangled",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 159
        },
        "renderpass": [
            {
                "code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the  and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat pi = 3.141592;\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\n\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\nfloat cube( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\nfloat m1(vec3 uv, vec3 d, float f1) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv.xz *= rot(i * a * 2.);\n   \n    uv = abs(uv); \n    uv -= vec3(2.,4.1,7.3);\n    uv = -abs(uv);\n   \n    float f2 = 1.;//f1 * 2.;\n    float x1 =  cube(uv.xz , vec2(1,1));\n    float x2 =  cube(uv.xz + vec2(2,11)+f2, vec2(1.,5.));\n    float x3 =  cube(uv.xz + vec2(14,14)-f2, vec2(.2,53.));\n    vec2  q  =    replim(uv.xz, 10., vec2(11,2));\n    float x4 =  cube(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n/*\nfloat hash31(vec3 p)\n{   \n  \n\tvec3 p3  = fract(vec3(p.xyx) * 223.531);\n    p3 += dot(p3, p3.yzx + 313.153);\n    return fract((p3.x + p3.y) * p3.z);\n}\n*/\n\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nfloat a = 3.141592;\n\n\nfloat m2(vec3 uv, vec3 d, float f1) {\n\n  \n \n  \n  float q = 1.21;\n  \n  float z = 10000.;\n  vec3 off = vec3(58.,0.,20.);\n  for (float i = 0.; i <5.; i++) {\n    off.xz *= rot(i/(4.));\n   \n    uv.xz *= q + (f1/10.) * 3.14 ;\n    \n   \n    \n    uv.xz *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off, d, f1 );\n    z = min(z,a1);\n  \n  }\n \n  return z;\n}\n\nfloat decal(vec3 p,vec3 d) {\n \n   vec3 id = floor(p / d);\n   p =  mod(p,d) - p/2.;\n   float f1 = hash31(id);\n\n\n  return m2(p,d,f1);\n\n}\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nint matter = 0;\n// ddd\nvec3 domain = vec3(100, 10., 100);\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\nfloat hash21(vec2 p) {\n    float a = sin(p.x*1831.424)*9918.3232;\n    float b = sin(p.y*4254.001)*7742.4342;\n\n    float d = fract(a+b);\n    float e = sin(d * 4225.2421) * 9003.131;\n    return fract(e);\n\n}\n\nfloat box(vec3 p, float w, float h) {\n\n  vec3 b = vec3(w,w,h);\n  vec3 q = abs(p) - b;\n  return max(q.x,max(q.y,q.z)) ;\n\n}\n\nfloat spires(vec3 p) {\n\n  \n\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n   \n    vec2 dom = vec2(1.);\n     \n      \n    vec2 id = floor(p.yx/dom);\n    float f1 = hash21(id);\n    \n\n    float widthlimit = .4;\n    float heightlimit = 200.;\n    \n  \n    float factor = f1;\n\n    factor = 1. - f1;\n    factor = pow(factor,.8);\n  \n    \n    //float me   = cyl(p - vec3(center, 0),    widthlimit, heightlimit * pow(f1,5.) );\n    //float next = cyl(p - vec3(neighbour, 0), widthlimit, heightlimit );\n    \n    float me   = box(p - vec3(center, 0),    widthlimit, heightlimit * factor) ;\n    float next = box(p - vec3(neighbour, 0), widthlimit, heightlimit);\n    return min(me, next);\n}\nfloat box3d( vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return max(max(p.x,p.y),p.z);\n}\nfloat map(vec3 p) {\n\n// geo\n  \n  //p.xz = abs(p.xz) - 10.;\n\n  p = mod(p, domain) - domain/2.;\n \n  float level = box3d(p, vec3(domain.x, .1, domain.z));\n  return level;\n  \n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  for (int z = 0; z < 1; z++) {\n    r = smoothstep(0.,1.,r);\n  }\n  \n  return i + r;\n}\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat hash11 (float t) {\n  return fract(sin(t * 4551.7749) * 3561.582);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float tt = iTime;\n  \n\n  // nav\n  vec3 s = lattice(tt     ) * 277.;\n  vec3 t = lattice(tt + 3.) * 122.;\n  //vec3 s = vec3(0,iTime * 40., 0.);\n  //vec3 t = s + vec3(0.4,1.0,0.4);\n\n\n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n \n  float mask=1.0;\n  float d = 0.;\n  float dd = 0.;\n  float rand=rnd(uv); \n  \n\n  // march\n  \n  bool hit = false;\n  float i;\n  for(float z=0.; z < 400.; ++z) {\n    i = z;\n    d=map(p);\n    \n   if(d<0.01) {\n   \n      float ii = decal(p, domain);\n      \n      if (ii >= 0.0) {\n          d=0.1;\n      } else {\n          hit = true;\n          break;\n      }\n    }\n    \n    if ( dd > 5000.) {\n      break;\n    }\n    \n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n  \n  vec3 col;\n  \n  \n  if (! hit ) {\n \n     col = vec3(.5);\n     \n  } else {\n\n     col = vec3(0);\n\n     float ii = decal(p, domain);\n  \n     if ( ii < 0.0) {\n          col = vec3(0);\n     }\n     if ( ii < -0.14) {\n        col = vec3(.8, .5, .2);\n     }\n\n\n    }\n    //vec3 fog = vec3(.5);\n    //col = mix(col, fog, exp(-.000003 * dd * dd * dd));\n  \n  \n    fragColor = vec4(col, 1);\n\n\n\n \n  \n}\n\n/*\n\n  \n     //vec3 light =normalize(vec3(4,12.,2.));\n     //light.xz *= rot(iTime);\n\n     //light = abs(light);\n  \n \n     //vec3 n = norm(p);\n  \n     //float diff = max(0.0,dot(n,light)*0.5+0.5);\n     //float fren = pow(1.+dot(n,r),2.);\n     //float sss = sss(p,r,4.) * 2.;\n     //float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n      //loat shad = shadow(p, normalize(-light), .1, length(light-p));\n     //float fog =  pow(i/1000.,2.);\n  \n   \n     //col -= diff  * .7;\n*/\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}