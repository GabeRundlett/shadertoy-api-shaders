{
    "Shader": {
        "info": {
            "date": "1571938426",
            "description": "Dizzy monster",
            "flags": 32,
            "hasliked": 0,
            "id": "WdcSWN",
            "likes": 9,
            "name": "Shadertober 24 Dizzy",
            "published": 3,
            "tags": [
                "raymarching",
                "texture",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 419
        },
        "renderpass": [
            {
                "code": "// SHADERTOBER 24 Dizzy\n// Poulet vert 24-10-2019\n// thanks iq, flopine, leon, everyone\n\n#define VOLUME 0.001\n#define PI 3.14159\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n\n// Scene setup\nvec2 map(vec3 pos)\n{\n    vec2 scene = vec2(0.0, 0.0);\n    \n    vec3 groundP = pos + vec3(0.0);\n    float ground = sdPlane(groundP, vec4(0.0, 2.0, 0.0, 1.0));\n    \n    vec3 sphereP = pos + vec3(1.0, 0.0, 0.0);\n    float sphere = sdSphere(sphereP, .5);\n    \n    sphereP = pos + vec3(0.5, -0.5, 0.);\n    sphere = opSmoothUnion(sphere, sdSphere(sphereP, .5), .2);\n    \n    sphereP = pos + vec3(0.0, -0.5, 0.);\n    sphere = opSmoothUnion(sphere, sdSphere(sphereP, .5), .1);\n    \n    sphereP = pos + vec3(-0.5, -0.5, 0.);\n    sphere = opSmoothUnion(sphere, sdSphere(sphereP, .5), .5);\n    \n    sphereP = pos + vec3(-0.5, 0.3, 0.5);\n    sphere = opSmoothUnion(sphere, sdSphere(sphereP, .2), .5);\n    \n    sphereP = pos + vec3(-0.5, 0.3, -0.5);\n    sphere = opSmoothUnion(sphere, sdSphere(sphereP, .2), .5);\n    \n    sphereP = pos + vec3(-1.0, -1.0+sin(iTime*10.)*.1, -0.0);\n    sphere = opSmoothUnion(sphere, sdSphere(sphereP, .5), .3);\n    \n    // materials\n    scene = vec2(ground, 0.0);\n    scene = opU2(scene, vec2(sphere, 1.0));\n    \n    return scene;\n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t).x;\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x) - c);\n}\n\nfloat GetLight(vec3 N, vec3 lightPos)\n{\n    return max(dot(N, normalize(lightPos)), 0.0);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(t.x+fract(iTime), vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    if(t.x == -1.0)\n    {\n        \n        col = vec3(0.0);\n        \n    }\n    else\n    {    \n        vec3 N = GetNormal(pos);\n        \n        vec3 mainL = vec3(-1.0, 2.0, -2.0);\n        float mainlight = GetLight(N, mainL);\n        \n        vec2 ledFreq = vec2(.15, .17);\n        vec2 ledUV =  vec2(-pos.x+5.08, -pos.y-.5);\n        \n        float shade = GetShadow(pos, mainL, 8.0);\n        vec3 texstuff = texture(iChannel0, fract(ledFreq * ledUV * length(ro * rd + t.x) + iTime)).rgb;\n        \n        if(t.y == 0.0)\n        {\n            col = vec3(.2) * shade * (-pos.z * .1 + .3);\n        }\n        else if(t.y == 1.0)\n        {\n            col = texstuff;\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime * .5;\n    \n    \n    vec3 cp = vec3(sin(time), 0.1, cos(time)) * 5.0;\n    vec3 ct = vec3(0.0, 0.5, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv);\n    \n    col = sqrt(clamp(col, 0.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// rainbow texture\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    float t = fract(screenUV.x + iTime);\n    vec3 col = palette(t, vec3(.5), vec3(.5), vec3(1.0), vec3(0.0, 0.33, 0.67));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}