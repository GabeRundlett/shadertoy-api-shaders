{
    "Shader": {
        "info": {
            "date": "1726581804",
            "description": "Combining raymarching and traversal methods to produce an extruded radial animation.",
            "flags": 32,
            "hasliked": 0,
            "id": "XXscRs",
            "likes": 89,
            "name": "Polar Grid Raymarch Traversal",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "bokeh",
                "geometry",
                "polar",
                "traversal"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1015
        },
        "renderpass": [
            {
                "code": "/*\n\n    Polar Grid Raymarch Traversal\n    -----------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n\n/*\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 1.5, coc = .7;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n*/\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's float to float hash. I've added an extra sine wrapping modulo to\n// cater for my annoying AMD based system, which can't wrap sine with a \n// proper degree of accuracy.\nfloat hash11B(float x){ return fract(sin(mod(x, 6.2831853))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a heap of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// If you're interested in bokeh, Dave's function above and some of Shadertoy user, \n// Hornet's, are probably the ones you should be looking at. Xor has some cool simple \n// ones on here too.\n//\nvec4 bokeh(sampler2D iCh, vec2 uv){\n\n\n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = sqrt(10.), coc = .8;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD) - coc;\n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 2.);\n    //float ra = smoothstep(.1, .9, abs(uv.y - .5)*2.)*2.;\n    //float ra = mix(clamp(l/coc, 0., 2.), smoothstep(.3, 1., abs(uv.y - .5)*2.), .25);\n    //float ra = (smoothstep(.2, 1., length(uv - .5)));\n\n    // Standard Fibonacci distribution calculations, compliments of Dave Hoskins.\n    const int iter = 96;\n    float rad = 1.6;//max(2.*ra, .5); // Bokeh radius.\n    float r = 1.;\n\tvec4 tot = vec4(0), div = tot;\n    vec2 vangle = vec2(0., rad*.01/sqrt(float(iter)));\n    #define GA 2.3999632 // Golden angle.\n    const mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n    // Aspect ratio.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    // Trying to reduce the sample spread at larger resolutions.\n    //if(iResolution.y>450.) aspect *= mix(iResolution.y, 450., .5)/iResolution.y;\n    \n    \n\tfor (int i = 0; i<iter; i++){\n        \n        #if 1\n        \n        // Dave Hoskin's Fibonacci based scattering. Cheaper and much nicer, so\n        // it's set as the default.\n        // The approx increase in the scale of sqrt(0, 1, 2, 3...).\n        r += 1./r;\n\t    vangle = rot*vangle;\n        vec4 col = texture(iCh, uv - (r - 1.)*vangle*aspect, iResolution.y/450.*1.5); \n        \n        #else\n        \n        // A hash based random distribution, for anyone who wants to try it.\n        //int ii = i%10; // For square bokeh.\n        //int jj = i/10;\n    \n        // Random offset contained within a disk or radius n.\n        float fi = float(i) + fract(iTime);\n        //vec2 fi = vec2(ii, jj) - 5. + fract(iTime);\n        vec2 rnd2 = vec2(hash11B(fi), hash11B(fi + .1)*6.2831);\n        vec2 offs = 6.*sqrt(rnd2.x)*vec2(cos(rnd2.y), sin(rnd2.y));\n        ////////\n        /*\n        // Polygons, if desired. Comment out the line above and comment in\n        // the \"rot2\" formula above, if using it.\n        const float N = 6.;\n        float ra = rnd2.y;\n        float a = (floor(ra*N) + .5)*6.2831859/N;\n        vec2 offs  = mix(rot2(a)*vec2(0, 1), rot2(a + 6.2831859/N)*vec2(0, 1), fract(ra*N));\n        offs *= 6.*sqrt(rnd2.x);\n        */\n        ////////\n        offs *= rad;\n        //offs = rad*(offs + (vec2(hash11B(fi), hash11B(fi + .21)) - .5));\n        vec4 col = texture(iCh, uv - offs/iResolution.xy, iResolution.y/450.*1.5);  \n  \n        #endif\n         \n        // Thanks to Dave for figuring out how to tweak the colors to produce brighter \n        // contrast. It's common sense... once someone figures it out for you. :D \n        vec4 bokeh = pow(col, vec4(4));\n\t\ttot += bokeh*col*col;\n\t\tdiv += bokeh;\n        \n\t}\n    \n    \n    // Mixing the original value with the bokeh tweaked value according\n    // to the depth of field.\n    vec4 colOrig = texture(iCh, uv);\n    // Not entirely correct, but no one will notice here. :)\n\treturn mix(colOrig, colOrig*.25 + tot/div*4., ra);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    vec4 col = bokeh(iChannel0, uv);\n\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Polar Grid Raymarch Traversal\n    -----------------------------\n    \n    I've been enjoying posting simple 2D shaders, but I figured it was probably \n    time to post something more technical. I enjoy coding 3D shaders, but groan at \n    the prospect of tidying up the code for presentation.\n    \n    This is a raymarched traversal of a polar grid. The polar grid traversal code\n    was written some time ago, so I've merely combined it with raymarching code in\n    order to benefit from soft shadows, and so forth. Polar grid traversal is \n    definitely not common, but not nonexistent -- Abje wrote one a few years ago...\n    and I'm willing to bet that he was able to do it far less time than it took \n    me. :) The link is below, for anyone interested.\n    \n    Most traversals -- and by most, I mean, virtually all -- involve cells \n    bordered by straight lines or planes. Polar traversals involve cells bordered\n    by the former with additional curved borders. Logistically speaking, it's not\n    much different; With a square grid, for example, you'll require four straight\n    line cell border intersections. However, an extruded polar cell traversal will \n    involve two straight line intersections and two circular intersections -- which\n    will be pretty simple for anyone with even a rudimentary raytracing knowledge.\n    \n    Anyway, the details are below. The code runs fine, but could benefit from some\n    streamlining to speed things up -- Apologies for anyone trying to run this on\n    a slower system. The comments were rushed, but I'll tidy them up in due course. \n    By the way, I'll post a 2D polar traversal to accompany this soon, for anyone \n    interested.\n    \n    \n    \n    \n    Similar examples:\n    \n    // Abje codes some really interesting examples, and he seems to \n    // code them up very quickly.\n    polar wave - abje\n    https://www.shadertoy.com/view/wsSSWR\n\n*/\n\n// Infuse some color.\n#define ADD_COLOR\n\n \n// Maximum ray distance.\n#define FAR  20.\n\n\n// Light type: Point: 0, Direct: 1\n#define LIGHT_TYPE 0\n\n\n// Bore out some holes.\n#define HOLES\n\n//////////////\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n \n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.xz).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1664525U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;   \n     \n}\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    // Texture height value.\n    vec3 tx = texture(iChannel1, p).xyz; tx *= tx;\n    \n    return dot(tx, vec3(.299, .587, .114));\n}\n\n// Two value sign function.\n//vec2 sign2(in vec2 p){ return vec2(p.x<0.? -1 : 1, p.y<0.? -1 : 1); }\n \n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return max(dot(p - ro, n), 0.)/max(dot(rd, n), 1e-8);\n   float dn = dot(p - ro, n)/dot(rd, n);\n   return dn<0.? 1e8 : dn;   \n\n} \n\n\n// IQ's circle intersect function: I have my own, but IQ's functions are \n// known to people, and tend to be more reliable. I can't remember the \n// exact example that I referred to, but IQ's nicely presented shader,\n// here, will give you the general idea:\n//\n// Complex Intersection Points - iq\n// https://www.shadertoy.com/view/Dt3SDH\n//\n// I've substituted in a lot of comments, for anyone interested.\nfloat circleIntersect(in vec2 ro, in vec2 rd, in vec2 ce, float ra){\n\n    // Standard quadratic solution to the ray circle intersection.\n    // Ie. Solving the circle equation, \"x*x + y*y - ra*ra = 0\", where\n    // \"x = (ro - ce).x + rd.x*t\", and \"y = (ro - ce).y + rd.y*t\". \n    // Substituting produces a quadratic that can be solved for \"t\". \n    \n    vec2 oc = ro - ce; \n    float b = dot(oc, rd);\n    vec2 qc = oc - b*rd;\n    float h = ra*ra - dot(qc, qc); // Squared discriminant: b*b - 4*a*c.\n    \n    // No real roots, so no intersection... Not on the real plane, anyway.\n    if(h<0.) return 1e8; //if(b<0. || h<0.)\n    \n    // Interpreting the results, below:\n    //\n    // Real roots, so there are, at most, two solutions -- In the rare case of \n    // the direction ray running perpendicular to the circle normal at the hit\n    // point, there'd be two equal values (so techniqally, one solution), but \n    // it shouldn't affect the following logic.\n    \n    // If the second (larger value) is negative, then it follows that both values \n    // will be negative, so there'll be no intersection points.\n    \n    // If the second value is positive, but the first value is negative, then\n    // we're inside the circle, so we'll need the positive distance in front of us.\n    // Ie. The second value.\n    \n    // If both values are positive, then we're outside the circle, so we'll need the\n    // lesser distance, or the first one.\n    \n    h = sqrt(h);\n    \n    // Two real roots. Return the correct one based on the above information.\n    vec2 pI = vec2(-b - h, -b + h); \n    \n    return pI.y<0.? 1e8 : pI.x<0.? pI.y : pI.x;\n\n}\n\n\n// Global ring rotation matrix.\nmat2 gRot;\n\n// Number of cells.\nconst float rSpacing = 1./3.;\n\n\n// The polar grid.\nvec4 getGrid(inout vec2 p){\n\n    // Radial ID.\n    float iR = floor((length(p) + rSpacing/2.)/rSpacing);\n    // Number of segments per ring -- Roughly equal size chunks whilst \n    // maintaining some radial balance.\n    float aNum = max(floor(iR*3.), 1.);//6.2831*\n    \n    //if(iR>0.) aNum = max(aNum, 2.);\n\n\n     // More mechanical rotation.\n     float angT2 = cos(32./(iR + 1.)/1. + iTime + iR);\n     angT2 = smoothstep(-.4, .4, angT2)/1.5;\n     gRot = rot2(angT2);\n     // More fluid rotation.\n     //float angT = sin(32./(iR + 1.)/1. + iTime)/4.;\n     //gRot = rot2(angT);\n     p = gRot*p;\n\t\n    // Polar angle.\n    // Note: If using IDs, \"mod(atan(p.y, p.x), 6.2831)\" might be necessary.\n    float a = mod(atan(p.y, p.x), TAU);\n    \n\n    // Partitioning the angle into \"aNum\" cells.\n    float ia = mod(floor(a/TAU*aNum), aNum); // Modulo not always needed.\n    \n    // Radial ID, angular ID, angle, number of angular segments per ring.\n    return vec4(iR, ia, a, aNum);\n}\n \n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// ID and local XY coordinates.\n\nvec3 gP;\nvec4 gID;\n\n\n\nfloat map(vec3 q3) {\n\n    // Floor. Redundant here.\n    float fl = q3.y + .5;\n\n\n    //vec3 sc = GSCALE; // Scale.\n    // Local coordinates and cell ID.\n    vec2 p = q3.xz;//p4.xy;\n    vec4 d4 = getGrid(p); \n    //vec2 id = d4.xy;\n\n    float iR = d4.x;\n    float ia = d4.y;\n    float a = d4.z;\n    float aNum = d4.w;\n    float iaF = (ia + .5)/aNum*TAU;\n\n    vec2 pO = p;\n\n\n ////////////\n \n    // The minimum distance from the current position in the direction\n    // of the normalized XZ plane unit ray to the polar cell wall. There\n    // are four cell walls to check: The two straight edge sides and the\n    // the two inner and outer circular boundaries.\n    \n    // Cell radius.\n    float r = (iR + .5)*rSpacing;  \n\n    vec2 rdXZ = normalize(gRd.xz); // 2D XZ plane ray normal.\n    // Larger ring radius ray intersection.\n    float t1 = circleIntersect(q3.xz, rdXZ, vec2(0), r);\n    // Larger outer radius distance.\n    //float t1 = pI.y<0.? 1e8 : pI.x<0.? pI.y : pI.x;\n\n    // Smaller inner radius ray intersection.\n    r -= rSpacing;\n    float t2 = circleIntersect(q3.xz, rdXZ, vec2(0), r);\n    // Smaller inner radius distance.\n    //float t2 = pI.y<0.? 1e8 : pI.x<0.? pI.y : pI.x;\n\n    // Take the minimum.\n    float t = min(t1, t2);\n\n    // The edges of each segmented rings are the following:\n    // vec2 edgeLeft = r2(PI/aNum - iaF)*vec2(0, 1);\n    // vec2 edgeRight = r2(-PI/aNum - iaF)*vec2(0, 1);\n    // The inward-faceing normals to the edges are:\n    // vec2 normalLeft = normalize(edgeLeft*vec2(1, -1));\n    // vec2 normalRight = -normalize(edgeRight*vec2(1, -1));\n    //\n    // The following is just a way way to calculate the above.\n    vec2 n1 = vec2(sin(iaF - PI/aNum), -cos(-iaF + PI/aNum))/sqrt(2.);\n\n    // The rings, and as such, ring segments are rotated over time with individual \n    // rotation matrices, (gRot) so the normals need to be rotated accordingly.\n    n1 *= gRot; // Or, \"n1 = inverse(gRot)*n1;\".\n\n    // The two segment edge intersections. You could combine these, to save a few\n    // calculations, but this reads better. In instances where you're traversing a\n    // nonsegmented (single) ring, these calculations aren't necessary. In this \n    // example, the middle circle doesn't need side segment intersections, but\n    // we're doing them anyway to save on GPU nesting, branching, etc... which is\n    // not important here, but would be when traversing in 3D.\n    float t3 = rayLine(q3.xz, gRd.xz, vec2(0), n1);\n    float t4 = rayLine(q3.xz, gRd.xz, vec2(0), -rot2(TAU/aNum)*n1);\n    // The two segment edge distances.\n    t3 = t3<0.? 1e8 : t3;\n    t4 = t4<0.? 1e8 : t4;\n    \n    // Take the minimum of all distances, but only if the ring has been segmented.\n    if(d4.w>1.) t = min(t, min(t3, t4)); // Only segmented rings. Not single ones.\n    //t = max(t, 0.); \n    \n    // Minimum boundary wall distance.\n    gCD = t + .0015;\n\n////////////\n   \n   \n    // The extruded block height. See the height map function, above.\n    const float txSc = 5.;\n    vec2 rCoord = vec2(iResolution.y/iResolution.x, 1)*\n                  iR*rSpacing*vec2(cos(iaF), sin(iaF))/txSc + .5;\n   \n    // Block height.\n    float h = hm(rCoord)*2.;\n    // Adding some subtle randomized animation to break things up a bit.\n    //h += (sin(hash21(vec2(ia, iR) + .05)*TAU + iTime)*.5 + .5)*.3;\n \n   \n    // Radial coordinate.\n    r = length(p); \n    \n    // Repetition via polar coordinates. It repeats object as required, but warps \n    // space in the process. Sometimes, this is preferable, but not in this case.\n    //p = vec2(length(p), mod(a, TAU/aNum) - TAU/aNum/2.);\n    \n    // Converting the radial centers to their positions.\n    p *= rot2(iaF);\n    // The line above is equivalent to:\n    //p = vec2(p.x*cos(ia) + p.y*sin(ia), p.y*cos(ia) - p.x*sin(ia));\n   \n  \n    \n    // Setting the radial distance.\n    // Moving the points out a bit along the radial line. If you didn't perform this,\n    // all objects would be superimposed on one another in the center.\n    p.x = mod(r - rSpacing/2., rSpacing) - rSpacing/2.; // Radial repetition.\n     \n    // The radial distance field. For continuous rings with no segments, this would\n    // be all you'd need.\n    float d2 = abs(p.x) - rSpacing/2.;\n    \n    // Rings, not including the central circle.\n    if(aNum > 1.){\n       // We only need to segment piecewise annuli, not\n       // those with a single piece running the entire\n       // circumference.\n       \n       vec2 pR = rot2(-(iaF - (PI/aNum)))*pO;\n       vec2 pR2 = rot2(-(iaF + (PI/aNum)))*pO;\n      \n        d2 = smax(d2, max(-pR.y, pR2.y), .04);\n\n    }\n    \n    // The central circle.\n    if(iR==0.){\n       // The inner circle is handled differently. Basically, we just want\n       // a regular circle with regular coordinates.\n       p = pO;\n       d2 = length(p) - rSpacing/2.;\n       \n       //p.x = mod(p.x - rSpacing/2., rSpacing) - rSpacing/2.;\n       //d = abs(length(p) - (iR)*rSpacing) - rSpacing/2.;\n    }\n    \n    // Move the distance field cell walls in a little.\n    d2 += .005;\n    \n    // Random block holes. \n    #ifdef HOLES\n    if(hash21(rCoord)<.5) d2 = max(d2, -(d2 + rSpacing/2.4)); //if(sc.x>1./16.) \n    #endif\n    \n    // Creating the extruded prisms.\n    float d = opExtrusion(d2, q3.y - h/2., h/2., 0.);\n    //d -= -d2*.25; \n    d -= min(-d2, .045)*.35;// \n    \n    // Ridges.\n    d -= (smoothstep(-.01, .01, abs(d2 + .045) - .01) - .5)*.0075;\n    //d -= abs(fract(d2/rSpacing*6.) - .5)*.005;\n    //d -= abs(fract(p.x/rSpacing*8.) - .5)*.005;\n \n\n    // Saving the ID and local coordinates.\n    gP = vec3(p.x, (q3.y - h), p.y)/txSc;\n    gID = vec4(d, d2, vec2(iR, iaF));\n \n \n    // Scene distance.\n    return min(fl, d);\n}\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map\n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n \n// Raymarching.\nfloat rayMarch(vec3 ro, vec3 rd) {\n    \n    // Current and overall distance.\n    float d, t = 0.; //hash31(ro + rd)*.25; Jitter.\n    vec2 dt = vec2(1e8, 0); // IQ's edge desparkle trick.\n\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5; // sign(rd)*.5;\n    gRd = rd;\n\n\n    const int iter = 128;\n    int i = 0;\n     \n    for (i = 0; i < iter; i++) {\n       \n        // Scene distance.\n        d = map(ro + rd*t);\n        \n        // IQ's clever edge desparkle trick. :)\n        if (d<dt.x) { dt = vec2(d, t); } \n\n        // Surface or far plane bailout.\n        if(d<.001 || t > FAR) {\n           break;\n        }\n        \n        // Take the minimum of the scene distance or the \n        // nearest cell wall in the direction of the ray.\n        t += min(d*.9, gCD);\n    }\n    \n    // Minimum distance in the event that we didn't hit the surface.\n    if(i == iter - 1) { t = dt.y; }\n\n    // Scene distance.\n    return min(t, FAR);\n}\n\nfloat softShadow(in vec3 p, in vec3 ld, in float lDist, in float k) {\n    \n    float res = 1.;\n    float t = 0.;\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., ld) - .5;\n    gRd = ld; \n\n    for (int i=0; i<64; i++){\n\n        float d = map(p + ld*t);\n        res = min(res, k*d/t);\n        if (d<0. || t>lDist) break;\n\n        t += clamp(min(d*.9, gCD), .01, .25);\n    }\n    return clamp(res, 0., 1.);\n}\n\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash23(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir(in vec3 p, in vec3 n){\n\n    vec2 rnd = hash23(p);\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original, but I've \n// added in exements of XT95's faux path tracing ambient occlusion from his \n// shader, here:\n//\n// Alien cocoons - XT95.\n// https://www.shadertoy.com/view/MsdGz2\n//\nfloat calcAO(in vec3 p, in vec3 n){\n \n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<12; i++){\n    \n        float hr = (float(i) + 1.)*.35/12.; \n        //float fi = float(i + 1);\n        //vec3 rnd = vec3(hash31(p + fi), hash31(p + fi + .1), hash31(p + fi + .3)) - .5;\n        //vec3 rn = normalize(n + rnd*.15);\n        vec3 rn = cosDir(p + n*hr, n); // Random half hemisphere vector.\n        float d = map(p + rn*hr);\n        \n        occ = occ + max(hr - d, 0.)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\nvec4 render(vec3 ro, vec3 rd, vec2 uv){\n\n    // Lights.\n    #if LIGHT_TYPE == 0\n    // Point light.\n    vec3 lp = ro + vec3(3, 1, 2);\n    #else\n    // Direct light.\n    vec3 ld = normalize(vec3(3, 1, 2));\n    float lDist = FAR;\n    #endif\n    \n    // Raymarch the scene.\n    float t = rayMarch(ro, rd);\n\n    // Saving the local cell coorinates and cell ID.\n    vec3 svP = gP;\n    vec4 svGID = gID;\n\n\n    // Initializing.\n    vec3 col = vec3(0);\n   \n    // If we've hit something, color it up.\n    if (t < FAR){\n  \n        // Position and normal.\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        \n        // Light.\n        #if LIGHT_TYPE == 0\n        vec3 ld = lp - p;\n        float lDist = length(ld);\n        ld /= lDist;\n        #endif\n        \n         \n        // Shadow and ambient occlusion.\n        float shd = softShadow(p + n*.0015, ld, lDist, 8.);\n        float ao = calcAO(p, n);\n\n \n        // Block ID and corresponding height.\n        vec2 id = svGID.zw;\n    \n        // Object color.\n        vec3 oCol = mix(vec3(.8, .8, 1), vec3(.65, .6, .9)/1.25, hash21(id + .13))/2.;\n        #ifdef ADD_COLOR\n        if(mod(id.x + 3., 4.)>2. && svP.y>0.) \n            oCol = .7 + .55*cos(6.2831859*hash21(id + .07)/8. + vec3(0, 1, 2)*1.25+.25);\n        else if(mod(id.x + 3., 4.)<3. && svP.y<0.) \n            oCol = .7 + .55*cos(6.2831859*hash21(id + .07)/8. + vec3(0, 1, 2)*1.25+.25);\n        #endif \n        \n        // Extra coloring.\n        //oCol *= vec3(1.2, 1, .8);\n        \n        \n        // Sunset effect.\n        //oCol = mix(vec3(.2, .25, .4), mix(vec3(1, .2, .2), vec3(1, .4, .1), \n        //       smoothstep(.2, .8, uv.y + .5)), uv.y + .5);\n        \n        // Another sunset effect.\n        //oCol = mix(vec3(.1), vec3(1, .4, .1), uv.y + .5);\n       \n        // Pinkish gradient sides.\n        //oCol = mix(oCol, oCol.xzy, smoothstep(0., 1., -svP.y*5.));\n      \n        // Edges.\n        float ew = .007;\n        \n        // Face border coloring, etc.\n        if(svP.y>0.) {\n           \n           vec3 svCol = oCol;\n           oCol = mix(oCol*1.1, vec3(1), .25);\n           oCol = mix(oCol, oCol*.1, 1. - smoothstep(0., .003, svGID.y + .035));\n           oCol = mix(oCol, svCol*.9, 1. - smoothstep(0., .003, svGID.y + .035 + ew*2.5));\n           \n        }\n        \n        // Polar \"map\" function values.\n        // vec4(iR, ia, a, aNum)\n        vec2 pO = p.xz;\n        vec4 dm = getGrid(p.xz);\n        float iR = dm.x; // Radial.\n        float ia = dm.y; // Angular.\n        float a = dm.z;\n        float aNum = dm.w;\n        float iaF = (ia + .5)/aNum*TAU;\n\n       \n        #if 1\n        // Quick hacky face dot pattern... It needs extra work.\n        float pat = abs(mod(dm.z*dm.w*12. + PI*0., TAU)/TAU - .5)*2.;\n        float pat2 = abs(mod(svP.x/rSpacing*32. + .5, 1.) - .5)*2.;\n        pat = min(pat, pat2) - .35;\n        pat = min(pat, -(svGID.y + .121));\n        if(svP.y>0.) oCol = mix(oCol/8., oCol, 1. - smoothstep(0., .005, pat));\n        #endif\n       \n       \n        // Blue gradient tinge.\n        //oCol = mix(oCol, oCol*vec3(1, 1.5, 3), max(svP.x + svP.z, 0.)*10.);\n   \n        \n        // Apply edges.  \n        float d = abs(svGID.y - ew/2.*0.);\n        d = max(d, -svP.y + ew/2.) - ew/2.;\n        oCol = mix(oCol, oCol*.0, 1. - smoothstep(0., .003, d));\n             \n       \n         \n        // Leftover effect from another shader. Interesting... but no. :)\n        //vec2 id2 = floor(id/2.);\n        //if(mod(id2.x + id2.y, 2.)<.5) oCol = mix(oCol, oCol.zyx, .5);\n      \n        // Texture coordinates that match the animation.\n        vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n        \n        // Tri-planar texturing, rotate to tie in with the animation.\n        vec3 txP = p;\n        vec3 txN = n;\n        txP.xz = rot2(dm.z)*txP.xz;\n        txN.xz = rot2(dm.z)*txN.xz;\n        vec3 tx = tex3D(iChannel0, txP/2., txN);\n         // Subtle texture color.\n        oCol = oCol*(tx*2. + .05);\n         \n       \n         \n        // Cheap specular reflections.\n        float speR = pow(max(dot(normalize(ld - rd), n), 0.), 5.);\n        vec3 rf = reflect(rd, n); // Surface reflection.\n        vec3 rTx = texture(iChannel2, rf).zyx; rTx *= rTx;\n        oCol = oCol + oCol*speR*rTx*4.;\n        \n      \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //\n        // Studio.\n        float am = pow(length(sin(n*2.)*.5 + .5)/sqrt(3.), 2.); \n        // Outdoor.\n        //float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); \n        \n  \n\n        // Greyscale texture value -- used for varying surface roughness.\n        float gr = dot(tx, vec3(.299, .587, .114));\n \n        // Material type: Dielectics, with varying roughnesss and reflectance.\n        float matType = 1., roughness = gr*gr*4. + .15, reflectance = .725;\n        /*\n        if(svP.y<0.){\n           // Sides with less reflectance and more roughness.\n           reflectance = .5;\n           roughness = gr*gr*1. + .05;\n        }\n        */\n\n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(oCol, n, ld, -rd, matType, roughness, reflectance, vec3(4));\n\n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (oCol*am*(shd*.5 + .5) + ct*(shd))*ao;\n        \n\n\n        // Light attenuation. Barely visible, but it's there\n        float rt = t/FAR;\n        col *= 1.25/(1. + rt*.2); \n\n    }\n  \n    // Fog. Not visible, but it's there anyway.\n    col = mix(col, vec3(0), smoothstep(.0, .99, t/FAR));\n    \n    // Returning the final color for this pass... There's only one\n    // pass here, but a render function is useful when you want to\n    // bounce light around.\n    return vec4(col, t);\n  \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    // Coordinates.\n    vec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Look vector and camera origin.\n    vec3 lk = vec3(0, 0, 0);\n    vec3 ro = lk + vec3(cos(iTime/4.)*.15, 3, -1.5 + sin(iTime/2.)*.075);\n  \n    // Setting up a camera using the usual process. The variable names\n    // here suggest that this lot came from one of IQ's examples.\n    vec3 ww = normalize(lk - ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww ));\n    vec3 vv = cross(ww, uu);\n    const float FOV = 3.14159/2.; // Field of view.\n    vec3 rd = normalize(u.x*uu + u.y*vv + ww/FOV); // Unit direction vector.\n    \n    /*\n    // A bit of ray warping just to mix things up.\n    vec2 offs = vec2(fbm(rd.xz*12.), fbm(rd.xz*12. + .35));\n    const float oFct = .01;\n    rd.xz -= (offs - .5)*oFct; \n    rd = normalize(rd);\n    */\n    \n    /*\n    // Mouse movement.\n    if(iMouse.z>1.){\n        rd.yz *= rot2((iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        rd.xz *= rot2((iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n    */\n\n    // Render... I was going to perform a couple of passes, but decided against \n    // it. However, it's usually a good idea to have a separate render function.\n    vec4 c4 = render(ro, rd, u);\n    vec3 col = c4.xyz;\n    \n    \n    // Vignette and very rough Reinhard tone mapping.\n    col *= smoothstep(1.5, .5, length(2.*fragCoord/iResolution.xy - 1.)*.7);\n    col /= 1. + col/2.5;\n\n    \n    // Output the fragment color to the buffer.\n    fragColor = vec4(max(col, 0.), c4.w);\n    \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "///////////////////////////\n#define PI 3.14159265\n#define TAU 6.2831853\n\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef, vec3 lCol){\n     \n    vec3 h = normalize(v + l); // Half vector.\n\n    // Standard BRDF dot product calculations.\n    float nv = clamp(dot(n, v), 0., 1.);\n    float nl = clamp(dot(n, l), 0., 1.);\n    float nh = clamp(dot(n, h), 0., 1.);\n    float vh = clamp(dot(v, h), 0., 1.);  \n\n\n    // Specular microfacet (Cook- Torrance) BRDF.\n    //\n    // F0 for dielectics in range [0., .16] \n    // Default FO is (.16 * .5^2) = .04\n    // Common Fresnel values, F(0), or F0 here.\n    // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n    // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n    // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n    vec3 f0 = vec3(.16*(fresRef*fresRef)); \n    // For metals, the base color is used for F0.\n    f0 = mix(f0, col, type);\n    vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n    // Microfacet distribution... Most dominant term.\n    float D = D_GGX(nh, rough); \n    // Geometry self shadowing term.\n    float G = G_Smith(nv, nl, rough); \n    // Combining the terms above.\n    vec3 spec = F*D*G/(4.*max(nv, .001));\n\n\n    // Diffuse calculations.\n    vec3 diff = vec3(nl);\n    diff *= 1. - F; // If not specular, use as diffuse (optional).\n    diff *= (1. - type); // No diffuse for metals.\n\n\n    // Combining diffuse and specular.\n    // You could specify a specular color, multiply it by the base\n    // color, or multiply by a constant. It's up to you.\n    return (col*diff + lCol*spec*PI);\n  \n}\n////////////////////\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}