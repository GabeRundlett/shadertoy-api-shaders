{
    "Shader": {
        "info": {
            "date": "1502131323",
            "description": "mouse sets m.xy of sat(a,m.xy),try vec2(1,1) \n\nfast useful generalization of \na=clamp(a,0.,1.), known as saturate(a) in many other libraries.\nsat(a,vec2(1))==clamp(a,0.,1.)\nbut other vector parameters make sense too.\n\nnot the optimization i was going for.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sSfWK",
            "likes": 0,
            "name": "a=clamp(a,0,1) generalization",
            "published": 3,
            "tags": [
                "saturate",
                "clamp",
                "bisymmetry",
                "generalization"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "/*\nmouse sets m.xy of sat(a,m.xy), try mousePos = vec2(1,1) \n\nsat(a,m) is a fast useful generalization of \na=clamp(a,0.,1.), known as saturate(a) in many other libraries.\n\nsat(a,vec2(1))==clamp(a,0.,1.)\n\nbut other vector parameters make sense too.\nthe most reasonable inputs either have abs(m.x)=1. or abs(m.y)=1.;\n\n\nthis generalization lets you transition between some of 2 different clamp(a,b,c)\nnot the optimization i was going for.\n*/\n\n\n/*\nthe BISYMETRY PRINCIPLE:\n- utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - In a quest to increase symmetry for performance and modular shaders.\n- Only write atomic special cases and transformations, \n- ...to construct general functions from.\n- Instead of writing a general function, \n- ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- this way general functions can be made into special \"shortcut\" functions more easily.\n- this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- this whole structure screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this structure more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\"\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n\n------------\n\n[envelope]s and [window function]s and [Passband]s are pretty much mean the same to me now.\ni just lack a noun for min||max([window function],[envelope]) that is not [MoDem] or [context]\nhttps://en.wikipedia.org/wiki/Context_(computing)\nhttps://en.wikipedia.org/wiki/Modulation\nFor a lack of a better term, the terms I use are knowinggly fuzzy.\n\nthey come down to y=f(x) that often are only, or especially \n...focused on (inout) ranges [-.5..+.5] to [-3.14..+3.14]\n...while their parameters (like uv or scaling) are any range.\n\n[window function]s \n- tend to have smoother derivatives, nicer Local Lipschitz Constants. they include \n- https://en.wikipedia.org/wiki/Window_function\n[envelope]s tend to be more symmetric and opften less less continuous. they include \n- https://en.wikipedia.org/wiki/Envelope_(waves)\n- where continuity is easily broken due to Fourier Transform (of a square,triangle,seesaw wave)\n-\n- means envelopeD(log(envelopeE())), for lack of a better term.\n- ... where envelopeA()=envelopeB(envelopeC())\n- does not mean \n- https://en.wikipedia.org/wiki/Envelope_(mathematics)\n*/\n\n/*\nnotes to self, for improvement:\nuse #define to take a domain (x,y, z or w) as function parameter \nyour #define basically defines patterns over single domains, \nand their context lies on how these \n#defines are utilized min() mic() smin() swiveled or otherwise transformed.\n\n\nthe comments of\nhttps://www.shadertoy.com/view/MdSfzt\nare all about \n- line breaks in a define\n- using a buffer texture and a single define to display a string.\nthis is a current process...\n*/\n\n//sharpness of FullScreenAntiAliasing\n#define fsaa 5./iResolution.y\n//maximum view zoom\n#define viewZoom 14.\n//scale viewFrame\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n//3.14=ratio of unitCircleCircumference to diameter=\n#define pi acos(-1.)\n//0.61=golden ratio; phi-1=1/phi,smaller solution\n#define phi (sqrt(5.)*.5-.5)\n//1.61=Golden Ratio; Phi-1=1/Phi,larger  solution\n#define Phi (sqrt(5.)*.5+.5)\n\n//#define stretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nfloat sat(float a,vec2 m){    \n a=.5*(sign(a)+m.x)*a+m.y;\n a=(sign(2.-a)+1.)*(a-2.)+2.; \n return a*.5;}\nfloat sat(float a){return sat(a,vec2(1));}//return clamp(a,0.,1.); \n\n\n//squareroots for https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nconst vec4 s2=sqrt(vec4(2,3,5,6));//s6=sqrt(vec4(7,10,11,12));//arrays and matrices are too bulky here.\n\n//modulo tiled grid.\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));                   \n u.x*=u.x;return u.x*u.x;}\n\nfloat sawCos(vec2 u){//u*=2.;//sale here, or better outside of this function.\n u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c) with a hint of s, diminishing over c.\n#define sci() mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//use a matrix as if it is a list.\nfloat gm3(mat3 a,int n){return a[n/3][n%3];}\n//return a[int(n/3.)][int(mod(n,3.))];}//float variant\n#define gp(a) gm3(co,a)\n\n//return distance to (barely more than a) half-donut, bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);   \n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n //if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n//special halfWorm(u,1,1)\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y));\n return abs(a-.5*(1.+sign(u.y)));}\n//https://www.shadertoy.com/view/ldSBR3\n//special halfWorm(u,.5,1)\nfloat halfWorm51(vec2 u){u.x=abs(u.x);vec2 i=u*2.;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i));a=.5*(sign(u.y)*(a-1.)+3.*a-1.);\n return abs(a)*.5;}\n\nfloat halfdonut(vec2 p, float size) {\n    size=.5;\n    vec2 p2 = p;\n    p2.y = max(p.y,0.0);\n    return length(vec2(abs(length(p2)-size),p.y-p2.y));\n}//https://www.shadertoy.com/view/lsjBWy\n\n//halfdonut() with domain stretch\nfloat halfdonutfor3(vec2 p, float size) {\n    vec2 p2 = p;\n    p2.y = max(p.y,0.0);\n    return length(vec2(abs(length(p2)-size),min(p.y,-size/2.0)+size/2.0));\n}////https://www.shadertoy.com/view/lsjBWy\n\n\n//m.y sets zoom (makes sense for waveforms)\n//length sets zoom\n//#define scaledot(u) length(m)*u\n//length*length sets zoom, for EXTREME zoom out\n//#define scaledot(u) dot(m,m)*u\n//near main axes, zoom in\n//#define scaledot(u) min(abs(m.x),abs(m.y)   )*u\n//mix of axial distances sets zoom\n//#define scaledot(u) mix(abs(m.x),abs(m.y),.5)*u\n#define scaledot(u) u=min(abs(m.x),abs(m.y))*u\n\n\n\n//return distance to infinite line segment\n//float ils(vec2 u,vec4 m){if(0.<u.x)return u.y;return length(u);}\n//is not too useful for this shape, just a bit too dirty.\n\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u, vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n//pseudo ellipse, made of 2 circles.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))\n                                 +length(vec2(abs(u.x-1.),u.y));}\n\n\n\n\n//return distance to cube, rotated by sqrt(2)*.5\nfloat rotCube3(vec2 u,vec4 m){\n vec2 v=sqrt(vec2(1,3))*.5;    \n float c=abs(dot(vec2(u.x, u.y),v)); \n float d=abs(dot(vec2(u.x,-u.y),v.yx));\n return max(c,d);//return .5*(sign(a-b)*(a-b)+b+a);\n}\n\n/*\n//return distance to cube, rotated by sqrt(2)*.5\nfloat rotCube3s(vec2 u,vec4 m,vec2 v){u=vec2(-u.x,u.y)-v*m.x;\n float c=abs(dot(vec2(u.x, u.y),v));float d=abs(dot(vec2(u.x,-u.y),v.yx));\n return max(c,d);}//return .5*(sign(a-b)*(a-b)+b+a);}\n*/\n\n//bracked with 90deg ends\nfloat bracketN(vec2 u,vec4 m){\n m.x=abs(m.x);u.y=abs(u.y);\n vec2 v=sqrt(vec2(1,3))*.5;\n if(0.>dot(u,v.yx))return abs(length(u)-m.x);//bracket\n else{u=vec2(-u.x,u.y)-v*m.x;vec2 e=abs(vec2(dot(vec2(u.x, u.y),v),dot(vec2(u.x,-u.y),v.yx)));\n  return max(e.x,e.y);}}//with 90deg corners\nfloat bracketCn(vec2 u,vec4 m){//scaling wrapper for bracketN()\n    m.x=abs(m.y)/sqrt(3.);u.x=u.x-m.x*.5;u.y=u.y+sqrt(3.)*.5*m.x;return bracketN(u,m);}\n\n//bracked with rounded ends\nfloat bracketR(vec2 u,vec4 m){m.x=abs(m.x);u.y=abs(u.y);\n vec2 v=sqrt(vec2(1,3))*.5;float b=dot(u,v);\n if(0.>dot(u,v.yx))return abs(length(u)-m.x);//bracket\n return length(vec2(-u.x,u.y)-v*m.x);}//with rounded corners\nfloat bracketCr(vec2 u,vec4 m){//scaling wrapper for bracketR()\n    m.x=abs(m.y)/sqrt(3.);u.x=u.x-m.x*.5;u.y=u.y+sqrt(3.)*.5*m.x;return bracketR(u,m);}\n\n//fake ellipse that is 2 circles, faster and better distance field.\nfloat ellipseFake(vec2 u,vec4 m){\n u=abs(u);\n  if (u.y-sqrt(2.)+.5>u.x){   \n   u.y=mStretch(u.y,1.);\n   return length(u)-1.;\n }return  length(u+vec2(1,0))-1.-sqrt(2.);\n}\nfloat ribbon1(vec2 u,vec4 m){\n u.x=abs(u.x);\n float b=dot(u,-sqrt(vec2(1,3))*.5);\n float a=length(u);\n return max(abs(a-1.)-.1,b);\n}\n\nfloat balloon(vec2 u,vec4 m){\n //return rotCube3(u,m);\n //return bracketC(u,m);\n float b=ellipseFake(u-vec2(0.,2),m);\n float a=ribbon1(vec2(0,-3)-u,m);\n return min(a,b);\n}\n\n/*\n//return distance to sideways.horse-silhouette, optimized for speed.\nfloat silHorse(vec2 u,vec4 m){\n //u-=m.xy;//move by m.xy\n float t=length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))+.5;//tail\n float r=length(vec2(-1.5-u.x,mStretchP(u.y,4. )))+.5;\n float l=length(vec2( 1.5-u.x,mStretchP(u.y,7.5)))+.5;//front\n u.y-=3.5;\n vec2 n=vec2(2.25-u.x,u.y-2.5);\n float h=length(n)-.5;//head\n    n+=vec2(1.3,.7);\n h=min(h,length(n)+.3);\n u.x=mStretch(u.x,1.1);\n float b=length(u)-.2;\n //h=length();\n //vec2 v=abs(u-vec2(.5));\n //return b;\n return min(min(min(h,b),min(l,r)),t);\n return ellipseCheap(u)-1.5;\n return length(u);\n}*/\n\nfloat sum(vec2 a){return a.x+a.y;}\n/*\n//lookup table for https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nvec2 getRealRadical(int a){int b=(a/4)*2;a%=4;\n const mat4 r=mat4(.5*vec4(2,0,1,s2.y),.25*vec4(s2.w+s2.x,s2.w-s2.x,s2.w-s2.x,s2.w+s2.x),\n .5*vec4(s2.y,1,0,2),.5*s2.x*vec4(1,1,0,0));return vec2(r[a][b],r[a][b+1]);}\n\n//return distance to 1/24th rotated axis\nfloat r12(vec2 u){\n //const float s2=sqrt(2.), s6=sqrt(6.);\n //extreme unpoinry: return dot(u,vec2(s6+s2,s6-s2)*.25)\n //might as well just do a look up table matrix over one quater.\n return dot(u.yx,vec2(sum(s2.xw),s2.w-s2.x)*.25);}\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n\nfloat arrow(vec2 u,vec4 m){\n u.y*=sign(u.y);\n //if(u.y>m.x) return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n m.z*=.25;\n m.zw=abs(m.zw);\n //vec2 d=vec2(1,-sqrt(2.))*.5; //12th rotation\n float a=r12(u)-m.z;            //24th rotation\n a=max(a,-u.x);\n u.x=-mStretchM(u.x,m.x);u.y=-mStretchM(u.y,m.y);\n return min(a,length(u)-m.w);}//https://www.shadertoy.com/view/XsBBRd\n\n//glyph \"2\", acrually just 24th rotations, i got tired and halted that project early.\n//project is to get a FAST distance field to \"letter 2\" by rotating halfWorm11()\nfloat g2(vec2 u,vec4 m){\n int t=int(iTime*3.);  \n if(t%24>11){u=-u;}//180deg rotation\n if(t%12>5 ){u=vec2(u.y,-u.x);}//90deg rotation\n t=t%6;//resolve quadrant\n float a=abs(length(u)-1.)-.01;\n vec2 b=getRealRadical(t);\n float c=length(u-b)-.1;\n float d=dot(u,b);\n a=min(a,min(c,d));\n return a;}//https://www.shadertoy.com/view/ldBBRt\n*/\n\n//subroutine, reserved for serife\nfloat serif(vec2 u,vec4 m){\n return length(u);}\n\n//a corner that can easily be rounded at its ends. better for serife\nfloat corner(vec2 u,vec2 m){    \n //as core concept, overlaps a lot with;  https://www.shadertoy.com/view/ldjBRV\n //could be generalized, more integrated into this one:\n /*\n vec2 v=u;\n v.y=mStretchP(v.y,m.x);\n float a=length(v-vec2(m.x,0));\n u.x=mStretchP(u.x,m.x);\n float b=length(u-vec2(0,m.x));\n return min(a,b);\n /**/\n //above has the disadvantage of doing length() twice.\n //below delays the length() till the end, to a point where it can be ommitted.\n //this invlves what i call \"bisymmetry optimizazion  \n  \n m=abs(m);\n m.y=m.x;    \n mat2 a=mat2(-1,1,1,1);//change this matrix and see if you can make a heart.\n u*=a;\n m*=a;\n u.x=abs(u.x);//m.y=abs(m.y); \n //u.y=abs(mStretch(u.y,m.x));//strangely useful but inefficient\n a=inverse(a);\n u*=a;\n m*=a;\n float z=(u.x*2.-m.x),\n g=sign(z)+1.,//places 4 spheres.\n h=sign(abs(z)-m.x)+1.;//change +1 for heart shape\n u.x=.5*h*(.5*m.x*g-u.x);\n m.x*=1.-sign(m.x);\n u-=m;\n return length(u);}//rounded\n//u=abs(u);return max(u.x,u.y);}//corners //is much simpler...\n\n//special case of the above\nfloat corner1(vec2 u){   \n mat2 a=mat2(-1,1,1,1);//change this matrix and see if you can make a heart?\n u*=a;    \n vec2 m=vec2(0,2);\n u.x=abs(u.x);//m.y=abs(m.y); \n //u.y=abs(mStretch(u.y,m.x));//strangely useful but inefficient\n u*=inverse(a);\n float z=(u.x*2.-1.),//here you can modify whole numbers to generalize constants to vars.\n o=sign((abs(z)-1.))+1.,\n p=sign(u.x*2.-1.)+1.;\n u.x=.25*o*(p-u.x*2.);\n return length(u-vec2(0,1));//rounded\n //u=abs(u-vec2(0,1));return max(u.x,u.y);//corners //is much simpler...\n/**/\n}\n\nfloat g0(vec2 u,vec4 m){u.y=mStretch(u.y,.5);return abs(length(u)-.5);}\n\nfloat g1(vec2 u,vec4 m){\n u.y=mStretch(u.y,1.);return abs(length(u));//rounded \n //u=abs(u);u.y-=1.;return max(u.x,u.y);//corner border\n}\n\nfloat g2(vec2 u,vec4 m){\n float c=length(vec2(mStretch(u.x,.5),u.y+1.5));\n u*=.5*mat2(-s2.y,1,1,s2.y);//rotate\n //u*=mat2(-sqrt(2.),1,1,sqrt(2.))/sqrt(2.);//rotate\n //float a=abs(length(u-vec2(.5,-1.5))-1.);\n //a=max(a,-u.y-1.5);\n \n    \n //u=vec2(u.x,-u.y);u*=.5*mat2(-1,-s2.y,s2.y,-1);//rotate\n //a=max(a,u.y+.25);\n float b=halfWorm51(u);\n u.y=mStretchM(u.y,s2.x);//sqrt(2) in sqrt(3), apparently\n float a=(length(u+vec2(.5,0.)));\n return min(min(a,b),c); \n}\n\nfloat g3(vec2 u,vec4 m){\n u.y=abs(u.y);\n float c=halfWorm51(vec2(u.y-.5,u.x));\n #ifdef HighQuality3\n u*=.5*mat2(-s2.y,1,1,s2.y);float a=halfWorm51(u-vec2(.25,s2.y*.25));//rotate fullRotation/12 ish\n #else\n float a=halfWorm51(u-vec2(0,.5)); //rotate fullRotation/4\n #endif\n return min(a,c);}\n\nfloat g4(vec2 u,vec4 m){\n float b=corner1(vec2(1.-u.y,.5-u.x));//left half \"corner\" of a \"4\"\n u.x-=.5;\n u.y=mStretch(u.y,1.);\n float a=abs(length(u));\n return min(a,b);\n}\n\nfloat glyphs(vec2 u,vec4 m){\n u.x+=5.;\n float a=g0(u-vec2(-2.,1.5),m);\n float b=g1(u-vec2(0.,1.5),m);\n float c=g2(u-vec2(2.,2.),m);\n float d=g3(u-vec2(4.,1.5),m);\n float e=g4(u-vec2(6.,1.5),m);\n return min(min(min(a,b),min(c,d)),e);\n}\n\n//https://en.wikipedia.org/wiki/Dihedral_group_of_order_6\n//is intentionally bloaty/duped, makes it easier to remove symmetry where it is not needed.\n#define borderW .4\nfloat pmaa(vec2 u,vec4 m){\n //#if (borderW==0.)\n  return min(length(u-m.xy),abs(u.x)+borderW);//show dots and pattern bisymmetry borders.\n// #else\n //  return length(u-m.xy);//show just the dots\n// #endif\n}float d6m(vec2 u,vec4 m){\n m.x=abs(m.x);u.x=abs(u.x);float b=0.;\n //#if (0.==borderW)\n b=abs(u.x)+borderW;//adds upper vertical border.\n //#endif\n float s=sqrt(3.);\n u=u*(mat2(1,s,-s,1)*.5);\n m.xy=m.xy*(mat2(1,s,-s,1)*.5);\n u.x=abs(u.x);m.x=abs(m.x);\n float a=pmaa(u,m);\n u=u*(mat2(1,s,-s,1)*.5);\n m.xy=m.xy*(mat2(1,s,-s,1)*.5);\n u.x=abs(u.x);m.x=abs(m.x);\n float c=pmaa(u,m);\n //return min(a,b)-.1;\n return min(min(a,c),b)-.5;\n //return a-.01;    \n;}\n\n\n//some mouse cursor code, shading the same color space, inverting\nfloat mouseNeg(float c,float m){return sign(c)*min(m,abs(c));}\n//mix c and m where m is a disturbing distance field [m]  as \"mouse pointer\" in field [c]\nfloat mouseDif(float c,float m){//return sign(c)*max(-sign(c)*c,m);//alternative to below\n //return min(c*sign(m),m);//shorter variant of below\n float s=sign(m)*c;m-=s;return s+.5*(m-abs(m));}\n//view scaling\nvec3 co(vec2 u){//calculate color for fragment\n vec4 m=vec4(fr(iMouse.xy),fr(iMouse.zw));u=fr(u);//put vec2(0) in the center of the view, adjust for aspect ratio.\n/*\n m.w=abs(m.w*.5);//scaling mouse input for this one\n if(iMouse.z<0.)/(idling mouse\n m=vec4(sin(iTime*acos(0.))*2.+2.//length.x of handle\n       ,cos(iTime)            +1.//length.y of handle\n       ,sin(iTime)            +4.//size of the tip\n       ,cos(iTime*.61)*.2     +.2//roundness of handle\n       )*3.;\n/**/\n//   else m=fr(iMouse.xy);\n //scaledot(u);scaledot(m);//scale view, depending on m\n //u+=m;m+=m;//move view center away from vec2(0)\n vec3 c;//color composition\n    \n //m.x=clamp(m.x,0.,1.);\n //m.x=max(m.x,0.);\n //float a=bracketCn(u,m)-.1;\n //float b=bracketCr(u,m)-.1;\n //c.r=a;\n //c.r=mix(a,b,m.x);//if(m.y>0.)c.r=min(c.r,balloon(u,m));\n \n// m.y=max(m.y,.1);m.x=abs(m.x);//constraining UI for convenience.\n    \n    \n //c.r=glyphs(u,m)-.1-m.y;\n //c.r=min(c.r,corner(u,m.xy)-m.y);\n \n  c.r=sat(u.x,m.xy)-u.y;\n    \n //c.r=corner1(u);\n //c.r=silHorse(u,m)-1.;//distance field to horse shape.\n //c.r=d6m(u,m); //distance to d6m(mouse), 3*mirror symmetry (for hexagons).\n\n //c.r=g2(u,m);//distance to point and plane, rotated by fullRotation*n/24\n //c.r=circleStretch(u,m);//distance field at u, set by parameters m (complicated)\n float d=sin(iTime)*.5+.5;\n float mo=length(u-m.zw);//distance to mouse cursor (for more dynamic fields)\n //float e=length(u-m.zw)-1.;//distance to where mouse was pushed down\n //c.r=min(c.r,e);    \n      \n //c.r=mouseDif(c.r,mo);\n //c.r=mouseNeg(c.r,mo);\n //c.r=mouseDif(mouseNeg(c.r,mo),mo);\n //c.r=mouseNeg(mouseDif(c.r,mo),mo);\n //c.r=mix(mouseDif(c.r,mo),mouseNeg(c.r,mo),.5);\n c.bg=u;//making x-axis green comes naturally\n c=sawCos3(c,.9);//smoothest gradient visualization so far\n c.gb+=vec2(sawCos(length(u),.5)*.003);//show circles around (0,0)\n \n //the color mix below usually looks nice, \n //but hues cyclically bleed into another, causing some optical illusions if one domain is very low\n //it also means if any domain is NaN, it becomes 0.\n if(isnan(c.r))c.r=0.;//projecting NaN to 0.\n if(isnan(c.b))c.b=0.;//projecting NaN to 0.\n if(isnan(c.g))c.g=0.;//projecting NaN to 0.\n c=sqrt(c);//more evenly gamma correcting\n c=max(vec3(0),c);\n return c*.5+c.yzx*.25;}\n#define mainImage(o,u)o=vec4(co(u),1.);\n\n//vector dotproduct with vecN(1) is a faster sum.\n//float sum(float a,float b,float c,float d){return dot(vec4(a,b,c,d),vec4(1.));}\n//float sum(float a,float b,float c){return dot(vec3(a,b,c),vec3(1.));}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}