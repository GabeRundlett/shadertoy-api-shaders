{
    "Shader": {
        "info": {
            "date": "1606609412",
            "description": "iMouse.zw changed for the worse, breaking compatibility.\nhttps://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\nmessy signs can be fixed, adds 2 branches.\n\nleft half folds iMouse.mz=iMouse.xy onMouseUp\nright half stays onMouseUp",
            "flags": 0,
            "hasliked": 0,
            "id": "tsKBz1",
            "likes": 1,
            "name": "iMouse.zw compatibility patch",
            "published": 3,
            "tags": [
                "compatibility",
                "imouse",
                "incompatibility"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "/*\nabs(iMouse.zw) is unaffected by the 2020-11 change of iMouse.zw\n,but many older shaders\n,that cared for either the sign of iMouse.z or iMouse.w \n,are now broken, because the 2 signs now have indepentend behavior:\n\nIn 2020-11 iMouse.zw signs got changed to:\n if(iMouse.z==0||iMouse.w==0){ button was never clicked since PAGE-load}\n else{\n   if(iMouse.z<0){             button is down ,clicked now OR previously}\n   if(iMouse.w<0){             button is       clicked in THIS frame}\n }\n\nBeware that it initiates as 0, so <0, and <=0, as well as sign(iMouse)\n,can make a difference (on PageLoading, before clicking)\nOn (and after) klicking, iMouse will never be 0 again\n,because the smallest (bottom left) fragment is >=1  (I floor() to ckeck)\n\nTo fix iMouse.zw (for backwards compatibility):\nyou can either use abs(iMouse.zw)\nor the iMouseZwFix() function below to more explicitly\nswitch signs of iMouse.zw back to how they used to be.\n*/\n\n//backwards compatible signs of iMouse.zw (changed in november 2020)\n//m=iMouse.xyzw\n//NewCoke==true : mode now optionally ignores the onMouseUp event \n//(onMouseUp acts as if mouse is still hold down)\n//NewCoke==false : onMouseUp m.xy=m.zw like it used to be\n//NewCoke==true  : onMouseUp      m.zw stays as if mouse is still held down\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{\n    if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n\n//----- lineSegment drag visualizer by ollj\n\nvec2 fra(vec2 a,vec2 r){return (a-.5*r.xy)/r.y;}\n\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n\n#define segment2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))\n//sqared orthogonal projection ,segment()subroutine ,is squared distance\n#define segments(a,b,c) (segment2((a-b),(c-b)))\n//offset segment2(a,c) by -b\n#define segment(a,b,c) sqrt(segments(a,b,c))\n//pointAdistance to (diagonal) lineSegment from B to C\n\n\nvec4 mainImage3( out vec4 fragColor, vec2 u\n){vec2 r=iResolution.xy\n ;vec4 m=iMouse\n     \n ;if(u.x<r.x/2.)m=iMouseZwFix(iMouse,false) //iMouseZwFix\n ;else          m=iMouseZwFix(iMouse,true)\n\n ;u   =fra(u   ,r)  //scale to range [-.5,.5]\n ;m.xy=fra(m.xy,r)\n ;m.zw=fra(m.zw,r) \n ;if(//true\n     iMouse.z==0.\n    ){ //optionaly override m for pageload (previewImage control)\n     ;if(u.x<0.) m=vec4(.6,.4,.6, .4)\n     ;else       m=vec4(.6,.4,.7,-.4)\n    ;}\n     \n ;vec3 c=vec3(1)     \n ;c.x=segment(u,m.xy,m.zw) \n //fract to point to the OFFSCREEN position\n ;c.y=fract(length(u-m.zw)\n    *(3.+sign(iMouse.w))//indicate the 1 frame mouse was clicked\n           )     \n ;c.z=length(u-m.zw)-.1  //this one is messed up without iMouseZwFix\n ;c=smoothstep(.1,-.1,c)\n ;return vec4(c,1.0);}\n\n//end of left-endian-semicolon code by ollj\n\n\n\n\n//below code is from \n//https://www.shadertoy.com/view/llySRh\n//it helped me make a workaround patch (aboove) , but it needs 2 if conmditions.\n    \n//=== original link for citation: https://www.shadertoy.com/view/llySRh\n//find many other tricks here: https://shadertoyunofficial.wordpress.com/\n\n\n// --- printing chars, integers and floats ---------------------------\n\n// --- access to the image of ascii code c\n\n// 2 implementations.\n// Use #if 1 for extensive text use (with no superimposition nor color-appearance change)\n\n#define IMMEDIATE_DRAW 1\n\n#if IMMEDIATE_DRAW //  (allows for superimposition and appearance change).\n\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug with an old driver\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n  // variants:\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n#  define draw_char() vec4(0)  // stub the final call function is used\n\n#else // Deferred draw (call draw_char() ). Run and compiles faster.\n      //     First only determine the valid char id at cur pixel \n      //     then call the draw char once at the end.\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n     : textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );}\n#endif\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;}\n#endif\n\n\nvec4 mainImage2( out vec4 O,  vec2 uv ){\n    O -= O;\n    vec2 R = iResolution.xy, U;\n    uv /= R.y;    \n    int lod = int(mod(iTime,10.));\n    U = ( uv - vec2(.1,.8) ) * 8.;        // --- column 1\n   \n    U -= vec2(5,.5);\n    O += pInt(U, floor(iMouse.x));  U.y += .8;        // mouse location\n    O += pInt(U, floor(iMouse.y));  U.y += .8;\n    U.y += .4;\n    O += pInt(U, floor(iMouse.z));  U.y += .8;        // last mouse-click location \n    O += pInt(U, floor(iMouse.w));  U.y += .8;\n     \n    O += draw_char().xxxx;\n#if IMMEDIATE_DRAW\n    O = O.xxxx;\n#endif\n    // --- color space corrections\n   return pow(O, vec4(1./2.2) ); // shader result must be in sRGB colorspace -> gamma correction\n                               // note that it is very close to sqrt(O).\n    // similarly, color operations must be done in flat space, while textures are sRGB-encoded: pow(texture(),vec4(2.2)) or ~square.\n}\n\n\nvoid mainImage( out vec4 o, vec2 u\n){o=max(mainImage2(o,u),mainImage3(o,u));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}