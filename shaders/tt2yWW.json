{
    "Shader": {
        "info": {
            "date": "1595011805",
            "description": "Itsa me! Mario!\nAfter the piranha plant, a procedurally animated PBR Mario head hommage to the Mario 64 loading screen.\nI hope this brings you joy. ",
            "flags": 64,
            "hasliked": 0,
            "id": "tt2yWW",
            "likes": 47,
            "name": "Mario Head",
            "published": 3,
            "tags": [
                "animation",
                "mario",
                "face",
                "head",
                "expression"
            ],
            "usePreview": 1,
            "username": "PixelPhil",
            "viewed": 1483
        },
        "renderpass": [
            {
                "code": "//\n// Mario Head by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MAX_DST 45.0\n#define MIN_DST 0.008\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n#define ZERO (min(iFrame,0))\n\n//Material regions\n#define SKIN\t\t \t0.0\n#define CAP   \t\t\t1.0\n#define CAP2   \t\t\t2.0\n#define HAIR\t\t\t3.0\n#define HAIR2\t\t\t4.0\n#define EYES\t\t\t5.0\n#define INSIDE_MOUTH \t6.0\n#define\tTEETH\t\t\t7.0\n\n        \n// All the parametters for an animation pose\nstruct KeyFrame\n{\n\tvec2 eyePos;\n    float eyelidsOpen;\n\tfloat eyeOpening;\n    float browBend;\n    float moustacheBend;\n    float mouthOpenVert;\n    float mouthOpenHoriz;\n    float bendX;\n    float twistX;\n    vec2 headRotation;\n};\n\n// Linear interpolation between two animation frames\nvoid mixKeyFrame(KeyFrame a, KeyFrame b, float ratio, out KeyFrame c)\n{\n    c.eyePos\t\t = mix(a.eyePos\t\t\t,b.eyePos\t\t  ,ratio);\n    c.eyelidsOpen\t = mix(a.eyelidsOpen\t,b.eyelidsOpen\t  ,ratio);\n\tc.eyeOpening\t = mix(a.eyeOpening\t\t,b.eyeOpening\t  ,ratio);\n    c.browBend\t\t = mix(a.browBend\t\t,b.browBend\t\t  ,ratio);\n    c.moustacheBend  = mix(a.moustacheBend  ,b.moustacheBend  ,ratio);\n    c.mouthOpenVert  = mix(a.mouthOpenVert  ,b.mouthOpenVert  ,ratio);\n    c.mouthOpenHoriz = mix(a.mouthOpenHoriz ,b.mouthOpenHoriz ,ratio);\n    c.bendX\t\t\t = mix(a.bendX\t\t\t,b.bendX\t\t  ,ratio);\n    c.twistX\t\t = mix(a.twistX\t\t\t,b.twistX\t\t  ,ratio);\n    c.headRotation\t = mix(a.headRotation\t,b.headRotation\t  ,ratio);\n}\n\n// all matrices and offsets that needs to be pre-computed\n// in order to keep the SDF relatively straightforward\nstruct MatSpace\n{\n    float twistLower;\n    float twistX;\n    float bendX;\n    float moustacheBend;\n    \n    vec3 eyeRad;\n    vec3 cheekPos;\n\tvec3 cheekRad;\n\tvec3 chinPos;\n\tvec3 noseRad;\n\n\tvec3 mouthPos;\n\tvec3 mouthRad;\n\n\tvec3 lipPos;\n\tfloat lipStretchX;\n\tfloat lipThickness;\n\n\tmat3 earMat;\n\tmat3 cap1Mat;\n\tmat3 cap2Mat;\n\n\tvec3 hairTip1;\n\tvec3 hairTip2;\n\n\tfloat browOffset;\n\tfloat browBend;\n\n\tvec3 teethPos;\n\n\tvec2 eyePos;\n    float eyelidsOpen;\n};\n\n// Attributes of a PBR material\nstruct PBRMat\n{\n    vec3 albedo;\n    float metalness;\n    float roughness;\n};\n\n// Ditance to the Letter M (cap + bg)\nfloat MDist(vec2 uvs)\n{\n    vec2 p = uvs;\n    p.x = abs(p.x);\n            \n\n    float v = p.y - 0.7 - p.x;\n    v = max(v, p.y - 2.6 + p.x * 1.8); \n    \n    \n    float v2 = p.y - 0.0 - p.x;\n    v2 = max(v2, p.y - 1.6 + p.x * 2.35); \n    \n    v = max(v, -v2);\n    \n    v = max(v, -p.y - 1.0 + p.x * 0.3);\n    return v;\n}\n    \n\n// Computes a PBR Material from material ID and world position\nvoid GetColor(float id, vec3 pos, MatSpace ps, out PBRMat mat, out vec3 normalBend)\n{   \n    normalBend = vec3(0);\n    \n    if (id == SKIN)\n    {\n        mat = PBRMat(vec3(1.0, 0.8, 0.8), 0.1, 0.3);\n    }\n    else if (id == CAP)\n    {\n        float mMask = 0.0;\n        \n        if (pos.z < 0.0)\n        {\n            vec2 p = pos.xy - vec2(0.0, 8.0);\n           \n            float v = MDist(p);\n            \n            mMask = length(p * vec2(1.0, 1.2));\n    \t\tmMask = S(2.3, 2.28, mMask);\n            mMask *= S(-0.03, 0.03, v);\n        }\n     \n        \n        mat = PBRMat(mix(vec3(0.8, 0.0, 0.0), vec3(1,1,1), mMask) , 0.05, 1.0);\n    }\n    else if (id == CAP2)\n    {\n        mat = PBRMat(vec3(0.8, 0.0, 0.0), 0.05, 1.0);\n    }\n    else if (id == HAIR)\n    {\n        mat = PBRMat(vec3(0.5, 0.25, 0.05), 0.1, 0.5);\n    }\n    else if (id == HAIR2)\n    {\n        mat = PBRMat(vec3(0.25, 0.15, 0.02), 0.3, 0.2);\n    }\n    else if (id == EYES)\n    {\n\n        \n        vec2 uvs = pos.xy;\n        \n        uvs.x -= 1.5 * sign(pos.x);\n        uvs -=  ps.eyePos; // eye position\n        \n  \t\tfloat iris = length(uvs * vec2(1, 0.7));\n        \n        vec3 blue = vec3(0.3, 0.8, 1.0);\n        vec3 blue2 = vec3(0.1, 0.2, 0.8);\n        \n        blue = mix(blue, blue2, S(0.1, 1.3, iris - uvs.y * 0.2));\n        \n        vec3 eyeCol = mix(blue, vec3(1, 1, 1), S(0.75, 0.8, iris));\n        \n        eyeCol *=  S(0.45, 0.5, iris);\n        eyeCol +=  S(0.3, 0.2, length(uvs - vec2(0, 0.3))) * 3.0;\n        \n        float lidDst = abs(pos.y - 2.6) - ps.eyelidsOpen;\n        \n        float lid = S(0.001, 0.01, lidDst);\n        \n        eyeCol = mix(eyeCol, vec3(1.0, 0.8, 0.8) * S(-0.2, 0.2, lidDst), lid);\n        \n        mat = PBRMat(eyeCol, 0.0, 0.5);\n    }\n    else if (id == INSIDE_MOUTH)\n    {\n        mat = PBRMat(vec3(0.75, 0.0, 0.1), 0.05, 1.0);\n    }\n    else \n    {\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.05, 1.0);\n    }\n    \n    return;\n}\n\n\n// Some pprocedural animation functions\n\nvoid HappyExpression(out KeyFrame res)\n{\n    float opening = Noise1(iTime, 444.0);\n    res.eyeOpening = 1.0 + opening * 0.2;\n    res.browBend = -opening * 0.2;\n    res.moustacheBend = -opening * 0.15;//sin(iTime * 2.0) * 0.3;\n    \n    float smile = Noise1(iTime * 0.56, 447.0);\n    \n    res.mouthOpenVert =  0.01 - smile * 0.04;//sin(iTime * 3.0) * 0.04;\n    res.mouthOpenHoriz = 0.01 + smile * 0.08;//-0.02;//sin(iTime) * 0.05;\n    res.bendX = -0.1 -opening * 0.2;//sin(iTime) * 0.3;\n    res.twistX = 0.0;//sin(iTime * 10.0) * 0.2;\n\n    \n    float eyelidsOpen = fract(iTime * 0.2) * 30.0;\n                        \n    res.eyelidsOpen = eyelidsOpen;\n    \n    float rotX = Noise1(iTime * 0.3, 14.0);\n    res.headRotation = vec2(rotX * 0.5, opening * 0.3);\n    \n    res.eyePos = vec2(opening * 0.5, 3.0);\n}\n\n\n\nvoid AngryExpression(out KeyFrame res)\n{\n    float opening = Noise1(iTime, 444.0);\n    res.eyeOpening = 0.6 + opening * 0.4;\n    res.browBend = -opening * 0.4 - 0.4;\n    \n    \n    float smile = Noise1(iTime * 0.56, 447.0);\n    \n    res.moustacheBend = 0.2 -  smile * 0.2;//sin(iTime * 2.0) * 0.3;\n    \n    res.mouthOpenVert =  0.02 - smile * 0.04;//sin(iTime * 3.0) * 0.04;\n    res.mouthOpenHoriz = -0.02;// + smile * 0.08;//-0.02;//sin(iTime) * 0.05;\n    res.bendX = 0.2 + opening * 0.1;//sin(iTime) * 0.3;\n    \n\n    res.twistX = Noise1(iTime * 0.3, 487.0) * 0.5;\n\n    \n    float eyelidsOpen = min(fract(iTime * 0.2) * 30.0, 0.8 +  res.twistX);\n                        \n    res.eyelidsOpen = eyelidsOpen;\n    \n    float rotY = Noise1(iTime * 1.5, 14.0);\n    res.headRotation = vec2(-0.03, rotY * 0.3);\n    \n    res.eyePos = vec2(opening * 0.8, 3.2);\n}\n\nvoid LaughExpression(out KeyFrame res)\n{\n    float laugh = sin(iTime * 5.0) + sin(iTime * 16.34) * 0.5;\n    \n    float opening = Noise1(iTime, 444.0);\n    res.eyeOpening = 0.6 + opening * 0.4;\n    res.browBend = laugh * 0.3 + 0.1;\n    \n    float smile = Noise1(iTime * 1.56, 447.0);\n    \n    res.moustacheBend = -0.1 +  smile * 0.5;//sin(iTime * 2.0) * 0.3;\n    \n    res.mouthOpenVert =  0.03 + laugh * 0.02;//sin(iTime * 3.0) * 0.04;\n    res.mouthOpenHoriz = - laugh * 0.02;// + smile * 0.08;//-0.02;//sin(iTime) * 0.05;\n    res.bendX = -laugh * 0.2 + 0.05;\n\n    res.twistX = 0.0;//Noise1(iTime * 0.3, 487.0) * 0.5;\n                        \n    res.eyelidsOpen = 0.0;\n    \n    res.headRotation = vec2(0.4 + laugh * 0.2, Noise1(iTime * 0.2, 444.0) * 1.2);\n    \n    res.eyePos = vec2(0.0, 4.0);\n}\n\n\nvoid AmazedExpression(out KeyFrame res)\n{\n    float hfNoise = Noise1(iTime * 4.0, 36.0);\n  \tfloat opening = Noise1(iTime * 0.7, 444.0);\n    res.eyeOpening = 1.3 + opening * 0.2;\n    res.browBend = -opening * 0.2 + 0.1;\n    res.moustacheBend = hfNoise * 0.05 - 0.05;//sin(iTime * 2.0) * 0.3;\n    \n    float smile = Noise1(iTime * 0.56, 447.0);\n    \n    res.mouthOpenVert =  0.04 - hfNoise * 0.01;//sin(iTime * 3.0) * 0.04;\n    res.mouthOpenHoriz = 0.0 + smile * 0.02;//-0.02;//sin(iTime) * 0.05;\n    res.bendX = -0.1;//sin(iTime) * 0.3;\n    res.twistX = -opening * 0.1;//sin(iTime * 10.0) * 0.2;\n\n    \n    float eyelidsOpen = fract(iTime * 0.3) * 30.0;\n                        \n    res.eyelidsOpen = eyelidsOpen;\n    \n    \n    \n    float rotX = Noise1(iTime * 0.3, 14.0);\n    res.headRotation = vec2(rotX * 0.5 + 0.15, opening * 0.3);\n    \n    res.eyePos = vec2(opening * 0.5 + hfNoise * 0.2, 3.8 );\n}\n\n// Chooses a random anim based on a [0 - 1] seed\n\nvoid ExpressionForSeed(out KeyFrame res, float seed)\n{\n    if (seed < 0.25)\n    {\n\t\tLaughExpression(res);\n    }\n    else if (seed < 0.75)\n    {\n       HappyExpression(res);\n    }\n    else// if (seed < 0.75)\n    {\n       AmazedExpression(res);\n    }\n    /*\n    else\n    {\n       AngryExpression(res);// Not sure I like this expression anymore\n    }*/\n}\n\n// Build all the matrices and offsets necessary to compute the SDF\n// leaving all that in would lead to bad perfs and longer compile times\nvoid buildMatSpace(KeyFrame frame, out MatSpace res)\n{\n    res.moustacheBend = frame.moustacheBend;\n    res.twistLower = -0.4 + frame.mouthOpenVert * 0.5;\n    res.twistX = frame.twistX;\n    res.bendX = frame.bendX;\n    res.moustacheBend = frame.moustacheBend;\n\n    res.eyeRad = vec3(0.21, 0.37 * frame.eyeOpening, 0.20) * 0.5;\n    res.cheekPos = vec3(0.2 + frame.mouthOpenHoriz * 0.5, -0.014 - frame.mouthOpenVert, -0.19);\n    res.cheekRad = vec3(0.51, 0.55 + frame.mouthOpenVert * 0.5, 0.57) * 0.5;\n    res.chinPos = vec3(0.0, -0.26 - frame.mouthOpenVert * 0.6, -0.22 - frame.mouthOpenVert * 1.0);\n    res.noseRad = vec3(0.42 + frame.mouthOpenHoriz, 0.39 - frame.mouthOpenHoriz * 0.5, 0.41) * 0.5;\n\n    res.mouthPos = vec3(0.0, -0.13 - frame.mouthOpenVert * 1.8, -0.41);\n    res.mouthRad = vec3(0.32, 0.16 + frame.mouthOpenVert, 0.31) * 0.5;\n\n    res.lipPos = vec3(0.0, -0.06 - frame.mouthOpenVert * 3.0, -0.36 - frame.mouthOpenVert * 1.5);\n    res.lipStretchX = 1.0f - frame.mouthOpenHoriz * 7.0;\n    res.lipThickness = 0.1 - frame.mouthOpenVert;\n\n    res.earMat = rotationX3(-65.0 * degToRad + frame.mouthOpenHoriz);\n    res.cap1Mat = rotationX3(30.0 * degToRad);\n    res.cap2Mat = rotationX3(60.0 * degToRad);\n\n    res.hairTip1 = vec3(0.45 - frame.mouthOpenVert * 0.6,0.06,-0.23);\n    res.hairTip2 = vec3(0.42 - frame.mouthOpenVert * 0.25,0.19,-0.28);\n\n    res.browOffset = (frame.eyeOpening - 1.0) * 0.15;\n    res.browBend = frame.browBend;\n\n    res.teethPos = vec3(0.0, -0.1 - frame.mouthOpenVert * 0.5, -0.2  - frame.mouthOpenVert);\n\n    res.eyePos = frame.eyePos;\n    res.eyelidsOpen = frame.eyelidsOpen;\n\n}\n\n\n// SDF of the scene\nvec2 SDF(vec3 pos, MatSpace ps)\n{   \n      \n    vec3 posUntwisted = pos * 0.1;\n    \n    //twist for th jaw\n    float twist = S(-0.1, ps.twistLower, posUntwisted.y) * ps.twistX;\n    \n    pos = rotationY3(twist) * posUntwisted;\n\n    pos.x = abs(pos.x); // face is symmetrical\n    posUntwisted.x = abs(posUntwisted.x);\n    \n    // bend for the face (happy / sad)\n    float bend = clamp(pos.x * pos.x * ps.bendX, -0.5, 0.5);\n    \n    pos.y += bend;\n    \n    // ellipsoids for the face\n    float head = sdEllipsoid(pos - vec3(0.0, 0.22, 0.03), vec3(0.96, 1.18, 0.99) * 0.5);\n    float cheek = sdEllipsoid(pos - ps.cheekPos, ps.cheekRad);\n    float chin = sdEllipsoid(pos - ps.chinPos, vec3(0.41, 0.34, 0.38) * 0.5);\n    \n    // Nose (tapered ellipsoid)\n    vec3 noseR = ps.noseRad;\n    noseR.x += clamp(pos.y * 0.125, -0.05, 0.05);\n    float nose = sdEllipsoid(pos - vec3(0.0, 0.13, -0.62), noseR);\n    \n    // holes for the eyes and mouth\n    float eye = sdEllipsoidPrecise(pos - vec3(0.14, 0.27, -0.39), ps.eyeRad);\n    \n    vec3 mouthPos = pos;\n    mouthPos.x *= ps.lipStretchX;\n    float innerMouth = sdEllipsoid(mouthPos - ps.mouthPos, ps.mouthRad);\n    \n    // lower lip is a torus\n    float lowerlip = sdTorus((mouthPos - ps.lipPos).xzy, vec2(0.15, ps.lipThickness));\n    \n   \t// ears too\n    float ear = sdTorus(ps.earMat * (pos - vec3(0.5, 0.13, 0.07)).yzx, vec2(0.16, 0.07));\n    \n    // smooth combine all that stuff\n    head = smin(head, chin, 0.06);\n    head = smin(head, lowerlip, 0.02);\n    head = smax(head, -innerMouth, 0.05);\n    head = smax(head, -eye, 0.05);\n    head = smin(head, cheek, 0.1);\n    head = smin(head, nose, 0.06);\n    head = smin(head, ear, 0.11);\n    \n    \n    // The cap is also a bunch of eelipsoids\n    vec3 cap1Pos = ps.cap1Mat * (pos - vec3(0, 0.8, -0.08));\n    float cap = sdEllipsoid(cap1Pos, vec3(1.04, 0.69, 0.77) * 0.5);\n    \n    vec3 cap2Pos = ps.cap1Mat * (pos - vec3(0, 0.46, 0.24));\n    cap = smin(cap, sdEllipsoid(cap2Pos, vec3(1.28, 0.66, 1.18) * 0.5), 0.27);\n    \n    vec3 cap3Pos = ps.cap2Mat * (pos - vec3(0.0, 0.89, 0.69));\n    cap = smax(cap, -sdEllipsoid(cap3Pos, vec3(1.95, 0.71, 1.01) * 0.5), 0.09);\n    \n    // the visor is the intersection of two capsules\n    vec3 vpos = pos;\n    vpos.x *= 0.9; // sligtly scaled\n    float visor = sdCapsule(vpos, vec3(0,0.25,0), vec3(0,0.15,-1.0), 0.5);\n    \n  \tfloat visorHollow =  -sdCapsule(vpos, vec3(0,0,0), vec3(0,0.2,-2.0), 0.56);\n                              \n    visor = smax(visor, visorHollow, 0.09);\n \tcap = max(cap, visorHollow);\n    \n    // side hair is two capsules\n    float hair = sdCapsule(pos, vec3(0.40,0.39,-0.11), ps.hairTip1, 0.07);\n    hair = smin(hair, sdCapsule(pos, vec3(0.39,0.37,-0.11), ps.hairTip2, 0.06), 0.03);\n    \n    // back hair is a bunch of allipsoids\n    float backHair = sdEllipsoid(pos - vec3(0.0, -0.02, 0.43), vec3(0.34, 0.41, 0.34) * 0.5);\n    backHair = smin(backHair, sdEllipsoid(pos - vec3(0.21, 0.02, 0.38), vec3(0.34, 0.41, 0.34) * 0.5), 0.04);\n    backHair = smin(backHair, sdEllipsoid(pos - vec3(0.37, 0.1, 0.29), vec3(0.29, 0.39, 0.29) * 0.5), 0.04);\n    \n    hair = min(hair, backHair);\n    \n    // the moustache is a torus cut with a cylinder distorted with a sine\n    vec3 mSpace = posUntwisted;\n    mSpace.y += posUntwisted.x * ps.moustacheBend;\n    \n    vec3 mPos = (mSpace - vec3(0.0, 0.8, -0.5)).xzy;\n    mPos.y *= 3.0;\n    \n    float mustache = sdTorus(mPos, vec2(0.9, 0.15));\n    \n    float mCut = length(mSpace.xy - vec2(0.08, 0.12)) - 0.26;\n    mCut -= abs(sin(mSpace.x * 25.0)) * 0.03;\n    \n    mustache = smax(mustache, mCut, 0.06);\n    \n\t// brows are made with an tapered ellipsoid cut with a cylinder\n    vec3 browPos = pos;\n    \n    browPos.y += (pos.x - 0.15) * ps.browBend;\n    float brow = sdEllipsoid(browPos - vec3(0.17, 0.42 + ps.browOffset, -0.44 + browPos.x * 0.3), vec3(0.3, 0.3, 0.1) * 0.5);\n    float browCut = length(browPos.xy - vec2(0.15, 0.33 + ps.browOffset)) - 0.17;\n    \n    brow = smax(brow, -browCut, 0.03);\n    \n    mustache = min(mustache, brow);\n    \n    // teeth are a cylinder compound\n    vec3 tPos = pos - ps.teethPos;\n    \n    float teeth = length(tPos.xz) - 0.25;\n    teeth = abs(teeth) - 0.02;\n    teeth = max(teeth, abs(tPos.y) - 0.06);\n    \n    float eyes = sdEllipsoid(pos - vec3(0.0, 0.25, -0.17), vec3(0.78, 0.74, 0.50) * 0.5);\n    \n\n    // Combine all parts together with materil ids\n    vec2 res = vec2(head, innerMouth < 0.0 ? INSIDE_MOUTH : SKIN);\n    res = combineMin(res, vec2(cap, CAP));\n    res = combineMin(res, vec2(visor, CAP2));\n\tres = combineMin(res, vec2(hair, HAIR));\n    res = combineMin(res, vec2(mustache, HAIR2));\n    res = combineMin(res, vec2(eyes, EYES));\n    res = combineMin(res, vec2(teeth, TEETH));\n\treturn res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos, MatSpace ps)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e, ps).x;\n    }\n    return normalize(n);\n}\n\n// inspired by\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 pos, vec3 lPos, MatSpace ps)\n{   \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += dir * MIN_DST * 2.0;  // Get out of the surface\n    \n    float dst = SDF(pos, ps).x; // Get the SDF\n    \n    // Start casting the ray\n    float t = 0.0;\n    float obscurance = 1.0;\n    \n    while (t < len)\n    {\n        if (dst < MIN_DST) return 0.0; \n        obscurance = min(obscurance, (20.0 * dst / t)); \n        t += dst;\n        pos += dst * dir;\n        dst = SDF(pos, ps).x;\n    }\n    return obscurance;     \n}\n\nfloat shadow(vec3 p, vec3 n, vec3 lPos, MatSpace ps)\n{\n    return shadow(p + n * MIN_DST * 40.0, lPos, ps);\n}\n\n// Cast a ray across the SDF return x: Distance, y: Materila Id\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst, MatSpace ps)\n{\n    vec2 dst = vec2(minDst * 2.0, 0.0);\n    \n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        dst = SDF(pos, ps);\n        t += dst.x;\n        pos += dst.x * dir;\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\n\n// A PBR-ish lighting model\nvec3 PBRLight(vec3 pos, vec3 normal, vec3 view, PBRMat mat, vec3 lightPos, vec3 lightColor, float fresnel, MatSpace ps, bool shadows)\n{\n    //Basic lambert shading stuff\n    \n    //return vec3(fresnel);\n    \n    vec3 key_Dir = lightPos - pos;\n    \n    float key_len = length(key_Dir);\n    \n\n    \n    key_Dir /= key_len;\n    \n\n    float key_lambert = max(0.0, dot(normal, key_Dir));\n    \n     \n    float key_shadow = shadows ? S(0.0, 0.10, shadow(pos, normal, lightPos, ps)) : 1.0; \n    \n    float diffuseRatio = key_lambert * key_shadow;\n   \n    \n    vec3 key_diffuse = vec3(diffuseRatio);\n    \n\n    // The more metalness the more present the Fresnel\n    float f = pow(fresnel + 0.5 * mat.metalness, mix(2.5, 0.5, mat.metalness));\n    \n    // metal specular color is albedo, it is white for dielectrics\n    vec3 specColor = mix(vec3(1.0), mat.albedo, mat.metalness);\n    \n    vec3 col = mat.albedo * key_diffuse * (1.0 - mat.metalness);\n    \n    // Reflection vector\n    vec3 refDir = reflect(view, normal);\n    \n    // Specular highlight (softer with roughness)\n    float key_spec = max(0.0, dot(key_Dir, refDir));\n    key_spec = pow(key_spec, 10.0 - 9.0 * mat.roughness) * key_shadow;\n    \n    float specRatio = mat.metalness * diffuseRatio;\n    \n    col += vec3(key_spec) * specColor * specRatio;\n    col *= lightColor;\n    \n\n    \n    return col;\n}\n\n// Some 3 octave 1D noise for animation\nfloat Noise13(float x, float seed)\n{\n    float res = Noise1(x, seed);\n    res += Noise1(x * 2.0, seed) * 0.5;\n    res += Noise1(x * 4.0, seed) * 0.25;\n    return res;\n}\n\n\nvec4 render(vec2 uvs)\n{\n    vec3 col;\n    \n\n        \n    if (dot(uvs, uvs) > 0.3) // Skip pretty much everything away from the head\n    {\n       \t//return vec4(1.0);\n    }\n    else\n    {\n        // arrival spin\n        float arrival = 1.0 - min(iTime * 0.5, 1.0);\n        arrival *= arrival;\n\n        \n        // build camera ray\n        vec3 camPos = vec3(0.0, 3.25, -42.0);\n        vec3 camDir = vec3(0.0, 0.0,  1.0);\n        vec3 rayDir = camDir + vec3(uvs * 0.45, 0.0);\n\n\t\t// mouse interaction\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        if(mouse.x<.001) mouse = vec2(0.5, 0.5);\n\n        vec2 viewAngle = vec2((-mouse.x - 0.45) * pi2, (mouse.y - 0.5) * 0.8);\n\n        MatSpace matSpace;\n\n        // compute two animations\n        float slice = iTime * 0.2;\n        float id = floor(slice);\n        float progress = fract(slice);\n\n        KeyFrame kf1;\n        ExpressionForSeed(kf1, N2(vec2(id, 135.0)));\n\n        KeyFrame kf2;\n        ExpressionForSeed(kf2, N2(vec2(id + 1.0, 135.0)));\n\n\t\t// blend them together\n        KeyFrame kf;\n        mixKeyFrame(kf1, kf2, S(0.8, 1.0, progress), kf);\n\n        // compute the head rotation matrix\n        mat4 rotX = rotationX(kf.headRotation.x - arrival * 0.5);\n        mat4 rotY = rotationY(kf.headRotation.y  + arrival * (pi * 5.0));\n        mat4 rotZ = rotationZ(Noise1(iTime * 0.2, 345.0) * 0.2);\n        mat4 modelMat = rotY * rotX * rotZ;\n\n\n\t\t// then the viwe matrix\n        mat4 viewMat =  rotationY(viewAngle.x) * rotationX(viewAngle.y);\n        mat4 modelViewMat = modelMat * viewMat;\n\n\n\t\t// transform the ray in object space\n        camPos = (modelViewMat * vec4(camPos, 1.0)).xyz;\n        rayDir = (modelViewMat * vec4(rayDir, 0.0)).xyz;\n\n\n        // Build matrices & offsets\n        buildMatSpace(kf, matSpace);\n\n        \n\t\tvec2 d = castRay(camPos, rayDir, MAX_DST, MIN_DST, matSpace);\n        \n        if (d.x < MAX_DST)\n    \t{\n            // if it's a hit render the face\n            \n        \tvec3 pos = camPos + rayDir * d.x;\n \t\n        \tvec3 n;\n        \t\n        \tvec3 normalOffset = vec3(0);\n        \t\n            // compute the surface material\n        \tPBRMat mat;\n        \tGetColor(d.y, pos, matSpace, mat, normalOffset);\n        \t\n        \tmat.albedo *= mat.albedo; // Convert albedo to linear space\n        \t\n        \tn = normalize(calcNormal(pos, matSpace) + normalOffset);\n        \t\n            // Fake AO\n        \tfloat ao = SDF(pos + n * 0.7, matSpace).x;\n        \t\n\n        \tcol = mat.albedo * 0.2;\n        \t\n        \t// Fresnel\n        \tfloat fresnel = 1.0 - sat(dot(n, -rayDir));\n\t\n\t\n            // transform lights to object space\n        \tvec3 key_LightPos = (modelViewMat * vec4(12.0, 3.0, -30.0, 0.0)).xyz;        \n        \tvec3 fill_LightPos =  (modelViewMat * vec4(-15.0, -7.0, 10.0, 0.0)).xyz;\n            \n            // Add lighting\n        \tcol += PBRLight(pos, n, rayDir, mat, key_LightPos, vec3(1.2), fresnel, matSpace, true);\n        \tcol += PBRLight(pos, n, rayDir, mat, fill_LightPos, vec3(3.0), fresnel, matSpace, true);\n\t\n \t\t\tcol *= S(0.0, 0.1, ao) * 0.5 + 0.5; // blend AO to unflatten a bit\n        \t\n    \t\tcol = pow(col,vec3(0.4545)); // gamma correction\n    \t\treturn vec4(col, 0.0);\n    \t}\n    }\n    \n    // Background\n \n    vec2 screens = fract(uvs * vec2(2.2, 3.0) + vec2(0.0, 0.5)) - vec2(0.5, 0.5);\n\n    vec2 as = abs(screens);\n\n    float dark = S(0.7, 0.1, as.x) * S(0.7, 0.1, as.y);\n\n    vec3 deepBlue = vec3(0.2, 0.2, 0.8);\n    vec3 lightBlue = vec3(0.3, 0.4, 0.9);\n\n    float m = S(-0.1, 0.1, MDist(screens * vec2(6.0, 4.0) - vec2(0, -0.3)));\n\n    float scan = sin(uvs.y * 100.0 + iTime * 3.0) * 0.1;\n\n    float noiseFrame = floor(iTime * 20.0);\n    float noise = Noise2(uvs * 140.0 + vec2(noiseFrame * 14.3, noiseFrame * 4.3)) * 0.35;\n\n    col = mix(lightBlue, deepBlue, m + scan + noise)  * dark;\n  \n    return vec4(col, 0.0);\n}\n\n// Classic stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 res = render(uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 23366,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/user-147775334/itsa-me-mario-a-trap-creation-produced-by-dj-alexy"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n#define degToRad (pi / 180.0)\n\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat3 rotationX3( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat3(1.0, 0,\t 0,\n\t\t\t \t0, \t c,\t-s,\n\t\t\t\t0, \t s,\t c);\n}\n\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat3 rotationY3( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat3( c, 0,\t s,\n\t\t\t \t 0,\t1.0, 0,\n\t\t\t\t-s,\t0,\t c);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(pos - center) - radius;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat dot2( vec2 v ) { return dot(v,v); }\n\n\nvec2 combineMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x)? a : b;\n}\n\nvec2 combineMax(vec2 a, vec2 b)\n{\n    return (a.x > b.x)? a : b;\n}\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoidPrecise( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k1 = length(p/r);\n    return (k1-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(1456.2346));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// A 2d Noise\nfloat Noise2(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    //diff = smoothstep(vec2(0), vec2(1), diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\n// 1d Noise, y is seed\nfloat Noise1(float x, float seed)\n{\n    vec2 uv = vec2(x, seed);\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    float diff = fract(uv.x);\n    \n    diff = diff * diff * (3.0 - 2.0 * diff);\n    \n    return mix(c00, c10, diff) - 0.5;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}