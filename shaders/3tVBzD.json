{
    "Shader": {
        "info": {
            "date": "1618050608",
            "description": "This is a description",
            "flags": 100,
            "hasliked": 0,
            "id": "3tVBzD",
            "likes": 20,
            "name": "Pixels3000",
            "published": 3,
            "tags": [
                "grid",
                "retro",
                "pixels",
                "pioupiou"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 1011
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 postFX(vec2 uv, float blur)\n{\n    vec3 col;\n    int cnt = 20;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 2.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n    \tcol += texture(iChannel0, p).xyz;\n    }\n    \n    return col/float(cnt);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = postFX(uv,mix(0.01,0.05, sin(iTime)*.5+.5))*mix(1., 2., pow(FFT(5), 5.));\n    \n\tcol = pow(col*1.25, vec3(1.+length(uv)));\n\n    col *= pow(FFT(0), .1);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 26606,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/plant43/interlinked-ep-plant43-recordings-005"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec2 map(vec3 p)\n{\n    vec2 gnd = vec2(_plane(-p), 0.);\n    vec2 ex = vec2(min(_sph(p+vec3(0.,2.,sin(iTime*2.)), .5), _sph(p-vec3(sin(iTime), -2.+cos(iTime*.5),0.), .5)), 1.);\n    vec2 outD = _min(ex, gnd);\n    \n    float repa = 20.;\n    vec3 pa = p+vec3(0.,3.,iTime*15.);\n    pa.z = mod(pa.z+.5*repa, repa)-repa*.5;\n    pa.x += sin(pa.z-iTime)*1.5;\n    pa.y += cos(pa.z+iTime)+sin(iTime);\n    vec2 cubeA = vec2(_cube(pa, vec3(.1,.1,5.)), 1.);\n    \n    float repb = 40.;\n    vec3 pb = p+vec3(3.,3.,iTime*25.);\n    pb.z = mod(pb.z+.5*repb, repb)-repb*.5;\n    vec2 cubeB = vec2(_cube(pb, vec3(.2,1.,15.)), 2.);\n    \n    float repc = 40.;\n    vec3 pc = p+vec3(-3.,0.,iTime*55.);\n    pc.z = mod(pc.z+.5*repc, repc)-repc*.5;\n    vec2 cubeC = vec2(_cube(pc, vec3(.5,.05,15.)), 2.);\n    \n    outD = _min(outD, cubeA);\n    outD = _min(outD, cubeB);\n    outD = _min(outD, cubeC);\n    return outD;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    uv *= 1.; // FOV\n    vec2 uvs = sign(uv);\n    //uv = uvs*pow(abs(uv), vec2(.8));\n    uv *= pow(sat(length(uv*1.)), mix(.1, 0.5, sin(iTime*.5)*.5+.5));\n    return normalize(rd+uv.x*r+uv.y*u);\n}\n\n\nvec3 normal(vec3 p, float d)\n{\n    vec3 eps = vec3(0.01, 0.,0.);\n    return normalize(vec3(map(p+eps.xyy).x, map(p+eps.yxy).x, map(p+eps.yyx).x)-vec3(d));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.392,0.212,0.471)*(1.-sat(lenny(uv*2.)));\n    \n    vec3 ro = vec3(sin(iTime*.5)*3.,sin(iTime)*.5-1.5,-7.);\n    vec3 ta = vec3(0.,-2.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 p = ro;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            vec3 n = normal(p, res.x);\n            col = vec3(1.)*n*0.5+0.5;\n            vec3 a = vec3(0.784,0.000,1.000);\n            vec3 b = vec3(0.000,1.000,0.569);\n            if (res.y == 2.)\n            {\n                a = vec3(1.000,0.020,0.216);\n                b = vec3(0.996,0.765,0.125);\n            }\n            \n                col = mix(a, b, sat(0.5+0.5*dot(n, normalize(vec3(1.)))));\n            if (res.y < 0.5)\n            {\n                col = vec3(.5);\n                float th = .9;\n                vec2 sine = sat(sin(p.xz*5.+vec2(0.,iTime*25.))-th)/th;\n                float dgrd = mix(40., 1., pow(sat(length(p.xz*0.01)), .05));\n\n                \n                col *= sat(max(sine.x,sine.y)*dgrd);\n                col = mix(vec3(0.212,0.227,0.490)*.5, vec3(0.102,1.000,0.655), sat(col.x*3.));\n            }\n            \n            break;\n        }\n        p += res.x * rd*.7;\n    }\n    \n    col *= (1.-sat(lenny(uv)))+.5;\n    col += vec3(0.102,1.000,0.655)*(1.-sat(lenny(uv)))*.15;\n    return col;\n}\nvec3 rdr2(vec2 uv)\n{\n\n    \n    float a = atan(uv.y, uv.x);\n    \n    vec3 cols[7];\n    cols[0] = vec3(1.000,0.898,0.914);\n    cols[1] = vec3(1.000,0.000,0.149);\n    cols[2] = vec3(1.000,0.702,0.702);\n    cols[3] = vec3(1.000,0.302,0.580);\n    cols[4] = vec3(0.431,0.165,0.576);\n    cols[5] = vec3(0.000,1.000,0.933);\n    cols[6] = vec3(0.000,0.000,0.000);\n    \n    a+= iTime+sin(length(uv)*15.-iTime*50.)*.15*pow(FFT(100), 2.);\n    float f = sat(sin(a*2.)*.5+.5);\n    float stp = 0.15;\n    f = floor(f/stp)*stp;\n    float cur = f*7.;\n    int curIdx = min(int(floor(cur)), 6);\n    int nextIdx = min(curIdx+1, 6);\n    vec3 c = mix(cols[curIdx],cols[nextIdx], sat(fract(cur)));\n return sat((length(uv)-.25)*400.)*c*pow(1.-sat(length(uv)), .5);\n}\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec3 quantize(vec2 uv, vec3 c, float th)\n{\n    return floor((c)/th+rand(uv.xy))*th;\n}\n\nvec2 pixpix(vec2 uv, float q)\n{\n    return floor(uv/q)*q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv *= mix(1.,1.9, FFT(10));\n    \n    float uvpix = 0.005;\n    uv = pixpix(uv, uvpix);\n    \n    vec3 col = rdr(uv);\n    col *= 1.-pow(sat(length(uv*1.25)), 2.);\n    col = quantize(uv, col, 0.25);\n    \n    col = mix(col, col.zxy, sat(sin(iTime)));\n    col = mix(col, col.yzx, pow(sat(sin(iTime*0.05*FFT(100))), 5.));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n\n#define PI 3.14159265\n#define FFT(a) texelFetch(iChannel1, ivec2(a, 0), 0).x\n#define sat(a) clamp(a, 0., 1.)\n\nfloat lenny(vec2 uv)\n{\n    return abs(uv.x)+abs(uv.y);\n}\n\nfloat _sph(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat _plane(vec3 p)\n{\n    return p.y;\n}\n\nfloat _cyl(vec3 p, vec2 s)\n{\n    return 0.;\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\nvec2 _max(vec2 a, vec2 b)\n{\n    if (a.x > b.x)\n        return a;\n    return b;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}