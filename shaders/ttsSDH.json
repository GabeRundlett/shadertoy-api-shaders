{
    "Shader": {
        "info": {
            "date": "1562816820",
            "description": "top left: x=frequency, y=time, z=magnitude\ntop right: x=magnitude, y=time\nbottom left: x=frequency, y=magnitude\nbottom right: x=time, y=amplitude",
            "flags": 36,
            "hasliked": 0,
            "id": "ttsSDH",
            "likes": 13,
            "name": "2D audio visualizations",
            "published": 3,
            "tags": [
                "fft",
                "reactive",
                "audio"
            ],
            "usePreview": 0,
            "username": "zzggbb",
            "viewed": 1146
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv_drag, uv_click;\n    \n    if (iMouse.x > 0.01) {\n        // mouse input exists\n        uv_drag = iMouse.xy/iResolution.xy;\n        uv_click = iMouse.zw/iResolution.xy;\n    } else {\n        // no mouse input\n        uv_drag = vec2(0.5, 0.5);\n        uv_click = vec2(0.5, 0.5);\n    }\n\n    vec3 bg = BACKGROUND_COLOR;\n\tvec3 col;\n    \n    // top right: x=magnitude, y=time\n    vec4 tm_bounds = vec4(uv_drag.x, 1.0, 1.0, uv_drag.y);\n\n    // top left: x=frequency, y=time, z=magnitude\n    vec4 ftm_bounds = vec4(0.0, 1.0, uv_drag.x, uv_drag.y);\n\n    // bottom left: x=frequency, y=magnitude\n    vec4 fm_bounds = vec4(0.0, uv_drag.y, uv_drag.x, 0.0);\n\n    // bottom right: x=time, y=amplitude\n    vec4 ta_bounds = vec4(uv_drag.x, uv_drag.y, 1.0, 0.0);\n    \n    if (within(uv, ftm_bounds) > 0.0) {\n        // spectrogram (time vs frequency)\n        vec2 v = viewscale(uv, ftm_bounds);\n        #if FLOW\n        \tivec2 tex_p = ivec2(v.x * iResolution.x, v.y * fragCoord.y);\n        #else\n        \tivec2 tex_p = ivec2(v * iResolution.xy);\n\t\t#endif\n        col = texelFetch(SPECTROGRAM, tex_p, 0).rgb;\n    }\n    \n    if (within(uv, fm_bounds) > 0.0) {\n        // spectrum (magnitude vs frequency)\n        vec2 v = viewscale(uv, fm_bounds);\n        ivec2 tex_p = ivec2(v.x * iResolution.x, 0.0);\n        vec4 fft_obj = texelFetch(SPECTROGRAM, tex_p, 0);\n        float fft_y = fft_obj.a;\n\t\tfloat on_curve = shade_curve(v.y, fft_y, dFdx(fft_y));\n        col = mix(bg, color(fft_y), on_curve);\n        \n        #if ENABLE_CENTROID\n        float sc_x = texelFetch(STATE, ivec2(0, 0), 0).a;\t\n        float height = 1.0;//FM_BOUNDS.y - FM_BOUNDS.w;\n        float width = fm_bounds.z - fm_bounds.x;\n        float center = 0.5;\n        float bar_enable = step_pulse(v.x, sc_x, CENTROID_THICKNESS);\n        col += vec3(1.0) * bar_enable;\n        #endif\n    }\n    \n    if (within(uv, ta_bounds) > 0.0) {\n    \t// waveform (amplitude vs time)\n        vec2 v = viewscale(uv, ta_bounds);\n        ivec2 tex_p = ivec2(v * iResolution.xy);\n        col = texelFetch(WAVEFORM, tex_p, 0).rgb;\n    }\n    \n    if (within(uv, tm_bounds) > 0.0) {\n        vec2 v = viewscale(uv, tm_bounds);\n\n        float tex_x;\n        if (within(uv_drag, ftm_bounds) > 0.0) {\n            tex_x = linscale(\n                uv_drag.x, ftm_bounds.x, ftm_bounds.z, \n                0.0, iResolution.x\n            );   \n        }\n        \n        #if FLOW\n        \tivec2 tex_p = ivec2(tex_x, v.y * fragCoord.y);\n        #else\n       \t\tivec2 tex_p = ivec2(tex_x, v.y * iResolution.y);\n        #endif\n        vec4 fft_obj = texelFetch(SPECTROGRAM, tex_p, 0);\n        ivec2 texp_p;\n        if (tex_p.y == int(iResolution.y) - 1)\n            texp_p = tex_p;\n        else\n            texp_p = tex_p + ivec2(0, 1);\n        \n        vec4 fftp_obj = texelFetch(SPECTROGRAM, texp_p, 0);\n        float fft_y = fft_obj.a;\n        float fftp_y = fftp_obj.a;\n        //float on_curve = between(v.x, vec2(fft_y, fftp_y));\n        \n        /*\n        float on_curve = smooth_line(\n            sd_line(\n                v, \n                vec2(fft_y, v.y),\n                vec2(fftp_y, v.y)\n            ), 0.001, 4.0\n       \t);\n\t\t*/\n\t\t\n        \n        float on_curve = shade_curve(v.x, fft_y, dFdx(fft_y));\n        col = mix(bg, color(v.x), on_curve);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float spectral_centroid(void) {\n\tfloat weighted_sum = 0.0;\n    float area = 0.0;\n    \n    float frequency_uv;\n    float magnitude;\n    float tex_x;\n    for (float i=0.0; i<AUDIO_IN_SIZE; i++) {\n        tex_x = linscale(i, 0.0, AUDIO_IN_SIZE-1.0, 0.0, iResolution.x);\n        magnitude = texelFetch(SPECTROGRAM, ivec2(tex_x, 0), 0).a;\n        frequency_uv = i;\n        weighted_sum += magnitude*frequency_uv;\n        area += magnitude;\n    }\n    return weighted_sum / area;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float alpha = 0.5;\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0) {\n    \talpha = linscale(spectral_centroid(), 0.0, AUDIO_IN_SIZE-1.0, 0.0, 1.0);\n    }\n    if (int(fragCoord.x) == 1 && int(fragCoord.y) == 0) {\n    \talpha = texelFetch(STATE, ivec2(0,0), 0).a;\n    }\n    fragColor = vec4(vec3(0.0), alpha);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n- This module renders the spectrogram to Buffer B. \n- The top display (spectrogram) and middle display (magnitude spectrum)\n  both use Buffer B as their data source. \n- The bottom row of the buffer stores the most recent FFT curve. \n- The other rows are copies of the row beneath them.\n- The FFT colors are stored in the first 3 channels.\n- The y-values are stored as the alpha channel \n*/\n\nfloat cubic_interp(float x, vec4 xs, vec4 ys) {\n    vec4 xs2 = xs*xs;\n    vec4 xs3 = xs*xs2;\n    mat4 A = mat4(xs3, xs2, xs, vec4(1.0));\n    vec4 k = inverse(A) * ys;\n    float x2 = x*x;\n    float x3 = x*x2;\n    return dot(k, vec4(x3, x2, x, 1.0));\n}\n\nfloat fft_sdf(vec2 p) {\n    // convert x from uv space [0..1] to fft index [0..511]\n    #if LOG_SCALE\n    \tfloat fft_x = logyscale(p.x, 0.0, 1.0, 1.0, AUDIO_IN_SIZE-2.0);\n\t#else\n    \tfloat fft_x = linscale(p.x, 0.0, 1.0, 1.0, AUDIO_IN_SIZE-2.0);\n    #endif\n    \n    // closest previous sample\n    float fft_x1 = floor(fft_x); \n    float fft_y1 = texelFetch(AUDIO_IN, ivec2(fft_x1, 0), 0).x;\n\n    // closest next sample\n    float fft_x2 = ceil(fft_x); \n    float fft_y2 = texelFetch(AUDIO_IN, ivec2(fft_x2, 0), 0).x;\n    \n    return sd_line(p, vec2(fft_x1, fft_y1), vec2(fft_x2, fft_y2));   \n}\n\nfloat fft(float x) {\n    // convert x from uv space [0..1] to fft index [0..511]\n    #if LOG_SCALE\n    \tfloat fft_x = logyscale(x, 0.0, 1.0, 2.0, AUDIO_IN_SIZE-1.0);\n\t#else\n    \tfloat fft_x = linscale(x, 0.0, 1.0, 2.0, AUDIO_IN_SIZE-1.0);\n    #endif\n    \n    // sample before closest previous sample\n    float fft_x0 = floor(fft_x) - 1.0;\n    float fft_y0 = texelFetch(AUDIO_IN, ivec2(fft_x0, 0), 0).x;    \n    \n    // closest previous sample\n    float fft_x1 = floor(fft_x); \n    float fft_y1 = texelFetch(AUDIO_IN, ivec2(fft_x1, 0), 0).x;\n\n    // closest next sample\n    float fft_x2 = ceil(fft_x); \n    float fft_y2 = texelFetch(AUDIO_IN, ivec2(fft_x2, 0), 0).x;\n    \n    // sample after closest next sample\n    float fft_x3 = ceil(fft_x) + 1.0; \n    float fft_y3 = texelFetch(AUDIO_IN, ivec2(fft_x3, 0), 0).x;\n    \n    vec4 fft_xs = vec4(fft_x0, fft_x1, fft_x2, fft_x3);\n    vec4 fft_ys = vec4(fft_y0, fft_y1, fft_y2, fft_y3);\n\n    #if INTERP == 2\n    // cubic interpolation (smooth corners)\n    float fft_y;\n    if (x > 0.5)\n        fft_y = linscale(fft_x, fft_x1, fft_x2, fft_y1, fft_y2);\n    else\n\t\tfft_y = cubic_interp(fft_x, fft_xs, fft_ys);\n    \n    #elif INTERP == 1\n    // linear interpolation (sharp corners)\n    float fft_y = linscale(fft_x, fft_x1, fft_x2, fft_y1, fft_y2);\n    \n    #elif INTERP == 0\n    // nearest neighbor interpolation\n    float fft_y = fft_y1;\n    #endif\n    \n    /*\n    float xbar = (fft_x1+fft_x2)/2.0;\n    if (between(fft_x, vec2(fft_x1, xbar)) > 0.0) {\n    \tfft_y = linscale(fft_x, fft_x1, xbar, fft_y1, 0.0);\n    } else {\n    \tfft_y = linscale(fft_x, xbar, fft_x2, 0.0, fft_y2);\n    }\n\t*/\n    \n    return pow(fft_y, FFT_POW);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 col;\n    bool freeze = false;\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    if (0.0 <= uv.y && uv.y <= SPECTROGRAM_SPEED && !freeze) {\n        // shading a pixel in the bottom row, so calculate the FFT curve\n        float y = fft(uv.x);\n        vec3 col = color(y);\n        \n        #if ENABLE_CENTROID\n        float sc_x = texelFetch(STATE, ivec2(0, 0), 0).a;\n        float sc_xp = texelFetch(STATE, ivec2(1, 0), 0).a;\n        //float bar_enable = between(uv.x, vec2(sc_x, sc_xp));\n        float bar_enable = smooth_line(\n            sd_line(\n                uv, \n                vec2(sc_x, 0.0),\n                vec2(sc_xp, SPECTROGRAM_SPEED)\n            ), CENTROID_THICKNESS, 4.0\n       \t);\n        col += vec3(1.0) * bar_enable;   \n        #endif\n        \n    \tfragColor = vec4(col, y);\n    } else {\n        // shading a pixel not in the bottom row, so copy from the pixel below us.\n        float y = uv.y - SPECTROGRAM_SPEED;\n        ivec2 p_tex = ivec2(vec2(uv.x, y) * iResolution.xy);\n        fragColor = texelFetch(SPECTROGRAM, p_tex, 0).rgba;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.14159265\n#define AUDIO_IN iChannel0\n#define STATE iChannel1\n#define SPECTROGRAM iChannel2\n#define WAVEFORM iChannel3\n#define AUDIO_IN_SIZE iChannelResolution[0].x\n\n#define BACKGROUND_COLOR vec3(0.05)\n\n#define FLOW 0\n\n// Number of time-amplitude waveform segment.\n// Increasing this decreases the scrolling speed of the time-amplitude waveform,\n// while also 'zooming' out of the signal.\n// Must be >= 1\n#define WAVEFORM_SEGMENTS 5.0\n\n// Scrolling speed of the spectrogram.\n#define SPECTROGRAM_SPEED 0.01\n\n// Use INTERP=2 for cubic curve interpolation\n// Use INTERP=1 for linear interpolation.\n// Use INTERP=0 for nearest neighbor interpolation.\n#define INTERP 2\n\n// use LOG_SCALE=1 for logarithmic frequency scaling.\n// use LOG_SCALE=0 for linear frequency scaling.\n#define LOG_SCALE 1\n\n// Raise the FFT to this power.\n// Powers greater than 1.0 push down the weaker magnitudes.\n// powers less than 1.0 pull up the weaker magnitudes.\n#define FFT_POW 3.0\n\n// Thickness (percent of screen height) of the frequency and time curves.\n#define THICKNESS 0.05\n\n// Use ENABLE_CENTROID=1 to draw the spectral centroid.\n// Use ENABLE_CENTROID=0 to skip drawing the centroid.\n#define ENABLE_CENTROID 1\n\n// Width of the centroid bar (in UV space)\n#define CENTROID_THICKNESS 0.005\n\n// Define our color palette\nvec3 color(float t) {\n    t *= 0.75;\n\tvec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(2.0*PI*(c*t + d));\n}\n\nfloat sd_line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smooth_line(float d, float w, float g) {\n\treturn exp(-5.0*pow(d/w, g));\n}\n\n// scale from linear range [x1,x2] to linear range [y1,y2]\nfloat linscale(float x, float x1, float x2, float y1, float y2) {\n\treturn (y2-y1)/(x2-x1)*(x-x2) + y2;   \n}\n\n// scale from logarithmic range [x1,x2] to linear range [y1,y2]\nfloat logxscale(float x, float x1, float x2, float y1, float y2) {\n\treturn (y2-y1)/(log2(x2+1.0)-log2(x1+1.0))*(log2(x+1.0)-log2(x2+1.0))+y2;   \n}\n\n// scale from linear range [x1,x2] to logarithmic range [y1,y2]\nfloat logyscale(float x, float x1, float x2, float y1, float y2) {\n    return pow(2.0, log2((y2+1.0)/(y1+1.0))*(x-x2)/(x2-x1) + log2(y2+1.0)) - 1.0;\n}\n\nfloat step_pulse(float x, float c, float w) {\n\treturn step(c-w/2.0, x) - step(c+w/2.0, x);   \n}\n\nfloat between(float x, vec2 bounds) {\n\treturn step_pulse(\n        x, \n        (bounds.x+bounds.y)/2.0, \n        abs(bounds.x-bounds.y)\n    );\n}\n\nfloat within(vec2 p, vec4 bounds) {\n\t/*\n    bounds.xy ---------\n\t|\t\t\t\t  |\n\t|\t\t\t\t  |\n\t----------bounds.zw\n    */\n    return between(p.x, bounds.xz) * between(p.y, bounds.yw);\n}\nvec2 viewscale(vec2 uv, vec4 bounds) {\n    return vec2(\n\t\tlinscale(uv.x, bounds.x, bounds.z, 0.0, 1.0),\n    \tlinscale(uv.y, bounds.w, bounds.y, 0.0, 1.0)\n    );\n}\nfloat cubic_pulse(float x, float c, float w) {\n\tx = abs(x-c);\n    if (x>w) return 0.0;\n    x/=w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat shade_curve(float v, float c, float dc) {\n\tfloat theta = abs(atan(dc));\n    float height = THICKNESS * 1.0 / cos(theta);\n    float center = linscale(\n        c, 0.0, 1.0, \n        height/2.0, 1.0-height/2.0\n    );\n    return step_pulse(v, center, height);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// amplitude of time waveform for time 'x'\nfloat wav(float x) {\n\tfloat wav_x = linscale(x, 0.0, 1.0, 0.0, AUDIO_IN_SIZE-1.0);\n    \n    float wav_x0 = ceil(wav_x) - 1.0;\n    float wav_y0 = texelFetch(AUDIO_IN, ivec2(wav_x0, 1), 0).x;\n    \n    float wav_x1 = ceil(wav_x);\n    float wav_y1 = texelFetch(AUDIO_IN, ivec2(wav_x1, 1), 0).x;\n    \n    #if INTERP == 0\n    float wav_y = wav_y1;\n    #else\n    float wav_y = linscale(wav_x, wav_x0, wav_x1, wav_y0, wav_y1);\n\t#endif\n    \n    return wav_y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    if (1.0 - 1.0/WAVEFORM_SEGMENTS < uv.x) {\n    \t// shade with fresh samples\n        vec3 bg = BACKGROUND_COLOR;\n        float wav_x = linscale(uv.x, 1.0 - 1.0/WAVEFORM_SEGMENTS, 1.0, 0.0, 1.0);\n        float wav_y = wav(wav_x);\n        float on_curve = shade_curve(uv.y, wav_y, dFdx(wav_y));\n        col = mix(bg, color(sqrt(2.0*abs(wav_y - 0.5))), on_curve);\n    } else {\n        // shade from a previously drawn segment\n        float x = fragCoord.x+1.0/WAVEFORM_SEGMENTS*iResolution.x;\n        ivec2 tex_p = ivec2(x, fragCoord.y);\n    \tcol = texelFetch(WAVEFORM, tex_p, 0).rgb;\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}