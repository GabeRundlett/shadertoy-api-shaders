{
    "Shader": {
        "info": {
            "date": "1578505670",
            "description": "Dither-Styled Polar-Coordinate Linked Geometry inspired by the work of @patriciogv on his Spirit Deck Project.\n\nINSTA: instagram.com/willstall/\nWEBSITE: willstall.com\nTWITTER: twitter.com/willstall\n",
            "flags": 0,
            "hasliked": 0,
            "id": "wty3zw",
            "likes": 5,
            "name": "Linked Twist",
            "published": 3,
            "tags": [
                "sdf",
                "dither",
                "geometry",
                "polar",
                "hex",
                "hex"
            ],
            "usePreview": 0,
            "username": "willstall",
            "viewed": 431
        },
        "renderpass": [
            {
                "code": "//------------------------------------------------------------------------\n// Linked Twist\n// by @willstall\n//------------------------------------------------------------------------\n\n#define SIDES 7\n\n#define SECONDS 5.0\n#define COLORS 24.0\n\n#define DITHER_AMOUNT 90.0\n#define DITHER_SIZE 8.0\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\nmat2 rotate(float angle){   return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );    }\n\nvec2 ratio(vec2 st)\n{\n    return  vec2(\n            max(st.x/st.y,1.0),\n            max(st.y/st.x,1.0)\n            );\n}\n\nvec2 center(vec2 st)\n{\n    float offset = iResolution.x/iResolution.y;\n    st.x = st.x * offset - offset * 0.5 + 0.5;\n    return st;\n}\n\nfloat divide(float x,float a){          return floor(x * a)/a;    }\n\n// cos color palette by iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\treturn a + b*cos( 6.28318*(c*t+d) );\t}\n\nvec3 color_gradient(float x){          return texture(iChannel0, vec2(x,0.5),-10.0).rgb;}\nvec3 color_gradient(float x,float a){   return color_gradient(divide(x,a));    }\n\nfloat random(vec2 st){  return fract( sin( dot(st,vec2(3.678,678.90)) )*678910.0 ); }\n\nfloat dither(vec2 st, float x, float amount)\n{\n    float s = 1.0/DITHER_SIZE;\n\n    st *= amount;\n    st.y += 0.5*step(mod(st.x,2.0),1.0);\n\n    float c = length(fract(st)-0.5)*x*0.5;\n    c = smoothstep(0.75,1.0,1.0-c)*(s)*0.5;   \n    return fract(x + c );\n    //return x+c;\n}\n\n\nfloat hex(vec2 pos)\n{\n    pos = abs(pos);\n    float d = dot(pos,normalize(vec2(1.0,1.73)));\n        d = max(d,pos.x);\n    return d;\n}\n\nvec2 hexCoords(vec2 st, out vec2 position)\n{\n    vec2 aspect = vec2(1.00,1.73);\n    vec2 h_aspect = aspect * 0.5;\n\n    vec2 a = mod(st,aspect)-h_aspect;\n    vec2 b = mod(st-h_aspect,aspect)-h_aspect;\n\n    vec2 grid;\n    if(length(a) <length(b))\n        grid = a;\n    else\n        grid = b;    \n\n    position = st-grid;\n    return vec2(grid.x,grid.y);\n}\n\nfloat cutout(float x, float y, float cut)\n{\n    float z = x;\n    z = max(z,-y+cut);\n    z = min(z,y);\n    return z;\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime/SECONDS);\n    float interval = floor(mod(iTime,SECONDS));\n\n\tvec2 st = fragCoord/iResolution.xy;\n    st = center(st);\n    st = st * 2.0 - 1.0;  \n    \n    vec2 uv = st;\n    \n    st *= 01.35;\n    st *= 1.0 + 0.025*sin(TWO_PI*time);\n    st *= rotate(TWO_PI*.25);      \n\n    float pixelSmoothing = 2.0;\n    float aa = ratio(iResolution.xy).x/iResolution.x;\n    aa *= pixelSmoothing;\n    \n    float cut_size = 0.1125;\n\n    const int n = SIDES;\n    float a = TWO_PI/float(n);\n\n    vec2 pos;\n    vec2 angle_st = hexCoords(st*1.0,pos);\n    float angle = atan(angle_st.x,angle_st.y)/TWO_PI+0.5;\n\n    float debug;\n    float sdf = 1.0;\n\n    float distance_offset = 0.25;\n    \n    for(int i = 0; i <= n*2; i++)\n    {\n        vec2 pos = (st) * rotate(float(i)*a)-distance_offset;\n        float size = .06*(0.5+0.5*sin(TWO_PI*time+HALF_PI*(pos.x-pos.y*.65)));\n        float d = abs(hex(pos)-0.5)+size;\n        float cut = pos.x-pos.y*.65;\n        cut = smoothstep(-aa,aa,sdf);\n        cut = (mod(float(i),2.0) >= 1.0) ? 1.0-cut :cut;\n\n        float m = cutout(d/cut,sdf/cut,cut_size);\n        sdf = min(sdf,m);\n    }\n\n    float texture = dither(st,sdf+a,DITHER_AMOUNT);\n    float cutoff = sdf-0.025;\n    cutoff = smoothstep(-aa,aa,cutoff);\n    \n    st = hexCoords(st*0.44,pos);\n    a = atan(st.x,st.y)/TWO_PI+0.5;\n\t\n    float grad = fract(texture*1.0-time*1.0+a*1.0);\n    vec3 tex = color_gradient(grad,COLORS);\n\t\n    vec3 p = palette(length(tex),vec3(1.25,0.125,0.025),vec3(0.0,0.95,0.125),vec3(1.0, 0.5, 0.0),vec3(0.5));\n    tex = p;\n    \n    float size = hex(st);\n    float outside_cutoff = max(sdf-0.25,-(sdf-0.23));\n    outside_cutoff = smoothstep(-aa,aa,outside_cutoff);\n\t\n    float bg = length(uv)-0.75-0.25*random(uv);\n    vec3 background = vec3(0.9333, 0.9333, 0.9333);\n    vec3 col = vec3(background);\n    \tcol = mix(vec3(1.0),col,bg);\n        col = mix(tex,col,cutoff);\n\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}