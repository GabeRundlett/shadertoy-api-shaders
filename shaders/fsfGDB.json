{
    "Shader": {
        "info": {
            "date": "1616533917",
            "description": "Mouse controls camera.  bottom left: back to auto demo.\nSPACE to show scene.\nTAB to toggle masking of hidden parts.\nInspired by Sig'97 \"Tour into the picture\" http://graphics.cs.cmu.edu/courses/15-463/2006_fall/www/Papers/TIP.pdf",
            "flags": 16,
            "hasliked": 0,
            "id": "fsfGDB",
            "likes": 19,
            "name": "London 3D - projective mapping",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "regentstreet"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 593
        },
        "renderpass": [
            {
                "code": "#define rot(a)          mat2( cos( a + vec4(0,33,11,0)) )\n#define rot3(V)         V.yz *= rot(.03), V.xz *= rot(.4) // proj to photo frame\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat s,c0,c1, l=16.;                                 // material id\n\nfloat map( vec3 q ) {                                 // 3D model of Regent Street\n    q += vec3(-182,2,2);\n    float l = length(q.xz),\n    t = min( c1 = l-160.,                             // right facade\n             c0 = 184.-l );                           // left facade\n    t = min( t, max( l-170., 16.-q.y ));              // top of right facade\n \n    t = min(t, max( length(q.xz+vec2(174.1,40))-1.4 , abs(q.y)-1.8 ) ); // bus\n    t = min(t, max( length(q.xz+vec2(165,40))-.9 , abs(q.y)-1.45 ) );   // car\n    t = min(t, max( length(q.xz+vec2(169.5,25))-.24 , abs(q.y)-1. ) );   // pole\n    t = min( t, s = q.y);                             // floor\n    t = max( t, q.z -2. );                            // front plane\n    return t;\n}\n\n#define march \\\n    for ( ; c < 350. && t > .01 ; c++ )               /* march scene         */ \\\n        t = map(p),                                   /* distance to objects */ \\\n        p += .5*t*D;                                  /* sphere-tracing step */\n        \nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,                      // normalized centered coords\n         M = iMouse.xy;\n\n    float t = iTime, \n          c = 0., F=4.;                               // color (pseudo-shading), delta per iteration\n    vec3  D = normalize( vec3(U,-F) ),                // ray direction. z = field of view = zoom\n          p = length(M) > 20.                         // ray origin, then current point on ray\n                ? M/=R,- vec3( 4.*(M.x-.5), 0, 15.*(M.y-.2) )            // mouse control\n                                          // p.y += 5.*(1.-M.y);\n                : vec3(2.*cos(iTime),1.+sin(iTime),-5.-5.*cos(iTime/3.));// demo mode\n    rot3(D), rot3(p);                                 // rotate camera\n    march;                                            // march scene\n    \n    if (keyToggle(32)) {                              // --- show 3D mode\n        c = 1. - c/250.;                              // pseudo-lighting\n        O = t==c0 ? vec4(.6,1,.8,1) : t==c1 ? vec4(1,.8,.6,1) \n           : t==s ? vec4(0,.2,0,1) : vec4(1);         // coloring\n        O = c*O; \n    } else O-=O;\n                                                      // --- project photo on 3D scene\n    vec3 X = vec3(1,0,0), Y = vec3(0,1,0), Z = vec3(0,0,1), p0=p;\n    rot3(X), rot3(Y), rot3(Z);\n // p.xz *= rot(-.4); p.yz *= rot(-.03);              // why is it not equivalent ?\n    vec2 T = .5 - 2.*R.y/R*vec2( dot(p,X), dot(p,Y) ) / dot(p,Z), // go to texture-projector space\n         A = abs(T-.5); \n    D = normalize(p), p-=p, c=0., t++; march;         // new ray to check whether p was hidden\n    if ( max(A.x,A.y) < .5) O += keyToggle(32)\n               ? 2.*( textureLod(iChannel0,T,0.) - textureLod(iChannel0,T,2.) ) // sketch (in 3D mode )\n               : length(p-p0)/ abs(dot(p0,Z))<.1 || !keyToggle(9)               // p not hidden:\n                   ?   texture(iChannel0,T)                                     // projected texture\n                   : ( textureLod(iChannel0,T,log2(l))*l-texture(iChannel0,T) )/(l-1.); // desoccluded: mask front object\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}