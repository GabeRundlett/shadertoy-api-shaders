{
    "Shader": {
        "info": {
            "date": "1677339696",
            "description": "After being struck with a bit of melancholy while driving home alone during a cold, foggy night, I tried to capture that feeling into this, somewhat too basic for my liking, scene.",
            "flags": 96,
            "hasliked": 0,
            "id": "md33WN",
            "likes": 17,
            "name": "Road to Nowhere",
            "published": 3,
            "tags": [
                "raymarching",
                "noise",
                "sdf",
                "pointlight",
                "road",
                "stars",
                "night",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "sagieL",
            "viewed": 1562
        },
        "renderpass": [
            {
                "code": "// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Special thanks to BigWings and mithrandir for the Raymarching templates \n// and to IQ for all the SDFs in the world.\n\n// Post processing effects go here.\n\n#define RES iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const mat3 YIQ2RGB = mat3(1    , 1     , 1     ,\n                              0.956, -0.272, -1.106,\n                              0.619, -0.647,  1.703);\n                              \n    const mat3 RGB2YIQ = mat3(0.299,  0.596,  0.212,\n                              0.587, -0.274, -0.523,\n                              0.114, -0.322,  0.311);\n                              \n    vec2 uv = fragCoord / RES;\n    vec3 col = texture(iChannel0, uv).rgb; \n    \n    // Desaturate.\n    vec3 colYIQ = RGB2YIQ * col;\n    colYIQ.yz *= .85;\n    \n    col = YIQ2RGB * colYIQ;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 32507,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://on.soundcloud.com/r37u4"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Special thanks to BigWings and mithrandir for the Raymarching templates \n// and to IQ for all the SDFs in the world.\n\n#define TAU 6.283185\n#define PI 3.141592\n\nstruct Mat {\n    vec3 col;\n    float spec;\n};\n\nstruct RayOut {\n  Mat mat;\n  float dist;\n};\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// SDFs from https://iquilezles.org/articles/distfunctions\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdFog(vec3 p, vec3 center, float near, float far) {\n    float fogDepth = max(far - near, 1.);\n    float dist = length(p - center);\n    dist = far - dist;\n    \n    return clamp(dist / fogDepth, 0.0, 1.0);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/// NOISE\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n  p = fract(p * 0.011); \n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n// Exposure tone mapping.\nvec3 toneMapping(vec3 hdrColor, float exposure) {\n   vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);\n   return mapped;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Special thanks to BigWings and mithrandir for the Raymarching templates \n// and to IQ for all the SDFs in the world.\n\n// Here's where the scene is rendered.\n\n#define RES iResolution.xy\n#define EPS .000001\n\n#define MAX_STEPS 100\n#define SHADOW_STEPS 75\n#define MAX_DIST 200.\n#define SURF_DIST .001\n\n// Light.\n#define LIGHT_COLOR vec3(1.0, .3, .05)\n#define LIGHT_INTENSITY 5.\n#define SKY_COLOR vec3(0.01,0.03,0.2)\n#define OFF_BLACK vec3(0.0003)\n#define FAR_MOUNTAINS_FOG vec3(0.0001,0.0001,0.0015)\n#define BOUNCE_COLOR vec3(0.4,0.02,0.02) * .1\n#define PLANE_TEXTURE_TILLING 0.5\n\n#define POINT_LIGHT_ATTEN vec3(0.72, .09, .053)\n#define INIT_LIGHT_POS vec3(0., LAMP_HEAD_ROADSIDE - 2., LAMP_HEAD_HEIGHT + 1.)\n#define FAR_FOG_DIST_SCALE .92\n#define ROAD_FOG_DIST 50.\n\n// Lamp.\n#define LAMP_REPEAT_DIST 40.\n#define LAMP_HEAD_HEIGHT 3.3\n#define LAMP_HEAD_ROADSIDE 4.4\n\n#define FOG_COL vec3(0.05, 0.1, 0.3) * 0.08\n\n// Camera.\n#define CAMERA_HEIGHT 3.0\n#define CAMERA_INIT_POS\t0.0\n#define CAMERA_SPEED 4.0\n\n// Materials.\n#define ROAD_MAT Mat(vec3(0.2, 0.2, 0.2), 10.)\n#define MOUNTAIN_MAT Mat(vec3(0.01, 0.3, 0.1), 1.)\n#define ROAD_WHITE_LINE_MAT Mat(vec3(0.95), 40.)\n#define ROAD_YELLOW_LINE_MAT Mat(vec3(0.7, 0.7, 0.1), 40.)\n#define LAMP_STEEL_MAT Mat(vec3(0.06, 0.06, 0.06), 120.)\n#define LAMP_LIGHT_BULB Mat(LIGHT_COLOR * 6., 1.)\n\nfloat LampXRepeat(float x) {\n    return mod(x, LAMP_REPEAT_DIST) - LAMP_REPEAT_DIST * 0.5;\n}\n\nfloat MountainSideDist(float z, float scale) {\n    return smoothstep(10., 20., abs(z) * scale);\n}\n\nRayOut SceneDist(vec3 p, int onlyDist) {    \n    Mat mat;\n    \n    // StreetLamp.\n    float lampXPos = LampXRepeat(p.x);\n    float lampZPos = abs(p.z);\n    float lampBase = sdCapsule(vec3(lampXPos, p.y, lampZPos - 5.8), vec3(0., 0., 0.), vec3(0, 3., 0.), .1);\n    float lampExt = sdCapsule(vec3(lampXPos, p.y, lampZPos - 5.8), vec3(0., 3., 0.), vec3(0., 3.5, -1.4), .1);\n    float lampHead = sdCappedCone(vec3(lampXPos , p.y - LAMP_HEAD_HEIGHT, lampZPos - LAMP_HEAD_ROADSIDE), .28, .4, .12);\n    float lamp = smin(smin(lampBase, lampExt, .05), lampHead, 0.1);\n    float lightBulb = sdSphere(vec3(lampXPos , p.y - LAMP_HEAD_HEIGHT + .15, lampZPos - LAMP_HEAD_ROADSIDE), .22);\n    \n    // Road.\n    float yellowLines = sdBox(vec3(p.y, fract(p.x), abs(p.z) - 5.), vec3(0.001, 2., .4));\n    float whiteLines = sdBox(vec3(p.y, mod(p.x, 5.), p.z), vec3(0.001, 2., .2));\n    \n    float sideDist = MountainSideDist(p.z, 1.);\n    \n    // TODO: why are there artifacts when maxMountainsHeight >= 15??\n    const float maxMountainsHeight = 14.;\n    const float maxRocksHeight = 1.8;\n \n    float noise1 = noise(p.xz * 0.1);\n    float noise2 = noise(p.xz * 1.6);\n    \n    float mountainsHeight = mix(0., maxMountainsHeight, clamp(pow(abs(p.z) * 0.02, 2.), 0., 1.)) * noise1;\n    float groundPlainDistScaled = clamp(length(p.yz) * 0.02, 0., 1.);\n    float rocksHeight = mix(maxRocksHeight, 0., groundPlainDistScaled) * noise2;\n    float ground = p.y - sideDist * (mountainsHeight + rocksHeight * step(groundPlainDistScaled, .35));\n    \n    float d = min(\n        min(ground, whiteLines),\n        min(min(yellowLines, lamp), lightBulb)\n    );\n    \n    // This value should be uniform for all calls in a given scope. \n    // Is this a good optimization? \n    if (onlyDist == 1) { return RayOut(mat, d); }\n    \n    float grain = texture(iChannel0, p.xz * PLANE_TEXTURE_TILLING).r;\n    \n    Mat groundMat = Mat(mix(ROAD_MAT.col * grain, ROAD_MAT.col, 0.1), ROAD_MAT.spec);\n    groundMat.col = mix(groundMat.col, MOUNTAIN_MAT.col, sideDist);\n    float isGround = step(abs(d - ground), EPS);\n    \n    Mat whiteLinesMat = ROAD_WHITE_LINE_MAT;\n    whiteLinesMat.col = mix(whiteLinesMat.col * grain, whiteLinesMat.col, 0.8);\n    float isWhiteLines = step(abs(d - whiteLines), EPS);\n    \n    Mat yellowLinesMat = ROAD_YELLOW_LINE_MAT;\n    yellowLinesMat.col = mix(yellowLinesMat.col * grain, yellowLinesMat.col, 0.8);\n    float isYellowLines = step(abs(d - yellowLines), EPS);\n    \n    float isLamp = step(abs(d - lamp), EPS);\n    float isLightBulb = step(abs(d - lightBulb), EPS);\n        \n    mat.col = \n      groundMat.col * isGround +\n      whiteLinesMat.col * isWhiteLines +\n      yellowLinesMat.col * isYellowLines +\n      LAMP_STEEL_MAT.col * isLamp +\n      LAMP_LIGHT_BULB.col * isLightBulb;\n      \n    mat.spec = \n      groundMat.spec * isGround +\n      whiteLinesMat.spec * isWhiteLines +\n      yellowLinesMat.spec * isYellowLines +\n      LAMP_STEEL_MAT.spec * isLamp +\n      LAMP_LIGHT_BULB.spec * isLightBulb;\n    \n    return RayOut(mat, d);\n}\n\nRayOut RayMarch(vec3 ro, vec3 rd, int steps, int onlyDist) {\n\tfloat dO = 0.;\n    RayOut rayOut = RayOut(Mat(vec3(0), 1.), MAX_DIST);\n    \n    for(int i = 0; i < steps; i++) {\n    \tvec3 p = ro + rd*dO;\n        rayOut = SceneDist(p, onlyDist);\n        dO += rayOut.dist;\n        \n        if (dO > MAX_DIST || rayOut.dist < SURF_DIST) { break; }\n    }\n    \n    return RayOut(rayOut.mat, dO);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(SURF_DIST, 0);\n    vec3 n = SceneDist(p, 1).dist - \n        vec3(SceneDist(p-e.xyy, 1).dist,\n             SceneDist(p-e.yxy, 1).dist, \n             SceneDist(p-e.yyx, 1).dist);\n    \n    return normalize(n);\n}\n\nvec3 GetPointLight(vec3 p, vec3 n, vec3 rd, float spec, vec3 lightPos)\n{\n    vec3 light = vec3(0.0);\n    \n    float lightDist = distance(p, lightPos);\n    float attenuation = 1. / (POINT_LIGHT_ATTEN.x + POINT_LIGHT_ATTEN.y * lightDist + \n    POINT_LIGHT_ATTEN.z * lightDist * lightDist);\n    \n    if (attenuation < 0.01) { return light; } // Light is too weak to contibute, save on calcs.\n    \n    vec3 LightDir = normalize(p - lightPos);\n    vec3 P2L = -LightDir;\n    \n    float diffuse = clamp(dot(n, P2L), 0.0, 1.0);\n    \n    float shadowRayDist = RayMarch(p + n * SURF_DIST * 2., P2L, SHADOW_STEPS, 1).dist;\n\n    diffuse *= attenuation;\n        \n    float shadow = shadowRayDist < lightDist ? 0. : 1.;\n    float bounce_dif = clamp(0.5 + 0.5 * dot(n, vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n    vec3 reflection = reflect(-rd, n);\n    float specular = pow(clamp(dot(reflection, P2L), 0.0, 1.0), spec) * diffuse;\n    \n    specular *= attenuation;\n\n    light += vec3(specular) * LIGHT_COLOR * LIGHT_INTENSITY * shadow;\n    light += LIGHT_COLOR * diffuse * shadow;\n    light += BOUNCE_COLOR * bounce_dif;\n    \n    return light;\n}\n\nvec3 Stars(vec2 uv) {\n    const float maxRange = 40.;\n    vec2 range = uv * maxRange;\n    vec2 starUV = fract(range) - .5;\n    float d = length(starUV);\n    vec2 id = floor(range);\n    float n = noise(id);\n    float starExists = step(0.94, n); \n    float sparkle = smoothstep(0.9, 1., sin(n * 100. + n * .8 * iTime) * .5 + .5);\n    float starSDF = pow(0.8 - d, 20.) * mix(5., 30., sparkle);\n\n    float starIntensity = starExists * starSDF;\n    return vec3(starIntensity);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 forward = vec3(0, 0, iTime * CAMERA_SPEED);\n    vec3 ro = vec3(0, CAMERA_HEIGHT, -CAMERA_INIT_POS) + forward;\n    ro.xz *= Rot(-0.75 * TAU);\n\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    rd.xz *= Rot(-0.75 * TAU);\n    \n    //rd.xy *= Rot(-m.y * PI + 1.); // Up-down rotation.\n    //rd.xz *= Rot(-m.x*TAU); // Doesn't work well since I cheat and bump lights forward.\n    \n    float skyFactor = smoothstep(.0, 2.2, .5 - rd.y);\n    vec3 col = mix(OFF_BLACK, SKY_COLOR, skyFactor);\n   \n    RayOut rayOut = RayMarch(ro, rd, MAX_STEPS, 0);\n\n    if (rayOut.dist < MAX_DIST) {\n        vec3 p = ro + rd * rayOut.dist;\n        vec3 n = GetNormal(p);\n        \n        float lightOffs = floor(-(forward.z - LAMP_REPEAT_DIST) / LAMP_REPEAT_DIST) * LAMP_REPEAT_DIST;\n        vec3 currLightPos = INIT_LIGHT_POS + vec3(LampXRepeat(0.) + lightOffs, 0, 0);\n        \n        // Calculate both lights over the z axis at once to save performance. Possible because \n        // scene is symmetric over the XY plane at the areas which are effected by this point light.\n        // This does not accumulate light twice for areas where both point lights should've hit\n        // however (nor account for their unique z positions).\n        vec3 reflectedP = vec3(p.xy, abs(p.z));\n        \n        col = rayOut.mat.col * GetPointLight(reflectedP, n, rd, rayOut.mat.spec, currLightPos);\n        //col += rayOut.mat.col * GetPointLight(p, n, rd, rayOut.mat.spec,\n        //    vec3(currLightPos.xy, -currLightPos.z));\n\n        for (float i = 1.; i < 2.; i += 1.) { // More lights means less performance.\n          currLightPos.x -= LAMP_REPEAT_DIST;\n            \n          col += rayOut.mat.col * GetPointLight(reflectedP, n, rd, rayOut.mat.spec, currLightPos);\n          //col += rayOut.mat.col * GetPointLight(p, n, rd, rayOut.mat.spec, \n          //  vec3(currLightPos.xy, -currLightPos.z));\n        }\n        \n        float fog = sdFog(p, ro, 8., ROAD_FOG_DIST);\n        col = mix(FOG_COL, col, fog);\n        \n        // Use mountains fog if very far away sideways.\n        col = mix(FAR_MOUNTAINS_FOG, col, 1. - MountainSideDist(abs(p.z-ro.z), FAR_FOG_DIST_SCALE));\n    } else {\n        col += smoothstep(0., 0.3, rd.y) * Stars(Rot(iTime * 0.01) * rd.yz);\n    }\n    \n    col = toneMapping(col, 4.);\n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Special thanks to BigWings and mithrandir for the Raymarching templates \n// and to IQ for all the SDFs in the world.\n\n// Here we are applying antialiasing, if desired, to the raymarched scene.\n\n#define RES iResolution.xy\n\n// Change this variable to toggle Antialiasing\n#define ENABLE_FXAA 1\n\n#define luma vec3(0.299, 0.587, 0.114)\n\n//Using the following fxaa filter\n//https://www.shadertoy.com/view/4tf3D8\nvec3 fxaa(vec2 p)\n{\n\tfloat FXAA_SPAN_MAX   = 8.0;\n    float FXAA_REDUCE_MUL = 1.0 / 8.0;\n    float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    // 1st stage - Find edge\n    vec3 rgbNW = texture(iChannel0, p + (vec2(-1.,-1.) / RES)).rgb;\n    vec3 rgbNE = texture(iChannel0, p + (vec2( 1.,-1.) / RES)).rgb;\n    vec3 rgbSW = texture(iChannel0, p + (vec2(-1., 1.) / RES)).rgb;\n    vec3 rgbSE = texture(iChannel0, p + (vec2( 1., 1.) / RES)).rgb;\n    vec3 rgbM  = texture(iChannel0, p).rgb;\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    // 2nd stage - Blur\n    vec3 rgbA = .5 * (texture(iChannel0, p + dir * (1./3. - .5)).rgb +\n        \t\t\t  texture(iChannel0, p + dir * (2./3. - .5)).rgb);\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  texture(iChannel0, p + dir * (0./3. - .5)).rgb +\n        \t\t\t  texture(iChannel0, p + dir * (3./3. - .5)).rgb);\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 Col = vec3(0.0);\n    \n    #if ENABLE_FXAA > 0\n    \tCol = fxaa(fragCoord/RES);\n    #else\n    \tCol = texture(iChannel0, fragCoord/RES).rgb;\n    #endif\n    \n    fragColor = vec4(Col,1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}