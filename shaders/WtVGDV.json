{
    "Shader": {
        "info": {
            "date": "1579928993",
            "description": "I can canonically obtain \"sign\" based on \"InCircle test\", but it doesn't give canonical AA-friendly pixel value since it is the volume of a tetrahedra in a quite unrelated 3d space.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtVGDV",
            "likes": 3,
            "name": "Signed circumcircle",
            "published": 3,
            "tags": [
                "2d",
                "triangle",
                "circle"
            ],
            "usePreview": 0,
            "username": "hiogawa",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "//\n// Signed circumcircle\n//\n// NOTE:\n//   I can canonically obtain \"sign\" based on \"InCircle test\",\n//   but it doesn't give canonical AA friendly pixel value\n//   since it is the volume of a tetrahedra in a quite unrelated 3d space.\n//   So, \"USE_IN_CIRCLE_TEST = false\" switches to direct computation\n//   of circumcircle and signed area of a triangle.\n//\n\n#define M_PI 3.14159\n\nbool USE_IN_CIRCLE_TEST = true;\nfloat IN_CIRCLE_TEST_VOLUME_SCALE = 1000.0;\n\nfloat SCALE = 1.2;\nfloat SCALE_TIME = .4;\n\nfloat CHECKER_SCALE = 4.0;\nvec3  CHECKER_COLOR0 = vec3(0.20);\nvec3  CHECKER_COLOR1 = vec3(0.60);\n\nfloat POINT_RADIUS = 3.0;\nvec3  POINT_COLOR = vec3(0.0, 1.0, 1.0);\n\nvec3  TRIANGLE_COLOR = vec3(0.0, 1.0, 1.0);\nfloat TRIANGLE_ALPHA = 0.75;\n\nvec3  DISK_COLOR = vec3(1.0);\nfloat DISK_ALPHA = 0.75;\n\nfloat AA = 2.0;\n\n//\n// Utils\n//\n\nvec2 unitVector2(float t) {\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nvoid intersect_Line_Line(\n    vec2 p1, vec2 v1, vec2 p2, vec2 v2,\n    out float t1, out float t2) {\n  // assume v1, v2: linear indep.\n  // p1 + t1 v1 = p2 + t2 v2\n  // <=>  (p1 - p2) + [v1, -v2] {t1, t2} = 0\n  // <=>  {t1, t2} = inv([v1, -v2]) (-p1 + p2)\n  vec2 t1t2 = inverse(mat2(v1, -v2)) * (-p1 + p2);\n  t1 = t1t2[0];\n  t2 = t1t2[1];\n}\n\nfloat distance_Point_LineSegment(vec2 p, vec2 q1, vec2 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n\n  vec2 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\n\n//\n// Noise\n//\n\nfloat hash11(float t) {\n  return fract(sin(1.0 + t * 123456.789) * 123456.789);\n}\n\nfloat hash21(vec2 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]));\n}\n\nvec2 hash12(float v) {\n  return vec2(hash11(v), hash21(vec2(v, 1.0)));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  return unitVector2(hash21(uv));\n}\n\nfloat gradientNoise2(vec2 uv) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float f00 = dot(hashGradient2(uvi + vec2(0.0, 0.0)), uvf - vec2(0.0, 0.0));\n  float f10 = dot(hashGradient2(uvi + vec2(1.0, 0.0)), uvf - vec2(1.0, 0.0));\n  float f01 = dot(hashGradient2(uvi + vec2(0.0, 1.0)), uvf - vec2(0.0, 1.0));\n  float f11 = dot(hashGradient2(uvi + vec2(1.0, 1.0)), uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nvec2 someNoise(float hash_seed, float conti_seed) {\n  // Taking hashed direction to break inherent velocity pattern of gradientNoise2\n  vec2 p = hash12(hash_seed);\n  vec2 dir1 = unitVector2(p[0]);\n  vec2 dir2 = unitVector2(p[1]);\n  vec2 v = vec2(\n      gradientNoise2(123.456 * vec2(hash_seed) + 456.789 + conti_seed * dir1),\n      gradientNoise2(456.123 * vec2(hash_seed) + 789.456 + conti_seed * dir2));\n\n  // Tonemap [0, 1] to make movement more \"dynamical\"\n  return smoothstep(0.0, 1.0, v);\n}\n\n\n//\n// Misc\n//\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nfloat signedDistanceToTriangle(vec2 uv, vec2 p0, vec2 p1, vec2 p2) {\n  vec2 v1 = p1 - p0;\n  vec2 v2 = p2 - p0;\n  float signed_area = cross(vec3(v1, 0.0), vec3(v2, 0.0)).z;\n  if (abs(signed_area) <= 0.0000001) {\n    return 1000.0;\n  }\n\n  // Barycentric coord (uv = p0 + s * v1 + t * v2)\n  mat2 v1v2 = mat2(v1, v2);\n  vec2 st = inverse(transpose(v1v2) * v1v2) * transpose(v1v2) * (uv - p0);\n  bool is_inside = st.x >= 0.0 && st.y >= 0.0 && (st.x + st.y) <= 1.0;\n\n  float dist = 1000.0;\n  dist = min(dist, distance_Point_LineSegment(uv, p0, p1));\n  dist = min(dist, distance_Point_LineSegment(uv, p1, p2));\n  dist = min(dist, distance_Point_LineSegment(uv, p2, p0));\n\n  return is_inside ? -dist : dist;\n}\n\nfloat signedDistanceToCircle(vec2 uv, vec2 center, float radius) {\n  return distance(uv, center) - radius;\n}\n\nfloat inCircleTestVolume(vec2 q, vec2 p0, vec2 p1, vec2 p2) {\n  mat3 circle_test_mat = mat3(\n    (p0 - q).x, (p0 - q).y, dot(p0, p0) - dot(q, q),\n    (p1 - q).x, (p1 - q).y, dot(p1, p1) - dot(q, q),\n    (p2 - q).x, (p2 - q).y, dot(p2, p2) - dot(q, q));\n  float circle_test_det = determinant(circle_test_mat);\n  return circle_test_det;\n}\n\nvec2 circumcircleCenter(vec2 p0, vec2 p1, vec2 p2) {\n  // assume non degenerate triangle\n  vec2 q1 = (p0 + p1) / 2.0;\n  vec2 q2 = (p0 + p2) / 2.0;\n  vec2 u1 = p1 - p0;\n  vec2 u2 = p2 - p0;\n  vec2 v1 = vec2(cross(vec3(0.0, 0.0, 1.0), vec3(u1, 0.0)));\n  vec2 v2 = vec2(cross(vec3(0.0, 0.0, 1.0), vec3(u2, 0.0)));\n  float t1, t2;\n  intersect_Line_Line(q1, v1, q2, v2, t1, t2);\n  return q1 + t1 * v1;\n}\n\n// anti alias\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n// view transform with aspect ratio preserved\nmat3 invViewTransform(vec2 center, float scale_y) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(scale_y * Res.x / Res.y, scale_y);\n  vec2 a = center - size / 2.0;\n  float Sy = scale_y / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0\n  );\n  return xform;\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(vec2(0.5, 0.5), SCALE);\n  float inv_view_scale = inv_view_xform[0][0];\n\n  vec2 uv = vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Draw checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Prepare random 3 points\n    vec2 ps[3];\n    for (int i = 0; i <= 2; i++) {\n      ps[i] = someNoise(float(i), t);\n    }\n\n    // Draw circumcircle\n    if (USE_IN_CIRCLE_TEST) {\n      float volume = inCircleTestVolume(uv, ps[0], ps[1], ps[2]);\n      volume *= IN_CIRCLE_TEST_VOLUME_SCALE;\n      float coverage = 1.0 - smoothstep(-1.0, 1.0, volume);\n      color = mix(color, DISK_COLOR, DISK_ALPHA * coverage);\n\n    } else {\n      vec2 center = circumcircleCenter(ps[0], ps[1], ps[2]);\n      float radius = distance(center, ps[0]);\n      float sd = signedDistanceToCircle(uv, center, radius);\n\n      float signed_area = cross(vec3(ps[1] - ps[0], 0.0), vec3(ps[2] - ps[0], 0.0)).z;\n      sd *= sign(signed_area);\n\n      float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n      color = mix(color, DISK_COLOR, DISK_ALPHA * coverage);\n    }\n\n    // Draw triangle\n    {\n      float sd = signedDistanceToTriangle(uv, ps[0], ps[1], ps[2]);\n      float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n      color = mix(color, TRIANGLE_COLOR, TRIANGLE_ALPHA * coverage);\n    }\n\n    // Draw point\n    {\n      float min_distance = 1000.0;\n      for (int i = 0; i <= 2; i++) {\n        min_distance = min(min_distance, distance(ps[i], uv));\n      }\n      float coverage = smoothBoundaryCoverage(\n          min_distance / inv_view_scale - POINT_RADIUS, AA);\n      color = mix(color, POINT_COLOR, coverage);\n    }\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}