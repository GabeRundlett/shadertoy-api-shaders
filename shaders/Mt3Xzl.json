{
    "Shader": {
        "info": {
            "date": "1481112850",
            "description": "Just screwing around with the new texture. Designed while thinking about the old state based OpenGL API.",
            "flags": 0,
            "hasliked": 0,
            "id": "Mt3Xzl",
            "likes": 10,
            "name": "New text shader",
            "published": 3,
            "tags": [
                "2d",
                "text"
            ],
            "usePreview": 0,
            "username": "KylBlz",
            "viewed": 668
        },
        "renderpass": [
            {
                "code": "//lower case\n#define _a res = min(res, pl(vec2(1., 9.), uv));\n#define _b res = min(res, pl(vec2(2., 9.), uv));\n#define _c res = min(res, pl(vec2(3., 9.), uv));\n#define _d res = min(res, pl(vec2(4., 9.), uv));\n#define _e res = min(res, pl(vec2(5., 9.), uv));\n#define _f res = min(res, pl(vec2(6., 9.), uv));\n#define _g res = min(res, pl(vec2(7., 9.), uv));\n#define _h res = min(res, pl(vec2(8., 9.), uv));\n#define _i res = min(res, pl(vec2(9., 9.), uv));\n#define _j res = min(res, pl(vec2(10., 9.), uv));\n#define _k res = min(res, pl(vec2(11., 9.), uv));\n#define _l res = min(res, pl(vec2(12., 9.), uv));\n#define _m res = min(res, pl(vec2(13., 9.), uv));\n#define _n res = min(res, pl(vec2(14., 9.), uv));\n#define _o res = min(res, pl(vec2(15., 9.), uv));\n#define _p res = min(res, pl(vec2(0., 8.), uv));\n#define _q res = min(res, pl(vec2(1., 8.), uv));\n#define _r res = min(res, pl(vec2(2., 8.), uv));\n#define _s res = min(res, pl(vec2(3., 8.), uv));\n#define _t res = min(res, pl(vec2(4., 8.), uv));\n#define _u res = min(res, pl(vec2(5., 8.), uv));\n#define _v res = min(res, pl(vec2(6., 8.), uv));\n#define _w res = min(res, pl(vec2(7., 8.), uv));\n#define _x res = min(res, pl(vec2(8., 8.), uv));\n#define _y res = min(res, pl(vec2(9., 8.), uv));\n#define _z res = min(res, pl(vec2(10., 8.), uv));\n//upper case\n#define _A res = min(res, pl(vec2(1., 11.), uv));\n#define _B res = min(res, pl(vec2(2., 11.), uv));\n#define _C res = min(res, pl(vec2(3., 11.), uv));\n#define _D res = min(res, pl(vec2(4., 11.), uv));\n#define _E res = min(res, pl(vec2(5., 11.), uv));\n#define _F res = min(res, pl(vec2(6., 11.), uv));\n#define _G res = min(res, pl(vec2(7., 11.), uv));\n#define _H res = min(res, pl(vec2(8., 11.), uv));\n#define _I res = min(res, pl(vec2(9., 11.), uv));\n#define _J res = min(res, pl(vec2(10., 11.), uv));\n#define _K res = min(res, pl(vec2(11., 11.), uv));\n#define _L res = min(res, pl(vec2(12., 11.), uv));\n#define _M res = min(res, pl(vec2(13., 11.), uv));\n#define _N res = min(res, pl(vec2(14., 11.), uv));\n#define _O res = min(res, pl(vec2(15., 11.), uv));\n#define _P res = min(res, pl(vec2(0., 10.), uv));\n#define _Q res = min(res, pl(vec2(1., 10.), uv));\n#define _R res = min(res, pl(vec2(2., 10.), uv));\n#define _S res = min(res, pl(vec2(3., 10.), uv));\n#define _T res = min(res, pl(vec2(4., 10.), uv));\n#define _U res = min(res, pl(vec2(5., 10.), uv));\n#define _V res = min(res, pl(vec2(6., 10.), uv));\n#define _W res = min(res, pl(vec2(7., 10.), uv));\n#define _X res = min(res, pl(vec2(8., 10.), uv));\n#define _Y res = min(res, pl(vec2(9., 10.), uv));\n#define _Z res = min(res, pl(vec2(10., 10.), uv));\n//numbers\n#define _0 res = min(res, pl(vec2(0., 12.), uv));\n#define _1 res = min(res, pl(vec2(1., 12.), uv));\n#define _2 res = min(res, pl(vec2(2., 12.), uv));\n#define _3 res = min(res, pl(vec2(3., 12.), uv));\n#define _4 res = min(res, pl(vec2(4., 12.), uv));\n#define _5 res = min(res, pl(vec2(5., 12.), uv));\n#define _6 res = min(res, pl(vec2(6., 12.), uv));\n#define _7 res = min(res, pl(vec2(7., 12.), uv));\n#define _8 res = min(res, pl(vec2(8., 12.), uv));\n#define _9 res = min(res, pl(vec2(9., 12.), uv));\n//special\n#define _dot  res = min(res, pl(vec2(14., 13.), uv));\n#define _crlf _cur.xy = vec2(_cur.z, _cur.y-_sz.y);\n#define _sp   _cur.x += _sz.z;\n#define _tab  _cur.x += _sz.z * 2.;\n//state\nvec3 _col, _cur, _sz, _rto;\nfloat _italic = 0., _underline = 0., _strike = 0.;\n// font modifiers\nvoid setCursor(vec2 cur) { _cur = vec3(cur.xyx); }\nvoid setColor(vec3 col) { _col = col; }\nvoid setSize(vec2 sz) { _sz = vec3(sz,sz.x*.5); _rto = vec3(1./16.); }\n// dont use\nfloat pl(vec2 ltr, vec2 uv) {\n    _cur.x += _sz.z;\n    if (any(lessThan(uv, _cur.xy)) || any(greaterThan(uv, _cur.xy+_sz.xy))) return 1.;\n    vec2 dlta = uv-_cur.xy, smp = (((dlta - _italic * vec2(.16 * dlta.y, 0.)) / _sz.xy) + ltr) * _rto.xy;\n    float dysy = dlta.y/_sz.y;\n    return 1. - (texture(iChannel0, smp).r + step(.1, dysy) * step(dysy, .15) * _underline + step(.45, dysy) * step(dysy, .5) * _strike);\n}\n\nvoid RenderTime(in vec2 uv, inout vec3 res) {\n    if (iTime > 100.)\n        res = min(res, pl(vec2(floor(mod(iTime * 0.01, 10.)), 12.), uv));\n    if (iTime > 10.)\n        res = min(res, pl(vec2(floor(mod(iTime * 0.1, 10.)), 12.), uv));\n    res = min(res, pl(vec2(floor(mod(iTime * 1.0, 10.)), 12.), uv));\n    _cur.x -= 0.005;\n    _dot\n    _cur.x -= 0.005;\n    res = min(res, pl(vec2(floor(mod(iTime * 10., 10.)), 12.), uv));\n    res = min(res, pl(vec2(floor(mod(iTime * 100., 10.)), 12.), uv));\n    res = min(res, pl(vec2(floor(mod(iTime * 1000., 10.)), 12.), uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv) * .2;\n    \n    //this needs to exist\n    vec3 res = vec3(1.);\n    //this is all the options\n    setCursor(vec2(.2, .5));\n    setColor(vec3(0., .5, 1.));\n    setSize(vec2(1./8., 1./4.));\n    _italic = 0.; \t //range -1. - 1. (slant)\n    _underline = 0.; //range 0. - 1. (opacity)\n    _strike = 0.; \t //range 0. - 1. (opacity)\n    \n    //message:\n    _K _y _l _B _l _z\n    //end message\n    fragColor.rgb = mix(_col, fragColor.rgb, vec3(res));\n    res = vec3(1.);\n\n    //another message\n    setCursor(vec2(.1, .3));\n    setColor(vec3(1.));\n    setSize(vec2(1./16., 1./8.));\n    \n    _italic = -1.;\n    _underline = 1.;\n    _strike = 1.;\n    _S _i _m _p _l _e\n    \n    _italic = -.5;\n    _underline = 1.;\n    _strike = 0.;\n    _sp _s _t _a _t _e\n    \n\t_italic = .5;\n    _underline = 0.;\n    _strike = 0.;\n    _sp _b _a _s _e _d\n    \n    _italic = 1.;\n    _underline = 0.;\n    _strike = 0.;\n    _sp _t _e _x _t\n\n    fragColor.rgb = mix(_col, fragColor.rgb, vec3(res));\n    res = vec3(1.);\n\n    _italic = 0.;\n    _underline = 0.;\n    _strike = 0.;\n    setCursor(vec2(.1, .1));\n    setColor(vec3(1., .5, 0.));\n    RenderTime(uv, res);\n    _cur.x += 0.4;\n    RenderTime(uv, res);\n    \n    fragColor.rgb = mix(_col, fragColor.rgb, vec3(res));\n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}