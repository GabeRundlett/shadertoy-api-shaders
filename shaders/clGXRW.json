{
    "Shader": {
        "info": {
            "date": "1686111544",
            "description": "Cell,SDF",
            "flags": 0,
            "hasliked": 0,
            "id": "clGXRW",
            "likes": 0,
            "name": "Cell_Mix",
            "published": 3,
            "tags": [
                "sdf",
                "learning",
                "cell"
            ],
            "usePreview": 0,
            "username": "KTSAMA",
            "viewed": 39
        },
        "renderpass": [
            {
                "code": "#define ZERO (min(iFrame,0))\n#define PI 3.1415926\n#define _BackGroundIntensity 0.8\n#define _LightDir normalize( vec3(0.1, 0.8, 0.1) )\n//#define _ColorSphere_CellSide1 vec4(0.74,0.77,0.79,0.92)\n//#define _ColorSphere_CellSide2 vec4(0.74,0.77,0.79,0.92)\n#define _ColorSphere_CellSide1 vec4(0.8,0.2,0.2,0.8)\n#define _ColorSphere_CellSide2 vec4(0.2,0.2,0.8,0.8)\n\n#define _ColorSphere_CellInSide1 vec4(0.11,0.15,0.25,1.0)\n#define _ColorSphere_CellInSide2 vec4(0.11,0.15,0.25,1.0)\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n vec3 mod2D289( vec3 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n  vec4 mod2D289( vec4 x ) { return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0; }\n  vec3 permute( vec3 x ) { return mod2D289( ( ( x * 34.0 ) + 1.0 ) * x ); }\n            vec4 permute( vec4 x ) { return mod2D289( ( ( x * 34.0 ) + 1.0 ) * x ); }\n            //计算3DNoise\n            float noise3D(vec3 p)\n            {\n                vec3 a = floor(p);\n                vec3 d = p - a;\n                d = d * d * (3.0 - 2.0 * d);\n\n                vec4 b = vec4( a.x, a.x, a.y, a.y ) + vec4( 0.0, 1.0, 0.0, 1.0 );\n                vec4 k1 = permute( b.xyxy );\n                vec4 k2 = permute( k1.xyxy + b.zzww );\n\n                vec4 c = k2 + a.zzzz;\n                vec4 k3 = permute( c );\n                vec4 k4 = permute( c + 1.0 );\n\n                vec4 o1 = fract( k3 * ( 1.0 / 41.0 ) );\n                vec4 o2 = fract( k4 * ( 1.0 / 41.0 ) );\n\n                vec4 o3 = o2 * d.z + o1 * ( 1.0 - d.z );\n                vec2 o4 = o3.yw * d.x + o3.xz * ( 1.0 - d.x );\n\n                return o4.y * d.y + o4.x * ( 1.0 - d.y );\n            }\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n// Union\nfloat opU(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n// Union\nvec4 opU4(vec4 d1, vec4 d2)\n{\n\treturn d1.w<d2.w?d1:d2;\n}\n// SMOOTH BOOLEAN OPERATORS\n\nvec4 opUS4( vec4 d1, vec4 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n vec3 color = mix(d2.rgb, d1.rgb, h);\n    float dist = mix( d2.w, d1.w, h ) - k*h*(1.0-h); \n return vec4(color,dist);\n}\nvec4 opUS4(vec4 d1_col, vec4 d2_col,float d1,float d2,float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    vec3 color = mix(d2_col.rgb, d1_col.rgb, h);\n    float dist = mix(d2, d1, h) - k * h * (1.0 - h);\n    return vec4(color, dist);\n}\n\nfloat opUS( float d1, float d2,float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float dist = mix( d2, d1, h ) - k*h*(1.0-h); \n return dist;\n}\nvec2 opUS( float d1, float d2,float d1_num,float d2_num ,float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    vec2 dist=vec2(0.0,0.0);\n    dist.x = mix( d2, d1, h ) - k*h*(1.0-h); \n    dist.y=mix(d1_num,d2_num,h);\n return dist;\n}\n\nfloat opSS( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opIS( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res1 = vec2( pos.y, 0.0 );\n    vec2 res2 = vec2( pos.y, 1.0 );\n     res1.x =sdSphere(pos-vec3(cos(iTime+PI/2.0),0.0,0.0), 0.5);\n       \n     res2.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0), 0.5);\n       \n       vec2 result1=opUS(res1.x, res2.x,res1.y,res2.y,0.45);\n    return result1;\n}\n\nvec2 mapInside( in vec3 pos )\n{\n float noiseScale=10.0;\n   vec2 res3 = vec2( pos.y, 0.0 );\n      vec2 res3_1 = vec2( pos.y, 0.0 );\n      vec2 res3_2 = vec2( pos.y, 0.0 );\n      vec2 res3_3 = vec2( pos.y, 0.0 );\n      vec2 res3_4 = vec2( pos.y, 0.0 );\n   vec2 res4 = vec2( pos.y, 1.0 );\n      vec2 res4_1 = vec2( pos.y, 1.0 );\n      vec2 res4_2 = vec2( pos.y, 1.0 );\n      vec2 res4_3 = vec2( pos.y, 1.0 );\n      vec2 res4_4 = vec2( pos.y, 1.0 );\n    \n       res3.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0), 0.2);\n       res3_1.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0)-vec3(0.06,0.15,0.1), 0.01);\n       res3_2.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0)-vec3(0.1,-0.15,0.06), 0.01);\n       res3_3.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0)-vec3(0.1,-0.1,-0.15), 0.02);\n       res3_4.x =sdSphere(pos-vec3( cos(iTime+PI/2.0),0.0,0.0)-vec3(-0.15,0.1,-0.1), 0.02);\n       res3.x=opUS(res3.x,res3_1.x,0.1);\n       res3.x=opUS(res3.x,res3_2.x,0.1);\n       res3.x=opUS(res3.x,res3_3.x,0.1);\n       res3.x=opUS(res3.x,res3_4.x,0.1)+(noise3D((pos-vec3( cos(iTime+PI/2.0),0.0,0.0))*noiseScale)*2.0-1.0)*0.008;\n         \n       res4.x =sdSphere(pos-vec3( sin(iTime),0.0,0.0), 0.2);\n       res4_1.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0)-vec3(0.1,-0.1,0.1), 0.01);\n       res4_2.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0)-vec3(-0.1,-0.1,0.1), 0.01);\n       res4_3.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0)-vec3(-0.1,-0.1,-0.15), 0.02);\n       res4_4.x =sdSphere(pos-vec3(sin(iTime),0.0,0.0)-vec3(0.12,0.12,0.12), 0.03);\n       res4.x=opUS(res4.x,res4_1.x,0.1);\n       res4.x=opUS(res4.x,res4_2.x,0.1);\n       res4.x=opUS(res4.x,res4_3.x,0.1);\n       res4.x=opUS(res4.x,res4_4.x,0.1)+(noise3D((pos-vec3(sin(iTime),0.0,0.0))*noiseScale)*2.0-1.0)*0.008;\n       \n       \n       vec2 result2=opUS(res3.x, res4.x,res3.y,res4.y,0.3);\n    return result2;\n}\n\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox(in vec3 ro, in vec3 rd, in vec3 rad) {\n    // compute the inverse ray direction\n    vec3 invRd = 1.0 / rd;\n    // compute the distance to the box\n    vec3 dist = invRd * ro;\n    // compute the box radius\n    vec3 boxRadius = abs(invRd) * rad;\n    // compute the distance to the near and far planes\n    vec3 t1 = -dist - boxRadius;\n    vec3 t2 = -dist + boxRadius;\n    // return the distance to the box\n    return vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.0,0.0), rd, vec3(2.0,2.0,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\nvec2 raycastInside( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.0,0.0), rd, vec3(2.0,2.0,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = mapInside( ro+rd*t );\n            if( abs(h.x)<(0.0001*t))\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow_Inside( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = mapInside( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal_Inside( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapInside(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO_Inside( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = mapInside( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy)\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n//============================================================\n\n\n\n\n//====================Blur Func========================================\nconst int   c_samplesX    = 15;  // must be odd\nconst int   c_samplesY    = 15;  // must be odd\nconst float c_textureSize = 512.0;\n\nconst int   c_halfSamplesX = c_samplesX / 2;\nconst int   c_halfSamplesY = c_samplesY / 2;\nconst float c_pixelSize = (1.0 / c_textureSize);\n\nfloat Gaussian (float sigma, float x)\n{\n    return exp(-(x*x) / (2.0 * sigma*sigma));\n}\n\nvec3 BlurredPixel (in vec2 uv)\n{\n\n    float total = 0.0;\n    vec3 ret = vec3(0);\n        \n    for (int iy = 0; iy < c_samplesY; ++iy)\n    {\n        float fy = Gaussian (10.0, float(iy) - float(c_halfSamplesY));\n        float offsety = float(iy-c_halfSamplesY) * c_pixelSize;\n        for (int ix = 0; ix < c_samplesX; ++ix)\n        {\n            float fx = Gaussian (5.0, float(ix) - float(c_halfSamplesX));\n            float offsetx = float(ix-c_halfSamplesX) * c_pixelSize;\n            total += fx * fy;            \n            ret += texture(iChannel3, uv + vec2(offsetx, offsety)).rgb * fx*fy;\n        }\n    }\n    return ret / total;\n}\n\n//============================================================\n\n\nvec4 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy,vec2 uv ,float inside)\n{ \n    // background\n    vec4 col=vec4(0.0);\n    vec4 backGround=texture(iChannel3, uv)*_BackGroundIntensity;\n   \n    col.xyz= vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    col.w=0.0;\n    // raycast scene\n    vec2 resOut = raycast(ro,rd);\n\n    float t = resOut.x;\n\tfloat m = resOut.y;\n    if( m>=-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<0.0) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n       \n     \n        vec3 ref = reflect( rd, nor );\n      // material  混合两个球的颜色\n         col= mix(_ColorSphere_CellSide1,_ColorSphere_CellSide2,m);\n       \n        float ks = 5.0;\n         \n        // lighting\n         float occ = calcAO( pos, nor );\n         \n\n        // backGround=vec4(0.0); texture( iChannel3, uv+vec2(cos(d),sin(d))*Radius*i+(nor.xy/0.8)*15.0/iResolution.xy)*(1.0-inside*0.98);\t\t\n         \n        backGround =vec4(BlurredPixel(uv+(nor.xy)*20.0/iResolution.xy), 1.0)*(1.0-inside*0.98);\n          //backGround /= (Quality * Directions )- 15.0;\n         col.rgb*=backGround.rgb;\n\t\t vec3 lin = vec3(0.0);\n\n     \n        // sun\n        {\n            vec3  lig = _LightDir;\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.05, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),500.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col.xyz*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n           \n        }\n        // sky\n        {\n            float dif = 0.5*sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.05, 2.5 );\n            lin += col.xyz*0.60*dif*vec3(0.40,0.60,1.15);\n            lin += 2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n            \n        \tlin += col.xyz*0.55*dif*vec3(0.25,0.25,0.25);\n           \n            \n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col.xyz*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n      \n       \n          //f*env\n        {\n            vec3 evn_col=texture(iChannel2,ref).xyz*2.0;\n            float f=pow((1.0-max(0.0,dot(-rd,nor)))*2.0,5.0);\n            lin+=col.xyz*evn_col*0.1*pow((max(0.0,dot(-rd,nor)))*2.0,5.0);\n            \n            lin+=col.rgb*f*evn_col*0.2;\n             lin*=clamp(pow((max(0.0,dot(-rd,nor)))*1.0,2.0)+0.3,0.0,1.0);\n            // lin=clamp(lin,0.0,1.0);\n        }\n\t\tcol.xyz = 0.7*lin;\n        col.xyz = mix( col.xyz, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n      \n    }\n   // return backGround;\n\treturn vec4( clamp(vec4(backGround.xyz*(1.0-col.w)+col.xyz*col.w,1.0),0.0,1.0) );\n}\n\nvec4 renderInside( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy,vec2 uv )\n{ \n    // background\n    vec4 col=vec4(0.0);\n    vec4 backGround=vec4(0.0);\n   \n    col.xyz= vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    col.w=0.0;\n    // raycast scene\n    vec2 resSide = raycastInside(ro,rd);\n\n    float t = resSide.x;\n\tfloat m = resSide.y;\n    if( m>=-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<0.0) ? vec3(0.0,1.0,0.0) : calcNormal_Inside( pos );\n       \n     \n        vec3 ref = reflect( rd, nor );\n        \n        \n      // material  混合两个球的颜色\n         col= mix(_ColorSphere_CellInSide1,_ColorSphere_CellInSide2,m);\n        float ks = 0.5;\n       \n        // lighting\n         float occ = calcAO_Inside( pos, nor );\n        // backGround=texture(iChannel3, uv+((nor.xy)*2.0-0.5)*5.0/iResolution.xy)*_BackGroundIntensity*1.0;\n        // col.rgb*=+backGround.rgb;\n\t\t vec3 lin = vec3(0.0);\n\n     \n        // sun\n        {\n            vec3  lig = _LightDir;\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( pow(dot( nor, lig ),2.0), 0.0, 1.0 );\n           // return vec4(dif);\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow_Inside( pos, lig, 0.05, 2.5 );\n                  // return vec4(dif);\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),100.0);\n           \n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col.xyz*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = 0.5*sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow_Inside( pos, ref, 0.05, 2.5 );\n            lin += col.xyz*0.60*dif*vec3(0.40,0.60,1.15);\n            lin += 2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n            \n        \tlin += col.xyz*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col.xyz*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n      \n       \n        //f*env\n        {\n            vec3 evn_col=texture(iChannel2,ref).xyz*0.5;\n           //lin+=col.xyz*evn_col;\n            float f=pow((1.0-max(0.0,dot(-rd,nor)))*1.5,5.0);\n            lin+=col.rgb*f*evn_col*0.2;\n        }\n\t\tcol.xyz = 0.7*lin;\n        col.xyz = mix( col.xyz, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n   // return backGround;\n\treturn vec4( clamp(vec4(backGround.xyz*(1.0-col.w)+col.xyz*col.w,col.w),0.0,1.0) );\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // camera\t\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 2.0, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 3.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n      \n         // render\tInside\n        vec4 colInside = renderInside( ro, rd, rdx, rdy,uv);\n        \n          // render\t传入内部不透明部位，用于减去透视的背景部分\n        vec4 col = render( ro, rd, rdx, rdy,uv,colInside.w);\n        col+=colInside;\n        //col.rgb=vec3(colInside.rgb*(1.0-col.w)+col.w*col.rgb);\n       //col=vec4(colInside.w);\n         //col=colInside;\n        // Normalized pixel coordinates (from 0 to 1)\n    \n        // gain\n        // col = col*3.0/(2.5+col);\n\t\t// gamma\n        col.xyz = pow( col.xyz, vec3(0.4545) );\n\n        tot += col.xyz;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n \n\n\n   fragColor = vec4( tot, 1.0 );\n //  fragColor = ;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}