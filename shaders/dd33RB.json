{
    "Shader": {
        "info": {
            "date": "1677449246",
            "description": "Simple test of periodic piecewise C1 quadratic interpolation of points.\nYou can move one of the points with mouse.\n\nIf you set a fixed initial slope instead of the periodicity condition, moving the points only affect the neigbouring pieces.",
            "flags": 0,
            "hasliked": 0,
            "id": "dd33RB",
            "likes": 5,
            "name": "Periodic quadratic spline",
            "published": 3,
            "tags": [
                "spline",
                "quadratic",
                "periodic"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 215
        },
        "renderpass": [
            {
                "code": "/*\nSee https://www.shadertoy.com/view/Dd33zs for C2 cubic spline variant\nSee https://www.shadertoy.com/view/dd3Gzl for cubic cardinal spline variant\nSee https://www.shadertoy.com/view/cstGRs for akima spline variant\n*/\n\nconst vec3 dot_col = vec3(0);\nconst vec3 curve_col = vec3(0,1,0);\nconst vec3 bg_col = vec3(1);\n\nconst float dot_size = .01;\nconst float line_width = .003;\n\nconst float zoom = 2.;\n\n// compute parameters of quadratic polynomial with end points a b and slope ma in a\nvec3 compute_params(vec2 a, vec2 b, float ma){\n\tmat3 matrix = mat3(a.x * a.x, b.x * b.x, 2. * a.x,\n\t                   a.x, b.x, 1.,\n\t                   1., 1., 0.);\n\n\treturn inverse(matrix) * vec3(a.y, b.y, ma);\n}\n\n// compute slope at end of quadratic piece\nfloat slope_at_end(vec3 params, float end){\n\tfloat diff = end * 2. * params.x + params.y;\n\treturn diff;\n}\n\n// approximate distance to quadratic curve between a and b\nfloat quad_distance_approx(vec2 uv, float a, float b, vec3 params){\n\tfloat val = uv.x * (uv.x * params.x + params.y) + params.z;\n\tfloat diff = uv.x * 2. * params.x + params.y;\n\n\tif(uv.x > a && uv.x < b){\n\t\treturn abs(uv.y-val) / length(vec2(diff,1));\n\t}\n\telse{\n\t\treturn 1e38;\n\t}\n}\n\n// compute parameters of the linear function which computes outgoing slope as function of ingoing slope\nvec2 slope_change_func(vec2 a, vec2 b){\n\tmat3 matrix = mat3(a.x * a.x, b.x * b.x, 2. * a.x,\n\t                   a.x, b.x, 1.,\n\t                   1., 1., 0.);\n\n\tmat3 inv = inverse(matrix);\n\n\tvec2 ci = mat2(inv[0].xy,inv[1].xy) * vec2(a.y, b.y);\n\n\t//return vec2(2.*inv[2][0]*b.x + inv[2][1], 2.*ci.x*b.x+ci.y);\n\n\t// the linear part seems to always be -1 (why exactly?)\n\treturn vec2(-1., 2.*ci.x*b.x+ci.y);\n\t\n}\n\n// compute concatenation of affine linear functions\nvec2 concat_lin_func(vec2 f1, vec2 f2){\n\treturn vec2(f1.x*f2.x, f2.x*f1.y + f2.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border = 2. / iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse -= .5;\n    mouse.y *= iResolution.y / iResolution.x;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n    \n    // choose sensible point for preview\n    if(mouse.x < -.6 || mouse.x > .6){\n        mouse = vec2(-.1,.2);\n    }\n\n    // clamp mouse to allowed area\n\tmouse.x = clamp(mouse.x, -.39, .39);\n\n    // points that are interpolated\n\tvec2 points[] = vec2[](vec2(-.8,-.2),vec2(-.6,.1),vec2(-.4,.2),mouse,vec2(.4,.0),vec2(.6,-.2));\n\n    // repeat curve\n\tuv.x -= points[0].x;\n\tuv.x = mod(uv.x, points[points.length()-1].x - points[0].x);\n\tuv.x += points[0].x;\n\n\tvec3 color = bg_col;\n\n\tfloat curve_dis = 1e38;\n\tfloat point_dis = 1e38;\n\n\tvec2 slope_func = vec2(1,0);\n\n    // compute slope in last point as linear function of the slope in first point\n\tfor(int i=0;i<points.length()-1;i++){\n\t\tvec2 change_func = slope_change_func(points[i], points[i+1]);\n\t\tslope_func = concat_lin_func(slope_func, change_func);\n\t}\n\n\t//float initial_slope = slope_func.y / (1. - slope_func.x);\n\n\t// the linear part seems to always be -1 (why exactly?)\n\tfloat initial_slope = slope_func.y / 2.;\n\t//float initial_slope = 0.;\n\n\tfloat last_slope = initial_slope;\n\n    // render splines and dots\n\tfor(int i=0;i<points.length()-1;i++){\n\t\tpoint_dis = min(point_dis, distance(uv,points[i])-dot_size);\n\n\t\tvec3 params = compute_params(points[i], points[i+1], last_slope);\n\t\tcurve_dis = min(curve_dis, quad_distance_approx(uv, points[i].x, points[i+1].x, params)-line_width);\n\n\t\tlast_slope = slope_at_end(params, points[i+1].x);\n\t}\n\tpoint_dis = min(point_dis, distance(uv,points[points.length()-1])-dot_size);\n\n\tcolor = mix(curve_col, color, smoothstep(-border/2.,border/2.,curve_dis));\n\tcolor = mix(dot_col, color, smoothstep(-border/2.,border/2.,point_dis));\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}