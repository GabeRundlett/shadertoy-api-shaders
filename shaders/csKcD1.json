{
    "Shader": {
        "info": {
            "date": "1696182421",
            "description": "This is the most annoying way of \"drawing\" I have ever experienced #?%&%!! :) And compilation takes forever (help!)\n\nPress mouse to remove censorship.\n\nSpace toggles animation, Enter shows control points. V and W switches drawing method.",
            "flags": 48,
            "hasliked": 0,
            "id": "csKcD1",
            "likes": 39,
            "name": "Hot Girl (Spline Interpolation)",
            "published": 3,
            "tags": [
                "2d",
                "cartoon",
                "spline",
                "catmullrom",
                "sexy",
                "girl",
                "nude"
            ],
            "usePreview": 1,
            "username": "misol101",
            "viewed": 4801
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\n\n Hot Girl by misol101\n\n Original spline routine by revers (https://www.shadertoy.com/view/MlGSz3)\n\n--------------------------------------------------------------------------------------*/\n\n#define V(a,b) vec2((a),(b))\n\n// from https://www.shadertoy.com/view/lsKSWR by Ippokratis\nfloat vignette(vec2 FC, float extent, float intensity) {\n\tvec2 uv = FC.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * intensity;\n    return pow(vig, extent);\n}\n\nvec4 curtain(vec2 uv) {\n    const int NUML = 12;\n    vec2 x_w[NUML] = vec2[] ( V(0.686,0.004), V(0.325,0.004),\n                              V(0.716,0.002), V(0.756,0.0025), V(0.816,0.003), V(0.906,0.003), V(0.976,0.003),\n                              V(0.299,0.002), V(0.265,0.0025), V(0.205,0.003), V(0.125,0.003), V(0.025,0.003) );\n    for (int i=0; i<NUML; i++) {\n        float xd = abs(uv.x - x_w[i].x);\n        if (xd < x_w[i].y) { return vec4(0.); }\n    }\n    return vec4(1.);\n}\n\nvoid censor(inout vec4 fc, vec2 uv, vec2 p) {\n    float asp = iResolution.y/iResolution.x;\n    float xd = abs(uv.x - p.x + (uv.y - p.y)*asp);\n    float xd2 = abs(uv.x - p.x - (uv.y - p.y)*asp);\n    float yd = abs(uv.y - p.y);\n    if ((xd < 0.007 || xd2 < 0.007) && yd < 0.024) { fc = vec4(0.75,0.,0.,0.); }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n\tvec2 uv = fragCoord / iResolution.xy;\n\n    if (uv.x>0.686 || uv.x < 0.325) fragColor=vec4(1.); //vec4(1.,0.9,0.9,0.);\n    fragColor=min(fragColor, curtain(uv)); // +sin(iTime*4.5)*.002\n\n    if (iMouse.z < 0.5) {\n        censor(fragColor, uv, vec2(0.524, 0.634));\n        censor(fragColor, uv, vec2(0.424, 0.663));\n        censor(fragColor, uv, vec2(0.424, 0.313));\n    }\n\n\tfragColor *= 1.0 - 0.03 * length(fragCoord / iResolution.xy - 0.5);\n    fragColor *= vignette(fragCoord, 0.04, 95.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Original spline routine by revers (https://www.shadertoy.com/view/MlGSz3)\n\n/**\n * Tension. Default Catmul-Rom matrix has tension equal to 0.5.\n *\n * Values below 0.5 will cause sharp edges,\n * values above 0.5 will produce more curly lines.\n */\n#define T 0.6\n\n/**\n * Catmull-Rom Matrix\n */\nconst mat4 CRM = mat4(-T,        2.0 - T,  T - 2.0,         T,\n                       2.0 * T,  T - 3.0,  3.0 - 2.0 * T,  -T,\n                      -T,        0.0,      T,               0.0,\n                       0.0,      1.0,      0.0,             0.0);\n/**\n * Catmull-Rom Spline Interpolation\n */\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n//=======================================================================================\n\nfloat sdSegmentSq(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec2 d = pa - ba * h;\n\treturn dot(d, d);\n}\n\nfloat sdPointSq(vec2 p, vec2 a) {\n\tvec2 d = p - a;\n\treturn dot(d, d);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n#define V(a,b) vec2((a),(b))\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey(int key) { return texelFetch( iChannel1, ivec2(key, 0), 0).x > .5; }\nbool readKeyToggle(int key) { return texelFetch( iChannel1, ivec2(key, 2), 0).x > .5; }\n\nconst int NUM = 12;\nconst int WNUM = NUM-2;\n\nvoid drawPath(out vec4 fragColor, vec2 fragCoord, vec2 path[NUM], float linew[WNUM], int nofP) {\n\tfloat e = 1.0 / iResolution.x;\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(1.0);\n\n    float scale = iResolution.x/1920.;\n    \n\t//------------------------------------------------------\n\t// draw path\n\t//------------------------------------------------------\n\tif (readKeyToggle(KEY_ENTER)) {\n\t\tvec2 d = vec2(1000.0);\n        int j = 1;\n\t\tfor (int i = 0; i < (nofP - 1); i++) {\n\t\t\tvec2 a = path[i + 0];\n\t\t\tvec2 b = path[i + 1];\n            \n            vec2 tmp = vec2(sdSegmentSq(uv, a, b), sdPointSq(uv, a));\n            if (tmp.y < d.y) {\n                j = i;\n            }\n\t\t\td = min(d, tmp);\n\t\t}\n\t\t//d.x = sqrt(d.x);\n\t\td.y = sqrt(min(d.y, sdPointSq(uv, path[nofP - 1])));\n\t\tcol = mix(col, j==0?vec3(0.3, 0.8, 0.3):j==nofP-2?vec3(1.0, 0.0, 0.0):vec3(0.9, 0.6, 0.0), 1.0 - smoothstep(12.0 * scale * e, 13.0 * scale * e, d.y));\n\t}\n\n\t//------------------------------------------------------\n\t// Catmull-Rom interpolation\n\t//------------------------------------------------------\n\t{\n\t\tfloat d = 1e5;\n\t\tfloat ani = (cos(max(0.,iTime-0.0))*0.4+0.4)*float(nofP);\n        if (!readKeyToggle(KEY_SPACE)) ani = 1.0 * float(nofP); // draw entire thing\n\n\t\tvec2 p = path[0];\n        float lm=0.5;\n\n\t\tfor (int i = 0; i < nofP - 3; i++) {\n\t\t\tfloat fi = float(i);\n\n\t\t\tif (fi > ani) {\n\t\t\t\tbreak;\n\t\t\t}\n            \n\t\t\tvec2 A = path[i + 0];\n\t\t\tvec2 B = path[i + 1];\n\t\t\tvec2 C = path[i + 2];\n\t\t\tvec2 D = path[i + 3];\n            \n\t\t\tfor (float t = 0.0; t <= 1.01; t += 0.1) {\n\t\t\t\tvec2 q = interpolate(A, B, C, D, t);\n\n                float dt = sdSegmentSq(uv, p, q);\n                // adjust/interpolate line width for each segment (added by misol101)\n                if (dt < d) {\n                    d = dt;\n                    lm = linew[i];\n                    \n                    float l1 = length((i==0?A:B)-C);\n                    float l2 = length(C-uv);\n                    if (!readKeyToggle(KEY_V)) lm = mix(linew[i+1], linew[i], smoothstep(0.1,0.9,l2/l1) );\n                }\n\t\t\t\tp = q;\n\n\t\t\t\tif (fi + t > ani) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        if (readKeyToggle(KEY_W)) lm=0.8;\n\t\td = sqrt(d);\n\n        float bsize = 12.0*scale*lm;\n        float aa = bsize - 4.*scale;\n\n\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.0 - smoothstep(aa * e, bsize * e, d));\n        col *= 0.75 + 0.25 * smoothstep(0.0, 0.11*lm, sqrt(d));\n\t}\n\n\tfragColor = vec4(col, 1.0);\n}\n\nvoid animSingle(inout float result, float time, float startTime, float duration) {\n    if (time > startTime && time < startTime+duration) {\n        result = (time-startTime) / duration; \n    }\n}\n\nvoid getBlink(inout float bl, float time, float blTime, float blLen) {\n    if (time > blTime && time < blTime+blLen) {\n        bl = sin((time-blTime)/blLen*3.142);\n    }\n}\n\n// first line between points is drawn straight\n\n#define FACE\n#define HAIR_RIGHT\n#define HAIR_LEFT\n#define EYE_LEFT\n#define EYE_RIGHT\n#define MOUTH\n#define BREAST_STOMACH_LEFT\n#define BREAST_RIGHT\n#define ARM_LEFT\n#define ARM_RIGHT_UPPER\n#define ARM_RIGHT_LOWER\n#define LEG_LEFT\n#define LEG_RIGHT_L\n#define LEG_RIGHT_R\n#define NAVEL\n#define NIPPLES\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    const vec2 P = vec2(0.); // padding\n    vec4 colC=vec4(1.), colT;\n\n#ifdef ARM_RIGHT_UPPER\n    if (length(uv-V(0.613,0.6)) < 0.18) {\n        const vec2 cN = V(0.685,0.499); // last point, to add twice\n        vec2 armRU[NUM] =  vec2[] ( V(0.578,0.765), V(0.579,0.734), V(0.614,0.738), V(0.627,0.709), V(0.599,0.61), V(0.587,0.51), V(0.619,0.49), cN, cN, P, P, P );\n        float linewArmRU[WNUM] = float[] ( 0.6, 1.0, 0.6, 0.8, 0.7, 0.8, 0.5, -0., -0., -0. );\n        \n        /*float amv = 0.;\n        animSingle(amv, mod(iTime,23.), 7.8, 9.2);\n        amv = sin(amv*4.*3.1416);\n        armRU[7].y -= amv*0.04*0.3;\n        armRU[8].y -= amv*0.04*0.3;*/\n        \n        drawPath(colT, fragCoord, armRU, linewArmRU, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef ARM_RIGHT_LOWER\n    if (length(uv-V(0.607,0.502)) < 0.1) {\n        vec2 armRD[NUM] =  vec2[] ( V(0.563,0.568), V(0.563,0.568), V(0.548,0.476), V(0.568,0.439), V(0.609,0.429), V(0.68,0.447), V(0.68,0.447), P,P,P,P,P );\n        float linewArmRD[WNUM] = float[] ( 0.6, 1.0, 0.6, 0.95, 0.5, -0., -0., -0., -0., -0. );\n\n        /*float amv = 0.;\n        animSingle(amv, mod(iTime,23.), 7.8, 9.2);\n        amv = sin(amv*4.*3.1416);\n        armRD[5].y -= amv*0.03*0.3;\n        armRD[6].y -= amv*0.03*0.3;*/\n\n        drawPath(colT, fragCoord, armRD, linewArmRD, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef LEG_RIGHT_L\n    if (length(uv-V(0.442,0.187)) < 0.2) {\n        const vec2 cN = V(0.432,0.0);\n        vec2 legRL[NUM] =  vec2[] ( V(0.456,0.368), V(0.446,0.352), V(0.431,0.308), V(0.423,0.23), V(0.423,0.137), V(0.431,0.019), cN, cN,P,P,P,P );\n        float linewLegRL[WNUM] = float[] ( 0.3, 0.5, 0.6, 0.6, 0.75, 0.7, -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, legRL, linewLegRL, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef LEG_RIGHT_R\n    if (length(uv-V(0.517,0.261)) < 0.3) {\n        const vec2 cN = V(0.5535,0.529);\n        vec2 legRR[NUM] = vec2[] ( V(0.461,0.0), V(0.465,0.01), V(0.492,0.098), V(0.509,0.169), V(0.520,0.242), V(0.520,0.314), V(0.501,0.399), V(0.498,0.453), V(0.525,0.498), cN, cN, P );\n        float linewLegRR[WNUM] = float[] ( 0.6, 0.7, 0.85, 1.0, 0.95, 0.5, 0.5, 1.0, 1.0, -0. );\n        drawPath(colT, fragCoord, legRR, linewLegRR, 11);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef LEG_LEFT\n    if (length(uv-V(0.397,0.221)) < 0.19) {\n        const vec2 cN = V(0.428,0.062);\n        vec2 legL[NUM] =  vec2[] ( V(0.425,0.307), V(0.425,0.307), V(0.399,0.336), V(0.375,0.4), V(0.375,0.4), V(0.368,0.346), V(0.382,0.218), V(0.41,0.104), cN, cN ,P,P);\n        float linewLegL[WNUM] = float[] ( 0.9, 0.5, 0.0, 0.35, 0.5, 0.8, 0.6, 0.6, -0., -0. );\n        drawPath(colT, fragCoord, legL, linewLegL, 10);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef BREAST_RIGHT\n    if (length(uv-V(0.54,0.634)) < 0.1) {\n        const vec2 cN = V(0.545,0.706);\n        vec2 breastR[NUM] =  vec2[] ( V(0.594,0.681), V(0.58,0.666), V(0.579,0.621), V(0.558,0.563), V(0.516,0.5552), V(0.492,0.589), V(0.489,0.649), V(0.511,0.7), cN, cN, P,P );\n        float linewBreastR[WNUM] = float[] ( 0.4, 0.6, 1.0, 0.0, 0.55, 0.5, 0.85, 0.5, -0., -0. );\n        drawPath(colT, fragCoord, breastR, linewBreastR, 10);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef FACE\n    if (length(uv-V(0.563,0.841)) < 0.1) {\n        const vec2 cN = V(0.594,0.923);\n        vec2 face[NUM] =  vec2[] ( V(0.515,0.845), V(0.522,0.812), V(0.535,0.776), V(0.56,0.754), V(0.589,0.783), V(0.601,0.844), V(0.598,0.911), cN, cN, P,P,P );\n        float linewFace[WNUM] = float[] ( 0.5, 0.8, 0.8, 0.6, 0.5, 0.3, 0.0, -0., -0., -0. );\n        drawPath(colT, fragCoord, face, linewFace, 9);\n        colC=min(colC,colT);\n\n        float nose=length(uv-V(0.563,0.841));\n        if (nose < 0.004 && uv.y <= 0.842) {\n            float aap = smoothstep(0.002,0.004, nose);\n            colC=min(colC, vec4(aap));\n        }\n    }\n#endif\n\n#ifdef BREAST_STOMACH_LEFT\n    if (length(uv-V(0.45,0.587)) < 0.22) {\n        const vec2 cN = V(0.372,0.388);\n        vec2 breastL[NUM] =  vec2[] ( V(0.51,0.719), V(0.50,0.717), V(0.462,0.728), V(0.428,0.704), V(0.421,0.634), V(0.443,0.587), V(0.474,0.575), V(0.465,0.551), V(0.421,0.506), V(0.392,0.461), cN, cN );\n        float linewBreastL[WNUM] = float[] ( 0.4, 0.5, 0.9, 0.7, 0.6, 0.7, 0.9, 0.9, 0.7, 0.3 );\n        drawPath(colT, fragCoord, breastL, linewBreastL, 12);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef HAIR_RIGHT\n    if (length(uv-V(0.563,0.841)) < 0.16) {\n        const vec2 cN = V(0.59,0.920);\n        vec2 hairR[NUM] =  vec2[] ( V(0.618,0.737), V(0.621,0.782), V(0.617,0.889), V(0.594,0.958), V(0.55,0.978), V(0.519,0.921), V(0.505,0.859), V(0.491,0.813), V(0.538,0.881), V(0.573,0.931), cN, cN);\n        float linewHairR[WNUM] = float[] ( 0.5, 0.8, 0.8, 0.6, 0.7, 0.4, 0.05, 0.8, 0.4, 0.5 );\n        drawPath(colT, fragCoord, hairR, linewHairR, 12);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef EYE_RIGHT\n    if (length(uv-V(0.584,0.864)) < 0.03) {\n        const vec2 cN = V(0.573,0.856);\n        vec2 eyeR[NUM] =  vec2[] ( V(0.57,0.862), V(0.57,0.862), V(0.585,0.87), V(0.605,0.865), V(0.587,0.859), cN, cN, P, P, P, P, P);\n\n        float bl = 0.;\n        float period = 7.;\n        float time = mod(iTime, period);\n        getBlink(bl, time, 2.1, 0.3);\n        if ((int(iTime/period) & 1) == 0) {\n            getBlink(bl, time, 4.7, 0.3);\n            getBlink(bl, time, 5.3, 0.3);\n        }\n        eyeR[2].y -= bl*0.009;\n\n        float linewEyeR[WNUM] = float[] ( 0.3, 0.6, 0.8, 0.6, 0.3, 0.4, -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, eyeR, linewEyeR, 7);\n        colC=min(colC,colT);\n\n        float pup=length(vec2((uv.x-0.584), (uv.y-0.864+0.003*bl)*(1.+bl)));\n        if (pup < 0.006) {\n            float aap = smoothstep(0.005,0.006, pup);\n            colC=min(colC, vec4(aap));\n        }\n    }\n#endif\n\n#ifdef EYE_LEFT\n    if (length(uv-V(0.541,0.862)) < 0.02) {\n        const vec2 cN = V(0.573,0.856);\n        vec2 eyeL[NUM] =  vec2[] ( V(0.553,0.858), V(0.553,0.858), V(0.532,0.869), V(0.528,0.859), V(0.551,0.856), cN, cN, P, P, P, P, P);\n        float linewEyeL[WNUM] = float[] ( 0.3, 0.6, 0.8, 0.3, -0., -0., -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, eyeL, linewEyeL, 6);\n        colC=min(colC,colT);\n\n        float pup=length(uv-V(0.541,0.862));\n        if (pup < 0.005) {\n            float aap = smoothstep(0.004,0.005, pup);\n            colC=min(colC, vec4(aap));\n        }\n    }\n#endif\n\n#ifdef MOUTH\n    if (length(uv-V(0.565,0.809)) < 0.04) {\n        const vec2 cN = V(0.544,0.812);\n        vec2 mouth[NUM] =  vec2[] ( V(0.541,0.817), V(0.544,0.812), V(0.564,0.821), V(0.585,0.821), V(0.575,0.791), V(0.555,0.787), cN, cN, P, P, P, P);\n        float linewMouth[WNUM] = float[] ( 0.3, 0.6, 0.3, 1.0, 1.0, 0.4, 0.4, -0., -0., -0. );\n        drawPath(colT, fragCoord, mouth, linewMouth, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef HAIR_LEFT\n    if (length(uv-V(0.521,0.77)) < 0.09) {\n        const vec2 cN = V(0.513,0.83);\n        vec2 hairL[NUM] =  vec2[] ( V(0.541,0.764), V(0.54,0.747), V(0.528,0.724), V(0.503,0.724), V(0.494,0.753), V(0.51,0.796), V(0.513,0.837), cN, cN, P,P,P);\n        float linewHairL[WNUM] = float[] ( 0.5, 0.8, 0.8, 0.6, 0.4, 0.8, -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, hairL, linewHairL, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef ARM_LEFT\n    if (length(uv-V(0.382,0.502)) < 0.09) {\n        vec2 armL[NUM] =  vec2[] ( V(0.433,0.518), V(0.413,0.514), V(0.366,0.53), V(0.300,0.54), V(0.317,0.513), V(0.349,0.48), V(0.391,0.463), V(0.391,0.463), P,P,P,P );\n        float linewArmL[WNUM] = float[] ( 0.6, 0.6, 0.3, 0.3, 0.7, 0.95, -0., -0., -0., -0. );\n\n        drawPath(colT, fragCoord, armL, linewArmL, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n    vec2 navel[NUM] =  vec2[] ( V(0.427,0.430), V(0.427,0.430), V(0.429,0.404), V(0.4249,0.393), V(0.422,0.402), V(0.424,0.412), V(0.424,0.412), P, P,P,P,P );\n    float linewNavel[WNUM] = float[] ( 0.1, 0.3, 0.6, 0.3, 0.3, -0., -0., -0., -0., -0. );\n#ifdef NAVEL\n    if (length(uv-V(0.425,0.41)) < 0.025) {\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef NIPPLES\n    for (int i=0; i < NUM; i++) navel[i] +=  vec2(0.1, 0.23); // right\n    if (length(uv-V(0.425+0.1,0.41+0.23)) < 0.025) {\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n\n    if (length(uv-V(0.425+0.1-0.099,0.41+0.23+0.033)) < 0.025) {\n        for (int i=0; i < NUM; i++) navel[i] +=  vec2(-0.099, 0.033); // left\n        linewNavel[4] = 0.;\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n    fragColor = colC; \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}