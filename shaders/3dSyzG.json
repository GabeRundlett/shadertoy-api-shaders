{
    "Shader": {
        "info": {
            "date": "1586801058",
            "description": "challenge: recreate https://www.instagram.com/p/B3dHAHCHSrv/\nvia: @DmC",
            "flags": 0,
            "hasliked": 0,
            "id": "3dSyzG",
            "likes": 2,
            "name": "coffee and code challenge",
            "published": 3,
            "tags": [
                "coffee"
            ],
            "usePreview": 0,
            "username": "adamburr",
            "viewed": 269
        },
        "renderpass": [
            {
                "code": "// challenge: recreate https://www.instagram.com/p/B3dHAHCHSrv/\n// via: @DmC\n\n// easter colors:\nvec3 colorA = vec3(1., .4, .8);\nvec3 colorB = vec3(.8, 1., .4);\nvec3 colorC = vec3(.4, .8, 1.);\nconst float shade = .2;\n\n// animation:\nconst float persp = .9;\nconst float spin = .7;\nconst float dolly = .04;\n\n// constants:\nconst float pi = asin(1.);\nconst float bgDepth = 1e16;\n\nstruct Cylinder {\n    vec3 centers[2];\n    float radius;\n};\n\nstruct Ray {\n    vec3 position;\n    vec3 direction;\n};\n\nvoid hitPlane(vec3 position, vec3 normal, Ray ray, out float depth, out bool front)\n{\n    float nd = dot(normal, ray.direction);\n    depth = dot(position - ray.position, normal) / nd;\n    front = nd < 0.;\n}\n\nvoid hitCylinder(Cylinder cylinder, Ray ray, out float depth, out int faceId)\n{\n    // quadratic ray-cylinder intersection solve:\n    vec3 dir = normalize(cylinder.centers[0] - cylinder.centers[1]);\n    vec3 v0 = ray.position - cylinder.centers[0];\n    vec3 v1 = ray.direction - dot(ray.direction, dir) * dir;\n    vec3 v2 = v0 - dir * dot(v0, dir);\n    float a = dot(v1, v1);\n    float b = dot(v1, v2) * 2.;\n    float c = dot(v2, v2) - cylinder.radius * cylinder.radius;\n    float desc = b * b - 4. * a * c;\n    float sqrtDesc = sqrt(desc);\n    float d = .5 / a;\n    depth = desc > 0. ? (-b - sqrtDesc) * d : bgDepth;\n    float backDepth = desc > 0. ? (-b + sqrtDesc) * d : bgDepth;\n\n    // end caps:\n    faceId = 0;\n    for (int i = 0; i < 2; ++i) {\n        float hitDepth;\n        bool front;\n        hitPlane(cylinder.centers[i], dir, ray, hitDepth, front);\n        if (front != bool(i)) {\n            if (backDepth < hitDepth) {\n                depth = bgDepth;\n            } else if (depth < hitDepth) {\n                depth = hitDepth;\n                faceId = i + 1;\n            }\n        } else if (depth > hitDepth) {\n            depth = bgDepth;\n        }\n    }\n}\n\nvec4 shadeScene(vec2 uv)\n{\n    // spin angle:\n    float angle = iTime * spin + pi * .5;\n    float sinAngle = sin(angle);\n    float cosAngle = cos(angle);\n    bool phase = sinAngle > 0.;\n    \n    // camera dolly:\n    float dollyTime = iTime * iTime * dolly + 1.;\n\n    // this does the crazy ortho/persp blending:\n    Ray ray;\n    ray.position = vec3(uv * dollyTime, 0.);\n    float lens = abs(sinAngle); // <- this\n    ray.direction = normalize(vec3(uv * persp * lens, 1.));\n\n    // tiling selects which cylinders are drawn:\n    vec2 tile = floor((ray.position.xy - vec2(0., float(phase))) * .5 + .5);\n    vec3 tileCenter = vec3(tile * 2. + vec2(0., float(phase)), 0.);\n    \n    // draw 4 cylinders around empty center hole:\n    Cylinder cylinder;\n    cylinder.radius = .5;\n    float depth = bgDepth;\n    int colorId;\n    for (int dir = 0; dir < 2; ++dir) { // x or y\n        float endOffsetZ = bool(dir) == phase ? -sinAngle : sinAngle;\n        vec3 endOffset = vec3(0., cosAngle, endOffsetZ) * .5;\n        for (int sign = 0; sign < 2; ++sign) { // - or +\n            // draw a cylinder:\n            vec3 cylinderOffset = vec3(0.);\n            cylinderOffset[dir] = float(sign * 2 - 1);\n            cylinder.centers[0] = tileCenter + cylinderOffset + endOffset;\n            cylinder.centers[1] = tileCenter + cylinderOffset - endOffset;\n            float hitDepth;\n            int faceId;\n            hitCylinder(cylinder, ray, hitDepth, faceId);\n            // depth composite:\n            if (hitDepth < depth) {\n                depth = hitDepth;\n                colorId = faceId;\n            }\n        }\n    }\n\n    // colors:\n    vec3 modelColor = bool(colorId % 3) ? colorC : (phase ? colorB : colorA);\n    vec3 bgColor = phase ? colorA : colorB;\n\n    // depth lighting:\n    float light = mix(1., .5 - depth, shade);\n    float fill = 1. - shade * .5;\n    modelColor *= mix(fill, light, lens);\n    bgColor *= fill;\n\n    // final comp:\n    return vec4(depth < bgDepth ? modelColor : bgColor, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // supersampling:\n    const int samplesSqrt = 2;\n    float xyScale = 1. / iResolution.y;\n    vec2 xy = (fragCoord.xy - iResolution.xy * .5) * xyScale;\n    float xyStep = xyScale / float(samplesSqrt);\n    fragColor = vec4(0.);\n    for (int i = 0; i < samplesSqrt; ++i) {\n        for (int j = 0; j < samplesSqrt; ++j) {\n            vec2 uv = xy + vec2(i, j) * xyStep - xyScale * .5;\n            fragColor += shadeScene(uv);\n        }\n    }\n    fragColor *= 1. / fragColor.a;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}