{
    "Shader": {
        "info": {
            "date": "1690996661",
            "description": "The wave equation applied to a spherical source, with varying Courant number, rendered via voxel traversal. Voxel shadows are precomputed.\n\n*WASD/QE: control camera*\n*mouse: move light*\n*Left/right: voxel resolution*\n*space: reset*\n*alt: b/w*",
            "flags": 48,
            "hasliked": 0,
            "id": "ctlczH",
            "likes": 28,
            "name": "Courant Noise Voxels",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "wave",
                "light",
                "voxel",
                "volumetric",
                "shadows",
                "transparent",
                "translucent",
                "equation"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 276
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another shader using the wave equation, but in 3D. It's the 3D analogue of my\n//  previous shader\n//\n//      Courant Noise                      https://shadertoy.com/view/cslBWX\n//\n//  Specifically, they are both updated according to Nils Burglund's \"wave equation\"\n//  with a Courant number (also wave speed) that is positionally dependant.\n//\n//  The rendering is conceptually identical but cleaned up from its fork parent\n//\n//      Smoke of Many Colors               https://shadertoy.com/view/ddGGzd\n//      \n//  Buffer A runs the simulation while Buffer B computes the light/shadow reaching\n//  each voxel. By default, the voxel buffer size is the maximum possible NxNxN that\n//  will fit in your buffer; press left arrow to reduce it (and right arrow to increase\n//  it back again). You might get a performance benefit from a scaled-down buffer size.\n//\n//  I've tried to tune the sim so that different resolutions and buffer sizes appear\n//  as similar as I could get, but of course very small buffers look quite a bit\n//  different from \"normal sized\" ones.\n//\n//  Move the light around with the mouse, and take control of the camera with WASD/QE.\n//  Space to reset and resume camera rotation. Hold alt to turn off the false color\n//  for a more traditional \"cloud\" effect.\n//\n//  In terms of the implmentation, the voxel traversal is fairly standard but you\n//  might find it interesting that I achieved minimal \"generic programming\" with it.\n//  The traversal is implemented as a function-like macro INTEGRATE_VOXELS, so that\n//  different voxel processors can be plugged in. I am thereby able to use the same\n//  voxel loop for voxel self shadows, ground shadows, and voxel rendering.\n//\n//  The floor is rendered using the technique from iq's\n//\n//       Filtered checker (triangle, 3D)   https://shadertoy.com/view/llffWs\n//\n// ---------------------------------------------------------------------------------------\n\nvoid renderVoxels(vec3 ro, vec3 rd, int maxIter, float maxDist, inout vec3 color);\nvec3 ACESFilm(vec3 x);\nfloat renderChecker( in vec2 fragCoord, float light, float t, vec3 pos, vec3 ro, vec3 rd, vec3 ww, vec3 uu, vec3 vv );\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    // init global variables\n    fxGetState();\n    computeVoxelSide();\n\n    // set up main camera ray\n    vec3 ta, ro, fwd, left, up;\n    fxCalcCamera(ta, ro, fwd, left, up);\n    vec3 rd = fxCalcRay(u, iResolution, fwd, left, up);\n    \n    // noise to reduce visible voxel boundaries\n    float dth = textureLod(iChannel2,(floor(iTime*1024.0)+u)/1024.0,0.0).x*1.0;\n    vec3 dth3 = vec3(dth, fract(dth + .666), fract(dth * .333)) * 2. - 1.;\n\n    // ground\n    float t = -ro.y / rd.y;\n    vec3 hit = ro + rd * t; // ground hit position\n    vec3 ld = g_State.lightPos - hit; // light direction\n    float light = 1e2 * ld.y / dot(ld, ld); // light intensity\n\n    // compute shadows\n    ld = normalize(ld);\n    float block = 1.;\n    vec2 ts = boxIntersection(hit - vec3(0, g_vs / 2., 0), ld, vec3(g_vs / 2.));\n\n    if (ts.x != -1. && g_State.resolution > 0. && rd.y < 0.)\n    {\n        block = integrateDensity(hit + dth3, ld, g_ivs * 4, ts.y);\n    }\n\n    // checkerboard pattern\n    float check = renderChecker(u, light, t, hit, ro, rd, fwd, left, up);\n\n    // compute color\n    O = vec4(block * check);\n    \n    // check for ray hitting voxel bounding box\n    vec2 t2 = boxIntersection(ro - vec3(0, g_vs / 2., 0), rd, vec3(g_vs / 2.));\n    \n    if (t2.x != -1. && g_State.resolution > 0.)\n    {\n        // if the ray hits the box, cast against the voxels\n        renderVoxels(ro + rd * t2.x + dth3, rd, g_ivs * 2, t2.y, O.rgb);\n    }\n    \n    O.xyz = pow(ACESFilm(O.xyz), vec3(1./2.2));\n    O.a = 1.;\n}\n\n// VOXELS\n\n// light scattering\nconst float LIGHT_BLOCK = .5;\nconst float LIGHT_BOUNCE = 1.;\n\n// collect color contributed to the pixel by a single voxel. this function is designed\n// to be used as a \"functor\" for INTEGRATE_VOXELS.\nvoid colorFromVoxel(vec3 pos, inout vec4 acc, sampler2D vox, int width)\n{\n    vec4 v = voxel(pos);\n    if (v.w > MIN_DENS)\n    {\n        acc.a *= exp(-max(0., v.w)); // accumulate alpha with Beer's Law\n\n        ivec3 addr = ivec3(pos + vec3(g_vs / 2., 0, g_vs / 2.));\n        ivec2 coords = coordFromAddr(addr, width);\n        float light = fxIsStatePixel(coords) ? 0. : texelFetch(iChannel1, ivec2(coords), 0).x * .2 + .008; // get bounced/trasmitted light from buffer\n        vec3 color = keyDown(KEY_ALT) ? vec3(1) : normalize(sin(smoothstep(-0.8, .8, v.w) * 6. + vec3(0, 11, 33))); // colorize\n        acc.rgb += acc.a * v.w * light * LIGHT_BOUNCE * color; // add light contribution from bounced light\n    }\n}\n\n// traverse voxels and accumulate color along camera ray\nvoid renderVoxels(vec3 ro, vec3 rd, int maxIter, float maxDist, inout vec3 color)\n{\n    INTEGRATE_VOXELS(ro, rd, maxIter, maxDist, iChannel0, int(iResolution.x), colorFromVoxel);\n    \n\tcolor = color * a.a + a.rgb;\n}\n\n// COLOR GRADING\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\n// CHECKERED FLOOR\n\n// from iq's  Filtered checker (triangle, 3D)  https://shadertoy.com/view/llffWs\n// --- analytically triangle-filtered checkerboard ---\n\nvec3 pri(vec3 x)\n{\n    // see https://www.shadertoy.com/view/MtffWs\n    vec3 h = fract(x/2.)-.5;\n    return x*.5 + h*(1.-2.*abs(h));\n}\n\nfloat checkersTextureGradTri(vec3 p, vec3 ddx, vec3 ddy)\n{\n    vec3 w = max(abs(ddx), abs(ddy)) + .001;      // filter kernel\n    vec3 i = (pri(p+w)-2.*pri(p)+pri(p-w))/(w*w); // analytical integral (triangle filter)\n    return .5 - .5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvec3 texCoords(vec3 p)\n{\n\treturn 5. * p / g_vs + vec3(0, .5, 0);\n}\n\nfloat renderChecker(vec2 u, float light, float t, vec3 pos, vec3 ro, vec3 rd, vec3 ww, vec3 uu, vec3 vv)\n{\n\tvec3 ddx_rd = fxCalcRay(u + vec2(1,0), iResolution, ww, uu, vv);\n\tvec3 ddy_rd = fxCalcRay(u + vec2(0,1), iResolution, ww, uu, vv);\n\n    // trace\n\tfloat col = rd.y * .1 + .02;\n\tif( t > 0. && ro.y > 0. )\n\t{\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ro - ddx_rd*(ro-pos).y/ddx_rd.y;\n\t\tvec3 ddy_pos = ro - ddy_rd*(ro-pos).y/ddy_rd.y;\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3     uvw = texCoords(    pos);\n\t\tvec3 ddx_uvw = texCoords(ddx_pos) - uvw;\n\t\tvec3 ddy_uvw = texCoords(ddy_pos) - uvw;\n        \n\t\t// shading\t\t\n\t\tcol = checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw);\n\n        // fog\t\t\n        col = mix( col, .9, 1.-exp( -.000001*t*t ) ) * light;\n\t}\n\t\n\treturn col * .8 + .1;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float LIGHT_INTENS = 1.5; // light intensity\nconst float MIN_DENS = .08; // miminum density\nconst float DENSITY_LIGHT_BLOCK = .1; // how much light is blocked by some amount of density\n\n// UTILITY\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat length2(vec3 v) { return dot(v, v); }\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_ALT 18\n#define KEY_SPACE 32\n\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Q 81\n#define KEY_E 69\n\n// https://iquilezles.org/articles/boxfunctions/\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n\n    return vec2( tN, tF );\n}\n\n// STATE MANAGEMENT\n\nstruct fxState\n{\n    vec3 lightPos;\n    float camAngle;\n    float camPitch;\n    float camOrbit;\n    float resolution;\n    float bufferScale;\n    float attractPause;\n    float camPitchVel;\n    float waveDelay;\n} g_State;\n\nvoid fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(0, 1), 0);\n    vec4 data2 = texelFetch(sampler, ivec2(0, 2), 0);\n    \n    g_State.camAngle = data0.x;\n    g_State.camPitch = data0.y;\n    g_State.camOrbit = data0.z;\n    g_State.resolution = data0.w;\n    g_State.bufferScale = data1.x;\n    g_State.camPitchVel = data1.y;\n    g_State.attractPause = data1.z;\n    g_State.lightPos = data2.xyz;\n    g_State.waveDelay = data2.w;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel1)\n\nvec4 fxPutState(ivec2 ifc)\n{\n    if (ifc == ivec2(0, 2))\n        return vec4(g_State.lightPos, g_State.waveDelay);\n    else if (ifc == ivec2(0, 1))\n        return vec4(g_State.bufferScale, g_State.camPitchVel, g_State.attractPause, 0);\n    \n    return vec4(g_State.camAngle, g_State.camPitch, g_State.camOrbit, g_State.resolution);\n}\n\nbool fxIsStatePixel(ivec2 ifc)\n{\n    return ifc == ivec2(0) || ifc == ivec2(0, 1) || ifc == ivec2(0, 2);\n}\n\nconst int NUM_STATE_PIXELS = 3; // used to move voxels over so they do not overlap with state pixels\n\n// VOXELS\n\n// the length of the side of the voxel cube\nfloat g_vs = 0.;\nint g_ivs = 0;\n\n// compute the largest voxel side length that will fit in our buffer\n// must be called in each buffer before g_vs and g_ivs are valid\n#define computeVoxelSide() computeVoxelSideImpl(iResolution.xy)\nvoid computeVoxelSideImpl(vec2 res)\n{\n    float pixels = res.x * res.y * g_State.bufferScale;\n    g_vs = trunc(pow(pixels, 1./3.));\n    g_ivs = int(g_vs);\n}\n\n// compute the voxel address from the buffer coordinates where its data is stored\n#define posFromCoord(X) posFromCoordImpl(X, int(iResolution.x))\nvec3 posFromCoordImpl(ivec2 p, int width)\n{\n    int id = p.y * width + p.x - NUM_STATE_PIXELS;\n    int y = id / (g_ivs * g_ivs);\n    int xz = id - y * (g_ivs * g_ivs);\n    int x = xz / g_ivs;\n    int z = xz - x * g_ivs;\n    return vec3(x, y, z) - vec3(g_vs / 2., 0, g_vs / 2.);\n}\n\n// compute the buffer coordinates for a particular voxel\nivec2 coordFromAddr(ivec3 p, int width)\n{\n    int id = p.z + g_ivs * p.x + g_ivs * g_ivs * p.y + NUM_STATE_PIXELS;\n    int y = id / width;\n    int x = id - y * width;\n    return ivec2(x, y);\n}\n\n// get voxel data at a particular position\n#define voxel(X) voxelImpl(X, iChannel0, int(iResolution.x))\nvec4 voxelImpl(vec3 pos, sampler2D vox, int width)\n{\n    ivec3 addr = ivec3(pos + vec3(g_vs / 2., 0, g_vs / 2.));\n    if (addr.x < 0 || addr.y < 0 || addr.z < 0) return vec4(0);\n    if (addr.x >= g_ivs || addr.y >= g_ivs || addr.z >= g_ivs) return vec4(0);\n    ivec2 coords = coordFromAddr(addr, width);\n    return texelFetch(vox, ivec2(coords), 0);\n}\n\n// integrate voxels along ray, apply \"functor\" f\n#define INTEGRATE_VOXELS(ro, rd, mi, mt, vox, w, f) \\\nvec4 a = vec4(0,0,0,1);                             \\\nvec3 p = floor(ro),                                 \\\n     s = sign(rd),                                  \\\n     q = s / rd,                                    \\\n     d = (p - ro + .5 + s * .5) / rd, m;            \\\nfloat t = 0.;                                       \\\nfor (int x = 0; x < mi && t < mt; ++x)              \\\n{                                                   \\\n    f(p, a, vox, w);                                \\\n    m = step(d, d.yzx);                             \\\n    m *= (1. - m.zxy);                              \\\n    d += m * q;                                     \\\n    p += m * s;                                     \\\n    t = dot(d - q, m);                              \\\n}\n\n// get density from one voxel. this function is designed to be used as a \"functor\" for INTEGRATE_VOXELS.\nvoid densityFromVoxel(vec3 pos, inout vec4 acc, sampler2D vox, int width)\n{\n    acc.w *= exp(-max(0., voxelImpl(pos, vox, width).w * DENSITY_LIGHT_BLOCK));\n}\n\n// accumulate density along ray, for shadows (both per-voxel and on the ground)\n#define integrateDensity(X, Y, Z, W) integrateDensityImpl(X, Y, Z, W, iChannel0, int(iResolution.x))\nfloat integrateDensityImpl(vec3 eye, vec3 ray, int maxIter, float maxDist, sampler2D vox, int width)\n{\n    INTEGRATE_VOXELS(eye, ray, maxIter, maxDist, vox, width, densityFromVoxel);\n    \n    return max(0., a.w);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(out vec3 ta, out vec3 ro, out vec3 fwd, out vec3 left, out vec3 up)\n{\n    ro = vec3(0, 0, g_State.camOrbit * g_vs);\n    ro.yz *= rotate(g_State.camPitch);\n    ro.xz *= rotate(g_State.camAngle);\n    ro.y += g_vs / 8.;\n    ta = vec3(0, g_vs / 2., 0);\n\n    fwd  = normalize(ta - ro);\n    left = -normalize(cross(fwd, vec3(0,1,0)));\n    up   = normalize(cross(left, fwd));\n}\n\nvec3 fxCalcRay(vec2 u, vec3 R, vec3 fwd, vec3 left, vec3 up)\n{\n\tvec2 screen = (u - .5 * R.xy) / R.y;\n\treturn normalize(fwd - screen.x * left - screen.y * up);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Performs wave equation simulation; x is displacement, y is previous displacement\n// ---------------------------------------------------------------------------------------\n\nconst float SPAWN_DENSITY = 100.; // how strong the waves are when created\nconst float DAMPING = .99; // allows waves to fade as they spread\n\nfloat noise(vec3 p)\n{\n    p *= .005; // scale\n    p += iTime * .002; // motion\n\n    return .45 * textureLod(iChannel2, p, 0.).x\n         + .22 * textureLod(iChannel2, 2.3 * p, 0.).x\n         + .2  * textureLod(iChannel2, 4.4 * p, 0.).x\n         + .05 * textureLod(iChannel2, 6.3 * p, 0.).x;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxGetState();\n\n    O = vec4(0);\n    \n    if (iFrame == 0 || g_State.resolution < 0.)\n        return;\n\n    computeVoxelSide();\n\n    vec3 pos = posFromCoord(ivec2(u));\n    if (pos.y >= g_vs) return;\n    \n    float C = noise(pos); // Courant number, modulated by position\n    C *= .1 * C;\n    \n    O = voxel(pos).xxyz; // shift x into y to store prev; copy old prev into z for use\n    \n    const vec2 o = vec2(1, 0); // offset\n    O.x = -O.z + 2.*O.x + C*(voxel(pos + o.xyy) + voxel(pos - o.xyy) +\n                             voxel(pos + o.yxy) + voxel(pos - o.yxy) +\n                             voxel(pos + o.yyx) + voxel(pos - o.yyx) - 6. * O).x; // apply wave equation\n\n    // spawn spherical waves at center\n    float d = distance(pos, vec3(0, g_vs * .5, 0));\n    if (d < 3. && g_State.waveDelay <= 0.)\n        O.y += SPAWN_DENSITY * pow(g_State.bufferScale * iResolution.y / 2e3, 1.2) * sin(d) / (1. + d);\n\n    O.x *= DAMPING;\n    O.w = pow(abs(O.x), 1.3); // convenience for render\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the light reaching each voxel (shadow buffer) and maintains persistent state\n// ---------------------------------------------------------------------------------------\n\nconst float ATTRACT_PAUSE_TIME = 10.; // camera rotation restarts after this many seconds\n\nvoid updateCamera();\nvoid updateLightPos();\nbool updateState(ivec2 ifc);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxGetState();\n    \n    ivec2 ifc = ivec2(u);\n    if (updateState(ifc))\n    {\n        O = fxPutState(ifc);\n        return;\n    }\n\n    computeVoxelSide();\n\n    vec3 pos = posFromCoord(ifc);\n    if (pos.y >= g_vs) return;\n    \n    if (voxel(pos).w < MIN_DENS)\n    {\n        O.x = 1.; // skip voxels with no density...we'll never query them\n        return;\n    }\n    \n    // compute light reaching this voxel\n    vec3 delta = pos - g_State.lightPos;\n    vec3 lightDir = -normalize(delta);\n    float block = integrateDensity(pos + .5 + lightDir, lightDir, g_ivs * 2, g_vs);\n    O.x = block * LIGHT_INTENS * length2(g_State.lightPos) / length2(delta);\n}\n\n// STATE MANAGEMENT\n\nvoid updateCamera()\n{\n    if (keyDown(KEY_W)) { g_State.camPitch -= .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    if (keyDown(KEY_S)) { g_State.camPitch += .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    g_State.camPitch = clamp(g_State.camPitch, -1.5, 1.5);\n    if (keyDown(KEY_A)) { g_State.camAngle -= .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    if (keyDown(KEY_D)) { g_State.camAngle += .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    if (keyDown(KEY_Q)) { g_State.camOrbit += .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    if (keyDown(KEY_E)) { g_State.camOrbit -= .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    g_State.camOrbit = max(.1, g_State.camOrbit);\n    \n    if (g_State.attractPause > 0.)\n    {\n        g_State.attractPause -= iTimeDelta;\n        g_State.camPitchVel = 0.;\n    }\n    else\n    {\n        g_State.attractPause = 0.;\n        \n        g_State.camAngle += .005;\n        g_State.camPitch += g_State.camPitchVel * 2e-5;\n        g_State.camPitchVel -= sin(g_State.camPitch * 2.) * 1.2 + .7;\n    }\n}\n\nvoid updateLightPos()\n{\n    vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    if (iMouse.z > 0.)\n        g_State.lightPos = floor(vec3(m.x * 300., m.y * 150. + 250., 200)) + .5; // keep light away from voxel sides to avoid traversal errors\n}\n\nbool updateState(ivec2 ifc)\n{\n    if (iFrame == 0)\n    {\n        g_State.camAngle = 3.;\n        g_State.camPitch = 0.;\n        g_State.camOrbit = 1.2;\n    }\n    \n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(g_State.resolution))\n    {\n        g_State.lightPos = vec3(-100, 300, 200);\n        g_State.resolution = -iResolution.x * iResolution.y;\n        g_State.bufferScale = 1.;\n        g_State.attractPause = 0.;\n        g_State.waveDelay = 0.;\n    }\n    else\n    {\n        g_State.resolution = abs(g_State.resolution);\n\n        updateCamera();\n        updateLightPos();\n\n        if (keyDown(KEY_LEFT)) { g_State.bufferScale *= .9; g_State.resolution = -abs(g_State.resolution); }\n        if (keyDown(KEY_RIGHT)) { g_State.bufferScale /= .9; g_State.resolution = -abs(g_State.resolution); }\n        \n        g_State.bufferScale = min(1., g_State.bufferScale);\n        \n        if (g_State.waveDelay < 0.)\n            g_State.waveDelay = 100.;\n        else\n            g_State.waveDelay--;\n    }\n\n    return fxIsStatePixel(ifc);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}