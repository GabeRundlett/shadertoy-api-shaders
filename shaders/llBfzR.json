{
    "Shader": {
        "info": {
            "date": "1514346391",
            "description": "Path traces a Julia Set with Monte Carlo integration\n\nDone mostly using information from http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/",
            "flags": 32,
            "hasliked": 0,
            "id": "llBfzR",
            "likes": 12,
            "name": "Monte Carlo Julia Set",
            "published": 3,
            "tags": [
                "julia",
                "tracing",
                "path",
                "monte",
                "carlo"
            ],
            "usePreview": 0,
            "username": "kjfung",
            "viewed": 1544
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define N float(iFrame)\n#define SPHERE_SIZE 75.0\n#define COLOR vec3(1.0)\n#define T 37.5\n#define FRAC_ITER 10\n#define c vec4(-0.137,-0.630,-0.475,-0.046)\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Shamelessly stolen from iq's fractal demo\n// ???? What is a cosine 多多多多\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n\n    return  sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nfloat rand(vec2 co)\n{\n    co.x += iTime;\n    co.y -= iTime;\n    return abs(sin(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453)));\n}\n\nvec4 qSquare(vec4 a)\n{\n    return vec4(a.x*a.x - dot(a.yzw,a.yzw), 2.0*a.x*(a.yzw));\n}\n\nfloat distToScene(vec3 p) {\n    vec4 f = vec4(p, 0.0);\n    float fp2 = 1.0;\n    for (int i = 0; i < FRAC_ITER; i++)\n    {\n        fp2 *= 4.0 * dot(f,f);\n\t\tf = qSquare(f) + c;\n        if (dot(f,f) > 4.0)\n            break;\n    }\n    \n    float r = length(f);\n    float julia = 0.5 * log(r) * (r/sqrt(fp2));\n    \n    vec4 n = vec4(0.0, 1.0, 0.0, 1.0);\n    float plane = dot(p,n.xyz) + n.w;\n    \n    return min(julia, plane);\n}\n\nbool rayMarch(vec3 eye, vec3 dir, out vec3 p, out vec3 nor)\n{\n    p = eye + dir;\n    float d = distToScene(p);\n    vec3  e = vec3(0.0005, 0.0, 0.0);\n\n    for(int i = 0; i < 256; i++)\n    {\n        if(d <= e.x)\n        {\n            nor = normalize(vec3(distToScene(p + e.xyy) - d,\n                                 distToScene(p + e.yxy) - d,\n                                 distToScene(p + e.yyx) - d));\n            return true;\n        }\n        p = p + d * normalize(dir);\n        d = distToScene(p);\n    }\n\n    nor = vec3(0.0);\n    return false;\n}\n\nvec3 primaryRay(vec2 pxCoord, out vec3 eye)\n{\n\teye = vec3(3.0 * sin(T), 0.0, 3.0 * cos(T));\n    float focal = 500.0;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 focus = vec3(0.0, 0.0, 0.0);\n    \n    // Perturb the pixel a little bit\n    pxCoord.x += (rand(pxCoord) - 0.5);\n    pxCoord.y += (rand(pxCoord.yx) - 0.5);\n    \n    //Calculate eye directions\n    vec3 look = focus - eye;\n    vec3 right = cross(look, up);\n    \n    //Calculate this particular pixel's normalized coordinates\n    //on the virtual screen\n    float screenX = (2.0 * pxCoord.x)/(1.0 * iResolution.x) - 1.0;\n    float screenY = (2.0 * pxCoord.y)/(1.0 * iResolution.y) - 1.0;\n\n    //Calculate the direction that the ray through this pixel goes\n    vec3 dir = normalize(focal * normalize(look)\n               + screenX * normalize(right) * iResolution.x/2.0\n               + screenY * normalize(up) * iResolution.y/2.0);\n    return dir;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Create primary ray\n    vec3 eye;\n    vec3 dir = primaryRay(fragCoord.xy, eye);\n\n    vec3 f = vec3(0.0);\n    vec3 lum = vec3(1.0);\n    vec3 p, nor;\n    for (int i = 0; i < 2; i++)\n    {\n        if (rayMarch(eye, dir, p, nor))\n        {\n            eye = p + 0.1 * nor;\n            dir = cosineDirection(rand(uv), nor);\n            lum *= 2.0 * 0.5 * dot(dir, nor);\n        }\n        else\n        {\n            f = lum * COLOR;\n        }\n    }\n    \n    vec4 oldValue = texture(iChannel0, uv);\n    fragColor = ((oldValue * N) + vec4(f, 1.0)) / (N + 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}