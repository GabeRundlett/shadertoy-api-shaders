{
    "Shader": {
        "info": {
            "date": "1668485978",
            "description": "Using a long-range Texture SDF algorithm, you have much more control over the result (such as neighbor search distance) without impacting performance.\nThe exact distance to pixel algorithm also seems to help a lot with noise and aliasing.",
            "flags": 32,
            "hasliked": 0,
            "id": "DdsXzr",
            "likes": 13,
            "name": "Procedural Eroded Mountains 2.0",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "field",
                "signed"
            ],
            "usePreview": 1,
            "username": "Hatchling",
            "viewed": 586
        },
        "renderpass": [
            {
                "code": "// Controls:\n// ______________________________\n//\n// Mouse Drag - Move Camera\n\n// May take 5-20 seconds to compile.\n// This is mainly due to recursion,\n// but this lets the shader run fast!\n// Too bad these compilations cannot be cached.\n\n// Changes:\n// - Added \"fuzzing\" to raycast algorithm so that\n//   undersampled edges are blurred instead of stepped,\n//   creating a pseudo-DoF effect instead.\n// - Added detail albedo map.\n\n// Known issues:\n// - Artifacts may be visible on mobile devices.\n//   I tried it with my phone and saw excessive\n//   dithering, this could happen to you.\n//   To fix, uncomment this line.\n// #define NO_DITHER\n\nbounds worldBounds() \n{\n    bounds b;\n    b.mini = vec3\n    (\n        0,\n        0,\n        0\n    );\n    \n    b.maxi = vec3\n    (\n        iChannelResolution[0].x,\n        600,\n        iChannelResolution[0].y\n    );\n    return b;\n}\n\nvec3 boundsToWorld(vec3 boundsPoint)\n{\n    bounds b = worldBounds();\n    return mix\n    (\n        b.mini,\n        b.maxi,\n        boundsPoint\n    );\n}\n\nvec3 worldToBounds(vec3 worldPoint)\n{\n    bounds b = worldBounds();\n    return invMix\n    (\n        b.mini,\n        b.maxi,\n        worldPoint\n    );\n}\n\nvec3 projectBoundsPoint(vec3 p, bool zeroEdge)\n{\n    if(zeroEdge && clamp(p,0.0,1.0) != p) \n    {\n        p.y = 0.0;\n        return p;\n    }\n    \n    vec4 t = texture(iChannel0, p.xz);\n    p.y = t.b / t.a;\n    return p;\n}\n\nvec3 projectWorldPoint(vec3 p, bool zeroEdge)\n{\n    p = worldToBounds(p);\n    p = projectBoundsPoint(p, zeroEdge);\n    p = boundsToWorld(p);\n    return p;\n}\n\nbool isWorldPointUnderTerrain(vec3 p)\n{\n    vec3 proj = projectWorldPoint(p, true);\n    return proj.y > p.y;\n}\n\nvoid worldPointToNormalCurvature(vec3 p, out vec3 n, out vec2 c)\n{    \n    p = worldToBounds(p);\n    vec4 t = texture(iChannel1, p.xz);\n    \n    n.xz = t.xy;\n    c = t.zw;\n    n.y = sqrt(1.0 - lengthSqr(n.xz));\n\n    /*const float offset = 16.0;\n    \n    vec3 posC = p;\n    vec3 posR = p + vec3(offset, 0.0,    0.0);\n    vec3 posL = p - vec3(offset, 0.0,    0.0);\n    vec3 posT = p + vec3(   0.0, 0.0, offset);\n    vec3 posB = p - vec3(   0.0, 0.0, offset);\n    \n    posR = projectWorldPoint(posR, false);\n    posL = projectWorldPoint(posL, false);\n    posT = projectWorldPoint(posT, false);\n    posB = projectWorldPoint(posB, false);\n    \n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    n = -normalize(cross(dx, dy));\n    \n    float curveX = dot(posC + posC - posR - posL, n);\n    float curveY = dot(posC + posC - posT - posB, n);\n    \n    c = vec2(curveX, curveY) / vec2(distance(posR, posL), distance(posT, posB));\n    \n    /*n = normalize(vec3(posL.y - posR.y, 1.0, posB.y - posT.y));\n    c = vec2\n    (\n        posL.y + posR.y - 2.0 * posC.y, \n        posB.y + posT.y - 2.0 * posC.y \n    ) * 0.5;*/\n}\n\nbool raycast(vec3 camPos, vec3 camDir, uint rngState, vec2 fragCoord, out vec3 pos)\n{\n    bounds b = worldBounds();   \n    pos = vec3(0);\n    \n    vec3 near, far;\n    if(!rayIntersectBounds(b, camPos, camDir, near, far))\n    {\n        return false;\n    }\n    \n    pos = near;\n    float minD = 0.0, maxD = 1.0;\n    bool hit = false;\n    const float increment = 0.005;\n    \n    #ifdef NO_DITHER\n    const float start = 0.0;\n    #else\n    // Randomize ray starting point to fuzz undersampled edges.\n    float noise = sampleBlueNoise(iChannel2, fragCoord, rngState).x;\n    float start = increment * noise;\n    #endif\n    \n    for(float i = start;; i += increment)\n    {\n        float j = i;\n        if(j > 1.0) j = 1.0;\n        j = i*i;\n        \n    \tpos = mix(near, far, j);\n        \n        maxD = j;\n        \n        if(isWorldPointUnderTerrain(pos))\n        {\n            hit = true;\n            break;\n        }\n        \n        minD = j;\n        \n        if(i > 1.0) \n        {\n            break;\n        }\n    }\n    \n    if(!hit) return false;\n\n    maxD = (minD + maxD) * 0.5;\n    float stepSize = (maxD - minD) * 0.5;\n\n    for(int i = 0; i < 5; i++, stepSize *= 0.5)\n    {\n    \tpos = mix(near, far, maxD);\n        if(!isWorldPointUnderTerrain(pos))\n        {\n            minD = maxD;\n            maxD += stepSize;\n        }\n        else\n        {\n            maxD -= stepSize;\n        }\n    }\n    \n    return true;\n}\n\nvec4 skybox(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    gradient *= gradient;\n    gradient *= gradient;\n   \n    gradient = 1.-gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient = 1.-gradient;\n    \n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 2.0;\n    \n    return vec4(sqrt(color), 1.0);\n}\n\nvec3 envLighting(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    gradient = 1.-gradient;\n    gradient *= gradient * gradient;\n    gradient = 1.-gradient;\n    \n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 5.0;\n    \n    return sqrt(color);\n}\n\nvec4 shade(bool hit, vec3 hitPoint, vec3 camPos, vec3 camRay)\n{\n    if(!hit) return vec4(0);\n    \n    vec3 normal;\n    vec2 curvature;\n    worldPointToNormalCurvature(hitPoint, normal, curvature);\n    \n    \n    vec2 posCurve2 = max(vec2(0), curvature);\n    vec2 negCurve2 = -min(vec2(0), curvature);\n    \n    float posCurve = posCurve2.x + posCurve2.y;\n    posCurve = posCurve / (0.025 + posCurve);\n    float negCurve = negCurve2.x + negCurve2.y;\n    negCurve = negCurve / (0.075 + negCurve);\n    float curve = (curvature.x + curvature.y);\n    curve = curve / (0.075 + abs(curve));\n    \n    //posCurve = negCurve = curve = 0.;\n    \n    //hitPoint /= 10.;\n    //hitPoint -= floor(hitPoint);\n    \n    vec3 reflDir = reflect(camRay, normal); \n    \n    Indirect ind;\n    {\n        ind.diffuse = envLighting(normal);\n        ind.specular = skybox(reflDir).rgb;\n        \n        vec3 ambientDir = vec3(0, 1, 0);\n        {\n            float ambient = dot(normal, ambientDir) * 0.5 + 0.5;\n            ambient *= ambient;\n            ambient *= ambient;\n            //ambient *= ambient;\n            ambient *= curve * 0.5 + 0.5;\n            ind.diffuse *= ambient; \n        }\n        //return vec4(ind.diffuse, 1.0);\n        {\n            float ambient = dot(normal, ambientDir) * 0.5 + 0.5;\n            ambient *= ambient;\n            ambient *= ambient;\n            //ambient *= ambient;\n            ambient *= curve * 0.5 + 0.5;\n            ind.specular *= ambient; \n        }\n        //return vec4(ind.specular, 1.0);\n    }\n    \n    \n    Light light;\n    light.dir = normalize(vec3(0, 3, 5));\n    light.color = vec3(2.0, 1.5, 1.0);\n    \n    MaterialMetallic mat;\n    {\n        mat.albedo  = vec3(1.);\n\n        float slopeFactor;\n        float heightFactor;\n        {\n            heightFactor = hitPoint.y / worldBounds().maxi.y;\n\n            heightFactor = smoothstep(0., 1., heightFactor);        \n            heightFactor = smoothstep(0., 1., heightFactor);\n\n            slopeFactor = abs(normal.y);\n            slopeFactor *= slopeFactor;\n            slopeFactor *= slopeFactor;\n            slopeFactor *= slopeFactor;\n            //slopeFactor *= slopeFactor;\n            slopeFactor = 1.-slopeFactor;\n            slopeFactor *= slopeFactor;\n            slopeFactor *= slopeFactor;\n            //slopeFactor *= slopeFactor;\n            slopeFactor = 1.-slopeFactor;\n            //slopeFactor = smoothstep(0., 1., slopeFactor);\n            //slopeFactor = smoothstep(0., 1., slopeFactor);\n            //slopeFactor = smoothstep(0., 1., slopeFactor);\n\n            vec3 flatLow = vec3(0.1, 0.4, 0.05);\n            vec3 flatHigh = vec3(0.7, 0.7, 0.5);\n\n            vec3 slopeLow = vec3(0.4, 0.7, 0.2);\n            vec3 slopeHigh = vec3(0.3, 0.2, 0.05);\n\n            vec3 flatColor = mix(flatLow, flatHigh, heightFactor);\n            vec3 slopeColor = mix(slopeLow, slopeHigh, heightFactor);\n\n            mat.albedo = mix(slopeColor, flatColor, slopeFactor);\n        }\n        \n        // Add texture.\n        {\n            vec2 texUV = (hitPoint.xz * 8.0) / iChannelResolution[3].xy;\n            \n            mat.albedo *= texture(iChannel3, texUV).rgb;\n            mat.albedo /= texture(iChannel3, texUV, 16.).rgb;\n        }\n\n        float crestFactor = slopeFactor;\n        // Highlight cracks.\n        {\n            crestFactor *= crestFactor;\n            crestFactor *= crestFactor;\n            crestFactor = 1.-crestFactor;\n            crestFactor = crestFactor * 0.6 + 0.4;\n            float crests = posCurve;\n            crests = 1.-crests;\n            crests = lerp(crests, crests*crests, 0.5);\n            crests = 1.-crests;\n            crestFactor *= crests;\n            mat.albedo = mix(mat.albedo, (mat.albedo*1.0+vec3(0.75))*vec3(0.7,0.65,0.3), crestFactor); \n        }\n\n        // Add rivers.\n        float rivers;\n        {\n            rivers = max(0.,negCurve - posCurve);\n\n            rivers = pow(rivers, pow(2., mix(0.5, -0.7, slopeFactor) + mix(-0.7, 0.7, heightFactor)));   \n\n            //rivers = pow(rivers, heightFactor + 1.0);   \n            //rivers = pow(rivers, heightFactor*3.+0.5);         \n\n            rivers = smoothstep(0., 1., rivers);\n            rivers = smoothstep(0., 1., rivers);\n\n            //rivers = 1.-rivers;\n            //rivers *= rivers;\n            //rivers = 1.-rivers;\n\n            mat.albedo = mix(mat.albedo, vec3(0.1,0.2,0.5), rivers); \n        }\n        \n        \n\n        //mat.albedo *= mat.albedo * 2.0;\n        //mat.albedo = vec3(1.);\n        \n        mat.smoothness = 0.0;\n        mat.smoothness = mix(mat.smoothness, 1., 0.75 * crestFactor);//length(color)*length(color)*0.2;\n        mat.smoothness = mix(mat.smoothness, 1., 1.0 * rivers);\n        \n        mat.metallic = crestFactor;\n        mat.metallic *= mat.metallic;\n    }\n    \n    //MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect\n    vec3 color = lighting(mat, normal, -camRay, light, ind);\n    \n    float fogScale = 1.0 / 1200.0;\n    float fogDist = lengthSqr((hitPoint - camPos) * fogScale);\n    \n    color.rgb = mix(skybox(camRay).rgb, color.rgb, pow(vec3(0.5), fogDist * vec3(0.1,0.4,2.))); \n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n\n    vec3 pivotPos   = boundsToWorld(vec3(0.5, 0.25, 0.5));\n    vec3 camPos     = boundsToWorld(vec3(0.5, 1, 0.0));\n    vec3 camOffset  = camPos - pivotPos;\n    \n    quaternion pan  = FromAngleAxis(vec3(0, iTime * 0.125, 0));\n    camOffset       = mul(pan, camOffset);\n    camPos          = pivotPos + camOffset;\n    if(iMouse.xy != vec2(0)) camPos = boundsToWorld(vec3(iMouse.xyy / iResolution.xyy));\n    camPos          = projectWorldPoint(camPos, false) + vec3(0.0, 50.0, 0.0);\n    \n    //vec3 lookDir    = -camOffset;    \n    //quaternion pan  = FromAngleAxis(vec3(0, iTime * 0.125, 0));\n    //quaternion tilt = FromToRotation(vec3(0,0,1), lookDir);\n    \n    //vec3 camRay     = normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.yy, 1));\n    //camOffset       = mul(pan, camOffset);\n    //camRay          = mul(mul(pan, tilt), camRay);\n    \n    vec3 normal; vec2 curvature;\n    worldPointToNormalCurvature(camPos, normal, curvature);\n    vec3 lookFwd;\n    vec3 lookUp;\n    vec3 lookRight;\n    \n    vec3 lookAtPoint = camPos + normalize(pivotPos - camPos) * 250.0;\n    lookAtPoint          = projectWorldPoint(lookAtPoint, false) + vec3(0.0, 10.0, 0.0);\n    \n    lookFwd = normalize(lookAtPoint - camPos);\n    lookUp = vec3(0,1,0);\n    /*lookRight = safeNormalize(cross(lookUp, lookFwd));\n    lookUp = normal;\n    lookFwd = safeNormalize(cross(lookRight, lookUp)) + lookFwd * 5.0;\n    lookUp = vec3(0,1,0);*/\n    \n    \n    quaternion look = LookRotation(lookFwd, lookUp);\n    vec3 camRay     = normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.yy, 1));\n    \n    camRay          = mul(look, camRay);\n    \n    fragColor = skybox(camRay);\n    \n    vec3 hitPoint;\n    bool hit = raycast(camPos, camRay, rngState, fragCoord, hitPoint);\n    vec4 foreground = shade(hit, hitPoint, camPos, camRay);\n    \n    blend(foreground, fragColor);\n    \n    // Vignette\n    {\n        half2 diff = abs(fragCoord / iResolution.xy - vec2(0.5));\n        half2 maxDiff = vec2(0.5);\n        vec4 _Vignette = vec4(1.0, 0.8, 2.0, 1.0); \n        \n        half maxDistanceToCenter = pow( pow(maxDiff.x, _Vignette.z) + pow(maxDiff.y, _Vignette.z), 1.0/_Vignette.z);\n        \n        half distanceToCenter = pow( pow(diff.x, _Vignette.z) + pow(diff.y, _Vignette.z), 1.0/_Vignette.z) / maxDistanceToCenter;\n        half vignette = saturate(distanceToCenter);\n        vignette = pow(vignette, _Vignette.x);\n        vignette = 1.0 - vignette;\n        vignette *= _Vignette.w;\n        vignette /= 1.0 + vignette;\n        vignette /= _Vignette.w / (1.0 + _Vignette.w);\n        vignette = smoothstep(1.0,0.0,vignette);\n        vignette = lerp(0.0, vignette, _Vignette.y);\n        fragColor.rgb = lerp(fragColor.rgb * vec3(2.0, 1.0, 0.5), vec3(0), pow(vec3(vignette), vec3(0.75, 2.0, 5.0)));\n        \n    }\n    \n    fragColor.rgb = fragColor.rgb / sqrt(1.0+fragColor.rgb*fragColor.rgb);\n    fragColor.rgb = linearToGamma(fragColor.rgb);\n    fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\n// Constants ----------------------------------\n\nconst float Pi = 3.14159265358979;\nconst float InvPi = 1.0 / 3.14159265358979;\n\n// HLSL support -------------------------------\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define half  float\n#define half2 vec2\n#define half3 vec3\n#define half4 vec4\n\n#define fixed  float\n#define fixed2 vec2\n#define fixed3 vec3\n#define fixed4 vec4\n\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n\n#define lerp mix\n\n#define decl_saturate(type)            \\\ntype saturate(type x)                  \\\n{                                      \\\n    return clamp(x, type(0), type(1)); \\\n} \n\ndecl_saturate(float)\ndecl_saturate(vec2)\ndecl_saturate(vec3)\ndecl_saturate(vec4)\n\n// Boolean -------------------------------\n\nbool  isinf2(float v) { return isinf(v); } \nbvec2 isinf2(vec2 v)\n{\n    return bvec2\n    (\n        isinf(v.x),\n        isinf(v.y)\n    );\n}\nbvec3 isinf2(vec3 v)\n{\n    return bvec3\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z)\n    );\n}\nbvec4 isinf2(vec4 v)\n{\n    return bvec4\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z),\n        isinf(v.w)\n    );\n}\n\nbool  isnan2(float v) { return isnan(v); } \nbvec2 isnan2(vec2 v)\n{\n    return bvec2\n    (\n        isnan(v.x),\n        isnan(v.y)\n    );\n}\nbvec3 isnan2(vec3 v)\n{\n    return bvec3\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z)\n    );\n}\nbvec4 isnan2(vec4 v)\n{\n    return bvec4\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z),\n        isnan(v.w)\n    );\n}\n\nbool bnot(bool b) { return !b; }\nbvec2 bnot(bvec2 b) \n{ \n    return bvec2(!b.x, !b.y); \n}\nbvec3 bnot(bvec3 b) \n{ \n    return bvec3(!b.x, !b.y, !b.z); \n}\nbvec4 bnot(bvec4 b) \n{ \n    return bvec4(!b.x, !b.y, !b.z, !b.w); \n}\n\nbool band(bool a, bool b) { return a && b; }\nbvec2 band(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x && b.x,\n        a.y && b.y\n    ); \n}\nbvec3 band(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z\n    ); \n}\nbvec4 band(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z,\n        a.w && b.w\n    ); \n}\n\nbool bor(bool a, bool b) { return a || b; }\nbvec2 bor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x || b.x,\n        a.y || b.y\n    ); \n}\nbvec3 bor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z\n    ); \n}\nbvec4 bor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z,\n        a.w || b.w\n    ); \n}\n\nbool bxor(bool a, bool b) { return a != b; }\nbvec2 bxor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x != b.x,\n        a.y != b.y\n    ); \n}\nbvec3 bxor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z\n    ); \n}\nbvec4 bxor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z,\n        a.w != b.w\n    ); \n}\n\n#define decl_isfinite(retType, type) \\\nretType isfinite(type v)             \\\n{                                    \\\n    return band                      \\\n    (                                \\\n        bnot(isinf2(v)),             \\\n        bnot(isnan2(v))              \\\n    );                               \\\n} \ndecl_isfinite(bool, float)\ndecl_isfinite(bvec2, vec2)\ndecl_isfinite(bvec3, vec3)\ndecl_isfinite(bvec4, vec4)\n\nfloat select(bool s, float a, float b)\n{\n    return s ? a : b;\n}\n\nvec2 select(bvec2 s, vec2 a, vec2 b)\n{\n    return vec2\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y\n    );  \n}\n\nvec3 select(bvec3 s, vec3 a, vec3 b)\n{\n    return vec3\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z\n    );  \n}\n\nvec4 select(bvec4 s, vec4 a, vec4 b)\n{\n    return vec4\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z,\n        s.w ? a.w : b.w\n    );  \n}\n\n// Vector math -------------------\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) \\\nretType lengthSqr(type a)             \\\n{                                     \\\n    return dot2(a,a);                 \\\n}                                     \n\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) \\\nretType distSqr(type a, type b)     \\\n{                                   \\\n    type diff = a-b;                \\\n    return lengthSqr(diff);         \\\n}                                   \n\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// Borrowed from UnityEngine\n#define decl_safeNormalize(type)                 \\\ntype safeNormalize(type inVec)                   \\\n{                                                \\\n    float dp3 = max(0.001f, dot2(inVec, inVec)); \\\n    return inVec / sqrt(dp3);                    \\\n}\ndecl_safeNormalize(vec2)\ndecl_safeNormalize(vec3)\ndecl_safeNormalize(vec4)\n\n// Misc. math --------------------\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type)              \\\nretType floorToInt(type a)                          \\\n{                                                   \\\n    return retType(floor(a) + sign(a) * type(0.5)); \\\n}                                                   \n\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n\n#define decl_invMix(type) \\\ntype invMix(type a, type b, type t) \\\n{                                   \\\n    type result = (t-a)/(b-a);      \\\n    return select(isfinite(result), result, type(0.5)); \\\n}\n\ndecl_invMix(float)\ndecl_invMix(vec2)\ndecl_invMix(vec3)\ndecl_invMix(vec4)\n\n#define invLerp invMix\n\nhalf Pow5 (half x)\n{\n    return x*x * x*x * x;\n}\n\nhalf2 Pow5 (half2 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf3 Pow5 (half3 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf4 Pow5 (half4 x)\n{\n    return x*x * x*x * x;\n}\n\n// RNG ----------------------------------------\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}\n\n// Color -------------------------------\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\nstruct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nquaternion LookRotation(float3 forward, float3 up)\n{\n    quaternion q;\n    forward = safeNormalize(forward);\n    q = FromToRotation(vec3(0,0,1), forward);\n    up = up - dot(forward, up) * forward;\n    vec3 upFrom = mul(q, vec3(0,1,0));\n    q = mul(FromToRotation(upFrom, up), q);\n    return q;\n}\n\n\n\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n// PBR Lighting ------------------------------\n// Borrowed from UnityEngine\nstruct MaterialMetallic\n{\n    fixed3 albedo;      // base (diffuse or specular) color\n    half metallic;      // 0=non-metal, 1=metal\n    half smoothness;    // 0=rough, 1=smooth\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specColor;\n    float oneMinusReflectivity;\n    float smoothness;\n};\n\nstruct Light\n{\n    half3 color;\n    half3 dir;\n};\n\nstruct Indirect\n{\n    half3 diffuse;\n    half3 specular;\n};\n\nconst float4 dielectricSpec = float4(0.04, 0.04, 0.04, 1.0 - 0.04);\n\nhalf OneMinusReflectivityFromMetallic(half metallic)\n{\n    half oneMinusDielectricSpec = dielectricSpec.a;\n    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nhalf3 DiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)\n{\n    specColor = lerp (dielectricSpec.rgb, albedo, metallic);\n    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n    return albedo * oneMinusReflectivity;\n}\n\nMaterial toMaterial(MaterialMetallic i)\n{\n    Material o;\n    \n    o.albedo = i.albedo;\n    o.smoothness = i.smoothness;\n    \n    half oneMinusReflectivity;\n    half3 specColor;\n    o.albedo = DiffuseAndSpecularFromMetallic (o.albedo, i.metallic, o.specColor, o.oneMinusReflectivity);\n    \n    return o;\n}\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1.0 - smoothness);\n}\n\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\nhalf DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)\n{\n    half fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    half lightScatter   = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotL));\n    half viewScatter    = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotV));\n\n    return lightScatter * viewScatter;\n}\n\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    // Original formulation:\n    //  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\n    //  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\n    //  G           = 1 / (1 + lambda_v + lambda_l);\n\n    // Reorder code to be more optimal\n    half a          = roughness;\n    half a2         = a * a;\n\n    half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);  // This function is not intended to be running on Mobile,\n                                                // therefore epsilon is smaller than can be represented by half\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return InvPi * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nhalf3 FresnelTerm (half3 F0, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\n\nhalf3 FresnelLerp (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return lerp (F0, F90, t);\n}\n\n\nhalf3 brdf (half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi)\n{\n    float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    float3 halfDir = safeNormalize(float3(light.dir) + viewDir);\n\n    // The amount we shift the normal toward the view vector is defined by the dot product.\n    half shiftAmount = dot(normal, viewDir);\n    normal = shiftAmount < 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;\n    normal = normalize(normal);\n\n    float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here\n\n    float nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n\n    half lv = saturate(dot(light.dir, viewDir));\n    half lh = saturate(dot(light.dir, halfDir));\n\n    // Diffuse term\n    half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl / 3.1415927;\n\n    // Specular term\n    float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    \n    // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\n    roughness = max(roughness, 0.002);\n    float V = SmithJointGGXVisibilityTerm (nl, nv, roughness);\n    float D = GGXTerm (nh, roughness);\n\n    float specularTerm = V*D; // Torrance-Sparrow model, Fresnel is applied later\n\n    // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value\n    specularTerm = max(0.0, specularTerm * nl);\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\n    half surfaceReduction;\n    surfaceReduction = 1.0 / (roughness*roughness + 1.0);           // fade \\in [0.5;1]\n\n    // To provide true Lambert lighting, we need to be able to kill specular completely.\n    //specularTerm *= (specColor != vec3(0)) ? 1.0 : 0.0;\n\n    half grazingTerm = saturate(smoothness + (1.0-oneMinusReflectivity));\n    half3 color =   albedo * (gi.diffuse + light.color * diffuseTerm)\n                    + specularTerm * light.color * FresnelTerm (specColor, lh)\n                    + surfaceReduction * gi.specular * FresnelLerp (specColor, vec3(grazingTerm), nv)\n                    ;\n\n    return half3(color);\n}\n\n/*half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi*/\nvec3 lighting(MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect)\n{\n    Material m = toMaterial(mat);\n    \n    return brdf(m.albedo, m.specColor, m.oneMinusReflectivity, m.smoothness,\n    normal, viewDir, light, indirect);\n    \n}\n\n/////////////////////////////////////////////////////////////\n// C# Code used to precompute coordinate lookup tables:\n/*\nusing System;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Linq;\n\t\t\t\t\t\npublic class Program\n{\n\tstatic void GetSubsampleCoords(int index, out int[] c0, out int[] c1, out int[] c2, out int[] c3)\n\t{\n\t\tint r = 0x1B; // 00 10 01 11;\n\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tconst int xor = 0xAA; // 10 10 10 10\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tconst int xor = 0x55; // 01 01 01 01\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tconst int xor = 0x3C; // 00 11 11 00\n\t\t\tr = r ^ xor;\n\t\t}\n\n\t\tint[] c0_m = new int[2]\n\t\t{\n\t\t\t0x80, // 10 00 00 00\n\t\t\t0x40 // 01 00 00 00\n\t\t};\n\n\t\tint[] c0_s = new int[2]\n\t\t{\n\t\t\t7,\n\t\t\t6\n\t\t};\n\t\t\n\t\tint[] c1_m = new int[2]\n\t\t{\n\t\t\t0x20, // 00 10 00 00\n\t\t\t0x10  // 00 01 00 00\n\t\t};\n\n\t\tint[] c1_s = new int[2]\n\t\t{\n\t\t\t5, \n\t\t\t4 \n\t\t};\n\n\t\tint[] c2_m = new int[2]\n\t\t{\n\t\t\t0x08, // 00 00 10 00\n\t\t\t0x04  // 00 00 01 00\n\t\t};\n\n\t\tint[] c2_s = new int[2]\n\t\t{\n\t\t\t3, \n\t\t\t2\n\t\t};\n\t\t\n\t\tint[] c3_m = new int[2]\n\t\t{\n\t\t\t0x02, // 00 00 00 10\n\t\t\t0x01  // 00 00 00 01\n\t\t};\n\n\t\tint[] c3_s = new int[2]\n\t\t{\n\t\t\t1,\n\t\t\t0\n\t\t};\n\t\t\n\t\tc0 = new int[2];\t\t\n\t\tc1 = new int[2];\n\t\tc2 = new int[2];\n\t\tc3 = new int[2];\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tc0[i] = (r & c0_m[i]) >> c0_s[i];\n\t\t\tc1[i] = (r & c1_m[i]) >> c1_s[i];\n\t\t\tc2[i] = (r & c2_m[i]) >> c2_s[i];\n\t\t\tc3[i] = (r & c3_m[i]) >> c3_s[i];\n\t\t}\n\t}\n\t\n\tstatic string AsString(int[] v)\n\t{\n\t\tstring s = \"ivec2(\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t}\n\t\t\ts = s + v[i].ToString();\n\t\t}\n\t\t\n\t\ts += \"), \";\n\t\treturn s;\n\t}\n\t\n\tstatic Vector2 GetTestCoord(int index)\n\t{\n\t\tVector2 v = default(Vector2);\n\t\t\n\t\t// abs(x) > abs(y)?\n\t\tif((index & 4) != 0)\n\t\t{\n\t\t\tv.X = 0.25f;\n\t\t\tv.Y = 0.125f;\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tv.X = 0.125f;\n\t\t\tv.Y = 0.25f;\n\t\t}\n\t\t\n\t\t// x < 0?\n\t\tif((index & 1) != 0)\n\t\t{\n\t\t\tv.X = -v.X;\n\t\t}\n\t\t\n\t\t// y < 0?\n\t\tif((index & 2) != 0)\n\t\t{\n\t\t\tv.Y = -v.Y;\n\t\t}\n\t\t\n\t\treturn -v;\n\t}\n\t\n\tstatic string AsString(Vector2 v)\n\t{\n\t\treturn string.Format\n\t\t(\n\t\t\t\"ivec2({0}{1}, {2}{3})\", \n\t\t\t v.X < 0 ? '-' : (v.X > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.X), \n\t\t\t v.Y < 0 ? '-' : (v.Y > 0 ? '+' : ' '), \n\t\t\t Math.Abs(v.Y)\n\t     );\n\t}\n\t\n\tstatic string AsString(Vector2[] v)\n\t{\n\t\tstring s = \"\";\n\t\t\n\t\tfor(int i = 0; i < v.Length; i++)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\ts = s + \", \";\n\t\t\t\t\n\t\t\t\tif(i % 4 == 0)\n\t\t\t\t\ts = s + '\\n';\n\t\t\t}\n\t\t\ts = s + AsString(v[i]);//.ToString();\n\t\t}\n\t\t\n\t\ts += \",\";\n\t\treturn s;\n\t}\n\t\n\tpublic static void Main()\n\t{\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint[] a, b, c, d;\n\t\t\tGetSubsampleCoords(i, out a, out b, out c, out d);\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(AsString(a) \n\t\t\t\t\t\t\t+ AsString(b)\n\t\t\t\t\t\t\t+ AsString(c)\n\t\t\t\t\t\t\t+ AsString(d));\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"________________\");\n\t\tConsole.WriteLine(\"                \");\n\t\t\n\t\tconst int radius = 4;\n\t\tconst int diameter = radius+radius+1;\n\t\tconst int capacity = diameter * diameter - 1;\n\t\tList<Vector2> pixelCoords = new List<Vector2>(capacity);\n\t\t\n\t\tconst float maxDistanceSqr = (radius + 0.5f) * (radius + 0.5f);\n\n\t\tfor(int x = -radius; x <= radius; x++)\n\t\t{\n\t\t\tfor(int y = -radius; y <= radius; y++)\n\t\t\t{\n\t\t\t\tif(x == 0 && y == 0) continue;\n\t\t\t\tpixelCoords.Add(new Vector2(x,y));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tVector2 testCoord = GetTestCoord(i);\n\t\t\t\n\t\t\tvar pixelsSorted = pixelCoords.Where(p => Vector2.DistanceSquared(p, testCoord) <= maxDistanceSqr).OrderBy(p => Vector2.DistanceSquared(p, testCoord)).ToArray();\n\t\t\t\n\t\t\t//Console.WriteLine(pixelsSorted.Length);\n\t\t\tConsole.WriteLine(AsString(pixelsSorted));\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nfloat perlin(vec2 uv, inout uint rngState)\n{\n    uv += vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n    vec2 occ = vec2(0);\n\n    const float startScale = 1.0;\n    const float endScale = 0.005;\n    const int layerCount = 10;\n    float uvScale = pow(endScale / startScale, 1. / float(layerCount));\n    float alphaScale = 1. / uvScale;\n    uv *= startScale;\n    float a = 1.0 / startScale;\n    \n    for(int i = 0; i <layerCount; i++)\n    {\n        occ += vec2(texture(iChannel0, uv).r, 1) * a;\n        uv *= uvScale;\n        a *= alphaScale * 0.975;\n        uv += vec2(RandomFloat01(rngState), RandomFloat01(rngState));\n    }\n    float v = occ.x / occ.y;\n    \n    return v;\n       \n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    \n    vec2 uvTile = uv * 2.0;\n    \n    if(uvTile.x > 1.0)\n        uvTile.x = 2.0-uvTile.x;\n    if(uvTile.y > 1.0)\n        uvTile.y = 2.0-uvTile.y;\n        \n    \n    uvTile = smoothstep(0., 1., uvTile);\n        \n    uint rngState = 3114u;\n    \n    vec2 uv00 = uv + vec2(0.5, 0.5);\n    uv00 -= floor(uv00);\n    vec2 uv01 = uv + vec2(0.0, 0.5);\n    uv01 -= floor(uv01);\n    vec2 uv10 = uv + vec2(0.5, 0.0);\n    uv10 -= floor(uv10);\n    vec2 uv11 = uv + vec2(0.0, 0.0);\n    uv11 -= floor(uv11);\n    \n    float height00 = perlin(uv00, rngState);\n    float height01 = perlin(uv01, rngState);\n    float height10 = perlin(uv10, rngState);\n    float height11 = perlin(uv11, rngState);\n    \n     //height00 = 0.;\n     //height01 = 0.;\n     //height10 = 0.;\n     //height11 = 0.;\n    \n    float height0X = mix(height00, height01, uvTile.x);\n    float height1X = mix(height10, height11, uvTile.x);\n    float v = mix(height0X, height1X, uvTile.y);\n    \n    //v = height01;\n    /*float height1 = perlin(uv, rngState);\n    \n    vec2 offsetUv = uv;\n    offsetUv += vec2(0.5, 0.5);\n    offsetUv -= floor(offsetUv);\n    \n    float height2 = perlin(offsetUv, rngState);\n    \n    vec2 weightXY = abs(uv - vec2(0.5)) * 2.0;\n    float weight2 = weightXY.x * weightXY.y  + 0.001;\n    float weight1 = (1.0-weightXY.x) * (1.0-weightXY.y) + 0.001;\n    \n    float weight = weight2 / (weight1 + weight2);\n    weight = smoothstep(0., 1., weight);\n    \n    float v = mix(height1, height2, weight);*/\n        \n\n    \n    // Increase contrast\n    // (though this will flatten the tops and bottoms).\n    v = v * 2.0 - 1.0;\n    v = min(1.0, max(-1.0, v * 2.25));\n    //v = tanh(v * 2.0);\n    v = v * 0.5 + 0.5;\n    \n    // Make peaks pointer and valleys flatter.\n    v *= v;\n    \n    v = 1. - v;\n    \n    \n    fragColor = vec4(v, v, v, 1.0); \n    \n    vec3 noise = getNoise(iFrame);\n    fragColor.x = v > noise.z ? 1. : 0.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "// HOLY ---- I DID IT\n// Broad crawl outward, then a recursive mipmap quadtree search.\n// FAST runtime, FAST compilation (comparitavely).\n// Should compile in about 7.2 seconds, 144+ FPS @ 900x506\n\n// Controls =================================\n// Frag + Click: Change the distance checked position.\n\n// Colors ===================================\n// Black Cell:       Cell fully empty.\n// Blue Cell:        Cell partially occupied (contains an edge).\n// Light Blue Cell:  Cell fully occupied.\n// Red-Tinted Cells: Cells checked for occupancy.\n// Circle:           (Color) Gradient (Radius) Final distance.\n\nconst int mipCount = 8;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\nconst int SampleCoordCount = 64*8;\nconst ivec2 SampleCoords[64*8] = ivec2[64*8]\n(\n    ivec2( 0, -1), ivec2(-1,  0), ivec2(-1, -1), ivec2(+1,  0), \n    ivec2( 0, +1), ivec2(+1, -1), ivec2(-1, +1), ivec2(+1, +1), \n    ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+1, -2), ivec2(+2,  0), ivec2(-2, +1), ivec2( 0, +2), \n    ivec2(+2, -1), ivec2(-1, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(-2, -2), ivec2( 0, -3), ivec2(+2, -2), ivec2(-3,  0), \n    ivec2(-1, -3), ivec2(-2, +2), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+2, +2), ivec2(-3, +1), ivec2(+3,  0), ivec2(+3, -1), \n    ivec2( 0, +3), ivec2(-2, -3), ivec2(-3, -2), ivec2(-1, +3), \n    ivec2(+3, +1), ivec2(+1, +3), ivec2(+2, -3), ivec2(+3, -2), \n    ivec2(-3, +2), ivec2(-2, +3), ivec2( 0, -4), ivec2(-1, -4), \n    ivec2(+3, +2), ivec2(-4,  0), ivec2(+2, +3), ivec2(+1, -4), \n    ivec2(-4, -1), ivec2(-3, -3), ivec2(-4, +1), ivec2(+4,  0), \n    ivec2(+3, -3), ivec2(-2, -4), ivec2(+4, -1), ivec2(-4, -2), \n    ivec2( 0, +4), ivec2(+2, -4), ivec2(+4, +1), ivec2(-3, +3), \n    ivec2(-1, +4), ivec2(+1, +4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2( 0, -1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, -1), \n    ivec2( 0, +1), ivec2(-1, -1), ivec2(+1, +1), ivec2(-1, +1), \n    ivec2( 0, -2), ivec2(+2,  0), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-1, -2), ivec2(-2,  0), ivec2(-2, -1), ivec2( 0, +2), \n    ivec2(+2, +1), ivec2(+1, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(+2, -2), ivec2(-2, -2), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(+3,  0), ivec2(+2, +2), ivec2(-1, -3), ivec2(+3, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(+3, +1), ivec2(-3, -1), \n    ivec2( 0, +3), ivec2(+2, -3), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+3, -2), ivec2(-1, +3), ivec2(-2, -3), ivec2(-3, -2), \n    ivec2(+3, +2), ivec2( 0, -4), ivec2(+2, +3), ivec2(-3, +2), \n    ivec2(+1, -4), ivec2(-2, +3), ivec2(+4,  0), ivec2(-1, -4), \n    ivec2(+4, -1), ivec2(+3, -3), ivec2(+4, +1), ivec2(-4,  0), \n    ivec2(-3, -3), ivec2(-4, -1), ivec2(+2, -4), ivec2( 0, +4), \n    ivec2(+4, -2), ivec2(-4, +1), ivec2(-2, -4), ivec2(+1, +4), \n    ivec2(+3, +3), ivec2(-1, +4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(-1,  0), ivec2(-1, +1), ivec2(+1,  0), \n    ivec2( 0, -1), ivec2(+1, +1), ivec2(-1, -1), ivec2(+1, -1), \n    ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+1, +2), ivec2(+2,  0), ivec2(-2, -1), ivec2( 0, -2), \n    ivec2(+2, +1), ivec2(-1, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(-2, +2), ivec2( 0, +3), ivec2(+2, +2), ivec2(-3,  0), \n    ivec2(-1, +3), ivec2(-2, -2), ivec2(-3, +1), ivec2(+1, +3), \n    ivec2(+2, -2), ivec2(-3, -1), ivec2(+3,  0), ivec2(+3, +1), \n    ivec2( 0, -3), ivec2(-2, +3), ivec2(-3, +2), ivec2(-1, -3), \n    ivec2(+3, -1), ivec2(+1, -3), ivec2(+2, +3), ivec2(+3, +2), \n    ivec2(-3, -2), ivec2(-2, -3), ivec2( 0, +4), ivec2(-1, +4), \n    ivec2(+3, -2), ivec2(-4,  0), ivec2(+2, -3), ivec2(+1, +4), \n    ivec2(-4, +1), ivec2(-3, +3), ivec2(-4, -1), ivec2(+4,  0), \n    ivec2(+3, +3), ivec2(-2, +4), ivec2(+4, +1), ivec2(-4, +2), \n    ivec2( 0, -4), ivec2(+2, +4), ivec2(+4, -1), ivec2(-3, -3), \n    ivec2(-1, -4), ivec2(+1, -4), ivec2(-4, -2), ivec2(+4, +2),\n\n    ivec2( 0, +1), ivec2(+1,  0), ivec2(-1,  0), ivec2(+1, +1), \n    ivec2( 0, -1), ivec2(-1, +1), ivec2(+1, -1), ivec2(-1, -1), \n    ivec2( 0, +2), ivec2(+2,  0), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-1, +2), ivec2(-2,  0), ivec2(-2, +1), ivec2( 0, -2), \n    ivec2(+2, -1), ivec2(+1, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(+2, +2), ivec2(-2, +2), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(+3,  0), ivec2(+2, -2), ivec2(-1, +3), ivec2(+3, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(+3, -1), ivec2(-3, +1), \n    ivec2( 0, -3), ivec2(+2, +3), ivec2(-3, -1), ivec2(+1, -3), \n    ivec2(+3, +2), ivec2(-1, -3), ivec2(-2, +3), ivec2(-3, +2), \n    ivec2(+3, -2), ivec2( 0, +4), ivec2(+2, -3), ivec2(-3, -2), \n    ivec2(+1, +4), ivec2(-2, -3), ivec2(+4,  0), ivec2(-1, +4), \n    ivec2(+4, +1), ivec2(+3, +3), ivec2(+4, -1), ivec2(-4,  0), \n    ivec2(-3, +3), ivec2(-4, +1), ivec2(+2, +4), ivec2( 0, -4), \n    ivec2(+4, +2), ivec2(-4, -1), ivec2(-2, +4), ivec2(+1, -4), \n    ivec2(+3, -3), ivec2(-1, -4), ivec2(-4, +2), ivec2(+4, -2),\n\n    ivec2(-1,  0), ivec2( 0, -1), ivec2(-1, -1), ivec2( 0, +1), \n    ivec2(+1,  0), ivec2(-1, +1), ivec2(+1, -1), ivec2(+1, +1), \n    ivec2(-2,  0), ivec2( 0, -2), ivec2(-2, -1), ivec2(-1, -2), \n    ivec2(-2, +1), ivec2( 0, +2), ivec2(-1, +2), ivec2(+1, -2), \n    ivec2(+2,  0), ivec2(+2, -1), ivec2(+1, +2), ivec2(+2, +1), \n    ivec2(-2, -2), ivec2(-3,  0), ivec2(-2, +2), ivec2(-3, -1), \n    ivec2( 0, -3), ivec2(+2, -2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +2), ivec2( 0, +3), ivec2(+1, -3), ivec2(-1, +3), \n    ivec2(+3,  0), ivec2(-3, -2), ivec2(-2, -3), ivec2(+1, +3), \n    ivec2(+3, -1), ivec2(+3, +1), ivec2(-3, +2), ivec2(-2, +3), \n    ivec2(+2, -3), ivec2(-4,  0), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(+2, +3), ivec2( 0, -4), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(-1, -4), ivec2(-3, -3), ivec2(+1, -4), ivec2( 0, +4), \n    ivec2(-3, +3), ivec2(-4, -2), ivec2(-1, +4), ivec2(-2, -4), \n    ivec2(+4,  0), ivec2(-4, +2), ivec2(+1, +4), ivec2(+3, -3), \n    ivec2(+4, -1), ivec2(+4, +1), ivec2(-2, +4), ivec2(+2, -4),\n\n    ivec2(+1,  0), ivec2( 0, -1), ivec2( 0, +1), ivec2(+1, -1), \n    ivec2(-1,  0), ivec2(+1, +1), ivec2(-1, -1), ivec2(-1, +1), \n    ivec2(+2,  0), ivec2( 0, -2), ivec2(+2, -1), ivec2(+1, -2), \n    ivec2(+2, +1), ivec2( 0, +2), ivec2(-2,  0), ivec2(-1, -2), \n    ivec2(+1, +2), ivec2(-2, -1), ivec2(-1, +2), ivec2(-2, +1), \n    ivec2(+2, -2), ivec2(+2, +2), ivec2(+3,  0), ivec2( 0, -3), \n    ivec2(+3, -1), ivec2(-2, -2), ivec2(+1, -3), ivec2(+3, +1), \n    ivec2(-2, +2), ivec2(-1, -3), ivec2( 0, +3), ivec2(+1, +3), \n    ivec2(-3,  0), ivec2(+3, -2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -3), ivec2(-3, +1), ivec2(+3, +2), ivec2(+2, +3), \n    ivec2(-2, -3), ivec2(-3, -2), ivec2(+4,  0), ivec2(-2, +3), \n    ivec2(+4, -1), ivec2(-3, +2), ivec2( 0, -4), ivec2(+4, +1), \n    ivec2(+1, -4), ivec2(+3, -3), ivec2(-1, -4), ivec2( 0, +4), \n    ivec2(+3, +3), ivec2(+1, +4), ivec2(+4, -2), ivec2(-4,  0), \n    ivec2(+2, -4), ivec2(-1, +4), ivec2(+4, +2), ivec2(-4, -1), \n    ivec2(-3, -3), ivec2(-4, +1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(-1,  0), ivec2( 0, +1), ivec2(-1, +1), ivec2( 0, -1), \n    ivec2(+1,  0), ivec2(-1, -1), ivec2(+1, +1), ivec2(+1, -1), \n    ivec2(-2,  0), ivec2( 0, +2), ivec2(-2, +1), ivec2(-1, +2), \n    ivec2(-2, -1), ivec2( 0, -2), ivec2(-1, -2), ivec2(+1, +2), \n    ivec2(+2,  0), ivec2(+2, +1), ivec2(+1, -2), ivec2(+2, -1), \n    ivec2(-2, +2), ivec2(-3,  0), ivec2(-2, -2), ivec2(-3, +1), \n    ivec2( 0, +3), ivec2(+2, +2), ivec2(-3, -1), ivec2(-1, +3), \n    ivec2(+2, -2), ivec2( 0, -3), ivec2(+1, +3), ivec2(-1, -3), \n    ivec2(+3,  0), ivec2(-3, +2), ivec2(-2, +3), ivec2(+1, -3), \n    ivec2(+3, +1), ivec2(+3, -1), ivec2(-3, -2), ivec2(-2, -3), \n    ivec2(+2, +3), ivec2(-4,  0), ivec2(+3, +2), ivec2(-4, +1), \n    ivec2(+2, -3), ivec2( 0, +4), ivec2(+3, -2), ivec2(-4, -1), \n    ivec2(-1, +4), ivec2(-3, +3), ivec2(+1, +4), ivec2( 0, -4), \n    ivec2(-3, -3), ivec2(-4, +2), ivec2(-1, -4), ivec2(-2, +4), \n    ivec2(+4,  0), ivec2(-4, -2), ivec2(+1, -4), ivec2(+3, +3), \n    ivec2(+4, +1), ivec2(+4, -1), ivec2(-2, -4), ivec2(+2, +4),\n\n    ivec2(+1,  0), ivec2( 0, +1), ivec2( 0, -1), ivec2(+1, +1), \n    ivec2(-1,  0), ivec2(+1, -1), ivec2(-1, +1), ivec2(-1, -1), \n    ivec2(+2,  0), ivec2( 0, +2), ivec2(+2, +1), ivec2(+1, +2), \n    ivec2(+2, -1), ivec2( 0, -2), ivec2(-2,  0), ivec2(-1, +2), \n    ivec2(+1, -2), ivec2(-2, +1), ivec2(-1, -2), ivec2(-2, -1), \n    ivec2(+2, +2), ivec2(+2, -2), ivec2(+3,  0), ivec2( 0, +3), \n    ivec2(+3, +1), ivec2(-2, +2), ivec2(+1, +3), ivec2(+3, -1), \n    ivec2(-2, -2), ivec2(-1, +3), ivec2( 0, -3), ivec2(+1, -3), \n    ivec2(-3,  0), ivec2(+3, +2), ivec2(-3, +1), ivec2(-1, -3), \n    ivec2(+2, +3), ivec2(-3, -1), ivec2(+3, -2), ivec2(+2, -3), \n    ivec2(-2, +3), ivec2(-3, +2), ivec2(+4,  0), ivec2(-2, -3), \n    ivec2(+4, +1), ivec2(-3, -2), ivec2( 0, +4), ivec2(+4, -1), \n    ivec2(+1, +4), ivec2(+3, +3), ivec2(-1, +4), ivec2( 0, -4), \n    ivec2(+3, -3), ivec2(+1, -4), ivec2(+4, +2), ivec2(-4,  0), \n    ivec2(+2, +4), ivec2(-1, -4), ivec2(+4, -2), ivec2(-4, +1), \n    ivec2(-3, +3), ivec2(-4, -1), ivec2(-2, +4), ivec2(+2, -4)\n);\n\nconst ivec2 SubsampleCoords[4*8] = ivec2[4*8] \n(\n    ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n    ivec2(1, 0), ivec2(1, 1), ivec2(0, 0), ivec2(0, 1),\n    ivec2(0, 1), ivec2(0, 0), ivec2(1, 1), ivec2(1, 0),\n    ivec2(1, 1), ivec2(1, 0), ivec2(0, 1), ivec2(0, 0),\n    ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1),\n    ivec2(1, 0), ivec2(0, 0), ivec2(1, 1), ivec2(0, 1),\n    ivec2(0, 1), ivec2(1, 1), ivec2(0, 0), ivec2(1, 0),\n    ivec2(1, 1), ivec2(0, 1), ivec2(1, 0), ivec2(0, 0)\n);\n\nint GetSampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*64) : 0;\n    index |= testToSample.y < 0. ? (2*64) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*64) : 0;\n    return index;\n}\n\nint GetSubsampleIndexOffset(vec2 testToSample)\n{\n    int index;\n    index  = testToSample.x < 0. ? (1*4) : 0;\n    index |= testToSample.y < 0. ? (2*4) : 0;\n    index |= abs(testToSample.x) > abs(testToSample.y) ? (4*4) : 0;\n    return index;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nvec3 get_diff_minDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 pointToCenter = squareCenter - point;\n    vec2 minOffset = clamp(pointToCenter, vec2(-0.5), vec2(0.5));\n    vec2 pointToMin = pointToCenter - minOffset;\n    return vec3(pointToMin, lengthSqr(pointToMin));\n}\n\nstruct SubSampleArgs\n{\n    ivec3 smpCrd_mip;\n    vec3 diff_distSqr;\n    vec2 testCoord;\n};\n\n#define MIP smpCrd_mip.z\n#define SAMPLECOORD smpCrd_mip.xy\n#define TESTCOORD testCoord\n#define DIFFDISTSQR diff_distSqr\n\nvoid IncreaseDepth(inout SubSampleArgs a)\n{\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);      \n}\n\nSubSampleArgs GetNextArgs(in SubSampleArgs a, ivec2 coord)\n{\n    a.SAMPLECOORD = coord;\n    a.diff_distSqr *= vec3(2.0,2.0,4.0);\n    a.testCoord *= vec2(2.0,2.0);\n    a.smpCrd_mip += ivec3(a.smpCrd_mip.xy, -1);    \n    return a;\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) vec3 name\n#define SSA00 (\n#define SSA01     SubSampleArgs a,\n#define SSA02     in bool    testOccupied\n#define SSA03 )\n#define SSA04 {    \n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA05     int iSubOffset = GetSubsampleIndexOffset(vec2(a.SAMPLECOORD + ivec2(1)) - a.TESTCOORD);   \n    \n                 // Go through subsamples from closest to furthest.\n#define SSA06    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA07    {\n#define SSA08        ivec2 subsamplingCoord = a.SAMPLECOORD + SubsampleCoords[iSub + iSubOffset];\n#define SSA09        vec3 subsampleDiffDistSqr = get_diff_minDistSqr(a.TESTCOORD, subsamplingCoord);\n        \n#define SSA10        if(!(subsampleDiffDistSqr.z < a.DIFFDISTSQR.z))\n#define SSA11            continue;\n    \n#define SSA12        if(!containsEdge(testOccupied, subsamplingCoord, a.MIP))\n#define SSA13            continue;\n\n                     // Recursive   \n#define SSR(name)    subsampleDiffDistSqr = name                     \n#define SSB00        (\n#define SSB01            GetNextArgs(a, subsamplingCoord),\n#define SSB02            testOccupied\n#define SSB03        );\n\n#define SSC00        if(a.DIFFDISTSQR.z > subsampleDiffDistSqr.z) a.DIFFDISTSQR = subsampleDiffDistSqr;\n#define SSC01     }\n    \n#define SSC02     return a.DIFFDISTSQR * vec3(0.5, 0.5, 0.25);\n#define SSC03 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 \n\n#define SSB_0 SSB00 SSB01 SSB02 SSB03\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSB_0\n#define SS_END              SSC_0\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 7\nSS_DECLARE_TERMINATING(SubSample7)\nSS_DECLARE_RECURSIVE(SubSample6, SubSample7)\nSS_DECLARE_RECURSIVE(SubSample5, SubSample6)\nSS_DECLARE_RECURSIVE(SubSample4, SubSample5)\nSS_DECLARE_RECURSIVE(SubSample3, SubSample4)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 noise = getNoise(iFrame);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    // Set up fragment coordinates.\n    vec2 fragUV = fragCoord / iChannelResolution[0].xy;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize) \n                       + noise.xy * (1.0 / float(1 << RECURSION_DEPTH));\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    bool fragIsOccupied = isOccupied(fragUV); \n    \n    const float maxDist = 2.0;\n    vec3 diff_distSqr = vec3(maxDist, 0.0, maxDist*maxDist);\n\n    int iCoordOffset = GetSampleIndexOffset((vec2(fragTestIntCoord) + vec2(0.5) - fragTestCoord));\n    for(int iCoord = -1; iCoord < 64; iCoord++)\n    {\n        ivec2 samplingCoord = fragTestIntCoord;\n        if(iCoord >= 0)\n        {\n            samplingCoord += SampleCoords[iCoord + iCoordOffset];\n        }\n        \n        vec3 sampleDiffDistSqr = get_diff_minDistSqr(fragTestCoord, samplingCoord);\n        \n        // Need to add a bias for some reason.\n        if(sampleDiffDistSqr.z >= diff_distSqr.z + 1.5)\n            break;\n            \n        if(sampleDiffDistSqr.z >= diff_distSqr.z)\n            continue; \n            \n        if(!containsEdge(fragIsOccupied, samplingCoord, maxMip))\n            continue;\n            \n        SubSampleArgs a;\n        a.DIFFDISTSQR = diff_distSqr;\n        a.SAMPLECOORD = samplingCoord;\n        a.MIP = maxMip;\n        a.TESTCOORD = fragTestCoord;\n        IncreaseDepth(a);\n        diff_distSqr = SubSample\n        (\n            a,\n            fragIsOccupied\n        ); \n    }\n         \n    vec3 diff_dist = vec3(diff_distSqr.xy, sqrt(diff_distSqr.z)) / (fragIsOccupied ? -maxDist : maxDist);     \n         \n    diff_dist.xy = normalize(diff_dist.xy);\n    \n    diff_dist.z = diff_dist.z * 0.5 + 0.5;\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    //diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    //diff_dist.z = smoothstep(0., 1., diff_dist.z);\n    \n         \n    fragColor = vec4(diff_dist, 1.0);\n    if(isnan(fragColor.z + fragColor.a)) fragColor = vec4(0);\n    if(isinf(fragColor.z + fragColor.a)) fragColor = vec4(0);\n    \n    // Check if the image size increased:\n    bool increased;\n    {\n        increased = texture(iChannel1, vec2(1)).a <= 0.0;\n    }\n    \n    // Accumulate samples over time.\n    if(iFrame > 1 && !increased)\n    {\n        vec2 uv = (fragCoord.xy) / iChannelResolution[1].xy;\n        vec4 oldColor = texture(iChannel1, uv);\n        fragColor += oldColor;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bounds worldBounds() \n{\n    bounds b;\n    b.mini = vec3\n    (\n        0,\n        0,\n        0\n    );\n    \n    b.maxi = vec3\n    (\n        iChannelResolution[0].x,\n        600,\n        iChannelResolution[0].y\n    );\n    return b;\n}\n\nvec3 boundsToWorld(vec3 boundsPoint)\n{\n    bounds b = worldBounds();\n    return mix\n    (\n        b.mini,\n        b.maxi,\n        boundsPoint\n    );\n}\n\nvec3 worldToBounds(vec3 worldPoint)\n{\n    bounds b = worldBounds();\n    return invMix\n    (\n        b.mini,\n        b.maxi,\n        worldPoint\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvC = fragCoord.xy / iResolution.xy;\n\tvec2 uvR = (fragCoord.xy + vec2(1.25,0)) / iResolution.xy;\n\tvec2 uvT = (fragCoord.xy + vec2(0,1.25)) / iResolution.xy;\n\tvec2 uvL = (fragCoord.xy - vec2(1.25,0)) / iResolution.xy;\n\tvec2 uvB = (fragCoord.xy - vec2(0,1.25)) / iResolution.xy;\n    vec2 colC = texture(iChannel0, uvC).ba;\n    vec2 colR = texture(iChannel0, uvR).ba;\n    vec2 colT = texture(iChannel0, uvT).ba;\n    vec2 colL = texture(iChannel0, uvL).ba;\n    vec2 colB = texture(iChannel0, uvB).ba;\n    \n    colC.r *= 1. / colC.g;\n    colR.r *= 1. / colR.g;\n    colT.r *= 1. / colT.g;\n    colL.r *= 1. / colR.g;\n    colB.r *= 1. / colT.g;\n    \n\n    vec3 posC = vec3(uvC.x, colC.r, uvC.y);\n    vec3 posR = vec3(uvR.x, colR.r, uvR.y);\n    vec3 posL = vec3(uvL.x, colL.r, uvL.y);\n    vec3 posT = vec3(uvT.x, colT.r, uvT.y);\n    vec3 posB = vec3(uvT.x, colB.r, uvB.y);\n    \n    posC = boundsToWorld(posC);\n    posR = boundsToWorld(posR);\n    posL = boundsToWorld(posL);\n    posT = boundsToWorld(posT);\n    posB = boundsToWorld(posB);\n\n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    vec3 n = -normalize(cross(dx, dy));\n    \n    float curveX = dot(posC + posC - posR - posL, n);\n    float curveY = dot(posC + posC - posT - posB, n);\n    \n    vec2 c = vec2(curveX, curveY) / vec2(distance(posR, posL), distance(posT, posB));\n    \n    fragColor = vec4(n.xz, c);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}