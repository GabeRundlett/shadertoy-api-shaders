{
    "Shader": {
        "info": {
            "date": "1637622020",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "ftK3W1",
            "likes": 6,
            "name": "spqr: portal",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "Fahrenheitrequited",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n//float gid;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat getId(float t) {\n   return fract(sin(t * 478.129) * 992.421);\n}\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash21 (vec2 uv) {\n  return (fract(sin(uv.x * 1913.7361) + uv.y) * 4440.321);\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv,float id) {\n\n\n  float dom = 20.;\n\n  uv = mod(uv,dom) - dom/2.;  \n\n \n  vec2 uv2 = uv;\n  float q = 1.4 ;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n\n    uv *= rot(a/2.);\n    \n    float a1 = m1(uv  + off );\n\n    z = min(z,a1) ;\n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  //glow += .01/(.02 + pow(u,4.5));\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.);\n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat pi = 3.141592;\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nconst float domain_width = 290.;\nconst float domain_height = 27.;//77.;\nvec3 domain = vec3(domain_width,domain_height,domain_width) ;\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\nfloat decal(vec3 p, vec3 domain) {\n\n// ink\n  // return m2(uv);\n  //vec2 q = kifs(p + pow(kifs(p),vec2(1. + sin(iTime))*.5+.5) );\n  \n  \n  vec3 id = floor(p/domain);\n  float f1 = fract(hash31(id) + tick(iTime * .13 ));\n  \n  p = mod(p,domain) - domain/2.;\n  //float one =  k1(kifs(p * f1 + kifs(p * f1)), f1);\n  //float one =  k1(kifs(p + kifs(p) + kifs(kifs(p))), f1);\n  //float one = k1(kifs(p + kifs(p)),f1);\n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(300.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 0;\n\n\nfloat map(vec3 p) {\n\n // geo\n \n\n  \n  \n  float pi = 3.141592;\n  \n  vec3 q = p;\n  q = rep(q, vec3(0,0,57));\n\n\n  p = vec3(atan(p.x,p.y), length(p.xy) - 1., p.z);\n  \n   \n  p.y = abs(p.y) - 2.;\n  p.y = abs(p.y) -2.;\n\n\n\n \n  float tunnel = box(p, vec3(domain_width,1.,domain_width));\n \n \n  vec3 pulse = vec3(iTime * 10.,0,0);\n  float beam = cylcap(q.yxz + vec3(0,0,430. * sin(iTime * 1.3)), 1.,1.);\n  glow += 0.6/(0.1 + beam);\n \n \n  float hit = min(beam,tunnel);\n  \n  if (tunnel == hit) {\n      matter = 1;\n  \n  }\n  if (beam == hit) {\n      matter = 2;\n  }\n\n\n  return hit;\n \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\nvec3 probepos;\nvec3 probe (vec3 r, vec2 uv, float dd) {\n // volume\n  \n  float rand=rnd(uv);\n  \n  \n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>dd) {\n      break;\n    }\n    \n    vec3 lv = probepos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    vec3 target = vec3(0);\n   \n    \n    float shadvol = shadow(lp, lv, ldistvol, 10, 0.01);\n \n    \n    float u = dot( normalize(lp - probepos), normalize(probepos-target) ) ;\n    //if ( u > .99) {\n    //u = min(.5,u);\n    //if ( u > .99) {\n    atcol += 35./(0.01+(pow(ldistvol,1.5))) * shadvol * pow(u,10.);\n    //}\n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n \n  return atcol;\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float time = iTime;\n\n  // nav\n  \n   float tt = iTime * .15;\n  \n   vec3 s = lattice(tt) * 9.;\n  \n   vec3 t = lattice(tt+5.) * 7.;\n  \n   s.z += tt * 10.;\n   t.z += tt * 10.;\n\n   \n   probepos = s + vec3(0,0,100) * sin(iTime*7.);;\n\n\n \n  vec3 cz=normalize(t-s);\n\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n  r.xy *= rot(sin(tick(iTime))*.2);\n\n  vec3 p=s;\n  //float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  \n  bool hit = false;\n  float i ;\n  float z;\n  float res = 1.;\n  for( z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n      \n       i = decal(p * 100., domain); // resolution\n     \n      if (matter == 1) { \n          if (i > 4.5) {\n            d = .1;\n          } else {\n            hit = true;\n            break;\n          }\n      } else {\n           hit = true;\n            break;\n       \n      \n      }\n    }\n    if ( dd > 10000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n\n  vec3 col = vec3(1.);\n  \n  i = decal(p * 100., domain + .01 );\n  \n  if ( matter == 1) {\n      if ( i > 0.0 && i < 3.0) {\n          col = vec3(0);\n      }\n\n      if ( i > -12.0 && i < 0.0) {\n          col = vec3(.1,.1,.5)*.3;\n        \n      }\n  }\n  if ( matter == 2) {\n      col = vec3(1,1,0);\n  }\n    if ( matter == 3) {\n      col = vec3(1);\n  }\n \n //col += probe(r, uv, dd) * .9;\n col += glow * .6;\n col = mix(vec3(.5), col, 1. - z/260.);\n  \n \n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,2,2)))  * .5 + .5;\n    per = pow(per,2.);\n   \n    col =   mix(  vec3(.5), vec3 (.5) *.1, per);\n    \n  }\n  \n  fragColor = vec4(col, 1);\n\n}\n\n\n  \n\n\n/*\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n/*\n float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n  */",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}