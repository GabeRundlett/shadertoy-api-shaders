{
    "Shader": {
        "info": {
            "date": "1714573472",
            "description": "Spectral power distribution of visible light and associated LMS curves.\nI made this for demonstration purpose, so the focus was not on physical accuracy. But if you see errors or possible improvements, please feel free to make suggestions.",
            "flags": 0,
            "hasliked": 0,
            "id": "lctSDf",
            "likes": 24,
            "name": "Light spectrum",
            "published": 3,
            "tags": [
                "spectrum",
                "light",
                "rainbow",
                "lms",
                "wavelength",
                "spd"
            ],
            "usePreview": 0,
            "username": "jsulpis",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "//=======================================================================================//\n//\n// Light spectrum\n// by Julien Sulpis (https://twitter.com/jsulpis)                   \n// https://www.shadertoy.com/view/lctSDf\n//\n// inspired by:\n// P_Malin - Spectral Power Distribution (https://www.shadertoy.com/view/lsKczc)\n// Tynach - Color Blindness LMS Curves (https://www.shadertoy.com/view/MtcfDj)\n//\n//=======================================================================================//\n\n#define L_MIN 380.\n#define L_MAX 780.\n#define BEAM_LENGTH 2.\n#define BEAM_WIDTH .04\n#define PADDING_TOP .3\n#define PADDING_BOTTOM .55\n#define GRAPH_LINE_THICKNESS 1.5\n\n#define PI acos(-1.)\n\n//======================//\n//  Choose a mode here  //\n//======================//\n\n#define BLACKBODY 1\n#define NOISE 2\n#define MONOCHROMATIC 3\n\n#define MODE NOISE\n\n\n\nfloat getMonochromaticWavelength() {\n    float lmin = L_MIN + 10.;\n    float lmax = L_MAX - 60.;\n    return mix(lmin, lmax, (sin(iTime/2.) + 1.) / 2.);\n}\n\n// by @P_Malin (https://www.shadertoy.com/view/lsKczc)\nfloat FBM(float p, float ps) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = .2;\n    for( int i=0; i<5; i++) {\n        f += SmoothNoise(p + iTime) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n// by @P_Malin (https://www.shadertoy.com/view/lsKczc)\nfloat SPD_BlackBody(float w, float t) {\n    return BlackBody( w, t ) / BlackBody( 600.0, t );\n}\n\nfloat SPD_Noise(float w) {\n    float n = FBM((w) * 0.005, 0.5);\n    return pow(n, 3.) * 40.;\n}\n\nfloat SPD(float l_nm) {\n    #if MODE == BLACKBODY\n        float blackBodyTemperature = 2000. + 8000. * (sin(iTime) + 1.) / 2.;\n        return SPD_BlackBody(l_nm, blackBodyTemperature) / 10.;\n        \n    #elif MODE == NOISE\n        return SPD_Noise(l_nm) * smoothstep(L_MIN-50., L_MIN+100. , l_nm) * smoothstep(L_MAX+50., L_MAX-100., l_nm);\n    \n    #elif MODE == MONOCHROMATIC\n        return 1. - step(1., abs(l_nm - getMonochromaticWavelength()));\n    \n    #else \n        return 1.;\n    #endif\n}\n\nfloat getGraphShape(in float value, in vec2 uv, in bool filled) {\n   float v = value - uv.y;\n   float graph = smoothstep(0., 1., GRAPH_LINE_THICKNESS - abs(v)/fwidth(v)); // by @FabriceNeyret2 https://www.shadertoy.com/view/lXlGRB\n   \n   if (filled) {\n       graph += .3 * step(0., uv.y) * (1. - step(value, uv.y));\n   }\n\n   graph *= smoothstep(-.1, .15, uv.x) \n          * smoothstep(1.1, .5, uv.x);\n   return .9 * graph;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 spectrumUV = vec2(fragCoord.x / iResolution.x * 1.5 - .3, fragCoord.y / iResolution.y * 4. - PADDING_BOTTOM * 2.);\n    float w = mix(L_MIN, L_MAX, spectrumUV.x);\n    float fPower = SPD(w);     \n        \n    if (uv.y < -.1 && uv.y > -1. + PADDING_BOTTOM) {\n        #if MODE == MONOCHROMATIC\n            col = wl2xyz(w) * .5;\n        #else \n            col = wl2xyz(w) * fPower * 2.;\n        #endif\n        \n    } else if (uv.y > -.1 && abs(uv.x) < 1.) {\n        #if MODE == MONOCHROMATIC\n            vec3 beamColor =  wl2xyz(getMonochromaticWavelength());\n            float beamDist = sdBox(uv, vec2(BEAM_WIDTH/2., 100.));\n            beamDist = clamp(beamDist, 0., 1.);\n            float beamIntensity = pow(1. - beamDist, 150.) + .2 * pow(1. - beamDist, 40.);\n            beamIntensity *= smoothstep(-.5, .5, uv.y);\n            col = mix(col, beamColor, beamIntensity);\n        #else \n            // radial gradient, inspired by @izutionix: https://www.shadertoy.com/view/wtsyDl (l.31)\n            float t = (fragCoord.x/iResolution.x - .5)/(1. - fragCoord.y/iResolution.y - PADDING_TOP * .45) + .45;\n            float w = mix(L_MIN, L_MAX, t);\n            float fPower = SPD(w);\n            col = wl2xyz(w) * fPower * smoothstep(-.3, .5, uv.y);\n\n            // compute the resulting color\n            vec3 lightColor = vec3(0.);    \n            for(float wl = L_MIN; wl < L_MAX; wl += 5.0) {\n                vec3 vCurrXYZ = wl2xyz(wl);\n                float fPower = SPD(wl);\n                lightColor += vCurrXYZ * fPower;\n            }\n\n            // cleaning\n            col *= smoothstep(0., .1, 1. - abs(t - .5) ); \n            col *= step(PADDING_TOP, 1. - uv.y);\n            col = clamp(col, 0., 1.);\n\n            vec3 beamColor = lightColor / lightColor.y; // normalize lightness\n\n            vec2 p = rotateZ(-PI/5.) * (uv - vec2(.0, 1. - PADDING_TOP));\n            float beamDist = sdBox(p, vec2(BEAM_WIDTH/2., 100.));\n            beamDist = clamp(beamDist, 0., 1.);\n            float beamIntensity = pow(1. - beamDist, 150.) + .2 * pow(1. - beamDist, 40.);\n            beamIntensity *= smoothstep(-.7, .7, uv.x + uv.y);\n            beamIntensity *= 1. - 0.8 * step(1., 1. - p.y);\n            col += beamColor * beamIntensity;\n\n            float gratingDist = sdBox(p, vec2(.15, .001));\n            gratingDist = clamp(gratingDist, 0., 1.);\n            float gratingIntensity = smoothstep(.008, .0, gratingDist);\n            col += vec3(.5) * gratingIntensity;\n\n            float glareDist = sdCircle(p, BEAM_WIDTH/10.);\n            glareDist = clamp(glareDist, 0., 1.);\n            float glareIntensity = .8 * pow(1. - glareDist, 20.) + .05 * pow(1. - glareDist, 10.);\n            col += beamColor * glareIntensity;\n        #endif\n    }\n\n    #if MODE == MONOCHROMATIC\n        float wl = getMonochromaticWavelength();\n        vec3 lms = .2 * waveToLms(w, vec3(0.)) * waveToLms(wl, vec3(0.));\n        float spdGraph = smoothstep(wl - 1., wl, w) * smoothstep(wl+1., wl, w) * smoothstep(.8, .75, spectrumUV.y) * smoothstep(-.1, -.05, spectrumUV.y);\n    #else \n        vec3 lms = waveToLms(w, vec3(0.)) * fPower * 1.2;\n        vec2 spdUV = spectrumUV * vec2(1., .25);\n        float spdGraph = getGraphShape(fPower, spdUV, false);\n    #endif\n    \n    col = mix(col, vec3(1.), spdGraph);\n    \n    vec2 lmsGraphUV = (spectrumUV + vec2(0., .8)) * vec2(1., .3);\n    col = mix(col, vec3(1., .5, 0.), getGraphShape(lms.x, lmsGraphUV, true)); // long - red\n    col = mix(col, vec3(0.5, 1., 0.), getGraphShape(lms.y, lmsGraphUV, true)); // medium - green\n    col = mix(col, vec3(0.2, 0.3, 1.), getGraphShape(lms.z, lmsGraphUV, true)); // short - blue \n    \n    \n    col = col * XYZ2SRGB;\n    col = clamp(col, 0., 1.);\n\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n\n//=========================//\n//  Color transformations  //\n//=========================//\n\nfloat g(in float x, in float m, in float t1, in float t2) {\n    return exp(-0.5 * pow((x < m ? t1 : t2) * (x - m), 2.));\n}\n\n// https://en.wikipedia.org/wiki/CIE_1931_color_space#Analytical_approximation\nvec3 wl2xyz(in float w){\n    float x = 1.056 * g(w, 599.8, 0.0264, 0.0323) + 0.362 * g(w, 442.0, 0.0624, 0.0374) - 0.065 * g(w, 501.1, 0.049, 0.0382);\n    float y = 0.821 * g(w, 568.8, 0.0213, 0.0247) + 0.286 * g(w, 530.9, 0.0613, 0.0322);\n    float z = 1.217 * g(w, 437.0, 0.0845, 0.0278) + 0.681 * g(w, 459.0, 0.0385, 0.0725);\n    return vec3(x,y,z);\n}\n\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\nconst mat3 XYZ2SRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                           -0.9692660, 1.8760108, 0.0415560,\n                           0.0556434, -0.2040259, 1.0572252);\n\n// x = current wavelength\n// u = control point wavelength\n#define gauss(x, u, o, A) A/o*exp(-0.5*pow((x - u)/o, 2.0))\n    \n// by @Tynach (https://www.shadertoy.com/view/MtcfDj)\n// Converts from a wavelength to LMS.\n// Constructed using multi-peak Gaussian functions generated using Labplot\n// and closely fitted to the CIE 2006 2Â° cone fundamentals created by Stockman & Sharp 2000).\nvec3 waveToLms(float wave, vec3 amount) {\n\t// LMS Gaussian function parameters for each cone type\n\tconst vec3[5] lParams = vec3[](\n\t\tvec3(449.682, 21.6622, 2.36612),\n\t\tvec3(477.589, 11.0682, 1.39883),\n\t\tvec3(532.488, 25.7494, 34.0478),\n\t\tvec3(570.2, 5.91487, 0.243387),\n\t\tvec3(585.858, 34.98, 77.8669)\n\t);\n\n\tconst vec3[5] mParams = vec3[](\n\t\tvec3(450.237, 19.5222, 3.33537),\n\t\tvec3(479.559, 13.3211, 3.68813),\n\t\tvec3(519.924, 17.1502, 9.68484),\n\t\tvec3(542.8, 3.27696, 0.105766),\n\t\tvec3(552.158, 33.3895, 77.9298)\n\t);\n\n\tconst vec3[5] sParams = vec3[](\n\t\tvec3(467.661, 8.84562, 5.32073),\n\t\tvec3(422.211, 10.2028, 8.58498),\n\t\tvec3(443.084, 11.9848, 19.6347),\n\t\tvec3(444.863, 1.30608, -0.0330768),\n\t\tvec3(460.886, 25.7907, 24.9128)\n\t);\n\n\t// Return the LMS values for the given wavelength\n\treturn vec3(\n\t\t// L cone response curve\n\t\tgauss(wave, lParams[0].x, lParams[0].y, lParams[0].z) +\n\t\tgauss(wave, lParams[1].x, lParams[1].y, lParams[1].z) +\n\t\tgauss(wave, lParams[2].x, lParams[2].y, lParams[2].z) +\n\t\tgauss(wave, lParams[3].x, lParams[3].y, lParams[3].z) +\n\t\tgauss(wave, lParams[4].x, lParams[4].y, lParams[4].z),\n\n\t\t// M cone response curve\n\t\tgauss(wave, mParams[0].x, mParams[0].y, mParams[0].z) +\n\t\tgauss(wave, mParams[1].x, mParams[1].y, mParams[1].z) +\n\t\tgauss(wave, mParams[2].x, mParams[2].y, mParams[2].z) +\n\t\tgauss(wave, mParams[3].x, mParams[3].y, mParams[3].z) +\n\t\tgauss(wave, mParams[4].x, mParams[4].y, mParams[4].z),\n\n\t\t// S cone response curve\n\t\tgauss(wave, sParams[0].x, sParams[0].y, sParams[0].z) +\n\t\tgauss(wave, sParams[1].x, sParams[1].y, sParams[1].z) +\n\t\tgauss(wave, sParams[2].x, sParams[2].y, sParams[2].z) +\n\t\tgauss(wave, sParams[3].x, sParams[3].y, sParams[3].z) +\n\t\tgauss(wave, sParams[4].x, sParams[4].y, sParams[4].z)\n\t)/sqrt(2.0*PI);\n}\n\n// https://en.wikipedia.org/wiki/Planck%27s_law\nfloat BlackBody( float w_nm, float t ) {\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n    float w = w_nm / 1e9;\n    float w5 = w*w*w*w*w;\n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n    return o;\n}\n\n//==========//\n//  Noises  //\n//==========//\n\n// by @P_Malin (https://www.shadertoy.com/view/lsKczc)\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * .5);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// by @P_Malin (https://www.shadertoy.com/view/lsKczc)\nfloat SmoothNoise(float o) {\n\tfloat p = floor(o);\n\tfloat f = fract(o);\n\n\tfloat a = hash11(p);\n\tfloat b = hash11(p+1.0);\n\t\n\tfloat f2 = f * f;\n\tfloat f3 = f2 * f;\n\t\n\tfloat t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat res = a + (b-a)*t;\n    \n    return res;\n}\n\n//================//\n//  Ray marching  //\n//================//\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nmat2 rotateZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2(\n    vec2(c, -s),\n    vec2(s, c)\n  );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}