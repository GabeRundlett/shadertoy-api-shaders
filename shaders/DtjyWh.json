{
    "Shader": {
        "info": {
            "date": "1691869700",
            "description": "Demonstrating three different voronoi particle tracking search strategies.\n\nLeft: traditional\nCenter: randomized\nRight: jump flood\n\n*mouse x controls particle speed*\n*mouse y controls horizontal split*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "DtjyWh",
            "likes": 21,
            "name": "Voronoi Tracking Options",
            "published": 3,
            "tags": [
                "voronoi",
                "particles",
                "tracking",
                "jfa"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I've done a lot of shaders using voronoi-tracked particles, but I've never slowed\n//  down to do a proper study of the effect of different voronoi search strategies.\n//  Of course, the particular algorithm you might want for a particular shader depends\n//  on a lot of factors that are not demonstrated here, but hopefully this might still\n//  give you some ideas of some general principles.\n//\n//  What you see are three different methods of tracking particles via voronoi buffer.\n//\n//  Left: traditional\n//  Center: randomized\n//  Right: jump flood\n//\n//  The voronoi tracking is intentionally weakened by only letting it run once every\n//  8 frames. This simulates the effects of faster moving particles while letting us\n//  study the patterns. Set SKIP to 1 in Buffer B to see \"full power\" tracking. You\n//  would also probably want more than one \"kick start\" whole-screen random search\n//  iteration.\n//\n//  To control the shader, use the mouse. Mouse x sets the particle speed, and mouse y\n//  sets the horizontal split bar. Above the bar, particles are rendered using the \n//  tracking buffer. Below the bar, the ids of the closest particles are visualized.\n//\n//  There are interesting things to see both above and below the bar. Above the bar,\n//  observe where the particles fail to render. Below the bar, it's easier to see how\n//  the different algorithms percolate the information across space.\n//\n//  The \"traditional\" search on the left side is what you usually get in voronoi\n//  tracking example shaders, like these:\n//\n//      Gegell's [Gegell] Boids                   https://shadertoy.com/view/ms2SW3\n//      FabriceNeyret2's Crowdy Waves 2           https://shadertoy.com/view/3ty3Dy  \n//      michael0884's Voronoi edge tracking II    https://shadertoy.com/view/WsXcWH\n//\n//  This works fine for some shaders, but if you have a need for speed (you want \n//  faster moving particles) you may want to go further. Above the bar, you can see how\n//  the particles are flickering quite badly, and below the bar, you can see how slowly\n//  the information moves through the buffer.\n//\n//  The middle area shows what you get if instead of only looking at the four nearest\n//  neighbors, we look at four random cells in some larger area. We could easily search\n//  more than four for even more power, I just wanted a fair comparison against the\n//  traditional search so I only do four here. It's both a strength and weakness of\n//  this method that you can, and need to tune the number of searches and the distance\n//  they roam.\n//\n//  I had higher hopes for the jump flood method on the right. I guess the idea was\n//  the inspiration for this shader, since I recently implemented JFA for this:\n//\n//      SDF Writer w/ JFA                         https://shadertoy.com/view/DllcDs\n//\n//  But, looking at the results here, the random search seems to usually do better.\n//  I think JFA converges a little faster when the particles are moving very slowly;\n//  click the mouse over on the left and press space to see this. But, in the busy\n//  middle section where the particles pass each other, they flicker much worse, and\n//  at slower speeds. When the particles move faster, the multi-frame beat of the JFA\n//  becomes quite visible below the bar. I guess both problems could be solved with\n//  a pipelined JFA like the greatest of all JFA shaders:\n//\n//      Flyguy's Van Damme - Distance             https://shadertoy.com/view/Wl3fWX\n//\n//  But that's a lot more complicated than most voronoi particle shaders, using the\n//  cubemap buffer to somehow compute the whole JFA each frame. Magic!\n//\n//  Are there any other search strategies I haven't tried?\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float h = texelFetch(iChannel0, ivec2(iResolution.x - 1., iResolution.y - 1.), 0).y; // mouse y determines horizontal split point\n    vec2 p = (u - .5 * iResolution.xy) / iResolution.y;\n    ivec4 old = T(u);\n    float e = 3. / iResolution.y;\n    \n    if (p.y > h)\n    {\n        O = vec4(0);\n    \n        // render particles\n        for (int i = 0; i < 4; ++i)\n        {\n            int id = old[i];\n            if (id < 0) break;\n            vec4 v = getParticle(id);\n            float d = fxLinePointDist(v.xy, v.zw, p);\n            O.xyz += smoothstep(e + e, e, d) * vec3(1, 0, 0);\n            O.xyz += smoothstep(e, 0., abs(d - e - e));\n        }\n    }\n    else\n    {\n        // render voronoi below vertical split\n        O.rgb = sin(vec3(old.x) + vec3(0, 11, 33));\n    }\n    \n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(e, 0., abs(p.y - h)));    // horizontal bar\n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(e, 0., abs(p.x - VBAR))); // vertical bars\n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(e, 0., abs(p.x + VBAR)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tParticle \"sim\" and state management\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec3 s = texelFetch(iChannel0, ivec2(iResolution.x - 1., iResolution.y - 1.), 0).xyz; // state stored in last pixel\n    float t = s.z;\n    if (u == vec2(iResolution.x - .5, iResolution.y - .5))\n    {\n        // persistent state tracking\n        O.xyz = s;\n        if (iMouse.z > 0.)\n            O.xy = (iMouse.xy - .5 * iResolution.xy) / iResolution.xy; // xy holds mouse position\n        O.z = t + iTimeDelta * (s.x + .5) * .1; // z holds particle time\n        if (iFrame == 0) O.xyz = vec3(0); // init\n        return;\n    }\n    \n    O.zw = texelFetch(iChannel0, ivec2(u), 0).xy; // zw holds previous position\n    u = floor(u);\n    \n    float idx = u.x + u.y * iResolution.x; // which particle\n    if (int(idx) >= MAX_PARTICLES) return;\n    \n    // this is not really a simulation at all, just a stateless animation to give our tracker something to do\n    idx = idx * .06 + t;\n    O.x = (.7 * sin(idx) + .3 * sin(idx * 40.)) * .4 * iResolution.x / iResolution.y;\n    O.y = cos(idx * 10.) * .4;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer, implemented three ways\n// ---------------------------------------------------------------------------------------\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(int id, vec2 u)\n{\n    if (id < 0 || id >= MAX_PARTICLES) return 1e6;\n    vec4 v = getParticle(id);\n    \n    return min(length2(v.xy - u), length2(v.zw - u));\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(ivec4 old, vec2 p, inout ivec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        float dis2 = distance2Particle(id, p);\n        insertionSort( new, dis, id, dis2 );\n    }\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nint SKIP = 8; // how often to perform voronoi updates (set to 1 for \"full power\")\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n\tvec2 p = (u - .5 * iResolution.xy) / iResolution.y;\n    float v = VBAR; // location of vertical split screen\n\n    ivec4 new = ivec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n\n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        ivec4 old = T(u);\n        O = vec4(old);\n        \n        if (iFrame % SKIP != 0) return; // weaken the voronoi for demonstration purposes\n        \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        if (p.x > v)\n        {\n            // On the right hand side, we have a jump flood. Over the course of JUMP_STEPS steps,\n            // first we look for neighbors 2^(JUMP_STEPS - 1) away, then 2^(JUMP_STEPS - 2) away,\n            // down to 1 away on the last step. \n            \n            const int JUMP_STEPS = 4;\n            \n            for (int x = -1; x <= 1; ++x)\n            for (int y = -1; y <= 1; ++y)\n                sortNbs(T(u + exp2(float((iFrame / SKIP) % JUMP_STEPS)) * vec2(x, y)), p, new, dis);\n        }\n        else if (p.x > -v)\n        {\n            // In the middle we have a randomized search. I'm sure I'm not the first person to do\n            // this, but I don't know where I saw it, or I might have rediscovered it. Just search\n            // a few times at random nearby spots. The quality of the hash function is important.\n            \n            const int SEARCH_STEPS = 4;\n            const float SEARCH_RANGE = 50.;\n            \n            for(int i = 0; i < SEARCH_STEPS; ++i)\n            {\n                vec2 h = hash3(uvec3(u, iFrame * 4 + i)).xy - .5;\n\n                sortNbs(T(u + vec2(h * SEARCH_RANGE)), p, new, dis);\n            }\n        }\n        else\n        {\n            // On the left is \"traditional\" voronoi tracking, as many shadertoy examples seem to\n            // use. Just search the four nearest neighbors to see if they have any better options.\n            \n            sortNbs(T(u + vec2(0, 1)), p, new, dis);\n            sortNbs(T(u + vec2(0, -1)), p, new, dis);\n            sortNbs(T(u + vec2(1, 0)), p, new, dis);\n            sortNbs(T(u + vec2(-1, 0)), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        float h = hash3(uvec3(u, iFrame)).x;\n        int id = int(h*float(MAX_PARTICLES));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    O = vec4(new);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const int MAX_PARTICLES = 300;\n\n// get the info for one particle: position in xy, previous position in zw\n#define getParticle(X) getParticleImpl(iChannel0, int(iResolution.x), X)\nvec4 getParticleImpl(sampler2D smp, int wd, int id)\n{\n    return texelFetch(smp, ivec2(id % wd, id / wd), 0);\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\n\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n#define T(X) ivec4(texelFetch(iChannel1, ivec2(X), 0))\n#define VBAR iResolution.x / iResolution.y / 6.\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n\n#define KEY_SPACE 32",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}