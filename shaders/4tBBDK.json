{
    "Shader": {
        "info": {
            "date": "1517157583",
            "description": "The implementation of \"Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\"\nhttps://labs.unity.com/article/real-time-polygonal-light-shading-linearly-transformed-cosines",
            "flags": 32,
            "hasliked": 0,
            "id": "4tBBDK",
            "likes": 50,
            "name": "linearly transformed cosines",
            "published": 3,
            "tags": [
                "brdf",
                "arealight",
                "ltc",
                "polygonlight"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 1956
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float PI = 3.1415926;\n\nconst float roughness = 0.2;\nconst float intensity = 1.5;\nconst float light_width = 0.5;\nconst float light_height = 0.5;\n\nconst vec3 diff_col = vec3(1.);\nconst vec3 spec_col = vec3(1.);\n\nconst vec3 light_col = vec3(1.0)*intensity;\nconst vec3 light_pos = vec3(0., 0.3, 0.);\nconst vec3 light_normal = vec3(0., 0., 1.);\n\nconst float LUTSIZE  = 8.0;\nconst float MATRIX_PARAM_OFFSET = 8.0;\n\n\n\nfloat rect(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvoid init_rect_points(out vec3 points[4])\n{\n    // get the orthogonal basis of polygon light\n    vec3 right=normalize(cross(light_normal, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, light_normal));\n    \n    vec3 ex = light_width * right;\n    vec3 ey = light_height * up;\n\n    points[0] = light_pos - ex - ey;\n    points[1] = light_pos + ex - ey;\n    points[2] = light_pos + ex + ey;\n    points[3] = light_pos - ex + ey;\n}\n\n\n#define LIGHT 0.\n#define SCENE 1.\n\nfloat object_id = 0.;\n\nfloat sphere(vec3 p, float r)\n{\n   \treturn length(p)-r;\n}\n\nfloat map(vec3 p)\n{\n    float d0=rect(p-light_pos, vec3(light_width, light_height, 0.));\n    float d1=abs(p.y+0.5);\n    float d2=sphere(p-vec3(-0.4, -0.2, 1.2), 0.3);\n    \n   \tfloat d = d0;\n    object_id = LIGHT;\n    \n    if(d > d1)\n    {\n        d = d1;\n        object_id=SCENE;\n    }\n    \n    if(d > d2)\n    {\n        d = d2;\n        object_id=SCENE;\n    }\n    \n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.01;\n    for( int i=0; i<64; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c < 0.005 ) break;\n        t += c;\n        if( t>100.0 ) return -1.0;\n    }\n    return t;\n}\n\n\n// Linearly Transformed Cosines \n\nfloat IntegrateEdge(vec3 v1, vec3 v2)\n{\n    float cosTheta = dot(v1, v2);\n    float theta = acos(cosTheta);    \n    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);\n\n    return res;\n}\n\nvoid ClipQuadToHorizon(inout vec3 L[5], out int n)\n{\n    // detect clipping config\n    int config = 0;\n    if (L[0].z > 0.0) config += 1;\n    if (L[1].z > 0.0) config += 2;\n    if (L[2].z > 0.0) config += 4;\n    if (L[3].z > 0.0) config += 8;\n\n    // clip\n    n = 0;\n\n    if (config == 0)\n    {\n        // clip all\n    }\n    else if (config == 1) // V1 clip V2 V3 V4\n    {\n        n = 3;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 2) // V2 clip V1 V3 V4\n    {\n        n = 3;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 3) // V1 V2 clip V3 V4\n    {\n        n = 4;\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n        L[3] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 4) // V3 clip V1 V2 V4\n    {\n        n = 3;\n        L[0] = -L[3].z * L[2] + L[2].z * L[3];\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n    }\n    else if (config == 5) // V1 V3 clip V2 V4) impossible\n    {\n        n = 0;\n    }\n    else if (config == 6) // V2 V3 clip V1 V4\n    {\n        n = 4;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 7) // V1 V2 V3 clip V4\n    {\n        n = 5;\n        L[4] = -L[3].z * L[0] + L[0].z * L[3];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 8) // V4 clip V1 V2 V3\n    {\n        n = 3;\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n        L[1] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] =  L[3];\n    }\n    else if (config == 9) // V1 V4 clip V2 V3\n    {\n        n = 4;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[2].z * L[3] + L[3].z * L[2];\n    }\n    else if (config == 10) // V2 V4 clip V1 V3) impossible\n    {\n        n = 0;\n    }\n    else if (config == 11) // V1 V2 V4 clip V3\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 12) // V3 V4 clip V1 V2\n    {\n        n = 4;\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n    }\n    else if (config == 13) // V1 V3 V4 clip V2\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = L[2];\n        L[2] = -L[1].z * L[2] + L[2].z * L[1];\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n    }\n    else if (config == 14) // V2 V3 V4 clip V1\n    {\n        n = 5;\n        L[4] = -L[0].z * L[3] + L[3].z * L[0];\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n    }\n    else if (config == 15) // V1 V2 V3 V4\n    {\n        n = 4;\n    }\n    \n    if (n == 3)\n        L[3] = L[0];\n    if (n == 4)\n        L[4] = L[0];\n}\n\n\nvec3 LTC_Evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4])\n{\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize(V - N*dot(V, N));\n    T2 = cross(N, T1);\n\n    // rotate area light in (T1, T2, N) basis\n    Minv = Minv * transpose(mat3(T1, T2, N));\n\n    // polygon (allocate 5 vertices for clipping)\n    vec3 L[5];\n    L[0] = Minv * (points[0] - P);\n    L[1] = Minv * (points[1] - P);\n    L[2] = Minv * (points[2] - P);\n    L[3] = Minv * (points[3] - P);\n\n    int n=0;\n    // The integration is assumed on the upper hemisphere\n    // so we need to clip the frustum, the clipping will add \n    // at most 1 edge, that's why L is declared 5 elements.\n    ClipQuadToHorizon(L, n);\n    \n    if (n == 0)\n        return vec3(0, 0, 0);\n\n    // project onto sphere\n    L[0] = normalize(L[0]);\n    L[1] = normalize(L[1]);\n    L[2] = normalize(L[2]);\n    L[3] = normalize(L[3]);\n    L[4] = normalize(L[4]);\n\n    // integrate for every edge.\n    float sum = 0.0;\n\n    sum += IntegrateEdge(L[0], L[1]);\n    sum += IntegrateEdge(L[1], L[2]);\n    sum += IntegrateEdge(L[2], L[3]);\n    if (n >= 4)\n        sum += IntegrateEdge(L[3], L[4]);\n    if (n == 5)\n        sum += IntegrateEdge(L[4], L[0]);\n\n    sum =  max(0.0, sum);\n\n    vec3 Lo_i = vec3(sum, sum, sum);\n\n    return Lo_i;\n}\n\n/////////////////////////////////////////////\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.001;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        if(object_id==LIGHT)break;\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += h;\n    }\n    return clamp(res,0.1,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    vec3 lookat = vec3(0.0, -0.5*light_height, 0.);\n\tvec3 ro = vec3(1.8, light_height, 2.2);\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    \n    vec3 points[4];\n    \n    // setup the four vertices for the rect light\n    init_rect_points(points);\n\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    if(t>-0.5)\n    {\n        col = vec3(1.0);\n        \n     \tif(object_id == SCENE)\n        {            \n            vec3 pos = ro + rd * t;\n\n            vec3 N = get_normal(pos);\n            vec3 V = -rd;\n\n            float theta = acos(dot(N, V));\n            vec2 uv = vec2(roughness, theta/(0.5*PI)) * float(LUTSIZE-1.);        \n            \n            // The offset to get correct interpolation\n            uv+=vec2(0.5, 0.5);\n            \n            vec4 params = texture(iChannel0, (uv+vec2(MATRIX_PARAM_OFFSET, 0.0))/iChannelResolution[0].xy);\n           \n            // The inverse transformation matrix, so we \n            // can integrate cosine distribution over the polygon \n            // transformed by this matrix, instead of integrating the\n            // complicated brdf over the untransformed polygon.\n            mat3 Minv = mat3(\n                vec3(  1,        0,      params.y),\n                vec3(  0,     params.z,   0),\n                vec3(params.w,   0,      params.x)\n            );\n\n            vec3 spec = LTC_Evaluate(N, V, pos, Minv, points);\n\n            spec *= texture(iChannel0, uv/iChannelResolution[0].xy).x;\n\n            vec3 diff = LTC_Evaluate(N, V, pos, mat3(1), points); \n\n            // shadow is not area light based here.\n            float sha=softshadow( pos+0.01*N, normalize(light_pos-pos), 32.0 );\n\n            col  = light_col*(spec_col*spec + diff_col*diff)*sha;\n            col /= 2.0*PI;\n        }\n\n    }\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// The inverse of the transformation matrix M is precomputed and \n// stored in this buffer as a lookup table.\n// The matrix is used to transform cosine distribution to whatever \n// brdf we like.\n// Refer to:  https://labs.unity.com/article/real-time-polygonal-light-shading-linearly-transformed-cosines\n\nvoid store_buf(vec2 pos,vec4 val,vec2 fragCoord,inout vec4 fragColor)\n{\n    if(abs(fragCoord.x-pos.x)<0.01&&abs(fragCoord.y-pos.y)<0.01)\n        fragColor=val;\n}\n\n// The first 8x8 stores the normalization\n// The second 8x8 stores the matrix parameters\n\nvoid setLUT(vec2 fragCoord, inout vec4 fragColor)\n{\n    store_buf(vec2(0.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 0.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(2.5, 0.5), vec4(0.999138), fragCoord, fragColor);\n    store_buf(vec2(3.5, 0.5), vec4(0.953919), fragCoord, fragColor);\n    store_buf(vec2(4.5, 0.5), vec4(0.855017), fragCoord, fragColor);\n    store_buf(vec2(5.5, 0.5), vec4(0.677721), fragCoord, fragColor);\n    store_buf(vec2(6.5, 0.5), vec4(0.475624), fragCoord, fragColor);\n    store_buf(vec2(7.5, 0.5), vec4(0.306905), fragCoord, fragColor);\n    store_buf(vec2(0.5, 1.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 1.5), vec4(0.999990), fragCoord, fragColor);\n    store_buf(vec2(2.5, 1.5), vec4(0.995492), fragCoord, fragColor);\n    store_buf(vec2(3.5, 1.5), vec4(0.955938), fragCoord, fragColor);\n    store_buf(vec2(4.5, 1.5), vec4(0.852346), fragCoord, fragColor);\n    store_buf(vec2(5.5, 1.5), vec4(0.676815), fragCoord, fragColor);\n    store_buf(vec2(6.5, 1.5), vec4(0.478562), fragCoord, fragColor);\n    store_buf(vec2(7.5, 1.5), vec4(0.311751), fragCoord, fragColor);\n    store_buf(vec2(0.5, 2.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 2.5), vec4(0.999952), fragCoord, fragColor);\n    store_buf(vec2(2.5, 2.5), vec4(0.993337), fragCoord, fragColor);\n    store_buf(vec2(3.5, 2.5), vec4(0.950365), fragCoord, fragColor);\n    store_buf(vec2(4.5, 2.5), vec4(0.844905), fragCoord, fragColor);\n    store_buf(vec2(5.5, 2.5), vec4(0.674537), fragCoord, fragColor);\n    store_buf(vec2(6.5, 2.5), vec4(0.487632), fragCoord, fragColor);\n    store_buf(vec2(7.5, 2.5), vec4(0.327273), fragCoord, fragColor);\n    store_buf(vec2(0.5, 3.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 3.5), vec4(0.999865), fragCoord, fragColor);\n    store_buf(vec2(2.5, 3.5), vec4(0.991766), fragCoord, fragColor);\n    store_buf(vec2(3.5, 3.5), vec4(0.942684), fragCoord, fragColor);\n    store_buf(vec2(4.5, 3.5), vec4(0.831852), fragCoord, fragColor);\n    store_buf(vec2(5.5, 3.5), vec4(0.673589), fragCoord, fragColor);\n    store_buf(vec2(6.5, 3.5), vec4(0.505564), fragCoord, fragColor);\n    store_buf(vec2(7.5, 3.5), vec4(0.355949), fragCoord, fragColor);\n    store_buf(vec2(0.5, 4.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 4.5), vec4(0.999665), fragCoord, fragColor);\n    store_buf(vec2(2.5, 4.5), vec4(0.986371), fragCoord, fragColor);\n    store_buf(vec2(3.5, 4.5), vec4(0.930421), fragCoord, fragColor);\n    store_buf(vec2(4.5, 4.5), vec4(0.813602), fragCoord, fragColor);\n    store_buf(vec2(5.5, 4.5), vec4(0.678975), fragCoord, fragColor);\n    store_buf(vec2(6.5, 4.5), vec4(0.537882), fragCoord, fragColor);\n    store_buf(vec2(7.5, 4.5), vec4(0.403271), fragCoord, fragColor);\n    store_buf(vec2(0.5, 5.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 5.5), vec4(0.999025), fragCoord, fragColor);\n    store_buf(vec2(2.5, 5.5), vec4(0.973317), fragCoord, fragColor);\n    store_buf(vec2(3.5, 5.5), vec4(0.900245), fragCoord, fragColor);\n    store_buf(vec2(4.5, 5.5), vec4(0.804126), fragCoord, fragColor);\n    store_buf(vec2(5.5, 5.5), vec4(0.703751), fragCoord, fragColor);\n    store_buf(vec2(6.5, 5.5), vec4(0.594890), fragCoord, fragColor);\n    store_buf(vec2(7.5, 5.5), vec4(0.481143), fragCoord, fragColor);\n    store_buf(vec2(0.5, 6.5), vec4(1.000000), fragCoord, fragColor);\n    store_buf(vec2(1.5, 6.5), vec4(0.992850), fragCoord, fragColor);\n    store_buf(vec2(2.5, 6.5), vec4(0.926124), fragCoord, fragColor);\n    store_buf(vec2(3.5, 6.5), vec4(0.860745), fragCoord, fragColor);\n    store_buf(vec2(4.5, 6.5), vec4(0.833379), fragCoord, fragColor);\n    store_buf(vec2(5.5, 6.5), vec4(0.782873), fragCoord, fragColor);\n    store_buf(vec2(6.5, 6.5), vec4(0.703637), fragCoord, fragColor);\n    store_buf(vec2(7.5, 6.5), vec4(0.620129), fragCoord, fragColor);\n    store_buf(vec2(0.5, 7.5), vec4(0.987461), fragCoord, fragColor);\n    store_buf(vec2(1.5, 7.5), vec4(0.938899), fragCoord, fragColor);\n    store_buf(vec2(2.5, 7.5), vec4(0.942983), fragCoord, fragColor);\n    store_buf(vec2(3.5, 7.5), vec4(0.943682), fragCoord, fragColor);\n    store_buf(vec2(4.5, 7.5), vec4(0.943818), fragCoord, fragColor);\n    store_buf(vec2(5.5, 7.5), vec4(0.943681), fragCoord, fragColor);\n    store_buf(vec2(6.5, 7.5), vec4(0.943351), fragCoord, fragColor);\n    store_buf(vec2(7.5, 7.5), vec4(0.942877), fragCoord, fragColor);\n\n    float BIAS = 8.;\n    \n    store_buf(vec2(BIAS+0.5, 0.5), vec4(0.000200, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 0.5), vec4(0.040821, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 0.5), vec4(0.163499, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 0.5), vec4(0.359810, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 0.5), vec4(0.608219, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 0.5), vec4(0.849327, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 0.5), vec4(1.026876, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 0.5), vec4(1.127918, -0.000000, 1.000000, -0.000000), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 1.5), vec4(0.000200, -0.000046, 1.052217, 0.228243), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 1.5), vec4(0.040821, -0.009316, 1.052066, 0.228242), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 1.5), vec4(0.163218, -0.036566, 1.051517, 0.228141), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 1.5), vec4(0.360871, -0.077435, 1.049110, 0.226851), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 1.5), vec4(0.608870, -0.112986, 1.040456, 0.216178), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 1.5), vec4(0.850681, -0.110371, 1.022363, 0.171798), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 1.5), vec4(1.033758, -0.063836, 1.011022, 0.089896), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 1.5), vec4(1.130218, 0.000062, 1.000010, -0.000080), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 2.5), vec4(0.000200, -0.000096, 1.232269, 0.481573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 2.5), vec4(0.040829, -0.019653, 1.232083, 0.481559), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 2.5), vec4(0.163323, -0.077152, 1.229494, 0.481157), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 2.5), vec4(0.361362, -0.161748, 1.215935, 0.476966), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 2.5), vec4(0.602530, -0.224893, 1.149731, 0.444834), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 2.5), vec4(0.832866, -0.211716, 1.066321, 0.339254), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 2.5), vec4(1.033638, -0.123274, 1.025543, 0.170803), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 2.5), vec4(1.137644, 0.000154, 0.999953, -0.000082), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 3.5), vec4(0.000199, -0.000159, 1.627474, 0.797472), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 3.5), vec4(0.040836, -0.032524, 1.635685, 0.797401), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 3.5), vec4(0.164108, -0.127318, 1.628042, 0.795956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 3.5), vec4(0.365844, -0.258932, 1.575327, 0.783120), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 3.5), vec4(0.602895, -0.339455, 1.372632, 0.710306), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 3.5), vec4(0.825683, -0.302224, 1.158343, 0.512880), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 3.5), vec4(1.030563, -0.173519, 1.049980, 0.243539), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 3.5), vec4(1.151713, 0.000105, 0.999957, -0.000055), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 4.5), vec4(0.000198, -0.000248, 2.529443, 1.253956), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 4.5), vec4(0.040880, -0.051100, 2.570697, 1.253684), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 4.5), vec4(0.166706, -0.198049, 2.542881, 1.248409), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 4.5), vec4(0.380361, -0.384441, 2.334701, 1.206127), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 4.5), vec4(0.617299, -0.459699, 1.772357, 1.025249), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 4.5), vec4(0.835445, -0.380695, 1.304201, 0.680722), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 4.5), vec4(1.040850, -0.213042, 1.089431, 0.306573), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 4.5), vec4(1.176060, 0.000010, 1.000023, -0.000021), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 5.5), vec4(0.000187, -0.000388, 4.301116, 2.076506), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 5.5), vec4(0.041070, -0.084546, 5.305590, 2.075270), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 5.5), vec4(0.175521, -0.321638, 5.161014, 2.051541), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 5.5), vec4(0.413187, -0.560077, 4.055352, 1.869406), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 5.5), vec4(0.665130, -0.580464, 2.432246, 1.376237), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 5.5), vec4(0.870094, -0.441204, 1.506300, 0.819691), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 5.5), vec4(1.068578, -0.241436, 1.137736, 0.354430), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 5.5), vec4(1.219174, -0.000534, 1.000063, 0.000162), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 6.5), vec4(0.000144, -0.000631, 6.468958, 4.381222), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 6.5), vec4(0.042200, -0.177353, 20.085962, 4.369584), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 6.5), vec4(0.209979, -0.606367, 16.868328, 4.106197), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 6.5), vec4(0.500901, -0.795643, 8.099620, 2.893355), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 6.5), vec4(0.769693, -0.688227, 3.439625, 1.659662), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 6.5), vec4(0.955036, -0.470746, 1.760819, 0.883184), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 6.5), vec4(1.134532, -0.254869, 1.190455, 0.377490), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 6.5), vec4(1.308330, -0.002944, 0.999844, 0.001275), fragCoord, fragColor);\n    store_buf(vec2(BIAS+0.5, 7.5), vec4(0.000102, -0.118482, 1184.816772, 1184.816284), fragCoord, fragColor);\n    store_buf(vec2(BIAS+1.5, 7.5), vec4(0.319603, -3.097308, 7133.888672, 23.645655), fragCoord, fragColor);\n    store_buf(vec2(BIAS+2.5, 7.5), vec4(0.546638, -1.442077, 133.966263, 8.593670), fragCoord, fragColor);\n    store_buf(vec2(BIAS+3.5, 7.5), vec4(0.837342, -1.129903, 20.226521, 3.658263), fragCoord, fragColor);\n    store_buf(vec2(BIAS+4.5, 7.5), vec4(1.004258, -0.809128, 5.700182, 1.768790), fragCoord, fragColor);\n    store_buf(vec2(BIAS+5.5, 7.5), vec4(1.117055, -0.531464, 2.269246, 0.923613), fragCoord, fragColor);\n    store_buf(vec2(BIAS+6.5, 7.5), vec4(1.336692, -0.312752, 1.241618, 0.414403), fragCoord, fragColor);\n    store_buf(vec2(BIAS+7.5, 7.5), vec4(1.670654, -0.056394, 0.998759, 0.033416), fragCoord, fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.x > 16. || fragCoord.y > 8. ) discard;\n\tsetLUT(fragCoord, fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}