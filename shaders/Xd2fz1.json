{
    "Shader": {
        "info": {
            "date": "1500222842",
            "description": "I starderd playing with 3d noise and raymarching, then I discovered fractal brownian motion and got addicted...",
            "flags": 0,
            "hasliked": 0,
            "id": "Xd2fz1",
            "likes": 3,
            "name": "NoisePursuit_v1",
            "published": 3,
            "tags": [
                "raymarching",
                "fbm",
                "3dnoise",
                "blackbody"
            ],
            "usePreview": 0,
            "username": "Palliaci",
            "viewed": 767
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Palliaci\n * Inspired by revers shader : https://www.shadertoy.com/view/4ddXW4\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * I wanted to play around with 3d noise and the analytical normals from iq :\n * https://iquilezles.org/articles/morenoise\n *\n * The green thing is also a variation from iq's shader on raymarching primitives.\n */\nconst float FOV = 1.;\nconst float MarchDumping = .7579;\nconst float Far = 38.925;\nconst int MaxSteps = 128;\nconst float precis = .002;\nconst float CameraSpeed = 1.5099998;\nconst float TunnelSmoothFactor = 1.2;\nconst float TunnelRadius = 0.15660005;\nconst float TunnelFreqA = 0.318003;\nconst float TunnelFreqB = 0.25;\nconst float TunnelAmpA = 3.6230998;\nconst float TunnelAmpB = 2.4324;\nconst float NoiseIsoline = 0.119;\nconst float NoiseScale = 2.9980001;\n\n// Goes from 1 to 4\n#define COL1\n// Activates lightning, otherwise color depends only on the blackbody and COL define\n#define LIGHTS\n// If you want some \"fresh air\"\n#define OUT\n// Replace by the name of the fbm function to raymarch\n#define FBM fbm\n\nvec2\tuv;\nvec3\tnor;\nfloat\tt;\nfloat\tid_t;\nfloat\tst;\nfloat\tct;\n\n\nvec3\tcalcNormal( in vec3 pos );\nfloat\tiqhash(vec3 p);\nvec4\tnoised( in vec3 x );\nfloat\tcalculateAO(in vec3 p, in vec3 n);\nfloat\tsmax(float a, float b, float k);\nvec3 \tblackbody(float Temp);\nvec3\tcamera(vec2 uv, vec3 forw);\nmat3\trotX( float a );\nmat3\trotY( float a );\nmat3\trotZ(float a);\n\nfloat fbm(vec3 p) {\n\tvec4 res;\n\tres = 0.5000 * noised(p);\n\tp *= 2.01;\n\tres += 0.2500 * noised(p);//noise(p);\n\tp *= 2.02;\n\tres += 0.1250 * noised(p);//noise(p);\n    p *= 8.03;\n    p.x *= 2.0;\n\tres += 0.0150 * noised(p);//noise(p);\n\n    nor = res.yzw;\n\treturn res.x;\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.96, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.96, -0.48,\n                       0.60, -0.48,  0.64 );\nfloat fbm2(vec3 p)\n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.49;  // could be 0.5\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    vec4 n;\n    for( int i=0; i < 3; i++ )\n    {\n\t\tn = noised(p);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        p = f*m3*p;\n        m = f*m3i*m;\n    }\n    nor = d;\n    return a;\n}\n\n// From \"Subterranean Fly-Through\" by Shane https://www.shadertoy.com/view/XlXXWj\nvec2 path(float z) {\n\treturn vec2(TunnelAmpA * sin(z * TunnelFreqA), TunnelAmpB * cos(z * TunnelFreqB));\n}\n\nfloat noiseDist(vec3 p) {\n\tp = p / NoiseScale;\n\treturn (FBM(p) - NoiseIsoline) * NoiseScale;\n}\n\nfloat map(vec3 p) {\n\tfloat d = noiseDist(p);\n    p.xy -= path(p.z);\n\tfloat d2 = length(p.xy) - TunnelRadius;\n    \n\td = smax(/*.25*st*/d, -d2, TunnelSmoothFactor);\n#ifdef OUT\n    vec3 pnor = vec3(0., 1., 0.);\n    d = smax(d, dot(p, pnor) - 1.2, 2.);\n#endif\n    \n    p.z -= t + .5;\n    id_t = d;\n    //d = min(d, length(p) - .1);\n    d = min(d, (length(p)-.1)+ st*0.03 * cos( 50.0 * p.x ) * sin( 50.0 * p.y)\n                             * sin(50.0 * p.z));\n    id_t = (id_t != d)? 1. : 0. ;\n\treturn d;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat t = tmin;\n    float d;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\td = map(ro + rd * t);\n\t\tif (d < precis || t > Far) {\n\t\t\tbreak;\n\t\t}\n\t\tt += d * MarchDumping;\n\t}\n\treturn t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uv  = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n//    if (!(uv.x > .5 && uv.y > .25 && uv.x < 1.25 && uv.y < .75))\n//       discard;\n    st = sin(iTime);\n    ct = cos(iTime);\n    \n    t = iTime * CameraSpeed * (1.+.001*st) + 4.0 * 60.0;\n//    t = iTime * CameraSpeed + 4.0 * 60.0;\n    vec3 ro = vec3(path(t), t);\n    t += 0.5;\n    vec3 target = vec3(path(t), t);\n    vec3 rd = camera(uv, normalize(target - ro));\n\n    float d = march(ro, rd);\n    vec3 col;\n\t\n    vec3\tv = ro + d * rd;\n\n    if ( d <= Far )\n\t{\n        if (id_t == 1.)\n        {\n\t        col =   1. - blackbody(d*3000.).yzx;\n        \tnor =\tcalcNormal(v);\n        }\n        else\n#ifdef COL1\n            col =\tblackbody(d*300.+100.)* (.5+.5*texture(iChannel0, v.xy * .1).xyz);\n#endif\n#ifdef COL2\n    \t\tcol =\tblackbody(((d)*200.*(1.+.5*ct)+300.));\n#endif\n#ifdef COL3\n    \t\tcol =\tblackbody(((d)*200.*(1.+.5*ct)+300.)).xzy;\n#endif\n#ifdef COL4\n    \t\tcol =\t1.-blackbody((d)*3000.);\n#endif\n#ifdef LIGHTS\n        vec3\tev = normalize( v - ro );\n\t\tvec3\tref_ev = reflect( ev, nor );\n        t =\t\t(iTime + 2.) * CameraSpeed + 4.0 * 60.0;\n        vec3\tlight_pos   = vec3(path(t+.2), t+.2);\n\n        vec3\tvl = normalize( light_pos - v );\n\t\tfloat\tdiffuse  = max( 0.001, dot( vl, nor ) );\n\t\tfloat\tspecular = pow( max( 0.001, dot( vl, ref_ev ) ), 1. );\n        float\tao = calculateAO(v, nor);\n        float\tbrdf = (diffuse + specular + ao );// * .25 + .75;\n        col =\tcol * brdf;\n#endif\n    }\n\telse\n        col = vec3(uv, 0.);\n//    col = pow(col, vec3(.4545));\n    fragColor = vec4(col, 1.0);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat iqhash(vec3 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = iqhash(p+vec3(0.0,0.0,0.0));\n    float b = iqhash(p+vec3(1.0,0.0,0.0));\n    float c = iqhash(p+vec3(0.0,1.0,0.0));\n    float d = iqhash(p+vec3(1.0,1.0,0.0));\n    float e = iqhash(p+vec3(0.0,0.0,1.0));\n\tfloat f = iqhash(p+vec3(1.0,0.0,1.0));\n    float g = iqhash(p+vec3(0.0,1.0,1.0));\n    float h = iqhash(p+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y +\n                 k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z,\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ));\n}\n\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n// by iq. https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nmat3\trotX( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( 1, 0, 0, 0, c, -s, 0, s, c );\n}\nmat3\trotY( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n}\nmat3\trotZ(float a) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat3( c, s, 0, -s, c, 0, 0, 0, 1.0 );\n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvec3\tcamera(vec2 uv, vec3 forw) {\n\tvec3    right = vec3( 1.0, 0.0, 0.0) ;\n\tvec3    up    = vec3( 0.0, 1.0, 0.0) ;\n\n    return ( normalize( ( uv.x - 1. ) * right\n                        + ( uv.y - 0.5 ) * up\n                        + FOV * forw ) );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}