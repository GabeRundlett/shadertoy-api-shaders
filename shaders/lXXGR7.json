{
    "Shader": {
        "info": {
            "date": "1713977710",
            "description": "Altered Newton's Method",
            "flags": 0,
            "hasliked": 0,
            "id": "lXXGR7",
            "likes": 4,
            "name": "Altered Newton's Method testing",
            "published": 3,
            "tags": [
                "alterednewtonsmethod"
            ],
            "usePreview": 0,
            "username": "Elyades",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nvec3 palette1(float t)\n{\n    vec3 a = vec3(0.4,0.4,0.5);\n    vec3 b = vec3(0.2,0.2,0.5);\n    vec3 c = vec3(1.0,1.0,0.5);\n    vec3 d = vec3(0.05,0.15,0.25);\n    return( vec3( a + b*cos( TWOPI*( c*t + d ) ) ) );\n}\n\nfloat norm(vec2 uv)\n{\n    return( uv.x*uv.x + uv.y*uv.y );\n}\n\nvec2 square(vec2 uv)\n{\n    return( vec2(uv.x*uv.x - uv.y*uv.y , 2.0*uv.x*uv.y) );\n}\n\nvec2 cube(vec2 uv)\n{\n    return vec2(uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y , 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y);\n}\n\nvec2 quad(vec2 uv)\n{\n    float x2 = uv.x*uv.x ; float y2 = uv.y*uv.y; float xy = uv.x*uv.y;\n    return( vec2(x2*x2 - 6.0*x2*y2 + y2*y2 , 4.0*xy*(x2 - y2) ) );\n}\n\nvec2 pent(vec2 uv)\n{\n    float x2 = uv.x*uv.x; float y2 = uv.y*uv.y; float xy = uv.x*uv.y;\n    float x3 = x2*uv.x; float y3 = y2*uv.y;\n    return( vec2(x2*x3 - 10.0*x3*y2 + 5.0*y3*xy  , 5.0*xy*x3 - 10.0*x2*y3 + y2*y3 ) );\n}\n\nvec2 times(vec2 x, vec2 y)\n{\n    return( vec2(x.x*y.x - x.y*y.y , x.y*y.x + x.x*y.y) );\n}\n\nvec2 oneover(vec2 uv)\n{\n    return( vec2(uv.x , -uv.y)/norm(uv) );\n}\n\nvec2 itimes(vec2 uv)\n{\n    return( vec2(-uv.y,uv.x) );\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return ( vec2 (exp2d(itimes(uv)) + exp2d(itimes(-uv)))*0.5);\n}\n\nvec2 sin2d(vec2 uv)\n{\n    return ( vec2 (-itimes((exp2d(itimes(uv)) - exp2d(itimes(-uv)))*0.5)));\n}\n\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\n\nvec2 f(vec2 uv, vec2 c)\n{\n    //vec2 m = vec2(1.0,0.0) + (iMouse.xy/iResolution.xy - 0.5)*6.0;\n    //return( cube(uv) + times(c,uv) - vec2(0.5));\n    return( cube(uv) + times(c,uv) - vec2(0.5));\n}\n\nvec2 fprime(vec2 uv, vec2 c)\n{\n    return( 2.0*square(uv) + c );\n}\n\nvec2 NewtonIteration(vec2 uv, vec2 c, vec2 a)\n{\n    return(uv - times(a, times(f(uv,c) , oneover(fprime(uv,c)) ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*5.0;\n    uv.y *= iResolution.y/iResolution.x;\n    float zoom = pow(10.0,-iTime/5.0); uv *= zoom;\n    vec2 m = vec2(1.0,0.0) + (iMouse.xy/iResolution.xy - 0.5)*3.0;\n    vec2 zoomPoint = vec2(0.04,0.5115); uv += zoomPoint;\n    vec2 dummyuv = uv; vec2 previousuv = vec2(10000.0,-2451.0); float distanceToPrevious;\n    float maxIteration = 1000.0; int i = 0; float tolerance = pow(10.0,-8.0);\n    \n    int hasStopped = 0; //0 means not enough iter. 1 means converged. 2 means stuck without converging\n    float dist;\n    vec2 c; c = dummyuv; \n    uv = vec2(0.0);\n    //c = m; \n    for (i = 0; i < int(maxIteration); i++)\n    {\n        dist = norm(f(uv,c));\n        distanceToPrevious = norm( uv - previousuv );\n        if( dist < tolerance){hasStopped = 1; break;}\n        else if( distanceToPrevious < tolerance ){hasStopped = 2; break;}\n        previousuv = uv;\n        uv = NewtonIteration(uv, c, vec2(1.0,0.0));\n    }\n    \n    vec3 finalColor;\n    \n    if (hasStopped == 1)//converged\n    {\n        float index = 2.0*log(float(i) + 1.0);\n        finalColor = palette1(index);\n    }\n    else if(hasStopped == 2)//stuck\n    { finalColor = vec3(1.0,0.0,0.0);}\n    \n    else//not enough iter\n    { finalColor = vec3(0.0,0.0,0.0);}\n  \n    fragColor = vec4(finalColor,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}