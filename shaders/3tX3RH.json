{
    "Shader": {
        "info": {
            "date": "1582525134",
            "description": "This is Anpanman.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tX3RH",
            "likes": 4,
            "name": "Anpanman.",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "nodo",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "#define MAT_BALL 1.0\n#define MAT_BALL2 2.0\n#define MAT_BALL3 3.0\n#define MAT_A_EYE 4.0\n#define MAT_A_EYEBLOW 5.0\n#define MAT_A_HEAD 6.0\n#define MAT_A_NOSE 7.0\n#define MAT_A_MOUTH 8.0\n#define MAT_S_HEAD 9.0\n#define MAT_K_HEAD 11.0\n#define MAT_K_TOOTH 12.0\n#define MAT_K_MOUTH 13.0\n#define MAT_K_NOSE 14.0\n\n\n\n\n#define MAT_FLOOR 10.0\n#define MAT_SKY 100.0\n\n\n\n\nprecision mediump float;\n\n\nconst float PI = 3.14159265;\nconst vec3 lightDir = normalize(vec3(0.5, 0.5, 0.5));\nvec3 RayOrigin, Target;\n\n// rotate\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot(float t){\n    float s = sin(t),c = cos(t);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0))\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (d1.x<-d2.x) ? vec2(-d2.x,d2.y) : d1;\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? vec2(d2.x,-d2.y) : d1;\n}\n\n\n\n// anpanman\nvec2 anpanHead(vec3 p, float size){\n    return vec2(sdEllipsoid(p, vec3(size,size*0.95,size*0.8)),MAT_A_HEAD);\n}\n\n\nvec2 anpanEye(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-0.3*size,-0.75*size), vec3(size/12.0,size*0.95/10.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.2*size,-0.3*size,-0.75*size), vec3(size/12.0,size*0.95/10.0,size*0.5/10.0));\n    return vec2(min(d1,d2),MAT_A_EYE);\n}\n\nvec2 anpanNose(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.0,0.0,-0.8 *size), vec3(size/4.8,size*0.95/5.0,size*0.5/5.0));\n    float d2 = sdEllipsoid(p+vec3(0.33*size,0.03*size,-0.73*size), vec3(size/5.5,size*0.95/5.5,size*0.5/5.5));\n    float d3 = sdEllipsoid(p+vec3(-0.33*size,0.03*size,-0.73*size), vec3(size/5.5,size*0.95/5.5,size*0.5/5.5));\n    return vec2(min(d1,min(d2,d3)),MAT_A_NOSE);\n}\n\n\nvec2 anpanMouth(vec3 p, float size){\n    float d1 = sdRoundedCylinder(rotate(p+vec3(0.0,0.15*size,-0.8*size),radians(90.0),vec3(1.0,0.0,0.0)), 0.15*size, 0.2*size, 0.1*size );\n    float d2 = sdBox(p, vec3(0.3*size,0.2*size,1.0*size));\n    return vec2(max(d1,-d2),MAT_A_MOUTH);\n}\n\nvec2 anpanEyeblowLeft(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-0.34*size,-0.75*size), vec3(size/8.0,size*0.95/6.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(0.2*size,-0.34*size,-0.75*size), vec3(size/8.5,size*0.95/6.5,size*0.5/8.0));\n    float d3 = sdSphere(p+vec3(0.17*size,-0.28*size,-0.75*size), 0.14*size);\n    return vec2(max(max(d1,-d2),-d3),MAT_A_EYEBLOW);\n}\n\nvec2 anpanEyeblowRight(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(-0.2*size,-0.34*size,-0.75*size), vec3(size/8.0,size*0.95/6.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.2*size,-0.34*size,-0.75*size), vec3(size/8.5,size*0.95/6.5,size*0.5/8.0));\n    float d3 = sdSphere(p+vec3(-0.17*size,-0.28*size,-0.75*size), 0.14*size);\n    return vec2(max(max(d1,-d2),-d3),MAT_A_EYEBLOW);\n}\n\nvec2 anpanman(vec3 p, float size){\n    vec2 d = opU(anpanEyeblowLeft(p,size),anpanEyeblowRight(p, size));\n    d = opU(d,anpanHead(p,size));\n    d = opU(d,anpanEye(p,size));\n    d = opS(d,anpanMouth(p,size));\n    d = opU(d,anpanNose(p,size));\n    return d;\n}\n\n//syokupanman\nvec2 syokupanHead(vec3 p, float size){\n    float d1 = sdRoundBox(p+vec3(0.0,0.0,0.0)*size,vec3(0.5,0.5,0.5)*size, 0.2 *size);\n    float d2 = sdEllipsoid(p+vec3(0.0*size,-0.75*size,0.0*size), vec3(size* 0.9,size*0.4,size*0.8));\n    float d3 = sdBox(p,vec3(2.0*size,2.0*size,0.2*size));\n    return vec2(max(min(d1,d2),d3),MAT_S_HEAD);\n}\n\nvec2 syokupanEye(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.25*size,-0.55*size,-0.2*size), vec3(size/13.0,size*0.95/9.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.25*size,-0.55*size,-0.2*size), vec3(size/13.0,size*0.95/9.0,size*0.5/10.0));\n    return vec2(min(d1,d2),MAT_A_EYE);\n}\n\nvec2 syokupanEyeblowLeft(vec3 p, float size){\n    p += vec3(0.05,-0.3,0.55);\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-0.34*size,-0.75*size), vec3(size/8.0,size*0.95/6.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(0.2*size,-0.34*size,-0.75*size), vec3(size/8.5,size*0.95/6.5,size*0.5/8.0));\n    float d3 = sdSphere(p+vec3(0.17*size,-0.28*size,-0.75*size), 0.14*size);\n    return vec2(max(max(d1,-d2),-d3),MAT_A_EYEBLOW);\n}\n\nvec2 syokupanEyeblowRight(vec3 p, float size){\n    p += vec3(-0.05,-0.3,0.55);\n    float d1 = sdEllipsoid(p+vec3(-0.2*size,-0.34*size,-0.75*size), vec3(size/8.0,size*0.95/6.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.2*size,-0.34*size,-0.75*size), vec3(size/8.5,size*0.95/6.5,size*0.5/8.0));\n    float d3 = sdSphere(p+vec3(-0.17*size,-0.28*size,-0.75*size), 0.14*size);\n    return vec2(max(max(d1,-d2),-d3),MAT_A_EYEBLOW);\n}\n\nvec2 syokupanMouth(vec3 p, float size){\n    p.y -= 0.1;\n    size*=1.2;\n    float d1 = sdRoundedCylinder(rotate(p+vec3(0.0,0.15*size,-0.2*size),radians(90.0),vec3(1.0,0.0,0.0)), 0.15*size, 0.2*size, 0.1*size );\n    float d2 = sdBox(p, vec3(0.3*size,0.2*size,1.0*size));\n    return vec2(max(d1,-d2),MAT_A_HEAD);\n}\n\nvec2 syokupanNose(vec3 p, float size){\n    p += vec3(0.0,-0.2,-0.2);\n    p = rotate(p, radians(20.0), vec3(1.0, 0.0, 0.0));\n    return vec2(sdBox(p,vec3(0.05,0.09,0.05)),MAT_S_HEAD);\n}\n\nvec2 syokupanman(vec3 p, float size){\n    return opU(opI(syokupanHead(p,size),-syokupanMouth(p,size)),opU(opU(syokupanEye(p,size),syokupanNose(p, size)),opU(syokupanEyeblowLeft(p,size),syokupanEyeblowRight(p, size))));\n}\n\nfloat smin( float a, float b)\n{\n    float k = 1.3;\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float tmp = mix( b, a, h );\n    return tmp - k*h*(1.0-h);\n}\n\n//kabao\n\nvec2 kabaoHead(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.0*size,0.2*size,0.0*size), vec3(size/1.0,size/1.2,size/1.0));\n    float d2 = sdEllipsoid(p+vec3(0.0*size,-1.2*size,0.0*size), vec3(size/1.5,size/2.0,size/1.5));    \n\treturn vec2(smin(d1,d2),MAT_K_HEAD);\n}\n\nvec2 kabaoEye(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-1.2*size,-0.75*size), vec3(size/15.0,size*1.05/10.0,size*0.5/10.0));\n    float d2 = sdEllipsoid(p+vec3(-0.2*size,-1.2*size,-0.75*size), vec3(size/15.0,size*1.05/10.0,size*0.5/10.0));\n    return vec2(min(d1,d2),MAT_A_EYE);\n}\n\nvec2 kabaoEyeblow(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.2*size,-1.35*size,-0.7*size), vec3(size/7.0,size*1.05/7.0,size*0.5/7.0));\n    float d2 = sdEllipsoid(p+vec3(0.2*size,-1.33*size,-0.7*size), vec3(size/7.0,size*1.05/7.0,size*0.8/7.0));\n\td1 = max(d1,-d2);\n    \n    float d3 = sdEllipsoid(p+vec3(-0.2*size,-1.35*size,-0.7*size), vec3(size/7.0,size*1.05/7.0,size*0.5/7.0));\n    float d4 = sdEllipsoid(p+vec3(-0.2*size,-1.33*size,-0.7*size), vec3(size/7.0,size*1.05/7.0,size*0.8/7.0));\n\td3 = max(d3,-d4);\n    return vec2(min(d1,d3),MAT_A_EYEBLOW);\n}\n\nvec2 kabaoMouth(vec3 p, float size){\n    float d1 = sdEllipsoid(p+vec3(0.45*size,0.1*size,-0.8*size), vec3(size/3.2,size/3.2,size/3.2));\n    float d2 = sdEllipsoid(p+vec3(-0.45*size,0.1*size,-0.8*size), vec3(size/3.2,size/3.2,size/3.2));\n\treturn vec2(smin(d1,d2),MAT_K_MOUTH);\n}\n\nvec2 kabaoEar(vec3 p, float size){\n    float d1 = sdRoundedCylinder(rotate(p + vec3(0.40*size,-1.7*size,-0.2*size),radians(90.0),vec3(1.0,0.0,0.0)), 0.07/size, 0.07/size,0.03/size );\n    float d2 = sdRoundedCylinder(rotate(p + vec3(-0.40*size,-1.7*size,-0.2*size),radians(90.0),vec3(1.0,0.0,0.0)), 0.07/size, 0.07/size,0.03/size );\n\td1 = min(d1,d2);\n    return vec2(d1,MAT_K_HEAD);\n}\n\nvec2 kabaoTooth(vec3 p, float size){\n    float d1 = sdRoundBox(p +vec3(0.3*size,0.43*size,-0.68*size), vec3(0.025/size,0.005/size,0.005/size), 0.15 /size);\n    float d2 = sdRoundBox(p +vec3(-0.3*size,0.43*size,-0.68*size), vec3(0.03/size,0.005/size,0.005/size), 0.15 /size);\n    float d3 = sdRoundBox(p +vec3(0.4*size,-0.15*size,-0.64*size), vec3(0.03/size,0.005/size,0.005/size), 0.15 /size);\n    float d4 = sdRoundBox(p +vec3(-0.4*size,-0.15*size,-0.64*size), vec3(0.03/size,0.005/size,0.005/size), 0.15 /size);\n\td1 = min(d1,d2);\n    d1 = min(d1,d3);\n    d1 = min(d1,d4);\n    return vec2(d1,MAT_K_TOOTH);\n}\n\nvec2 kabaoNose(vec3 p, float size){\n    float d1 =  sdRoundedCylinder(rotate(p + vec3(0.35*size,-0.53*size,-0.73*size),radians(90.0),vec3(0.9,0.3,0.0)), 0.09/size, 0.09/size,0.01/size );\n    float d2 =  sdRoundedCylinder(rotate(p + vec3(-0.35*size,-0.53*size,-0.73*size),radians(90.0),vec3(0.9,-0.3,0.0)), 0.09/size, 0.09/size,0.01/size );\n\td1 = min(d1,d2);\n    return vec2(d1,MAT_K_NOSE);\n}\n\n\n\nvec2 kabao(vec3 p, float size){\n    vec2 d = opI(kabaoHead(p,size),-kabaoMouth(p,size));\n    d = opU(d,kabaoEye(p,size));\n    d = opU(d,kabaoEyeblow(p,size));\n    d = opU(d,kabaoEar(p,size));\n    d = opU(d,kabaoTooth(p,size));\n    d = opU(d,kabaoNose(p,size));\n    return d;   \n}\n\n\n\n\n\nvec2 distFunc(vec3 p){\n    \n    vec2 d = anpanman(p+vec3(0.0,-2.0,1.5),1.0);\n    vec2 d2 = vec2(sdBox(p+vec3(0.0,2.0,1.5),vec3(5.0,3.0,2.0)),MAT_FLOOR);\n    vec2 d3 = syokupanman(p+vec3(2.5,-2.0,1.5),1.0);\n    vec2 d4 = kabao(p+vec3(-2.5,-2.0,1.5),1.0);\n\n    d = opU(d,d3);\n    d = opU(d,d4);\n    \n    return opU(d,d2);\n}\n\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)).x - distFunc(p + vec3( -d, 0.0, 0.0)).x,\n        distFunc(p + vec3(0.0,   d, 0.0)).x - distFunc(p + vec3(0.0,  -d, 0.0)).x,\n        distFunc(p + vec3(0.0, 0.0,   d)).x - distFunc(p + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = distFunc(p + t*l).x;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\n//V:-ray L:lightdir\nvec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n    float shadow = shadow(pos, L);\n    //shadow =1.0;\n\tvec3 diffuseBRDF = kd * albedo / PI;\n   // return diffuseBRDF* Lradiance * NdotL * shadow;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n//return specularBRDF;\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n\nvec4 genAmbientOcclusion(vec3 ro, vec3 rd)\n{\n    vec4 totao = vec4(0.0);\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++)\n    {\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = distFunc(aopos).x;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca * vec4(1.0, 1.0, 1.0, 1.0);\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n    totao.w = 1.0 - clamp(aoCoef * totao.w, 0.0, 1.0);\n\n    return totao;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 materialize(vec3 p, vec3 ray, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 sky = vec3(0.1, 0.3, 0.5) * 1.5;\n    vec4 cube = texture(iChannel0, ray);\n\n\n    float roughness = 0.0, metalness = 0.0;\n    vec3 albedo = vec3(0.0), normal = vec3(0.0), emissive = vec3(0.0);\n    float h = mat.y;\n    float specular = 0.0;\n    vec3 ambient = vec3(0.1);\n    normal = getNormal(p);\n\n\n\tif (mat.y == MAT_SKY) {\n\n        col = cube.xyz;\n        return col;\n    } else if (mat.y == MAT_BALL) {\n        col = pow(vec3(102.0 / 255.0, 69.0 / 255.0, 0.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_BALL2) {\n        col = vec3(0.8,0.8,0.5);\n        col = pow(vec3(59.0 / 255.0, 59.0 / 255.0, 123.0 / 255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_BALL3) {\n        col = vec3(0.0,1.0,1.0);\n        col = pow(vec3(20.0 / 255.0, 120.0 / 255.0, 102.0 / 255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_HEAD) {\n        col = pow(vec3(235.0/255.0,151.0/255.0, 98.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.4;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_EYE) {\n        col = pow(vec3(0.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_EYEBLOW) {\n        col = pow(vec3(0.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_NOSE) {\n        col = pow(vec3(0.8,0.0,0.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_A_MOUTH) {\n        col = pow(vec3(143.0/255.0, 54.0/255.0, 67.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    } else if (mat.y == MAT_S_HEAD) {\n        if(dot(normal,vec3(0.0,0.0,1.0)) > 0.5 ){\n        \tcol = pow(vec3(240.0/255.0, 240.0/255.0, 240.0/255.0), vec3(2.2)) * 0.6;\n        }else{\n        \tcol = pow(vec3(235.0/255.0,151.0/255.0, 98.0/255.0), vec3(2.2)) * 0.6;\n        }\n\n        roughness = 0.7;\n        metalness = 0.8;\n    }else if (mat.y == MAT_K_HEAD) {\n        col = pow(vec3(170.0/255.0,88.0/255.0, 67.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.4;\n        metalness = 0.8;\n    }else if (mat.y == MAT_K_TOOTH) {\n        col = pow(vec3(240.0/255.0, 240.0/255.0, 240.0/255.0), vec3(2.2)) * 0.6;\n        \n        roughness = 0.9;\n        metalness = 0.9;\n    }else if (mat.y == MAT_K_MOUTH) {\n        col = pow(vec3(197.0/255.0,102.0/255.0,110.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    }else if (mat.y == MAT_K_NOSE) {\n        col = pow(vec3(117.0/255.0,64.0/255.0,58.0/255.0), vec3(2.2)) * 0.6;\n\n        roughness = 0.7;\n        metalness = 0.8;\n    }else if (mat.y == MAT_FLOOR) {\n        col = vec3(1.0);\n        // generate tile pattern\n        float u = 1.0 - floor(mod(p.x, 2.0));\n        float v = 1.0 - floor(mod(p.z, 2.0));\n        vec2 uv = vec2(0.0);\n        if(dot(normal,vec3(0.0,1.0,0.0)) < 0.5 ){\n        \tfloat u = 1.0 - mod(p.x*0.2, 1.0);\n        \tfloat v = 1.0 - mod(p.y*0.2, 1.0);\n            uv = vec2(u,v);\n        }else{\n            float u = 1.0 - mod(p.x*0.2, 1.0);\n        \tfloat v = 1.0 - mod(p.z*0.2, 1.0);   \n            uv = vec2(u,v);\n        }\n        if((u == 1.0 && v < 1.0) || (u < 1.0 && v == 1.0)){\n            col *= 0.7;\n        }\n        \n        col = pow(col, vec3(2.2)) * 0.1;\n        \n        roughness = 0.5;\n        metalness = 0.0;\n    }else {\n        col = vec3(1.0,0.0,1.0);\n    }\n    \n    vec4 ao = genAmbientOcclusion(p, normal);    \n    \n    vec3 result = vec3(0.);\n    result += shade(p, col, metalness, roughness, normal, -ray, lightDir, vec3(1.0, 0.98, 0.95) * 100.);\n    col = result-(ao.xyz*ao.w);\n    \n \n    return col;    \n}\n\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n           \n    RayOrigin =  vec3(0.0,  4.0,  6.0);\n    RayOrigin.xz *= rot(iTime*0.3);\n    Target = vec3(0.0, 2.0, 0.0);\n\n    mat3 c = camera(RayOrigin, Target, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.0));\n\n    vec3  rPos = RayOrigin;\n    float alpha = 1.0;\n\tvec3 color=vec3(0.0);\n\n\n    for(int i = 0; i < 3; i++) {\n\n\n    // marching loop\n    float rLen = 0.0;\n    vec2 mat;\n    bool isSky = true;\n\n    for(int i = 0; i < 128; i++){\n        mat = distFunc(rPos);\n        if (mat.x < 0.001) {\n            isSky = false;\n            break;\n        }\n        \n        if(rLen > 50.0){\n        \tisSky = true;\n        \tbreak;\n    \t}\n        rLen += mat.x;\n        rPos = RayOrigin + ray * rLen;\n    }\n\n  //  mat.x < 0.00001 ? mat.y += 0.0:mat.y =100.0;\n        \n    if(isSky){\n    \tmat.y = 100.0;                 \n    }\n        \n    color += alpha * materialize(rPos,ray,mat);\n    alpha *= 0.3;\n    \n    vec3 normal = getNormal(rPos);\n    \n    ray = normalize(reflect(ray, normal));\n    rPos = rPos + normal * 0.001;\n\n    if (mat.y == 100.0) {\n      break;\n    }\n  }\n\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}