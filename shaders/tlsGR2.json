{
    "Shader": {
        "info": {
            "date": "1557393726",
            "description": "this shader is a simpler mess, simpler and messier than usual\n\naclength implementation is false. still hitting that save button.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlsGR2",
            "likes": 1,
            "name": "parabola quadrcInverse",
            "published": 3,
            "tags": [
                "quadratic",
                "inverse",
                "parabola"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "/*\nsome quadratic fucntion utility\n*/\n\n#define viewZoom 4.\n#define cf(r,u) (u-.5*r)*viewZoom/r.y\n\n#define dd(a) dot(a,a)\n\n/*\n(4.*a*c-(b*b)+1.)*.25/a) ==height of \n  *.25/a ==height of focus\n//at what x do we get that height\nx*x=.25/a\nx=sqrt(.25/a)\n/**/\n\nfloat parabola(float x,vec3 a){\n ;return a.x*x*x\n        +a.y*x\n        +a.z;}\n\nvec2 vertexOfParabola(float a,float b,float c){return vec2(-.5*b/a,(4.*a*c-(b*b)+0.)*.25/a);}\n//vec2  focusOfParabola(float a,float b,float c){return vec2(-.5*b/a,(4.*a*c-(b*b)+1.)*.25/a);}\nvec2  focusOfParabola(float a,float b,float c){return vec2(-.5*b/a,.25/a)+vec2(0,c);}\nfloat DirectrixofParabola(float a,float b,float c){return c-((b*b)+1.)*4.*a;} \n//https://www.geeksforgeeks.org/c-program-for-finding-the-vertex-focus-and-directrix-of-a-parabola/\n\n\nvec2 vertexOfParabola(vec3 a){return vertexOfParabola(a.x,a.y,a.z);}\nvec2  focusOfParabola(vec3 a){return focusOfParabola(a.x,a.y,a.z);}\nfloat DirectrixofParabola(vec3 a){return DirectrixofParabola(a.x,a.y,a.z);}\n\n//(x-h)*(x-h)+k //x=range k=height\n\n//return 2 inverses of [parabola: y=a*x*x+b*x+c] == x=-b+-sqrt(-4*a*c)/(2*a)\nvec2 InverseQuadY(float a,float b,float c//a>0 c>=0\n){//if(a  ==0.)return vec2(0,-1)//no root, because a  ==0\n ;//if(a*c <0.)return vec2(0,-2)//no root, because a*b <0\n ;a*=2.\n ;return (vec2(-1,1)*sqrt(b*b-2.*a*c)-b)/a\n ;}\nvec2 InverseQuadY(vec3 a){return InverseQuadY(a.x,a.y,a.z);}\n\n#define arclength(f, p) 0.25 * p/f * length(vec2(p, 2.0 * f)) + f * asinh(0.5 * p/f)\n\n/*\n//p=charthesian.x (unsigned PointDistance to [axis of symmetry])\n//f=focalLength [distance from [focus] to [vertex==LocalMiminum]]\n//return arclength of parabola\nfloat arclength(float f,float p\n){float h=(p)*.5\n ;float q=sqrt(f*f+h*h) //q is just another length()\n ;return h*q/f+f*log((h+q)/f)\n ;}//https://en.wikipedia.org/wiki/Parabola#Arc_length\n*/\n\nvec2 linesegments(vec2 u,vec3 q,float f,float p,vec4 m\n){//q=quadratic coefficients f=focalLength, x=segment.x,m.xy=Vertex,m.zw=focus\n ;vec2 r=vec2(1)\n  //remove wrongly implemented line below, and see that all other code is fine.\n ;f=arclength(f,p) //this line is contextually false. everything up to this point is correct.\n //f anf p are both contextually correct values.\n ;if(u.x-m.x>0.&&u.x-m.x<p)r.x=parabola(u.x,q)-u.y//show parabola from 0 till p\n ;if(u.x-m.x>0.&&u.x-m.x<f)r.y=m.y            -u.y//show flattened arclength\n ;return abs(r);\n ;}\n\nvec4 showArcLength(float t,vec2 u,vec3 r,vec4 m,vec3 q\n){vec4 c=vec4(1)\n ;float p=mix(0.,2.,sin(t)*.5+.5)//arbitiaty parabola-segment\n ;p=abs(p) //basic inequalities of linesegments() only cover positive p\n ;m.zw=focusOfParabola(q)\n ;m.xy=vertexOfParabola(q)\n ;//c.x=length(u-vec2(x+m.z,m.w))//wrong .y offset lacks context\n ;c.x=length(u-vec2(p+m.z,parabola(p+m.z,q)))\n ;float f=length(m.w-m.y)  //focalLength\n ;//a=arclength(x,a) //this is false\n ;vec2 n=linesegments(u,q,f,p,m)\n ;//if(abs(u.x)>abs(u.y))u=(u.yx)*vec2(1,-1)\n ;c.z=length(u-vec2(f+m.x,m.y))//blue dot shows focalLength on x axis.\n\n ;n=smoothstep(.01,-.01,n-.02)\n ;c=smoothstep(.01,-.01,c-.05)\n ;c.xz=max(c.xz,n)\n ;return c;}\n\n\nvec4 stuff(float t,vec2 u,vec3 r,vec4 m,vec3 q){\n ;vec4 c=vec4(0)\n ;vec2 n=InverseQuadY(q)\n ;m=u.xyxy-vec4(n,0,0).xzyw\n ;n=sqrt(vec2(dd(m.xy),dd(m.zw)))//distance to 2 poitns, that mark 2 roots\n ;m.zw=focusOfParabola(q)\n ;m.xy=vertexOfParabola(q)\n ;c.b=length(vec2(u)-vec2(m.x,m.y-(m.w-m.y)))\n ;c.b=min(c.b,abs(u.y-m.y+(m.w-m.y))+.025)\n ;c.rg=vec2(length(u-m.xy)\n           ,length(u-m.zw))\n ;//c.b=m.z-m.y\n ;c.g=min(min(c.r,c.g),min(n.x,n.y))\n ;c.g=min(c.b,c.g)\n     \n ;c.r=1.\n\n ;c.b=parabola(u.x,q)-u.y\n ;c.b=abs(c.b)\n ;return c;}\n\nvoid mainImage( out vec4 o,vec2 u\n){vec3 r=iResolution\n ;vec4 m=iMouseZwFix(iMouse,true)\n ;u   =cf(r.xy,u)\n ;m.xy=cf(r.xy,m.xy)\n ;m.zw=cf(r.xy,m.zw)\n ;vec4 c=vec4(0)\n ;//m.xy=abs(m.xy)\n ;vec3 q=vec3(m.xy,cos(iTime))//quadratic function parameters\n ;c=      smoothstep(.01,-.01,stuff(iTime,u.xy,iResolution,m.xyzw,q)-.05)\n ;c.xyz=mix(c.xyz,c.yzx,.61*.61)//.rgb rotation\n ;//below line is optional, same, with swapped domains\n ;//c=max(c,smoothstep(.01,-.01,stuff(iTime,u.yx,iResolution,m.yxwz,q)-.05))\n ;c+=showArcLength(iTime,u.xy,iResolution,m.xyzw,q)\n ;o=vec4(c.xyz,1)\n ;}\n\n/*\n\nvoid parabola(float a, float b, float c) \n{ \n    cout << \"Vertex: (\" << (-b / (2 * a)) << \", \"\n         << (((4 * a * c) - (b * b)) / (4 * a)) \n         << \")\" << endl; \n    cout << \"Focus: (\" << (-b / (2 * a)) << \", \"\n         << (((4 * a * c) - (b * b) + 1) / (4 * a)) \n         << \")\" << endl; \n    cout << \"Directrix: y=\"\n         << c - ((b * b) + 1) * 4 * a << endl; \n} \n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n/*\nrant:\nthe second week of may 2019 was predictably a shitty week for me\n, allegies and hardware failures delay all my processing during that week.\n, to a point where I spend a lot more tzime sorting and archiving.\n\nIn preparation for this\n, I made a this significantly simpler shader side poroject\n, where process is easier, a simpler reward, while beign distracted.\n\nBut in the end this shader was put on hold\n, for the [bokeh+shadows within 20 reflections debug project]\n, to then add logEps()  logic to it\n, which ended up taking most of a 12-hour-period of that week\n, including breaks.\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}