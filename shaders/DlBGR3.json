{
    "Shader": {
        "info": {
            "date": "1673630563",
            "description": "A tribute to the masterpiece that made me fall in love with open world puzzle games.",
            "flags": 32,
            "hasliked": 0,
            "id": "DlBGR3",
            "likes": 33,
            "name": "Myst Book",
            "published": 3,
            "tags": [
                "2d",
                "retro",
                "drawing",
                "world",
                "tribute",
                "exile",
                "pages",
                "riven",
                "age"
            ],
            "usePreview": 1,
            "username": "kishimisu",
            "viewed": 603
        },
        "renderpass": [
            {
                "code": "/* \"Myst Book\" by @kishimisu (2023) - https://www.shadertoy.com/view/DlBGR3\n    \n    A tribute to one of my favorite video games\n    https://learn.sparkfun.com/tutorials/myst-linking-book/the-dni-and-the-art-\n    \n    This shader is made in the Image tab and displays the content \n    of Buffer A, so you can input your own scenes inside the \n    Buffer A tab to be displayed inside the book !\n    \n    This retro style fits the Myst series but I'd love to make\n    a more realistic and animated 3D version someday\n*/\n\n#define WORLD_ZOOM 1.1 // Zoom level on the Buffer A texture\n\n// Distance functions - https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdOBox( in vec2 p, in vec2 a, in vec2 b, float th ) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n// 2D noise value & fbm - https://www.shadertoy.com/view/lsf3WH\nfloat hash_(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise_( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash_( i + vec2(0.0,0.0) ), hash_( i + vec2(1.0,0.0) ), u.x),\n                mix( hash_( i + vec2(0.0,1.0) ), hash_( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm_(vec2 p) {\n    float f = 1.0, a = 1.0, t = noise_(p);\n    for(int i=1; i<6; i++) {\n        t += a*noise_(f*p);\n        f *= 2.0; a *= .5;\n    }\n    return t;\n}\n\nfloat sdMyst(vec2 u) {\n    const float sm = 0., lg = 0.03;\n    \n    u += vec2(.9, -.15);\n    float M =  sdOBox(u, vec2(0)   , vec2(.0, .2), sm);\n    M = min(M, sdOBox(u, vec2(.104,.03), vec2(.0, .2), lg));\n    M = min(M, sdOBox(u, vec2(.1,.01), vec2(.2, .2), sm));\n    M = min(M, sdOBox(u, vec2(.2,0), vec2(.2, .2), lg));\n    \n    u.x -= .26;\n    float Y =  sdOBox(u, vec2(.075, .1), vec2(0, .2),   lg);\n    Y = min(Y, sdOBox(u, vec2(.075, .1), vec2(.075, 0), lg));\n    Y = min(Y, sdOBox(u, vec2(.075, .1), vec2(.15, .2), sm));\n    \n    u.x -= .26;\n    float S = sdOBox(u + vec2(sin(u.y*30.+3.14)*.06,0), vec2(0), vec2(0, .2), lg);\n    \n    u.x -= .18;\n    float T =  sdOBox(u, vec2(0), vec2(0, .2), lg);\n    T = min(T, sdOBox(u, vec2(-.09, .2), vec2(.09, .2), sm));\n    \n    return min(min(min(M, Y), S), T);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    vec2 R = iResolution.xy, u = (2.*F-R)/R.y*.95;\n    vec3 col;\n     \n    // bottom pages\n    float m = 0., att = 1.;\n    for (float i = 0.; i < 9.; i++) {\n        float rr = abs(u.x) + fbm_(u*10.+i)*(i==0.?4.:2.)*.005 - i*.008 - 1.08;\n        if (rr > 0.) {\n            att *= .9-i*.007 - .5*smoothstep(.04, -.08, rr);\n            m = i+1.;\n        }\n    }\n    \n    float r0 = fbm_(u*5.+m*.2);\n    float r1 = fbm_(u*10.);\n    float rt = fbm_(u*10.+iTime*.4);\n    float r2 = fbm_(u*20.+iTime*.2);  \n    \n    if (u.x > 0.) {\n        // right page\n        col = mix(vec3(0.898,0.843,0.804), vec3(0.824,0.706,0.455), abs(u.x*1.2 - .95) + r0*.2 + r0*smoothstep(0.04, .4, sdBox(u, vec2(1.14, .82)*.7)));\n        col = mix(vec3(0.549,0.388,0.106), col, smoothstep(0., .8, u.x+.2));\n        col *= smoothstep(0., .2+ r0*.1, u.x)*.3+.7;\n        \n        // world portal\n        const vec2 offs = vec2(.55, .2);\n        const vec2 dims = vec2(.37, .27);\n        \n        if (abs(u.x - offs.x) < dims.x + .1 && abs(u.y - offs.y) < dims.y + .1) {\n            float world = -sdBox(u - offs, dims);\n            vec2 uv = (F/R-.5 - vec2(offs.x*R.y/R.x, offs.y)*.5)*WORLD_ZOOM + .5;\n            vec3 wcol = texture(iChannel0, uv).rgb;\n            \n            col *= smoothstep(-.01, .015, abs(world + r2*.015))*.4+.6;\n            col *= smoothstep(.1, .0, world + r2*.02);\n            col = mix(col, wcol, .8*smoothstep(0., .02, world + r2*.02));        \n        }\n    } else {\n        // left page\n        col = mix(vec3(0.796,0.678,0.471), vec3(0.855,0.753,0.631), -sin(u.x*5.5)+sin(u.x*10.)*.2 - r0*.3 - r0*smoothstep(0.04, .3, sdBox(u, vec2(1.14, .82)*.7)));\n        col *= smoothstep(-.1, .2+ r0*.05, -u.x)*.4+.6;\n        \n        // myst text\n        float myst = sdMyst(u);\n        col *= smoothstep(-.01, .035, myst+ rt*.005)*.5+.5;\n        myst = smoothstep(0., .026, myst + r1*.006);\n        col = mix(vec3(0.443,0.314,0.137)*rt, col, myst);\n    }\n    \n    // middle occlusion (this tiny shade really adds a lot to the depth)\n    col *= clamp(pow(abs(u.x)*4., .1), 0., 1.);\n        \n    // bottom pages\n    col *= att;\n     \n    // bottom cover\n    float book = sdBox(u, vec2(1.16, .85));\n    float corners = smoothstep(0.35, .4, abs(abs(abs(u.x)-.2) - abs(u.y)));\n    vec3  bcol = mix(vec3(0.910,0.776,0.412), vec3(0.361,0.208,0.180), corners+r1*.3-.3);\n    bcol *= smoothstep(0., .05, book + r1*.01)*.5+.4;\n    col = mix(col, bcol, smoothstep(0., .01, book + r1*.012));\n    \n    // background\n    float bg = -sdBox(u, vec2(1.23, .9)*.97);\n    vec3 bgcol = texture(iChannel1, F/R).rgb;\n    bgcol *= smoothstep(0.01, 0.1, -bg + r1*.005)*.65+.35;\n    col = mix(bgcol, col, smoothstep(0., .008, bg + r1*.005));\n            \n    O.rgb = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* Low-res version of my shader \"Aldebaran's Sanctuary\"\n   (https://www.shadertoy.com/view/cslXRs)\n   \n   Replace with any shader code ! */\n\n\n#define ALTERNATE_VIEWS 1 // Set to 0 to prevent camera from switching viewpoints\n\n#define MAX_ITERATIONS 50.\n#define MAX_DISTANCE   40.\n#define EPSILON        .001\n\n#define FBM_LAYERS  4\n#define SHADOW_FBM_LAYERS 3\n#define RELAXATION  2.\n\n#define VOLUME_STEPS    15.\n#define VOLUME_DENSITY  .8\n#define VOLUME_LIGHT    0.6\n\n#define sunCycle (sin(iTime*.4)*.5+.5)\n#define sunColor vec3(1.2,0.671,0.376)*(sunCycle*.9+.15)\n#define skyColor vec3(0.604,0.784,0.976)*(sunCycle*.9+.15)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define treeRep 24.\n\n// Value noise - https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise2( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// https://shadertoyunofficial.wordpress.com/2019/01/02/\nvec3 hash33(vec3 p) {\n    return fract(cos((p)*mat3(127.1,311.7,74.7,269.5,183.3,246.1,113.5,271.9,124.6))*43758.5453123);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// https://www.shadertoy.com/view/3ddGzn\nfloat noise3(vec3 p) {\n\tvec3 ip=floor(p), s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp-=ip; p=p*p*(3.-2.*p);\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm3(vec3 p) { \n    p += vec3(iTime*.1, iTime*.1, 0.);\n    float f = 1.0, a = 1.0,\n          t = noise3(p);\n    for(int i=1; i<5; i++) {\n        t += a*noise3(f*p);\n        f *= 2.0; a *= .5;\n    }\n    return t;\n}\n\nfloat fastnoise2(vec2 p) {\n    return (sin(p.x)-cos(p.y))*.5+.5;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCone(vec3 p) {\n    const vec2 c = vec2(0.198669, 0.980067);\n    vec2   q = vec2( length(p.xz), -p.y );\n    float  d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0) - .1;\n}\nfloat sdArc( in vec2 p, in float ra, float rb ) {\n    const vec2 sc = vec2(0.808496, -0.588501);\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\nfloat sdCircle(vec2 p, float ra, float rb) {\n    return abs(length(p) - ra) - rb;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nvec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 rad)  {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// Smarter fbm calculation - https://www.shadertoy.com/view/msXSR2\nfloat fbm(vec2 p, float h, int layers) {\n    float n = fastnoise2(p); \n    float a = 1.;\n    \n    for (int i = 0; i < layers; i++) {\n        if (h > n + a) break;\n        \n        p *= 2.; a *= .5;\n   \n        n -= a*abs(fastnoise2(p)-n);\n      \n    } \n    \n    return n;\n}\n\nfloat terrainH(vec3 p, int layers) {    \n    float mnt =  smoothstep(0., 1., -sdArc(vec2(p.z, -p.x - 4.), 6. , 1.));\n    mnt += 2.2 * smoothstep(0., 2., -sdCircle(p.xz - vec2(-4,0), 22., 5.)); \n    mnt += 4.  * smoothstep(0., 2., -sdCircle(p.xz - vec2(-4,0), 36., 5.));         \n    return fbm(p.xz*.5, p.y - mnt, layers) + mnt;\n}\n\nvec2 map(vec3 p, int layers, inout vec3 light) {\n    float l = length(p.xz);\n    // Terrain\n    float ground = 1e6;\n    if (p.y < 5.) {\n        float terrain = terrainH(p, layers);\n        ground  = p.y - terrain;\n    }\n    \n    // Trees\n    float trees = 1e6;\n    if (ground < 1.) {\n        float sm  = smoothstep(5.5, 6., l);\n        float rep = mix(treeRep, 10., sm);\n        vec3  fp  = fract(p*rep)-.5; \n        vec3  id  = floor(p*rep)+.5;\n        vec3  r   = hash32(id.xz);\n        float fh  = fbm(id.xz*.5/rep, p.y-.1, layers); \n\n        float h  = 3. + r.y*sm*.4;\n        vec3 off = vec3(1.,0.,1.)*r*.4*sm;\n        fp.y = (p.y - fh) * rep - h;\n        trees = (sdCone(fp - off) + smoothstep(.5, .9, noise2(p.xz))) / rep;  \n    }\n    \n    // Structures\n    float shape = 1e6, cables = 1e6;\n    if (l < 12.) {\n        vec3  sp  = p;\n        float an  = 6.283185 / 16.;\n        float aid = (round((atan(p.z, p.x)-an/2.)/an)*an)+an/2.;\n        vec3  rs  = hash31(aid);\n        sp.xz *= rot(-aid);\n\n        shape = sdBox(sp - vec3(8.5,0,0), vec3(.3,3.,.45));\n        float hole  = sdBox(sp - vec3(8.5,1.8,0), vec3(.35, .9, .3));\n        shape = smax(shape, -hole, .1);\n\n        float center = length(p+vec3(0,.2,0))-.35;\n        float doors = sdBox(sp + vec3(0,.2,0), vec3(.4, .25*(sin(iTime*.1)*.5+.5), .04));\n        center = smax(center, - doors, .03);\n        center = min(center, sdCylinder(sp - vec3(1,-.5,0), .04, .5+rs.z*.2 + sin(.2*iTime+aid*10.)*.06));\n        shape  = min(shape, center) - .01;\n\n        // These aren't real objects, their signed distance is always strictly positive. It's only\n        // captured in lighting as it increases the iteration count near these phantom cables.\n        sp.z = abs(sp.z);\n        cables = sdCapsule(sp, vec3(1,0,0), vec3(9,3,.4), -.01-smoothstep(0.4, 0.6, sunCycle));\n\n        // Lighting\n        vec3 lc = 0.06 * (vec3(.7,.7,1.) - rs*.2);\n        light += lc / (1. + pow(abs(hole), 1.4));\n        light += 1.5*lc * vec3(0.447,0.118,0.600) / (1. + pow(abs(center*5.), 1.4));\n        light += 1.5*lc * vec3(0.118,0.600,0.522) / (1. + pow(abs(doors*5.), 1.4));\n    }\n    \n    vec2 res = vec2(ground, 0.);\n    if (trees < res.x) res = vec2(trees, 1.);\n    if (shape < res.x) res = vec2(shape, 2.);\n    if (cables < res.x) res = vec2(cables,3.);\n    \n    return res; \n}\n\nvec3 ltmp;\nvec3 getNormal(vec3 p, float d) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy*map(p + e.xyy, FBM_LAYERS,ltmp).x + e.yyx*map(p + e.yyx, FBM_LAYERS,ltmp).x + \n\t\t\t\t\t e.yxy*map(p + e.yxy, FBM_LAYERS,ltmp).x + e.xxx*map(p + e.xxx, FBM_LAYERS,ltmp).x);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float maxt) {\n    float t = 0.1, res = 1., k = 10.;\n    for (float i = 0.; i < MAX_ITERATIONS*.7; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p, SHADOW_FBM_LAYERS,ltmp).x;\n        res = min(res, k*d/t);\n        t += d;\n        if (t > maxt) return res;\n        if (d < EPSILON) return 0.;\n    }\n    return 0.;\n}\n\nvec3 volumeColor(vec3 ro, vec3 rd, float near, float far, vec3 sunDir, vec3 col) {\n    vec3 vcol  = vec3(0.);\n    float mask = 1.;\n    float vstep = (far - near) / VOLUME_STEPS;\n    const float dh = 1./VOLUME_DENSITY;\n\n    for (float t = near, i = 0.; t <= far && i < VOLUME_STEPS; t += vstep, i++) {\n        vec3 p = ro + t*rd;\n        \n        float dens = fbm3(p/6.);\n        dens = smoothstep(dh, dh+1., dens);\n\n        float prev = mask;\n        mask *= exp(-dens * vstep * .3);\n        float absorbed = prev - mask;\n        \n        vec3 light = 1.5-vec3(smoothstep(dh, dh+.6, fbm3((p-sunDir*.1)/6.)));\n        vcol += vec3(.9,1.,.7) * sunColor * absorbed * vstep * light * VOLUME_LIGHT;          \n    }\n    \n    return col*mask + min(vcol, vec3(1.));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.z == 0. ? vec2(.5) : iMouse.xy/iResolution.xy*2.-1.; \n    float t = iTime*.1, tt = 0.;\n    ro = vec3(0., -.1 + cos(t*1.1)*.1, 3. + sin(t*1.2)*.3);\n#if ALTERNATE_VIEWS\n    tt = step(20., mod(iTime, 35.)); \n#endif\n    ro.yz *= rot(cos(t*1.15)*.05-mix(.5, .1, tt));\n    ro.zx *= rot(sin(t)*.3-mix(-1.2, 1.2, tt)); \n    vec3 f = normalize(vec3(cos(t)*.01,.5+cos(t)*.02,sin(t)*.015)-ro), r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    \n    // Scale down\n    uv *= 2.5;\n    if (abs(uv.x) > iResolution.x/iResolution.y || abs(uv.y) > 1.) {\n        O*=0.;\n        return;\n    }\n    \n    vec2 res;\n    vec3 ro, rd;\n\n    initRayOriginAndDirection(uv, ro, rd);\n    \n    bool hitWater = false;\n    float t   = 0., i;\n    vec3  p   = ro, \n        col   = skyColor, \n      light   = vec3(0.);  \n        \n    for (i = 0.; i < MAX_ITERATIONS; i++) {\n        res = map(p, hitWater ? 5 : FBM_LAYERS, light);\n        \n        if (p.y < -.33) {\n            // Reflect if ray hit water level\n            p.y += 2.*abs(p.y+.33);\n            rd.y = -rd.y;\n            rd = normalize(rd + (noise2(p.xz*80.+iTime*.2)-.5)*.06);\n            hitWater = true;\n        }\n        \n        float d = res.x > 0. ? res.x*.9 : res.x*.3;\n        t += d;\n        p += rd * d;\n\n        if (res.x < EPSILON*(1. + t*RELAXATION) || t > MAX_DISTANCE) break;\n    }\n    \n    float phi = 0.32 * 6.28, the = -0.00 * 3.14 + 1.27 + (1.-sunCycle)*.2;\n    vec3 lightDir = normalize(vec3(sin(the)*sin(phi), cos(the), sin(the)*cos(phi)));\n    \n    if (t < MAX_DISTANCE) {\n        // Hit object\n        float th = terrainH(p, FBM_LAYERS);\n        vec3  id = floor(p*treeRep)+.5;\n        vec3   r = hash32(id.xz);\n        vec3   n = getNormal(p - rd*EPSILON*4., t);\n        float sunLight    = max(.1, dot(n, lightDir));\n        float sunShadow   = max(.02, getShadow(p + n*EPSILON*4., lightDir, MAX_DISTANCE));\n        float skyLight    = max(.0, n.y);\n        float bounceLight = max(.0, dot(n, -lightDir));\n        float spec        = max(.0, dot((rd + n)/2., lightDir));\n\n        if (res.y == 0.) {\n            // Terrain\n            col = vec3(1.);\n            col *= .4+smoothstep(.55, .7, skyLight );\n            col *= .05 + 1.*sunColor * sunLight * sunShadow;\n        } else if (res.y == 1.) {\n            // Trees\n            col = mix(\n                vec3(.2,.6 + (r.y-.5)*.5,.4)*.25, \n                vec3(1.)   + (r.x-.5)*.5, \n                smoothstep(0., .13, p.y - th + t * .0) \n            );\n            col *= .25*(sunCycle+.1) + 1.*sunColor * sunLight * sunShadow;  \n        } else {\n            // Structures\n            col = 1. - texture(iChannel1, p.xy*4.).rrr*.4;\n            col *= .2 + 1.*sunColor * sunLight * sunShadow;\n        }\n        \n        col *= smoothstep(.2, .4, length(p + vec3(0,.2,0)));\n\n        col += 0.2*skyColor * skyLight;\n        col += 0.1*vec3(.4,.2,0.) * bounceLight;\n        col += 1.5*pow(spec, 4.)*sunCycle;\n    } \n    \n    // Clouds\n    vec2 hit = boxIntersection(ro - vec3(0, 8, 0), rd, vec3(200., 4., 200.));\n    if (hit.x >= 0. && hit.x < t) {\n        col = volumeColor(ro, rd, hit.x, min(hit.y, t), lightDir, col);\n        t = min(hit.x, t);\n    }\n    \n    // Water occlusion\n    if (hitWater) col *= vec3(.7,.7,.9);\n    col *= mix(0.4, 1., smoothstep(-.35, -.25, p.y));\n    \n    // Apply fog\n    vec3 fog = exp2(-t*0.07*vec3(1,1.8,4)); \n    col = mix(clamp(skyColor - vec3(1.,1.5,2.)*abs(rd.y)*.3, vec3(0.), vec3(1.)), col, fog);   \n    \n    // Color adjust\n    col = pow(col, vec3(.99,.88,.95));\n    col = smoothstep(vec3(0.04), vec3(1), col);\n    col = pow(col, vec3(.4545));\n    \n    // Night lighting\n    col += light * smoothstep(.8, 0., sunCycle);\n           \n    // Accumulate frames\n    vec3 ocol = texelFetch( iChannel0, ivec2(F-0.5), 0 ).xyz;\n    if(iFrame==0) ocol = col;\n    col = mix(ocol, col, 1./10.);\n    \n    O = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}