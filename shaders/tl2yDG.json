{
    "Shader": {
        "info": {
            "date": "1595898408",
            "description": "A procedurally generated planet.\nControls:\n    Translate: W, A, S, D\n    Rotate: Arrow Keys\n    Change velocity: hold C or V\n    Change seed: hold E or R",
            "flags": 48,
            "hasliked": 0,
            "id": "tl2yDG",
            "likes": 11,
            "name": "Procedurally generated world",
            "published": 3,
            "tags": [
                "raymarching",
                "input",
                "proceduralgeneration"
            ],
            "usePreview": 0,
            "username": "vipiao",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "vec3 test = vec3(0);\nvec3 test2 = vec3(0);\n\nfloat mountainHeightMapTexture(in vec3 pos){\n    \n    vec3 cameraPosSampleA = texelFetch(iChannel0, ivec2(CAMERA_POS_SAMPLE, 0), 0).xyz;\n    vec3 posA = pos - cameraPosSampleA;\n    float l = length(posA.xz);\n    if(l > 1.){\n    \tposA = posA/sqrt(l);\n    }\n    \n    posA = posA/MAP_WIDTH;\n    posA.z *= iResolution.x/iResolution.y;\n    posA += 0.5;\n    float heightA = texture(iChannel1, posA.xz).x;\n    \n    vec3 cameraPosSampleB = texelFetch(iChannel0, ivec2(CAMERA_POS_SAMPLE_2, 0), 0).xyz;\n    vec3 posB = pos - cameraPosSampleB;\n    l = length(posB.xz);\n    if(l > 1.){\n    \tposB = posB/sqrt(l);\n    }\n    \n    posB = posB/MAP_WIDTH;\n    posB.z *= iResolution.x/iResolution.y;\n    posB += 0.5;\n    float heightB = texture(iChannel1, posB.xz).y;\n    \n    float f = mod(iTime, TERRAIN_UPDATE_RATE)/TERRAIN_UPDATE_RATE;\n    //f = f*f*3.-f*f*f*2.; // Makes the transition smoother.\n    \n    float combined = heightB*(1.-f) + heightA*f;\n    \n    return combined;\n}\n\nfloat sdMountain(in vec3 pos){\n    vec3 flatPos = vec3(pos.x, 0., pos.z);\n    float height;\n    height = mountainHeightMap(/*in vec3 pos=*/flatPos);\n    \n\tfloat heightDiff = pos.y - height;\n    const float maxSlope = 2.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    return nextDist;\n}\n\nfloat sdMountainTexture(in vec3 pos){\n    vec3 flatPos = vec3(pos.x, 0., pos.z);\n    float height;\n    height = mountainHeightMapTexture(/*in vec3 pos=*/flatPos);\n    \n\tfloat heightDiff = pos.y - height;\n    const float maxSlope = 3.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    return nextDist;\n}\n\nvoid sdMountainNormal(in vec3 pos, inout vec3 normal, out float sd){\n\tsd = sdMountain(pos);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    float df = max(sqrt(length(cameraPos-pos)), 1.)*0.001;\n    vec2 e = vec2(df, 0.);\n    normal = normalize(sd - vec3(\n    \tsdMountain(pos - e.xyy),\n    \tsdMountain(pos - e.yxy),\n    \tsdMountain(pos - e.yyx)\n    ));\n}\n\nvoid sdMountainNormalTexture(in vec3 pos, inout vec3 normal, out float sd){\n\tsd = sdMountainTexture(pos);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    float df = max(sqrt(length(cameraPos-pos)), 1.)*0.02;\n    vec2 e = vec2(df, 0.);\n    normal = normalize(sd - vec3(\n    \tsdMountainTexture(pos - e.xyy),\n    \tsdMountainTexture(pos - e.yxy),\n    \tsdMountainTexture(pos - e.yyx)\n    ));\n}\n\nconst float WATER_HEIGHT = -7.;\nfloat waterFunction(in vec3 pos, in float time){\n\tconst int size = 6;\n    const float f = 2.;\n    const float m = 0.05;\n    const vec3 vecs[size] = vec3[](\n        vec3( f*1.,  f*2.,  m*0.2),\n        vec3(f*0.5, f*0.5,  m*0.1),\n        vec3(f*-1., f*0.2,  m*0.1),\n        vec3( f*0.,f*-0.5,  m*0.5),\n        vec3( f*2., f*-2., m*0.01),\n        vec3(f*-2.,  f*5., m*0.01)\n    );\n    float waveHeight = 0.;\n    for(int i=0; i<size; i++) {\n        // The speed of waves on water is independent on amplitude and wavelength.\n    \twaveHeight += sin(pos.x*vecs[i].x+pos.z*vecs[i].y+0.5*time*length(vecs[i].xy))*vecs[i].z;\n    }\n    return waveHeight + WATER_HEIGHT;\n}\n\nfloat sdWater(in vec3 pos){\n    const float maxWaveHeight = (.2+.1+.1+.5+.01+.01)*.05;\n    const float maxWaterHeight = maxWaveHeight + WATER_HEIGHT; // See waterFunction(.).\n    if(pos.y - maxWaterHeight > maxWaveHeight){\n    \treturn pos.y - maxWaterHeight;\n    }\n    \n    float waveHeight = waterFunction(pos, iTime);\n    \n\tfloat heightDiff = pos.y - waveHeight;\n    const float maxSlope = 1.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    return max(nextDist, pos.y-maxWaterHeight);\n}\n\nvoid sdWaterNormal(in vec3 pos, inout vec3 normal, inout float sd){\n\tsd = sdWater(pos);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    float df = max(sqrt(length(cameraPos-pos)), 1.)*0.01;\n    vec2 e = vec2(df, 0.);\n    normal = normalize(sd - vec3(\n    \tsdWater(pos - e.xyy),\n    \tsdWater(pos - e.yxy),\n    \tsdWater(pos - e.yyx)\n    ));\n}\n\n# define INTERSECTED 0\n# define TOO_FAR 1\n# define TOO_MANY_STEPS 2\nvoid marchWorld(\n    inout vec3 pos, inout vec3 dir,\n    inout float dist, in float maxDist, in float minDist,\n    inout int numSteps, in int maxNumSteps,\n    inout vec3 color, out vec3 normal, out int returnCode\n){\n    //nearest = maxDist;\n    // Setup.\n    \n    // Trace.\n    for(int i=0; i<maxNumSteps; i++) {\n        //\n        numSteps++;\n        \n        // Mountain.\n        float sdMount = sdMountainTexture(/*in vec3=*/pos); // Signed distance.\n        float sdWater = sdWater(/*in vec3 pos=*/pos);\n        \n        float sd = min(sdMount, sdWater);\n        \n        if(dist + sd > maxDist){\n        \tsd = maxDist-dist;\n            dist += sd;\n            pos += dir*sd;\n            \n            returnCode = TOO_FAR;\n        \treturn;\n        }\n        if(sd <= minDist + dist*0.0003){\n            if(sdMount < sdWater){\n                // Mountain.\n            \tsdMountainNormalTexture(/*in vec3 pos=*/pos, /*inout vec3 normal=*/normal, /*out float sd=*/sd);\n                \n                // Grass\n                color = vec3(51./255.,102./255.,41./255.);\n                \n                // Sand.\n                //color = mix(color, vec3(76./255.,70./255.,50./255.), max(1.-abs(pos.y-WATER_HEIGHT), 0.));\n                color = mix(color, vec3(153./255.,133./255.,92./255.), clamp(WATER_HEIGHT - pos.y + 2., 0., 1.));\n                \n                // Mountain.\n                color = mix(color, vec3(127./255.,127./255.,127./255.), clamp((pos.y - (1.))*0.2, 0., 1.));\n                \n                // Snow.\n                color = mix(color, vec3(255./255.,255./255.,255./255.), clamp(pos.y - 13. + normal.y*3., 0., 1.));\n                \n                returnCode = INTERSECTED;\n                return;\n            } else {\n                // Water.\n                sdWaterNormal(/*in vec3 pos=*/pos, /*inout vec3 normal=*/normal, /*inout float sd=*/sd);\n                color = vec3(0.5, 0.5, 0.5);\n                \n                if(dot(normal, dir) < 0.){\n                    dir = reflect(dir, normal);\n                    sd = max(sd, minDist*2.);\n                }\n            }\n        }\n        \n        //\n        dist += sd;\n        pos += dir*sd;\n       \t\n    }\n    returnCode = TOO_MANY_STEPS;\n    return;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Input.\n    //vec3 cameraPos = texture(iChannel0, vec2(float(CAMERA_POS)/iResolution.x, 0)).xyz;\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    //vec3 forward = normalize(texture(iChannel0, vec2(float(CAMERA_DIRECTION)/iResolution.x, 0)).xyz);\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = cross(right, forward);\n    \n    //\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    vec3 viewDir = normalize(forward + right * uv.x + up * uv.y);\n    \n    \n    //\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.;\n    float maxDist = 120.;\n    float minDist = 0.0001;\n    int numSteps = 0;\n    int maxNumSteps = 400;\n    vec3 color = vec3(0.);\n    vec3 normal;\n    int returnCode;\n\t//\n    \n    marchWorld(\n        /*inout vec3 pos=*/pos, /*inout vec3 dir=*/dir,\n        /*inout float dist=*/dist, /*in float maxDist=*/maxDist, /*in float minDist=*/minDist,\n        /*inout int numSteps=*/numSteps, /*in int maxNumSteps=*/maxNumSteps,\n        /*inout vec3 color=*/color, /*out vec3 normal=*/normal, /*out int returnCode=*/returnCode\n    );\n    \n    // Lights.\n    vec3 lightDir = normalize(vec3(10.,-1,1.));\n    \n    vec3 shaddowPos = pos-lightDir*minDist*100.;\n    vec3 shaddowDir = -lightDir;\n    float shaddowDist = 0.;\n    float shaddowMaxDist = 80.;\n    float shaddowMinDist = minDist;\n    int shaddowNumSteps = 0;\n    int shaddowMaxNumSteps = maxNumSteps/3;\n    vec3 shaddowColor = vec3(0.);\n    vec3 shaddowNormal;\n    int shaddowReturnCode;\n    float shaddowFactor;\n    if(returnCode == INTERSECTED){\n        marchWorld(\n            /*inout vec3 pos=*/shaddowPos, /*inout vec3 dir=*/shaddowDir,\n            /*inout float dist=*/shaddowDist, /*in float maxDist=*/shaddowMaxDist, /*in float minDist=*/shaddowMinDist,\n            /*inout int numSteps=*/shaddowNumSteps, /*in int maxNumSteps=*/shaddowMaxNumSteps,\n            /*inout vec3 color=*/shaddowColor, /*out vec3 normal=*/shaddowNormal, /*out int returnCode=*/shaddowReturnCode\n        );\n    \tshaddowFactor = (1.-min(1.*(shaddowMaxDist - shaddowDist), 1.));\n    } else {\n    \tshaddowFactor = 1.;\n    }\n    \n    vec3 finalViewDir = normalize(pos-camPos);\n    \n    // Ambient occlusion\n    vec3 occlusionColor = vec3(0.,0.,0.);\n    float occlusionFactor = float(numSteps)/log(dist+10.) * max(dot(-finalViewDir, normal), 0.);\n    occlusionFactor = max(1.-occlusionFactor*0.025, 0.);\n    \n    float diff = max(dot(-lightDir, normal), 0.);\n    \n    vec3 reflectDir = reflect(lightDir, normal); // reflect(I, N) = I - 2.0 * dot(N, I) * N.\n    float spec = pow(max(dot(reflectDir, -finalViewDir), 0.0), 8.);\n    \n    color = (color*diff + color*spec*0.2)*shaddowFactor + color*0.5*occlusionFactor;\n    \n    // Mist.\n    vec3 mistColor = vec3(0.5,0.6,0.9);\n    float mistFactor = max(float(numSteps)/float(maxNumSteps), float(dist)/float(maxDist));\n    color = mix(color, mistColor, mistFactor);\n    \n    // The sun.\n    float d = dist/maxDist * 2.*max(mistFactor*mistFactor*mistFactor-0.5, 0.)*min(pow(max(dot(dir, -lightDir), 0.), 1024.), 1.);\n    color = min(color + vec3(d), 1.);\n\n    // Output to screen\n    fragColor = vec4(color,0.1);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 prevColor = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    \n    // Keep track of time.\n    if(ivec2(fragCoord) == ivec2(PREVIOUS_TIME,0)){\n        float prevTimeTemp = texelFetch(iChannel1, ivec2(PREVIOUS_TIME_TEMP, 0), 0).x;\n    \tprevColor.r = prevTimeTemp;\n    }\n    if(ivec2(fragCoord) == ivec2(PREVIOUS_TIME_TEMP,0)){\n    \tprevColor.r = iTime;\n    }\n    \n    // Zoom.\n    float sensitivity = texelFetch(iChannel1, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.1;\n            prevColor.r = 0.1;\n        }\n        if(texelFetch( iChannel0, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 0.4){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel0, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.001){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel1, ivec2(CAMERA_DIRECTION, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(-1,0,0);\n    }\n    forward = normalize(forward);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = cross(right, forward);\n    if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION,0)){\n        bool arrowRight = texelFetch( iChannel0, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n        bool arrowLeft = texelFetch( iChannel0, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n        bool arrowUp = texelFetch( iChannel0, ivec2(KEY_UP,0), 0 ).x > 0.5;\n        bool arrowDown = texelFetch( iChannel0, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n        if(arrowRight){\n            forward = normalize(forward + right*0.02);\n        }\n        if(arrowLeft){\n            forward = normalize(forward - right*0.02);\n        }\n        if(arrowUp){\n            forward = normalize(forward + up*0.02);\n        }\n        if(arrowDown){\n            forward = normalize(forward - up*0.02);\n        }\n    \tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n    \tvec3 up = cross(right, forward);\n        prevColor = normalize(forward);\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel0, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel0, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel0, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel0, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel0, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel0, ivec2(KEY_S,0), 0 ).x > 0.5;\n        if(wDown){\n        \tprevColor += forward*sensitivity;\n        }\n        if(sDown){\n        \tprevColor -= forward*sensitivity;\n        }\n        if(dDown){\n        \tprevColor += right*sensitivity;\n        }\n        if(aDown){\n        \tprevColor -= right*sensitivity;\n        }\n        if(spaceDown){\n        \tprevColor += up*sensitivity;\n        }\n        if(shiftDown){\n        \tprevColor -= up*sensitivity;\n        }\n        if(iTime < 1.){\n        \tprevColor = vec3(-.5,1.-iTime,0);\n        }\n    }\n    \n    // Change seed.\n    bool eIsDown = texelFetch(iChannel0, ivec2(KEY_E,0), 0).x > 0.5;\n    bool rIsDown = texelFetch(iChannel0, ivec2(KEY_R,0), 0).x > 0.5;\n    if(ivec2(fragCoord) == ivec2(CHANGE_SEED,0)){\n        if(eIsDown){\n        \tprevColor.r += 0.1;\n        }\n        if(rIsDown){\n        \tprevColor.r -= 0.1;\n        }\n    }\n    \n    // Global variables.\n    if(ivec2(fragCoord) == ivec2(TEXTURE_UPDATE,0)){\n\t\tprevColor.r = 0.;\n    }\n    float prevTimeTemp = texelFetch(iChannel1, ivec2(PREVIOUS_TIME_TEMP, 0), 0).x;\n    if(eIsDown || rIsDown || mod(iTime, TERRAIN_UPDATE_RATE) < mod(prevTimeTemp, TERRAIN_UPDATE_RATE)){\n    \t// Once a TERRAIN_UPDATE_RATE:\n\t\tif(ivec2(fragCoord) == ivec2(CAMERA_POS_SAMPLE_2,0)){\n            prevColor = texelFetch(iChannel1, ivec2(CAMERA_POS_SAMPLE, 0), 0).xyz;\n        } else if(ivec2(fragCoord) == ivec2(CAMERA_POS_SAMPLE,0)){\n            prevColor = texelFetch(iChannel1, ivec2(CAMERA_POS, 0), 0).xyz;\n        }\n        if(ivec2(fragCoord) == ivec2(TEXTURE_UPDATE,0)){\n            prevColor.r = 1.;\n        }\n    }\n    \n    \n    \n    // Write data/color.\n    fragColor = vec4(prevColor, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// --Global variables.\n\n// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\n\n//\nconst int PREVIOUS_TIME = 0;\nconst int PREVIOUS_TIME_TEMP = 1;\n\nconst int CAMERA_POS = 2;\nconst int CAMERA_SENSITIVITY = 3;\nconst int CAMERA_DIRECTION = 4;\nconst int CHANGE_SEED = 5;\n\nconst int CAMERA_POS_SAMPLE = 6;\nconst int CAMERA_POS_SAMPLE_2 = 7;\nconst int TEXTURE_UPDATE = 8;\n\n// TerrainGen.\nconst float MAP_WIDTH = 40.;\nconst float TERRAIN_UPDATE_RATE = 1.;\n\n// --Hash function--\n/*\nInspired by Adam Smith.\nsource: https://groups.google.com/forum/#!msg/proceduralcontent/AuvxuA1xqmE/T8t88r2rfUcJ\n*/\n# define PRECISION 3\n// 2^32-1\n# define LARGEST_UINT 4294967295u\n# define LARGEST_UINT_AS_FLOAT 4294967295.\n// 2^31-1 = 2147483647\n# define LARGEST_INT 2147483647\n# define LARGEST_INT_AS_FLOAT 2147483647.\n# define SMALLEST_INT -2147483648\n# define SMALLEST_INT_AS_FLOAT -2147483648.\n// 2^32 = 4294967296\n# define LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT 4294967296.\n\nint rotate (int x, int b) {\n    return (x << b) ^ (x >> (32-b));\n}\n\nint pcg (int a) {\n    int b = a;\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a) {\n    return (float(pcg(a))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a, int b) {\n    return (float(pcg(a,b))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b, int c) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c) + (c^0xcabba6e5), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d) + (c^0x0b5e55ed), 5);\n        c = rotate((a^0x5eaf00d5) + (b^0xdecea5ed) + (c^0xba5eba11), 16);\n    }\n    // https://www.dcode.fr/words-containing\n    return a^b^c;\n}\n\nfloat pcgUnit (int a, int b, int c) {\n    return (float(pcg(a,b,c))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\n// --GPU dependent noise--\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz, vec3(12.9893, 78.233, 35.537))) * 43758.5453);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9893, 78.233))) * 43758.5453);\n}\n\n// --Noise functions--\nfloat boxNoise(vec3 pos, int seed){\n\tivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    //return mix(mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+0), pcgUnit(ind.x+1, ind.y+0, ind.z+0), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+0), pcgUnit(ind.x+1, ind.y+1, ind.z+0), u.x), u.y),\n    //           mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+1), pcgUnit(ind.x+1, ind.y+0, ind.z+1), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+1), pcgUnit(ind.x+1, ind.y+1, ind.z+1), u.x), u.y), u.z);\n    \n    // Optimized version.\n    // 15485863 and 179424673 are primes.\n    ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    return mix(mix(mix( pcgUnit(ind.x + yS.x + zS.x, seed), pcgUnit(ind.x+1 + yS.x + zS.x, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.x, seed), pcgUnit(ind.x+1 + yS.y + zS.x, seed), u.x), u.y),\n               mix(mix( pcgUnit(ind.x + yS.x + zS.y, seed), pcgUnit(ind.x+1 + yS.x + zS.y, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.y, seed), pcgUnit(ind.x+1 + yS.y + zS.y, seed), u.x), u.y), u.z);\n}\nfloat boxNoise(vec3 pos){\n    return boxNoise(pos, 0);\n}\n\nfloat layeredBoxNoise(vec3 pos, int numLayers, int seed){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * boxNoise(pos, ++seed);\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\nfloat perlinNoise(vec3 pos, int seed){\n    ivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    f = f;\n    \n    // 2038074743 and 179424673 are primes.\n    ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    \n    float nf = 2./float(0x3ff);\n    \n    int x0y0z0H = pcg(ind.x + yS.x + zS.x, seed);\n    float x0y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z0H)*nf-1.),\n            (float((0x000ffc00 & x0y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z0H) >> 20)*nf-1.)\n        ),\n        f\n    );\n    \n    int x1y0z0H = pcg(ind.x+1 + yS.x + zS.x, seed);\n    float x1y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z0H)*nf-1.),\n            (float((0x000ffc00 & x1y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z)\n    );\n    \n    int x0y1z0H = pcg(ind.x + yS.y + zS.x, seed);\n    float x0y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z0H)*nf-1.),\n            (float((0x000ffc00 & x0y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z)\n    );\n    \n    int x1y1z0H = pcg(ind.x+1 + yS.y + zS.x, seed);\n    float x1y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z0H)*nf-1.),\n            (float((0x000ffc00 & x1y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z)\n    );\n    \n    int x0y0z1H = pcg(ind.x + yS.x + zS.y, seed);\n    float x0y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z1H)*nf-1.),\n            (float((0x000ffc00 & x0y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y, f.z-1.)\n    );\n    \n    int x1y0z1H = pcg(ind.x+1 + yS.x + zS.y, seed);\n    float x1y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z1H)*nf-1.),\n            (float((0x000ffc00 & x1y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z-1.)\n    );\n    \n    int x0y1z1H = pcg(ind.x + yS.y + zS.y, seed);\n    float x0y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z1H)*nf-1.),\n            (float((0x000ffc00 & x0y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z-1.)\n    );\n    \n    int x1y1z1H = pcg(ind.x+1 + yS.y + zS.y, seed);\n    float x1y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z1H)*nf-1.),\n            (float((0x000ffc00 & x1y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z-1.)\n    );\n    \n    return mix(mix(mix( x0y0z0, x1y0z0, u.x),\n                   mix( x0y1z0, x1y1z0, u.x), u.y),\n               mix(mix( x0y0z1, x1y0z1, u.x),\n                   mix( x0y1z1, x1y1z1, u.x), u.y), u.z);\n}\n\nfloat perlinNoise(vec3 pos){\n    return perlinNoise(pos, 0);\n}\n\nfloat layeredPerlinNoise(vec3 pos, int numLayers, int seed){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * perlinNoise(pos, ++seed);\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\n// --Signed distance functions. (SDF)--\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\nvoid sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, inout float sd){\n\tsd = sdSphere(pos, center, radius);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdSphere(pos - e.xyy, center, radius),\n    \tsdSphere(pos - e.yxy, center, radius),\n    \tsdSphere(pos - e.yyx, center, radius)\n    ));\n}\n\n// --Terrain functions--\n//\nfloat mountainHeightMap(in vec3 pos){\n    \n    float noise = layeredPerlinNoise(/*vec3 pos=*/pos*0.05*0.2, /*int numLayers=*/14, /*int seed=*/30)*15.*5.;\n    \n    return noise;\n    \n    // Alternative mountain noise.\n    //vec3 shifted = vec3(\n    //    layeredPerlinNoise(/*vec3 pos=*/pos*0.005, /*int numLayers=*/12, /*int seed=*/0),\n    //    layeredPerlinNoise(/*vec3 pos=*/pos*0.005, /*int numLayers=*/12, /*int seed=*/1),\n    //    layeredPerlinNoise(/*vec3 pos=*/pos*0.005, /*int numLayers=*/12, /*int seed=*/2)\n    //);\n    //return perlinNoise(/*vec3 pos=*/pos*0.01 + shifted*5., /*int seed=*/3)*30.;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel1, ivec2(fragCoord.x, fragCoord.y), 0);\n    \n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x * MAP_WIDTH;\n    // uv.x is between -MAP_WIDTH/2 and +MAP_WIDTH/2.\n    // uv's x and y coordinates represent world x and z coordinates.\n    \n    bool textureUpdate = texelFetch(iChannel0, ivec2(TEXTURE_UPDATE, 0), 0).x > 0.5;\n    if(textureUpdate){\n        float l = length(uv);\n        if(l > 1.){\n            uv = uv*l;\n        }\n\n        vec3 cameraPosSampleA = texelFetch(iChannel0, ivec2(CAMERA_POS_SAMPLE, 0), 0).xyz;\n        float yShift = texelFetch(iChannel0, ivec2(CHANGE_SEED, 0), 0).x;\n        vec3 wcA = vec3(uv.x + cameraPosSampleA.x, yShift, uv.y + cameraPosSampleA.z);\n    \t\n        float heightA = mountainHeightMap(/*in vec3 pos=*/wcA);\n        \n    \tfragColor = vec4(heightA, prevColor.r, 0, 0);\n    } else {\n        \n        fragColor = prevColor;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}