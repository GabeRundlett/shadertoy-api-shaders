{
    "Shader": {
        "info": {
            "date": "1460826760",
            "description": "Right part of screen is correctly converted to sRGB before outputting and left part is not. More info at the top of the shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "lscSzl",
            "likes": 60,
            "name": "Gamma Correction Tutorial",
            "published": 3,
            "tags": [
                "tutorial",
                "gamma",
                "srgb"
            ],
            "usePreview": 0,
            "username": "finalman",
            "viewed": 6662
        },
        "renderpass": [
            {
                "code": "/*\n\nA common misconception among new computer graphics programmers is that RGB values are mapped\nlinearly to brightness when displayed on the screen. However, this is actually not true.\nA well calibrated computer monitor does not use the linear RGB colorspace, but instead use the\nslightly wonky sRGB colorspace. Being aware of this is key to writing good looking shaders with\nnatural shading and colors.\n\nIn sRGB higher resolution is given to darker colors with RGB values close to zero. \nThis is a good thing, since our eyes are more sensitive to differences in brighness in dark colors\nthan in bright ones. A computer monitor using linear RGB would make dark images look really shitty.\n\nIn coder terms: In sRGB myColor * 2.0 is not twice as bright as myColor, and it may even have\na different hue. \n\nShadertoy does not automatically convert colors from linear RGB to sRGB for us. We must do it\nourselves. In this shader the right part of the screen is correctly converted to sRGB before outputting,\nand the left part is not. Apart from making the picture brighter overall, it also removes some artifacts\nthat can be seen in the left part.\n\nIn the topmost pattern the three primary colors are linearly blended together. If we don't convert \nto sRGB dark fringes will be seen where two colors are blended halfway, like around the green blobs.\n\nThe bottom pattern has some very high frequency content. Here we can see a lower frequency pattern\nappearing when the color is not converted to sRGB. It looks just like aliasing, but it's actually an\nartifact of not being in the correct colorspace and wrongly expecting 0.5 to be half as bright as 1.0,\nwhen it actually comes out a lot darker than that on the screen. The right part should have a uniform\nbrightness if your monitor is correcly calibrated.\n\nWorking in sRGB all the time is a huge hassle, however. What we typically do is to write our shader\nin linear RGB and then convert it to sRGB once before writing to fragColor. Care must be taken when\nsampling textures for their color values, however. Textures are also stored in sRGB rather than linear\nRGB, so when using them in our linear RGB based shader we must convert the color value from sRGB to\nlinear RGB before using it. \n\nThis still leaves a slight problem, though, since your graphics card will perform filtering and\ninterpolation of the texture as if it was linear RGB rather than sRGB. This can be solved by informing\nOpenGL that the color space of the texture is sRGB. Having an option for this for all textures and\nbuffers (including the framebuffer) is something I personally would like to see in a future update\nof Shadertoy.\n\nIn practice, instead of using the sRGB colorspace as is, we often use a gamma curve of 2.2 as a very good\napproximation, which saves us a few cycles. Holding your mouse button down on the shader will use\ngamma 2.2 instead of sRGB. (Spoiler alert: the difference is imperceptible).\n\nHere is a lighthearted youtube video that may explain this whole thing better than I can:\n  https://www.youtube.com/watch?v=LKnqECcg6Gw\n\nAnd some further reading on Wikipedia:\n  https://en.wikipedia.org/wiki/SRGB\n  https://en.wikipedia.org/wiki/Gamma_correction\n\nHappy shading!\n\n*/\n\nconst float GAMMA = 2.2;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvec3 decodeSRGB(vec3 screenRGB)\n{\n    vec3 a = screenRGB / 12.92;\n    vec3 b = pow((screenRGB + 0.055) / 1.055, vec3(2.4));\n    vec3 c = step(vec3(0.04045), screenRGB);\n    return mix(a, b, c);\n}\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return (iMouse.z < 0.5) ? encodeSRGB(linearRGB) : gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvec3 screenToLinear(vec3 screenRGB)\n{\n    return (iMouse.z < 0.5) ? decodeSRGB(screenRGB) : gamma(screenRGB, GAMMA);\n}\n\nmat2 rotate2D(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec3 pattern1(vec2 fragCoord)\n{\n\tvec2 uv = 2.0 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec2 a = (uv * 10.0) + iTime;\n    vec2 b = (uv * 12.0) + iTime;\n    float r = clamp(sin(a.x) * cos(a.y) + 0.4, 0.0, 1.0);\n    float g = clamp(sin(b.x) * cos(b.y) * 1.2 - 0.1, 0.0, 1.0);\n    \n    return mix(mix(vec3(0,0,1), vec3(1,0,0), r), vec3(0,1,0), g);\n}\n\nvec3 pattern2(vec2 fragCoord)\n{\n    fragCoord = fragCoord - iResolution.xy * vec2(0.5, 0.25);\n    fragCoord *= rotate2D(sin(iTime) * 0.01);\n    \n    vec2 uv = fragCoord * PI * 0.99;\n    \n    return vec3((sin(uv.x) + cos(uv.y)) * 0.25 + 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    \n    if (fragCoord.y > iResolution.y * 0.5 + 2.0 && fragCoord.y < iResolution.y - 4.0)\n    {\n        color = pattern1(fragCoord);\n    }\n    else if (fragCoord.y < iResolution.y * 0.5 - 2.0 && fragCoord.y > 4.0)\n    {\n        color = pattern2(fragCoord);\n    }\n    \n    if (fragCoord.x > iResolution.x * 0.5)\n    {\n        color = linearToScreen(color);\n    }\n        \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}