{
    "Shader": {
        "info": {
            "date": "1720477828",
            "description": "WIP ( cf [url]https://en.wikipedia.org/wiki/Hex_(board_game)[/url] )\n\nblue and red must connect their respective sides.\nrestart after win.",
            "flags": 32,
            "hasliked": 0,
            "id": "4XyXWK",
            "likes": 25,
            "name": "Hex game",
            "published": 3,
            "tags": [
                "game",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 226
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O, vec2 U )\n{                   \n    coords;\n    vec2 I = floor( L ), A = abs(I),                 // triangle id\n         T = fract( L );                             // local lozange coordinates\n         \n    O*=0.;\n    O +=  smoothstep(18./R.y,0.,length(U-vec2(-8,3))-1. ) // who is playing\n         * ( T(ivec2(0)).w > 0. ? vec4(0,0,1,0) : vec4(1,0,0,0) );\n         \n    if (A.x==6. && A.y<6.) { O.r++; return; }        // margins\n    if (A.y==6. && A.x<6.) { O.b++; return; }\n    if (A.x>5. || A.y >5. ) {                        // outside\n        if (T(ivec2(12,6)).y>0.) O = vec4(1,0,0,0) * (.5+.5*sin(31.*iTime)); // red win\n        if (T(ivec2(6,12)).z>0.) O = vec4(0,0,1,0) * (.5+.5*sin(31.*iTime)); // blue win\n        return;\n    }\n    O++;                                             // background\n    T -= .5;                                         // centers \n // O -= .5* smoothstep(-12./R.y,0.,max(abs(T.x),abs(T.y))-.5); // debug\n    T *= M;                                          // back to local screen coordinates \n    O -= smoothstep(12./R.y,0.,abs(length(T)-.37) ); // show circle room\n    I += 6.;\n    float v = T(I).x;                                // read local piece\n    if (v>0.) O = mix( O, v>1. ? vec4(0,0,1,0) : vec4(1,0,0,0),\n                       smoothstep(9./R.y,-9./R.y,length(T)-.27) ); // draw piece\n    v = smoothstep(12./R.y,0.,length(T)-.37 );       // vibrates if connected to home\n    O.gb -= .4*v* fract( T(I).y /15. );\n    O.rg -= .4*v* fract( T(I).z /15. );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 3758.5453)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    ivec2 I = ivec2(U);\n    \n    if ( iFrame < 1 ) {                                   // --- init\n        O *= 0.;\n        O.x = I.x>12 || I.y>12 || abs(I-6)==ivec2(6) ? 0. // empty\n            : I.x==0 || I.x==12 ? 1.                      // red home\n            : I.y==0 || I.y==12 ? 2.                      // blue home\n            : 0.;\n         // : floor(H(u+iTime)*3.);                       // debug: random pieces\n        return;\n      }\n                                                          \n    O = T(I);                                             // --- read previous state\n\n    if (iMouse.w > 0.) {                                  // --- player clicked\n        U = iMouse.xy;\n        coords;\n        vec2 A = abs(floor(L));                           // global lozange coordinates\n        ivec2 C = ivec2( L + 6. );                        // lozange index\n        if (A.x>5. || A.y>5. ) return;\n\n        if ( I == C && O.x == 0. )                        // clicked cell & free\n            O.x = 1. + T(ivec2(0)).w;\n\n        if ( I==I-I && T(C).x == 0. )                     // was valid click: swap color\n            O.w = 1.-O.w;\n    }\n                                                          // --- update connected stamp\n    if ( abs(I-6) == ivec2(6) ) return;\n    if ( I.x==0 /*|| I.x==12*/ ) { O.y++; return; }       // increase stamp in homes\n    if ( I.y==0 /*|| I.y==12*/ ) { O.z++; return; }\n    \n    int i = int(O.x);                                     // propagates stamp to 6-connected\n    if ( i>0 ) O[i] = max( max( max(D(-1,) ,D(1,)  ), max(D(,-1),D(,1)) ),\n                           max( max(D(-1,1),D(1,-1)), O ) )[i];\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define T(I)   texelFetch(iChannel0, ivec2(I) , 0)\n#define D(x,y) texelFetch(iChannel0, ivec2(I) + ivec2(x+0,y+0), 0)\n\n#define coords                                                            \\\n    mat2 M = mat2(1,.5,0,.87);      /* transform to tilted coordinates */ \\\n    vec2 R = iResolution.xy, L;                                           \\\n         U = 6.*( 2.*U - R ) / R.y;                                       \\\n         L = U * inverse(M) +.5;    /* global lozange coordinates */\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}