{
    "Shader": {
        "info": {
            "date": "1625549177",
            "description": "Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)",
            "flags": 32,
            "hasliked": 0,
            "id": "NtXXDH",
            "likes": 15,
            "name": "sinwave audio react",
            "published": 3,
            "tags": [
                "raymarching",
                "blur",
                "radial",
                "godrays"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 684
        },
        "renderpass": [
            {
                "code": "// Fork of \"Fork Full Scene firebreath 550\" by firebreathz. https://shadertoy.com/view/NlfSRM\n// 2021-07-06 05:24:30\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 120.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(410, 2809)))*4575008.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(10.57, 0) - iTime/1000.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(50.5, 10., -0.05));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.99; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 2.92; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.001; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.5;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*0. - 10.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.5);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define WAVES 12.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 2.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 17.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 20.0), 0.4 * intensity, 1.75 * intensity) * (4.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}