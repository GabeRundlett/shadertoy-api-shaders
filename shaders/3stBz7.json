{
    "Shader": {
        "info": {
            "date": "1604685014",
            "description": "Mouse.xy blends waveleng-mixing\nCostas-Array is most equi-distributed non-0 derivatives(is pattern-free)\n\nparents:\n-[url=https://www.shadertoy.com/view/llKyWc]fft canvas[/url]\n-[url=https://www.shadertoy.com/view/Ws3BzH]Costas to weight-noise[/url] ",
            "flags": 32,
            "hasliked": 0,
            "id": "3stBz7",
            "likes": 6,
            "name": "Costas7 70.468.464.254.443.709^2",
            "published": 3,
            "tags": [
                "noise",
                "fft",
                "gradient",
                "dither",
                "poisson",
                "fourier",
                "distribution",
                "dft",
                "dft",
                "laplachian",
                "galois",
                "costasarray",
                "patternfree",
                "pqfm",
                "unniquedt"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 573
        },
        "renderpass": [
            {
                "code": "//all costasArray Code is in the commonTab.\n//Image+buffA+buffb are EXCLUSIVELY the 2d-FFT signal-instepctor.\n\n\n/*\n\nMouse.x blends etween 2 different weighting-sets\nsmall mouse.x emphasize shorter wavelengths (blueer noise) == smaller costas arrays\nlarge mouse.x emphasize longer  wavelengths (blueer noise) == larger  costas arrays\n\n(note, that i chose the shorter costas arrays poorly, resulting in diabonal bamnding, this is easily fixed)\n\n\n//self   :   https://www.shadertoy.com/view/3stBz7   Costas7\n//parent0:   https://www.shadertoy.com/view/Ws3BzH   Costas6\n//parentC:   https://www.shadertoy.com/view/llKyWc   Fourier Analysis Canvas\n//parent1:   https://www.shadertoy.com/view/tstBRr   Costas5 ?\n//parent2:   https://www.shadertoy.com/view/Wsdfzr   Costas4 ?\n//parent3:   https://www.shadertoy.com/view/tdjfzR   Costas3 ?\n\nCostas7 only differs in Costas6 in having larger costasArrays in it\nand no (diagonal mirror) symmetric ones.\nthis should fix some issues.\nbut sorting the bad from the good (in larger arrays) takes a while.\nits lists of 1000 of lines.\nand this one has the best 4 of those costasArray lines of many.\nin sizes  (239..281) (known costas arrays of prime number size only)\n\nthis uses 2 iterations (quasi recursive) costas lookups\n, to shuffle a linear offset band into a decently \"noisy\" 2d testure\nbased on a single costas array\n\nWe use 4 layers of tiles, of prime number size, to get a large LCM==LeastCommonMultiple permuted period.\n\n------- todo, implement function that takes seesaw and outputs triangleWave.\n\nby using costas arrays of the prime number sizes:\n239,241,269,281, that define 4 overlapping modulo tiles, that share no coprimes,\nwe get a permuted tile size==period of \n 239*241*269*281 \n=70.468.464.254.443.709\nthat needs 60 bits to store as unsigned int\nand thats its period over 3 domains (x,y,time)\n\nhaving 4 long costas arrays in a per pixel coded buffer is slow\nthis would be faster in a TEXTURE \nor BufferC, but then its limited to 768 pixels of preview space (or less when zoomed)\n\n\n\ni suspected, that the FFT of this would\n- look circular\n- approach something, that looks like its source (being its own semi-FFT) (as a costas arrayrepeats no differentials)\n- have NO case of a differential of 0, anywhere (therefore a STRONG SLIM black cross in the FFT exists)\n\n\n/**/\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\tThe display is as follow:\n\t\tTop left: Averaged distribution of the signal in the [0..1] range with\n\t\t\t\t  reference bars at 1/4, 1/2 and 3/4\n\n\t\tBottom left: Preview of the signal itself, coordinates are slowly moving by\n\t\t\t\t\t default, can be turned off in the Common tab\n\n\t\tTop right: First and second derivatives of a slice of the signal, to see\n\t\t\t\t   at a glance the continuity of the signal, uses horizontal (X aligned)\n\t\t\t\t   slices by default, can be switched to diagonal slices in the common tab\n\n\t\tBottom right: 2D discrete fourier transform of the input, useful to see the\n\t\t\t\t\t  signal's frequency distribution and potential anisotropy\n\n\n\t\tTo increase the size/resolution of the DFT, increase the globalSize to shrink the \n\t\tfeature size to help get a better picture over the signal's main frequqncy range\n\n\n\t\tAn interesting note regarding the noise distributions: For noises/signals with\n\t\ttoo narrow a distribution a simple smoothstep (or a more complex filter) can\n\t\tbe used as a primitive form of \"gain compression\" to flatten the distribution.\n\t\tEspecially useful when building FBM noise from narrow distributed noises \n\t\t(such as gradient noise) so that the end result isn't in a very short value range.\n*/\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.525,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        //;amp=amp+1./3.\n        //;if(amp>1.)amp-=1.\n        //;col=rainbow(amp)\n        \n            ;col=mix(vec3(amp),blackbodyLike(amp*2.-.5),vec3(.2));\n        \n        //col = vec3(amp);\n    ;}\t\n    else\n#endif\n    {\n        col = textureLod(iChannel0, q, 0.).rgb;\n        \n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    //First and second derivatives plot\n    if (fragCoord.y> SIZE && fragCoord.x > SIZE)\n    {\n        col = vec3(1);\n#ifndef DIAGONAL_DERIVATIVES \n        //Horizontal derivatives\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE),0).x;\n#else\n        //Diagonal derivative\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE+1.),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE+2.),0).x;\n#endif\n        float dr = (t0 - t1)*iResolution.x*0.00025/globalScale;\n        float dr2 = (t1 + t2 - t0*2.)*iResolution.x*0.001/globalScale;\n    \n        col.rgb = smoothstep(1.5,.0, abs(dr*SIZE-fragCoord.y + SIZE + 35.))*vec3(1.0,0.7,0.3);\n        col.rgb += smoothstep(1.5,.0, abs(dr2*SIZE-fragCoord.y + SIZE + 10.))*vec3(0.5,0.7,1);\n    \n    }\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//set to  iResolution.x/2.\n//#define lazyGradient 350.\n\n//smaller number for faster palette-animation\n//a gre3yscale pallete, the size of each period\n//, cycle-animates every Nth frame\n// 1 => 1-palette-loop-steps per  1 frame\n// 2 => 1-palette-loop-steps per  2 frames\n//30 => 1-palette-loop-steps per 30 frames\n#define FramesPerPaletteAnimation 1\n\n\n//if(mouse is up) simulate a mouse on autopilot, that moves around at this speed.\n//values larger than 0 will automatically explore different period-blends\n#define AutopilotSpeed 0.\n\n//this uses 7 costas arrays of prime-sizes\n// 241,239,281,269,19,17,13  (the LCM is 1.8e+13 decimals long)\n// 4 large and 3 small prime are a pretty BAD mix here, lacks in-betweens\n//choise made in favor of having \n//, short periods for bluer-noise AND larger primes for longer periods\n//, and do contrast between long and hsort periods more\n\n//a simple lesosn here is;\n//the smallest-used-primes must be further away\n//from each other than minimally possible, or you just amplify emergent-patterns (small coprimes are noticably too small)\n\n\n#define v0 float\n#define v2 vec3 \n#define pi acos(-1.)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.) \n#define ab012(a,b)(a+b*v2(0,1,2))  //desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nv2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nv2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbowt(v0 a){return rainbowt(a,1./3.);}\n\nvec3 blackbodyLike(float T){\n ;vec3 c=rainbow(((((2.-T)/pi)*pi)-.5)/2.+1./6.,1./6.)\n //;c=c/max(c.r,max(c.g,c.b))*u5(((c.g)/(c.r+c.b)))//optional norm\n ;return c;\n}\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.5)*2.)\n\nconst float globalScale = 1.;\n\n//end of signal inspector (global parameters)\n//\n//start of costas array:\n\n/*\n//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animarteable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n/**/\n\n#define arrLen 7\n\n\n/*  //simpler idea outdated\nfloat mixArrayFloat[](int a[7],int b[7],float c,int l){\n    for(i=0;i<l;i++)\n      a[i]=mix(a[i],b[i],c);\n    }return a;}\n*/      \n\n//gpo() returns sizes of used tiles (of costas arrays in them) by index a.\n//this is also a list of used frequencies in terms of how blue your noise is.\n//values share no prime factors to maximize the permuted period\nint gpo(int a){int b[arrLen]=int[7](241,239,281,269,19,17,13);return b[a];}\n\n//costas arrays of tile sizes\nint getCostasOf(int a,int p){//return costas at Position of Array#\n bool r=false;\n if(a<4){\n  if(a<2){\n   if(a==0){\n          int c[]=int[241](1,38,3,156,46,114,231,141,9,155,15,226,55,39,138,205,60,100,161,203,209,186,160,181,66,8,27,71,233,223,170,169,45,25,184,194,78,173,165,196,120,117,102,57,172,69,159,131,76,108,180,236,145,58,163,157,241,73,179,125,127,214,143,225,175,74,28,140,238,166,201,59,204,232,198,124,49,24,6,17,81,52,77,213,99,149,215,62,22,185,218,89,26,146,34,23,106,240,135,105,123,75,90,136,68,122,2,98,33,182,234,210,116,35,30,202,11,70,10,104,121,37,118,111,227,109,112,50,64,91,48,171,197,195,32,85,206,207,94,12,235,150,113,151,192,42,228,31,86,82,144,44,56,29,115,224,107,154,193,101,63,174,96,47,5,13,20,229,134,164,239,137,142,219,40,19,53,36,129,133,221,152,139,208,67,158,97,167,187,211,88,191,92,80,41,126,162,222,200,148,84,93,237,178,16,65,230,4,199,14,190,176,119,132,21,177,168,216,128,87,43,212,103,217,110,188,54,130,79,183,147,220,7,72,95,153,18,61,83,51,189\t);if(r)return c[(241-p)%241];return c[p%241];\t//\t76\t\tgood very\n       ;}else{\n      int c[]=int[239](4,151,89,144,236,156,6,229,193,21,65,56,227,101,226,28,201,105,207,154,125,17,185,167,7,100,11,96,106,163,121,122,135,130,64,18,221,90,198,40,73,199,37,212,83,149,141,19,98,146,202,132,107,23,60,172,42,208,225,215,219,119,131,171,168,214,45,150,170,230,138,145,234,61,134,33,210,186,159,213,237,161,27,43,51,114,142,81,239,22,41,224,129,118,194,116,197,157,5,26,232,231,216,110,162,189,36,3,53,203,191,47,72,86,180,209,160,55,178,10,147,233,67,85,25,140,95,39,152,133,192,111,113,235,177,94,169,153,123,126,74,195,204,92,139,32,12,76,102,52,238,49,79,20,166,127,80,183,228,173,88,84,77,109,179,75,217,97,59,120,29,218,82,220,143,115,44,1,70,35,14,206,9,108,205,137,190,184,223,136,57,187,38,15,158,16,50,181,24,200,87,188,48,54,69,104,78,34,2,13,165,124,8,66,182,71,58,99,176,174,196,63,128,164,91,175,30,68,46,211,112,117,103,222,31,148,62,93,155\t);if(r)return c[(239-p)%239];return c[p%239];\t//\t47\t\tgood very\n  ;}}else{\n   if(a==2){\n           int c[]=int[281](108,277,20,24,177,157,241,58,204,270,106,59,30,265,127,84,208,140,86,143,130,128,193,203,161,111,38,5,87,252,125,149,218,98,36,70,97,210,75,76,185,180,201,226,121,279,238,14,219,207,31,91,122,105,233,35,244,102,189,50,181,27,221,142,21,133,172,178,266,236,79,229,165,264,18,89,187,115,191,268,171,69,271,215,54,51,7,22,242,167,199,8,131,237,188,224,186,6,196,247,146,174,113,256,278,129,19,198,182,136,216,163,46,28,47,137,42,158,67,53,225,12,1,217,272,41,49,72,32,200,117,126,258,213,119,61,248,255,169,134,281,173,4,261,257,104,124,40,223,77,11,175,222,251,16,154,197,73,141,195,138,151,153,88,78,120,170,243,276,194,29,156,132,63,183,245,211,184,71,206,205,96,101,80,55,160,2,43,267,62,74,250,190,159,176,48,246,37,179,92,231,100,254,60,139,260,148,109,103,15,45,202,52,116,17,263,192,94,166,90,13,110,212,10,66,227,230,274,259,39,114,82,273,150,44,93,57,95,275,85,34,135,107,168,25,3,152,262,83,99,145,65,118,235,253,234,144,239,123,214,228,56,269,280,64,9,240,232,209,249,81,164,155,23,68,162,220,33,26,112,147\t);if(r)return c[(281-p)%281];return c[p%281];\t//\t1121\te\tgood, very good\n           ;}else{\n          int c[]=int[269](77,170,158,48,161,199,10,258,227,75,209,203,165,187,151,11,207,94,79,110,175,255,248,3,98,17,109,67,12,253,40,27,212,154,193,141,223,167,168,159,69,18,192,174,225,127,190,237,123,264,13,80,202,90,222,172,246,83,82,143,213,72,140,112,107,121,208,39,247,37,198,33,183,21,244,53,96,131,144,14,134,15,1,118,245,243,197,130,201,108,8,200,76,19,25,230,250,259,180,229,97,218,221,265,220,228,89,62,241,171,66,78,215,236,269,135,191,188,84,267,142,211,256,59,145,74,57,38,232,239,92,20,224,266,182,93,148,41,210,184,4,177,23,137,35,46,70,122,150,102,16,217,47,88,49,113,189,149,234,166,63,251,105,71,160,32,85,179,155,114,162,68,156,233,125,216,100,51,226,153,73,99,263,136,235,205,185,26,242,219,176,260,52,106,124,268,257,204,196,132,169,58,54,64,147,249,104,133,101,128,164,262,252,5,152,117,56,31,61,139,95,36,86,120,45,91,206,129,7,194,30,126,9,24,173,231,116,28,138,178,34,186,55,60,238,240,42,146,163,195,261,103,43,214,181,44,119,254,87,50,29,157,6,22,81,65,2,111,115\t);if(r)return c[(269-p)%269];return c[p%269];\t//\t678\t\tgood very\n ;}}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);if(r)return c[(19-p)%19];return c[p%197];}//is too symmetrical\n   if(a==5){\n       int c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n    }else {int c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n//more best ofs (alternative arrays)\n/*\tint c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n/*\tint c[]=int[11](0,4,10,7,8,2,1,9,5,3,6);if(r)return c[(11-p)%11];return c[p%11];\t//\t57\t\tgood very\n/*\tint c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n/*\tint c[]=int[ 7](1,4,5,3,0,6,2);if(r)return c[(7-p)%7];return c[p%7];\t//\t22\t\tgood very\n/*\tint c[]=int[ 5](1,2,4,0,3);if(r)return c[(5-p)%5];return c[p%5];\t//\t4 good\n/**/\n;}}}\n\n\n//cs() does 2 iterations over getCostasOf()\n//a 1d costas array (==list) is usually shown as square of binary tiles.\n//but i need a 2d heightmap and not a 1d heightmap.\n//but a 2d costasArray (for a 2d heightmap) is useless here\n//(because it has elements that are NaN (==mod(a,0) )\n//because 3d costas arrays are MUCH trickier to calculate (and usually kept secret)\n//we instead do 2 iterations over a 1d costasArray, to get a PSEUDO-2d-costasArray\nint Cs(ivec2 u,int a,int iFrame){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //integer modulo (tile to positive infinity)\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r=(r+iFrame/FramesPerPaletteAnimation)%(per); //iFrame for color-paletter-cycling\n ;return r;}\n\n\n//biased mixing of multiple modulo tiles (that are set by Cs(parameter) )\nvec4 CostasNoise(ivec2 u,int iFrame,vec4 m){\n ;u/=2\n ;float r=0.;\n //last 3 entries are better set to 0, they are very small and too symmetrical costas arrays (cause diagonal bands)\n //;float f[]=float[7](1.,0.,0.,0.,0.,0.,0.)//singleton    \n ;float f[]=float[7](1.,1.,1.,1.,1.,1.,1.)//flat (strong banding)\n //;float f[]=float[7](4.,3.,2.,1.,0.,0.,0.)//valley\n;float blue[]=float[7](1.,2.,4.,8.,16.,32.,64.)//blue (most banding?)\n //;float f[]=float[7](1.,2.,2.,1.,0.,0.,0.)//windowed \n ;float yellow[]=float[7](64.,32.,16.,8.,4.,2.,1.)//anti-blue /least banding)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n ;m=clamp(m,0.,1.)\n \n ;for(int i=0;i<7;i++){\n      blue[i]=mix(blue[i],yellow[i],m.x);//mix blue and yellow over mouse.x\n }    \n;for(int i=0;i<7;i++){\n      f[i]=mix(blue[i],f[i],m.y);//mix to flat==grainier over m.y\n      //flatter is worse for longer periods\n      //flatter looks better for longer periods\n      //flatter hides the repetive-tiling of short periods more.\n      //flatter looks smoother, while still having local peaks.\n      //flatter looks more repetitive, the longer the mixed periods are.\n\n }\n ;r+=float(Cs(u,0,iFrame))/float(gpo(0))*f[0];\n ;r+=float(Cs(u,2,iFrame))/float(gpo(2))*f[2];\n ;u=u.yx//addition, to make half of the arrays diagonally flipped\n ;r+=float(Cs(u,1,iFrame))/float(gpo(1))*f[1];\n ;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[3];\n //large above, small below\n ;r+=float(Cs(u,4,iFrame))/float(gpo(4))*f[4];    \n ;u=u.yx//addition, to make half of the arrays diagonally flipped\n ;r+=float(Cs(u,5,iFrame))/float(gpo(5))*f[5];\n ;r+=float(Cs(u,6,iFrame))/float(gpo(6))*f[6]; \n    \n ;float a=r/(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])//divide by sum of weights\n #ifdef lazyGradient\n ;a-=float(u.x)/lazyGradient\n #endif\n;return vec4(a,a,a,1);\n}\n\nfloat wrap(vec2 u,int iFrame,float iTime,vec4 m){//O=getCostasOfFloat(u);\n ;if(m.z<=0.){m.y=0.;m.x=cos(iTime*AutopilotSpeed)*.5+.5;}//autopilot-mouse\n ;//u*=2.2\n ;u/=2.5 //hacky zoom to nicely match the 2d FourierTransform\n //;float g=(sqrt(5.)*.5+.5)\n //;float speed=.00003 //to move uv-.xy  of noise move noise over time\n //;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //while its color palette cycles.\n ;ivec2 scroll=ivec2(0); //to move uv-.xy  of noise move noise over time\n ;//ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;return CostasNoise(ivec2(u)+scroll,iFrame,m).x;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n#ifdef SCROLL_COORDS\n    p += vec2(1,1.5)*iTime*0.03;\n#endif\n    \n    if (fragCoord.y > SIZE)        p*=0.75;\n    \n    vec3 col = vec3(0);\n        \n    col= vec3(wrap(p*iResolution.y*2.5,iFrame,iTime,iMouse/iResolution.xyxy));\n\n    //;col=mix(vec3(col),blackbodyLike(col.x*2.5),vec3(.3));\n    //col=rainbow(col.x);\n    \n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}