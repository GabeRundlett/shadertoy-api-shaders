{
    "Shader": {
        "info": {
            "date": "1645879134",
            "description": "3dversion of my basic shape cat~!",
            "flags": 0,
            "hasliked": 0,
            "id": "fdjfzw",
            "likes": 7,
            "name": "odos|C-A-T",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "ErinZ",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "#define TMIN 0.01\n#define TMAX 200.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.1415926\n\n#define S(v,r) smoothstep( r, r+ 3./iResolution.y, v )\nfloat logo(vec2 uv);\n\n//========SDFunctions========\nfloat sdSphere(vec3 p, vec3 o, float r){\n    return length(p-o)-r;\n}\nfloat sdCapsule(vec3 p,vec3 a, vec3 b,float r){\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);\n    vec3 c = a +t*ab;\n    return length(p-c)-r;\n}\n//https:iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n//===============TRANSFORM=================\nmat2 rotate(float a){\nreturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nfloat smUni( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n//===============RENDER===================\n//Scene\nfloat f(vec3 p){\n    p.x=abs(p.x);\n    float d;\n    {//face\n    vec3 p0 = vec3(p.x*.8,p.y+.4,p.z);\n    d = sdSphere(p0,vec3(0),1.5); \n    p0 = vec3(p.x*.6,p.y+.6,p.z+.7);\n    float d0 = sdSphere(p0,vec3(0),1.);\n    d = smUni(d,d0,.3);\n    }\n    float angle = sin(iTime*5.)*.1;\n    {//ear\n    vec3 p0 = vec3(p.x-.85,p.y-.3,p.z*1.2+.3);\n    p0.xy *= rotate(-.3);\n    p0.yz *= rotate(-.3);\n    float d0 = sdRoundCone(p0,.8,.2,1.2)/1.2; \n    d = smUni(d,d0,.3);\n    }\n    {//nose\n    float d0 = sdCapsule(p,vec3(0,0,-1.5),vec3(0,-.6,-1.7),.3); \n    d = smUni(d,d0,.05);\n    }\n    {//nose\n    float d0 = sdSphere(p,vec3(.3,-.6,-1.65),.45); \n    d = smUni(d,d0,.05);\n    }\n    {//eye\n    vec3 p0 = vec3(p.x-.6,p.y+.1,p.z+1.45);\n    p0.xy *= rotate(-1.2);\n    p0.yz *= rotate(-0.3);\n    float d0 = sdRoundCone(p0,.06,.08,.2); \n    d = smUni(d,d0,.05);\n    }\n    {//\n    vec3 p0 = vec3(p.x-.9,p.y+.5,p.z+1.3);\n    p0.xy *= rotate(.2+angle*.5);\n    float d0 = sdCapsule(p0,vec3(0,0,0),vec3(.8,0,0),.1);\n    p0.xy *= rotate(-.4+angle*.5);\n    d0 = smUni(d0,sdCapsule(p0,vec3(0,0,0),vec3(.8,0,0),.1),.05);\n    d = smUni(d,d0,.05);\n    }\n    return d;\n}\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n    float t = TMIN;\n    for(int i = 0; i < RAYMARCH_TIME ; i++) {\n        vec3 p = ro + t * rd;\n        float d = f(p);\n        t += d;\n        if(d < PRECISION || t > TMAX)\n            break;\n    }\n    return t;\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * f(p + k.xyy * h) +\n        k.yyx * f(p + k.yyx * h) +\n        k.yxy * f(p + k.yxy * h) +\n        k.xxx * f(p + k.xxx * h));\n}\n\nmat3 setCamera(in vec3 camtar, in vec3 campos, in float camro){\n    vec3 z = normalize(camtar-campos);\n    vec3 cp = vec3(sin(camro),cos(camro),0.);\n    vec3 x = normalize(cross(cp,z));\n    vec3 y = cross(z,x);\n    return mat3(x,y,z);\n}\nvec3 render(vec2 uv){\n    vec3 lightPos = vec3(-5., 5.,-5);//light\n\n    //SET Camera\n    vec3 cam_tar = vec3(0,-.5,0);//cam target\n    float angle = pow(sin(iTime+.3),3.)*.5;\n    vec3 cam_pos = vec3(sin(angle),0,-cos(angle))*10.;//cam position\n\n    vec3 rd = vec3(uv,4.); //decide view width\n    if(iMouse.x!=0. || iMouse.y!=0. ){\n        float angle_x = -(iMouse.x /iResolution.x-0.5)  *0.5*PI;\n        float angle_y = (iMouse.y /iResolution.y-0.5)  *0.5*PI;\n        rd.yz *= rotate(angle_y);\n        rd.zx *= rotate(angle_x);}\n    rd = normalize(setCamera(cam_tar,cam_pos,0.)*rd);//viewing frustum\n\n    float t = rayMarch(cam_pos,rd);//raymarching\n    \n    vec3 color = mix(vec3(0,0,1),vec3(0,0,.6),uv.y*.5+.5);//background\n\n    if(t > TMAX) return color; \n    \n    vec3 p = cam_pos + t*rd;\n    vec3 n = calcNormal(p);\n    vec3 l = normalize(lightPos-p);//lightDir\n    vec3 h = normalize(l-rd);//\n\n    vec3 diffusecol = vec3(1.);//diffuse color\n    vec3 specol = vec3(1.);//specular color\n    vec3 cmrfl = .5*vec3(1)*textureLod(iChannel0,reflect(rd,n),1.).rgb;//cubemap reflection\n    \n    float dif = clamp(dot(l,n),0.,1.);//diffuse    \n    float spe = pow(clamp(dot(h,n),0.,1.),50.);//specular\n    float fresnel = pow(clamp(1. - dot(n,-rd),0.,1.),5.);\n\n    color = cmrfl + .1*dif*diffusecol + smoothstep(.6,1.,spe)*specol;//metal\n    color = smoothstep(0.,1.,color);//add contrast\n\n    color += fresnel*.4;\n    \n    return color;\n}\nvec2 getuv(vec2 coord){\n    return (2.*coord-iResolution.xy)/iResolution.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.);\n    #if AA>1\n    for(int m = 0; m < AA; m++) {\n        for(int n = 0; n < AA; n++) {\n            vec2 offset = 2. * (vec2(float(m), float(n)) / float(AA) - .5);\n            vec2 uv = getuv(fragCoord + offset);\n    #else\n            uv = getuv(fragCoord);\n    #endif\n            color += render(uv);\n    #if AA>1\n        }\n    }\n    color /= float(AA*AA);\n    #endif\n\n \n    color = mix(color,vec3(1),logo(uv));\n    fragColor = vec4(color,1.0);\n}\n\n \nfloat logo(vec2 uv){\nfloat n = 0.;\nn += S(.05,abs(length(uv-vec2(-1.23,0))-.12));\nn *= 1.-S(-1.25,uv.x);\nn += S(.17,abs(uv.y))*S(.05,abs(uv.x+1.29));\nn += S(.05,abs(length(uv-vec2(-1.5,0))-.12));\nn += S(.05,abs(length(uv-vec2(-0.9,0))-.12));\nn += (1.+S(-.6,uv.x)-S(.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,.03))-.09));\nn += (1.-S(-.6,uv.x)+S(-.05,uv.y))*S(.05,abs(length(uv-vec2(-0.6,-.04))-.09));\nreturn n;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}