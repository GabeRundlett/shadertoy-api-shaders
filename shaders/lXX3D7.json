{
    "Shader": {
        "info": {
            "date": "1707539594",
            "description": "A test of an animation",
            "flags": 0,
            "hasliked": 0,
            "id": "lXX3D7",
            "likes": 1,
            "name": "Radiating rect",
            "published": 3,
            "tags": [
                "sdf",
                "rectangle"
            ],
            "usePreview": 0,
            "username": "cacheflowe",
            "viewed": 132
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////\n// started from rounded rect SDF example: \n// - https://www.shadertoy.com/view/Nlc3zf\n// by @cacheflowe - do what you want with this code!\n// - Latest @ https://www.shadertoy.com/view/lXX3D7\n////////////////////////////////////////////////////////////////////\n\n#define PI  3.14159\n#define TAU 6.28318\n\nconst vec2 boxSizeOrig = vec2(0.35, 0.3);\nconst vec2 centerStart = vec2(0., -0.2);\nconst vec3 baseColor = vec3(1.);\nconst float cornerRadius = 0.1;\nconst float scaleStart = -1.;\nconst float scaleEnd = 10.;\nconst float thickOscStart = 0.1;\nconst float thickOscEnd = 2.;\nconst float curProgress = -1.; \n\n////////////////////////////////////////////////////////////////////\n// shapes\n////////////////////////////////////////////////////////////////////\n\nfloat box(vec2 position, vec2 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0) - cornerRadius;\n}\n\n////////////////////////////////////////////////////////////////////\n// curve helpers\n////////////////////////////////////////////////////////////////////\n\n\nfloat remap(float value, float low1, float high1, float low2, float high2) {\n   return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat circularIn(float t) {\n  return 1.0 - sqrt(1.0 - t * t);\n}\n\nfloat quintIn(float t) {\n  return t * t * t * t * t;\n}\n\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ////////////////////////////////////////////////////////////////////\n    // context & position\n    ////////////////////////////////////////////////////////////////////\n\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float aspect = iResolution.y / iResolution.x;\n\n    ////////////////////////////////////////////////////////////////////\n    // animation progress\n    ////////////////////////////////////////////////////////////////////\n\n    float progress = (curProgress == -1.) ?\n        mod(iTime/4., 1.) : // automate if not set by uniform\n        curProgress;\n    \n    ////////////////////////////////////////////////////////////////////\n    // move to center from initial offset\n    ////////////////////////////////////////////////////////////////////\n        \n    position += mix(centerStart, vec2(0.), quintIn(progress));\n\n    ////////////////////////////////////////////////////////////////////\n    // box size w/scaling\n    ////////////////////////////////////////////////////////////////////\n    \n    vec3 edgeColor = baseColor;\n    vec3 color = baseColor;\n    float rectScale = remap(progress, 0., 1., scaleStart, scaleEnd);\n    vec2 boxSize = boxSizeOrig * rectScale;\n\tfloat d = box(position, boxSize, cornerRadius);\n\n    ////////////////////////////////////////////////////////////////////\n    // thickness animation\n    ////////////////////////////////////////////////////////////////////\n    \n    // sine thickness amp\n    float thickOsc = sin(quadraticInOut(progress) * PI);     // scale up and back down on a sine curve, but ease-in-out the speed through the curve\n    float thickOscMap = remap(thickOsc, 0., 1., thickOscStart, thickOscEnd); // remap from normalized number to thickness range\n    \n    // linear thickness ramp\n    float thickRamp = remap(progress, 0., 1., 2.5, 1.);     \n    float thickRampPow = pow(progress, thickRamp) * 4.;\n    \n    // mix the two approaches. this gives us nice falloff at the end of the animation\n    float thickness = mix(thickRampPow, thickOscMap, quintIn(progress));\n    // thickness = thickRampPow;\n\n    ////////////////////////////////////////////////////////////////////\n    // animate gradient - magic numbers here\n    ////////////////////////////////////////////////////////////////////\n    \n    float gradientRamp = remap(progress, 0., 1., 1., 1.8); // start / end gradient. lower number is more gradient\n    float gradientSub = remap(progress, 0., 1., -3., -1.);\n\n\n    ////////////////////////////////////////////////////////////////////\n    // final calculation - box & gradient falloff\n    ////////////////////////////////////////////////////////////////////\n    color -= gradientRamp - exp(gradientSub * abs(d)); // gradient\n    color = mix(color, edgeColor, 1.0 - smoothstep(0.0, thickness, (abs(d) - 0.001))); // aa\n    fragColor = vec4(color, color.r);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}