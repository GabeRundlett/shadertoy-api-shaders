{
    "Shader": {
        "info": {
            "date": "1595097955",
            "description": "drag mouse for quaternion rotation\narrow keys to accellerate and roll\nsee image tab\n\ni tried rotations and AABVs, and rotations failed.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "wlSyzd",
            "likes": 8,
            "name": "quadratic bezier triangle 2 AABV",
            "published": 3,
            "tags": [
                "bezier",
                "camera",
                "bspline",
                "fly",
                "aabv",
                "bpatch"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "//drag mouse for quaternion rotation\n//arrow keys to accellerate and roll\n\n//grandparent bezierPatch  : https://www.shadertoy.com/view/XsjSDt\n//grandparent flyQuaternion: https://www.shadertoy.com/view/MldczM\n//parent                   : https://www.shadertoy.com/view/ttjSzw\n//self                     : https://www.shadertoy.com/view/wlSyzd\n\n//A triangular cubic bezier patch, bound by 6 CV-heights, \n//is tranceable analytically with good performance and precision\n//for no good reason i never bothered to fix the camera of /XsjSDt, till now\n//and i notice that this shader sucks if the camera is inside the bezier-triangle-prism.\n\n//it works fine, as long as the patch is not too planar\n//any near-planar bezierPatch has a too small determinant which diminishes precision too much.\n//the first few milliseconds of this demo are near-planar\n\n//it works fine as long as the camera is not inside the bounding-prism (incl min&&max height) \n//of the bezier patch\n\n//But if the camera is inside the bezierPrism, the roots are in the wrong order. \n//and it seems to treat roots behind the camera as if they are infront of the camera??\n\n//BUT it always renders 2 patches, and their distance to each other is the distance of the camera to vec3(0)\n//, as if they are mirror images.\n//and they intersect when the camera is close to it.\n//, and they appear to swap places when you move over one of them.\n//and then you may confuse it for its mirror image.\n//unless you have the original inside its AABV\n\n//the open question here is, how to remove the mirror image solution?\n\nvoid mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA and common",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n#define dd(a)dot(a,a)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(v1(-a.y,a.x),b)\nv0 suv(v1 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nv3 minx(v3 a,v3 b){return mix(b,a,step(a.x,b.x));}//return the v3 with the smaller .x\n\nv0 suv(v2 a){return a.x+a.y+a.z;}\nv0 ad(v1 a){return a.x+a.y;}\nv0 mu(v1 a){return a.x*a.y;} \n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n//#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n//#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\n//v1   skew(v1 u){return u+ad(u)*ske;}\n//v1 unskew(v1 u){return u-ad(u)*reSke;}\nv0 det2d(v1 a,v1 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))-=perpendicular dotproduct\n\n//Cartesian to barycentric(relative to spline verts)\nv2 CartToBary(v1 c,v1 p1,v1 p2,v1 p3\n){c-=p1;v1 a=p2-p1,b=p3-p1,d=v1(dot(c,b),dot(c,a))\n ;v2 r=v2(dd(a),dd(b),dot(a,b))\n ;r=v2(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx)\n ;return v2(1.-r.y-r.z,r.yz);}\n\nv0 board(v2 p){p=floor(p*2.);return mod(p.x+p.y+p.z,2.);}\nv0 board(v1 p){p=floor(p*2.);return mod(p.x+p.y,2.);}\n//https://www.shadertoy.com/view/4lySzc\n\nmat3 opop(v2 a,v2 b){return outerProduct(a,v2(1))\n                           +outerProduct(  v2(1),b);}\nmat3 pqfmA(){return opop((v2(2,7,5)),sqrt(v2(13,21,17)));}\n//matrix of quadratic fields with unique prime factors to maximize period length\n//also has the neat effect of all starting at null, which tends to be (near) a special (coplanar) case\n// that we can then skip over and safely assert to not reorrur anytime soon.\n\n//quaternions q()<->creation r()<->rotaition\n//use like matrix multiplication, see https://www.shadertoy.com/view/lstSRM\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\nv3 qid(){return v3(0,0,0,1);}//NULL_ROTATION\nv3 qinv(v3 q){return v3(-q.xyz,q.w)/dd(q);}//inverse quaternion\nv3 q(v2 o){o*=0.5;v2 s=sin(o),c=cos(o) //quaternion from pitch,yaw,roll (in that order):\n          ;return v3(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\nv3 q(v3 q){return q/dd(q);} //normalize quaternion (may be needed after every 5th rotation)\n//return quaternin of [axis]&{angle] rotation\nv3 q(v2 axis, v0 angle){angle*=.5;return v3(axis*sin(angle),cos(angle));}\n//return [r]rotation, rotated by [b]\nv3 r(v3 b,v3 r){return v3(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz));}\n//return [v]vector, rotated by [b] around v2(0)\nv2 r(v3 b,v2 v){v2 t=2.*cross(b.xyz, v);return v+b.w*t+cross(b.xyz,t);}//return r(q,r(v3(v,.0),qinv(q))).xyz\n//return p, rotated by b, AROUND c (center) instead of around v2(0) (offset rotation)\nv2 r(v3 b,v2 p,v2 c){return r(b,p+c)-c;}\n//return shortest rotation fro+\n//get rotation from a to b (around v2(0), has higher precision for small angles: Written by Moon Metty, optimized by Strife Onizuka\nv3 RotBetween(v2 a,v2 b\n){v0 aabb=sqrt(dd(a)*dd(b))//product of the lengths of the arguments\n ;if(aabb!=0.\n ){v0 ab=dot(a,b)/aabb// normalized dotproduct of the arguments (cosine)\n  ;v2 c=v2((a.y*b.z-a.z*b.y),(a.z*b.x-a.x*b.z),(a.x*b.y-a.y*b.x))/aabb//normalized crossproduct of the arguments\n  ;v0 cc=dd(c)//squared length of normalized crossproduct (sine)\n  ;if (cc!=0.//test if arguments are not (anti)parallel\n  ){v0 s\n   ;if(ab>-.707107)s=1.+ab   //use the cosine, or...\n   ;else s=cc/(1.+sqrt(1.-cc))//use the sine   to adjust the s-element\n   ;v0 m=sqrt(cc+s*s)//magnitude of the quaternion\n   ;return v3(c,s)/m  //return normalized quaternion\n  ;}if(ab>0.)return v3(0,0,0,1);//arguments are parallel, or anti-parallel if not true: ZERO_ROTATION\n  ;v0 m=length(a.xy)//sqrt(a.x*a.x+a.y*a.y)//length of one argument projected on the XY-plane\n  ;if(m!=0.)return v3(a.y,-a.x,0,0)/m //return rotation with axis in the XY-plane\n  ;return v3(1,0,0,0);// arguments are parallel to Z-axis,rotate around the X-axis\n ;}return v3(0,0,0,1);}//arguments too small,ZERO_ROTATIO\n/*\nv3 q2aa(v3 q){return v3(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\nv3 qlookat(v2 v){return aa2q(v2(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nv2 vmulq(v2 p, v3 q){return qmulq(qinv(q),qmulq(v3(p,0.0),q)).xyz;}//inverse rotation\nv3 qslerp(v3 q1, v3 q2, v0 f){\n\tv0 d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost);}/**/\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\nv2 triangleNornal(v2 a,v2 b,v2 c){return cross(a-b,a-c);}//normal of triangle of 3 pointsi is cross() of any 2 sides.\n\n//LineSegmentAB+RayUD intersection\nv1 LineISect(v1 a,v1 b,v1 u,v1 d\n){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)\n ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))\n ;if(u.y==0.)return v1(0)//parralel lines do not intersect.\n ;c*=v3(u.xx,vec2(dot(c.xy,a)))\n ;return (c.wx-c.yz)/u.y;}\n\n/* //explicit version for compatibility where bvec4 is not a defined type.\nbool altm(v1 a,v3 b){\n ;v3 c=v3(a,b.zw)\n ;b=v3(b.xy,a)\n ;if(c.x<b.x)return true;\n ;if(c.y<b.y)return true;\n ;if(c.z<b.z)return true;\n ;if(c.w<b.w)return true;\n ;return false\n ;//return any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;}*/\n\n\n/*\n//grandparent backup version to check errors\nv1 v2VertA = v1( 0.0, 4.0 ); \nv1 v2VertB = v1(-4.0,-4.0 );\nv1 v2VertC = v1( 4.0,-4.0 );\n#define D_BIAS 0.0001\nv2 CartToBary( v1 v2Cart ){\n    v1 w0 = v2VertB - v2VertA;\n    v1 w1 = v2VertC - v2VertA;\n    v1 w2 = v2Cart - v2VertA;\n    v0 d00 = dot(w0, w0);\n    v0 d01 = dot(w0, w1);\n    v0 d11 = dot(w1, w1);\n    v0 d20 = dot(w2, w0);\n    v0 d21 = dot(w2, w1);\n    v0 denom = d00 * d11 - d01 * d01;\n    v2 v3Bary;\n    v3Bary.y = (d11 * d20 - d01 * d21) / denom;\n    v3Bary.z = (d00 * d21 - d01 * d20) / denom;\n    v3Bary.x = 1.0 - v3Bary.y - v3Bary.z;\n    return v3Bary;}\nv3 BezierTriISect( const v2 v3CameraPos, const v2 v3LookDir, v2 CP_2, v2 CP_0 ){\n    v1 v2LookPt = v3CameraPos.xy + v3LookDir.xy;\n    //This is a hacky brute-force way of finding limits of triangle bounding retion.  \n    // I will probably re-write this with a better approach.\n    v1 v2PosA = LineISect( v2VertA, v2VertB, v3CameraPos.xy, v2LookPt );\n    v1 v2PosB = LineISect( v2VertB, v2VertC, v3CameraPos.xy, v2LookPt );\n    v1 v2PosC = LineISect( v2VertC, v2VertA, v3CameraPos.xy, v2LookPt );\n    v1 v2MinA = v1( min( v2VertA.x, v2VertB.x ), min( v2VertA.y, v2VertB.y ) ) - D_BIAS;\n    v1 v2MinB = v1( min( v2VertB.x, v2VertC.x ), min( v2VertB.y, v2VertC.y ) ) - D_BIAS;\n    v1 v2MinC = v1( min( v2VertC.x, v2VertA.x ), min( v2VertC.y, v2VertA.y ) ) - D_BIAS;\n    v1 v2MaxA = v1( max( v2VertA.x, v2VertB.x ), max( v2VertA.y, v2VertB.y ) ) + D_BIAS;\n    v1 v2MaxB = v1( max( v2VertB.x, v2VertC.x ), max( v2VertB.y, v2VertC.y ) ) + D_BIAS;\n    v1 v2MaxC = v1( max( v2VertC.x, v2VertA.x ), max( v2VertC.y, v2VertA.y ) ) + D_BIAS;\n    bool bAValid = \n        v2PosA.x >= v2MinA.x && v2PosA.x <= v2MaxA.x && \n        v2PosA.y >= v2MinA.y && v2PosA.y <= v2MaxA.y;\n    bool bBValid =\n        v2PosB.x >= v2MinB.x && v2PosB.x <= v2MaxB.x &&\n        v2PosB.y >= v2MinB.y && v2PosB.y <= v2MaxB.y;    \n    bool bCValid =\n        v2PosC.x >= v2MinC.x && v2PosC.x <= v2MaxC.x && \n        v2PosC.y >= v2MinC.y && v2PosC.y <= v2MaxC.y;\n    v0 fCamDistA = (v2PosA.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistB = (v2PosB.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistC = (v2PosC.x - v3CameraPos.x) / v3LookDir.x;\n    \n    v2 v3Start, v3End;\n    if( bAValid && bBValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistA, fCamDistB );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistA, fCamDistB );\n    }else if( bBValid && bCValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistB, fCamDistC );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistB, fCamDistC );\n    }else if( bCValid && bAValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistC, fCamDistA );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistC, fCamDistA );\n    }else{       return v3( 0.0, 0.0, 0.0, 2.0 );    }       //no intersection!\n    v2 S = CartToBary( v3Start.xy );\n    v2 E = CartToBary( v3End.xy );\n    //Plug in eye ray and solve variables for root finding.\n    v2 ES = E - S;\n    v0 fA = dot( ES * ES, CP_2 ) + 2.0*dot( v2(ES.y*ES.z, ES.x*ES.z, ES.x*ES.y), CP_0 );\n    v0 fB = - (v3End.z - v3Start.z) + 2.0*( \n        dot( ES*S, CP_2 ) + \n        dot( v2((ES.y*S.z + ES.z*S.y), (ES.x*S.z + ES.z*S.x), (ES.x*S.y + ES.y*S.x)), CP_0 ) );\n    v0 fC = - v3Start.z + dot( S*S, CP_2 ) +\n    \t2.0*dot( v2(S.y*S.z,S.x*S.z,S.x*S.y), CP_0 );    \n    //Actual root finding\n    v0 fRoot = fB*fB - 4.0*fA*fC;\n    if( fRoot >= 0.0 )    {\n        v0 fRootA = (-fB + sqrt( fRoot ) ) /( 2.0 * fA );\n        v0 fRootB = (-fB - sqrt( fRoot ) ) /( 2.0 * fA );        \n        if( fRootA >= 0.0 && fRootA <= 1.0 )        {\n            if( fRootB >= 0.0 )                fRootA = min( fRootB, fRootA );\n            return v3( S + fRootA*ES, fRootA );        }\n        if( fRootB >= 0.0 && fRootB <= 1.0 )            return v3( S + fRootB*ES, fRootB );    }    \n    return v3(0.0, 0.0, 0.0, 2.0);}/**/\n\n\n\n//by @JJcoolkl,crunched by ollj\n//analytical intersection of RAY [u,d]=[origin,direction] \n//and quadratic-bezier triangular-patch(6 CV-heights)\n//in:\n//c1,c0 6 CW heights (orthogonal to triangle plane)\n//p1,p2,p3 corners of base triangle\n//res=resolution.x (screen width in oixel)\n//out:\n//.xyz returns intersection\n//.w   returns if it hits (.w<=1 means it hit a surface)\n//inout:\n//cd is a debug color, used to show the bounding volume, and 3 cases within that volume.\nv3 BezierTriISect(const v2 u,const v2 d,v2 c1,v2 c0,v1 p1,v1 p2,v1 p3,v0 res,inout v2 cd\n){\n ;//return BezierTriISect(u,d,c1,c0) //reference to grandparent version, to compare if i introduced an error, or found a grandpparent error\n ;v1 L=u.xy-d.xy\n ,a=LineISect(p1,p2,u.xy,L)//project ray onto the triangle, within its ray+triangle intersections\n ,b=LineISect(p2,p3,u.xy,L)\n ,c=LineISect(p3,p1,u.xy,L)//three 2d intersections\n //\n //sicne eror hairlines are always lines, the error seems to be in the projected triangle 2d intersection.\n //\n //g+bA, h+bB, o+bC distinguish 3 ways to slice a triangle in two, in respect to its corners \n #define Mm(a,b,c)min(a.c,b.c)\n #define MM(a,b,c)max(a.c,b.c)\n #define mmm(a,b)v3(Mm(a,b,x),Mm(a,b,y),MM(a,b,x),MM(a,b,y))+q\n ;v3 q=v3(-1,-1,1,1)*.001/res//tiny epsilon accounts for precision loss. this seals the seam between 2 planes in screenspace\n //;v3 q=v3(-1,-1,1,1)*4./res//just to visualize the screenspace seam\n ,g=mmm(p1,p2),h=mmm(p2,p3),o=mmm(p3,p1)\n #define altm(a,b)any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h)\n ;v2 f,e=(v2(a.x,b.x,c.x)-u.x)/d.x//e stores 3 lengths.x of raystart.x to intersections.x, we care more for the shorter ones here.\n ;cd=v2(.7,0,0);//initially assume intersection with 1/3 sides of a \"triangle prism\"\n ;       if(  bA||bB ){bool bC=altm(c.xy,o)//restructured,1/3 of all cases skips the calculation of cB (remains default assumed case above)\n  ;      if(!(bB||bC)){e=e.yzx;cd=cd.yzx//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){e=e.zxy;cd=cd.zxy//intersection with 1/3 sides of a \"triangle prism\"\n ;}else{cd=cd.yyy;return v3(0,0,0,2);}}//no intersection with prism\n ;f=u+d*miv(e.xy);v2 S=CartToBary(f.xy,p1,p2,p3)//barycentric projection root solving black magic\n ;e=u+d*mav(e.xy);v2 E=CartToBary(e.xy,p1,p2,p3)-S//Plug in eye ray and solve variables for root finding.\n ;o=v3(0,f.z-e.z,dot(S*S,c1)-f.z,0)\n   +v3(dot(E*E,c1)+dot(E.yxx*E.zzy,c0)*2.\n      ,dot(E*S,c1)+dot(v2(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0)//i smell a cross()\n      ,dot(v2(S.y*S.z,S.x*S.z,S.x*S.y),c0),0)*2.//3 root solving factors; .x is the scalar to baricentric range[0..1]\n ;o.z=o.y*o.y-2.*o.x*o.z\n ;if(o.z>=0.&&o.x!=0.//worksafing\n ){a=(v1(1.,-1.)*sqrt(o.z)-o.y)/o.x;//[a] stores 2 distances to two roots, scaled to a [0..1] barycentric range., a.x may not be within that range, meaning theres less than 2 roots.\n  ;if(abs(a.x-.5)<.5\n  ){if(a.y>0.) a.x=miv(a); //a.xy may not be within that [0..1]range, meaning theres less than 2 roots, we hope theres one root.\n   ;return v3(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5){cd+=v2(0,.3,.3);return v3(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n  ;}};return v3(0,0,0,2);}//no intersection\n\n\n\n//above function has triangle normal fixed to v2(0,0,+11), all corners have .z==0.\n//below version rotates the whole set around p1 to set the triangle normal to v2(0,0,1)\nv3 BezierTriISect(v2 u,v2 d,v2 c1,v2 c0,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd\n){v2 n=normalize(triangleNornal(p1,p2,p3))\n ;v3 b=RotBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;v2 s=v2(0,0,p1.z);\n \n// ;u =r(b,u ,p1)-s\n// ;d =r(b,d ,p1)-s\n// ;p2=r(b,p2,p1)-s\n// ;p3=r(b,p3,p1)-s\n ;return BezierTriISect(u,d,c1,c0,p1.xy,p2.xy,p3.xy,res,cd);}\n//this transform seems to be false.",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//buffA.start\n\n/*\nbezier patch analytic: https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\nv2 BezierTriangle_Quadratic_Normal(const v2 u,const v2 a,const v2 b,v2 p1,v2 p2,v2 p3//get normal(2nd derivative)of quadradicBezier triangularPatch\n){v2 n=triangleNornal(p1,p2,p3)\n ;v3 c=RotBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;//v2 s=v2(0,0,p1.z);\n ;//p2=r(c,p2,p1)-s\n ;//p3=r(c,p3,p1)-s\n ;return normalize(cross(v2(p1.xy-p2.xy,suv(u*v2(a.x-b.z,b.z-a.y,b.y-b.x)))\n                        ,v2(p1.xy-p3.xy,suv(u*v2(a.x-b.y,b.z-b.x,b.y-a.z)))));}\n\nv3 ComputeBezierColor(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd//get color based on bezier tri intersection+lighting\n){v3 v4ISect=BezierTriISect(u,d,a,b,p1.xy,p2.xy,p3.xy,res,cd)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;v2 c=v2(0)\n ;if(v4ISect.w<2.\n ){v2 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b,p1,p2,p3)//analytical first derivative\n  ;c=n*.5+.5\n  ;if(board(v4ISect.xyz*9.)>0.)c.z=1.-c.z//barycentric checkerboard\n  ;return v3(c,1);}return v3(0);}\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define THRUST 0.1*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n//return signed distane of[p] to a surface. (relict for collision detection of flyCamera.\nv0 gd(v2 u){return 999.;}//never collide\n\n//load and save, originally from iq, modified\nv0 isInside(v1 p,v1 c){v1 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nv3 load(int re){return texture(iChannel0,(.5+v1(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in v3 va, inout v3 o, in v1 u\n){if(isInside(u,v1(re,0))>.0)o=va;}//o=(isInside(u,v1(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x>0.0);}\nv0 key(in int key){return texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x;}\n\n/*\n//namespace convention\n[o]RayOrigin\n[d]RayDirection\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n*/\n\nv0 sp(v2 u,v2 d,vec4 s//draw CV as transparent spheres,with simple projection;radius scaled by distance to camera.//cameraPos,Sphere\n){u-=s.xyz;v0 a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\nv0 ComputeOverlay(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3\n ){v2 n=normalize(triangleNornal(p1,p2,p3))\n  ;return sp(u,d,v3(p1+n*a.x,.2))\n         +sp(u,d,v3(p2+n*a.y,.2))      \n         +sp(u,d,v3(p3+n*a.z,.2))      \n         +sp(u,d,v3((p1+p2)*.5+n*b.x,.2))\n         +sp(u,d,v3((p3+p1)*.5+n*b.y,.2))\n         +sp(u,d,v3((p2+p3)*.5+n*b.z,.2));}//paint 6 CVs\n\n//lots of min max for an aabv\nv0 doAABV(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b){\n     ;v2 n=normalize(triangleNornal(p1,p2,p3))\n// ;v3 q=RotBetween(n,v2(0,0,1))\n/*\n ;v2 s=v2(0,0,p1.z);\n ;p2=r(q,p2,p1)-s\n ;p3=r(q,p3,p1)-s\n/**/ \n ;v2 cv1=p1+n*a.x,cv12=(p1+p2)*.5+n*b.x\n ;v2 cv2=p2+n*a.y,cv23=(p3+p3)*.5+n*b.y\n ;v2 cv3=p3+n*a.z,cv31=(p3+p1)*.5+n*b.z\n #define muchm(a,b,c) v0 b=a(a(a(cv1.c,cv2.c),a(cv3.c,cv12.c)),a(cv23.c,cv31.c))\n ;muchm(min,x,x);muchm(max,X,x)\n ;muchm(min,y,y);muchm(max,Y,y)\n ;muchm(min,z,z);muchm(max,Z,z)     \n ;v2 aa=aabv(v,d,v2(x,y,z),v2(X,Y,Z))\n ;if(aa.x<1.)return 0.//outside of AABV\n ;return 1.;}\n\nv2 bezierPatch(v2 v,v2 d,v2 p1,v2 p2,v2 p3){//position,direction, trianglecorners \n ;v3 o=v3(0);\n ;mat3 pq=pqfmA()//matrix of different quadratic fields, to be most aperiodic\n ;pq=pq*(iTime*.2+.001)//.001 to skip the coplanar case at iTime==0 (with tiny determinant). dare to get closer to it, its quite the precision-mess where it gets too planar (but not quite planar)\n ;v2 a=cos(pq[0]),b=cos(pq[2])\n ;//a=v2(0,1,2)\n ;//b=v2(0,1,2)\n ;a*=9.\n ;b*=9.\n ;v2 cd=v2(0)\n //the line below is completely optional, and may not even be worth computing\n //as it is only an AxisAlignedBoundingVolume for culling.\n ;if(doAABV(v,d,p1,p2,p3,a,b)==0.)return v2(.5)//if(ray misses AABV)return grey!\n    \n ;//a*=0.0;b*=0.0 //known bug debug enforcing case: planar case has determinant of 0 special case!\n ;v3 c=ComputeBezierColor(v,d,a,b,p1,p2,p3,iResolution.x,cd)\n ;c=mix(v3(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;if(c.xyz==v2(.5))c.xyz=mix(c.xyz,cd,.2)//debug color output\n ;o=mix(c,v3(.7,.7,.7,1),ComputeOverlay(v,d,a,b,p1,p2,p3))\n ;return o.xyz;\n;}\n \nv2 scene(v2 o,v2 d\n){ //corners.xy of a triangle\n ;v2 \n p1=v2(-4,0,0)\n,p2=v2(4,0,0)\n,p3=v2(0,sqrt(3.)/3.*4.*4.,0);\n//.z==0. for simplicity/debugging\n ;return bezierPatch(o,d,p1,p2,p3)\n ;}//origin,direction\n\nv3 mainImage2(out v3 fragColor,v1 fragCoord){\n v2 t=normalize(v2((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n v2 o=load(0).xyz;\n v3 fw=(load(1));\n t=r(fw,t);\n return v3(scene(o,t),1);}\n\nvoid steer(out v3 o,v1 u\n){v3 p,qrot\n ;if(iFrame<2//init\n ){p=v3(8,4,0,0)-v3(11,11,11,0)\n  ;//todo debug the line in this camera angle: p=v3(8,4,0,0);qrot=normalize(v3(0,1,2,1))\n  ;qrot=normalize(v3(0,1,2,1))\n  ;//p.xyz+=r(qrot,v2(0,0,1))*6.//move camera forward, but the error is gone then\n ;}else{//next frame\n  ;p=load(0);qrot=load(1)//load state from previous frame\n  ;v2 fw=v2(0,0,1)\n  ;fw=r(qrot,fw) //this can be done simpler\n  ;v2 newp=p.xyz+fw*p.w*.2\n  ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n  ;else{\n   ;if(gd(v2(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n   ;if(gd(v2(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n   ;if(gd(v2(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n  ;}\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;v0 roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;v1 m=v1(0)\n ;vec4 mouse=iMouse\n ;mouse=iMouseZwFix(mouse,true)\n ;if(iMouse.z>.0\n ){v1 n=mouse.xy-mouse.zw\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy;}\n ;v3 qp=q(v2(m.yx*ROTATE,roll))\n ;qrot=normalize(r(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,forwardVelocity\n;store(1,qrot,o,u)//rotation\n;}\n\nvoid mainImage(out v3 o,v1 u){\n;if(all(lessThan(u,v1(2.5,1.5))))steer(o,u)\n    ;else o=mainImage2(o,u); }",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}