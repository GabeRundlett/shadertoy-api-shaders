{
    "Shader": {
        "info": {
            "date": "1537775803",
            "description": "2 limb inverse kinematics is as simple as circleCircle intersection within rotation.\n\nif(mouse down) limb lengths are set by where you klicked. \ndrag mouse to place handTarget\n\nblue area shows what HandTargets are reachable by the current LimbLengths.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "llycDV",
            "likes": 10,
            "name": "over inverse kinematic",
            "published": 3,
            "tags": [
                "intersection",
                "circle",
                "ik",
                "robot",
                "inverse",
                "library",
                "kinematics",
                "arm"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 734
        },
        "renderpass": [
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n/* html boilerplate + canvas\n<html><style>body{padding:0;margin:0;position:absolute;width:100%;height:100%;}\n#ID{color:#000;top:0px;left:0px;position:absolute;;width:100%;height:100%}\n#IF{color:#FFF;top:0px;left:0px;position:absolute;pointer-events:none;text-shadow:0 0 9px #000;}\n</style><head></head><script>var w2,wMs=[\"experimental-webgl\",\"webgl\",\"webgl2\"]\n,wM=3//<---wM sets the webGL version,points at wMs[];[ wM=2 ] sets it to [version300es],(w2==true),\"webgl2\",all others are(w2==false)\n</script><script id=\"e\">\nuniform int iFrame;\nuniform float iTime;\nuniform vec3 iResolution;//.z is set to 1,initially for projection mapping (to project on house walls),later mostly for smaller shaders.\nuniform vec4 iMouse;\nuniform vec4 iDate;\nuniform sampler2D backbuffer;\n</script><script id=\"h\">\n//mousedown state fixed\nvec2 v1u;\n/**/\n\n\n\n//alphacompositing fixed\n//lacks root-solving shapes (parabola-ellipse)\n//canvas \"TinyBri300OHGDAPo14\"\n//lots of code from [inogo quilez] [mercury] [dr2] [David Hoskins]\n//has iFrame fixed\n//has unified smin() smooth-Boolean-fuzzy-logic variants\n//has complex 2d transforms (possibly buggy,checked as much as i care and know this stuff)\n//has some rgba-colorspace-gradients/indicators (but surely not all that i care for,cieluelch is missing)\n//has noise (upper ones are better for (hyperplanes of) less domains\n//- tri,which is food for very fast volumetric storms\n//- h41=[fastest fbm with normals],that is just fast fbm noise with (poorly estimated) 3d normals\n//- hfd=[hash(fract(dot()))],that does not use sin(fract(a)),by David Hopkins\n//- cel=cellular noise,parallelized/fast vorley noise with 2 shortest distances in 2d or 3d,with hash as additional static domain.\n//- s13=[simplex],highest quality/performance noise,generally too slow for 3d spheretracking (as displacement or heightmap)\n//- - lacks bayerMatrix,blueHash<-part of higher-domain content.\n//has DA derivative arithmetic\n//- has issues with Param2:\n//- - decapitated filling lists with zeroes,seems VERY nonsensical\n//- - DA mixing differs from MAT mixin,not just in structure.\n//- - ... previous DA shaders made the error od declaring DA-mixing as MAT-mixind with DA-parameters?\n//- - ... or was that just cases where MAT is identical to DA?\n//has alias-folds fixed,with mercury.sexy/hg_sdf\n//- are declared as defines,for\n//- - N-dimensional inputs,where that function still makes sense in higher dimensions\n//- - uses the same labels as DA,so depending on input it can also calculate derivatives\n//- Includes minified HG_SDF by Mercury mercury.sexy/hg_sdf\n//- omitted platonic solids because the original code uses arrays\n//- Some functions are converted to macros because they would be even smaller when preprocessed.\n//- Another macro,_M,is really filling up almost identical code as to make the result even smaller,\n\n//has AD=automatic Differentiation via chain rule but only demoes it in 1d\n//note to self,default background is black,otherwise tiny shadertoy shaders will be white image on white background.\n\n#define vec1 float\n#define norma normalize\n//#define ss smoothstep\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define cl(a,b,c) mi(ma(a,0.),1.)//till i define this for AD\n#define sat(x) cl(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define u5cos(a) u5(cos(a))\nstruct v11{vec1 a;vec1 b;};\nstruct v22{vec2 a;vec2 b;};\nstruct v33{vec3 a;vec3 b;};//for 2 domains(density/distance field)\nstruct v44{vec4 a;vec4 b;};\nstruct v444{vec4 a;vec4 b;vec4 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v333{vec3 a;vec3 b;vec3 c;};\nstruct v3333{vec3 a;vec3 b;vec3 c;vec3 d;};\nstruct v222{vec2 a;vec2 b;vec2 c;};\n//v222 g222(vec3 a,vec3 b){return v222(vec2(a.x,b.x),vec2(a.y,b.y),vec2(a.z,b.z));}\nv222 g222(v33 a){return v222(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv3333 muv(v3333 a,vec4 b){return v3333(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nvec4 ddv(v3333 a){return vec4(dd(a.a),dd(a.b),dd(a.c),dd(a.d));}\n//above [v*] struct implies matrix arithmetic,below [w*] struct implies AD,wherelater spaces are (analytic) lower-exponent-differentials\n//[.b] is always a derivative of [.a],along one (of multiple) domain(s)\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\nstruct DAm2{w13 x;w13 y;w13 z;};//for 3 domains (density/distance field) \nstruct DAm1{w12 x;w12 y;};//for 2 domains (heightmap,isoline,contour)\nstruct DAm0{w11 x;};//for 2 domains (heightmap,isoline,contour)\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n\n\n\n\n\n\n\n\nw11 ma(w11 a,vec1 b){return w11(max(a.a,b),max(a.b,b));}\nw11 mi(w11 a,vec1 b){return w11(min(a.a,b),min(a.b,b));}\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define viewZoom 3.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/viewZoom)\n#define fra(u)(u-.5*iResolution.xy)*viewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n//DAm2 maxdm(DAm2 a,v2 p){return DAm2(maxd(a.a,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\n//DAm2 mindm(DAm2 a,v2 p){return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\n//DAm2 maxdm(DAm2 a,vec1 p){return maxdm(a,v2(p));}\n//DAm2 mindm(DAm2 a,vec1 p){return mindm(a,v2(p));}//needed for fast clamping\n//w13 maxdm(w13 a,w13 b,w13 c){return maxd(maxd(a,b),c);}\n//w13 maxdm(DAm2 a){return maxdm(a.a,a.y,a.z);}\n//The 3(or 2)dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN p)]:\n//where N=number of domains,range [0..3]\nv444 da_domain(vec3 p){return v444(vec4(p.x,1,0,0),vec4(p.y,0,1,0),vec4(p.z,0,0,1));}\nv33 da_domain(vec2 p){return v33(vec3(p.x,1,0),vec3(p.y,0,1));}\nvec2 da_domain(vec1 p){return vec2(p,1);}//for 1 domain(linear equation)\n//vNN() declares c11() c22() c33() c44()... for implicit typecasting into structs; v11 v22 v33 v44\nv11 c11(vec1 a,vec1 b){return v11(a,b);}\nv11 c11(vec1 a){return v11(a,a);}\n#define vNNv(z,x) {return z(x(a),x(b));}\n#define vNNu(z,x,y) z x(vec1 a,y b)vNNv(z,y) z x(y a,vec1 b)vNNv(z,y) z x(vec1 a,vec1 b)vNNv(z,y)\n#define vNN(z,y,x) vNNu(z,y,x) z y(x a,x b){return z(a,b);} z y(x a){return z(a,a);}\nvNN(v22,c22,vec2)\nvNN(v33,c33,vec3)\nvNN(v44,c44,vec4)\n\n\n//param1MAT dreaming of vec5 and vec2x2,also,this keeps define-namespace unused,by declating function sets!\n//lets me type \" a=min(vec3(a),float(b)) a=pow(vec3(a),float(b)) \" with less explicit typecasting and shorter aliases:\n//negate,reciprocal,abs,log,sin,asin,cos,acos,tan,atan,fract,floor\n#define NE(y,z) z ne(z a){return -a;}y ne(y a){return y(-a.a,-a.b);}\nNE(v11,vec1)NE(v22,vec2)NE(v33,vec3)NE(v44,vec4)\nw13 ne(w13 a){return w13(-a.a,-a.b);}\nw12 ne(w12 a){return w12(-a.a,-a.b);}\nw11 ne(w11 a){return w11(-a.a,-a.b);}\n#define def1E(z,y,x) x z(x a){return y(a);}\n#define def1(a,b) def1E(a,b,vec1) def1E(a,b,vec2) def1E(a,b,vec3) def1E(a,b,vec4)\n#define re(a) di(1.,b)\ndef1(ab,abs)def1(sg,sign)def1(sq,sqrt)\ndef1(ln,log)def1(ex,exp)\ndef1(si,sin)def1(asi,asin)\ndef1(co,cos)def1(aco,acos)\ndef1(ta,tan)def1(ata,atan)\ndef1(fr,fract)\ndef1(fl,floor)\n//----param2MAT\n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(ne(a)))\n#define def2U(z,y,x) x z(vec1 a,x b){return y(x(a),b);} x z(x a,vec1 b){return y(a,x(b));}\n#define def2E(z,y,x) x z(x a,x b){return y(a,b);}\n#define def2(a,b) def2E(a,b,vec1) def2E(a,b,vec2) def2E(a,b,vec3) def2E(a,b,vec4)\n#define defU(a,b) def2(a,b) def2U(a,b,vec2) def2U(a,b,vec3) def2U(a,b,vec4)\n#define sub(a,b) ((a)-(b))\n#define add(a,b) ((a)+(b))//sub(a,ne(b))\n#define div(a,b) ((a)/(b))\n#define mul(a,b) ((a)*(b)) //di(a,re(b)) reciprocal define may lose time&precision\n//a lot of these just reserve namespaces //dot() is special for folding to a vec1 uses defD()\n#define def2D(z,y,x) vec1 z(vec1 a,x b){return y(x(a),b);} vec1 z(x a,vec1 b){return y(a,x(b));}\n#define def2F(z,y,x) vec1 z(x a,x b){return y(a,b);}\n#define defF(a,b) def2F(a,b,vec1) def2F(a,b,vec2) def2F(a,b,vec3) def2F(a,b,vec4)\n#define defD(a,b) defF(a,b) def2D(a,b,vec2) def2D(a,b,vec3) def2D(a,b,vec4)\n//vNN operands foldlike this:\n#define vXX(z,y) z(y(a.a,b),y(a.b,b))\n#define vXY(z,y) z(y(a.a,b.a),y(a.b,b.a))\n#define vvZ(z,w,v,y) w z(w a,v b){return y(w,z);}w z(w a,vec1 b){return y(w,z);}w z(v11 a,v b){return y(w,z);}\n#define vvY(z,w,v,y) w z(w a,v b){return y(w,z);}w z(v a,w b){return y(w,z);}w z(w a,w b){return y(w,z);}\n#define vvX(y,w,v) vvZ(y,w,v,vXX) vvY(y,w,v11,vXY)\n#define vMM(z) vvX(z,v22,vec2)vvX(z,v33,vec3)vvX(z,v44,vec4)v11 z(v11 a,v11 b){return vXY(v11,z);}v11 z(v11 a,vec1 b){return vXX(v11,z);}\n//alias2_NinputAsVec; due to symmetrically defined alising,in favor of min() max() functions (previously called miv() mav()):\n//note that dt(vec4 a)==dot(dot(a.x,a.y),dot(a.z,a.w)),equivalent to ad(vec4 a)\n//note that po(vec4 a)==pow(pow(a.x,a.y),pow(a.z,a.w)),which is quite silly\n//note that su(vec4 a)==(a.x-a.y)-(a.z-a.w)=a.x+a.w-a.y-a.z=a.x+a.w-(a.y+a.z)\n//note that di(vec4 a)==(a.x/a.y)/(a.z/a.w)=a.x*a.w/a.y/a.z=a.x*a.w-(a.y*a.z)\n//alternatively fo() couls also be defined as dot(a,1.),where parts of a are negated or reciprocal\n#define Fo1(u,t) vec1 u(t a){return u(a.x,a.y);}\n#define Fo2(u,t) vec1 u(t a){return u(u(a.xy),a.z);}\n#define Fo3(u,t) vec1 u(t a){return u(u(a.xy),u(a.zw));}\n#define Fon(u) Fo1(u,vec2) Fo2(u,vec3) Fo3(u,vec4)\n#define defM(a,b) defU(a,b) vMM(a) Fon(a)\ndefM(po,pow)\ndefM(mi,min)defM(ma,max)\ndefM(su,sub)defM(di,div)\ndefM(ad,add)defM(mu,mul)\ndefM(mo,mod)\ndefM(st,step)\n//higher domains for high-domain-permutations/zOrder/Noise\n//v33 su(vec3 a,v33 b){return v33(a-b.a,a-b.b);}\nv33 g33(vec2 a){return v33(vec3(a.x),vec3(a.y));}\nv333 su(vec3 a,v333 b){return v333(a-b.a,a-b.b,a-b.c);}\nv333 g333(v33 a,vec3 b){return v333(a.a,a.b,b);}\nv3333 g3333(vec3 a,v333 b){return v3333(a,b.a,b.b,b.c);}\nv44 fl(v44 a){return v44(fl(a.a),fl(a.b));}\nv44 fr(v44 a){return v44(fr(a.a),fr(a.b));}\n//polar Complex dot()\nconst vec3 vs=vec3(-1,0,1);\n#define le(a) sq(dd(a))\ndefD(dt,dot)\n#define dd(a) dot(a,a)\n//vMM(dt)//breaks a pattern,due to being a foldingprojection\nFon(dt)\nvec2 perp(vec2 a){return a.yx*vs.xz;}\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nfloat perpdot(vec2 a,vec2 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n//\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(vec1 a){return cs(vec2(a,a));}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c2(c)-(c.a-c.b*i)\n#define c2(a)c4(anaa(a)).xy\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(vec1 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(vec1 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n\n\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n\nvec2 crCo(vec2 a){return sqrt(le(a)+c2(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nvec2 ciCo(vec2 u,vec2 z,float r){return vec2(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//param2&2*x complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nvec2 sqc(vec2 a){float n=a.x+length(a);return vec2(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nvec4 sqc(vec4 a){vec4 c=vec4(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\nvec2 po2c(vec2 c){vec2 d=c*c;return vec2(d.x-d.y,2.*c.x*c.y);}//vec2 po2c(vec2 a){return muc(a,a);return vec2(sub(a*a),2.*a.x*a.y);}//complex square\nvec2 po3c(vec2 z){float p=z.x*z.x,q=z.y*z.y;return z*vec2(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nvec2 recc(vec2 a){if(a.x==0.)return vec2(1e10);return c2(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\nvec2 lgc(vec2 a){a=c2p(a);a.x=log(a.x);return a;}//return vec2(log(dd(a))*.5,arg(a));}\nvec4 lgc(vec4 a){return vec4(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nvec2 suc(vec2 a,vec2 b){return a-b;}vec2 adc(vec2 a,vec2 b){return a+b;}///complex addition is trivial\nvec2 muc(vec2 a,vec2 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nvec2 muc(vec2 a,vec2 b,vec2 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nvec2 muc(vec4 a){return muc(a.xy,a.zw);}//parallel mult\nvec2 dic(vec2 a,vec2 b){if(a.x==0.)return vec2(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nvec2 lgc(vec2 a,vec2 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z,b is complex;\nvec2 lgc(vec2 a,float c){return vec2(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nvec2 exc(vec2 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i))\n//vec2 lgc(vec2 a,float c){a=c2p(a);return vec2(log(a.x),a.y+c*tau);}//should be the same!\nvec2 poc(vec2 a,vec2 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nvec2 poc(vec2 w,vec2 z,float c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nvec2 lgc(vec2 a,vec2 b,float c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nvec2 wrtc(vec2 a,vec2 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nvec2 wrtc(vec2 a,vec2 b,float c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n//vec2 sqc(vec2 z){vec2 c=sqrt((length(z)+c2(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\nvec2 sic(vec2 z){return .5*cs(z.x).yx*(exp(z.y)+c2(exp(-z.y)));}//vec2 sic(vec2 z){return vec2(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  vec2 sic(vec2 c){vec2 d=exp(c2(c.y));return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 si2c(vec2 c){vec2 d=vec2(exp(c.y),1);return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 coc(vec2 z){return .5*c2(cs(z.x))*(exp(z.y)+c2(exp(-z.y)));}\n\n//obsoleted vec2 coc(vec2 z){ return vec2(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted vec2 coc(vec2 c){vec2 d=exp(c2(c.y));return vec2(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nvec2 ta2c(vec2 c){vec2 d=exp(c2(c.y));float e=cos(c.x),s=(d.x-d.y)*.5;return vec2(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nvec2 tac(vec2 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nvec2 cotc(vec2 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nvec2 sihc(vec2 z){return .5*cs(z.y)*(exp(z.x)+c2(exp(-z.x)).yx);}//vec2 sinh(vec2 z){ return 0.5*vec2((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//vec2 sinh2c(vec2 z){z=c2(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nvec2 cohc(vec2 z){return coc(c2(z.yx));}//vec2 cosh(vec2 z){ return vec2(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 vec2 tahc(vec2 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 vec2 cothc(vec2 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(vec2 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl.0 vec2 cschc(vec2 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nvec2 arsic(vec2 z){return c2(lgc(perp(z)+sqc(c2(po2c(z.yx)))+vec2(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//vec2 arsic(vec2 z){vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(-z.y+a.x,z.x+a.y));return vec2(a.y,-a.x);}\nvec2 arcoc(vec2 z){return-c2(lgc(z+c2(sqc(po2c(z.yx)+vec2(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//vec2 arcoc(vec2 z){ vec2 a=sqc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(vec2(z.x+a.y,z.y-a.x));return vec2(-a.y,a.x);}\nvec2 csec(vec2 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nvec2 ccsc(vec2 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nvec2 arcotc(vec2 z){float r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((vec4(z.yx,-z.yx)+vec4(r,0,r,0)).yxzw/r)))*.5;}//vec2 arcotc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=lgc(vec2(p+q-z.y,-z.x)/r);vec2 b=lgc(vec2(p+q+z.y,z.x)/r);return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nvec2 artac(vec2 z){return sub2(c4(lgc(vec4(1,0,1,0)-c2(z.yx).xyxy).yxwz))*.5;}//vec2 artac(vec2 z){ vec2 a=lgc(vec2(1.0+z.y,-z.x));vec2 b=lgc(vec2(1.0-z.y,z.x));return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nvec2 arcsec(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(sub2(c4(vec4(z,sqc(ciCo(u,z,r)).yx)))).yx)+vec2(0.,log(r));}//vec2 arcsec(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(z.x-a.y,a.x-z.y));return vec2(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nvec2 arccsc(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=su(u);return c2(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+vec2(0.,log(r));}//vec2 arccsc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r-p+q,2.0*z.x*z.y));a=lgc(vec2(a.x+z.y,a.y+z.x));return vec2(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nvec2 arcsch(vec2 z){vec2 u=z*z;float r=su(u);return lgc(c2(z)+sqc(ciCo(u.yx,z,r)))-vec2(0,log(r));}//vec2 arcsch(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqc(vec2(r*r+p-q,-2.0*z.x*z.y));a=lgc(vec2(a.x+z.x,a.y-z.y));return vec2(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nvec2 arsinh(vec2 z){return lgc(z+sqc(po2c(z)+vec2(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nvec2 arcosh(vec2 z){return lgc(z+muc(sqc(z.xyxy+vec4(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nvec2 artanh(vec2 z){float r=1.-su(z*z);z*=2.;return .5*lgc(-vec2(r,z.y)/(r+z.x));}//vec2 artanh(vec2 z){float r=z.x*z.x+z.y*z.y;return lgc(vec2(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nvec2 arcoth(vec2 z){;float r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(vec2(r,z.y)/(r+2.+z.x));}//vec2 arcoth(vec2 z){ float r=z.x*z.x+z.y*z.y;return lgc(vec2(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nvec2 arsech(vec2 z){float r=su(z*z);return lgc(c2(z)+muc(sqc(vec4(-r,0,r,0)+c2(z).xyxy)))-vec2(log(r),0);}//ok-ollj\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(iTime)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(iTime)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n\n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n//how to transform this to a non-boolean solution with smooth borders?\n//multiply with a smoothstep?\nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a\n ;}\n \n//---param3MAT\n//SF3() is a hot mess to be simplified a lot! //only allows for vec1 ot vecmax\n//explicit namespace fold for scalar operations\n#define fi3(m,z,a,b,c) {return z(m(a),m(b),m(c));}\n#define Q3(z,a,b,c){return z(a,b,c);}\n#define SF3(n,y,z,a,b,c) n y(n a,n b,n c)fi3(n,z,a,b,c) n y(n a,n b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,n c)fi3(n,z,a,b,c) n y(n a,vec1 b,vec1 c)fi3(n,z,a,b,c) n y(vec1 a,n b,n c)fi3(n,z,a,b,c) n y(vec1 a,n b,vec1 c)fi3(n,z,a,b,c)\n#define scalar3(y,z) vec1 y(vec1 a,vec1 b,vec1 c)Q3(z,a,b,c) SF3(vec2,y,z,a,b,c) SF3(vec3,y,z,a,b,c) SF3(vec4,y,z,a,b,c)\nscalar3(mx,mix)\n//---param1AD Automatic Differenciation (needs param2MAT)\n//todo AD for;tan,asin,acos,atan,reciprocal\n//memo museum: for consistency structure changed: d->v00->v11;d1->v01->w12;d2->v02->w13\n//...the swivels oof d; are .xd ,the swivels of v0N (and [w*]) are .ab\nvec1 rec(float a){return(a==0.)?a:1./a;}//return [1/a] ,work safe//sqrt()and divisions require a worksave reciprocal operator:\n#define sqD(h)h sq(h a){vec1 q=sq(a.a);return h(q,.5*rec(q)*a.b);}\n#define cmD(h,i) h cmd(w11 a,i b){return h(a.a,mu(a.b,b));}\ncmD(w11,vec1)cmD(w12,vec2)cmD(w13,vec3)cmD(w14,vec4)//cmd() is special case of component-wise-multiplication,special because a.x==1: is subroutine of abs()\n//i am not too sure about my implementation on fr();\n//the hell,just use mo()instead,mo()has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)-=.0)\nvec1 jud(vec1 a){return mx(a,-1.,st(fr(a),0.)*st(0.,fract(a)));}\nvec2 jud(vec2 a){return vec2(jud(a.x),jud(a.y));}\nvec3 jud(vec3 a){return vec3(jud(a.x),jud(a.y),jud(a.z));}\nvec4 jud(vec4 a){return vec4(jud(a.x),jud(a.y),jud(a.z),jud(a.w));}\n//i should definitely define this by fract,and not by floor.\n//because fm-modulation taught me that i need fract()a lot more than floor()\n#define frD(h)h fr(h a){return h(fl(a.a),jud(a.b));}\n#define abD(h)h ab(h a){return cmd(w11(ab(a.a),sg(a.a)),a.b);}//w13(abs(a.x),sign(a.x)*a.d);}\n#define siD(h)h si(h a){return h(si(a.a),mu(co(a.a),a.b));}\n#define coD(h)h co(h a){return h(co(a.a),mu(ne(si(a.a)),a.b));}\n#define lgD(h)h ln(h a){return h(ln(a.a),di(a.b,a.a));}\n#define exD(h)h ex(h a){vec1 x=exp(a.a);return h(x,x*a.b);}\n#define DA1(h)h(w11)h(w12)h(w13)h(w14)\nDA1(abD)DA1(siD)DA1(coD)DA1(lgD)DA1(exD)DA1(sqD)DA1(frD)//because different functions have unique derivatives,\n//fl(a)=a-fr(a); hasvery slightly lower precision?rarely relevant.fract()has great precision on float!\n#define fl(a) su(a,fr(a))\n//---Param2AD are trickier: https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mo()mx()mi()ma()\n//AD_mo() ideally should be replaced by fr(),but that adds 1dvd()and 1mu(),BUT DA_mo(a,b) outperforms mu(fr(di(a,b)),b),via [reciprocal product rule]\n#define moD(h,i)h mo(h a,i b){return h(mo(a.a,b  ),fr(a.b));}\n#define moE(h,i)h mo(h a,i b){return h(mo(a.a,b.a),fr(a.b));}\n#define moF(h,i)h(w11,i)h(w12,i)h(w13,i)h(w14,i)\nmoF(moD,vec1)moF(moE,w11)\n#define miG(r,h,j) r mo(h a,r b){return r(mod(a.a,b.a),j(0));}\nmiG(w14,w13,vec4)miG(w14,w12,vec4)miG(w14,w11,vec4)miG(w13,w11,vec3)miG(w13,w12,vec3)\nw13 mo(vec1 a,w13 b){return w13(mod(a,b.a),vec3(0));}\nw12 mo(vec1 a,w12 b){return w12(mod(a,b.a),vec2(0));}\nw11 mo(vec1 a,w11 b){return w11(mod(a,b.a),0.);}\n//substraction is simple,because \"differentiation is integration\"; https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for; https://en.wikipedia.org/wiki/Translation_(geometry)\n//BUT if we substract a struct da from a vec1 or w11,we must negate the .b part.\n//i possibly messed this one up by not flipping the .a part,but i an not sure there.\n#define suNN(h,i,j)h su(i a,j b){return h(su(a.a,b.a),a.b);}h su(j a,i b){return h(su(a.a,b.a),-b.b);}\nsuNN(w12,w12,w11)suNN(w13,w13,w11)suNN(w13,w13,w12)//the leftmost param equals the larger param of the other 2 params\nsuNN(w14,w14,w11)suNN(w14,w14,w12)suNN(w14,w14,w13)//..the rightmost param is always smaller than the middle param\n#define suNM(t)t su(t a,vec1 b){return t(su(a.a,b),a.b);}t su(vec1 a,t b){return t(su(a,b.a),-b.b);}\n#define suMM(t)suNM(t)t su(t a,t b){return t(su(a.a,b.a),su(a.b,b.b));}\nsuMM(w11)suMM(w12)suMM(w13)suMM(w14)\n//in the end mix() has an identity,and that identity does translate into DA:\n#define mixd(a,b,c) ad(mu(c,su(a,b),a)\n//a big issue of this is that mixd() and mind() where defined as MAT-functions,vut using the AD-labeling\n//so is just deleted that junk code\n//I define mind()and=maxd(-,-)instead of maxd()and=mind(-,-)\n//because min()is far more common than max(),for z-buffering.\n//negation identity:max(a,b)--min(-a,-b),requires struct negation\n//addition is negated substraction.\n#define ad(a,b) su(a,ne(b))\n//AD_mu simplifies contextually ,scalar multiplication is tautological product_rule.\n#define adM2(h) h mu(h a,vec1 b){return h(mu(a.a,b),mu(a.b,b));}\n#define adM1(h) adM2(h)h mu(vec1 a,h b){return mu(b,a);}\n#define atta(h,i,j) h mu(i a,j b){return h(mu(a.a,b.a),ad(mu(a.b,b.a),mu(a.a,b.b)));}\n#define attA(h) atta(h,h,w11)atta(h,h,h)atta(h,w11,h)\nadM1(w11)adM1(w12)adM1(w13)adM1(w14)\natta(w11,w11,w11)attA(w12)attA(w13)attA(w14)//oh i really like this attA()-way of folding it\nDAm2 mu(DAm2 p,vec3 s){return DAm2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nDAm1 mu(DAm1 p,vec2 s){return DAm1(mu(p.x,s.x),mu(p.y,s.y));}\nDAm0 mu(DAm0 p,vec1 s){return DAm0(mu(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define rXX(h) h di(h a,vec1 b){return h(di(a.a,b),di(a.b,b));}h di(vec1 a,h b){return h(di(a,b.a),di((mu(ne(a),b.b)),mu(b.a,b.a)));}\nrXX(w11)rXX(w12)rXX(w13)rXX(w14)\n//inverse scalar multiplication is a tautolotgy.\n//some of these may be nonsensical\n#define rXY(h,i,j) i di(h a,i b){return i(di(a.a,b.a),di((mu(ne(a.a),b.b)),(b.a*b.a)));}i di(i a,j b){return i(di(a.a,b.a),di((su(mu(a.b,b.a),mu(a.a,b.b))),(mu(b.a,b.a))));}\nrXY(w13,w12,w11)\nrXY(w11,w13,w13)\nrXY(w12,w13,w11)\nrXY(w11,w14,w14)//just guessing this line\nrXY(w12,w14,w11)//just guessing this line\n//All exponential functions utilize their Base_E_identity:...which is still not efficient,but comes down to O(exp(n*log(n)))\n//pow (x,y)-=exp(log(x)*y)//baseE exponential and logarythmic functions.\n#define po(x,y)ex(mu(ln(x),x))\n/*\n//It gets trickier with functions that take 3 parameters:,applying the\n//https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem)with first derivatives.\n#define v0q vec1 q=length(vec2(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nw11 le(w11 x,w11 y){v0q;return w11(ll2\nw12 le(w12 x,w12 y){v0q;return w12(ll2\nw13 le(w13 x,w13 y){v0q;return w13(ll2\nw13 lengthw13(DAm2 u){return le(u.x,u.y);}//2*3domain\n//above is planar length 2 input parameters.below is 3d length.\nw13 le(w13 x,w13 y,w13 z){float q=length(vec3(x.a,y.a,z.a));return w13(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nw13 le(DAm2 u){return le(u.x,u.y,u.z);}//3*3domain\n//the utility of a length()function is clear.*/\n//su(ab(p),s)equals a translation away from the origin by [s] AND mirroring at origin,via abs()\n//...so it it clamps a an implicit surface to a limited \"thickness\" (in 3 domains),also translating its first derivatives.\nw12 suab(w12 p,vec1 s){return su(ab(p),s);}\nw11 suab(w11 p,vec1 s){return su(ab(p),s);}\nw13 suab(w13 p,vec1 s){return su(ab(p),s);}\nDAm2 suab(DAm2 p,vec3 s){return DAm2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nDAm1 suab(DAm1 p,vec2 s){return DAm1(suab(p.x,s.x),suab(p.y,s.y));}\nDAm0 suab(DAm0 p,vec1 s){return DAm0(suab(p.x,s));}\n\n\n//spheretracker /ePr is referenced by bicapsule() and other unsigned distances\n//ideally only a 4d marcher is defined,with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\nconst float iterRm=256.;\nconst float eRm=.0001;\nconst float zFar=200000.;\nconst vec2 EN=vec2(.005,0);\nvec2 df(vec3 p);\nfloat dFb(vec3 p);\n#define dNdom(u,a,b) (a(u+EN.b).x-a(u-EN.b).x)\n#define dNormal3X(u,a) normalize(vec3(dNdom(u,a,xyy),dNdom(u,a,yxy),dNdom(u,a,yyx)))\n \nvec4 trace(vec3 ray_start,vec3 ray_dir\n){//vec3 ray_start=a.a;vec3 ray_dir=a.b\n ;float ray_len=0.\n ;vec3 p=ray_start\n ;for(float i=0.; i<iterRm;++i\n){float dist=df(p).x\n  ;if (dist < eRm) break\n  ;if (ray_len > zFar) return vec4(0)\n  ;p +=dist*ray_dir\n  ;ray_len +=dist;}return vec4(p,1);}\n//vec4 trace(vec3 a,vec3 b){return trace(v33(b,a));}//legacy compatible\n/*\nvec4 trace(v33 a\n){float t=0.\n ;for(float i=0.;i<iterRm;++i\n ){float d=df(a.a).x\n  ;if(d<eRm)return vec4(a.a,i);\n  ;if(t>zFar)return vec4(0)\n  ;a.a+=d*a.b*.5//this marther has its first step overstep way too often,doubling lipschitz evades this(poorly)\n  ;t+=d;}return vec4(a.a,iterRm);}\nvec4 trace(vec3 a,vec3 b){return trace(v33(a,b));}//legacy compatible\n*/\n\n//spheretracker\n//ideally only a 4d marcher is defined, with special cases for less domains\n//but usually a 4d object only is traced as its 3d shadow/hyperslice.\n//const float iterRm=160.;\n//const float eRm=.001;\n//const float zFar=20000.;\n\n\n\n//\"crossproduct\" and \"determinant\" are related,cross() is the bilin()* of a lin()_determinant()\n//therefore i can fold the detemrinant() mnamespace onto the cross() namespace.\n//a cross() has 2 inpouts,where a determinant() has 1 input\n//we generalize \"crossproduct\" into its ternary: \"find the only vector that in a 90deg angle to all inputs\"\nvec2 cr(vec2 a){return a.yx*vec2(-1,1);}//rotBy4\nvec3 cr(vec3 a,vec3 b){return cross(a,b);}\n//vec4 cr(vec4 a,vec4 b,vec4 c){\n//solve LinearEquation for   dot(a,d)=0;dot(b,d)=0;dot(c,d)=0;with additional constrains to length(d)==1\n//}\n//[a bilinear (2 input vectors) product with a vector result only exists in 3d and 7d,in 7f it has more than 2 results (handedness,signs)\n//7d_dotproduct() is the octonion_pairing to 3d_quaternion.\nfloat det2d(vec2 a,vec2 b){return dot(a,cr(b));}//a.x*b.y-a.y*b.x//2d determinant(mat2(a,b))==det2d(a,b)==perpendicular dotproduct perpdot dotperp\n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos,p.zy),perm2(u5cos,p.zx),perm2(u5cos,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//noronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\nv33 ff(vec3 a){return v33(fract(a),floor(a));}//BUT here mat3 would just waste memory and mat32 mat23 are less comatible.\nv22 ff(vec2 a){return v22(fract(a),floor(a));}\nvec2 ff(float a){return vec2(fract(a),floor(a));}\nv33 su(vec2 a,v33 b){return v33(a.x-b.a,a.y-b.b);}\nv33 mu(float a,v33 b){return v33(a*b.a,a*b.b);}\nmat3 su(mat3 a,mat3 b){return a-b;}\nmat3 addf(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n\n//fast cellular noise,optimized by ollj\n//mouse.xy is basically \"salting hashes\"\n//imouse.x sets jitter range[0..1] 0 is squares,1 is maximum jitter. (known bug,iMouse.x-scaling for lower left quadrant is a bit bad here)\n//imouse.z sets hash dividend,is ideally 1/7,but others can be fine too.use like a salt.\n//lower left quadrant is 2d input noise2x2x2\n//the other 3 quadrants are 3d input noises3x3x3 where .z is iTime.\n//the 3 quadrants inputs are swiveled differently to debug 3 orthogonal hyperplanes in one view.\n//return value .x is L1,.y is L2 according to [worley noise]\n//this uses a lot of mat2,or the v33 struct,and permute()functions similar to ahsima-simplex noise,defers the sorting,for performance.\n//Cellular noise (\"Worley noise\")in 3D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license.\n//See LICENSE file for details.\n//https://github.com/stegu/webgl-noise\n#define mous (iResolution.xyxy-iMouseZwFix(iMouse,true))//flip mouse everywhere,for shadertoy fun\nmat3 fr(mat3 a){return mat3(fr(a[0]),fr(a[1]),fr(a[2]));}\n//mat3 fl(mat3 a){return mat3(fl(a[0]),fl(a[1]),fl(a[2]));}\nmat3 addd(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n//mat3 addF(mat3 a,vec3 b){return mat3(a[0]+b,a[1]+b,a[2]+b);}//contextual namespace hell.\nmat3 ma3(vec3 a,float b,float c){return mat3(a,vec3(b),vec3(c));}\n//th7 is for the 2d noise,should be (iResolution.y/7.),BUT i managed to make other values look fine,too\n#define th7 (mous.y/iResolution.y)//usually==1./7.,because mod(a,7)is famous for old LCGs.\n//th8 is for the 3d noise,should be (iResolution.y/7.),other values may work,but they tend to barely work at all,try only simple factors of 1/7\n#define th8 (iResolution.y/7./mix(1.,4.,mous.y/iResolution.y))//seems to be fine bounds,not too sure.\nvec3 mod2893d(vec3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nmat3 mod2893d(mat3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nvec3 mod73d(vec3 x){return x-floor(x*(1.0/th8))*th8;}//Modulo 7 without a division\nmat3 mod73d(mat3 x){return x-fl(x*(1.0/th8))*th8;}\n//Permutation polynomial:(34x^2+x)mod 289\nvec3 permute3d(vec3 x){return mod2893d((34.0*x+1.)*x);}\nmat3 permute3d(mat3 x){return mod2893d((34.0*x+1.)*x);}\n#define Kcel 1./th8//1/7\n#define Kcel2 1./th8/th8//1/(7*7)\n#define Kcelo (1.-Kcel)*.5//1/2-Kcel/2\n#define Kcelz 1./(th8-1.)//1/6\n#define Kcelzo .5-2./(th8-1.)//0.416666666667//1/2-1/6*2\n#define jitter mous.x/iResolution.x//smaller jitter gives more regular pattern\nmat3 perM3(vec3 p){return mat3(permute3d(p-1.),permute3d(p),permute3d(p+1.));}\nmat3 perM3(vec3 p,vec3 b){vec3 p1=permute3d(p+b.x-1.);vec3 p2=permute3d(p+b.y);vec3 p3=permute3d(p+b.z+1.);return mat3(p1,p2,p3);}\n#define maa(a,b,c) ma3(pf[0],pf[1].a,pf[2].b)+jitter*c\n#define mat3dd(a)a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n#define mat3ddmaa(a,b,c)mat3dd((maa(a,b,mat3(ox3[c],oy3[c],oz3[c]))))\nvec3 square(v33 a){return a.a*a.a+a.b*a.b;}\n//todo,make it traversable bny getting distance2Border.\nvec2 cellular(vec3 P,float m//not to be confuced with a voronoi3d,but can look similar.\n){vec3 p=mod2893d(floor(P))\n ;mat3 pf=addf(mat3(1,0,-1,1,0,-1,1,0,-1),fract(P)-.5)\n ;mat3 pp=perM3(permute3d(p.x+vec3(-1,0,1))+p.y)\n ;mat3 p1=perM3(pp[0]+p.z)\n ;mat3 p2=perM3(pp[1]+p.z)\n ;mat3 p3=perM3(pp[2]+p.z)\n ;mat3 ox=fr(p1*Kcel)-Kcelo\n ;mat3 ox2=fr(p2*Kcel)-Kcelo\n ;mat3 ox3=fr(p3*Kcel)-Kcelo \n ;mat3 oz=fl(p1*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz2=fl(p2*Kcel2)*Kcelz-Kcelzo\n ;mat3 oz3=fl(p3*Kcel2)*Kcelz-Kcelzo \n ;mat3 oy=mod73d(fl(p1*Kcel))*Kcel-Kcelo\n ;mat3 oyy=mod73d(fl(p2*Kcel))*Kcel-Kcelo\n ;mat3 oy3=mod73d(fl(p3*Kcel))*Kcel-Kcelo\n ;mat3 dy=jitter*oy+pf[1].x\n ;mat3 dy2=jitter*oyy+pf[1].y\n ;mat3 dz=addf(jitter*oz,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dz2=addf(jitter*oz2,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dx=mat3(pf[0],pf[0],pf[0])+jitter*ox   \n ;mat3 dx2=mat3(pf[0],pf[0],pf[0])+jitter*ox2\n ;mat3 d1=maa(x,x,mat3(ox[0],oy[0],oz[0]))\n ;vec3 d31=mat3ddmaa(z,x,0)\n ;vec3 d32=mat3ddmaa(z,y,1)\n ;vec3 d33=mat3ddmaa(z,z,2)\n ;vec3 d11=dx[0]*d1[0]+dy[0]*d1[1]+dz[0]*d1[2]\n ;vec3 d12=dx[1]*dx[1]+dy[1]*dy[1]+dz[1]*dz[1]\n ;vec3 d13=dx[2]*dx[2]+dy[2]*dy[2]+dz[2]*dz[2] \n ;vec3 d21=dx2[0]*dx2[0]+dy2[0]*dy2[0]+dz2[0]*dz2[0]\n ;vec3 d22=dx2[1]*dx2[1]+dy2[1]*dy2[1]+dz2[1]*dz2[1]\n ;vec3 d23=dx2[2]*dx2[2]+dy2[2]*dy2[2]+dz2[2]*dz2[2]\n ;mat3 a\n //for a second pass that also gets distance2Border i need these 3 values\n //mg=g;//ID to shortest distance cell (integer vector)\n //mr=r;//vector to shortest distance    md=d;//shortest distance squared==is dot(r,r)\n //Sort out the two smallest distances (F1,F2)\n #if 0\n ;vec3 d1=min(min(d11,d12),d13) //sort out only F1\n ;vec3 d2=min(min(d21,d22),d23)\n ;vec3 d3=min(min(d31,d32),d33)\n ;vec3 d=min(min(d1,d2),d3)//shortest of 9 distances,except its 9*vec3()\n ;d.x=min(min(d.x,d.y),d.z)\n ;return vec2(sqrt(d.x));}//F1 F1\n #else\n ;vec3 d1a=min(d11,d12)//sort out F1 and F2\n ;d12=max(d11,d12)\n ;d11=min(d1a,d13)//Smallest now not in d12 or d13\n ;d13=max(d1a,d13)\n ;d12=min(d12,d13)//2nd smallest now not in d13\n ;vec3 d2a=min(d21,d22)\n ;d22=max(d21,d22)\n ;d21=min(d2a,d23)//Smallest now not in d22 or d23\n ;d23=max(d2a,d23)\n ;d22=min(d22,d23)//2nd smallest now not in d23\n ;vec3 d3a=min(d31,d32)\n ;d32=max(d31,d32)\n ;d31=min(d3a,d33)//Smallest now not in d32 or d33\n ;d33=max(d3a,d33)\n ;d32=min(d32,d33)//2nd smallest now not in d33\n ;vec3 da=min(d11,d21)\n ;d21=max(d11,d21)\n ;d11=min(da,d31)//Smallest now in d11\n ;d31=max(da,d31)//2nd smallest now not in d31\n ;d11.xy=(d11.x<d11.y)?d11.xy:d11.yx\n ;d11.xz=(d11.x<d11.z)?d11.xz:d11.zx//d11.x now smallest\n ;d12=min(min(d21,min(d22,d31)),min(min(d12,d21),min(d22,d32)))\n ;d11.yz=min(d11.yz,d12.xy)//nor in d12.yz\n ;d11.y=min(d11.y,d12.z)//Only two more to go\n ;d11.y=min(d11.y,d11.z)//Done! (Phew!)\n ;return sqrt(d11.xy);}//F1,F2\n#endif\n//crunched by ollj\n//Cellular noise (\"Worley noise\")in 2D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license of://https://github.com/stegu/webgl-noise\n//mod(a,289.)without a division (only multiplications),because [mod(33.,33.)!=0] on too many implementations.\nvec3 mob89(vec3 a){return a-floor(a*(1./289.))*289.;}\nvec2 mob89(vec2 a){return a-floor(a*(1./289.))*289.;}\nv22  mob89(v22  a){return v22(a.a,a.b-floor(a.b*(1./289.))*289.);}//vers ypecial use case\nmat2 mob89(mat2  a){return mat2(a[0],a[1]-floor(a[1]*(1./289.))*289.);}//vers ypecial use case\nvec3 modth7(vec3 a){return a-floor(a*th7)/th7;}//Modulo 7 without a division\nv33  modth7(v33  a){return v33(a.a,(a.b-floor(a.b*th7)/th7)*th7);}//special case for a #define\nvec3 permute(vec3 a){return mob89((34.*a+1.)*a);}//Permutation polynomial:(34x^2+x)mod 289\n#define tt3(p,f,j,m,a)square(su(j,su(v33(vec3(a),f),mu(m,mu(m,modth7(ff(p*th7)))))))\n#define permi(c)p=permute(o+k.b.y+px.c)\n#define ppm(d,e,c)r[d]=tt3(p,f,k.a,m,e);permi(c)\n//Cellular noise,returning F1 and F2 in a vec2//3x3-hood reduced to 2 permute()as special case voronoi\n//m[0..1] sets distortedness for a GOOD LCG (minimal self-similarity)m=1./7.,by sqiveling this parameter,you get+0.7 domain very cheaply\n//as in by making m a 3rd parameter,you ALMMOST get cheap cellular3d noise,BUT it is likely a bit flawed,more repetitive,shorter period.\nvec2 cellular(vec2 P,float m//this is voronoi without loop.the permute()function marks+1 iteration/tap//is 4tap voronoi in O(3)\n){v22 k=mob89(ff(P))\n ;vec3 o=vec3(-1,0,1),f=o+.5,px=permute(o+k.b.x),permi(x)\n ;mat3 r\n ;ppm(0,-.5,y)//it seems that the loop got unrolled and al lits min()fucntions fold into the below\n ;ppm(1,+.5,z)//...//which is quite a lot of symmetry folding,surely gets better performance.\n ;r[2]=min(r[0],r[1])\n ;r[1]=clamp(r[1],r[0],tt3(p,f,k.a,m,1.5))\n ;r[0]=min(r[1],r[2])\n ;r[1]=max(r[2],r[1])\n ;r[0].xy=mix(r[0].yx,r[0].xy,step(r[0].x,r[0].y))\n ;r[0].xz=mix(r[0].zx,r[0].xz,step(r[0].x,r[0].z))\n ;r[0].yz=min(r[0].yz,r[1].yz)//can not be inserted in below line ,because r[0].y is a return value.\n ;r[0].y=min(mi(r[0].yz),r[1].x)\n ;return sqrt(r[0].xy);}\n//simplex noise3d (simplex noise is worth it for higher dimensions)\n//Original:https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec4 permute(vec4 x){return mod(x*x*34.+x,289.);}\nfloat simplex1(vec3 v//ashima simplex3d,early optimizations by @makio64,structure by @ollj  https://www.shadertoy.com/view/Xd3GRf\n){const vec2 C=1./vec2(6,3);const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy)),x0=v-i+dot(i,C.xxx),g=step(x0.yzx,x0.xyz),l=1.-g//is a sequence of 4,no parallelization\n ;v33 f=v33(min(g.xyz,l.zxy),max(g.xyz,l.zxy));v3333 d=g3333(x0,su(x0,g333(su(f,g33(C)),D.yyy)))\n ;i=mod(i,289.);v222 F=g222(f);vec3 ns=.142857142857*D.wyz-D.xzx\n ;vec4 p=permute(permute(permute(i.z+vec4(0,F.c,1))+i.y+vec4(0,F.b,1))+i.x+vec4(0,F.a,1)),j=p-49.*floor(p*ns.z*ns.z),k=floor(j*ns.z)\n ;v44 t=ad(mu(v44(k,floor(j-7.*k)),ns.x),ns.y)\n ;vec4 h=1.-abs(t.a)-abs(t.b),a=-step(h,vec4(0))\n ;v44 b=v44(vec4(t.a.xy,t.b.xy),vec4(t.a.zw,t.b.zw))\n ;b=ad(v44(b.a.xzyw,b.b.xzyw),mu(v44(a.xxyy,a.zzww),ad(mu(fl(v44(b.a.xzyw,b.b.xzyw)),2.),1.)))\n ;v3333 q=v3333(vec3(b.a.xy,h.x),vec3(b.a.zw,h.y),vec3(b.b.xy,h.z),vec3(b.b.zw,h.w))\n ;q=muv(q,inversesqrt(ddv(q)));vec4 m=max(.6-ddv(d),0.)\n ;return .5+12.*dot(m*m*m,vec4(dot(q.a,d.a),dot(q.b,d.b),dot(q.c,d.c),dot(q.d,d.d)));}\n\n//fbm of dr2 noise (with multitap normals),is a bit crude,in favor for fast normals.\n#define fBm(a) vec2 b=vec2(0,1);for(int i=0;i<a;i++){b=vec2(b.x,0)+vec2(noise1(p),.5)*b.y;p*=2.;}return b.x/(2.-b.y);}\nvec1 fbm(vec1 p){fBm(5)vec1 fbm(vec2 p){fBm(5)vec1 fbm(vec3 p){fBm(5)vec1 fbms(vec3 p){fBm(3)\nvec1 fbmn(vec3 p,vec3 n){vec4 r=vec4(0,0,0,1);for(int i=0;i<4;i++\n){r=vec4(r.xyz,0)+r.w*vec4(vec3(noise1(p.yz),noise1(p.zx),noise1(p.xy)),.5);p*=2.;}return dot(r.xyz,abs(n));}\nvec3 VaryNf(vec3 p,vec3 n,vec1 f\n){vec2 e=vec2(.1,0);vec3 g=vec3(fbmn(p+e.xyy,n),fbmn(p+e.yxy,n),fbmn(p+e.yyx,n))-fbmn(p,n)\n ;return norma(n+f*(g-n*dot(n,g)));}\nfloat fbma(vec3 p//fbm of ashima simplex (no normals,duh)\n){float f\n ;f=.5*(simplex1(p));p=p*2.01\n ;f+=.25*(simplex1(p));p=p*2.02\n ;f+=.125*(simplex1(p));p=p*2.03\n ;f+=.0625*(simplex1(p));p=p*2.04\n ;f+=.03125*(simplex1(p));return f;}\n\n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\nfrflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)frflpm(v44,c44)\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\nfloat Blob(vec3 p){p=ab(p);p=mx(p,p.yzx,st(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) ad(dt(p,n),d)\n#define abm(a,b) su(ab(a),b)//ditance taxicap   -b\n#define lbm(a,b) su(le(a),b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))//==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a))//i am not convinced by this one\n#define box(a,b) roundit(abm(a,b))\nfloat fBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(ma(d,vec3(0)))+ma(min(d,vec3(0)));}\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define segment2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,segment()sub ,is squared distance\n#define segment(a,b,c) sq(segment2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n#define segmentY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\n//note that a torus can not be mStretch()ed into a tube\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both chicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u,vec4 m){\n//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x);//calculate dorated differential\n return dot(u-m.xy,(f));//signed distance to line \n//more generally,f should be normalized here for proper caling.\n//but scaling is irrelevant as we only care fror the sign \n}\n//earvageg is still far from standardized. rac is the central radius, should be parametric.\nfloat EarVagEgg(vec2 u,vec2 m//m.x+m.xy<=1. is televant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=mix(.5,3.,sin(iTime)*.5+.5)\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (sd2l(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(sd2l(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //CylEarVagEgg() is capped cylinder to extrude it to 3d.\nfloat EarVagEgg(vec2 u,vec3 m//m.x+m.xy<=1. is televant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=m.z\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (sd2l(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(sd2l(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //CylEarVagEgg() is capped cylinder to extrude it to 3d.\n \n//pointUdistance to cylinder of thickness h of shapeFunction z example for z==(abs(EarVagEgg(u.xy,m))-.05\n//#define cyl(u,h,z) ma(abs(u.z)-h,abs(abs(EarVagEgg(u.xy,m))-.05)-.02)//nope can not indert a function() as #defione param\nfloat CylEarVagEgg(vec3 u,vec2 m,float h){return ma(abs(u.z)-h,abs(abs(EarVagEgg(u.xy,m))-.05)-.02);}\n\n\n#define tiny .000001\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\nvec2 CoordCross(vec3 u\n){vec3 o=vec3(2,.1,2)\n ;vec2 b=vec2(box(u-o*vec3(1,-1,1),o),-1)\n ;float e=ma(ab(u))-9.*u5(cos(iTime))//distance from vec3(0) where coordinate crosses are drawn\n ;u=fract(u/2.-.5)-.5\n ;float c=ma(ab(u))+.125*e//width of each coordinate cross\n ;float y=step(abs(u.z),abs(u.x))\n ;u.xz=mix(u.xz,vec2(-u.z,u.x),step(abs(u.z),abs(u.x)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;y+=step(abs(u.z),abs(u.y))*2.\n ;u.yz=mix(u.yz,vec2(-u.z,u.y),step(abs(u.z),abs(u.y)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;float d=ma(ab(u.xy))+.003*e//thickness of coordinate crosses\n ;d=ma(d,c) \n ;d=ma(d,e)\n ;vec2 r=vec2(d,y)\n ;r=minx(r,b)\n ;return r\n ;}\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5cos(2.*pi*ab012(a,b));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below,but close\nvec3 hsv2rgb(const vec3 c){return c.z*mx(1.,sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n\n\n\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\nstruct v21{vec2 a;vec1 b;};//currently only for alpha compositing plans\nstruct v31{vec3 a;vec1 b;};//...for MAT arithmetic\nstruct v41{vec4 a;vec1 b;};\nv21 su(v21 a,v21 b){return v21(a.a-b.a,a.b-b.b);}\nv21 mu(v21 a,v21 b){return v21(a.a*b.a,a.b*b.b);}\nv21 mu(v21 a,vec1 b){return v21(a.a*b,a.b*b);}\nv31 su(v31 a,v31 b){return v31(a.a-b.a,a.b-b.b);}\nv31 mu(v31 a,v31 b){return v31(a.a*b.a,a.b*b.b);}\nv31 mu(v31 a,vec1 b){return v31(a.a*b,a.b*b);}\nv41 su(v41 a,v41 b){return v41(a.a-b.a,a.b-b.b);}\nv41 mu(v41 a,v41 b){return v41(a.a*b.a,a.b*b.b);}\nv41 mu(v41 a,vec1 b){return v41(a.a*b,a.b*b);}\n//generalizing alpha-compositing functions,named after porterDuff\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent,.W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs with their alpha;\n// a.xyz*=a.w ; b.xyz*=b.w\n//.x inputs (ant interpolants) should be sat()ed,or you likely get [color inverted hazes],this version si still not haze-free?\n//ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//ommits 2 functions,that return a or b,for simplicity\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n//#define pd5(z)z pdOut(z a,z b){return ut(b,a.b);}z pdOver(z a,z b){return ad(ut(b,a.b),a);}z pdAtop(z a,z b){return ad(ut(b,a.b),mu(a,b.b));}z pdXor(z a,z b){return ad(ut(b,a.b),ut(a,b.b));}\n//pd5(v11)pd5(v21)pd5(v31)pd5(v41)//if you want alpha seperated in a struct\n//making tweening/unifying functionms of alpha compositing is silly fun. c is best range [0..1]\n//this reduces it to 5. within pd() unifying function,because 4/5 include ut(a,b),i segregate 1/5_pdIn()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\nvec3 pf(vec4 a,float c,vec4 b//c sets a mix type of this generalized function\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//c sets a mix type.makes little sense to bilinn 4 functions on a plane,done anyways\n ;a=mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w)\n ;return a;}//you likely want to a=sat(a) the c.x input,or have some negative-outlineglow-colors on -1>c>1\n\n\n\n\n//smin: 2nd letter sets 1of3 boolean fuzzy-unions,\"mex()\"==max(a,-b) is semi-nonsense;\n//3rd letter sets type of smoothing union\n//sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))//sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)//sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\nw11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n);}//somehow almost correct.\n//SminPPolynomial [m*e] by IQ is fast but not commutative; mis2() is subroutine\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//sMinQuadratic mar()mir()mer() use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n\nfloat recsum(vec2 a){return 1./(su(1./a));}\n\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)//sMaxExponential\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))\n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//(a)*(b)*(c)/((b)*(c+1.)+(a)*(b+1.))//smells like nonsense\n#define miso2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define miso3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)//sAvgExponential\n\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(iTime*vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-miso3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n\nvec4 demoSmin(vec2 u,vec2 m,vec2 n//smin (exponential and polinomial) , with automativDifferenciation\n){return demoSminBone3(u,m,n)\n ;w11 a=w11(u.x-m.x*9.,1.)\n ;w11 b=w11(u.x-m.x*9.,1.)\n ;m.x=abs(m.x)+.2//optional evasion of very short wavelength\n ;vec4 c=vec4(0)\n ;float amp=1.//m.y\n ;a=   mu(co(di(a,di(m.x,mu(pi,.5)))),amp)//a.b is analytic first derivative of a.a\n ;b=ad(mu(si(di(b,di(m.x,mu(pi,.5)))),amp),mu(si(b),.3))//b.b is analytic first derivative of b.a\n ;a=su(co(mu(a,2.)),mu(a,.2))\n ;b=su(si(mu(b,2.)),mu(b,.561))\n ;w11 d=mae(a,b,1./m.y)\n ;w11 e=mae(a,b,1./m.y)\n ;w11 f=mas(a,b,3.*m.y)\n ;c.y=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.x=abs(b.a-u.y)/sqrt(1.+b.b*b.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.z=abs(d.a-u.y)/sqrt(1.+d.b*d.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;c.w=abs(f.a-u.y)/sqrt(1.+f.b*f.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;//c=abs(c-.2)-.1//optional shows how this is NOT distance2Sin()\n ;c=abs(c-aaa*2.)-aaa*.5//optional double line\n ;c=smoothstep(aaa,-aaa,c)\n ;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n ;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec4 y=vec4(angleToColor(vec3(rainb.y,1,1)),c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(angleToColor(vec3(rainb.z,1,1)),c.z)//coordinate system in magenta/pink\n ;vec4 w=vec4(angleToColor(vec3(rainb.w,1,1)),c.w)//coordinate system in magenta/pink\n ;x.xyz*=x.w;y.xyz*=y.w;z.xyz*=z.w;w.xyz*=w.w//alpha premultiplied\n ;x=pdOver(y,x)\n ;x=pdOver(z,x)\n ;x=pdOver(w,x)\n ;return x;}\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n\n\n \n/*\n//return distance to(barely more than a)half-donut,bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);\n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n//if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n//https://www.shadertoy.com/view/ldSBR3\n//return distance to sideways.horse-silhouette,optimized for speed.\nfloat silHorse(vec2 u//main plan is to use something common with low symmetry, to demo folding patterns.\n){//u-=m.xy;//move by m.xy\n ;float t=length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))+.5//tail\n ;float r=length(vec2(-1.5-u.x,mStretchP(u.y,4.)))+.5\n ;float l=length(vec2(1.5-u.x,mStretchP(u.y,7.5)))+.5//front\n ;u.y-=3.5\n ;vec2 n=vec2(2.25-u.x,u.y-2.5)\n ;float h=length(n)-.5//head\n ;n+=vec2(1.3,.7)\n ;h=min(h,length(n)+.3)\n ;u.x=mStretch(u.x,1.1)\n ;float b=length(u)-.2\n ;//h=length()\n ;//vec2 v=abs(u-vec2(.5))\n ;//return b\n ;return min(min(min(h,b),min(l,r)),t)\n ;return ellipseCheap(u)-1.5\n ;return length(u);}\nfloat CylSilHorse(vec3 u,float h){return ma(abs(u.z)-h,(silHorse(u.xy*3.)-1.)/3.);}\n\n\nfloat legs4(vec3 u,vec3 d //distance to the 4 legs of a table d.y=tableHeight. d.xz=distancesBetweenLegs.\n){u.y=mStretchP(u.y,d.y)\n ;u.xz=abs(u.xz)-d.xz\n ;return le(u)\n ;}\nfloat horseBody(vec3 u\n){u.x=mStretch(u.x,.45)\n ;return length(u-vec3(0,1.1,0))\n ;}\n\n//accidental vulalike, due to 2x -.5 offset\n// ;r=length(vec2(u.z,length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))-.5))-.5  //tail\n\nfloat horseTail(vec3 u\n){return (length(vec2(u.z,length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))))+.2)*.5;}\n\nfloat horseAnus(vec3 u){return torus((u.yxz+vec3(-1.3,.82,0)),.06);}\nfloat horseVag(vec3 u\n){u.z=mStretch(u.z,.2)\n ;u.xy-=vec2(1,0)\n ;float scale=3.2\n ;return length(vec2(u.z,EarVagEgg(u.xy*scale,vec3(.01,.25,1.2))/scale)-.01)\n ;}//CylEarVagEgg(((u.zyx-vec3(1,.8,.25)))*2.,.5*iMouse.xy/iResolution.xy,.2)\nfloat horseButt(vec3 u){\n ;u.z=abs(u.z)-.2\n ;return length(u-vec3(-.57,1.1,0))-.2\n ;}\n\nfloat SilHorse(vec3 u\n){float r=legs4(u,vec3(.5,1,.26))-.18\n ;r=mis(r,horseBody(u)-.4,.3)//torso\n ;r=mis(r,le(u-vec3(.5,1.4,0))-.05,.2)//neck\n ;r=mis(r,le(u-vec3(.8,1.9,0))-.5,.2)//head\n ;r=mis(r,horseButt(u),.3)\n ;float s=mis(horseVag(u.zyx-vec3(-1,.9,-.65))-.03,horseAnus(u)-.03,.05)\n ;r=mis(r,s,.05)\n ;r=mis(r,(horseTail(u*2.3+vec3(-.1,.9,0))+u.x*.3+.1),.6)//tail has some tricky lipschitz tweaks\n ;return r;\n ;}\n\nvec2 FactorioFurnace(vec3 u){\n ;float d=length(u)\n ;return vec2(d,1)\n ;}\n \n\n\nvec2 debugHg2(vec3 u){\n ;vec2 r=vec2(zFar,0.)\n ;float t=cos(iTime)*.4+.5\n ;r=minx(r,FactorioFurnace(u))\n ;//r=minx(r,CoordCross(u))//coordinate crosses\n ;u.x=1.-u.x//flip towards light source\n ;//r=minx(r,vec2(CylEarVagEgg(((u.zyx-vec3(1,.8,.25)))*2.,.5*iMouse.xy/iResolution.xy,.2),13))\n ;float h=CylSilHorse(u-vec3(1,0,3),.4)\n ;r=minx(r,vec2(h,13))\n ;r=minx(r,vec2(SilHorse(u-vec3(1,0,0)),14))\n ;//r=box(u,vec3(1))-t\n ;//r=length(u-bicapsule3(u,vec3(-.5,0,2),vec3(.5,0,2),.7,.2))-.1\n ;//bicapsule(u,vec3(1,0,0),vec3(0,0,1),.5,2.)\n ;//r=Blob(u)\n ;//r=fPlane(abs(u),vec3(1,1,1),-1.5)//the raymarcher is not ideal for this one,with its alpha fadeout.\n ;//r=boxf(u,vec3(1))-.5\n ;//r=corner(u.xy)\n ;//r=cylinder(u,1.,1.)\n ;//failed to make a rounded cylinder via roundit()\n ;//r=segment(u,vec3(0),vec3(1,2,3))-t\n ;//r=segmentY(u,vec2(1,2))//could not get it to work instantly\n ;//r=torus(u,1.)-1.\n ;//r=disc(u,vec2(1.))-2.//could not get it to work instantly\n ;//r=hexCircum(u,1.)-1.\n ;//r=fCone(u,1.,2.)\n ;return r;}\n//2-distance input unions\n//note,for higher dimensions,i may prefer; input (a,b); over; input (a.x,a.y)\n#define miChamfer(a,b,r) mi(mi(a,b),(a-r+b)*sq(.5))\n#define maChamfer(a,b,r) ma(ma(a,b),(a+r+b)*sq(.5))\n#define meChamfer(a,b,r) maChamfer(a,-b,r)\n//above chamfer are worse around 90deg; below chamfer is worse near 180deg. both are still good upper bounds. below is \"smoother\"\n#define chamfer1802(a,b,r,e) mi(a,b)-(e)*(e)*.25/(r)\n#define chamfer180(a,b,r) chamfer1802(a,b,r,ma0(r-abs(a-(b))))\n//a is 2 distances,b is a radius //todo,compare with mima()\n#define miRound(a,b) mi(ma0(a),-b)+le(ma0(b+a))//is likely wrong\n#define maRound(a,b) -fOpRoundMin(-a,b)//is likely wrong\n#define meRound(a,b) fOpRoundMin(a*vec2(1,-1),r);}//is likely wrong\n/*\n#define _M(S) (float a,float b,float r,float n){float c,m=min(a,b);if(a>r||b>r)return S*m;vec2 p=vec2(a,b);c=r*1.41421356237/(n*2.-0.58578643762);pR45(p);\nfloat micolumns _M(1.)\n ;p.x+=sqrt(.5)*-r+c*sqrt(2.)\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b)\n ;}\n\nfloat macolumns _M(-1.)\n p.y+=c;p.x=sqrt(.5)*(r+c)/p.x\n ;if(mod(n,2.)==1.)p.y+=c;pmod(p.y,c*2.)\n ;p.y=-mi(le(p)-c,p.x)\n ;return mi(mi(p.y,a),b);}//fails on its own\n#define mecolumns(a,b,r,n) -macolumns(a,-b,r,n)/**/\n\n\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n){float s=r/n;float u=b-r;return mi(mi(a,b),.5*(u+a+abs(mo(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\nvec2 debugHg(vec3 u){\n ;return debugHg2(u)\n ;float r=0.\n ;u.z-=1.\n ;float t=cos(iTime)*.4+.5\n ;float a=box(u   ,vec3(1))-t\n ;//u.xy*=r2(1.)\n ;float b=box(u-1.,vec3(1))-.2\n ;//return mi(a,b)\n ;//return ma(a,b)\n ;//return ma(a,-b)\n ;//return miChamfer(a,b,0.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return miChamfer(a,b,3.5)//chamfer over more than the difference and get a nice roudned shape\n ;//return maChamfer(a,b,.5)//not sure if broken or tracer issue\n ;//return meChamfer(a,b,.5)\n ;//return chamfer180(a,b,.5)//round chamfer is best\n ;//return -chamfer180(-a,-b,.5)//max() round chamfer is weird but fun\n ;//return -chamfer180(-a,b,.23)//max(a,-b) round chamfer easily gets discotinuous\n ;//return chamfer180(a,b,3.5)//overchamfering round is bumpy\n ;//return miRound(a,b)//todo fixme\n ;//return mistairs(a,b,.5,13.)\n ;//return mistairs(a,b,.5,13.)\n ;//return mestairs(a,b,.5,13.)\n ;a=micolumns(a,b,.5,4.)\n ;//return mecolumns(a,b,.5,4.)\n ;//return mucolumns(a,b,.5,4.) \n ;//return macolumns(a,b,.5,4.)//macolumns fails\n ;//return mecolumns(a,b,.5,4.)\n ;//return pipe(a,b,.2)\n ;//return engrave(a,b,.5)\n ;//return -groove(-a,b,.5,.1)\n ;//return tongue(a,b,.5,.1)\n ;return vec2(a,1);}\n\n\n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\nfloat sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is\n){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2\n){vec2 d=vec2(-p.z,p.z)-h\n ;float si=.5*(r1-r2)/h\n ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)\n ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}\n/*\nfloat sdConeSection( vec3 p, float h, float r1, float r2 ){\n  float d1=-p.z-h;\n  float q=p.z-h;\n  float si=0.5*(r1-r2)/h;\n  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );\n  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}*/\n\n\n\n\n\n//https://www.shadertoy.com/view/XdVyRd\nbool SolveSquare(float A,float B,float C,out vec2 x\n){float D=B*B-4.0*A*C\n ;if(D<0.0)return false\n ;x.x=(-B-sqrt(D))/(2.0*A)\n ;x.y=(-B+sqrt(D))/(2.0*A)\n ;return true;}\nfloat sphIntersect(vec3 ro,vec3 rd,vec4 sph//https://www.shadertoy.com/view/4tlBDs\n){vec3 oc=ro-sph.xyz//this one is by iq, with his mit licensing.\n ;float b=dot(oc,rd)\n ;float c=dot(oc,oc)-sph.w*sph.w\n ;float h=b*b-c\n ;if(h<0.0)return-1.\n ;return-b-sqrt(h);}\nbool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float A=dot(rd,rd)\n ;float B=2.0*dot(ro,rd)\n ;float C=dot(ro,ro)-SpRad*SpRad\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;t=min(tt.x,tt.y)\n ;if(t<0.0)return false\n ;norm=normalize(ro+t*rd)\n ;return true;}\n//cube intersection function\nbool cube (vec3 p,vec3 dir,vec3 pos,float size,inout vec2 startend,inout vec3 side,inout vec3 hit\n){float fix=.00001//https://www.shadertoy.com/view/MtSGRc\n ;vec3 minim=pos-vec3(size)*.5\n ;vec3 maxim=pos+vec3(size)*.5\n ;vec3 omin=(minim-p)/dir\n ;vec3 omax=(maxim-p)/dir\n ;vec3 maxi=max(omax,omin)\n ;vec3 mini=min(omax,omin)\n ;startend.y=min(maxi.x,min (maxi.y,maxi.z))\n ;startend.x=max(max(mini.x,0.0),max(mini.y,mini.z))\n ;float rayhit=0.\n ;if(startend.y-startend.x>fix)rayhit=1.\n ;hit=p+startend.x*dir\n ;side=vec3(0,0,-1.)//get normal\n ;if(abs(hit.x-minim.x)<fix)side=vec3( 1, 0,0)\n ;if(abs(hit.x-maxim.x)<fix)side=vec3(-1, 0,0)\n ;if(abs(hit.y-minim.y)<fix)side=vec3( 0, 1,0)\n ;if(abs(hit.y-maxim.y)<fix)side=vec3( 0,-1,0)\n ;if(abs(hit.z-minim.z)<fix)side=vec3( 0, 0,1)\n ;return rayhit>.5;}\nbool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float Al=ConeR_ab.x*rd.z\n ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y\n ;float A=dot(rd.xy,rd.xy)-Al*Al\n ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)\n ;float C=dot(ro.xy,ro.xy)-Bl*Bl\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;vec2 zz=ro.zz+rd.zz*tt\n ;int n=2\n //todo: apply zz.x-=zz.y and do the LessThan magic\n ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}\n ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}\n ;if(n==0)return false\n ;t=min(tt.x,tt.y)\n ;norm.xy=normalize(ro.xy+rd.xy*t)\n ;norm.z=-ConeR_ab.x\n ;norm=normalize(norm)\n ;return true;}\n\n\n//The MIT License\n//Copyright © 2017 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 parallelogramIntersect(vec3 ro,vec3 rd,vec3 v0,vec3 v1,vec3 v2//https://www.shadertoy.com/view/4tlBDs\n){vec3 a=v0-v1\n ;vec3 b=v2-v0\n ;vec3 p=v0-ro\n ;vec3 n=cross(a,b)\n ;vec3 q=cross(rd,p)\n ;float i=1.0/dot(rd,n)\n ;float u=dot(q,a)*i\n ;float v=dot(q,b)*i\n ;float t=dot(n,p)*i\n ;if(u<0.0 || u>1.0 || v<0.0 || v>1.0)return vec3(-1.0)\n ;return vec3(t,u,v);}\n\n\n//is a bit lame, because it just traces 3 things seperately.\nbool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm\n){if(spZRad1.x>spZRad2.x\n ){vec2 tmp=spZRad1\n  ;spZRad1=spZRad2\n  ;spZRad2=tmp;}\n ;vec2 ConeCaps\n ;float spdz=spZRad2.x-spZRad1.x\n ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz\n ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz\n ;ConeCaps.x=spZRad1.x-h1\n ;ConeCaps.y=spZRad2.x-h2\n ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)\n ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)\n ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)\n ;vec2 ConeR_ab\n ;ConeR_ab.x=dZdR.y/dZdR.x\n ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x\n ;float sp_t\n ;vec3 sp_n\n ;int n=0\n ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}\n ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;return(n>0);}\n \n//The MIT License\n//Copyright © 2016 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//trace capsule.if(missed)return vec4(-1); return vec(SmallestPositiveIntersection,normal.xyz)\nvec4 iCapsule(vec3 u,vec3 d,vec3 b,vec3 a,float t//rayOrigin,rayDirection,BasePosition,CylinderSpine,radius\n){vec3 o=u-b;t*=t;float l=length(a)//cylinderspine goes from Baseposition to the center of the second sphere.\n ;if(l>0.//https://www.shadertoy.com/view/Xt3SzX\n ){vec3 e=a/l;vec2 v=vec2(dot(e,d),dot(e,o));//normalize and project\n  ;e=vec3(dot(o,d)-v.y*v.x,dd(o)-v.y*v.y-t,1.-v.x*v.x)\n  ;float h=perpdot(e.xy,e.zx)//trace cylinder hit condition\n  ;if(h<0.)return vec4(-1)//misses cyliner\n  ;e.z=(-e.x-sqrt(h))/e.z;v.y+=e.z*v.x;v.x=e.z//trace cylinder\n  ;if(abs(v.y)<l)return vec4(v.x,normalize(o+v.x*d-a*v.y/l));//return traced cylinder cylinder\n  ;u-=b+a*sign(v.y)//mirrored sphere\n  ;e.x=dot(u,d)//[o] has changed,this is a different dot(o,d)than the one earlier.\n  ;t+=e.x*e.x-dd(u)//difference between 3 squares\n  ;if(t>0.){v.x=-e.x-sqrt(t);return vec4(v.x,normalize(u+d*v.x));}\n ;}//else//trace sphere\n ;return vec4(-1);}//change to(1)to see the tangents\n\n\n\n\n//someone overthought checkerboard patterns\n//float xnor(float x,float y){return abs(x+y-1.);}// abs(0+0-1)-1 abs(1+0-1)-0 abs(0+1-1)-0 abs(1+1-1)-1\n//xnor(xnor(e.x,e.y),e.z)//checkerboard3d\n\n//struct Hit{vec3 n;}\n#define MAX_DEPTH 200.\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id\n){//intersect any quadric Ax^2+By^2+Cz^2-r=0  (this is only complicated because of the cap)\n //ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n p=ro-p ;//mx*(ro-p);rd=mx*rd;//for rotations\n vec2 pln=vec2(0.0);\n vec3 N;\n float Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n if(yCap!=vec2(0.0)){ \n  pln=vec2(p.y-yCap)/-rd.y;\n  if(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n }\n if(pln.y>=0.0){\n  float A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n  if(inner<0.0){//throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n   if(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n  }else{\n   inner=sqrt(inner);\n   vec2 t=vec2(-B-inner,-B+inner)/(2.0*A);\n   if(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n   t1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n  }\n  if(yCap!=vec2(0.0)){\n   if(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}//no hit\n   else if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n  }\n  //if(t1>0.0 && t1<H.t){   H.t=t1;H.id=id;H.n=normalize(N);//*mx;\n  //}\n }\n}//https://www.shadertoy.com/view/ldGGRD\n\n\n\nvec4 GN(int i//plane definitions for geod\n){vec4 n=vec4(0.0,1.0,0.0,0.5)\n ;    if(i==11)n.y=-n.y\n ;    else if(i>0\n ){        float j=mod(float(i)-1.0,5.0)\n  ;        float a=2.0*pi/5.0*j\n  ;        float y=0.6\n  ;        if(i>5){a+=pi/5.0;y=-y;}\n ;n=vec4(cos(a),y,sin(a),0.6);    }\n ;return n ;}\n\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id//trace geod\n){//a convex shape made by intersecting planes\n //find the farthest facing plane nearer then the closest back-facing plane\n p=ro-p;\n float t1=-MAX_DEPTH,t2=MAX_DEPTH;\n vec3 N1;\n for(int i=0;i<12;i++){\n  vec4 n=GN(i); //mx*N[i].xyz;\n  float frontface=dot( n.xyz,-rd );\n  float t=(dot( n.xyz, p )-n.w) / frontface;\n  if(frontface>0.0){\n   if(t>t1){N1=n.xyz;t1=t;}\n  }else{\n   if(t<t2){t2=t;}\n  }\n }\n //if(t1>0.0 && t1<=t2 && t1<H.t){H.t=t1;H.id=id;H.n=N1;//*mx;\n //}\n}//https://www.shadertoy.com/view/ldGGRD\n\n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\nfloat trapezoid2(vec2 p,vec3 s,inout vec4 t\n){p.x=abs(p.x)//https://www.shadertoy.com/view/XdKGDy\n ;t=vec4(vec3(p.xy,s.x)-s.yzy,-2.*s.z)\n ;vec2 d=t.xy-t.zw*sat(pc(t.xy,t.zw))\n ;vec4 h=vec4(max(p.x-vec2(s.xy),0.),p.y+s.z*vec2(1,-1))\n ;h.xyz=vec3(dd(d),dd(h.xz),dd(h.yw))\n ;return sqrt(mi(h.xyz));}\nfloat trapezoidU(vec2 p,vec3 s){vec4 t=vec4(0);return trapezoid2(p,s,t);}\nfloat trapezoid(vec2  p,vec3 s){vec4 t=vec4(0);float a=trapezoid2(p,s,t);return a*sign(max(dot(t.xy,vec2(-1,1)*t.wz),abs(p.y)-s.z));}\n\n#define fsaa (2./min(iResolution.x,iResolution.y))\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n\n//float gm3(mat3 a,int n){return a[n/3][n%3];}//use a matrix as if it is a list.\n\n\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;float k=dot(m,u.yx);return k;}\nfloat lineN(vec2 u,vec2 m){return line(u,normalize(m));}\n//https://www.shadertoy.com/view/4dBfzG\n//return unsigned distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat lsa(vec2 u,vec2 m){return abs(line(u,m));}\nfloat lsaN(vec2 u,vec2 m){return abs(line(u,normalize(m)));}\n//return distance of [u] to ray from(0,0)trough [m],m must be normalized.\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\nfloat ilsN(vec2 u,vec2 m){return ils(u,normalize(m));}\n//return distance of [u] to line_segment from(0,0)to [m],m must be normalized!\n//this line segment has a length of 1.\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\nfloat ls1N(vec2 u,vec2 m){return ls1(u,normalize(m));}\n//return distance of [u] to line_segment from(0,0)to [m],m must be normalized\n//[m] must NOT be normalized!\nfloat ls(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\nfloat lsN(vec2 u,vec2 m){return ls(u,normalize(m),m);}\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\nfloat lssN(vec2 u,vec2 n,float a){return lss13(u,normalize(n),a);}\n//signed infionite line\nfloat lineInf(vec2 p,vec2 a,vec2 b){vec2 d=b-a;return(dot(normalize(vec2(d.y,-d.x)),p-a));}\n\n\n\n\n//return distance to 1/24th rotated axis\nfloat r12(vec2 u\n){const float s2=sqrt(2.),s6=sqrt(6.)\n ;//extreme un-pointy:return dot(u,vec2(s6+s2,s6-s2)*.25)\n ;return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\nfloat arrow(vec2 u,vec4 m\n){u.y*=sign(u.y)\n ;//if(u.y>m.x)return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n ;m.z*=.25\n ;m.zw=abs(m.zw)\n ;//vec2 d=vec2(1,-sqrt(2.))*.5;//12th rotation\n ;float a=r12(u)-m.z//24th rotation\n ;a=max(a,-u.x)\n ;u.y=-mStretchP(u.y,m.y)\n ;u.x=-mStretchM(u.x,m.x)\n ;//u.x=mStretchP(u.x,-m.x)\n ;float b=length(u)-m.w\n ;a=min(a,b)\n ;//return c\n ;//a=min(a,c)\n ;return a;}\n\n#define sm(a,b)smoothstep(a-10./iResolution.y,a,b)\nfloat PatternCircles(vec2 p,float m//https://www.shadertoy.com/view/MsSyRz\n){p.x-=m*.5*step(0.,sin(pi*p.y/m))\n ;p=mod(p,m)-m*.5\n ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n\nfloat DistanceYtoLine(vec2 u,vec2 m,vec2 n\n){;m=m-n;;return (u.x-n.x)*m.y/m.x-u.y+n.y;}\n\n\n\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n//#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 normalize(vec3(1,1,1))\n#define GDFVector4 normalize(vec3(-1,1,1))\n#define GDFVector5 normalize(vec3(1,-1,1))\n#define GDFVector6 normalize(vec3(1,1,-1))\n#define GDFVector7 normalize(vec3(0,1,1.61+1.))\n#define GDFVector8 normalize(vec3(0,-1,1.61+1.))\n#define GDFVector9 normalize(vec3(1.61+1.,0,1))\n#define GDFVector10 normalize(vec3(-1.61-1.,0,1))\n#define GDFVector11 normalize(vec3(1,1.61+1.,0))\n#define GDFVector12 normalize(vec3(-1,1.61+1.,0))\n#define GDFVector13 normalize(vec3(0,1.61,1))\n#define GDFVector14 normalize(vec3(0,-1.61,1))\n#define GDFVector15 normalize(vec3(1,0,1.61))\n#define GDFVector16 normalize(vec3(-1,0,1.61))\n#define GDFVector17 normalize(vec3(1.61,1,0))\n#define GDFVector18 normalize(vec3(-1.61,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d +=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fDodecahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\n/**/\n\n\n\n\n\nfloat fTruncatedIcosahedronB(vec3 u,float r){return max(fIcosahedron(u,r),fDodecahedron(u,r));}\nfloat fTruncatedOctahedronB(vec3 u,float r){return max(box(u,r),fOctahedron(u,r));}\nfloat fTruncatedIcosahedronB(vec3 u,float r,float s){return max(fIcosahedron(u,r,s),fDodecahedron(u,r,s));}\nfloat fTruncatedOctahedronB(vec3 u,float r,float s){return max(box(u,r),fOctahedron(u,r,s));}\n//well i do not have an exponential box.\n\n//where .a is a distance .b is intended to be a colorCode. if(any(.b<0)) it encodes a 4d textureID;else ist is a texturte.rgba\nstruct v14{vec1 a;vec4 b;};\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//todo,  define a mix for struct v14\n\nv14 demoSpheroid(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 d=v14(zFar,vec4(0))\n ;vec4 c=vec4(-5,0,0,0)\n ;d=minxb(d,v14(box                   (u,vec3(1.)      ),c))\n ;d=minxb(d,v14(fOctahedron           (u-vec3(3,0,3),1.),c))\n ;d=minxb(d,v14(fTruncatedOctahedron  (u-vec3(3,0,0),1.),c))\n ;d=minxb(d,v14(fTruncatedOctahedronB (u-vec3(0,0,3),1.),c))\n ;u+=vec3(6,0,0)\n ;c=vec4(-6,0,0,0)\n ;d=minxb(d,v14(fDodecahedron         (u            ,1.),c))\n ;d=minxb(d,v14(fIcosahedron          (u-vec3(3,0,3),1.),c))\n ;d=minxb(d,v14(fTruncatedIcosahedron (u-vec3(3,0,0),1.),c))//==c60 soccer ball\n ;d=minxb(d,v14(fTruncatedIcosahedronB(u-vec3(0,0,3),1.),c))\n ;return v14(d.a*scale,d.b);}\n\nv14 demoSpheroidB(vec3 u\n){float scale=.5\n ;float tt=mix(3.,105.,u5(cos(iTime)))//i found this range to be continuous, and outOfRange not.\n ;u/=scale\n ;v14 d=v14(zFar,vec4(0))\n ;vec4 c=vec4(-7,0,0,0)\n ;d=minxb(d,v14(box                   (u,vec3(1.)         ),c))\n ;d=minxb(d,v14(fOctahedron           (u-vec3(3,0,3),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedOctahedron  (u-vec3(3,0,0),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedOctahedronB (u-vec3(0,0,3),1.,tt),c))\n ;u+=vec3(6,0,0)\n ;c=vec4(-8,0,0,0)\n ;d=minxb(d,v14(fDodecahedron         (u            ,1.,tt),c))\n ;d=minxb(d,v14(fIcosahedron          (u-vec3(3,0,3),1.,tt),c))\n ;d=minxb(d,v14(fTruncatedIcosahedron (u-vec3(3,0,0),1.,tt),c))//==c60 soccer ball\n ;d=minxb(d,v14(fTruncatedIcosahedronB(u-vec3(0,0,3),1.,tt),c))\n ;return v14(d.a*scale,d.b);}\n\n\n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv33 cam(vec2 u\n){float camOrbit=3.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=-.03*(iMouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*iTime)//autopilot\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;m=mx(n,m,step(0.,mouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v33(pos,dir);}\n\n\n\n//Phong+debugPlanes\n//\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n#define tracePlane(po,pd,o,d) dot(po-(o),pd)/dot(d,pd)\n//traceR if(t<0) return -1; return t;\n#define traceR(t) mix(-1.,t,step(t,0.))\n#define raytrace_plane(po,pd,o,d) traceR(tracePlane2(po,pd,o,d))\nvec1 planeDebug2(vec3 o,vec3 d,vec3 c,inout float t,vec2 n//ray,ray,curPlane,time,domainLengths\n){if(n.x<length(c)&&n.y>0.//debug plane //n.x=o.y n.y=d.y\n ){float p=tracePlane(c,c*t,o,d)//;if(abs(p)<9.){\n  ;p=df(o+d*p).x\n  ;float q=fract(p*8.)/(p*p*p*p+4.)\n  ;p=mix(q,mix(1.,.5,q),step(p,0.))\n  ;return p*.5;}//}\n ;return 0.;}\n//x can be y,beware that z may be hidden from some cameras,need to rotate camera asound.\n//d is linked to e; e=x f=0 ; e=y f=1 ; e=z f=2 (; e=w f=3)\n#define planeDebug(a,b,c,d,e) planeDebug2(a,b,c,d,vec2(a.e,b.e))\n\nvec4 DebugPlanes(vec3 o,vec3 d,float t\n){float c0=u5(sin(iTime*.1))*2.\n ;vec4 a=planeDebug(o,d,(c0*vec3(1,0,0)),t,x)*vec4(0,1,.5,1)\n ;vec4 b=planeDebug(o,d,(c0*vec3(0,1,0)),t,y)*vec4(.5,0,1,1)\n ;vec4 c=planeDebug(o,d,(c0*vec3(0,0,1)),t,z)*vec4(1,.5,0,1)\n ;return sat((a+b+c)*2.);}\nvec3 tex(vec3 u//textureid is 2 integers, .x one sets hue, .y sets saturation.\n){float i=df(u).y;\n ;vec3 r=hsv2rgb(vec3(fract(i*phi),1,1))\n //;if (i<0.)\n ;//r=mix(r,dNormal3X(u.xyz,df)*.5+.5,.7)\n ;//r=mix(r,vec3(checkerSignSt(u-1.,.5+.5*cos(-iTime)*vec3(1,1,1))*.5+.75),.5)\n ;//r=po(r,1.4)//gamma\n ;return r\n //return cellular(u*5.,iTime).xyx\n //;return fract(u*4.+cos(iTime))\n ;}\n\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n \n//these likely have simpler expressions,its too late timeofday for me to bother now.\nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n\n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(iTime*.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1])\n ;y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(ma(dt(p,y))-o.x*3.,sq(mi(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\nv14 dfPolyMod3(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec2 pp=poly(p,type,vec3(a,b,c))\n ;v14 r=v14(pp.x,-vec4(vec2(pp.y,index/15.).yxyx))\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n \nv14 dfPoly16(vec3 p,float i//.x=distanceP .y=surfaceId .z= i/15.\n){float index=i\n ;float modindex=mod(index,7.)\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 oldtype=vec3(poly(p,type,vec3(a,b,c)),index)//previous return type was a vec3\n ;return v14(oldtype.x,-oldtype.yzyz)\n ;}\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\nv14 dfPoly(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 r=v14(zFar,vec4(0))\n ;float tt=iTime*.5\n ;float ls=3.//lattice scale\n ;v14 s=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt   ,32.)))\n ;v14 q=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt+1.,32.)))\n ;q=mi(s,q,fract(tt))\n ;r=minxb(r,q)\n ;u.xz+=1.5*ls \n ;r=minxb(r,dfPoly16(u,0.))//slow lattice because its not traversed.\n ;r=minxb(r,dfPoly16(u-vec3(0,0,1)*ls,1.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,2)*ls,2.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,3)*ls,3.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,0)*ls,4.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,1)*ls,5.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,2)*ls,6.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,3)*ls,7.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,0)*ls,8.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,1)*ls,9.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,2)*ls,10.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,3)*ls,11.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,0)*ls,12.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,1)*ls,13.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,2)*ls,14.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,3)*ls,11.))/**/\n //so , a BVH for each sphere coul.d help a marcher, but then it also taps for color\n ;r.b.x=r.b.y*.5//sloppy bridge conversion, todo, fix this as soon as the conversion is done.\n //;v14 r=v14(pp.x,-pp.yzyz)\n ;r.a*=scale\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n\n\nvec2 demohh(vec3 u\n){float scale=1.\n ;u*=scale\n ;//;float dodec=fDodecahedron(p-vec3(-9,2,-4)/4.,.7)//i like how this is placed n the mirroring plane\n ;float b=fBox(u-vec3(0,-.1,0),vec3(1))\n ;float s=length(u-vec3(1.+sin(iTime*.25)*.2,.8,1))-1.//sphere\n ;s=min(b,s)\n //;return s;\n ;float d=mistairs(b,s,.7,4.)\n ;u.xz*=r1(iTime*.041);u.zy*=r1(iTime*.021)//lazy small rotation\n ;//vec2 n=cellular(u*5.61,1./7.)\n ;//d-=(n.y-n.x)*.05//too much foreach march iteration.\n ;return vec2(d/scale,1);}\n\n\nvec2 df(vec3 u//.x=distance .y=textureId\n){float scale=1.\n ;u*=scale\n#if 0\n //;u.xz=-u.xz;\n //;vec2 q=pModMirror2(u.xz,vec2(4.5))//offset repetition doesnt go well with the camera transform\n#endif\n ;v14 d=v14(zFar,vec4(0));\n ;d=minxb(d,demoSpheroid (u-vec3(.5,0,5.5)))//spheroid shit\n ;d=minxb(d,demoSpheroidB(u-vec3(.5,0,2)))//spheroid shit exponential\n ;d=minxb(d,dfPoly(u+vec3(0,0,2)))//array of 16 different spheroids,slow due to 4x4 lattice.\n ;//d=min(d,demohh(u-vec3(3,0,0)).x)//old decapitated basis for scale\n ;//d=min(d,debugHg(u-vec3(0,0,3)).x)//hg_sdf debug playgound\n ;return vec2(d.a/scale,d.b);}\n //;return min(d,dodec);}\n\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal3X(u.xyz,df)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=vec2(0)//d(u.xyz).yz//surfaceID is distanceField specific\n ;//tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;//tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(.3,.6,1.),vec3(1,.9,.7),diffuse)*surf+spec*vec3(1,.9,.8)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n\n\n\n\nvec4 demo2NoiseCel(vec2 u,vec2 m\n){vec3 o=vec3(u*6.,cos(iTime)*4.)\n ;o.xz*=r1(iTime*.041);o.zy*=r1(iTime*.021)//lazy small rotation\n ;return vec4(cellular(o,iTime*.161),0,1);}\n\nvec4 demoAd2d(vec2 u,vec2 m//deomes 1d automatic differentiation\n){vec3 c=vec3(0)\n ;w11 a=w11(u.x*9.,1.)\n ;a=w11(u.x,1.)\n ;a=si(ex((a)))//a.b is analytic first derivative of a.a\n //;a=(si(fr(a)))\n ;c.x=abs(a.a-u.y)/sqrt(1.+a.b*a.b)//euclidean_scale by first derivative. (bad near very thin extrema)\n ;float o=c.x\n ;c.y=a.b\n ;c.yz-=u.y\n ;c.yz=abs(c.yz)\n ;float aaa=4./min(iResolution.x,iResolution.y)\n ;c=smoothstep(aaa,-aaa,c-aaa)\n ;if(abs(a.b)<aaa*50.)c.z=max(c.z,pow(1.-abs(a.b)*2.,4.))//mark local extrema with vertical lines (better line width would need 2nd derivative)\n ;c=c.zyx//;c=mix(c,c.yzx,iMouse.x/iResolution.x)*2.#\n ;vec4 x=vec4(0  ,c.x,c.x,c.x)//first derivative\n ;vec4 y=vec4(c.y,0  ,c.y,c.y)//smoothened graph  in yellow\n ;vec4 z=vec4(c.z,c.z,0  ,c.z)//coordinate system in magenta/pink\n ;x=pdOver(y,x)//2 graphs,one is 1st derivative  in cyan/blue\n ;x=pdOver(z,x)//add coordinate system that highlights loccal extrema\n ;return x;}\n\nvec4 demo2d1(vec2 u,vec2 m,vec2 n\n){vec2 i=mix(n,m,abs(cos(iTime*2.)))\n ;vec4 c=sqrt(vec4(dd    (m-u) ,dd    (n-u) ,dd    (u) ,dd    (i-u)))//abs(cos())bounce for direction\n ;vec4 d=     vec4(ma(abs(m-u)),ma(abs(n-u)),ma(abs(u)),ma(abs(i-u)))\n ;c=mix(c,d,2.*(cos(iTime)))\n ;float thick=.005,diam=.1\n ;c=smoothstep(.01,-.01,abs(abs(c-diam)-diam+thick)-thick)//i know theres better ways to do this abs(abs())identities...\n ;c.xy+=c.w;return vec4(c.xyz,ma(c.xyz))\n ;vec4 a=pdOver(vec4(0,c.y,0,c.y),vec4(c.x,0,0,c.x))//green over red\n ;c     =pdOver(vec4(c.w,c.w,0,c.w),vec4(0,0,c.z,c.z))//yellow over blue\n ;c     =pdOver(a,c)//green over red over yellow over blue\n ;return c;}\n\nvec3 sspm(float a,vec3 b){return smoothstep(a,-a,b);}\n\nvec4 pd(vec2 u\n){vec2 m=fra(iMouse.xy)\n ;if(iMouse.z<.0)m=-vec2(.5)//while(mouse up)simulate mouse down.\n ;vec2 s=-vec2(1.,sin(iTime))//vector moves over time.\n ;vec3 e=vec3(dd(u)\n ,dd(u-m)\n ,dd(u-s))//eucliden distance projection.\n ;e=sqrt(e)//delayed square root\n ;e-=.5//circle radius\n ;e=abs(e)-.2;//turn cirlce into ring\n ;float SSAA=(cos(iTime)+1.25)*12./min(iResolution.x,iResolution.y);//screen-space-anti-aliasing\n ;e=sspm(SSAA,e)\n ;e=sat(e)\n ;vec3 g=vec3(.96,.25,.05)//color ramp equals cheap colorblind mode.\n ;vec4 c0=vec4(g,e.x)\n ;vec4 c1=vec4(g.yzx,e.y)\n ;vec4 c2=vec4(g.zxy,e.z)//some colors with e.rgb as alpha channel.\n ;c0.rgb*=c0.w//general form scales .rgb by alpha,\n ;c1.rgb*=c1.w//...this acoids some division by 0 cases\n ;c2.rgb*=c2.w\n ;vec4 O=pdOver(c0,c1);O=pdOver(O,c2)\n ;//O=sXor(c0,c1);O=sXor(O,c2)\n ;//O=sAtop(c0,c1);O=sAtop(O,c2)\n ;vec4 bg=vec4(vec3((checkerBool2(u))),u.y)\n //;bg.rgb=pow(bg.rgb,vec3(2.2))\n ;if(O.w!=0.)O.rgb/=O.w\n ;O=pdOver(O,bg);\n ;O.rgb=pow(O.rgb,vec3(1./2.2))/**/\n ;return O;}\n\n/*\nvec4 demoshit(vec2 fragCoord\n){vec2 uv=(fragCoord.xy-iResolution.xy*0.5)/iResolution.y\n ;vec3 lir=normalize(vec3(.5,1.0,-.25))\n ;// Simple model-view matrix:\n ;v33 ray=cam(uv)\n ;vec4 c=shade(ray.a,ray.b,lir,trace(ray.a,ray.b))\n ;//c.xyz=pow(c.xyz,vec3(.44))//gamma\n ;return vec4(c);}*/\n\nvec4 demoHg3d(vec2 u\n){vec3 lir=norma(vec3(.5,1.0,-.25))\n ;v33 ray=cam(u)\n ;vec4 c=shade(ray.a,ray.b,lir,trace(ray.a,ray.b))\n ;//c.xyz=pow(c.xyz,vec3(.44))//gamma\n ;return c;}\n\n//solve 2 limb-IK and paint it,red&green=limbs; Yellow=ellbow and hand ; blue= handRange \n#define eIK .001\nvec4 demoIkX(vec2 u,vec2 m,vec2 l//2 limb IK along x-axis (circleCircleIntersection)\n){vec2 i=1.+vec2(1,-1)*eIK//evade rounding errors from moving the boal out too far (overlapping limbs\n ;vec2 L=l.y+l.x*vec2(-1,1);m.x=clamp(m.x,abs(L.x)*i.x,L.y*i.y)//move goalspost within limb range\n ;vec2 e=vec2(0)//ellbow position\n ;e.x=cci(vec3(l.xy,m.x))\n ;e.y=sqrt(l.x*l.x-e.x*e.x)//point.y on left circle\n //you possibly just want to return [e] (likely rotated back by an angle)\n ;vec4 a=vec4(0)//the rest is \"just\" for visualization\n ;a.x=segment(u,vec2(0),e)\n ;a.y=segment(u,e,vec2(m.x,0))\n ;float aaa=2./min(iResolution.x,iResolution.y)\n ;float j=aaa*7.//make outer circle withs j thinner than line segments\n ;vec2 p=abs(vec2(length(u)-l.x,length(u-vec2(m.x,0))-l.y))+j\n ;a.xy=min(abs(abs(abs(a.xy)-aaa*14.)-aaa*3.)-aaa*2.,p.xy-aaa*9.)\n ;a.w=length(u-e)-.1//pointAtEllbow\n ;a.w=min(a.w,length(u-vec2(m.x,0))-.1)//pointAtHand\n ;a.w=abs(a.w)+j*.5//turn into \"rings\"\n ;a.z=abs(length(u)-L.y)+j\n ;a.z=min(a.z,abs(length(u)-abs(L.x))+j)\n ;float mid=(abs(L.x)+L.y)*.5\n ;float range=(abs(L.x)-(L.y))*.5\n ;a.z=abs(length(u)-mid)+range\n ;a.w-=aaa*9.//thicker lines\n\n ;a=smoothstep(aaa,-aaa,a)\n ;vec4 r=vec4(0)\n ;r=pdOver(r,vec4(1,0,0,1)*a.x)\n ;r=pdOver(r,vec4(0,1,0,1)*a.y)\n ;r=pdOver(r,vec4(1,1,0,1)*a.w)\n ;r=pdOver(r,vec4(0,0,1,1)*a.z*.5)\n ;return r;}\n//m is handTarget, n.xy are limb lengths\n//for a planar visualization, we just rotate all inputs by matrix[b]\n//if we wanted the ellbow position, we would have that to be returned and then; return \nvec4 demoIk(vec2 u,vec2 m,vec2 n//2 limb IK along x-axis (circleCircleIntersection)\n){if(iMouse.z<=0.\n ){n=mix(vec2(1,0),vec2(0,1),u5(cos(iTime*vec2(.5,.61))))+.5//auromatic limg lengths\n  ;}\n ;//n=vec2(0.61,1.61)//limb lengths\n ;//n=mix(vec2(1,0),vec2(0,1),u5(cos(iTime*vec2(.5,.61))))+.5//optionally change over time\n ;mat2 b=r1(AngleBetween(m));return demoIkX(u*b,m*b,n)\n ;}\n\n\n\nvoid mainImage(out vec4 O,vec2 u\n){O=vec4(0)\n ;//O=pdOver(O,demoshit(u))//mouseCoords\n ;u=fra(u)\n ;vec2 auto=(cs(iTime)+vec2(.8,0))*1.2+cs(iTime*6.*1.61)*.2\n ;vec4 mouse=iMouseZwFix(iMouse,true)\n ;vec2 m=mix(auto,fra(mouse.xy),sign(mouse.z))\n ;vec2 n=mix(auto.yx,fra(mouse.zw),sign(mouse.z))\n ;O=pdOver(O,demoIk(u,m,u5(n/2.)))\n ;O=pdOver(O,demo2d1(u,m,n))//mouseCoords\n ;//O=pdOver(O,demoAd2d(u,m))//ad 1d\n ;//O=pdOver(O,demoSmin(u,m,n))//ad 1d smin\n ;//O=pdOver(O,demoHg3d(u))//hg_sdf,u-scaling sets camera distance to center\n ;//O=pdOver(O,demoComplex(u,m,n))\n ;//O=pdOver(O,demo2NoiseCel(u,m)*vec4(.3,.3,.3,1.))//celularNoise\n ;O=pdOver(O,vec4(vec3((checkerBoolT(u*1.61))*.5+.25),u.y))//checkerboard background\n ;}\n\n\n\n\n\n\n\n\n\n\n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dSegment(a,b,c) segment(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return segmentY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return segment(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n\n\n\n/*\n//html boilerplate\n\n\nvoid main(){vec4 o=vec4(1);mainImage(o,v1u*iResolution.xy);\n//Tiny Bridge300 O Mouse5small,fixes iResolution.z iMouse and iTime shadertoy compatibility\n\n</script><script id=\"i\">=o;}</script><script>//body for all vertex shader versions\n//boilerplate based on piLibs 2015-2017@ https://iquilezles.org/www/material/piLibs/piLibs.htm\nwindow.requestAnimFrame=(function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame\n||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(cb){window.setTimeout(cb,16);};})();\nvar mF32Textures=mF16Textures=mDerivatives=mDrawBuffers=mDepthTextures=mHaderTextureLOD=true//assimilateds \nvar mC,mS={},par={startTime:Date.now(),t:0,f:0,MX:0,MY:0,MZ:0,MW:0,SX:0,SY:0}//uniforms,timestamp,mouse,canvasSize\n,sB=null,mR,vA,mS\nfunction gei(a){return document.getElementById(a).textContent;}\nfunction cul(p,l){if(p.uniformsCache===undefined)p.uniformsCache={};p.uniformsCache[l]=m.getUniformLocation(p,l);}\nfunction SetShaderConstant1I(u,x){m.uniform1i(m.getUniformLocation(sB.mProgram,u),x);}\nfunction SetShaderConstant2F(u,x){m.uniform2fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant3F(u,x){m.uniform3fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant4F(u,x){m.uniform4fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}\nfunction SetShaderConstant1F(u,x){m.uniform1f(m.getUniformLocation(sB.mProgram,u),x);}//fine\nfunction SetShaderConstant2F(u,x){m.uniform2fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\nfunction SetShaderConstant3F(u,x){m.uniform3fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\nfunction SetShaderConstant4F(u,x){m.uniform4fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}\ndocument.addEventListener('mousedown' ,function(e){par.MZ=e.clientX/window.innerWidth;par.MW=1-e.clientY/window.innerHeight;},false)\ndocument.addEventListener('mouseup' ,function(e){par.MZ=0.;par.MW=0.;},false)\ndocument.addEventListener('mousemove' ,function(e){par.MX=e.clientX/window.innerWidth;par.MY=1-e.clientY/window.innerHeight;},false)\nvar fpsTo,fpsA,pL=pN=fl=mi=mis=0\nfunction rAf(\n){pL=pN;pN=performance.now()//2 frame timestamps\n ;par.t=Date.now()-par.startTime\n ;var now=new Date();sec=now.getHours()*3600+now.getMinutes()*60+now.getSeconds();\n//;SetRenderTarget(null)\n ;sB=mS;m.useProgram(mS.mProgram);\n ;SetShaderConstant1I(\"iFrame\",par.f)//older error was:wrong type\n ;SetShaderConstant1F(\"iTime\",par.t*0.001)//error runs too fast?\n ;SetShaderConstant4F(\"iMouse\",[par.MX*mD.width,par.MY*mD.height,par.MZ*mD.width,par.MW*mD.height])\n ;SetShaderConstant4F(\"iDate\",[now.getFullYear(),now.getMonth(),now.getDate(),sec])\n ;SetShaderConstant3F(\"iResolution\",[mD.width,mD.height,1])\n ;m.drawElements(m.TRIANGLES,3,m.UNSIGNED_SHORT,0);\n ;par.f=par.f+1.0\n ;fpsA++\n ;var te=(pN-pL).toFixed(2)\n ;if(te>mi)mi=te//mis shows the largest sime it took for the last M-frames to render,doubles on frame skips/hickups.\n ;document.getElementById(\"IF\").innerHTML=wMs[wM]+\"-\"+(par.f).toFixed(0)+\"<br>fps:\"+fl+\"<br>ms \"+mis+\"<br>tB-o300\"\n ;if((pN-fpsTo)>250\n ){fl=(1000.*fpsA/(pN-fpsTo)).toFixed(2)\n  ;mis=te;\n  ;mi=0.\n  ;fpsA=0\n  ;fpsTo=pN;}\n ;requestAnimFrame(rAf);}\nvar mF32Textures=mF16Textures=mDerivatives=mDrawBuffers=mDepthTextures=mHaderTextureLOD=mRenderToFloat32F=false\nfunction extendGL(//optional openGL_ES extensions\n){if(w2//not all extensions exist in all versions of OpenGL_ES,webgl is a patchwork of extensions prior to version300es:\n){mDerivatives=m.getExtension('OES_standard_derivatives')\n  ;mHaderTextureLOD=mF32Textures=m.getExtension('OES_texture_float')//these extensions were optional prior to version300es\n  ;mF16Textures=m.getExtension('OES_texture_half_float')//...and are included in version 300es\n  ;mDrawBuffers=m.getExtension('WEBGL_draw_buffers')\n  ;mDepthTextures=m.getExtension('WEBGL_depth_texture')\n  ;mHaderTextureLOD=m.getExtension('EXT_shader_texture_lod')\n ;}else mRenderToFloat32F=m.getExtension('EXT_color_buffer_float')//version300es exclusive extension\n ;mF32Filter=m.getExtension('OES_texture_float_linear')//but these 3 extensions persist as extensions\n ;mF16Filter=m.getExtension('OES_texture_half_float_linear')\n ;mAnisotropic=m.getExtension('EXT_texture_filter_anisotropic');}\nfunction sh(a,b){alert(a+\"\\n\"+m.getShaderInfoLog(b));}\nfunction cs(v,h,b){m.shaderSource(v,h);m.compileShader(v);if(!m.getShaderParameter(v,m.COMPILE_STATUS)){sh(b,v);}}\n;function pIn(\n){par.MX=(e.clientX/window.innerWidth);par.MY=(1-e.clientY/window.innerHeight)\n ;par.MZ=0.;par.MW=0.//optional clean mouse init\n ;mD=document.getElementById(\"ID\")\n ;mD.width=mD.offsetWidth;mD.height=mD.offsetHeight//optional aspect ratio scaling\n ;m=false\n ;while(wM>-1&&!m\n){m=mD.getContext(wMs[wM--]\n,{alpha:false,depth:false,stencil:false,premultipliedAlpha:false,antialias:false,preserveDrawingBuffer:false,powerPreference:\"high-performance\"})}\n ;wM++\n ;w2=(m instanceof WebGLRenderingContext)\n ;extendGL()\n ;var j=\"\\n#ifdef GL_ES\\nprecision highp float;precision highp int;\\n#endif\\n\",hF,hV=(w2)?j:\"#version 300 es\\n\"+j\n ;if(w2//hV,hF puzzle concatenate a string for 2 shader shader programs;vertex,fragment\n){hF=j\n  ;if(mDerivatives)hF+=\"#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives:enable\\n#endif\\n\"\n  ;if(mHaderTextureLOD)hF+=\"#extension GL_EXT_shader_texture_lod:enable\\n\"\n  ;if(mHaderTextureLOD){hF+=\"vec4 textureLod(sampler2D s,vec2 c,float b){return texture2DLodEXT(s,c,b);}\\n\"\n  ;hF+=\"vec4 textureGrad(sampler2D s,vec2 c,vec2 dx,vec2 dy){return texture2DGradEXT(s,c,dx,dy);}\\n\";}\n ;}else hF=hV\n ;var a=w2?\"attribute vec2 iPo;varying vec2 v1u;\":\"layout(location=0)in vec2 iPo;out vec2 v1u;\"\n ;hV+=j+\"uniform float iTime;uniform vec4 iMouse;\"+a+\"void main(){v1u=iPo*.5+.5;gl_Position=vec4(iPo,0,1);}\"\n ;var b=w2?\"varying \"+gei('h')+\"gl_FragColor\":\"out vec4 outColor;in \"+gei('h')+\"outColor\"\n ;hF+=gei('e')+b+gei('i')\n ;m.bindBuffer(m.ARRAY_BUFFER,m.createBuffer())\n ;m.bufferData(m.ARRAY_BUFFER,new Float32Array([-1,3,0,0,0,0,3,-1,0,-1,-1,0]),m.DYNAMIC_DRAW)\n ;m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,m.createBuffer())\n ;m.bufferData(m.ELEMENT_ARRAY_BUFFER,new Uint16Array([2,3,0]),m.STATIC_DRAW)\n ;m.vertexAttribPointer(m.enableVertexAttribArray(vA),3,m.FLOAT,false,0,0)\n//;m.vertexAttribPointer(svp,2,m.FLOAT,false,0,0)\n ;var v=m.createShader(m.VERTEX_SHADER),f=m.createShader(m.FRAGMENT_SHADER)\n ;cs(v,hV,\"v\");cs(f,hF,\"f\")\n ;mS.mProgram=m.createProgram();var p=mS.mProgram;pc=p//alias\n ;m.attachShader(p,v);m.attachShader(p,f)\n ;m.linkProgram(p);cul(p,'iFrame');cul(p,'iTime');cul(p,'iMouse');cul(p,'iDate');cul(p,'iResolution')\n ;if(!m.getProgramParameter(p,m.LINK_STATUS))sh(lp,p);\n ;to=performance.now()\n ;fpsTo=performance.now()\n ;par.f++\n ;rAf();}\n</script><body onload=\"pIn()\"><canvas id=\"ID\"></canvas><div id=\"IF\"></div></body></html>\n    /**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}