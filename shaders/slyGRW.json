{
    "Shader": {
        "info": {
            "date": "1637228443",
            "description": "Literally just nudging the ray a bit then marching through the stuff, which is probably the quickest way to do this but its slow since your raymarch loop isn't over the first few hits.",
            "flags": 0,
            "hasliked": 0,
            "id": "slyGRW",
            "likes": 16,
            "name": "Quicky \"Glass\" ",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "glass"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 427
        },
        "renderpass": [
            {
                "code": "// Cole Peterson (Plento)\n\n#define R iResolution.xy\n#define m ((iMouse.xy - .5*R.xy) / R.y)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat rbox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Dave Hoshkin \nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n#define b vec3(2., 2., 2.)\n\nvec3 getCell(vec3 p){\n    return floor(p / b);\n}\n\nvec3 getCellCoord(vec3 p){\n    return mod(p, b) - b*.5;\n}\n\nfloat map(vec3 p){\n    vec3 id = getCell(p);\n    p = getCellCoord(p);\n    \n    float rnd = 2.*hash13(id*663.) - 1.;\n    \n    p.xz *= rot(rnd*iTime*.3 + rnd);\n    p.xy *= rot(rnd*iTime*.3 + rnd);\n    p.yz *= rot(p.x*(5.+rnd*10.));\n\n    return rbox(p, vec3(0.7, .16, .16), .1);\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 n, float t){\n    vec3 p = ro + rd*t;\n    vec3 lp = ro + vec3(.0, .0, 2.7);\n    \n    if(iMouse.z>0.) lp.z += m.y*14.;\n    \n    vec3 ld = normalize(lp-p);\n    float dd = length(p - lp);\n    float dif = max(dot(n, ld), .1);\n    float fal = 1. / dd;\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 23.);\n\n    vec3 id = getCell(p);\n    vec3 objCol = hash33(id*555.);\n    \n    \n    objCol *= (dif + .2);\n    objCol += spec * 0.6;\n    objCol *= fal;\n    \n    return objCol;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, 0.8));\n    vec3 ro = vec3(0., 7.0, 4.);\n    rd.xy*=rot(-iTime*.1 + .5);\n    ro.zy += iTime;\n    ro.x += cos(iTime)*.25;\n    \n    int nHits = 0;\n    float d = 0.0, t = 0.0, ns = 0.;\n    vec3 p, n, col = vec3(0);\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        \n        if(nHits >= 4 || t >= 12.) break;\n        \n        if(abs(d) < .001){\n            p = ro + rd*t;\n            n = normal(p);\n            \n            if(d > 0. && nHits == 0) rd = refract(rd, n, 1.03);\n            \n            col += color(ro, rd, n, t);\n            \n            nHits++;\n            t += .1;\n        }\n        t += abs(d) * .6;\n        \n        if(nHits == 0) ns++;\n    }\n    \n    col /= float(nHits)*.6;\n    col *= smoothstep(.5, .3, ns * .01);\n    \n    col = 1.-exp(-col);\n    f = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}