{
    "Shader": {
        "info": {
            "date": "1717421751",
            "description": "This is a demo showcasing the basic versions of animation frame blending. It provides a comparison between flipbook animation, linear frame blending, and motion vector blending.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfKSW3",
            "likes": 1,
            "name": "Frame Blending Comparison",
            "published": 3,
            "tags": [
                "optical",
                "animation",
                "blending",
                "flow",
                "vector",
                "motion",
                "comparison",
                "flipbook",
                "interpolaiton"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 128
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis demo compares basic methods of flipbook animation blending. It \nfeatures a circle animating in an orbit to highlight the differences. \nIn reading order, we have no blending between frames, linear \ninterpolation, motion vector blending, and optical flow blending.\n\nThe classic flipbook uses a single texture sample, but it requires \nmany animation frames to achieve smoothness.\n\nLinear blending improves upon this, but it tends to blur the result \nand requires two samples.\n\nMotion vector blending offsets the pixels with their current velocity.\nAlthough it requires more data and four texture samples for blending, \nyou can compensate for the additional storage by using fewer frames \nsince the vectors do a lot of the animation work. The motion vectors \ncan also be lower resolution. It is a bit jittery and blury.\n\nOptical flow vector blending uses the difference between frames to \ndisplace the pixels. It requires the optical flow vectors, but you can\nreduce the frames and vector resolution. It only needs 3-4 samples. I \npersonally think this is the best method. I only made them for the \ncircle and not Nyan Cat, but Python has libaries that can make them \nfrom images.\n\nIf you have additional methods to share please comment.\n\nSee the global constants below to modify the result and gain a better \nunderstanding of what's happening.\n\nFor additional explanations, have a read of this article:\nhttps://www.klemenlozar.com/frame-blending-with-motion-vectors/\n\nOr a GDC talk on the time-lapse skies of Forza Horizon 3:\nhttps://www.youtube.com/watch?v=kquyK8pE81s\n*/\n\n// Time in seeconds to finish one animation cycle\n#define PERIOD 5.0\n\n// Number of frames until the animation repeats\n#define FRAME_COUNT 12\n\n// Comment this to disable Nyancat\n#define NYAN_CAT\n\n// Function to calculate the sphere's center position\nvec2 getSphereCenter(int frameIndex, int frameCount) {\n\n    // Calculate weight for the animation interpolation\n    float weight = float(frameIndex) * 6.282 / float(frameCount);\n\n    // Calculate the sphere's center position\n    return vec2(cos(weight), sin(weight)) *  0.1;\n}\n\n// Function to calculate the motion vector of the pixels\nvec2 getMotionVector(int frameIndex, int frameCount) {\n    // Get the sphere's center for the current frame\n    vec2 sphereCenterCurrent = getSphereCenter(frameIndex, frameCount);\n    \n    // Calculate the tangent vector (perpendicular to the current position vector)\n    vec2 tangentVector = vec2(-sphereCenterCurrent.y, sphereCenterCurrent.x);\n    \n    // Normalize the tangent vector\n    tangentVector = normalize(tangentVector);\n    \n    // Calculate the circumference of the circle\n    float circumference = 6.282 * 0.1; // 2 * pi * radius\n    \n    // Scale the tangent vector based on the frame count\n    float scale = circumference / float(frameCount); // The length of each segment\n    return tangentVector * scale;\n}\n\n// Function to calculate the motion vector between frames\nvec2 getDifferenceVector(int frameIndex, int frameCount) {\n\n    // Get the sphere's center for the current frame\n    vec2 sphereCenterCurrent = getSphereCenter(frameIndex, frameCount);\n    \n    // Get the sphere's center for the next frame\n    vec2 sphereCenterNext = getSphereCenter(frameIndex + 1, frameCount);\n    \n    // Calculate the motion vector as the difference in the sphere's position\n    return sphereCenterNext - sphereCenterCurrent;\n}\n\n// Sample the color of a quasi flipbook\nvec4 getAnimationFrame(vec2 uv, int frameIndex, int frameCount) {\n\n    // Get the sphere's center for the current frame\n    vec2 sphereCenter = getSphereCenter(frameIndex, frameCount);\n    \n    // Calculate the distance from the UV coordinate to the sphere's center\n    float dist = length(uv - sphereCenter);\n    \n    // Calculate anti-aliasing effect\n    vec2 uvFwidth = fwidth(uv);\n    float aa = max(uvFwidth.x, uvFwidth.y) * 2.0;\n    \n    // Mask for the circle outline\n    float size = 0.14;\n    float circle = smoothstep(size-aa, size+aa, dist);\n    \n    // Add a bit of color with a texture pattern for the circle\n    vec3 colorCircle = vec3(1,0.710,0.169) + \n                       colorModulation(iChannel0, (uv-sphereCenter)*3.)*2.;\n    \n    #ifdef NYAN_CAT\n        // Sample cat flipbook texture\n        vec4 cat = nyanCat(iChannel1, (uv-sphereCenter)*4.+0.5, frameIndex);\n\n         // Blend Cat with Background\n        colorCircle = mix(colorCircle, cat.xyz, cat.w);\n    #endif\n\n    // Return color and alpha mask\n    return vec4(colorCircle, circle);\n}\n\n// Standard flipbook switching between frames\nvec4 flipbook(vec2 uv, float time, int frameCount) {\n\n    // One full cycle animation over 1 speed \n    int index = int(time * float(FRAME_COUNT));\n    \n    // Sample the flipbook\n    return getAnimationFrame(uv, index, FRAME_COUNT);\n}\n\n// Interpolated flipbook switching between frames\nvec4 flipbookBlend(vec2 uv, float time, int frameCount) {\n\n    // One full cycle animation over 1 speed \n    float index = time * float(FRAME_COUNT);\n    \n    // Get the indices of the two frames to interpolate\n    int indexCurrent = int(index);\n    int indexNext = int(ceil(index));\n    \n    // Calculate the interpolation weight\n    float weight = fract(index);\n    \n    // Add a bit of contrast so the transitions are a bit faster\n    weight = smoothValue(weight);\n    \n    // Sample the flipbook and interpolate between frames\n    vec4 colorCurrent = getAnimationFrame(uv, indexCurrent, FRAME_COUNT);\n    vec4 colorNext = getAnimationFrame(uv, indexNext, FRAME_COUNT);\n    \n    // Interpolate between the current and next frame\n    return mix(colorCurrent, colorNext, weight);\n}\n\n// Function to animate and blend frames using two motion vector\nvec4 motionVectorBlend(vec2 uv, float time, int frameCount) {\n\n    // One full cycle animation over 1 speed \n    float index = time * float(FRAME_COUNT);\n    \n    // Get the indices of the two frames to interpolate\n    int indexCurrent = int(index);\n    int indexNext = int(ceil(index));\n    \n    // Calculate the interpolation weight\n    float weight = fract(index);\n    \n    // Get the motion vectors for the current and previous frames\n    vec2 directionCurrent = getMotionVector(indexCurrent, frameCount);\n    vec2 directionNext = getMotionVector(indexNext, frameCount);\n    \n    // Sample the frames and animate them in and against motion direction\n    vec4 colorCurrent = getAnimationFrame(uv - directionCurrent * weight, indexCurrent, FRAME_COUNT);\n    vec4 colorNext = getAnimationFrame(uv + directionNext * (1.-weight), indexNext, FRAME_COUNT);\n\n    // Blend the animated frames\n    return mix(colorCurrent, colorNext, weight);\n}\n\n// Function to animate and blend frames using one difference vector\nvec4 opticalFlowBlend(vec2 uv, float time, int frameCount) {\n\n    // One full cycle animation over 1 speed \n    float index = time * float(FRAME_COUNT);\n    \n    // Get the indices of the two frames to interpolate\n    int indexCurrent = int(index);\n    int indexNext = int(ceil(index));\n    \n    // Calculate the interpolation weight\n    float weight = fract(index);\n\n    // Get the difference vectors between the current and previous frames\n    vec2 direction = getDifferenceVector(indexCurrent, frameCount);\n    // Similar to motionVectorBlend you could have a unique vector back from\n    // the next frame back to the current frame, but it may not be worth it.\n    \n    // Sample the frames and animate them in and against motion direction\n    vec4 colorCurrent = getAnimationFrame(uv - direction * weight, indexCurrent, FRAME_COUNT);\n    vec4 colorNext = getAnimationFrame(uv + direction * (1.-weight), indexNext, FRAME_COUNT);\n\n    // Blend the animated frames\n    return mix(colorCurrent, colorNext, weight);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Square UVs with (0,0) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x,iResolution.y);  \n    \n    // Time with scalar\n    float time = iTime / PERIOD;\n    \n    // Alternate between different flipbook blending methods\n    vec4 circle;\n    if (uv.x <0. && uv.y < 0.) {   \n        // Bottom Left\n        vec2 offset = vec2(0.25);\n        circle = motionVectorBlend(uv + offset, time, FRAME_COUNT);\n        \n    } else if (uv.x >= 0. && uv.y < 0.) {\n        // Bottom Right\n        vec2 offset = vec2(-0.25,0.25);\n        circle = opticalFlowBlend(uv + offset, time, FRAME_COUNT);\n        \n    } else if (uv.x < 0. && uv.y >= 0.) {\n        // Top Left\n        vec2 offset = vec2(0.25,-0.25);\n        circle = flipbook(uv + offset, time, FRAME_COUNT);        \n        \n    } else {\n        // Top Right\n        vec2 offset = vec2(-0.25);\n        circle = flipbookBlend(uv + offset, time, FRAME_COUNT);        \n    }\n    \n    // background color\n    vec3 background = vec3(0,0.333,0.667) + colorModulation(iChannel2, uv+0.5);\n    \n    // blend between circle and background\n    vec3 color = mix(circle.xyz, background, circle.w);\n    \n    // Get the color of the current animation frame\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// GENERIC FUNCTIONS ____________________________________________________________\n\n// Generate a neutral color variation vector to make colors more interesting\nvec3 colorModulation(sampler2D tex, vec2 uvCoords) {\n    // Sample the highest mip to get the texture's average color\n    vec3 averageColor = textureLod(tex, vec2(0), 99.).xyz;\n    \n    // Sample the texture as usual\n    vec3 albedo = texture(tex, uvCoords).xyz;\n    \n    // Subtract the average to get a -0.5 to 0.5 color variation vector\n    return albedo - averageColor;\n}\n\n// Simplified Smoothstep https://www.desmos.com/calculator/ela1otib0z\nfloat smoothValue(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// applies Anti Aliasing to texture samples meant for pixel art\nvec4 aaTextureSample(sampler2D tex, vec2 uv) {\n    // Get the size of the texture in pixels\n    vec2 texsize = vec2(textureSize(tex, 0));\n        \n    // Scale the UV coordinates by the texture size and shift by 0.5\n    vec2 scaledUV = uv * texsize - 0.5;\n    \n    // Calculate the rate of change of `uv` to apply anti-aliasing\n\tvec2 fw = fwidth(scaledUV);\n    \n    // Apply smooth stair like pattern to the UV coordinates\n    // for the math see: https://www.desmos.com/calculator/0p2hp7look\n    vec2 uvAA = (floor(scaledUV) + smoothstep(0.5 - fw, 0.5 + fw, fract(scaledUV)) + 0.5) / texsize;\n    \n    // Sample the texture at the anti-aliased UV coordinates\n\treturn textureLod(tex, uvAA, 0.);\n}\n\n// Flipbook animation nyan cat from IQ: https://www.shadertoy.com/view/lsX3Rr\nvec4 nyanCat(sampler2D tex, vec2 uv, int frameIndex) {\n    // prevent repetition\n    vec2 catUV = clamp( uv, 0.0, 1.0 );\n    \n    // offset for flipbook animation\n\tfloat offset = mod( float(frameIndex), 6.0);\n\n    // scale cat to full uv size\n\tfloat scale = 40.0/256.0;\n    \n    // apply flipbook offset\n\tcatUV.x = catUV.x * scale + offset * scale;\n    \n    // Sample Cat texture\n    return aaTextureSample(tex, catUV);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}