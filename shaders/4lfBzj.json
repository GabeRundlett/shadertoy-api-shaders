{
    "Shader": {
        "info": {
            "date": "1512425931",
            "description": "12 spheres in an icosahedral arrangement, inverted in a sphere.\n\nThe mouse controls the centre of inversion. Key 'i' to go uninverted.",
            "flags": 16,
            "hasliked": 0,
            "id": "4lfBzj",
            "likes": 7,
            "name": "Inversions",
            "published": 3,
            "tags": [
                "spheres",
                "raytrace",
                "inversion"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 810
        },
        "renderpass": [
            {
                "code": "bool invert = true;\n\nvoid invertsphere(inout vec3 p, inout float r2) {\n  // Use mouse position to determine centre of inversion (for x and y)\n  vec3 icentre = vec3(0.5,0.0,-1.25);\n  // On startup iMouse.x = iMouse.y = 0\n  if (iMouse.x > 0.0) {\n      icentre = vec3(3.0*(iMouse.x-0.5*iResolution.x)/iResolution.x,\n                      3.0*(iMouse.y-0.5*iResolution.y)/iResolution.y,\n                      -1.25);\n    }\n  // Shift origin to sphere centre\n  p -= icentre;\n  float c = dot(p,p);\n  // This inverts the sphere (in the origin).\n  float k = 1.0/(c-r2);\n  // Shift back\n  r2 = r2*k*k;\n  p = p*k+icentre;\n}\n\nfloat intersectsphere(vec3 p, float r2, vec3 q, vec3 r, out vec3 n) {\n  //vec3 p = s.p;\n  q -= p;\n  float c = 0.0;//length(p);\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q,r);\n  float C = dot(q,q)-r2;\n  float D = B*B - C;\n  if (D < 0.0) return -1.0;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return -1.0;\n  // Normal is the radial vector of sphere\n  n = q+t*r;\n  return t;\n}\n\nfloat intersectsphere0(vec3 p, float r2, vec3 q, vec3 d, out vec3 n) {\n  q -= p;\n  float k = dot(q,d);\n  q -= k*d;\n  float C = r2-dot(q,q);\n  if (C < 0.0) return -1.0;\n  float t = -sqrt(C);\n  if (t < k) t = -t;\n  if (t < k) return -1.0;\n  // Normal is the radial vector of sphere\n  n = q+t*d;\n  return t-k;\n}\n\nvec3 getvertex(int i) {\n  float phi = 0.80902;\n  // Three golden rectangles, oriented to the three axes.\n  switch(i) {\n  case 0: return vec3( 0.5, phi,0); //++0 A\n  case 1: return vec3( 0.5,-phi,0); //+-0 B\n  case 2: return vec3(-0.5, phi,0); //-+0 C\n  case 3: return vec3(-0.5,-phi,0); //--0 D\n\n  case 4: return vec3(0, 0.5, phi); //0++ B\n  case 5: return vec3(0, 0.5,-phi); //0+- D\n  case 6: return vec3(0,-0.5, phi); //0-+ C\n  case 7: return vec3(0,-0.5,-phi); //0-- A\n\n  case 8: return vec3( phi,0, 0.5); //+0+ D\n  case 9: return vec3( phi,0,-0.5); //+0- C\n  case 10: return vec3(-phi,0, 0.5); //-0+ A\n  case 11: return vec3(-phi,0,-0.5); //-0- B\n  }\n}\n\nvec3 getcolor(int i) {\n  // A nice 4-coloring of icosahedron vertices\n  switch(i) {\n  case 0: case 7: case 10: return vec3(1,0,0);\n  case 1: case 4: case 11: return vec3(1,1,0);\n  case 2: case 6: case 9: return vec3(0,1,0);\n  case 3: case 5: case 8: return vec3(0,0,1);\n  }\n}\n\nint scene(vec3 r, vec3 d, out float t, out vec3 n) {\n  float time = 0.5*iTime;\n  mat2 m = mat2(cos(time),-sin(time),\n                sin(time),cos(time));\n  int found = -1;\n  for (int i = 0; i < 12; i++) {\n    vec3 v = getvertex(i);\n    v.xz *= m;\n    float r2 = 0.25;\n    vec3 p = v;\n    vec3 n1;\n    if (invert) invertsphere(p,r2);\n    float t1 = intersectsphere(p,r2,r,d,n1);\n    if (t1 > 0.0 && (found < 0 || t1 < t)) {\n      t = t1; n = n1;\n      found = i;\n    }\n  }\n  return found;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec4 solve(vec3 q, vec3 d) {\n  float t; vec3 n;\n  int found = scene(q,d,t,n);\n  if (found<0) {\n    return vec4(0,0,0,1);\n  } else {\n    n = normalize(n);\n    if (dot(d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = getcolor(found);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),d)),5.0);\n    color += 0.5*specular*vec3(1.0,1.0,1.0);\n    color *= clamp(1.0 - (t-3.0)/5.0,0.0,1.0);\n    return vec4(sqrt(color),1.0);\n  }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (key(CHAR_I)) invert = false;\n  light = normalize(vec3(0.5,1.0,-1.0));\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 q = vec3(0,0,-3.0);\n  // \"screen\" coordinate\n  vec3 d = vec3(uv, 2);\n  d = normalize(d); // Direction from camera to screen point\n  fragColor = solve(q,d);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// const int KEY_SHIFT = 16;\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\nconst int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\n// const int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}