{
    "Shader": {
        "info": {
            "date": "1560380171",
            "description": "mapping each pixel to a hilbert curve index, then taking a value from the Roberts R1 quasirandom sequence for it.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tB3z3",
            "likes": 85,
            "name": "Hilbert R1 Blue Noise",
            "published": 3,
            "tags": [
                "noise",
                "blue",
                "hilbert",
                "quasirandom"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 4265
        },
        "renderpass": [
            {
                "code": "uint part1by1 (uint x) {\n    x = (x & 0x0000ffffu);\n    x = ((x ^ (x << 8u)) & 0x00ff00ffu);\n    x = ((x ^ (x << 4u)) & 0x0f0f0f0fu);\n    x = ((x ^ (x << 2u)) & 0x33333333u);\n    x = ((x ^ (x << 1u)) & 0x55555555u);\n    return x;\n}\n    \nuint compact1by1 (uint x) {\n    x = (x & 0x55555555u);\n    x = ((x ^ (x >> 1u)) & 0x33333333u);\n    x = ((x ^ (x >> 2u)) & 0x0f0f0f0fu);\n    x = ((x ^ (x >> 4u)) & 0x00ff00ffu);\n    x = ((x ^ (x >> 8u)) & 0x0000ffffu);\n    return x;\n}\n    \nuint pack_morton2x16(uvec2 v) {\n\treturn part1by1(v.x) | (part1by1(v.y) << 1);\n}\n\nuvec2 unpack_morton2x16(uint p) {\n    return uvec2(compact1by1(p), compact1by1(p >> 1));\n}\n\nuint inverse_gray32(uint n) {\n    n = n ^ (n >> 1);\n    n = n ^ (n >> 2);\n    n = n ^ (n >> 4);\n    n = n ^ (n >> 8);\n    n = n ^ (n >> 16);\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGcDm\nint hilbert( ivec2 p, int level )\n{\n    int d = 0;\n    for( int k=0; k<level; k++ )\n    {\n        int n = level-k-1;\n        ivec2 r = (p>>n)&1;\n        d += ((3*r.x)^r.y) << (2*n);\n    \tif (r.y == 0) { if (r.x == 1) { p = (1<<n)-1-p; } p = p.yx; }\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/llGcDm\nivec2 ihilbert( int i, int level )\n{\n    ivec2 p = ivec2(0,0);\n    for( int k=0; k<level; k++ )\n    {\n        ivec2 r = ivec2( i>>1, i^(i>>1) ) & 1;\n        if (r.y==0) { if(r.x==1) { p = (1<<k) - 1 - p; } p = p.yx; }\n        p += r<<k;\n        i >>= 2;\n    }\n    return p;\n}\n\n// knuth's multiplicative hash function (fixed point R1)\nuint kmhf(uint x) {\n    return 0x80000000u + 2654435789u * x;\n}\n\nuint kmhf_inv(uint x) {\n    return (x - 0x80000000u) * 827988741u;\n}\n\n// mapping each pixel to a hilbert curve index, then taking a value from the Roberts R1 quasirandom sequence for it\nuint hilbert_r1_blue_noise(uvec2 p) {\n    #if 1\n    uint x = uint(hilbert( ivec2(p), 17 )) % (1u << 17u);\n    #else\n    //p = p ^ (p >> 1);\n    uint x = pack_morton2x16( p ) % (1u << 17u);    \n    //x = x ^ (x >> 1);\n    x = inverse_gray32(x);\n    #endif\n    #if 0\n    // based on http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n    const float phi = 2.0/(sqrt(5.0)+1.0);\n\treturn fract(0.5+phi*float(x));\n    #else\n    x = kmhf(x);\n    return x;\n    #endif\n}\n\n// mapping each pixel to a hilbert curve index, then taking a value from the Roberts R1 quasirandom sequence for it\nfloat hilbert_r1_blue_noisef(uvec2 p) {\n    uint x = hilbert_r1_blue_noise(p);\n    #if 0\n    return float(x >> 24) / 256.0;\n    #else\n    return float(x) / 4294967296.0;\n    #endif\n}\n\n// inverse\nuvec2 hilbert_r1_blue_noise_inv(uint x) {\n    x = kmhf_inv(x);\n    return uvec2(ihilbert(int(x), 17));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat c = hilbert_r1_blue_noisef(uvec2(fragCoord));\n    \n    if (uv.x > 0.5) {\n    \tc = step(c, uv.y);\n    }\n    \n    fragColor = vec4(vec3(c),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}