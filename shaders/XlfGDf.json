{
    "Shader": {
        "info": {
            "date": "1427164494",
            "description": "Creating patterns by combining different geometric transforms onto a point on a circle.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlfGDf",
            "likes": 9,
            "name": "Phase Engine",
            "published": 3,
            "tags": [
                "transforms"
            ],
            "usePreview": 0,
            "username": "mpcomplete",
            "viewed": 1596
        },
        "renderpass": [
            {
                "code": "//#define DEBUG 1\n#define time (iTime*.9)\n\n// 2D rotation matrix.\nmat2 rotate(float angle)\n{\n    return mat2(\n        vec2( cos(angle), sin(angle)),\n        vec2(-sin(angle), cos(angle)));\n}\n\n// Transform a point on square to a circle.\nvec2 mapSquare(in vec2 p)\n{\n    vec2 ap = abs(p);\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return r*vec2(cos(angle), sin(angle));\n}\n\n// Make a pattern of squares in a repeating grid.\nvec2 dupSquares(in vec2 p)\n{\n    vec2 ap = abs(sin(p*6.));\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return r*vec2(cos(angle), sin(angle));\n}\n\n// Duplicate pattern in dupSquaresConcentric squares.\nvec2 dupSquaresConcentric(in vec2 p)\n{\n    vec2 ap = abs(p);\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return sin(3.*r)*vec2(cos(angle), sin(angle));\n}\n\n// Duplicate pattern in a repeating grid.\nvec2 dupGrid(in vec2 p)\n{\n    return abs(sin(p*4.));\n}\n\nfloat numPhases = 6.;\nvec2 getTransform(in vec2 p, float t)\n{\n    int which = int(mod(t, numPhases));\n\n    if (which == 0) {\n        p = mapSquare(p);\n        p = pow(vec2(.3), abs(p));\n        p = rotate(time*.1)*p;\n        p += .1*sin(time*.2);\n        p = dupSquares(p);\n        p -= .1*sin(time*.2);\n        p = dupSquares(p);\n    } else if (which == 1) {\n        p = pow(abs(p), vec2(.5));\n        p = mapSquare(p);\n        p = pow(abs(p), vec2(3.));\n        p += .1*sin(time*.2);\n        p = dupSquares(p);\n        p = rotate(time*.1)*p;\n        p = dupGrid(p);\n        p -= .1;\n        p = rotate(time*.1)*p;\n    } else if (which == 2) {\n        p = mapSquare(p);\n        p = dupGrid(p*.5);\n        p += .2 + .1*sin(time*.2);\n        p = dupSquares(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n    } else if (which == 3) {\n        p = mapSquare(p);\n        p = dupGrid(p*.7);\n        p = dupSquaresConcentric(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p += .3*sin(time*.2);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    } else if (which == 4) {\n        p = pow(vec2(.3), abs(p));\n        p = mapSquare(p);\n        p = dupGrid(p);\n        p = dupSquaresConcentric(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p += .3*sin(time*.2);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    } else if (which == 5) {\n        p = pow(vec2(.3), abs(p));\n        p = mapSquare(p);\n        p = dupGrid(p);\n        p = dupSquaresConcentric(p);\n        p += .3*sin(time*.2);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    }\n#if 0  // REJECTS\n    } else {\n        p = mapSquare(p);\n        p = dupSquares(p*.5);\n        p = dupGrid(p);\n        p = dupSquares(p*.5);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n\n    }\n#endif\n    return p;\n}\n\nvec2 applyTransform(in vec2 p)\n{\n    float t = time*.05;\n#ifdef DEBUG\n    if (iMouse.z > .001) t = iMouse.x/iResolution.x * numPhases;\n#endif\n    float pct = smoothstep(0., 1., mod(t, 1.));\n    return mix(getTransform(p, t), getTransform(p, t+1.), pct);\n}\n\nmat3 rotation(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * a.x * a.x + c,        oc * a.x * a.y - a.z * s,  oc * a.z * a.x + a.y * s,\n                oc * a.x * a.y + a.z * s,  oc * a.y * a.y + c,        oc * a.y * a.z - a.x * s,\n                oc * a.z * a.x - a.y * s,  oc * a.y * a.z + a.x * s,  oc * a.z * a.z + c);\n}\n\n// Fuzzy unit circle.\nfloat circle(in vec2 p)\n{\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    if (1.-r < 0.)\n        return 0.;\n    return step(r, 1.) * pow(1.-r, .5);\n}\n\nvec3 recolor(vec3 c)\n{\n    vec3 axis = vec3(0.454,0.725,0.372);\n    c = rotation(2.0*length(axis)*sin(time), axis)*c;\n    return c;\n}\n\nvec4 applyColor(vec2 p)\n{\n    float c1 = circle(p);\n#if 0\n    float c2 = circle(p*1.7);\n    float c3 = circle(p*1.3);\n#else\n    float c2 = circle(p*1.7 + .25*vec2(sin(time*.6), cos(time*.4)));\n    float c3 = circle(p*1.3 - .15*vec2(sin(time*.5), cos(time*.5)));\n#endif\n\treturn vec4(recolor(vec3(c1, c2, c3)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    p *= 1.3;\n\n    p = applyTransform(p);\n\tfragColor = applyColor(p);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}