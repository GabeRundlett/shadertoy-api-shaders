{
    "Shader": {
        "info": {
            "date": "1618927470",
            "description": "You are walking and flying through an infinite English countryside. \nChill out and use the mouse to look around. \nA single walk->fly cycle is about 50s.",
            "flags": 32,
            "hasliked": 0,
            "id": "fsXXzX",
            "likes": 332,
            "name": "English Lane",
            "published": 3,
            "tags": [
                "forest",
                "cellular",
                "trees",
                "nature",
                "path",
                "roads",
                "devon"
            ],
            "usePreview": 1,
            "username": "blackjero",
            "viewed": 17351
        },
        "renderpass": [
            {
                "code": "IMAGE",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// English Lane by Jerome Liard, April 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/fsXXzX\n//\n// You are walking and flying through an infinite English countryside.\n// Chill out and use the mouse to look around. \n// A single walk->fly cycle is about 50s.\n//\n// Shadertoy compilation time seems to be about 15s, thanks for your patience.\n\n// This is the start lane index. At each walk-flight cycle we switch to the next lane midair.\n// You can set any reasonable integer value (negative ok too) to walk along other paths.\n\n#define FIRST_LANE_INDEX 10.0\n//#define FIRST_LANE_INDEX (-80.0+mod(iDate.x*365.+iDate.y*31.+iDate.z,160.)) // one different lane every day (no fade when day changes)\n\n// If the reprojection is janky please press the button that resets time to zero.\n//\n// I wanted to make a navigable countryside with paths inspired by paintings from Richard Thorn (see his book \"Down an English Lane\"), \n// and a little bit by Hiroshi Nagai and Tezuka Osamu's Jumping short anime (both life long inspirations).\n//\n// Creation of the initial patchwork and parameterized paths network:\n//\n//   - 2 perpendicular sets of regularly spaced parallel 1d lanes are used. \n//   - Each 1d lane has an id. The amplitude of each 1d lane must be such that they don't cross the previous or next 1d lane.\n//   - The horizonal set of parallel lanes have constant vertical center spacing.\n//   - The twist: the vertical set of parallel lanes can have their spacing set more freely based on which stab we are in the horizontal set.\n//     This helps generating complex branching patterns.\n//   - For each set of parallel lanes we simply use its local x coordinate as a parameter (used for garden brick wall and camera).\n//   - The intersections of lane stabs give us a cellular base for country patches, and for each patch we get an id, a distance to boundary, and parameterized borders.\n//\n// Trees and houses placement:\n//\n//   - Patches ids is used to decide what combination of things goes on the patch (trees, bushes, farms, walls, lawn...)\n//   - There are 3 layers of cellular placement for trees, bushes, and farms.\n//     - Bushes are too close to each other and must be soft blended, but 3x3 search is no-no so we do a \"4 or 5\" neighbours search (we only consider checkboard black cells).\n//     - For farms and trees we use randomly decimated jittered grid and actually only consider the current cell we are in, and hack marching to death to compensate.\n//   - Modeling:\n//     - Trees leaves volume have a base shape done with 2 spheres soft blended, then distored by 2 layers of packed 3d spheres tiling to blobify the leaves volume, and then some fine noise distortion on the surface.\n//       The use of densely packed sphere tiling is inspired by @Shane's Cellular Tiling https://www.shadertoy.com/view/4scXz2\n//     - Farms are randomized with gable and hipped roof, chimneys and colors very vaguely inspired by pictures of Devon.\n//\n// Marching:\n//\n//   - For patches, marching uses ghost steps nearby patch boundaries so that we don't check neighbour patches objects, only the patch we are in.\n//   - For trees and farms too, we force the raymarch to take ghost steps along their cell borders for x1 sdf eval.\n//     - This ghost point machinery is hacky and not perfect (esp on patches boundary where we don't have clean intersections) but still helps.\n//   - Because of all the cellular evals going on, to save height evals we use taylor expansion of the heightfield on local neiborhood.\n//   - Despite above efforts I had to resort to reprojection and still perf isn't great. \n//     Blurring the noise with reprojection also helps hide the general noisy lameness and gives better colors.\n//\n// Clouds are volumetric but baked in a spheremap at first frame and assumed distant.\n// Also had to turn view trace/shadow trace/scene gradient/cellular evals into loops to help compile time on the website, sometimes at the expense of runtime perfs.\n// As always some code, techniques, ideas from @iq, @Dave_Hoskins, @Shane, @FabriceNeyret2 are used in various places, \n// this shader also uses some spherical gaussian code from Matt Pettineo \n// (see comment for links to references).\n\n#define PI 3.141592654 // He does love his numbers\n#define FLT_MAX 1000000.0\n\n#define SQR2 1.414213562\n#define SQR3 1.732050807\n\n#define RED  vec3( 1, 0, 0 )\n#define GREEN vec3( 0, 1, 0 )\n#define BLUE vec3( 0, 0, 1 )\n#define WHITE vec3( 1, 1, 1 )\n#define BLACK vec3( 0, 0, 0 )\n#define MAGENTA vec3( 1, 0, 1 )\n#define YELLOW vec3( 1, 1, 0 )\n#define AZURE vec3( 0.0, 0.5, 1.0 )\n\n#define A_FEW_FUNC(type) \\\ntype saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); } \\\ntype smoothstep_unchecked( type x ) { return ( x * x ) * ( type(3.0) - x * 2.0 ); } \\\ntype smoothstep_unchecked_d( type x ) { return 6.0 * x * ( type(1.0) - x ); }\n\nA_FEW_FUNC( float )\nA_FEW_FUNC( vec2 )\nA_FEW_FUNC( vec3 )\nA_FEW_FUNC( vec4 )\n\nfloat exp_decay( float x ) { return 1. - exp( -x ); }\n// cubic bump that goes through (0,0)->(1,0)\n// slope at x=0 is df0\n// slope at x=1 is df1\nfloat cubicbump( float x, float df0, float df1 ) { float a = df1 + df0; float c = df0; float b = -a - c; return x * ( x * ( x * a + b ) + c ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\n// like smoothstep, but takes a center and a radius instead\nfloat smoothstep_c( float x, float c, float r ) { return smoothstep( c - r, c + r, x ); }\n// centered at 0\nfloat smoothband( float x, float r, float raa ) { return 1. - smoothstep_c( abs( x ), r, raa ); }\n// range s,e\nfloat smoothband( float x, float s, float e, float raa ) { return smoothband( x - ( e + s ) * 0.5, ( e - s ) * 0.5, raa ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); } // return range -pi,pi\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\n// variant of exp/log soft min and max that save a few instructions\nfloat smin_exp2( float a, float b, float k ) { return -log2( exp2( -k * a ) + exp2( -k * b ) ) / k; }\nfloat smax_exp2( float a, float b, float k ) { return -smin_exp2( -a, -b, k ); }\n// https://iquilezles.org/articles/smin\nfloat smin_pol( float a, float b, float k ) { float h = clamp( 0.5f + 0.5f * ( b - a ) / k, 0.0f, 1.0f ); return mix( b, a, h ) - k * h * ( 1.0 - h ); }\nfloat smax_pol( float a, float b, float k ) { return -smin_pol( -a, -b, k ); }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat min_( float x, float y, float z ) { return min( min( x, y ), z ); }\nfloat max_( float x, float y, float z ) { return max( max( x, y ), z ); }\nfloat nearest( float x ) { return floor( 0.5 + x ); }\nfloat nearest( float x, float spacing ) { return floor( 0.5 + x / spacing ) * spacing; }\nvec2 nearest( vec2 x, vec2 spacing ) { return floor( vec2( 0.5 ) + x / spacing ) * spacing; }\nfloat sum( vec4 v ) { return v.x + v.y + v.z + v.w; }\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\n\n// project this on line (O,d), d is assumed to be unit length\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_line( type P, type O, type d ) { return O + d * dot( P - O , d ) / dot(d, d ); } \\\ntype project_on_plane( type P, type O, type n ) { return P - n * dot( P - O , n ) / dot(n, n ); } \\\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n// https://iquilezles.org/articles/distance\n// fast and nice in most cases\n#define FAST_SIGNED_DISTANCE_TO_FUNC_11_ARG( a_signed_distance, a_p, a_func, a_arg, a_epsilon ) \\\n{ \\\n\tvec2 _p = a_p; \\\n\tfloat _epsilon = a_epsilon; \\\n\tfloat _y = a_func( _p.x, a_arg ); \\\n\tfloat _y1 = a_func( _p.x + _epsilon, a_arg ); \\\n\tfloat _ddy = ( _y1 - _y ) * ( 1. / _epsilon ); \\\n\ta_signed_distance = ( _p.y - _y ) / sqrt( 1. + _ddy * _ddy ); \\\n}\n\n// this macro returns:\n//  - the vector to the closest point on a curve (the length of which gives a better distance than FAST_SIGNED_DISTANCE_TO_FUNC_11) \n//  - the tangent at that closest point\n// http://www.geometrie.tugraz.at/wallner/sproj.pdf\n// input:\n//  a_p               eval at pos\n//  a_funcd           is the R->R function to evaluate, first guess (iteration start point) is vec2(a_p.x,a_func(a_p.x))\n//                    a_funcd can be a macro, it seems\n//                    returns the function value at t in .x and the derivative at t in .y\n//  a_funcd_arg       an argument passed to a_func\n//  a_cheap           num iterations, 2 should be enough, a_cheap==true only does 1 iteration\n//\n// output:\n//  a_ret   \t\t  a_ret.xy is vector to closest point on curve\n//                    a_ret.zw is the derivative (tangent at the closest point)\n//\n// note: we could get the sign from the first iteration\n\n#define CLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( a_ret, a_p, a_funcd, a_funcd_arg, a_cheap ) \\\n{ \\\n\tvec2 _p = a_p.xy, _c, _dc, _ev; \\\n\tfloat _t = _p.x; /* t0, could be a parameter if the user knows better */ \\\n\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t_c = vec2( _t, _ev.x ); \\\n\t_dc = vec2( 1.0, _ev.y ); /*important: 1 in x!*/ \\\n\tif ( !(a_cheap) ) /* IMPORTANT: if num iteration is 2, an if test can behave much better than for loop */ \\\n\t{ \\\n\t\t/*#if 0*/ \\\n\t\t/*vec2 _q = project_on_line( _p.xy, _c, _dc );*/ \\\n\t\t/*_t += dot( _dc, _q - _c ) / dot( _dc, _dc );*/ \\\n\t\t/* simplifies to: */ \\\n\t\t/*#else*/ \\\n\t\t_t += dot( _p.xy - _c, _dc ) / dot( _dc, _dc ); \\\n\t\t/*#endif*/ \\\n\t\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t\t_c = vec2( _t, _ev.x ); \\\n\t\t_dc = vec2( 1.0, _ev.y ); /*important: 1 in x!*/ \\\n\t} \\\n\ta_ret = vec4( _c - _p, _dc ); \\\n}\n\nvec3 transform_vector( mat4 m, vec3 v ) { return ( m * vec4( v, 0.0 ) ).xyz ; }\n\nstruct bounds2 { vec2 pmin; vec2 pmax; };\nbounds2 mkbounds_unchecked( vec2 amin, vec2 amax ) { bounds2 ret; ret.pmin = amin; ret.pmax = amax; return ret; }\n\n#define REPEAT_FUNCTIONS( type ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float )\nREPEAT_FUNCTIONS( vec2 )\n\n// badly antialiased stripes\n// r is the half width of the stripes\n// raa is the half size of the edge/aa smoothstep (ex: pixel_size)\n// period is the distance between 2 consecutive stripes\n\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\nvec2 stripes( vec2 x, vec2 period, vec2 r, vec2 raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n\n// triangular sin waves - you can drop in as a replacement for sin to get polygonized looks\nfloat tri_sin( float x ) { return (abs(fract((x-PI*0.5)/(PI*2.))-0.5)-0.25)*4.0; }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nfloat hash11(float p) { p = fract(p * .1031); p *= p + 33.33; p *= p + p; return fract(p); }\nfloat hash12(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nfloat hash13(vec3 p3) { p3 = fract(p3 * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nvec2 hash22(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec2 hash23(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec3 hash31(float p) { vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash32(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy + p3.yxx )*p3.zyx ); }\n\n//###############################################################################\n\n// iq's function munged for vec4, used in city shader...\n// https://www.shadertoy.com/view/XlXcW4 note: source has changed since then...\n\nvec4 hash42_( ivec2 x0 )\n{\n\tuint k = 1103515245U;  // GLIB C\n\tuvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n//\tx = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference\n\treturn vec4( x ) * ( 1.0 / float( 0xffffffffU ));\n}\n\n// integer hashes\n// https://www.shadertoy.com/view/4tXyWN iq\n\nfloat hash1u2_4tXyWN( uvec2 x )\n{\n\tuvec2 q = 1103515245U * ( ( x >> 1U ) ^ ( x.yx  ) );\n\tuint  n = 1103515245U * ( ( q.x  ) ^ ( q.y >> 3U ) );\n\treturn float( n ) * ( 1.0 / float( 0xffffffffU ) );\n}\n\n// https://nullprogram.com/blog/2018/07/31/ Chris Wellons\n// https://www.shadertoy.com/view/WttXWX via Fabrice\n\nuint lowbias32(uint x) { x ^= x >> 16; x *= 0x7feb352dU; x ^= x >> 15; x *= 0x846ca68bU; x ^= x >> 16; return x; }\nfloat hash11u_lowbias32( uint x ) { return float( lowbias32( x ) ) / float( 0xffffffffU ); }\n\n#define V30 vec2( 0.866025403, 0.5 )\n#define V45 vec2( 0.707106781, 0.707106781 )\n#define V60 vec2( 0.5, 0.866025403 )\n\n// return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n// note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\n// theta_vec is the unit vector for angle theta\n// phi_vec is the unit vector for angle phi\nvec3 zup_spherical_coords_to_vector( vec2 theta_vec, vec2 phi_vec ) { return vec3( theta_vec.y * phi_vec, theta_vec.x ); }\nvec3 zup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phi ) ); }\nvec3 zup_spherical_coords_to_vector( vec2 theta_phi ) { return zup_spherical_coords_to_vector( theta_phi.x, theta_phi.y ); }\n\n// note: n.xy==0 is undefined for phi, pleae handle in caller code\nvec2 vector_to_zup_spherical_coords( vec3 n )\n{\n\tfloat theta = safe_acos( n.z ); // note: vectors normalized with normalize() are not immune to -1,1 overflow which cause nan in acos\n\tfloat phi = calc_angle( n.xy  );\n\treturn vec2( theta, phi );\n}\n\nvec3 yup_spherical_coords_to_vector( vec2 theta, vec2 phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx ; }\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return yup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nmat4 yup_spherical_coords_to_matrix( vec2 theta, vec2 phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( perp( theta ), phi ); // note: perp(theta) = unit_vector2(theta+PI*0.5)\n\tvec3 x = cross( y, z );\n\treturn ( mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) ) );\n}\n\nmat4 yup_spherical_coords_to_matrix( float theta, float phi ) {  return yup_spherical_coords_to_matrix( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nmat4 z_rotation( float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\n\nmat3 mat3_rotation_x( vec2 v ) { return mat3( vec3( 1, 0, 0 ), vec3( 0, v.x, v.y ), vec3( 0, -v.y, v.x ) ); }\nmat3 mat3_rotation_z( vec2 v ) { return mat3( vec3( v.x, v.y, 0 ), vec3( -v.y, v.x, 0 ), vec3( 0, 0, 1 ) ); }\n\n// icdf for pdf a*exp(-a*x) (wikipedia Exponential distribution)\nfloat ed_icdf( float u, float a ) { return -log( 1. - u ) * ( 1.0 / a ); }\n\n#define INDEXHASHOFFSET3 vec3( 137.0, 53.0, 173 )\n\n#define LAYERED1(func,p,args) ((func(p*1.0,args)*0.5)                                                                                               *(1.0/(0.5)))\n#define LAYERED2(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25)                                                                         *(1.0/((0.5+0.25))))\n#define LAYERED4(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625)                          *(1.0/((0.5+0.25+0.125+0.0625))))\n#define LAYERED5(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625+func(p*16.0,args)*0.03125)*(1.0/((0.5+0.25+0.125+0.0625+0.03125))))\n\nfloat noise12( vec2 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec2 p00 = floor( p );\n\tvec2 p10 = p00 + vec2( 1, 0 );\n\tvec2 p01 = p00 + vec2( 0, 1 );\n\tvec2 p11 = p00 + vec2( 1, 1 );\n\n\tfloat v00 = hash12( p00 );\n\tfloat v10 = hash12( p10 );\n\tfloat v01 = hash12( p01 );\n\tfloat v11 = hash12( p11 );\n\n\tvec2 f = fract( p ); // p-p00 but beware large values...\n\n\tif ( use_smooth ) f = smoothstep_unchecked( f );\n\n\tfloat A = v10 - v00;\n\tfloat B = v01 - v00;\n\tfloat C = ( v11 - v01 ) - A;\n\tfloat D = v00;\n\n//\treturn mix( mix( v00, v10, f.x ), mix( v01, v11, f.x ), f.y ),\n\treturn A * f.x + B * f.y + C * f.x * f.y + D;\n}\n\nfloat noise13( vec3 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tfloat v000 = hash13( p000 );\n\tfloat v100 = hash13( p100 );\n\tfloat v010 = hash13( p010 );\n\tfloat v110 = hash13( p110 );\n\tfloat v001 = hash13( p001 );\n\tfloat v101 = hash13( p101 );\n\tfloat v011 = hash13( p011 );\n\tfloat v111 = hash13( p111 );\n\n\tvec3 f = fract( p ); // bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f);\n\t\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\nvec3 noise33( vec3 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tvec3 v000 = hash33( p000 );\n\tvec3 v100 = hash33( p100 );\n\tvec3 v010 = hash33( p010 );\n\tvec3 v110 = hash33( p110 );\n\tvec3 v001 = hash33( p001 );\n\tvec3 v101 = hash33( p101 );\n\tvec3 v011 = hash33( p011 );\n\tvec3 v111 = hash33( p111 );\n\n\tvec3 f = fract( p ); // bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f); // looks sharper in 3d\n\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\nfloat enoise13( vec3 p, float a, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tvec2 h000 = hash23( p000 );\n\tvec2 h100 = hash23( p100 );\n\tvec2 h010 = hash23( p010 );\n\tvec2 h110 = hash23( p110 );\n\tvec2 h001 = hash23( p001 );\n\tvec2 h101 = hash23( p101 );\n\tvec2 h011 = hash23( p011 );\n\tvec2 h111 = hash23( p111 );\n\n\tfloat v000 = ed_icdf( h000.x, a ) * h000.y;\n\tfloat v100 = ed_icdf( h100.x, a ) * h100.y;\n\tfloat v010 = ed_icdf( h010.x, a ) * h010.y;\n\tfloat v110 = ed_icdf( h110.x, a ) * h110.y;\n\tfloat v001 = ed_icdf( h001.x, a ) * h001.y;\n\tfloat v101 = ed_icdf( h101.x, a ) * h101.y;\n\tfloat v011 = ed_icdf( h011.x, a ) * h011.y;\n\tfloat v111 = ed_icdf( h111.x, a ) * h111.y;\n\n\tvec3 f = fract( p ); // bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f); // looks sharper in 3d\n\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\n// prefix meaning: \n//  e stands for exponential distribution\n//  s stands for smoothstep interpolation\nfloat snoise12_( vec2 p, float args ) { return noise12( p, true ); }\nfloat snoise13_( vec3 p, float args ) { return noise13( p, true ); }\nvec3 noise33_( vec3 p, float args ) { return noise33( p, false ); }\nfloat enoise13_( vec3 p, float a ) { return enoise13( p, a, false ); }\nfloat sfbm1_12( vec2 p ) { return LAYERED1( snoise12_, p, -1.0); }\nfloat sfbm2_13( vec3 p ) { return LAYERED2( snoise13_, p, -1.0); }\nfloat sfbm2_13_leaf( vec3 p ) { return (noise13(p*0.8,true)+noise13(p*4.0,true)*0.6)/1.5;}\nfloat sfbm2_12( vec2 p ) { return LAYERED2( snoise12_, p, -1.0); }\nfloat efbm4_13( vec3 p, float arg ) { return LAYERED4( enoise13_, p, arg); }\nvec3 sfbm4_33( vec3 p ) { return LAYERED5( noise33_, p, -1.0); }\n\nstruct Ray { vec3 o; vec3 d;  };\n\nRay mkray( vec3 o, vec3 d ) { Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\n\nvec3 get_view_dir( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp )\n{\n\treturn normalize( vec3( normalized_pos.x * aspect, normalized_pos.y, -tan_half_fovy_rcp ) ); // note: looking down z\n}\n\n// same as get_view_ray_old but without a znear\n// note that we pass the reciprocal of tan_half_fovy\n// normalized_pos is (-1,1-)->(1,1)\nRay get_view_ray2( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp, mat4 camera )\n{\n\treturn mkray( camera[3].xyz , transform_vector( camera, get_view_dir( normalized_pos, aspect, tan_half_fovy_rcp ) ) );\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n\tvec3 x = normalize( cross( up, z ) );\n\tvec3 y = cross( z, x );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) );\n}\n\nvec2 sphere_trace( Ray ray, float radius, vec3 center )\n{\n\tvec3 O = ray.o;\n\tvec3 d = ray.d;\n\tfloat tp = dot( center - O, d ); // O + d * tp = center projected on line (O,d)\n\tfloat h_sqr = lensqr( ( O + d * tp ) - center );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\nfloat plane_trace( vec3 ray_o, vec3 ray_d, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray_d, n ); return abs( ddotn ) > epsilon ? dot( base - ray_o, n ) / ddotn : FLT_MAX; }\nfloat plane_trace( Ray ray, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray.d, n ); return abs( ddotn ) > epsilon ? dot( base - ray.o, n ) / ddotn : FLT_MAX; }\nfloat plane_trace_z( Ray ray, float base, float epsilon ) { return abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) / ray.d.z : FLT_MAX; }\n// d is a unit direction, ray starts at 0,0,0 base is plane position along z, this is just a division...\nfloat plane_trace_z( vec3 d, float base, float epsilon ) { return abs( d.z ) > epsilon ? base / d.z : FLT_MAX; }\n\n// build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here\nfloat her2( float x, float r ) { return 0.5 * ( ( 1.0 / r ) * x * x + r ); }\n// smooth bevel (like a soft_abs function)\nfloat curved_max_vfunc_weld_quadric( float x, float r ) { x = abs( x ); return x > r ? x : her2( x, r ); }\n// max\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI_soft2( float a, float b, float k ) { return smax_exp2( a, b, k ); }\nfloat opI_soft2_pol( float a, float b, float k ) { return smax_pol( a, b, k ); }\nfloat opI_weld_quadric( float a, float b, float r ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_weld_quadric( a - c, r ); }\n// min(a,b) = -max(-a,-b)\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opU_soft2_pol( float a, float b, float k ) { return -opI_soft2_pol( -a, -b, k ); }\nfloat opU_weld_quadric( float a, float b, float r ) { return -opI_weld_quadric( -a, -b, r ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opS_soft2( float a, float b, float k ) { return opI_soft2( -b, a, k ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\n// r can be zero\nfloat sd_bounds_range_round( vec2 p, vec2 mi, vec2 ma, float r )\n{\n\tvec2 h = ( ma - mi ) * 0.5;\n\tp = abs( p - ( mi + ma ) * 0.5 );\n\tvec2 c = h - r;\n\tfloat mask = maxcomp( step( c, p ) );\n\treturn mix( maxcomp( p - c ), length( max( p - c, vec2( 0.0 ) ) ), mask ) - r;\n}\n\n// r can be zero\nfloat sd_bounds_range_round( vec3 p, vec3 mi, vec3 ma, float r )\n{\n\tvec3 h = ( ma - mi ) * 0.5;\n\tp = abs( p - ( mi + ma ) * 0.5 );\n\tvec3 c = h - r;\n\tfloat mask = maxcomp( step( c, p ) );\n\treturn mix( maxcomp( p - c ), length( max( p - c, vec3( 0.0 ) ) ), mask ) - r;\n}\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\n// those bounds repeat might be good after all, since they centering and lead to a correct repeat...\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\n\nfloat sd_sphere( vec3 p, vec3 center, float radius ) { return length( p - center ) - radius; }\nfloat sd_sphere( vec2 p, vec2 center, float radius ) { return length( p - center ) - radius; }\n\n// iq's https://www.shadertoy.com/view/Xds3zN modified for z up\nfloat sdCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs( vec2( length( p.xy ),p.z)) - h;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, vec2( 0.0 ) ) );\n}\n\n// internal function in packed_spheres_tiling3d\nfloat packed_spheres_tiling3d_internal_layer( vec3 p )\n{\n\tvec2 rh = vec2( 1.0, SQR3 ); // r=1  (normally h = spacing*0.5 * SQR3, and here spacing=2)\n\tvec2 c = rh * 2.0; // cell size for each row\n\tvec2 i1 = floor( p.xy  / c );\n\tvec2 i2 = floor( ( p.xy  - rh ) / c );\n\treturn min(\n\t\tlength( p - vec3( ( i1 + vec2( 0.5 ) ) * c, 0 ) ) - 1.0f,\n\t\tlength( p - vec3( ( i2 + vec2( 0.5 ) ) * c + rh, 0 ) ) - 1.0f ); // second row offset by rh\n}\n\n// sdf of packed spheres of radius 1 (just add to distance for smaller radius...)\nfloat packed_spheres_tiling3d( vec3 p )\n{\n\tvec3 p0 = p;\n\tfloat h = SQR3; // height of equilateral triangle of edge len 1+1=2\n\tfloat b = ( 1.0 - h * h ) / ( -2.0 * h );\n\tfloat c = h - b;\n\tfloat h3 = sqrt( 2.0 * 2.0 - c * c ); // height of tetrahedra, also the spacing between layers, also the half period of each layer\n\tp = p0;\n\tp.z -= ( floor( ( p.z - ( -h3 ) ) / ( 2.0 * h3 ) ) + 0.5 ) * ( 2.0 * h3 ) - h3; // repeat layer\n\tfloat d1 = packed_spheres_tiling3d_internal_layer( p );\n//\treturn d1;\n\tp = p0;\n\tp.y += h - b; // offset to overlap centers of first layer exactly\n\tp.z -= ( floor( ( p.z - 0.0 ) / ( 2.0 * h3 ) ) + 0.5 ) * ( 2.0 * h3 ) - 0.0; // repeat layer\n\tfloat d2 = packed_spheres_tiling3d_internal_layer( p );\n//\treturn d2;\n//\treturn opU( d1, d2 );\n\treturn min( d1, d2 );\n}\n\n// r is sphere radius, distance between 2 spheres is spacing\n// r must be < spacing/2\nfloat packed_spheres_tiling3d( vec3 p, float r, float spacing )\n{\n\tfloat s = spacing * 0.5; // packed sphere radius\n\treturn packed_spheres_tiling3d( p * ( 1.0 / s ) ) * s + ( s - r );\n}\n\n// r is sphere radius, distance between 2 spheres is 2*r\nfloat packed_spheres_tiling3d( vec3 p, float r )\n{\n\treturn packed_spheres_tiling3d( p * ( 1.0 / r ) ) * r;\n}\n\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\n// the couple of following functions are copied from Matt Pettineo's spherical gaussian article, \n// I liked the soft look and ease of use of SG and ended up keeping to the end\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\n\nstruct SG { vec3 Amplitude; vec3 Axis; float Sharpness; };\n\n// approximate integral on omega of sg(v)dv\nvec3 ApproximateSGIntegral( in SG sg ) { return 2. * PI * ( sg.Amplitude / sg.Sharpness ); }\n\nSG CosineLobeSG( in vec3 direction )\n{\n\tSG cosineLobe;\n\tcosineLobe.Axis = direction;\n\tcosineLobe.Sharpness = 2.133f;\n\tcosineLobe.Amplitude = vec3( 1.17f );\n\treturn cosineLobe;\n}\n\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-3-diffuse-lighting-from-an-sg-light-source/\n\nvec3 SGIrradianceFitted( in SG lightingLobe, in vec3 normal )\n{\n\tfloat muDotN = dot( lightingLobe.Axis, normal );\n\tfloat lambda = lightingLobe.Sharpness;\n\n\tfloat c0 = 0.36f;\n\tfloat c1 = 1.0f / ( 4.0f * c0 );\n\n\tfloat eml  = exp( -lambda );\n\tfloat em2l = eml * eml;\n\tfloat rl   = 1.0 / lambda;\n\n\tfloat scale = 1.0f + 2.0f * em2l - rl;\n\tfloat bias  = ( eml - em2l ) * rl - em2l;\n\n\tfloat x  = sqrt( 1.0f - scale );\n\tfloat x0 = c0 * muDotN;\n\tfloat x1 = c1 * x;\n\n\tfloat n = x0 + x1;\n\n\tfloat y = saturate( muDotN );\n\tif ( abs( x0 ) <= x1 ) y = n * n / x;\n\n\tfloat result = scale * y + bias;\n\n\treturn result * ApproximateSGIntegral( lightingLobe );\n}\n\n// what am I doing\nvec3 SGDiffuseFitted( in SG lightingLobe, in vec3 normal, vec3 albedo )\n{\n\tvec3 brdf = albedo / PI;\n\treturn SGIrradianceFitted( lightingLobe, normal ) * brdf;\n}\n\n// BUFFER_MODE\n// 0: normal size (ugly but use to check artifacts in high def, also cloudless)\n// 2: halfsize + history reprojection... blurry-but-AA type of thing\n#define BUFFER_MODE 2\n\n// iChannel0 is always Buf A\n// iChannel1 is always Buf B\n\n// note: glsl doesn't let us write if (1), so we write if (_1), note that occasionally compiler may fail to treat that as a static branch\n#define _1 true\n#define _0 false\n\n// skip space faster above bushes (and maybe other things if proves useful)\n// notes:\n//  - at higher res we can see that causes artifacts, see the bit that sets\n//    eval.terrain_warp and tweak hack constants there\n//  - this causes artifacts on trees's tracing... close to patch borders maybe? (messes with shadows sometimes)\n//  - this messes with bush shadows even when bush surface seems unchanged (shrinks shadows a bit)\n#define TERRAIN_WARP\n\n#define FORCE_LOOP +min(0,aFrame)\n#define FORCE_LOOPF +min(0.0,float(aFrame))\n\n#define SHADOW_TINT_SATURATION 0.45 // [0,1]\n\n#define AO _0 // nice term, visible extra cost, but doesn't contribute much, so disable \n#define SHADOWS _1\n\n#define SUN _1\n#define SUN_GLARE _0 // could be interesting but needs more work\n\n#define GROUND_OCCLUSION _1 // first sdf is ground's base level so we get occlusion\n#define PATH _1 // cost peanuts\n#define GRASS _1 // cost peanuts\n#define BUSH _1 // a bit expensive\n#define TREE _1 // super expensive\n#define FARM _1 // cost a little bit\n#define BRICKWALL _1 // cost a little bit\n\n#define TAYLOR_HEIGHT_BUSH _1\n#define TAYLOR_HEIGHT_TREE _1\n#define TAYLOR_HEIGHT_FARM _0 // object is too large, causes a little bit too much distortion\n\n#define GHOST_STEPS_PATCH _1\n#define GHOST_STEPS_TREE _1 // visible extra cost, fixes the trees, but we start hitting iteration limit\n#define GHOST_STEPS_FARM _1 // little cost (large cells) and fixes farms, hits a little bit more max iterations far away\n// about GHOST_MAX_DIST:\n// introduced a second distance for bird views\n// having 2 thresh lets us fix bird view, but they get more expensive\n#define GHOST_MAX_DIST_FROM_T0 7.0\n#define GHOST_MAX_DIST_ABS 25.0\n// fixes weird grain that happens when using second threshold that goes further away... hack hack...\n#define GHOST_EPS 0.0001\n\n#define DISPLACE_PATH _1 // a bit expensive, actually\n#define DISPLACE_PATH_AMPL 0.002\n\n#define DISPLACE_PINE _1\n#define DISPLACE_TREE _1\n#define DISPLACE_BUSH _1\n#define DISPLACE_BUSH_FREQ 8.0\n\n// CLOUD_MODE\n//  0: no cloud\n//  1: trace cloud per pixel (for debug)\n//  2: cache trace cloud in B texture every frame and use that (for debug)\n// >3: cache trace cloud in B texture only first frame and use that (same cost as no cloud)\n#define CLOUD_MODE 3\n\n// the wind doesn't have much amplitude, and movement isn't smooth enough, but reprojection hides that a bit...\n#define WIND_BUSH _1\n#define WIND_TREE_AND_PINES _1\n\n#define FARM_WINDOWS _1\n\n#define SOFT_BLEND_BUSH _1\n#define SQUARE_BUSH_TEST _1 // some farms have nicely cut bushes arounds them\n\n#define MATID_NONE    0.0\n#define MATID_BUSH    1.0\n#define MATID_TRUNK   2.0\n#define MATID_HOUSE   3.0\n#define MATID_ROOF    4.0\n#define MATID_PINE    5.0\n#define MATID_BRICKWALL   6.0\n#define MATID_GRASS   7.0\n#define MATID_GROUND  8.0\n#define MATID_TREE    9.0\n#define MATID_WINDOW 10.0\n#define MATID_HOUSE_BOTTOM 11.0\n\n#define BROWN (vec3(133,84,57)/255.0)\n#define PATH_COLOR BROWN\n#define PATH_COLOR2 (BROWN*0.8)\n#define COLOR_BUSH1 (0.8*vec3(0.07,0.3,0.05))\n#define COLOR_BUSH2 (0.55*vec3(0.12,0.6,0.2))\n#define COLOR_BUSH3 (0.55*vec3(0.1,0.35,0.09))\n#define COLOR_BUSH4 (0.82*vec3(0.18,0.39,0.06))\n#define COLOR_BUSH5 vec3(0.1,0.3,0.01) // rare color\n#define COLOR_TREE1 (vec3(0.1,0.35,0.09)*0.55)\n#define COLOR_TREE2 (vec3(0.1,0.45,0.08)*0.8)\n#define COLOR_TREE_SURF vec3(0.15,0.4,0.04)\n#define COLOR_GRASS vec3(0.1,0.35,0.09)\n#define COLOR_GRASS2 vec3(0.35,0.39,0.06)\n#define COLOR_MOWED_GRASS vec3(0.17,0.37,0.05)\n#define COLOR_MOWED_GRASS2 (COLOR_MOWED_GRASS* 0.6)\n#define COLOR_PINE (vec3(0.4,1.0,0.2)*0.2)\n#define COLOR_PINE2 (vec3(0.5,1.0,0.0)*0.32)\n#define COLOR_TRUNK (BROWN*0.5)\n#define COLOR_ROOF1 (vec3(0.6,0.2,0.3)*0.7)\n#define COLOR_ROOF2 (vec3(0.1,0.4,0.5)*0.7)\n#define COLOR_BRICKWALL mix(vec3(0.52,0.33,0.22),vec3(0.9,0.9,0.7),0.35)\n#define COLOR_HOUSE mix((vec3(1,1,1)*0.65),COLOR_BRICKWALL,0.1) // white is a bit too white so blend with brickwall color\n#define COLOR_HOUSE_BOTTOM (COLOR_HOUSE*0.7)\n\nstruct CellPoint\n{\n\tvec2 p;\n\tivec2 _pi; // some cell index to take a hash from\n\tfloat pradius; // point radius, small points can be closer to cell edges\n};\n\n// meaning of id varies, if 32bits floats we should be able to have exact ints up to 2^24=16777216\nstruct DistanceId { float d; float id;  };\n\nDistanceId MkDistanceId( float d, float id ) { DistanceId v; v.d = d; v.id = id; return v; }\n\nDistanceId MkDistanceId_16( float d, float id, float id_fraction )\n{\n\treturn MkDistanceId( d, float( int( id ) | ( int( id_fraction * 65535.0 ) << 5 ) ) );\n}\n\nDistanceId MkDistanceId_5_5_5( float d, float id, vec3 v )\n{\n\treturn MkDistanceId( d, float( int( id )\n\t\t\t\t\t\t\t\t   | ( int( v.x * 31.0 ) <<  5 )\n\t\t\t\t\t\t\t\t   | ( int( v.y * 31.0 ) << 10 )\n\t\t\t\t\t\t\t\t   | ( int( v.z * 31.0 ) << 15 ) ) );\n}\n\nvec2 DecodeId_16( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn vec2( float( i&31 ), float( i >> 5 ) * ( 1.0 / 65535.0 ) );\n}\n\nfloat DecodeId( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn float( i&31 );\n}\n\nvec4 DecodeId_5_5_5( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn vec4( float( i&31 )\n\t\t\t\t , float( ( i >>  5 ) & 31 ) * ( 1.0 / 31.0 )\n\t\t\t\t , float( ( i >> 10 ) & 31 ) * ( 1.0 / 31.0 )\n\t\t\t\t , float( ( i >> 15 ) & 31 ) * ( 1.0 / 31.0 ) );\n}\n\n#if 0 \n// bogus build error on ? : in shadertoy\nDistanceId opUdi( DistanceId a, DistanceId b ) { return a.d < b.d ? a : b; }\n#else\nDistanceId opUdi( DistanceId a, DistanceId b ) { if ( a.d < b.d ) return a; return b; }\n#endif\n\n// some rough scale for the roads pattern\n// you need to tweak x spacing and y spacing of path slabs\n// and the x and y scale of the main path function\n#define LANEWIDTH 0.08\n\n// 0: sin waves\n//>1: sin waves with flat sections (default)\n// 2: constant (straight lines, rectangular layout)\n// 3: smooth noise\n#define LANE_FUNC 1\n\nvec2 PathNoise11sD( float x )\n{\n\tx -= 0.5;\n\tfloat fr = fract( x );\n\tint x0 = int( x - fr );\n\tuint i = uint( x0 );\n\tfloat y0 = hash11u_lowbias32( i );\n\tfloat y1 = hash11u_lowbias32( i + 1u );\n\tfloat f = smoothstep_unchecked( fr );\n\tfloat fd = smoothstep_unchecked_d( fr );\n\treturn vec2( mix( y0, y1, f ), ( y1 - y0 ) * fd );\n}\n\n// return lane's (y,y'), called a lot so make it cheap (this *does not* return world space y coord)\nvec2 wavyLaneFuncAndDerivative( float x, float lane_index )\n{\n#if LANE_FUNC==0\n\tfloat a = mix( 0.5, 1.7, ( 1.0 + cos( lane_index ) ) * 0.5 ); // per lane constant\n\treturn vec2( ( sin( a * x ) + 1.0 ) * 0.5, 0.5 * a * cos( a * x ) );\n#elif LANE_FUNC==1\n\t// sin wave with soft straight sections so it's just all curvy\n\tfloat a = mix( 0.9, 2.0, ( 1.0 + cos( lane_index ) ) * 0.5 ); // per lane constant\n\tfloat z = ( 1.0 + sin( x * a ) ) * 0.5;\n\treturn vec2( z * z, a * z * cos( a * x ) );\n#elif LANE_FUNC==2\n\treturn vec2( 0.5, 0 );\n#elif LANE_FUNC==3\n\treturn PathNoise11sD( x - lane_index * 80.0 );\n#endif\n}\n\n#define PATH_SPACING_Y 1.0\n// used by camera, don't forget to offset by lane_index (regular wavyLaneFuncAndDerivative() doesn't care!)\nvec2 wavyLaneFuncAndDerivative_WORLD( float x, float lane_index )\n{\n\treturn wavyLaneFuncAndDerivative( x, lane_index ) + vec2( lane_index * PATH_SPACING_Y, 0 );\n}\n\n// return vector to closest point in .xy, derivative there in .zw\n// use cheap when you don't care about accurate distance or closest point\nvec4 sdWavyLane( vec2 p, float lane_index, bool cheap )\n{\n\tvec4 ret;\n\tCLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( ret, p, wavyLaneFuncAndDerivative, lane_index, cheap )\n\treturn ret;\n}\n\nstruct SceneIn\n{\n\t// constant during trace:\n//\tvec3 o;\n\tvec3 v;\n\tvec3 v_rcp; // for cell boundaries\n\tint trace_flags; // we can skip material related calculations during the traversal and enable only on shade\n\t// varying during trace:\n\tvec3 p;\n\tfloat t0; // warp start to hmax\n\tfloat t;\n};\n\nstruct ClosestPath\n{\n\tDistanceId patch_di; // patch id and distance (which is also the distance to paths)\n\tvec2 v2closest; // vector to closest patch boundary point, in world coords\n\tfloat curve_local_param; // the curve parameter, p.x in the local curve distance eval, so we can parametrixe space for making walls etc\n\t\t\t\t\t   // (since the path uses x and y directions we need to know which was used)\n};\n\nvec2 GetLocalCurvePoint( ClosestPath path ) { return vec2( path.curve_local_param, length( path.v2closest ) ); }\n\n// spacing must be >= 1 for the band to work\nClosestPath EvalClosestPathSlab( vec2 p, float spacing, bool cheap )\n{\n\tfloat id1 = floor( p.y / spacing );\n\tp.y = p.y - id1 * spacing;\n\tvec4 c1 = sdWavyLane( p, id1, cheap ); // should return in 0,spacing\n\tfloat d1 = cheap ? abs( c1.y ) : length( c1.xy );\n\tfloat s1 = sign( c1.y ); // this tells us if are above or below the curve (which adjacent curve to eval)\n\n\tfloat id2 = id1 - s1; // find the other 1d lane of the slab we are in: next or prev\n\tvec4 c2 = sdWavyLane( p + vec2( 0, s1 * spacing ), id2, cheap );\n\tfloat d2 = cheap ? abs( c2.y ) : length( c2.xy );\n\tfloat s2 = sign( c2.y );\n\n\tfloat m = s2 < 0.0 ? id1 : id1 - s1;\n\n\tClosestPath eval;\n\tif ( d1 < d2 ) { eval.patch_di.d = d1; eval.v2closest = c1.xy; }\n\telse           { eval.patch_di.d = d2; eval.v2closest = c2.xy; }\n\teval.patch_di.id = m;\n\teval.curve_local_param = p.x;\n\treturn eval;\n}\n\n// the lane curve is evaluated 4 times (twice per axis)\nClosestPath EvalClosestPath( vec2 p, bool cheap )\n{\n\t// horizonal lanes\n\t// PATH_SPACING_Y must be >= 1 for the band to work\n\tClosestPath ev1 = EvalClosestPathSlab( p, PATH_SPACING_Y, cheap );\n\n\t// vertical lanes\n\t// each horizontal stab can call a different set of vertical lanes which generates complex patterns\n\tvec2 p2 = perp( p ); // 90 degrees\n\t// important: spacing2 must be >= 1 for the band to work\n\tfloat spacing2 = ( 1.0 + 4.0 * ( sin( ev1.patch_di.id * 10.0 ) + 1.0 ) * 0.5 ); // spacinf of vertical lane can differ per horizontal stab which is key to complex branching patterns\n\tClosestPath ev2 = EvalClosestPathSlab( p2, spacing2, cheap );\n\tev2.v2closest = -perp( ev2.v2closest ); // put v2closest back to world coords (-90 degrees)\n\n\tClosestPath eval = ev1;\n\teval.patch_di.id *= ev2.patch_di.id; // get a unique id for this patch\n\tif ( ev2.patch_di.d < ev1.patch_di.d )\n\t{\n\t\teval.patch_di.d = ev2.patch_di.d;\n\t\teval.v2closest = ev2.v2closest;\n\t\teval.curve_local_param = ev2.curve_local_param;\n\t}\n\treturn eval;\n}\n\n// I hope you like magic constant\n#define MAX_TERRAIN_HEIGHT 0.74\n#define TALLEST_OBJECT_HEIGHT 0.645\n\nfloat sin_bumps_array( vec2 p ) { return sin( p.x ) * sin( p.y ) + 1.0; }\n\n// this function is called a lot so pick something simple\nfloat BaseGroundHeight( vec2 p  )\n{\n\tfloat h = sin_bumps_array( p.xy * ( 0.16 * PI ) ) * 0.5;\n\treturn h * h * MAX_TERRAIN_HEIGHT; // sinbumps as is is too bumpy everywhere, we need also flatter areas, so square h\n}\n\n// image was blue point juniper... end result is noise vomit\nfloat pine_tree_cross_section( float x, vec2 rh ) { x /= rh.y; return cubicbump( x, 3.0, -0.98 ) * rh.x; }\nfloat sdRevolutionPine( vec3 p, float r, float h )\n{\n\tvec2 p2d = vec2( ( p.z ), length( p.xy ) );\n\tif ( p2d.x >= h ) return length( p2d - vec2( h, 0 ) ); // don't forget to deal with endpoints...\n\tif ( p2d.x <= 0.0 ) return length( p2d - vec2( 0, 0 ) );\n\tfloat d; // note: we could use FAST_SIGNED_DISTANCE_TO_FUNCD_11_ARG but function is relatively cheap to eval so\n\tFAST_SIGNED_DISTANCE_TO_FUNC_11_ARG( d, p2d, pine_tree_cross_section, vec2( r, h ), 1e-3 );\n\treturn d; // note: this is already signed\n}\n\nvec3 ApplyWind( vec3 pd, float aTime ) { return vec3( sin( aTime * 0.8 + pd.zx ) * 0.0003, 0 ); }\n\nfloat ddPineSurfLayer( vec3 p )\n{\n\tp *= 400.0;\n\tp.z *= 0.25;\n\tp.xy = rotate_with_angle( p.xy, p.z * 0.11 );\n\treturn ( ( tri_sin( p.x ) + tri_sin( p.y ) + tri_sin( p.z ) ) + 3. ) * ( 1. / 6. ); // normalize to 0,1\n}\n\nfloat ddPineSurf( vec3 p )\n{\n\treturn ( ddPineSurfLayer( p ) + ddPineSurfLayer( vec3( rotate_with_angle( p.xy, 0.5 ), p.z ) * 0.5 ) )\n\t\t   * ( 1. / ( 2.5 ) ); // normalize to 0,1\n}\n\nfloat sdDisplacePine( vec3 p, float d, float uheight )\n{\n\tif ( !DISPLACE_PINE ) return d;\n\tfloat dd_amp = 0.018;\n\tif ( d > dd_amp ) return d;\n\tdd_amp *= ddPineSurf( p );\n\treturn d + dd_amp;\n}\n\n#define TRACE_VIEW 1\n#define TRACE_SHADE 2\n#define TRACE_AO 4\n#define TRACE_SHADOW 16\n#define TRACE_HAS_DIRECTION 64 // note: it is faster to check flags than checking for v_rcp == 0 or whatnot (that might not been resolved to static)\n\nbool IsShadeTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADE ) != 0; }\nbool IsShadowTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADOW ) != 0; }\nbool HasDirection( int trace_flags ) { return ( trace_flags & TRACE_HAS_DIRECTION ) != 0; }\n\nDistanceId sdTreeLeaves( vec3 p, vec2 c, float cz, float trunk_height\n\t\t\t\t\t\t , float leaves_volume_base_radius\n\t\t\t\t\t\t , float leaves_volume_top_radius\n\t\t\t\t\t\t , int trace_flags\n\t\t\t\t\t\t , float color_rnd )\n{\n\tfloat d = FLT_MAX;\n\tvec3 c0 = vec3( c, cz + trunk_height * 0.7 );\n\tvec3 c1 = vec3( c, cz + trunk_height );\n\tfloat d0 = length( p - c0 ) - leaves_volume_base_radius;\n\tfloat d1 = length( p - c1 ) - leaves_volume_top_radius;\n\t// soft blend between 2 sphere for the base leaves volumes\n\tfloat k = leaves_volume_base_radius * 0.4;\n\td = opU_soft2_pol( d0, d1, k );\n//\treturn MkDistanceId( d, MATID_TREE );\n\n#define TREE_SDD 0.02 // upper bound for  amplitude of fine displacement on pines and trees\n\n\tfloat dd1 = 0.007;\n\tif ( d > dd1 + TREE_SDD ) return MkDistanceId( d, MATID_TREE ); // massive saving. only consider envelope displacement when we are close\n\n\tfloat d_envelope = d;\n\tbool blend = _1;\n\tfloat depth = 0.0;\n\tfloat uheight = 0.0;\n\t\n\tif ( _1 )\n\t{\n\t\t// make the leaves volume more bubbly by using 2 layers of *packed* 3d spheres regular tiling (non packed doesn't work well)\n\t\t// see @Shane's cellular tiling shaders/comments\n\n\t\tmat3 m3 =\n\t\t\tmat3_rotation_x( unit_vector2( radians( c.x * 200. ) ) ) *\n\t\t\tmat3_rotation_z( unit_vector2( radians( c.y * 200. ) ) );\n\n\t\tfloat dl1;\n\n\t\t{\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.3;\n\t\t\tfloat da1 = packed_spheres_tiling3d( p * m3, c1, c1 * 2.5 ); // more spacing gives more clustering/bumpiness\n\t\t\tda1 += smoothstep( cz + trunk_height * 0.75, cz + trunk_height, p.z ) * 0.007;\n\t\t\tdl1 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.3 )\n\t\t\t\t: opI( d_envelope, da1 );\n\t\t}\n\n\t\tfloat dl2;\n\n\t\t{\n\t\t\t// note: the second packed_spheres_tiling3d could just be global and evaluated 1 for the 3 trees\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.4;\n\t\t\tfloat da1 = packed_spheres_tiling3d( m3 * p, c1, c1 * 2.5 );\n\t\t\tdl2 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.25 )\n\t\t\t\t: opI( d_envelope, da1 );\n\t\t}\n\n\t\tfloat d_leaf_clusters = blend\n\t\t\t? opU_weld_quadric( dl1, dl2, leaves_volume_base_radius * 0.1 )\n\t\t\t: opU( dl1, dl2 );\n\n\t\td = blend\n\t\t\t? opU_weld_quadric( d_leaf_clusters, d_envelope + 0.02, leaves_volume_base_radius * 0.19 )\n\t\t\t: d_leaf_clusters;\n\n\t\tdepth = saturate( 1.0 / ( 1. + abs( d - d_envelope ) * 100. ) );\n\t\t\n\t\tfloat b = c0.z - leaves_volume_base_radius; // bottom most-ish\n\t\tfloat t = c1.z + leaves_volume_top_radius; // topmost-ish\n\t\tuheight = saturate( ( p.z - b )/( t - b ) ); // a 0-1 normalized height value for shading\n\t}\n\n\tif ( _1 )\n\t{\n\t\t// clip leaves volume's bottom with a wavy surface so it's not spherical things everywhere\n\t\tfloat clipsurf = ( ( c0.z - leaves_volume_base_radius * .6 )\n\t\t\t\t\t\t   + leaves_volume_base_radius * 0.1\n\t\t\t\t\t\t   * ( sin_bumps_array( p.xy * ( 13.0 * PI ) ) - 2.4 ) );\n\n\t\td = blend\n\t\t\t? opI_weld_quadric( d, -( p.z - clipsurf ), leaves_volume_base_radius * 0.15 )\n\t\t\t: opI( d, -( p.z - clipsurf ) );\n\t}\n\n\treturn MkDistanceId_5_5_5( d, MATID_TREE, saturate( vec3( depth, uheight, color_rnd ) ) );\n}\n\n// retrieve terrain height, using full eval or taylor expansion\nfloat CalcHeight( vec2 c, vec2 p, vec3 h_gradval, bool taylor_expansion_height )\n{\n\treturn taylor_expansion_height\n\t\t   ? h_gradval.z + dot( h_gradval.xy, c - p ) // h(p)=h(c)+(c-h).grad(c): taylor expansion to skip height evaluations \n\t\t   : BaseGroundHeight( c );\n}\n\nDistanceId sdGridObj_TreeOrPine( DistanceId di\n\t\t\t\t\t\t\t\t , vec3 p\n\t\t\t\t\t\t\t\t , CellPoint cr\n\t\t\t\t\t\t\t\t , float radius_fraction\n\t\t\t\t\t\t\t\t , float patch_id\n\t\t\t\t\t\t\t\t , inout vec3 color\n\t\t\t\t\t\t\t\t , SceneIn scenein\n\t\t\t\t\t\t\t\t , vec3 h_gradval, bool taylor_expansion_height )\n{\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; // CULL\n#if 0\n\t// doesn't save enough vs extra test cost\n\tif ( HasDirection( scenein.trace_flags ) )\n\t{\n\t\tvec2 n = perp( scenein.v.xy );\n\t\tvec2 o = scenein.o.xy;\n\t\tvec2 pp = project_on_plane( c, o, n );\n\t\tif ( lensqr( p.xy - pp ) > r * r ) return di;\n\t}\n#endif\n\tvec4 hhh = hash42_( cr._pi * 123 );\n\tvec3 tree_base_point = vec3( c, cz );\n\n\tfloat pine_dice_roll = hhh.x;\n\tfloat pine_probability = 0.7;\n\t\n\tif ( _1 && ( pine_dice_roll > pine_probability) )\n\t{\n\t\tfloat pine_radius_scale = mix( 0.65, 0.75, hhh.w ) * r;\n\t\tfloat pine_height = mix( 0.42, 0.56, hhh.z * hhh.z );\n\t\tfloat uheight = saturate( ( p.z - cz ) / pine_height );\n\t\tDistanceId pine_tree = MkDistanceId_5_5_5( \n\t\t\tsdDisplacePine( p - tree_base_point\n\t\t\t\t\t\t\t, sdRevolutionPine( p - tree_base_point, pine_radius_scale, pine_height ), uheight )\n\t\t\t, MATID_PINE, vec3( 0.0, uheight, ( ( hhh.x - pine_probability ) * ( 1.0 / ( 1.0 - pine_probability ) ) ) ) );\n\t\treturn opUdi( di, pine_tree );\n\t}\n\n\thhh.x *= 1.0/pine_probability; // back into [0,1]\n\tfloat aa = mix( 0.018, 0.012, hhh.y ); // trunk\n\tfloat trunk_height = aa * ( 1.1 * 1.0 / 0.018 ) * mix( 0.2, 0.35, hhh.z * hhh.z );\n\tfloat trunk_radius = aa * 0.8;\n\tfloat leaves_volume_top_radius = mix( 0.5, 0.7, hhh.w ) * r;\n\tfloat leaves_volume_base_radius = mix( 1.1, 1.35, hhh.y ) * leaves_volume_top_radius;\n\tDistanceId leaves = sdTreeLeaves( p, c, cz, trunk_height, leaves_volume_base_radius, leaves_volume_top_radius, scenein.trace_flags, hhh.x );\n\tfloat trunk_uheight = saturate( ( p.z - cz ) / trunk_height );\n\ttrunk_radius *= mix(0.8,1.2,pow2(1.0-saturate(trunk_uheight*3.5)));\n\tDistanceId trunk = MkDistanceId( sdCylinder( p - tree_base_point, vec2( trunk_radius, trunk_height ) ), MATID_TRUNK );\n\tif ( trunk.d < 0. ) leaves = trunk; // horrible hack to force trunk to be trunk inside leaves, as the leaves sdf has been hacked to death and union doesn't quite work anymore\n\treturn opUdi( di, opUdi( trunk, leaves  ) );\n}\n\n// function used to make roof tiles\n// a1 is the slope of curve going up (1.)\n// a2 is the slope of curve going down (-2.)\n// p is the period\nfloat hard_waves( float x, float a1, float a2, float p ) { x = repeat( x, p ); return min( a1 * x, a2 * ( x - p ) ); }\n// roof tiles height field (hf)\nfloat hf_SurfaceRoofTiles( vec2 p ) { return 0.1 * hard_waves( p.y, 0.3, -1.1, 0.024 ) + 0.001 * ( 1.0 - pow2( 1.0 - abs( sin( p.x * 200. ) ) ) ); }\n\nstruct WindowOrDoorArg\n{\n\tvec2 c; // cellsize\n\tvec2 g; // num cells\n\tfloat frame_width, border_height, border_depth, glass_depth, frame_depth;\n};\n\nvoid sdOneWindow( vec3 p, inout DistanceId eval, WindowOrDoorArg args )\n{\n\tfloat d_in = eval.d;\n\tvec2 c = args.c;\n\tvec2 g = args.g - vec2( 1 );\n\tp.x += ( args.g.x * 0.5 - 0.5 ) * c.x; // center on x...\n\tvec2 pmin = -c.xy * 0.5;\n\tvec2 pmax = c.xy * ( vec2( 0.5 ) + g );\n\t// window glass and frame\n\tvec3 pr = p;\n\tvec2 i = floor( ( pr.xy - ( -c * 0.5 ) ) / c ); // c the cell size\n\ti = clamp( i, vec2( 0, 0 ), g );\n\tpr.xy -= i * c;\n\tfloat d_glass = sd_bounds_half_size( pr, vec3( c * 0.5 - vec2( args.frame_width ) * 0.5, args.glass_depth ) );\n\teval.d = opS( eval.d, d_glass );\n\t// window general frame\n\tfloat d_frame = sd_bounds_range( p, vec3( pmin, -args.frame_depth ), vec3( pmax, args.frame_depth ) );\n\teval.d = opS( eval.d, d_frame ); // make the whole window sink a bit\n\t// window border\n\tif ( _1 ) eval.d = opI( d_in - args.border_depth // clamp vs inflated version of source block we are decorating\n\t\t\t\t\t\t\t, opU( eval.d\n\t\t\t\t\t\t\t\t   , sd_bounds_range( p\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmin.x, pmin.y - args.border_height, 0 )\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmax.x, pmin.y, args.border_depth ) ) ) );\n\tif ( -d_glass == eval.d ) eval.id = MATID_WINDOW; // we used opS so we need -d_glass\n}\n\nvoid addWindow( inout DistanceId eval, vec3 p, float is_chimney_face, float half_wall_width )\n{\n\tp.y += 0.016; // adjust windows height\n\tvec2 c = vec2( 0.07*mix(1.8,1.0,is_chimney_face), 0.07 ); // tile size\n\tvec2 window_size = vec2( 0.018, 0.02 ); // size of the object inside each tile, must be smaller than c\n\tfloat d_glass = FLT_MAX;\n\tvec2 i = floor( ( p.xy - ( -c.xy * 0.5 ) ) / c.xy ); // c the cell size\n\tfloat maxnum_cells = floor( (half_wall_width / c.x) - 0.5 ); // max num window that fit on this wall, assume p.x centered\n\tivec2 imin = ivec2( -maxnum_cells, 1 );\n\tivec2 imax = ivec2(  maxnum_cells, 1 );\n\ti = clamp( i, vec2(imin), vec2(imax) );\n\tp.xy -= i * c;\n\tWindowOrDoorArg args;\n\targs.c = window_size; // cellsize\n\targs.g = mix( vec2( 2, 2 ), vec2( 2, 2 ), is_chimney_face ); // window glass grid size\n\tfloat scl = 0.012;\n\targs.frame_width = 0.05 * scl;\n\targs.border_height = 0.3 * scl;\n\targs.border_depth = 0.2 * scl; // can't be bigger than d_house_bottom_inset\n\targs.glass_depth = 0.3 * scl;\n\targs.frame_depth = 0.1 * scl;\n\tsdOneWindow( p, eval, args );\n}\n\n// convert point p to y=0 face local point, a is a plane base3d/origin2d point\nvec3 p2yface( vec3 p, vec2 orig ) { p.y = abs( p.y ); p.xy -= orig; p.xzy = p.xyz; p.x = -p.x; return p; }\n// convert point p to y=0 face local point, a is a plane base3d/origin2d point\nvec3 p2xface( vec3 p, vec2 orig ) { p.x = abs( p.x ); p.xy -= orig; return p.yzx; }\n\n// note: tracing detail doesn't always work very well on heightfields so z proj/triplanar type of mapping isn't great for roof\n// instead we do more tedious evals, building roof local points + 3d detail on that etc\nDistanceId sdFarm( vec3 p, CellPoint cr,float patch_id,float r, float detail )\n{\n\tvec4 hh = hash42_( cr._pi);\n\tbool has_chimney = hh.y > 0.4;\n\tbool _x2chimney = _1;\n\tvec2 hs1 = vec2( 0.25, 0.083 );\n\tvec2 hs2 = vec2( 0.083, 0.18+hh.z*0.02 );\n\tfloat h = 0.0996;\n\tfloat bottom_block_inset = 0.00498;\n\tfloat bottom_block_inset2 = bottom_block_inset*(has_chimney?0.0:1.0);\n\tfloat roof_thickness = 0.00166;\n\tfloat chimney_side_len = 0.018+hh.z*0.002; // chimney side length\n\tfloat chimney_height = h + hs1.y + chimney_side_len;\n\tfloat chimney_bottom = h + hs1.y - 0.04;\n\tfloat roof_tile_scl = 2.5; \n\tfloat roof_tile_scl2 = 1.1; \n\tbool half_hipped = hh.z>0.5;\n\tfloat bottom_inflate = 0.001;\n\tvec2 hs1_in = hs1 - vec2( bottom_block_inset2, bottom_block_inset );\n\tvec2 hs2_in = hs2 - vec2( bottom_block_inset );\n\t// symmetric window plane\n\tfloat block1_chimney_wall_plane_x = hs1_in.x;\n\tfloat block1_wall_plane_y = hs1_in.y;\n\tfloat block2_wall_plane_y = hs2_in.y;\n\tvec3 ps = p; // store signed p\n\tvec3 pay = p; pay.y = abs( pay.y ); // symmetric around y\n\tvec3 pax = p; pax.x = abs( pax.x ); // symmetric around x\n\tfloat d_block1_bottom = FLT_MAX;\n\tfloat d_block1_roof = FLT_MAX;\n\tfloat d_block1_bottom2 = FLT_MAX;\n\t{\n\t\t// --- gable roof, 2 planes (v-shaped)\n\t\tbounds2 block1 = mkbounds_unchecked( -hs1, hs1 );\n\t\tfloat d_block1_footprint = sd_bounds_range( p.xy, block1.pmin.xy, block1.pmax.xy );\n\t\tvec3 roof1_top_point = vec3( hs1.x, 0, h + hs1.y );\n\t\t// p.yz is the gable roof cross section space point\n\t\tvec3 roof_plane_local_p = vec3( -dot( pay.yz - roof1_top_point.yz, perp( V45 ) ), p.x, dot( pay.yz - roof1_top_point.yz, V45 ) );\n\t\td_block1_bottom = opI( roof_plane_local_p.z, d_block1_footprint );\n\t\td_block1_bottom = opI( d_block1_bottom, pay.y -hs1_in.y );\n\t\td_block1_bottom = opI( d_block1_bottom, pax.x - block1_chimney_wall_plane_x );\n\t\td_block1_bottom = opI( d_block1_bottom, roof_plane_local_p.z + 0.002 );\n\t\t// add tile detail to gabble roof, hacky mess to be sorted\n\t\td_block1_roof = roof_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof_plane_local_p.yx * roof_tile_scl )* roof_tile_scl2;\n\t\td_block1_roof = opS( d_block1_roof, roof_plane_local_p.z + 0.002 );\n\t\td_block1_roof = opI( d_block1_roof, d_block1_footprint );\n\t\td_block1_bottom2 = opI(d_block1_footprint-bottom_inflate,p.z);\n\t}\n\tfloat d_chimney = FLT_MAX;\n\tif ( has_chimney )\n\t{\n\t\tvec2 chimney_c = vec2( hs1_in.x, 0 );\n\t\tbounds2 chimney_footprint_b = mkbounds_unchecked( chimney_c - vec2( chimney_side_len ), chimney_c + vec2( 0, chimney_side_len * 0.5 ) );\n\t\tfloat d_chimney_footprint = sd_bounds_range( _x2chimney ? abs( p.xy ) : p.xy, chimney_footprint_b.pmin.xy, chimney_footprint_b.pmax.xy );\n\t\td_chimney = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z -chimney_height ) );\n\t\tfloat d_chimney_hole = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z - chimney_height * 1.5 ) ) + 0.002;\n\t\td_chimney = opS( d_chimney, d_chimney_hole );\n\t}\n\tfloat d_block2_roof = FLT_MAX;\n\tfloat d_block2_bottom = FLT_MAX;\n\tfloat d_block2_bottom2 = FLT_MAX;\n\tif ( hh.x > 0.4 )\n\t{\n\t\t// --- hipped roof\n\t\tbounds2 block2 = mkbounds_unchecked( -hs2, hs2 );\n\t\tfloat d_block2_footprint = sd_bounds_range( p.xy, block2.pmin.xy, block2.pmax.xy );\n\t\t//return d_block1_roof;\n\t\td_block2_bottom = opI( d_block2_footprint + bottom_block_inset, ( p.z - h ) ); // block2 is inset equally on x and y \n\t\td_block2_bottom2 = opI(d_block2_footprint-bottom_inflate,p.z);\n\t\t\n\t\t//return d_block2_bottom;\n\t\tvec3 roof2_corner_point = vec3( hs2, h );\n\t\tvec3 roof2a_plane_local_p = vec3( p.y, -dot( pax.xz - roof2_corner_point.xz, perp( V45 ) ),dot( pax.xz - roof2_corner_point.xz, V45 ) );\n\t\tfloat roof2detail_a = roof2a_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2a_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\t// like the s1 one, exactly. just offset, can we factorize?\n\t\tvec3 roof2b_plane_local_p = vec3( p.x, -dot( pay.yz - roof2_corner_point.yz, perp( V45 ) ),dot( pay.yz - roof2_corner_point.yz, V45 ) );\n\t\tfloat roof2detail_b = roof2b_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2b_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\td_block2_roof = opI( roof2b_plane_local_p.z, roof2a_plane_local_p.z );\n\t\td_block2_roof = opI( roof2detail_a, roof2detail_b );\n\n\t\tif ( half_hipped )\n\t\t{\n\t\t\td_block2_roof = opI( d_block2_roof, p.y );\n\t\t\td_block2_bottom = opI( d_block2_bottom, p.y );\n\t\t\td_block2_bottom2 = opI( d_block2_bottom2, p.y );\n\t\t}\n\t}\n\tDistanceId bb1 = MkDistanceId( d_block1_bottom, MATID_HOUSE );\n\tDistanceId bb2 = MkDistanceId( d_block2_bottom, MATID_HOUSE );\n\tif ( FARM_WINDOWS )\n\t{\n\t\taddWindow( bb1, p2xface( p, vec2( hs1_in.x, 0.0 ) ), 1., hs1_in.y );\n\t\taddWindow( bb1, p2yface( p, vec2( 0, hs1_in.y ) ), 0., hs1_in.x );\n\t\taddWindow( bb2, p2yface( p, vec2( 0, hs2_in.y ) ), 0., hs2_in.x );\n\t}\n\tDistanceId roof_eval = MkDistanceId( opI( h - p.z, opU( d_block1_roof, d_block2_roof ) ), MATID_ROOF );\n\tDistanceId bottom_eval = MkDistanceId( d_chimney, MATID_HOUSE );\n\tbottom_eval = opUdi( bottom_eval, bb1 );\n\tbottom_eval = opUdi( bottom_eval, bb2 );\n\tDistanceId bottom2_eval = MkDistanceId( opU( d_block1_bottom2, d_block2_bottom2 ), MATID_HOUSE_BOTTOM );\n\treturn opUdi( opUdi( roof_eval, bottom_eval ), bottom2_eval );\n}\n\nDistanceId sdGridObj_Farm( DistanceId di\n\t\t\t\t\t\t   , vec3 p\n\t\t\t\t\t\t   , CellPoint cr\n\t\t\t\t\t\t   , float radius_fraction\n\t\t\t\t\t\t   , float patch_id\n\t\t\t\t\t\t   , inout vec3 color\n\t\t\t\t\t\t   , SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, bool taylor_expansion_height )\n{\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\t\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; // CULL\n#if 0\n\tif ( HasDirection( scenein.trace_flags ) \n\t\t && ( sphere_trace( mkray( scenein.p, scenein.v ), r, vec3( c, cz ) ).x == FLT_MAX ) )\n\t{\n\t\treturn di;\n\t}\n#endif\n\t// orient farm along terrain gradient to reduce sinking cases\n\tvec2 e = vec2( 1e-3, 0 );\n\tvec2 h_gradval_at_c = ( vec2( BaseGroundHeight( c.xy + e.xy ),\n\t\t\t\t\t\t\t\t  BaseGroundHeight( c.xy + e.yx ) ) - vec2( cz ) ) / e.x; // be careful to not divide by e since it has zero in .y\n\t\n\tfloat grad_len = length( h_gradval_at_c );\n\n\t#define FARMS_GRAD_LIMIT   _1 // don't place farms when slope is too strong\n\t#define FARMS_GRAD_ELEVATE _1 // elevate house so they don't sink into the ground, using the gradient\n\t#define FARMS_GRAD_ALIGN   _1 // align farm with terrain gradient instead of random rotation\n\n\tif ( FARMS_GRAD_LIMIT && ( grad_len > 0.17 ) ) return di;\n\tif ( FARMS_GRAD_ELEVATE ) cz += r * grad_len * 0.65;\n\n\t// move to local coords\n\tp.xy -= c;\n\tp.z -= cz;\n\t\n\tp.xy = rotate_with_unit_vector( p.xy, FARMS_GRAD_ALIGN && ( grad_len > 0.01 )\n\t\t\t\t\t\t\t\t\t? normalize( h_gradval_at_c ) \n\t\t\t\t\t\t\t\t\t: unit_vector2( hash1u2_4tXyWN( uvec2(cr._pi) ) * 2.0 * PI ) ); // random rotation\n\n\tif ( _0 ) return MkDistanceId( sd_sphere( p, vec3( 0 ), r ), MATID_HOUSE ); // try make the building fit inside the sphere\n\n\tDistanceId eval = sdFarm( p, cr,patch_id, r, 1.0 );\n\t\n\tif ( IsShadeTrace( scenein.trace_flags ) && ( DecodeId( eval ) == MATID_ROOF ) )\n\t{\n\t\teval = MkDistanceId_16( eval.d, MATID_ROOF, hash11( patch_id ) ); // same roof color for all houses in patch\n\t}\n\n\treturn eval;\n}\n\nfloat sdBrickWall( vec3 p, ClosestPath path, float h )\n{\n\tfloat wall_start_dist = LANEWIDTH * 0.5 + 0.005;\n\tfloat wall_thickness = 0.018;\n\tfloat wall_height = 0.05;\n\tfloat wall_radius = 0.008;\n\tfloat d = FLT_MAX;\n\tfor ( float k = 0.0; k < 2.0; k += 1.0 )\n\t{\n\t\tvec3 pl = p; // p local\n\t\tpl.xy = GetLocalCurvePoint( path );\n\t\tpl.y -= wall_start_dist + wall_thickness * 0.5;\n\t\tpl.z -= h;\n\t\tvec3 s = vec3( 0.01, 0.006, 0.006 );\n\t\tfloat spacing = 0.0015;\n\t\tvec3 c;\n\t\tc.xz = vec2( s.x + spacing, 2.0 * s.z + spacing );\n\t\tc.y = s.y + spacing;\n\t\tvec2 offset = -0.5 * c.xz;\n\t\tfloat o = 0.5 * k;\n\t\toffset.xy += o * c.xz;\n\t\tvec2 i;\n\t\ti = floor( ( pl.xz - offset ) / c.xz );\n\t\ti.y = min( i.y, 2.0 );\n\t\tpl.xz -= i * c.xz;\n\t\tpl.xz -= o * c.xz;\n\t\tfloat r = 0.002;\n\t\td = opU( d, sd_bounds_range_round( pl, -s * 0.5, s * 0.5, r ) );\n\t}\n\tif ( _1 ) d -= 0.003 * sfbm2_13( p * 80.0 );\n\treturn d;\n}\n\nfloat sdGrass( vec3 p, float h ) { return p.z - h; }\n\n// scene eval output\nstruct SceneOut\n{\n\tDistanceId object_di;\n\tfloat d_ghost; // can we optimize that and have less of those?\n\tfloat base_height; // base ground height\n\tClosestPath path;\n\tClosestPath test2d; // for 2d view mode\n\tvec3 color; // special color case for bushes (when id_fraction is not enough)\n#ifdef TERRAIN_WARP\n\t// this cuts bush evals massively\n\tfloat terrain_warp; // todo: move out of this struct, this is not part of returned information\n#endif\n};\n\nvoid SceneOutInit( inout SceneOut eval ) { eval.d_ghost = FLT_MAX; }\n\nvec3 get_bush_palette( vec2 uv )\n{\n\treturn mix( mix( mix( COLOR_BUSH1, COLOR_BUSH2, uv.x ), mix( COLOR_BUSH3, COLOR_BUSH4, uv.x ), uv.y )\n\t\t\t\t, COLOR_BUSH5, smoothband( uv.x, 0.49, 0.51, 0.01 ) );\n}\n\nbool is_white_cell( vec2 p_index ) { return ( int( p_index.x + p_index.y ) & 1 ) == 1; }\n\nvoid consider_close_point_hi( inout float d, vec2 index, float r, inout vec4 color, vec3 p, float cellsize\n\t\t\t\t\t\t\t  , vec3 h_gradval, bool taylor_expansion_height, int trace_flags )\n{\n\tvec3 c;\n\tvec3 h = hash32( index );\n\tc.xy = ( index + h.xy ) * cellsize;\n\tc.z = CalcHeight( c.xy, p.xy, h_gradval, taylor_expansion_height ) + r * mix( -0.8, 1.3, h.z );\n\tfloat di = length( c - p ) - r;\n\td = min( d, di );\n\n\tif ( IsShadeTrace( trace_flags ) )\n\t{\n\t\tvec2 ch = hash22( index );\n\t\t// this is called only once in shade, knock yourself out\n\t\tfloat w = max( 1. - smoothstep( -r * 0.1, r * 0.25, di ), 1e-3 );\n\t\tcolor.xyz += get_bush_palette( ch ) * w;\n\t\tcolor.a += w;\n\t}\n}\n\nstruct CloseGridPointArgs { float cell_size, max_radius, radius_disparity; };\n\nstruct CloseGridPointArgsWithBand\n{\n\tCloseGridPointArgs args0;\n\tfloat band_start, band_end;\n\tbool taylor_expansion_height;\n};\n\n// 45 means we consider 4 or 5 neighbour (instead of 3x3) depending on whether we are on a white or a black cell (not perfect but covers lots of cases)\n// instead of giving the closest point this version does a little bit of extra calculation or each candidate for color blending on bushes\nfloat GetCloseGridPoints45( inout vec3 a_color, vec3 p, float cellsize, vec3 h_gradval, CloseGridPointArgsWithBand args, int trace_flags, int aFrame )\n{\n\tfloat r = args.args0.max_radius * 0.8;\n\tvec2 p_index = floor( p.xy * ( 1.0 / cellsize ) );\n\n\tfloat d = FLT_MAX;\n\tvec4 color = vec4( 0.0 );\n#if 0\n\t// the unrolled code path is faster on my current view (70ms->68ms) but shader compilation prefers the loop (-1s)\n\tif ( is_white_cell( p_index ) )\n\t{\n\t\t//white cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}\n\telse\n\t{\n\t\t//black cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2( -1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}\n#else\n\tvec2 offset = vec2( 0, 1 ); // white cells check 4 canonical axis neigbours\n\tif ( !is_white_cell( p_index ) )\n\t{\n\t\tconsider_close_point_hi( d, p_index, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags ); // this cell, only checked if black\n\t\toffset = vec2( 1, 1 ); // black cells check the 4 diagonal neighbours\n\t}\n\n\tfor ( int i = 0 FORCE_LOOP; i < 4; ++i )\n\t{\n\t\tconsider_close_point_hi( d, p_index + offset, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\toffset = perp( -offset ); // go to next neighbour by rotating +90\n\t}\n#endif\n\tif ( IsShadeTrace( trace_flags ) ) // skipping this test breaks the trees...\n\t\ta_color = color.xyz / color.a;\n\n\treturn d;\n}\n\n#define bush_max_radius 0.04\n// for bushes we do something symbolic looking, with a slight Hiroshi Nagai vibe \nvoid AddContributionBushes( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t\t, vec3 h_gradval, float groundz, vec3 patch_id_hash\n\t\t\t\t\t\t\t, bool is_forest_patch, float aTime, int aFrame )\n{\n\tvec3 p = scenein.p;\n\tbool has_bushes = patch_id_hash.x > 0.2;\n\tbool has_cut_bushes = SQUARE_BUSH_TEST && ( !is_forest_patch && patch_id_hash.x > 0.62 );\n\n\tfloat bush_cell_size = 0.095;\n\n\tfloat bush_d_min = p.z - ( groundz + bush_max_radius*1.9 ); // upper bound for distance to bushes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // multiply by 2 else lots of bushes get cut... \n\n\t// note: whether we use > or <= has resulted in big difference in the past sometimes\n\tif ( !has_bushes\n\t\t || ( bush_d_min > eval.object_di.d )\n#ifdef TERRAIN_WARP\n\t\t || (\n\t\t\t  ( eval.terrain_warp != 0.0 ) &&\n\t\t\t  ( bush_d_min > 0.0 ) &&\n\t\t\t  ( bush_d_min < eval.terrain_warp ) ) // we know we can roughly traverse by eval.terrain_warp before hitting next bush\n#endif\n\t\t) return;\n\n\tfloat d = FLT_MAX;\n\tfloat id_fraction = 0.0;\n\tfloat freq = 1.0;\n\n\tif ( has_cut_bushes )\n\t{\n\t\tfreq = DISPLACE_BUSH_FREQ;\n\t\t\n\t\t// patch section 2d point\n\t\tvec2 p_patch_section = vec2( eval.path.patch_di.d, p.z - eval.base_height );\n\t\tfloat d_square_bush = sd_bounds_range( p_patch_section, vec2( LANEWIDTH - 0.015, 0 ), vec2( LANEWIDTH + 0.02, 0.05 ) );\n\t\td = d_square_bush; // we distort so...\n\n\t\teval.color = COLOR_BUSH3;\n\t}\n\telse\n\t{\n\t\tfreq = DISPLACE_BUSH_FREQ;\n\n\t\t// this is a patch with bushes on the side\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = bush_cell_size;\n\t\targs.args0.max_radius = bush_max_radius;\n\t\targs.args0.radius_disparity = 0.4;\n\t\targs.band_start = LANEWIDTH * 0.5 + args.args0.max_radius * 0.5; // take a fraction of the radius so that some of the bushes overlap a bit with the path\n\t\targs.band_end = args.band_start + 0.18 + pow2( patch_id_hash.z ) * 0.3;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_BUSH;\n\n\t\td = GetCloseGridPoints45( eval.color, p, args.args0.cell_size * 0.5, h_gradval, args, scenein.trace_flags, aFrame );\n\n\t\tif ( SOFT_BLEND_BUSH ) d = opU_weld_quadric( p.z - eval.base_height, d, 0.027 );\n\n\t\t// clip bush vs path/walls (leak through walls is a happy accident)\n\t\tif ( _1 ) d = opS_soft2( d, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5, 100.0 );\n\n\t\tif ( _1 )\n\t\t{\n\t\t\t// fade bush inside patch\n\t\t\tfloat bf = ( sfbm1_12( p.xy * 18.0 ) - 0.5 ) * 0.33; // distort fade boundary\n\t\t\td = opS_soft2( d, args.band_end * ( 1. + bf ) - eval.path.patch_di.d, 30.0 );\n\t\t}\n\t}\n\n\tif ( DISPLACE_BUSH )\n\t{\n\t\tfloat dd = 0.0045; // need more displacement to see shadows...\n\n\t\tvec3 pd = p;\n\t\tif ( WIND_BUSH ) pd += ApplyWind( pd, aTime );\n\t\t\n\t\t // the test is < ..*3 because we INFLATE\n\t\tif ( d < dd * 3.0 ) d -= sfbm2_13( pd * vec3( 80.0, 80.0, 100 ) * freq ) * dd;\n\t}\n\n\teval.object_di = opUdi( eval.object_di, MkDistanceId_16( d, MATID_BUSH, id_fraction ) );\n}\n\n// return closest cell point with a radius, no neighbour, used by farms and trees\n// max_radius must be less than cell_size*0.5\n// radius_disparity percentage in 0,1\n// grid_offset in 0,1, conceptually...\nvoid GetClosestGridPoint( inout CellPoint point, vec2 p, CloseGridPointArgs args0, float grid_offset, float hoffset )\n{\n\tvec2 pi = floor( ( p - grid_offset ) / args0.cell_size );\n\tpoint._pi = ivec2( pi + vec2( hoffset ) );\n\tvec4 ph = hash42_( point._pi );\n//\tph.xy = vec2( 0.5 ); // debug\n\tpoint.pradius = args0.max_radius * ( 1.0 - args0.radius_disparity * ph.z );\n\tvec2 a = grid_offset + pi * args0.cell_size;\n\tvec2 b = a + vec2( args0.cell_size );\n\tpoint.p = mix( a + vec2( point.pradius ),\n\t\t\t\t   b - vec2( point.pradius ), ph.xy ); // important: +offset to put back in same space as p\n}\n\n// used by farms and trees\nbool GetClosestGridPointWithPathBand_x1( inout CellPoint point\n\t\t\t\t\t\t\t\t\t\t , vec2 p\n\t\t\t\t\t\t\t\t\t\t , vec3 h_gradval\n\t\t\t\t\t\t\t\t\t\t , CloseGridPointArgsWithBand args\n\t\t\t\t\t\t\t\t\t\t , float grid_offset, float hoffset )\n{\n\tGetClosestGridPoint( point, p, args.args0, grid_offset, hoffset );\n\n\t// we want to know if this point is within a band of the country patch we are currently in\n\tfloat distance_to_patch_border = abs( EvalClosestPath( point.p, true ).patch_di.d );\n\treturn ( distance_to_patch_border > args.band_start )\n\t\t&& ( distance_to_patch_border < args.band_end );\n}\n\nvoid SetSceneInDirection( inout SceneIn scenein, vec3 o, vec3 v, int trace_flags )\n{\n\tscenein.v = v;\n\tscenein.v_rcp = vec3( 1.0 ) / v;\n//\tscenein.o = o;\n\tscenein.trace_flags = trace_flags | TRACE_HAS_DIRECTION;\n\tscenein.t0 = 0.0;\n}\n\nvoid SetSceneInDirectionless( inout SceneIn scenein, int trace_flags )\n{\n\tscenein.v = vec3( 0.0 );\n\tscenein.v_rcp = vec3( 0.0 );\n//\tscenein.o = vec3( 0.0 );\n\tscenein.trace_flags = trace_flags;\n\tscenein.t0 = 0.0;\n}\n\nfloat ClampRayAgainstCurrentGridCell( vec3 p, vec3 v_rcp, vec3 cell_size, float cell_inflate_epsilon )\n{\n\t// we know the direction therefore we only have to test one side of each axis\n\tvec3 s = sign( v_rcp );\n\tvec3 amin = floor( p / cell_size ) * cell_size;\n\tamin -= vec3( cell_inflate_epsilon ); // instead of adding that to d_ghost we clamp to cell_size + cell_inflate_epsilon\n\tvec3 a = amin + ( ( s + 1.0 ) * 0.5 ) * ( cell_size + 2.0 * vec3( cell_inflate_epsilon ) );\n\tvec3 t = ( a - p ) * v_rcp; // ray vs all closest box planes\n//\tt += FLT_MAX * ( 1.0 - abs( s ) ); // when sign is zero, push next hit at t=+infinite, v_rcp has been set to zero in that case\n\treturn min( min( t.x, t.y ), t.z ); // should be > 0 by construction\n}\n\nbool CanGhostStep( SceneIn scenein, float maxdist_from_t0, float maxdist_abs )\n{\n\treturn HasDirection( scenein.trace_flags )\n\t\t&& ( scenein.t < maxdist_abs ) // GHOST_MAX_DIST_ABS\n\t\t&& ( ( scenein.t - scenein.t0 ) < maxdist_from_t0 ); // GHOST_MAX_DIST_FROM_T0\n}\n\nvoid GhostGridSteps( inout SceneOut eval, SceneIn scenein, float cell_size, float cell_inflate_epsilon )\n{\n\tfloat dm = ClampRayAgainstCurrentGridCell( scenein.p, scenein.v_rcp\n\t\t\t\t\t\t\t\t\t\t\t   , vec3( cell_size, cell_size, 20.0 ), cell_inflate_epsilon );\n\t// note that this doesn't deal with diagonals which might cross another cell\n\teval.d_ghost = min( eval.d_ghost, max( dm, GHOST_EPS ) );\n}\n\n// used by farms and trees\n#define SD_OBJECT_CONTRIB( _di_, _object_sd_func_, _grid_offset_, _hoffset_ ) {\\\n\tCellPoint _cp_; \\\n\tif ( GetClosestGridPointWithPathBand_x1( _cp_, p.xy, h_gradval, args, _grid_offset_, _hoffset_ ) )\\\n\t\t_di_.object_di = _object_sd_func_( _di_.object_di, p, _cp_, radius_fraction, _di_.path.patch_di.id, eval.color, scenein, h_gradval, args.taylor_expansion_height );\\\n}\n\nvoid AddContributionTrees( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, float groundz, vec3 patch_id_hash, int aFrame, float aTime )\n{\n\tvec3 p = scenein.p;\n\tfloat tree_max_radius = 0.15;\n\n\tCloseGridPointArgsWithBand args;\n\targs.args0.cell_size = 0.4;\n\targs.args0.max_radius = tree_max_radius;\n\targs.args0.radius_disparity = 0.1;\n\targs.band_start = args.args0.max_radius;\n\t// some patches are filled with trees, some other patches only have trees on the border\n#if 1\n\targs.band_end = patch_id_hash.x > 0.9 ? FLT_MAX : args.args0.max_radius * 3.0;\n#else\n\targs.band_end = FLT_MAX;\n#endif\n\targs.taylor_expansion_height = TAYLOR_HEIGHT_TREE;\n\n\tfloat grid_offset_step = 0.25; // this is wrong actually but creates a certain sparsity that is welcome\n\tvec3 grid_offsets = vec3( 0., 1.0, 2.0 ) * grid_offset_step * args.args0.cell_size;\n\tfloat radius_fraction = 1.0;\n#if 0\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.x, 000.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.y, 100.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.z, 200.0 );\n#else\n\t// this might be a bit faster (92->71!), also shadertoy compile time\n\tfor ( float f = 0.0 FORCE_LOOPF; f < 3.0; f += 1.0 )\n\t{\n\t\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offset_step * args.args0.cell_size * f, 100.0 * f );\n\t}\n#endif\n\n\tfloat mat_id = DecodeId( eval.object_di );\n\t// displace all the trees at once...\n\tif ( DISPLACE_TREE && ( ( mat_id == MATID_TREE ) || ( mat_id == MATID_PINE ) ) )\n\t{\n\t\tvec3 pd = p;\n\t\tif ( WIND_TREE_AND_PINES ) pd += ApplyWind( pd, aTime );\n\n\t\tfloat is_pine = ( mat_id == MATID_PINE ) ? 1. : 0.;\n\t\t\n\t\tpd.z *= mix(1.,0.75,is_pine);\n\t\t\n\t\teval.object_di.d += sfbm2_13_leaf( pd * 80.0 * 2.2 ) * TREE_SDD * mix( 1., 0.4, is_pine ) * 0.8;\n\t}\n\n\tif ( GHOST_STEPS_TREE && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t{\n\t\t// note: offset zero for all + smallest cell size fraction multiple should yield same result\n\t\tfloat cell_inflate_epsilon = 0.004; // tree\n\t\tGhostGridSteps( eval, scenein, grid_offset_step * args.args0.cell_size, cell_inflate_epsilon );\n\t}\n}\n\nvoid AddContributionFarms( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, float groundz, vec3 patch_id_hash\n\t\t\t\t\t\t   , float closest_path_middle_point_height )\n{\n\tvec3 p = scenein.p;\n\tbool is_farm_patch = patch_id_hash.x > 0.2;\n\n\tif ( !is_farm_patch ) return;\n\n\tif ( FARM )\n\t{\n\t\t// farms are sparse so use 1 cell\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = 1.2;\n\t\targs.args0.max_radius = 0.35;\n\t\targs.args0.radius_disparity = 0.3;\n\t\targs.band_start = args.args0.max_radius * 1.5;\n\t\targs.band_end = FLT_MAX;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_FARM;\n\t\tfloat radius_fraction = 0.8;\n\t\tSD_OBJECT_CONTRIB( eval, sdGridObj_Farm, 0.0, 0.0 );\n\t\tif ( GHOST_STEPS_FARM && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t\t{\n\t\t\tfloat cell_inflate_epsilon = 0.004;\n\t\t\tGhostGridSteps( eval, scenein, args.args0.cell_size, cell_inflate_epsilon );\n\t\t}\n\t}\n\n\tif ( BRICKWALL && patch_id_hash.y > 0.7 ) // note: not all farm patch have a visible house on them...\n\t{\n\t\tDistanceId walls = MkDistanceId( sdBrickWall( p, eval.path, eval.base_height ), MATID_BRICKWALL );\n\t\teval.object_di = opUdi( eval.object_di, walls );\n\t}\n}\n\nvoid AddContributionGrass( inout SceneOut eval, vec3 p, float groundz, vec3 patch_id_hash )\n{\n\tfloat grass_height = ( groundz - 0.01 ) // make sure grass doesn't cover the path ground\n\t\t+ smoothstep( -0.02, 0.04, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5 ) * 0.0195;\n\tDistanceId grass = MkDistanceId_16( sdGrass( p, grass_height ), MATID_GRASS, patch_id_hash.z ); // each patch has slightly different colors\n\teval.object_di = opUdi( eval.object_di, grass );\n}\n\nvoid AddContributionPath( inout SceneOut eval, SceneIn scenein, float groundz )\n{\n\tvec3 p = scenein.p;\n\tfloat path_d_min = p.z - groundz;\n\n\tif ( !( path_d_min < eval.object_di.d ) ) return; // weird compiler horror happened depending how we write the if branch here\n\n\t// path is the most occluded thing so do it last\n\tDistanceId path_di = MkDistanceId_16( path_d_min // lower bound for bushes\n\t\t\t\t\t\t\t\t\t   , MATID_GROUND, ( 1.0 - smoothstep( 0.0, 0.05, eval.path.patch_di.d ) ) );\n\tif ( DISPLACE_PATH )\n\t{\n\t\t// this displacement is expensive, cull as much as we can, maybe we could just do that in shade\n\t\tfloat path_blend = 1.0 - smoothstep( 0.001, 0.008, eval.path.patch_di.d - LANEWIDTH * 0.5 );\n\t\tfloat distance_blend = 1.0 - smoothstep( 6.0, 7.0, scenein.t );\n\t\tfloat fade = path_blend * distance_blend;\n\t\tif ( fade > 0.0 ) // that cuts a bit\n\t\t{\n\t\t\t// so we can scale along road direction\n\t\t\tpath_di.d += fade * sfbm2_12( GetLocalCurvePoint( eval.path ) * vec2( 1, 2 ) * 80.0 ) * DISPLACE_PATH_AMPL;\n\t\t}\n\t}\n\n\teval.object_di = opUdi( eval.object_di, path_di );\n}\n\nSceneOut evalScene( SceneIn scenein, int aFrame, float aTime)\n{\n\tvec3 p = scenein.p;\n\n\tSceneOut eval;\n\tSceneOutInit( eval );\n\t\n\tfloat groundz = BaseGroundHeight( p.xy );\n\teval.base_height = groundz;\n\teval.path = EvalClosestPath( p.xy, false );\n\tvec3 h_gradval = vec3( 0.0, 0.0, groundz );\n\n#ifdef TERRAIN_WARP\n\tvec3 ground_normal;\n#endif\n\n\tif (\n#ifdef TERRAIN_WARP\n\t\t _1 ||\n#endif\n\t\t // any of those need the height gradient at p\n\t\t TAYLOR_HEIGHT_BUSH ||\n\t\t TAYLOR_HEIGHT_TREE ||\n\t\t TAYLOR_HEIGHT_FARM )\n\t{\n\t\tvec2 e = vec2( 1e-3, 0 );\n\t\tfloat hx = BaseGroundHeight( p.xy + e.xy );\n\t\tfloat hy = BaseGroundHeight( p.xy + e.yx );\n\t\th_gradval.xy = vec2( hx - eval.base_height,\n\t\t\t\t\t\t\t hy - eval.base_height ) / e.x; // be careful to not divide by e since it has zero in .y\n#ifdef TERRAIN_WARP\n\t\tvec3 px = vec3( p.xy + e.xy, hx );\n\t\tvec3 py = vec3( p.xy + e.yx, hy );\n\t\tvec3 pc = vec3( p.xy, eval.base_height );\n\t\tground_normal = normalize( cross( px - pc, py - pc ) );\n#endif\n\t}\n\n#ifdef TERRAIN_WARP\n\teval.terrain_warp = 0.0;\n\tif ( HasDirection( scenein.trace_flags ) )\n\t{\n\t\tfloat large_optimistic_step = 3.0;\n\t\tvec3 base = vec3( p.xy, eval.base_height + bush_max_radius*2.5 );\n\t\tRay warp_ray;\n\t\twarp_ray.o = scenein.p;\n\t\twarp_ray.d = scenein.v;\n\t\tfloat t2 = plane_trace( warp_ray, base, ground_normal, 1e-3 );\n\t\tif ( t2 > 0.0 )\n\t\t{\n//\t\t\tif ( dot( ground_normal, scenein.v ) < 0 ) // if terrain is convex at ground_normal in trace direction?\n\t\t\t\teval.terrain_warp = min( t2, large_optimistic_step );\n\t\t}\n\t}\n#endif\n\n\t// eval.path.patch_di.id is the patch id\n\t// eval.path.patch_di.d is the distance to closest path\n\t//\n\t// the path we walk on is flat so we need the height of center of the road\n\tvec2 closest_patch_border_point2 = p.xy + eval.path.v2closest; // center of road\n\tfloat closest_path_middle_point_height = BaseGroundHeight( closest_patch_border_point2 ); // fences use\n\n\teval.test2d = eval.path;\n\n\t// upper bound for distance to ground, take into account displacement that might dig a little on paths\n\tfloat d_ground_max = p.z - ( eval.base_height - DISPLACE_PATH_AMPL * 2.0 );\n#if 0\n\t// bogus build error on ? : in shadertoy\n\teval.object_di = GROUND_OCCLUSION // occlusion helps\n\t\t? MkDistanceId( d_ground_max, MATID_GROUND )\n\t\t: MkDistanceId( FLT_MAX, MATID_NONE ); // enable PATH to get a ground\n#else\n\tif ( GROUND_OCCLUSION ) eval.object_di = MkDistanceId( d_ground_max, MATID_GROUND ); // occlusion helps\n\telse eval.object_di = MkDistanceId( FLT_MAX, MATID_NONE ); // enable PATH to get a ground\n#endif\n\t// hit the patch boundary tangent plane, this has 2 properties we want:\n\t//  1- the closer we are to the boundary the more this approximates the hit point, sort of\n\t//  2- if ray leaches the patch boundary, the hit point will be far away\n\t//      -> that second one improves significantly the horrible artifact where we run out of points...\n\t//  also ignore far away hits for perfs   \n\t\n\t// todo: we don't need ghost steps if we are far above the ground! we can save a bit\n\n\tif ( GHOST_STEPS_PATCH && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t{\n\t\tvec3 base = vec3( p.xy + eval.path.v2closest, p.z );\n\t\tvec3 normal = normalize( -vec3( eval.path.v2closest, 0 ) );\n\t\tfloat t2 = plane_trace( p, scenein.v, base, normal, 1e-3 );\n\t\tif ( t2 > 0.0 ) eval.d_ghost = min( eval.d_ghost, max( t2, GHOST_EPS ) );\n\t}\n\n//\tvec3 patch_id_hash = hash31( eval.path.patch_di.id );\n\tvec3 patch_id_hash = hash42_( ivec2( int( eval.path.patch_di.id ) ) ).xyz; // paranoid use of ints for important structural elements\n\n\tbool is_forest_patch = patch_id_hash.x > 0.65;\n\n\tif ( is_forest_patch )\n\t{\n\t\tif ( TREE ) AddContributionTrees( eval, scenein, h_gradval, groundz, patch_id_hash, aFrame, aTime );\n\t}\n\telse AddContributionFarms( eval, scenein, h_gradval, groundz, patch_id_hash, closest_path_middle_point_height );\n\n\tif ( BUSH ) AddContributionBushes( eval, scenein, h_gradval, groundz, patch_id_hash, is_forest_patch, aTime, aFrame );\n\tif ( GRASS ) AddContributionGrass( eval, p, groundz, patch_id_hash );\n\tif ( PATH ) AddContributionPath( eval, scenein, groundz );\n\n\treturn eval;\n}\n\nstruct TraceOutput\n{\n\tfloat t;\n\tfloat dist; // distance to surface (error)\n\tfloat shadow; // sun/main light occlusion\n};\n\n#define MAX_ITERATIONS_VIEW 120\n#define MAX_ITERATIONS_SHADOW 40 // set this as small as you can with your lighting setting, even if shadow ray escape to sky quickly this results in big win\n#define TMAX_VIEW 80.0 // was 200 before\n#define TMAX_SHADOW 40.0 // reducing this doesn't help much\n#define TFRAC 0.8\n#define DBREAK 0.0025 // tweak for perfs!!! depends on scene scale etc might make small features thicker than they actually are\n\nTraceOutput traceScene( Ray ray, float shadow_sharpness, int trace_flags\n\t\t\t\t\t\t, int max_iterations, float tfrac, float tmaxmax, float dbreak, vec2 uv, vec2 fragCoord, int aFrame, float aTime )\n{\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n\tfloat tmax = tmaxmax; // default to absolute max\n\n\t{\n\t\t// clamp traced segment\n\t\tfloat hmax = MAX_TERRAIN_HEIGHT + TALLEST_OBJECT_HEIGHT; // there must be nothing above this height\n\t\tfloat thit = plane_trace_z( ray, hmax, 1e-4 );\n\t\tif ( thit > 0.0 )\n\t\t{\n\t\t\tif ( ray.o.z > hmax ) to.t = thit; // above hmax looking down\n\t\t\telse tmax = min( thit, tmaxmax ); // below hmax looking up, clamp at hmax\n\t\t}\n\t\telse if ( ray.o.z > hmax )\n\t\t{\n\t\t\tto.t = tmaxmax * 1.1; // above hmax looking up, there is only sky\n//\t\t\treturn to; // don't branch here, that might be actually slower\n\t\t}\n\t}\n\n\tSceneIn scenein;\n\tSetSceneInDirection( scenein, ray.o, ray.d, trace_flags );\n\tscenein.t0 = to.t;\n\t\n\tfor ( int i = 0 FORCE_LOOP; i < max_iterations; ++i )\n\t{\n\t\tscenein.p = ray.o + to.t * ray.d;\n\t\tscenein.t = to.t;\n\t\tSceneOut eval = evalScene( scenein, aFrame, aTime );\n\t\tfloat d = min( eval.object_di.d, eval.d_ghost );\n\t\t// note: ghost points might make us jump over solid tfrac points\n\t\tfloat is_ghost_step = ( d == eval.d_ghost ? 1.0 : 0.0 );\n\t\tto.dist = d;\n\n\t\t// important: do not move this block after the to.dist check!\n\t\tif ( IsShadowTrace( trace_flags )\n\t\t\t//&& ( is_ghost_step == 0.0 ) // creates ugly discontinuities\n\t\t\t)\n\t\t{\n\t\t\t// note: if eval.object_di.d < 0 we set shadow to 0 in effect\n\t\t\t// that catches the case where first point is inside an object (because shadow ray offset issues, ex: bush vs ground normal discontinuity)\n\t\t\t// for regular case if distance is neg it means we hit an object and so shadow = 0 too anyway\n\t\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf for shadows\n\t\t\tto.shadow = min( to.shadow, shadow_sharpness * max( eval.object_di.d, 0.0 ) / ( to.t + 1e-4f ) );\n\t\t\t\n\t\t\tif ( to.shadow <= 0.01 ) break;\n\t\t}\n\n\t\t// warning: never stop on a ghost step!!\n\t\tif ( ( ( is_ghost_step == 0.0 ) && ( to.dist <= dbreak * to.t ) )\n\t\t\t || ( to.t > tmax ) ) break;\n\n\t\t// the amount by which we advance t: drop tfrac on ghost steps\n\t\tfloat dt = to.dist * mix( tfrac, 1.0, is_ghost_step );\n\n\t\tto.t += dt;\n\t}\n\n\tif ( to.t > tmax ) to.t = tmaxmax * 1.1;\n\n\treturn to;\n}\n\n#ifdef SHADERTOY_STANDALONE\n#define TIME_OF_DAY iSlider0\n#else\n#define TIME_OF_DAY 0.56\n#endif\n\nvec3 get_sun_direction(float aTime)\n{\n\tfloat sun_elevation = radians( mix( -30.0, 90.0, TIME_OF_DAY ) ); // careful with z, long shadows make the tracing slower\n\treturn zup_spherical_coords_to_vector( unit_vector2( PI * 0.5 - sun_elevation )\n\t\t\t\t\t\t\t\t\t\t\t , _1 ? V45 : unit_vector2( 2.0 * PI * aTime / 3.0 ) );\n}\n\n#define cloud_re 3000.0\n#define cloud_r1 ((cloud_re)+8.0)\n#define cloud_r2 ((cloud_r1)+1.8)\n#define fake_earth_center vec3(0,0,-cloud_re)\n\nfloat cloudDensity( vec3 p )\n{\n\tfloat sparsity = 0.07; // 0,1.x\n\tfloat freq = 0.2;\n\tfloat d = efbm4_13( p * freq, 1.0 + sparsity );\n\tfloat r = length( p - fake_earth_center );\n\tfloat r2 = length( p.xy );\n\tfloat c = smoothstep( 3., 5., r2 ); // cleanup singularity at north pole a little bit\n\td *= smoothstep( 0.4, 0.6, d * c ); // multiply d by c give best fade out\n\td = max( d, 0. );\n\td *= smoothstep( cloud_r1, cloud_r1 + 0.1, r )\n\t\t* ( 1.0 - smoothstep( cloud_r2 - 0.1, cloud_r2, r ) ); // altitude band\n\treturn d;\n}\n\n// make some ultra basic clouds out of thin air, we will bake them in a spheremap\nvec3 traceClouds( vec3 n, float aTime )\n{\n\tvec3 sun_direction = get_sun_direction(aTime);\n\tRay ray = mkray( vec3( 0.0 ), n );\n\tvec2 vt1 = sphere_trace( ray, cloud_r1, fake_earth_center );\n\tvec2 vt2 = sphere_trace( ray, cloud_r2, fake_earth_center );\n\t//return vec4( vec3( 0.1*( t2.y - t1.y ) / ( r2 - r1 ) ), 0 );\n//\tfloat li = 1.0;\n\tfloat vlen = ( vt2.y - vt1.y );\n\tfloat vdt = vlen / 100.0;\n\tfloat vt = vt1.y;\n\tfloat vod = 0.0;\n\tfloat vod2 = 0.0;\n\tfloat c = 0.8;\n\t// view ray\n\tfor ( ; vt < vt2.y ; vt += vdt )\n\t{\n\t\tvec3 p = ray.o + ray.d * vt;\n\t\tfloat pd = cloudDensity( p );\n\t\t{\n\t\t\t// sun ray\n\t\t\tRay lray = mkray( p, sun_direction );\n\t\t\tvec2 lt2 = sphere_trace( lray, cloud_r2, fake_earth_center );\n\t\t\tfloat llen = lt2.y;\n\t\t\tfloat ldt = llen / 5.0;\n\t\t\tfloat lt = ldt;\n\t\t\tfloat lod = 0.0;\n\t\t\tfor (; lt < llen; lt += ldt )\n\t\t\t{\n\t\t\t\tvec3 lp = lray.o + lray.d * lt;\n\t\t\t\tfloat lpd = cloudDensity( p );\n\t\t\t\tlod += vdt * lpd * c * 10.0;\n\t\t\t}\n\t\t\tvod2 += vdt * pd * exp( -lod -vod ); // inscatter\n\t\t}\n\t\tvod += vdt * pd * c; // absorption\n\t}\n\n\t// for compositing we do something like exp( -vod ) * distant_sky_color + vod2\n\treturn vec3( saturate(vod2), exp( -vod ), 0 );\n\t\n#define cloud_lowest_absorption_remap 0.6\n\t\n}\n\n// map theta to uv .5 r, we only keep the [0,PI/2] theta range\n#if 0\nfloat theta2r05( float theta ) { return theta *(1.0/PI) ; }\nfloat r052theta( float r ) { return r * PI; }\n#else\n// give more resolution to the horizon\nfloat theta2r05( float theta ) { return pow(saturate(theta*(1.0/(PI*0.5))),2.0) *0.5; }\nfloat r052theta( float r ) { return pow((r*2.0),0.5) *PI*0.5; }\n#endif\n\nvec3 get_cloud( vec3 v, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 cloud = vec3(0.0);\n#if BUFFER_MODE==2\n\tif ( CLOUD_MODE>0 )\n\t{\n\t\tvec2 sc = vector_to_zup_spherical_coords( v );\n\t\tif ( sc.x > PI * 0.5 ) return BLUE;\n\t\tvec2 uv = vec2( 0.5 ) + unit_vector2( sc.y ) * theta2r05( sc.x );\n\t\tuv.x *= aResolution.y / aResolution.x;\n\t\tcloud = CLOUD_MODE==1\n\t\t\t? traceClouds( v, aTime )\n\t\t\t: texture( aChannel1, uv ).xyz; // return the highres one here for debug, should match with sampled one\n\t}\n#endif\t\n\treturn cloud; // debug\n}\n\nfloat sFlarePeak( vec2 p, float da, float a, float a_offset )\n{\n\ta += a_offset;\n\ta = floor( ( a / da ) + 0.5 ) * da;\n\tvec2 vv = unit_vector2( a - a_offset );\n\treturn abs( dot( p, perp( vv ) ) );\n}\n\nvec4 sunGlareCoords( mat4 cam, vec3 v, vec3 l )\n{\n\tvec3 sy = normalize( cross( cam[0].xyz, l ) );\n\tvec3 sx = normalize( cross( l, sy ) );\n\treturn vec4( normalize( vec2( dot( v, sx ), dot( v, sy ) ) ), dot( v, l ), -cam[2].z );\n}\n\nvec3 sunGlare( vec4 ppd // xy: angle as unit vector z: dot(v,l)\n\t\t\t   , float solid_sun_disk_radius\n\t\t\t   , float ray_length // higher value = shorter length\n\t\t\t   , float ray_thickness\n\t\t\t   , float ray_thickness_disparity\n\t\t\t   , float n1 // can be arbitrarily large\n\t\t\t   , float n2 // there is a loop on n2 - the number of rays is n1*n2 so we have a trade off between the repeat in sFlarePeak (which can't do proper additive on rays) and the for loop (which can)\n\t\t\t   , float falloff_glare_attn\n\t\t\t   , float falloff_glare_p1\n\t\t\t   , float falloff_glare_p2\n\t\t\t   , bool falloff_glare_multiplicative )\n{\n\tvec2 anglev = ppd.xy; // angle as unit vector\n\tfloat v_dot_l = ppd.z;\n\tfloat r = safe_acos( v_dot_l ) / PI; // could do without acos but it is a lot more easier to work with regular spacing\n\tvec2 p = anglev * r;\n\tfloat a = calc_angle( anglev );\n//\treturn vec3( stripes(r,0.02,0.001,0.001/2.0), stripes(degrees(a),10.,0.1,0.1/2.0),0.); // visualize polarcoords\n\tfloat v = 0.0;\n\tfloat d2 = max( r - solid_sun_disk_radius, 0. ); // falloff glare\n\tfloat da = 2.0 * PI / n1;\n\tfloat da2 = 2.0 * PI / ( n1 + n2 );\n\tfor ( float i = 0.; i < n2; ++i )\n\t{\n\t\tvec3 rr = hash31( i + 1. );\n\t\tfloat rda = rr.x * da2 * 0.1;\n\t\tfloat d1 = sFlarePeak( p, da, a, -i * da / n2 + rda );\n\t\tif ( r < solid_sun_disk_radius ) d1 = 0.;\n\t\tv += exp2( -d1 * d1 * ray_thickness * mix( 1.0-ray_thickness_disparity, 1.+ray_thickness_disparity, rr.y )\n\t\t\t\t   -d2 * ray_length * mix( 0.5, 1.5, rr.z ) );\n\t}\n\tfloat falloff_glare = falloff_glare_attn * ( 1.0 - powerful_scurve( d2, falloff_glare_p1, falloff_glare_p2 ) );\n\tv = falloff_glare_multiplicative ? v * falloff_glare : v + falloff_glare;\n\tv = min( v, 1. );\n\treturn vec3( v );\n}\n\n#define FOG_GROUND _1\n\n // set render to false for getting a value for lighting calculation as opposed to display\nvec3 get_top_sky_color( bool render ) {  return AZURE * ( render ? 0.6 : 1.0 ); }\nvec3 get_sky_horizon_color() { return mix( WHITE, AZURE, 0.4 ); }\nvec3 get_fog_color() { return mix( AZURE, WHITE, 0.15 ); }\n\n// return a v.z normalized so that horizon view direction is remapped to 0 and zenith is still 1\nfloat get_hacked_vz( vec3 v, float ez )\n{\n\tfloat zmin = -max(ez,0.)/(TMAX_VIEW*1.1); // z/f=zmin/1. where f=TMAX_VIEW*1.1\n\treturn max(0.,(v.z-zmin)/(1.-zmin));\n}\n\nvec3 get_sky( vec3 v, vec3 l, float ez, bool render )\n{\t\n\tfloat hz = get_hacked_vz( v, ez );\n\treturn mix( get_sky_horizon_color(), get_top_sky_color(render), pow( hz, 0.2 ));\n}\n\nvec3 get_sky_plus_clouds( vec3 v, vec3 l, float ez, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 col = get_sky( v, l, ez, true );\n\tvec3 cloud = get_cloud( v, aChannel1, aResolution, aTime  );\n\tvec3 sky_with_clouds =  col * mix( cloud_lowest_absorption_remap, 1., cloud.y ) + vec3( cloud.x ); // composite clouds, col * absorption + scattering\n\treturn mix( col, sky_with_clouds, smoothstep( 0., 0.025, v.z ) ); // fade to sky on thin horizon band\n}\n\n// e = eye pos, v = view vector, p = lit point, n = normal, l = sun direction\nvec3 shadeSample( in vec3 e, in vec3 v, mat4 cam, in vec3 p, in vec3 n, vec3 l\n\t\t\t\t  , float shadow, TraceOutput to, float ao, vec2 uv\n\t\t\t\t  , SceneOut eval, bool sky, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 col = vec3( 0. );\n\t\n\tvec3 sunI = vec3( 2.0 );\n\n\tvec3 top_sky_color = get_sky(vec3(0,0,1),l,e.z,false);\n\n\tSG sun_lobe = CosineLobeSG( l );\n\tsun_lobe.Amplitude *= sunI;\n\n\tSG sky_lobe = CosineLobeSG( vec3( 0, 0, 1 ) );\n\tsky_lobe.Amplitude *= top_sky_color;\n\n\tif ( !sky )\n\t{\n\t\tvec3 scene_color = vec3( 0 );\n\t\n\t\tfloat bush_factor = 0.0;\n\t\tfloat tree_factor = 0.0;\n\t\tfloat pine_factor = 0.0;\n\t\tvec3 sky_reflection = vec3(0,0,0);\n\t\t\n\t\tvec2 mm = DecodeId_16( eval.object_di );\n\t\tfloat matid = mm.x;\n\t\tfloat matid_f = mm.y; // we can have color variations within an id\n\n\t\tbush_factor = smoothbump( MATID_BUSH, 0.5, matid );\n\t\ttree_factor = smoothbump( MATID_TREE, 0.5, matid );\n\t\tpine_factor = smoothbump( MATID_PINE, 0.5, matid );\n\t\tvec4 mm4 = DecodeId_5_5_5( eval.object_di ); // yzw = depth uheight color_rnd\n\t\tfloat tree_ao = mix( 0.6, 1., smoothstep( 0., 0.5, mm4.z ) ); // make it very faint, doesn't fit the style\n\n\t\tscene_color = vec3( 0 )\n\t\t\t+ bush_factor * eval.color\n\t\t\t+ tree_factor * mix( mix( COLOR_TREE1, COLOR_TREE2, mm4.w ), COLOR_TREE_SURF, 0.0*mm4.y*mm4.y*mm4.y ) * tree_ao\n\t\t\t+ smoothbump( MATID_TRUNK, 0.5, matid ) * COLOR_TRUNK\n\t\t\t+ smoothbump( MATID_HOUSE, 0.5, matid ) * COLOR_HOUSE\n\t\t\t+ smoothbump( MATID_HOUSE_BOTTOM, 0.5, matid ) * COLOR_HOUSE_BOTTOM\n\t\t\t+ smoothbump( MATID_ROOF, 0.5, matid ) * mix( COLOR_ROOF1, COLOR_ROOF2, matid_f )\n\t\t\t+ smoothbump( MATID_BRICKWALL, 0.5, matid ) * COLOR_BRICKWALL\n\t\t\t+ pine_factor * mix( COLOR_PINE, COLOR_PINE2, mm4.w ) * tree_ao\n\t\t\t+ smoothbump( MATID_GRASS, 0.5, matid ) * mix( COLOR_GRASS, COLOR_GRASS2, matid_f )\n\t\t\t+ smoothbump( MATID_GROUND, 0.5, matid ) * mix( PATH_COLOR, PATH_COLOR2, matid_f )\n\t\t\t+ smoothbump( MATID_NONE, 0.5, matid ) * MAGENTA;\n\n\t\tif ( MATID_WINDOW == matid ) \n\t\t{\n\t\t\tscene_color = BLACK;\n\t\t\tvec3 vr = reflect( v, n );\n\t\t\tvec3 refl_color = get_sky_plus_clouds( vr, l, p.z, aChannel1, aResolution, aTime );\n\t\t\trefl_color = mix( COLOR_GRASS * mix( 0.2, 1.0, shadow ), refl_color, smoothstep( -0.03, -0.0, vr.z ) );\n\t\t\tsky_reflection = refl_color * mix( 0.2, 1.0, pow( 1.0 - saturate( dot( -v, n ) ), 2.0 ) );\n\t\t}\n\n\t\tif ( MATID_GRASS == matid )\n\t\t{\n\t\t\tvec3 lf = sfbm4_33( p * 40.0 );\n\t\t\tfloat hf = sfbm1_12( p.xy * 2800.0 );\n\n\t\t\tif ( matid_f > ( 1. - 0.04 ) ) // mowed lawn, should be rare\n\t\t\t{\n\t\t\t\tfloat period = 0.07;\n\t\t\t\tfloat s = stripes( rotate_with_angle( p.xy, matid_f * 1000.0 ).x, period, period * 0.25, 0.004 );\n\t\t\t\tscene_color = mix( COLOR_MOWED_GRASS, COLOR_MOWED_GRASS2, saturate( s + ( lf.x - 0.38 ) * 1.5 ) );\n\t\t\t}\n\n\t\t\t// just apply some noise\n\t\t\tscene_color *= 1.0 - 0.2 * ( saturate( 1.0 - lf.y ) );\n\t\t\tscene_color *= saturate( 1.0 - 0.4 * hf * saturate( 1.0 - lf.y ) );\n\t\t}\n\t\n\t\tvec3 albedo = scene_color; // return albedo;\n\n\t\tcol += shadow * SGDiffuseFitted( sun_lobe, n, albedo );\n\n\t\t// this way of doing diffuse makes shadow color be different on ground than back of object resting on it which sucks\n\t\tif ( _1 ) col += mix( SGDiffuseFitted( sky_lobe, n, albedo ), top_sky_color, SHADOW_TINT_SATURATION )\n\t\t\t\t// add more sky ambient to tint shadow in blue? in a way that is not too hacky?\n\t\t\t\t* mix( 0.15, 0.02, shadow )\n\t\t\t\t* ao;\n\n\t\tcol += sky_reflection;\n\n\t\tfloat d = length( p - e );\n\t\tif ( FOG_GROUND ) col = mix( col, get_fog_color() * 0.8, ( 1. - exp( -0.1 * max( d - 6.1, 0. ) ) ) * 0.378 ); // fog\n\t}\n\telse\n\t{\n\t\tcol = get_sky_plus_clouds( v, l, e.z, aChannel1, aResolution, aTime );\n\n\t\tif ( SUN ) // this sun is the one in the sky\n\t\t{\n\t\t\tvec4 ppd = sunGlareCoords( cam, v, l );\n\t\t\tcol += sunGlare( ppd, 0.007, 280., 100000.0, 0.2, 20.0, 4.0, 0.3, 0.4, 8., false )\n\t\t\t\t* vec3( 0.8, 0.8, 0.5 ) * sunI;\n\t\t}\n\t}\n\n\t// note: we would like to do SUN_GLARE here, but reprojection only works on solid world pos or distance sky\n\treturn col;\n}\n\nvec3 postProcess( vec3 col, vec2 uv, vec4 ppd )\n{\n\tif ( SUN_GLARE )\n\t{\n\t\tcol.xyz += 0.116 * sunGlare( ppd, 0., 7., 8000.0, 0.2, 8.0, 8.0, 0.3, 2., 2., true )\n\t\t\t* vec3( 1., 0.7, 0.2 ) * 2. // use warmer color for this glare\n\t\t\t* smoothstep( -0.15, 0.3, ppd.w )\n\t\t\t* (1.0-smoothstep( 0.78, 0.9, ppd.z ));\n\t}\n\n\tfloat exposure = 3.0; \n\t// maybe auto expose when staring straight at the sun? the sun is a bit saturated on the clouds\n\t//exposure = mix(exposure,1.,smoothstep(0.985,1.0,1.-ppd.z));\n\tcol = exposure * tonemap_reinhard( col );\n//\tcol = max( vec3( 0. ), contrast( col, vec3( 1.02 ) ) );\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.15 );\n\tcol *= vignette;\n\tcol = contrast( col, vec3( 1.06 ) );\n\tcol = gamma_correction_itu( col );\n\treturn col;\n}\n\nstruct CameraRet { vec3 eye; vec3 target; float roll; float pitch; };\n\nCameraRet init_cam() { CameraRet cam; cam.roll = 0.; cam.pitch = 0.; return cam; }\n\n#define STICKY_MOUSE false\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy, vec3 aResolution, vec4 aMouse, float dmmx )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( dmmx, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( aMouse.z > 0.0 || STICKY_MOUSE ) mm = ( aMouse.xy - aResolution.xy * 0.5 ) / ( min( aResolution.x, aResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n\treturn camera * yup_spherical_coords_to_matrix( mm.y, mm.x );\n}\n\nstruct LanePoint { vec3 p; vec3 tangent2d; float lane_index; };\n\nLanePoint getPathPointAndDir( float x, float lane_index )\n{\n\tLanePoint ret;\n\tvec2 y = wavyLaneFuncAndDerivative_WORLD( x, lane_index );\n\tret.p.xy = vec2( x, y.x );\n\tret.p.z = BaseGroundHeight( ret.p.xy ) + 0.073;\n\tret.tangent2d = normalize( vec3( 1.0, y.y, 0 ) );\n\tret.lane_index = lane_index;\n\treturn ret;\n}\n\n// a cubicstep function that takes 2 arbitrary end points and 2 (begin end) slopes\nfloat cubicstep2( float x, vec2 p0, vec2 p1, float s0, float s1 )\n{\n\tx -= p0.x;\n\tp1 -= p0;\n\tx = clamp( x, 0., p1.x );\n\tfloat x1_sqr = p1.x * p1.x;\n\tvec3 eq1 = vec3( 3.0 * x1_sqr, 2.0 * p1.x, s1 - s0 );\n\tvec3 eq2 = vec3( x1_sqr * p1.x, x1_sqr, p1.y - s0 * p1.x );\n\tfloat a = ( eq1.y * eq2.z - eq1.z * eq2.y ) / ( eq1.y * eq2.x - eq1.x * eq2.y );\n\tfloat b = ( eq1.z - eq1.x * a ) / eq1.y;\n\treturn p0.y + ( ( a * x + b ) * x + s0 ) * x;\n}\n\nfloat linearstep2( float x, vec2 p0, float s0 ) { return p0.y + s0 * ( x - p0.x ); }\n\n// getCameraPathx is a line segment of length 'a', slope 'sa' followed by another line segment of length 'b', slope 'sb',\n// made periodic and smooth. \n// the 'a' segment is where we walk, the 'b' segment is where we fly \n// this lets us tweak length and speed of walk and flight sequences separately\n// the cubic transitions are a bit iffy and tedious looking but the curve must be really clean to make landing and take off transitions natural and gentle\n// return values:\n//  x: were we are on the lane\n//  y: flight smooth blend factor (0 means we walk >0 means we fly, function goes up and down smootly)\n//  z: the periodicity index, so each period can use a different lane\n//  w: the flight begin to end smoothstep, we use it so we can blend between lanes whilst we are in the air\nvec4 getCameraPathx( float x, float a, float b, float sa, float sb, float e )\n{\n\te = min( e, min( a, b ) * 0.5 ); // e is the half lenght of smooth transitions\n\tfloat period = a + b;\n\tfloat h = sa * a + sb * b;\n\tfloat n = floor( x / period );\n\tx -= n * period;\n//#if 1\n\tvec2 M = vec2( a, sa * a );\n\tvec2 F = vec2( a + b, h );\n\tvec2 A = vec2( 0, 0 );\n\tvec2 B = A + vec2( e, sa * e );\n\tvec2 C = M - vec2( e, sa * e );\n\tvec2 D = M + vec2( e, sb * e );\n\tvec2 E = F - vec2( e, sb * e );\n\tfloat y = n * h;\n\tif ( x < B.x ) y += cubicstep2( x, A + ( E - F ), B, sb, sa );\n\telse if ( x < C.x ) y += linearstep2( x, B, sa );\n\telse if ( x < D.x ) y += cubicstep2( x, C, D, sa, sb );\n\telse if ( x < E.x ) y += linearstep2( x, D, sb );\n\telse y += cubicstep2( x, E, F + ( B - A ), sb, sa );\n\tfloat section_b = min( smoothstep( C.x, D.x, x ), 1. - smoothstep( E.x, F.x + B.x - A.x, x ) )\n\t+ 1.0 - smoothstep( A.x + E.x - F.x, B.x, x );\n\treturn vec4( y, section_b, n, smoothstep( D.x, E.x, x ) ); // w: flight begin and end for lane transitions\n//#endif\n//\t// the function above if it was just piecewise linear\n//\tif ( x < a ) x *= sa; else x = sa * a + ( x - a ) * sb;\n//\treturn vec4( x + n * h, 0, n, 0 );\n}\n\n// get the args for getCameraPathx, with a travel lengh l and speed in input\nvec2 get_duration_and_slope( float l, float speed ) { float t = l / speed; return vec2( t, sqrt( max( l * l - t * t, 0. ) ) / t ); }\n\nmat4 walkAndFlyCamera( float tan_half_fovy, float aTime, vec4 aDate, vec3 aResolution, vec4 aMouse )\n{\n#if 1\n\tvec2 aa = get_duration_and_slope( 2.82, 1.41 );\n\tvec2 bb = get_duration_and_slope( 11.34, 7.56 );\n\tfloat te = 0.4;\n\tvec4 vv = getCameraPathx( te + aTime * 0.07, aa.x, bb.x, aa.y, bb.y, te ); // vv.y = is fly mode amount\n\tfloat lane_index = FIRST_LANE_INDEX;\n\tlane_index += vv.z;\n\tLanePoint pp_next = getPathPointAndDir( vv.x, lane_index+1.0 );\n\tLanePoint pp = getPathPointAndDir( vv.x, lane_index );\n\t// lerp with the next lane\n\tpp.p = mix(pp.p,pp_next.p,vv.w);\n\tpp.lane_index = mix(pp.lane_index,pp_next.lane_index,vv.w);\n\tpp.tangent2d = normalize(mix(pp.tangent2d,pp_next.tangent2d,vv.w));\n\t// lerp with straight curve corresponding to that (now blending) lane\n\tfloat alt = 1.;\n\tpp.p.z = mix( pp.p.z, alt, vv.y * vv.y );\n\tpp.p.y = mix( pp.p.y, ( pp.lane_index + 0.5 ) * PATH_SPACING_Y, vv.y * vv.y );\n\tpp.tangent2d = normalize( mix( pp.tangent2d, vec3( 1., 0., 0. ), vv.y ) );\n#else\n\tLanePoint pp = getPathPointAndDir( 9.8+aTime * 0.08, FIRST_LANE_INDEX ); // simple walk camera\n#endif\n\tCameraRet cam = init_cam();\n\tcam.eye = pp.p;\n\tcam.target = cam.eye + pp.tangent2d;\n\tcam.target.z -= mix(0.15,0.53, vv.y * vv.y); // this causes some roll on mouse movements as a happy side effect\n//\tcam.target.z -= 0.59 * vv.y * vv.y; // this causes some roll on mouse movements as a happy side effect\n\tmat4 camera = lookat( cam.eye, cam.target, vec3( 0., 0., 1. ) ) * z_rotation( cam.roll );\n\tfloat tilt = 0.2 * sin( aTime * 0.02 ) * vv.y * vv.y; // in flight mode add some small left-right to get some tilt when no one touches the mouse\n\tvec2 dmm = vec2( tilt, -0.35 * pow( abs( tilt ), 0.6 ) );\n\treturn look_around_mouse_control( camera, cam.pitch + dmm.y, tan_half_fovy, aResolution, aMouse, dmm.x );\n}\n\nvec2 pixelIndexToFragcoord( vec2 pixel_indexf, vec3 aResolution )\n{\n\t// note that pixelIndexToFragcoord(floor(fragCoord))==fragCoord\n\treturn aResolution.xy * ( ( vec2( 0.5 ) + pixel_indexf ) / aResolution.xy );\n}\n\nstruct CameraData { mat4 camera; float tan_half_fovy; }; // what we need to write for the reprojection\n\nCameraData GetCameraTransform( float aTime, vec4 aDate, vec3 aResolution, vec4 aMouse )\n{\n\tCameraData data;\n\n\tdata.tan_half_fovy = 0.6;\n\n#ifdef EXTRA_3D_CAMERA\n\tdata.camera = mat4( iCamera[0], iCamera[1], iCamera[2], iCamera[3] );\n\tdata.tan_half_fovy = iTanHalfFovy;\n#else\n\tdata.camera = walkAndFlyCamera( data.tan_half_fovy, aTime, aDate, aResolution, aMouse );\n#endif\n\treturn data;\n}\n\nvec3 mat_project_vector( vec3 v, mat4 camera ) { return vec3( dot( v, camera[0].xyz ), dot( v, camera[1].xyz ), dot( v, camera[2].xyz ) ); }\nvec3 mat_project_point_dir( vec3 p, mat4 camera ) { return normalize( mat_project_vector( p - camera[3].xyz, camera ) ); }\n\n// get subpixel index, 2x2 for now\nivec2 SubpixelIndex( int aFrame ) { aFrame &= 3; return ivec2( aFrame & 1, aFrame >> 1 ); }\n\nvec2 NumSubpixels( vec3 aResolution ) { return aResolution.xy / 2.0; }\n\nCameraData readCameraData( ivec2 offset, vec3 aResolution, sampler2D aChannel1 )\n{\n\tCameraData data;\n#if 0\n\tfloat y = offset.x + 2.0 * offset.y;\n\tdata.camera[0] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 0, y ) ) / aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[1] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 1, y ) ) / aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[2] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 2, y ) ) / aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[3] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 3, y ) ) / aResolution.xy, 0 ).xyz, 1 );\n\tdata.tan_half_fovy = texture( aChannel1, ( vec2( 0.5 ) + vec2( 4, y ) ) / aResolution.xy, 0 ).x;\n#else\n\tint y = offset.x + 2 * offset.y;\n\tdata.camera[0] = texelFetch( aChannel1, ivec2( 0, y ), 0 );\n\tdata.camera[1] = texelFetch( aChannel1, ivec2( 1, y ), 0 );\n\tdata.camera[2] = texelFetch( aChannel1, ivec2( 2, y ), 0 );\n\tdata.camera[3] = texelFetch( aChannel1, ivec2( 3, y ), 0 );\n\tdata.tan_half_fovy = texelFetch( aChannel1, ivec2( 4, y ), 0 ).x;\n#endif\n\treturn data;\n}\n\nvec4 mainScene( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel1\n\t\t\t\t, out vec4 ppd )\n{\n\tfloat aspect = aResolution.x / aResolution.y;\n\tvec2 uv = fragCoord.xy / aResolution.xy;\n\n\tvec2 pixel = fragCoord.xy;\n\tvec4 fragColor = vec4( 0.0 );\n\n#if 1\n\tCameraData camera_data = GetCameraTransform( aTime, aDate, aResolution, aMouse );\n#else\n\tivec2 offset0 = SubpixelIndex( aFrame - 0 ); // I think we get previous frame because double buffer so doesn't work as is\n\tCameraData camera_data = readCameraData( offset0, aResolution, aChannel1 );\n#endif\n\n\tRay view_ray = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 / camera_data.tan_half_fovy, camera_data.camera );\n\tfloat ao = 1.0;\n\n\tvec3 sun_direction = get_sun_direction( aTime );\n\tbool sky = false;\n\tfloat shadow = 1.0;\n\tTraceOutput to;\n\tvec3 p2;\n\tvec3 n;\n\tSceneOut eval_for_shade;\n\tSceneOutInit( eval_for_shade );\n    Ray trace_ray = view_ray;\n\tint trace_flags = TRACE_VIEW;\n\tint max_iterations = MAX_ITERATIONS_VIEW; \n\tfloat tmaxmax = TMAX_VIEW;\n\n\t// force a loop on view ray, shadow ray to prevent shadertoy compilation abject unrolling horror\n\tfor ( int pass = 0 FORCE_LOOP; pass < (SHADOWS?2:1); ++pass )\n\t{\n\t\tTraceOutput tmp_to = traceScene( trace_ray, 5.0, trace_flags, max_iterations, TFRAC, tmaxmax, DBREAK\n\t\t\t\t\t\t\t\t\t\t , uv, fragCoord, aFrame, aTime );\n\t\tif ( pass == 1 )\n\t\t{\n\t\t\t//shadow = ( tmp_to.t > TMAX_SHADOW ? 1 : 0 ); // check hard shadows\n\t\t\t//shadow = tmp_to.shadow; // default soft shadows, don't work well with this scene\n\t\t\tshadow = mix( 0.05, 1.0, smoothstep( 0.4, 0.6, tmp_to.shadow ) ); // take a threshold on default soft shadows, good for sunny setting\n\t\t\tbreak;\n\t\t}\n\n\t\t// only view rays make it here... \n\n\t\tto = tmp_to;\n\t\tp2 = view_ray.o + to.t * view_ray.d;\n\t\tsky = to.t > TMAX_VIEW;\n\n\t\tif ( sky ) break;\n\t\t\n\t\t// only view rays that hit solid surfaces make it here...\n\n\t\t// we need to evaluate normal vector at hit point, we will also retrieve extra material calculations\n\t\tSceneIn scenein;\n\t\tscenein.p = p2;\n\t\tSetSceneInDirectionless( scenein, TRACE_SHADE );\n\t\tscenein.t = 0.0;\n\n\t\t{\n\t\t\t// to set this epsilon, set the camera at 1000 and check fence and terrain normal...\n\t\t\t// it should look the same as 0,0,0...\n\t\t\tfloat e = 1e-3 * 2.;\n\t\t\tvec4 v; // center in .w, deltas in .xyz\n#if 0\n\t\t\tSceneIn scenein2 = scenein;\n\t\t\tscenein2.p = scenein.p + vec3( e, 0.0, 0.0 ); v.x = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\tscenein2.p = scenein.p + vec3( 0.0, e, 0.0 ); v.y = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\tscenein2.p = scenein.p + vec3( 0.0, 0.0, e ); v.z = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\teval_for_shade = evalScene( scenein, aFrame, aTime );\n\t\t\tv.w = eval_for_shade.object_di.d;\n#else\n\t\t\t// force a loop on gradient eval to prevent shadertoy compilation abject unrolling horror\n\t\t\tfor ( int i = 0 FORCE_LOOP; i < 4; ++i )\n\t\t\t{\n\t\t\t\tSceneIn scenein2 = scenein;\n\t\t\t\tif ( i != 3 ) scenein2.p[i] += e; // let's live dangerously and use vector component random access\n\t\t\t\teval_for_shade = evalScene( scenein2, aFrame, aTime ); // note: eval_for_shade contains material data at center, at the end of the loop\n\t\t\t\tv[i] = eval_for_shade.object_di.d;\n\t\t\t}\n#endif\n\t\t\tn = normalize( v.xyz - vec3( v.w ) );\n\t\t}\n\n\t\tif ( AO )\n\t\t{\n\t\t\tSceneIn scenein2 = scenein;\n\t\t\tSetSceneInDirection( scenein2, p2, n, TRACE_AO );  // shouldn't change anything\n\n\t\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n\t\t\tfloat delta = 0.1;\n\t\t\tfloat a = 0.0;\n\t\t\tfloat b = 1.0;\n\t\t\tfor ( int i = 0 FORCE_LOOP; i < 4; i++)\n\t\t\t{\n\t\t\t\tfloat fi = float( i );\n\t\t\t\tscenein2.p = p2 + n * delta * fi;\n\t\t\t\tfloat d = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\t\ta += ( delta * fi - d ) * b;\n\t\t\t\tb *= 0.5;\n\t\t\t}\n\t\t\tao = max( 1.0 - 1.8 * a, 0.0 );\n\t\t}\n\n\t\tif ( SHADOWS )\n\t\t{\n\t\t\t// hack: use a different normal offset for trees as noise shadows are very sensitive to that\n\t\t\tvec4 mm4 = DecodeId_5_5_5( eval_for_shade.object_di );\n\t\t\tfloat tree_ao = 1.0;\n\t\t\tif ( (mm4.x == MATID_TREE) || (mm4.x == MATID_PINE) )\n\t\t\t{\n\t\t\t\ttree_ao += 1.0 - smoothstep( 0.2, 0.5, mm4.z );\n\t\t\t\ttree_ao -= smoothstep( -0.2, 0.0, dot( sun_direction, n ) );\n\t\t\t\ttree_ao = saturate( tree_ao );\n\t\t\t}\n\n\t\t\t// note: because of surface noise, tweaking the shadow ray normal bias has a lot of impact on vegetation\n\t\t\t// might want to tweak it per surface too\n\t\t\ttrace_ray = mkray( p2 + n * mix( 0.004, 0.0005, tree_ao ), sun_direction ); // if bias is too small here tree shadows become shitty\n\t\t\ttrace_flags = TRACE_SHADOW;\n\t\t\tmax_iterations = MAX_ITERATIONS_SHADOW;\n\t\t\ttmaxmax = TMAX_SHADOW;\n\t\t}\n\t}\n\n\tfragColor.rgb = shadeSample( view_ray.o, view_ray.d, camera_data.camera, p2\n\t\t\t\t\t\t\t\t , n, sun_direction, shadow, to, ao, uv, eval_for_shade, sky, aChannel1, aResolution, aTime );\n\n\tppd = sunGlareCoords( camera_data.camera, view_ray.d, sun_direction );\n\n\tfragColor.a = to.t; // write depth in .w to recover the world position in reprojection\n\n\treturn fragColor;\n}\n\n#if BUFFER_MODE==0\nvec4 Mode0_NoBuffer_mainImage( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel1 )\n{\n\tvec4 ppd;\n\tvec4 col = mainScene( fragCoord, aTime, aDate, aResolution, aFrame, aMouse, aChannel1, ppd );\n\tcol.rgb = postProcess( col.rgb, fragCoord / aResolution.xy, ppd );\n\treturn col;\n}\n#endif\n\n#if BUFFER_MODE==2\n\n// write camera\nvec4 Mode2_Reproject_mainBufferB( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )\n{\n\tvec2 pi = floor( fragCoord );\n\tvec4 background = texelFetch( aChannel1, ivec2( pi ), 0 );\n\n\tif ( ( pi.y > 3.0 ) || \n\t\t ( pi.x > 4.0 ) ) \n\t{\n\t\tvec4 skybox = background;\n\n\t\tivec2 res_addr = ivec2( 5, 0 ); // store position for resolution\n\n\t\tif ( ( CLOUD_MODE > 1 ) &&\n\t\t\t ( ( CLOUD_MODE == 2 ) // always\n\t\t\t   || ( aFrame <= 1 ) // on first frame\n\t\t\t   || ( texelFetch( aChannel1, res_addr, 0 ).xy != vec2( aResolution.xy ) ) ) ) // on resolution change\n\t\t{\n\t\t\tif ( pi == vec2(res_addr) ) return vec4( aResolution.xy, 0, 0 );\n\t\t\t\n\t\t\tvec2 p = fragCoord / aResolution.y;\n\t\t\tif ( p.x > 1. || p.y > 1. ) skybox.xyz = MAGENTA;\n\t\t\telse\n\t\t\t{\n\t\t\t\tskybox.xyz = vec3( p,0 ); //vec3( traceClouds( n ) );\n\t\t\t\tp -= vec2( 0.5 );\n\t\t\t\tfloat r = length( p );\n\t\t\t\tvec3 n = zup_spherical_coords_to_vector( r052theta( r ), calc_angle( p ) ); // only care about theta in [0,PI/2]\n\t\t\t\tskybox.xyz = traceClouds( n, aTime );\n\t\t\t\tif ( r > 0.5 ) skybox.xyz = RED;\n\t\t\t\t//skybox = vec4( get_sky( n, vec3( 0 ) ).w, 0 );\n\t\t\t}\n\t\t}\n\n\t\tif ( CLOUD_MODE <= 1 ) skybox.xyz = MAGENTA;\n\n\t\treturn skybox; // unused area, we use the bottom (3*4,4) pixels\n\t}\n\n\tvec2 offset = vec2( SubpixelIndex( aFrame ) );\n\tfloat y = offset.x + 2.0 * offset.y; // subpixel flat index\n\t\n\tif ( pi.y == y )\n\t{\n\t\tCameraData data = GetCameraTransform( aTime, aDate, aResolution, aMouse );\n\t\tif ( pi.x == 0.0 ) return vec4( data.camera[0].xyz, 1 );\t   // return vec4( RED, 1 );    \n\t\tif ( pi.x == 1.0 ) return vec4( data.camera[1].xyz, 1 );\t   // return vec4( GREEN, 1 );  \n\t\tif ( pi.x == 2.0 ) return vec4( data.camera[2].xyz, 1 );\t   // return vec4( BLUE, 1 );   \n\t\tif ( pi.x == 3.0 ) return vec4( data.camera[3].xyz, 1 );\t   // return vec4( YELLOW, 1 ); \n\t\tif ( pi.x == 4.0 ) return vec4( data.tan_half_fovy, 0, 0, 1 ); // return vec4( MAGENTA, 1 );\n\t}\n\treturn background; // no touch = copy old data - we need to do that because shadertoy double buffers\n}\n\n// write each subpixel in its respective quadrant\nvec4 Mode2_Reproject_mainBufferA( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )\n{\n\tivec2 hres = ivec2( aResolution.xy ) / 2;\n\tivec2 offset = SubpixelIndex( aFrame );\n\tivec2 pi = ivec2( floor( fragCoord ) );\n\tivec2 pi0 = pi;\n\t// gather for coherency (make 4 quadrant, each having a full scene, instead of pixel all top pixels in 4)\n\tif ( offset != ( pi / hres ) ) // quadrant this pixel is in\n\t{\n\t\treturn texelFetch( aChannel0, pi, 0 ); // no touch = copy old data - we need to do that because shadertoy double buffers\n\t}\n\tpi = ( pi - offset * hres ) * 2; // also clears offset lower bits\n\tfragCoord = pixelIndexToFragcoord( vec2( pi + offset ), aResolution );\n//\treturn vec4( offset, 0., 1. ); // quadrant debug color\n\tvec4 ppd;\n\treturn mainScene( fragCoord, aTime, aDate, aResolution, aFrame, aMouse, aChannel1, ppd );\n}\n\n// input uv maps 0,1 to screen\nvec2 applySubPixelOffsetTo01UV( vec2 uv, vec2 offseti, vec3 aResolution )\n{\n\t// important: since we sample the *center* of the top level pixel,\n\t// we want the *corner* of the corresponding subpixel in the quadrant image\n\t// (so offset by half the quadrant offset)\n\t// without that the image is much blurrier than it should\n\t// besides, the chance I got this wroing somewhere is high :-D\n\tuv -= ( offseti - vec2( 0.5 ) ) / aResolution.xy;\n\treturn ( uv + vec2( offseti ) ) * 0.5;\n}\n\nfloat reprojected( vec3 p, ivec2 offseti, CameraData cdati, vec3 aResolution, out vec4 ret, out Ray view_ray, sampler2D aChannel0 )\n{\n\tfloat aspect = aResolution.x / aResolution.y;\n//\tCameraData cdati = readCameraData( offseti, aResolution ); // passed from caller\n\tvec3 v = mat_project_point_dir( p, cdati.camera ); // ray direction in the older camera\n\tview_ray.d = v;\n\tview_ray.o = cdati.camera[3].xyz;\n\tfloat t = plane_trace_z( v, -1.0 / cdati.tan_half_fovy, 1e-3 );\n\tvec2 uv = ( v * t ).xy;\n\tuv.x /= aspect;\n\tuv = ( uv + vec2( 1.0 ) ) * 0.5;\n\tvec2 uvcheck = uv; // before going to quadrant uv, store the 01 range uv to do a uv range check see if our sampled thing is valid...\n\tuv = applySubPixelOffsetTo01UV( uv, vec2(offseti), aResolution );\n\tif ( ( t < 0.0 ) || ( t == FLT_MAX ) || ( saturate( uvcheck ) != uvcheck ) ) return 0.0;\n#if 0\n\tret = texture( aChannel0, uv );\n#else\n#if 0\n\tivec2 pmin = ivec2( 0, 0 );\n\tivec2 pmax = ivec2( aResolution.xy ) - ivec2( 1, 1 );\n#else\n\t// deal with borders\n\tivec2 pmin = offseti * ivec2( aResolution.xy ) / 2;\n\tivec2 pmax = pmin + ivec2( aResolution.xy ) / 2 - ivec2( 1, 1 );\n#endif\n\t// bilinear by hand so we can exclude samples and/or clamp borders properly\n\tvec2 pi = uv * aResolution.xy - vec2( 0.5 );\n\tivec2 i = ivec2( floor( pi ) );\n\tvec2 f = fract( pi );\n\tvec4 v00 = texelFetch( aChannel0, clamp( i + ivec2( 0, 0 ), pmin, pmax ), 0 ); // return im0;\n\tvec4 v10 = texelFetch( aChannel0, clamp( i + ivec2( 1, 0 ), pmin, pmax ), 0 );\n\tvec4 v01 = texelFetch( aChannel0, clamp( i + ivec2( 0, 1 ), pmin, pmax ), 0 );\n\tvec4 v11 = texelFetch( aChannel0, clamp( i + ivec2( 1, 1 ), pmin, pmax ), 0 );\n#if 1\n\tvec4 A = v10 - v00;\n\tvec4 B = v01 - v00;\n\tvec4 C = ( v11 - v01 ) - A;\n\tvec4 D = v00;\n\tret = A * f.x + B * f.y + C * f.x * f.y + D;\n#else\n\tret = mix( mix( v00, v10, f.x ), mix( v01, v11, f.x ), f.y );\n#endif\n#endif\n//\tret = vec4(uvcheck,0,1);\n\treturn 1.0;\n}\n\n// combine images history\nvec4 Mode2_Reproject_mainImage( vec2 fragCoord, float aTime, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1, out vec4 ppd )\n{\n\tivec2 hres = ivec2( aResolution.xy ) / 2;\n\tivec2 pi = ivec2( floor( fragCoord ) );\n\tivec2 offset0 = SubpixelIndex( aFrame - 0 ); // this frame\n\tivec2 offset1 = SubpixelIndex( aFrame - 1 ); // previous frame\n\tivec2 offset2 = SubpixelIndex( aFrame - 2 ); // previous previous frame\n\tivec2 offset3 = SubpixelIndex( aFrame - 3 );\n\tCameraData cdat0 = readCameraData( offset0, aResolution, aChannel1 );\n\tCameraData cdat1 = readCameraData( offset1, aResolution, aChannel1 );\n\tCameraData cdat2 = readCameraData( offset2, aResolution, aChannel1 );\n\tCameraData cdat3 = readCameraData( offset3, aResolution, aChannel1 );\n\t// reprojection code path\n\t// we need to be careful here... the point we reproject is the center of the quadrant,\n\t// the regular raytraced position if we were fullscreen, because it is the only point\n\t// that is common to all quadrants and the only point that will give us a stable image\n\t// with 4 last frames (without accumulating)\n\tvec2 uv = fragCoord / aResolution.xy;\n\tfloat aspect = aResolution.x / aResolution.y;\n\tRay view_ray0 = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 / cdat0.tan_half_fovy, cdat0.camera );\n\tvec2 uv0 = applySubPixelOffsetTo01UV( uv, vec2(offset0), aResolution );\n\tvec4 im0 = texture( aChannel0, uv0 );\n//\treturn im0; // this one is always good, we have just calculated it\n\tvec3 p0 = view_ray0.o + view_ray0.d * im0.w; // the most recent world point we have\n\tvec4 im1, im2, im3;\n\tvec3 valid;\n\tRay view_ray1, view_ray2, view_ray3;\n\tvalid.x = reprojected( p0, offset1, cdat1, aResolution, im1, view_ray1, aChannel0 ); vec3 p1 = view_ray1.o + view_ray1.d * im1.w;\n\tvalid.y = reprojected( p0, offset2, cdat2, aResolution, im2, view_ray2, aChannel0 ); vec3 p2 = view_ray2.o + view_ray2.d * im2.w;\n\tvalid.z = reprojected( p0, offset3, cdat3, aResolution, im3, view_ray3, aChannel0 ); vec3 p3 = view_ray3.o + view_ray3.d * im3.w;\n\tvec4 w = vec4( 1.0 );\n\tw.yzw = valid.xyz;\n\tvec4 col = ( im0 * w.x + im1 * w.y + im2 * w.z + im3 * w.w ) / sum( w ); // note: don't preprocess here\n\tif ( SUN_GLARE ) ppd = sunGlareCoords( cdat0.camera, view_ray0.d, get_sun_direction( aTime ) ); // pass this to post processing\n\treturn col;\n}\n\n#endif\n\n#if BUFFER_MODE==0\n #define BUFFERB void mainImage( out vec4 fragColor, in vec2 fragCoord ) { }\n #define BUFFERA void mainImage( out vec4 fragColor, in vec2 fragCoord ) { }\n #define IMAGE void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode0_NoBuffer_mainImage( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel1); }\n#elif BUFFER_MODE==2\n #define BUFFERB void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode2_Reproject_mainBufferB( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel0, iChannel1); }\n #define BUFFERA void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode2_Reproject_mainBufferA( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel0, iChannel1); }\n #define IMAGE \\\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) \\\n  { \\\n\t  vec4 ppd; \\\n\t  fragColor = Mode2_Reproject_mainImage( fragCoord, iTime, iResolution, iFrame, iMouse, iChannel0, iChannel1, ppd ); \\\n\t  fragColor.rgb = postProcess( fragColor.rgb, fragCoord / iResolution.xy, ppd ); \\\n\t  fragColor.a = 0.; /* remember we have the depth in alpha, png save will go weird so clear */ \\\n  }\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "BUFFERA",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "BUFFERB",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}