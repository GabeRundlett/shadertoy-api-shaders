{
    "Shader": {
        "info": {
            "date": "1635684555",
            "description": "Stylized rendering of the Antibes bay",
            "flags": 32,
            "hasliked": 0,
            "id": "Nt3GzH",
            "likes": 1,
            "name": "[ConcoursJFIG2021] - Antibes",
            "published": 3,
            "tags": [
                "concoursjfig2021"
            ],
            "usePreview": 0,
            "username": "H4w0",
            "viewed": 197
        },
        "renderpass": [
            {
                "code": "void compute_region(in vec2 uv, in vec2 offset, in float size, out vec4 mean, out vec4 stddev )\n{\n    mean = texture(iChannel1,uv+offset,size);\n    vec4 moment = texture(iChannel2,uv+offset,size);\n    vec4 variance = moment - mean*mean;\n    stddev = sqrt(variance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (fragCoord - (iResolution.xy-iResolution.y)*0.5) / iResolution.y;\n    if(U.x < 0.0 || U.x > 1.0) {fragColor.rgb = vec3(0.0); return;}\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ts = max(iResolution.x,iResolution.y);\n    \n    float size = 2.3;\n    float quad = 1.2;\n    vec4 m1, std1; compute_region(uv, vec2(-quad,-quad)/ts, size, m1, std1);\n    vec4 m2, std2; compute_region(uv, vec2(-quad,+quad)/ts, size, m2, std2);\n    vec4 m3, std3; compute_region(uv, vec2(+quad,-quad)/ts, size, m3, std3);\n    vec4 m4, std4; compute_region(uv, vec2(-quad,+quad)/ts, size, m4, std4);\n    \n    \n    vec4 minStd = std1;\n    vec4 minMean = m1;\n    \n    if(std2.a < minStd.a)\n    {\n        minStd = std2;\n        minMean = m2;\n    }\n    \n    \n    if(std3.a < minStd.a)\n    {\n        minStd = std3;\n        minMean = m3;\n    }\n    \n    \n    if(std4.a < minStd.a)\n    {\n        minStd = std4;\n        minMean = m4;\n    }\n        \n    \n    /* Pixel value is the mean value of the region with the minimal standard deviation */  \n    fragColor = vec4(minMean.rgb,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-----------------------------------------------------------------------------\n//-- IDs ----------------------------------------------------------------------\nconst float SKY_ID = 0.2;\nconst float SEA_ID = 0.3;\nconst float FOREGROUND_ID = 0.4;\nconst float BACKGROUND_ID_1 = 0.5;\nconst float BACKGROUND_ID_2 = 0.6;\nconst float ANTIBES_CITY_ID = 0.9;\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi_2 \t\t= 1.5707963267;  \nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */            \nconst float m_2_pi \t\t= 6.2831853071; \nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_2f    = 0.01;     \nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;     \n\n//----------------------------------------------------------------------------------\n//-- Ray ---------------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- IQ Intersection Functions ------------------------------------------------\nvec2 intersection_axis_aligned_box(in vec3 ray_origin, in vec3 ray_direction, in vec3 box_parameters) \n{\n    vec3 m  = 1.0/ray_direction;\n    vec3 n  = m*ray_origin;\n    vec3 k  = abs(m)*box_parameters;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2(tN,tF);\n}\n\nfloat intersection_plane(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n//----------------------------------------------------------------------------------\n// IQ SDF functions ----------------------------------------------------------------\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w; // n must be normalized\n}\n\n//----------------------------------------------------------------------------------\n// SDF Operators -------------------------------------------------------------------\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat opUnn(float d1, float d2) \t{ return min(d1,d2); }\nfloat opSub(float d1, float d2) \t{ return max(-d1,d2); }\nfloat opInt(float d1, float d2) \t{ return max(d1,d2); }\nfloat opSUnn(float d1, float d2) \t{ return sminCubic(d1,d2,0.1); }\nvec2  opU(vec2 d1, vec2 d2)         { return((d1.x < d2.x) ? d1 : d2);}\n\n//----------------------------------------------------------------------------------\n// HSV to RGB courtesy of IQ -------------------------------------------------------\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+m_eps_3f)), d / (q.x+m_eps_3f), q.x);\n}\n\n//----------------------------------------------------------------------------------\n// hg_sdf functions, courtesy of Mercury -------------------------------------------\n\nvoid pR(inout vec2 p, float a) \n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.*m_pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n//----------------------------------------------------------------------------------\n// noises --------------------------------------------------------------------------\n\nfloat u_hash_1_1(in float p) {return fract(cos(p*89.42)*343.42);}\nfloat s_hash_1_1(in float p) {return -1.0+2.0*u_hash_1_1(p);}\nvec2  s_hash_2_2(in vec2  p) {return vec2(s_hash_1_1(p.x*23.62-300.0+p.y*34.35),s_hash_1_1(p.x*45.13+256.0+p.y*38.89));}\n\n\nfloat noise1( in float p )\n{\n    float i = floor(p);\n    float f = fract(p);\n    float u = f*f*(3.0-2.0*f);\n\n    float g0 = s_hash_1_1(i+0.0);\n    float g1 = s_hash_1_1(i+1.0);\n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\nfloat fbm_1D( in float x, in float amplitude, in int octaves )\n{    \n    float n = 0.0;\n    float a = amplitude;\n    for( int i=0; i<octaves; i++ )\n    {\n        n += a*noise1(x);\n        a *= 0.5;\n        x *= 2.0;\n    }\n    return n;\n}\n\n// Candycat's Perlin Noise Implementation :: Noise Lab (2D)\n// https://www.shadertoy.com/view/ldc3RB\nfloat perlin_noise_2D(in vec2 p)\n{\n    vec2 pi = floor(p);\n\tvec2 pf  = p-pi;\n    vec2 w = pf*pf*(3.0-2.0*pf);\n    return mix(mix(dot(pf - vec2(0, 0), s_hash_2_2(pi + vec2(0, 0))), \n                   dot(pf - vec2(1, 0), s_hash_2_2(pi + vec2(1, 0))), w.x), \n               mix(dot(pf - vec2(0, 1), s_hash_2_2(pi + vec2(0, 1))), \n                   dot(pf - vec2(1, 1), s_hash_2_2(pi + vec2(1, 1))), w.x),\n               w.y);\n}\n\nfloat fbm_2D(in vec2 p, in float amplitude, in int octaves)\n{\n    float f = 0.0;\n    float a = amplitude;\n\tfor (int i = 0; i < octaves; i++) \n    {\n\t\tf += perlin_noise_2D(p) * a;\n\t\ta *= 0.5;\n        p *= 2.0;\n\t}\n\treturn(f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//-----------------------------------------------------------------------------\n//-- Constantes ---------------------------------------------------------------\nconst float EPSILON             = m_eps_3f;\nconst float SAMPLES_WORLD       = 32.;\nconst vec3  WORLD_BOUNDING_BOX  = vec3(2.5,1.0,2.5);\nconst vec3  WORLD_LIGHT_DIRECTION = normalize(vec3(1.0,1.1,0.7));\n\n\nvec2 map_city(in vec3 P)\n{\n    float SDF = 1.;\n    vec3 O = P;\n\n    /* 1. MuseePicasso & Horloger */\n    vec3 CB1 = vec3(0.15, 0.7, 0.15 );\n    vec3 C1 = P - vec3(0.3,0.7,0.3);\n    vec3 CB2 = vec3(0.15, 0.8, 0.15);\n    vec3 C2 = P - vec3(1.9,0.8,0.0);\n    vec3 CB3 = vec3(0.6, 0.6, 0.3 );\n    vec3 C3 = P - vec3(0.9,0.6,0.3);\n    SDF = opUnn( SDF, sdBox(C1,CB1) );\n    SDF = opUnn( SDF, sdBox(C2,CB2) );\n    SDF = opUnn( SDF, sdBox(C3,CB3) );\n\n\n    /* 2. Ville */\n    float cellid = pModPolar(P.xz,6.0);\n    float h = 0.4*u_hash_1_1(cellid);\n    float offset = 0.38;\n\n    float inner_radius = 0.3;\n    float outer_radius = 1.0;\n    float border_wall  = 2.1; \n    float building_size = 0.1 + 0.8*h;\n\n    \n    vec3 B1 = vec3(building_size, 0.1+h, building_size );\n    vec3 Q1 = P - vec3(offset+0.3,0.3+h,0.0);\n    vec3 B2 = vec3( building_size, 0.12+h, building_size );\n    vec3 Q2 = P - vec3(offset+1.0,0.2+h,0.4);\n    vec3 B3 = vec3( building_size, 0.15+h, building_size );\n    vec3 Q3 = P - vec3(offset+1.35,0.2+h,-0.1);\n    SDF = opUnn( SDF, sdBox(Q1,B1) );\n    SDF = opUnn( SDF, sdBox(Q2,B2) );\n    SDF = opUnn( SDF, sdBox(Q3,B3) );\n\n    /* 3. Murs */\n    pModPolar(O.xz,12.0);\n    SDF = opUnn( SDF, sdBox(O-vec3(0.1,0.0,0.0),vec3(2.0,0.1,1.0)) );\n    pR(O.xy,0.3); \n    SDF = opUnn( SDF, sdBox(O-vec3(border_wall,-0.7,0.0),vec3(0.1,0.35,0.7)) );\n    return vec2(SDF,ANTIBES_CITY_ID);\n}\n\n\nvec2 MAP(in vec3 P)\n{      \n    return map_city(P);\n}\n\n//-----------------------------------------------------------------------------\n//-- Raymarching code ---------------------------------------------------------\nvec3 \tworld_get_light_direction() { return WORLD_LIGHT_DIRECTION; }\n\nvec2 world_intersect(in vec3 ro, in vec3 rd, in float tmax)\n{\n    float t = 0.01;\n    vec2  R = vec2(-1.);\n    for(float istep=0.; istep<SAMPLES_WORLD && t<tmax; istep+=1.)\n    {\n        vec2 H = MAP(ro + t * rd);\n        if( H.x < EPSILON )\n        {\n            R = vec2(t,H.y);\n            break;\n        }\n        t += H.x;\n    }\n    return R;\n}\n\nvec3 world_get_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*MAP( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*MAP( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*MAP( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*MAP( pos + e.xxx ).x );  \n}\n\nvec2 raymarch(vec3 ro, vec3 rd, vec3 rl)\n{ \n    float dist_max = distance(ro,rl);\n    vec2  hitinfo = world_intersect(ro, rd, dist_max);\n    float hit_dis = hitinfo.x;\n    float hit_obj = hitinfo.y;\n\n    if(hit_dis<0.) \n    {\n    \treturn vec2(-1);\n    }\n\n    return hitinfo;\n}\n\nvec2 launch_ray(inout vec3 ro, in vec3 rd)\n{\n    vec2 hitinfo = vec2(-1);\n    \n    float tmin = 0.0;\n    float tmax = 50.0;\n\n    /* First the sea level plane */\n    vec3 plane_normal = vec3(0.0,1.0,0.0);\n    float plane_hit = intersection_plane(ro,rd,vec4(plane_normal,0.0));\n    if(plane_hit>0.0)\n    {\n        tmax = min(tmax,plane_hit);\n        hitinfo = vec2(plane_hit,SEA_ID);\n    }\n\n    /* Foreground mountains */\n    vec2 foreground = intersection_axis_aligned_box(ro-vec3(-4.0,0.0,4.5), rd, vec3(5.0,1.5,0.2));    \n    bool foreground_miss = (foreground.x > foreground.y || foreground.y < 0.0);\n    bool foreground_closest = (foreground.x < tmax);\n    if( !foreground_miss  && foreground_closest ) \n    {\n        vec3 hit_pos = ro+rd*foreground.x;\n        float v = 0.2+0.6*fbm_1D( 0.13 + hit_pos.x*0.1,2.0,9);\n        if( hit_pos.y < 1.5*v )\n        {\n            tmax = min(tmax,foreground.x);\n            hitinfo = vec2(foreground.x,FOREGROUND_ID);\n        }\n    }\n    \n    /* Then the simplified montains landscape */\n    vec2 background = intersection_axis_aligned_box(ro-vec3(0.0,5.0,-5.0), rd, vec3(30.0,5.0,0.2) );   \n    bool back_miss = (background.x > background.y || background.y < 0.0);\n    bool back_closest = (background.x < tmax);\n    if( !back_miss  && back_closest ) \n    {\n        tmax = min(tmax,background.x);\n        hitinfo = vec2(background.x,BACKGROUND_ID_1);\n    }\n\n    /* Then the simplified Antibes city */\n    vec3 offset = vec3(0.0,1.0,0.0);\n    vec2 box = intersection_axis_aligned_box(ro-vec3(0.0,1.0,0.0), rd, WORLD_BOUNDING_BOX);    \n    bool box_miss = (box.x > box.y || box.y < 0.0);\n    bool box_closest = (box.x < tmax);\n    if( !box_miss  && box_closest ) \n    {\n        tmin = max(box.x,tmin);\n        tmax = min(box.y,tmax);\n\n        vec3  O = ro+tmin*rd; \n        vec3  E = ro+tmax*rd; \n        vec2 march = raymarch(O,rd,E);\n        if(march.y > 0.0)\n        {\n            hitinfo = march;\n            ro = O;\n        }\n    }\n\n    return hitinfo;\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd, in vec2 coords, in vec2 coords2)\n{   \n    float HUE = 240.0/360.0;\n    float OBJ = SKY_ID;\n    float DIS = 0.0;\n    float SAT = 0.8;\n    float VAL = 0.5;\n\n    float snow_factor = 0.0;\n    float wave_factor = 0.0;\n    float shade_factor = 0.0;\n    \n    vec3 ro_tmp = ro;\n\n    vec2 hitinfo = launch_ray(ro,rd);\n    float hit_dis = hitinfo.x;\n    float hit_obj = hitinfo.y;\n\n\n    if(hit_dis<0.) /* background color */\n    {\n        SAT = 0.5;\n        VAL = 1.0;\n    }\n\n    if(hit_obj == SEA_ID) /* sea level */\n    {\n        DIS = hit_dis;\n        HUE = 216.0/360.0;\n        OBJ = hit_obj;\n        SAT = 0.8;\n        VAL = 0.6;\n        wave_factor = 1.0;\n    }\n\n    if(hit_obj == FOREGROUND_ID) /* foreground coast   */\n    {\n        DIS = hit_dis;\n        HUE = 05.0/360.0;\n        OBJ = hit_obj;\n        SAT = 1.0;\n        VAL = 0.54;\n    }\n\n    if(hit_obj == ANTIBES_CITY_ID) /* city */\n    {\n        vec3 hit_pos = ro+rd*hit_dis;\n        vec3 hit_nor = world_get_normal(hit_pos);\n        \n        DIS = (hit_dis + distance(ro_tmp,ro));\n        HUE = 50.0/360.0 * dot(hit_nor, world_get_light_direction());\n        OBJ = hit_obj;\n        SAT = 0.8;\n        VAL = 0.5;\n    }\n\n    if(hit_obj == BACKGROUND_ID_1) /* mountains */\n    {\n        vec3 hit_pos = ro+rd*hit_dis;\n        float v = 0.4+0.2*fbm_1D(hit_pos.x*0.1,2.0,9);\n        float w = 0.5+0.2*fbm_1D( 1.1 + hit_pos.x*0.05,2.0,9);\n        \n        if(hit_pos.y < 5.*v )\n        {\n            HUE = 220.0/360.0;\n            OBJ = hit_obj;\n            DIS = hit_dis;\n            \n            SAT = 0.88;\n            VAL = 0.25;\n            shade_factor = 1.0;\n        }\n        else if( hit_pos.y < 5.5*w )\n        {\n            HUE = 200.0/360.0;\n            OBJ = BACKGROUND_ID_2;\n            DIS = (hit_dis+0.5);\n            SAT = 0.45;\n            VAL = 0.35;\n            snow_factor = 1.0;\n        }\n    }\n    \n    float hue_noise = 0.5+0.5*fbm_2D(coords+vec2(OBJ),1.0,3);\n    HUE += 0.1*hue_noise;\n    \n    \n    /* */\n    vec3 color = vec3(0.0);\n    float noise = fbm_2D(coords+2.0*vec2(SAT,VAL),1.2,5);\n    float warp1 = fbm_2D(coords.xx+2.0*noise,1.0,5);\n    float warp2 = fbm_2D(coords.yy+2.0*warp1+0.2*iTime,1.0,5);\n    /* Shading */\n    float shade = shade_factor*0.2*smoothstep(0.2,0.7,coords2.y+1.0*noise);\n    /* Wave */ \n    float wave = wave_factor*0.2*smoothstep(0.0,0.85,coords2.y+warp2);\n    /* Color */ \n    color = hsv2rgb( vec3(HUE + 0.1*noise + wave + shade,SAT,VAL) );\n    /* Snow */ \n    color += snow_factor*smoothstep(0.55,0.75,coords2.y+0.1*noise);\n    /* Final Color */\n    color = clamp(color,0.0,1.0);  \n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 U = (fragCoord - (iResolution.xy-iResolution.y)*0.5) / iResolution.y;  \n    vec2 screen_coords = (2.*fragCoord - iResolution.xy)/iResolution.y; \n    \n    \n    vec3 ta = vec3(0.,0.65,0.0);\n    vec3 ro = vec3( -1.1, 0.13, 7.0 );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, ta, 0.0);\n      \n    vec3 color = render(ro,rd, screen_coords, U);\n    fragColor = vec4(color,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rgbcolor = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    vec3 hsvcolor = rgb2hsv(rgbcolor);\n    float value = hsvcolor.b;    \n    fragColor = vec4(rgbcolor,value);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = texture(iChannel0,fragCoord/iResolution.xy);\n    vec4 moment = value*value;\n    fragColor = moment;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}