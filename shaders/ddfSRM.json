{
    "Shader": {
        "info": {
            "date": "1668622258",
            "description": "Code for generating a lot of types of noise maps.",
            "flags": 0,
            "hasliked": 0,
            "id": "ddfSRM",
            "likes": 1,
            "name": "Noise Maps Generator",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "gradient",
                "value",
                "polar"
            ],
            "usePreview": 0,
            "username": "rge15",
            "viewed": 231
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define selec 12\n\nfloat N21(in vec2 p)\n{\n    p = 50.*fract( p * PI);\n    p = 50.*fract((p+vec2(0.24342,709.23))/PI);\n\n    return -1. + 2.*fract((p.x*p.y) );\n}\n\nvec2 N22(in vec2 p)\n{\n    p = 50.*fract((p+vec2(0.24342,709.23))/PI);\n    return 1. - 2.*fract(p * vec2(p.x+p.y, p.y*p.x) + vec2(0.29137,0.9348));\n}\n\nvec2 modulo(in vec2 divident, in vec2 divisor)\n{\n   return mod(divident,divisor) * (divisor / abs(divisor));\n}\n\nfloat valueNoise(in vec2 pos)\n{\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    vec2 inter = f * f * (3. -2.*f);\n    \n    float vA = N21(i + vec2(0.,0.));\n    float vB = N21(i + vec2(1.,0.)); \n    float vC = N21(i + vec2(0.,1.)); \n    float vD = N21(i + vec2(1.,1.)); \n    \n    return vA + (vB - vA)*inter.x + (vC - vA)*inter.y + (vD - vC - vB + vA) * inter.x * inter.y;\n}\n\nfloat tiledValueNoise(in vec2 pos, in vec2 frec)\n{\n    vec2 f = fract(pos);\n \n    vec2 imin = floor(pos);\n    vec2 imax = ceil(pos);\n \n    imin = modulo( imin, frec );\n    imax = modulo( imax, frec );\n     \n \n    vec2 inter = f * f * (3. -2.*f);\n    \n    float vA = N21( imin );\n    float vB = N21( vec2( imax.x, imin.y)); \n    float vC = N21( vec2( imin.x, imax.y)); \n    float vD = N21( imax ); \n    \n    return vA + (vB - vA)*inter.x + (vC - vA)*inter.y + (vD - vC - vB + vA) * inter.x * inter.y;\n}\n\nfloat gradientNoise(in vec2 pos)\n{\n    vec2 f = fract(pos);\n    vec2 i = floor(pos);\n\n    vec2 inter = f * f * ( 3. - 2. * f);\n\n    vec2 vecA = N22( i );\n    vec2 vecB = N22( i + vec2( 1. , 0. ) );\n    vec2 vecC = N22( i + vec2( 0. , 1. ) );\n    vec2 vecD = N22( i + vec2( 1. ));\n    \n    float valA = dot( f , vecA );\n    float valB = dot( f - vec2(1.,0.) , vecB );\n    float valC = dot( f - vec2(0.,1.) , vecC );\n    float valD = dot( f - vec2(1.,1.) , vecD );\n\n    return valA + ( valB - valA ) * inter.x + ( valC - valA ) * inter.y + ( valD - valB - valC + valA ) * inter.x * inter.y;\n\n}\n\nfloat tiledGradientNoise(in vec2 pos, in vec2 frec)\n{\n    vec2 f = fract(pos);\n    vec2 imin = floor(pos);\n    vec2 imax = ceil(pos);\n    \n    imin = modulo(imin, frec);\n    imax = modulo(imax, frec);\n\n    vec2 inter = f * f * ( 3. - 2. * f);\n\n    vec2 vecA = N22( imin );\n    vec2 vecB = N22( vec2( imax.x, imin.y) );\n    vec2 vecC = N22( vec2( imin.x, imax.y) );\n    vec2 vecD = N22( imax );\n    \n    float valA = dot( f , vecA );\n    float valB = dot( f - vec2(1.,0.) , vecB );\n    float valC = dot( f - vec2(0.,1.) , vecC );\n    float valD = dot( f - vec2(1.,1.) , vecD );\n\n    return valA + ( valB - valA ) * inter.x + ( valC - valA ) * inter.y + ( valD - valB - valC + valA ) * inter.x * inter.y;\n\n}\n\nfloat valueFBM(in vec2 p, in float h, in int octaves)\n{\n    \n    float value = 0.;\n    \n    for(int i = 0; i < octaves ; i++ )\n    {\n        float f = pow(2.,float(i));\n        float a = pow(f,-h);\n        value += a * valueNoise( f*p );\n    }\n\n    return value;\n}\n\nfloat tiledValueFBM(in vec2 p, in vec2 frec ,in float h, in int octaves)\n{\n    \n    float value = 0.;\n    \n    for(int i = 0; i < octaves ; i++ )\n    {\n        float f = pow(2.,float(i));\n        float a = pow(f,-h);\n        value += a * tiledValueNoise( f*p , frec);\n    }\n\n    return value;\n}\n\nfloat gradientFBM(in vec2 p, in float h, in int octaves)\n{\n    \n    float value = 0.;\n    \n    for(int i = 0; i < octaves ; i++ )\n    {\n        float f = pow(2.,float(i));\n        float a = pow(f,-h);\n        value += a * gradientNoise( f*p );\n    }\n\n    return value;\n}\n\nfloat tiledGradientFBM(in vec2 p, in vec2 frec ,in float h, in int octaves)\n{\n    \n    float value = 0.;\n    \n    for(int i = 0; i < octaves ; i++ )\n    {\n        float f = pow(2.,float(i));\n        float a = pow(f,-h);\n        value += a * tiledGradientNoise( f*p , frec);\n    }\n\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    // Polar Coordinates\n    vec2 p_uv = vec2( atan(uv.x,uv.y), length(uv));\n    // Normalized Polar Coordinates\n    vec2 np_uv = vec2( p_uv.x/(2.*PI)+0.5 , p_uv.y );\n    \n    float noise = 0.;\n#if selec == 0\n    noise = valueNoise(uv*10.+vec2(iTime));\n#elif selec == 1\n    noise = tiledValueNoise(uv*10.+vec2(iTime), vec2(15.));\n#elif selec == 2\n    noise = tiledValueNoise(np_uv*vec2(20.,5.)+vec2(iTime), vec2(10.));\n#elif selec == 3\n    noise = clamp(tiledValueNoise(np_uv*vec2(5.,5.)+vec2(iTime), vec2(5.)),0.,1.);\n    noise *= tiledValueNoise(np_uv*vec2(40.,0.)+vec2(iTime,0.), vec2(20.));\n#elif selec == 4\n    noise = gradientNoise(uv*10.+vec2(iTime));\n#elif selec == 5\n    noise = tiledGradientNoise(uv*3.+vec2(iTime), vec2(10.,5.) );\n#elif selec == 6\n    noise = clamp(tiledGradientNoise(np_uv*vec2(5.,5.)+vec2(iTime*0.5,iTime), vec2(5.)),0.,1.);\n#elif selec == 7\n    noise = 0.7 * valueFBM(uv*10.+vec2(iTime),0.49,4);\n#elif selec == 8\n    noise = 0.7 * tiledValueFBM(uv*10., vec2(10.) ,0.49,4);\n#elif selec == 9\n    noise = 0.7 * tiledValueFBM(np_uv*vec2(10.,2.)+vec2(iTime*0.5), vec2(10.) ,0.49,7);\n    noise *= np_uv.y;\n#elif selec == 10\n    noise = 0.7 * gradientFBM(uv*10.+vec2(iTime),0.49,5);\n#elif selec == 11\n    noise = 0.7 * tiledGradientFBM(uv*10., vec2(10.) ,0.49,4);\n#elif selec == 12\n    noise = 0.7 * tiledGradientFBM(np_uv*vec2(10.,2.)+vec2(iTime*0.5), vec2(10.) ,0.49,2);\n    noise *= np_uv.y;\n#endif\n\n\n    // Time varying pixel color\n    vec3 col = vec3(noise);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}