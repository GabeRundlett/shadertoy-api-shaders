{
    "Shader": {
        "info": {
            "date": "1397930562",
            "description": "tried to capture the look as best I could...",
            "flags": 0,
            "hasliked": 0,
            "id": "4dlXzN",
            "likes": 39,
            "name": "is anyone there?",
            "published": 3,
            "tags": [
                "portal",
                "turret",
                "activated",
                "thereyouare",
                "hellooo"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 2162
        },
        "renderpass": [
            {
                "code": "vec3 L = normalize(vec3(-.3, 1., .2));\nvec3 n1 = normalize(vec3(2., -1., 0));\nvec3 n3 = normalize(vec3(4.,  1., 0));\n\nconst float cz = -.8;\nconst vec3 tgt = vec3(0, cz, 0);\nconst vec3 cpos = vec3(0, cz, 11.5);\n\n#define precis .01\n#define farval 1e5\n#define gap .03\n#define hip .3\n#define dmax 20.0\n#define rayiter 70\n\n#define MAT_SHINYBLACK .0\n#define MAT_DULLGRAY   1.\n#define MAT_MIDGRAY    2.\n#define MAT_WHITE      3.\n#define MAT_EYE        4.\n\n#define OVERLAY\n\nvec2 opU(in vec2 a, in vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nfloat sdBox(in vec3 p, in vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),.0) +\n         length(max(d,.0));\n}\n\nfloat sdCylinder(in vec3 p, in vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),.0) + length(max(d,.0));\n}\n\n\nvec2 baseEllipsoid(in vec3 pos) {\n    vec3 abc = vec3(1., 2.5, 1.);\n    abc = pos/(abc*abc);\n\treturn vec2((dot(pos * abc, vec3(.5)) - .5)*inversesqrt(dot(abc,abc)), MAT_WHITE);\n}\n\nfloat sdMidCyl(in vec3 pos) {\n    return .5*baseEllipsoid(2.*pos*vec3(1.,1.,0)).x;\n}\n\n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n\treturn mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\nvec2 ant(inout vec3 pos, in vec3 p1) {\n\tfloat u = clamp(dot(pos, p1)/dot(p1,p1), .0, 1.)-1.0;\n    pos -= p1;\n    return vec2(length(pos-p1*u)-.025, MAT_SHINYBLACK);\n}\n\n\nfloat sdCone( in vec3 p ){\n    p.z -= 0.58;\n\tvec2 q = vec2( length(p.xy), -p.z );\n\treturn max( max( dot(q,vec2(inversesqrt(2.))), -p.z), p.z-1. );\n}\n\nvec2 stick(in vec3 pos, in float l) {\n\t\n    float d;\n\td = dot(abs(pos.xz), normalize(vec2(3., -1.)));\n    pos.z -= l;\n    d = max(d,sdBox(pos, vec3(.15, .05, l)));\n    \n\treturn vec2(d, MAT_SHINYBLACK);\n\t\n}\n\nvec2 torus(in vec3 pos, in vec3 x, in vec3 y) {\n\t\n\tvec3 n = normalize(cross(x, y));\n\t\n\tvec3 pp = length(x)*normalize(pos - n*dot(n, pos));\n    \n\tfloat d = length(pos-pp)-.05;\n\td = max(d, dot(pos, normalize(cross(x, n))));\n\td = max(d, dot(pos, normalize(cross(n, y))));\n\n\treturn vec2(d, MAT_SHINYBLACK);\n\t\n\t\n}\n\n\nvec2 map(in vec3 pos) {\n\n    // antennae\n    vec2 rval = baseEllipsoid(pos);\n\n    vec3 lpos = pos - vec3(-.3, .2, -.2);\n    \n    rval = opU(rval, ant(lpos, vec3(0, 2.7, 0)));\n    \n    lpos = pos - vec3(-.5, 2., -.2);\n    rval = opU(rval, ant(lpos, vec3(0, 1., 0)));\n    rval = opU(rval, ant(lpos, vec3(.2, .2, 0)));\n    rval = opU(rval, ant(lpos, vec3(0, .4, 0)));\n    \t\n\tpos.x = abs(pos.x);\n    \n\t\n\trval.x = max(rval.x, min(dot(pos, n1), sdMidCyl(pos)));\n\trval.x = max(rval.x, -sdCone(pos));\n    rval.x = max(rval.x, -abs(pos.x)+.5*gap);\n\trval.x = max(rval.x, -sdBox(pos - vec3(0, -.15, 0), vec3(.7, .7, .5)));\n\t//rval.x = max(rval.x, -sdCylinder((pos-vec3(0, 0, .5)).xzy, vec2(.23, .5)));\n\n    rval = opU(rval, vec2(length(pos-vec3(0, 0,.56))-.3, MAT_EYE));\n\trval = opU(rval, vec2(sdBox(pos-vec3(0, -.15, 0), vec3(.3, .75, .8)), MAT_DULLGRAY));\n    rval = opU(rval, vec2(sdBox(pos+vec3(0, 13.5, .5), vec3(4., 10.1, 4.)), 2.9));\n\t//rval = opU(rval, vec2(pos.y+3.4, 2.5));\n       \n\t// front leg\n    rval = opU(rval, torus(pos-vec3(.45, -1.2, .3), \n                           vec3(-.45, .1, -1.), \n                           vec3( .45, -.25, .9)));\n\n\tlpos = rotX(1.8)*rotY(-.2)*(pos+vec3(-.5, 2.5, 0));\n\n\tvec2 e = baseEllipsoid(lpos);\n    \n\te.x = max(e.x, -(e.x+hip));\t\n\te.x = max(e.x, -sdMidCyl(lpos));\n\te.x = max(e.x, dot(lpos, n3));\n\te.x = max(e.x, -lpos.x);\n\te.x = max(e.x, -lpos.z);\n    \n    rval = opU(rval, e);\n    rval = opU(rval, stick(lpos-vec3(.22, -2.25, -1.45), 0.775));\n\n    // back leg\n    rval = opU(rval, torus(pos-vec3(0, -.7, -1.15),\n                           vec3(0, .05, -.7),\n                           vec3(0, -.35, .55)));\n\t\n\tlpos = rotX(-1.8)*(pos+vec3(0, 1.5, .4));\n\t\n\te = baseEllipsoid(lpos);\n    \n\te.x = max(e.x, -(e.x+hip));\t\n\te.x = max(e.x, -sdMidCyl(lpos));\n\te.x = max(e.x, dot(lpos, n3));\n\te.x = max(e.x, lpos.z);\n\n    rval = opU(rval, e);\n\n\trval = opU(rval, stick(vec3(0, -2.32, 2.5)-lpos, 1.3));\n\n\t\n    // side\n    pos.x -= .7;\n\n    e = baseEllipsoid(pos);\n\t\t\n\te.x = max(e.x, -sdMidCyl(pos)+gap);\n\te.x = max(e.x, dot(pos, -n3)+gap);\n\te.x = max(e.x, dot(pos, -n1)+gap);\n\t\n\te.x = max(e.x, -sdBox(pos-vec3(1.6, 0, 0), vec3(.75, .1, .5)));\n\t\n    rval = opU(rval, e);\n\n \te = vec2(sdBox(pos-vec3(.35, -.15, 0), vec3(.3, .65, .4)), MAT_DULLGRAY);\n\te = opU(e, vec2(sdBox(vec3(pos.xy, abs(pos.z))-vec3(0, -.2, .3), vec3(.5, .05, .05)), MAT_SHINYBLACK));\n    pos.y = abs(pos.y);\n\te = opU(e, vec2(sdCylinder((pos-vec3(.28, .2, .5)).xzy, vec2(.13, .2)), MAT_MIDGRAY));\n\te.x = max(e.x, -sdCylinder((pos-vec3(.28, .2, .35)).xzy, vec2(.1, .4)));\n    \n    rval = opU(rval, e);\n    \n\treturn rval;\n\t\n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(precis*2., -1.);\n    float t = .0;\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(res.x)<precis||t>dmax ) continue;//break;\n        t += res.x;\n\t    res = map( ro+rd*t );\n\t    res.y = res.y;\n    }\n\tif (t > dmax || abs(res.x) > precis) { res.y = -1.; }\n    res.x = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( .001, 0, 0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = .0;\n    float sca = 1.;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = .01 + .04*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= .8;\n    }\n    return clamp( 1. - 3.*totao, .0, 1. );\n}\n\n#ifdef OVERLAY\n\nfloat raycyl(vec3 o, vec3 d) { \n   \t\n    float r = .025;\n\tfloat a = dot(d,d) - d.z*d.z;\n\tfloat b = 2.*(dot(o,d)-o.z*d.z);\n\tfloat c = dot(o,o) - o.z*o.z - r*r;\n\t\t\n    a *= 2.;\n    \n\tfloat qd = b*b - 2.*a*c;\n \tfloat sd = sqrt(qd);\n\tfloat x1 = (-b + sd)/a;\n    float x2 = (-b - sd)/a;\n    \n    float t = qd < .0 ? farval : min(x1 < .0 ? farval : x1,\n\t\t\t \t\t\t             x2 < .0 ? farval : x2);\n    \n\tfloat u = o.z + t*d.z;\n\n    return (t < farval && u >= .0) ? t : farval;\n\t\n}\n\n#endif\n\n\nvec3 shade( in vec3 ro, in vec3 rd ) {\n\t\n\tvec2 tm = castRay(ro, rd);\n\tvec3 rcolor;\n\t\n\tif (tm.y >= .0) {\n\t\tvec3 pos = ro + tm.x * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tfloat ao = calcAO( pos, nor );\n\t\t\n\t\t// 0 = shiny black\n\t\t// 1 = dark gray\n\t\t// 2 = mid gray\n\t\t// 3 = shiny white\n\t\t// 4 = eye\n\t\t\n\t\tfloat r = clamp(mix(.2, 1., tm.y/3.), .0, 1.);\n\t\tr*=r;\n\t\tfloat gb = tm.y < 4. ? r : .0;\n\t\t\n\t\tif (tm.y == 4.) {\n\t\t\tfloat k = length(pos.xy);\n\t\t\tr *= (1. - 1.*cos(k*30.0));\n\t\t\tfloat a = atan(pos.y, pos.x);\n\t\t\tr *= (1. - .5*cos(a*16.));\n\t\t}\n\t\t\n\t\tfloat gamma = abs(tm.y - 1.5) < .75 ? .0 : .5;\n\t\t\n\t\tvec3 color = vec3(r, vec2(gb));\n\t\t\n\t\tfloat c1 = dot(nor, L);\n\n\t\tvec3 diffamb = (.5 + .5 * max(c1, -c1*.2))*color;\n\t\t\n\t\tvec3 R = 2.*nor*dot(nor,L)-L;\n\t\tfloat spec = gamma*pow(clamp(-dot(R, rd), .0, 1.), 24.);\n\t\trcolor = (diffamb + spec)*ao;\n\n\t} else {\n\t\tfloat g = max(.3*dot(L,rd)+.6, .0);\n\t\trcolor = vec3(g*g);\n\t}\n    \n#ifdef OVERLAY\n\t\n\tif (raycyl(ro, rd) < tm.x) {\n\t\trcolor = mix(rcolor, vec3(1., .3, .3), .5 + .15*sin(94.*iTime));\n\t}\n    \n#endif\n\n\treturn rcolor;\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\t\n\tvec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\t\n\tfloat thetax = -.05, thetay = -.10;\n\t\n\tif (max(iMouse.x, iMouse.y) > 20.0) { \n\t\tthetax = (iMouse.y - .5*iResolution.y) * 3.14/iResolution.y; \n\t\tthetay = (iMouse.x - .5*iResolution.x) * -6.28/iResolution.x; \n\t}\n\t\n    mat3 R = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);\n\n\tvec3 rd = R*normalize(vec3(uv, 1.)),\n        ro = tgt + R*vec3(0,0,-length(cpos-tgt));\n\t\n\tfragColor.xyz = pow(shade(ro, rd),vec3(.8));\n\t\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}