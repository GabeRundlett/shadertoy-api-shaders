{
    "Shader": {
        "info": {
            "date": "1619513897",
            "description": "I made this in 25 minutes, inspired by shader showdown things. There are many artifacts but I am claiming them as features :D",
            "flags": 0,
            "hasliked": 0,
            "id": "fdSSRz",
            "likes": 16,
            "name": "Uncontained Fracture",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 504
        },
        "renderpass": [
            {
                "code": "#define STEPS 164.0\n#define MDIST 300.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 glow = vec3(0);\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n\nvec2 map(vec3 p){\n    vec3 po = p;\n    //p.xy*=rot(iTime);\n    //p.yz*=rot(iTime);\n    //p.zx*=rot(iTime);\n    vec2 a = vec2(box(p,vec3(0.3)),1.0);\n    \n    glow+=vec3(1.000,0.067,0.090)*0.01/(0.01+a.x*a.x);\n    \n    \n    //a = (a.x>b.x)?b:a;\n    vec2 b = vec2(box(p-vec3(1,0,0),vec3(0.5)),2.0);\n    a = (a.x>b.x)?b:a;\n    b = vec2(box(p-vec3(-1,0,0),vec3(0.3)),3.0);\n    a = (a.x>b.x)?b:a;\n    \n    //a.x = min(a.x,b.x);\n    return a;\n}\n\nvec2 map2(vec3 p){\n    vec3 po = p;\n    float t = iTime;\n\n    for(float i=0.0;i<3.0;i++){\n        p=abs(p)-.3;\n        p.xy*=rot(0.5+t);\n        p.xz*=rot(0.5+t);\n    }\n    vec2 a = map(p);\n    a.x = box(po,vec3(1.5));\n    a.x = min(a.x,length(po)-2.0);\n    //vec2 b = vec2(po.y+1.8,2.0);\n    //a = (a.x>b.x)?b:a;\n    \n    return a;\n}\nvec2 map3(vec3 p){\n    vec3 po = p;\n    float t = iTime;\n    \n    vec2 a = map2(p);\n    \n    for(float i=0.0;i<9.0;i++){\n        p=abs(p)-vec3(2.3*i,1,1);\n        p.xy*=rot(pi/4.0*floor(t*3.0));\n        p.xz*=rot(pi/7.0*floor(t*3.0));\n        a = min(a,map2(p*0.5));\n    }\n        \n    //a.x = box(po,vec3(1.5));\n    //a.x = min(a.x,length(po)-2.0);\n    vec2 b = vec2(po.y+1.8,2.0);\n    a = (a.x>b.x)?b:a;\n    \n    po=mod(po,80.0)-40.0;\n    a.x = min(a.x,length(po.xz)-2.0);\n    a.x = min(a.x,length(po.zy)-2.0);\n    a.x = min(a.x,length(po.xy)-2.0);\n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.0);\n    return normalize(map3(p).x-vec3(\n    map3(p-e.xyy).x,\n    map3(p-e.yxy).x,\n    map3(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,30,-90);\n    vec3 rd = normalize(vec3(uv,1.0));\n    rd.zy*=rot(0.3);\n    ro.xz*=rot(iTime);\n    rd.xz*=rot(iTime);\n    vec3 p = ro;\n    float dO = 0.0;\n    float shad = 0.0;\n    float bnc = 0.0;\n    float dist = 0.0;\n    float dO2;\n    for(float i = 0.0; i<STEPS; i++){\n        p = ro + rd * dO;\n        vec2 d = map3(p);\n        dO += d.x;\n        dO2+= d.x;\n        if(dO2>MDIST || d.x < 0.01) {\n            shad = (i)/(STEPS);\n            if(bnc == 0.0)dist=dO;\n            if(bnc== 1.0||d.y!=2.0) {shad=i/STEPS; break;}\n            ro += rd*dO;\n            vec3 n = norm(ro);\n    \n            rd = reflect(rd,n);\n            ro += n*0.1;\n            dO = 0.0;\n            i=0.0;\n            bnc++;\n            \n        }\n    }\n    col = vec3(shad);\n    //col += 0.5*mix(vec3(0.176,0.259,1.000),vec3(0.722,0.067,1.000),sin(p.z*0.01));\n    col+=glow*0.2;\n    col=mix(col,vec3(0),(dist/MDIST));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}