{
    "Shader": {
        "info": {
            "date": "1566785150",
            "description": "This shader compares three different ways to integrate sin/cos in order to compute cos/sin without trigonometric functions.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlBXzd",
            "likes": 18,
            "name": "Waves - symplectic integrator",
            "published": 3,
            "tags": [
                "2d",
                "wave",
                "cosine",
                "integrator"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1488
        },
        "renderpass": [
            {
                "code": "// Symplectic Integrator, motivated by this tweet by MMalex\n// and Fabian Giesen's explanation:\n// https://twitter.com/mmalex/status/1165757266601099276\n//\n// The shader compares different ways to integrate sin/cos in\n// order to compute cos/sin without trigonometrics.\n//\n// Choose a METHOD for comparison\n//\n// 0 Red:    naive Euler way. Explodes quickly\n// 1 Yellow: normalizing the naive way. Stable, but drifts\n// 2 Blue:   symplectic integrator, pretty close to perfect\n// 3 Green:  rotation based, perfect\n//   Grey:   ground truth\n\n#define METHOD 2\n\n//---------------------------------------------\n\n\n\n// Ground truth cs for reference.\nvec2 waveExact( int x, const float w )\n{\n    return vec2(cos(w*float(x)),sin(w*float(x)));\n}\n\n\n// The naive method is to integrate each component\n// sequentially. It's equivalent to rotating the vector\n// cs by M = {1, -w, w, 1}, which is a poor approximation\n// to the rotation and more importantly has determinant\n// |M| = 1+w² > 1, which means it's going to explore rapidly.\nvec2 waveEulerNaive( int x, const float w )\n{\n    vec2 cs = vec2(1.0,0.0);\n    for( int i=0; i<x; i++ )\n    {\n        cs += w*vec2(-cs.y,cs.x);\n    }\n    return cs;\n}\n\n\n// The naive fix to the naive method is to renormalize\n// the vector cs after each tansformation. This doesn't\n// work neither in the long run, since it doesn't fix the\n// drifting. See yellow graph.\nvec2 waveEulerNormalized( int x, const float w )\n{\n    vec2 cs = vec2(1.0,0.0);\n    for( int i=0; i<x; i++ )\n    {\n        cs += w*vec2(-cs.y,cs.x);\n        cs = normalize( cs );\n    }\n    return cs;\n}\n\n// Symplectic integration - instead of updating the value\n// and its derivative at the same time (like in a normal\n// Euler integration), it updates the derivative and then\n// the value based on the updated derivative (Verlet style).\n// See https://en.wikipedia.org/wiki/Symplectic_integrator,\n// and make p=cos, q=sin, H=1, T(x)=x^2, V(x)=x^2, and use the\n// first order integrator.\n//\n// It is equivalent to transforming the vector cs each time\n// with M = {1, -w, w, 1-w²}, which has determinant |M|=1\n// (won't explode). Sometimes it will produce a vector a bit\n// longer than the true cs wave, and sometimes shoter, but\n// it oscillates regularly around the true length.\nvec2 waveSymplectic( int x, const float w )\n{\n    vec2 cs = vec2(1.0,0.0);\n    for( int i=0; i<x; i++ )\n    {\n        cs.x-=w*cs.y;\n        cs.y+=w*cs.x; \n    }\n    return cs;\n    \n    // measure deviation from unity length\n    // return vec2( (4.0/w)*(length(cs)-1.0), 0.0 );\n    \n    // measure deviation from true cs coordinates\n    // return vec2( (4.0/w)*length(cs-waveExact(x,w)), 0.0 );\n}\n\n// The most intuitive method is probably to rotate\n// cs by the right amount each time.\nvec2 waveRotations( int x, const float w )\n{\n    mat2 M = mat2(cos(w),-sin(w),sin(w),cos(w));\n    vec2 cs = vec2(1.0,0.0);\n    for( int i=0; i<x; i++ )\n    {\n        cs = M*cs;\n    }\n    return cs;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y;\n    float px = 1.0/iResolution.y;\n \n    const float pi = 3.1415926536;\n    const float w = 10.0*(2.0*pi)/800.0;\n    const float a = 0.1;\n\n    int x = int(fragCoord.x + min(pow(mod(iTime,15.0)/15.0,2.0)*4000.0,3000.0));\n    \n\n    vec3 col = vec3(0.15);\n\n    // axis\n    {\n    float d = abs(p.y-0.5);\n    col = mix( col, vec3(0.5), 1.0-smoothstep(0.5*px,1.5*px,d) );\n    }\n\n    // 2PI periods\n    {\n    float d = abs(mod(float(x)*w+pi,2.0*pi)-pi);\n    col = mix( col, vec3(0.5), 1.0-smoothstep(0.5*px,1.5*px,d) );\n    }\n\n    // naive: red\n    #if METHOD==0\n    {\n\tvec2 cs = a*waveEulerNaive( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(1.0*px,4.0*px,d) );\n    }\n    #endif\n\n\t// naive normalized: yellow\n    #if METHOD==1\n    {\n\tvec2 cs = a*waveEulerNormalized( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep(1.0*px,4.0*px,d) );\n    }\n    #endif\n    \n    // symplectic: blue\n    #if METHOD==2\n    {\n\tvec2 cs = a*waveSymplectic( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    col = mix( col, vec3(0.1,0.4,1.0), 1.0-smoothstep(1.0*px,4.0*px,d) );\n    }\n    #endif\n\n    \n    // rotations: green\n    #if METHOD==3\n    {\n\tvec2 cs = a*waveRotations( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    col = mix( col, vec3(0.1,1.0,0.0), 1.0-smoothstep(1.0*px,4.0*px,d) );\n    }\n    #endif\n    \n    // exact : white\n    {\n\tvec2 cs = a*waveExact( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    float e = smoothstep(-0.1,0.1,sin(iTime*3.1415927));\n    col = mix( col, vec3(1.0,1.0,1.0), e*(1.0-smoothstep(1.0*px,4.0*px,d)) );\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}