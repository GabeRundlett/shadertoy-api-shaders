{
    "Shader": {
        "info": {
            "date": "1657665007",
            "description": "Flocking example intended to demonstrate the basic idea of these kinds of algorithms. Will expand and improve it later. Mouse click randomizes their position",
            "flags": 32,
            "hasliked": 0,
            "id": "NdKBzh",
            "likes": 28,
            "name": "Flow of the Flock",
            "published": 3,
            "tags": [
                "mouse",
                "buffer",
                "flocking",
                "boids"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 673
        },
        "renderpass": [
            {
                "code": "// Cole Peterson\n\n// Image: display buffer B\n\n\n/*\n    Shader is intended to show a basic flocking algorithm with no extras.\n    Algorithm can be modified to add non 360 degree view and smoothing but right now its barebones.\n    \n    Mouse click randomizes their position\n    \n*/\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec4 bB = texture(iChannel0, u / R);\n    f = vec4(.44*vec3(texture(iChannel0, u / R).w), 1.);\n    f.xyz += 1. - exp(-bB.xyz);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Buffer A: Simple particle tracking + flocking algorithm\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    \n    // Only deal with the pixels representing our boids\n    if(int(u.x) < nParticles && int(u.y) == 0){\n        vec4 bA = A(ivec2(u)); // .xy = position | .zw = velocity ie. the current Boid\n        \n        bA.xy += bA.zw*dt; // Update position\n\n        vec2 avgDir = vec2(0); // Average direction of all boids in the sight radius\n        vec2 avgPos = vec2(0); // Average position of all boids in the sight radius\n        \n        float nb = 0.; // Number of boids in sight of current boid\n        \n        // Go through all particles\n        for(int i = 0; i < nParticles; i++){\n            vec4 p = A(vec2(i, 0)); // Boid position and velocity ie \"this\" Boid\n            float d = length(bA.xy - p.xy); // Distance from this Boid to current Boid\n            \n            // This boid is in sight\n            if(d <= radius){\n                avgDir += p.zw;\n                avgPos += p.xy;\n                nb++;\n            }\n            \n            // This boid is too close, push away\n            if(d <= minSep){\n                vec2 dir = normalize(p.xy - bA.xy);\n                bA.xy -= dir * minSep*.008;\n            }\n        }\n        \n        // At least 1 boid in sight\n        if(nb > 0.){\n            avgPos /= nb;\n            bA.zw = normalize(avgDir) * speed; // Set new velocity based on avg direction\n            \n            vec2 dir = normalize(avgPos - bA.xy); // Move boid in direction of avg position of boids in sight\n            bA.zw += dir * 0.1;\n        }\n        \n        // Add some randomness to their direction\n        bA.z += .22*cos(iTime + u.x*555.);\n        bA.w += .22*sin(iTime*1.3 + u.x*355.);\n        \n        \n        // Randomize position\n        if(iMouse.z > 0.){\n           bA.xy = hash22(u*999. + 522.2 + iDate.w)*R.xy * 0.7 + R.xy*0.15;\n        }\n        \n\n        // Repeat coordinates\n        bA.xy = mod(bA.xy, R.xy);\n        \n\n        // Init boid position\n        if(iFrame < 4){\n            bA.xy = hash22(u*999. + 522.2 + iDate.w)*R.xy * 0.7 + R.xy*0.15;\n            bA.zw = (2.*hash22(u*999. + 322.2) - 1.) * .4;\n        }\n        \n        f = bA;\n    }\n    else\n        return;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define KEY(v,m) texelFetch(iChannel1, ivec2(v, m), 0).x\n#define ss(a, b, t) smoothstep(a, b, t)\n#define A(p) texelFetch(iChannel0, ivec2(p), 0)\n\nconst int nParticles = 280; // Number of boids\n\nfloat dt = 0.7; // Simulation speed\n\n// Sim values\nconst float radius = 33.; // Boid sight radius\nconst float minSep = 33.; // Boid minimum seperation\nconst float speed = 2.2; // Boid movement speed \n\n// Render values\nconst float rad = 0.0075;\nconst float trail = 0.97;\n\n\nconst float obRad = 45.; // Obstacle radius\n\n// Hash from Dave Hoshkin https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Buffer B: Render particles and do ghosting effect (only reason it has its own buffer)\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec4 bB = texture(iChannel1, u / R);\n    \n    // Go through boidzz\n    for(int i = 0; i < nParticles; i++){\n        vec2 p = A(ivec2(i, 0)).xy; // Boid pos\n        vec2 v = A(ivec2(i, 0)).zw; // Boid vel\n        \n        float d = length(p - u.xy); // Distance from pixel to boid\n        vec3 c = 0.5 + 0.5*cos(vec3(4., 1., 2.)*float(i)*53.); // Boid color\n        bB.xyz = mix(bB.xyz, c, ss(rad*R.y, rad*R.y - 1., length(d))); // Add boid to color\n        \n        float sd2 = ss(.4*rad*R.y, .4*rad*R.y - 1., length(d));\n        bB.w = mix(bB.w, 1., sd2);\n    }\n    \n    // Leave trail\n    bB.xyz *= .8;\n    bB.w *= trail;\n    \n    f = bB;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}