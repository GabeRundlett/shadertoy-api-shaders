{
    "Shader": {
        "info": {
            "date": "1719893528",
            "description": "\"Cosmic Dance\" invites you to pause and reflect on the intricate dance of the cosmos, a reminder of the beauty that lies in the patterns of the universe.",
            "flags": 0,
            "hasliked": 0,
            "id": "MXVXzm",
            "likes": 4,
            "name": "Cosmic Dance",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "space",
                "geometry",
                "cosmic"
            ],
            "usePreview": 0,
            "username": "mr_vero",
            "viewed": 143
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n     // Normalized pixel coordinates (from 0 to 1), adjusted for -1 to 1 range\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Simulate refraction for a glass ball effect\n    float radius = 13.0; // Radius of the glass ball\n    vec2 center = vec2(0.0, 0.0); // Center of the glass ball\n    float dist = distance(uv, center); // Distance from the center\n    \n    // Refraction effect\n    if (dist < radius) {\n        float refractionIndex = 1.02; // Refraction index; adjust for stronger/weaker refraction\n        vec2 refraction = normalize(uv - center) * (1.0 - refractionIndex) * (radius - dist);\n        uv += refraction;\n    }\n   \n    float time = iTime * 0.5;\n    \n    mat4 rotationXY = mat4(cos(time), -sin(time), 0.0, 0.0,\n                           sin(time), cos(time), 0.0, 0.0,\n                           0.0, 0.0, 1.0, 0.0,\n                           0.0, 0.0, 0.0, 1.0);\n    \n    mat4 rotationZW = mat4(1.0, 0.0, 0.0, 0.0,\n                           0.0, 1.0, 0.0, 0.0,\n                           0.0, 0.0, cos(time), -sin(time),\n                           0.0, 0.0, sin(time), cos(time));\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n     // Mirror reflection effect near the sides\n    float mirrorWidth = 0.35; // Width of the mirror effect from the edges\n    float edgeDistX = min(uv.x + 1.0, 1.0 - uv.x); // Distance from the nearest horizontal edge\n    if (edgeDistX < mirrorWidth) {\n        // Reflect the uv coordinates horizontally based on proximity to the edge\n        uv.x = mix(-uv.x, uv.x, edgeDistX / mirrorWidth);\n    }\n    \n    for (int i = 0; i < 16; i++) {\n        for (int j = i + 1; j < 16; j++) {\n            // Simplified vertex calculation for demonstration\n            vec4 point1 = vec4(float(i % 4 - 2), float((i / 4) % 4 - 2), float((i / 16) % 4 - 2), float(i / 64 - 1));\n            vec4 point2 = vec4(float(j % 4 - 2), float((j / 4) % 4 - 2), float((j / 16) % 4 - 2), float(j / 64 - 1));\n            \n            point1 = rotationXY * point1;\n            point1 = rotationZW * point1;\n            point2 = rotationXY * point2;\n            point2 = rotationZW * point2;\n            \n            vec3 p3D1 = point1.xyz / (13.0 - point1.w);\n            vec3 p3D2 = point2.xyz / (13.0 - point2.w);\n            \n            vec2 p2D1 = p3D1.xy / (1.0 - p3D1.z);\n            vec2 p2D2 = p3D2.xy / (1.0 - p3D2.z);\n            \n            // Line drawing logic (simplified)\n            vec2 line = p2D2 - p2D1;\n            vec2 perpLine = vec2(-line.y, line.x);\n            float dist = abs(dot(perpLine, uv - p2D1)) / length(perpLine);\n            if(dist < 0.0005) {\n                fragColor = vec4(uv, 1.5 + 1.5 * sin(time), 1.0);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}