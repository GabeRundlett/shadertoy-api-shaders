{
    "Shader": {
        "info": {
            "date": "1719593127",
            "description": "combination originals https://www.shadertoy.com/view/Nsy3Dy",
            "flags": 0,
            "hasliked": 0,
            "id": "X3dSDj",
            "likes": 2,
            "name": " triagle box sphere if tunnel",
            "published": 3,
            "tags": [
                "fractal",
                "space",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 273
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(10,23,21))*1.5+.5)\nfloat intensity = 1.0;\nfloat radius = 0.05;\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n//Distance functions from\n//https://iquilezles.org/articles/distfunctions2d\nfloat triangleDist(vec2 p){\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat boxDist(vec2 p){\n    vec2 d = abs(p)-1.0;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circleDist( vec2 p){\n  return length(p) - 1.0;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     vec2 uv2 =C/iResolution.xy-0.5;\n    vec2 uv =C/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre;\n    vec2 pos;\n\n    float t = -iTime * 0.05;\n   \n    float dist;\n    float glow;\n    vec3 col = vec3(0);\n   \n    //The spacing between shapes\n    const float scale = 150.0;\n    //Number of shapes\n    const float layers = 10.0;\n   \n    float depth;\n    vec2 bend;\n   \n    const vec3 purple = vec3(0.611, 0.129, 0.909);\n    const vec3 green = vec3(0.133, 0.62, 0.698);\n   \n    float angle;\n    float rotationAngle;\n    mat2 rotation;\n   \n    //For movement of the anchor point in time\n    float d = 2.5*(sin(t) + sin(3.0*t));\n\n    //Create an out of frame anchor point where all shapes converge to    \n    //vec2 anchor = vec2(0.5 + cos(d), 0.5 + sin(d));\n    vec2 anchor = vec2(0.5);\n\n    //Create light purple glow at the anchor loaction\n    pos = anchor - uv;\n    pos.y /= widthHeightRatio;\n    dist = length(pos);\n    glow = getGlow(dist, 0.35, 0.9);\n    col += glow * vec3(0.2,0.2,0.20);\n   \nfor(float i = 0.0; i < layers; i++){\n       \n       \n        depth = fract(i/layers + t);\n\n        //Move the focus of the camera in a circle\n        //centre = vec2(0.5 + 0.2 * sin(t), 0.5 + 0.2 * cos(t));\n        centre = vec2(0.5);\n        //Position shapes between the anchor and the camera focus based on depth\n        bend = mix(anchor, centre, depth);\n     \n        pos = bend - uv;\n    pos.y /= widthHeightRatio;\n\n        //Rotate shapes\n        rotationAngle = 3.14 * sin(depth + fract(t) * 6.28) + i;\n        rotation = mat2(cos(rotationAngle), -sin(rotationAngle),\n                        sin(rotationAngle),  cos(rotationAngle));\n       \n        pos *= rotation;\n       \n        //Position shapes according to depth\n    pos *= mix(scale, 0.0, depth);\n   \n        float m = mod(i, 3.0);\n        if(m == 0.0){\n        dist = abs(boxDist(pos));\n        }else if(m == 1.0){\n        dist = abs(triangleDist(pos));\n        }else{\n        dist = abs(circleDist(pos));\n        }\n       \n        //Get glow from base radius and intensity modified by depth\n    glow = getGlow(dist, radius+(1.0-depth)*2.0, intensity + depth);\n       \n        //Find angle along shape and map from [-PI; PI] to [0; 1]\n        angle = (atan(pos.y, pos.x)+3.14)/6.28;\n        //Shift angle depending on layer and map to [1...0...1]\nangle = abs((2.0*fract(angle + i/layers)) - 1.0);\n       \n        //White core\n    col += 10.0*vec3(smoothstep(0.03, 0.02, dist));\n       \n        //Glow according to angle value\n      col += glow * mix(green, purple, angle);\n}\n   \n    //Tone mapping\n    col = 1.0 - exp(-col);\n   \n    vec4 p;\n    vec3 q,r=iResolution,\n    d2=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        p.xyz=g*d2*col;\n      p.z+=iTime*10.;\n        a=30.;\n        p=mod(p-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            p.z<p.w?p=p.zyxw:p;\n            p.z<p.y?p=p.xzyw:p;\n                    p.z<p.y?p=p.xzyw:p;\n            s*=e=1.4+sin(iTime*.1)*.1;\n            p.xyz=abs(p.xyz)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n    }\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n   O*= vec4(happy_star(uv2, anim) * vec3(0.05,0.2,1.15)*5.1, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}