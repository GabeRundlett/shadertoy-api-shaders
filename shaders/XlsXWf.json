{
    "Shader": {
        "info": {
            "date": "1575957815",
            "description": "Basic raymarch",
            "flags": 0,
            "hasliked": 0,
            "id": "XlsXWf",
            "likes": 2,
            "name": "Raymarching Cube",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "EvilTak",
            "viewed": 383
        },
        "renderpass": [
            {
                "code": "const int kRaySteps = 50;\nconst vec3 kAmbient = vec3(0.2, 0.2, 0.2);\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane(vec3 p)\n{\n    \n  return p.y;\n}\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(5.*p.y);\n    float s = sin(5.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdBox(q, vec3(.25));\n}\n\n// Distance to closest scene hit\nfloat map(vec3 pos)\n{\n\tfloat dist = opU(sdSphere(pos + vec3(-1., -0.625, -.5), 0.25), sdPlane(pos));\n    dist = opU(dist, sdTriPrism(pos + vec3(0., -0.125, 0.), vec2(0.25)));\n    return dist;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float epsilon = 0.001;\n\tvec2 t = vec2(0.0, epsilon);\nreturn normalize(vec3(map(pos + t.yxx) - map(pos - t.yxx),\n           \t  map(pos + t.xyx) - map(pos - t.xyx),\n              map(pos + t.xxy) - map(pos - t.xxy)));\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<kRaySteps; i++ )\n    {\n        float h = map(ro + rd*t);\n        {\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, 48.*h/t );\n        }\n        t += h;\n        if(t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n// Uses map function (smallest distance to scene) for\n// approximating normal at pos\nvec3 lighting(vec3 pos, vec3 lightDir)\n{\n    vec3 n =getNormal(pos);\n    return vec3(1.0) * max(0.,dot(n, lightDir)) * softshadow(pos, lightDir,0.02, 50.) + kAmbient;\n}\n\nfloat repeat(float t, float min, float max) \n{\n    float diff = max - min;\n    float d = t / diff;\n    return fract(d) * diff + min;\n}\n\nvec3 getColor(vec3 rayPos, vec3 rayDir)\n{\n    vec3 color;\n    vec3 bg = vec3(0.5, 0.6, 1.);\n    \n    color = bg;\n    for (int i = 0; i < kRaySteps; ++i)\n    {\n    \tfloat d = map(rayPos);\n        rayPos += d * rayDir;\n        if (d < 0.001)\n        {\n        \tcolor = lighting(rayPos, normalize(vec3(sin(iTime / 2.) + 0.1, 0.1, 0.2)));\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    // Make uv go [-0.5, 0.5] and scale uv.x according to aspect ratio\n    uv -= .5;\n    uv.x = aspect * uv.x;\n    \n    // Initialize camera stuff\n    vec3 camPos = vec3(1.5);//vec3(cos(iTime), 01., sin(iTime));\n    vec3 camTarget = vec3(0., 0., 0.);\n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = normalize(cross(camDir, camRight));\n    \n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    // Raymarch scene to get pixel color\n    vec3 color = getColor(rayPos, rayDir);\n    \n    // Set pixel color\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}