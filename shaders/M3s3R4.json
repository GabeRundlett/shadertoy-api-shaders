{
    "Shader": {
        "info": {
            "date": "1707220033",
            "description": "Ray tracing, Monte Carlo Global Illumination, PBR materials, HDR and Gamma Correction. \nReminder: one bounce only considered for a better performance.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3s3R4",
            "likes": 1,
            "name": "raytracingGI",
            "published": 3,
            "tags": [
                "raytracing",
                "gi",
                "pbrmaterials"
            ],
            "usePreview": 1,
            "username": "MorcilloSanz",
            "viewed": 224
        },
        "renderpass": [
            {
                "code": "\n/*\n    MIT License\n    \n    Copyright (c) 2024 MorcilloSanz\n    \n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n    \n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n    \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n\n    Basic ray tracing and global ilumination in GLSL.\n    One bounce only considered for a better performance.\n*/\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// Constants\n#define M_PI 3.1415926535897932384626433832795\n#define INF 999999999999.0;\n\n#define MAX_SPHERES 4\n#define SHADOW_INTENSITY 0.40\n\n#define FLOOR vec3(0.15, 0.15, 0.1)\n#define SKY vec3(0.1, 0.1, 1.0)\n\n// PBR, Ray Tracing and Global Ilumination\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emission;\n};\n\nstruct Sphere {\n    vec3 origin;\n    float radius;\n    Material material;\n};\n\nstruct HitInfo {\n    vec3 intersection;\n    vec3 normal;\n    float dist;\n    Material material;\n    bool hit;\n};\n\nSphere spheres[MAX_SPHERES];\n\nvec3 evaluate(Ray ray, float lambda) {\n    return ray.origin + lambda * ray.direction;\n}\n\nHitInfo intersection(Ray ray, Sphere sphere) {\n    \n    HitInfo hitInfo;\n    \n    vec3 oc = ray.origin - sphere.origin;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc, oc) - (sphere.radius * sphere.radius);\n    \n    float nabla = b * b - 4.0 * a * c;\n    \n    if (nabla > 0.0) {\n        \n        float lambda1 = (-b - sqrt(nabla)) / (2.0 * a);\n        float lambda2 = (-b + sqrt(nabla)) / (2.0 * a);\n        float lambda = min(lambda1, lambda2);\n        \n        if (lambda > 0.0) {\n            hitInfo.intersection = evaluate(ray, lambda);\n            hitInfo.normal = normalize(hitInfo.intersection - sphere.origin);\n            hitInfo.dist = lambda;\n            hitInfo.material = sphere.material;\n            hitInfo.hit = true;\n            return hitInfo;\n        }\n    }\n    \n    hitInfo.hit = false;\n    \n    return hitInfo;\n}\n\nHitInfo getHitInfo(Ray ray) {\n    \n    HitInfo hitInfo;\n    hitInfo.dist = INF;\n    \n    for(int i = 0; i < MAX_SPHERES; i ++) {\n        \n        Sphere sphere = spheres[i];\n        \n        HitInfo currentHitInfo = intersection(ray, sphere);\n    \n        if(currentHitInfo.hit && currentHitInfo.dist < hitInfo.dist)\n            hitInfo = currentHitInfo;\n    }\n    \n    return hitInfo;\n}\n\nbool shadow(HitInfo hitInfo, Sphere sun) {\n    \n    Ray ray;\n    ray.origin = hitInfo.intersection;\n    ray.direction = sun.origin - hitInfo.intersection;\n    \n    HitInfo hitInfoAux = getHitInfo(ray);\n    \n    return hitInfoAux.hit && dot(normalize(sun.origin), hitInfo.normal) > 0.0;\n}\n\n\nfloat distributionGGX(vec3 N, vec3 H, float roughness) {\n\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = geometrySchlickGGX(NdotV, roughness);\n    float ggx1 = geometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nvec3 specularCookTorrance(HitInfo hitInfo, vec3 H, vec3 wo, vec3 wi, vec3 F) {\n    \n    float NDF = distributionGGX(hitInfo.normal, H, hitInfo.material.roughness);   \n    float G = geometrySmith(hitInfo.normal, wo, wi, hitInfo.material.roughness);      \n    \n    vec3 numerator = NDF * G * F; \n    float denominator = 4.0 * dot(hitInfo.normal, wo) * dot(hitInfo.normal, wi) + 0.0001; // + 0.0001 to prevent divide by zero\n    vec3 specular = numerator / denominator;\n    \n    return specular;\n}\n\nvec3 getSky(float rate) {\n    \n    vec3 skyColor = mix(FLOOR, SKY, rate);\n    return skyColor / (skyColor + vec3(1.0));\n}\n\nfloat rand(vec2 co) {\n\n    highp float noise = fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n    return noise * 2.0 - 1.0;\n}\n\nfloat blueNoise(float index, vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    const float SQRT_NUM_SAMPLES = 300.0;\n    const float NUM_SAMPLES = SQRT_NUM_SAMPLES * SQRT_NUM_SAMPLES;\n\n    vec2 cellIndex = floor(uv * SQRT_NUM_SAMPLES);\n\n    float sampleIndex = mod((index * 1.0), NUM_SAMPLES);\n    vec2 jitter = vec2(rand(vec2(sampleIndex, 0.0)), rand(vec2(sampleIndex, 1.0))) / SQRT_NUM_SAMPLES;\n\n    vec2 sampleUV = (cellIndex + 0.5 + jitter) / SQRT_NUM_SAMPLES;\n    return rand(sampleUV);\n}\n\nvec3 computeIndirectLighting(vec3 wo, HitInfo hitInfo, Sphere sunSphere, in vec2 fragCoord) {\n    \n    wo = -normalize(wo);\n    vec3 lo = vec3(0.0);\n    \n    const int samples = 100;\n    for(int i = 0; i < samples; i ++) {\n        \n        vec3 loPrime = vec3(0.0);\n        \n        // Calculate direction \n        vec3 specularDir = reflect(wo, hitInfo.normal);\n        vec3 diffuseDir = specularDir + vec3(blueNoise(float(i), fragCoord));\n        \n        vec3 wi = mix(diffuseDir, specularDir, 1.0 - hitInfo.material.roughness);\n        wi = normalize(wi);\n        \n        Ray ray;\n        ray.origin = hitInfo.intersection;\n        ray.direction = wi;\n\n        vec3 H = normalize(wi + wo);\n        \n        // Reflactance\n        vec3 F0 = vec3(0.04); \n        F0 = mix(F0, hitInfo.material.albedo, hitInfo.material.metallic);\n        vec3 F = fresnelSchlick(max(dot(H, wo), 0.0), F0);\n        \n        // Shadow\n        bool isShadow = shadow(hitInfo, sunSphere);\n        \n        // Diffuse\n        vec3 fLambert = hitInfo.material.albedo / M_PI;\n\n        // Specular\n        vec3 specular = specularCookTorrance(hitInfo, H, wo, wi, F);\n        if(isShadow) specular = vec3(0.0);\n        \n        // Energy ratios\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        \n        vec3 fr = kD * fLambert + specular;\n        \n        HitInfo hitInfo2 = getHitInfo(ray);\n        \n        // If hit sphere, get radiance from sphere\n        if(hitInfo2.hit) {\n        \n            // Normalize colors for energy conservation. HDR (Reinhard tone mapping)\n            hitInfo2.material.albedo /= (hitInfo2.material.albedo + vec3(1.0));\n            hitInfo2.material.emission /= (hitInfo2.material.emission + vec3(1.0));\n\n            // li is the output lo from the new sphere (sphere_i)\n            vec3 li = vec3(0.0);\n            vec3 wo2 = wi;\n            vec3 wi2 = normalize(sunSphere.origin);\n            vec3 H2 = normalize(wi2 + wo2);\n            \n            // Reflactance\n            vec3 F02 = vec3(0.04); \n            F02 = mix(F02, hitInfo2.material.albedo, hitInfo2.material.metallic);\n            vec3 F2 = fresnelSchlick(max(dot(H2, wo2), 0.0), F02);\n            \n            // Shadow\n            bool isShadowLi = shadow(hitInfo2, sunSphere);\n            \n            // Diffuse\n            vec3 fLambert2 = hitInfo2.material.albedo / M_PI;\n            \n            // Specular\n            vec3 specular2 = specularCookTorrance(hitInfo2, H2, wo2, wi2, F2);\n            if(isShadowLi) specular2 = vec3(0.0);\n            \n            // Energy ratios\n            vec3 kS2 = F2;\n            vec3 kD2 = vec3(1.0) - kS2;\n            \n            // Rendering equation\n            vec3 li2 = sunSphere.material.emission;\n            vec3 fr2 = kD2 * fLambert2 + specular2;\n            li = hitInfo2.material.emission + fr2 * li2 * max(dot(wi2, hitInfo2.normal), 0.0);\n\n            // Shadows\n            if(isShadowLi)\n                li *= (1.0 - SHADOW_INTENSITY);\n            \n            // Rendering equation (le is already considered in direct lighting)\n            loPrime = fr * li * max(dot(wi, hitInfo.normal), 0.0);\n            \n            // Shadows\n            if(isShadow)\n                loPrime *= (1.0 - SHADOW_INTENSITY);\n                \n        }\n        \n        // If not hit sphere, hit radiance from sky\n        else {\n            float verticallity = 1.0 - normalize(dot(wi, vec3(0.0, -1.0, 0.0)));\n            float rate = verticallity;\n            \n            vec3 li = getSky(rate);\n            loPrime = fr * li * max(dot(wi, hitInfo.normal), 0.0);\n        }\n\n        lo += loPrime;\n    }\n    \n    return 2.0 * M_PI * lo / float(samples);\n}\n\n\nvoid initSpheres() {\n    \n    // Sphere 1\n    Material material1;\n    material1.albedo = vec3(0.1, 0.1, 4.0);\n    material1.metallic = 0.0;\n    material1.roughness = 0.5;\n    material1.emission = vec3(0.0);\n    \n    Sphere sphere1;\n    sphere1.origin = vec3(0.0, -0.15, -2.5);\n    sphere1.radius = 0.45;\n    sphere1.material = material1;\n    \n    // Sphere 2\n    Material material2;\n    material2.albedo = vec3(3.0, 0.1, 0.15);\n    material2.metallic = 0.0;\n    material2.roughness = 0.1;\n    material2.emission = vec3(0.0);\n    \n    Sphere sphere2;\n    sphere2.origin = vec3(0.55, 0.0, -4.0);\n    sphere2.radius = 0.45;\n    sphere2.material = material2;\n    \n    // Sphere 3\n    Material material3;\n    material3.albedo = vec3(0.1, 1.0, 0.15);\n    material3.metallic = 0.0;\n    material3.roughness = 1.0;\n    material3.emission = vec3(0.0);\n    \n    Sphere sphere3;\n    sphere3.origin = vec3(-0.55, 0.0, -4.0);\n    sphere3.radius = 0.45;\n    sphere3.material = material3;\n    \n    // Sphere 4\n    Material material4;\n    material4.albedo = vec3(0.5);\n    material4.metallic = 1.0;\n    material4.roughness = 0.1;\n    material4.emission = vec3(0.0);\n    \n    Sphere sphere4;\n    sphere4.origin = vec3(0.0, 0.65, -4.5);\n    sphere4.radius = 0.25;\n    sphere4.material = material4;\n    \n    // Add spheres\n    spheres[0] = sphere1;\n    spheres[1] = sphere2;\n    spheres[2] = sphere3;\n    spheres[3] = sphere4;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Init spheres\n    initSpheres();\n    \n    // Cast ray\n    Ray ray;\n    ray.origin = vec3(( 2.*fragCoord - iResolution.xy ) / iResolution.y, 0.);\n    ray.direction = vec3(0.0, 0.0, -1.0);\n    \n    // Sun\n    float w = 0.85;\n    float t = iTime;\n    float r = 5.0;\n    \n    Material sunMaterial;\n    sunMaterial.albedo = vec3(0.0);\n    sunMaterial.roughness = 0.0;\n    sunMaterial.metallic = 0.0;\n    sunMaterial.emission = vec3(8.0);\n    \n    Sphere sunSphere;\n    sunSphere.origin = vec3(r * sin(w * t), 0.85, r * cos(w * t));\n    sunSphere.radius = 0.25;\n    sunSphere.material = sunMaterial;\n    \n    // Draw spheres\n    HitInfo hitInfoSun = intersection(ray, sunSphere);\n    HitInfo hitInfo = getHitInfo(ray);\n    \n    if(hitInfoSun.hit && hitInfoSun.dist < hitInfo.dist)\n        hitInfo = hitInfoSun;\n    \n    // Sky color\n    vec3 lo = getSky(fragCoord.y / iResolution.y);\n\n    // Compute lighting\n    vec3 wo = -normalize(ray.direction);\n    vec3 wi = normalize(sunSphere.origin);\n    \n    vec3 H = normalize(wi + wo);\n\n    if(hitInfo.hit) {\n    \n        // Normalize colors for energy conservation. HDR (Reinhard tone mapping)\n        hitInfo.material.albedo /= (hitInfo.material.albedo + vec3(1.0));\n        hitInfo.material.emission /= (hitInfo.material.emission + vec3(1.0));\n        \n        // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 \n        // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)  \n        vec3 F0 = vec3(0.04); \n        F0 = mix(F0, hitInfo.material.albedo, hitInfo.material.metallic);\n        vec3 F    = fresnelSchlick(max(dot(H, wo), 0.0), F0);\n        \n        // Shadow\n        bool isShadow = shadow(hitInfo, sunSphere);\n        \n        // Diffuse\n        vec3 fLambert = hitInfo.material.albedo / M_PI;\n        \n        // Specular\n        vec3 specular = specularCookTorrance(hitInfo, H, wo, wi, F);\n        if(isShadow) specular = vec3(0.0);\n        \n        // Energy ratios\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        \n        // Direct lighting\n        vec3 li = sunSphere.material.emission;\n        vec3 fr = kD * fLambert + specular;\n        vec3 directLighting = hitInfo.material.emission + fr * li * max(dot(wi, hitInfo.normal), 0.0);\n        \n        // Indirect lighting\n        vec3 indirectLighting = computeIndirectLighting(wo, hitInfo, sunSphere, fragCoord);\n        \n        // Lighting\n        lo = directLighting + indirectLighting;\n        \n        // Shadows\n        if(isShadow) \n            lo *= (1.0 - SHADOW_INTENSITY);\n    }\n    \n    // Gamma correction\n    float gamma = 2.2;\n    float power = 1.0 / gamma;\n    \n    lo = vec3(pow(lo.x, power), pow(lo.y, power), pow(lo.z, power));\n    \n    // Output color    \n    fragColor = vec4(lo, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}