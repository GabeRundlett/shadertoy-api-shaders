{
    "Shader": {
        "info": {
            "date": "1596620321",
            "description": "Replicated the post effect antialiasing from nvidia docs and catlikecoding example.\nLeft side is with antialiasing and right side is without.",
            "flags": 32,
            "hasliked": 0,
            "id": "WtsfDH",
            "likes": 8,
            "name": "FXAA antialiasing",
            "published": 3,
            "tags": [
                "posteffect",
                "posteffect",
                "antialiasing",
                "antialiasing"
            ],
            "usePreview": 0,
            "username": "mystery",
            "viewed": 1059
        },
        "renderpass": [
            {
                "code": "// FXAA by Dave Hoskins, FXAA algorithm from NVIDIA\n// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n// https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/\n\n#define EDGE_STEP_COUNT 10\n#define EDGE_GUESS 8.0f\n#define EDGE_STEPS 1.0f, 1.5f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 4.0f\nconst float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );\n\nfloat _ContrastThreshold = 0.0312f;\nfloat _RelativeThreshold = 0.063f;\nfloat _SubpixelBlending = 1.0f;\n\nvec4 Sample (sampler2D  tex2D, vec2 uv) {\n\treturn texture(tex2D, uv);\n}\n\nfloat SampleLuminance (sampler2D tex2D, vec2 uv) {\t\t\t\n\treturn dot(Sample(tex2D, uv).rgb, vec3(0.3f, 0.59f, 0.11f));\n}\n\nfloat SampleLuminance (sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset) {\n\tuv += texSize * vec2(uOffset, vOffset);\n\treturn SampleLuminance(tex2D, uv);\n}\n\nstruct LuminanceData {\n\tfloat m, n, e, s, w;\n\tfloat ne, nw, se, sw;\n\tfloat highest, lowest, contrast;\n};\n\nLuminanceData SampleLuminanceNeighborhood (sampler2D tex2D, vec2 texSize, vec2 uv) {\n\tLuminanceData l;\n\tl.m = SampleLuminance(tex2D, uv);\n\tl.n = SampleLuminance(tex2D, texSize, uv,  0.0f,  1.0f);\n\tl.e = SampleLuminance(tex2D, texSize, uv,  1.0f,  0.0f);\n\tl.s = SampleLuminance(tex2D, texSize, uv,  0.0f, -1.0f);\n\tl.w = SampleLuminance(tex2D, texSize, uv, -1.0f,  0.0f);\n\n\tl.ne = SampleLuminance(tex2D, texSize, uv,  1.0f,  1.0f);\n\tl.nw = SampleLuminance(tex2D, texSize, uv, -1.0f,  1.0f);\n\tl.se = SampleLuminance(tex2D, texSize, uv,  1.0f, -1.0f);\n\tl.sw = SampleLuminance(tex2D, texSize, uv, -1.0f, -1.0f);\n\n\tl.highest = max(max(max(max(l.n, l.e), l.s), l.w), l.m);\n\tl.lowest = min(min(min(min(l.n, l.e), l.s), l.w), l.m);\n\tl.contrast = l.highest - l.lowest;\n\treturn l;\n}\n\nbool ShouldSkipPixel (LuminanceData l) {\n\tfloat threshold =\n\t\tmax(_ContrastThreshold, _RelativeThreshold * l.highest);\n\treturn l.contrast < threshold;\n}\n\nfloat DeterminePixelBlendFactor (LuminanceData l) {\n\tfloat f = 2.0f * (l.n + l.e + l.s + l.w);\n\tf += l.ne + l.nw + l.se + l.sw;\n\tf *= 1.0f / 12.0f;\n\tf = abs(f - l.m);\n\tf = clamp(f / l.contrast, 0.0, 1.0);\n\n\tfloat blendFactor = smoothstep(0.0f, 1.0f, f);\n\treturn blendFactor * blendFactor * _SubpixelBlending;\n}\n\nstruct EdgeData {\n\tbool isHorizontal;\n\tfloat pixelStep;\n\tfloat oppositeLuminance, gradient;\n};\n\nEdgeData DetermineEdge (vec2 texSize, LuminanceData l) {\n\tEdgeData e;\n\tfloat horizontal =\n\t\tabs(l.n + l.s - 2.0f * l.m) * 2.0f +\n\t\tabs(l.ne + l.se - 2.0f * l.e) +\n\t\tabs(l.nw + l.sw - 2.0f * l.w);\n\tfloat vertical =\n\t\tabs(l.e + l.w - 2.0f * l.m) * 2.0f +\n\t\tabs(l.ne + l.nw - 2.0f * l.n) +\n\t\tabs(l.se + l.sw - 2.0f * l.s);\n\te.isHorizontal = horizontal >= vertical;\n\n\tfloat pLuminance = e.isHorizontal ? l.n : l.e;\n\tfloat nLuminance = e.isHorizontal ? l.s : l.w;\n\tfloat pGradient = abs(pLuminance - l.m);\n\tfloat nGradient = abs(nLuminance - l.m);\n\n\te.pixelStep =\n\t\te.isHorizontal ? texSize.y : texSize.x;\n\t\n\tif (pGradient < nGradient) {\n\t\te.pixelStep = -e.pixelStep;\n\t\te.oppositeLuminance = nLuminance;\n\t\te.gradient = nGradient;\n\t}\n\telse {\n\t\te.oppositeLuminance = pLuminance;\n\t\te.gradient = pGradient;\n\t}\n\n\treturn e;\n}\n\nfloat DetermineEdgeBlendFactor (sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv) {\n\tvec2 uvEdge = uv;\n\tvec2 edgeStep;\n\tif (e.isHorizontal) {\n\t\tuvEdge.y += e.pixelStep * 0.5f;\n\t\tedgeStep = vec2(texSize.x, 0.0f);\n\t}\n\telse {\n\t\tuvEdge.x += e.pixelStep * 0.5f;\n\t\tedgeStep = vec2(0.0f, texSize.y);\n\t}\n\n\tfloat edgeLuminance = (l.m + e.oppositeLuminance) * 0.5f;\n\tfloat gradientThreshold = e.gradient * 0.25f;\n\n\tvec2 puv = uvEdge + edgeStep * edgeSteps[0];\n\tfloat pLuminanceDelta = SampleLuminance(tex2D, puv) - edgeLuminance;\n\tbool pAtEnd = abs(pLuminanceDelta) >= gradientThreshold;\n\n\tfor (int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++) {\n\t\tpuv += edgeStep * edgeSteps[i];\n\t\tpLuminanceDelta = SampleLuminance(tex2D, puv) - edgeLuminance;\n\t\tpAtEnd = abs(pLuminanceDelta) >= gradientThreshold;\n\t}\n\tif (!pAtEnd) {\n\t\tpuv += edgeStep * EDGE_GUESS;\n\t}\n\n\tvec2 nuv = uvEdge - edgeStep * edgeSteps[0];\n\tfloat nLuminanceDelta = SampleLuminance(tex2D, nuv) - edgeLuminance;\n\tbool nAtEnd = abs(nLuminanceDelta) >= gradientThreshold;\n\n\tfor (int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++) {\n\t\tnuv -= edgeStep * edgeSteps[i];\n\t\tnLuminanceDelta = SampleLuminance(tex2D, nuv) - edgeLuminance;\n\t\tnAtEnd = abs(nLuminanceDelta) >= gradientThreshold;\n\t}\n\tif (!nAtEnd) {\n\t\tnuv -= edgeStep * EDGE_GUESS;\n\t}\n\n\tfloat pDistance, nDistance;\n\tif (e.isHorizontal) {\n\t\tpDistance = puv.x - uv.x;\n\t\tnDistance = uv.x - nuv.x;\n\t}\n\telse {\n\t\tpDistance = puv.y - uv.y;\n\t\tnDistance = uv.y - nuv.y;\n\t}\n\n\tfloat shortestDistance;\n\tbool deltaSign;\n\tif (pDistance <= nDistance) {\n\t\tshortestDistance = pDistance;\n\t\tdeltaSign = pLuminanceDelta >= 0.0f;\n\t}\n\telse {\n\t\tshortestDistance = nDistance;\n\t\tdeltaSign = nLuminanceDelta >= 0.0f;\n\t}\n\n\tif (deltaSign == (l.m - edgeLuminance >= 0.0f)) {\n\t\treturn 0.0f;\n\t}\n\treturn 0.5f - shortestDistance / (pDistance + nDistance);\n}\n\nvec4 ApplyFXAA (sampler2D  tex2D, vec2 texSize, vec2 uv) {\n\tLuminanceData l = SampleLuminanceNeighborhood(tex2D, texSize, uv);\n\tif (ShouldSkipPixel(l)) {\n\t\treturn Sample(tex2D, uv);\n\t}\n\n\tfloat pixelBlend = DeterminePixelBlendFactor(l);\n\tEdgeData e = DetermineEdge(texSize, l);\n\tfloat edgeBlend = DetermineEdgeBlendFactor(tex2D, texSize, l, e, uv);\n\tfloat finalBlend = max(pixelBlend, edgeBlend);\n\n\tif (e.isHorizontal) {\n\t\tuv.y += e.pixelStep * finalBlend;\n\t}\n\telse {\n\t\tuv.x += e.pixelStep * finalBlend;\n\t}\n\treturn vec4(Sample(tex2D, uv).rgb, l.m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texSize = 1.0f/iResolution.xy;\n    float t = 0.5f + sin(iTime) * 0.5;\n    if(uv.x < t) {\n    \tfragColor = ApplyFXAA(iChannel0,texSize, uv);\n    } else {\n        fragColor = texture(iChannel0, uv);\n    }\n    fragColor += step(abs(uv.x - t), texSize.x);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 NormalizeSpace(vec2 uv)\n{\n    return (uv - 0.5 * iResolution.xy) / iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvTex = fragCoord/iResolution.xy;\n    vec2 uv = NormalizeSpace(fragCoord);\n    float c = step(length(uv), 0.25);\n    fragColor = vec4(c, c, c, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}