{
    "Shader": {
        "info": {
            "date": "1713051492",
            "description": "Click-drag to control bulge.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfyGRc",
            "likes": 4,
            "name": "Wiggle Grid",
            "published": 3,
            "tags": [
                "2d",
                "mouse",
                "grid",
                "random",
                "curve",
                "bulge"
            ],
            "usePreview": 0,
            "username": "milkfat",
            "viewed": 125
        },
        "renderpass": [
            {
                "code": "#define CELL_SIZE 22.0\n#define LINE_WIDTH 5.0\n#define LINE_CURVE 5.0\n//#define DEBUG\n\nfloat smix(float m, float p) {\n    float r = mix(int(p));\n    float a = m + .1;\n    \n    return sin(r * 6.28 + iTime*3.10*r)*.15*a + .5;\n}\n\nfloat sdist(vec2 p, vec2 l0, vec2 l1) {\n    vec2 v1 = l1 - l0;\n    vec2 v2 = l0 - p;\n    vec2 v3 = vec2(v1.y,-v1.x);\n    return dot(v2,normalize(v3));;\n}\n\n\nfloat dist(vec2 p, vec2 l0, vec2 l1) {\n    return abs(sdist(p, l0, l1));\n}\n\nfloat calc(vec2 coord) {\n    \n    \n    //mouse effect, 1.0 = max effect, 0.0 = unaffected\n    vec2 bulge = vec2(-1000,-1000);\n    \n    bulge = vec2(sin(iTime*.2),cos(iTime*.383));\n    bulge *= vec2(iResolution.x,iResolution.y)*2.0;\n    bulge += vec2(iResolution.x,iResolution.y)*.5;\n    if(bulge.x - coord.x > iResolution.x) bulge.x -= iResolution.x*2.0;\n    if(bulge.x - coord.x < -iResolution.x) bulge.x += iResolution.x*2.0;\n    if(bulge.y - coord.y > iResolution.y) bulge.y -= iResolution.y*2.0;\n    if(bulge.y - coord.y < -iResolution.y) bulge.y += iResolution.y*2.0;\n\n    \n    bulge = float(iMouse.z < 0.5) * bulge + float(iMouse.z > 0.5) * iMouse.xy;\n    \n    float m = clamp(distance(coord,bulge)/(iResolution.x*.3),0.0,1.0);\n    m = smoothstep(0.0,1.0,m);\n    m = smoothstep(0.0,1.0,m);\n    \n    #ifdef DEBUG\n    m = 1.0;\n    #endif\n    \n    //mouse magnify\n    float d = 1.0 - m;\n    d *= .4;\n    d*=sin(iTime*.5)*.2+.6;\n    vec2 c = coord - bulge;\n    c*=d;\n    coord-=c;\n  \n    \n    vec2 fcoord = floor(coord/CELL_SIZE);\n    vec2 ccoord = ceil(coord/CELL_SIZE);\n    vec2 mcoord = vec2(mod(coord,CELL_SIZE));\n    \n    //calculate a pseudo random coordinate for each side of a cell\n    vec2 t2 = vec2(smix(m,fcoord.x + (ccoord.y+1.0)*10000.0)*CELL_SIZE, CELL_SIZE*2.0);\n    vec2 t =  vec2(smix(m,fcoord.x + ccoord.y*10000.0)*CELL_SIZE,       CELL_SIZE);\n    vec2 b =  vec2(smix(m,fcoord.x + fcoord.y*10000.0)*CELL_SIZE,       0);\n    vec2 b2 = vec2(smix(m,fcoord.x + (fcoord.y-1.0)*10000.0)*CELL_SIZE, -CELL_SIZE);\n    vec2 l2 = vec2(-CELL_SIZE,                                        smix(m, (fcoord.x-1.0) + fcoord.y*20000.0)*CELL_SIZE);\n    vec2 l =  vec2(0,                                                 smix(m, fcoord.x + fcoord.y*20000.0)*CELL_SIZE);\n    vec2 r =  vec2(CELL_SIZE,                                         smix(m, ccoord.x + fcoord.y*20000.0)*CELL_SIZE);\n    vec2 r2 = vec2(CELL_SIZE*2.0,                                     smix(m, (ccoord.x+1.0) + fcoord.y*20000.0)*CELL_SIZE);\n    \n    //our position within a cell 0.0-1.0 for x and y\n    vec2 ratio = 1.0 - mcoord/CELL_SIZE;\n    \n    ratio = clamp(ratio,0.0,1.0);\n    ratio = smoothstep(0.0,1.0,ratio);\n     \n    //verticle squiggles\n    //smooth blending between this cell and the appropriate neighboring cell\n    float bri1 = clamp((LINE_WIDTH - abs(sdist(mcoord, b, b+(t-b2))*ratio.y + sdist(mcoord, t, t+(t2-b))*(1.0-ratio.y)))/LINE_CURVE, 0.0, 1.0);\n    //horizontal squiggles\n    float bri2 = clamp((LINE_WIDTH - abs(sdist(mcoord, l, l+(r-l2))*ratio.x + sdist(mcoord, r, r+(r2-l))*(1.0-ratio.x)))/LINE_CURVE, 0.0, 1.0);\n    \n    bri1 = smoothstep(0.0,1.0,bri1);\n    bri2 = smoothstep(0.0,1.0,bri2);\n    \n    //sRGB to linear\n    bri1 = pow(bri1, 2.2);\n    bri2 = pow(bri2, 2.2);\n    \n    //add colors\n    float bri = max(bri1,bri2);\n    \n    #ifdef DEBUG\n    //draw points\n    bri = max(bri,1.0-clamp(length(mcoord-t)/10.0, 0.0, 1.0));\n    bri = max(bri,1.0-clamp(length(mcoord-b)/10.0, 0.0, 1.0));\n    bri = max(bri,1.0-clamp(length(mcoord-l)/10.0, 0.0, 1.0));\n    bri = max(bri,1.0-clamp(length(mcoord-r)/10.0, 0.0, 1.0));\n    #endif\n    //linear to sRGB\n    bri = pow(bri, 1.0/2.2);\n    \n    return bri;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //4x MSAA\n    float p  = calc(fragCoord);\n    float pd = calc(fragCoord + vec2(.5,.5));\n    float pb = calc(fragCoord + vec2(0,.5));\n    float pl = calc(fragCoord + vec2(.5,0));\n    float bri = p + pd + pb + pl;\n    bri /= 4.0;\n    \n    //add some lighting\n    float light = (1.0-abs((pb - p)-.1)) * (1.0-abs((pl - p)-.1));\n    light *= light;\n    light *= light;\n    bri = (bri>.2) ? light : bri*5.0*light;\n    \n    \n    \n    fragColor = vec4(bri,bri,bri,1.0);\n    \n    \n    #ifdef DEBUG\n    vec2 mcoord = vec2(mod(fragCoord-.5,CELL_SIZE));\n    if (abs(mcoord.x) < 2.0) fragColor.r = 1.0;\n    if (abs(mcoord.y) < 2.0) fragColor.g = 1.0;\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float mix(int p) {\n    uint b = uint(p);\n\tb += 0x9e3779b9u;\n\tb ^= b >> 15;\n\tb *= 0x85ebca6bu;\n\tb ^= b >> 13;\n\tb *= 0xc2b2ae3du;\n\tb ^= b >> 16;\n\treturn fract(abs(float(b)/1000000.0));\n}\n\nfloat mix(float p) {\n    return mix(int(p));\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}