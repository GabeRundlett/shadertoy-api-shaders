{
    "Shader": {
        "info": {
            "date": "1538956028",
            "description": "Hologram/iridescence effect on a ray marched cube. \nIridescence effect is based off of this awesome post by MinionsArt: https://www.patreon.com/posts/quick-game-art-15466787\nUse mouse to add extra rotation",
            "flags": 0,
            "hasliked": 0,
            "id": "XlcBR7",
            "likes": 36,
            "name": "Hologram/Iridescence Raymarching",
            "published": 3,
            "tags": [
                "raymarching",
                "iridescence",
                "hologram"
            ],
            "usePreview": 1,
            "username": "Aj_",
            "viewed": 4282
        },
        "renderpass": [
            {
                "code": "\nconst float iridStrength = 0.5;\nconst float iridSaturation = 0.7;\nconst float fresnelStrength = 3.;\nconst vec3 lightCol = vec3(.02, .7, .02);\n\nvec2 mouse;\n#define MRX(X) mat3(1., 0., 0. ,0., cos(X), -sin(X) ,0., sin(X), cos(X))\t//x axis rotation matrix\n#define MRY(X) mat3(cos(X), 0., sin(X),0., 1., 0.,-sin(X), 0., cos(X))\t//y axis rotation matrix\t\n#define MRZ(X) mat3(cos(X), -sin(X), 0.\t,sin(X), cos(X), 0.\t,0., 0., 1.)\t//z axis rotation matrix\n#define MRF(X,Y,Z) MRZ(Z)*MRY(Y)*MRX(X)\t//x,y,z combined rotation macro\n#define ROT MRF(iTime * .1 + mouse.y, iTime * .2 + mouse.x, iTime * .3)\nconst int iter = 256;\nconst float far = 1000.;\n#define EPSILON 0.00001\n\n//iq's signed-box distance function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxR(vec3 p, vec3 b) {\n    p = p * ROT;\n    return sdBox(p, b);\n}\n\nvec3 normalBoxR(vec3 p, vec3 b) {\n     float dx = sdBoxR(vec3(p.x + EPSILON, p.y, p.z), b) - sdBoxR(vec3(p.x - EPSILON, p.y, p.z), b);\n    float dy = sdBoxR(vec3(p.x, p.y + EPSILON, p.z), b) - sdBoxR(vec3(p.x, p.y - EPSILON, p.z), b);\n    float dz = sdBoxR(vec3(p.x, p.y, p.z + EPSILON), b) - sdBoxR(vec3(p.x, p.y, p.z - EPSILON), b);\n    return vec3(dx, dy, dz);\n}\n\n\n\nvec3 normalBox(vec3 p, vec3 b) {\n    float dx = sdBox(vec3(p.x + EPSILON, p.y, p.z), b) - sdBox(vec3(p.x - EPSILON, p.y, p.z), b);\n    float dy = sdBox(vec3(p.x, p.y + EPSILON, p.z), b) - sdBox(vec3(p.x, p.y - EPSILON, p.z), b);\n    float dz = sdBox(vec3(p.x, p.y, p.z + EPSILON), b) - sdBox(vec3(p.x, p.y, p.z - EPSILON), b);\n    return vec3(dx, dy, dz);\n}\n\n\n//Color palette function taken from iq's shader @ https://www.shadertoy.com/view/ll2GD3\n#define  pal(t) ( .5 + .5* cos( 6.283*( t + vec4(0,1,2,0)/3.) ) )\n\n//rgb to grey scale\nvec3 greyScale(vec3 color, float lerpVal) {\n    \n    float greyCol = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n    vec3 grey = vec3(greyCol, greyCol, greyCol);\n    vec3 newColor = mix(color, grey, lerpVal);\n    return newColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mouse = iMouse.xy/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    uv.x*= iResolution.x/iResolution.y;\n    uv*=5.;\n\n    vec3 camPos = vec3(0., 0., -20.);\n    vec3 screen = vec3(uv.x, uv.y, -5.);\n    vec3 rayDir = normalize(screen - camPos);\n    \n    vec3 box = vec3(2. , 2., 2.);\n    \n    float depth = 0.;\n   \n    for(int i=0;i<iter;i++) {\n        vec3 tpc = camPos + rayDir * depth;\n        tpc = tpc*ROT;\n        float distc = sdBox(tpc, box);\n        if(distc < EPSILON){\n            break;\n        }        \n        if(depth > far) {            \n            break;\n        }\n        depth+=distc;\n    }\n    \n    vec3 p = camPos + rayDir * depth;\n    vec3 pc = camPos + rayDir * depth;\n    vec3 rpc = pc*ROT;\n    float c = sdBox(rpc, box);\n    vec3 nc = normalize(normalBox(rpc, box));\n    vec3 nco = normalize(normalBoxR(pc, box)); //normal for calculating fresnel\n  \tc = smoothstep(1.,.07, c);\n    \n  \tvec3 up; \n    //calculating up and right surface vectors for texturing\n    if(abs(dot(vec3(0., 0., 1.), nc)) > 1. - EPSILON \n       || abs(dot(vec3(0., 0., -1.), nc)) > 1. - EPSILON ) \n    {\n        up = vec3(0., 1., 0.) ;\n    }\n    else \n    {\n    \tup = normalize(cross(vec3(0., 0., 1.), nc));\n    }\n    vec3 right;\n  \tif(abs(dot(up, nc)) > 1. - EPSILON \n      || abs(dot(-up, nc)) > 1. - EPSILON ) \n    {\n        right = vec3(1., 0., 0.);//* -sign(nc.y) ;\n    }\n    else \n    {\n   \t\tright = normalize(cross(nc, up));\n    }\n    vec3 rpco = (rpc - box * (up + right))/(box*2.);\n    float dRight = (dot((rpco), right));//right surface vector\n    float dUp = dot(rpco, up);//up surface vector\n    \n    //lights\n    vec3 lightPos = vec3(2., 2., -5.);\n    vec3 lightDir = normalize(-lightPos);\n    float ldc = dot(lightDir, -nc);\n    vec3 rflct = reflect(normalize(pc - lightPos), nc);\n    float spec = dot(rflct, normalize(camPos - pc));\n   \n    vec2 uvm = (abs(vec2(dRight, dUp))); //texture uv\n    vec4 tex = texture(iChannel0, uvm);\n    vec4 greyTex = vec4(greyScale(tex.rgb, 1.), 1.);\n    float fres = 1. - dot(nco, normalize(camPos - pc));\n    fres *= fresnelStrength;\n    vec4 irid = pal((c)+(fres * greyTex)) ; //iridescence    \n    vec3 col = ((.4 + .3* ldc + pow(spec, 2.) * 0.3) * lightCol) * .3 * c;\n    col += greyScale(irid.rgb , 1. - iridSaturation) * c * iridStrength;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}