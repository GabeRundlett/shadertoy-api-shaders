{
    "Shader": {
        "info": {
            "date": "1627545462",
            "description": "Revisited my original ray tracer from the beginning of the month! Speed went from 11 fps to 55 fps :)\n- Way better random in unit sphere & vector & disk\n- Unrolled the loop from `hit`\n- Removed a few conditionals. That's it!",
            "flags": 0,
            "hasliked": 0,
            "id": "7tBXDh",
            "likes": 24,
            "name": "Ray Tracing One Weekend Improved",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "chenglou",
            "viewed": 1816
        },
        "renderpass": [
            {
                "code": "//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\nconst float PI = 3.14159;\nconst float SAMPLES_PER_PIXEL = 10.;\nconst int MAX_RAY_BOUNCES = 6;\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_sphere(vec2 p) {\n    vec3 rand = hash32(p);\n    float phi = 2.0 * PI * rand.x;\n    float cosTheta = 2.0 * rand.y - 1.0;\n    float u = rand.z;\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\n\nvec3 random_in_unit_disk(vec2 p) {\n    return vec3(random_in_unit_sphere(p).xy, 0);\n}\n\nconst int material_lambertian = 0;\nconst int material_metal = 1;\nconst int material_dielectric = 2;\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float metal_fuzz;\n    float dielectric_index_of_refraction;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    float t;\n    material material;\n};\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    material material;\n};\n\nconst sphere spheres[24] = sphere[](\n  sphere(vec3( 0.0, -1000., -1.0), 1000., material(material_lambertian, vec3(0.5), 0., 0.)),\n  sphere(vec3(-4.0,    1.0, 2.),   1.0, material(material_dielectric, vec3(0), 0., 1.5)),\n  sphere(vec3( 0.0,    1.0, 0.),   1.0, material(material_metal, vec3(0.7, 0.6, 0.5), 0., 0.)),\n  sphere(vec3( 4.0,    1.0, 2.),   1.0, material(material_lambertian, vec3(0.7, 0.3, 0.3), 0., 0.)),\n  sphere(vec3(-6, 0.2, 2.8), 0.2, material(material_dielectric, vec3(0, 0, 0.2), 0., 1.5)),\n  sphere(vec3(1.6, 0.2, -0.9), 0.2, material(material_dielectric, vec3(0), 0., 1.5)),\n  sphere(vec3(-5.7, 0.2, -2.7), 0.2, material(material_lambertian, vec3(0.8, 0.3, 0.3), 0., 0.)),\n  sphere(vec3(-3.6, 0.2, -4.4), 0.2, material(material_lambertian, vec3(0.9, 0.3, 0.2), 0., 0.)),\n  sphere(vec3(0.8, 0.2, 2.3), 0.2, material(material_lambertian, vec3(0.2, 0, 0.5), 0., 0.)),\n  sphere(vec3(3.8, 0.2, 4.2), 0.2, material(material_lambertian, vec3(0.4, 0.3, 0.7), 0., 0.)),\n  sphere(vec3(-0.1, 0.2, -1.9), 0.2, material(material_lambertian, vec3(0.4, 0, 0.4), 0., 0.)),\n  sphere(vec3(-2.5, 0.2, 5.4), 0.2, material(material_metal, vec3(0.3, 0.7, 0.9), 0.3, 0.)),\n  sphere(vec3(-3.9, 0.2, -0.3), 0.2, material(material_lambertian, vec3(0.9, 0.8, 0.5), 0., 0.)),\n  sphere(vec3(-6, 0.2, 4), 0.2, material(material_lambertian, vec3(0.9, 0.9, 0.5), 0., 0.)),\n  sphere(vec3(4.4, 0.2, -0.5), 0.2, material(material_lambertian, vec3(0.5, 0.4, 0.8), 0., 0.)),\n  sphere(vec3(3.4, 0.2, 5.3), 0.2, material(material_lambertian, vec3(0.1, 0.6, 0.2), 0., 0.)),\n  sphere(vec3(4.6, 0.2, -3.8), 0.2, material(material_lambertian, vec3(0.2, 0.2, 0.2), 0., 0.)),\n  sphere(vec3(0.7, 0.2, -2.5), 0.2, material(material_metal, vec3(0, 0.2, 0.1), 0., 0.)),\n  sphere(vec3(2.4, 0.2, -4.3), 0.2, material(material_lambertian, vec3(0.8, 0.9, 0), 0., 0.)),\n  sphere(vec3(4.4, 0.2, 4.9), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0), 0., 0.)),\n  sphere(vec3(-4.7, 0.2, 4.6), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.7), 0., 0.)),\n  sphere(vec3(4.2, 0.2, -3.5), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.6), 0., 0.)),\n  sphere(vec3(-5.2, 0.2, 0.5), 0.2, material(material_lambertian, vec3(0.2, 0.7, 0.9), 0., 0.)),\n  sphere(vec3(5.7, 0.2, -0.8), 0.2, material(material_lambertian, vec3(0.3, 0, 0.7), 0., 0.))\n);\n\nvoid hit_sphere(sphere sph, ray r, inout hit_record rec, inout bool hit_anything) {\n    float closest_so_far = rec.t;\n    vec3 oc = r.origin - sph.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = half_b * half_b - a * c;\n    if (discriminant < 0.) {\n        return;\n    }\n\n    float sqrtd = sqrt(discriminant);\n\n    // Find the nearest root that lies in the acceptable range\n    float root = (-half_b - sqrtd) / a; // the t. from -b - sqrt(dis) / 2a\n    if (root < 0.001 || closest_so_far < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < 0.001 || closest_so_far < root) {\n            return;\n        }\n    }\n\n    hit_anything = true;\n    vec3 p = r.origin + r.dir * root;\n    rec = hit_record(p, (p - sph.center) / sph.radius, root, sph.material);\n}\n\nbool hit(ray r, out hit_record rec) {\n    bool hit = false;\n    // dummy. Set initial hit distance to max\n    rec = hit_record(vec3(0), vec3(0), 9999., material(material_lambertian, vec3(0), 0., 0.));\n\n    // unrolling this loop gave 4x perf boost...\n    hit_sphere(spheres[0], r, rec, hit);\n    hit_sphere(spheres[1], r, rec, hit);\n    hit_sphere(spheres[2], r, rec, hit);\n    hit_sphere(spheres[3], r, rec, hit);\n    hit_sphere(spheres[4], r, rec, hit);\n    hit_sphere(spheres[5], r, rec, hit);\n    hit_sphere(spheres[6], r, rec, hit);\n    hit_sphere(spheres[7], r, rec, hit);\n    hit_sphere(spheres[8], r, rec, hit);\n    hit_sphere(spheres[9], r, rec, hit);\n    hit_sphere(spheres[10], r, rec, hit);\n    hit_sphere(spheres[11], r, rec, hit);\n    hit_sphere(spheres[12], r, rec, hit);\n    hit_sphere(spheres[13], r, rec, hit);\n    hit_sphere(spheres[14], r, rec, hit);\n    hit_sphere(spheres[15], r, rec, hit);\n    hit_sphere(spheres[16], r, rec, hit);\n    hit_sphere(spheres[17], r, rec, hit);\n    hit_sphere(spheres[18], r, rec, hit);\n    hit_sphere(spheres[19], r, rec, hit);\n    hit_sphere(spheres[21], r, rec, hit);\n    hit_sphere(spheres[22], r, rec, hit);\n    hit_sphere(spheres[23], r, rec, hit);\n\n    return hit;\n}\n\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nvoid scatter(hit_record rec, ray r, vec2 seed, inout vec3 attenuation, inout ray scattered) {\n    material m = rec.material;\n\n    if (m.type == material_lambertian) {\n        vec3 scatter_direction = normalize(rec.normal + random_unit_vector(seed));\n\n        // catch degenerate scatter direction\n        if (near_zero(scatter_direction)) {\n            scatter_direction = rec.normal;\n        }\n\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = m.albedo;\n    } else if (m.type == material_metal) {\n        vec3 reflected = reflect(r.dir, rec.normal);\n        ray scattered_ = ray(rec.p, normalize(reflected + m.metal_fuzz * random_in_unit_sphere(seed)));\n        if (dot(scattered_.dir, rec.normal) > 0.) {\n            scattered = scattered_;\n            attenuation = m.albedo;\n        }\n    } else if (m.type == material_dielectric) {\n        bool front_face = dot(r.dir, rec.normal) < 0.;\n        vec3 adjusted_normal = front_face ? rec.normal : -rec.normal;\n        float ref = m.dielectric_index_of_refraction;\n        float refraction_ratio = front_face ? 1.0/ref : ref;\n\n        float cos_theta = min(dot(-r.dir, adjusted_normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash12(seed)) {\n            direction = reflect(r.dir, adjusted_normal);\n        } else {\n            direction = refract(r.dir, adjusted_normal, refraction_ratio);\n        }\n\n        scattered = ray(rec.p, direction);\n        attenuation = vec3(1);\n    }\n}\n\nvec3 ray_color(in ray r, vec2 seed) {\n    vec3 color = vec3(1);\n    hit_record rec;\n    int depth;\n    for (depth = 0; depth < MAX_RAY_BOUNCES; depth++) {\n        if (hit(r, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            scatter(rec, r, seed * 999. + float(depth), attenuation, scattered);\n            r = scattered;\n            color *= attenuation;\n        } else {\n            // hit bg, aka nothing\n            float t = 0.5 * (r.dir.y + 1.0);\n            color *= mix(vec3(1.), vec3(0.5, 0.7, 1.0), t);\n\n            break;\n        }\n    }\n\n    if (depth == MAX_RAY_BOUNCES) {\n        return vec3(0);\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // camera\n    vec3 lookfrom = vec3(cos(iTime) * 13., 2.0, sin(iTime) * 10.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 30.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n\n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n\n    vec3 origin = lookfrom;\n    vec3 horizontal = focus_dist * viewport_width * u;\n    vec3 vertical = focus_dist * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal / 2. - vertical / 2. - focus_dist * w;\n\n    float lens_radius = aperture / 2.;\n\n    // render\n    vec3 color = vec3(0);\n    for (float s = 0.; s < SAMPLES_PER_PIXEL; s++) {\n        vec2 rand = hash22(fragCoord * 999. + s + iTime);\n\n        vec2 normalizedCoord = (fragCoord + rand) / iResolution.xy;\n        vec3 rd = lens_radius * random_in_unit_disk(normalizedCoord * 999. + s + iTime);\n        vec3 offset = u * rd.x + v * rd.y;\n        ray r = ray(\n            origin + offset,\n            normalize(lower_left_corner + normalizedCoord.x * horizontal + normalizedCoord.y * vertical - origin - offset)\n        );\n        color += ray_color(r, normalizedCoord);\n    }\n\n    fragColor = vec4(sqrt(color / SAMPLES_PER_PIXEL), 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}