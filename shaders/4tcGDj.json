{
    "Shader": {
        "info": {
            "date": "1471479228",
            "description": "To go along with the corresponding blog post which can be found here: http://fabricecastel.github.io/blog/2016-08-17/main.html",
            "flags": 0,
            "hasliked": 0,
            "id": "4tcGDj",
            "likes": 11,
            "name": "Sphere Tracing 105",
            "published": 3,
            "tags": [
                "raymarching",
                "tutorial",
                "domainrepetition"
            ],
            "usePreview": 0,
            "username": "fab",
            "viewed": 4061
        },
        "renderpass": [
            {
                "code": "// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.01;\nconst float EPSILON = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    vec3 q = vec3(mod(p.x, 3.0) - 1.5, p.yz);\n\tfloat s = 1.0;\n    vec3 d = abs(q) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 40; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0, 50.0*cos(iTime));\n            result = computeLambert(hit, computeSurfaceNormal(hit), light);\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(10.0*sin(iTime), 2.0, 10.0*cos(iTime));\n\tvec3 cameraDirection = normalize(vec3(-1.0*sin(iTime), -0.2, -1.0*cos(iTime)));\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n  \n    // generate the ray for this pixel\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    const float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 pixelColour = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColour, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}