{
    "Shader": {
        "info": {
            "date": "1548978578",
            "description": "An interactive water ripple effect. Click and drag to create a water trail.\nThe propagation in Buffer A is based on a sample I saw online in a random forum but I've since lost the link.\nIf it looks familiar, let me know.",
            "flags": 32,
            "hasliked": 0,
            "id": "3sB3WW",
            "likes": 29,
            "name": "Interactive Ripples",
            "published": 3,
            "tags": [
                "interactive",
                "water",
                "ripple"
            ],
            "usePreview": 1,
            "username": "4rknova",
            "viewed": 2733
        },
        "renderpass": [
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define DEBUG\n\n#define SPECULAR    (12.)\n#define DEPTH       (12.)\n#define WATER_COLOR vec3(0.92, 0.95, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 col = vec4(0);\n    \n    #ifdef DEBUG\n    \tcol = texture(iChannel0, uv);\n    #else\n    \tvec2 tc = texture(iChannel0, uv).xy;\n    \tcol = texture(iChannel1, tc - (0.5 - uv));\n    \tcol.xyz *= WATER_COLOR;\n     \tvec3 n = normalize(vec3(length(dFdx(tc)), length(dFdy(tc)), DEPTH/max(iResolution.x,iResolution.y)));\n    \tcol.xyz += pow(dot(n,normalize(vec3(.9,.25,-.1))),2.0) * pow(textureLod(iChannel2, n, 5.).xyz,vec3(SPECULAR));\n    #endif /* DEBUG */\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define AUTO\n\n#define STRENGTH     (1.75)\n#define MODIFIER     (0.99)\n#define STEP         (2.00)\n\n#define S(e) (texture(iChannel0, p+e).x) // Sample\n\nvec3 getPos()\n{\n#ifdef AUTO\n  \tfloat t = iTime*5.0;\n    vec2  s = fract(floor(t)*vec2(0.456665,0.708618))*iResolution.xy;\n    return vec3(s, 1);\n#else\n    if (iMouse.z > 0.) return vec3(iMouse.xy, 1);\n  \treturn vec3(0);\n#endif /* AUTO */\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = 0.;\n    vec2  p = gl_FragCoord.xy / iResolution.xy;\n    vec4  c = texture(iChannel0, p);\n   \tvec3  e = vec3(vec2(STEP)/iResolution.xy,0.);\n   \tfloat s0 = c.y, s1 = S(-e.zy), s2 = S(-e.xz), s3 = S(e.xz), s4 = S(e.zy);\n\n   \tvec3 pos = getPos();\n   \tif (pos.z > 0.5) d = STRENGTH * smoothstep(3.,0.5,length(pos.xy - gl_FragCoord.xy));\n \n   \t// Calculate new state\n   \td += -(s0 - .5) * 2. + (s1 + s2 + s3 + s4 - 2.);\n   \td *= MODIFIER;\n    d *= smoothstep(0.,1.,float(iFrame >= 60)); // Clean buffer at startup\n    d = d * 0.5 + 0.5;\n \tfragColor = vec4(d, c.x, 0, 0); // Save current and previous state\n}\n   ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}