{
    "Shader": {
        "info": {
            "date": "1631476327",
            "description": "Drag the mouse to vary wavelength (x) and twist (y).\nMost reasonable settings are at bottom/center.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdKGWh",
            "likes": 13,
            "name": "XOR ripples (245 chars)",
            "published": 3,
            "tags": [
                "ripples",
                "interactive",
                "xor",
                "monochrome",
                "short",
                "golf"
            ],
            "usePreview": 0,
            "username": "hnh",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "/* \nThis little shader is the result of messing around with https://www.shadertoy.com/view/NsKGRh \nand its shortened version by FabriceNeyret2.\nIt's some twist and rippling applied to a pattern generated from simple integer logic. \nIn FabriceNeyret2's https://www.shadertoy.com/view/MdlfRM you can see that the \"&\" operation\nresults in the typical XOR-pattern. \n*/\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n//*   // switch: \"//*\" -> \"/*\"\n// Shrinked, antialiased version by Xor\n\n    O-=O;\n    vec2 r,u,R = iResolution.xy,\n    m = iMouse.xy/R;\n    m = m==-m? vec2(.6,.07):m;\n    \n    for(int i = 0;i<9;)\n        u = U+vec2(i%3,i++/3)/3.,\n        r = length(u-= .5*R)+R-R,\n        u = u*sin(r/exp(5.*m.x) - 4.*iTime) + 4.*m.y*r,\n        O += sqrt(vec4(int(u) & int(u.y))/r.x)/9.;\n\n/*/\n// Minimal version (128 chars)\n// no mouse, antialiasing, gamma correction\n//  float r= length(U-= .5*iResolution.xy);\n//  U= U*sin(.05*r - 4.*iTime) + .3*r;\n//  O= vec4(int(U) & int(U.y))/r;\n\n\n// Original version\n  float r= length(U-= .5*iResolution.xy);\n  vec2 m= iMouse.xy/iResolution.xy;\n  if(m==vec2(0.)){m= vec2(.6,.07);}  // default parameters - better way?  \n  U= U*sin(r/exp(5.*m.x) - 4.*iTime) + 4.*m.y*r;\n  \n  // Variants\n  O= sqrt(vec4(int(U.x) & int(U.y))/r);\n  //O= vec4(int(U.x) & int(U.y))/r;  \n  //O= 6.*sqrt(vec4(int(U.x) & int(U.y)))/r;\n  //O= .5+log(vec4(int(U.x+r) & int(U.y+r))/r);  \n//*/\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}