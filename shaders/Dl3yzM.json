{
    "Shader": {
        "info": {
            "date": "1698973482",
            "description": "Weird idea, if the sun is directly overhead and our noise function is a 2D height map we can get the depth travelled through the volume for free when we sample the height map to get the density\nI get 4 ms frametimes at 1920x1080 on my GTX 1650",
            "flags": 0,
            "hasliked": 0,
            "id": "Dl3yzM",
            "likes": 19,
            "name": "Fast Volumetric Clouds",
            "published": 3,
            "tags": [
                "approximation",
                "garbage",
                "approximate"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 552
        },
        "renderpass": [
            {
                "code": "float fBm(vec2 x) {\n    // 4-octave fractal brownian motion (no mipmaps)\n    return\n    0.5333333333333333*textureLod(iChannel0, 0.00390625*x, 0.0).r+\n    0.2666666666666667*textureLod(iChannel0, 0.00781250*x, 0.0).g+\n    0.1333333333333333*textureLod(iChannel0, 0.01562500*x, 0.0).b+\n    0.0666666666666667*textureLod(iChannel0, 0.03125000*x, 0.0).a;\n}\n\nfloat fBm_MipMap(vec2 x) {\n    // 4-octave fractal brownian motion\n    return\n    0.5333333333333333*texture(iChannel0, 0.00390625*x).r+\n    0.2666666666666667*texture(iChannel0, 0.00781250*x).g+\n    0.1333333333333333*texture(iChannel0, 0.01562500*x).b+\n    0.0666666666666667*texture(iChannel0, 0.03125000*x).a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0); // initialize fragColor\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/(0.5*iResolution.y); // screen-space uv coords\n\n    vec3 ro = vec3( 0.0, -1.0,  0.0); // ray origin\n    vec3 rd = vec3(uv.x, uv.y, -1.0)/sqrt(dot(uv,uv)+1.0); // ray direction\n\n    //rd = normalize(rd); // normalize ray direction\n\n    // animate camera position\n    //ro.x = sin(3.*iTime); // swing left and right\n    //ro.y += 0.5*cos(3.*iTime); // swing up and down\n    ro.z = -5.0*iTime; // fly forward forever\n\n    const float step_size = 0.5*0.3333333333333333; // fixed step size\n\n    vec3 transmittance = vec3(1); // contribution to total light\n\n    float dithering_offset = texture(iChannel1, 0.0009765625*fragCoord).r; // initial offset to dither sampling\n\n    // main loop\n    for(int i = 0; i < 64; i++) {\n        if(transmittance.r < 0.00390625) break; // if contribution is 1/256 (8-BPC limit) stop\n\n        float t = step_size*(float(i)+dithering_offset); // distance along the camera ray we are sampling\n\n        vec3 x = ro+t*rd; // point along the camera ray we are sampling\n\n        if(x.y < -0.5 || x.y > 0.5) continue; // skip sampling noise above and below the clouds\n\n        //float hmin = -0.2*fBm(x.xz)+0.5; // different noise at the bottom of clouds experiment (looked terrible lol)\n        float hmax = fBm(x.xz)-0.4; // height of the top of the clouds\n        //float hmax2 = fBm(x.xz+0.2*vec2(cos(iTime),sin(iTime)))-0.4; // angled shadow experiment\n\n        float density = max(hmax-abs(x.y),0.0); // density of the volume at the sampled point\n\n        float illumin = 2.0*exp(-5.0*max(hmax-max(x.y,-hmax),0.)); // amount of light recieved at the sampled point\n\n        density *= 50.0; // make the volume more dense\n\n        transmittance *= exp(-step_size*density); // account for loss in contribution (less light makes it through denser reigons)\n\n        fragColor.rgb += step_size*transmittance*density*illumin; // add light to the total\n    }\n\n    vec4 p = vec4(0.0, 1.0, 0.0, 1.0); p = normalize(p);\n\n    float ground_t = -(dot(ro+vec3(0.0,3.0,0.0),p.xyz)-p.y)/dot(rd,p.xyz); // ground plane intersection\n\n    vec3 gx = ro+ground_t*rd; // point the ground ray hit\n\n    float hmax = fBm_MipMap(gx.xz)-0.4; // height of the top of the clouds above the point on the ground\n\n    float ill = 0.2*exp(-2.0*max(hmax-max(gx.y,-hmax),0.)); // amount of light recieved at the point on the ground\n\n    // calculate final color (if the ground ray hit, the ground color\n    // if not, the sky color\n    fragColor.rgb = fragColor.rgb + (ground_t > 0.0 ? transmittance*vec3(0.8)*ill : transmittance*(0.9*max(rd.y,0.)+0.1)*vec3(0.6,0.7,0.8));\n\n    //fragColor.rgb = fragColor.rgb + transmittance*(0.9*max(rd.y,0.)+0.1)*vec3(0.6,0.7,0.8); // calculate the final color (light from sky)\n\n    //fragColor.rgb = max(fragColor.rgb,0.0);\n\n    fragColor.rgb *= 2.0; // exposure\n\n    fragColor.rgb = fragColor.rgb/(fragColor.rgb+1.0); // tonemap\n\n    //fragColor.rgb = tanh(fragColor.rgb); // tonemap\n\n    //fragColor.rgb = clamp(fragColor.rgb,0.,1.); // clamp values\n\n    //fragColor.rgb = pow(fragColor.rgb,vec3(1./2.2)); // undo display gamma\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}