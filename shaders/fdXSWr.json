{
    "Shader": {
        "info": {
            "date": "1618445528",
            "description": "Ok, i think i got the clock gang thing covered by now.\nLast Clock shader. promise. (for the meanwhile).\nAnyway that is the base shader i wanted to do from the start.\nits a tribute to the live graphics PinkFloyd used while preforming.\ninfo,credits, in code",
            "flags": 32,
            "hasliked": 0,
            "id": "fdXSWr",
            "likes": 1,
            "name": "Tribute-Pink Floyd live graphics",
            "published": 3,
            "tags": [
                "time",
                "clock",
                "starfield",
                "tribute",
                "musicvideo",
                "pinkfloyd"
            ],
            "usePreview": 0,
            "username": "Pelegefen",
            "viewed": 286
        },
        "renderpass": [
            {
                "code": "// Main shader at Buffer C, this is a watercolor-like post-procces effects.\n\n\n// Original Clip - https://www.youtube.com/watch?v=BJImSd32f3Y&ab_channel=GoodOldMusic\n\n// Pink floyd's Time Tribute -  Clock shader by Peleg Gefen.\n// Basicaly a \"starfield\" effect with 2D clocks instead of stars, some \"3D\" trickery with UV manipulations.\n// The clocks are set of course, but might not be the best way to tell time, i'll leave it to you.\n\n// I Drew from the abyss Raja's watercolor shader and updated it to run in WebGL2.0 (added 1 to sample func lol)\n// link to WaterColor shader (dead) - https://www.shadertoy.com/view/Xdc3Df\n\n// took alot of inspiration from \"The Art Of Code - Starfield tutorial\" By Martijn Steinrucken\n// link to tutorial (very much alive) - https://www.youtube.com/watch?v=rvDo9LvfoVE&t=391s&ab_channel=TheArtofCode\n\n\n//water color FX r\nconst int radius = 8;\n\n\n\nvec3 sample1( vec2 fragCoord, const int x, const int y)\n{\n\tvec2 uv = (fragCoord.xy + vec2(x, y)) / iResolution.xy;\n\t//uv.y = 1.0 - uv.y;\n\t\n\treturn texture(iChannel1, uv).xyz;\n}\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n {\n\t vec2 src_size = vec2 (1.0 / iResolution.x, 1.0 / iResolution.y);\n     vec2 uv = fragCoord.xy/iResolution.xy;\n\n     float n = float((radius + 1) * (radius + 1));\n     int i; \n\t int j;\n     vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n     vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n     vec3 c;\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m0 += c;\n             s0 += c * c;\n         }\n     }\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m1 += c;\n             s1 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m2 += c;\n             s2 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m3 += c;\n             s3 += c * c;\n         }\n     }\n\n\n\t vec4 result;\n     float min_sigma2 = 1e+2;\n     m0 /= n;\n     s0 = abs(s0 / n - m0 * m0);\n\n     float sigma2 = s0.r + s0.g + s0.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m0, 1.0);\n     }\n\n     m1 /= n;\n     s1 = abs(s1 / n - m1 * m1);\n\n     sigma2 = s1.r + s1.g + s1.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m1, 1.0);\n     }\n\n     m2 /= n;\n     s2 = abs(s2 / n - m2 * m2);\n\n     sigma2 = s2.r + s2.g + s2.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m2, 1.0);\n     }\n\n     m3 /= n;\n     s3 = abs(s3 / n - m3 * m3);\n\n     sigma2 = s3.r + s3.g + s3.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m3, 1.0);\n     }\n\t\n\t const vec3 lumi = vec3(0.2126, 0.7152, 0.0722);\n\t\n\tvec3 hc =sample1(fragCoord,-1,-1) *  1.0 + sample1( fragCoord,0,-1) *  2.0\n\t\t \t+sample1( fragCoord,1,-1) *  1.0 + sample1(fragCoord,-1, 1) * -1.0\n\t\t \t+sample1( fragCoord,0, 1) * -2.0 + sample1( fragCoord,1, 1) * -1.0;\n\t\t\n\tvec3 vc =sample1(fragCoord,-1,-1) *  1.0 + sample1(fragCoord,-1, 0) *  2.0\n\t\t \t+sample1(fragCoord,-1, 1) *  1.0 + sample1( fragCoord,1,-1) * -1.0\n\t\t \t+sample1(fragCoord, 1, 0) * -2.0 + sample1( fragCoord,1, 1) * -1.0;\n\t\n\tvec3 c2 = sample1(fragCoord,0, 0);\n\t\n\tc2 -= pow(c2, vec3(0.2126, 0.7152, 0.0722)) * pow(dot(lumi, vc*vc + hc*hc), .5);\n\tfragColor = vec4(overlay(screen( result.rgb,c2.rgb), result.rgb) , 1.0);\n    \n }\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// renders the clock!\n\nvec4 Hand(vec2 uv , float l, float w, float t)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , 1. * RES.y/RES.x * w);\n    \n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 7,/* Width*/6.,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n\n \n    col.a = col.r;// at this point, each of the rgb vals is at 1. and showing the mask, so store it in the A channel.\n    \n    col = max (col,vec4(0.));\n    return col;\n}\n\nvec4 HandsShadow(vec2 uv , float l, float w, float t , float b)\n{\n    vec4 col = vec4(0.);\n    \n    uv.y += .05;\n    uv.x -= .02;\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , w);\n    uv.y += .02;\n    uv *= .45;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 7,/* Width*/6. * w,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n   \n    \n    \n    col -= length(uv.y) * 2.; // attenuate based on height\n    \n    \n    \n    col = max (col,vec4(0.));\n    return col * .1;\n}\nvec4 Dial(vec2 uv, float m)\n{\n    \n    vec4 col = vec4(0.);\n    vec2 fuv = polarMap(uv + .5, .008 , .0) * .5;\n    \n    \n    fuv.x = fract(fuv.x * 8. ) ;\n    col += vec4(ShapeN(fuv+vec2(0.,-.6) ,4  ,  3.15, 0.8 ),0.7) * .5;\n    \n    \n    uv = polarMap(uv + .5, .0035 , .25) * .5;\n    \n    uv.x = fract(uv.x * 24. * m ) ;\n\n    vec2 id = floor(uv * 24.  );\n\n    if(id.x <=  1.6 && id.y >= 18. && id.y <= 26.)return col = vec4(.35);\n\n    col = clamp(col,0.,1.);\n    return col;\n}\n\n\n//returns a working clock\nvec4 ClockFace(vec2 uv){\n    \n    //uv += 1.5;\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    vec4 wt = vec4(.8,.7,0.,1.);// sample wood tex\n    \n    wt += S(-.7,.1,-abs(uv.y)); // add shine\n    \n    float f = circle(uv,4.3, .001 );//clocks frame\n    float fm = (1. - (circle(uv,4.3, .055 ) )) * .6;//clocks frame bevel\n    f -= fm;\n    col += f;\n    col -= circle(uv,3.8, .001 ) - circle(uv,3.7, .001 );//clocks frame\n    col = mix(col,  wt ,  col - circle(uv,3.7, .001 )); // apply wood tex\n\n    //Decoration at 12 o'clock\n    col += circle(uv + vec2(0.,-1.03),0.3, .001 ) * 0.5;\n    col -= circle(uv + vec2(0.,-1.03),0.25, .001 ) * 0.5;\n   // col += circle(uv + vec2(0.,-1.0),0.3, .5 );\n    col -= vec4(ShapeN(uv+vec2(0.,-.5) ,5  ,  5.15, 1.15 ),0.7) * .3;\n    col += circle(   uv + vec2(0.,-.8) ,0.1, .1 );\n    \n    \n    \n    \n    col -= (circle(uv,3.6, .001 ) * .18) + (-uv.y * .1); //inset and shading\n    \n    // Shadow\n    float d = length(uv + vec2(0.,0.1 ))* 0.88;\n    float m = 1. - circle(uv,4.3,.0001);\n  \n    \n     //add the dial and decoration\n    col -= Dial(uv/1.3, 1.);\n    \n    //---------- time is set here------------\n\n    vec4 iDate = iDate;\n    float mils = fract(iDate.w);\n\tfloat secs = mod( floor(iDate.w),        60.0 );\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\n\n\n    vec4 ch1 = Hand(uv, 0.9,0.9, hors  * TAU * .8 );//hours hand\n    \n    ch1 = clamp(ch1,0.,1.);\n    col -= ch1;\n    vec4 ch1s = HandsShadow(uv , 1.,.9, hors  * TAU * .8 , .5);\n    col -= ch1s;\n\n    vec4 ch2 = Hand(uv , 1.6,0.5, mins);//minutes hand\n\n    ch2 = clamp(ch2,0.,1.);\n    col -= ch2;\n    vec4 ch2s = HandsShadow(uv , 1.7,.7, mins , .5);\n    col -= ch2s;\n\n    //vec4 ch3 = Hand(uv ,  2.0, .07 ,secs ); //secondes hand\n    vec4 ch3 = vec4(segmentT(uv,vec2(0,0.),rot(vec2(0.,1.0)  ,secs * TAU/60.  ) , \n    1. * RES.y/RES.x * .05 ));\n   // vec4 ch3m = Hand(uv , 1.1, .05 ,secs ); //secondes hand m\n    //ch3 -= ch3m;\n    \n\n    ch3 = clamp(ch3,0.,1.);\n    col -= ch3;\n    vec4 ch3s = vec4(segmentT(uv,vec2(0,-0.02),rot(vec2(0.1* uv.y ,  1. - uv.y * .1)  ,secs * TAU/60.  ) , \n    1. * RES.y/RES.x * .05 )) * .1;\n    col -= ch3s;\n    \n    vec4 hCol = vec4(0.4,0.4,0.4,1.);// clock hand clr\n    \n    float sh = -   dot(-uv.x * .5,.5) + dot(-uv.y * .5,.5) + .8 ;// clock hands shading\n    \n    \n    vec4 tex1 =hCol / sh;// texture(iChannel0,(rot( uv * 2., -secs* TAU/60.)));\n    vec4 tex2 =hCol/ sh;// texture(iChannel0,(rot( uv * 2., -mins* TAU/60.)));\n    vec4 tex3 =hCol/ sh;// texture(iChannel0,(rot( uv * 2., -hors* TAU/60.)));// we also have to spin the texture per hand!\n  \n    col = mix (col, ch1 * tex3  , ch1) ;\n    col = mix (col,ch2 * tex2 ,ch2 ) ;\n    col = mix (col,ch3 * tex1 ,ch3 ) ;\n    \n    \n    //------------End of Time setting-----------------  \n   \n    float cc =  circle(uv,0.3, .001 ) ;//clocks hand cover\n    cc = ceil(cc);\n    \n    cc = max(cc,0.);\n    cc = min(cc,1.);\n    \n    col =  mix(vec4(cc * .3) , col,1. -cc);\n    col += vec4(circle(uv,0.3, .2 ) * .3) *(fract( uv.y* 50. - .1)  ) ; // dot on the clock hand cover\n    \n    col -= circle(uv,3.7, .001 ) * .18;// glass cover\n    col += max((circle(uv,3.9, .05 ) * .3 * uv.y),0.);\n     m = 1. - circle(uv,4.3,.001);\n    col.a =  1.- m;\n    col = col - m;\n    col = max(vec4(0.),col);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n   // uv.y *= 0.56;\n    vec2 ouv = uv;\n    \n    vec4 col = vec4(0.0);\n    \n    uv -= .5;\n    uv.y += .22;\n\n     uv *= 5.2;\n     //col -= max( 1. - length((uv + vec2(.0,.1))* .7), 0.) ;\n    vec4 cf = ClockFace(uv );\n    col = mix(col,cf,cf.a);\n    \n    //if (ouv.x >= -0.01 && ouv.x <= .01) col -= vec4(1.,0.,0.,1.);\n\n  \n\n     \n     \n    // Output to screen\n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define S smoothstep \n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define RES iResolution.xy\n\n\nvec3 darken( vec3 s, vec3 d )\n{\n\treturn min(s,d);\n}\n\nvec3 multiply( vec3 s, vec3 d )\n{\n\treturn s*d;\n}\n\nvec3 colorBurn( vec3 s, vec3 d )\n{\n\treturn 1.0 - (1.0 - d) / s;\n}\n\nvec3 linearBurn( vec3 s, vec3 d )\n{\n\treturn s + d - 1.0;\n}\n\nvec3 darkerColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z < d.x + d.y + d.z) ? s : d;\n}\n\nvec3 lighten( vec3 s, vec3 d )\n{\n\treturn max(s,d);\n}\n\nvec3 screen( vec3 s, vec3 d )\n{\n\treturn s + d - s * d;\n}\n\nvec3 colorDodge( vec3 s, vec3 d )\n{\n\treturn d / (1.0 - s);\n}\n\nvec3 linearDodge( vec3 s, vec3 d )\n{\n\treturn s + d;\n}\n\nvec3 lighterColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d;\n}\n\nfloat overlay( float s, float d )\n{\n\treturn (d < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 overlay( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = overlay(s.x,d.x);\n\tc.y = overlay(s.y,d.y);\n\tc.z = overlay(s.z,d.z);\n\treturn c;\n}\n\nfloat softLight( float s, float d )\n{\n\treturn (s < 0.5) ? d - (1.0 - 2.0 * s) * d * (1.0 - d) \n\t\t: (d < 0.25) ? d + (2.0 * s - 1.0) * d * ((16.0 * d - 12.0) * d + 3.0) \n\t\t\t\t\t : d + (2.0 * s - 1.0) * (sqrt(d) - d);\n}\n\nvec3 softLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = softLight(s.x,d.x);\n\tc.y = softLight(s.y,d.y);\n\tc.z = softLight(s.z,d.z);\n\treturn c;\n}\n\nfloat hardLight( float s, float d )\n{\n\treturn (s < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 hardLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = hardLight(s.x,d.x);\n\tc.y = hardLight(s.y,d.y);\n\tc.z = hardLight(s.z,d.z);\n\treturn c;\n}\n\nfloat vividLight( float s, float d )\n{\n\treturn (s < 0.5) ? 1.0 - (1.0 - d) / (2.0 * s) : d / (2.0 * (1.0 - s));\n}\n\nvec3 vividLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = vividLight(s.x,d.x);\n\tc.y = vividLight(s.y,d.y);\n\tc.z = vividLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 linearLight( vec3 s, vec3 d )\n{\n\treturn 2.0 * s + d - 1.0;\n}\n\nfloat pinLight( float s, float d )\n{\n\treturn (2.0 * s - 1.0 > d) ? 2.0 * s - 1.0 : (s < 0.5 * d) ? 2.0 * s : d;\n}\n\nvec3 pinLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = pinLight(s.x,d.x);\n\tc.y = pinLight(s.y,d.y);\n\tc.z = pinLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 hardMix( vec3 s, vec3 d )\n{\n\treturn floor(s + d);\n}\n\nvec3 difference( vec3 s, vec3 d )\n{\n\treturn abs(d - s);\n}\n\nvec3 exclusion( vec3 s, vec3 d )\n{\n\treturn s + d - 2.0 * s * d;\n}\n\nvec3 subtract( vec3 s, vec3 d )\n{\n\treturn s - d;\n}\n\nvec3 divide( vec3 s, vec3 d )\n{\n\treturn s / d;\n}\n\n//\trgb<-->hsv functions by Sam Hocevar\n//\thttp://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\t\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hue( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.x = rgb2hsv(s).x;\n\treturn hsv2rgb(d);\n}\n\nvec3 color( vec3 s, vec3 d )\n{\n\ts = rgb2hsv(s);\n\ts.z = rgb2hsv(d).z;\n\treturn hsv2rgb(s);\n}\n\nvec3 saturation( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.y = rgb2hsv(s).y;\n\treturn hsv2rgb(d);\n}\n\nvec3 luminosity( vec3 s, vec3 d )\n{\n\tfloat dLum = dot(d, vec3(0.3, 0.59, 0.11));\n\tfloat sLum = dot(s, vec3(0.3, 0.59, 0.11));\n\tfloat lum = sLum - dLum;\n\tvec3 c = d + lum;\n\tfloat minC = min(min(c.x, c.y), c.z);\n\tfloat maxC = max(max(c.x, c.y), c.z);\n\tif(minC < 0.0) return sLum + ((c - sLum) * sLum) / (sLum - minC);\n\telse if(maxC > 1.0) return sLum + ((c - sLum) * (1.0 - sLum)) / (maxC - sLum);\n\telse return c;\n}\n\nmat2 Rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\n\n    return mat2(c, -s, s, c);\n}\nfloat Hash21(vec2 n){\n\n   return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 ShapeN(vec2 st, int N, float w, float h){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  st.x += 1.0 ;\n  st.y += .7;\n  st.y /= h;\n    st.x *= w;\n  // Number of sides of your shape\n  //int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulates the distance\n  d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  color = vec3(S(.41,.4,d));\n\n    return color;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (length(uv) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\nfloat circle (vec2 p, float r, float g)\n{\n\n    float d = length(p / r);\n\n    float ss = S(.32,.32 - g,d);\n    \n    ss = max(0.,ss);\n    return ss;\n\n}\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn S(r, 0.7*r, d);\n}\nfloat segmentT(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A ;\n    float d = length(h - g * clamp(dot(g , h ) / dot(g,g), 0.0, 1.0));\n    \n\n\treturn S(r, 0.7*r, d);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//BG\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(.5);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 ouv = uv;\n    vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    \n    \n    uv = M*4.; \n    vec2 ruv = rot(uv,iTime* .05) * .5;\n    uv.x += .01 * iTime;\n    uv.x = sin(uv.y);\n    uv.y = abs(uv.y);\n    vec4 tx = texture(iChannel0,ruv + ouv) * 1.1;\n    vec4 tx1 = texture(iChannel1,( uv+ ouv)*.2+.5) * 1.3;\n    tx = vec4(tx.r);\n    tx1 = vec4(tx1.r);\n    col += vec4(.4,.4,1.,1.) * uv.y ;\n    col *= tx;\n    col *= tx1;\n    col = clamp(col,0.2,1.);\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// number of layers to render, go over 5.5 only if you have a strong GPU! \n// min is 1.1\n#define NUM_LAYERS 5.5\n\nvec4 Layer(vec2 uv )\n{\n   // uv.y *= 2.0;\n    vec2 ouv = uv; //storing the original uvs.\n\n\n    uv.x +=  iTime * .001;\n    uv = rot(uv, 0.001 * iTime);\n    vec2 buv = uv;\n    //buv.x = buv.x +sin( buv.y + iTime * .001);\n    \n    \n    buv *= cos(sin(  iTime * .0001)*.5+.5) * 5.;\n    //vec2 mouse = iMouse.xy / iResolution.xy + .5;\n    //buv *= 1.- mouse.x + 1.5;\n    \n    buv.x -= .5;\n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n    \n    buv -= .25;\n   // buv.x += .1;\n    //uv = buv;\n\n    if ( mod(id.x,2.) == 0.)buv.x = (( (buv.x )/ sin(Hash21(id) *(iTime * .5  * (Hash21(id)))))); //fake 3d rotation\n    \n    \n    //buv.y *= 2.5 +.5;\n    buv /= 1.5 - Hash21(id);// random size\n    vec4 cf = texture(iChannel0,rot(buv * 3.5  -0.5,iTime * .1 * (Hash21(id))));\n    \n    \n    cf = min(cf,vec4(1.));\n    \n    col = mix(col,cf,cf.a);\n    //col + id;\n    \n   //col += vec4(fuv,0.,1.);\n  \n    \n\n\ncol.a = floor(cf.a);\n//\nreturn col;\n\n}\n\nvec4 RegLayer(vec2 uv )\n{\n    vec2 ouv = uv; //storing the original uvs.\n\n\n    vec2 buv = uv;\n\n   buv *= (sin(iTime * .01)*.5+.5) * 20.;\n    //buv *= 13.;\n    \n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n\n    \n    \n    \n    vec4 cf = texture(iChannel0,buv * 1.3);\n    \n    \n    cf = min(cf,vec4(1.));\n    \n    col = mix(col,cf,cf.a);\n    \n    \n\n  \n    \n\n\ncol.a = floor(cf.a);\n//\nreturn col;\n\n}\n\nvec4 ClockSoup(vec2 uv, vec2 nuv)\n{\n\n\n   vec2 ouv = uv;\n\tvec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    vec4 col = vec4(0);\n    float t = iTime*.01;\n    \n    uv += M*4.;\n    \n    uv *= Rot(t);\n    \n  \n     float m = 1.;\n    \n    vec4 tcol = vec4(0.);\n    \n    \n     //add clock layers loop\n    for(float i=0.; i<=1.; i+=1./NUM_LAYERS) {\n    \tfloat depth = fract(i+t);\n        \n        float s = mix(1.5, .01,i + depth);\n        float f = depth * smoothstep(1., .95, depth);\n        \n        uv = rot(uv, t * i);\n        vec4 l = Layer(uv*s+i*22.2-M);\n        l.a *= f;\n        m -= l.a;\n      \n        \n        col -= l.a;\n        col = clamp(col,0.,1.);\n        col = mix(col,l, l.a);\n\n    }\n    col = clamp(col,0.,1.);\n    //col = vec4(uv,.0,1.);\n    return col;\n}\n\nvec4 ClockHorizonSquash(vec2 uv, vec2 nuv)\n{\n    vec2 ouv = uv;\n    vec4 col = vec4(0.);\n    uv.x =  (abs(1.-uv.y) * uv.x) ;\n    uv.x = pow(uv.y,uv.x * .2 );\n    uv.y = pow(uv.y,.2);\n    uv.y = -abs(uv.y );\n    uv.y += fract(iTime * .05);\n    \n    \n    vec4 rl = RegLayer( ( uv + vec2(.205,.0)) * 1.3);\n\n    col += rl;\n    col = clamp(col,0.,1.);\n    col -=  pow(length(fract(1.- ouv.y)),12.1);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   vec2 nuv = fragCoord.xy/iResolution.xy;\n\n   vec2 ouv = uv;\n\tvec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    vec4 col = vec4(0);\n    float t = iTime*.01;\n    \n    float bs = (sin(t * 15.)*.5+.5);// used to blend between the animations\n    \n    vec4 bg = texture(iChannel2, nuv );\n    //\n    vec4 cs = ClockSoup(uv,nuv);\n    vec2 huv = uv;\n    huv.y = abs(huv.y);\n    vec4 chs = ClockHorizonSquash(huv - vec2((M.x * .5),abs(M.y) * .5),nuv);\n    \n    \n    col = clamp(col,0.,1.);\n    \n    \n    vec4 blend =  mix(cs,chs,S(0.4,.6,bs));\n    blend = clamp(blend,0.,1.);\n    col = mix(blend,bg,1. -blend);\n    \n\n    //col += cs;\n    col = pow(col, vec4(.82));\t//gamma corrct\n    \n    col -= pow(length(ouv * 2.),124.7)  ;//circle vignette\n    //col = vec4(1. -blend);\n    col = clamp(col,0.,1.);\n        //col = texture(iChannel0,nuv);\n   // col = vec4(Hash21(uv));\n    fragColor = col;\n\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}