{
    "Shader": {
        "info": {
            "date": "1477983763",
            "description": "This is an attempt to solve everything anyone could want from a line in one function. See comments.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tc3DX",
            "likes": 75,
            "name": "Glorious Line Algorithm",
            "published": 3,
            "tags": [
                "line",
                "circle",
                "antialiasing",
                "antialias",
                "rectangle",
                "algorithm",
                "rounded"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 2955
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n\n**************** Glorious Line Algorithm ****************\nThis is an attempt to solve everything anyone could want from a line in one function.\nGlorious features:\n- antialiasing\n- rectangles, squares, lines, circles, rounded rectangles\n- square or rounded endpoints\n- outline shapes (might have some bugs still)\n- dashed, animated lines\n- resolution dependent or independent - some functions work in pixel units, some in UV coordinates.\n- efficient\n*/\n\n// Clamp [0..1] range\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Basically a triangle wave\nfloat repeat(float x) { return abs(fract(x*0.5+0.5)-0.5)*2.0; }\n\n// This is it... what you have been waiting for... _The_ Glorious Line Algorithm.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n    // This is for animated dashed lines. Delete if you don't like dashes.\n    float dashScale = 2.0*thick.y;\n    // Make a distance function for the dashes\n    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;\n    // Combine this distance function with the line's.\n    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n// This makes an outlined line in pixel units. A 1.0 thick outline will be 1 pixel thick.\nfloat DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float scale = abs(dFdy(uv).y);\n    thick = (thick * 0.5 - 0.5) * scale;\n    rounded = (rounded * 0.5 - 0.5) * scale;\n    outlineThick = (outlineThick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / scale);\n}\n\n// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes a dashed line in UV units. A 1.0 thick line will span a whole 0..1 in UV space.\nfloat FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);\n    return saturate(df / abs(dFdy(uv).y));\n}\n\n// This makes an outlined line in UV units. A 1.0 thick outline will span 0..1 in UV space.\nfloat DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));\n}\n\n// This just draws a point for debugging using a different technique that is less glorious.\nvoid DrawPoint(vec2 uv, vec2 p, inout vec3 col) {\n    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust UV space so it's a nice size and square.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 16.0;\n\n    // Make things that rotate with time.\n    vec2 rotA = vec2(cos(iTime*0.82), sin(iTime*0.82));\n    vec2 rotB = vec2(sin(iTime*0.82), -cos(iTime*0.82));\n    // Make a bunch of line endpoints to use.\n    vec2 pA = vec2(-4.0, 0.0) - rotA;\n    vec2 pB = vec2(4.0, 0.0) + rotA;\n    vec2 pC = pA + vec2(0.0, 4.0);\n    vec2 pD = pB + vec2(0.0, 4.0);\n    // Debugging code\n    //float df = LineDistField(uv, pA, pB, vec2(28.0 * dFdy(uv).y), 0.1, 0.0);\n    //float df = DistField(uv, pA, pB, 25.000625 * dFdx(uv).x, 0.5);\n    //vec3 finalColor = vec3(df*1.0, -df*1.0, 0.0);\n    //finalColor = vec3(1.0) * saturate(df / dFdy(uv).y);\n    //finalColor = vec3(1.0) * saturate((abs(df+0.009)-0.009) / dFdy(uv).y);\n\n    // Clear to white.\n    vec3 finalColor = vec3(1.0);\n\n    // Lots of sample lines\n    // 1 pixel thick regardless of screen scale.\n    finalColor *= FillLinePix(uv, pA, pB, vec2(1.0, 1.0), 0.0);\n    // Rounded rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(32.0), 16.0, 1.0);\n    // square-cornered rectangle outline, 1 pixel thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(64.0), 0.0, 1.0);\n    // Fully rounded endpoint with outline 8 pixels thick\n    finalColor *= DrawOutlinePix(uv, pA, pB, vec2(128.0), 128.0, 8.0);\n    // Dashed line with rectangular endpoints that touch pC and pD, 0.5 radius thickness in UV units\n    finalColor *= FillLineDash(uv, pC, pD, vec2(0.0, 0.5), 0.0);\n    // Rounded endpoint dashed line with radius 0.125 in UV units\n    finalColor *= FillLineDash(uv, pC + vec2(0.0, 2.0), pD + vec2(0.0, 2.0), vec2(0.125), 1.0);\n    \n    finalColor *= DrawOutline(uv, (pA + pB) * 0.5 + vec2(0.0, -4.5), (pA + pB) * 0.5 + vec2(0.0, -4.5), vec2(2.0, 2.0), 2.0, 0.8);\n    finalColor *= FillLine(uv, pA - vec2(4.0, 0.0), pC - vec2(4.0, 0.0)+rotA, vec2(0.125), 1.0);\n    finalColor *= FillLine(uv, pB + vec2(4.0, 0.0), pD + vec2(4.0, 0.0)-rotA, vec2(0.125), 1.0);\n\n    DrawPoint(uv, pA, finalColor);\n    DrawPoint(uv, pB, finalColor);\n    DrawPoint(uv, pC, finalColor);\n    DrawPoint(uv, pD, finalColor);\n\n    // Blue grid lines\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.x*2.0) - 0.92)*4.0;\n    finalColor -= vec3(1.0, 1.0, 0.2) * saturate(repeat(uv.y*2.0) - 0.92)*4.0;\n    //finalColor *= saturate(mod(fragCoord.y + 0.5, 2.0) + mod(fragCoord.x + 0.5, 2.0));\n    fragColor = vec4(sqrt(saturate(finalColor)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}