{
    "Shader": {
        "info": {
            "date": "1582846163",
            "description": "From Jules Verne's \"20K Leagues Under The Seas\".\nSource explains how to view all the scenes, but the compile time will be longer.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lVSWw",
            "likes": 12,
            "name": "Nautilus: The Book",
            "published": 3,
            "tags": [
                "submarine",
                "sciencefiction",
                "verne"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 373
        },
        "renderpass": [
            {
                "code": "// \"Nautilus: The Book\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Seas\"\n\n// For complete book, change ALL_PG from 0 to 1 -- probably longer compile time.\n// Mouse-x overrides autopaging, mouse-y vertical view direction.\n\n#define ALL_PG   0    // = 0/1 for short/full version\n#define ISBOOK   1    // = 1 for book format\n\n#if ! ALL_PG      // single page selection for faster compilation (not with book)\n#define IPAGE  1  // (for short book set = 1, else 1...6)\n#if IPAGE == 4 || IPAGE == 5\n#define UNWAT  1\n#else\n#define UNWAT  0\n#endif\n#if IPAGE == 5 || IPAGE == 6\n#define INCAVE 1\n#else\n#define INCAVE 0\n#endif\n#endif\n#if ! ALL_PG && IPAGE == 3\n#define ISDARK 1\n#else\n#define ISDARK 0\n#endif\n#if ! ALL_PG && IPAGE == 1\n#define INENV 0\n#else\n#define INENV 1\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, sunDir, sbPos, ltDirEx, qHit, pgSize;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, cvSize, msAz, msEl, dstFarEx, tpBook, phsTurn, idPage;\nint idObj;\nconst int nPage = 6;\nbool inCave, unWat, isDark, bmOn, inEnv;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idCav = 14, idGrnd = 15;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPathCv (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\n#if ALL_PG || INCAVE\n\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrackPathCv (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.5 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    p = ro + dHit * rd;\n    d = CaveDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + d * rd));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = CaveDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 16; j ++) {\n    h = CaveDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\n#endif\n\n#if ALL_PG || UNWAT\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q;\n  float ht, wAmp;\n  q = 0.2 * p;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    ht += wAmp * Noisefv2 (q);\n    q *= qRot;\n    wAmp *= 0.5;\n  }\n  return ht - 8.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2 (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2 (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.07);\n}\n\n#endif\n\n#if ALL_PG || ! (UNWAT || INCAVE)\n\nfloat WaveHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, t4o, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, ht;\n  wFreq = 0.4;\n  wAmp = 0.1;\n  t4o.xz = tCur * vec2 (1., -1.);\n  q2 = p;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = (t4o.xxzz + vec4 (q2, q2)) * wFreq;\n    t2 = Noisev2v4 (t4);\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + sqrt (1. - ta4 * ta4));\n    v2 = pow (1. - pow (v4.xz * v4.yw, vec2 (0.65)), vec2 (8.));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;\n    wFreq *= 2.;\n    wAmp *= 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 50; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyHrzCol (vec3 rd)\n{\n  vec3 col, clCol, mDir, vn;\n  vec2 q;\n  float a, f, fd, ff, smd, mRad, ts;\n  a = atan (rd.z, rd.x);\n  if (rd.y < 0.02 * Fbm1 (32. * a) - 0.02) {\n    col = vec3 (0.22, 0.3, 0.33) * (0.8 + 0.2 * Fbm2 (64. * vec2 (a, rd.y)));\n    if (isDark) col *= 0.5;\n  } else {\n    if (isDark) {\n      mDir = normalize (vec3 (0.6, 0.05, 1.));\n      mRad = 0.015;\n      col = vec3 (0.06, 0.06, 0.03) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n      smd = dot (rd, mDir);\n      ts = smd * smd - 1. + mRad * mRad;\n      if (ts > 0.) {\n        ts = smd - sqrt (ts);\n        if (ts > 0.) {\n          vn = normalize ((ts * rd - mDir) / mRad);\n          col += vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (-0.77, -0.4, 0.5), vn) *\n             (1. - 0.3 * Noisefv3 (8. * vn)), 0., 1.);\n        }\n      } else col += StarPat (rd, 6.);\n    } else {\n      smd = max (dot (rd, sunDir), 0.);\n      q = vec2 (0.05 * tCur + 2. * rd.xz / rd.y);\n      ff = Fbm2 (q);\n      f = smoothstep (0.2, 0.8, ff);\n      fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n      clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n         smoothstep (0., 0.05, abs (fd)));\n      col = mix (vec3 (0.4, 0.5, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n      col += 0.1 * pow (smd, 16.) + 0.2 * pow (smd, 256.);\n    }\n  }\n  return col;\n}\n\n#endif\n\n#if ALL_PG || ! UNWAT\n\nfloat WakeFac (vec3 p)\n{\n  vec2 tw;\n  tw = Rot2D (p.xz - sbPos.xz, sbRot);\n  tw.y += 6.5;\n  return (1. - smoothstep (0.3, 0.6, abs (tw.x) + 0.1 * tw.y)) * clamp (1. - 2. * tw.y, 0., 0.2) *\n     smoothstep (-5., -2., tw.y);\n}\n\n#endif\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = (isDark || unWat || inCave) ? vec4 (0.5, 0.4, 0.3, -1.) : vec4 (0.4, 0.4, 0.5, 0.1);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n    if (isDark) col4.rgb *= 0.5;\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, vno, vnb, rob[2], rdb[2], bgCol, ltVec, roo, row, vnw;\n  vec2 lbDist, ws;\n  float dstObj, dstObjO, dstCave, dstGrnd, dstWat, sh, atten, wkFac, s;\n  bool waterRefl;\n  dstObj = ObjRay (ro, rd);\n#if ALL_PG || INCAVE\n  if (inEnv && inCave) {\n    dstCave = CaveRay (ro, rd);\n    if (dstCave < min (dstObj, dstFar)) {\n      dstObj = dstCave;\n      idObj = idCav;\n    }\n  }\n#endif\n#if ALL_PG || UNWAT  \n  if (inEnv && unWat) {\n    dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;\n    if (dstGrnd < min (dstObj, dstFar)) {\n      dstObj = dstGrnd;\n      idObj = idGrnd;\n    }\n  }\n#endif\n  sh = 1.;\n  atten = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  if (inEnv && unWat) {\n#if ALL_PG || UNWAT  \n    if (dstObj < dstFar) {\n      if (idObj == idGrnd) {\n        ro += dstObj * rd;\n        col4 = mix (vec4 (0.4, 0.3, 0.3, 0.), vec4 (0.3, 0.3, 0.2, 0.),\n           0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (1. +\n           0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n        vn = GrndNf (ro);\n        vno = vec3 (0., 1., 0.);\n        if (vn.y > 0.85) {\n          vn4 = RippleNorm (0.25 * ro.xz, vn, 8. * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n          vn = vn4.xyz;\n          col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);\n        }\n        vn = VaryNf (4. * ro, vn, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n        ws = ro.xz - sbPos.xz;\n        ws = Rot2D (ws, sbRot);\n        sh = 0.6 + 0.4 * smoothstep (-0.2, 0.8, length (ws -\n           vec2 (0., clamp (ws.y, - sbLen, sbLen))) -\n           1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, ws.y / sbLen)) *\n           (1. - 0.85 * smoothstep (0.6, 1.1, - ws.y / sbLen)));\n#if ALL_PG || INCAVE\n        if (inCave) sh = min (sh, min (CaveSShadow (ro, vec3 (0., 1., 0.)), \n           0.5 + 0.5 * CaveAO (ro, vec3 (0., 1., 0.))));\n#endif\n        col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.));\n        col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (- dstObj / dstFar));\n        col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n      } else if (idObj == idCav) {\n#if ALL_PG || INCAVE\n        ro += dstObj * rd;\n        vn = CaveNf (ro);\n        vno = vn;\n        col = vec3 (0.4, 0.4, 0.4);\n        col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (-4. * dstObj / dstFar));\n        vn = VaryNf (ro, vn, 12.);\n        col *= (0.2 + 0.8 * max (dot (vn, sunDir), 0.) +\n           0.5 * pow (max (dot (reflect (sunDir, vn), rd), 0.0), 128.));\n        col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n#endif\n      } else {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        vno = vn;\n        col4 = NautColN (ro, vn);\n        sh = ObjSShadow (ro, vec3 (0., 1., 0.));\n        if (col4.a >= 0.) {\n          col = col4.rgb * (0.5 + 0.5 * sh * max (vn.y, 0.) + 0.2 * UnwCol (rd));\n          col *= vec3 (0.7, 0.9, 1.);\n        } else {\n          col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        }\n      }\n      col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vno), 0.2 * tCur) *\n         (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);\n    } else {\n      col = UnwCol (rd) + WatShd (rd);\n    }\n#endif\n  } else if (! inEnv || inEnv && ! unWat) {\n#if ALL_PG || ! UNWAT\n    roo = ro;\n    dstObjO = dstObj;\n    bgCol = (abs (rd.y) < 0.5) ? vec3 (0.05, 0.05, 0.1) : vec3 (0.01);\n    waterRefl = false;\n    if (inEnv && inCave) {\n#if ALL_PG || INCAVE\n      if (rd.y < 0. && ro.y + rd.y * dstObj < 0.) {\n        dstWat = - ro.y / rd.y;\n        waterRefl = (dstWat < min (dstObj, dstFar) && ro.y + rd.y * dstWat < 0.001);\n      } else {\n        dstWat = dstFar;\n      }\n#endif\n    } else if (inEnv && ! inCave) {\n#if ALL_PG || ! INCAVE\n      dstWat = WaveRay (ro, rd);\n      waterRefl = (dstWat < min (dstFar, dstObj));\n#endif\n    }\n    if (waterRefl) {\n      ro += dstWat * rd;\n      row = ro;\n#if ALL_PG || INCAVE\n      if (inCave) vnw = VaryNf (0.2 * ro, vec3 (0., 1., 0.), 0.1);\n#endif\n#if ALL_PG || ! INCAVE\n      if (! inCave) vnw = WaveNf (ro, dstWat);\n#endif\n      wkFac = WakeFac (row);\n      if (wkFac > 0.) vnw = VaryNf (8. * row, vnw, 16. * wkFac);\n      rd = reflect (rd, vnw);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n#if ALL_PG || INCAVE\n      if (inCave) {\n        dstCave = CaveRay (ro, rd);\n        if (dstCave < min (dstObj, dstFar)) {\n          dstObj = dstCave;\n          idObj = idCav;\n        }\n      }\n#endif\n      if (bmOn) {\n        rob[1] = ro;\n        rdb[1] = rd;\n      }\n    }\n    if (inEnv && inCave) {\n#if ALL_PG || INCAVE\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        ltVec = roo + ltPos - ro;\n        s = length (ltVec);\n        atten = (1. - smoothstep (0.1, 0.6, s / dstFar)) / (1. + 0.002 * pow (s, 1.5));\n        ltVec /= s;\n        if (idObj == idCav) {\n          vn = CaveNf (ro);\n          col4 = vec4 (mix (vec3 (0.55, 0.5, 0.5), vec3 (0.3, 0.4, 0.2),\n             smoothstep (0.5, 0.8, vn.y)), 0.5);\n          sh = min (CaveSShadow (ro, ltVec), CaveAO (ro, vn));\n          vn = VaryNf (ro, vn, 12.);\n        } else {\n          vn = ObjNf (ro);\n          col4 = NautColN (ro, vn);\n          sh = ObjSShadow (ro, ltVec);\n        }\n        if (col4.a >= 0.) col = col4.rgb * sh * (0.2 + 0.8 * max (dot (vn, ltVec), 0.)) +\n           col4.a * step (0.95, sh) * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.);\n        else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        col = mix (col, bgCol, smoothstep (0.45, 0.99, dstObj / dstFar)) * atten;\n      } else col = bgCol;\n      if (waterRefl) col = mix (vec3 (0.1, 0.2, 0.3) * (0.2 + 0.8 * atten), col, 0.5);\n#endif\n    } else if (inEnv && ! inCave) {\n#if ALL_PG || ! INCAVE\n      if (dstObj < min (dstWat, dstFar)) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = NautColN (ro, vn);\n        sh = isDark ? 1. : ObjSShadow (ro, sunDir);\n        if (col4.a >= 0.) {\n          col = col4.rgb * (0.3 + 0.2 * max (- dot (vn, sunDir), 0.) +\n             0.7 * sh * max (dot (vn, sunDir), 0.)) +\n             col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n        } else {\n          col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        }\n      } else {\n        col = SkyHrzCol (rd);\n      }\n      if (waterRefl) col *= 0.6;\n      if (isDark) col *= 0.8;\n#endif\n    } else if (! inEnv) {\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = NautColN (ro, vn);\n        col4.rgb = vec3 (1.) * pow (Maxv3 (col4.rgb), 0.7);\n#if ISBOOK\n        col4.rgb *= vec3 (0.8, 0.8, 0.85);\n#else\n        col4.rgb *= mix (vec3 (0.8, 1., 1.), vec3 (1., 1., 0.8), - dot (vn, rd));\n#endif\n      if (col4.a < 0.) col4.a = 0.2;\n        s = max (dot (vn, sunDir), 0.);\n        col = col4.rgb * (0.2 + 0.8 * s * s) +\n           2. * col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n      } else {\n        col = vec3 (0., 0., 0.5);\n      }\n    }\n#if ALL_PG || ! UNWAT\n    if (inEnv && waterRefl && wkFac > 0.) {\n      s = Fbm3 (16. * row);\n      if (inCave) col = mix (col, vec3 (0.7), 4. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));\n      else col = mix (col, vec3 (0.9), 8. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));\n    }\n#endif\n#if ALL_PG || ! UNWAT && ! INCAVE\n    if (inEnv && waterRefl && ! inCave) {\n      col = mix (col, vec3 (0.7), pow (clamp (2.8 * WaveHt (row.xz) +\n         0.5 * Fbm3 (32. * row), 0., 1.), 8.));\n    }\n#endif\n#endif\n  }\n  if (inEnv && bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    if (unWat) {\n#if ALL_PG || UNWAT\n      vnb = LBeamNf (rob[0] + lbDist.x * rdb[0]);\n      if (lbDist.x < min (dstObj, dstFar))\n         col = mix (col, vec3 (1., 1., 1.), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));\n#endif\n    }\n    if (! unWat) {\n#if ALL_PG || ! UNWAT\n      if (lbDist.x < min (min (dstObjO, dstWat), dstFar))\n         col = mix (col, vec3 (1., 1., 0.7), 0.7 * (1. - lbDist.y));\n      if (waterRefl) {\n        lbDist = LBeamRay (rob[1], rdb[1]);\n        if (lbDist.x < min (min (dstObj, dstWat), dstFar))\n           col = mix (col, vec3 (0.8, 1., 0.7), 0.4 * (1. - lbDist.y));\n      }\n#endif\n    }\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, s, dVu, tVuCyc;\n  uv = fCoord;\n#if ISBOOK\n  tCur += 30. * idPage;\n#endif\n#if ALL_PG\n#if ! ISBOOK\n  tVuCyc = 20.;\n  idPage = floor (mod (tCur / tVuCyc, 6.)) + 1.;\n#endif\n  unWat = (idPage == 4. || idPage == 5.);\n  inCave = (idPage == 5. || idPage == 6.);\n  isDark = (idPage == 3.);\n  inEnv = (idPage >= 2.);\n#elif ISBOOK && ! ALL_PG\n  unWat = false;\n  inCave = false;\n  isDark = (idPage == 3. || idPage == 5.);\n  inEnv = (idPage >= 2.);\n#else\n  unWat = (UNWAT == 1);\n  inCave = (INCAVE == 1);\n  isDark = (ISDARK == 1);\n  inEnv = (INENV == 1);\n#endif\n  cvSize = 7.;\n  if (inEnv) {\n    bmOn = isDark || unWat || inCave;\n  } else {\n    bmOn = false;\n    isDark = false;\n  }\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  t = 3. * tCur;\n  az = 0.;\n  el = 0.;\n  if (inEnv && inCave) {\n    fpF = TrackPathCv (t + 0.1);\n    fpB = TrackPathCv (t - 0.1);\n    sbPos = 0.5 * (fpF + fpB);\n    sbPos.y = 0.09;\n    vd = fpF - fpB;\n    sbRot = atan (vd.x, vd.z);\n  } else if (inEnv && ! inCave) {\n    sbPos = vec3 (0., 0.09, t);\n    if (! unWat) sbPos.y = 0.1 - 0.5 * (1. + sin (0.1 * 2. * pi * tCur));\n    sbRot = 0.;\n  } else if (! inEnv) {\n    sbPos = vec3 (0.);\n    sbRot = -0.25 * pi;\n  }\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  s = unWat ? 1. : -1.;\n  if (inEnv && inCave) {\n    dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n    t += 20. * dVu;\n    fpF = TrackPathCv (t + 0.1 * sign (dVu));\n    fpB = TrackPathCv (t - 0.1 * sign (dVu));\n    ro = 0.5 * (fpF + fpB);\n    ro.x += 2. * s * (1. - abs (dVu));\n    ro.y = 2. + 2. * (1. - abs (dVu));\n    vd = sbPos - ro;\n    vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n    dstFar = 50. * cvSize;\n    zmFac = 1.4;\n  } else if (inEnv && ! inCave) {\n    ro.xz = sbPos.xz + 24. * sin (0.01 * s * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n    ro.y = unWat ? -2. : 2.;\n    vd = sbPos - ro;\n    vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n    dstFar = 100.;\n    zmFac = unWat ? 2. : 4.;\n  } else if (! inEnv) {\n#if ISBOOK\n    ro = vec3 (0., 8., 24.);\n    vd = sbPos + vec3 (-1., 0., 0.) - ro;\n    vuMat = StdVuMat (atan (vd.y, length (vd.xz)), atan (vd.x, vd.z));\n    dstFar = 100.;\n    zmFac = 6.;\n#else\n    az += 0.05 * pi * tCur;\n    el -= 0.1 * pi * sin (0.04 * pi * tCur);\n    vuMat = StdVuMat (el, az);\n    dstFar = 60.;\n    zmFac = 5.;\n    ro = vuMat * vec3 (0., 0., -24.);\n#endif\n  }\n  ltPos = vuMat * vec3 (0., 1., 1.);\n  if (inEnv) {\n    sunDir = normalize (vec3 (1., 3., -1.));\n  } else {\n#if ISBOOK\n    sunDir = normalize (vec3 (-0.1, 0.4, 1.));\n#else\n    sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#endif\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  if (inEnv && unWat) {\n#if ISBOOK\n    uv *= vec2 (pgSize.z  / pgSize.x, 1.);\n#else\n    uv *= vec2 (9./16., 1./0.85);\n#endif\n    col *= 1. - 0.8 * smoothstep (0.9, 1., length (uv));\n  }\n  fCol = col;\n}\n\n#if ISBOOK\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 3.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.z / nRing;\n  bc = q.z;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (3.2, 0.011, 1.8);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = (idPage > 1.) ? vec3 (0.8, 0.8, 0.9) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz)) :\n         vec3 (0.1, 0.1, 0.6);\n      col4 = vec4 (c, 0.2);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (idPage > 1. && min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n#if ISBOOK\n  tpBook = max (0.35 * tCur - 1., 0.);\n  az = 0.;\n  el = -0.5 * pi;\n#endif\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n#if ISBOOK\n    tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n    msEl = 0.5 * pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n#else\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n#endif\n  }\n#if ISBOOK\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (3.2, 0., -20.);\n  zmFac = 9.5;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n  ro = vuMat * ro;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ExShowScene (ro, rd);\n#else\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}