{
    "Shader": {
        "info": {
            "date": "1574131392",
            "description": "Trying more stuff with hybrid raytracing/raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "3sySWm",
            "likes": 13,
            "name": "Strange Crystal 2",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "reflection",
                "refraction"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "#define FDIST 0.7\n#define PI 3.1415926\n\n\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(1., 1., 1.)\n\n#define ABSORPTION_RATE vec3(0.7, 0.5, 0.5)\n#define IOR 1.33\n#define SCATTER_FACTOR 0.02\n#define SAMPLES 25\n#define REFLECTIONS 4\n#define RAYMARCH_STEPS 15\n#define RAYMARCH_TOL 0.005\n\n#define TIME_T 2.\n#define TIME_H 2.\n#define TIME_L 10.\n\n\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pin = - k - n;\n    vec3 pout =  k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout) return -1.;\n    if (entering) {\n    \tnn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    } else {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nfloat boxsdf(in vec3 ro, in vec3 r) {\n    vec3 b = abs(ro) - r;\n    float d = max(b.x, max(b.y, b.z));\n    d += 0.005 * (1.+sin(50.*length(ro) - 2.*iTime));\n    return d;\n}\n\nvec3 boxgrad(in vec3 ro, in vec3 r) {\n    vec2 diff = vec2(RAYMARCH_TOL, 0.);\n    float dx = boxsdf(ro + diff.xyy, r) - boxsdf(ro - diff.xyy, r);\n    float dy = boxsdf(ro + diff.yxy, r) - boxsdf(ro - diff.yxy, r);\n    float dz = boxsdf(ro + diff.yyx, r) - boxsdf(ro - diff.yyx, r);\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat hybridbox(in vec3 ro, in vec3 rd, in vec3 r, out vec3 n, in bool entering) {\n    float t = box(ro, rd, r, n, entering);\n    if (t > 0.) {\n        for (int i=0; i<RAYMARCH_STEPS; i++) {\n            float dist = boxsdf(ro + t*rd, r);\n            t += (entering ? dist : -dist);\n            if (dist < RAYMARCH_TOL) {\n                n = boxgrad(ro + t*rd, r);\n                return t;\n            }\n        }\n    }\n    return -1.;\n}\n\nvec2 sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return vec2(-1.);\n    float tdiff = sqrt(disc);\n    float tin = -pd - tdiff;\n    float tout = -pd + tdiff;\n    ni = normalize(ro + tin * rd);\n    \n    return vec2(tin, tout);\n}\n\nvec3 bgcol(in vec3 rd) {\n    return mix(vec3(0., 0., 1.), vec3(0.6, 0.8, 1.), 1.-pow(abs(rd.z), 2.));\n}\n\n//raytrace the exterior surroundings\nvec3 background(in vec3 ro, in vec3 rd) {\n    float t = (-1. - ro.z)/rd.z;\n    if (t < 0.) return bgcol(rd);\n    vec2 uv = ro.xy+t*rd.xy;\n    if (max(abs(uv.x), abs(uv.y)) > 8.) return bgcol(rd);\n    vec2 checkers = smoothstep(vec2(GROUNDGRID*0.75), vec2(GROUNDGRID), abs(mod(uv, vec2(GROUNDSPACING))*2.-GROUNDSPACING));\n    float aofac = smoothstep(-0.5, 1., length(abs(uv)-min(abs(uv), vec2(0.75))));\n    return mix(vec3(0.2), vec3(1.), min(checkers.x,checkers.y)) * aofac;\n}\n\n//raytrace the insides\nvec3 insides(in vec3 ro, in vec3 rd, in float INNERRAD, in mat2 rot, out float tout) {\n    vec3 ni;\n    vec2 t = sphere(ro, rd, INNERRAD, ni);\n    vec3 ro2 = ro + t.x * rd;\n    // shading/texture\n    vec2 checkers = step(mod(rot * ro2.xy, vec2(0.25)), vec2(0.01));\n    vec3 tex = mix(vec3(1.), vec3(0., 0.7, 0.), abs(checkers.x-checkers.y));\n    float fac = -ni.z;\n    \n    //inner background\n    vec3 n;\n    float tb = box(ro, rd, vec3(INNERRAD), n, false);\n    vec3 rob = ro + tb * rd;\n    vec3 checkersb = abs(mod(rob.xyz, vec3(0.5))-0.25)*4.;\n    vec3 texb = mix(vec3(0., 0., 1.), vec3(0.), step(0.25, abs(abs(checkersb.x-checkersb.y)-checkersb.z)));\n    tout = mix(tb, t.x, step(0., t.x));\n    return mix(mix(vec3(0.5), texb, step(0., tb)) * 0.5, tex * fac, step(0., t.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t_osc = 0.5*(TIME_H+TIME_L)+TIME_T;\n    float h_l = 0.5*TIME_L/t_osc;\n    float h_h = (0.5*TIME_L+TIME_T)/t_osc;\n    float osc = smoothstep(0., 1., (clamp(abs(mod(iTime, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n    float INNERRAD = mix(0.5, 1.5, osc);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    \n    vec3 ni;\n    float t = hybridbox(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z + ro.yz * ni.x + ro.zx * ni.y;\n    \n    if (t > 0.) {\n        float ang = -iTime * 0.33;\n    \tfloat c = cos(ang);\n    \tfloat s = sin(ang);\n    \tmat2 rot = mat2(c, -s, s, c);\n        vec3 col = vec3(0.);\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        for (int i=0; i<SAMPLES; i++) {\n            \n            vec2 theta = rand2d(coords + float(i) * vec2(1., 0.) * vec2(104., -30.6));\n            theta *= vec2(2.*PI, SCATTER_FACTOR*PI);\n            vec3 n = vec3(cos(theta.x)*sin(theta.y), sin(theta.x)*sin(theta.y), cos(theta.y));\n            // reflection\n            vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n            vec3 rdr = reflect(rd, nr);\n            vec3 reflcol = background(ro, rdr);\n            \n            // refraction & insides\n            \n            //vec3 rd2 = rd.yzx * ni.x + rd.zxy * ni.y + rd.xyz * ni.z;\n            \n            vec3 rd2 = refract(rd, nr, 1./IOR);\n            \n            vec3 insidecol = vec3(0.);\n            float accum = 1.;\n            vec3 transmission = vec3(1.);\n            vec3 no2 = ni;\n            vec3 ro_refr = ro;\n            \n            for (int j=0; j<REFLECTIONS; j++) {\n                float tb;\n                //no2 = -no2;\n                vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n                vec3 eye2 = vec3(coords2, -max(INNERRAD, 1.));\n                vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n                rd2trans.z = -rd2trans.z;\n                vec3 internalcol = insides(eye2, rd2trans, INNERRAD, rot, tb);\n                if (tb > 0.) {\n                    //terminate at interior geometry\n                    insidecol += accum * internalcol * transmission * pow(ABSORPTION_RATE, vec3(tb));\n\t\t\t\t\tbreak;\n                } else {\n                    //compute contribution of the light leaked from the environment through this bounce\n                    float tout = hybridbox(ro_refr, rd2, BOXDIMS, no2, false);\n                    no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                    vec3 rout = ro_refr + tout * rd2;\n                    vec3 rdout = refract(rd2, -no2, IOR);\n                    float fresnel2 = R0 + (1.-R0) * pow(1.-dot(rdout, no2), 5.);\n                    rd2 = reflect(rd2, -no2);\n                    \n                    ro_refr = rout;\n                    ro_refr.z = max(ro_refr.z, -0.999);\n\n                    transmission *= pow(ABSORPTION_RATE, vec3(tout));\n                    insidecol += accum * (1.-fresnel2) * background(ro_refr, rdout) * transmission;\n                    if (fresnel2 < 0.1) break;\n                    accum *= fresnel2;\n                }\n            }\n            \n            // background\n            \n            float fresnel = R0 + (1.-R0) * pow(1.-dot(-rd, nr), 5.);\n            col += mix(insidecol, reflcol, fresnel);\n        }\n        col /= float(SAMPLES);\n\n        fragColor = vec4(col, 1.);\n    } else {\n\t\tfragColor = vec4(background(eye, rd), 1.);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}