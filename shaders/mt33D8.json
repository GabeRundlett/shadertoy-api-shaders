{
    "Shader": {
        "info": {
            "date": "1682330489",
            "description": "Motion along a 3D Hilbert path (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "mt33D8",
            "likes": 29,
            "name": "Hilbert Walk 3D",
            "published": 3,
            "tags": [
                "hilbert",
                "graycode",
                "peano"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "// \"Hilbert Walk 3D\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 6 in \"Hilbert\" series\n    \"Hilbert Square\"                   (MsGyDK)\n    \"Hilbert 3D\"                       (lltfRj)\n    \"Hilbert's Path\"                   (tl2fWG)\n    \"Hilbertian Saltation\"             (NtVfDh)\n    \"Looping Hilbertian Saltation\"     (DdXGWn)\n*/\n\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nconst int nBall = 100;\nconst int nDim = 3;\nconst int nBit = 4;\n\nstruct Hvec {\n  int u[nDim];\n};\n\nvec3 ltDir, qHit, qDir;\nfloat dstFar, tCur, segLen;\nint idObj, pathLen, qSeq;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n/*\n  Skilling's Gray-code Hilbert curve algorithm\n \n  Ref: Skilling, J., \"Programming the Hilbert Curve\", AIP Conf. Proc. 707, 381 (2004).\n \n  Source: http://www.inference.org.uk/bayesys/test/hilbert.c\n \n  Simplified by mla (flX3W8) including partial restriction to 3D case.\n \n  Alternative (simpler, and closer to original) adaptation used here.\n \n  Original copyright:\n\n     Filename:  hilbert.c\n     Version:   2 Dec 2003\n   \n     Copyright (c) 1996-2003 Maximum Entropy Data Consultants Ltd,\n     114c Milton Road, Cambridge CB4 1XE, England\n  \n     This library is free software; you can redistribute it and/or\n     modify it under the terms of the GNU Lesser General Public\n     License as published by the Free Software Foundation; either\n     version 2.1 of the License, or (at your option) any later version.\n     \n  Original function headers at end\n*/\n\nHvec AxesToTranspose (Hvec h)\n{\n  int t, q;\n  q = 1 << nBit;\n  for (int k = 0; k < nBit - 1; k ++) {\n    q >>= 1;\n    if ((h.u[0] & q) != 0) h.u[0] ^= q - 1;\n    for (int j = 1; j < nDim; j ++) {\n      t = q - 1;\n      if ((h.u[j] & q) == 0) {\n        t &= h.u[0] ^ h.u[j];\n        h.u[j] ^= t;\n      }\n      h.u[0] ^= t;\n    }\n  }\n  for (int j = 1; j < nDim; j ++) h.u[j] ^= h.u[j - 1];\n  t = h.u[nDim - 1];\n  for (int k = 1; k < nBit; k <<= 1) h.u[nDim - 1] ^= h.u[nDim - 1] >> k;\n  t ^= h.u[nDim - 1];\n  for (int j = nDim - 2; j >= 0; j --) h.u[j] ^= t;\n  return h;\n}\n\nHvec TransposeToAxes (Hvec h)\n{\n  int t, q;\n  t = h.u[nDim - 1] >> 1;\n  for (int j = nDim - 1; j > 0; j --) h.u[j] ^= h.u[j - 1];\n  h.u[0] ^= t;\n  q = 1;\n  for (int k = 0; k < nBit - 1; k ++) {\n    q <<= 1;\n    for (int j = nDim - 1; j > 0; j --) {\n      t = q - 1;\n      if ((h.u[j] & q) == 0) {\n        t &= h.u[0] ^ h.u[j];\n        h.u[j] ^= t;\n      }\n      h.u[0] ^= t;\n    }\n    if ((h.u[0] & q) != 0) h.u[0] ^= q - 1;\n  }\n  return h;\n}\n\nHvec LineToTranspose (int n) \n{\n  Hvec h;\n  int p, t;\n  p = 1 << (nBit - 1);\n  t = 1 << (nDim * nBit - 1);\n  for (int j = 0; j < nDim; j ++) h.u[j] = 0;\n  for (int k = 0; k < nBit; k ++) {\n    for (int j = 0; j < nDim; j ++) {\n      if ((n & t) != 0) h.u[j] |= p;\n      t >>= 1;\n    }\n    p >>= 1;\n  }\n  return h;\n}\n\nint TransposeToLine (Hvec h)\n{\n  int p, n, t;\n  p = 1 << (nBit - 1);\n  t = 1 << (nDim * nBit - 1);\n  n = 0;\n  for (int k = 0; k < nBit; k ++) {\n    for (int j = 0; j < nDim; j ++) {\n      if ((h.u[j] & p) != 0) n |= t;\n      t >>= 1;\n    }\n    p >>= 1;\n  }\n  return n;\n}\n\nvec3 LineToAxes3 (int n)\n{\n  Hvec h;\n  vec3 u;\n  h = TransposeToAxes (LineToTranspose (n));\n  for (int j = 0; j < nDim; j ++) u[j] = float (h.u[j]);\n  return u;\n}\n\nint AxesToLine3 (vec3 u)\n{\n  Hvec h;\n  for (int j = 0; j < nDim; j ++) h.u[j] = int (u[j]);\n  return TransposeToLine (AxesToTranspose (h));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, c, cP, cN;\n  float dMin, d, r;\n  int iSeg;\n  dMin = dstFar / 2.;\n  d = PrBoxDf (p, vec3 (1.));\n  if (d < 0.05) {\n    q = (p + 1.) / 2.;\n    r = 0.005;\n    c = floor (clamp (q, 0.5 * segLen, 1. - 0.5 * segLen) / segLen);\n    iSeg = AxesToLine3 (c);\n    if (iSeg > 0) {\n      cP = LineToAxes3 (iSeg - 1);\n      d = PrEECapsDf (q, (cP + 0.5) * segLen, (c + 0.5) * segLen, r);\n      if (d < dMin) {\n        qDir = c - cP;\n        qSeq = iSeg;\n      }\n      DMINQ (1);\n    } else cP = c;\n    if (iSeg < pathLen) {\n      cN = LineToAxes3 (iSeg + 1);\n      d = PrEECapsDf (q, (c + 0.5) * segLen, (cN + 0.5) * segLen, r);\n      if (d < dMin) {\n        qDir = cN - c;\n        qSeq = iSeg + 1;\n      }\n      DMINQ (1);\n    } else cN = c;\n    if (length (cN + cP - 2. * c) > 0.) {\n      d = PrSphDf (q - (c + 0.5) * segLen, 1.4 * r);\n      if (d < dMin) qSeq = iSeg;\n      DMINQ (2);\n    }\n    dMin *= 2.;\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp, vn;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  dMin = dstFar;\n  if (df > 0. && dn < df) dMin = dn;\n  return dMin;\n}\n\nvec3 BallPos (int k)\n{\n  vec3 p;\n  float tc;\n  int n, nn;\n  tc = 2. * tCur + float (k) * float (pathLen) / float (nBall);;\n  n = int (mod (tc, float (pathLen)));\n  nn = (n < pathLen) ? n + 1 : pathLen;\n  return (mix (LineToAxes3 (n), LineToAxes3 (nn), smoothstep (0.02, 0.98, fract (tc))) +\n     0.5) * segLen * 2. - 1.;\n}\n\nvec4 BallHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 u, vn;\n  float dMin, d, b, w;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    u = ro - BallPos (k);\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vn = (u + d * rd) / rad;\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n} \n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 db4;\n  vec3 col, vn;\n  float dstObj, nDotL, s;\n  col = vec3 (0.9, 0.9, 1.) * (0.7 + 0.2 * rd.y);\n  if (BlkHit (ro, rd, vec3 (1.)) < dstFar) {\n    segLen = 1. / float (1 << nBit);\n    pathLen = (1 << nDim * nBit) - 1;\n    db4 = BallHit (ro, rd, 0.025);\n    dstObj = ObjRay (ro, rd);\n    if (min (dstObj, db4.x) < dstFar) {\n      if (db4.x < dstObj) dstObj = db4.x;\n      ro += dstObj * rd;\n      if (dstObj == db4.x) {\n        vn = db4.yzw;\n        col = vec3 (1.);\n      } else {\n        vn = ObjNf (ro);\n        col = HsvToRgb (vec3 (mod (- float (qSeq) + 10. * tCur, float (pathLen)) /\n           float (pathLen), 0.7, 1.));\n        if (idObj == 1) {\n          qHit *= normalize (qDir);\n          s = (abs (qDir.x) > max (abs (qDir.y), abs (qDir.z))) ? qHit.x :\n             ((abs (qDir.y) > abs (qDir.z)) ? qHit.y : qHit.z);\n          col *= 0.6 + 0.4 * step (0.5, fract (8. * s / segLen - 2. * tCur));\n        }\n      }\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = col * (0.3 + 0.7 * nDotL * nDotL) +\n         0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  zmFac = 3.8;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 4. * abs (az);\n  } else {\n    az += 0.02 * pi * tCur;\n    el -= 0.05 * pi * sin (0.03 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.5);\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (0); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  return PrEVCapsDf (p - v1, vec4 (normalize (v2 - v1), length (v2 - v1)), r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\n// Original function headers:\n\n//=============================================================================\n//              Hilbert-curve (a space-filling Peano curve) library\n//=============================================================================\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: LineToAxes\n//            AxesToLine\n//\n// Purpose:   Serial Hilbert length  <---->   multidimensional Axes position.\n//\n//   Space  = n-dimensional hypercube of side R = 2^b\n//            Number of cells = N = R^n = 2^(n*b)\n//\n//   Line   = serial number of cell along Hilbert curve through hypercube\n//          = extended integer of n*b bits ranging from 0 to N-1,\n//            stored as vector of n unsigned b-bit integers with [0] high.\n//\n//   Axes   = Geometrical position of cell\n//          = n b-bit integers representing coordinates.\n//\n// Notes: (1) Unit change in Line yields single unit change in Axes position:\n//            the Hilbert curve is maximally local.\n//        (2) CPU proportional to total number of bits, = b * n.\n//\n// History:   John Skilling  20 Apr 2001, 11 Jan 2003, 3 Sep 2003\n//-----------------------------------------------------------------------------\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: LineToTranspose\n//            TransposeToLine\n//\n// Purpose:   Recover Hilbert integer by bit-transposition\n//\n// History:   John Skilling  20 Apr 2001, 3 Sep 2003, 14 Oct 2003\n//-----------------------------------------------------------------------------\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: TransposeToAxes\n//            AxesToTranspose\n//\n// Purpose:   Transform between Hilbert transpose and geometrical axes\n//\n// History:   John Skilling  20 Apr 2001, 3 Sep 2003, 14 Oct 2003\n//-----------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}