{
    "Shader": {
        "info": {
            "date": "1536878878",
            "description": "Hills background testing",
            "flags": 0,
            "hasliked": 0,
            "id": "4l3cDN",
            "likes": 1,
            "name": "Hills background testing",
            "published": 3,
            "tags": [
                "hills"
            ],
            "usePreview": 0,
            "username": "uqone",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "#define EPSILON 0.1\n\n#define time (iTime+285.)\n\nfloat hash( const in float n ) {\n\treturn fract(sin(n)*4378.5453);\n}\n\nfloat pnoise(in vec3 o) \n{\n\tvec3 p = floor(o);\n\tvec3 fr = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0 + p.z * 1009.0;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\tfloat c = hash(n+ 57.0);\n\tfloat d = hash(n+ 58.0);\n\t\n\tfloat e = hash(n+  0.0 + 1009.0);\n\tfloat f = hash(n+  1.0 + 1009.0);\n\tfloat g = hash(n+ 57.0 + 1009.0);\n\tfloat h = hash(n+ 58.0 + 1009.0);\n\t\n\t\n\tvec3 fr2 = fr * fr;\n\tvec3 fr3 = fr2 * fr;\n\t\n\tvec3 t = 3.0 * fr2 - 2.0 * fr3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat w = t.z;\n\n\t// this last bit should be refactored to the same form as the rest :)\n\tfloat res1 = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n\tfloat res2 = e + (f-e)*u +(g-e)*v + (e-f+h-g)*u*v;\n\t\n\tfloat res = res1 * (1.0- w) + res2 * (w);\n\t\n\treturn res;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat SmoothNoise( vec3 p )\n{\n    float f;\n    f  = 0.5000*pnoise( p ); p = m*p*2.02;\n    f += 0.2500*pnoise( p ); \n\t\n    return f * (1.0 / (0.5000 + 0.2500));\n}\n\nfloat hillnoise(in vec3 o) {\n \treturn SmoothNoise(o.xyy);   \n}\n\nmat2 rot(const in float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat fbm( in vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*hillnoise( p ); p = m3*p*1.22;\n    f += 0.2500*pnoise( p ); p = m3*p*1.53;\n    f += 0.1250*pnoise( p ); p = m3*p*4.01;\n    f += 0.0625*pnoise( p );\n    return f/0.9375;\n}\n\n// intersection functions\n\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. && d < dist ) {\n\t\tdist = d;\n\t\treturn true;\n    } else {\n\t\treturn false;\n\t}\n}\n\n// light direction\n\nvec3 lig = normalize(vec3( 0.3,0.5, 0.6));\n\nvec3 bgColor( const in vec3 rd ) {\n\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\treturn col;\n}\n\n// coulds functions by inigo quilez\n\n#define CLOUDSCALE (500./(64.*0.03))\n\nfloat cloudMap( const in vec3 p, const in float ani ) {\n\tvec3 r = p/CLOUDSCALE;\n\n\tfloat den = -1.8+cos(r.y*5.-4.3);\n\t\t\n\tfloat f;\n\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,1.0,15.0)*ani*0.15;\n    f  = 0.50000*hillnoise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\n    f += 0.25000*hillnoise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\n    f += 0.12500*hillnoise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\n    f += 0.06250*hillnoise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\n    f += 0.03125*hillnoise( q );\n\t\n\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\n}\n\nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\n    // dithering\t\n\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);\n\t\n    // raymarch\t\n\tvec4 sum = vec4( 0.0 );\n\tfor( int i=0; i<64; i++ ) {\n\t\tif( sum.a > 0.99 || t > maxdist ) continue;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tfloat a = cloudMap( pos, ani );\n\n        // lighting\t\n\t\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);\n\t\tvec4 col = vec4( (1.+dif)*fgc, a );\n\t\t// fog\t\t\n\t//\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n        // advance ray with LOD\n\t\tt += (0.03*CLOUDSCALE)+t*0.012;\n\t}\n\n    // blend with background\t\n\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\n\t\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\n\n// terrain functions\nfloat terrainMap( const in vec3 p ) \n{\n    float dist = pow(length(p) / 64.0, 0.2);\n    return ((fbm( (p.xzz*0.5+16.0)*0.00346 ) * 1.5 - 1.0)*250.0*dist)+(dist*8.0);\n}\n\nvec4 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist, inout bool hit ) {\n\tfloat t = startdist;\n    float alpha = 0.0;\n\n    // raymarch\t\n\tvec4 sum = vec4( 0.0 );\n\tvec3 col = vec3(0.0);//bgc;\n\t\n\tfor( int i=0; i<8; i++ ) {\n\t\tif( hit ) break;\n\t\t\n\t\tt += float(i*64);// + t/100.;\n\t\tvec3 pos = ro + t*rd;\n\t\t\n\t\tif( pos.y < terrainMap(pos) ) {\n\t\t\thit = true;\n\t\t}\t\t\n\t}\n\tif( hit ) {\n\t\t// binary search for hit\t\t\n\t\tfloat dt = 4.+t/400.;\n\t\tt -= dt;\n\t\t\n\t\tvec3 pos = ro + t*rd;\t\n\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\t\t\n\t\tfor( int j=0; j<2; j++ ) {\n\t\t\tpos = ro + t*rd;\n\t\t\tdt *= 0.5;\n\t\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\n\t\t}\n\t\tpos = ro + t*rd;\n\t\t\n\t\tvec3 dx = vec3( 100.*EPSILON, 0., 0. );\n\t\tvec3 dz = vec3( 0., 0., 100.*EPSILON );\n\t\t\n\t\tvec3 normal = vec3( 0., 0., 0. );\n\t\tnormal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);\n\t\tnormal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);\n\t\tnormal.y = 1.;\n\t\tnormal = normalize( normal );\t\t\n\n\t\t//col = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * vec3(1.,.9,0.6);\n\t\t\n\t\tfloat veg = 0.3*fbm(pos*0.2)+normal.y;\n\t\t\t\t\t\n\t\tif( veg > 0.75 ) {\n\t\t\tcol = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;\n\t\t} else \n\t\tif( veg > 0.66 ) {\n\t\t\tcol = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;\n\t\t}\n\t\tcol *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);\n\t\t\n\t\tvec3 brdf = col;\n\t\t\n\t\tfloat diff = clamp( dot( normal, -lig ), 0., 1.);\n\t\t\n\t\tcol = brdf*diff*vec3(1.0,.6,0.1);\n\t\tcol += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;\n\t\tcol += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;\n\t\t\n\t\tdist = t;\n\t\tt -= pos.y*3.5;\n        alpha = 1.0-clamp(exp(-0.0000005*t*t), 0.0, 1.0);\n\t\tcol = mix( col, bgc, alpha );\n\t}\n\treturn vec4(col, alpha >= 0.1 ? 1.0 : 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n\t// camera parameters\n\tvec3 ro = vec3(0.0, 0.5, 0.0);\n\tvec3 ta = vec3(0.0, 0.45,1.0);\n\tif (iMouse.z>=1.) {\n\t\tta.xz *= rot( (iMouse.x/iResolution.x-.5)*7. );\n\t}\n\t\t\n\t//ta.xz *= rot( mod(iTime * 0.05, 6.2831852) );\n    \n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\tfloat fresnel, maxdist = 1200.;\n\tvec3 normal;\n    vec4 col = vec4(bgColor( rd ), 1.0);\n\tvec3 roo = ro, rdo = rd, bgc = col.rgb;\n\n    bool hit = false;\n\tcol = raymarchTerrain( ro, rd, col.rgb, 1200., maxdist, hit );\n    //col = raymarchClouds( ro, rd, col, bgc, 150., maxdist, time*0.05 );\n\t\n\tcol.rgb = pow( col.rgb, vec3(0.7) );\n\t\n\t// contrast, saturation and vignetting\t\n\tcol.rgb = col.rgb*col.rgb*(3.0-2.0*col.rgb);\n    col.rgb = mix( col.rgb, vec3(dot(col.rgb,vec3(0.33))), -0.5 );\n \t//col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = mix(vec4(1.0, 0.0, 0.0, 1.0), vec4( col.rgb, 1.0 ), col.a);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}