{
    "Shader": {
        "info": {
            "date": "1617625709",
            "description": "A hand sanitiser bottle.\n...I tried.\n\nI _think_ this is my first properly 3d prod.\nContains code from yx, Alia, noby, Mercury, iq, and stackoverflow which has been smooshed together to create a path tracer.",
            "flags": 32,
            "hasliked": 0,
            "id": "3ttBRB",
            "likes": 14,
            "name": "Sanitised",
            "published": 3,
            "tags": [
                "caustics",
                "handsanitiser"
            ],
            "usePreview": 0,
            "username": "Molive",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "//uniform sampler2D T;\n//layout(location = 2) uniform vec3 TexCoord;\n#define TexCoord vec3(iResolution.xy,0)\n#define T iChannel0\nconst float a = 3.;\n\n#define Radius 3\n\nvec3 neighborhoods[Radius*Radius];\n\n\nvoid getNeighborhoods(vec2 coord)\n{\n    vec2 step1 = vec2(1.0)/TexCoord.xy;\n    \n    for (int i = 0; i < Radius*Radius; i++)\n    {\n        vec4 color = texture(T, coord + vec2(i/Radius, mod(float(i), float(Radius)))*step1);\n        neighborhoods[i] = a*color.rgb/color.a;\n    }\n}\n\nvoid sortNeighborhoods()\n{\n    for(int i = 0; i < Radius*Radius/2-1; i++)\n    {\n         for (int j=0; j < (Radius*Radius -1-i); j++)\n         {\n              if (length(neighborhoods[j+1]) > length(neighborhoods[j]))\n              { \n                    vec3 temp = neighborhoods[j];\n                    neighborhoods[j] = neighborhoods[j+1];\n                    neighborhoods[j+1] = temp;\n              }\n          }\n     }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{  \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 tex=texture(T,uv);\n    vec3 c= a*tex.rgb/tex.a;\n\n    vec3 color = c;\n    \n        float n = length(color);\n    color*=pow(n,1.5)*6.;\n\n\tcolor=color*(1.+(color/10.))/(1.+color);\n\n\n    \n\tuv-=.5;   \n    // gamma correction and a slight blue color grading\n\tcolor=pow(color, .45*vec3(1.0,1.1,1.2))*(1.-dot(uv,uv)*.75);\n    \n\tfragColor.rgb=color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi (acos(-1.))\n\nconst int matDiffuse=0;\nconst int matMirror=1;\nconst int matBlack=2;\nconst int matLiquid=3;\nconst int matFloor=4;\nconst int matLight=5;\nconst int matPlastic=6;\nconst int matBound=7;\nconst int matPipe=8;\nconst vec3 lightpos=vec3(24.,12.,-29.);\n//const vec3 lightpos=vec3(19.,12.,-23.);\n#define Epsilon 1.000001\n#define pixelRadius 0.0001\n\n//A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n//float seed;\n//float hash() {\n//\tfloat p=fract((seed++)*.1031);\n//\tp+=(p*(p+19.19))*3.;\n//\treturn fract((p+p)*p);\n//}\n//\n//vec2 hash2() {\n//    return vec2(hash(),hash());\n//}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nvec2 random( uvec2  v ) {return vec2(floatConstruct(hash( v.x ^ hash(v.y))),floatConstruct(hash( v.y ^ hash(v.x))));}\n\nvec2 uv;\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n    /// Returns a point on a sphere, r is in 0..1 range\nvec3 pointOnSphere(vec2 r) {\n    r=vec2(6.283185*r.x,2.*r.y-1.);\n    return vec3(sqrt(Epsilon-r.y*r.y)*vec2(cos(r.x),sin(r.x)),r.y); // 1.001 required to avoid NaN\n}\n \n    /// Returns a cosine weighted sample\nvec3 lambertSample(vec3 n,vec2 r) {\n    return normalize(n*Epsilon+pointOnSphere(r)); // 1.001 required to avoid NaN\n}\n\nvec4 iCylinderInverse( in vec3 ro, in vec3 rd, \n                in vec3 cb, in vec3 ca, float ra ) // extreme a, extreme b, radius\n{\n    vec3  oc = ro - cb;\n    \n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float k2 = 1.            - card*card;\n    float k1 = dot(oc,rd) - caoc*card;\n    float k0 = dot(oc,oc) - caoc*caoc - ra*ra;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);\n    h = sqrt(h);\n    float t = (-k1+h)/k2;\n\n    // body\n    float y = caoc + t*card;\n    return vec4( t, (oc+t*rd - ca*y)/-ra );\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 cb, in vec3 ca, float ra ) // extreme a, extreme b, radius\n{\n    vec3  oc = ro - cb;\n    \n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float k2 = 1.            - card*card;\n    float k1 = dot(oc,rd) - caoc*card;\n    float k0 = dot(oc,oc) - caoc*caoc - ra*ra;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return (-k1-h)/k2;\n}\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// sphere of size ra centered at point ce\nvec4 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(-1.0); // no intersection\n    h = sqrt( h );\n    float t = (-b-h);\n    return vec4( t, (oc+t*rd)/ra );\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, float c )\n{\n  return length(p.xz)-c;\n}\n\nvec2 hash2( float p ) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nvec3 opCheapBend(in vec3 p )\n{\n    const float k = 10.0; // or some other amount\n    float  c = cos(k*p.z);\n    float  s = sin(k*p.z);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.zx,p.y).yzx;\n}\n\n// hacky parameter to control the size\nfloat T=4.;\n\nint mat;\nfloat inv;\n\n// distance function\nfloat sdScene(vec3 p)\n{\n    mat = matBlack;\n    float d = 1e9;\n    \n    //d = min(d,sdSphere(p,T));\n    \n    float top = sdRoundedCylinder(p-vec3(0,10.7,0), 0.3*T, 0.1*T, 0.35*T);\n    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,12.5,0), 0.25*T, 0.05*T, 0.15*T),0.2);\n    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,15,0), 0.08*T, 0.05*T, 0.6*T),0.2);\n    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,16.2,0), 0.1*T, 0.05*T, 0.25*T),0.2);\n    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,16.7,0), 0.23*T, 0.15*T, 0.01),0.2);\n    top = fOpUnionRound(top,sdRoundedCylinder(p.xzy-vec3(0,2.5,17.-p.z*p.z*0.03), 0.06*T, 0.05*T, 0.5*T),0.2);    \n    \n    float glass = min( \n    max(\n    sdRoundedCylinder(p, 0.85*T, 0.2*T, 0.75*T),\n    -sdSphere(p+vec3(0,6.7*T,0),6.0*T)),\n    max(\n    sdSphere(p*vec3(1.0,3.6/T,1.0)-vec3(0,0.75*3.6,0),1.7*T),\n    2.0-p.y)\n    );\n    \n    float tube = sdCylinder(p+vec3(0.,0.,sin(p.y/4.)-0.9), 0.15*T);\n    //if (max(tube,glass) < d) {mat = matPipe;}  \n\n    top = max(top,-glass);   \n    glass = fOpUnionRound(glass,top,0.2);\n    top = max(top,-glass);\n    glass = max(glass,-tube);\n    \n    if (top < d) {mat = matPlastic;}\n    d=min(d,top);\n    \n    if (glass < d) {\n    /*if (abs(p.y)<2.7) mat = matPlastic;\n    else mat = matLiquid;*/\n        if (tube > glass) {\n            mat = matLiquid;\n        } else {\n        if (p.y > 8.) {\n            mat = matPlastic;\n        } else {\n            mat = matPipe;\n        }\n        }\n    }\n    d = min(d, glass);\n    //vec3 q = opCheapBend(p);\n\n    //d = min(d,max(tube,glass));\n\n    /*float top = min(\n    sdRoundedCylinder(p, 0.85*T, 0.2*T, 0.75*T),\n    );*/\n    //mat = matDiffuse;\n    float fl= fPlane(p,vec3(0,1,0),4.);\n       if (fl < d) {mat = matDiffuse;}\n    d=min(d,fl);\n    \n    return inv*d;\n}\n\n// intersection function\nvec4 iScene(vec3 ro, vec3 rd)\n{\n    mat = matBound;\n    float innerScene = iCylinder(ro,rd,vec3(0.),vec3(0.,1.,0.),1.7*T);\n    if (innerScene > 0. && (ro+rd*innerScene).y >= -4.) return vec4(innerScene,0.,0.,0.);\n    mat = matLight;\n    vec4 light = sphIntersect(ro,rd,lightpos,4.);\n    if (light.x > 0.) return light;\n    mat = matDiffuse;\n    float plane = plaIntersect(ro, rd, vec4(0,1,0,4));\n    if (plane > 0. && (ro+rd*plane).x >= -10.) return vec4(plane, 0.,1.,0.);\n    vec4 curve = iCylinderInverse(ro,rd, vec3(-10.,11.,0.), vec3(0.,0.,1.),15.);\n    if (curve.x > 0. && ro.x+rd.x*curve.x <= -10.) return curve;\n    return vec4(0);\n}\n\nfloat err(float dist){\n    dist = dist/100.0;\n    return min(0.01, dist*dist);\n}\n\nvec3 dr(vec3 origin, vec3 direction, vec3 position){\n    const int iterations = 3;\n    for(int i = 0; i < iterations; i++){\n        position = position + direction * (sdScene(position) - err(distance(origin, position)));\n    }\n    return position;\n}\n\nvec2 rv2;\nint bounce = 0;\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    const vec3 lightdir = normalize(vec3(.7,.4,-1));\n    \n    const float THRESHOLD = .02;\n\n    vec3 accum = vec3(1);\n    bool inside = false;\n    for(bounce = 0;bounce<3;bounce++)\n    {\n        float t = 0.;\n        float k = 0.;\n        vec3 n = vec3(1,0,0);\n        vec3 h = vec3(0);\n        rv2 = random(uvec2(abs(rv2*2000.)));\n        \n        while (true) {\n            t = 0.;\n            k = 0.;\n            n = vec3(1,0,0);\n            h = vec3(0);\n            mat = matBlack;\n            if (length(cam.xz) > 1.7*T+THRESHOLD) {\n                inside = false;\n                vec4 scene = iScene(cam,dir);\n                if (scene.x > 0.) \n                {\n                    t = scene.x;\n                    n = scene.yzw;\n                    h = cam+dir*t;\n                    k = THRESHOLD;\n                }\n            } else {\n                inv = inside ? -1. : 1.;\n                t = 0.;\n                k = 0.;\n                for(int i=0;i<80;++i)\n                {\n                    k = sdScene(cam+dir*t);\n                    if (abs(k) < THRESHOLD) {\n                        h = dr(cam,dir,cam+dir*t);\n                        vec2 o = vec2(.001, 0);\n                        n = normalize(vec3(\n                            sdScene(h+o.xyy)-sdScene(h-o.xyy),\n                            sdScene(h+o.yxy)-sdScene(h-o.yxy),\n                            sdScene(h+o.yyx)-sdScene(h-o.yyx)\n                        ));\n                        break;\n                    }\n                    t += k;\n                    vec3 pos = cam+dir*t;\n                    if (length(pos.xz) > 1.7*T+THRESHOLD) {\n                        h = cam+dir*(t+THRESHOLD);\n                        mat = matBound;\n                        break;\n                    }\n                    if (pos.y > 25.) {\n                    return vec3(0);\n                    }\n                }\n            }\n            if (mat == matBound) {\n                cam = h;\n                continue;\n            } else {\n                break;\n            }\n        }\n        \n\n        \n        if (abs(k)<=THRESHOLD) {\n            // if we hit something\n\n            float fresnel = pow(1.-dot(-dir,n),5.);\n            fresnel*=1.-step(.99,fresnel);\n            \n            // debug normals visualization\n            //if (mat != matBound)\n            //return (n*.5+.5) * (.7+.3*step(1.4,length(step(.1,fract(h.xz-.5)))));\n\n            if (mat == matDiffuse)\n            {\n                // bounce the ray in a random direction\n                if (rv2.x > 0.) {\n                    dir = lambertSample(n,rv2);\n                } else {\n                    dir = normalize(lightpos + lambertSample(n,rv2) * 6. - cam);\n                }\n                accum *= dot(dir,n);\n            }\n            else if (mat == matLight)\n            {\n                return accum * vec3(10.,11.,12.) * step(.8,dot(dir,lightdir));\n            }\n            else if (mat == matBlack)\n            {\n                accum *= fresnel*.99+.01;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matPlastic)\n            {\n                if (rv2.y < 0.02) {\n              dir = reflect(dir, n);\n                 } else {\n                 dir = lambertSample(n, rv2.yx);\n                 }\n              accum *= fresnel*.1+.9;\n              accum *= dot(dir,n);\n            }\n            else if (mat == matMirror)\n            {\n                n += sin(h*4.).bgr*.001;\n                n += sin(h*3.77).bgr*.001;\n                n += sin(h*.737).bgr*.001;\n                \n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matFloor)\n            {\n                // grid lines\n                float gridscale=2.;\n                vec3 a = 1.-step(.49,abs(fract(h*gridscale)-.5));\n                float f=min(a.z,a.x);\n            \n                // checkerboard\n                gridscale=.25;\n                h.xz++;\n                f*=.8-step(.0,(fract(h.x*gridscale)-.5)*(fract(h.z*gridscale)-.5))*.3;\n            \n                dir = lambertSample(n,rv2);\n            \taccum *= f;\n            }\n            else if (mat == matLiquid || mat == matPipe)\n            {     \n               /* if (abs(h.y)<2.7) {\n            \n                                // Find reflection angle, accounting for surface roughness\n                    vec3 dir = normalize( // Ray dir must be normalised\n                          mix( // Mix between...\n                              reflect(dir, n), // the reflected angle\n                              lambertSample(n, rv2), // and a random angle projected into the surface\n                              0.02 // based on how smooth the glass surface is\n                              )\n                          );\n                          accum *= fresnel*.7+.3;\n                          }*/\n                          \n    \n                // Randomly reflect or refract, probability based on fresnel term\n                // If non-fresnel, refract\n                if (rv2.x > fresnel) {\n                    // refraction\n                    // Index of refraction\n                    float ior = mat == matLiquid ? inside ? 1.364 : 1./1.364: inside ? 1.460/1.364 : 1.364/1.460;\n        \n                    // Find refraction angle, accounting for surface roughness\n                    vec3 rayDir = normalize( // Ray dir must be normalised\n                          mix( // Mix between...\n                              refract(dir, n, ior), // the refracted angle\n                              lambertSample(-n, rv2), // and a random angle projected into the surface\n                              mat == matLiquid ? 0.01 : 0.05 // based on how smooth the glass surface is\n                              )\n                          );\n        \n                    // Test for total internal reflection\n                    if(dot(n, dir) < 0.0) {\n                        // Not TIR, we're OK to refract\n            \n                        // Set the ray direction\n                        dir=rayDir;\n            \n                        // Flip the inside value as we pass through the surface\n                        inside=!inside;\n                        bounce--;\n                        cam = h + dir * 2. * max(THRESHOLD * 4.,abs(k));\n\n                        if (!inside) {\n                        accum *= vec3(1.) - t * vec3(0.,0., mat == matLiquid ? 0.01 : 0.02);\n                        }\n                        continue;\n                    }\n                }\n    \n                // Ray failed to refract, therefore reflection\n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            } else {\n            return vec3(0,0,1);\n            }\n            \n            cam = h + dir * THRESHOLD * 1.1 / dot(dir,n);\n        }\n        else {\n        bounce++;\n        break;\n        }\n    }\n    return vec3(0);\n}\n\nvec2 ringDof(vec2 seed)\n{\n    seed=fract(seed);\n    if (seed.y>seed.x)\n        seed=1.-seed;\n    float r=seed.x;\n    float a=(seed.y/seed.x)*pi*2.;\n    return vec2(cos(a),sin(a))*r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // grab the previous color so we can iteratively render.\n    // in the actual executable I just rendered additively to a single framebuffer instead\n   \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    uv = fragCoord.xy/iResolution.xy-.5;\n\n    // random function borrowed from I can't remember where\n    float seed = float(((int(iFrame*73856093))^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\trv2 = hash2( 24.4316544311+float(iFrame)+seed );\n    //rv2 = random(uvec2(normalize(abs(vec2(seed, 24.4316544311+iFrame+seed)))*20000.0));\n\n    \n    // jitter camera for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // make a camera\n\tvec3 cam = vec3(1.,5.,-80.);\n    vec3 dir = normalize(vec3(uv,2.5));\n\n    // slight jitter for dof\n    //const float dofScale = .05 ;\n    //const float dofDist = 10.;\n    //vec2 dofJitter = ringDof(rv2);\n    //cam.xy += dofJitter*dofScale;\n    //dir.xy -= dofJitter*dofScale/dofDist;\n\n    // spin it to an isometric angle\n    cam.yz = rotate(cam.yz, pi/16.);\n    dir.yz = rotate(dir.yz, pi/16.);\n    \n    // debug camera rotation\n    //if (iMouse.z > 0.) {\n    //    float a = .8-2.*(iMouse.y/iResolution.y);\n    //\tcam.yz = rotate(cam.yz, a);\n    //\tdir.yz = rotate(dir.yz, a);\n    //}\n\n    // spin it to an isometric angle\n    cam.xz = rotate(cam.xz, pi/2.);\n    dir.xz = rotate(dir.xz, pi/2.);\n    \n    // debug camera rotation\n    //if (iMouse.z > 0.) {\n    //    float a = 1.-4.*(iMouse.x/iResolution.x);\n    //\tcam.xz = rotate(cam.xz, a);\n    //\tdir.xz = rotate(dir.xz, a);\n    //}\n    \n    // compute the pixel color\n    vec3 pixel = vec3(0);\n    for (int i = 0; i < 8; i++) {\n        pixel += trace(cam,dir);\n    }\n    pixel /= 8.;\n   \n    // reset buffer if we're clicking\n    // if (iMouse.z > 0.) gl_FragColor *= .1;\n\n    // accumulate the pixel\n    if(pixel.r >= 0.)\n    fragColor += vec4(pixel,1);\n    \n    //gl_FragColor = vec4(random(uvec2(abs(uv*1000.))),1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}