{
    "Shader": {
        "info": {
            "date": "1563569718",
            "description": "Chaos Communication Camp 2019\n\nBased on the artwork by Sven Sedivy (graphorama)\nSee https://events.ccc.de/2019/07/09/design-release-chaos-communication-camp-2019/",
            "flags": 32,
            "hasliked": 0,
            "id": "3lsSR2",
            "likes": 29,
            "name": "CCCamp 2019",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "glow",
                "distance",
                "cubic",
                "neon",
                "ccc",
                "camp",
                "2019",
                "fairydust"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 1418
        },
        "renderpass": [
            {
                "code": "/*\nGlow is computed by approximated euclidean distance to the cubic bezier curves\nwith the hybrid mode from https://www.shadertoy.com/view/3lsSzS\n*/\n\nconst vec3 fairydust1_col = vec3(0,.463,.729);\nconst vec3 fairydust2_col = vec3(1.,.776,0.);\nconst vec3 fairydust3_col = vec3(.6,.729,0.);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 coord = gl_FragCoord.xy;\n    \n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    border = 2./iResolution.y;\n    \n    vec3 color = vec3(0);\n    \n    vec3 f1_col = vec3(1.,.776,0.);\n    vec3 f2_col = vec3(0,.463,.729);\n    vec3 f3_col = vec3(.6,.729,0.);\n\n    vec4 tex1 = texture(iChannel0,uv);\n    float d1 = tex1.a;\n    vec3 col1 = tex1.rgb;\n    \n    vec4 tex2 = texture(iChannel1,uv);\n    float d2 = tex2.a;\n    vec3 col2 = tex2.rgb;\n    \n    vec4 tex3 = texture(iChannel2,uv);\n    float d3 = tex3.a;\n    vec3 col3 = tex3.rgb;\n    \n    if(d1 < d2){\n        float ratio = d1/d2;\n        float lambda = ratio/(ratio+1.);\n    \tcolor = (1.-lambda)*col1+lambda*col2;\n    }\n    else{\n        if(d3 < d2){\n            float ratio = d3/d2;\n            float lambda = ratio/(ratio+1.);\n            color = (1.-lambda)*col3+lambda*col2;\n        }\n        else{\n            if(d1 < d3){\n                float ratio = d1/d2;\n        \t\tfloat lambda = ratio/(ratio+1.);\n    \t\t\tcolor = (1.-lambda)*col1+lambda*col2;\n            }\n            else{\n                float ratio = d3/d2;\n            \tfloat lambda = ratio/(ratio+1.);\n            \tcolor = (1.-lambda)*col3+lambda*col2;\n            }\n        }\n    }\n    \n    color += vec3(.01*(hash(coord+100.*mod(iTime,10.))-.5));\n    \n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int num_segments = 5;\n\nfloat border;\n\nconst float inner_size_base = .004;\nfloat inner_size = inner_size_base;\nconst float line_size = .005;\nconst float border_size = .006;\nconst float glow_size = .03;\nconst float glow_size2 = .3;\nconst float shadow_size = .015;\n\nconst float brightness_cutoff = .5;\n\nconst vec3 bg_col = vec3(0);\nconst vec3 inner_col = vec3(1);\nconst float border_fac = .1;\nfloat glow_fac = .4;\nfloat glow_fac2 = .3;\n\nconst float glow_gamma = .6;\n\nfloat seed2;\n\n//derivative of ssteppow by tholzer, see https://www.shadertoy.com/view/ltjcWW\nfloat diff(float x){\n\tfloat ix = 1.-x;\n\n\tfloat xp = pow(x,.75);\n\tfloat ixp = pow(ix,.75);\n\n\tfloat xp2 = xp*x;\n\tfloat ixp2 = ixp*ix;\n\n\tfloat sum = xp2+ixp2;\n\n\treturn -1.75*xp2*(xp - ixp)/(sum*sum) + 1.75*xp/sum;\n}\n\nfloat sstep_diff(float edge0, float edge1, float x){\n\tx = clamp((x - edge0) / (edge1 - edge0),0.,1.);\n\treturn diff(x)/(edge1-edge0);\n}\n\nfloat curve_diff(float x){\n\tfloat sgn = sign(x);\n\tx = abs(x);\n\n\tfloat w = inner_size_base;\n\tfloat h = .2;\n\n\treturn sgn*sstep_diff(w,0.,x)*h;\n}\n\nvec3 composit_tube_col_dark(float dis, vec2 dir, vec3 ground_col, vec3 cur_col){\n    vec3 col = cur_col;\n\n\tvec3 nor = normalize(vec3(dir*abs(curve_diff(dis)),1));\n\tvec3 light_dir = normalize(vec3(-.8,1.,1.));\n\tvec3 view = vec3(0,0,1);\n\tvec3 halfway = normalize(view+light_dir);\n\n\tvec3 tube_col = clamp(dot(nor,light_dir),0.,1.)*ground_col*.02;\n\ttube_col += vec3(pow(clamp(dot(nor,halfway),0.,1.),50.))*.2;\n\n\ttube_col = pow(tube_col,vec3(.4545));\n\n\tcol = col*clamp(dis/shadow_size,0.,1.);\n    col = mix(tube_col,col,smoothstep(0., border, dis-border_size));\n    \n    return col;\n}\n\nvec3 composit_tube_col(float dis, vec3 ground_col, vec3 cur_col){\n    vec3 col = cur_col;\n    \n    vec3 tube_col = vec3(0);\n    tube_col = mix(border_fac*ground_col,tube_col,smoothstep(0., border, dis-border_size));\n    tube_col = mix(ground_col,tube_col,smoothstep(0., border, dis-line_size));\n\ttube_col = mix(inner_col,tube_col,clamp(dis/inner_size,0.,1.));\n    col = mix(tube_col,col,smoothstep(0., border, dis-border_size));\n    \n    return col;\n}\n\nvec3 composit_glow_col(float dis, vec3 ground_col, vec3 cur_col){\n    vec3 col = cur_col;\n    \n\tcol = mix(glow_fac2*ground_col,col,clamp(dis/glow_size2,0.,1.));\n\tcol = mix(glow_fac*ground_col,col,pow(clamp(dis/glow_size,0.,1.),glow_gamma));\n\n    return col;\n}\n\n//Hash function by Dave Hoskin (https://www.shadertoy.com/view/4djSRW)\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\n//Hash function by MBR (https://www.shadertoy.com/view/Xdy3Rc)\n#define W0 0.5545497\n#define W1 0.308517\nfloat hash(vec2 c){\n  float x = c.x*fract(c.x * W0);\n  float y = c.y*fract(c.y * W1);\n\n  return fract(x*y);\n}\n\nfloat cub_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2 = a2+t*a3;\n\tvec2 a_1 = a1+t*a_2;\n\tvec2 b_2 = a_2+t*a3;\n\n\tvec2 uv_to_p = a0+t*a_1;\n\tvec2 tang = a_1+t*b_2;\n\n\tfloat l_tang = dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cub_bezier_normal_iteration2(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2 = a2+t*a3;\n\tvec2 a_1 = a1+t*a_2;\n\tvec2 b_2 = a_2+t*a3;\n\n\tvec2 uv_to_p = a0+t*a_1;\n\tvec2 tang = a_1+t*b_2;\n\tvec2 snd_drv = 2.*(b_2+t*a3);\n\n\tfloat l_tang = dot(tang,tang);\n\n\tfloat fac = dot(tang,snd_drv)/(2.*l_tang);\n\tfloat d = -dot(tang,uv_to_p);\n\n\tfloat t2 = d/(l_tang+fac*d);\n\n\treturn t+t2;\n}\n\n//segment code based on iq's code (see https://www.shadertoy.com/view/XdVBWd)\nfloat length2(vec2 v) { return dot(v,v); }\n\nvec2 segment_to_p(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn pa-ba*h;\n}\n\nvec2 shortest_dir(inout float cur_dis, vec2 a, vec2 b){\n\tfloat dis = length2(b);\n\tif(cur_dis < dis){\n\t\treturn a;\n\t}\n\telse{\n\t\tcur_dis = dis;\n\t\treturn b;\n\t}\n}\n\nvec2 cubic_bezier_segments_to_p(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float d0 = 1e38;\n\tvec2 dir = vec2(1e38);\n    vec2 a = p0;\n    for( int i=1; i<num_segments; i++ )\n    {\n        float t = float(i)/float(num_segments-1);\n        float s = 1.0-t;\n        vec2 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n\t\tdir = shortest_dir(d0,dir,segment_to_p(uv, a, b));\n        a = b;\n    }\n    \n    return dir;\n}\n\nvec2 approx_cubic_bezier_to_p(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\tvec2 dir = vec2(1e38);\n\n\tconst int num_its = 2;\n\n\tfloat t;\n\tvec3 params = vec3(0,.5,1);\n\n\tfor(int i=0;i<3;i++){\n\t\tt = params[i];\n\t\tfor(int j=0;j<num_its;j++){\n\t\t\tt = cub_bezier_normal_iteration2(t,a0,a1,a2,a3);\n\t\t}\n\t\tt = clamp(t,0.,1.);\n\t\tvec2 uv_to_p = ((a3*t+a2)*t+a1)*t+a0;\n\t\tdir = shortest_dir(d0,dir,-uv_to_p);\n\t}\n\n\tif(d0 > .005){\n\t\tdir = shortest_dir(d0,dir,cubic_bezier_segments_to_p(uv,p0,p1,p2,p3));\n\t}\n\n\treturn dir;\n}\n\nvec2 mirror_point(vec2 p){\n\treturn vec2(-(p.x),p.y);\n}\n\nfloat single_sawtooth(float t, float start, float width, float height){\n\tif(t < start || t > start+width){\n\t\treturn 0.;\n\t}\n\telse{\n\t\treturn (t-start)*height/width;\n\t}\n}\n\nfloat brightness_func(float t, float seed){\n\tfloat rand_dt = .1;\n\n\tfloat t0 = floor(t/rand_dt)*rand_dt;\n\tfloat t1 = ceil(t/rand_dt)*rand_dt;\n\n\tfloat rand_depth = .2;\n\n\tfloat rand_val0 = hash11(t0+seed*seed2);\n\tfloat rand_val1 = hash11(t1+seed*seed2);\n\n\tfloat rand_val = rand_depth*mix(rand_val0,rand_val1,t-t0);\n\n\tfloat spike_duration = .1;\n\n\tfloat start1 = 0.9+.1*hash11(seed*seed2+.5423098);\n\tfloat start3 = 1.8+.1*hash11(seed*seed2+.9130482);\n\tfloat start4 = 3.0+.1*hash11(seed*seed2+.7358364);\n\n\tfloat start2 = start1+spike_duration;\n\n\tfloat start5 = start4+spike_duration;\n\tfloat start6 = start5+spike_duration;\n\tfloat start7 = start6+spike_duration;\n\n\tfloat intensity1 = .2;\n\tfloat intensity2 = .5;\n\tfloat intensity3 = .8;\n\n\tfloat val = 0.;\n\tval += single_sawtooth(t,start1,spike_duration,intensity1);\n\tval += single_sawtooth(t,start2,spike_duration,intensity1);\n\n\tval += single_sawtooth(t,start3,spike_duration,intensity2);\n\n\tval += single_sawtooth(t,start4,spike_duration,intensity3);\n\tval += single_sawtooth(t,start5,spike_duration,intensity3);\n\tval += single_sawtooth(t,start6,spike_duration,intensity3);\n\n\tval += clamp((t-start7)/spike_duration,0.,1.);\n\n\tif(t > start7+spike_duration){\n\t\tval+=rand_val;\n\t}\n\n\treturn val;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const vec2 p_0 = vec2(-0.3397095857142857,-0.12086985714285703);\nconst vec2 q_0 = vec2(-0.32898295714285714,-0.08835985714285699);\nconst vec2 r_0 = vec2(-0.26115762857142855,0.13549671428571441);\n\nconst vec2 p_1 = vec2(-0.35183894285714284,0.23409928571428584);\nconst vec2 q_1 = vec2(-0.37972818571428574,0.26446385714285725);\nconst vec2 r_1 = vec2(-0.39127994285714285,0.2739528571428571);\n\nconst vec2 p_2 = vec2(-0.39557060000000005,0.28773242857142844);\nconst vec2 q_2 = vec2(-0.3991186428571429,0.2992017142857142);\nconst vec2 r_2 = vec2(-0.40373934285714286,0.3273384714285714);\n\nconst vec2 p_3 = vec2(-0.4030792428571428,0.3345995857142856);\nconst vec2 q_3 = vec2(-0.40299667142857143,0.3355072142857143);\nconst vec2 r_3 = vec2(-0.4072048714285714,0.3010994285714286);\n\nconst vec2 p_4 = vec2(-0.4135583428571428,0.28781499999999993);\nconst vec2 q_4 = vec2(-0.4250275857142857,0.26388628571428563);\nconst vec2 r_4 = vec2(-0.4515141285714286,0.2549750000000002);\n\nconst vec2 p_5 = vec2(-0.4454907142857143,0.23987514285714306);\nconst vec2 q_5 = vec2(-0.43517664285714286,0.21413128571428586);\nconst vec2 r_5 = vec2(-0.39210507142857143,0.21602900000000025);\n\nconst vec2 p_6 = vec2(-0.37188950000000004,0.20167185714285707);\nconst vec2 q_6 = vec2(-0.34284507142857146,0.18104371428571442);\nconst vec2 r_6 = vec2(-0.3434226571428572,0.1496064285714287);\n\nconst vec2 p_7 = vec2(-0.35810990000000004,0.13104099999999974);\nconst vec2 q_7 = vec2(-0.37568507142857144,0.10884514285714264);\nconst vec2 r_7 = vec2(-0.43352638571428576,0.10587471428571393);\n\nconst vec2 p_8 = vec2(-0.4511840714285714,0.13062857142857154);\nconst vec2 q_8 = vec2(-0.47214227142857146,0.15983800000000015);\nconst vec2 r_8 = vec2(-0.4441705,0.17130714285714288);\n\nconst vec2 p_9 = vec2(-0.44912125714285717,0.19713357142857157);\nconst vec2 q_9 = vec2(-0.4515141285714286,0.2096755714285714);\nconst vec2 r_9 = vec2(-0.4647161428571428,0.2120684285714287);\n\nconst vec2 p_10 = vec2(-0.4759378428571429,0.19845385714285713);\nconst vec2 q_10 = vec2(-0.5210722285714285,0.14341799999999982);\nconst vec2 r_10 = vec2(-0.5030844857142857,-0.007745142857143117);\n\nconst vec2 p_11 = vec2(-0.48336397142857146,-0.06987699999999997);\nconst vec2 q_11 = vec2(-0.4580326142857143,-0.14958414285714294);\nconst vec2 r_11 = vec2(-0.3672687857142857,-0.13184400000000007);\n\nconst vec2 p_12 = vec2(-0.3680114,-0.10618257142857157);\nconst vec2 q_12 = vec2(-0.3686715,-0.08365657142857152);\nconst vec2 r_12 = vec2(-0.4374869857142858,-0.08299657142857142);\n\nconst vec2 p_13 = vec2(-0.4630658857142857,-0.11798185714285703);\nconst vec2 q_13 = vec2(-0.4857568428571428,-0.14892414285714262);\nconst vec2 r_13 = vec2(-0.5032495142857143,-0.16732442857142837);\n\nconst vec2 p_14 = vec2(-0.5041571428571429,-0.32830642857142855);\nconst vec2 q_14 = vec2(-0.5753655,-0.15783542857142852);\nconst vec2 r_14 = vec2(-0.5202471,-0.049826428571428716);\n\nconst vec2 p_15 = vec2(-0.4030792428571428,-0.04966142857142852);\nconst vec2 q_15 = vec2(-0.28483872857142856,-0.04949642857142833);\nconst vec2 r_15 = vec2(-0.2226242571428571,-0.18720985714285687);\n\nconst vec2 p_16 = vec2(-0.30777722857142864,-0.3273162857142857);\nconst vec2 q_16 = vec2(-0.29457521428571437,-0.23325200000000001);\nconst vec2 r_16 = vec2(-0.3081897857142858,-0.1410028571428572);\n\nconst vec2 p_17 = vec2(-0.3667737142857143,-0.14826399999999995);\nconst vec2 q_17 = vec2(-0.39953120000000003,-0.15230714285714297);\nconst vec2 r_17 = vec2(-0.39812848571428566,-0.2503319999999998);\n\nconst vec2 p_18 = vec2(-0.4030792428571428,-0.32995671428571427);\nconst vec2 q_18 = vec2(-0.4092676857142857,-0.251487142857143);\nconst vec2 r_18 = vec2(-0.42378989999999994,-0.17277028571428565);\nconst vec2 s_18 = vec2(-0.4418601571428571,-0.15065685714285726);\n\nconst vec2 bb_0 = vec2(-0.402095164285714,0.00233024285714289);\nconst vec2 bb_1 = vec2(0.133786821428571,0.332286957142857);\n\nconst vec3 fairydust1_col = vec3(0,.463,.729);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= vec2(.5);\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    border = 2./iResolution.y;\n    seed2 = floor(iDate.w-iTime);\n\n\tfloat d0 = 1e38;\n\tfloat d1 = 1e38;\n\n    vec2 dir_tmp;\n    \n    vec2 dir = vec2(1e38);\n    \n    float brightness = brightness_func(iTime+.3,.183710923982357);\n\tinner_size *= max(brightness,brightness_cutoff);\n\tglow_fac *= brightness;\n\tglow_fac2 *= brightness;\n\n    vec3 tube_col1 = bg_col;\n    vec3 tube_col2 = bg_col;\n    \n    if(all(lessThan(abs(uv-bb_0),bb_1+vec2(glow_size2)))){\n\t\tdir = approx_cubic_bezier_to_p(uv,p_16,q_16,r_16,p_17);\n\t\td0 = length2(dir);\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_17,q_17,r_17,p_18));\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust1_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust1_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_12,q_12,r_12,p_13);\n\t\td0 = length2(dir);\n\t\tdir_tmp = dir;\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_13,q_13,r_13,p_14));\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust1_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust1_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_14,q_14,r_14,p_15);\n\t\td0 = length2(dir);\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_15,q_15,r_15,p_16));\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust1_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust1_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_0,q_0,r_0,p_1);\n\t\td0 = length2(dir);\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_1,q_1,r_1,p_2));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_2,q_2,r_2,p_3));\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust1_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust1_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_3,q_3,r_3,p_4);\n\t\td0 = length2(dir);\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_4,q_4,r_4,p_5));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_5,q_5,r_5,p_6));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_6,q_6,r_6,p_7));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_7,q_7,r_7,p_8));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_8,q_8,r_8,p_9));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_9,q_9,r_9,p_10));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_10,q_10,r_10,p_11));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_11,q_11,r_11,p_12));\n\n\t\tif(distance(uv,p_12)<border_size+border+.01){\n\t\t\tdir = shortest_dir(d0,dir,dir_tmp);\n\t\t}\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust1_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust1_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_18,q_18,r_18,s_18);\n\t\td0 = length2(dir);\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust1_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust1_col,tube_col2);\n\t\td1 = min(d0,d1);\n    }\n    \n    d1 = sqrt(d1);\n\n\tvec3 color = bg_col;\n\tcolor = composit_glow_col(d1,fairydust1_col,color);\n\tvec3 tube_col = mix(tube_col2,tube_col1,clamp(brightness/brightness_cutoff,0.,1.));\n\tcolor = mix(tube_col,color,smoothstep(0., border, d1-border_size));\n\n\tcolor = mix(tube_col,color,smoothstep(0., border, d1-border_size));\n\n\tfragColor = vec4(color,d1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec2 p_0 = vec2(0.08982285714285719,-0.21211857142857138);\nconst vec2 p_1 = vec2(0.07668,-0.04040428571428567);\nconst vec2 p_2 = vec2(0.13782285714285714,-0.12840428571428575);\nconst vec2 p_3 = vec2(0.00045,-0.030757142857142927);\nconst vec2 p_4 = vec2(0.06989142857142853,0.1745285714285716);\nconst vec2 p_5 = vec2(0.10357142857142858,0.18637);\nconst vec2 p_6 = vec2(0.0,0.22737);\nconst vec2 p_7 = vec2(0.0,0.12011428571428562);\nconst vec2 p_8 = vec2(0.0,0.30423714285714265);\nconst vec2 p_9 = vec2(0.0,-0.3289614285714286);\nconst vec2 p_10 = vec2(0.039878571428571374,-0.13481857142857123);\nconst vec2 p_11 = vec2(0.11525142857142863,-0.3289457142857142);\n\nconst vec3 fairydust2_col = vec3(1.,.776,0.);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= vec2(.5);\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    border = 2./iResolution.y;\n    seed2 = floor(iDate.w-iTime);\n\n\tfloat d0 = 1e38;\n    float d1 = 1e38;\n    \n  \tvec2 dir = vec2(1e38);\n\n    float brightness = brightness_func(iTime,.8128143439809);\n\tinner_size *= max(brightness,brightness_cutoff);\n\tglow_fac *= brightness;\n\tglow_fac2 *= brightness;\n\n    vec2 old_uv = uv;\n    float sign_uv = sign(uv.x);\n\tuv.x = abs(uv.x);\n    \n    vec3 tube_col1 = bg_col;\n    vec3 tube_col2 = bg_col;\n    \n   \tdir = segment_to_p(uv,p_0,p_1);\n\td0 = length2(dir);\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_1,p_4));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_1,p_4));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_4,p_3));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_5,p_4));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_6,p_5));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_8,p_6));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_10,p_3));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_1,p_10));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_2,p_0));\n\n\tdir.x *= sign_uv;\n\ttube_col1 = composit_tube_col(sqrt(d0),fairydust2_col,tube_col1);\n\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust2_col,tube_col2);\n\td1 = min(d1,d0);\n\n\tdir = segment_to_p(uv,p_8,p_5);\n\td0 = length2(dir);\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_5,p_1));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_1,p_2));\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_2,p_11));\n\n\tdir.x *= sign_uv;\n\ttube_col1 = composit_tube_col(sqrt(d0),fairydust2_col,tube_col1);\n\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust2_col,tube_col2);\n\td1 = min(d1,d0);\n\n\tdir = segment_to_p(uv,p_9,p_7);\n\td0 = length2(dir);\n\n\tdir.x *= sign_uv;\n\ttube_col1 = composit_tube_col(sqrt(d0),fairydust2_col,tube_col1);\n\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust2_col,tube_col2);\n\td1 = min(d1,d0);\n\n\tdir = segment_to_p(uv,p_7,p_4);\n\td0 = length2(dir);\n\tdir = shortest_dir(d0,dir,segment_to_p(uv,p_4,p_6));\n\n\tdir.x *= sign_uv;\n\ttube_col1 = composit_tube_col(sqrt(d0),fairydust2_col,tube_col1);\n\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust2_col,tube_col2);\n\td1 = min(d1,d0);\n\n\tdir = segment_to_p(uv,p_3,p_1);\n\td0 = length2(dir);\n\n\tdir.x *= sign_uv;\n\ttube_col1 = composit_tube_col(sqrt(d0),fairydust2_col,tube_col1);\n\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust2_col,tube_col2);\n\td1 = min(d1,d0);\n\n\tdir = segment_to_p(old_uv,p_9,p_10);\n\td0 = length2(dir);\n\tdir = shortest_dir(d0,dir,segment_to_p(old_uv,p_0,p_11));\n\tdir = shortest_dir(d0,dir,segment_to_p(old_uv,p_10,p_0));\n\n\ttube_col1 = composit_tube_col(sqrt(d0),fairydust2_col,tube_col1);\n\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust2_col,tube_col2);\n\td1 = min(d1,d0);\n\n\tdir = segment_to_p(old_uv,p_9,mirror_point(p_10));\n\td0 = length2(dir);\n\tdir = shortest_dir(d0,dir,segment_to_p(old_uv,mirror_point(p_0),mirror_point(p_11)));\n\tdir = shortest_dir(d0,dir,segment_to_p(old_uv,mirror_point(p_0),mirror_point(p_10)));\n\n\ttube_col1 = composit_tube_col(sqrt(d0),fairydust2_col,tube_col1);\n\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust2_col,tube_col2);\n\td1 = min(d1,d0);\n\n    \n    d1 = sqrt(d1);\n\n\tvec3 color = bg_col;\n\tcolor = composit_glow_col(d1,fairydust2_col,color);\n\tvec3 tube_col = mix(tube_col2,tube_col1,clamp(brightness/brightness_cutoff,0.,1.));\n\tcolor = mix(tube_col,color,smoothstep(0., border, d1-border_size));\n\n\tcolor = mix(tube_col,color,smoothstep(0., border, d1-border_size));\n\n\tfragColor = vec4(color,d1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec2 p_0 = vec2(0.3884829,0.3592089285714286);\nconst vec2 q_0 = vec2(0.4176633428571428,0.3020879999999999);\nconst vec2 r_0 = vec2(0.42791369999999995,0.22115985714285702);\n\nconst vec2 p_1 = vec2(0.3998905571428572,0.1146057142857142);\nconst vec2 q_1 = vec2(0.3729420428571429,0.012102142857142617);\nconst vec2 r_1 = vec2(0.4120421857142857,-0.08816942857142873);\nconst vec2 s_1 = vec2(0.4204739285714287,-0.10536357142857145);\n\nconst vec2 p_2 = vec2(0.41253817142857135,0.2805952857142857);\nconst vec2 q_2 = vec2(0.2668012857142857,0.19082214285714283);\nconst vec2 r_2 = vec2(0.2878806428571428,-0.03452042857142845);\nconst vec2 s_2 = vec2(0.4097275857142857,-0.3288874285714285);\n\nconst vec2 q_3 = vec2(0.4938796857142857,-0.09850242857142866);\nconst vec2 r_3 = vec2(0.5811730142857142,0.1442821428571428);\n\nconst vec2 p_4 = vec2(0.3677342,-0.21861342857142851);\nconst vec2 q_4 = vec2(0.3379751142857143,-0.2698651428571428);\nconst vec2 r_4 = vec2(0.3051574428571429,-0.3034268571428571);\nconst vec2 s_4 = vec2(0.27167847142857143,-0.32897);\n\nconst vec2 p_5 = vec2(0.27167847142857143,-0.32897);\nconst vec2 q_5 = vec2(0.25514564285714286,-0.24217271428571419);\nconst vec2 r_5 = vec2(0.26324672857142867,-0.1528954285714288);\nconst vec2 s_5 = vec2(0.3253275,-0.06692471428571412);\n\nconst vec2 p_6 = vec2(0.4526384857142857,-0.20786714285714303);\nconst vec2 q_6 = vec2(0.4823975857142857,-0.2591188571428571);\nconst vec2 r_6 = vec2(0.5173645142857143,-0.30334414285714306);\nconst vec2 s_6 = vec2(0.5509261571428572,-0.3288874285714285);\n\nconst vec2 p_7 = vec2(0.5509261571428572,-0.3288874285714285);\nconst vec2 q_7 = vec2(0.5674589857142858,-0.24208999999999992);\nconst vec2 r_7 = vec2(0.5548940285714287,-0.15281271428571408);\nconst vec2 s_7 = vec2(0.49289592857142855,-0.06684199999999985);\n\nconst vec2 p_8 = vec2(0.4134474714285714,0.18477085714285724);\nconst vec2 q_8 = vec2(0.3888962142857143,0.1862587142857144);\nconst vec2 r_8 = vec2(0.36409697142857145,0.17551242857142868);\nconst vec2 s_8 = vec2(0.35326797142857147,0.16121157142857134);\n\nconst vec2 p_9 = vec2(0.45866475714285715,0.152713857142857);\nconst vec2 q_9 = vec2(0.44965437142857145,0.1605669999999999);\nconst vec2 r_9 = vec2(0.4330388714285714,0.16999071428571444);\nconst vec2 s_9 = vec2(0.41146352857142865,0.17007342857142826);\n\nconst vec2 p_10 = vec2(0.4527129428571428,0.09395028571428576);\nconst vec2 q_10 = vec2(0.43601478571428565,0.08195514285714278);\nconst vec2 r_10 = vec2(0.4168366999999999,0.08151728571428585);\nconst vec2 s_10 = vec2(0.3936907428571429,0.08370628571428562);\n\nconst vec2 p_11 = vec2(0.3532558285714286,0.12266971428571427);\nconst vec2 q_11 = vec2(0.3636715142857143,0.11382471428571428);\nconst vec2 r_11 = vec2(0.3793777,0.10671557142857147);\nconst vec2 s_11 = vec2(0.3971504857142858,0.1033264285714286);\n\nconst vec2 p_12 = vec2(0.37600061428571424,-0.09205457142857143);\nconst vec2 q_12 = vec2(0.3841843571428571,-0.0769271428571432);\nconst vec2 r_12 = vec2(0.3931120857142857,-0.06783399999999995);\nconst vec2 s_12 = vec2(0.4045197428571428,-0.060228857142857084);\n\nconst vec2 p_13 = vec2(0.3136718571428571,-0.20174999999999987);\nconst vec2 q_13 = vec2(0.3302873428571429,-0.1778599999999999);\nconst vec2 r_13 = vec2(0.3419429857142857,-0.14925814285714267);\nconst vec2 s_13 = vec2(0.3435136,-0.14297571428571398);\n\nconst vec2 p_14 = vec2(0.47492027142857135,-0.13712328571428567);\nconst vec2 q_14 = vec2(0.48776078571428555,-0.15445714285714307);\nconst vec2 r_14 = vec2(0.4995089428571428,-0.18597485714285744);\nconst vec2 s_14 = vec2(0.5028867428571429,-0.19786942857142864);\n\nconst vec3 fairydust3_col = vec3(.6,.729,0.);\n\nconst vec2 bb_0 = vec2(0.410893985714286, 0.0151194642857143);\nconst vec2 bb_1 = vec2(0.146669342857143, 0.344089464285714);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= vec2(.5);\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    border = 2./iResolution.y;\n    seed2 = floor(iDate.w-iTime);\n\n\tfloat d0 = 1e38;\n    float d1 = 1e38;\n    \n    vec2 dir = vec2(1e38);\n    \n    float brightness = brightness_func(iTime+.4,.7102342125365);\n\tinner_size *= max(brightness,brightness_cutoff);\n\tglow_fac *= brightness;\n\tglow_fac2 *= brightness;\n\n    vec3 tube_col1 = bg_col;\n    vec3 tube_col2 = bg_col;\n\n    if(all(lessThan(abs(uv-bb_0),bb_1+vec2(glow_size2)))){\n\t\tdir = approx_cubic_bezier_to_p(uv,p_8,q_8,r_8,s_8);\n\t\td0 = length2(dir);\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_9,q_9,r_9,s_9));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_10,q_10,r_10,s_10));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_11,q_11,r_11,s_11));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_12,q_12,r_12,s_12));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_13,q_13,r_13,s_13));\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_14,q_14,r_14,s_14));\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust3_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust3_col,tube_col2);\n\t\td1 = d0;\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_5,q_5,r_5,s_5);\n\t\td0 = length2(dir);\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust3_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust3_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_4,q_4,r_4,s_4);\n\t\td0 = length2(dir);\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust3_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust3_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_7,q_7,r_7,s_7);\n\t\td0 = length2(dir);\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust3_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust3_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_6,q_6,r_6,s_6);\n\t\td0 = length2(dir);\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust3_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust3_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_2,q_2,r_2,s_2);\n\t\td0 = length2(dir);\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust3_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust3_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,s_2,q_3,r_3,p_2);\n\t\td0 = length2(dir);\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust3_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust3_col,tube_col2);\n\t\td1 = min(d0,d1);\n\n\t\tdir = approx_cubic_bezier_to_p(uv,p_0,q_0,r_0,p_1);\n\t\td0 = length2(dir);\n\t\tdir = shortest_dir(d0,dir,approx_cubic_bezier_to_p(uv,p_1,q_1,r_1,s_1));\n\n\t\ttube_col1 = composit_tube_col(sqrt(d0),fairydust3_col,tube_col1);\n\t\ttube_col2 = composit_tube_col_dark(sqrt(d0),dir,fairydust3_col,tube_col2);\n\t\td1 = min(d0,d1);\n    }\n\n    d1 = sqrt(d1);\n\n\tvec3 color = bg_col;\n\tcolor = composit_glow_col(d1,fairydust3_col,color);\n\tvec3 tube_col = mix(tube_col2,tube_col1,clamp(brightness/brightness_cutoff,0.,1.));\n\tcolor = mix(tube_col,color,smoothstep(0., border, d1-border_size));\n\n\tcolor = mix(tube_col,color,smoothstep(0., border, d1-border_size));\n\n\tfragColor = vec4(color,d1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}