{
    "Shader": {
        "info": {
            "date": "1459166133",
            "description": "Three little steam locomotives",
            "flags": 0,
            "hasliked": 0,
            "id": "ldtXD8",
            "likes": 7,
            "name": "Thomas X3",
            "published": 3,
            "tags": [
                "raymarching",
                "train"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 788
        },
        "renderpass": [
            {
                "code": "// \"Thomas X3\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Thomas is a popular toy engine (many design changes have been made).\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBox2Df (vec2 p, vec2 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec4 pCar[3];\nvec3 qHit, ltDir;\nvec2 rlSize;\nfloat ti[13], dstFar, tCur, szFac, trSpd, rgHSize, trkWid, tCyc;\nint idObj, idObjGrp;\n\nconst int idEng = 1, idCabin = 2, idCoal = 3, idBase = 4, idBand = 4, idAxle = 4,\n   idRoof = 6, idWheel = 7, idSpoke = 7, idCrod = 8, idFunl = 9, idFunt = 10,\n   idStripe = 10, idLamp = 11, idCpl = 12, idGrnd = 21, idTflr = 22, idRail = 23;\nconst int dirNS = 0, dirEW = 1, dirSW = 2, dirNW = 3, dirSE = 4, dirNE = 5,\n   dirX = 6;\n\nfloat TrackDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 ip;\n  float dMin, d, db, dc, sqWid;\n  int indx, isq;\n  dMin = dstFar;\n  sqWid = 0.4999;\n  ip = floor (p.xz);\n  db = PrOBox2Df (p.xz, vec2 (2. * sqWid * rgHSize));\n  q = p;\n  q.xz = fract (q.xz) - vec2 (0.5);\n  indx = -1;\n  isq = int (2. * rgHSize * mod (ip.y + rgHSize, 2. * rgHSize) +\n     mod (ip.x + rgHSize, 2. * rgHSize));\n  if (isq == 6 || isq == 8 || isq == 20 || isq == 23 || isq == 26 ||\n     isq == 29) indx = dirNS;\n  else if (isq == 1 || isq == 13 || isq == 15 || isq == 16 || isq == 33 ||\n     isq == 34) indx = dirEW;\n  else if (isq == 35) indx = dirSW;\n  else if (isq == 2 || isq == 17) indx = dirNW;\n  else if (isq == 12 || isq == 32) indx = dirSE;\n  else if (isq == 0) indx = dirNE;\n  else if (isq == 14) indx = dirX;\n  d = dstFar;\n  if (indx >= 0 && indx <= dirX) {\n    q.y -= 0.5 * rlSize.y;\n    dc = max (db, PrBox2Df (q.xz, vec2 (sqWid)));\n    if (indx < dirX) {\n      if (indx == dirEW) q.xz = q.zx;\n      else if (indx == dirNW) q.z *= -1.;\n      else if (indx == dirSE) q.x *= -1.;\n      else if (indx == dirNE) q.xz *= -1.;\n      if (indx <= dirEW) {\n        q.z += 0.5;  q.x = abs (q.x);\n      } else {\n        q.xz += 0.5;  q.x = abs (length (q.xz) - 0.5);\n      }\n      d = max (PrOBox2Df (q.xy, vec2 (2. * trkWid, 0.5 * rlSize.y)), dc);\n      if (d < dMin) { dMin = d;  idObj = idTflr;  qHit = q; }\n      q.xy -= vec2 (trkWid, rlSize.y);\n      d = max (PrOBox2Df (q.xy, rlSize), dc);\n      if (d < dMin) { dMin = d;  idObj = idRail;  qHit = q; }\n    } else {\n      qq = q;  q.x = abs (q.x);  q.z += 0.5;\n      d = PrOBox2Df (q.xy, vec2 (2. * trkWid, 0.5 * rlSize.y));\n      q = qq;  q.xz = q.zx;   q.x = abs (q.x);  q.z += 0.5;\n      d = max (min (d, PrOBox2Df (q.xy, vec2 (2. * trkWid, 0.5 * rlSize.y))), dc);\n      if (d < dMin) { dMin = d;  idObj = idTflr;  qHit = q; }\n      q = qq;  q.y -= rlSize.y;  qq = q;\n      q.x = abs (q.x) - trkWid;  q.z += 0.5;\n      d = PrOBox2Df (q.xy, rlSize);\n      q = qq;  q.xz = q.zx;  q.x = abs (q.x) - trkWid;  q.z += 0.5;\n      d = min (d, PrOBox2Df (q.xy, rlSize));\n      q = qq;  q.xz = abs (q.xz) - trkWid + 1.75 * rlSize.x;\n      d = max (max (d, - min (PrBox2Df (q.xz, vec2 (trkWid, 0.75 * rlSize.x)),\n         PrBox2Df (q.xz, vec2 (0.75 * rlSize.x, trkWid)))), dc);\n      if (d < dMin) { dMin = d;  idObj = idRail;  qHit = q; }\n    }\n  }\n  return dMin;\n}\n\nfloat TrackRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h;\n  float dHit, d;\n  srd = - sign (rd.xz);\n  dda = - srd / (rd.xz + 0.0001);\n  dHit = max (0., PrBox2Df (ro.xz, vec2 (rgHSize)));\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    d = TrackDf (p);\n    dHit += min (d, 0.001 + max (0., min (h.x, h.y)));\n    if (d < 0.0001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d > 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nfloat EngDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, aw, a, sx, wRad, tw;\n  wRad = 0.8;\n  tw = 214. * szFac * trkWid;\n  q = p;\n  q -= vec3 (0., -0.2, 0.5);\n  d = max (PrCapsDf (q, 1., 2.), - (q.z + 1.7));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idEng; }\n  q = p;  q.z = abs (q.z - 0.85);  q -= vec3 (0., -0.2, 1.8);\n  d = PrCylDf (q, 1.05, 0.05);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idBand; }\n  q = p;  q -= vec3 (0., -1.3, -0.25);\n  d = PrBoxDf (q, vec3 (1., 0.1, 3.2));\n  q = p;  q -= vec3 (0., -1.4, 3.);\n  d = min (d, PrBoxDf (q, vec3 (1.1, 0.2, 0.07)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idBase; }\n  q.x = abs (q.x);  q -= vec3 (0.6, 0., 0.1);\n  d = PrCylDf (q, 0.2, 0.1);\n  q = p;  q -= vec3 (0., -2.4, -1.75);\n  d = min (d, max (PrCylDf (q, 4., 0.65), - (q.y - 3.75)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idRoof; }\n  q = p;  q -= vec3 (0., 0.01, -1.75);\n  d = max (max (PrBoxDf (q, vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (q - vec3 (0., 0., -0.2), vec3 (0.95, 1.3, 0.65))),\n     - PrBoxDf (q - vec3 (0., 0.7, 0.), vec3 (1.1, 0.4, 0.5)));\n  q.x = abs (q.x);  q -= vec3 (0.4, 1., 0.4);\n  d = max (d, - PrBoxDf (q, vec3 (0.35, 0.15, 0.3)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCabin;  qHit = q; }\n  q = p;  q -= vec3 (0., -0.5, -3.15);\n  d = PrBoxDf (q, vec3 (1., 0.7, 0.3));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCoal;  qHit = q; }\n  q = p;  q -= vec3 (0., -1.4, -3.5);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCpl; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.12, -1.4, 1.1);\n  d = PrCylDf (q.zyx, wRad, 0.1);\n  aw = - trSpd * tCur / (szFac * wRad);\n  if (d < dMin) {\n    d = min (max (min (d, PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n       - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n    if (d < dMin) { dMin = d;  idObj = idObjGrp + idWheel; }\n    q = p;  q.x = abs (q.x);  q -= vec3 (tw - 0.17, -1.4, 1.1 * sign (q.z));\n    q.yz = q.yz * cos (aw) + q.zy * sin (aw) * vec2 (-1., 1.);  \n    a = floor ((atan (q.y, q.z) + pi) * 8. / (2. * pi) + 0.5) / 8.;\n    q.yz = q.yz * cos (2. * pi * a) + q.zy * sin (2. * pi * a) * vec2 (-1., 1.);\n    q.z += 0.5 * wRad;\n    d = PrCylDf (q, 0.05, 0.5 * wRad);\n    if (d < dMin) { dMin = d;  idObj = idObjGrp + idSpoke; }\n  }\n  q = p;  sx = sign (q.x);  q.x = abs (q.x);\n  q -= vec3 (tw + 0.08, -1.4, 0.);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);  q -= vec3 (-0.1, 0., 1.1);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCrod; }\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idAxle; }\n  q = p;  q -= vec3 (0., 1.1, 2.15);  d = PrCylDf (q.xzy, 0.3, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idFunl; }\n  q = p;  q -= vec3 (0., 1.5, 2.15);\n  d = max (PrCylDf (q.xzy, 0.4, 0.15), - PrCylDf (q.xzy, 0.3, 0.2));\n  q = p;  q -= vec3 (0., 0.8, 0.55);\n  d = min (d, PrCapsDf (q.xzy, 0.3, 0.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idFunt; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, 0.85);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 1.8));\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, -1.75);\n  d = min (d, PrBoxDf (q, vec3 (0.05, 0.1, 0.6)));\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, -3.15);\n  d = min (d, PrBoxDf (q, vec3 (0.05, 0.1, 0.3)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idStripe; }\n  q = p;  q -= vec3 (0., -0.2, 3.5);\n  d = PrCylDf (q, 0.2, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idLamp; }\n  return dMin;\n}\n\nfloat SceneDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db;\n  dMin = dstFar;\n  db = PrOBox2Df (p.xz, vec2 (0.999 * rgHSize));\n  d = abs (p.y + 0.001) - 0.001;\n  d = max (d, db);\n  if (d < dMin) { dMin = d;  idObj = idGrnd;  qHit = p; }\n  dMin /= szFac;\n  for (int k = 0; k < 3; k ++) {\n    q = p;\n    q -= pCar[k].xyz;\n    q /= szFac;\n    d = PrCylDf (q.xzy, 4., 2.2);\n    if (d < dMin) {\n      q.xz = Rot2D (q.xz, pCar[k].w);\n      idObjGrp = (k + 1) * 256;\n      dMin = EngDf (q, dMin);\n    }\n }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat SceneRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = SceneDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = min (dMin, TrackDf (p));\n  dMin = min (dMin, SceneDf (p));\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = 0.0001 * vec3 (1., -1., 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 n)\n{\n  vec4 objCol;\n  int ig, id;\n  const vec4 cR = vec4 (1., 0., 0., 1.), cY = vec4 (1., 1., 0., 1.),\n     cG = vec4 (0., 1., 0., 1.), cB = vec4 (0., 0., 1., 1.),\n     cBlk = vec4 (0.03, 0.03, 0.03, 0.1), cLB = vec4 (0.4, 0.4, 1., 1.);\n  objCol = vec4 (0.);\n  if (idObj <= idRail) {\n    if (idObj == idGrnd) objCol = vec4 (mix (vec3 (0.4, 0.25, 0.1),\n        vec3 (0.3, 0.6, 0.3), smoothstep (0.8, 1.1, Fbm2 (5. * ro.xz))) *\n        (1. - 0.1 * Noisefv2 (30. * ro.xz)), 0.05);\n    else if (idObj == idTflr) objCol = vec4 (0.4, 0.5, 0.4, 0.1) *\n       (1. - 0.3 * Fbm2 (90. * ro.xz));\n    else if (idObj == idRail) objCol = vec4 (0.7, 0.7, 0.7, 0.5);\n  } else {\n    ig = idObj / 256;\n    id = idObj - 256 * ig;\n    if (id == idEng) objCol = (ig == 1) ? cG : ((ig == 2) ? cY : cR);\n    else if (id == idCabin) objCol = (qHit.y > -1.3) ? cLB : cB;\n    else if (id == idCoal)\n       objCol = (qHit.y > 0.3) ? ((n.y > 0.9) ? cBlk : cLB) : cB;\n    else if (id == idBase || id == idBand || id == idAxle)\n       objCol = vec4 (0.3, 0.2, 0.2, 0.3);\n    else if (id == idRoof || id == idCpl || id == idFunl && n.y <= 0.9)\n       objCol = (ig == 3) ? cG : ((ig == 1) ? cY : cR);\n    else if (id == idFunl && n.y > 0.9) objCol = cBlk;\n    else if (id == idWheel || id == idSpoke) objCol = vec4 (0.6, 0.7, 0.7, 0.5);\n    else if (id == idCrod) objCol = cY;\n    else if (id == idStripe || id == idFunt) objCol = (ig == 2) ? cG :\n       ((ig == 3) ? cY : cR);\n    else if (id == idLamp) objCol = (mod (tCur + 0.667 * float (ig), 2.) < 1.) ?\n       vec4 (1., 1., 1., -1.) : vec4 (0.6, 0.6, 0.6, -1.);\n  }\n  return objCol;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.05, 3. * h);\n    if (h < 0.001) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 qHitT, col, vn;\n  float dstHit, d, sh;\n  int idObjT;\n  dstHit = dstFar;\n  d = TrackRay (ro, rd);\n  if (d < dstHit) dstHit = d;\n  idObjT = idObj;\n  qHitT = qHit;\n  d = SceneRay (ro, rd);\n  if (d < dstHit) dstHit = d;\n  else {\n    idObj = idObjT;\n    qHit = qHitT;\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idTflr) vn = VaryNf (100. * ro, vn, 2.);\n    else if (idObj == idGrnd) vn = VaryNf (5. * ro, vn, 0.5);\n    objCol = ObjCol (ro, rd, vn);\n    col = objCol.rgb;\n    if (objCol.a >= 0.) {\n      sh = ObjSShadow (ro, ltDir);\n      col = col * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.)) +\n         objCol.a * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    }\n  } else col = vec3 (0.1, 0.1, 0.2);\n  return clamp (col, 0., 1.);\n}\n\n#define SLIN(k,d) ti[k + 1] = ti[k] + d\n#define SCRV(k) ti[k + 1] = ti[k] + tc\n\nvoid TrSetup ()\n{\n  float tc;\n  tc = 0.25 * pi;\n  ti[0] = 0.;\n  SCRV(0);   SLIN(1, 1.);  SCRV(2);  SLIN(3, 4.);  SCRV(4);  SLIN(5, 2.);\n  SCRV(6);  SLIN(7, 2.);  SCRV(8);  SLIN(9, 4.);  SCRV(10);  SLIN(11, 1.);\n  tCyc = ti[12];\n}\n\nvec2 TrackPath (float t)\n{\n  vec2 r, dr;\n  float tc, a;\n  tc = 0.25 * pi;\n  t = mod (t, tCyc);\n  dr = vec2 (0.);\n  a = 99.;\n  if (t < ti[1]) {\n    r = vec2 (0., 0.);  dr.xy = vec2 (1.);  a = 0.5 * tc + 0.25 * (t - ti[0]);\n  } else if (t < ti[2]) {\n    r = vec2 (1., 0.5);  dr.x = (t - ti[1]);\n  } else if (t < ti[3]) {\n    r = vec2 (2., 0.);  dr.y = 1.;  a = 0.75 * tc + 0.25 * (t - ti[2]);\n  } else if (t < ti[4]) {\n    r = vec2 (2.5, 1.);  dr.y = (t - ti[3]);\n  } else if (t < ti[5]) {\n    r = vec2 (2., 5.);  dr.x = 1.;  a = 0.5 * tc - 0.25 * (t - ti[4]);\n  } else if (t < ti[6]) {\n    r = vec2 (3., 5.5);  dr.x = (t - ti[5]);\n  } else if (t < ti[7]) {\n    r = vec2 (5., 5.);  a = 0.25 * tc - 0.25 * (t - ti[6]);\n  } else if (t < ti[8]) {\n    r = vec2 (5.5, 5.);  dr.y = - (t - ti[7]);\n  } else if (t < ti[9]) {\n    r = vec2 (5., 2.);  dr.y = 1.;  a = 0. * tc - 0.25 * (t - ti[8]);\n  } else if (t < ti[10]) {\n    r = vec2 (5., 2.5);  dr.x = - (t - ti[9]);\n  } else if (t < ti[11]) {\n    r = vec2 (0., 2.);  dr.x = 1.;  a = 0.25 * tc + 0.25 * (t - ti[10]);\n  } else if (t < ti[12]) {\n    r = vec2 (0.5, 2.);  dr.y = - (t - ti[11]);\n  }\n  if (a != 99.) {\n    a *= 2. * pi / tc;\n    r += 0.5 * vec2 (cos (a), sin (a));\n  }\n  r += dr - rgHSize;\n  return r;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, pc;\n  vec3 ro, rd, col, u, vd;\n  vec2 canvas, uv, uvs, ori, ca, sa, vo;\n  float el, az, zmFac, t, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 40.;\n  ltDir = normalize (vec3 (1., 2., -1.));\n  rgHSize = 3.;\n  szFac = 0.07;\n  rlSize = vec2 (0.005, 0.01);\n  trkWid = 0.095;\n  trSpd = 0.8;\n  TrSetup ();\n  for (int k = 0; k < 3; k ++) {\n    t = trSpd * tCur - float (k) * tCyc / 3.;\n    pCar[k].xz = TrackPath (t);\n    pCar[k].y = 3. * rlSize.y + 0.15;\n    vo = TrackPath (t + 0.01) - pCar[k].xz;\n    pCar[k].w = atan (vo.x, vo.y);\n  }\n  if (length (uvs) < 1.5 * SmoothBump (0.2, 0.7, 0.04, mod (0.05 * tCur, 1.))) {\n    az = 0.01;\n    el = 0.1 * pi;\n    if (mPtr.z > 0.) {\n      az -= 2. * pi * mPtr.x;\n      el = clamp (el - pi * mPtr.y, 0.02 * pi, 0.45 * pi);\n    }\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., sa.y, 0., 1., 0., - sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, sa.x, 0., - sa.x, ca.x);\n    ro = vuMat * vec3 (0., 0., -15.);\n    zmFac = 8.;\n  } else {\n    t = mod (0.1 * tCur, 3.);\n    pc = (t < 1.) ? pCar[0] : ((t < 2.) ? pCar[1] : pCar[2]);\n    ro = vec3 (0., 1., -5.);\n    vd = normalize (pc.xyz - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    zmFac = 6.;\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}