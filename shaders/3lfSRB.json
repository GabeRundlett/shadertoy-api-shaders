{
    "Shader": {
        "info": {
            "date": "1563377131",
            "description": "Trying a graph untangling algorithm by simulating springs + reframing.\nYou can help untangling the graph with the mouse.  click+SPACE to unconnect node.\nRestart for new set-up.\nlong term goal: Vax Game [url]https://vax.herokuapp.com/game[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "3lfSRB",
            "likes": 8,
            "name": "untangling graph",
            "published": 3,
            "tags": [
                "simulation",
                "graph",
                "mesh",
                "network",
                "untangle"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 865
        },
        "renderpass": [
            {
                "code": "// draw line. from https://www.shadertoy.com/view/4dcfW8\nfloat line(vec2 p, vec2 a,vec2 b) {\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    p -= b * h;\n    return dot(p,p);                                  // dist^2 to segment\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n#if TEST\n    O = texelFetch(iChannel0,ivec2(U/8.),0); if (int(U.x/8.)>0) O/=N,O.g=.6*float(O.x>0.); return;\n#endif\n    \n    vec2 R = iResolution.xy;\n    U = ( 2.*U - R ) / R.y;\n    \n    float p = 3./R.y, n = 1e9, l = 1e9, l2 = 1e9, r;\n    for (int i=0; i < int(N); i++) {       // for each node\n        vec4 P = node(i);\n        if (P.xy==vec2(0)) continue;       // invalid node\n        r = length(P.xy-U)-.03;            // distance to node\n      //r = length(P.xy-U)-.007*P.w;       \n        n = min(n, r);\n        for (int j=0; j < int(P.z); j++) { // for each link in its list\n            float k = link(i,j);           // distance to line\n            vec2 P2 = node(k).xy;\n        if (P2==vec2(0)) continue;         // invalid node\n            l = min(l, line(U,P.xy, P2));\n        }              \n/*      for (int j=int(P.z); j < int(P.w); j++) { // debug: back-links\n            float k = link(i,j);           // distance to line\n            l2 = min(l2, line(U,P.xy, node(k).xy));\n        }            \n*/  }\n    O = vec4( smoothstep(p,0.,n) ,0,0,0);  // draw (closest) node\n    O += smoothstep(p,0.,sqrt(l));         // draw (closest) line\n  //O.g = smoothstep(p,0.,sqrt(l2));       // debug: draw back-links\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Line = node id.  Columns: 0: (x,y,n,n+back) 1..n+back: (x:#id)\n// attention: node might link to self. ignore these.\n\n#define rot(a)  mat2( cos(a), -sin(a), sin(a), cos(a) )\n//#define rnd4(p) texelFetch(iChannel1, ivec2(p)%256, 0) // not available at Frame0\n  #define rnd(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n  #define rnd4(p) vec4( rnd(p), rnd(.1+p), rnd(.3+p), rnd(.4+p) )\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    if (U.y >= N) return;\n    \n    if (iFrame==0) { // --- init nodes: random pos + random targets\n        float t = mod(3.*iDate.w,256.);\n#if TEST\n        if (U.x > ceil(sqrt(N)/2.*rnd4(vec2(U.y,t)).z)) return;\n#endif\n        if (U.x==0.) O.xyz = rnd4(vec2(U.y,t)).xyz, // coords\n                     O.xy = 2.*O.xy-1., \n                     O.z = ceil(sqrt(N)/2.*O.z);    // connectivity: #n\n        else O.x = floor(N*rnd4(U+t).w);            // connectivity: link ids\n        return;\n    }\n    \n    O = texelFetch(iChannel0, ivec2(U), 0);    // restore prev state\n    \n    if (iFrame==1) { // --- appends the back-links to node list\n        float n = node(U.y).z, t = 0.;\n        if ( ( U.x > n && U.x <= n+N ) || U.x == 0. ) {\n            for (int i=0; i < int(N); i++) {   // search for back-link\n                int n2 = int(node(i).z);\n                for (int j=0; j < n2; j++) {\n                    if (link(i,j) == U.y) {    // got one !\n                        t++;                   // count back-links\n                        if ( U.x == n+t )      // it falls on the right slot\n                        { O.x = float(i); return; }\n                    }\n                }\n            }\n            if (U.x==0.) O.w = n+t;            // total list count\n        }\n        return;\n    }\n    \n    //return;\n    if (U.x==0.) {                             // === node simulation\n        if ( iMouse.z > 0.) {\n            vec2  R = iResolution.xy,          // --- mouse move node\n                M = ( 2.*iMouse.xy - R ) / R.y;\n            float r = 1e5, l, ii=-1.;\n            for (int i=0; i < int(N); i++) {\n                vec2 P = node(i).xy; \n                if (P==vec2(0)) continue;      // invalid node\n                l = length(P-M);\n                if ( l < r ) r=l, ii=float(i);\n            }\n            if (r<.1 && ii==U.y)          \n                if keyClick(32) { O.xy = M-M; return; } // disconnect (lazy: should decrease backN).\n                else O.xy = M;                 // nearest node follow mouse\n        }\n            \n        vec4 P = node(U.y);                    // --- do the spring physics\n        if (P.xy==vec2(0)) return;             // invalid node\n        vec2 F = vec2(0);\n        for (int j=0; j < int(P.w); j++) {\n            vec2 P2 = node(link(U.y,j)).xy;\n            if (P2==vec2(0)) continue;         // invalid node\n            F += P2-P.xy;\n          //F += pow(length(P2-P.xy),4.)*normalize(1e-5+P2-P.xy);\n        }\n        O.xy += .02* F / P.w; // variant: with/without P.w normaliaztion\n        \n        vec2 M1=vec2(0), M2=vec2(0), S;        // --- reframe\n        float mxy = 0., sxy;\n        for (int i=0; i < int(N); i++) {\n            vec2 P = node(i).xy;\n            if (P==vec2(0)) continue;          // invalid node\n            M1 += P; M2 += P*P; mxy += P.x*P.y;// 1st & 2nd moments        \n        }\n        M1 /= N; M2 /= N; mxy /= N;\n        O.xy -= M1;                            // recenter coords\n        S = M2-M1*M1; sxy = mxy-M1.x*M1.y;     // covariance matrix\n      //O.xy /= 2.*sqrt(S);                    // rescale coords\n        float a=S.x, b=S.y, ab=a+b, c=sxy, d = sqrt(max(0.,ab*ab-4.*(a*b-c*c))),\n             s = sign(a-b),                    // get eigenvalues/vectors\n            r1 = (ab+s*d)/2., r2 = (ab-s*d)/2.,// ellipsoid radius^2\n             A = d<1e-5 ? 0. : .5*asin(clamp(2.*c/(r1-r2),-1.,1.)); // ellipsoid tilt\n        O.xy *= rot(-A); \n        O.xy /= 2.*sqrt(max(vec2(r1,r2),1e-5)); \n        O.xy *= rot(A);\n        O.xy /= max(abs(O.xy),1.);             // clamp to window border\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define N 30.\n\n#define TEST 0\n\n#define node(n)   texelFetch(iChannel0, ivec2(0,n), 0)      // (x,y,n,n+back)\n#define link(n,i) texelFetch(iChannel0, ivec2(i+1,n), 0).x  // #id",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}