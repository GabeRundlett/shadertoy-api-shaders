{
    "Shader": {
        "info": {
            "date": "1645505286",
            "description": "Animated e-giant from clash royal! Sorry about the slow compile time, if you know how to reduce it please let me know.\n\nInspired by https://www.youtube.com/watch?v=ol_od46644k",
            "flags": 64,
            "hasliked": 0,
            "id": "7dlfzf",
            "likes": 13,
            "name": "Electro-giant",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "character"
            ],
            "usePreview": 1,
            "username": "El_Sargo",
            "viewed": 283
        },
        "renderpass": [
            {
                "code": "#define WALKSPEED 4.\n#define color\n#define sdTest sdGiant\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 a = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.yx );\n\treturn (x*a.x + y*a.y + z*a.z) / (a.x + a.y + a.z);\n}\n\nvec3 opElongate(in vec3 p, in vec3 h )\n{\n    vec3 q = p - clamp( p, -h, h );\n    return q;\n}\n\n\nvec3 opCheapBend( in vec3 p, float k)\n{\n\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, float t, float r )\n{\n  vec2 q = vec2(length(p.xz)-r,p.y);\n  return length(q)-t;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opSymX( in vec3 p)\n{\n    p.x = abs(p.x);\n    return p;\n}\nvec3 opSymZ( in vec3 p)\n{\n    p.z = abs(p.z);\n    return p;\n}\n\nvec3 opSymXY(vec3 p){\n    p.xy = abs(p.xy);\n    return p;\n}\n\nfloat sdXCapsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-0.5;\n}\n\nfloat sdBBox(vec3 p, vec3 b){\n    float d = sdBox(p.xz, b.xz);\n    vec2 w = vec2( d, abs(p.y) - b.y );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdRoundBox( in vec3 p, in float h )\n{\n    float d = sdRoundedBox(p.xy, vec2(0.35,0.08), vec4(0.05,0.15,0.05,0.1));\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdTriPrisim( in vec3 p, in float h )\n{\n    float d = sdEquilateralTriangle(p.xy);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat pow4(float v){\n    return v*v*v*v;\n   }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat sdBeardSpine(vec3 p, float s){\n    p*=s;\n    return min(opSmoothSubtraction(sdSphere(p-vec3(0,-8.90,1.6), 10.),\n                                sdTriPrisim(p-vec3(0,sin(p.z)*0.9,1.), 1.),\n                                0.4)/s,\n                                1.);\n}\n\nfloat sdBeltBuckle(vec3 p){\n    return sdHexPrism(p-vec3(0, -1.5, -1.), vec2(.35,.1));\n}\n\nfloat sdBelt(vec3 p){\n    return min(\n                sdTorus(opElongate(p-vec3(0, -1.5, 0), vec3(1., 0.2, 0.1)), 0.1, .6),\n                sdBeltBuckle(p)\n                );\n}\n\nvec3 repeat4y(vec3 p){\n    const float l = 2.;\n    const float c = 0.3;\n    float q = p.y-c*clamp(round(p.y/c),-l,l);\n    return vec3(p.x, q, p.z);\n}\n\nfloat sdBeard(vec3 p){\n    vec3 q = opSymX(p)-vec3(.6,-1.4,-.4);\n    vec3 w = opSymX(p)-vec3(1.5,-1.2,-.4);\n    vec3 z = opSymX(p)-vec3(1.15,-0.5,-.0);\n    return min(min(\n                    sdBeardSpine(q*rotz(-0.1*3.14)*roty(.1*3.14)*rotx(.3*3.14),2.3),\n                    sdBeardSpine(w*rotz(-0.2*3.14)*roty(.3*3.14)*rotx(.2*3.14),2.)),\n                    sdBeardSpine(z*roty(0.3*3.14)*rotz(-0.25*3.14)*rotx(.2 * 3.14),4.) \n                );\n}\n\nfloat sdMouthCavity(vec3 p){\n\n    return sdRoundBox(p-vec3(0,-0.4,-0.4), .5);\n}\n\nfloat sdCoil(vec3 p){\n    return sdTorus(opElongate(repeat4y(p-vec3(1.7,-0.7,0)), vec3(0.1,0.,.8)), 0.2, 0.5);\n}\n\nfloat sdPlate(vec3 p){\n    p-=vec3(0,0.1,-0.085);\n    p*=roty(0.5*3.141);\n    vec3 symP = opSymZ(p);\n    return  min(\n                smin(\n                    max(\n                        -sdHexPrism((p-vec3(0.,-0.2,.20)),vec2(1.2, 2.7))+0.2,\n                        max(\n                            max(\n                                -sdHexPrism(opElongate(p*rotx(0.5*3.141)+vec3(0.3,0,0.1), vec3(0.,0.4,0)), vec2(0.4,2.7))+0.2,\n                                sdHexPrism(p,vec2(1.2, 2.7))-0.1),\n                            sdHexPrism(p*rotx(0.5*3.141),vec2(1.5, 1.8))-0.1\n                            )\n                        ),\n                    min(sdCapsule(symP, vec3(0.5,0,0.5), vec3(0.9,1.4,.9)*1.5, 0.12),\n                        sdSphere(symP-vec3(0.9,1.4,.9)*1.4, 0.54)\n                        ),\n                    0.02),\n                    min(\n                        max(-sdBox(p-vec3(1.7,-0.7,0), vec3(.9,0.7,1.9)),\n                            sdBBox(p-vec3(1.7,-0.7,0), vec3(.3,1,1.1))),\n                        sdCoil(p))\n                    );\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdBand(vec3 p){\n    return sdTorus(opElongate((p-vec3(0,0.16,0))*rotx(0.1), vec3(0.1,0.047,0.1)), 0.05, 0.62);\n}\n\nfloat sdTeeth(vec3 p){\n return sdTorus(p-vec3(0,-0.4,-0.25+sin(p.x*40.)*0.01), .11,.3);\n}\n\nfloat sdLens(vec3 p){\n    return sdCappedCylinder(p, 0.29, 0.35);\n}\n\nfloat sdRim(vec3 p){\n    p = opSymX(p);\n    p-=vec3(0.43,0.05,-0.4);\n    p*=rotx(1.44);\n    return min(\n                max(-sdCappedCylinder(p, 0.2, 10.),sdCappedCylinder(p, 0.29, 0.35)-0.03),\n                sdLens(p)\n               );\n}\n\nfloat sdGoggles(vec3 p){\n    return min(sdBand(p),\n               sdRim(p));\n}\n\nfloat sdNose(vec3 p){\n       p -= vec3(0,-.2,-.7);\n       return opSmoothSubtraction(sdSphere(opSymX(p)-vec3(0.3,-0.3,-0.1), 0.33),\n                                   sdRoundCone(p, 0.2, 0.07, 0.2),\n                                   0.1);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\nfloat gloveRing(vec3 p, float h, float r){\n    float d = sdHexagram(p.xy, r);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0))-0.1;\n}\nfloat sdGlove(vec3 p){\n    p -= vec3(.15, -2.2, -2.2);\n    p *= 3.;\n    return smin(\n                smin(\n                    smin(\n                        smin(\n                            sdTorus(repeat4y(opElongate(p, vec3(0.1,0,0.1))), 0.28, 0.4),\n                            sdBox(p-vec3(0.2,0.1,1.0),vec3(0.1, .3, 0.6))-0.5,\n                            0.5),\n                        sdCapsule(p, vec3(-0.9,.5,0.), vec3(-0.8,-.5,0.), 0.5),\n                        0.01),\n                    sdCapsule(p, vec3(-0.5,.8,1.), vec3(-0.9,.5,0.), 0.5),0.6),\n                 gloveRing(p-vec3(0,0,2.6), .2, 1.),\n                 0.2) / 3.;\n                \n}\n\nfloat sdShoulder(vec3 p){\n    p = opSymX(p)-vec3(2.,0.6,0);\n    return sdEllipsoid(p,vec3(0.9, 0.8, 0.7));\n}\n\nfloat sdArm(vec3 p){\n    float x = p.x;\n    p = opSymX(p)-vec3(2.,0.6,0);\n    p*= roty(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25)*rotz(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25)*rotx(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25);\n    return min(min(\n                smin(\n                    sdEllipsoid(p-vec3(0,-0.8,-0.1),vec3(0.5, 0.8, 0.6)),\n                    sdEllipsoid((p-vec3(0.1,-2.,-1.1))*rotx(0.2*3.14), vec3(0.5,0.4,.6)),\n                    0.3),\n                 sdGlove(p)\n               ),2.1);\n               //Quick hack to prevent the ray from overshooting when evaluating the other side\n               //Since the left arm is just a mirror of the right if x>0 then the ray will get the\n               //distance for the right arm and could over shoot the left one.\n               //Clamping the distance to a max of 2 will prevent this overshooting\n}\n\nfloat sdHead(vec3 p){\n    p-=vec3(0,1.8,-0.5);\n    vec3 q = vec3(p.x, p.y+cos(p.x*4.)*0.07-0.05+p.y*p.y*0.1, p.z-0.03);\n    float bound = sdSphere(q, 1.);\n    if (bound < 1.) {\n    return smin(\n                smin(\n                    min(sdTeeth(q),\n                        opSmoothSubtraction(\n                                            sdMouthCavity(q),\n                                            min(\n                                                smin(\n                                                        smin(sdSphere(p, 0.57),sdBox(p, vec3(0.3)),0.2),\n                                                        min(sdBox((p-vec3(0,-0.1,0))*rotx(0.88), vec3(0.25,0.1, 0.8)),\n                                                            sdBox((p-vec3(0,0,-0.2))*rotx(0.3), vec3(0.5,0.0, 0.52))\n                                                            ),\n                                                        0.04\n                                                    ),\n                                                sdGoggles(p)\n                                                ),\n                                             0.02\n                                            )\n                        ),\n                        sdNose(p), \n                        0.0\n                        ),\n                   sdBeard(p),\n                   0.005\n                 );\n                } else \n                    return bound;\n}\n\nfloat sdLegs(vec3 p, float leftOrRight){\n    p *= rotx(cos(iTime*WALKSPEED)*0.2*leftOrRight+0.5);\n    return min(\n                smin(\n                    sdCapsule(p, vec3(0), vec3(0., -1., 0), 0.5),\n                    sdBox((p-vec3(0., -1.4, .8)*rotx(.25*3.14))+vec3(0,sin((p.z-1.5)*2.)*0.1,0), vec3(0.3, -0.2, 0.5))-0.2,\n                    0.1),\n                .5);\n    }\n\nfloat sdPants(vec3 p){\n    vec3 q = opSymX(p)-vec3(.8, -2., 0);\n    vec3 knee = vec3(0.1, -0.7, 0);\n    q *= rotx(sin(iTime*WALKSPEED)*-0.5*p.x/abs(p.x)-0.5);\n   return  smin(\n               smin(sdSphere(p-vec3(0,-2.,0), 0.5),\n                    sdCapsule(\n                                q, \n                                vec3(0), \n                                knee,\n                                0.6), \n                    0.2),\n                sdLegs(q-knee, p.x/abs(p.x)),\n                0.1);\n}\n\nfloat sdGiant(vec3 p){\n    p.y += abs(cos(iTime*WALKSPEED))*0.1;\n    //Adding this bounding volume resulted in 5x fps and 0.25x compile time on my computer\n    float bound = sdBox(p, vec3(4,4.5,3.5));\n    if (bound < 1.){\n        vec3 h = p*rotx(cos(iTime*WALKSPEED*2.)*0.1);\n        p*=roty(sin(iTime*WALKSPEED)*-0.051);\n        vec3 q = p*rotx(cos(iTime*WALKSPEED*2.)*0.1);\n\n        return min(\n                    min(\n                        smin(\n                            min(\n                                smin(\n                                     smin(\n                                         sdBox(q-vec3(0,0.5,0)  ,vec3(1.,.2,0.3))-0.25,\n                                         sdBox(q-vec3(0,-0.35,0),vec3(1.,0.7,0.15))-0.25,\n                                         0.75\n                                         ),\n                                      sdPants(p),\n                                      0.1\n                                     ),\n                                min(\n                                    sdArm(q),\n                                    sdPlate(q)\n                                    )\n                                ),\n                             sdShoulder(q),\n                             0.1\n                            ),\n                        sdHead(h)),\n                        sdBelt(p)\n                        );\n    } else\n        return bound;\n                \n                \n}\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat sdPlane(vec3 p, float h){\n    return p.y - h;\n}\n\nfloat sdGround(vec3 p){\n    return sdPlane(p, -4.5);\n}\n\nfloat sdScene(vec3 p){\n    return min(sdGiant(p), sdGround(p));\n}\n\nfloat pow2(float v){\n    return v*v;\n}\n\n// IQ's normal function.\nvec3 calcNormal(vec3 p){ \n    \n    vec3 e = vec3(.001, 0, 0);\n    \n    vec3 n = vec3(0.0);\n    for( int i = min(iFrame, 0); i<4; i++ )\n    {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*sdScene(p + .001*e);\n    }\n    \n    return normalize(n);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdGiant(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return 1.-pow4(1.-res);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 im = iMouse / iResolution.xyxy;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, .4));\n    //rd *= rotx(0.0);\n    vec3 ro = vec3(0,1,-10);\n    vec3 LD = vec3(-0.4,1,-.3);\n    mat3 xr = rotx(.5);\n    mat3 yr = roty((-im.x)*3.14*-2.);\n    ro*=xr*yr;\n    rd*=xr*yr;\n    vec3 rp = ro;\n    \n    //March\n    float dist;\n    for (int i=0;i<60;i++){\n        dist = sdScene(rp);\n        if (10. < dist ^^ dist < 0.01)\n            break;\n        else\n            rp += rd*dist;\n    }\n    vec3 normal = calcNormal(rp);\n    //Colors\n    vec3 background = texture(iChannel0, rd).zyx;\n    vec3 refBackground = texture(iChannel0, reflect(rd, normal)).zyx;\n    vec3 col;\n    float ref = 0.05;\n   \n    //Coloring\n    #ifndef color\n    if (sdScene(rp) < 0.1){\n        col = vec3(0.9);\n        float shadow = softshadow(rp, LD, 1., 5., 1.);\n         col = col *shadow * dot(LD, normal)\n               + col * vec3(0.7, 0.8, 0.9) * 0.1;\n    } else {\n        float groundDist = plaIntersect(ro, rd, vec4(1,0,0,0));\n        vec2 gp = (rd*groundDist).xz;\n        vec2 grid = mod(gp, vec2(gridSize));\n        if (rd.y < 0.){\n            if ((grid.x < gridSize/2.) || (grid.y < gridSize/.2))\n                col = vec3(0.2);\n            else\n                col = vec3(0.4);\n        } else\n            col = background;\n    }\n            \n        col = background;\n    #else\n    if (sdGiant(rp) < 0.01){\n        rp.y += abs(cos(iTime*WALKSPEED))*0.1;\n        col = vec3(250,219,172)/256.;\n        //Giant rotations\n        vec3 p = rp*roty(sin(iTime*WALKSPEED)*-0.051);\n        vec3 h = rp*rotx(cos(iTime*WALKSPEED*2.)*0.1);\n        vec3 q = p*rotx(cos(iTime*WALKSPEED*2.)*0.1);\n        //Belt coloring\n        float belt = sdBelt(p);\n        float head = sdHead(h);\n        float plate = sdPlate(q);\n        float pants = sdPants(p);\n        //Arm transform\n        float x = q.x;\n        vec3 z = opSymX(q)-vec3(2.,0.6,0);\n        z *= roty(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25)*rotz(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25)*rotx(sin(iTime*WALKSPEED)*x/abs(x)*0.3-0.25);\n        float gloves = sdGlove(z);\n        if (belt <0.05){\n            col = mix(col, vec3(138, 51, 36) / 256., clamp(1./belt,0.,1.));\n            float beltBuckle = sdBeltBuckle(p);\n            if (beltBuckle < 0.01)\n                ref = 0.9;\n                col = mix(col, vec3(255,215,0) / 256., clamp(1./beltBuckle,0.,1.));\n        }\n        else if (head < 0.01){\n            //Head transforms\n            h-=vec3(0,1.8,-0.5);\n            float beard = sdBeard(h);\n            float nose = sdNose(h);\n            float teeth = sdTeeth(h);\n            float goggles = sdGoggles(h);\n            if (beard < 0.04)\n                col = mix(col, vec3(240, 74, 0) / 256., clamp(0.04/clamp(beard,10e-10,1.),0.,1.));\n            else if (nose <0.02)\n                col = mix(col, vec3(255,219,172)/350., clamp(0.02/clamp(nose,10e-10,1.),0.,1.));\n            else if (teeth < 0.01)\n                col = mix(col, vec3(1.), clamp(0.01/clamp(teeth,10e-10,1.),0.,1.));\n            else if (goggles < 0.1){\n                \n                float band = sdBand(h);\n                float rims = sdRim(h);\n                if (rims < 0.015){\n                        //Rim color    215\n                        ref = 0.7;\n                        col = mix(col, vec3(255,215,0) / 256., clamp(0.015/rims,0.,1.));\n                        //Rim space distortions\n                        h = opSymX(h);\n                        h-=vec3(0.43,0.05,-0.4);\n                        h*=rotx(1.44);\n                        float lens = sdLens(h);\n                        if (lens < 0.02)\n                            col = mix(col, vec3(135,206,250) / 256., clamp(0.02/clamp(lens,10e-10,1.),0.,1.));\n                }\n                else if (band < 0.1)\n                    col = mix(col, vec3(0.1), clamp(0.1/band, 0.,1.));\n            }\n        }\n        else if (plate < 0.14){\n            p-=vec3(0,0.1,-0.085);\n            p*=roty(0.5*3.141);\n            if (sdCoil(p) < 0.1){\n                ref = 0.7;\n                col = vec3(255,215,0) / 256.;\n            } else {\n                ref = 0.5;\n                col = mix(col, vec3(0.4), clamp(1./plate, 0., 1.));\n            }\n        }\n        else if (pants < 0.1){\n            vec3 l = opSymX(p)-vec3(.8, -2., 0);\n            vec3 knee = vec3(0.1, -0.7, 0);\n            l *= rotx(sin(iTime*WALKSPEED)*-0.5*p.x/abs(p.x)-0.5);\n            float legs = sdLegs(l-knee, p.x/abs(p.x));\n            if (legs > 0.1)\n                col = mix(col, vec3(0.1, 0.1, 0.9), clamp(1./pants, 0., 1.));\n        }\n        else if (gloves < 0.1){\n            col = mix(col, vec3(138, 51, 36)/256., clamp(1./gloves, 0., 1.));\n        }\n    float shadow = clamp(0.5+softshadow(rp, LD, 1., 5., 1.), 0., 1.)*0.5;\n     col = col *shadow*2. * (0.25*dot(LD, normal)+0.75)\n           + col * vec3(0.7, 0.8, 0.9) * 0.1;\n       col = mix(col, refBackground, ref * clamp(shadow*2.,0.,1.));\n    } else if (rd.y < 0.){\n        float shadow = softshadow(rp, LD, 1., 5., 1.);\n        float g = texture(iChannel2, rp.xz*0.05+ vec2(0, -0.05*iTime*WALKSPEED)).x;\n        col = clamp(shadow, 0.2, 0.3) * vec3(g);\n    } else {\n        \n        col = background;\n    }\n    #endif\n    \n    //Lighting\n    \n    // Output to screen\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 28281,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/direalshaggy/boombastic?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}