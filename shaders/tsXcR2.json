{
    "Shader": {
        "info": {
            "date": "1585138592",
            "description": "reaction diffusion adapted from https://forum.processing.org/two/discussion/22385/reaction-diffusion-using-glsl-works-different-from-normal",
            "flags": 32,
            "hasliked": 0,
            "id": "tsXcR2",
            "likes": 4,
            "name": "PetriDiffusion",
            "published": 3,
            "tags": [
                "diffusion"
            ],
            "usePreview": 0,
            "username": "etch4sketch",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "\nfloat circle(in vec2 _uv, in float _aspect){\n    float dist = length(vec2(_uv.x * _aspect, _uv.y) - vec2(0.5 * _aspect, 0.5));\n\treturn dist;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    //get the pixel value for thisVal from buffer\n    vec2 conc = texture(iChannel0, uv).xy;\n    \n    vec3 white = vec3(1.0);\n\n    vec3 whiteness = conc.x * white;\n    vec3 blackness = conc.y * white;\n    \n    vec3 color = whiteness - blackness;\n    \n    color.x += 0.125;\n    \n    \n    float circ = smoothstep(0.675, 0.695, 1.0 - circle(uv, aspect));\n    \n    float circ2 = smoothstep(0.69, 0.695, 1.0 - circle(uv, aspect)) - smoothstep(0.70, 0.7050, 1.0 - circle(uv, aspect));\n      \n    float circ3 = smoothstep(1.0 - 0.68,1.0 - 0.67,circle(uv, aspect));\n        \n    \n    color *= circ;\n    color -= 0.2 * circ2;\n    \n    color += circ3;   \n    \n    \n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//laplacian filter\nvec2 laplacian(in vec2 uv)\n{\n    \n    vec2 AB = (texture(iChannel0, uv)).xy ;\n    vec2 pixel = vec2(0.001);\n    vec2 laplace = -1.0 * AB;\n    \n    //slight noise added to the filter sides\n    float sideWeight = 0.2;// * (0.98 + random(uv ) / 25.0 );\n    float cornerWeight = 0.05;\n    \n    laplace += texture(iChannel0, uv + pixel * vec2(0, -1)).xy * cornerWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(-1, 0)).xy * cornerWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(1, 0)).xy * cornerWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(0, 1)).xy * cornerWeight;\n    \n    \n    laplace += texture(iChannel0, uv + pixel * vec2(-1, -1)).xy * sideWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(1, -1)).xy * sideWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(-1, 1)).xy * sideWeight;\n    laplace += texture(iChannel0, uv + pixel * vec2(1, 1)).xy * sideWeight;\n    \n    return laplace;\n    \n}\n\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float DA = 1.0;\n    float DB = 0.5;\n    float feed = 0.03;\n    float kill = 0.062;\n    float dt = 1.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n       \n    float A = texture(iChannel0, uv).x ;\n    float B = texture(iChannel0, uv).y ;  \n    vec2 laplaceAB = laplacian(uv);\n    float laplaceA = laplaceAB.x;\n    float laplaceB = laplaceAB.y;\n    \n    \n    float jitter = (random(uv * iTime) - 0.5) * 0.05 ;\n    \n    //kill *= 0.5 + random(uv);\n        \n    float nA = A + ((DA*laplaceA) - (A*B)*B + (feed*(1.0 - A)))*dt + jitter ;\n    float nB = B + ((DB*laplaceB) + (A*B)*B - ((kill + feed)*B))*dt;\n    \n    \n    //need to seed the pixels on first frame\n    if(iFrame > 2) fragColor = vec4(clamp(nA, 0.0, 1.0), clamp(nB, 0.0, 1.0), 0.0, 1.0);\n    else {\n        \n        float rand = noise(uv * 100.0);\n        \n        float binary = step(0.04, rand);\n        \n        fragColor = vec4(vec3(0.5 + binary/2.0, 0.5 - binary/2.0, 0.0), 1.0);\n        //if(random(uv) > 0.05) fragColor = vec4(vec3(1.0, 0.0, 0.0), 1.0);\n        //else fragColor = vec4(vec3(0.5, 0.5, 0.0), 1.0);   \n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}