{
    "Shader": {
        "info": {
            "date": "1469033021",
            "description": "All of the block data here is generated and remains on the GPU, and is rendered by raycasting. If you are getting a black screen, your GPU might be lacking necessary features. Has been tested on recent Nvidia and Intel GPUs.",
            "flags": 112,
            "hasliked": 0,
            "id": "MtcGDH",
            "likes": 272,
            "name": "[SH16C] Voxel Game",
            "published": 3,
            "tags": [
                "game",
                "raycasting",
                "voxel",
                "minecraft",
                "multipass",
                "sh16c"
            ],
            "usePreview": 1,
            "username": "fb39ca4",
            "viewed": 21807
        },
        "renderpass": [
            {
                "code": "/* \nVoxel Game\nfb39ca4's SH16C Entry\n\nThis was an attempt to make something like Minecraft entirely in\nShadertoy. The world around the player is saved in a buffer, and as long\nas an an area is loaded, changes remain. However, if you go too far\naway, blocks you have modified will reset. To load more blocks, go to \nfullscreen to increase the size of the buffers. I tried to implement\nmany of the features from Minecraft's Creative mode, but at this point,\nthis shader is more of a tech demo to prove that interactive voxel games\nare possible.\n\nFeatures:\n    Semi-persistent world\n    Flood-fill sky and torch lighting\n    Smooth lighting and ambient occlusion\n    Day/Night cycle\n    Movement with collision detection\n    Flying and sprinting mode\n    Block placment and removal\n    Hotbar to choose between: Stone, Dirt, Grass, Cobblestone, Glowstone, \n        Brick, Gold, Wood\n    \nControls:\n    Click and drag mouse to look, select blocks\n    WASD to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n    Q + mouse button to place block\n    E + mouse button to destroy blocks\n    Z/X to cycle through available blocks for placement\n    0-8 to choose a block type for placement\n    Page Up/Down to increase or decrease render resolution\n    O,P to decrease/increase speed of day/night cycles\n\n\tThere are #defines in Buffer A to change the controls.\n\nTODO:\nâœ“ Voxel Raycaster\nâœ“ Free camera controls\nâœ“ Store map in texture\nâœ“ Infinite World\nâœ“ Persistent World\nâœ“ Sky Lighting\nâœ“ Torch Lighting\nâœ“ Smooth Lighting, Ambient Occlusion\nâœ“ Vertical Collision Detection\nâœ“ Walking, Jumping\nâœ“ Horizontal collision detection\nâœ“ Textures\nâœ“ Proper world generation\nâœ“ Block picking\nâœ“ Adding/Removing blocks\nâœ“ GUI for block selection\nâœ“ Sun, Moon, Sky\nâœ“ Day/Night Cycle\nâœ“ Double jump to fly, double tap forwards to run\n*/\n\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy), 0.0);\n}\n\nfloat keyToggled(int keyCode) {\n\treturn textureLod(iChannel1, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id / 16.));\n\treturn textureLod(iChannel2, 16. * (c + gridPos) / iChannelResolution[2].xy, 0.0);\n}\n\nconst float numItems = 8.;\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) {\n  return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nvec4 drawGui(vec2 c) {\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    vec4 o = vec4(0);\n    float xStart = (r.x - 16. * numItems) / 2.;\n    c.x -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c / 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)/2.,.5);\n    vec2 v = vec2(-sqrt(3.)/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.x < numItems * 16. && c.x >= 0. && c.y < 16.) {\n        float slot = floor(c.x / 16.);\n    \to = getTexture(48., fract(c / 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * selected, 0));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\nconst vec2 packedChunkSize = vec2(11,6);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float scaleFactor = pow(sqrt(2.), load(_renderScale).r);\n    vec2 renderResolution = ceil(iResolution.xy / scaleFactor); \n    fragColor = texture(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy);\n    vec4 gui = drawGui(fragCoord);\n    fragColor = mix(fragColor, gui, gui.a);\n    \n    vec3 pos = load(_pos).xyz;\n        \n    if (bool(keyToggled(114))) {\n        if (fragCoord.x < 20.) fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, fragCoord / iResolution.xy).rgb, texture(iChannel0, fragCoord / iResolution.xy).a);\n        fragColor = mix( fragColor, vec4(1,1,0,1), PrintValue(fragCoord, vec2(0.0, 5.0), vec2(8,15), iTimeDelta, 4.0, 1.0));\n        fragColor = mix( fragColor, vec4(1,0,1,1), PrintValue(fragCoord, vec2(0.0, 25.0), vec2(8,15), load(_time).r, 6.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y - 20.), vec2(8,15), pos.x, 4.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 40.), vec2(8,15), pos.y, 4.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yyxx, PrintValue(fragCoord, vec2(0., iResolution.y - 60.), vec2(8,15), pos.z, 4.0, 5.0));\n        \n    }\n\t\n    //fragColor = texture(iChannel2, fragCoord / 3. / iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_DECREASE_RESOLUTION 34\n#define KEY_INCREASE_RESOLUTION 33\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_INVENTORY_NEXT 88\n#define KEY_INVENTORY_PREVIOUS 90\n#define KEY_INVENTORY_ABSOLUTE_START 49\n\nconst float PI = 3.14159265359;\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[1].xy), 0.0);\n}\n\nbool inBox(vec2 coord, vec4 bounds) {\n\treturn coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\n\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n\tif (inBox(currentCoord, vec4(coord, 1., 1.))) {\n    \toutValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n\treturn textureLod(iChannel2, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n\treturn textureLod(iChannel2, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n\tbool now = bool(keyDown(keycode));\n    bool previous = bool(textureLod(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\nconst vec2 packedChunkSize = vec2(12,7);\nconst float heightLimit = packedChunkSize.x * packedChunkSize.y;\n\nfloat calcLoadDist(void) {\n\tvec2 chunks = floor(iResolution.xy / packedChunkSize);\n    float gridSize = min(chunks.x, chunks.y);\n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange(vec2 pos) {\n\tvec2 d = calcLoadDist() * vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n\treturn float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\nvec4 readMapTex(vec2 pos) {\n \treturn textureLod(iChannel1, (floor(pos) + 0.5) / iChannelResolution[0].xy, 0.0);   \n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nstruct voxel {\n\tfloat id;\n    float sunlight;\n    float torchlight;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nbool getHit(vec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = readMapTex(voxToTexCoord(p)).r;\n\treturn d > 0.5;\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n    vec3 tangent;\n    vec3 bitangent;\n    float dist;\n};\n\n    \nrayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset) {\n\tvec3 mapPos = floor(rayPos);\n    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    vec3 rayStep = sign(rayDir);\n    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n    vec3 mask;\n    bool hit = false;\n    for (int i = 0; i < 9; i++) {\n\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += vec3(mask) * rayStep;\n\t\t\n        if (mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;\n        if (getHit(mapPos - offset)) { \n            hit = true; \n            break;\n        }\n\n\t}\n    vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n   \tvec2 uv;\n    vec3 tangent1;\n    vec3 tangent2;\n    if (abs(mask.x) > 0.) {\n        uv = endRayPos.yz;\n        tangent1 = vec3(0,1,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else if (abs(mask.y) > 0.) {\n        uv = endRayPos.xz;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else {\n        uv = endRayPos.xy;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,1,0);\n    }\n    uv = fract(uv);\n    rayCastResults res;\n    res.hit = hit;\n    res.uv = uv;\n    res.mapPos = mapPos;\n    res.normal = -rayStep * mask;\n    res.tangent = tangent1;\n    res.bitangent = tangent2;\n    res.rayPos = endRayPos;\n    res.dist = length(rayPos - endRayPos);\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n            \tfragColor.r = texture(iChannel2, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iResolution.xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n        \t}\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse / length(iResolution.xy);\n\t\t\t\tfloat renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n\n                if (iFrame == 0) {\n                    pos = vec3(0,0,52);\n                    angle = vec2(-0.75,2.5);\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = 0.;\n                    time = vec2(0,4);\n                    selected = 0.;\n                }\n                if (oldMouse.z > 0. && iMouse.z > 0.) {\n                    angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1);\n                    angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                /*move += dir * (keyDown(87)-keyDown(83));\n                move += dirU * (keyDown(68) - keyDown(65));\n                move += vec3(0,0,1) * (keyDown(82) - keyDown(70));*/\n\n                float inBlock = 0.;\n                float minHeight = 0.;\n                vec3 vColPos, hColPos;\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    if (getVoxel(vColPos - offset + vec3(0,0,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,0.5), pos.xy, vec2(.8))\n                        + getVoxel(vColPos - offset + vec3(0,1,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,1.5), pos.xy, vec2(.8)) \n                        + getVoxel(vColPos - offset + vec3(1,0,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,0.5), pos.xy, vec2(.8))\n                        + getVoxel(vColPos - offset + vec3(1,1,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,1.5), pos.xy, vec2(.8))\n                        > .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n                float maxHeight = heightLimit - 1.8;\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                if (getVoxel(vColPos - offset + vec3(0,0,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,0.5), pos.xy, vec2(.8))\n                    + getVoxel(vColPos - offset + vec3(0,1,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,1.5), pos.xy, vec2(.8)) \n                    + getVoxel(vColPos - offset + vec3(1,0,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,0.5), pos.xy, vec2(.8))\n                    + getVoxel(vColPos - offset + vec3(1,1,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,1.5), pos.xy, vec2(.8))\n                    > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;\n                }\n                float minX = pos.x - 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8)\n                    > .5) {\n                    minX = hColPos.x + 1.301;\n                }\n                float maxX = pos.x + 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8)\n                    > .5) {\n                    maxX = hColPos.x - .301;\n                }\n                            float minY = pos.y - 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8)\n                    > .5) {\n                    minY = hColPos.y + 1.301;\n                }\n                float maxY = pos.y + 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8)\n                    > .5) {\n                    maxY = hColPos.y - .301;\n                }\n                                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.;\n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n                    \n                if (bool(keySinglePress(KEY_FORWARDS))) {\n\t\t\t\t\tif (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\t\t\t\t\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    else {\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\t\t\t\t\n                \n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                if (iMouse.z > 0.) {\n                    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n                    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * iResolution.y / iResolution.x;\n                    vec2 screenPos = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n                    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n                    rayCastResults res = rayCast(pos + vec3(0,0,1.6), rayDir, offset);\n                    if (res.dist <= 5.) {\n                        pick.xyz = res.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(vec2(0,9),pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += res.normal;\n                            timer += dt / 0.3;\n                        }\n                \t\tif (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                else {\n                    pick = vec4(-1,-1,-1,0);\n                    timer = 0.;\n                }\n\t\t\t\t\n                const int numItems = 8;\n                selected += keyPress(KEY_INVENTORY_NEXT) - keyPress(KEY_INVENTORY_PREVIOUS);\n                for (int i = 0; i < 9; i++) {\n                \tif (bool(keyPress(KEY_INVENTORY_ABSOLUTE_START + i))) selected = float(i);   \n                }\n\t\t\t\tselected = mod(selected, float(numItems));\n                \n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_RESOLUTION) - keySinglePress(KEY_INCREASE_RESOLUTION), 0., 4.);\n\t\t\t\ttime.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n\t\t\t\ttime.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                store3(_pos, pos);\n                store2(_angle, angle);\n                store4(_loadRange, calcLoadRange(pos.xy));\n                store4(_mouse, mouse);\n                store1(_inBlock, inBlock);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                fragColor = outValue;\n            }\n        }\n        else fragColor = texture(iChannel0, (fragCoord - _old) / iResolution.xy);\n    }\n    else fragColor.rgb = vec3(0,0,0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 4290,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/bitesizekid/minecraft-background-music"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[1].xy));\n}\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n//\n// Description : Array and textureless GLSL 2D,3D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nconst vec2 packedChunkSize = vec2(12,7);\nconst float heightLimit = packedChunkSize.x * packedChunkSize.y;\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\nfloat calcLoadRange(void) {\n\tvec2 chunks = floor(iResolution.xy / packedChunkSize);\n    float gridSize = min(chunks.x, chunks.y);\n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 readMapTex(vec2 pos) {\n \treturn texture(iChannel1, (floor(pos) + 0.5) / iChannelResolution[0].xy);   \n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset) {\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nstruct voxel {\n\tfloat id;\n    float sunlight;\n    float torchlight;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 o;\n    o.r = v.id;\n    o.g = clamp(floor(v.sunlight), 0., 15.) + 16. * clamp(floor(v.torchlight), 0., 15.);\n    o.b = v.hue;\n    o.a = 1.;\n    return o;\n}\n\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nbool overworld(vec3 p) {\n\tfloat density = 48. - p.z;\n    density += mix(0., 40., pow(.5 + .5 * snoise(p.xy /557. + vec2(0.576, .492)), 2.)) * snoise(p / 31.51 + vec3(0.981, .245, .497));\n    return density > 0.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset);            \n    \n    voxel vox;\n    vec4 range = load(_old+_loadRange);\n    vec4 pick = load(_pick);\n    if (!inRange(voxelCoord.xy, range) || iFrame == 0 ) {\n    \tbool solid = overworld(voxelCoord);\n        if (solid) {\n            vox.id = 3.;\n            if (overworld(voxelCoord + vec3(0,0,1))) vox.id = 2.;\n            if (overworld(voxelCoord + vec3(0,0,3))) vox.id = 1.;\n    \t\tif (hash13(voxelCoord) > 0.98 && !overworld(voxelCoord + vec3(0,0,-1))) vox.id = 6.;\n        }\n        if (snoise(voxelCoord / 27.99 + vec3(0.981, .245, .497).yzx * 17.) > 1. - (smoothstep(0., 5., voxelCoord.z) - 0.7 * smoothstep(32., 48., voxelCoord.z))) vox.id = 0.;\n        if (voxelCoord.z < 1.) vox.id = 16.;\n        vox.hue = fract(hash13(voxelCoord));\n        vox.sunlight = 0.;\n        vox.torchlight = 0.;\n    }\n    else {\n    \tvox = getVoxel(voxelCoord - oldOffset);\n    }\n\n    if (voxelCoord == pick.xyz) {\n        if (pick.a == 1. && load(_pickTimer).r > 1. && vox.id != 16.) vox.id = 0.;\n        if (pick.a == 2.) vox.id = getInventory(load(_selectedInventory).r);\n    }\n    \n    voxel temp;\n    if (voxelCoord.z == heightLimit - 1.) {\n    \tvox.sunlight = 15.;   \n    }\n    else vox.sunlight = 0.;\n    vox.torchlight = 0.;\n    //if (length(voxelCoord + .5 - load(_pos).xyz) < 1.) vox.torchlight = 15.;\n    if (voxelCoord.z < heightLimit - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,0,1) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.z > 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,0,-1) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.x > range.x + 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(-1,0,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.x < range.y - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(1,0,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.y > range.z + 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,-1,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.y < range.w - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,1,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    \n    if (vox.id > 0.) {\n        vox.sunlight = 0.;\n        vox.torchlight = 0.;\n    }\n    \n    if (vox.id == 6.) {\n    \tvox.torchlight = 15.;   \n    }\n    fragColor = encodeVoxel(vox);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\n\nvec4 load(vec2 coord) {\n\treturn texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy));\n}\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec4 noiseTex(vec2 c) {\n\treturn texture(iChannel1, c / iChannelResolution[1].xy);   \n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nfloat signed(float x) {\n\treturn x * 2. - 1.;   \n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n\tfloat d = 1.0e10;\n    //t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = texture(iChannel1, vec2(4, i) / 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) / length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id / 16.));\n\treturn texture(iChannel2, (c + gridPos * 16.) / iChannelResolution[3].xy);\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    \n    vec2 gridPos = floor(fragCoord / 16.);\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 16.);\n    o.a = 1.;\n    if (id == 0) {\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) {\n        o.rgb = 0.45 + 0.2 * vec3(noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)) * 3. - 1.), 0.)).b);\n    }\n    if (id == 2) {\n    \to.rgb = vec3(0.55,0.4,0.3) * (1. + 0.3 * signed(noiseTex(c + 37.).r));\n        if (hash12(c * 12.) > 0.95) o.rgb = vec3(0.4) + 0.2 * noiseTex(c + 92.).g;\n    }\n    if (id == 3) {\n    \to.rgb = getTexture(2., c).rgb;\n        if (noiseTex(vec2(0, c.x) + 12.).a * 3. + 1. > 16. - c.y) o.rgb = getTexture(4., c).rgb;\n    }\n    if (id == 4) {\n    \to.rgb = hsv2rgb(vec3(0.22, .8 - 0.3 * noiseTex(c + 47.).b, 0.6 + 0.1 * noiseTex(c + 47.).b));\n    }\n    if (id == 5) {\n    \to.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.));\n    }\n    if (id == 6) {\n        float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n    if (id == 7) {\n    \to.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) {\n        o.rgb = vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c)) * (1. + 0.2 * noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)))) * 3. - 1.).b);\n    }\n    if (id == 16) {\n      \to.rgb = (-1. + 2. * getTexture(1., c).rgb) * 2.5;\n    }\n    if (id == 32) {\n    \to.rgb = vec3(crackingAnimation(c / 16., load(_pickTimer).r));\n    }\n    if (id == 48) {\n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float PI = 3.14159265359;\n\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy), 0.0);\n}\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = storageCoord;\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nconst vec2 packedChunkSize = vec2(12,7);\n\nvec4 readMapTex(vec2 pos) {\n \treturn textureLod(iChannel1, (floor(pos) + 0.5) / iChannelResolution[0].xy, 0.0);   \n}\n\nvec2 voxToTexCoord(vec3 p) {\n \tp = floor(p);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nbool getHit(vec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = readMapTex(voxToTexCoord(p)).r;\n\treturn d > 0.5;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id / 16.));\n\treturn textureLod(iChannel2, 16. * (c + gridPos) / iChannelResolution[3].xy, 0.0);\n}\n\n\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\nstruct voxel {\n\tfloat id;\n    vec2 light;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.light.s = floor(mod(textel.g, 16.));\n    o.light.t = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(vec2 light) {\n    light = 15. - light;\n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;\n}\n\nfloat opaque(float id) {\n\treturn id > .5 ? 1. : 0.;   \n}\n\nvec3 calcLightingFancy(vec3 r, vec3 s, vec3 t, vec2 uv) {\n\tvoxel v1, v2, v3, v4, v5, v6, v7, v8, v9;\n    //uv = (floor(uv * 16.) + .5) / 16.;\n    v1 = getVoxel(r - s + t);\n    v2 = getVoxel(r + t);\n    v3 = getVoxel(r + s + t);\n    v4 = getVoxel(r - s);\n    v5 = getVoxel(r);\n    v6 = getVoxel(r + s);\n    v7 = getVoxel(r - s - t);\n    v8 = getVoxel(r - t);\n    v9 = getVoxel(r + s - t);\n    \n    //return vec3(uv, 0.) - .5 * opaque(v6.id);\n    \n    vec2 light1, light2, light3, light4, light;\n    light1 = max24(v1.light, v2.light, v4.light, v5.light);\n    light2 = max24(v2.light, v3.light, v5.light, v6.light);\n    light3 = max24(v4.light, v5.light, v7.light, v8.light);\n    light4 = max24(v5.light, v6.light, v8.light, v9.light);\n    \n    float ao1, ao2, ao3, ao4, ao;\n    ao1 = vertexAo(opaque(v2.id), opaque(v4.id), opaque(v1.id));\n    ao2 = vertexAo(opaque(v2.id), opaque(v6.id), opaque(v3.id));\n    ao3 = vertexAo(opaque(v8.id), opaque(v4.id), opaque(v7.id));\n    ao4 = vertexAo(opaque(v8.id), opaque(v6.id), opaque(v9.id));\n    \n    light = mix(mix(light3, light4, uv.x), mix(light1, light2, uv.x), uv.y);\n    ao = mix(mix(ao3, ao4, uv.x), mix(ao1, ao2, uv.x), uv.y);\n    \n    return lightmap(light) * pow(ao, 1. / 1.);\n}\n\nvec3 calcLightingFast(vec3 r, vec3 s, vec3 t, vec2 uv) {\n    return lightmap(min(getVoxel(r).light + 0.2, 15.));\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n    vec3 tangent;\n    vec3 bitangent;\n    float dist;\n};\n\nrayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset, vec4 range) {\n\tvec3 mapPos = floor(rayPos);\n    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    vec3 rayStep = sign(rayDir);\n    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n    vec3 mask;\n    bool hit = false;\n    for (int i = 0; i < 384; i++) {\n\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += vec3(mask) * rayStep;\n\t\t\n        if (!inRange(mapPos.xy, range) || mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;\n        if (getHit(mapPos - offset)) { \n            hit = true; \n            break;\n        }\n\n\t}\n    vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n   \tvec2 uv;\n    vec3 tangent1;\n    vec3 tangent2;\n    if (abs(mask.x) > 0.) {\n        uv = endRayPos.yz;\n        tangent1 = vec3(0,1,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else if (abs(mask.y) > 0.) {\n        uv = endRayPos.xz;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else {\n        uv = endRayPos.xy;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,1,0);\n    }\n    uv = fract(uv);\n    rayCastResults res;\n    res.hit = hit;\n    res.uv = uv;\n    res.mapPos = mapPos;\n    res.normal = -rayStep * mask;\n    res.tangent = tangent1;\n    res.bitangent = tangent2;\n    res.rayPos = endRayPos;\n    res.dist = length(rayPos - endRayPos);\n    return res;\n}\n\n\nvec3 skyColor(vec3 rayDir) {\n    float t = load(_time).r;\n    float lightLevel = lightLevelCurve(t);\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    vec3 sunDir = vec3(cos(sunAngle), 0, sin(sunAngle));\n    \n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float scaleFactor = pow(sqrt(2.), load(_renderScale).r);\n    vec2 renderResolution = ceil(iResolution.xy / scaleFactor); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n    vec2 screenPos = (fragCoord.xy / renderResolution.xy) * 2.0 - 1.0;\n\tvec3 rayPos = load(_pos).xyz + vec3(0,0,1.6);\n    vec2 angle = load(_angle).xy;\n    vec4 range = load(_loadRange);\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV);\n\t\n\tvec3 mapPos = vec3(floor(rayPos));\n    vec3 offset = vec3(floor(load(_pos).xy), 0.);\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tvec3 rayStep = vec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tvec3 mask;\n    \n    mapPos;\n    \n    rayCastResults res = rayCast(rayPos, rayDir, offset, range);\n\t\n\tvec3 color = vec3(0);\n    voxel vox = getVoxel(res.mapPos - offset);\n    if (res.hit) {\n        \n        color = calcLightingFancy(res.mapPos - offset + res.normal, res.tangent, res.bitangent, res.uv);\n        //color *= hsv2rgb(vec3(getVoxel(mapPos + .5 - offset).hue, .1, 1));\n        float textureId = vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        color *= getTexture(textureId, res.uv).rgb;\n        vec4 pick = load(_pick);\n        if (res.mapPos == pick.xyz) {\n            if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n            else color = mix(color, vec3(1), 0.2);\n        }\n        //color.rgb = res.uv.xyx;\n    }\n    //else color = mix(lightmap(vec2(0)) / 2., skyColor(rayDir), vox.light.s / 15.);\n    else color = skyColor(rayDir);\n    fragColor.rgb = pow(color, vec3(1.));\n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}