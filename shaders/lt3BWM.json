{
    "Shader": {
        "info": {
            "date": "1539852476",
            "description": "simple demos of 1d perlin noise.\nupper left:   1d perlin noise curve\nupper right:  simple 2D terrain\nlower left:   hand drawn effect\nlower right:  2D water surface",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3BWM",
            "likes": 32,
            "name": "Demo - 1D Perlin Noise",
            "published": 3,
            "tags": [
                "terrain",
                "perlinnoise",
                "water",
                "1d",
                "curve",
                "handdrawn"
            ],
            "usePreview": 0,
            "username": "ikuto",
            "viewed": 2607
        },
        "renderpass": [
            {
                "code": "//---------------------------------------------------------------------------\n//Rendering: four simple demos\n//upper left:   1d perlin noise curve\n//upper right:  simple 2D terrain\n//lower left:   hand drawn effect\n//lower right:  2D water surface\n//---------------------------------------------------------------------------\n#define FADE_SCALE 30.0\n\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color, bool isSolid) \n{\n\tfloat d = (length(uv - center) - radius) * FADE_SCALE;\n    d = isSolid ? d : abs(d);\n\treturn vec4(color, 1. - clamp(d, 0., 1.));\n}\n\nvec4 rect(vec2 uv, vec2 minV, vec2 maxV, vec3 color, bool isSolid)\n{\n\tfloat d = max(max(uv.x-maxV.x, minV.x-uv.x), max(uv.y-maxV.y, minV.y-uv.y)) * FADE_SCALE;\n    d = isSolid ? d : abs(d);\n\treturn vec4(color, 1. - clamp(d, 0., 1.));\n}\n\nvec4 renderUL(in vec2 uv)\n{\n    float noise = .5 * fbm(2.*uv.x + 4.*iTime, 4, .2);\n    float d = (uv.y - noise) * FADE_SCALE;\n\tfloat t = clamp(abs(d), 0., 1.);\n    \n    return mix(vec4(1.), vec4(0.) + abs(uv.y)*.3, t);\n}\n\nvec4 renderUR(in vec2 uv)\n{\n    float noise = .5 * fbm(uv.x - iTime, 3, .2);\n    float d = (uv.y - noise) * FADE_SCALE;\n\tfloat t = clamp(d, 0., 1.);\n    \n    vec3 skyColor = vec3(.15, .05, .0) + uv.y * .1;\n    vec3 mountainColor = vec3(0.0) + .4*(uv.y+1.)*skyColor;\n    return vec4(mix(mountainColor, skyColor, t), 1.);\n}\n\nvec4 renderLL(in vec2 uv)\n{\n    float noise = .04 * (fbm(uv.x, 5, .7) + fbm(uv.y, 5, .7));\n \tvec4 layer1 = circle(uv, vec2(0.), .7 + noise, vec3(0., .6, 0.), false);\n    vec4 layer2 = circle(uv, vec2(0.), .5 + noise, vec3(.6, .6, 0.), false);\n    vec4 layer3 = circle(uv, vec2(0.), .3 + noise, vec3(.2), false);\n    vec4 layer4 = rect(uv + noise, vec2(-.85), vec2(.85), vec3(.0, .7, .7), false);\n    vec4 finalColor = vec4(.87, .83, .75, 1.) + 2.*noise;\n    \n    finalColor = mix(finalColor, layer1, layer1.a);\n    finalColor = mix(finalColor, layer2, layer2.a);\n    finalColor = mix(finalColor, layer3, layer3.a);\n    finalColor = mix(finalColor, layer4, layer4.a);\n    return finalColor;\n}\n\nvec4 renderLR(in vec2 uv)\n{\n    float noise = .04 * (fbm(uv.x, 4, .1) + fbm(uv.x + iTime, 4, .1));\n    float d = (uv.y + noise + .24) * FADE_SCALE;\n\tfloat t = clamp(d, 0., 1.);\n    \n    vec3 skyColor = vec3(.3, .5, .8) - uv.y * .3;\n    vec3 waterColor = vec3(.0, .3, .5) + .3 * uv.y;\n    return vec4(mix(waterColor, skyColor, t), 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    float noise = .02 * fbm(uv.x + uv.y, 6, 1.);\n    \n    if (uv.x <= noise && uv.y > noise)\n\t\tfragColor = renderUL(2.*uv+vec2(aspect, -1.));\n    else if (uv.x > noise && uv.y > noise)\n        fragColor = renderUR(2.*uv+vec2(-aspect, -1.));\n    else if (uv.x <= noise && uv.y <= noise)\n        fragColor = renderLL(2.*uv+vec2(aspect, 1.));\n    else\n        fragColor = renderLR(2.*uv+vec2(-aspect, 1.));  \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//---------------------------------------------------------------------------\n//1D Perlin noise implementation \n//---------------------------------------------------------------------------\n#define HASHSCALE 0.1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat fbm(float pos, int octaves, float persistence) \n{\n    float total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n    for(int i = 0; i < octaves; ++i) \n    {\n        total += perlinNoise1D(pos * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total / maxValue;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}