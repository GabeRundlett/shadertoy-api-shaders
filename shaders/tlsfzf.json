{
    "Shader": {
        "info": {
            "date": "1598555855",
            "description": "ZeroTwo from \"Darling in the Franxx\"",
            "flags": 0,
            "hasliked": 0,
            "id": "tlsfzf",
            "likes": 99,
            "name": "Code:002",
            "published": 3,
            "tags": [
                "zerotwo"
            ],
            "usePreview": 0,
            "username": "Pidhorskyi",
            "viewed": 3534
        },
        "renderpass": [
            {
                "code": "vec4 render(float d, vec3 color, float w)\n{\n    float anti = fwidth(d) * w;\n    return vec4(color, smoothstep(anti, -anti, d));\n}\n\nvec4 render(float d, vec4 color)\n{\n    float anti = fwidth(d) * 1.0;\n    return vec4(color.rgb, color.a * smoothstep(anti, -anti, d));\n}\n\nvec4 render_stroked(float d, vec3 color, float stroke)\n{\n    float anti = fwidth(d) * 1.0;\n    vec4 strokeLayer = vec4(vec3(0.01), smoothstep(anti, -anti, d - stroke));\n    vec4 colorLayer = vec4(color, smoothstep(anti, -anti, d));\n    return vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\nvec4 render_stroked_masked(float d, vec3 color, float stroke, float stroke_mask)\n{\n    float anti = fwidth(d) * 1.0;\n    vec4 strokeLayer = vec4(vec3(0.01), smoothstep(anti, -anti, d));\n    float se = smoothstep(anti, -anti, stroke_mask);\n    vec4 colorLayer = vec4(color, smoothstep(anti, -anti, d + stroke));\n    return vec4(mix(mix(strokeLayer.rgb, colorLayer.rgb,  se), colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\nvoid render_layer(inout vec4 c, vec4 layer)\n{ \n    c.rgb = mix(c.rgb, layer.rgb, layer.a);\n}\n\nvoid render_layer_mul(inout vec4 c, vec4 layer)\n{ \n    c.rgb = mix(c.rgb, c.rgb * layer.rgb, layer.a);\n}\n\nfloat exact_intersection(float d1, float d2)\n{\n    float dmin = min(d1, d2);\n    float dmax = max(d1, d2);\n    return dmin < 0. ? dmax : dmin;\n}\n\nvec4 sdEye(vec2 p)\n{\n    p += vec2(0.52, -0.15);\n    vec2 plt = vec2(-0.035, -0.045); vec2 pmt = vec2(0.56, 0.31); vec2 prt = vec2(0.862, 0.0421);\n    vec2 plm = vec2(0.039, -0.3);                                vec2 prm = vec2(0.87, -0.088);\n    vec2 plb = vec2(0.31, -0.35); vec2 pmb = vec2(0.55, -0.35); vec2 prb = vec2(0.84, -0.25);\n    \n    float d1 = sdBezier(prt, pmt, plt, p);\n    float d2 = sdBezier(plt, plm, plb, p);\n    float d3 = sdBezier(plb, pmb, prb, p);\n    float d4 = sdBezier(prb, prm, prt, p);\n    \n    float d14 = exact_intersection(d1, d4);\n    float d23 = exact_intersection(d2, d3);\n    float dd = exact_intersection(d23, d14);\n    return vec4(dd, d1, d23, d2);\n}\n\n\nfloat sdPupil(vec2 p, float r, vec2 offset)\n{\n    return sdEllipse(vec2(0.2, 0.3) * r, p - offset);\n}\n\nfloat pow2(float x) { return x * x; }\n\nvec4 sdHair(vec2 p)\n{\n    float def1 = p.y + 1.5;\n    float def2 = p.y + 0.3;\n    \n    p.x += pow2(3.8 * max(0.1 - def1 * def1 * 0.15, 0.)) * sign(p.x) * smoothstep(0.40, 0.43, abs(p.x));\n    p.x -= pow2(2.5 * max(0.1 - def1 * def1 * 0.15, 0.)) * float(p.x < 0.);\n    p.x += pow2(1.5 * max(0.1 - def2 * def2 * 0.35, 0.)) * float(p.x < -0.46);\n    \n\tfloat d = sdUnevenCapsuleY( p, 0.73, 0.51, 2.1 );\n    \n    float dcut = 0.16 -p.y - p.x * 0.05;\n    float dsub = abs(p.x) - 0.41;\n    dsub = max(dsub, -dcut);\n    float d3 = max(d, -dsub);\n    return vec4(d3, d, dcut, dsub);\n}\n\nconst float f[]   = float[](0.4, 0.23, 0.1, 0.05);\nconst float off[] = float[](-0.4, 0.1, 0.5, 0.5);\nconst float amp[] = float[](8.0, 12.4, 22.4, 32.4);\nconst float bias[] = float[](0.4, 0.2, 0.2, 0.2);\nconst int n = 4;\nvec4 sdHairBands(vec2 p)   \n{\t\n    vec4 dh = sdHair(p);\n    float d = dh.x;\n    float dcut = 0.16 -p.y - p.x * 0.05;\n    \n    p += 0.2 * sin(p.x / 0.4) * (1.0-cos((p.y + 0.15) / 0.4));\n    \n    float db = -(0.2 - abs(dcut));\n    float dmod = -0.2;\n    float b1 = 0.0;\n    \n    for (int i = 0; i< n; ++i)\n    {\n    \tb1 = -amp[i] * (max(mod(p.x + off[i], f[i]), f[i] / 2. ) -5./4.*f[i] + max(mod(-p.x - off[i], f[i]), f[i]/2. ));\n    \tb1 = -pow(max(b1, 0.0), 2.5) + bias[i];\n    \tdmod = max(dmod, -b1);\n    }\n\n    float k = 4.0;\n    dmod = tanh(k * dmod) / k;\n    db += dmod;\n    \n    db += 0.1 * max(1.0 - 5.0 * p.x * p.x, 0.) - 0.1;\n    db *= 0.5;\n    db = max(db, dh.y);\n    \n    d = min(db, max(d, -0.1));\n        \n    return vec4(d, dh.y, dh.z, dh.w);\n}\n \n#define LayerF(d, color) render_layer(fragColor, render(d, color, 1.))\n#define LayerFM(d, color) render_layer_mul(fragColor, render(d, color, 1.))\n#define LayerFMW(d, color, w) render_layer_mul(fragColor, render(d, color, w))\n#define LayerS(d, color, stroke) render_layer(fragColor, render_stroked(d, color, stroke))\n#define LayerSM(d, color, stroke, mask) render_layer(fragColor, render_stroked_masked(d, color, stroke, mask))\n\nstruct Params\n{\n    float size;\n    float pixSize;\n    float yaw;\n    float lj;\n    float wj;\n    float wc;\n    float th;\n    float trh;\n    float radius;\n    float m;\n    float stroke;\n};\n\nfloat make_head(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float a = sdfTriangleDist(p.wj, p.th, (uv + vec2(0.0, p.lj)));\n    float b = sdTrapezoid(p.wj, p.wc, p.trh, (uv + vec2(0.0, p.lj - p.th - p.trh)));\n    float c = sdfCircle(p.wc * 1.005, uv - vec2(0.0, p.m));\n    c = sdfIntersection(c, -uv.y + p.m);\n\n    float e = sdEgg(p.wc * 1.005, 0.04, (uv - vec2(0.0, p.m))  * vec2(1.0, -1.0)) ;\n    \n    float d = 1e6;\n    d = sdfUnion(a, b);\n    d = sdfUnion(d, c);\n    d = mix(d, e, 0.4 * smoothstep(0.1, p.wj, abs(uv.x)));\n    \n    d -= p.radius;\n    d += disp(uv, 20.0) * 0.001;  \n    \n    LayerS(d, vec3(0.757, 0.772, 0.796), p.stroke);\n    return d;\n}\n\n\nvoid make_hair_back(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv = rotate(uv, -0.09);\n    uv += vec2(0.02, -0.31);\n    uv *= 1.35;\n    float d = sdHair(uv * vec2(1.2, 1.0) + vec2(0.01, 0.12)).y;\n\n    LayerF(d, vec3(0.54, 0.37, 0.46));\n}\n  \nvoid make_hair_shadow(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv = rotate(uv, -0.09);\n    uv += vec2(0.02, -0.31);\n    uv *= 1.35;\n    float ds = sdHairBands(uv * vec2(1.02, 1.0) + vec2(-0.03, 0.05)).x;\n    LayerFMW(ds, vec3(0.752, 0.66, 0.69) * 0.9, 3.0);\n}\n\nvoid make_hair(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv = rotate(uv, -0.09);\n    uv += vec2(0.02, -0.31);\n    uv *= 1.35;\n    float def = max(-uv.x + 0.6 * uv.y - 0.45, 0.) * 2.0;\n    uv.x -= def * def;\n    float d = sdHairBands(uv).x;\n\n    d += disp(uv, 2.0) * 0.005;  \n    d += disp(uv, 20.0) * 0.001;  \n\n    LayerS(d, vec3(0.75, 0.67, 0.76), p.stroke * 1.5);\n    LayerF(d + 0.18, vec3(0.75, 0.84, 0.87));\n}\n\nvoid _make_hair2(inout vec4 fragColor, Params p, vec2 uv, float l)\n{\n    uv *= 1.35;\n    float def1 = uv.y + 1.5;\n    uv.x -= pow(2.5 * max(0.1 - def1 * def1 * 0.15, 0.), 2.0) * (1.0 - 0.6 * l);\n    uv /= 1.35;\n    float d = abs(0.33 - 0.02 * l + uv.x) - 0.03 * (1.0 + 0.5 * (1. - l ) + uv.y * (0.4 + 0.3 * (1.-l)));\n    \n    d = max(d, uv.y);\n    \n    float m = -(uv.y - 0.14 + l * 0.07 - uv.x * 0.6);\n    \n    m = mix(m, min(m, (uv.x + 0.33 - 0.02 * l)), uv.y < -0.75);\n\n    d += disp(uv, 2.0) * 0.005;  \n    d += disp(uv, 20.0) * 0.001;  \n\n    LayerSM(d, vec3(0.75, 0.67, 0.76), p.stroke * 0.5, m);\n}\n\nvoid make_hair2(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float l = float(uv.x > 0.);\n    uv += vec2(0.045, -0.31);\n    uv = rotate(uv, -0.12 + 0.025 * l);\n    uv.x = -abs(uv.x);\n    // uv = mix(uv, uv * vec2(1.03, 0.99) - vec2(0.03, -0.005), l);\n    _make_hair2(fragColor, p, uv, l);\n}\n\nvoid make_band_and_horns(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv = rotate(uv, 0.06);\n    uv += vec2(0.05, -0.30);\n\tfloat d = sdUnevenCapsuleY(uv, 0.73, 0.32, 2.1 );\n    uv += vec2(-0.0, 0.09);\n\tfloat d2 = sdUnevenCapsuleY(uv, 1.0, 0.335, 2.1 );\n    d = max(d, -d2);\n    \n    float r = float(uv.x > 0.);\n    float ir = 1.0 - r;\n    uv.x = -abs(uv.x);\n\n    float a = sdfTriangleDist(0.05, 0.08 - 0.03 * r, rotate( uv + vec2(0.24, -0.16 - 0.038 * r), -0.4));\n    a = max(a, -uv.x + uv.y - 0.5);\n    d = min(d, a);\n\n    LayerS(d, vec3(0.72, 0.79, 0.88), p.stroke);\n    \n    vec2 p0 = vec2(-0.010, 0.07 - 0.02 * ir);\n\tfloat c = max(uv.y - 0.36, 0.) * (r * 0.5 + 0.5);\n    uv -= vec2(c * c * 1.25, 0.0);\n    float dh = sdTriangle(p0, p0 + vec2(-0.05 - 0.01 * ir, 0.3), p0 + vec2(0.03 * r, 0.13), uv + vec2(0.24, -0.16));\n    // dh = max(dh, -uv.x + uv.y - 0.5);\n    dh -= 0.005;\n\n    float dhs = max(dh, uv.x + uv.y * 0.5 + 0.07);\n    float dhh = max(dh, uv.x + uv.y * 0.18 + 0.195 + 0.012 * ir) + 0.004;\n    \n    LayerS(dh, vec3(0.52, 0.24, 0.34), p.stroke);\n    LayerF(dhs, vec3(0.28, 0.17, 0.27));\n    LayerF(dhh, vec3(0.69, 0.62, 0.72));\n}\n\nvoid make_neck(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv += vec2(0.0, p.lj);\n    uv += vec2(0.007, 0.1);\n    uv *= 2.6;\n\n    vec2 plt = vec2(-0.5,  0.34); vec2 prt = vec2(0.5,  0.34);\n    vec2 plm = vec2(-0.4, -0.0);  vec2 prm = vec2(0.4, -0.1);\n    vec2 plb = vec2(-0.45, -0.35); vec2 prb = vec2(0.52, -0.2);\n    \n    float d2 = sdBezier(plt, plm, plb, uv);\n    float d4 = sdBezier(prb, prm, prt, uv);\n    \n    float d24 = exact_intersection(d2, d4);\n    float d_caps = max(uv.y - 0.35, -0.34 - uv.y);\n    float dd = max(d24, d_caps);\n    \n    LayerS(dd, vec3(0.54, 0.46, 0.46), p.stroke * 2.6);\n}\n\nvoid make_mouth(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float mm = sdEllipse(vec2(p.wj * 0.55, p.th * 0.13), opCheapBend(uv + p.yaw * vec2(0.005, 0.), 2.0) + vec2(0.0, p.lj - p.th - 0.01));\n    float mme = sdfCircle(0.02, uv + p.yaw * vec2(0.005, 0.) + vec2(-0.03, p.lj - p.th + 0.01));\n    mm += disp(uv, 20.0) * 0.002; \n    LayerSM(mm, vec3(0.70, 0.58, 0.6),  p.stroke * (1. + 2. * smoothstep(p.wj * 0.1, p.wj * 0.4, uv.x)), mme);\n}\n\nvoid make_nose(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv.x -= 0.005;\n    float nn1 = udBezier(vec2(0.01, p.m - p.th * 1.48), vec2(0.008, p.m - p.th * 1.38), vec2(0.017, p.m - p.th * 1.08), uv);\n    float nn2 = udBezier(vec2(0.007, p.m - p.th * 0.62), vec2(0.007, p.m - p.th * 0.75), vec2(0.017, p.m - p.th * 0.87), uv);\n    float nn3 = udBezier(vec2(0.01, p.m - p.th * 0.2), vec2(0.017, p.m + p.th * 0.1), vec2(0.04, p.m + p.th * 0.3), uv);\n    nn1 = min(nn1, nn2);\n    nn1 = min(nn1, nn3);\n    \n    vec2 p0 = vec2(0.001, p.m - p.th * 0.62);\n\tfloat c = max(uv.y - 0.36, 0.);\n    float def = dot(vec2(p.th * 0.25, 0.01), p0 - uv) - 0.0003;\n    def *= 1200.0;\n    def = max(1.0 - def * def, 0.);\n    uv.y -= def * 0.015;\n    float dh = sdTriangle(p0, p0 + vec2(-0.021, -p.th * 0.4), p0 + vec2(0.01, -p.th * 0.25), uv);\n\n    dh -= 0.008;\n\n    LayerFMW(dh, vec3(0.752, 0.66, 0.69), 1.5);\n    LayerS(nn1, vec3(0.), p.pixSize * 0.6);\n}\n\nvoid make_eye(inout vec4 fragColor, Params p, vec2 uv, float l)\n{\n    uv.x += p.wc * 0.8;\n    uv.y -= p.m;\n    uv += vec2(-0.05, 0.06);\n    uv *= 5.2;\n    vec4 d = sdEye(uv);\n    LayerF(d.x, vec3(0.73, 0.78, 0.83));\n    float w = (1.0 - (uv.x * uv.x / 0.5)) * 1.3;\n    LayerS(abs(d.y - 0.03 * w), vec3(0.08, 0.14, 0.18),  0.04 * w);\n    \n    float dh = max(d.w - 0.13 * (1.45 + 3.2 * uv.y), -d.w);\n    dh = max(dh, uv.y - uv.x * 0.9 - 0.65);\n    dh = max(dh, -uv.y + uv.x * 0.44 + 0.0);\n    LayerF(dh, vec3(0.59, 0.31, 0.44));\n    \n    float m = uv.y + 0.08;\n    LayerF(max(abs(d.z)- 0.015, m), vec3(0.08, 0.14, 0.18));\n    \n    float p1 = sdPupil(uv, 1.0, vec2(-0.05, 0.) * l);\n    float p2 = sdPupil(uv, 0.52, vec2(-0.05, 0.) * l + vec2(0.03, 0.) * (l - 0.5) + vec2(0.0, 0.03));\n    float p3 = sdPupil(uv, 0.15, vec2(-0.05, 0.) * l + vec2(0.05, 0.) * (l - 0.5) + vec2(0.0, 0.03));\n    float s1 = sdPupil(uv, 0.3, vec2(-0.05, 0.) * l + vec2(0.36, 0.) * (l - 0.5));\n    \n    LayerS(max(p1, d.x), vec3(0.26, 0.45, 0.45),  p.stroke * 5.2);\n    LayerS(max(p2, d.x), vec3(0.26, 0.45, 0.45),  p.stroke * 5.2);\n    LayerS(max(p3, d.x), vec3(0.08, 0.14, 0.18),  p.stroke * 5.2);\n    LayerF(max(s1, d.x), vec3(0.75, 0.84, 0.87));\n    {\n    \tvec2 _uv = uv + vec2(0.4, -0.38) + vec2(0.15, 0.02) * l - 0.1 * uv.x * l;\n    \tvec2 plt = vec2(0.1, 0.04); vec2 pmt = vec2(0.5, 0.2); vec2 prt = vec2(0.88, 0.05);\n    \tfloat du = udBezier(prt, pmt, plt, _uv);\n    \tLayerS(du, vec3(0.),  p.stroke * 3.);\n    }\n}\n\nvoid make_eyebrow(inout vec4 fragColor, Params p, vec2 uv, float l)\n{\n    uv.x += p.wc * 0.8;\n    uv.y -= p.m;\n    uv += vec2(-0.05, 0.06);\n    uv *= 5.2;\n\n  \tvec2 _uv = uv + vec2(0.4, -0.60) + vec2(0.15, 0.02) * l - 0.1 * uv.x * l;\n   \tvec2 plt = vec2(-0.01, -0.05); vec2 pmt = vec2(0.5, 0.02); vec2 prt = vec2(0.98, 0.18);\n   \tfloat du = udBezier(prt, pmt, plt, _uv) - 1.0 * min(dot3(_uv - vec2(-0.01, -0.05)) * dot2(_uv - vec2(0.98, 0.18)), 0.1);\n   \tLayerS(du, vec3(0.75, 0.67, 0.76),  p.stroke * 3.);\n}\n\nvoid make_eyes(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float l = float(uv.x > 0.);\n    uv.x = -abs(uv.x);\n    uv = mix(uv, uv * vec2(1.03, 0.99) - vec2(0.03, -0.005), l);\n    make_eye(fragColor, p, uv, l);\n}\n\nvoid make_eyebrows(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float l = float(uv.x > 0.);\n    uv.x = -abs(uv.x);\n    uv = mix(uv, uv * vec2(1.03, 0.99) - vec2(0.03, -0.005), l);\n    make_eyebrow(fragColor, p, uv, l);\n}\n\nvoid make_ear(inout vec4 fragColor, Params p, vec2 uv, float l, float headd)\n{\n    uv += vec2(0.38, 0.065) + vec2(-0.075, 0.02) *l;\n    uv = rotate(uv, -0.4);\n    float def1 = uv.x - uv.y + 0.0;\n    float def2 = uv.x + uv.y * 0.7 - 0.05;\n    float def3 = uv.x - uv.y + 0.0;\n    uv.x -= max(0.02 - def1 * def1, 0.);\n    uv.x -= pow(max(0.1 - def2 * def2 * 20.0, 0.), 2.);\n    float d = sdEllipse(vec2(0.05, 0.11), uv);\n    d = max(d, -headd + p.stroke);\n    LayerS(d, vec3(0.757, 0.772, 0.796), p.stroke);\n    vec2 uv2 = rotate(uv, -0.2);\n    uv2 += vec2(0.005, 0.026);\n    float d2 = sdEllipse(vec2(0.024, 0.045), uv2);\n    d2 = max(d2, -headd + p.stroke);\n    LayerS(d2, vec3(0.49, 0.46, 0.51), p.stroke);\n    {\n    \tvec2 _uv = uv;\n    \tvec2 plt = vec2(-0.015, 0.085); vec2 pmt = vec2(-0.0, 0.085); vec2 prt = vec2(0.005, 0.035);\n    \tfloat du = udBezier(prt, pmt, plt, _uv);\n    \tLayerS(du, vec3(0.),  p.stroke * 0.5);\n    }\n}\n\nvoid make_ears(inout vec4 fragColor, Params p, vec2 uv, float headd)\n{\n    float l = float(uv.x > 0.);\n    uv.x = -abs(uv.x);\n    make_ear(fragColor, p, uv, l, headd);\n}\n\nvoid make_body_shadow(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv += vec2(-0.045, 0.46);\n    uv = rotate(uv, -0.05);\n    uv += vec2(-0.01, 0.1);\n    float def = uv.y + uv.x * 0.2 - 0.06;\n    uv.y += pow(max(def, 0.), 2.) * 12.0;\n\tfloat d2 = sdUnevenCapsuleY(uv, 0.5, 0.26, 0.9 ) - 0.04;\n    LayerS(d2 + 0.01, vec3(0.31, 0.15, 0.16), p.stroke);\n}\n\nvoid make_body(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv += vec2(-0.045, 0.46);\n    uv = rotate(uv, -0.05);\n    float d = sdTrapezoid(0.14, 0.36, 0.11, uv) - 0.04;\n    \n    uv += vec2(-0.01, 0.1);\n    \n\tfloat dw = sdTrapezoid(0.18, 0.30, 0.11, uv) - 0.04;\n    float _dw = dw;\n    vec2 _uv = uv;\n    \n    float def = uv.y + uv.x * 0.2 - 0.06;\n    uv.y += pow(max(def, 0.), 2.) * 12.0;\n    uv.y += 0.25 - pow(abs(uv.x) * 1.2, 1.4);\n\tfloat d2 = sdUnevenCapsuleY(uv, 0.5, 0.26, 0.9 ) - 0.04;\n    \n    uv = _uv;\n    def = uv.y + (uv.x - 0.1) * 0.2 - 0.06;\n    uv.y += (min(max(uv.y + 0.7, 0.), 0.8) + 0.2) * (0.26 - min(pow(abs(uv.x + uv.y * 0.2 - 0.03) * 1.2, 1.4), 0.26)) * 1.2;\n    \n\tfloat d22 = sdUnevenCapsuleY(uv, 0.5, 0.26, 0.9 ) - 0.04;\n    float dd = max(d, d2);\n    dw = max(dw, d2);\n    dw = max(dw, -d);\n    float _dw_ = dw;\n    dw = max(dw, -min(abs(_uv.x + _uv.y * 0.1 + 0.03) -0.02, 0.1));\n    \n    uv = rotate(_uv, 0.03);\n    float def2 = pow(max(-uv.y + uv.x * 0.075 + 0.06, 0.), 3.1);\n    float k = 1.5;\n    def2 = (1. / (1. + exp(k * def2* 470.0)) - 0.5) / k;\n    uv.x += sign(uv.x) * def2;//min(pow(max(def2, 0.), 2.) * 10.0, 0.23);\n    uv.x += def2 *0.25;\n\tfloat d3 = sdUnevenCapsuleY(uv, 0.5, 0.26, 0.9 ) - 0.04;\n    d3 = min(d3, d2);\n    d3 = max(d3, -d);\n    d3 = max(d3, uv.y - 0.05);\n    \n    float d33 = max(d3, abs(_uv.x - 0.04) - _uv.y * (0.3 + 4.*max(uv.x, 0.))  - 0.55);\n    \n    LayerSM(d2, vec3(0.31, 0.15, 0.16), p.stroke * 2.0, -abs(_uv.x + 0.03) + 0.22);\n    LayerF(d22, vec3(0.48, 0.2, 0.21));\n    LayerS(d3, vec3(0.70, 0.77, 0.87) * 0.9, p.stroke);\n    LayerS(d33, vec3(0.70, 0.77, 0.87) * 0.7, p.stroke);\n    LayerS(_dw_ + 0.005, vec3(0.70, 0.77, 0.87), p.stroke);\n    LayerS(dw, vec3(0.70, 0.77, 0.87), p.stroke);\n}\n\nvoid make_background(inout vec4 c, vec2 uv)\n{\n    float R = 0.6;\n\tvec2 grid;\n    float uv_ys = uv.x / (1.5*R);\n    grid.y = fract(uv_ys);\n    float odd = mod(floor(uv_ys), 2.0);\n    grid.x = fract(uv.y / (SQRT3 * R) - odd*.5) - 0.5;\n    float d =  abs(grid.x);\n    d = mix(1e3, d, grid.y > 1./3.);\n    grid.x = abs(grid.x); \n    float dd1 = abs(dot(grid - vec2(0, 1./3.), normalize(vec2(1./ 3., 0.5))));\n    grid.y = 1.0 - grid.y + 1. + 1./3.; \n    float dd2 = abs(dot(grid - vec2(0, 4./3.), normalize(vec2(1./ 3., 0.5))));\n    d = min(dd1, d);\n    d = min(dd2, d);\n        \n    float anti = fwidth(d) * 1.0;\n    float sig = 0.00005;\n    float hex = 1. - exp(-d*d * 0.5 / sig) * 0.3;//smoothstep(-anti, anti, d - stroke);\n    vec3 bcol = vec3(0.3,0.4, 0.57) * (0.8 + 0.2*uv.y) *(1.1-0.1*length(uv));\n    \n    c = vec4(bcol * (hex * 0.5 + 0.5), 1.0); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y * 2.0;\n    uv /= 1.4;\n    uv += vec2(0.3, 0.0);\n    \n    Params p;\n\tp.size = min(iResolution.x, iResolution.y);\n    p.pixSize = 1.0 / p.size;\n    p.yaw = 1.;\n    p.lj = 0.3;\n    p.wj = 0.21;\n    p.wc = 0.29;\n    p.th = 0.12;\n    p.trh = 0.15;\n    p.radius = 0.08;\n    p.stroke = p.pixSize * 1.5 + disp(uv, 40.0) * 0.001;\n    p.m = -p.lj + p.th + p.trh * 2. + p.radius / 2.0;\n    \n    make_background(fragColor, uv - vec2(0., 0.5));\n    \n    uv = rotate(uv, 0.13);\n    vec2 uv_nw = uv;\n    uv_nw.x -= 0.09 * p.yaw;\n    uv.x -= 0.1 * p.yaw * (cos(uv.x / 0.35)) * (cos(max(uv.y - p.m, 0.0) / 0.35));\n    \n    make_hair_back(fragColor, p, uv_nw);\n    make_body_shadow(fragColor, p, uv);\n    make_neck(fragColor, p, uv);\n    make_body(fragColor, p, uv);\n    float headd = make_head(fragColor, p, uv);\n    float d = disp(uv, 30.0) * 0.0015 * float(int(iTime * 12.0) % 2 == 0);\n    make_mouth(fragColor, p, uv + d);\n    make_nose(fragColor, p, uv_nw);\n    make_eyebrows(fragColor, p, uv_nw + d);\n    make_hair_shadow(fragColor, p, uv_nw);\n    float olds = p.stroke;\n    p.stroke = p.pixSize * 1.5 + d;\n    make_eyes(fragColor, p, uv_nw + d);\n    p.stroke = olds;\n    make_hair(fragColor, p, uv_nw);\n    make_ears(fragColor, p, uv_nw, headd);\n    make_hair2(fragColor, p, uv_nw);\n    make_band_and_horns(fragColor, p, uv_nw);\n    float n = noise(uv_nw * 200.0);\n    fragColor += n * 0.04;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SQRT3 1.732050807\n\n// 2D SDF functions from iq: https://iquilezles.org/articles/distfunctions2d\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot3(in vec2 v ) { return dot(v,v) * length(v); }\nfloat dot4(in vec2 v ) { return dot(v,v) * dot(v,v); }\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdfCircle(float r, vec2 p )\n{\n    return length(p) - r;\n}\n\nfloat sdEgg(in float ra, in float rb, in vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(p) - r :\n            (k*(p.x+r)<p.y) ? length(p - vec2(0,k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nfloat sdParabola(in float k, in vec2 pos)\n{\n    pos.x = abs(pos.x);\n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\n\n// unsigned distance to a quadratic bezier\nfloat udBezier(in vec2 A, in vec2 B, in vec2 C, in vec2 pos)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 A, in vec2 B, in vec2 C, in vec2 pos)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cross2(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\n\nfloat sdEllipse(in vec2 ab,  in vec2 p)\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n// uneven capsule\nfloat sdUnevenCapsuleY( in vec2 p, in float ra, in float rb, in float h )\n{\n    p.y += h;\n\tp.x = abs(p.x);\n    \n    float b = (ra-rb)/h;\n    vec2  c = vec2(sqrt(1.0-b*b),b);\n    float k = cross2(c,p);\n    float m = dot(c,p);\n    float n = dot(p,p);\n    \n         if( k < 0.0   ) return sqrt(n)               - ra;\n    else if( k > c.x*h ) return sqrt(n+h*h-2.0*h*p.y) - rb;\n                         return m                     - ra;\n}\n\nvec2 opCheapBend(in vec2 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,s,-s,c);\n    return m*p;\n}\n\nfloat disp(vec2 p, float f)\n{\n    float d = 0.0;\n    for (int i = 0; i <4; ++i)\n    {\n \t\td += sin(f*p.x)*sin(f*p.y);\n        p *= 1.9;\n        d *= 2.0;\n    }\n    return d / 16.0;\n}\n\nfloat sdfLine(vec2 p0, vec2 p1, float width, vec2 coord)\n{\n    vec2 dir0 = p1 - p0;\n\tvec2 dir1 = coord - p0;\n\tfloat h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n\treturn (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat sdfTriangleDist(float width, float height, vec2 p)\n{\n    vec2 q = vec2(width, height);\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTriangle(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p)\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTrapezoid(in float r1, float r2, float he, in vec2 p)\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat sdfUnion( const float a, const float b )\n{\n    return min(a, b);\n}\n\nfloat smoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat sdfDifference( const float a, const float b)\n{\n    return max(a, -b);\n}\n\nfloat sdfIntersection( const float a, const float b )\n{\n    return max(a, b);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nvec2 rotate(vec2 uv, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 m = mat2(c,s,-s,c);\n    return m * uv;\n}\n\nvec3 shadeDistance(float d) {\n    d *= .5;\n    float dist = d*120.;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}