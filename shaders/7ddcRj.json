{
    "Shader": {
        "info": {
            "date": "1654273908",
            "description": "Just playing around with some flat 2D interface design (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "7ddcRj",
            "likes": 21,
            "name": "Game and Watch ",
            "published": 3,
            "tags": [
                "2d",
                "interface",
                "desgin"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    interface\n    06/03/22 | byt3_m3chanic\n    \n    Just playing around with some flat 2D interface design (mouseable)\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\n// power color\nconst vec3 tcolor = vec3(0.518,0.933,0.365);\n\nmat2 rot(float g){return mat2(cos(g), sin(g),-sin(g), cos(g));}\nfloat hash21( vec2 p ){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\nconst float scale = 40.;\nconst float hlfsc = (.435/scale)*scale;\n\nconst float N = 10.;\nconst float SN = 8.;\nconst int oct = 5;\n\n// @Shane - a very tightly compacted, self-contained version \n// of IQ's 3D value noise function.\n//---------------------------------------------------------------\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n//---------------------------------------------------------------\n// @iq fbm generator\nfloat fbm3( in vec3 x) {\n    x*=.64;\n    x.x = mod(x.x,SN*N);\n    x.y = mod(x.y,SN*N);//@mla : shifting the y value from the range [-PI,+PI] to [0,2N]\n    x*=.085;\n    float a = 0.1,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for (int i = 0; i < oct; ++i) {      \n        float n = n3D(f*x);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}\n\nfloat box(vec2 p, vec2 b) {vec2 d=abs(p)-b;return length(max(d,0.))+min(max(d.x,d.y),0.);}\nfloat rbox(vec2 p, vec2 b, vec4 r ) {\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n//iq color functions\nvec3 hue(float t){ \n    t*=3.125;\n    vec3 d = vec3(0.357,0.937,0.043);\n    return .65+.4*cos( PI2*t * (vec3(0.945,0.937,0.875)*d) ); \n}\n\nfloat px = 0.;\n\nvec2 mainSize = vec2(.725,.45);\nvec2 insetSize =vec2(.7125,.4375);\nvec2 screenSize =vec2(.475,.275);\n\nvoid nanoBody(inout vec3 C, vec2 p) {\n    vec2 uv=p-vec2(0);\n    \n    //body\n    float d = box(uv,mainSize)-.015;\n    float sad = d;\n    d=smoothstep(px,-px,d);\n\n    //inset\n    float i = box(uv,insetSize)-.015;\n    i=smoothstep(px,-px,i);\n    \n    //shadow\n    float sd = box(uv+vec2(0,.01),insetSize);\n    sd=smoothstep(.045-px,-px,abs(sd)-.01);\n    \n    //screen\n    float d2 = box(uv-vec2(0.,.115),screenSize)-.015;\n    float d3 = abs(d2)-.0015;\n    float d4 = abs(d2)-.008;\n    d2=smoothstep(px,-px,d2);\n    d3=smoothstep(px,-px,d3);\n    d4=smoothstep(.015-px,-px,d4);\n    float hs = hash21(uv*sin(uv.x));\n    //red buttons\n    px=4./R.x;\n    vec2 dv = uv;\n    dv.x=abs(dv.x)-.61;\n    float btn = length(dv-vec2(.0,-.15))-.065;\n    btn=min(btn,rbox(dv+vec2(.185,.25),vec2(.065,.030),vec4(.030)) );\n    btn=min(btn,rbox(dv+vec2(.46,.25),vec2(.065,.030),vec4(.030)) );\n    btn=smoothstep(px,-px,btn);\n    \n    vec2 tv = uv*10.;\n    float nd = box(vec2(abs(tv.x)-6.1,tv.y-1.7),vec2(.65,1.4));\n    //speaker dots\n    tv=mod(tv+.1,.2)-.1;\n    float dts = length(tv)-.05;\n    dts=max(dts,nd);\n    dts=smoothstep(px,-px,dts);\n\n    C= mix(C,vec3(.0),sd);\n    C= mix(C,vec3(.015)-(hs*.01),d);\n\n    C= mix(C,vec3(.335)-(hs*.01),min(clamp(min(uv.y+.4,i),0.,1.),1.-btn) );\n    C= mix(C,vec3(0.208,0.373,0.220)-(hs*.05),d2);\n    C= mix(C,C*.5,min(d4,d2));\n    C= mix(C,vec3(.6),d3);\n    C= mix(C,vec3(.015),dts);\n    \n    float mcheck = 0.;\n    px=2./R.x;\n    float ftn = length(dv-vec2(.0,-.15))-.055;\n    float rtn=rbox(dv+vec2(.185,.25),vec2(.055,.020),vec4(.020));\n    rtn=min(rtn,rbox(dv+vec2(.46,.25),vec2(.055,.020),vec4(.020)) );\n    ftn=smoothstep(px,-px,ftn);\n    rtn=smoothstep(px,-px,rtn);\n    C= mix(C,vec3(.9,.01,.01),ftn);\n    C= mix(C,vec3(0.149,0.149,0.149),rtn);\n    //button highlight\n    float etn = length(dv-vec2(.0,-.15))-.05;\n    float een = rbox(dv+vec2(.185,.249),vec2(.050,.015),vec4(.015));\n    een=min(een,rbox(dv+vec2(.46,.25),vec2(.050,.015),vec4(.015)) );\n    etn=smoothstep(px,-px,etn);\n    een=smoothstep(px,-px,een);\n    C= mix(C,vec3(1),min(clamp((uv.y*3.25)+.55,0.,1.),etn));\n    C= mix(C,vec3(1),min(clamp((uv.y*3.55)+.95,0.,1.),een));\n    // power light\n    float l = box(uv+vec2(.685,-.42),vec2(.0125,.002))-.0025;\n    float sl=smoothstep(.02-px,-px,l);\n    l=smoothstep(px,-px,l);\n    C= mix(C,tcolor*.2,sl);\n    C= mix(C,tcolor,l);\n\n}\n\nconst float tx = .5;\nconst vec2[4] myhood = vec2[4](vec2(1,0),vec2(0,-1),vec2(-1,0),vec2(0,1));\nconst vec2[4] mypos  = vec2[4](vec2(tx,0),vec2(0,-tx),vec2(-tx,0),vec2(0,tx));\n\nfloat side(float hs) {\n    float s=(hs>.75)?0.:(hs>.5)?2.:(hs>.25)?1.:3.;\n    return s;\n}\n\nvec3 checkColor(float sd, float fc, vec4 hash) {\n    float ch = side(hash[int(fc)]);\n\n    if(sd==0.&&ch==1.||sd==1.&&ch==0.) ch=8.;\n    if(sd==0.&&ch==3.||sd==3.&&ch==0.) ch=7.;\n    if(sd==0.&&ch==2.||sd==2.&&ch==0.) ch=6.;\n    \n    if(sd==1.&&ch==3.||sd==3.&&ch==1.) ch=14.;\n    if(sd==1.&&ch==2.||sd==2.&&ch==1.) ch=9.;   \n  \n    if(sd==2.&&ch==3.||sd==3.&&ch==2.) ch=5.;\n    \n    if(sd==ch) ch=sd;\n    \n    return vec3(1./ch);\n}\n\nvec4 gethood(vec2 id, inout float hs) {\n    vec4 nh = vec4(0);\n    hs = fbm3(vec3(id,T*2.5));\n    for(int i=0;i<4;i++){\n        nh[i]=fbm3(vec3(id-myhood[i],T*2.5));\n    }\n    return nh;\n}\n\nvoid getScreen(inout vec3 C, vec2 p3) {\n    vec2 uv=p3;\n\n    //screen\n    float srrn = box(uv-vec2(0.,.115),screenSize*.99)-.015;\n    srrn=smoothstep(px,-px,srrn);\n    \n    float px =scale/R.x;\n    vec3 clr = vec3(1.);\n    uv+=vec2(.0,.1)*T;\n    uv-=vec2((M.x/R.x*PI)*1.-.5,(M.y/R.y*PI)*1.-.5);\n  \n    vec2 id= floor(uv*scale);\n    vec2 p = fract(uv*scale)-.5;\n    \n    float hs = 0.;\n    vec4  gs = gethood(id, hs);\n\n    float d1 = box(p,vec2(hlfsc*.89))-.075;\n    if(hs>.25){\n        float d2 = length(p)-(hs*.3);\n        d2=abs(d2)-.02;\n        d2=smoothstep(px,-px,d2);\n    }\n    \n    float sd = side(hs);\n    d1=smoothstep(px,-px,d1);\n    C=mix(C,C*hue(sd),min(d1,srrn));\n    \n    float sz = .85;\n\n    for(int i=0;i<4;i++){\n\n        vec2 tuv = p+vec2(mypos[i]);\n        vec2 bs = i==1||i==3 ? vec2(hlfsc*sz,hlfsc*.25) : vec2(hlfsc*.25,hlfsc*sz);\n        d1=box(tuv,bs);\n\n        float s1 = box(tuv-vec2(-.05,.05),bs);\n        s1=smoothstep(.15-px,-px,s1);\n        \n        float od1 = abs(d1)-.015;\n        d1=smoothstep(px,-px,d1);\n        clr = checkColor(sd,float(i),gs);\n        \n        // only if edges are different draw overlap\n        if(side(gs[i])!=sd){\n            C=mix(C,C*.5,min(s1,srrn));\n            C=mix(C,clr,min(d1,srrn));\n            od1=smoothstep(px,-px,od1);\n            C=mix(C,vec3(.01),min(od1,srrn));\n        }\n    }\n}\n\nvoid rainbow( inout vec3 C, vec2 uv) {\n    float hs = hash21(uv*sin(uv.x));\n    float s1 = length(abs(uv.y+.04))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.576,0.024,0.161)-(hs*.025),s1);\n\n    s1 = length(abs(uv.y))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.576,0.216,0.024)-(hs*.035),s1);\n    \n    s1 = length(abs(uv.y-.04))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.678,0.624,0.020)-(hs*.035),s1);\n    \n    s1 = length(abs(uv.y-.08))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.184,0.553,0.027)-(hs*.025),s1);\n\n    s1 = length(abs(uv.y-.12))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.027,0.220,0.533)-(hs*.035),s1);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    float hs = hash21(uv*sin(uv.x));\n    vec3 C = vec3(clamp((uv.y+1.)*.1,.01,1.))-(hs*.015);\n\n    px=2./R.x;\n\n    rainbow(C, uv);\n    nanoBody(C, uv);\n    getScreen(C,uv);\n\n    if(hs<.65) C = clamp(C-(hs*.005),C,vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}