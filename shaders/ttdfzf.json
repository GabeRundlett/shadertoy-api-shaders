{
    "Shader": {
        "info": {
            "date": "1613397589",
            "description": "Using a basic hexagon fractal structure to stack 2D isometric cubes in a way that resembles a Sierpinski triangle.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttdfzf",
            "likes": 34,
            "name": "Isometric Fractal Cubes",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "cube",
                "isometric",
                "polar",
                "sierpinski"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 658
        },
        "renderpass": [
            {
                "code": "/*\n\n    Isometric Fractal Cubes\n    -----------------------    \n    \n    Applying simple fractal priciples to render isometric cubes in a \n    Sierpinski fashion. The result is something resembling stacked cubes.\n    As you can see, this is a 2D process. However, in many ways, it\n    would be easier to perform in 3D, but where's the fun in that? :)\n    \n    I started this a while back then forgot about it. I was motivated to \n    finish it after viewing Kali's cool polygon fractal example. Fizzer \n    also has an excellent hexagonal fractal demonstration that involves \n    similar principles. I've provided both links below for anyone \n    interested in this kind of thing.\n    \n    The idea behind polygon fractals is pretty simple: Render a polygon,\n    subdivide space into polar cells and render more objects in each of\n    those cells, subdivide the resultant cells and render more objects \n    around the newly rendered objects... Continue ad infinitum, as they say. \n    Anyway, I've put together a much cleaner, simpler version for anyone\n    who would like to understand this particular example better. The link\n    is below.\n    \n    \n    \n    Other 2D polygon-based fractal examples:\n    \n    \n    // Very watchable, and with virtually no code. \n    Pen Patterns - Kali\n    https://www.shadertoy.com/view/tsdfWf\n    \n    // A very cool hexagon fractal pattern.\n    Linked Rings Fractal Tiling - Fizzer\n    https://www.shadertoy.com/view/3l3fRn\n    \n    // An unlisted accompanying shader featuring the basic fractal cube \n    // structure only, which should make things easier to comprehend.\n    Sierpinski Fractal Cubes - Shane\n    https://www.shadertoy.com/view/tldfzX\n\n*/\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    const float gSc = 1.;//2./3.;\n    \n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Scaling, translation, etc.\n    vec2 p = uv*gSc + vec2(1, 0)*iTime/4.;//HSCALE*iTime/4.;\n    \n    vec2 oP = p;\n   \n    p.y += 1./8./gSc; \n    \n  \n    #ifdef REPEAT_GRID\n    vec4 p4 = getGrid(p); \n    vec2 id = (p4.zw + .5)*HSCALE;//\n    p = p4.xy;\n    #else\n    vec2 id = floor(vec2(p.x*.8660254, 0));\n    p.x -= (id.x + .5)/.8660254;\n    //float ndg = .25*pow(.5, 5.);\n    //p.x = mod(p.x, sqrt(3.)/2. + ndg) - (sqrt(3.)/2. + ndg)*.5;\n    #endif\n \n     // Distance field holders for the cubes, lines and the previous\n    // cube (used for CSG related to overlap).\n    float d = 1e5, ln = 1e5, prevD = 1e5; \n    \n    // Edge width. \n    const float ew = .0015;\n    \n    // Render a simple gradient background... There'd be a neater way to do\n    // this, but I was in a hurry. :)\n    float shd = .5 - uv.y*.5;\n    vec3 bg = mix(vec3(.25, .5, 1).xzy, vec3(.25, .5, 1), 1./(1. + shd*shd));\n    bg = mix(bg, bg.zyx, .5*shd*shd);\n    vec3 col = bg;\n    \n    // Box center.\n    vec2 cntr = vec2(0);\n    \n    // Cube scale and height. These will be scaled further on each fractal level.\n    float sc = .25;\n    float sch = sc/.8660254;\n    \n    // Shadow normal and shadow scale.\n    vec2 n = normalize(vec2(1, -2));\n    float shF = iResolution.y/450.; // Shadow resize factor.\n    float scSh = .025*shF;\n    \n    \n    // Number of fractal levels.\n    #ifdef REPEAT_GRID\n    int nn = 4;\n    #else\n    int nn = 3 + int(abs(mod(id.x, 4.) - 2.));\n    #endif\n    \n    // Render the fractal levels.\n    for(int i = 0; i<nn; i++){\n    \n        \n        // Break at random levels to give the appearance of random stacks.\n        #ifndef REPEAT_GRID \n        if(mod(id.x, 3.)<1.5 && hash21(id + cntr + .1)<float(i)/float(nn)*.5) break;\n        #endif\n        \n       \n        // Random number for this particular stack and box position.\n        float rnd = hash21(id + cntr);\n        //\n        #ifdef REPEAT_GRID \n        rnd = (float((i + 2)%nn))*.3;\n        #endif\n      \n        // Fake AO and drop shadow.\n        float dsh = hDist(p, sc);\n        col = mix(col, vec3(0)*.1, (1. - smoothstep(0., sf*10.*shF, dsh))*.2);\n        dsh = hDist(p - n*scSh, sc);\n        col = mix(col, vec3(1.1, 1, .9)*.1, (1. - smoothstep(0., sf*10.*shF, dsh))*.3);\n        scSh *= .7;\n        \n        // Obtain the individual cube face quad distances. There are three\n        // visible to the viewer.\n        vec3 d3 = cubeQuads(p, sc*2.);\n        \n        \n        // Iterate through the cube faces for this level.\n        for(int j = 0; j<3; j++){\n            \n            // Face ID... A mixture of common sense and trial and error, as always. :D\n            int fid = 2 - (i - j + 4)%3;\n            \n            // Normal based shade.\n            float sh = .5 + (float(fid)/2.)*.5;\n            // Distance based shade.\n            float shd = max(1. + d3[j]/sc/2., 0.);\n            \n            // Produce a shaded color for the face.\n            vec3 fCol = .65 + .35*cos(6.2831*rnd/2.5 + vec3(0, 1, 2) - 1.);\n            fCol *= sh*sh*1.5;\n            if(i<nn - 1) fCol *= vec3(1)*shd;\n            \n            // Render the shaded face color and a mild inner edge.\n            col = mix(col, min(fCol, 1.), (1. - smoothstep(0., sf, d3[j])));\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs( d3[j] + ew*5.5) - ew/2.))*.5);\n       \n            \n        \n        }\n        \n        \n        // Apply edges over the top of the quads.\n        float cube = min(min(d3[0], d3[1]), d3[2]);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cube) - ew/2.))*.95);\n       \n        // Cube centers, for debugging purposes.\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, length(p) - .015));\n        \n        // Here's the fun polar fractal stuff.. And by that I mean, it wasn't fun. It never is. :D\n        // Having said that, it's based on a simple fractal setup, which involves making \n        // copies of objects, then rendering them in coordinated places at different scales,\n        // rotations, etc.\n        \n        // Obtain three repeat polar angles around the cube.\n        float aNum = 3.;\n        p = rot2(6.2831/6.)*p;\n        float a = mod(atan(p.x, p.y), 6.2831);\n        float ia = floor(a/6.2831*aNum);\n        ia = (ia + .5)/aNum*6.2831;\n        \n        // Rotate the object by this particular polar angle.\n        p = rot2(ia)*p;\n        // Move it out from the object at the angle above.\n        p -= vec2(0, sch);\n        // Rotate the object in situ.\n        p = rot2(ia*2.)*p;\n\n        \n        // Do the same for the object center. The center doubles\n        // as a unique ID point, which is used for coloring.\n        cntr = rot2(6.2831/6.)*cntr;\n        cntr = rot2(ia)*cntr;\n        cntr += vec2(0, sch);\n        cntr = rot2(ia*2.)*cntr;\n        \n        // Rotate the shadow direction vector to in unison with the\n        // above, so the shadows face the same way on each cube -- Note \n        // that normal translation isn't necessary... Sometimes, 2D is \n        // more annoying than 3D. :) \n        n = rot2(6.2831/6.)*n;\n        n = rot2(ia)*n;\n        n = rot2(ia*2.)*n;\n        \n     \n        // Reduce vertical cube distace and scale for the next iteration.\n        sch *= .5; // Reduce scale height.\n        sc *= .5; // Reduce scale.\n        \n         \n        \n     \n    }\n    \n    // Apply a simple pixelated hatch to give the scene an oldschool look.\n    #ifdef NAIVE_HATCH\n    float hatch = doHatch(oP/gSc, iResolution.y);\n    col *= hatch*.35 + .8;\n    #endif\n\n    // Rough gamma correction and output to screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// UTILITY FUNCTIONS -- These are just worker functions. All the logic is contained\n// within the \"Image\" tab.\n\n// Showing that you can render this on a hexagonal grid... I thought it'd look\n// more interesting that it does, but it's there as an option anyway. :)\n//#define REPEAT_GRID\n\n// Simple pixelated hatch.\n#define NAIVE_HATCH\n\n// Hexagon cell scale.\n#define HSCALE vec2(.5, .8660254)\n\n// Vertices and edge midpoints: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-1, -1./3.), vec2(-1, 1./3.), vec2(0, 2./3.), \n                      vec2(1, 1./3.), vec2(1, -1./3.), vec2(0, -2./3.));\n\n\n/*\n// Hexagon arrangement. Flat top or pointed top.\n//#define FLAT_TOP\n\n// This sets the scale of the extruded shapes.\n#ifdef FLAT_TOP\n#define HSCALE vec2(.8660254, .5)\n#else \n#define HSCALE vec2(.5, .8660254)\n#endif\n\n#ifdef FLAT_TOP\n//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-2./3., 0)/vec2(1, .5), vec2(-2./6., .5)/vec2(1, .5), vec2(2./6., .5)/vec2(1, .5), \n                      vec2(2./3., 0)/vec2(1, .5), vec2(2./6., -.5)/vec2(1, .5), vec2(-2./6., -.5)/vec2(1, .5)); \nvec2[6] eID = vec2[6](vec2(-.5, .25)/vec2(1, .5), vec2(0, .5)/vec2(1, .5), vec2(.5, .25)/vec2(1, .5), \n                      vec2(.5, -.25)/vec2(1, .5), vec2(0, -.5)/vec2(1, .5), vec2(-.5, -.25)/vec2(1, .5));\n#else\n// Vertices and edge midpoints: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-.5, -2./6.)/vec2(.5, 1), vec2(-.5, 2./6.)/vec2(.5, 1), vec2(0, 2./3.)/vec2(.5, 1), \n                      vec2(.5, 2./6.)/vec2(.5, 1), vec2(.5, -2./6.)/vec2(.5, 1), vec2(0, -2./3.)/vec2(.5, 1));\nvec2[6] eID = vec2[6](vec2(-.5, 0)/vec2(.5, 1), vec2(-.25, .5)/vec2(.5, 1), vec2(.25, .5)/vec2(.5, 1), vec2(.5, 0)/vec2(.5, 1), \n                      vec2(.25, -.5)/vec2(.5, 1), vec2(-.25, -.5)/vec2(.5, 1));\n#endif\n*/\n////////\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n\n\n\n\n#ifdef REPEAT_GRID\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec2 s = HSCALE;\n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n#endif\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n    \n}\n\n\n// Hexagon bound -- Accurate enough for this example.\nfloat hDist(vec2 p, float sc){\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x) - sc;\n}\n\n\n// Entirely based on IQ's signed distance to a 2D triangle. I've expanded it \n// to work with convex quads and generalized it a bit, but I doubt it would \n// translate to speed. It would be easy to generalize to convex polyons though.\nfloat quad(in vec2 p, in vec2[4] v){\n\n    // Lines between successive vertex points.\n    vec2[4] e = vec2[4](v[1] - v[0], v[2] - v[1], v[3] - v[2], v[0] - v[3]);\n    \n    // Winding related sign.\n    float s = sign(e[0].x*e[3].y - e[0].y*e[3].x);\n    \n    vec2 d = vec2(1e5);\n    \n    for(int i = 0; i<4; i++){\n        \n        // Minimum point to line calculations.\n        vec2 vi = p - v[i];\n        vec2 qi = vi - e[i]*clamp(dot(vi, e[i])/dot(e[i], e[i]), 0., 1.);\n        d = min(d, vec2(dot(qi, qi), s*(vi.x*e[i].y - vi.y*e[i].x)));\n    }\n\n    // Quad distance.\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Returns the 3 viewable cube face distances.\nvec3 cubeQuads(vec2 p, float sc){\n\n\n    vec2 hSc = HSCALE*sc;\n    vec3 d;\n    \n    // Iterate through the three cube faces.\n    for(int j = 0; j<3; j++){\n        \n        // Using the hexagon vertices to constructing the 3 viewable cube quad faces.\n        vec2[4] v = vec2[4](vID[(j*2 + 5)%6]*hSc, vID[(j*2)%6]*hSc, vID[(j*2 + 1)%6]*hSc, vec2(0));\n\n        // Face quad.\n        d[j] = quad(p, v);\n            \n    }\n    \n    return d;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}