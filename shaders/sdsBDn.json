{
    "Shader": {
        "info": {
            "date": "1644741192",
            "description": "Infinite plane of speakers using domain repetition.",
            "flags": 64,
            "hasliked": 0,
            "id": "sdsBDn",
            "likes": 3,
            "name": "Sonic test site",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 349
        },
        "renderpass": [
            {
                "code": "const int AA = 2;\nconst vec3 sun = normalize(vec3(3.21,1,-0.4));\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n//iq\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\n//iq\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n\n\nfloat pow2(float a){\n    return a* a;\n}\n\nfloat sdPlane(vec3 p, float h){\n    return p.y - h;\n}\n//iq\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n//iq\nfloat sdTorus( vec3 p, float t, float r)\n{\n  vec2 q = vec2(length(p.xz)- t,p.y);\n  return length(q)- r;\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat posSin(float f){\n    return sin(f)*0.5+1.;\n}\n\nfloat sdSpeaker(vec3 p, float amplitude){\n    p -= vec3(0,-0.3,0);\n    \n    return\n                smin(\n                    min(\n                        sdCutHollowSphere(p - vec3(0, -1. + amplitude*2., 0.), .4,-.15, 0.01),\n                        sdSphere(p - vec3(0, -1.4 + amplitude*2., 0.), 0.1)\n                        ),\n                    sdTorus(p - vec3(0,-0.30,0.), 0.4, 0.03),\n                    0.01\n                    );                 \n}\nvec2 localHex(vec2 p){\n    const float z = sqrt(1.-0.25);\n    const vec2 g = vec2(1.5,z);\n    vec2 tile = mod(p+g,2.*g)-g;        \n    if (abs(tile.y) > z/0.5*(1.-abs(tile.x))){tile = mod(tile,2.*g)-g;}\n    return tile;\n}\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 repeat(vec3 p) {\n    const vec2 c = vec2(1.2);\n    vec2 x = localHex(p.xz*1.5)/1.5;\n    return vec3(x.x, p.y, x.y);\n}\n\nfloat sdScene(vec3 p, float amplitude) {\n        vec3 q = p;\n        p = repeat(p);\n            \n        vec2 id = p.xz-q.xz;\n        \n        float off = hash12(round(id)*10.);\n        amplitude = smoothstep(0.,1.,texture(iChannel0, vec2(0.02+off*0.5, 0)).x)*0.15+0.35;\n\n        return smin(\n                    sdSpeaker(p, amplitude),\n                    opSubtraction(\n                                   sdSphere(p - vec3(0, -0.5, 0.), 0.47),\n                                   sdPlane(p, -.6)\n                                  ),\n                    0.001\n                    );\n}\n\n//iq\nvec3 softshadow( in vec3 ro, in vec3 rd, float amplitude, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sdScene(ro + rd*t, amplitude);\n        if( h<0.001 )\n            return vec3(0.0);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return mix(vec3(res),vec3(1.000,0.702,0.602)*res,smoothstep(1.,-.5,abs(0.5-res)));\n}\n\n//iq\nvec3 calcNormal( in vec3 p, float amplitude ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene(p + k.xyy*h, amplitude ) + \n                      k.yyx*sdScene(p + k.yyx*h ,amplitude ) + \n                      k.yxy*sdScene(p + k.yxy*h, amplitude ) + \n                      k.xxx*sdScene(p + k.xxx*h, amplitude ) );\n}\n\nfloat calcAO(vec3 pos, vec3 nor,float a){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=0; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = sdScene(pos+h*nor, a);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 intersection(vec3 ro, vec3 rd){\n    \n    //Boring variables\n    float zslice = -.158;//cos(stime);\n    vec3 pos = ro;\n    vec2 mouseUV = (iMouse.xy-iResolution.xy*.5f)/iResolution.x * 5.;\n    float T = 0.;\n    \n    //Colour \n    float h = sdScene(pos,0.);\n    \n    \n    //The interesting part\n    float omega = 1.;\n    float pom = 1.;\n    float ph = 1e5;\n    vec2 gap = vec2(0.,0.);\n    for (int i = 0; i<40; ++i) {\n    \n        //Position and distance estimation\n        vec3 p = ro+T*rd;\n        h = sdScene(p,0.);\n        \n        \n        //Overstep recovery\n        float om = (ph+h)/ph;\n        if (om<pom && pom > 1.) { //ph+h<ph*pom\n            \n            gap = vec2(h,T);\n            T+=(1.-pom)*ph;\n            pom = 1.;\n            \n        } else {\n            \n            //Variable updates\n        \tT += h * omega;\n            ph = h;\n            pom = omega;\n            \n            //Back to the place where the gap opened (foward)\n        \tif (T>=gap.y-gap.x && gap.y+gap.x > T) {T = gap.y+gap.x*omega; ph = gap.x;};\n        }\n        \n          \n        //Dynamic Omega \n        //omega = clamp((omega+om)*.5,1.,3.);\n        omega = clamp(omega+(om-omega)*.6,1.,3.);\n    }\n    return ro+T*rd;;\n}\nvec3 SC;\nfloat amplitude;\nvec3 render(vec2 uv ){\nvec3 rd = normalize(vec3(uv, .4));\n    rd *= rotx(0.8);\n    vec3 rp = vec3(0.0, 1, iTime);\n\n\n\n    rp = intersection(rp,rd);\n\n    vec3 scl = vec3(.99, .9, .8);\n    vec3 amb = vec3(.9, .95, .99);\n    vec3 nor = calcNormal(rp, amplitude);\n    vec3 sha = softshadow(rp, sun, amplitude, .01, 2.,10.);\n   float occ = calcAO(rp, nor, amplitude);\n    vec3 hvc = normalize(sun-rd);\n    vec2 loc = localHex(rp.xz*1.5)/1.5;\n    vec3 p = vec3(loc.x, rp.y, loc.y)-vec3(0,-.5,0);\n    float l = length(p);\n    vec3 lnr = normalize(-p);\n    vec3 bcl = mix(vec3(uv+vec2(0.5),0.5)*SC.r*1.3,\n                  vec3(.01),\n                  1.-smoothstep(0.44,0.456,length(repeat(rp).xz)));\n    vec3 col = 1.5*bcl * scl * sha * max(0.,dot(nor,sun)); \n         col += pow(max(0.,dot(hvc,nor)),100.)*sha*scl;\n         col += .1*bcl*amb*occ;\n         \n         col += pow(dot(nor, lnr), 8.)*vec3(0.361,0.020,0.020);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Camera setup...\n    //https://www.shadertoy.com/view/4tGfz3\n    SC = texture(iChannel0, vec2(0.02, 0)).xyz;\n    amplitude = smoothstep(0.,1.,SC.x)*0.15+0.35;\n\n\n    vec3 col;\n    float inv = 1./float(AA);\n    for (int x=0;x<AA;x++){\n    for (int y=0;y<AA;y++){\n        vec2 delta = vec2(x,y)*inv-0.5;\n        vec2 uv = (fragCoord.xy + delta) / iResolution.xy;\n        uv -= vec2(0.5);\n        uv.y /= iResolution.x / iResolution.y;\n    \n        col += render(uv)*inv*inv;\n    }}\n        \n    fragColor = sqrt(vec4(clamp(col, vec3(0.,0.,0.), vec3(1.,1.,1.)),1.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 31936,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ian-brinkerhoff/spongebob-trap-remix-the-krusty-krab?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}