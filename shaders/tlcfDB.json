{
    "Shader": {
        "info": {
            "date": "1613362656",
            "description": "3D distance field buffering version two. Its really slow and it hasn't worked for anything other than this. Help? (uncomment lines 30-43 in Cubemap A to see what I mean). If it looks messed up at the beginning, try resetting the time.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlcfDB",
            "likes": 2,
            "name": "3D Distance Field Buffering II",
            "published": 3,
            "tags": [
                "3d",
                "distancefield",
                "sdf",
                "cubemap",
                "buffering",
                "storage"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 156
        },
        "renderpass": [
            {
                "code": "// filt 0: no filter\n// filt 1: trilinear\n// filt 2: tricubic\nfloat fetch(in vec3 p, in vec3 offs) {\n    vec4 ray = cube2ray(space2cube(p, offs, SIZE, RESOLUTION));\n    return texture(iChannel0, ray.xyz)[int(ray.w)];\n}\n\nfloat sampleDistanceField(in vec3 p, in int filt) {\n    vec3 halfSize = 0.5 * SIZE;\n    if (all(lessThan(abs(p), halfSize))) {\n        if (filt == 0) {\n            return fetch(p, vec3(0.0));\n        }\n\n        else {\n            vec3 local = fract(p / SIZE * RESOLUTION);\n            if (filt == 2) local *= local * (3.0 - 2.0 * local);\n\n            float ldb = fetch(p, vec3(0.0));\n            float rdb = fetch(p, vec3(1.0, 0.0, 0.0));\n            float lub = fetch(p, vec3(0.0, 1.0, 0.0));\n            float rub = fetch(p, vec3(1.0, 1.0, 0.0));\n            float ldf = fetch(p, vec3(0.0, 0.0, 1.0));\n            float rdf = fetch(p, vec3(1.0, 0.0, 1.0));\n            float luf = fetch(p, vec3(0.0, 1.0, 1.0));\n            float ruf = fetch(p, vec3(1.0));\n\n            return mix(mix(mix(ldb, rdb, local.x), mix(lub, rub, local.x), local.y),\n                       mix(mix(ldf, rdf, local.x), mix(luf, ruf, local.x), local.y), local.z);\n        }\n    }\n\n    vec3 q = abs(p) - halfSize + 0.01;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat mapScene(in vec3 p) {\n    return sampleDistanceField(p, 1);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0);\n    if (true) { // iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nCubemap face resolution is 1024x1024\nx 6 faces x 4 color channels = 25165824 slots!\ncuberoot(25165824) ~ 293\nso it is possible to store a cubic grid with 293^3 resolution!\n\nCubemap coordinates are stored as: vec4(face id, x, y, color channel)\nThis is just my convention by the way.\n\nFace numbering:\n0: right\n1: left\n2: up\n3: down\n4: front\n5: back\n*/\n\n// RESOLUTION is the sample resolution, SIZE is the space it maps to\n#define RESOLUTION vec3(280.0)\n#define SIZE vec3(5.0)\n\n// Determines which cubemap face a ray with direction rd is pointing at\nfloat getFaceID(in vec3 rd) {\n    vec3 ar = abs(rd);\n    if (ar.x >= ar.y && ar.x >= ar.z) return 0.0 + step(0.0, -rd.x); // X axis aligned face\n    if (ar.y >= ar.x && ar.y >= ar.z) return 2.0 + step(0.0, -rd.y); // Y axis aligned face\n    if (ar.z >= ar.x && ar.z >= ar.y) return 4.0 + step(0.0, -rd.z); // Z axis aligned face\n}\n\n// Calculates a ray direction hitting the cubemap texel at cm\nvec4 cube2ray(in vec4 cm) {\n    float sgn = sign(0.5 - mod(cm.x, 2.0));\n    if (cm.x == 0.0 || cm.x == 1.0) return vec4((cm.yz - 512.0) * vec2(-sgn, -1.0), 512.0 * sgn, cm.w).zyxw;\n    if (cm.x == 2.0 || cm.x == 3.0) return vec4((cm.yz - 512.0) * vec2( 1.0,  sgn), 512.0 * sgn, cm.w).xzyw;\n    if (cm.x == 4.0 || cm.x == 5.0) return vec4((cm.yz - 512.0) * vec2( sgn, -1.0), 512.0 * sgn, cm.w).xyzw;\n}\n\n// Converts 3D coordinates to cubemap coordinates\n// offs allows the sample position to be offset directly, avoiding precision errors\nvec4 space2cube(in vec3 p, in vec3 offs, in vec3 size, in vec3 res) {\n    p = floor((p / size + 0.5) * res) + offs;\n    float u = p.z * res.x * res.y + p.y * res.x + p.x;\n    float ch = mod(u, 4.0); // Color channel\n    u -= ch; u /= 4.0;\n    float x = mod(u, 1024.0); // X coordinate\n    u -= x; u /= 1024.0;\n    float y = mod(u, 1024.0); // Y coordinate\n    u -= y; u /= 1024.0;\n    float fid = u; // Face ID\n    return vec4(fid, x, y, ch);\n}\n\n// Converts cubemap coordinates to 3D coordinates\nvec3 cube2space(in vec4 cm, in vec3 size, in vec3 res) {\n    float u = cm.x * 4194304.0 + cm.z * 4096.0 + cm.y * 4.0 + cm.w; // *1024*1024*4, *1024*4, *4, *1\n    float x = mod(u, res.x);\n    float y = mod(u - x, res.x * res.y);\n    float z = (u - x - y) / res.x / res.y;\n    return (vec3(x, y / res.x, z) / res - 0.5) * size;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash13(in float x) {\n   vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        fragColor = vec4(1000000.0);\n    }\n\n    if (iFrame > 0) {\n        fragColor = texture(iChannel0, rayDir);\n        float fid = getFaceID(rayDir); // Face ID\n\n        // Loop over color channels\n        for (int ch=0; ch < 4; ch++) {\n            vec3 p = cube2space(vec4(fid, iFragCoord, ch), SIZE, RESOLUTION);\n\n            // Uncomment to see the abominations\n            /*float id = iTime * 1000.0;\n            vec3 pos = Hash13(id) * SIZE - 0.5 * SIZE;\n            float shape = Hash11(id + 473.847);\n\n            float size = Hash11(id) * 0.5;\n            vec3 q = abs(p - pos) - size;\n            float newShape = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n            if (shape > 0.333) {\n                newShape = length(p - pos) - size;\n            }\n\n            if (shape > 0.666) {\n                newShape = length(vec2(length(p.xy - pos.xz) - size, p.z - pos.y)) - 0.5 * size;\n            }*/\n\n            float newShape = length(p) - 1.5;\n\n            fragColor[ch] = min(fragColor[ch], newShape);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}