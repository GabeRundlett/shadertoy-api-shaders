{
    "Shader": {
        "info": {
            "date": "1633449966",
            "description": "interpolating between several cameras depending of the screen location.\nIn this example, just changing the camera height with U.y while looking at (0,0,0).\nMouse.x : range of camera change\nMouse.y : distance\ntry commented variants ;-)",
            "flags": 0,
            "hasliked": 0,
            "id": "sdcXzB",
            "likes": 13,
            "name": "multicamera view",
            "published": 3,
            "tags": [
                "raymarching",
                "camera",
                "distorsion",
                "short",
                "falseperspective"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 417
        },
        "renderpass": [
            {
                "code": "#define rot(a)        mat2(cos(a),sin(a),-sin(a),cos(a))  // rotation                  \n//#define fwidth(v)   sqrt( dFdx(v)*dFdx(v) + dFdy(v)*dFdy(v) )                 \n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R =  iResolution.xy, \n          U = ( 2.*u - R ) / R.y,\n          M = iMouse.xy!=vec2(0) ? 2.*iMouse.xy/R - 1. : vec2(sin(iTime),0);\n    vec3  V,\n          D = normalize(vec3(U, 1)),             // ray direction\n          p = vec3(0,1,-1),                      // ray start \n          L = vec3(0);                           // lookat\n          \n // p.x += M.x*U.x; p.xz /=length(p.xz);         // Xcam changes with U.x\n // p.x += M.x*U.y;                              // Xcam changes with U.y\n    p.y += M.x*U.y;                              // Ycam changes with U.y\n // p.xz*= rot(M.x*(.5+.5*U.y));                 // XZcam rotate with U.y\n // p.y += M.x*U.x;                              // Ycam changes with U.x\n    p *= 1.+M.y;                                 // Zoom\n    \n    V = L - p;                                   // D from Lookat\n    float phi = atan( V.y, length(V.xz) ),\n          theta = atan(V.x,V.z);   \n    D.yz *= rot(phi); D.xz *= rot(theta); \n        \n    \n    float d = -p.y/D.y;                          // intersect plane\n    if (d<0.) { O-=O; return; }\n    p += d* D;\n    \n    O = 6.28*vec4(1,2,4,0);                      // color scheme (checker texture with AA )\n    O = sin(O*p.x) * sin(O*p.z);\n    O = .5 + .5* O/fwidth(O)  * smoothstep(1.,0.,length(fwidth(p.xz)));\n                              // * smoothstep(0.,-5.,log2(fwidth(p.z))); // AA at horizon\n    p = abs(p); if (min(p.x,p.z)>.5) O = O.rrrr; // B&W out of [-1,1]Â²\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}