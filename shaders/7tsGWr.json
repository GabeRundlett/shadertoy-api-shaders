{
    "Shader": {
        "info": {
            "date": "1621960741",
            "description": "Koch Snowflake fractal, with working pan and zoom :)\nUp/Left/Down/Right = WASD\nRotation = Q/E\nZoom = I/O",
            "flags": 48,
            "hasliked": 0,
            "id": "7tsGWr",
            "likes": 5,
            "name": "Koch Snowflake fractal",
            "published": 3,
            "tags": [
                "fractal",
                "rotation",
                "panandzoom"
            ],
            "usePreview": 0,
            "username": "Hitthesurf",
            "viewed": 318
        },
        "renderpass": [
            {
                "code": "vec2 my_reflect(in vec2 pos, in vec2 n)\n{\n    n = normalize(n);\n    pos -= 2.*min(0.0, dot(pos, n))*n;\n    return pos;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.xy;\n    vec3 col = vec3(0);\n    float scale = 1.;\n    \n    \n    \n    //Pan and Zoom and Rotation\n    vec4 qp = textureLod(iChannel0, vec2(0.0,0.0), 0.0);\n    vec4 zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0);\n    // angle, angle vel, cos(angle), sin(angle)\n    vec4 rot = textureLod(iChannel0, vec2(0.5,10.5)/iResolution.xy,0.0);\n    \n    \n    uv *= zoom.z;\n    scale *= zoom.z;\n    uv = vec2(uv.x*rot.z-uv.y*rot.w, uv.x*rot.w + uv.y*rot.z);\n    uv.xy += qp.xy;\n    \n    //col.rg += uv;    \n\n  \n\n    \n    uv.x +=.5;\n    for (int i = 0; i < 12; i++) {\n        uv *= 3.;\n        scale *=3.;\n        uv.x -= 1.5;\n        uv.x = abs(uv.x); //reflection\n        uv.x -= 0.5;\n        uv = my_reflect(uv, vec2(0.866,-0.5));\n\n    } \n\n    float d = length(uv - vec2(clamp(uv.x,-1.,1.),0.0));//closest position to line segment\n    col += smoothstep(1./iResolution.y,0.00,d/scale);//only change color if far enough away\n    uv /= scale;\n    col += texture(iChannel1, uv*sin(iTime*0.1)).rgb;\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Keyboard Code to make it work\n// keys are javascript keycode\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nconst float speed = 0.03;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    //Only run once each frame\n    \n    /*\n    if (ivec2(fragCoord.xy) == ivec2(0,0))\n    {\n    \n    //Load previous offset x, offset y, zoom and rotation\n    vec4 visual = textureLod(iChannel0, vec2(0.0,0.0), 0.0);\n    //Zoom\n    visual.z += ReadKey(Key_I)-ReadKey(Key_O);\n    \n    \n    visual.x += ReadKey(Key_D)-ReadKey(Key_A);\n    visual.y += ReadKey(Key_W)-ReadKey(Key_S);\n    \n    \n    fragColor = visual;\n    \n    }\n    */\n    \n    \n    //Panning\n    if (ivec2(fragCoord.xy) == ivec2(0,0))\n    {\n    //float speed = 0.05;\n    \n    //Load previous x_pos, y_pos, x_vel, y_vel\n    vec4 qp = textureLod(iChannel0, vec2(0.0,0.0), 0.0);\n    //Need zoom as zoom level impacts offset\n    vec4 zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0);\n    \n    //Need Rot as rotatoin impacts offset\n    vec4 rot = textureLod(iChannel0, vec2(0.5,10.5)/iResolution.xy,0.0);\n    \n    //Velocity\n    qp.z = (ReadKey(Key_D)-ReadKey(Key_A))*speed*zoom.z; //Change input\n    qp.w = (ReadKey(Key_W)-ReadKey(Key_S))*speed*zoom.z; //velocity on zoom level\n    \n    //Deal with rotation\n    qp.zw = vec2(qp.z*rot.z-qp.w*rot.w, qp.z*rot.w + qp.w*rot.z);\n    \n\n    \n    \n    //New Position\n    qp.x += qp.z; //*time delta\n    qp.y += qp.w;\n    \n    fragColor = qp;\n    \n    }\n    \n    //Zoom\n    if (ivec2(fragCoord.xy) == ivec2(10,10) )\n    {\n    \n        vec4 zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0);\n        //Number of times zoom in - zoom out has happend\n        \n        zoom.y = (ReadKey(Key_I)-ReadKey(Key_O)); //Zoom velocity\n        zoom.x += zoom.y; //*time delta\n        zoom.z = pow(2.71,-zoom.x*speed);\n        \n        //Save Zoom data to bufferA pixel (10,10)\n        fragColor = zoom;\n    }\n    \n    //Rotation\n    if (ivec2(fragCoord.xy) == ivec2(0,10) )\n    {\n        // angle, angle vel, cos(angle), sin(angle)\n        vec4 rot = textureLod(iChannel0, vec2(0.5,10.5)/iResolution.xy,0.0);\n        //Number of times zoom in - zoom out has happend\n        \n        rot.y = (ReadKey(Key_Q)-ReadKey(Key_E))*speed; //Rot velocity\n        rot.x += rot.y; //*time delta\n        rot.z = cos(rot.x);\n        rot.w = sin(rot.x);\n        \n        //Save Zoom data to bufferA pixel (10,10)\n        fragColor = rot;\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}