{
    "Shader": {
        "info": {
            "date": "1546688841",
            "description": "A simple two-pass outline shader that compares the color of neighbouring pixels in a 2x2 neighbourhood. Produces thin and crisp one-pixel lines (except when 3 or more lines meet at the same point). ",
            "flags": 32,
            "hasliked": 0,
            "id": "3sl3RS",
            "likes": 13,
            "name": "Crisp and thin two-pass outlines",
            "published": 3,
            "tags": [
                "outlines"
            ],
            "usePreview": 0,
            "username": "mv",
            "viewed": 1593
        },
        "renderpass": [
            {
                "code": "// Reads from the color buffer (Buffer A) and compares neighbouring pixel colors. \n\n#define SHOW_OUTLINES\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// NOTE: This can be a single textureGather if the identifier color is a single component.\n    // NOTE: Introduces a slight bias towards the upper-right due to the biased sample pattern. \n    vec4 p00 = texelFetchOffset(iChannel0, ivec2(fragCoord.xy), 0, ivec2(0, 0)); // lower-left\n    vec4 p10 = texelFetchOffset(iChannel0, ivec2(fragCoord.xy), 0, ivec2(1, 0)); // lower-right\n    vec4 p01 = texelFetchOffset(iChannel0, ivec2(fragCoord.xy), 0, ivec2(0, 1)); // upper-left\n    vec4 p11 = texelFetchOffset(iChannel0, ivec2(fragCoord.xy), 0, ivec2(1, 1)); // upper-right\n    \n    fragColor = p00;\n#ifdef SHOW_OUTLINES\n    if ((p10 != p00) || ((p01 != p00) && (p11 != p00))) {\n     \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Writes different color per object\n\nvec2 dmin(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat distDisk(vec2 p, vec2 c, float r) {\n \treturn length(p - c) - r;\n}\n\nvec2 map(vec2 p) {\n    vec2 c1 = vec2(-0.4, -0.5) + 0.25*vec2(cos(1.20*iTime), sin(1.10*iTime));\n    vec2 c2 = vec2(+0.5, -0.4) + 0.25*vec2(cos(1.40*iTime), sin(1.25*iTime));\n    vec2 c3 = vec2(+0.4, +0.5) + 0.25*vec2(cos(1.10*iTime), sin(1.30*iTime));\n    vec2 c4 = vec2(-0.5, +0.4) + 0.25*vec2(cos(1.50*iTime), sin(1.00*iTime));\n    \n    vec2 d = vec2(0.0, 0.0); // d < 0.0 in the interior of any shape\n \td = dmin(d, vec2(distDisk(p, c1, 0.7), 1.0));\n \td = dmin(d, vec2(distDisk(p, c2, 0.4), 2.0));\n    d = dmin(d, vec2(distDisk(p, c3, 0.6), 3.0));\n    d = dmin(d, vec2(distDisk(p, c4, 0.5), 4.0));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.2*(2.0*fragCoord.xy - iResolution.xy)/iResolution.yy;\n    \n    vec2 d = map(uv);\n    fragColor = vec4(0.5 + 0.5*cos(vec3(8.0, 6.0, 7.0)*d.y), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}