{
    "Shader": {
        "info": {
            "date": "1509427595",
            "description": "testing a modified version of iq's approximate soft shadows, which extends the penumbra inwards as well as outwards.The space between the pillars would not cast a sliver of light on the floor otherwise.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tBcz3",
            "likes": 11,
            "name": "Improved Soft Shadows",
            "published": 3,
            "tags": [
                "raymarching",
                "shadow",
                "soft",
                "technique"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 1102
        },
        "renderpass": [
            {
                "code": "#define fdist 0.5\n#define maxdist 100.\n#define iters 40\n#define shadowiters 70\n#define threshold 0.025\n#define eps 0.01\n#define shadoweps 0.1\nfloat sharpness = 1.;\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define lightdir normalize(vec3(1., 1., 0.))\n\nfloat cylindersdf(vec3 pos, vec3 c, float r, float h) {\n    pos -= c;\n    return max(length(pos.xz)-r, max(-pos.y, pos.y - h));\n}\n\nfloat sdf(vec3 pos) {\n    float h1 = cylindersdf(pos, vec3(0., 0., 0.55), 0.5, 5.);\n    float h2 = cylindersdf(pos, vec3(0., 0., -0.55), 0.5, 5.);\n    return min(max(length(pos.xz)-7., pos.y), min(h1, h2));\n}\n\nvec3 getnormal(vec3 pos) {\n    float xp = sdf(pos + vec3(eps, 0., 0.));\n    float xm = sdf(pos - vec3(eps, 0., 0.));\n    float ddx = xp - xm;\n    float yp = sdf(pos + vec3(0., eps, 0.));\n    float ym = sdf(pos - vec3(0., eps, 0.));\n    float ddy = yp - ym;\n    float zp = sdf(pos + vec3(0., 0., eps));\n    float zm = sdf(pos - vec3(0., 0., eps));\n    float ddz = zp - zm;\n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec2 raytrace(vec3 eye, vec3 rd) {\n    int i;\n    float t = 0.;\n    float dist = sdf(eye);\n    for (i=0; i<iters; i++) {\n        t += dist;\n        dist = sdf(eye + t*rd);\n        if (abs(dist) < threshold) {\n            return vec2(t, 1.);\n        } else if (dist > maxdist) {\n            break;\n        }\n    }\n    return vec2(t, 0.);\n}\n\n//a version of soft shadow raytracing that uses the distance to surfaces from both inside and outside\nfloat shadowtrace(vec3 ro, vec3 rd) {\n    int i;\n    float t = shadoweps;\n    float dist = sdf(ro+t*rd);\n    float fac = 1.0;\n    for (i=0; i<shadowiters; i++) {\n        t += clamp(dist/10., 0.1, 0.2);\n        dist = sdf(ro + t*rd);\n        fac = min(fac, dist * sharpness / t);\n    }\n    return mix(mix(0.5, 0., -fac), mix(0.5, 1., fac), step(fac, 0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float alt = clamp(iMouse.y/iResolution.y,0.15, 1.) * PI/2.;\n    float azi = (iMouse.x/iResolution.x-0.35) * TWO_PI;\n    float cphi = cos(alt);\n    vec3 eye = 10. * vec3(sin(azi)*cphi, sin(alt), cos(azi)*cphi);\n    eye.y += 2.;\n    sharpness = 4.*sin(iTime) + 5.;\n    vec3 w = -normalize(eye);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(fdist*w + (fragCoord.x/iResolution.x-0.5)*u + (fragCoord.y-0.5*iResolution.y)/iResolution.x*v);\n    \n\tvec2 d = raytrace(eye, rd);\n    if (d.y < 0.5) {\n        fragColor = vec4(0., 0., 0., 1.);\n    } else {\n        vec3 n = getnormal(eye + rd * d.x);\n        float shade = max(0., dot(n, lightdir));\n        float fac = shadowtrace(eye+rd*d.x, lightdir);\n        fac = min(fac, shade);\n        fragColor = vec4(pow((n+1.)/2.*max(fac, 0.05), vec3(0.45)), 1.);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}