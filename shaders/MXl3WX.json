{
    "Shader": {
        "info": {
            "date": "1708011213",
            "description": "Rework of Portal - Blue and Orange idea to loopless.\nDraw 8 layers of sdf-animation layer;",
            "flags": 0,
            "hasliked": 0,
            "id": "MXl3WX",
            "likes": 29,
            "name": "Portal - loopless example",
            "published": 3,
            "tags": [
                "portal",
                "trail",
                "loopless",
                "blueportal",
                "orangeportal"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "// Created by Danil (2024+) https://github.com/danilw\n// License - CC0 or use as you wish\n\n// self https://www.shadertoy.com/view/MXl3WX\n\n// example of loopless sdf draw idea/similar to https://www.shadertoy.com/view/MXlGD2\n// draw 8 layers of sdf animation \n\n\n\n// change show define\n// 0 particles\n// 1 blured lines\n#define show 1\n\n\n// sdf scale\nconst float line = 0.003;\nconst float px = 0.004;\n\n//example\n//const float line = 0.0065;\n//const float px = 0.0023;\n\n\n\n\n#define PORTAL_ORANGE vec3(1.000,0.5,0.000)\n#define PORTAL_BLUE vec3(0.0,0.5,1.0)\n\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI 3.14159265358979\n\nfloat hash11(float p);\nfloat sdEllipse( in vec2 p, in vec2 ab );\nfloat draw(vec2 p, float px, float timer){\n    const int ldraw = 15;\n    const int lstep = 10;\n    \n    float d = sdEllipse(p, vec2(0.35,0.45));\n    \n    int lid = int((d+(line+px*2.)*0.5)/(line+px*2.));\n    lid+=lstep*int(d<-(line+px*2.)*0.5);\n    lid+=(lstep+1)*int(d>-(line+px*2.)*0.5);\n    d = mod(abs(d),line+px*2.)-(line+px*2.)*0.5;\n    d = smoothstep(-px,px,abs(d));\n    \n    d = d*step(0.,float(lid))*step(float(lid),float(ldraw));\n    \n    lid+=2;\n    float rot = timer*(0.25+(float(lid)+5.77*hash11(float(lid)*15.457))*0.45)+float(lid)*PI*0.23;\n#if(show)\n    rot*=2.;\n    rot+=(3.+float(lid)*.75)*sin(timer*0.733+float(lid)*PI*0.35);\n    //rot+=7.*cos(timer*0.712+float(lid)*PI*.63);\n    vec2 tp = (p*MD(rot*0.5));\n    float td = smoothstep(0.,px,tp.x);\n#else\n    rot*=.65;\n    vec2 tp = (p*MD(rot*0.5));\n    float td = smoothstep(0.,px,tp.x*sign(tp.y))*(smoothstep(0.,0.005+0.063*clamp(float(lid-7)/20.,0.,1.),abs(tp.y)));\n#endif\n    td*=1.-smoothstep(0.,0.25+0.015*float(abs(lid)),abs(tp.y));\n    d*=td;\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y-0.5*res;\n    \n    float d = draw(uv,px, iTime);\n    float d2 = draw(uv,px, iTime*1.33+1.5);\n    float d3 = draw(uv*1.015,px*1.015, iTime);\n    float d4 = draw(uv*1.015,px*1.015, iTime*1.33+1.5);\n    \n    float db = draw(uv,px, iTime*1.5+5.);\n    float db2 = draw(uv,px, iTime*1.5*1.33+1.5+5.);\n    float db3 = draw(uv*1.015,px*1.015, iTime*1.5+5.);\n    float db4 = draw(uv*1.015,px*1.015, iTime*1.5*1.33+1.5+5.);\n    \n    //float dr = clamp(max(d3*d4,d*d2),0.,1.);\n    //float dbr = clamp(max(db3*db4,db*db2),0.,1.);\n    float dr = clamp((d3*d4+d*d2),0.,1.);\n    float dbr = clamp((db3*db4+db*db2),0.,1.);\n    \n    vec3 ca = PORTAL_ORANGE*dr;\n    vec3 cb = PORTAL_BLUE*dbr;\n    \n    vec3 c = ca+cb;\n    \n    c = c+0.65*pow(c,vec3(2.2));\n    \n    float ed = abs(sdEllipse(uv, 0.85*vec2(0.35,0.45)));\n    c*=1.-smoothstep(0.025,0.175,ed);\n    float g = 1.-smoothstep(-0.1,0.25,ed);\n    g*=0.75;\n    vec3 tc = 0.5+0.5*cos(iTime*0.75+uv.xyx*0.5+vec3(0,2,4));\n    c+=g*g*(mix(PORTAL_BLUE,PORTAL_ORANGE,tc.r)+tc*0.5)+g*g*(PORTAL_BLUE*d*db2+PORTAL_ORANGE*d3*db4);\n    \n    fragColor = vec4(c,1.0);\n    \n}\n\n\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}