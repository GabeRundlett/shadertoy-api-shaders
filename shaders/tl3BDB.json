{
    "Shader": {
        "info": {
            "date": "1613355091",
            "description": "Volumetric clouds. Use the mouse to look around. Clouds shape and shading can be adjusted by changing the constants at the top of the file.",
            "flags": 0,
            "hasliked": 0,
            "id": "tl3BDB",
            "likes": 3,
            "name": "Volume Scattering Clouds",
            "published": 3,
            "tags": [
                "raymarching",
                "clouds",
                "volumetric",
                "scattering"
            ],
            "usePreview": 0,
            "username": "vinkna",
            "viewed": 441
        },
        "renderpass": [
            {
                "code": "// Volume Scattering Clouds\n// by Vincent Knauss @vinkna, 2021\n// https://www.shadertoy.com/view/tl3BDB\n\n// Based on the course notes\n// Real-Time Volumetric Rendering by Patapom / Bomb!, 2013\n// https://patapom.com/topics/Revision2013/Revision%202013%20-%20Real-time%20Volumetric%20Rendering%20Course%20Notes.pdf\n\nconst vec3 blueSkyColor = vec3(0.2, 0.8, 2.0);\n\nconst float cloudiness = 0.35;  // controls how much of the sky is covered by clouds\nconst float cloudDensity = 0.15;  // scales the density of the clouds, a multiplier to the scattering and extinction coeffs\n\n// sigma_t and sigma_s in the volumetric rendering equation\n// properly, sigma_t = sigma_s + sigma_a and for clouds sigma_a ~= 0 so sigma_s ~= sigma_t\n// however I found this makes the clouds too dark. probably because there is no multiple scattering\nconst float fExtinction = 0.0275;\nconst float fScattering = 0.0375;\n\nconst float PI = 3.141592653;\n\nconst float rPlanet = 1000000.0;  // controls how fast clouds drop below the horizon. further clouds show more undersampling aritfacts\n\n// clouds are drawn in a spherical shell with inner radius rPlanet + cloudBottom and outer radius rPlanet + cloudTop\n// the ray march steps are aligned to the surface of this shell, meaning the distance for each step depends on the angle of the ray\nconst float cloudBottom = 1500.0;\nconst float cloudTop = 6000.0;\nconst int cloudSteps = 64;\n\n// shadow steps are raymarched out from each point, and accumulate extinction values to approximate how much direct\n// sunlight is transmitted to the point\nconst int shadowSteps = 6;\nconst float shadowStepDist = 100.0;\n\nconst float noiseFrequency = 0.0001;  // base scale applied to the coordinates when noise is sampled. multiplied by 3 on the y axis\n\nconst vec3 sunDirection = normalize(vec3(-5, -3, -1));  // direction of the sunlight, not to the sun\nconst vec3 sunIntensity = vec3(5.0, 5.0, 5.0);\n\nconst vec2 cloudVelocity = vec2(300, 200);\n\n\n// 2D Random from The Book of Shaders\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat random(in vec3 c) {\n    return random(vec2(random(c.xy), c.z));\n}\n\n// 3D Value Noise based on:\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec3 st) {\n    vec3 i = floor(st);\n    vec3 fr = fract(st);\n\n    // 8 corners in 3D of a tile\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec3 u = fr*fr*(3.0-2.0*fr);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 8 corners percentages\n    return mix(mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y,\n                mix(e, f, u.x) + (g - e)* u.y * (1.0 - u.x) + (h - f) * u.x * u.y, u.z);\n}\n\nfloat fbm(vec3 coord, int octave, float baseScale) {\n    float influence = 0.5;\n    float scale = baseScale;\n    float sum = 0.0;\n    for (int i = 0; i < octave; ++i) {\n        sum += influence * noise(coord * scale);\n        influence *= 0.5;\n        scale *= 2.0;\n    }\n    return sum;\n}\n\n// Formula for distance from a point at the top of a circle with radius r to the edge of a circle with radius r + d along a ray with vertical angle theta:\n// d = sqrt(r^2 * cos^2(theta) + 2*r*d + d^2) - r * cos(theta)\nfloat distanceToSphereEdge(float r, float d, float cst) {\n    return sqrt(r*r*cst*cst + 2.0*r*d + d*d) - r*cst;\n}\n\n// Henyey-Greenstein phase function\nfloat phaseHG(float g, float cst) {\n    float gg = g*g;\n    return (1.0 - gg) / (4.0*PI*pow(1.0+gg-2.0*g*cst, 1.5));\n}\n\nfloat cloud(vec3 coord, float dist, float startDist, float endDist) {\n    float d = fbm(coord * vec3(1, 3, 1), 8, noiseFrequency);\n    \n    d = cloudDensity * clamp((d-1.0+cloudiness)/cloudiness, 0.0, 1.0);\n\n    // ramp the density to 0 at the top and bottom of the cloud layer\n    d *= clamp((dist - startDist) / 700.0, 0.0, 1.0);\n    d *= clamp((endDist - dist) / 10.0, 0.0, 1.0);\n    \n    return d;\n}\n\nvec2 rotate(vec2 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 worldDir = normalize(vec3((fragCoord - 0.5 * iResolution.xy)/iResolution.y, 1.0));\n    worldDir.yz = rotate(worldDir.yz, clamp((iMouse.y - abs(iMouse.w)) / iResolution.y * 5.0, -PI/2.0, PI/2.0));\n    worldDir.xz = rotate(worldDir.xz, (iMouse.x - abs(iMouse.z)) / iResolution.x * 5.0);\n    \n       \n    if (worldDir.y > 0.0) {\n        vec3 cloudLuminance = vec3(0, 0, 0);\n        float cloudExtinction = 1.0;\n\n        // cos(theta) is equal to worldDir.y here\n        float cloudStartDist = distanceToSphereEdge(rPlanet, cloudBottom, worldDir.y);\n        float cloudEndDist = distanceToSphereEdge(rPlanet, cloudTop, worldDir.y);\n\n        float cloudDist = cloudStartDist;\n        float cloudStepDist = (cloudEndDist - cloudStartDist) / float(cloudSteps - 1);\n\n        float cosTheta = -dot(worldDir, sunDirection);\n        float phaseSun = 0.01 * phaseHG(0.8, cosTheta) + 0.8 * phaseHG(0.1, cosTheta) + 0.19 * phaseHG(-0.2, cosTheta);\n\n        float phaseAmbient = 1.0 / (4.0 * PI);\n\n        int inCloud = 0;\n        float sumDensity = 0.0;\n        for (int i = 0; i < cloudSteps; ++i) {\n            vec3 cloudPos = worldDir * cloudDist + vec3(cloudVelocity.x, 0, cloudVelocity.y) * iTime;\n            float thisStepDist = cloudStepDist;\n\n            float density = cloud(cloudPos, cloudDist, cloudStartDist, cloudEndDist);\n\n            if (density > 0.0) {\n                inCloud = 2;\n            } else {\n                --inCloud;\n            }\n            \n            if (inCloud > 0) {\n                float sunExtinction = 1.0;\n                for (int j = 0; j < shadowSteps; ++j) {\n                    vec3 shadowPos = cloudPos - sunDirection * shadowStepDist * float(j+1);\n\n                    float shadowCloudDensity = cloud(shadowPos, length(worldDir * cloudDist + sunDirection * shadowStepDist * float(j+1)), cloudStartDist, cloudEndDist);\n\n                    sunExtinction *= exp(-fExtinction * shadowCloudDensity * shadowStepDist);\n                }\n\n                vec3 ambientColor = sunIntensity;\n                vec3 sunColor = sunExtinction * sunIntensity;\n\n               \n                cloudExtinction *= exp(-fExtinction * density * cloudStepDist);\n                \n                if (cloudExtinction <= 0.001) {\n                    cloudExtinction = 0.0;\n                    break;\n                }\n\n                vec3 sampleLuminance = cloudExtinction * fScattering * density * cloudStepDist * (phaseAmbient * ambientColor + phaseSun * sunColor);\n                if (any(lessThan(sampleLuminance, vec3(0.0)))) cloudLuminance = vec3(10, 0, 0);\n                else cloudLuminance += clamp(1.0 -sumDensity, 0.0, 1.0) * sampleLuminance;\n            }\n\n            cloudDist += cloudStepDist;\n            sumDensity += density;\n        }\n        \n        float distBlend = 1.0 - clamp((cloudStartDist-cloudBottom)/500000.0, 0.0, 1.0);\n        distBlend *= distBlend;\n\n        float sunFactor = clamp(-dot(worldDir, sunDirection)-0.998, 0.0, 0.002) * 500.0;\n        sunFactor *= sunFactor;\n        vec3 skyColor = blueSkyColor + sunFactor * sunIntensity;\n        skyColor = distBlend * cloudLuminance + skyColor * cloudExtinction + blueSkyColor * (1.0 - cloudExtinction) * (1.0 - distBlend);\n        \n        fragColor = vec4(skyColor, 1.0);\n    } else {\n        fragColor = vec4(vec3(0.2), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}