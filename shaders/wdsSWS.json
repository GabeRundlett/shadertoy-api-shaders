{
    "Shader": {
        "info": {
            "date": "1552067926",
            "description": "klick mouse.\ninterpolates between 2 porterDuffAlphacompsiting scemes, it may help to have a generalization of them all.\nmy first attempt to that was just false(4tscRf)\nand i never uploaded this demo on its own. i just included its functions in my shaders.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdsSWS",
            "likes": 5,
            "name": "bokehIterpolate PorterDuffAlpha",
            "published": 3,
            "tags": [
                "blur",
                "compositing",
                "ssaa",
                "alpha",
                "composite",
                "bound",
                "compositioning",
                "linearinterpolation",
                "porterduffalphacompositing",
                "champlaincolle"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 647
        },
        "renderpass": [
            {
                "code": "//porter duff compositing.\n//blends 4 quadrants\n//, each quadrant has a different compositing function\n//of https://en.wikipedia. org/wiki/Alpha_compositing\n\n//this demo has a different porterDuffAlphacompositing\n//of [blue and yellow] for each quadrant\n//top    left  = blue   Over orange (most common)\n//top    right = blue   Xor  orange (overlap is transparent)\n//bottom left  = blue   Atop orange (blue over orange && non-orange is transparent)\n//bottom right = orange Out  blue   (blue over orange && blue       is transparent)\n\n//they smoothly interpolate and bokeh into each other.\n//they still work if the thickness of a line or gap is ==0.\n//but in terms of the gradient that is still a thickness or gap!\n\n//on [premultiply], you may want to watch\n//https://www.youtube.com/watch?v=XobSAXZaKJ8\n\n//these params seem defuncted:\n//turn circles into rings\n#define rings\n//show invisible pink unicors,arranged in a checkerboard tiling.\n#define ExplicitBackground\n//gritty  reboot please? have some inverse do_gamma\n#define do_gritty\n//my eyes,the googles do nothing!\n#define do_gamma\n\n//View.Zoom\n#define ViewZoom 2.\n//View.blurryness of screen-space-anti-aliasing (smoothstep range)\n#define SSAAblur 99.*u5(cos(iTime*1.61))*ViewZoom\n//[*2.] nicely  precision loss of Dfdx()Dfdy(),half screenspace respolution.\n//view Frame==2d camera\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n//common aliases:\n#define vec1 float\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n\nfloat checkerBool2(vec2 h){h=fract(h);\n         bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\n\n\n#define sat(a) clamp(a,0.,1.)\n\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//.w=0 is fully transparent, .W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs wioth their alpha;\n//; a.xyz*=a.w\n//; b.xyz*=b.w\n//and the outputs of these functions will be already_premultiplied.\n//\n//else if(you to one last pdOver a nontransparent background) you must NOT premultiply the backbround!\n//pdver without premultiplied alpha, note that nonstransparent red+nontransparent green = nontransparendt yellow.\n//vec4 pdo(vec4 a,vec4 b){return vec4((a.xyz*a.w+b.xyz*b.w)/(a.xyz+b.w*(1.-a.w)),,a.w+b.w*(1.-a.w));}\n//these functions are with premultiplied alpha (better performance, easy to buffer)\n//\n//GENERAL alpha composition:  named after porterDuff\n//see https://en.wikipedia.org/wiki/Alpha_compositing\n//    https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent, .W=1 is fully visible\n//inputs should be x=sat(x), or you likely get [color inverted hazes], this version is still not haze-free?\n//\n//on premultiplication:\n//iff (you want to keep an alpha channel after a composition)  !!!!\n//You must FIRST premultiplay all inputs with their alpha.w :  !!!!\n//; a.xyz*=a.w                                                 !!!!\n//; b.xyz*=b.w                                                 !!!!\n//on general [premultiply], you may want to watch              !!!!\n//https://www.youtube.com/watch?v=XobSAXZaKJ8                  !!!!\n//\n//IFF you can discard the alpha channel after a SINGLE composition\n//, you may also skip the premultiply-multiplication in some cases.\n\n//ut() is a subroutine for alpha compositing:\n//#define ut(a,b) (a*(1.-b))   //this one liner is a lot less worksafe!\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}\n//below are the 5 alpha compositions:\nvec4 pdOut (vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+(a*b.w);}\nvec4 pdXor (vec4 a,vec4 b){return ut(b,a.w)+vec4(ut(a,b.w));}\nvec4 pdIn  (vec4 a,vec4 b){return vec4(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//the above ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//the above ommits 2 functions, that return a or b, for simplicity\n//end of basic part of alpha compositing (yep, thats ALL there is to it)\n//\n//start of extended alpha compositing \n//...adds interpolation+generalization to compositing (interpolating different types of compositing)\n//The below allows you to MIX(a,b,c) between any 2 or 4 types of alpha compositing, by the parameter [c]\n//pf() does unify all 5 pd-compositions (above) into 1 parametric function\n//pf() was a silly idea of smoothly cyling between 5 compositions\n//pf() was quickly obsoleted by pf()\n//pdOverAtop() and pdOutXor() are interpolating subroutines for pf()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\n//pf() has c set how we interpolate; c is range [0..4] and whole-bumber-c causes a [mix(a,b,0.)==a] result\n#define Over 0. //[c range 0..1 => over..atop]\n#define Atop 1. //[c range 1..2 => atop..out]\n#define Out  2. //[c range 2..3 =>  out..Xor]\n#define Xor  3. //[c range 3..4 =>  xor..In]\n#define In   4.\n//the ability to interpolate is just a side effect of using mix() to generalize.\n//pf() may actually only work well for c=floor(c) its not tested well.\nvec3 pf(vec4 a,float c,vec4 b\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\n//\n//pd() makes more sense than pf() for demoing interpolation of compositing\n//pd() does bilinear interpolatin over c.xy, as in https://www.shadertoy.com/view/wdsSWS\n//top    left  = Over\n//top    right = Xor\n//bottom left  = Atop\n//bottom right = Out \nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//clamping c.x to ensure bounds.\n ;return mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w);}\n/**/\n\n//variants with swapped parameters, meh i never used these.\n//vec4 pdXord(vec4   a,vec4 b){return pdXor(b,a);}//perfectly valid (13th unique) function!\n//vec4 pdOverd(vec4  a,vec4 b){return pdOver(b,a);}\n//vec4 pdInd(vec4    a,vec4 b){return pdIn(b,a);}\n//3 trivial remaining cases; return 0;return a,return b\n\n\n#define sat(a) clamp(a,0.,1.)\nvoid mainImage(out vec4 O,vec2 u\n){u=fra(u)//frame uv\n ;vec2 m=fra(iMouse.xy)//frame mouse\n ;vec2 n=fra(iMouse.zw)//frame mouse\n ;vec2 d=smoothstep(1.,-1.,u)\n //;d.x=checkerBool2(u)\n //;d.y=checkerBool2(u*.61)\n ;d.x=length(u)\n ;d.y=length(u-m)-.1\n ;d=abs(d-.7)-.02\n ;d=mix(abs(abs(d-.2)-.1-.09)-.04,d-.3,cos(iTime/2.61)*.5+.5)//optional more but thinner rings\n ;//d=sat(d)no.this is not it\n ;float bokeh=(cos(iTime)*.5+.5)*.1\n ;d=smoothstep(bokeh,-bokeh,d)\n ;vec4 a=vec4(0,.2,1,d.x)\n ;vec4 b=vec4(1,.8,0,d.y)\n ;float tm=cos(iTime*.61)*.5+.5\n ;tm=1.//core issue debug override --------------------\n //;a=mix(a,b,tm)\n ;a.xyz*=a.w//premultiuply alpha keeps things simple\n ;b.xyz*=b.w//premultiuply alpha keeps things simple\n ;vec2 uu=u*vec2(3,2)\n //;a=pdXor(a,b)//works\n ;a=pd(a,uu,b)//scaling and offset on uu could be better\n //;a=pd(a,-vec2(0,1),b)//shoows flaws\n //;a=pd(a,0.,b)\n ;a=sat(a)\n ;//last one is very optional\n ;vec4 c=vec4(vec3(checkerBool2(u*2.61)*.5+.25),1)//;c.xyz*=a.w//last canvas/background gets NO premultiplied.xyz\n ;a=pdOver(a,c)\n ;O=a;\n ;}\n\n//parent shader of THIS was VERY WRONG, for shame:  https://www.shadertoy.com/view/4tscRf",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}