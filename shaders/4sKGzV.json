{
    "Shader": {
        "info": {
            "date": "1455417250",
            "description": "Wang tile shader\n\nHas 3 good demos of wang tilesets -- colored triangles (enabled by default), circles on tile edges, and circles on tile corners. ",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKGzV",
            "likes": 10,
            "name": "Wang tiles",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "tile",
                "wang"
            ],
            "usePreview": 0,
            "username": "ChronosDragon",
            "viewed": 1276
        },
        "renderpass": [
            {
                "code": "#define iSCREEN_TILES (20)\n#define SCREEN_TILES (float(iSCREEN_TILES))\n\n#define DEMO_EDGE_COLORS 1\n#define DEMO_EDGE_SHAPES 2\n#define DEMO_CORNER_SHAPES 3\n\n#define DEMO DEMO_EDGE_COLORS\n\nfloat sample1(vec2 coord)\n{\n    float value = texture(iChannel0, coord.xy/iChannelResolution[0].xy).x;\n    return fract(value * 373.7681691);\n}\n\nfloat sample2(vec2 coord)\n{\n    float value = texture(iChannel0, coord.xy/iChannelResolution[0].xy).x;\n    return fract(value * 789.1798684);\n}\n\nvec4 cornerSample(vec2 coord)\n{\n    float t = iTime*0.002;\n    return vec4(sample1(coord + vec2(t, t)),\n                sample1(coord + vec2(t, t+1.)),\n                sample1(coord + vec2(t+1., t+1.)),\n                sample1(coord + vec2(t+1., t))); \n}\n\n// A procedural edge pattern. Samples two different intervals to compose the set of \n//   edge \"colors\". \n// Note that this is a very generic wang tileset, consisting of all possible combinations\n//   of colors on all possible edges. More interesting tilesets are formed with constraints,\n//   that have properties such as periodicity and decidability. \n// A \"color\" is some float value, which can be arbitrarily\n//   assigned a visual color/shape as a result of a tile creation function\nvec4 edgeSample(vec2 coord)\n{\n    float t = iTime*0.002;\n    return vec4(sample1(coord + vec2(0., t)),  // left\n                sample2(coord + vec2(t, 1.)),  // top\n                sample1(coord + vec2(1., t)),  // right\n                sample2(coord + vec2(t, 0.))); // bottom\n}\n\n// Edge patterns:\n// Red channel: left edge color\n// Green channel: top edge color\n// Blue channel: right edge color\n// Alpha channel: bottom edge color\n\nvec3 wangEdgeDot(in vec2 uv, vec4 edges)\n{\n    float x = uv.x;\n    float y = uv.y;\n    float halfx = x-0.5;\n    float halfy = y-0.5;\n    float invx = 1. - uv.x;\n    float invy = 1. - uv.y;\n    \n    float result = 0.0;\n    if (edges.r > 0.7) {\n        result = max(result, float(x*x + halfy*halfy < 0.25));\n    }\n    if (edges.g > 0.7) {\n        result = max(result, float(halfx*halfx + invy*invy < 0.25));\n    }\n    if (edges.b > 0.7) {\n        result = max(result, float(invx*invx + halfy*halfy < 0.25));\n    }\n    if (edges.a > 0.7) {\n        result = max(result, float(halfx*halfx + y*y < 0.25));\n    }\n    return vec3(result);\n}\n\nvec3 wangEdgeSimple(in vec2 uv, vec4 edges)\n{\n    float x = uv.x;\n    float y = uv.y;\n    float invx = 1. - uv.x;\n    float invy = 1. - uv.y;\n    \n    float result = 0.0;\n    if (edges.r > 0.5) {\n        result = max(result, float(x < 0.3));\n    }\n    if (edges.g > 0.5) {\n        result = max(result, float(invy < 0.3));\n    }\n    if (edges.b > 0.5) {\n        result = max(result, float(invx < 0.3));\n    }\n    if (edges.a > 0.5) {\n        result = max(result, float(y < 0.3));\n    }\n    return vec3(result);\n}\n\n// Classic wang colored tiles. Fills in colors based on edge conditions.\n// TODO: Loads of branches here, and its very aliased. Need to work on\n// a better way to get the same effect with less branching.\nvec3 wangEdgeColoredTriangle(in vec2 uv, vec4 edges)\n{\n    float x = uv.x;\n    float y = uv.y;\n    float halfx = x-0.5;\n    float halfy = y-0.5;\n    float invx = 1. - uv.x;\n    float invy = 1. - uv.y;\n    \n \n    vec3 result = vec3(0.0);\n    if (edges.r > 0.8) {\n        result.r = max(result.r, float(x <= 0.45-abs(halfy)));\n    }\n    else if (edges.r > 0.6) {\n        result.g = max(result.g, float(x <= 0.45-abs(halfy)));\n    }\n    else if (edges.r > 0.45) {\n        result.b = max(result.b, float(x <= 0.45-abs(halfy)));\n    }\n    else if (edges.r > 0.2) {\n        result.rg = max(result.rg, float(x <= 0.45-abs(halfy)));\n    }\n    \n    if (edges.g > 0.8) {\n        result.r = max(result.r, float(invy <= 0.45-abs(halfx)));\n    }\n    else if (edges.g > 0.6) {\n        result.g = max(result.g, float(invy <= 0.45-abs(halfx)));\n    }\n    else if (edges.g > 0.45) {\n        result.b = max(result.b, float(invy <= 0.45-abs(halfx)));\n    }\n    else if (edges.g > 0.2) {\n        result.rg = max(result.rg, float(invy <= 0.45-abs(halfx)));\n    }\n    \n    if (edges.b > 0.8) {\n        result.r = max(result.r, float(invx < 0.45-abs(halfy)));\n    }   \n    else if (edges.b > 0.6) {\n        result.g = max(result.g, float(invx < 0.45-abs(halfy)));\n    }\n    else if (edges.b > 0.45) {\n        result.b = max(result.b, float(invx < 0.45-abs(halfy)));\n    }\n    else if (edges.b > 0.2) {\n        result.rg = max(result.rg, float(invx < 0.45-abs(halfy)));\n    }\n    \n    if (edges.a > 0.8) {\n        result.r = max(result.r, float(y < 0.45-abs(halfx)));\n    }\n    else if (edges.a > 0.6) {\n        result.g = max(result.g, float(y < 0.45-abs(halfx)));\n    }\n    else if (edges.a > 0.45) {\n        result.b = max(result.b, float(y < 0.45-abs(halfx)));\n    }\n    else if (edges.a > 0.2) {\n        result.rg = max(result.rg, float(y < 0.45-abs(halfx)));\n    }\n    \n    if (x < 0.015 || y < 0.015 || invx < 0.015 || invy < 0.015) { return vec3(0.); }\n    \n    return result;\n}\n\n\n// Corner patterns:\n// Red channel: bottom left corner color\n// Green channel: top left corner color\n// Blue channel: top right corner color\n// Alpha channel: bottom right corner color\nvec3 wangCornerDot(in vec2 uv, vec4 corners)\n{\n    float x = uv.x;\n    float y = uv.y;\n    float invx = 1. - uv.x;\n    float invy = 1. - uv.y;\n    \n    float result = 0.0;\n    if (corners.r > 0.5) {\n        result = max(result, float(x*x + y*y < 0.2));\n    }\n    if (corners.g > 0.5) {\n        result = max(result, float(x*x + invy*invy < 0.2));\n    }\n    if (corners.b > 0.5) {\n        result = max(result, float(invx*invx + invy*invy < 0.2));\n    }\n    if (corners.a > 0.5) {\n        result = max(result, float(invx*invx + y*y < 0.2));\n    }\n    return vec3(result);\n}\n\n// Triangles, resulting in a tilted grid pattern\nvec3 wangCornerTriangle(in vec2 uv, vec4 corners)\n{\n    float result = 0.0;\n    if (corners.r > 0.5) {\n        result = max(result, float(uv.x + uv.y <= 1.));\n    }\n    if (corners.g > 0.5) {\n        result = max(result, float(uv.x - uv.y <= 0.));\n    }\n    if (corners.b > 0.5) {\n        result = max(result, float(uv.x + uv.y >= 1.));\n    }\n    if (corners.a > 0.5) {\n        result = max(result, float(uv.y - uv.x <= 0.));\n    }\n    return vec3(result);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Square \"cover\"-style UV\n\tvec2 uv = (fragCoord.xy + vec2(0., (iResolution.x - iResolution.y)/2.)) / iResolution.x;\n    // UV within a tile\n    vec2 tileuv = fract(uv * SCREEN_TILES);\n    // Coordinate of the tile\n    ivec2 tileIdx = ivec2(uv * SCREEN_TILES);\n    vec2 tileIdxf = uv*SCREEN_TILES - tileuv;\n    \n    // Chooses which wang tile to draw\n    #if DEMO == DEMO_EDGE_COLORS\n    vec4 edges = edgeSample(tileIdxf);\n    vec3 wangcolor = wangEdgeColoredTriangle(tileuv, edges);\n    #elif DEMO == DEMO_EDGE_SHAPES\n    vec4 edges = edgeSample(tileIdxf);\n    vec3 wangcolor = wangEdgeDot(tileuv, edges);    \n    #elif DEMO == DEMO_CORNER_SHAPES\n    vec4 corners = cornerSample(tileIdxf);\n    vec3 wangcolor = wangCornerDot(tileuv, corners);\n    #endif\n  \n    fragColor = vec4(wangcolor, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}