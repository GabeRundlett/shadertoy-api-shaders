{
    "Shader": {
        "info": {
            "date": "1598443725",
            "description": "A simple polar weave pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ljfR1",
            "likes": 46,
            "name": "Polar Weave Pattern",
            "published": 3,
            "tags": [
                "2d",
                "repetition",
                "pattern",
                "polar",
                "weave"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 808
        },
        "renderpass": [
            {
                "code": "/*\n\n\tPolar Weave Pattern\n\t-------------------\n\n\tOne of my favorite nerd related hobbies is to recreate a simple \n    pattern I've come across on the internet. If I really feel like \n    geeking out, I'll render the exact pattern using several different \n    approaches. :)\n\t\n    Anyway, this particular pattern and its derivatives are all over \n    the net, and although I couldn't find any, there are probably \n    examples on here too. There are several ways to produce it. In this \n    case, I'm minimizing rendering calls by using a single pass repeat \n    polar approach, which means no neighboring cells need be considered. \n\n    It took me longer to put together than I anticipated, but the idea \n    is pretty simple: Partition space into repeat polar cells, then \n    render two circular arcs on each cell edge with radii such that \n    their edges completely overlap. This will result in what look like \n    a bunch of overlapping circles. The final step is to flip the \n    bottom half of each cell to produce a weave.\n\n\n\n    Related examples:\n\n    // When Fabrice first posted these, I wasted way too much\n    // time playing around with the code. :)\n    rosace 3c - FabriceNeyret2\n    https://www.shadertoy.com/view/Ms3SzB\n\n    // Related in the sense that it uses polar coordinates only,\n    // but it's really cool, so I included it anyway. :)\n    Rose - Dave_Hoskins\n    https://www.shadertoy.com/view/ldBGDh\n\n    // An unlisted bare bones polar coordinate example, for \n\t// anyone who's not quite sure how the polar thing works.\n    Polar Repetition - Shane\n\thttps://www.shadertoy.com/view/wdtGDM\n\n\n*/\n\n// Display the radial cell boundaries on the background.\n//#define SHOW_CELLS\n\n// Adds the weave effect: If you comment in the SHOW_CELLS define\n// above, then scroll down to the WEAVE define, you'll see that it \n// involves a very simple trick.\n#define WEAVE\n\n// Random ordering. I prefer the ordered look, but the option\n// is here to show it can be done. The pattern changes every two\n// seconds. By the way, this can occasionally produce discontinous\n// results when using odd cell numbers... which I'll fix later. \n//#define RANDOM_ORDER\n\n// Number of cells: Integers between 4 and 10 work. Beyond that,\n// some tweaking will be necessary. Interestingly, odd numbers will\n// produce a single weave, whereas even numbers will produce two\n// separate interlocked weaves.\n#define CELL_NUM 8.\n\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Hacky globals, put in as an afterthought. Struct containers are tidier, but \n// sometimes they can be even less readable. In addition, WebGL can throw all\n// kinds of errors when you're trying to used them inside raymarching loops,\n// which can be extra annoying.\n//\n// Anyway, there's an alternate cell variable and edge width. The vec2 is a \n// global local cell coordinate variable, which is kind of a contradiction \n// in terms. :)\nfloat gDir, gEw;\nvec2 gP;\n\nvec4 dist(vec2 p){\n    \n    // Rotation performed here.\n    p *= r2(-iTime/4.);\n    \n\t\n    // Polar angle.\n    float a = atan(p.y, p.x);\n    \n    // Number of cells.\n    const float aNum = CELL_NUM;\n    \n    // Partitioning the angle into \"aNum\" cells.\n    float ia = floor(a/6.2831853*aNum);\n \n    // Used to generate a random number for each cell, and consequently,\n    // a random rendering order.\n    float svIA = ia;\n    \n    // Variable to determine alternate cells... Only useful for even cell numbers.\n    float dir = mod(ia, 2.)<.5? -1. : 1.;\n    \n    \n    // Centering and converting back to radians... If you do this often enough,\n    // it'll become second nature.\n    ia = (ia + .5)/aNum*6.2831853;\n    \n    // Converting the radial centers to their positions.\n    p *= r2(ia);\n    // Above is equivalent to:\n    //p = vec2(p.x*cos(ia) + p.y*sin(ia), p.y*cos(ia) - p.x*sin(ia));\n\n    // Hacky global coordinate save.\n    gP = p;\n    \n    \n    // Producing the objects: In this case, two circles at the mid edges of each cell.\n\n    \n    // Setting the radial distance: We achive this by setting one of the polar \n    // coordinates to this value, which effectively moves the points out a bit along \n    // the radial line. If you didn't perform this, all objects would be superimposed \n    // on one another in the center. Repeat radial coordinates are possible too.\n    const float rad = .265;\n  \n    #ifdef WEAVE\n    // This is the trick you use to turn circles into a weave. It's very simple, but it\n    // took me a while to figure out. Simply reverse the rendering order of the circles\n    // on the bottom half of each cell. Just remember that the X and Y vector positions\n    // (selected members, or whatever they're called) represent the polar coordinates of \n    // the cell. The don't literally mean X and Y... I've been doing this stuff for years \n    // and I still make that mistake. :) Anyway, the easiest way to see how it works is\n    // to comment the line out, then comment it back in again.\n    //\n    // The halfway point on the cell edge occurs at the apothem, which is the radial\n    // distance multiplied by the cosine expression below... and I knew this because \n    // I'm a good guesser. :D Seriously though, look at the geometry of a regular \n    // polygon, and the following should make sense.\n    if(p.x<rad*cos(3.14159/aNum)) p.y = -p.y;  \n    #endif\n  \n    \n    // Far left and right sides of the cells. Each point is rotated back half a \n    // cell, then edged out by the radial distance... Polar coordinate stuff... You get \n    // used to it after a while... Kind of. :D\n    vec2 p1 = p*r2(-3.14159/aNum) - vec2(rad, 0);\n    vec2 p2 = p*r2(3.14159/aNum) - vec2(rad, 0);\n\n    \n    \n    // The arc radius should be half the cell width, or half the side length of the  \n    // regular polygon that the pattern is based on... I think this is right, but I was \n    // in a hurry, so if you have time, I'd double check it. It seems to work visually \n    // though, so that's a good sign. :)\n    float offs = rad*sin(3.14159/aNum);\n    \n    \n    // Two circles. We're rendering one over the other, so we need a distance for each.\n    vec2 d = vec2(length(p1), length(p2)) - offs;\n\n    // The polar angle for respective positions on each circle. If you're doing stuff\n    // with circles, you'll want angles. In this case, they're being used to light up\n    // different parts of the circles.\n    vec2 ang = vec2(atan(p1.y, p1.x), atan(p2.y, p2.x));\n    \n    // Turning circles into arcs -- It's a standard CSG move. The centeral arc line\n    // will occur at the original outer circle radius. Because of the absolute \n    // function, the width will be double, so you just halve what you want it to be.\n    const float ew = rad/2.; // Arc width. \n    d = abs(d) - ew/2.; // Arc.\n    \n    \n    #ifdef RANDOM_ORDER\n    // Random rendering order, arranged to change every two seconds.\n    if(fract(sin(svIA + floor(iTime/2. + 37.)*.083)*45758.5453)<.5) {\n        d = d.yx;\n        ang = ang.yx;\n    }\n    #endif\n\n    // Save the alternate cell and edge width for use outside the function.\n    gDir = dir;\n    gEw = ew;\n    \n    \n    // Returning the two arc distances and their respective angles.\n    return vec4(d, ang);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float iRes = iResolution.y; // min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iRes;\n \n   \n    // Scaling... Trivial in this case.\n    vec2 p = uv;\n    \n     // Falloff factor: Sometimes,  we might have to use \"fwidth(d),\" \n    // a numeric solution, or use a constant.\n    float sf = 2.5/iRes; \n    \n    // Taking two samples.\n    //\n    // Drop shadow fields and angles.\n    vec4 dSh = dist(p - normalize(vec2(-1.5, -1))*.03);\n    // Distance fields and angles.\n    vec4 d = dist(p);\n    \n    // Distance field angles.\n    vec2 ang = d.zw;\n    \n\n    // RENDERING \n    \n    // Producing two line patterns.\n    //\n    // Multiple dark lines for that cliche record look. The expression, \n    // \"abs(fract(x*N - shift) - .5),\" is a repeat triangle formula of sorts and \n    // useful when you want to produce repeat edge lines... There are heaps of \n    // other ways to produce concentric lines, but I find it's the most reliable.\n    //\n    const float lnN = 8.; // Number of concentric pattern lines.\n    vec2 pat = abs(fract(d.xy/gEw*lnN - .5) - .5)*2. - .07;\n    pat = smoothstep(0., sf/gEw*lnN, pat);\n    // The darkish outer arc lines.\n    vec2 pat2 = abs(fract(d.xy/gEw/2. - .5) - .5)*2. - 1./lnN;\n    pat2 = smoothstep(0., sf/gEw/2., pat2);\n    \n    // Lighting: Using the respective arc angles to add or take away light from\n    // the surface. The light and darker sections add to the illusion. The numbers\n    // themselves are a bit of science mixed in with trial and error.\n    vec2 shad;\n\tshad.x = clamp((cos(ang.x*1.8))*1.35, 0., 1.);\n\tshad.y = clamp((1. - cos(ang.y*1.6))*1.25, 1., 2.);\n    shad = shad*.5 + .5;\n  \n    \n    // Background: Very simple, but you can make it more elaborate.\n    vec3 bg = mix(vec3(1, .9, .5), vec3(1, .85, .8), uv.y*.5 + .5)*(1. - length(uv)*.35);\n    \n    \n    #ifdef SHOW_CELLS \n    // Display the radial cell boundaries on the background. Seeing each \n    // individual cell pattern can be helpful for debug purposes.\n    float ln = min(abs(r2(-3.14159/CELL_NUM)*gP).y, abs(r2(3.14159/CELL_NUM)*gP).y);\n    bg = mix(bg, bg*1.7, 1. - smoothstep(0., sf*CELL_NUM/6.2831, ln*CELL_NUM/6.2831 - .003));\n    bg = mix(bg, bg/12., 1. - smoothstep(0., sf*CELL_NUM/6.2831, ln*CELL_NUM/6.2831 - .0007));\n    // Alternate cell shading for even cell numbers. When the number is odd, alternate\n    // cell coloring doesn't really make sense.\n    if(mod(CELL_NUM, 2.)<.5 && gDir<0.) bg = mix(bg, bg.zzz, .25);\n    else bg = bg = mix(bg, bg.xxx, .25);\n    #endif \n    \n     \n    // Setting the scene color to that of the background.\n    vec3 col = bg;\n    \n    // Drop shadows and arc edge shadows for that fake ambient occlusion look\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(dSh.x, dSh.y)))*.25);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(d.x, d.y)))*.25);\n    \n    // The ring colors. We're using the same color for each, but different colors\n    // are possible.\n    vec3 col1 = vec3(.62, .6, .58);\n    vec3 col2 = col1;\n    \n    /*\n    // If using different ring colors, alternate cells need to be swapped, but\n    /// we're not, so it doesn't matter.\n    if(gDir<0.) {\n        vec3 tmp = col1; col1 = col2; col2 = tmp;\n    }\n    */\n    \n    // Applying the dark lines, edges lines and shading to each arc.\n    col1 *= (pat2.x*.3 + .7)*pat.x*shad.x;\n    col2 *= (pat2.y*.3 + .7)*pat.y*shad.y;\n    // Colored stripes, if you prefer.\n    //col1 *= mix(vec3(1), bg*vec3(1.1, 1, .9), 1. - pat2.x)*pat.x*shad.x;\n    //col2 *= mix(vec3(1), bg*vec3(1.1, 1, .9), 1. - pat2.y)*pat.y*shad.y;\n\n    \n    \n    // Rendering the bottom arc. Dark lines and color.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d.x));\n    col = mix(col, col1, 1. - smoothstep(0., sf, d.x + .0035));\n    \n    // Laying down some shadowing from the top arc onto the bottom one.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(d.y, d.x)))*.25);\n    \n    // Rendering the top arc. Dark lines and color.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d.y));\n    col = mix(col, col2, 1. - smoothstep(0., sf, d.y + .0035));\n    \n    \n    // Extra sutble gradient coloring.\n    //col = mix(col.yxz, col, uv.y*.5 + .5);\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}