{
    "Shader": {
        "info": {
            "date": "1696859094",
            "description": "Using a grid and very basic keyframing concepts to create a simple repetitive dot animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "msKcDV",
            "likes": 47,
            "name": "Simple Dot Animation",
            "published": 3,
            "tags": [
                "grid",
                "circle",
                "random",
                "animation",
                "motion",
                "tween",
                "keyframe"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 584
        },
        "renderpass": [
            {
                "code": "/*\n\n    Simple Dot Animation\n    --------------------\n    \n    As you can see, this is a very basic animation sequence. There's \n    nothing particularly original about it, since it can be found in \n    various forms all over the internet, but I thought it was fun to watch, \n    and would provide a way to give anyone not familiar with motion tweening \n    concepts a place to start.    \n    \n    I love those cute geometric keyframe-based animations that pop up all \n    over the internet, often in gif form. They exist on Shadertoy too, and\n    some are amazing, but they're not what I'd call common.\n    \n    I guess one of the reasons is that pixelshaders can be restrictive,\n    since there's generally no random pixel access and calculations occur \n    on a per-pixel basis. Basically pixelshaders are not really designed for \n    motion tweening. However, it's all pretty doable. This particular \n    animation didn't require too much effort at all.\n    \n    I remember back in the day when democoders finally started giving people \n    a look at the code magic behind the productions and I was amazed at how \n    simple the key framing component was: Divide time up into time blocks,\n    each with their own start and end node markers. Determine which time  \n    block you're in, set some start time entities (like position, color, \n    orientation, etc.), set the corresponding end time entities, interpolate \n    all entities over the block's time period, then proceed to the next time \n    block.\n    \n    Anyway, for this particular animation sequence, I'm breaking time into \n    three blocks, interpolating the object position between the first two, \n    then interpolating position and rotation on the last. The process is \n    repeated ad infinitum, and is all pretty straight forward. The details \n    can be found in the code below.\n    \n    The animation rendering itself was put together pretty quickly. This is\n    a 2D example, so speed wasn't really a consideration, but I did it in a\n    way that would allow me to extrude it at a later date. Therefore, there\n    are more than likely cleverer ways to render this, which I'll leave to \n    the code golfing crowd. :)\n    \n    \n    \n    Other examples:\n    \n    // Animated squares. 104 makes a lot of cool shaders. I've only \n    // skimmed the code, but I'm pretty sure this was created using \n    // similar principles.\n    90's Mirrored Squares - 104\n    https://www.shadertoy.com/view/3lBSzW\n    \n    \n    // You can't mention keyframes without referencing this one. \n    // Clever on so many levels.\n    [SH18] Human Document - reinder\n    https://www.shadertoy.com/view/XtcyW4\n\n*/\n\n// Showing the background grid pattern can spoil the illusion, but it\n// helps show how the animation is made.\n//#define GRID\n\n\n// Total running time, tmID, and time segment.\nfloat tmTotal, tmID, tmSeg;\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n \n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n \n\n// Animated dots.\nfloat dots(vec2 p, vec2 ip, vec2 sc){\n\n   \n    // Vertices: Clockwise from the bottom left. We're only using two\n    // of them, but I'm including the other two for completeness.\n    mat4x2 v = mat4x2(vec2(-1), vec2(-1, 1), vec2(1), vec2(1, -1));\n    // Mid edges corrsponding to the above.\n    mat4x2 e = mat4x2(vec2(-1, 0), vec2(0, 1), vec2(1, 0), vec2(0, -1));\n    \n     // Fractional time segment: Same as fract(tmTotal).\n    float fTm = tmTotal - tmID; // Range: [0. 1].\n    \n    // Using smoothstep to smoothly interpolate the time period between\n    // zero and one. You could also use any number of easing functions, \n    // but I'm trying to keep things simple. The following roughly\n    // emulates a fast-in-the-middle motion... Not the technical term. :D\n    fTm = smoothstep(.25, .75, fTm);\n   \n    \n    // Object position and direction.\n    vec2 pos = vec2(0), dir;\n    \n    // Object (dot) size. \n    float sz = .2*min(sc.x, sc.y);\n    \n    // The resultant field distance.\n    float d;\n    \n    \n    if(tmSeg<.001){\n    \n        // Verticle direction.\n        dir = vec2(0, 1);\n \n        \n        vec2 di;\n        // Left wall semi-circle moving up from v[0].\n        di.x = length(p - (v[0] + dir*fTm)*sc/2.) - sz;\n        di.x = max(di.x, -(p.x + sc.x/2.));\n        \n        // Right wall semi-circle moving down from v[2].\n        di.y = length(p - (v[2] - dir*fTm)*sc/2.) - sz;\n        di.y = max(di.y, (p.x - sc.x/2.));\n            \n            \n        d = min(di.x, di.y);\n \n     \n    }\n    else if(tmSeg<1.001){\n    \n        // Horizontal direction.\n        dir = vec2(1, 0);\n         \n        // Splitting a semi circle running between \n        // the left and right edge midpoints and\n        // moving them in opposite directions.\n        \n        vec2 di;\n        // Moving left from e[2].\n        di.x = length(p - (e[2] - dir*fTm)*sc/2.) - sz;\n        di.x = max(di.x, p.y);\n        \n        // Moving right from e[0].\n        di.y = length(p - (e[0] + dir*fTm)*sc/2.) - sz;\n        di.y = max(di.y, -p.y);\n            \n            \n        d = min(di.x, di.y);\n \n  \n    }\n    else {\n    \n        // Instead of rendering four quarter circles in the center then moving\n        // them to the corners, we're saving some rendering (kind of), but splitting\n        // the cell into four smaller cells, then rendering diagonally from the\n        // appropriate vertex to the opposite diagonal one.\n\n\n         // We've effectively split each cell into fours, so based on the cell\n         // ID, we need to determine which clockwise quadrant we're in.\n         vec2 mIP = mod(ip, 2.);\n         int j = mIP.x==0.? mIP.y==0.? 0 : 1 : mIP.y==0.? 3 : 2;\n\n         // Starting vertex and ending vertex.\n         pos = mix(v[(j + 2)&3], v[j], fTm); \n         // The diagonal direction vector.\n         dir = (v[(j + 2)&3] - v[j]);\n\n         // Interpolating a half spin over time.\n         mat2 m2 = rot2(mix(0., 3.14159, fTm));\n\n         // Moving a square (the same size as the dot) to the dot's central\n         // point, rotating it about that point according to the rotational \n         // factor, then moving the edges to the dot center to create a rotating\n         // quarter circle... Yeah, transformations can get a little confusing,\n         // but they're not hard to learn, and you get better with practice.\n         vec2 q = abs(m2*(p - pos*sc/2.) + sign(dir)*sz) - sz;\n         float bound = max(q.x, q.y); // Bounding square.\n          \n         // The object position itself.\n         float di = length(p - pos*sc/2.) - sz*2.;\n         di = max(di, bound); // CSG with the bound to form a quarter circle.\n         d = di; // Setting as the distance.\n     \n    }\n    \n\n    \n    return d;\n}\n\nvoid mainImage( out vec4 o, in vec2 p){\n \n    // Coordinates: They're already in aspect correct form, so a \n    // simple translation and scaling is all that is necessary.\n    p = (p - iResolution.xy*.5)/iResolution.y; \n    \n    vec2 op = p;\n    \n    // Last minute subtle plane warping.\n    p *= .95 + length(p)*.1;\n    // Screen rotation. I liked this angle, but you could choose another.\n    p = rot2(3.14159/6.)*(p - vec2(2, 1)*iTime/60.);\n   \n    \n    \n    // Obviously, timing is important in keyframing. This breaks time into\n    // three equal segments lasting 1.5 seconds each.\n    tmTotal = iTime/1.5; \n    tmID = floor(tmTotal);\n    tmSeg = mod(tmID, 3.);\n    \n    // Grid scale: I've set it to squares, but rectangles work too. \n    vec2 sc0 = vec2(1)/6.;\n    vec2 sc = tmSeg<1.01? sc0 : sc0/2.;\n    \n    \n    // A gradient background.\n    vec3 c = mix(vec3(1, .7, .3), vec3(1, .8, .2), op.y + .5);\n    #ifdef GRID \n    float rnd = hash21(floor(p/sc0));\n    vec3 bCol = .5 + .45*cos(6.2831*rnd - op.y/2. + vec3(0, 1, 2));\n    float ch = mod(dot(floor(p/sc0*2.), vec2(1)), 2.)<.5? -.1 : .1;\n    c = mix(c, max(bCol + ch, 0.), .5);\n    #endif \n    \n    \n    // Grid distance and shadow.\n    float d = 1e5, dSh = 1e5;\n    \n    // Light direction: Used to cast shadows.\n    vec2 ld = rot2(3.14159/6.)*vec2(-1);\n    \n    // Rendering the grid: Some of the objects move slightly outside the\n    // cell bounds and into the neighboring cells, which means you need\n    // to render the neighbors also. The following is a standard way to \n    // do that.\n    for(int i = 0; i<4; i++){\n        \n        // Neighbor offset.\n        vec2 offs = vec2(i&1, i/2) - .5;\n\n        // Grid partitioning -- ID and local coordinates.\n        vec2 q = p;\n        vec2 iq = floor(q/sc + offs);\n        q -= (iq + .5)*sc;\n\n        // The dot field and shadow field.\n        d = min(d, dots(q, iq, sc));\n        dSh = min(dSh, dots(q - ld*.015, iq, sc));\n    }\n    \n    // Smoothing factor.\n    float sf = 1.5/iResolution.y;\n    \n    \n    // Shadow, edge and face color.\n    vec3 svC = mix(c*.2, vec3(.14), .75);\n    c = mix(c, vec3(0), (1. - smoothstep(0., sf*2., dSh - .007))*.5);\n    c = mix(c, vec3(0), 1. - smoothstep(0., sf, d - .007));\n    c = mix(c, vec3(.14)*0. + svC, 1. - smoothstep(0., sf, d));\n\n    // Rough gamma correction.\n    o = vec4(sqrt(max(c, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}