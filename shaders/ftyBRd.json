{
    "Shader": {
        "info": {
            "date": "1665000938",
            "description": "An [b]approximated[/b] distance to an helix. Another weekend I'll try getting the exact one based on [url=https://www.shadertoy.com/view/3t23WG]3t23WG[/url] perhaps. Credits to tdhooper for the concept. This version has a lot less math, so it's faster.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftyBRd",
            "likes": 42,
            "name": "Helix - distance (APPROXIMATED)",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "distance"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1623
        },
        "renderpass": [
            {
                "code": "// Inigo Quilez 2022\n\n// Based on the same concept as https://www.shadertoy.com/view/tt2Xzc\n// so credits to him. However, this implementation uses less space\n// transformations, which means no trigonoemtrics and no square roots\n// (but the last measure of course), among other things.\n//\n// IT IS NOT AN EXACT SDF, please don't use in production. I'll try\n// implementing an exact SDF some other weekend.\n//\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\nfloat sdHelix( in vec3 p, float fr, float r1, float r2 )\n{\n    vec2  nline = vec2(fr, 6.283185*r1 );\n    vec2  pline = vec2(nline.y, -nline.x);\n    float repeat = nline.x*nline.y;\n\n    vec2  pc = vec2(p.x,r1*atan(p.y,p.z));              // to cylindrical\n\n    vec2  pp = vec2( dot(pc,pline),                     // project to line\n                     dot(pc,nline));\n    \n    pp.x = round(pp.x/repeat)*repeat;                   // repeat in x\n\n    vec2 qc = (nline*pp.y+pline*pp.x)/dot(nline,nline); // un project to cylindrical\n    qc.y /= r1;\n    \n    vec3 q = vec3(qc.x, sin(qc.y)*r1, cos(qc.y)*r1 );   // to cartesian\n        \n    return length(p-q)-r2;\n}\n\nfloat map( in vec3 pos )\n{\n    float fr = 1.0 - 0.5*cos(6.283185*iTime/6.0);\n    float r1 = 0.4;\n    float r2 = 0.1;\n\n    return sdHelix(pos,fr,r1,r2) - 0.0001;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n   \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 1.0 + 0.0*iTime;\n\tvec3 ro = vec3( 1.5*cos(an), 0.4, 1.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 13.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( abs(h)<0.0001 || t>tmax ) break;\n            t += h*0.75;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}