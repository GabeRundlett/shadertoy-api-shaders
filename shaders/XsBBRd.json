{
    "Shader": {
        "info": {
            "date": "1501610182",
            "description": "arrow shape.\nwhere you click sets the tips size and the handle-roundness\ndrag mouse to change handle size.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XsBBRd",
            "likes": 3,
            "name": "superprim arrow fast",
            "published": 3,
            "tags": [
                "arrow",
                "shape",
                "stretch",
                "superprim",
                "bisymmetry",
                "modem",
                "context",
                "realradicals",
                "mstretch"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 792
        },
        "renderpass": [
            {
                "code": "/*\narrow-shaped distance field:\niMouse.xyzw is used to set 4 parameters of this \"superprim\", which is not too user friendly:\n- where you click sets roundness of the handle and the size of the tip.\n- dragging the mouse sets size   of the handle.\n\nThe tip is calculaed without cos() or atan() or normalize(), by using a single dot() and\nhttps://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n\nwith 2 sqrt(const) that are also useful for other things and worth buffering at some point.\n\nit is not too user friendly in its parameter parsing, because it is made for performance.\nthe handle distance field is not too defined for its interior.\nthe handles distance field has 3 better solutions here\nhttps://www.shadertoy.com/view/ldjBRV\nbut for performance, the one used here is good enough for most cases;\n... as long as (sqrt(2)*roundness>=epsilonForNormalGradientCalculation) this should be good enough,\n... and that min() is easily set.\n\n*/\n\n\n\n\n/*\nil d vague abstract concept, please ignore.\n\nthe BISYMETRY PRINCIPLE:\n- utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - In a quest to increase symmetry for performance and modular shaders.\n- Only write atomic special cases and transformations, \n- ...to construct general functions from.\n- Instead of writing a general function, \n- ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- this way general functions can be made into special \"shortcut\" functions more easily.\n- this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- this whole structure screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this structure more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\"\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n\n------------\n\n[envelope]s and [window function]s and [Passband]s are pretty much mean the same to me now.\ni just lack a noun for min||max([window function],[envelope]) that is not [MoDem] or [context]\nhttps://en.wikipedia.org/wiki/Context_(computing)\nhttps://en.wikipedia.org/wiki/Modulation\nFor a lack of a better term, the terms I use are knowinggly fuzzy.\n\nthey come down to y=f(x) that often are only, or especially \n...focused on (inout) ranges [-.5..+.5] to [-3.14..+3.14]\n...while their parameters (like uv or scaling) are any range.\n\n[window function]s \n- tend to have smoother derivatives, nicer Local Lipschitz Constants. they include \n- https://en.wikipedia.org/wiki/Window_function\n[envelope]s tend to be more symmetric and opften less less continuous. they include \n- https://en.wikipedia.org/wiki/Envelope_(waves)\n- where continuity is easily broken due to Fourier Transform (of a square,triangle,seesaw wave)\n-\n- means envelopeD(log(envelopeE())), for lack of a better term.\n- ... where envelopeA()=envelopeB(envelopeC())\n- does not mean \n- https://en.wikipedia.org/wiki/Envelope_(mathematics)\n*/\n\n/*\nnotes to self, for improvement:\nuse #define to take a domain (x,y, z or w) as function parameter \nyour #define basically defines patterns over single domains, \nand their context lies on how these \n#defines are utilized min() mic() smin() swiveled or otherwise transformed.\n\n\nthe comments of\nhttps://www.shadertoy.com/view/MdSfzt\nare all about \n- line breaks in a define\n- using a buffer texture and a single define to display a string.\nthis is a current process...\n*/\n\n//sharpness of FullScreenAntiAliasing\n#define fsaa 5./iResolution.y\n//maximum view zoom\n#define viewZoom 20.\n\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n//3.14=ratio of unitCircleCircumference to diameter=\n#define pi acos(-1.)\n//0.61=golden ratio; phi-1=1/phi,smaller solution\n#define phi (sqrt(5.)*.5-.5)\n//1.61=Golden Ratio; Phi-1=1/Phi,larger  solution\n#define Phi (sqrt(5.)*.5+.5)\n\n//modulo tiled grid.\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));                   \n u.x*=u.x;return u.x*u.x;}\n\nfloat sawCos(vec2 u){//u*=2.;//sale here, or better outside of this function.\n u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c) with a hint of s, diminishing over c.\n#define sci() mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//use a matrix as if it is a list.\nfloat gm3(mat3 a,int n){return a[n/3][n%3];}\n//return a[int(n/3.)][int(mod(n,3.))];}//float variant\n#define gp(a) gm3(co,a)\n\n//vector dotproduct with vecN(1) is a faster sum.\n//float sum(float a,float b,float c,float d){return dot(vec4(a,b,c,d),vec4(1.));}\n//float sum(float a,float b,float c){return dot(vec3(a,b,c),vec3(1.));}\n\n/*\n//just some demo y=f(x) functions\nfloat fx(vec2 u,vec2 m){\n float x=u.x;\n float logE = log(x);\n float expE = exp(x);\n float pow3 = (x*1.)*(x*x);\n float pow4 = (x*x )*(x*x);\n mat3 co=mat3(-10,8,-6,5,-6,4,-7,-2,1);//9 coeficients to a polynomial should be enough\n //co=1.co; //reciprocal coeficcients\n //co*=.1;//smaller coefficients\n //float polyn=x*gm3(co,0)-u.y;\n   \n float polyn=x*(gp(0)+x*(x*(gp(1)+x*(x*(gp(2)+x*(x*(gp(3)+x*gp(4)+x*(gp(5)))))))));\n float cosine=cos(x*.1)*10.;//a large amplitude large interval cosine.\n x*=.1;\n float fourier=cos(x*gp(0))\n              +cos(x*gp(1)*2.)\n              +cos(x*gp(2)*3.)\n              +cos(x*gp(3)*5.)\n              +cos(x*gp(4)*7.)\n              +cos(x*gp(5)*13.);//cosines, scaled by primes.\n    \n //return fourier;\n \n //return cosine;\n //return logE; //makes negative blue green, i see no way to cath this NaN\n return fourier+cosine+x*x;\n}\n/**/\n\n//m.y sets zoom (makes sense for waveforms)\n//length sets zoom\n//#define scaledot(u) length(m)*u\n//length*length sets zoom, for EXTREME zoom out\n//#define scaledot(u) dot(m,m)*u\n//near main axes, zoom in\n//#define scaledot(u) min(abs(m.x),abs(m.y)   )*u\n//mix of axial distances sets zoom\n//#define scaledot(u) mix(abs(m.x),abs(m.y),.5)*u\n#define scaledot(u) u=min(abs(m.x),abs(m.y))*u\n\n/*\nfloat mStretch(float u,vec2 m){\n m.y=0.;\n float b=.5*sign(u)*m.x;\n float c=(sign(abs(u)-m.x));\n u*=-.5;\n return b+c*(b+u)+u*2.*m.y/m.x+u;\n //if(abs(u.x)>m.x)return -u.x+m.x*sign(u.x);return 0.; //branching variant can be faster\n}*/\n\n\n//float mStretch(float u,float m){return .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.);}\n\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n\n//return distance to infinite line segment\n//float ils(vec2 u,vec4 m){if(0.<u.x)return u.y;return length(u);}\n//is not too useful for this shape, just a bit too dirty.\n\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u, vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n//return distance to 1/24th rotated axis\nfloat r12(vec2 u){\n const float s2=sqrt(2.), s6=sqrt(6.);\n //extreme un-pointy: return dot(u,vec2(s6+s2,s6-s2)*.25)\n return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n\nfloat arrow(vec2 u,vec4 m){\n u.y*=sign(u.y);\n //if(u.y>m.x) return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n m.z*=.25;\n m.zw=abs(m.zw);\n //vec2 d=vec2(1,-sqrt(2.))*.5; //12th rotation\n float a=r12(u)-m.z;            //24th rotation\n a=max(a,-u.x);\n u.y=-mStretchP(u.y,m.y);  \n u.x=-mStretchM(u.x,m.x); \n //u.x=mStretchP(u.x,-m.x);\n float b=length(u)-m.w;\n\n\n a=min(a,b);\n\n //return c;\n //a=min(a,c);\n return a;\n}\n\nfloat mouseNeg(float c,float m){return sign(c)*min(m,abs(c));}\n//mix c and m where m is a disturbing distance field [m]  as \"mouse pointer\" in field [c]\nfloat mouseDif(float c,float m){//return sign(c)*max(-sign(c)*c,m);//alternative to below\n //return min(c*sign(m),m);//shorter variant of below\n float s=sign(m)*c;m-=s;return s+.5*(m-abs(m));}\n\nvec3 co(vec2 u){\n vec4 m=vec4(fr(iMouse.xy),fr(iMouse.zw));u=fr(u);//put vec2(0) in the center of the view, adjust for aspect ratio.\n m.w=abs(m.w*.5);//scaling mouse input for this one\n if(iMouse.z<0.)\n m=vec4(sin(iTime*acos(0.))*2.+2.//length.x of handle\n       ,cos(iTime)            +1.//length.y of handle\n       ,sin(iTime)            +4.//size of the tip\n       ,cos(iTime*.61)*.2     +.2//roundness of handle\n       )*3.;\n//   else m=fr(iMouse.xy);\n //scaledot(u);scaledot(m);//scale view, depending on m\n //u+=m;m+=m;//move view center away from vec2(0)\n vec3 c;//color composition\n c.r=arrow(u,m);//distance field at u, set by parameters m\n\n //c.r=circleStretch(u,m);//distance field at u, set by parameters m\n //c.r=analstretching(u.xy,m.xy).x-u.y;\n \n float d=sin(iTime)*.5+.5;\n //if (sign(c.r)>sign(cur))c.r=-c.r;\n float mo=length(u-m.zw);//distance to mouse cursor\n //float e=length(u-m.zw)-1.;//distance to where mouse was pushed down\n //c.r=min(c.r,e);\n    \n      \n //c.r=mouseDif(c.r,mo);\n //c.r=mouseNeg(c.r,mo);\n //c.r=mouseDif(mouseNeg(c.r,mo),mo);\n //c.r=mouseNeg(mouseDif(c.r,mo),mo);\n //c.r=mix(mouseDif(c.r,mo),mouseNeg(c.r,mo),.5);\n c.bg=u;//making x-axis green comes naturally\n c=sawCos3(c,.9);//smoothest gradient visualization so far\n c.gb+=vec2(sawCos(length(u),.5)*.003);//show circles around (0,0)\n \n //the color mix below usually looks nice, \n //but hues cyclically bleed into another, causing some optical illusions if one domain is very low\n //it also means if any domain is NaN, it becomes 0.\n if(isnan(c.r))c.r=0.;//projecting NaN to 0.\n if(isnan(c.b))c.b=0.;//projecting NaN to 0.\n if(isnan(c.g))c.g=0.;//projecting NaN to 0.\n c=sqrt(c);//more evenly gamma correcting\n c=max(vec3(0),c);\n return c*.5+c.yzx*.25;}\n \n \n\nvoid mainImage( out vec4 o, in vec2 u ){\n    o=vec4(co(u),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}