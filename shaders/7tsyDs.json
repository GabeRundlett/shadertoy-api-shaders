{
    "Shader": {
        "info": {
            "date": "1649068077",
            "description": "nice right?\n\nplease teach me how to do this with domain bending and not in cycles\n\nalso code is not cleaned up",
            "flags": 0,
            "hasliked": 0,
            "id": "7tsyDs",
            "likes": 20,
            "name": "nice flowers",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "sdf",
                "tutorial",
                "tutorial",
                "youtube",
                "live",
                "live",
                "maths",
                "stream",
                "livestream"
            ],
            "usePreview": 1,
            "username": "curiouspers",
            "viewed": 556
        },
        "renderpass": [
            {
                "code": "// Fork of \"TUT  Sphere Gears\" by iq. https://www.shadertoy.com/view/tt2XzG\n// 2022-04-03 09:00:38\n\n// Created by curiouspers - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Part 1: https://www.youtube.com/watch?v=sl9x19EnKng\n// Part 2: https://www.youtube.com/watch?v=bdICU2uvOdU\n\n\n#define AA 1  // Set AA to 2 if you have 3090ti and 720p display\n\n#define TAU 6.283185\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}  \n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad )\n{\n    ro -= cen;\n    float b = dot(rd, ro);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if ( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    \n    return vec2( -b-h, -b+h );\n}\n             \n             \n//----------------------------------\n\n\nvec2 rot( vec2 v )\n{\n    return vec2(v.x-v.y,v.y+v.x)*0.707107;\n}\n\nfloat remap(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec4 flower( in vec3 p, float time, float mat, float segments, vec3 rotation, float ra1, float rb, float h )\n{\n    \n    //p = fract(p*0.02);\n    vec4 d = vec4(1.);\n    float t = time;\n    \n    //float segments = 8.;\n    p.yz *= Rot(rotation.x);\n    p.xz *= Rot(rotation.y);\n    p.xy *= Rot(rotation.z);\n    \n    // please teach me how to do this with domain bending and not in cycles\n    float leafsPeriod = TAU/32.;\n    for (float j = 0.; j < 1.; j += 1./segments){\n        t+=j*0.5;\n        vec3 ppp = p;\n        ppp.xz *= Rot(j*TAU);\n        ppp.x -= 0.2;\n        //float leaf = 0.;\n        for (float i = leafsPeriod*1.; i < TAU/2.6; i += leafsPeriod){\n            //leaf++;\n            vec3 pp = ppp;\n            //pp.yz *= Rot((i+1.) * .1);\n\n            pp.xy *= Rot(i );\n            //pp.xy *= Rot(0.1);\n            pp.xy *= Rot(fract(t)*leafsPeriod);\n\n            float ra = ra1;\n            \n            //ra = sin(t*0.)*ra*0.5 + 0.6*ra;\n            //float tt = abs(fract(t*1.)*2.-1.);\n            //ra += tt*ra*i;\n            //ra += ra*i;\n            \n            pp.x += ra+0.1;\n            //pp.y -= 0.03*i;\n            pp.x += pow(abs(pp.z),1.5); // bend the leaf at center\n            pp.xy *= Rot(0.9);\n\n            //float halfWay = TAU/2.5/2.;\n            //float cur = i / halfWay;\n            //float inc = (i < halfWay) ? ra*0.25 : -ra*0.25;\n            float inc = ra*1.25 ;\n            ra = ra + mix(i*inc, (i+leafsPeriod)*inc, fract(t));\n            //ra = ra<0.08 ? ra : mix(ra, 0.04*(i+leafsPeriod), fract(t)); // try to shrinj last leafs\n            //ra = ra<0.08 ? 0. : ra;\n            \n            //ra = ra + mix(leaf*inc, (leaf+1.)*inc, fract(t)*leafsPeriod);\n            pp.x += mix(i*inc*2., (i+leafsPeriod)*inc*2., fract(t));\n            \n            //pp.y += (1.-i)*0.1;\n\n            //pp.y += fract(t);\n            //pp.x += t;\n            pp.x *= 0.45;\n            \n            //float r1 = 0.003;\n            //float r2 = 0.008;\n            //float rb = r1;//mix(r1, r2, fract(t) * i / TAU);\n            //float h = 0.001;\n            d = min(d, vec4(sdRoundedCylinder(pp, ra, rb, h), vec3(1.)));\n        }\n    }\n    d.w = mat;\n    return d;\n}\nvec4 map( in vec3 p, float time )\n{\n    time *= .75;\n    vec3 p1 = p+vec3(0.18, 0.19, -0.8);\n    vec4 d = flower(p1, time, 1., 8., vec3(0.0,0.2,0.), 0.025, 0.003, 0.001);\n    \n    p1 = p+vec3(0.98,0.35,0.50);\n    vec4 t = flower(p1, 1.-time, 2., 6., vec3(-0.32,0.12,0.2), 0.04, 0.009, 0.001);\n    if( t.x<d.x ) d=t;\n    \n    //p *= 0.7;\n    p1 = p+vec3(-0.83,0.25,0.1);\n    t = flower(p1, 1.-time, 3., 9., vec3(-0.2,-0.10,-0.3), 0.025, 0.01, 0.000);\n    if( t.x<d.x ) d=t;\n    \n\treturn d;\n}\n\n#define ZERO min(iFrame,0)\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float time )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, time ).x );\n#else\n    // klems's trick to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    vec2 vol = iSphere( ro, rd, vec3(0., 0., 0.), 1.9);\n    if ( vol.y > 0.0)\n    {\n        // raymarch\n        float t = max(0.0,vol.x);\n        for( int i=0; i<128 && t<vol.y; i++ )\n        {\n            vec4 h = map(ro+t*rd,time);\n            if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5+0.5*sin(fragCoord.x*111.0)*sin(fragCoord.y*331.543);\n        float time = iTime - 1.0*(1.0/48.0)*(float(m*AA+n)+d)/float(AA*AA);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n        time *= 0.5;\n        \n\t    // camera\t\n        //float an = 6.2831*time/40.0;\n        //vec3 ta = vec3( 0.0+cos(time*2.12)*0.03, cos(time*2.23)*0.05, cos(time*3.8)*0.03 );\n        //vec3 ro = ta + vec3( 1.3*cos(an), 0.5, 1.2*sin(an) );\n        //vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        //vec3 ro = ta + vec3( 0.00, 0.8, 1.2 );\n        vec3 ta = vec3(0.);//vec3( 0.0+cos(time*2.12)*0.005, cos(time*2.23)*0.005, cos(time*3.8)*0.005 );\n        // good camera angle\n        vec3 ro = ta + vec3( 0.1, 0.8, 1.2 );\n        //vec3 ro = ta + vec3( 0.5, 1.3, 1. );\n        \n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n        \n        // background\n        vec3 col = vec3(.92+rd.y)*0.8;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n            \n            #if 1\n            vec3 te = 0.5*texture( iChannel0, tuvw.yz*2.0 ).xyz+\n                      0.5*texture( iChannel0, tuvw.yw*1.0 ).xyz;\n            vec3 mate = 0.92*te;\n            #else\n            vec3 mate = vec3(1.);\n            #endif\n            \n            if (tuvw.w < 2.){\n                //mate =  tuvw.xyz*1.3-vec3(0.3,0.0,0.0);//tuvw.xyz;//vec3(1.000,1.000,1.000); // vec3(0.996,0.498,0.282);\n                // purple - dark blue\n                mate *= mix (vec3(0.3,0.0,0.0),vec3(1.,1.,0.6), tuvw.xyz-vec3(0.8,0.9,0.)) * 4.;\n            } else if (tuvw.w < 3.){\n                // golden - green\n                mate *= mix (vec3(0.3,0.03,0.0),vec3(1.,1.,0.0), tuvw.xyz-vec3(0.5,0.9,0.)) * 4.5 + .2;\n            } else if (tuvw.w < 4.){\n                // light blue\n                //mate = mix (vec3(0.1,0.03,0.2),vec3(0.0,2.,1.0), tuvw.xyz-vec3(1.0,0.7,0.0)) * 1.9;\n                // red velvet\n                mate *= mix (vec3(1.000,1.000,.0),vec3(1.500,0.1,0.1), tuvw.xyz-vec3(0.0,0.,0.0)) * 4.;\n            }\n            float len = length(pos);\n            // coloring center\n            //mate = mix( mate, vec3(1.0,.4,.2), 1.0-smoothstep(0.12,0.123,len) );\n            \n            \n            vec3 f0 = mate;\n            float ks = 0.5;//clamp(0.5+1.5*te.x, 0.0, 1.0);\n\n            float focc = 1.0;\n            focc = 0.55+0.45*dot( nor, normalize(pos) );\n            focc *= 0.1+0.9*clamp(length(pos)/0.535,0.0,1.0);\n            \n            float occ = calcAO( pos, nor, time ) * focc;\n            \n            #if 0\n                float li1 = 0.5+0.5*nor.y;\n                col = 10.0*li1*mate*occ;\n            #else\n                col = vec3(0.0);\n            #endif\n            \n            // top light\n            {\n                float dif = 0.5+0.5*nor.y;//clamp(\n                //dif *= occ;\n                \n                vec3 ref = reflect(rd, nor);\n                \n                vec3 spe = vec3(1.)*smoothstep(0.5*sqrt(sqrt(focc)),0.9,ref.y);\n                spe *= occ;\n                \n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                spe *= f0 + (1.0-f0)*pow(fre,1.0);\n                spe *= 6.0;\n                \n                //vec3 lcol = vec3(0.7, 0.8, 1.1);\n                vec3 lcol = vec3(1.);\n                \n                col += 0.05*lcol*dif*occ;\n                col += ks*lcol*spe*dif;\n                \n            }\n           \n            // bottom light\n            {\n                float dif = clamp( 0.5-0.5*nor.y, 0.0, 1.0 );\n                col += mate*dif*occ*2.*vec3(3.);//*vec3(0.7, 0.8, 1.1);\n            }\n           \n        }\n        \n        // vignette\n        col *= 1.0 - 0.2*dot(p,p);\n        \n        // gamma        \n\t    tot += pow(col,vec3(0.35) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    // S-curve\n    tot = clamp(tot, 0.0, 1.0);\n    //tot = tot*tot*(3.0-2.0*tot); // same as below\n    tot = smoothstep(0.0,1.0,tot); // make it more contrasty\n    \n    // dither\n    tot += (1.0/512.0)*sin(fragCoord.x*111.0)*sin(fragCoord.y*321.5423);\n    \n    // show banding\n    //tot = floor(tot*255.)/255.;\n    //tot = (abs(dFdy(tot))+abs(dFdx(tot)))*200.0;\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}