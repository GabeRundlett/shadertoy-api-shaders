{
    "Shader": {
        "info": {
            "date": "1582473334",
            "description": "G is for goals(not Google :))",
            "flags": 0,
            "hasliked": 0,
            "id": "3tGSWR",
            "likes": 26,
            "name": "G is for goals",
            "published": 3,
            "tags": [
                "glow",
                "neon",
                "goals",
                "gtd"
            ],
            "usePreview": 0,
            "username": "indigoabstract",
            "viewed": 1585
        },
        "renderpass": [
            {
                "code": "// adapted from the beautiful shader \"NEON LOVE\" by alro\n// https://www.shadertoy.com/view/WdK3Dz\n#ifdef GL_ES\n\tprecision highp float;\n#endif\n\nconst int i1_point_count = 50;\nvec2 v2_points[i1_point_count];\n\nconst float v1_folded_duration_secs = 2.0;\nconst float v1_unfolding_duration_secs = 4.5;\nconst float v1_unfolding_start_secs = v1_folded_duration_secs;\nconst float v1_blink_duration_secs = 0.7;\nconst float v1_blink_start_secs = v1_unfolding_start_secs + v1_unfolding_duration_secs;\nconst float v1_unfolded_duration_secs = 4.5;\nconst float v1_unfolded_start_secs = v1_blink_start_secs + v1_blink_duration_secs;\nconst float v1_folding_duration_secs = v1_unfolding_duration_secs;\nconst float v1_folding_start_secs = v1_unfolded_start_secs + v1_unfolded_duration_secs;\nconst float v1_cycle_duration_secs = v1_folding_start_secs + v1_folding_duration_secs;\n\nconst float v1_pi_rad = 3.14159265;\nconst float v1_two_pi_rad = 6.28318531;\nconst float v1_cirle_start_offset_rad = v1_pi_rad / 4.;\nconst float v1_circle_scale = 16.0;\nconst float v1_seg_length = 0.1455;\nconst float v1_scale = 0.012;\n\n\n// https://www.shadertoy.com/view/MlKcDD\n// Signed distance to a quadratic bezier\nfloat sd_bezier(vec2 v2_pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - v2_pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0)\n\t{ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n\telse\n\t{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\nvec2 get_obj_pos(float i_v1_pos, float i_curve_length)\n{\n\tif(i_curve_length > v1_two_pi_rad - v1_cirle_start_offset_rad)\n\t{\n\t\treturn -v1_circle_scale * vec2(cos(i_v1_pos), 0.);\n\t}\n\t\n    return -v1_circle_scale * vec2(cos(i_v1_pos), sin(i_v1_pos));\n}\n\nfloat get_segment(int i1_crt_point_count, float i_v1_mixf, vec2 v2_pos, float i_v1_offset)\n{\n\tfor(int i = 0; i < i1_crt_point_count; i++)\n\t{\n\t\tfloat v1_curve_length = float(i) * v1_seg_length;\n\t\tfloat v1_pos = i_v1_offset + v1_curve_length;\n        v2_points[i] = get_obj_pos(v1_pos, v1_curve_length);\n    }\n    \n    vec2 c = (v2_points[0] + v2_points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat dist = 10000.0;\n\tfloat prev_dist = dist;\n    \n    for(int i = 0; i < i1_crt_point_count - 1; i++)\n\t{\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n\t\tprev_dist = dist;\n        c = (v2_points[i] + v2_points[i + 1]) / 2.;\n        dist = min(dist, sd_bezier(v2_pos, v1_scale * c_prev, v1_scale * v2_points[i], v1_scale * c));\n    }\n\t\n\tif(i1_crt_point_count > 1)\n\t{\n        c = mix(v2_points[i1_crt_point_count - 2], v2_points[i1_crt_point_count - 1], i_v1_mixf);\n        dist = min(prev_dist, sd_bezier(v2_pos, v1_scale * c_prev, v1_scale * v2_points[i1_crt_point_count - 2], v1_scale * c));\n\t}\n\t\n    return max(0.0, dist);\n}\n\nvec3 get_color(int i1_crt_point_count, float i_v1_mixf, vec2 i_v2_pos)\n{\n\tfloat dist = get_segment(i1_crt_point_count, i_v1_mixf, i_v2_pos, v1_cirle_start_offset_rad);\n\tfloat intensity = 0.9;\n\tfloat radius = 0.025;\n\t// https://www.shadertoy.com/view/3s3GDn\n\tfloat v1_glow = pow(radius / dist, intensity);\n\t//float v1_glow_2 = pow(0.004525 / dist, 1.9);\n\tvec3 v3_color = vec3(0.0);\n\t// white core\n\tv3_color += 10.0 * vec3(smoothstep(0.006, 0.003, dist * 7.));\n\t// glow\n\tv3_color += v1_glow * vec3(0.05, 0.35, 1.0);\n\t//v3_color += v1_glow_2 * vec3(0.05, 0.135, 1.0);\n\t\t\n\t// tone mapping\n\tv3_color = 1.0 - exp(-v3_color);\n\t\n\treturn v3_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 v2_uv = fragCoord/iResolution.xy;\n    float v1_aspect_ratio = iResolution.x/iResolution.y;\n    vec2 v2_origin = vec2(0.5);\n    vec2 v2_pos = v2_origin - v2_uv;\n    v2_pos.y /= v1_aspect_ratio;\n    float v1_time_secs = mod(iTime, v1_cycle_duration_secs);\n\tvec3 v3_color = vec3(0.0);\n    \n\t//v3_color = get_color(i1_point_count, 0.5, v2_pos); if(false)\n\tif(true)\n\t{\n\t\t// folded phase\n\t\tif(v1_time_secs < v1_unfolding_start_secs)\n\t\t{\n\t\t}\n\t\t// unfolding phase\n\t\telse if(v1_time_secs < v1_blink_start_secs)\n\t\t{\n\t\t\tfloat v1_t = v1_time_secs - v1_folded_duration_secs;\n\t\t\tfloat v1_pc = (float(i1_point_count) * v1_t) / v1_unfolding_duration_secs;\n\t\t\tfloat v1_mixf = fract(v1_pc);\n\t\t\tint i1_crt_point_count = int(min(floor(v1_pc), float(i1_point_count)));\n\t\t\t\n\t\t\tv3_color = get_color(i1_crt_point_count, v1_mixf, v2_pos);\n\t\t}\n\t\t// blink phase\n\t\telse if(v1_time_secs < v1_unfolded_start_secs)\n\t\t{\n\t\t\tfloat v1_delta = v1_time_secs - v1_blink_start_secs;\n\t\t\t\n\t\t\tif(v1_delta < 2.0 * v1_blink_duration_secs / 4.0)\n\t\t\t{\n\t\t\t\tv3_color = get_color(i1_point_count, 0.5, v2_pos);\n\t\t\t}\n\t\t\telse if(v1_delta < 2.5 * v1_blink_duration_secs / 4.0)\n\t\t\t{\n\t\t\t}\n\t\t\telse if(v1_delta < 3.5 * v1_blink_duration_secs / 4.0)\n\t\t\t{\n\t\t\t\tv3_color = get_color(i1_point_count, 0.5, v2_pos);\n\t\t\t}\n\t\t}\n\t\t// unfolded phase\n\t\telse if(v1_time_secs < v1_folding_start_secs)\n\t\t{\n\t\t\tv3_color = get_color(i1_point_count, 0.5, v2_pos);\n\t\t}\n\t\t// folding phase\n\t\telse if(v1_time_secs < v1_cycle_duration_secs)\n\t\t{\n\t\t\tfloat v1_t = v1_cycle_duration_secs - v1_time_secs;\n\t\t\tfloat v1_pc = (float(i1_point_count) * v1_t) / v1_folding_duration_secs;\n\t\t\tfloat v1_mixf = fract(v1_pc);\n\t\t\tint i1_crt_point_count = int(min(floor(v1_pc), float(i1_point_count)));\n\t\t\t\n\t\t\tv3_color = get_color(i1_crt_point_count, v1_mixf, v2_pos);\n\t\t}\n\t}\n\n    fragColor = vec4(v3_color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}