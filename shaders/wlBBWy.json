{
    "Shader": {
        "info": {
            "date": "1599748875",
            "description": "Go to Gokuraku Joudo (極楽浄土)",
            "flags": 0,
            "hasliked": 0,
            "id": "wlBBWy",
            "likes": 27,
            "name": "Mandara boze",
            "published": 3,
            "tags": [
                "raymarching",
                "cineshader",
                "boze"
            ],
            "usePreview": 1,
            "username": "kaiware007",
            "viewed": 48527
        },
        "renderpass": [
            {
                "code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n//#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define SCROLL_SPEED (2.)\n\n#define AA 1\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n/*\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n*/\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\n#define SURF_MAN1(d) \t(surface(d, vec4(1,0,0.1,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Simple Palette : https://iquilezles.org/articles/palettes\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( M_PI2*(c*t+d) );\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, vec3 col)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo = vec4(col, 1);\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n*/\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdMandara1(vec3 p, float h, float l, float t)\n{\n    vec3 q = rotate(p + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n    \n    float d = sdCappedCylinder(q, h, l);\n\tsurface result = SURF_MAN1(d);\n    float r = distance(vec2(0,0.05), p.xy);\n    //result.albedo = vec4(hsv2rgb(vec3(r * 10. + t, 1, 1)), 1);\n    result.albedo = vec4(palette(r * 5. + t*2., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)) * smoothstep(0.1,0.3, fract(r*8. + t*5.3)), 1);\n    return result;\n}\n\nsurface map(vec3 p)\n{\n    float t = iTime * M_PI2;\n    //float ms = sin(t*SCROLL_SPEED)*0.5 + 0.5;\n    float ms = 1.;\n    \n    p = opRep(p, vec3(2.5,2.5,101));\n        \n    p = rotate(p, M_PI, vec3(0,1,0));\n\tsurface result = sdBoze(p, vec3(2.), ms);\n    result = opU(result, sdMandara1(p, 0.5, 0.01, -t*0.1));\n    //vec3 q = rotate(p + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n    //result = opU(result, SURF_MAN1(sdCappedCylinder(q, 0.5, 0.01)));\n\n    float l = 0.8;\n    float angle = M_PI2 / 8.;\n    for(int i = 0; i < 8; i++) {\n        //float r = float(i) * M_PI2 / num + st; \n        float a = (float(i) + t*0.1) * angle;\n        vec3 pp = p + vec3(cos(a) * l, sin(a) * l, 0.);\n    \t//result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3((float(i) + t) * 0.125,0.9,1))));\n        result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3((float(i) + t) * 0.125,0.9,1))));\n        \n        result = opU(result, sdMandara1(pp, 0.31, 0.01, -t*0.1));\n                     \n        //vec3 q = rotate(pp + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n        //p = rotate(p, M_PI, vec3(0,1,0));\n        //result = opU(result, SURF_MAN1(sdCappedCylinder(q, 0.31, 0.01)));\n    }\n                     \n    //vec3 q = opRep(p - vec3(2.5, 50., 2.5), vec3(5, 100., 5));\n    //result = SURF_BG1(sdCappedCylinder(q, 0.5, 100.), p);\n    //float bg = sdCappedCylinder(q, 0.5, 100.);\n    \n    // background\n    //result = opU(result, SURF_BG1(sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), p));\n    //bg = smin(bg, sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), 2.0);\n    //result = SURF_BG1(bg, p);\n    \n    // boze    \n    //result = opU(result, sdBozeFullBody(p));\n        \n    return result;\n}\n\n#if 1\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=map(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(map(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/articles/normalsSDF\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\n#define MANDEL_AA 2\nfloat mandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 256.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<512; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>511.0 ) return 0.0;\n    \n    // ------------------------------------------------------\n    // smooth interation count\n    //float sl = l - log(log(length(z))/log(B))/log(2.0);\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n    float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*iTime ) );\n    l = mix( l, sl, al );\n\n    return l;\n}\n\nvec3 SkyColor( vec3 rd)\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0,0,0);\n    \n    /*\n    // julia\n    //float zoom = mod(iTime * M_PI2 * 0.5, 5.);\n    //float zoom = sin(iTime) * 1.5;\n    float zoom = -iTime*0.1;\n    vec2 z = rd.xy * (2.5 + zoom);\n\n    float t = 5.+iTime * 0.05;\n\tvec2 c = 0.51*cos(vec2(0,699)+0.1*t) - \n             0.25*cos(vec2(0,699)+0.2*t );\n\n\tfloat f = 1e20;\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tz = vec2( z.x*z.x-z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\tf = min( f, dot(z,z) );\n\t}\n\t\n    f = 1.0+log2(f)/16.0;\n    //return vec3(f,f*f,f*f*f);\n    //return palette(f*3., vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25));\n    return palette(f*3., vec3(0.2,0.3,0.2),vec3(0.75,0.5,0.85),vec3(1.0,0.8,1.1),vec3(0.54,0.2,0.67));\n    */\n    /*\n    // Mandelbrot\n    vec3 col = vec3(0.0);\n    //float l = length(rd.xy);\n    //vec2 rp = vec2(rd.x * cos(rd.y), rd.x * sin(rd.y));\n    vec2 rp = rd.xy;\n    //x=rcosθ,y=rsinθ\n#if MANDEL_AA>1\n    for( int m=0; m<MANDEL_AA; m++ )\n    for( int n=0; n<MANDEL_AA; n++ )\n    {\n        //vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        vec2 p = (rp.xy + vec2(float(m),float(n))/float(MANDEL_AA)*0.001)* 1.1;\n        float w = float(MANDEL_AA*m+n);\n        float t = iTime + 0.5*(1.0/24.0)*w/float(MANDEL_AA*MANDEL_AA);\n#else    \n        //vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        vec2 p = rp.xy * 0.5;\n        //float t = mod(iTime, 20.);\n        float t = iTime * M_PI2;\n#endif\n        \n        //vec2 p = rd.xy * 0.1;\n        //float t = iTime;\n        //float zoo = 0.62 + 0.38*cos(.07*t);\n        //float zoo = 0.62 - 0.38*mod(.05*t, 0.5);\n        //float zoo = 0.62 - 0.38*(mod(t * 0.2, 1.)*1.0);\n        float zoo = 0.38*(mod(t * 0.2, 1.)*1.0);\n        float coa = cos( 0.01*(1.0-zoo)*t );\n        float sia = sin( 0.01*(1.0-zoo)*t );\n        //float coa = 1.;\n        //float sia = 0.;\n        //zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float f = mandelbrot(c);\n        //col += palette(f*0.15, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20));\n        //col += palette(f*0.15, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n        col += sinebow(f*0.15+t);\n#if MANDEL_AA>1\n    }\n    col /= float(MANDEL_AA * MANDEL_AA);\n#endif\n    return col;\n    //return 0.5 + 0.5*cos( 3.0 + f*0.15 + vec3(0.0,0.6,1.0));\n    */\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    return sinebow(iTime*0.5 + hash12(rd.xy*135156.));\n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n    \n    \n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\n*/\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n    \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n        \n        // out line\n        float NoV = abs(dot(nor, -direction)) + 1e-5;\n        hit.albedo.rgb *= smoothstep(0.19, 0.2,NoV);\n        \n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        //hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        //hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n\t\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //if (!mat.isHit && mat.albedo.a < EPS) \n    if (!mat.isHit) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    //col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    //return vec4(col, 1. - clamp(mat.dist, 0., 1.));\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y;\n#endif    //vec2 mouseUV = (-iResolution.xy + 2.0 * iMouse.xy)/iResolution.y;\n    \n        //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n        //vec2 p = (fragCoord.xy) / iResolution.xy;\n\n        //vec2 idx = floor(p*3.0);\n        //p = fract(p*3.0) - 0.5;\n        //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n\n        float t = iTime * M_PI2;\n        float y = 0.0;\n        float r = 100. - mod(t * SCROLL_SPEED, 100.);\n        float theta = RAD90;\n        float phi   = 0.;\n        vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n        vec3 ta = vec3(0., y, 0);\n\n        //ro.xy += mouseUV * 20.0;\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 50.0));\n        vec3 col = render(ro, ray, fragCoord.xy);\n\n        //col = postEffect(col, idx);\n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}