{
    "Shader": {
        "info": {
            "date": "1613372518",
            "description": "Procedural render of \"Remember\" by Becca Tindol, with a purple border added and some other slight modifications. See comments at the top for more info.\nClick to change recursion angle and intensity.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtfcW2",
            "likes": 18,
            "name": "\"Remember\" by Becca Tindol",
            "published": 3,
            "tags": [
                "raymarching",
                "mouse",
                "rainbow",
                "recursion",
                "dna"
            ],
            "usePreview": 0,
            "username": "amhall",
            "viewed": 660
        },
        "renderpass": [
            {
                "code": "// Procedural render of \"Remember\" by Becca Tindol\n// Original - https://www.instagram.com/p/CHb3Su8HF6g/\n// Check out her other art! https://linktr.ee/alteredmoonart\n// Created by Anthony Hall, December 2020\n\n// Supersample more toward the center to reduce aliasing\n// At high resolutions, this doesn't impact performance very much\nconst bool dynamicSupersample = true;\n\n// The base number of samples to take on each axis\nconst int baseSamples = 1;\n\n// Render a border between layers\n// Disabling this makes the result more accurate to the original artwork\nconst bool renderBorder = true;\n\n// Frequency of layer zoom, glow oscillation, DNA rotation, and sky movement\nconst float zoomFrequency = 0.6667;\nconst float glowFrequency = 0.5 * zoomFrequency;\nconst float twistFrequency = -0.75 * zoomFrequency;\nconst float skyFrequency = 5. * zoomFrequency;\n\n// Raymarching constants\nconst float maxDistance = 50.0;\nconst float baseEpsilon = 0.003;\nfloat epsilon; // set in sampleScene - increases with deeper layers\n\n// Other globals\nconst vec3 cameraPos = vec3(0., 0., 37.5);\nconst float fov = radians(50.0);\nvec3 lightPos = vec3(16.0, 3.0, 20.0);\n\n// Colors taken directly from the source\nconst vec3 glowColor = vec3(6, 202, 227) / 255.0;\nconst vec3 purple = vec3(125, 39, 239) / 255.0;\nconst vec3 blue = vec3(69 /* nice */, 46, 250) / 255.0;\n\n// 2D rotation in radians\nmat2 rotate(float angle) {\n    return mat2(\n        cos(angle), sin(angle),\n        -sin(angle), cos(angle));\n}\n\n// Folds point across a line through origin with specified normal\nvec2 fold(vec2 point, vec2 normal)\n{\n    float dist = min(dot(point, normal), 0.0);\n    return point - 2. * dist * normal;\n}\n\nfloat sdCircle(vec2 point, vec2 center, float radius) {\n    return distance(point, center) - radius;\n}\n\n// Distance to a segment of specified length on the x-axis\nfloat sdSegmentX(vec3 point, vec3 center, float len)\n{\n\tfloat r = len/2.0;\n    point = abs(point - center);\n    return length(max(point - vec3(r, 0., 0.), 0.0));\n}\n\nconst float helixRadius = 0.19;\nconst float helixSpacing = 2.;\nconst float ladderRadius = 0.1;\nconst float ladderSpacing = 0.67;\nconst float spiralIntensity = 0.9;\n\n// Infinite DNA traversing Y axis\nfloat sdDna(vec3 point, vec2 center, float time) {\n    // Spiral about the Y axis\n    point.xz -= center;\n    point.xz = rotate(-point.y * spiralIntensity + time) * point.xz;\n    point.xz += center;\n    \n    float leftHelix = sdCircle(point.xz, center + vec2(-helixSpacing/2.0, 0.0), helixRadius);\n    float rightHelix = sdCircle(point.xz, center + vec2(helixSpacing/2.0, 0.0), helixRadius);\n    float helix = min(leftHelix, rightHelix);\n    \n\t// Repeat ladder along z axis\n    point.y -= ladderSpacing/2.0;\n    point.y = mod(point.y, ladderSpacing);\n    point.y += ladderSpacing/2.0;\n    float ladder = sdSegmentX(point, vec3(center.x, 0.5, center.y), helixSpacing) - ladderRadius;\n    \n    // iq's smooth minimum\n    float k = .175;\n    float h = max(k - abs(helix - ladder), 0.0) / k;\n    return min(helix, ladder) - h*h*h*k/6.0;\n}\n\nfloat dnaX = 15.0;\nfloat borderX = 13.0;\nfloat borderRadius = 0.25;\n\n// Returns the distance to the scene\nfloat scene(vec3 point)\n{\n    // Fold the space twice to create a square around the center\n    point.xy = fold(point.xy, normalize(vec2(1., -1.)));\n    point.xy = fold(point.xy, normalize(vec2(1., 1.)));\n    \n    float time = iTime * twistFrequency * radians(180.0);\n    \n    // Scale DNA distance down because the space distortions sometimes result in overstepping\n    float dna = 0.75 * sdDna(point, vec2(dnaX, 0.), time);\n    float dist = dna;\n    \n    if (renderBorder)\n    {\n        float border = sdCircle(point.xz, vec2(borderX, -0.), borderRadius);\n        dist = min(dist, border);\n    }\n    return dist;\n}\n\n// Approximates the normal at an intersection by calculating the gradient of the map\nvec3 estimateNormal(vec3 point) {\n\treturn normalize(vec3(\n        scene(vec3(point.x + epsilon, point.y, point.z)) - scene(vec3(point.x - epsilon, point.y, point.z)),\n        scene(vec3(point.x, point.y + epsilon, point.z)) - scene(vec3(point.x, point.y - epsilon, point.z)),\n        scene(vec3(point.x, point.y, point.z  + epsilon)) - scene(vec3(point.x, point.y, point.z - epsilon))));\n}\n\n// Gets rainbow color based on position around the border, slightly offset each level\nvec3 getRainbow(vec3 point, float level)\n{\n    point = abs(point);\n    float t = -min(point.x, point.y) / 15.0 + 0.2;\n    t += 0.05 * level;\n    \n    // Pretty much a hue scalar -> rgb\n    vec3 a = vec3(0, 1, 2) / 3.0;\n    return 0.5 + 0.5 * clamp(2.0 * cos(radians(360.0) * (t + a)), -1.0, 1.0);\n}\n\n// Shades a surface at the given point\nvec3 shadeSurface(vec3 point, vec3 rayDir, float level)\n{\n    vec3 normal = estimateNormal(point);\n    vec3 surfaceColor;\n    \n    // Set the surface color based on whether this is the DNA or the border\n    float region = max(abs(point.x), abs(point.y));\n    if (region > borderX + borderRadius + epsilon)\n    {\n        surfaceColor = getRainbow(point, level);\n    }\n    else\n    {\n        surfaceColor = purple;\n        //surfaceColor = vec3(0.9); // The lighting effects are more apparent with a silver border\n        \n        // Add rainbow colored highlighting around the edges\n        vec3 toEye = -rayDir; \n        float intensity = 1.0 - dot(normal, toEye);\n        surfaceColor = mix(surfaceColor, getRainbow(point, level), intensity);\n    }\n    // Smoothstepped diffuse lighting\n    vec3 toLight = normalize(lightPos - point);\n    float diffuse = max(dot(normal, toLight), 0.0);\n    diffuse = smoothstep(0.6, 0.85, diffuse);\n    \n    // Add some ambient lighting and return\n    diffuse = mix(diffuse, 1.0, 0.4);\n    return surfaceColor * diffuse;\n}\n\n// Calculates the sky as purple with a bit of cloud-like animation\nvec3 getSky(vec3 rayOrigin, vec3 rayDir)\n{\n    // Calculate coordinates of intersection\n    vec3 intersect = abs(rayDir * rayOrigin.z / rayDir.z);\n    float x = max(intersect.x, intersect.y);\n    float y = min(intersect.x, intersect.y);\n    \n    // Calculate the fade (colorMix) between the blue glow and purple sky\n    // band - the band that runs along the axis of the DNA\n    // ellipse - The more pronounced bulge near the center of each edge\n    float band = smoothstep(0.6, 1.6, abs(x - dnaX));\n    float ellipse = length(vec2((x - dnaX) * 0.7, y * 0.225)) - 1.5;\n    float colorMix = min(band, ellipse);\n    colorMix = clamp(colorMix, 0.0, 1.0);\n    \n    const vec3 baseColor = purple * 1.1;\n    \n    // Get the intensity of the purple sky component\n    const float innerSkyStart = renderBorder? -3.0 : -4.0;\n    const float innerSkyEnd = renderBorder? -0.5 : -1.25;\n    float skyIntensity = smoothstep(innerSkyStart, innerSkyEnd, x - dnaX) * smoothstep(14.0, 0.5, x - dnaX);\n    skyIntensity = pow(skyIntensity, 1.4);\n    vec3 purpleSky = skyIntensity * baseColor;\n    \n    // Add some moving textures to the sky to animate it\n    float textureScale = 1./90.;\n    \n    // Use pebble texture to get main \"cloud\" effect moving outward\n    float time = iTime * skyFrequency;\n    vec2 uv = vec2(min(intersect.x, intersect.y), x - time) * textureScale;\n    uv.x -= 0.8;\n    float coarse = texture(iChannel0, uv).r;\n    coarse = mix(coarse, 1.0, 0.7);\n    \n    // Use another more fine texture with slower outward movement\n    uv.y = (x - time * .4) * textureScale;\n    uv *= 0.45;\n    float fine = texture(iChannel1, uv).r;\n    fine = mix(fine, 1.0, 0.875);\n    \n    float textureIntensity = coarse * fine;\n     \n    // Add the texture effects weakly to the blue and strongly to the purple\n    return mix(blue * textureIntensity,\n               purpleSky * textureIntensity * textureIntensity,\n               colorMix);\n}\n\n// Returns the result color of casting a ray\nvec3 castRay(vec3 rayOrigin, vec3 rayDir, float level)\n{\n    // Time intensity scalar from 0 - 1 of both iteration-based glow (on hit)\n    // and distance-based glow (on miss)\n    float glowOscillate = 0.5 + 0.5 * cos(iTime * glowFrequency * radians(360.0) + level * 0.25);\n    \n    vec3 color = getSky(rayOrigin, rayDir);\n    \n    vec3 point = rayOrigin;\n    float t;\n    int iters = 0;\n    float minDist = 1e10;\n    \n    for (t = 0.; t < maxDistance; point = rayOrigin + t*rayDir)\n    {\n     \tfloat dist = scene(point);\n        minDist = min(dist, minDist);\n        \n        if (dist <= epsilon)\n        {\n            color = shadeSurface(point, rayDir, level);\n            \n            // Add iteration-based glow\n            // Only add glow on DNA, not on border\n            if (max(abs(point.x), abs(point.y)) > borderX + borderRadius + epsilon)\n            {\n                float baseGlow = float(iters) / 50.0;\n                float glowIntensity = 0.8 + 1.5 * glowOscillate;\n                color += glowColor * glowIntensity * pow(baseGlow, 1.075);\n            }\n        \treturn color;\n        }\n        t += dist;\n        iters++;\n    }\n    // On miss, add distance-based glow\n    float glowIntensity = 0.4 + 0.4 * glowOscillate;\n    float baseGlow = exp2(-2.5 * minDist);\n    color += glowColor * glowIntensity * pow(baseGlow, 1.4);\n    \n    return color;\n}\n\n// Variables/defaults used for calculating recursion\n// Calculated in mainImage\nfloat borderPercentage;\nfloat scalePerIteration = 441./367.;\nfloat anglePerIteration = radians(7.84);\n\n// Samples the scene at specified pixel coordinate\n// Recurses to the proper layer and then calls castRay\nvec3 image(vec2 fragCoord)\n{\n    // Convert coords to [-1, 1] in minimum dimension\n    float minDimension = min(iResolution.x, iResolution.y);\n    vec2 coord = (2.0 * fragCoord - iResolution.xy) / minDimension;\n    \n    // Fake infinite zoom\n    float time = iTime * zoomFrequency;\n    float zoom = fract(time);\n    float startLevel = floor(time);\n    coord /= pow(scalePerIteration, zoom);\n    coord = rotate(zoom * anglePerIteration) * coord;\n    \n    // logScale - when there is twisting between the levels, we can still determine\n    // the most shallow level the point must be in by inscribing an upright square\n    // into the rotated square\n    float logScale;\n    if (max(abs(coord.x), abs(coord.y)) >= borderPercentage)\n    {\n        logScale = scalePerIteration / (sin(abs(anglePerIteration)) + cos(abs(anglePerIteration))); \n    } else\n    {\n        logScale = scalePerIteration * (sin(abs(anglePerIteration)) + cos(abs(anglePerIteration)));\n    }\n    \n    // Optimization - Advance to the point to the most shallow level it is guaranteed to be in\n    vec2 logs = ceil(-log(abs(coord  / borderPercentage)) / log(logScale));\n    float level = min(logs.x, logs.y);    \n    coord *= pow(scalePerIteration, level);\n    coord = rotate(-level * anglePerIteration) * coord;\n    \n    // Finish advancing the point to its actual level\n    for (int i = 0; i < 25; i++)\n    {\n        if (max(abs(coord.x), abs(coord.y)) < borderPercentage) {\n            coord *= scalePerIteration;\n            coord = rotate(-anglePerIteration) * coord;\n            level += 1.0;\n            continue;\n        }\n        break;\n    }\n    // Reduce aliasing slightly by reducing LOD in deep levels\n    epsilon = baseEpsilon * pow(scalePerIteration, level * 0.9);\n    \n    // Cast the recalculated ray\n\tvec3 rayDir = normalize(vec3(coord * tan(fov/2.0), -1.0));\n    return castRay(cameraPos, rayDir, startLevel + level);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate border size, scale/angle per iteration\n    \n    // borderPercentage - the percentage of the scene where the ray is tangent to\n    // the inside of the border cylinder (i.e. when to recurse to the next level)\n    float r = borderRadius + baseEpsilon;\n    float c = length(vec2(cameraPos.z, borderX));\n    float theta1 = atan(borderX / cameraPos.z);\n    float theta2 = asin(r / c);\n    borderPercentage = tan(theta1 - theta2) / tan(fov/2.) + 0.0005; // Add a bit to compensate for slight error\n    \n    // Overwrite angle/scale defaults by mouse x/y respectively if clicked\n    if (iMouse.z > 0.0)\n    {\n        vec2 mouse = min(iMouse.xy, iResolution.xy); // So changing resolution doesn't cause unwanted values\n        anglePerIteration = -0.15 * (2.0 * mouse.x - iResolution.x) / iResolution.x;\n        scalePerIteration = mix(1.18, 1.5, mouse.y / iResolution.y);\n    }\n\n    // Supersample more toward the center\n    // Because the level of detail is logarithmic, we can supersample\n    // based on pixel distance regardless of viewport size\n    float minDimension = min(iResolution.x, iResolution.y);\n    vec2 absPixelCoord = abs(fragCoord - 0.5 * iResolution.xy);\n    float bound = max(absPixelCoord.x, absPixelCoord.y);\n    int samples = baseSamples;\n    \n    if (dynamicSupersample)\n        samples += int(bound < 150.0) + int(bound < 34.0);\n\n    float increment = 1.0 / float(samples);\n    float offset = increment / 2.0 - 0.5;\n\n    // Supersample by accumulating color of all samples\n    vec3 color = vec3(0.0);\n    \n    for(int y = 0; y < samples; y++) {\n        for(int x = 0; x < samples; x++)\n        {\n            vec2 screenCoord = fragCoord + offset + increment * vec2(x, y);\n            color += image(screenCoord);\n        }\n    }\n    color /= float(samples * samples);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}