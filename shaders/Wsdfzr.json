{
    "Shader": {
        "info": {
            "date": "1604253897",
            "description": "costas arrays are pattern free==aperiodic\n3d costas arrays are impractival (too large LUT)\nbut a self recursed 2d costas array is still semi-aperiodic, great for dithering (in theory)\nsome of them still compress nicely due to meta-patterns between 2 of em",
            "flags": 0,
            "hasliked": 0,
            "id": "Wsdfzr",
            "likes": 3,
            "name": "Costas3 (semi)aperiodic dither",
            "published": 3,
            "tags": [
                "noise",
                "dither",
                "bluenoise",
                "costas",
                "costasarray",
                "patternfree"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 336
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/Wsdfzr\n//parent: https://www.shadertoy.com/view/tdjfzR\n\n//todo, 2d fourier transform\n\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n/*\ncostas array [mode==0] is pattern free \nin short, it is an extension to the \"place the most exclusive queens on a checkerboard\"\n- BUT where even ALL XY-differentials between any 2 tokens must be unique (on a torus repetition)\nThis is (in theory) ideal for dithering\n(or as a basis for a music scmapler, that just has to add local arbitiary (strided) repetitions)\n\nThe [mode==1] greyscaling gradient is BASIC (and too much of a pattern)\n\nIt can easily be more distorted\n, by applying a second greyscaling-recursionpass [mode==2] of a costas array \n\nIf that is the same CostasArray over itself, it is only SEMI-pattern-free\n, even that but likely still good enough.\n\nTo turn this into (any amount of) (pattern free) BLUE (noise)\n,simply mix(a,b,0.75) 2 of these, where the scale.xy of one of CostasArray [a] \nis an interger multiple of the scale of the scale.xy of CostasArray [b]\n(and make sure, that both costas arrays are also costas-arrays over a tiled neighborhood)\n\nalso see [worlds ugliest music]==  https://www.youtube.com/watch?v=RENk9PK06AQ\n*/\n\n\n#define mode 4\n//mode 0 shows costas array as boolean dots\n//mode 1 shows it as linear fade gradient\n//mode 2 suffles the gradeitn by the same costas array\n//- this looks fine for most costas arrays, though its only semi-pattern.free\n//I assume mode 2 fails on SIMPLE costas3() costas arrays (that compress more than a LUT)\n//it sure looked nicer on my LUT arrays.\n//mode 4 cycles trhough all modes\n\n#define period 256\n\n//scale by period\n#define zoom (min(iResolution.x,iResolution.y)/float(period-1))\n//pixel perfect, but only in preview\n//#define zoom 1.\n\n/*  //mathematical construction of a costas array list quickly hits limits of 32bit int\n    //therefore this segment is quite limited in its utility, and therefore commented out\n\n#define base1 2\n//the  (pase,period) pairs -> (3,5) (3,7) (5,7) make costas arrays\n//the  (pase,period) pairs (2,11) (2,13) (2,29) look a lot like they make costas arrays\n//(5,9) (7 11)\n//the function below fails for too large [#] values\n//it breaks for period>=37 (overflow or low float precision?)\n#define base2 base1  //trying otherbases\n\n\n\nint poi(int a,int b){//integer pow(a,b) as loop is slow but more precise\n ;//b=abs(b) //imply b>-1\n ;int r=a;for(int i=0;i<b;i++){r*=a;}return r;}\nint costas3(int x,int b\n){//return int(round(pow(float(b),float(x)+1.)))%int(period)//round() is essential on type float\n ;return poi(int(b),int(x))%period //type int has larger range, but type int exp() is silly\n ;}\n\n/**/\n\n//return entry [a] of CostasArray list\n//return entry a of array (is a heightmap-like wrapper function)\nint ae(int a){\n ;//return (a*5)%period         //linear *5 debug\n ;//return costas3(a,base1)-1;    //works up to (2,29) with type float.\n ;//but seriously, use other LUTs:\n ;int c[] = int[256](1,17,140,33,222,156,40,49,23,238,109,172,143,56,105,65,41,39,224\n                    ,254,179,125,53,188,187,159,162,72,11,121,103,81,248,57,5,55,234\n                    ,240,26,14,82,195,102,141,244,69,32,204,79,203,180,175,84,178,74\n                    ,88,107,27,19,137,239,119,62,97,108,8,77,73,192,21,130,71,229,250\n                    ,70,256,148,42,243,30,45,98,38,211,6,118,150,157,99,4,182,85,242\n                    ,48,189,220,174,95,131,219,186,196,36,191,144,100,214,194,138,90\n                    ,117,104,215,123,18,43,165,35,80,153,217,255,221,135,152,78,252\n                    ,113,241,124,206,24,7,93,127,89,25,208,163,37,171,146,251,87,232\n                    ,245,218,10,66,86,228,16,63,164,68,58,91,3,223,46,92,61,176,114\n                    ,213,54,132,227,29,22,246,134,83,166,226,173,158,115,170,20,128\n                    ,198,122,101,199,2,149,64,201,205,136,236,225,190,247,111,9,147\n                    ,155,235,216,202,50,212,47,52,75,207,76,160,197,116,13,230,67\n                    ,210,142,154,112,106,183,133,185,120,209,231,249,139,200,34,31,59\n                    ,60,181,253,51,126,96,167,169,193,233,184,15,44,237,110,151,177\n                    ,168,28,94,161,12,145,129);\n ;return c[a%period];}\n    //i admit, its quite the LUT\n    //but give it a try, because it should be VERY aperiodic, in theory, great for dithering\n    //\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n\n\nvoid mainImage(out vec4 O, vec2 u\n){//u=u.yx\n ;int m=mode\n ;if (m==4)m=int(iTime+2.)%3;  \n ;vec3 c=vec3(0)\n ;if(u.x<float(period-1)*zoom\n   &&u.y<float(period-1)*zoom //if not the blue part\n ){ivec2 U=ivec2(u*float(period)/iResolution.y)\n  ;//U=U.yx                          //sqivel domains\n  //;u*=float(period)/iResolution.y\n  ;//if(u.x<2.)c=vec3(1);\n  ;float f=0.\n  ;int a=0\n  ;if(m==0\n  ){if(ae(U.x)==U.y)a=period;//black or white\n  }else{\n   ;a=ae(U.x)+(U.y)                      //linear gradient\n   ;a=a%period//;if(a>period)a-=period //single overflow   (no mod needed) \n   ;if(m>1\n   ){a=ae(a)+(U.y)     //+1 ae() recursion  //the U.y seems important, may even try U.x\n    ;a=a%period;}}\n  ;f=float(a)/float(period) \n  ;c=vec3(f)\n  ;}else c=vec3(0,0,1);\n ;O=vec4(c,1)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nselection of some costasArrays\npersonally i only care for diagonal-mirror-symmetrical costasArrays, because these compress a lot better.\n\nall* symmetrical costas arrays of order 2 are:\n\t1\t2\nall* symmetrical costas arrays of order 3 are:\n\t1\t3\t2\nall* symmetrical costas arrays of order 4 are:\n\t1\t2\t4\t3\nall* symmetrical costas arrays of order 5 are:\n\t1\t3\t4\t2\t5                          <---- demoed \n\t2\t4\t1\t5\t3\nall* symmetrical costas arrays of order 6 are:\n\t1\t4\t5\t3\t2\t6\n\t1\t5\t3\t6\t2\t4\n\t1\t6\t3\t5\t4\t2\n\t1\t6\t4\t3\t5\t2\n\t2\t4\t5\t1\t6\t3\nall* symmetrical costas arrays of order 7 are:\n\t1\t2\t6\t4\t7\t3\t5\n\t1\t2\t7\t4\t6\t5\t3\n\t1\t2\t7\t5\t4\t6\t3\n\t1\t7\t3\t4\t6\t5\t2\n\t2\t1\t5\t7\t3\t6\t4\n\t2\t1\t6\t4\t7\t3\t5\n\t2\t5\t6\t1\t3\t7\t4\n\t2\t5\t6\t4\t1\t7\t3\n\t2\t6\t1\t3\t4\t7\t5\n\t3\t6\t1\t7\t5\t2\t4\nall* symmetrical costas arrays of order 8 are:\n\t1\t5\t8\t4\t2\t7\t6\t3\n\t1\t7\t3\t8\t6\t5\t2\t4\n\t1\t7\t4\t3\t5\t8\t2\t6\n\t3\t5\t1\t8\t2\t7\t6\t4\nall* symmetrical costas arrays of order 9 are:\n\t1\t4\t6\t2\t9\t3\t8\t7\t5\n\t2\t1\t5\t8\t3\t9\t7\t4\t6\nall* symmetrical costas arrays of order 10 are:\n\t1\t7\t4\t9\t3\t5\t8\t6\t2\t10\n\t2\t1\t9\t4\t5\t8\t10\t6\t3\t7\n\t2\t6\t8\t1\t9\t5\t3\t4\t10\t7\n\t2\t8\t9\t4\t1\t3\t7\t5\t10\t6\n\t3\t9\t1\t4\t5\t10\t8\t7\t2\t6\n\t3\t9\t7\t8\t4\t1\t6\t10\t2\t5\t\nall* symmetrical costas arrays of order 11 are:\n\t1\t6\t8\t9\t4\t10\t3\t7\t5\t2\t11\n\t1\t7\t5\t8\t10\t4\t9\t6\t2\t3\t11\n\t1\t7\t11\t6\t8\t4\t2\t5\t10\t9\t3\n\t1\t10\t4\t3\t8\t11\t9\t5\t7\t2\t6\n\t3\t10\t1\t9\t6\t5\t7\t11\t4\t2\t8\nall* symmetrical costas arrays of order 12 are:\n\t1\t2\t8\t12\t7\t9\t5\t3\t6\t11\t10\t4\n\t1\t2\t11\t5\t4\t9\t12\t10\t6\t8\t3\t7\n\t1\t4\t11\t2\t10\t7\t6\t8\t12\t5\t3\t9\n\t3\t6\t1\t12\t10\t2\t7\t9\t8\t5\t11\t4\n\nall* symmetrical costasArrays of order 16 are\n\t1\t13\t3\t16\t14\t8\t10\t6\t15\t7\t12\t11\t2\t5\t9\t4\n\t3\t12\t1\t4\t10\t6\t14\t9\t8\t5\t15\t2\t16\t7\t11\t13\n\t3\t13\t4\t15\t12\t6\t10\t2\t7\t8\t11\t1\t14\t16\t9\t5\n\t6\t14\t10\t7\t9\t1\t4\t16\t5\t3\t12\t11\t15\t2\t13\t8\n\nall* symmetrical costasArrays of order 27 are\n\t1\t25\t19\t5\t4\t12\t10\t16\t26\t7\t18\t6\t23\t27\t24\t8\t21\t11\t3\t22\t17\t20\t13\t15\t2\t9\t14\n\t3\t9\t1\t8\t13\t15\t19\t4\t2\t20\t11\t25\t5\t17\t6\t27\t14\t24\t7\t10\t26\t23\t22\t18\t12\t21\t16\n\t3\t24\t10\t26\t20\t15\t13\t23\t14\t1\t8\t4\t22\t19\t21\t2\t5\t25\t9\t17\t6\t7\t11\t16\t27\t12\t18\n\t4\t17\t21\t9\t11\t16\t25\t12\t1\t7\t26\t22\t14\t15\t13\t20\t23\t3\t24\t6\t18\t8\t2\t27\t10\t5\t19\n\t6\t10\t23\t13\t16\t1\t11\t20\t15\t2\t7\t26\t4\t27\t9\t5\t19\t25\t17\t8\t24\t22\t3\t21\t18\t12\t14\n\t6\t16\t20\t12\t14\t7\t1\t25\t8\t17\t18\t26\t11\t23\t10\t24\t15\t13\t3\t19\t22\t27\t5\t2\t9\t4\t21\n\t6\t23\t14\t8\t21\t1\t26\t4\t22\t20\t12\t11\t16\t3\t17\t13\t15\t24\t27\t10\t5\t9\t2\t18\t25\t7\t19\n\n[*]== there are more than these BUT these extra costas-arrays are just a few SPECIFIC diagonal offsets \n(aslong the mirror axis) of the ones that are listed.\nand theres always the 4 axisAligned mirrors of g-symmetry.\n\nsome symmetrical costasArrays f order 30 are:\n\t1\t23\t14\t12\t18\t26\t30\t20\t25\t11\t10\t4\t16\t3\t21\t13\t22\t5\t19\t8\t15\t17\t2\t28\t9\t6\t29\t24\t27\t7\n\t11\t22\t5\t13\t23\t10\t2\t26\t29\t15\t19\t20\t14\t4\t6\t21\t18\t27\t1\t30\t25\t7\t3\t9\t16\t28\t17\t8\t24\t12\n\t12\t24\t20\t17\t2\t9\t29\t3\t16\t4\t28\t18\t19\t27\t22\t6\t10\t1\t30\t8\t14\t25\t11\t5\t15\t7\t21\t23\t26\t13\n\t13\t26\t2\t21\t29\t4\t9\t11\t15\t27\t12\t8\t17\t18\t7\t22\t1\t30\t20\t23\t6\t24\t19\t16\t10\t3\t25\t5\t28\t14\n\na symmetrical costas array of order 35 is:\n\t1\t12\t7\t27\t32\t30\t3\t24\t31\t17\t19\t2\t16\t29\t20\t13\t10\t35\t11\t15\t23\t33\t21\t8\t26\t25\t4\t34\t14\t6\t9\t5\t22\t28\t18\n\t\na symmetrical costas array of order 65 is:\n\t1\t29\t46\t16\t24\t37\t17\t22\t12\t63\t55\t9\t15\t42\t13\t4\t7\t26\t44\t56\t50\t8\t49\t5\t40\t18\t32\t34\t2\t54\t51\t27\t65\t28\t53\t57\t6\t39\t38\t25\t48\t14\t59\t19\t62\t3\t58\t41\t23\t21\t31\t61\t35\t30\t11\t20\t36\t47\t43\t64\t52\t45\t10\t60\t33\n\na symmetrical costas array of order 99 is:\n1\t33\t94\t11\t21\t59\t40\t85\t39\t44\t4\t75\t88\t36\t73\t56\t60\t45\t67\t61\t5\t24\t55\t22\t87\t30\t92\t64\t37\t26\t49\t51\t2\t79\t38\t14\t29\t35\t9\t7\t97\t63\t89\t10\t18\t70\t62\t76\t31\t99\t32\t78\t65\t74\t23\t16\t96\t71\t6\t17\t20\t47\t42\t28\t53\t95\t19\t69\t68\t46\t58\t86\t15\t54\t12\t48\t82\t52\t34\t91\t98\t77\t93\t90\t8\t72\t25\t13\t43\t84\t80\t27\t83\t3\t66\t57\t41\t81\t50\n\n/**/\n\n/*\n\n//for compatibility with old opengl versions \n//(and to make arrays forksafe)\n//define shitty array struct\n//, with get()set()wrappers and constant array length code.\n//maxlen 27 ceashes too many tested environments (this first version is a bit shitty, too)\n#define maxLen 26\nstruct arr{int a[maxLen];int len;};\nvoid setN(inout arr u,int n,int s){n=clamp(n,1,maxLen);u.len=max(u.len,n);u.a[n-1]=s;}\nint  getN(arr u,int n){return u.a[clamp(n-1,0,u.len-1)];}//worksafing clamp()is faster than mod()\narr  newA(){arr r; r.len=1; r.a[0]=0;return r;}\n\n\n//modify setArray()to set the size of the array \n//AND the height of its pixels (last parameter)\n//theres only 1 pixel per column (later ones overwrite earlier ones)\n//any 2 pixels in the same line will be marked in white\n//where this is found ONCE (is not a CostasArray in that case)\narr setArray(){ //this could be read from a vertex buffer.\n ;arr a=newA()\n ;setN(a,1,1)\n ;setN(a,2,3)\n ;setN(a,3,4)\n ;setN(a,4,2)\n ;setN(a,5,5)\n\n//slow checker if an \n//struct arr{int a[maxLen];int len;}; \n//is a costasArray: https://www.shadertoy.com/view/tdjXWh\n//return array type[arr] as list of differentials of [a] with indexDistance [d]=[0<d<a.len]\narr strideDiff(arr a,int d\n){arr r=newA()\n ;for(int i=1;i<maxLen;i++\n ){setN(r,i,getN(a,i)-getN(a,i+d))\n  ;if (i+d>=a.len)break;}\n ;return r;}\n//getDupeEntry;\n//return pointers to the first 2 found duplicate entries in [a], comparing from a[0] till a[l].\n//if (there are no duplicate entry in [a] till entry a[l] )return ivec2(-1,-1)\nivec2 getDupeEntryS(ivec2 r,arr a,int i,int j\n){for(i=1;i<j;i++){if(getN(a,i)==getN(a,j))return ivec2(i,j);}\n ;return r;}\nivec2 getDupeEntry(arr a\n){ivec2 r=ivec2(-1,-1)//default state of [no dupes found]\n ;for(int i=0;i<maxLen-1;i++\n ){if(i==a.len)return r\n  ;r=getDupeEntryS(r,a,i,a.len-i)\n ;}return r;}\n//return if [a] is a [costas array] of order [a.len]\nivec3 isCostas(arr a\n){for(int i=1;i<=a.len;i++\n ){ivec2 dupes=getDupeEntry(strideDiff(a,i))\n  ;if(dupes.x!=-1)return ivec3(dupes,i);//return 2 indexes of found duplicate differential and dx\n  ;}\n ;return ivec3(-1,-1,-1);}//case of no dupes AND all in bounds == is costas Array\n\n/**/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}