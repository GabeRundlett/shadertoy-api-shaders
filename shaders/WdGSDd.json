{
    "Shader": {
        "info": {
            "date": "1577881103",
            "description": "Happy New Year 2020 !\nThis year, instead of a boring card I decided to wish everyone my best wished for the new year 2020 with a shader.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WdGSDd",
            "likes": 57,
            "name": "2020 - A celebration of new year",
            "published": 3,
            "tags": [
                "bokeh",
                "numbers",
                "distance",
                "vector",
                "happy",
                "new",
                "outline",
                "fields",
                "year"
            ],
            "usePreview": 0,
            "username": "PixelPhil",
            "viewed": 4487
        },
        "renderpass": [
            {
                "code": "//\n// 2020 - A celebration of new year by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// Note: This shader is a fairly standard 2D composition with two layers. The digits\n// are produced with bespoke signed distance functions (the fact that 2020 has only two diferent\n// digits made the process easier).\n// The background is itslef a composition of 3 layers of cellular bokeh with some color tweaks\n// similar to techniques shown in BigWings tutorials.\n//\n// There is no huge technical feat but I wanted to create a warm and colorfull image.\n// Tell me what you think :D\n\n\n#define S(a,b,c) smoothstep(a,b,c)\n\n// outputs a colored shape with a white border from distance field (RGBA premultiplied)\nvec4 border(vec3 color, float dist)\n{\n    vec4 res;\n    \n    float aa = 30. / iResolution.x;\n    \n    res.a = S(0.25 + aa, 0.25, dist); \n    res.rgb = mix(color, vec3(res.a),  S(0.1, 0.1 + aa, dist)); \n    \n    return res;\n}\n\n// Blend a premultiplied rbga color onto rgb\nvec3 premulBlend(vec4 src, vec3 dst)\n{\n    return dst * (1.0 - src.a) + src.rgb;\n}\n\n// Blend a premultiplied rbga color onto rgba (accurate alpha handling)\nvec4 premulBlend(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = dst.rgb * (1.0 - src.a) + src.rgb;\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a); \n    \n    return res;\n}\n\n\n// Distance field to the digit 0\nfloat zeroDst(vec2 uv)\n{\n    float dist;\n    \n    uv.y -= 0.5;\n    \n    if (uv.y > 0.0) // upper part\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    else if (uv.y > -1.1) // middle part\n    {\n        dist = abs(uv.x);\n    }\n    else  // lower part\n    {\n        uv.y += 1.1;\n        uv.y = pow(-uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    \n    return (abs(dist - 0.725) - 0.275);\n}\n\n// a box distance function\nfloat box(vec2 p, vec2 b )\n{\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// Distance field to the digit 2\nfloat twoDst(vec2 uv)\n{\n    uv.y -= 0.5;\n    \n    float topBar = box((uv + vec2(0.725, 0.0)) * vec2(1.0, 1.4), vec2(0.275, 0.0));\n    \n    if (uv.y > 0.0) // Top 'curve'\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tfloat dist = length(uv);\n        return max(-topBar, (abs(dist - 0.725) - 0.275));\n    }\n    else\n    {\n        float bottomBar = box((uv + vec2(0.0, 1.83)) * vec2(1.0, 1.4), vec2(0.95, 0.299));\n        \n        float two = min(topBar, bottomBar);\n        \n        if (uv.y > -1.8)\n        {    \n            float curve = (cos(uv.y * 2.0) - 1.0) * 0.7;\n            float x = 0.0 + uv.x - curve;\n            float mid = abs(uv.y + 0.4) * 0.7;\n            float x2 = 0.0 + uv.x - curve - mid * mid * 0.15 + 0.01;\n         \n            two = min(two, max(-x + 0.45, x2 -1.0));\n        }\n    \treturn two;\n    }\n\n}\n\n\n// Coordinate transform from global uv space to charcter space with poition and rotation\nvec2 letterUVs(vec2 uv, vec2 pos, float angle)\n{\n    float c = sin(angle);\n    float s = cos(angle);\n    float sc = 1.35;\n    uv -= pos;\n    return uv.x * vec2(s * sc, c) + uv.y * vec2(-c * sc, s);\n}\n\nfloat shadowsIntensity = 0.74;\nfloat shadowRadius = 1.1;\n\n// Character two with outline and shadow (premultiplied RGBA)\nvec4 twoCol(vec2 uv, vec3 col, vec2 pos, float angle)\n{\n    uv = letterUVs(uv, pos, angle);\n    vec4 res = border(col, twoDst(uv));\n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, twoDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n// Character zero with outline and shadow (premultiplied RGBA)\nvec4 zeroCol(vec2 uv, vec3 col, vec2 pos, float angle)\n{\n    uv = letterUVs(uv, pos, angle);\n    vec4 res = border(col, zeroDst(uv));\n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, zeroDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n\nvec3 red = vec3(0.9, 0.01, 0.16);\nvec3 yellow = vec3(0.96, 0.70, 0.19); // 248, 181, 51\nvec3 green = vec3(0.00, 0.63, 0.34);  //1, 162, 88\nvec3 blue = vec3(0.01, 0.57, 0.76);   //5, 142, 197\n\n// 2020 with colors and shadows (premultiplied rgba)\nvec4 yearCol(vec2 uv)\n{\n    float angle = sin(iTime) * 0.3;\n    \n    vec4 date = twoCol(uv, red, vec2(-2.5, 0.0), angle);\n    date = premulBlend(zeroCol(uv, yellow, vec2(-0.8, 0.0), angle), date);\n    date = premulBlend(twoCol(uv, green, vec2(0.8, 0.0), angle), date);\n    date = premulBlend(zeroCol(uv, blue, vec2(2.5, 0.0), angle), date);\n    \n    return  date;\n}\n\n// Borrowed from BigWIngs (random 1 -> 4)\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));\n}\n\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat bokehSpot(vec2 uv, vec2 id, float decimation)\n{\n    float accum = 0.0;\n    \n    for (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n    \n            vec2 cellUV = uv - offset + rnd.yz * 0.5;\n\n            float dst = length(cellUV);\n\n            float radSeed = sin(iTime * 0.02 + rnd.x * 40.0);\n            float rad =  (abs(radSeed) - decimation) / (1.0 - decimation);\n\n            float intensity = S(rad, rad - 0.15, dst);\n            \n            accum += intensity;\n        }\n    }\n    \n    return accum;\n}\n\n// Computes a random layer of bokeh spots\nfloat bokehLayer(vec2 uv, float decimation)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    float intensity = bokehSpot(cellUV, id, decimation);\n    \n    return intensity;\n}\n\n\n// Computes the bokeh background\nvec3 bokeh(vec2 uv)\n{\n    //accumulates several layers of bokeh\n    float intensity = bokehLayer(uv * 1.4 + vec2(iTime * 0.3, 0.0), 0.9) * 0.2;\n    //intensity += bokehLayer(uv * 0.8 + vec2(200.0 + iTime * 0.3, 134.0), 0.9) * 0.3;\n    intensity += bokehLayer(uv * 0.5 + vec2(0.0 + iTime * 0.3, 334.0), 0.95) * 0.15;  \n    intensity += bokehLayer(uv * 3.0 + vec2(iTime * 0.3, 99.0), 0.95) * 0.05;\n    \n    float cDist = max(0.0, 1.0 - length(uv) * 0.05);\n    \n    intensity = cDist + intensity;\n    \n    // Vary color with intensity\n    vec3 chroma = mix(vec3(1.0, 1.0, 0.4), vec3(1.0, 0.7, 0.5), uv.y * 0.1 + 0.4 + intensity * 0.4);\n    \n    return chroma * intensity;\n}\n\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 3.0;\n    \n    vec4 dateCol =  yearCol(uv); // 2020\n    \n    vec3 bg = bokeh(uv);\n    \n    //add a bit of light\n    dateCol.rgb -= uv.y * 0.15 * dateCol.a;\n    bg.rgb -= uv.y * 0.03;\n    \n    // blend 2020 and BG\n    vec3 col = premulBlend(dateCol, bg);\n    \n    // Gamma correction to make the image warmer\n    float gamma = 0.8;\n    col.rgb = pow(col.rgb, vec3(gamma));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}