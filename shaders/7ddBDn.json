{
    "Shader": {
        "info": {
            "date": "1656357796",
            "description": "002 - I studied a bit about some glsl funcions and tried to \"mathify\" the cycle function.\n\nCompared to the first version, this code is way smaller, but I think that the cycle function is less performant and can be replaced by a smooth-step function.",
            "flags": 0,
            "hasliked": 0,
            "id": "7ddBDn",
            "likes": 0,
            "name": "002 - Respiration line improve",
            "published": 3,
            "tags": [
                "beginner",
                "learning",
                "step"
            ],
            "usePreview": 0,
            "username": "PiGIon",
            "viewed": 189
        },
        "renderpass": [
            {
                "code": "// 2022.06.27 rev 1\n\n#define PI 3.14159265\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    // let n be the ammount of cycles per second\n    // f(x)=0.5 + (cos(((x + 0.5/ n ) * 20 * n ) / (PI)) / 2.)\n    return 0.5+(cos(((iTime+0.5/perSecond)*20.*perSecond)/(PI))/2.);\n}\n\nfloat horizontalCycle() {\n    return 0.5 + (cycle(0.34) * 0.5) - 0.25;\n}\n\nfloat diagonalLine(vec2 uv, float width) {\n    return step(distance(uv.x, uv.y), width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // Now, the coord system is 0 to 1\n    // [0, 0] = left bottom corner\n    // [1, 1] = top right corner\n    \n    // I had a huge problem trying to discover how to mix the middle\n    // screen divided colors with the line\n    // I noticed that I can use the step function to \"exclude\" what should be\n    // drawn to the screen\n    //\n    // red is only 1, when l is 1 AND (through a multiplication) is above the h threshould\n    // h is like the middle of the screen, but animated between 0.25 and 0.75\n    //\n    // green is only 1, when l is 1 AND (through a multiplication) is below the h threshould\n    // h is like the middle of the screen, but animated between 0.25 and 0.75\n    //\n    // blue is only 1, when l is 0 through a abs invert of abs(1-1) -> 0 and abs(0-1) -> 1\n    \n    float l = diagonalLine(uv, (0.1 + (cycle(0.233) * 0.1)));\n    float h = horizontalCycle();\n    \n    l = step(l, uv.x);\n    fragColor = vec4(\n        l * step(h, uv.x),\n        l * step(uv.x, h), \n        abs(1.-l), \n        1\n    );\n    \n    // cute bug :)\n//        fragColor = vec4(\n//            max(step(horizontalCycle(), l), uv.x),\n//            max(uv.x, step(l, horizontalCycle())), \n//            0, \n//            1\n//        );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}