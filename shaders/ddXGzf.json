{
    "Shader": {
        "info": {
            "date": "1666612822",
            "description": "emulating more bits for higher quality",
            "flags": 0,
            "hasliked": 0,
            "id": "ddXGzf",
            "likes": 4,
            "name": "mandelbrot zoomer 2",
            "published": 3,
            "tags": [
                "mandelbrot"
            ],
            "usePreview": 0,
            "username": "the0neboy",
            "viewed": 215
        },
        "renderpass": [
            {
                "code": "#define T iTime\n#define iterations 1500\n#define gradientEnabled true\n\nfloat times_frc(float a, float b) {\n  return mix(0.0, a * b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat plus_frc(float a, float b) {\n  return mix(a, a + b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat minus_frc(float a, float b) {\n  return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);\n}\n\n// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n//\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n// Substract: res = ds_add(a, b) => res = a + b\nvec2 add (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float t1, t2, e;\n\n  t1 = plus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = plus_frc(plus_frc(plus_frc(minus_frc(dsb.x, e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Substract: res = ds_sub(a, b) => res = a - b\nvec2 sub (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float e, t1, t2;\n\n  t1 = minus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = minus_frc(plus_frc(plus_frc(minus_frc(minus_frc(0.0, dsb.x), e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat cmp(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 mul (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float c11, c21, c2, e, t1, t2;\n  float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n  cona = times_frc(dsa.x, split);\n  conb = times_frc(dsb.x, split);\n  a1 = minus_frc(cona, minus_frc(cona, dsa.x));\n  b1 = minus_frc(conb, minus_frc(conb, dsb.x));\n  a2 = minus_frc(dsa.x, a1);\n  b2 = minus_frc(dsb.x, b1);\n\n  c11 = times_frc(dsa.x, dsb.x);\n  c21 = plus_frc(times_frc(a2, b2), plus_frc(times_frc(a2, b1), plus_frc(times_frc(a1, b2), minus_frc(times_frc(a1, b1), c11))));\n\n  c2 = plus_frc(times_frc(dsa.x, dsb.y), times_frc(dsa.y, dsb.x));\n\n  t1 = plus_frc(c11, c2);\n  e = minus_frc(t1, c11);\n  t2 = plus_frc(plus_frc(times_frc(dsa.y, dsb.y), plus_frc(minus_frc(c2, e), minus_frc(c11, minus_frc(t1, e)))), c21);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n\n  return dsc;\n}\n\n// create double-single number from float\nvec2 set(float a) {\n  return vec2(a, 0.0);\n}\n\nfloat rand(vec2 co) {\n  // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\n// double complex multiplication\nvec4 dcMul(vec4 a, vec4 b) {\n  return vec4(sub(mul(a.xy,b.xy),mul(a.zw,b.zw)),add(mul(a.xy,b.zw),mul(a.zw,b.xy)));\n}\n\nvec4 dcAdd(vec4 a, vec4 b) {\n  return vec4(add(a.xy,b.xy),add(a.zw,b.zw));\n}\n\n// Length of double complex\nvec2 dcLength(vec4 a) {\n  return add(mul(a.xy,a.xy),mul(a.zw,a.zw));\n}\n\nvec4 dcSet(vec2 a) {\n  return vec4(a.x,0.,a.y,0.);\n}\n\nvec4 dcSet(vec2 a, vec2 ad) {\n  return vec4(a.x, ad.x,a.y,ad.y);\n}\n\n// Multiply double-complex with double\nvec4 dcMul(vec4 a, vec2 b) {\n  return vec4(mul(a.xy,b),mul(a.wz,b));\n}\n\n\tvec4 dcSub(vec4 a, vec4 b) {\n\t\treturn vec4(sub(a.xy,b.xy),sub(a.zw,b.zw));\n\t}\n\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nfloat zoom = 1.;\n#define offset dcSet(vec2(0.45272105023, 0.396494224267))\n\nvec2 jp = vec2(0);\n\nvec3 mapping[16] = vec3[16](\nvec3(66, 30, 15), vec3(25, 7, 26), vec3(9, 1, 47), vec3(4, 4, 73),\nvec3(0, 7, 100), vec3(12, 44, 138), vec3(24, 82, 177), vec3(57, 125, 209),\nvec3(134, 181, 229), vec3(211, 236, 248), vec3(241, 233, 191), vec3(248, 201, 95),\nvec3(255, 170, 0), vec3(204, 128, 0), vec3(153, 87, 0), vec3(106, 52, 3));\n\nvec2 powc(vec2 z, float p) {\n    float r = length(z);\n    float a = atan(z.y/z.x);\n\n    vec2 v = pow(r,p)*vec2(cos(p*a),sin(p*a));\n\n    return v;\n}\nvec2 divc(vec2 z, float p) {\n    return powc(p/z,-1.);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 color(float t) {\n    //dont worry about any of this, because it works.\n\n    vec4 gradient[] = vec4[6](\n    vec4(0, 7, 100, 0.0),\n    vec4(32, 107, 203, 0.16),\n    vec4(237, 255, 255, 0.42),\n    vec4(255, 170, 0, 0.6425),\n    vec4(0, 2, 0, 0.8575),\n\n    vec4(0, 7, 100, 1.0));\n    \n    vec4 col = vec4(255);\n    if (gradientEnabled) {\n        for (int i=0;i<gradient.length();i++) {\n            if (gradient[i].w >= t) {\n                int ni = i-1;\n                if (ni < 0) ni = gradient.length()-1;\n                col = mix(gradient[ni],gradient[i],(t-gradient[ni].w)/(abs(gradient[ni].w-gradient[i].w)));\n                break;\n            }\n        }\n    }\n    return vec3(col);\n}\n\n//fractal formula:\nvec3 formula(vec2 fragCoord) {\n    \n    vec4 uv = dcSet(fragCoord/iResolution.xy);\n    uv = vec4(mul(uv.xy, dcSet(vec2(16.,9.)).xy), mul(uv.zw, dcSet(vec2(16.,9.)).zw));\n    uv = dcSub(uv, dcSet(vec2(8.,4.5)));\n    uv = dcMul(uv, dcSet(set(1./16.)));\n    uv = dcMul(uv, dcSet(set((zoom*2.)*(16./9.))));\n    \n    vec4 c = vec4(\n        uv\n    );\n\n    c = dcAdd(c,offset);\n    \n    vec4 z = vec4(0.);\n    \n    for (int i=0;i<iterations;i++) {\n        //if (length(z)>2.) { // smooth\n        if (max(abs(z.x),max(abs(z.y), max(abs(z.z),abs(z.w)))) > 2.0) { //scallops\n            float iterationOffset = -17.;\n            float colorSmoothness = 160.;\n            float t = mod(float(i)+iterationOffset,colorSmoothness)/(colorSmoothness);\n            \n            return color(t);\n        } else {\n            z = dcAdd((dcMul(z,z)),c);\n        }\n    }\n    \n    return vec3(0);\n}\n\n//calculate each pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //zoom = pow(10.,-T);\n    zoom = pow(10.,-T/3.);\n    \n    //offset = dcSet(vec2(-0.0452407411, 0.9868162204352258));\n    \n    //jp += offset;\n    \n    vec3 col = vec3(255,0,0);\n    \n    /*vec2 boxDim = vec2(zoom/2., zoom/2.*(9./16.));\n    vec2 boxCenter = vec2(zoom*16./9., zoom)-boxDim+offset;\n    \n    if (abs(uv.x-boxCenter.x)<boxDim.x && abs(uv.y-boxCenter.y)<boxDim.y && iMouse.z > .2) {\n        vec2 boxuv = vec2((uv.x-boxCenter.x+boxDim.x)/(boxDim.x*2.),(uv.y-boxCenter.y+boxDim.y)/(boxDim.y*2.));\n        boxuv = vec2(16.,9.)*boxuv;\n        boxuv -= vec2(8.,4.5);\n        boxuv /= 16.;\n        boxuv *= (zoom/500.)*(16./9.);\n        \n        vec2 boxoffset = jp;\n        \n        boxuv += boxoffset;\n    \n        col = formula(boxuv);\n    } else {\n        col = formula(uv);\n    }*/\n    \n    col = formula(fragCoord);\n\n    // Output to screen\n    \n    /*if (length(fragCoord/iResolution.xy*vec2(2., 2.*9./16.)-vec2(1., 9./16.)) <= .01) {\n        col = vec3(255);\n    }*/\n    \n    fragColor = vec4(col/255.,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}