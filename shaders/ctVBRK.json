{
    "Shader": {
        "info": {
            "date": "1702277140",
            "description": "The Hyperspace Exit effect, ROTJ style. Based on https://www.shadertoy.com/view/MlKBWw. Use the mouse to look around.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctVBRK",
            "likes": 7,
            "name": "Fork Hyperspace guvacode 133",
            "published": 3,
            "tags": [
                "hyperspace",
                "starwars",
                "trails"
            ],
            "usePreview": 0,
            "username": "guvacode",
            "viewed": 195
        },
        "renderpass": [
            {
                "code": "/*\n\tSimplified and adapted from:\n\thttps://www.shadertoy.com/view/MlKBWw\n*/\n\n#define TAU 6.28318\n\n// The way this shader works is by looking at the screen as if it were a disk and then\n// this disk is split into a number of slices centered at the origin. Each slice renders\n// a single trail. So this setting controls the overall density of the effect:\n#define NUM_SLICES 125.0\n//#define NUM_SLICES 50.0\n\n// Each trail is rendered within its slice; but to avoid generating regular patterns, we\n// randomly offset the trail from the center of the slice by this amount:\nconst float MAX_SLICE_OFFSET = 0.4;\n\n// This is the length of the effect in seconds:\nconst float T_MAX = 2.0;\n// T_JUMP is in normalized [0..1] time: this is the time when the trails zoom out of view\n// because we've jumped into hyperspace:\nconst float T_JUMP = 0.90;\n// This is the speed during the final jump:\nconst float jump_speed = 5.0;\n\n// I've noticed that the effect tends to have a bluish tint. In this shader, the blue color\n// is towards the start of the trail, and the white color towards the end:\nconst vec3 blue_col = vec3(0.3, 0.3, 0.6);\nconst vec3 white_col = vec3(0.8, 0.8, 0.95);\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, in float ring )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - ring;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    float time = mod(iTime, T_MAX);\n    float t = time / T_MAX;\n\n    vec2 mo = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float p_len = length(p);    \n    p += vec2(0, -0.2); // In XWA the aiming HUD is not at the screen's center\n    \n    float ta = TAU * mod(iTime, 8.0) / 8.0;\n    //ta = 12.0 * 0.01745;\n    float ay = 0.0, ax = 0.0, az = 0.0;\n    if (iMouse.z > 0.0) {\n        ay = 3.0 * mo.x;\n        ax = 3.0 * mo.y;\n    }\n    //ay += 135.0;\n    mat3 mY = mat3(\n         cos(ay), 0.0,  sin(ay),\n         0.0,     1.0,      0.0,\n        -sin(ay), 0.0,  cos(ay)\n    );\n    \n    mat3 mX = mat3(\n        1.0,      0.0,     0.0,\n        0.0,  cos(ax), sin(ax),\n        0.0, -sin(ax), cos(ax)\n    );\n    mat3 m = mX * mY;\n    \n    vec3 v = vec3(p, 1.0);\n    v = m * v;\n    \n    float trail_start, trail_end, trail_length = 1.0, trail_x;\n    // Fade all the trails into view from black to a little above full-white:\n    float fade = mix(1.4, 0.0, smoothstep(0.65, 0.95, t));\n    //float fade = 1.2;\n    \n    // Each slice renders a single trail; but we can render multiple layers of\n    // slices to add more density and randomness to the effect:\n\tfor(float i = 0.0; i < 60.0; i++) \n    //float i = 1.0;\n    {\n        vec3 trail_color = vec3(0.0);\n\t\t//float angle = (atan(v.y, v.x) / 3.141592 / 3.0 + 0.5);\n        float angle = atan(v.y, v.x) / 3.141592 / 2.0 + 0.13 * i;\n        \n\t\tfloat slice = floor(angle * NUM_SLICES);\n        float slice_fract = fract(angle * NUM_SLICES);\n        // Don't center the trail in the slice: wiggle it a little bit:\n        float slice_offset = MAX_SLICE_OFFSET * \n            rand(vec2(slice, 4.0 + i * 25.0)) - (MAX_SLICE_OFFSET / 2.0);\n        // Without dist, all trails get stuck to the walls of the\n        // tunnel. Allowing dist to be negative gives a more homogeneous \n        // coverage of all the space, both in front and behind the \n        // camera.\n        float dist = 10.0 * rand(vec2(slice, 1.0 + i * 2.0)) - 5.0;\n        float z = dist * v.z / length(v.xy);\n        \n        // When dist is negative we have to invert a number of things:\n        float f = sign(dist);\n        if (f == 0.0) f = 1.0;\n        // This is the speed of the current slice\n        float fspeed = f * (rand(vec2(slice, 1.0 + i * 0.1)) + i * 0.01);\n        float fjump_speed = f * jump_speed;\n        float ftrail_length = f * trail_length;\n        \n        trail_end = 10.0 * rand(vec2(slice, i + 10.0)) - 5.0;\n\t\ttrail_end -= t * fspeed;\n        \n        // Adding to the trail pushes it \"back\": Z+ is into the screen\n        // away from the camera... unless f is negative, then we invert\n        // the rules\n        trail_start = trail_end + ftrail_length;\n        if (f >= 0.0) {\n            // Shrink the trails into their ends:\n            trail_start = max(trail_end,\n                              trail_start - (t * fspeed) - \n                                mix(0.0, fjump_speed, \n                                                smoothstep(0.5, 1.0, t))\n                              );\n            //float trail_x = smoothstep(trail_start, trail_end, p_len);\n        } else {\n            // Shrink the trails into their ends:\n            trail_start = min(trail_end,\n                              trail_start - (t * fspeed) -\n                                mix(0.0, fjump_speed, \n                                                smoothstep(0.5, 1.0, t))\n                              );\n        }\n        trail_x = smoothstep(trail_start, trail_end, z);\n        trail_color = mix(blue_col, white_col, trail_x);\n        \n        // This line computes the distance from the current pixel, in \"slice-coordinates\"\n        // to the ideal trail centered at the slice center. The last argument makes the lines\n        // a bit thicker when they reach the edges as time progresses.\n        float h = sdLine(\n            vec2(slice_fract + slice_offset, z),\n            vec2(0.5, trail_start), \n            vec2(0.5, trail_end),\n        \tmix(0.0, 0.015, z));\n        \n        // This threshold adds a \"glow\" to the line. This glow grows with\n        // time:\n        float threshold = mix(0.12, 0.0, smoothstep(0.5, 0.8, t));\n        //float threshold = 0.12;\n        h = (h < 0.01) ? 1.0 : 0.75 * smoothstep(threshold, 0.0, abs(h));\n        \n        trail_color *= fade * h;\n        // DEBUG\n        // This part displays the size of each slice.\n        //float r = 0.0;\n        //if (trail_start <= p_len && p_len <= trail_end)\n        //    r = 1.0;\n        //trail_color = vec3(h, h, h);\n        // DEBUG\n        \n        // Accumulate this trail with the previous ones\n        color = max(color, trail_color);\n\t}\n    // Whiteout\n    color += mix(1.0, 0.0, smoothstep(0.0, 0.2, t));\n\tfragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}