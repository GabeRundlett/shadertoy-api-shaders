{
    "Shader": {
        "info": {
            "date": "1393091016",
            "description": "Mipmapped, 2D texture based 4D noise. This is mostly a test shader where I developed the noise functions for [url]https://www.shadertoy.com/view/XsSGDy[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4dSGDy",
            "likes": 20,
            "name": "musk's texturenoise",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "texture",
                "mipmap"
            ],
            "usePreview": 0,
            "username": "mu6k",
            "viewed": 1040
        },
        "renderpass": [
            {
                "code": "/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tThis is mostly a test shader where I developed the noise functions for \n\tFloating Mountains https://www.shadertoy.com/view/XsSGDy\n\n\tThe input texture is 2d however I'm generating upto 4d texture by \nadding the same slice of texture with random offsets. Mipmapping along \ngenerated dimensionns produces some artifacts but it's good enough.\n\t\n\t- There are some minor artifacts (at least on my hardware)\n\t- Mipmapping can be disabled by using a negative lod parameter.\n\t- The noise is smoothened if you use a positive lod parameter.\n    - The texture has 4 channels. There is absolutely no reason not to use them.\n\n*/\n\n/* short singleline version\n//2D texture based 4 component 1D, 2D, 3D noise\nvec4 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0));}\nvec4 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy);}\nvec4 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev).yz*21.421),texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s).yz*14.751),m);}\nvec4 noise(vec4 p){float m = mod(p.w,1.0);float s = p.w-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(noise(p.xyz+noise(sprev).wyx*3531.123420),\tnoise(p.xyz+noise(s).wyx*4521.5314),\tm);}\nvec4 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod);}\nvec4 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod);}\nvec4 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev,lod).yz,lod*21.421),texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s,lod).yz,lod*14.751),m);}\n*/\n\n//2D texture based 4 component 1D, 2D, 3D noise\nvec4 noise(float p)\n{\n\treturn texture(iChannel0,vec2(p/iChannelResolution[0].x,.0));\n}\n\nvec4 noise(vec2 p)\n{\n\treturn texture(iChannel0,p/iChannelResolution[0].xy);\n\n}\nvec4 noise(vec3 p)\n{\n\tfloat m = mod(p.z,1.0);\n\tfloat s = p.z-m; \n\tfloat sprev = s-1.0;\n\tif (mod(s,2.0)==1.0) \n\t{ \n\t\ts--; \n\t\tsprev++; \n\t\tm = 1.0-m; \n\t};\n\treturn mix(\n\t\ttexture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev).yz*21.421),\n\t\ttexture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s).yz*14.751)\n\t\t,m\n\t);\n}\n\nvec4 noise(vec4 p)\n{\n\tfloat m = mod(p.w,1.0);\n\tfloat s = p.w-m; \n\tfloat sprev = s-1.0;\n\tif (mod(s,2.0)==1.0) \n\t{ \n\t\ts--; \n\t\tsprev++; \n\t\tm = 1.0-m; \n\t};\n\treturn mix(\n\t\tnoise(p.xyz+noise(sprev).wyx*3531.123420),\n\t\tnoise(p.xyz+noise(s).wyx*4521.5314),\n\t\tm\n\t);\n}\n\nvec4 noise(float p, float lod)\n{\n\treturn texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod);\n}\n\nvec4 noise(vec2 p, float lod)\n{\n\treturn texture(iChannel0,p/iChannelResolution[0].xy,lod);\n}\n\nvec4 noise(vec3 p, float lod)\n{\n\tfloat m = mod(p.z,1.0);\n\tfloat s = p.z-m; \n\tfloat sprev = s-1.0;\n\tif (mod(s,2.0)==1.0) \n\t{ \n\t\ts--; \n\t\tsprev++; \n\t\tm = 1.0-m; \n\t};\n\treturn mix(\n\t\ttexture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev,lod).yz,lod*21.421),\n\t\ttexture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s,lod).yz,lod*14.751)\n\t\t,m\n\t);\n}\n\nvec4 noise(vec4 p, float lod)\n{\n\tfloat m = mod(p.w,1.0);\n\tfloat s = p.w-m; \n\tfloat sprev = s-1.0;\n\tif (mod(s,2.0)==1.0) \n\t{ \n\t\ts--; \n\t\tsprev++; \n\t\tm = 1.0-m; \n\t};\n\treturn mix(\n\t\tnoise(p.xyz+noise(sprev).wyx*3531.123420,lod),\n\t\tnoise(p.xyz+noise(s).wyx*4521.5314,lod),\n\t\tm\n\t);\n}\n\n#define t (iTime+16.0)\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat object(vec3 p)\n{\n\tfloat sphere = length(p)-1.;\n\tfor (float i = .0; i<1.0; i+=.09)\n\t{\n\t\tfloat plane = (p*rotate_x(t*.05+i*3214.1)*rotate_y(t*.06+i*12342.581)*rotate_z(t*.07+i*7342.581)).z;\n\t\tplane = plane+sin(t*0.2)*.4-.6;\n\t\tsphere = max(plane,sphere);\n\t}\n\treturn sphere;\n}\n\nfloat dist(vec3 p)\n{\n\treturn object(p);\n}\n\nvec3 normal(vec3 p) //returns the normal, uses the distance function\n{\n\tfloat e = .03; float d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n\t\n}\n\nvec4 texture4d(vec4 p) //4d texture\n{\n\treturn ((noise(p)+noise(p*2.0)*.5+noise(p*4.0)*.25+noise(p*8.0)*.125)*.5);\n\t\t\n}\n\nvec3 background(vec3 p, vec3 d)\n{\n\tvec3 a = vec3(.0);\n\tfor (float i=.0; i<1.0; i+=.2)\n\t{\n\t\tvec3 light = normalize(noise(t*.2+i*142100.0).xyz-vec3(.5));\n\t\tvec3 light_color = normalize(noise(t*.1+i*15400.0).xyz);\n\t\ta += (dot(light,d)*.5+.5)*light_color*(i+.2)*.2;;\n\t\ta += ((vec3(1.0)-light_color)*.125)*.1;\n\t}\n\treturn a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tvec3 c = (uv.y*.5+.5)*vec3(.4,.6,.9);\n\t\n\tvec3 p = vec3(.0,.0,3.0);\n\tvec3 d = normalize(vec3(uv,-1.0));\n\t\n\tmat3 rotation = rotate_x(mouse.y*+4.0)*rotate_y(mouse.x*+4.0);\n\tmat3 inv_rot = rotate_y(mouse.x*-4.0)*rotate_x(mouse.y*-4.0);\n\tp*=rotation; d*=rotation;\n\t\n\tfloat ds;\n\tfor (int i=0; i<80; i++)\n\t{\n\t\tds = dist(p);\n\t\tp+=ds*d*1.0;\n\t\tif (ds>40.1001||ds<.001) break;\n\t}\n\t\n\t//shading\n\t\n\tvec3 backdrop = background(p,d);\n\tvec3 a = backdrop;\n\t\n\t\n\t\n\tif (ds<1.0)\n\t{\n\t\ta = vec3(.0);\n\t\t//use noise functions for coloring\n\t\tvec4 tex;\n\t\n\t\t\ttex = \n\t\t\t\ttexture4d(vec4(p*pow(10.0+6.0*sin(t*.142),2.0)*.25,t*1.1)).xyzw;\n\t\t\n\t\tvec3 diffuse_color = tex.xyz;\n\t\t\n\t\tvec3 n = normal(p);\n\t\tn = normalize(n+(tex.zyx-vec3(.5))*tex.w);\n\t\t\n\t\tdiffuse_color = mix(diffuse_color,vec3(.2,.4,.8),.5);\n\n\t\tfloat fresnel = pow(1.0+dot(d,n),2.0);\n\t\tfresnel = min(1.0,fresnel);\n\t\t\n\t\tfor (float i=.0; i<1.0; i+=.2)\n\t\t{\n\t\t\tvec3 light = normalize(noise(t*.2+i*142100.0).xyz-vec3(.5));\n\t\t\t\n\t\t\tfloat diffuse = dot(n,light);\n\t\t\tdiffuse = pow(max(.0,diffuse*.9+.1),.7);\n\t\t\tvec3 light_color = normalize(noise(t*.1+i*15400.0).xyz);\n\t\t\tvec3 shading = mix((vec3(1.0)-light_color)*.125,light_color,diffuse);\n\t\t\tfloat highlight = pow(dot(reflect(d,n),light)*.5+.5,100.0)*2.0;\n\t\t\ta += (diffuse_color*shading+vec3(highlight)*fresnel)*(i+.2)*.7;\n\t\t}\n\t\t\n\t\t\n\t\ta += background(p,reflect(d,n))*fresnel;\n\t}\n\t\n\ta += noise(vec3(fragCoord.xy,t*24.0)).xyz*.02;\n\ta -= length(uv)*.1;\n\ta = mix(a,vec3(length(a)),a*1.5-.5);\n\t\n\tfragColor = vec4(pow(a,vec3(.7)),1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}