{
    "Shader": {
        "info": {
            "date": "1727844759",
            "description": "How to solve the broken lines that appear in the diagram? I have made many attempts, but they are only partially effective.",
            "flags": 0,
            "hasliked": 0,
            "id": "43SyDt",
            "likes": 7,
            "name": "Problem with Drawing a Spring",
            "published": 3,
            "tags": [
                "spring"
            ],
            "usePreview": 0,
            "username": "shadertoyjiang",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "\n\n// https://beautifier.io/\n// 2024-10-2\n// ! 可能遇到不同时缩放\n\n#define iTime (iTime*10.) \n//#define iTime min(iTime * 8., 21.3)\n\n#define PI 3.14159265358979\n#define TAU 6.2831853\n#define rot(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\n\n\n/*vec3 qq(vec2 u){\nvec3 p =vec3(3,0,0);// vec3(u.x,0,u.y)\nfloat A = PI / 2.000001 * min(.999999,iTime * .01); \n        float R = 18., r = 1.;\n        float a = atan(p.z, p.x) / TAU;\n        if (a < 0.) a += 1.;\n        \n        // x1: Unit angle (circumference of the spring's bottom surface)\n        // y1: Unit height\n        float x1 = 2. * PI * R, y1 = x1 * tan(A), kyx = y1 / x1;\n        \n        // i0: The total number of unit heights before this point\n        float i0 = floor(p.y / y1);\n        \n        // x: The x-coordinate of point p on the unfolded diagram, and y is the height column\n        // (The unfolding is of a cylinder with radius R)\n        float x = (i0 + a) * x1, y = p.y;\n        \n        vec3 ny =normalize(vec3(0,-x1,y1));\n        ny.xz = rot(x)*ny.xz;//  刚垂直\n        vec3 nx =normalize(vec3(p.x,0,p.z));\n        vec3 nz =cross(nx,ny);\n        nz=normalize(nz);nx = cross(ny,nz);\n        return u.x *nx + 0.*ny+ u.y*nz;\n        //return vec3(dot(p,nx),dot(p,ny),dot(p,nz));\n        \n        \n}*/\n\n\n\nfloat sdSpring(vec3 p) {\n        \n        // A: Incline angle\n        // R: Spring radius\n        // r: Wire radius\n        float A = PI / 2.000001 * min(.999999,iTime * .01); \n        float R = 16., r = 8.15;\n        float a = atan(p.z, p.x) / TAU;\n        if (a < 0.) a += 1.;\n        \n        // x1: Unit angle (circumference of the spring's bottom surface)\n        // y1: Unit height\n        float x1 = 2. * PI * R, y1 = x1 * tan(A), kyx = y1 / x1;\n        \n        // i0: The total number of unit heights before this point\n        float i0 = floor(p.y / y1);\n        \n        // x: The x-coordinate of point p on the unfolded diagram, and y is the height column\n        // (The unfolding is of a cylinder with radius R)\n        float x = (i0 + a) * x1, y = p.y;\n        \n        // p2: The corresponding position of input point p on the unfolded diagram\n        // n: Unit vector perpendicular to the spring (straight line) on the unfolded diagram.\n        vec2 p2 = vec2(x, y), \n             n = normalize(vec2(-y1, x1));\n        \n        // Move point p2 into a slanted strip (instead of a square step).\n        if (p2.y < p2.x / x1 * y1) p2.x -= x1;\n        \n        // Find the closest point j1 below p2 on the lower boundary of the strip and the closest point j2 above p2 on the upper boundary.\n        float dt1, dt2;\n        dt1 = dot(p2 - vec2(0), n);\n        vec2 j1 = p2 - dt1 * n;\n        dt2 = dot(p2 - vec2(-x1, 0), n);\n        vec2 j2 = p2 - dt2 * n; // j2.x += x1;//\n        \n        // Convert these two intersection points back to their actual 3D coordinates.\n        vec3 pj1 = vec3(R * cos(j1.x / R), j1.y, R * sin(j1.x / R));\n        vec3 pj2 = vec3(R * cos(j2.x / R), j2.y, R * sin(j2.x / R));\n        \n        // draw sphere\n        float d1 = length(p - pj1) - r;\n        float d2 = length(p - pj2) - r;\n        return min(d1,d2)*max(.01,(length(vec3(p.x,p.y*min(y1/x1,x1/y1),p.z))+.00001)/(length(p)+.000001)*.5);\n        //return min(min(d1,d2),R*.5);                  \n}\n\nfloat map(vec3 p) {\n        float t = iTime;\n        p.xz *= rot(t);\n        return sdSpring(p);\n}\n\nvoid mainImage(out vec4 O, vec2 v) {\n        O = vec4(0.5);\n        vec2 R = iResolution.xy,\n                u = (v + v + .1 - R) / R.y,\n                m = (iMouse.xy * 2. - R) / R.y;\n        \n        // spalmer \n        \n        \n        \n        vec3 q = vec3(u,iTime*0.).xzy * 18.;\n        if(iMouse.x<R.x*.51)q=q.yzx;\n        //q = qq(u*18.);\n        float mq = map(q);\n        //O.rgb = vec3(mq < 0., mq<18.&& mq > 0., mq>18.) * abs(sin(9. * mq))// * abs(tanh(mq*.04))\n                ;//*.4+.3;\n        \n        vec3 o = vec3(0, 1, -66),\n                r = normalize(vec3(u, 2)),\n                e = vec3(0, 1e-3, 0),\n                p, n,\n                s = normalize(vec3(-1, 2, -3));\n        float d, t, f, g, c;\n        for (int i; i < 256 && t < 115.; i++) {\n                p = o + r * t;\n                d = map(p);\n                if (d < .02) break;\n                t += d;\n        }\n        if (d < .02) {\n                O *= 0.;\n                n = normalize(vec3(map(p + e.yxx), map(p + e), map(p + e.xxy)) - d);\n                f = .5 + .5 * dot(n, s);\n                g = max(dot(n, s), 0.);\n                c = 1. + pow(f, 200.) - f * .3; // 665.352.6.542.9958.8.63\n                O += c * g;\n                O *= vec4(1.5,.5,0,1);\n        }\n}\n\n\n        //jj=j1;if(dt2<dt1)jj=j2;\n        \n        //vec3 nx; ny; nz;\n        //ny = rot(jj.x/R) * normalize(vec3(0,y1,x1));\n        //nz = vec3(0,-1,0);\n        //nx = normalize(cross(ny,nz));\n        //nz = cross(nx, ny);\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}