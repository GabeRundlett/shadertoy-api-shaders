{
    "Shader": {
        "info": {
            "date": "1459878301",
            "description": "Fractal Experiment 18 : Lattice",
            "flags": 1,
            "hasliked": 0,
            "id": "4s3XRB",
            "likes": 13,
            "name": "Fractal Experiment 18 : Lattice",
            "published": 3,
            "tags": [
                "fractal",
                "experiment",
                "lattice",
                "18"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 911
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nbased on https://www.shadertoy.com/view/4stXR7\n*/\n\nconst vec3 ld = vec3(0.,1., .5);\nfloat dstepf = 1.0;\nfloat t = 0.;\n\nvec2 path(float z){return sin(z*.2 + vec2(1.6,0));}\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nfloat fractus(vec3 p)\n{\n\tvec2 z = p.xy;\n    vec2 c = vec2(-1.04,-0.36) * vec2(cos(p.z), sin(p.z));\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<6.;i++)\n    {\n\t\th *= 4.*k;\n\t\tk = dot(z,z);\n\t\tif (k > 4.) break;\n        z = vec2(z.x * z.x - z.y * z.y, 2.* z.x * z.y) + c;\n    }\n\treturn  sqrt(k/h)*log(k);   \n}\n\nfloat df(vec3 p)\n{\n\tvec3 tutu;\n\t\n   \tvec3 pz = p;\n    pz.z += 0.;\n    pz.xy = mod(pz.xy, 8.) - 8.*0.5;\n\tpz *= getRotZMat(sin(pz.z*0.));\n\ttutu.x = min(1.,fractus(pz.xyz));\n\n\tvec3 py = p;\n\tpy.y += 0.;\n    py.xz = mod(py.xz, 8.) - 8.*0.5;\n\tpy *= getRotYMat(sin(py.y*0.));\n\ttutu.y = min(1.,fractus(py.xzy));\n\t\n\tvec3 px = p;\n    px.x += 0.;\n\tpx.z += -0.5;\n    px.yz = mod(px.yz, 8.) - 8.*0.5;\n\tpx *= getRotXMat(sin(px.x*0.));\n\ttutu.z = min(1.,fractus(px.yzx));\n\n\tfloat k = tutu.x*tutu.y*tutu.z;\n\treturn k;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy) - df(p-e.xyy),\n\t\tdf(p+e.yxy) - df(p-e.yxy),\n\t\tdf(p+e.yyx) - df(p-e.yyx) );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat h = df( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd, float prec) \n{\n    vec3 l = lp - p;\n    float d = max(length(l), 0.01);\n    float atten = 1.0-exp( -0.01*d*d );\n    l /= d;\n    \n    vec3 n = nor(p, prec);\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    dif *= softshadow(p, rd, 0.1, 1.);\n    \n    vec3 lin = vec3(0.08,0.32,0.47);\n    lin += 1.0*dif*vec3(1,1,0.84);\n    lin += 2.5*spe*dif*vec3(1,1,0.84);\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin * atten * calcAO(p, n);\n}\n\n\nfloat trace( in vec3 ro, in vec3 rd)\n{\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = ro;\n\t\n\tfor (float i=0.; i<150.; i++)\n\t{\n\t\tif (s < 0.025*log(d*d/s/500.) || d>40.) break; // last change was d*d\n\t\ts = df(p);\n\t\td += s * 0.2;\n\t\tp = ro + rd * d;\t\n\t\tdstepf += 0.005;\n\t}\n\t\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*fragCoord-si)/min(si.x, si.y);\n\n\tt = iTime * 0.1;\n\n    vec3 cu = vec3(0,1,0);\n    vec3 ro = vec3(cos(t),cos(t)*sin(t),sin(t));\n\tro.xz *= 10.5;\n    ro.y *= 9.;\n\tt+= .1;\n    vec3 co = ro + vec3(sin(t), cos(t),cos(t));\n\t\n\tfloat fov = 0.8;\n\tvec3 axisZ = normalize(co - ro);\n\tvec3 axisX = normalize(cross(cu, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rd = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat d = trace(ro, rd);\n\tvec3 p = ro + rd * d;\t\n\t\n    float fogd = 0.01;\n    if (iMouse.z>0.)\n        fogd = 0.001;\n    \n\tfragColor.rgb = vec3(0.47,0.6,0.76) * lighting(p, ro, rd, 0.0001); \n\tfragColor.rgb = mix( fragColor.rgb, vec3(0.5,0.49,0.72), 1.0-exp( -fogd*d*d ) ); \n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n\n    vec2 si = iResolution.xy;\n\tvec2 uv = (2.*fragCoord-si)/min(si.x, si.y);\n\n\tt = iTime * 0.1;\n\n    vec3 ro = fragRayOri;\n    vec3 rd = fragRayDir;\n    \n\tfloat d = trace(ro, rd);\n\tvec3 p = ro + rd * d;\t\n\t\n    float fogd = 0.01;\n    \n\tfragColor.rgb = vec3(0.47,0.6,0.76) * lighting(p, ro, rd, 0.0001); \n\tfragColor.rgb = mix( fragColor.rgb, vec3(0.5,0.49,0.72), 1.0-exp( -fogd*d*d ) ); \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}