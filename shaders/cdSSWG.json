{
    "Shader": {
        "info": {
            "date": "1670770842",
            "description": "Just learning how raytracing works, and also simultaneously figuring out how materials are done properly\n\nSignificant credit to Zavie's shaders for allowing me to understand light transport better than ever before.\n\nSmoothness doesn't do anything... yet",
            "flags": 0,
            "hasliked": 0,
            "id": "cdSSWG",
            "likes": 2,
            "name": "Reflective Raytracing",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 120
        },
        "renderpass": [
            {
                "code": "//Significant credit goes to Zavie, for creating https://www.shadertoy.com/view/llBGz1 which is \n//the shader I learned from for how to manage colours properly\n\n\nrayHit sphereRay(vec3 o, vec3 dirV, sphere sp)\n{    \n    rayHit hit;\n    hit.incoming = dirV;\n    hit.sphere = sp;\n\n    float t = dot(sp.pos - o, dirV);\n    vec3 p = o + dirV*t;\n    \n    float y = length(sp.pos - p);\n    \n    hit.t1 = cameraFarPlane;\n    hit.t2 = cameraFarPlane;\n    \n    if (y < sp.radius && t > 0.)//hit && in front of camera\n    {\n        float x = sqrt(sp.radius*sp.radius - y*y);\n        hit.t1 = t-x;\n        hit.t2 = t+x;\n        \n        vec3 p1 = o + dirV*hit.t1;\n        vec3 n = normalize(p1 - sp.pos);\n        hit.normal = n;\n        hit.hit = true;\n        hit.pos = o + dirV*hit.t1;\n        hit.mat = sp.mat;\n\n    }\n    else if (y < sp.radius)\n    {\n        hit.hit = false;\n        sphere nullSphere;\n        nullSphere.mat.col = vec3(0);\n        hit.sphere = nullSphere;\n    }\n    return hit;\n\n}\n\nrayHit planeRay(vec3 o, vec3 dirV, vec3 pos, vec3 normal)\n{\n    rayHit hit;\n    hit.incoming = dirV;\n    \n    float dist = abs(dot(normal, pos-o));\n    dist /= dot(dirV, -normal);\n    \n    \n    hit.t1 = cameraFarPlane;\n    hit.t2 = cameraFarPlane;\n\n    if (dist > 0.0)\n    {\n        hit.t1 = dist;\n        hit.hit = true;\n        hit.pos = o + hit.t1 * dirV;\n        hit.normal = normal;\n    }\n    \n    \n    if (length(hit.pos-pos-vec3(0, 0, 1.0)) > 4.0){\n        hit.hit = false;\n        /*hit.t1 = cameraFarPlane;\n        hit.t2 = cameraFarPlane;//*/\n    }\n    \n    return hit;\n    \n}\n\nrayHit ray(vec3 o, vec3 dirV)\n{\n\n    float time = iTime;\n    float metallic = 0.04;\n    float smoothness = 0.8;\n    \n    \n    sphere sp1;\n    sp1.pos = vec3(cos(time), 0, sin(time)); \n    sp1.radius = 1.0;\n    sp1.mat.col = vec3(0.0, 0.5, 1); \n    sp1.mat.metallic = metallic;\n    sp1.mat.smoothness = smoothness;\n    \n    sphere sp2;\n    sp2.radius = 100000.;\n    sp2.pos = vec3(0, -sp2.radius-sp1.radius*1.0, 0);\n    sp2.mat.col = vec3(0.5, 1, 0.5); \n    sp2.mat.metallic = metallic;\n    sp2.mat.smoothness = smoothness;\n    \n    sphere sp3;\n    sp3.pos = vec3(sin(time*2.0)*2.0, cos(time), 0); \n    sp3.radius = 0.5;\n    sp3.mat.col = vec3(1.0, 0.3, 0.2); \n    sp3.mat.metallic = metallic;\n    sp3.mat.smoothness = smoothness;\n    \n    \n    rayHit hits[3];\n    \n    hits[0] = sphereRay(o, dirV, sp1);\n    \n    //rayHit h2 = sphereRay(o, dirV, sp2);\n    \n    hits[2] = planeRay(o, dirV, vec3(0, -1.0, 0), vec3(0, 1, 0));\n    hits[2].mat.col = vec3(0.2, 0.7, 0.4);\n    vec3 p = hits[2].pos;\n    hits[2].mat.col *= mod(floor(p.x) + floor(p.y+0.1) + floor(p.z), 2.)*0.8 + 0.2;\n    hits[2].mat.metallic = metallic;\n    hits[2].mat.smoothness = smoothness;\n    \n    hits[1] = sphereRay(o, dirV, sp3);\n    \n    \n    \n    rayHit data;\n    data.t1 = -1.0;\n    float minDist = cameraFarPlane;\n    \n    for (int i = 0; i<3; i++){\n        if (minDist > hits[i].t1 && hits[i].hit){\n            minDist = hits[i].t1;\n            data = hits[i];\n        }\n    }\n    \n    if (data.t1 < 0.0)\n    {\n        data = hits[0];\n    }\n\n        \n    return data;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 lightDir = normalize(vec3(sin(time), 1., cos(time)));\n    \n    vec3 o = vec3(0, 0, -4);\n    //vec3 dirV = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec2 mouse = iMouse.z > 0.0?(iMouse.xy/iResolution.xy) * 2.0 - 1.0:vec2(0.0, -0.03);\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= mouseSensitivity*fieldOfView;    \n\n    vec2 p = (-iResolution.xy + fieldOfView*fragCoord.xy) / iResolution.y;\n    float an = mouse.x*mouseSensitivity - pi/2.0;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, (mouse.y*mouseSensitivity) +1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 dirV = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n\n    vec3 colTotal = vec3(0.0);\n    \n    for (int i = 0; i<1; i++){\n    \n        //o is origin of ray, aka camera position\n        rayHit data;\n        \n        /*\n        Random rng = seed(seed(fragCoord), iFrame); vec3 randVec = uniform_sphere_area(rng);         \n        dirV = normalize(mix(dirV, randVec, 1.0/iResolution.x));\n        //*/\n        \n        data.incoming = dirV;\n        data.pos = o;\n        data.reflection = data.incoming;\n\n        float light;\n        rayHit lightData;\n\n    \n        vec3 energy = vec3(1.0);\n        float f = 0.0;\n        col = vec3(0);\n\n        for (int i = 0; i<DEPTH; i++)\n        {\n            data = ray(data.pos, data.reflection);       \n            data.reflection = reflect(data.incoming, data.normal);\n\n\n            lightData = ray(data.pos, lightDir);\n            light = lightData.hit?0.0:1.0;\n            light = light * max(0.0, dot(data.normal, lightDir));\n\n            f = pow(1.0-clamp(dot(data.incoming, -data.normal), 0.0, 1.0), 5.0) * (1.0-data.mat.metallic) + data.mat.metallic ;\n\n            vec3 diffuse = (data.hit?\n                data.mat.col * light * energy * (1.0-f):\n                energy * background(time, data.reflection)\n            );\n\n            energy *= f * mix(vec3(1.0), data.mat.col, data.mat.metallic);\n\n\n            col = col + diffuse;\n            if (!data.hit){ break; }\n        }\n        \n        colTotal = colTotal + col;\n    }\n    colTotal = colTotal/1.0;\n    col = colTotal;\n\n    //col = vec3(energy);\n    //col = vec3((data.hit?0:1));\n    \n    \n    \n    // uniform reinhard\n    //*\n    vec3 O = col;\n    O *= 1.5;\n    float lum = dot(O.rgb, vec3(.2126, .7152, .0722));\n    O.rgb /= lum + 1.;\n    float whiteFac = max(log2(lum) / 5.0, 0.0);\n    O = mix(O, vec3(1.0), whiteFac);\n    col = O;\n    //*/\n    \n    col = pow(col, vec3(1.0/2.2)) * 1.055 - vec3(0.055);\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DEPTH 5\n\nstruct material\n{\n    float metallic;\n    float smoothness;\n    vec3 col;\n    \n};\n\nstruct sphere\n{\n    vec3 pos;\n    float radius;\n    material mat;\n};\n\nstruct rayHit\n{\n    float t1;\n    float t2;\n    vec3 pos;\n    vec3 normal;\n    vec3 incoming;\n    vec3 reflection;\n    bool hit;\n    sphere sphere;\n    material mat;\n};\n\nfloat remap01(float a, float b, float t)\n{\n    return (t-a)/(b-a);\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5)*vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\nconst float pi = 3.14159;\nfloat cameraFarPlane = 10000000.0;\nfloat fieldOfView = 2.;\nfloat mouseSensitivity = 2.;\n\n\n\n\n\n\n\n\n\n\n\n\n///RNG LIBRARY FROM https://www.shadertoy.com/view/ssGXDd by paniq\nuint uhash(uint a, uint b) { \n    uint x = ((a * 1597334673U) ^ (b * 3812015801U));\n#ifdef RNGL_HIGH_QUALITY\n    // from https://nullprogram.com/blog/2018/07/31/\n    x = x ^ (x >> 16u);\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n    x = x ^ (x >> 16u);\n#else\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n#endif\n    return x;\n}\nfloat unorm(uint n) { return float(n) * (1.0 / float(0xffffffffU)); }\n#define RNGL_HIGH_QUALITY\nstruct Random { uint s0; uint s1; };\nuint uhash(uint a, uint b);\nRandom seed(uint s) { return Random(s, uhash(0x1ef7c663u, s)); }\nRandom seed(uvec2 s) { return Random(s.y, uhash(s.x, s.y)); }\nRandom seed(Random a, uint b) { return Random(b, uhash(a.s1, b)); }\nRandom seed(Random a, uvec2 b) { return seed(a, uhash(b.x, b.y)); }\nRandom seed(Random a, uvec3 b) { return seed(a, uhash(uhash(b.x, b.y), b.z)); }\nRandom seed(Random a, uvec4 b) { return seed(a, uhash(uhash(b.x, b.y), uhash(b.z, b.w))); }\nRandom seed(uvec3 s) { return seed(seed(s.xy), s.z); }\nRandom seed(uvec4 s) { return seed(seed(s.xy), s.zw); }\nRandom seed(int s) { return seed(uint(s)); }\nRandom seed(ivec2 s) { return seed(uvec2(s)); }\nRandom seed(ivec3 s) { return seed(uvec3(s)); }\nRandom seed(ivec4 s) { return seed(uvec4(s)); }\nRandom seed(Random a, int b) { return seed(a, uint(b)); }\nRandom seed(Random a, ivec2 b) { return seed(a, uvec2(b)); }\nRandom seed(Random a, ivec3 b) { return seed(a, uvec3(b)); }\nRandom seed(Random a, ivec4 b) { return seed(a, uvec4(b)); }\nRandom seed(float s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec2 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec3 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec4 s) { return seed(floatBitsToUint(s)); }\nRandom seed(Random a, float b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec2 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec3 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec4 b) { return seed(a, floatBitsToUint(b)); }\nuint urandom(inout Random rng) {\n    uint last = rng.s1;\n    uint next = uhash(rng.s0, rng.s1);\n    rng.s0 = rng.s1; rng.s1 = next;\n    return last;\n}\nuvec2 urandom2(inout Random rng) { return uvec2(urandom(rng),urandom(rng)); }\nuvec3 urandom3(inout Random rng) { return uvec3(urandom2(rng),urandom(rng)); }\nuvec4 urandom4(inout Random rng) { return uvec4(urandom2(rng),urandom2(rng)); }\nint irandom(inout Random rng) { return int(urandom(rng)); }\nivec2 irandom2(inout Random rng) { return ivec2(urandom2(rng)); }\nivec3 irandom3(inout Random rng) { return ivec3(urandom3(rng)); }\nivec4 irandom4(inout Random rng) { return ivec4(urandom4(rng)); }\nfloat unorm(uint n);\nfloat random(inout Random rng) { return unorm(urandom(rng)); }\nvec2 random2(inout Random rng) { return vec2(random(rng),random(rng)); }\nvec3 random3(inout Random rng) { return vec3(random2(rng),random(rng)); }\nvec4 random4(inout Random rng) { return vec4(random2(rng),random2(rng)); }\nint range(inout Random rng, int mn, int mx) { return mn + (irandom(rng) % (mx - mn)); }\nivec2 range(inout Random rng, ivec2 mn, ivec2 mx) { return mn + (irandom2(rng) % (mx - mn)); }\nivec3 range(inout Random rng, ivec3 mn, ivec3 mx) { return mn + (irandom3(rng) % (mx - mn)); }\nivec4 range(inout Random rng, ivec4 mn, ivec4 mx) { return mn + (irandom4(rng) % (mx - mn)); }\nuint range(inout Random rng, uint mn, uint mx) { return mn + (urandom(rng) % (mx - mn)); }\nuvec2 range(inout Random rng, uvec2 mn, uvec2 mx) { return mn + (urandom2(rng) % (mx - mn)); }\nuvec3 range(inout Random rng, uvec3 mn, uvec3 mx) { return mn + (urandom3(rng) % (mx - mn)); }\nuvec4 range(inout Random rng, uvec4 mn, uvec4 mx) { return mn + (urandom4(rng) % (mx - mn)); }\nfloat range(inout Random rng, float mn, float mx) { float x=random(rng); return mn*(1.0-x) + mx*x; }\nvec2 range(inout Random rng, vec2 mn, vec2 mx) { vec2 x=random2(rng); return mn*(1.0-x) + mx*x; }\nvec3 range(inout Random rng, vec3 mn, vec3 mx) { vec3 x=random3(rng); return mn*(1.0-x) + mx*x; }\nvec4 range(inout Random rng, vec4 mn, vec4 mx) { vec4 x=random4(rng); return mn*(1.0-x) + mx*x; }\n\n\nvec3 uniform_sphere_area (inout Random rng) {\n    vec2 u = random2(rng);\n    float phi = 6.28318530718*u.x;\n    float rho_c = 2.0 * u.y - 1.0;\n    float rho_s = sqrt(1.0 - (rho_c * rho_c));\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}