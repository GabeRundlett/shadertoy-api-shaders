{
    "Shader": {
        "info": {
            "date": "1620418671",
            "description": "Benchmark for general SDF ([url]https://www.shadertoy.com/view/fsBXRG[/url]) by applying to ellipse.\nIn this case, there is already a shader that uses the same idea and seeks to be more efficient ([url]https://www.shadertoy.com/view/4lsXDN[/url]).",
            "flags": 0,
            "hasliked": 0,
            "id": "fsSSzG",
            "likes": 4,
            "name": "Apply General SDF to Ellipse",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2021 IWBTShyGuy\n\nconst int DIV = 50;\nconst int BISECTIONMAX = 10;\n\nconst float PARAM_MIN = -3.141592653;\nconst float PARAM_MAX = 3.141592653;\n\nvec2 curve(in float t, in vec2 ab) {\n    return vec2(ab.x * cos(t), ab.y * sin(t));\n}\n\nvec2 derive(in float t, in vec2 ab) {\n    return vec2(-ab.x * sin(t), ab.y * cos(t));\n}\n\n// Roughly find the parameter hint that minimizes the distance between p and curve(hint).\nfloat rough(in vec2 p, in vec2 ab) {\n    float hint = 0.0, mdist = 10.0;\n    for (int i = 0; i <= DIV; i++) {\n        float t = (PARAM_MAX - PARAM_MIN) * float(i) / float(DIV) + PARAM_MIN;\n        float dist = distance(curve(t, ab), p);\n        mdist = min(dist, mdist);\n        hint = t + sign(dist - mdist) * (hint - t);\n    }\n    return hint;\n}\n\n// Find the critical parameter t of the signed distance between p and curve(t) by the bisection method.\nfloat precise(in vec2 p, in vec2 ab) {\n    float hint = rough(p, ab);\n    float t0 = hint - (PARAM_MAX - PARAM_MIN) / float(DIV);\n    float t1 = hint + (PARAM_MAX - PARAM_MIN) / float(DIV);\n    for (int _i = 0; _i < BISECTIONMAX; _i++) {\n        float f0 = dot(derive(t0, ab), curve(t0, ab) - p);\n        float t = (t0 + t1) / 2.0;\n        float f = dot(derive(t, ab), curve(t, ab) - p);\n        t0 = t0 + max(sign(f * f0), 0.0) * (t - t0);\n        t1 = t1 - min(sign(f * f0), 0.0) * (t - t1);\n    }\n    return (t0 + t1) / 2.0;\n}\n\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    float t = precise(p, ab);\n    vec2 c = curve(t, ab);\n    vec2 d = derive(t, ab);\n    float s = sign((p.x - c.x) * d.y - (p.y - c.y) * d.x);\n    return s * distance(p, c);\n}\n\n// same mainImage as https://www.shadertoy.com/view/4sS3zz\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n\t\n \tfloat d = sdEllipse( uv, vec2(0.6,1.0)*m + vec2(0.4,0.2) );\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}