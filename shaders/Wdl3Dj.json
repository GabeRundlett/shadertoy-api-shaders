{
    "Shader": {
        "info": {
            "date": "1547539034",
            "description": "efx combination, the fbm is from thebookofshader",
            "flags": 0,
            "hasliked": 0,
            "id": "Wdl3Dj",
            "likes": 15,
            "name": "毒雾",
            "published": 3,
            "tags": [
                "voronoi",
                "fbm"
            ],
            "usePreview": 0,
            "username": "jcyuan",
            "viewed": 390
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define TAU 6.28318530718\n#define MAX_ITER 2\n#define SZ 5.\n\n#define NUM_OCTAVES 5\n\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float random( const in vec2 uv ) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );\n    return fract(sin(sn) * c);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// voronoi distance noise, based on iq's articles\nfloat voronoi(in vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tvec2 res = vec2(8.0);\n\tfor(int j = -1; j <= 1; j ++) {\n\t\tfor(int i = -1; i <= 1; i ++) {\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + random(p + b);\n\n\t\t\t// chebyshev distance, one of many ways to do this\n            float d = max(abs(r.x), abs(r.y));\n\n\t\t\tif(d < res.x) {\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = d;\n\t\t\t} else if(d < res.y) {\n\t\t\t\tres.y = d;\n\t\t\t}\n\t\t}\n\t}\n\treturn res.y - res.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = uv;\n    uv = (uv - 0.5) * 2.0;\n    float horzAlpha = 1. - uv.x;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    float inc = sin(iTime) * .5 + .5;\n    uv.x -= iTime * 0.1;\n    uv.y += inc * 0.01;\n\n\tfloat v = 0.0;\n\n\tfloat v1 = voronoi(uv * SZ + 5.0);\n\tfloat v2 = voronoi(uv * SZ * 0.5 + 50.0 + iTime);\n\n    float va = 1.0 - smoothstep(0.0, 0.1, v1);\n\tfloat vb = 1.0 - smoothstep(0.0, 0.08, v2);\n\n    v += pow(va * (0.5 + vb), 5.0);\n\n    vec3 thunder = vec3(v);\n\n    // ------\n    uv *= 2.;\n    vec2 q = vec2(\n        fbm( uv ),\n        fbm( uv + 1. )\n    );\n\n    vec2 r = vec2(\n        fbm( uv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * iTime ),\n        fbm( uv + 1.0 * q + vec2(8.3, 2.8) + 0.126 * iTime)\n    );\n\n    float f = fbm(uv + r);\n\n    vec3 wave = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f * f) * 4.0, 0.0, 1.0));\n\n    wave = mix(wave,\n                vec3(0, 0, 0.164706),\n                clamp(length(q), 0.0, 1.0));\n\n    wave = mix(wave,\n                vec3(0.666667, 1, 1),\n                clamp(length(r.x), 0.0, 1.0));\n\n    float DF = (f * f * f + .6 * f * f + .5 * f);\n    wave *= DF;\n    \n    vec3 color = (1. - smoothstep(.1, .8, DF)) * thunder;\n    color = mix(wave, color, .16);\n    \n    // float alpha = clamp(0., 1., DF * horzAlpha);\n    float alpha = DF;\n    \n    color *= pow(clamp(0., 1., DF * horzAlpha), 1.);\n\n    fragColor = vec4(mix(texture(iChannel0, suv).rgb, color, alpha), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}