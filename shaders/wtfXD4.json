{
    "Shader": {
        "info": {
            "date": "1567035999",
            "description": "Simple raymarched sdf of a loop ramp. To make the composition a bit more interesting a ball with sketchy physics has been added. The ball can be grabbed an dragged with the mouse. The view can be rotated with the arrow keys.",
            "flags": 48,
            "hasliked": 0,
            "id": "wtfXD4",
            "likes": 39,
            "name": "Loop Ramp",
            "published": 3,
            "tags": [
                "sdf",
                "physics"
            ],
            "usePreview": 0,
            "username": "glk7",
            "viewed": 955
        },
        "renderpass": [
            {
                "code": "// Created by genis sole - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nmat4 getState() {\n    return mat4(load(S0), load(S1), load(S2), load(S3));\n}\n\nmat4 sphere_state = mat4(0.0);\n\nvec2 iAABox(in vec3 ro, in vec3 rd, in vec3 invrd, vec3 b) \n{\n    vec3 t0 = (-b - ro) * invrd;\n    vec3 t1 = (b- ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    return vec2(fmin * sign(fmax - fmin), fmax);\n}\n\nfloat map_sphere(vec3 p)\n{\n    return length(p - sphere_state[1].xyz) - Sphere; \n}\n\nvec2 min_id(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b; \n}\n\nfloat scene_id(vec3 p) \n{\n    vec2 plane = vec2(map_plane(p), 0.0);\n    vec2 loop = vec2(map_loop(p), 1.0);\n    vec2 sphere = vec2(map_sphere(p), 2.0);\n    vec2 ramp = vec2(map_ramp(p), 3.0);\n    vec2 rails = vec2(map_rails(p), 4.0);\n\n    return min_id(plane, \n                  min_id(min_id(loop, rails), \n                         min_id(sphere, ramp))).y;\n}\n\nfloat scene_map(vec3 p) \n{\n\treturn min(map(p), map_sphere(p));     \n}\n\nvec3 scene_normal(vec3 p, float w) \n{\n    vec3 e = vec3(w, 0.0, 0.0);\n\n\treturn normalize(vec3(\n        scene_map(p + e.xyy) - scene_map(p - e.xyy),\n        scene_map(p + e.yxy) - scene_map(p - e.yxy),\n        scene_map(p + e.yyx) - scene_map(p - e.yyx)));\n}\n\nfloat ambinet_occlusion(vec3 ro, vec3 n)\n{   \n    float occ = 0.0;\n    float ff = 1.0;\n    \n    for( int i = 0; i < 5; ++i ){\n        float d = 0.1 + 0.03*float(i);\n        \n        float sd = scene_map(ro + n*d);\n        \n        occ += (sd - d)*-ff;\n        ff *= 0.4;\n    }\n    \n    return clamp(1.0 - 1.0*occ, 0.0, 1.0);    \n}\n\nfloat shadow_traversal(vec3 ro, vec3 rd, float maxd)\n{   \n    float d = 0.0;\n    float s = 1.0;\n    \n    for( int i = 1 << 7; i > 0; --i ){\n        float sd = scene_map(ro + rd*d);\n        \n        if (sd < 0.0001) return 0.0;\n        \n        d += sd;\n        s = min(s, sd*128.0/d);\n        \n        if (d > maxd) break;\n    }\n    \n    return s;\n}\n\nvec4 material(vec3 p, vec3 n, float id)\n{   \n    const vec4 fc = vec4(vec3(0.6,0.7,0.8), 0.9);\n    \n    if (id < 0.5) {\n        return vec4(fc)*0.8;\n    }\n    else if (id < 1.5) {\n      \tvec3 pl = vec3(abs(p.x), p.y, p.z * sign(p.x));\n    \n    \tfloat y = normalize(pl.xy).y * 0.5 - 0.5;\n    \n    \tfloat s = atan(pl.x, pl.y) - sign(p.x)*abs(pl.z + y*1.3)*0.15;\n    \tfloat a = mod(min(18.0, floor((s + 0.08) * 20.0/PI)), 2.0);\n        //a *= step(dot(n,normalize(p)), 0.0);\n    \treturn mix(fc, vec4(vec3(1.0, 0.4, 0.05), 0.15), a);\n    }\n    else if (id < 2.5) {\n    \tp = quatRotate(quatConjugate(sphere_state[0]), p - sphere_state[1].xyz);\n        vec2 b = sign(p.xz);\n        float h = abs(step(p.y, 0.0) - step(0.0, b.x*b.y)) * 0.5 + 0.2;\n        return vec4(h, h, 0.0, 0.4);    \n    }\n    \n    return fc;\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float e)\n{    \n    const vec3 l = normalize(vec3(5.0, 3.5, -3.0));\n    const vec3 plc = vec3(5.0, 4.5, 3.5)*0.5;\n\tconst vec3 slc = vec3(0.3, 0.4, 0.5);\n    \n    if (d > 10000.0) {\n        vec3 pl = plc*0.2 * pow(max(0.0, dot(rd, l)), 20.);\n        return mix(slc + pl - 0.3*rd.y, vec3(0.6), exp(-rd.y*20.));\n    }\n    \n    float id = scene_id(p);\n    vec3 n = scene_normal(p, 0.001);\n    \n    float sh = shadow_traversal(p + l*0.1, l, 50.);\n    float ao = ambinet_occlusion(p + n*0.01, n);\n    \n    vec4 m = material(p, n, id);\n    \n    vec3 h = normalize(l - rd);\n    \n    float ndotv = max(0.0, dot(n, -rd));\n    float ndotl = max(0.0, dot(n, l));\n    float ndoth = max(0.0, dot(n, h));\n    \n    float a2 = m.a*m.a;\n    float dd = (ndoth*ndoth * (a2 - 1.0) + 1.0);\n    float ggx_d = a2 / (PI * dd * dd);\n    \n    float r = (m.a + 1.0);\n    float k = (r*r) / 8.0;\n\t\n    float ggx1 = ndotv / (ndotv * (1.0 - k) + k);\n    float ggx2 = ndotl / (ndotl * (1.0 - k) + k);\n                          \n    vec3 l1 = plc * sh * ndotl;\n    vec3 l2 = max(0.0, n.y) * (plc*0.1 + slc*0.1);\n    \n    float fr = 0.04 + (max(1.0 - m.a, 0.04) - 0.04) * pow(1.0 - ndotv, 5.0);\n    \n    float fr_l1 = 0.04 + (1.0 - 0.04) * pow(1.0 - ndoth, 5.0);\n    \n    float spec = (ggx_d * ggx1 * ggx2 * fr_l1) / \n        max(0.001, (4.0 * ndotv * ndotl));\n    \n    vec3 diff = m.rgb/PI * (1.0 - fr_l1);\n    \n    vec3 c1 = l1 * (spec + diff);\n    vec3 c2 = l2 * (m.rgb/PI) * (1.0 - fr) * ao + fr * slc*1.0;\n    \n    return mix(vec3(0.6), c1 + c2 + m.rgb*ao*0.6, exp(-d*0.001));\n}\n\nfloat traversal(vec3 ro, vec3 rd, float d, float maxd)\n{   \n    for( int i = 1 << 8; i > 0; --i ){\n        float sd = map(ro + rd*d);\n        \n       \tif (sd < 0.001 || d > maxd) break;\n        \n        d += sd;\n    }\n    \n    if( d > maxd ) return -1.0;\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat e = 1.0 / iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    \n    vec3 ro = vec3(0.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    \n    mat4 T = camera(load(CAMERA).xy, iTime);\n    \n    ro = (T * vec4(ro, 1.0)).xyz;\n    rd = mat3(T) * rd;\n    vec3 invrd = 1.0 / rd;\n    \n    mat4 iT = mat4(transpose(mat3(T)));\n    iT[3] = vec4(0.0, 0.0, cam_dist, 1.0);\n    \n    sphere_state = getState();\n    \n   \tvec2 ibox = iAABox(ro, rd, invrd, bbox*1.1);\n    float sd = iSphere(ro - sphere_state[1].xyz, rd, Sphere);\n    float pd = (-ro.y - 3.2)*invrd.y;\n    \n    float td = -1.0;\n    if (ibox.x > 0.0) td = traversal(ro, rd, ibox.x, ibox.y);\n    \n    sd = abs(sd) + step(sd, 0.0)*10000.0;\n    td = abs(td) + step(td, 0.0)*10000.0;\n    pd = abs(pd) + step(pd, 0.0)*10000.0;\n    \n    td = min(pd, min(sd, td));\n    \n    vec3 c = shade(ro + rd*td, rd, td, e);\n    \n    vec2 v = uv*0.5;\n    c = c * (1.0 - dot(v, v)*2.0) ;\n  \n    fragColor = vec4(vec3(pow(clamp(c, 0.0, 1.0), vec3(0.4545))), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by genis sole - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel0, P, 0)\n#define key(K)  step(0.5, texelFetch(iChannel1, ivec2(K, 0), 0).x)\n\nconst int KEY_R = 82;\n\nconst vec3 G = vec3(0.0, -9.81, 0.0);\nconst float M = 10.0;\nconst float invM = 1.0/M;\n\n\nconst mat3 invI_sphere = inverse(\n        mat3((2.0/5.0) * M*Sphere*Sphere, 0.0, 0.0, \n             0.0, (2.0/5.0) * M*Sphere*Sphere, 0.0, \n             0.0, 0.0, (2.0/5.0) * M*Sphere*Sphere));\n\nmat4 getState() {\n    return mat4(load(S0), load(S1), load(S2), load(S3));\n}\n\nvoid storeState(inout vec4 fragColor, in ivec2 fragCoord, mat4 s) {\n    store(S0, s[0]);\n    store(S1, s[1]);\n    store(S2, s[2]);\n    store(S3, s[3]);\n}\n\nvec3 c_points[6];\nvec4 c_normal_dist[6];\nvoid findContactPoints(vec3 x)\n{\n    const vec3 so = vec3(Sphere*0.1, 0.0, 0.0);\n    c_points = vec3[6](so.xyy, -so.xyy, so.yxy, -so.yxy, so.yyx, -so.yyx);\n    \n    for( int cp = 0; cp < 6; ++cp ){\n        vec3 p = c_points[cp] + x;\n\t\t\n        float dist = 1000.0;\n        float sph_dist = 0.0;\n        vec3 n = vec3(0.0);\n        for (int i = 0; i < 32; ++i) {\n            dist = map(p);\n            sph_dist = length(p - x) - Sphere;\n            n = -normal(p, 0.001);\n\n            if (dist < 0.001 || sph_dist > 0.001) break; \n\n            p += n*dist;\n\n        }\n\n        if (abs(dist) < 0.001 && sph_dist > 0.001) {\n        \tc_points[cp] = vec3(0.0);\n            c_normal_dist[cp] = vec4(1000.0);\n        }\n        else {\n       \t\tc_points[cp] = p - x;\n        \tc_normal_dist[cp] = vec4(-n, dist);\n        }\n    }\n}\n\nvoid contactFriction(vec3 x, vec3 v, vec3 omega, out vec3 F, out vec3 T)\n{\n    F = vec3(0.0);\n    T = vec3(0.0);\n    \n    for (int cp = 0; cp < 6; ++cp){\n        vec3 p = c_points[cp];\n  \t\tfloat dist = c_normal_dist[cp].w;\n        vec3 n = c_normal_dist[cp].xyz;\n        \n        if (dist > 0.001) continue;\n        \n       \tvec3 vp = v + cross(omega, p);\n        \t\n        vec3 fd = vp - dot(vp, n)*n;\n        \n        vec3 ff = -fd*M*10.0;\n        F += ff;\n        T += cross(p, ff);\n    }\n}\n\nvoid collisionImpulse(vec3 x, vec4 q, vec3 v, vec3 omega, mat3 invI, inout vec3 P, inout vec3 L) {  \n\n    //for (int s = 0; s < 5; ++s){\n        for (int cp = min(iFrame,0); cp < 6; ++cp) {\n            float dist = c_normal_dist[cp].w;\n            if (dist > 0.001) continue;\n            \n       \t\tvec3 p = c_points[cp];\n            \n          \tvec3 n = c_normal_dist[cp].xyz;\n            \n        \tfloat vrel = dot(n, v + cross(omega, p));\n\n            if (vrel > 0.001) continue;\n            \n            float epsilon = 0.5;\n            vec3 f = n * ((-vrel*(1.0 + epsilon))\n                          / ((invM + dot(n, cross(invI*cross(p, n), p)))));\n\n            P += f;\n            L += cross(p, f);\n\n            v = P*invM;\n            omega = invI*L;\n\n        }\n    //}\n}\n\nvoid integrate(in vec3 F, in vec3 T, inout mat4 s) {\n\tvec4 q = s[0];\n    vec3 x = s[1].xyz;\n    vec3 P = s[2].xyz;\n    vec3 L = s[3].xyz;\n\n    float boxd = sdBox(x, bbox) - Sphere;\n    \n    float fdis = -mix(2.9, 3.2, step(0.0, boxd));\n    x.y = max(fdis + Sphere, x.y);\n  \n    if(length(x.xz) > 50.0) {\n    \tx = vec3(-1.0, -0.5, 1.);\n        P = vec3(0.0);\n        L = vec3(0.0);\n    }\n\n    float dt = iTimeDelta/16.;\n    \n    for (int i = 0; i < 16; ++i) {\n    \t\n       \tvec3 v = P*invM;\n   \t\tmat3 R = quatMat3Cast(q);\n    \tmat3 invI = R*invI_sphere*transpose(R);\n    \tvec3 omega = invI*L;\n        \n        if (map(x + v*dt) - Sphere < 0.001) {\n            findContactPoints(x);\n            vec3 fF;\n            vec3 fT;\n            contactFriction(x, v, omega, fF, fT);\n            F += fF*dt;\n        \tL += fT*dt;\n            \n            collisionImpulse(x, q, v, omega, invI, P, L);\n    \t}\n        \n    \tx += v*dt;\n    \tq += 0.5 * quatMult(vec4(omega*dt, 0.0), q);\n    \tq = normalize(q);\n\n    \tP += F*dt;\n    \tL += T*dt;\n    }\n    \n    s = mat4(q, vec4(x, 1.0), vec4(P, 0.0), vec4(L, 0.0));\n}\n\nbool init(inout vec4 fragColor, in ivec2 fragCoord) {\n    if (iTime == 0.0 || iFrame == 0) {\n\n        mat4 s = mat4(quat(normalize(vec3(1.0, 1.0, 1.0)), 0.0),\n                      vec4(-6.5,6.5, 0.9, 1.0),\n                      vec4(0.0, 0.0, 0.0, 0.0),\n                      vec4(0.0, 0.0, 0.0, 0.0));\n\n        storeState(fragColor, fragCoord, s);  \n        store(SELECTION, vec4(0.0));\n   \t\tstore(MOUSE, vec4(-1.0));\n        store(CLICK, vec4(0.0));\n        store(CAMERA, vec4(3.*PI - 0.1*0.0, PI*0.25 + 0.1, 0.0, 0.0));\n        \n        return true;\n    }\n    \n    return false;\n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 deltaKeys()\n{\n    return vec2(key(KEY_LEFT) - key(KEY_RIGHT), \n                key(KEY_DOWN) - key(KEY_UP)) * \n        \tvec2(1.0, 2.0)*0.15 * iTimeDelta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 ifragCoord = ivec2(fragCoord);\n    if (any(greaterThan(ifragCoord, MEMORY_BOUNDARY))) return;\n\n    fragColor = load(ifragCoord);\n\n    if (init(fragColor, ifragCoord)) return;\n   \n    mat4 s = getState();\n\n    float e = 1.0 / iResolution.x;\n    vec2 uv = (iMouse.xy - iResolution.xy*0.5) * e;\n    \n    vec4 mouse = load(MOUSE);\n    store(MOUSE, iMouse);\n   \n    vec2 cam = load(CAMERA).xy + deltaKeys(); \n    cam.y = clamp(cam.y, 0.3, PI*0.25 + 0.25);\n    store(CAMERA, vec4(cam, 0.0, 0.0));\n    \n    vec4 selection = load(SELECTION);\n    \n    mat4 v = camera(cam, iTime);\n    \n    vec3 ro = (v * vec4(vec3(0.0), 1.0)).xyz;\n    vec3 rd = mat3(v) * normalize(vec3(uv, 1.0));\n\n    if (iMouse.w > 0.0) {\n        float d = iSphere(ro - s[1].xyz, rd, Sphere);\n            \n        selection = vec4(ro+rd*d, d);\n        store(SELECTION, selection);\n    }\n    else if (iMouse.z < 0.0) { \n        if (selection.w > 0.0) {\n            selection = vec4(vec3(0.0), -1.0);\n            store(SELECTION, selection);\n        }\n    }\n    \n    vec3 F = G*M;\n    vec3 T = vec3(0.0);\n    \n    if (selection.w > 0.0) {\n        vec3 t = ro + rd * selection.w;\n        if (t.y < -3.2) t = ro + rd * (-ro.y - 3.2)/rd.y;\n        vec3 p = s[1].xyz;\n        s[2].xyz = (t - p)*2.0*M;\n    }\n\t\n    integrate(F, T, s);\n\n    storeState(fragColor, ifragCoord, s);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by genis sole - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(2, 4);\n\nconst int STATE = 0;\nconst int WINDOW = 1;\n\nconst ivec2 S0 = ivec2(STATE, 0);\nconst ivec2 S1 = ivec2(STATE, 1);\nconst ivec2 S2 = ivec2(STATE, 2);\nconst ivec2 S3 = ivec2(STATE, 3);\n\nconst ivec2 SELECTION = ivec2(WINDOW, 0);\nconst ivec2 MOUSE = ivec2(WINDOW, 1);\nconst ivec2 CLICK = ivec2(WINDOW, 2);\nconst ivec2 CAMERA = ivec2(WINDOW, 3);\n\nconst float PI = 3.141592;\n\nconst float cam_dist = 30.0;\nconst float Sphere = 0.5;\nconst vec3 bbox = vec3(4.5 + 1.6*2.0, 3.4, 3.4);\n\nvec4 quat(vec3 axis, float rads) {\n    return vec4(sin(rads*0.5)*axis, cos(rads*0.5)); \n}\n\nvec4 quatMult(vec4 q1, vec4 q2) {\n    return vec4(q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz),\n                q1.w*q2.w - dot(q1.xyz, q2.xyz));\n}\n\nvec3 quatRotate(vec4 q, vec3 v) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 quatConjugate(vec4 q) {\n\treturn vec4(-q.xyz, q.w);    \n}\n\nmat3 quatMat3Cast(vec4 q) {\n    float xx = 2.0*q.x*q.x;\n    float yy = 2.0*q.y*q.y;\n    float zz = 2.0*q.z*q.z;\n    float xy = 2.0*q.x*q.y;\n    float xz = 2.0*q.x*q.z;\n    float yz = 2.0*q.y*q.z;\n\n    float w = 2.0*q.w;\n    float wx = w*q.x;\n    float wy = w*q.y;\n    float wz = w*q.z;\n\n    return mat3(1.0 - yy - zz, xy + wz, xz - wy,\n                xy - wz, 1.0 - xx - zz, yz + wx,\n                xz + wy, yz - wx, 1.0 - xx - yy);\n                               \n}\n\nmat4 camera(vec2 mouse, float time) \n{\n    vec2 m = (-vec2(mouse) * vec2(2.0*PI, PI*0.5)) - vec2(2.0*PI, -PI*0.5);\n    /*\n    if (all(lessThan(mouse, vec2(0.01)))) {\n        m = vec2(cos(time*0.05 + 4.3)*PI, sin(time*0.1)*0.5 + 0.5);\n    }*/\n    \n    vec2 c = cos(m);\n    vec2 s = sin(m);\n    \n   \tmat4 t = mat4(c.x, 0.0, -s.x, 0.0, \n                  s.x*s.y, c.y, c.x*s.y, 0.0, \n                  s.x*c.y, -s.y, c.x*c.y, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    \n    t[3] = vec4(t[2].xyz * -cam_dist, 1.0); \n\n    return t;\n    \n}\n\nfloat iSphere(vec3 ro, vec3 rd, float r) \n{\n    float p = dot(rd, ro);\n    float t = p*p - dot(ro, ro) + r*r;\n    \n    if (t < 0.0) return -1.0;\n    \n    return -p - sqrt(t);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdPipe(vec3 p, vec3 t)\n{\n\treturn max(abs(p.z) - t.z, abs(length(p.xy) - t.x) - t.y);\n}\n\nfloat sdLoop(vec3 p, vec4 l, vec2 r)\n{\n    vec3 pl = vec3(abs(p.x), p.y, p.z * sign(p.x));\n    pl.z = abs(pl.z + l.w*(normalize(pl.xy).y * 0.5 - 0.5));\n    \n    vec4 lr = vec4(l.x, l.w, 0.3, 0.09).xzwy;\n    //lr.x -= 0.15+0.05;\n    float sd_loop = max(-pl.x, sdPipe(pl, l.xyz));\n    float sd_rim_l = max(-pl.x, sdPipe(pl - vec3(0.0, 0.0, l.z), lr.xyz));\n                        \n    return min(sd_loop, sd_rim_l);\n}\n\n\nfloat map_rails(vec3 p)\n{\n    vec4 l = vec4(3.0, 0.1, 1.0, 1.3);\n    vec4 lr = vec4(l.xw, 0.3, 0.09).xzwy;\n    \n    vec3 pf = vec3(abs(p.x), p.y, p.z * -sign(p.x));\n    pf.z = abs(pf.z - l.w);\n    \n\treturn sdBox(pf - vec3(1.0, -l.x, l.z), vec3(lr.yz, 1.0).zxy);\n}\n\nfloat map_loop(vec3 p) \n{\n    return sdLoop(p, vec4(3.0, 0.1, 1.0, 1.3), vec2(0.2, 0.05));\n}\n\nfloat map_ramp(vec3 p)\n{\n    const vec3 b = vec3(4.5, 0.2, 3.5);\n    const vec3 sb = vec3(1.6, 1.5, b.z);\n   \t\n    const vec3 st = vec3(b.x + sb.x, sb.y - b.y, 0.0);\n    const vec2 ct = st.xy + sb.xy*vec2(-1.0, 1.0);\n    const vec2 tt = st.xy + sb.xy - vec2(0.3, 0.2);\n    \n    p = vec3(abs(p.x), p.y + 3.1, abs(p.z));\n   \n  \treturn max(-length(p.xy - ct) + 2.0*(sb.y - b.y),\n                min(sdBox(p - st , sb), sdBox(p, b)));\n}\n\nfloat map_plane(vec3 p)\n{\n\treturn p.y + 3.2;   \n}\n\nfloat map(vec3 p)\n{\n    return min(map_plane(p), min(map_ramp(p), min(map_rails(p), map_loop(p)*0.95)));\n}\n\nvec3 normal(vec3 p, float w) \n{\n    vec3 e = vec3(w, 0.0, 0.0);\n\n\treturn normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}