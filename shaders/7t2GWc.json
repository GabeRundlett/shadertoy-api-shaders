{
    "Shader": {
        "info": {
            "date": "1624895212",
            "description": "IFS with Field of space",
            "flags": 0,
            "hasliked": 0,
            "id": "7t2GWc",
            "likes": 4,
            "name": "IFS with Field of space",
            "published": 3,
            "tags": [
                "ifs"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 554
        },
        "renderpass": [
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n#define MATERIAL_DIFFUSE0 0\n#define MATERIAL_REFLECT 10\n\nconst float Epsilon = 1e-10;\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 combine(vec2 val1, vec2 val2, float k){\n    vec2 res1 = val1;\n    vec2 res2 = val2;\n    res1.x = smin(val2.x,val1.x,k);\n    res2.x = smin(val1.x,val2.x,k);\n    return (val1.x < val2.x)?res1:res2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                      dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                      dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n         +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                           max(p.y,max(q.z,q.x))),\n                           max(p.z,max(q.x,q.y))));\n}\n\nvec2 GetDist(vec3 p) {\n    float t = iTime*0.1;\n    \n    mat3 rot = matRotateZ(radians(-25.0)+t*2.0);\n    vec3 prevP = p*rot;\n\n    float d = 10000.0;\n    p.z = mod(p.z,5.)-2.5;\n    float maskd = sdBox(p,vec3(3.0,3.0,5.0));\n    \n    p = prevP;\n    p.z+=iTime*5.0;\n    p.xy = mod(p.xy,9.)-4.5;\n    p.z = mod(p.z,8.)-4.;\n    \n    mat3 rot2 = matRotateX(radians(-25.0)+t)*matRotateY(radians(30.0)+t);\n    \n    for(float i = 1.; i<=5.; i++){\n        p = abs(p);\n        p -= (0.5)*i;\n        p *= rot2;\n        d = min(d,sdBoundingBox(p, vec3(1.9,1.9,2.),.05));\n    }\n    \n    d = max(maskd,d);\n    p = prevP;\n    d = max(sdBox(p,vec3(5.0,5.0,19.0)),d);\n    \n    vec2 res = vec2(d, MATERIAL_REFLECT);\n        \n    vec2 model = res;\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(rd,n);\n    vec3 col = r;\n    \n    float nn = cnoise(p.xy*3.0);\n    col += nn*5.0;\n    float k = r.y*2.5+2.5;\n    col = mix(col*vec3(0.5),vec3(0.5),k);\n    return col;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 col) {\n    float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n    return vec3(dif)*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 3, -5.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(mod(iTime,20.0)<17.0){\n        ro.xz *= Rot(iTime*.1+1.0);\n    } else {\n        ro.xz *= Rot(radians(0.0));\n    }\n    \n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,-0.3,0), 1.5);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(0.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        \n        int mat = int(d.y);\n        if(mat == MATERIAL_DIFFUSE0){\n            col = diffuseMaterial(n,vec3(1.0));\n        } else if(mat == MATERIAL_REFLECT) {\n            col = reflectMaterial(p,rd,n);\n        }\n\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.3545) );\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}