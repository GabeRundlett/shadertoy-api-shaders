{
    "Shader": {
        "info": {
            "date": "1639836926",
            "description": "Hitomezashi 3d. Inspired by Ayliean MacDonald on Numberphile: [url]https://www.youtube.com/watch?v=JbfhzlMk2eY[/url]",
            "flags": 16,
            "hasliked": 0,
            "id": "7tdXDj",
            "likes": 19,
            "name": "Hitomezashi 3D",
            "published": 3,
            "tags": [
                "3d",
                "hitomezashi"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 415
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////\n//\n// 3D Hitomezashi Patterns, Matthew Arcus, mla. 2021\n//\n// Inspired by the Numberphile video by Ayliean MacDonald:\n// https://www.youtube.com/watch?v=JbfhzlMk2eY\n//\n// Mouse moves viewpoint\n// 'a': turn on AA\n// 'c': clip to cube\n// 'r': autorotation\n// 't': autotranslation\n// 'x': variable randomicity\n//\n////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool dotranslate = true;\nbool doclamp = false;\n\nfloat N = 9.0; // Clamped size\nfloat vradius = 0.1; // Vertex radius\nfloat eradius = 0.05; // Edge radius\nfloat maxdist = 50.0;\n\nfloat eyedist = 10.0;     // Distance of eye from origin\nvec3 light = vec3(0,2,1); // Light direction\nint numsteps = 200;       // Maximum raymarching steps\nfloat precis = 1e-3;      // Raymarching precision\n\nvec3 clampvertex(vec3 vertex){\n  if (!doclamp) return vertex;\n  return clamp(vertex,0.0,N);\n}\n\n// It seems worth caching data for the last vertex used.\nvec3 lastvertex = vec3(0.5);\nvec3 vx,vy,vz;\n\nfloat threshold = 0.5; // Randomization threshold\n\nfloat de0(vec3 z, out int type) {\n  if (dotranslate) z.z -= iTime;\n  z += 0.5*N; \n  vec3 vertex = round(z);\n  vertex = clampvertex(vertex);\n  if (vertex != lastvertex) {\n    lastvertex = vertex;\n    vec3 signs = 2.0*mod(vertex,2.0)-1.0;\n    vec3 lines = vec3(hash(vertex.yz),\n                      hash(vertex.zx),\n                      hash(vertex.xy));\n    signs *= 2.0*vec3(lines.x<threshold,\n                      lines.y<threshold,\n                      lines.z<threshold)-1.0;\n    vx = clampvertex(vertex-signs.x*vec3(1,0,0));\n    vy = clampvertex(vertex-signs.y*vec3(0,1,0));\n    vz = clampvertex(vertex-signs.z*vec3(0,0,1));\n  }\n  int xytype = 1+(int(vertex.z) & 1);\n  float d = 1e8, d1;\n  d1 = distance(z,vertex)-vradius;\n  if (d1 < d) { d = d1; type = 0; }\n  d1 = segment(z,vertex,vx)-eradius;\n  if (d1 < d) { d = d1; type = xytype; }\n  d1 = segment(z,vertex,vy)-eradius;\n  if (d1 < d) { d = d1; type = xytype; }\n  d1 = segment(z,vertex,vz)-eradius;\n  if (d1 < d) { d = d1; type = 3; }\n  return d;\n}\n\nfloat de(vec3 z, out int type) {\n  int t1,t2;\n  float d = de0(z,type);\n  float d1 = d;\n  //d1 = de0(z.yzx+0.5,t1);\n  //if (d1 < d) { d = d1; type = t1; }\n  return d;\n}\n\nfloat de(vec3 z) {\n  int type;\n  return de(z,type);\n}\n\nvec3 getbackground(vec3 r) {\n  if (key(CHAR_B)) return vec3(0);\n  return vec3(1,1,0.8);\n}\n\nvec3 getbasecolor(int type) {\n  if (type == 0) return vec3(0.2);\n  if (type == 1) return 0.2+0.8*vec3(1,0,0);\n  if (type == 2) return 0.2+0.8*vec3(0,0,1);\n  if (type == 3) return 0.2+0.8*vec3(1,1,0);\n  return vec3(1,0,1);\n}\n\nfloat march(vec3 q, vec3 r) {\n  float t = 0.01; // Total distance so far.\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 50);\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t;\n    t += 0.8*d;\n    // We might go backwards!\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p, float t) {\n  float eps = 1e-3;\n  vec2 e = vec2(eps,0);\n  float k = de(p);\n  return normalize(vec3(de(p + e.xyy) - k,\n                        de(p + e.yxy) - k,\n                        de(p + e.yyx) - k));\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n      float t = iTime;\n      p.yz = rotate(p.yz,-t*0.05);\n      p.zx = rotate(p.zx,-t*0.05);\n  }\n  return p;\n}\n\n// Follow ray from q, direction r.\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p,t);\n  int type = 0;\n  de(p,type);\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  vec3 lightdir = normalize(light);\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n    if (!key(CHAR_S)) {\n    float specular = pow(max(0.0,dot(reflect(lightdir,normal),r)),4.0);\n    color += specular;\n  }\n  if (!key(CHAR_F)) color = mix(color,getbackground(r),clamp(t/(maxdist),0.0,1.0));\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  int AA = 1;\n  if (key(CHAR_A)) AA = 2;\n  dorotate = key(CHAR_R);\n  doclamp = key(CHAR_C);\n  dotranslate = !doclamp && !key(CHAR_T);\n  if (key(CHAR_X)) threshold += 0.5*(cos(0.2*PI*iTime));\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      if (key(CHAR_I)) {\n        eye = transformframe(vec3(4.0*z,-8.0));\n        ray = vec3(0,0,1);\n      }\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;;\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(vec2 p) {\n  uint ux = uint(int(p.x));\n  uint uy = uint(int(p.y));\n  uint h = ihash(ux^(uy<<16));\n  return float(h)/pow(2.0,32.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}