{
    "Shader": {
        "info": {
            "date": "1533467493",
            "description": "SpellCard of Okina Matara\nhttps://www.youtube.com/watch?v=yPsNtvYR_HI&t=23m05s\n\nTouch the screen to interact with shader.",
            "flags": 32,
            "hasliked": 0,
            "id": "ltdyD7",
            "likes": 9,
            "name": "Touhou 16 Stage 6 Boss spellcard",
            "published": 3,
            "tags": [
                "2d",
                "particles",
                "touhou"
            ],
            "usePreview": 0,
            "username": "0x384c0",
            "viewed": 1268
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 f, vec2 g )\n{\n\tf = texture(iChannel0, g/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//RENDERER SHADER\n\n\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \n#define SCALE 40.\n#define STAR_SIZE 0.0001\n#define LENSE_EFFECT 0\nconst float star_luminosity = 1e3;\nvec3 star_color = vec3(210./255., 166./255., 99./255.)*star_luminosity;\nvec2 FragCoord;\nvec3 draw_star(vec2 pos, float I) {\n    I *= pow(300./iResolution.y,3.);\n    \n    pos -= FragCoord.xy/iResolution.y; \n    \n    float d = length(pos)*SCALE;\n    \n    vec3 col, spectrum = I*star_color;\n    \n    col = spectrum/(d*d*d);\n#if LENSE_EFFECT\n    d = length(pos*vec2(50.,.5))*SCALE;\n    col += spectrum/(d*d*d);\n    d = length(pos*vec2(.5,50.))*SCALE;\n    col += spectrum/(d*d*d);\n#endif\n\n    return col;\n}\n\nvoid draw_stars(out vec4 fragColor, in vec2 fragCoord ){\n    float mixResValue = 0.;\n    if (iResolution.x < iResolution.y){\n        mixResValue = iResolution.x;\n    } else {\n        mixResValue = iResolution.y;\n    }\n    \n    const int searchRange = 7;\n\tfragColor = vec4(0.);\n    for (int x = -searchRange; x <= searchRange; x += 1){\n        for (int y = -searchRange; y <= searchRange; y += 1){\n            vec2 coord = fragCoord + vec2(x,y); //pixel coord\n            vec4 particleData = texture(iChannel1, coord/iResolution.xy);\n            if (dot(particleData,particleData) != 0.){\n                vec2 particleCoord = vec2(coord.x/mixResValue,coord.y/mixResValue);\n                fragColor += vec4(draw_star(particleCoord,STAR_SIZE),1.);\n            }\n        }\n    }\n    \n}\n\n\n// main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    FragCoord = fragCoord; //for star\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //prepare background\n    //fragColor = vec4(0.0);\n    fragColor = clamp(texture(iChannel0, fragCoord / iResolution.xy)  * 0.3,-100.,100.); //tracer\n    \n    //render\n    //fragColor += texture(iChannel1, fragCoord/iResolution.xy);\n    draw_stars(fragColor,fragCoord);\n    \n    \n#if 0\n    //grid\n    if (round(mod(fragCoord.x,100.)) == 100. ||\n        round(mod(fragCoord.y,100.)) == 100. ){\n        fragColor = vec4(1.,0.,0.,1.);\n    }\n    //mouse\n    if (fragCoord.x >= iMouse.x && fragCoord.x <= iMouse.x + 1.||\n        fragCoord.y >= iMouse.y && fragCoord.y <= iMouse.y + 1.){\n        fragColor = vec4(0.,1.,0.,1.);\n    }\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buf A is a uniform grid data structure, but storage in each pixel is 1 particle\n// (.xy=vel, .zw=pos). For each bucket, searches neighbourhood for newly arriving particle,\n// greedily takes first one so particles can annihilate each other if they land in the same\n// pixel bucket.\n\n// Flock or perhaps even SPH behavious could probably be implemented on a similar framework.\n\n#define R 5.\n#define RESTITUTION .5\n\n// scene data\n#define GRAVITY_ENABLED 0\n#define COLISIONS_ENABLED 0\n#define COL0 vec2(2.5,0.5)/iResolution.xy\n#define COL1 vec2(3.5,0.5)/iResolution.xy\n#define COL2 vec2(4.5,0.5)/iResolution.xy\n\nvec2 GetVel( vec4 part ) { return part.xy; }\nvoid SetVel( inout vec4 part, vec2 newVel ) { part.xy = newVel; }\nvec2 GetPos( vec4 part ) { return part.zw; }\nvoid SetPos( inout vec4 part, vec2 newPos ) { part.zw = newPos; }\n\nvec2 FindArrivingParticle( vec2 arriveCoord, out vec4 partData )\n{\n    for( float i = -R; i <= R; i++ )\n    {\n        for( float j = -R; j <= R; j++ )\n        {\n            vec2 partCoord = arriveCoord + vec2( i, j );\n            \n            vec4 part = textureLod( iChannel0, partCoord / iResolution.xy, 0. );\n            \n            // particle in this bucket?\n            if( dot(part,part) < 0.001 )\n                continue;\n            \n            // is the particle going to arrive at the current pixel after one timestep?\n            vec2 partPos = GetPos( part );\n            vec2 partVel = GetVel( part );\n            vec2 nextPos = partPos + partVel;\n            // arrival means within half a pixel of this bucket\n            vec2 off = nextPos - arriveCoord;\n            if( abs(off.x)<=.5 && abs(off.y)<=.5 )\n            {\n                // yes! greedily take this particle.\n                // a better algorithm might be to inspect all particles that arrive here\n                // and pick the one with the highest velocity.\n                partData = part;\n                return partCoord;\n            }\n        }\n    }\n    // no particle arriving at this bucket.\n    return vec2(-1.);\n}\n\nvoid Clip( inout vec4 partData, vec2 col0Pos, vec2 col1Pos, vec2 col2Pos )\n{\n    vec2 pos = GetPos( partData );\n    vec2 vel = GetVel( partData );\n    \n    vec2 nextPos = pos + vel;\n    if( nextPos.y < 0. ) vel.y *= -RESTITUTION;\n    if( nextPos.x < 0. ) vel.x *= -RESTITUTION;\n    if( nextPos.y > iResolution.y ) vel.y *= -RESTITUTION;\n    if( nextPos.x > iResolution.x ) vel.x *= -RESTITUTION;\n\n    vec2 off; float loff2;\n    off = nextPos - col0Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 0. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col0Pos + 50.*n );\n    }\n    off = nextPos - col1Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 0. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col1Pos + 50.*n );\n    }\n    off = nextPos - col2Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 0. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col2Pos + 50.*n );\n    }\n\n    SetVel( partData, vel );\n}\n\n\n//emitters\nbool emitMouse(out vec4 fragColor, in vec2 fragCoord ){\n    // mouse emits\n    if( iMouse.z > 0. && length(iMouse.xy-fragCoord.xy) < 9.)\n    {\n        vec4 newPart;\n        SetPos( newPart, fragCoord );\n        SetVel( newPart, 3. * normalize(fragCoord.xy-iMouse.xy));\n        fragColor = newPart;\n        return true;\n    }\n    return false;\n}\n\n#define SPEED_PIX 3.\nbool emitParticle(vec2 pos, float angle, out vec4 fragColor, in vec2 fragCoord){\n    float centerOffset = 10.;\n    pos += vec2(sin(angle) * centerOffset,cos(angle) * centerOffset);\n    \n    if (floor(fragCoord) == floor(pos)){\n        \n    \tvec2 vel = vec2(sin(angle) * SPEED_PIX,cos(angle) * SPEED_PIX);\n        \n        vec4 newPart;\n        SetPos( newPart, pos );\n        SetVel( newPart, vel);\n        fragColor = newPart;\n        return true;\n    }\n    return false;\n}\n\n#define M_PI 3.1415926\n#define ANGLES 11.\n#define FREQUENCY 2. // in frames \nbool emitBullets(out vec4 fragColor, in vec2 fragCoord){\n    \n    float angleMod = sin(iTime * M_PI/4.) * 10. - 6.; // rotation function\n    \n    vec2 origin = iResolution.xy/2.;\n    if( iMouse.z > 0.)\n        origin = iMouse.xy;\n    \n    origin.x += sin(iTime / 2.) * iResolution.x / 35.;\n    origin.y += sin(iTime / 3.) * iResolution.y / 25.;\n    \n    if (mod(float(iFrame),FREQUENCY) == 0.){\n        bool result = false;\n        const float andgleDiff = 2. * M_PI/ANGLES;\n        for (float angle = 0.001; angle <= 2. * M_PI; angle += andgleDiff){\n        \tresult = emitParticle(origin, angle + angleMod ,fragColor,fragCoord) || result;\n        }\n        return result;\n    }\n\treturn false;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col0Data = textureLod(iChannel2, COL0, 0.).xyz;\n    vec3 col1Data = textureLod(iChannel2, COL1, 0.).xyz;\n    vec3 col2Data = textureLod(iChannel2, COL2, 0.).xyz;\n    \n    //emitters\n    //if (emitMouse(fragColor,fragCoord)) {return;}\n    if (emitBullets(fragColor,fragCoord)) {return;}\n    \n    \n    // look for a particle arriving at the current bucket\n    vec4 partData;\n    vec2 partCoord = FindArrivingParticle( fragCoord, partData );\n    if( partCoord.x < 0. )\n    {\n        // no particle, empty this bucket\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 pos = GetPos( partData );\n    vec2 vel = GetVel( partData );\n    \n    // integrate pos using current vel\n    SetPos( partData, pos + vel );\n    \n    // gravity\n#if GRAVITY_ENABLED\n    vel += vec2(0.,-.05);\n#endif\n    \n    \n    \n    SetVel( partData, vel );\n    \n#if COLISIONS_ENABLED\n    Clip( partData, col0Data.xy, col1Data.xy, col2Data.xy );\n#endif\n    \n    \n    fragColor = partData;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}