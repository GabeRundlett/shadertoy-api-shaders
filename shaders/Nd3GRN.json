{
    "Shader": {
        "info": {
            "date": "1629223618",
            "description": "It's a dart cube.",
            "flags": 0,
            "hasliked": 0,
            "id": "Nd3GRN",
            "likes": 4,
            "name": "dart cube",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "sunhokim",
            "viewed": 234
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.1415926535897932384626433832795\n\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 mapSide(vec3 p, float displace) {\n    vec2 k = p.xz;\n    vec2 por = vec2(sqrt(k.x*k.x+k.y*k.y), atan(k.y,k.x));\n    float a = por.x/0.2;\n    float h2 = displace*0.4*a;\n    float h = displace*0.4*floor(a);\n    float b = smoothstep(0.1, 0.2, mod(por.x,0.2));\n    vec3 q = p;\n    float hh = displace*5.0*0.4;\n    q.y = 1.0*q.y-h+hh;\n    return vec4(sdBox(q, vec3(1.0,0.2, 1.0)),vec3(b, h2/hh, 0.0));\n}\n\nvec4 map(vec3 p) {\n    vec4 res = vec4(1e10, 0, 0,0);\n\n    float d = 0.7;\n    float s = 1.0;\n    if (iTime < 1.0) {\n        s = (1.0+sin(iTime*M_PI - M_PI*0.5))/2.0;\n    }\n    float dd = d*0.5*(1.0+sin(iTime - M_PI*0.5))+0.01;\n    {\n    vec3 q = p - vec3(0,0.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*1.5) - vec3(0,0.0, 1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*0.5) - vec3(0,-2.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateZ(p, M_PI*0.5) - vec3(1.0,-1.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateZ(p, M_PI*1.5) - vec3(-1.0,-1.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*1.0) - vec3(0.0,-2.0, 1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    \n    return res;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.05;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}   \n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.0);\n    vec2 tminmax = iSphere( ro, rd, 20.0 );\n\tif( tminmax.y>0.0 )\n    {\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<1024 && t<tminmax.y; i++ )\n        {\n            vec4 h = map(ro+t*rd);\n            if( h.x<0.01 ) { res=vec4(t,h.yzw); break; }\n            t += 0.1*h.x;\n        }\n    }\n    \n    return res;\n}\n\nvec3 gradient(float z) {\n    vec3 a = vec3(0.46,0.76,1);\n    vec3 b = vec3(0.11,0.98,1);\n    vec3 c = vec3(0.69,0.49,1);\n    vec3 d = vec3(1,1,1);\n    if (z < 0.3) {\n        return mix(a, b, z);\n    } else if (z < 0.99999) {\n        return mix (b, c, z);\n    } else {\n        return mix(c,d, z);\n    }\n}\n\nvec3 render( in vec3 ro, vec3 rd )\n{ \n    vec4 res = raycast(ro, rd);\n    vec3 pos = ro + res.x*rd;\n    vec3 col = vec3(0.0);\n    vec3 mat =  mix(vec3(1.0), gradient(res.z), res.y);\n    vec3 normal = calcNormal(pos);\n    if (res.x < 0.0) {\n        return vec3(0.0);\n    } \n\n    vec3 lin = vec3(0.0);\n    lin += 1.0;\n    col = lin * mat;\n\treturn vec3(clamp(col,0.0,1.0));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMat( in vec3 eye, in vec3 look )\n{\n    vec3 w = normalize(eye-look);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(w, u);\n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec2 mouse = iMouse.xy /iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        mouse = vec2(0.4,0.7);\n    }\n    vec2 spr = vec2(mouse.x * M_PI - M_PI/2.0, mouse.y*M_PI-M_PI)*0.8;\n    float r = 20.0;\n    vec3 eye = vec3(-r*sin(spr.x)*sin(spr.y), -r*cos(spr.y),-r*sin(spr.y)*cos(spr.x)) + vec3(0.0, -2.0, 0.0);\n    vec3 look = vec3(0.0,0.0,0);\n    mat3 view = viewMat(eye, look);\n    dir = view * dir;\n    vec3 col = render(eye, dir);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}