{
    "Shader": {
        "info": {
            "date": "1626561795",
            "description": "iso surface ray casting with binary search refinement.\nray marching is used to find the entry and exit point of the volume.\nVolumeIntensity() simulates intensity values inside the box instead of a CT scan or so.",
            "flags": 0,
            "hasliked": 0,
            "id": "stXSD2",
            "likes": 2,
            "name": "Ray Casting - Iso, MIP, Emi.Abs.",
            "published": 3,
            "tags": [
                "raycasting",
                "compositing",
                "isosurface",
                "maximumintensityprojection",
                "emissionabsorption"
            ],
            "usePreview": 0,
            "username": "Rapideye",
            "viewed": 366
        },
        "renderpass": [
            {
                "code": "// original \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// this shader simulates volume ray casting\n// 1) ray march a box to find entry and exit points of the volume\n// 2) ray cast into the volume and use several different compositing techniques\n//    - iso surface with binary search refinement\n//    - maximum/minimum intensity projection\n//    - front to back emission absorption\n//    - switch between them using defines below\n// misc:\n//    - have a look at VolumeIntensity(...)\n\n#define ISO_SURFACE_RAYCASTING true\n#define MAXIMUM_INTENSITY_PROJECTION false\n#define MINIMUM_INTENSITY_PROJECTION false\n#define FRONT_TO_BACK_EMISSION_ABSORPTION false\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S(a, b, x) smoothstep(a, b, x)\n#define T iTime\n\n#define BOX_SIZE 1.\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    return sdBox(p, vec3(BOX_SIZE));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += abs(dS);\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0.);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p),\n        r = normalize(cross(vec3(0., 1., 0.), f)),\n        u = cross(f, r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u,\n        d = normalize(i);\n    return d;\n}\n\n// here you can simulate whatever volume intensies you want\n// usually CT or MRI scans or simulations from the real world are used here\nfloat VolumeIntensity(vec3 p) {\n    // p : [0, 1]\n    // try to have no hard edges in intensity here -> would produce \"ugly\" normals\n    \n    // simulate sphere in center of volume with soft fall off at the edge of sphere to avoid \"ugly\" normals\n    float i = S(.6, .4, distance(p, vec3(.5)));\n    // float i = distance(p, vec3(.5)) < .5 ? 1. : 0.; // sphere without soft edge\n    \n    return i;\n}\n\nvec3 CentralDiffGradient(vec3 p, float dt)\n{\n    vec3 a0 = vec3(p.x+dt,p.y,p.z);\n    vec3 b0 = vec3(p.x,p.y+dt,p.z);\n    vec3 c0 = vec3(p.x,p.y,p.z+dt);\n\n    vec3 a1 = vec3(p.x-dt,p.y,p.z);\n    vec3 b1 = vec3(p.x,p.y-dt,p.z);\n    vec3 c1 = vec3(p.x,p.y,p.z-dt);\n\n    vec3 gradient = vec3(\n        VolumeIntensity(a0) - VolumeIntensity(a1),\n        VolumeIntensity(b0) - VolumeIntensity(b1),\n        VolumeIntensity(c0) - VolumeIntensity(c1));\n\n    return normalize(gradient);\n}\n\nvec3 phong(vec3 N, vec3 L, vec3 V, vec3 color, float shininess)\n{\n    // calc. lighting\n    vec3 R = normalize(reflect(-L, N));\n    float diffuse_intensity = max(dot(N, L) * .5 + .5, 0.); // wrapped lambert\n    float specular_intensity = pow(max(dot(V, R), 0.), shininess);\n\n    // calc. final color\n    return (diffuse_intensity + specular_intensity) * color;\n}\n\nvec3 WorldToVolumeCoord(vec3 p, vec3 min_box, vec3 max_box)\n{\n    return (p - min_box) / (max_box - min_box);\n}\n\nstruct EntryExitPoints {\n    vec3 p_front;\n    vec3 p_back;\n    bool volume_hit;\n};\n\nEntryExitPoints FindEntryExitPoints(vec3 ro, vec3 rd) {\n    EntryExitPoints result;\n    result.p_front = vec3(0.);\n    result.p_front = vec3(0.);\n    result.volume_hit = false;\n    \n    float d = RayMarch(ro, rd);\n\n    // check if front face was hit\n    if(d < MAX_DIST) {\n        // front face\n        vec3 p_front = ro + d * rd;\n        \n        // start again at front face with small offset inside the surface\n        // step inside the volume along normal as an alternative instead of just along the ray\n        // might be better at small angles\n        ro = p_front + 5e-2 * rd;\n        d = RayMarch(ro, rd);\n        \n        // check if back face was hit\n        if (d < MAX_DIST) {\n            // back face\n            vec3 p_back = ro + d * rd;\n            \n            // return valid result if front and back was found\n            result.p_front = p_front;\n            result.p_front = p_front;\n            result.volume_hit = true;\n        }\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3(0., 3., -3.);\n    ro.yz *= Rot(-m.y * 3.14 + 1.);\n    ro.xz *= Rot(-m.x * 6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0.), 1.);\n    vec3 col = vec3(0.);\n\n    // use ray-box intersection instead of ray marching for better performance here\n    EntryExitPoints entry_exit = FindEntryExitPoints(ro, rd);\n\n    if (entry_exit.volume_hit) {\n        vec3 p_front = entry_exit.p_front;\n        vec3 p_back = entry_exit.p_back;\n    \n        // parameters\n        vec3 surface_color = vec3(1., .4, .1);\n        vec3 light_color = vec3(1.);\n        vec3 L = normalize(vec3(1., -1., -1.));\n        vec3 V = normalize(-ro);\n        float shininess = 32.0;\n        float iso_value = .5;\n        int refinement_steps = 10;\n        float step_size = 1e-3;\n\n        // ray cast from p_front to p_back\n        float t = 0.;\n        float t_end = distance(p_front, p_back);\n                \n        // compositing options:\n        // - iso surface ray cast\n        // - maximum/minimum intensity projection\n        // - front to back emission absorption model\n\n        if (ISO_SURFACE_RAYCASTING) {\n        \n            while (t < t_end) {\n                // position in world space\n                vec3 p = p_front + t * rd;\n\n                // position in volume space with volume at origin\n                vec3 coord = WorldToVolumeCoord(p, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                float s = VolumeIntensity(coord);\n\n                // iso surface ray casting with boundary refinement\n                if (s > iso_value) {\n                    // refine position with binary search of iso surface\n                    float t_a = t - step_size;\n                    float t_b = t;\n                    vec3 coord_r = coord;\n                    for (int i = 0; i < refinement_steps; ++i)\n                    {\n                        // binary search position\n                        float t_r = 0.5f * (t_a + t_b);\n                        vec3 p_r = p_front + rd * t_r;\n                        coord_r = WorldToVolumeCoord(p_r, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                        // sample new intensity\n                        float s_r = VolumeIntensity(coord_r);\n\n                        // move left or right boundary for binary search\n                        if (s_r < iso_value)\n                            t_a = t_r;\n                        else\n                            t_b = t_r;\n                    }\n\n                    // get gradient\n                    vec3 N = CentralDiffGradient(coord_r, .5 * step_size);\n\n                    // phong with wrapped lambert\n                    col = phong(N, L, V, surface_color, shininess) * light_color;\n\n                    // debug\n                    //col = coord_r;\n                    //if (uv.x > .0) col = N;\n\n                    // stop, nothing can be seen behind the iso surface if it is fully opaque\n                    break;\n                }\n\n                // step along ray\n                t += step_size;\n            }\n            \n        } else if (MAXIMUM_INTENSITY_PROJECTION) {\n        \n            float max_s = .0;\n            while (t < t_end && max_s < 0.99) { // early ray termination\n                // position in world space\n                vec3 p = p_front + t * rd;\n\n                // position in volume space with volume at origin\n                vec3 coord = WorldToVolumeCoord(p, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                float s = VolumeIntensity(coord);\n                \n                // store maximum intensity\n                max_s = max(max_s, s);\n                \n                // step along ray\n                t += step_size;\n            }\n            col = vec3(max_s);\n            \n        } else if (MINIMUM_INTENSITY_PROJECTION) {\n            \n            float min_s = 1.;\n            while (t < t_end && min_s > .0) { // early ray termination\n                // position in world space\n                vec3 p = p_front + t * rd;\n\n                // position in volume space with volume at origin\n                vec3 coord = WorldToVolumeCoord(p, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                float s = VolumeIntensity(coord);\n                \n                // store minimum intensity\n                min_s = min(min_s, s);\n                \n                // step along ray\n                t += step_size;\n            }\n            col = vec3(min_s);\n            \n        } else if (FRONT_TO_BACK_EMISSION_ABSORPTION) {\n        \n            vec3 C = vec3(.0);\n            float A = .0;\n            while (t < t_end && A < .99) { // early ray termination\n                // position in world space\n                vec3 p = p_front + t * rd;\n\n                // position in volume space with volume at origin\n                vec3 coord = WorldToVolumeCoord(p, -vec3(BOX_SIZE), vec3(BOX_SIZE));\n\n                float s = VolumeIntensity(coord);\n                \n                // classification using a transfer function\n                //vec4 color = TransferFunction(s);\n                vec4 color = vec4(s);\n                color.rgb = surface_color;\n                color.a *= .05;\n                \n                // get gradient\n                vec3 N = CentralDiffGradient(coord, .5 * step_size);\n                \n                // shade\n                color.rgb = phong(N, L, V, color.rgb, shininess);\n                color.a *= step_size * 100.;\n                \n                // front to back emission absorption\n                C += (1. - A) * color.a * color.rgb;\n                A += (1. - A) * color.a;\n                \n                // step along ray\n                t += step_size;\n            }\n            col = C.rgb;\n            \n        } else {\n            // fallback error color as red\n            col = vec3(1., 0., 0.);\n        }\n    }\n    \n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}