{
    "Shader": {
        "info": {
            "date": "1532689673",
            "description": "mouse does things\nanalytic distance to ellipse\nslightly improved with mirror symmetry to mirror for highest precision segments.\nimproved a lot in its vis style",
            "flags": 0,
            "hasliked": 0,
            "id": "XttyWN",
            "likes": 5,
            "name": "quartic root ellipse visualize",
            "published": 3,
            "tags": [
                "ellipse",
                "analytic",
                "quintic",
                "4",
                "analysis",
                "roots",
                "fourroots"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 770
        },
        "renderpass": [
            {
                "code": "//self:https://www.shadertoy.com/view/XttyWN\n//parent https://www.shadertoy.com/view/4dVcR1\n/*\nfloat miv(vec2 a){return min(a.x,a.y);}float miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat getSmallestPos(vec4 a){//return position of smallest value[0..3] \n if(all(lessThan(a.xxx,a.yzw)))return 0.;\n if(all(lessThan(a.yy,a.zw)))return 1.;\n return mix(2.,3.,step(a.z,a.w));}\nfloat getSmallestPosPositive(vec4 a){return getSmallestPos(mix(a,vec4(infinity),step(a,vec4(0))));}//return position of smallest positive value[0..3] \n\nvec2 smaller_x(vec2 a,vec2 b){return mix(b,a,step(a.x,b.x));}\n*/\n//largest positive value,the concept of infinity is quite nonsensical in terms of hillbert-address-space,this just makes it \"newbie friendly\"\n//#define infinity 10000.\n\n\n//Ellipse quartic ,by mattz\n//improved by @ollj\n//parent https://www.shadertoy.com/view/4dVcR1\n//License: Creative Commons Attribution ShareAlike 4.0 https://creativecommons.org/licenses/by-sa/4.0/\n//analytic distance to ellipse,2 or 4 points on an ellipse whos differential is permendicular.\n//Each point corresponds to one of 4 possible roots of a quartic(4th degree polynomial)plotted below the ellipse to scale.\n//Shows relationship between [distance of point to ellipse] and [its quartic roots]\n#define sat(a)clamp(a,0.,1.)\n#define dd(a)dot(a,a)\n#define ss10(a)smoothstep(1.,0.,a)\nfloat suv(vec2 a){return a.x+a.y;}\n//closed-form solver(without special-case checks)from  https://www.shadertoy.com/view/XdKyRR  \nvec4 solve_quartic(vec4 p){\n ;float quadrant=sign(p.x),s=p.w// form resolvent cubic and solve it to obtain one real root\n ,j=p.x*p.z-4.*p.w,k=4.*p.y*p.w-p.z*p.z-p.x*p.x*p.w,b=(-2.*p.y*p.y*p.y+9.*p.y*j+27.*k)/27.//coefficients of normal form\n ,delta1=b*b/4.,a=(3.*j-p.y*p.y)/3.,delta2=a*a*a/27.,z1\n ;if(delta1+delta2<0.)z1=2.*sqrt(-a/3.)*cos(acos(-sign(b)*sqrt(delta1/-delta2))/3.)\n ;else    z1=suv(pow(abs(-.5*b+vec2(1,-1)*sqrt(max(delta1+delta2,0.))),vec2(1./3.)))//sum of 2 cubic roots\n ;z1+=p.y/3. // shift back from normal form to root of resolvent cubic\n ;float R2=p.x*p.x/4.-p.y+z1//form quartic roots from resolvent cubic root\n ;bool R_ok=(R2>=0.);float R=sqrt(max(R2,0.)),foo,bar\n ;if(R==0.//i do not call this elegant!\n ){float z124s=z1*z1-4.*p.w;R_ok=R_ok &&(z124s>=0.);foo=3.*p.x*p.x/4.-2.*p.y   ;bar=2.*sqrt(max(z124s,0.))\n ;}else{           ;foo=3.*p.x*p.x/4.-R2-2.*p.y;bar=(4.*p.x*p.y-8.*p.z-p.x*p.x*p.x)/(4.*R);}\n ;float D=sqrt(max(foo+bar,0.)),E=sqrt(max(foo-bar,0.));vec4 roots=vec4(-p.x/4.)+.5*vec4(R+D,R-D,-R+E,-R-E)\n ;roots=mix(roots,roots.xzyw,step(sign(p.x),0.))//optional root sorting within homotopy\n ;return roots;}\n\n//vec2 from_angle(float t){return vec2(cos(t),sin(t));}//angle2Normal\nvec2 from_cos(float u){u=clamp(u,-1.,1.);return vec2(u,sqrt(1.-u*u));}//cos2normal\nvec2 perp(vec2 v){return vec2(-v.y,v.x);}\nfloat ellipse_dist(vec2 p,vec2 ab,out vec4 coeffs,out vec4 roots,out bool is_circle,out int k\n){float sig=sign(p.y);p.y=abs(p.y);vec2 ds=vec2(1e5,-1)//signed distance\n ;is_circle=abs((ab.x-ab.y)/ab.x)<1e-2//is important for precision reasons,is a useful BVH-shortcut.\n ;if(is_circle//near-circles are special quadratic case of a quartic ellipse\n){float dc=length(p)-ab.x;float u=normalize(p).x;roots=vec4(u,0,0,-u);coeffs=vec4(0,1,0,-u*u);ds=vec2(abs(dc),dc)\n ;}else{//ellipse\n  //formulate quartic polynomial of ellipse. solve for position u=cos(theta)along ellipse \n  //so that the tangent at the point [a*u,b*sqrt(1-u^2)] is perpendicular to the displacement between p and the point itself\n  //this gets 2 or 4 solutions. we need to inspect each of them in the arc case\n  ;float l=ab.y*ab.y-ab.x*ab.x,ax=ab.x*p.x/l,by=ab.y*p.y/l,a2x2=ax*ax,b2y2=by*by\n  ;coeffs=vec4(2.*ax,(a2x2+b2y2)-1.,-2.*ax,-a2x2)// vector of polynomial coefficients\n  ;roots=solve_quartic(coeffs)// solve for up to 4 roots \n  ;roots=mix(roots.xzyw,roots,step(-sig,0.))//optional root sorting within homotopy,green always on top,disregarding u.y\n  ;roots=mix(roots,roots.xzyw,step(ab.y,ab.x))//optional root sorting within homotopy,green always on top,disregarding ellypsoid/ratio.\n  ;for(int i=0;i<4;++i//for each root\n ){vec2 c=ab*from_cos(roots[i])// get absolute distance to the closest point on the ellipse,as well as its sign\n   ;vec2 b=vec2(length(p-c),dot(p-c,c))\n   ;float s=sign(ds.x-b.x)*.5+.5\n   ;k=k+i*int(s)\n   ;ds=mix(ds,b,s)\n ;}}return ds.x*sign(ds.y);}\n\nfloat dline(vec2 p,vec2 a,vec2 b,float d// distance to(optionally dashed)line\n){p-=a;b-=a;float l2=dd(b),u=sat(dot(p,b)/l2),l=length(p-u*b)\n ;if(d!=0.){l=max(l,-sin(u*sqrt(l2)/d)*d);}return l;}\nfloat poly3(vec4 p,float x){return((p.x*x+p.y)*x+p.z)*x+p.w;}// evaluate cubic(first derivative of poly4)\nfloat poly4(vec4 p,float x){return(((x+p.x)*x+p.y)*x+p.z)*x+p.w;}//evaluate a quartic,first coefficient==1 \n// given point p,function value at p.x and function derivative at p.x\n//,get estimated distance to curve of function plot.\nfloat dist_to_plot(vec2 p,vec2 fdf){vec2 p0=vec2(p.x,fdf.x);vec2 n=normalize(vec2(-fdf.y,1));return abs(dot(p-p0,n));}\n//iq.HSV.Smooth: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c){vec3 r=sat(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.);\n return c.z*mix(vec3(1.),r*r*(3.-2.*r),c.y);}//is hermite,quadratic with 1 duplicitiy\nvec3 colorMeIrrationally(float a){a*=(sqrt(5.)*.5+.5);a=fract(a);return hsv2rgb(vec3(a,1,1));}\nvec3 colorMeIrrationally(int a){return colorMeIrrationally(float(a));}\n\nvoid mainImage(out vec4 O,vec2 fragCoord\n){float e_px_per_unit=iResolution.y/3.//set up ellipse drawing\n ;vec2 pctr=iResolution.xy*vec2(.5,.65)\n ;vec2 u=(fragCoord.xy-pctr)/e_px_per_unit // frag coords relative to ellipse\n ;vec2 q=(iMouse.xy/iResolution.xy-vec2(.5,.65))*3.//vec2(.5,.2)// white dot\n ;q.x*=iResolution.x/iResolution.y\n //;if(max(iMouse.x,iMouse.y)>20.){q=(iMouse.xy-pctr)/e_px_per_unit;}//disabled for mouse ui debug\n ;float time=iTime*.25+4.4//;time=0.//debug overwrite\n ;vec2 ab=vec2(cos(time+1.2)*.6+.8,sin(time*.7-.5)*.2+.6)// ellipse radii\n ,ww=-abs(u)//fixes diagonal jittering due to prexision loss in one end,by utilizing mirror symmetry homotopy.\n ,deg45=ww*mat2(1,1,-1,1)//this scales by sqrt(2),so you can undo this by multiplying bxy *=sqrt(.5)\n ,w=ww,ba=ab\n ;if(sign(deg45.x*deg45.y)>0.){ba=ab.yx;w=ww.yx;}//a fix for near circular cases and u.x close to 0.\n ;if(abs(w.y)<.1){w.y+=1./iResolution.y;}//very lazy evasion for near-divisions-by-0,we just jump 1 fragment to the side.\n ;if(abs(w.x)<.1){w.x+=1./iResolution.x;}//very lazy evasion for near-divisions-by-0,we just jump 1 fragment to the side.\n //this only stays unnoticed because the ellipse is very round(is still pretty bad for normals/reflections)\n //this basically splits 1 discontinuity(that should not exist)in 2 discontinuities(that are less apparent)\n ;vec4 coeffs,coeffs2,roots,roots2;bool is_circle;int j;int k//some debugging junk left in here\n //oh boy,we once to this for ONE specific point,and once for the UV\n ;float d=ellipse_dist(w,ba,coeffs2,roots2,is_circle,j)//to fragment pos,to actually calculate an ellipse\n //;q.y=0.//border case debug overwrite,is flickering-hell on the visualization,due to arbitiary root-sorting due to precision loss\n //;q.y=0. //leads to root-duplicity within a quartic.\n //;q.x=0.//border case debug overwrite,is flickering-hell on the visualization;root duplicity AND morror symmetry at x=0;\n //;q=vec2(0)//this does not flicker for me,but i expected flicker.\n ;ellipse_dist(q,ab,coeffs,roots,is_circle,k)//for debug vis,we calculate the same for a mouse pos input\n // get initial ellipse distance for shading background and drawing ellipse\n ;float g_px_per_unit=iResolution.x/2.75//set graph \n ;vec2 v=(fragCoord.xy-vec2(.5,.2)*iResolution.xy)/g_px_per_unit//frag coords relative to graph\n ;vec4 pder=vec4(4,3,2,1)*vec4(1,coeffs.xyz)//get derivative polynomial\n ;float rara=1.5/ab.x//the squash is real.\n ;v.x*=1.5/ab.x//scale v to match axial-scaling to ellipse.x\n ;vec2 fdf=vec2(poly4(coeffs,v.x),poly3(pder,v.x))//evaluate quartic & derivative\n ;fdf*=.1//debug squash graph to fit in screenspace\n ;if(is_circle){pder.x=0.;fdf=vec2(poly3(coeffs,v.x),poly3(pder,v.x));}//circle case,quartic collapses to quadratic\n //;float dwhite=abs(d)*e_px_per_unit-.75// dist to ellipse & markers\n ;float dwhite=1.//debug overwrite,exclude the ellipse shape from dwhite,this is actually better.\n ,dq=length(u-q)*e_px_per_unit-5.// dist to draggable dot\n ,dplot=dist_to_plot(v*rara,20.*fdf*rara)*g_px_per_unit/rara//distance to gray graph line\n ,ddot=length(u-q)*e_px_per_unit-7.//distance to dark dot outlines by ellipse\n ;vec4 d_ellipse_root=vec4(1e9),d_axis_root=vec4(1e9)//distances to colored points on ellipse/x-axis\n ;vec3 dcol=vec3(1)\n ;vec4 alph=vec4(.1)\n ;for(int i=0;i<4;++i//for each potential root\n){vec2 uv=from_cos(roots[i])//create point on unit circle\n  ;vec3 uvmin=vec3(1e5)\n  ;for(int j=0;j<2;++j// test against both pos & neg. y\n ){vec2 e=ab*uv,t=.5*(ab*perp(uv))// ellipse point// tangent\n   ;vec3 uvd=vec3(uv,abs(dot(t,q-e)))\n   ;if(uvd.z<uvmin.z)uvmin=uvd\n   ;uv.y=-uv.y // test other sign next\n  ;}\n ;if(true//uvmin.z<1e-3//the angle has some tolerance to the tangent,but if the angle is outside of that tolerance,it is just not shown.\n){uv=uvmin.xy//reconstruct unit circle point,ellipse point,tangent \n  ;vec2 e=ab*uv,t=.5*(ab*perp(uv))\n  ;v.x/=rara\n  ;float edst=length(u-e)*e_px_per_unit-5.//distance to point on ellipse\n  ,pdst=(length(v-vec2(roots[i]/rara,0.))*g_px_per_unit)-5.// distance to root on x-axis\n  ;v.x*=rara\n  ;d_ellipse_root[i]=min(d_ellipse_root[i],edst)//is a vec4,this is fine\n  ;d_axis_root[i]=min(d_axis_root[i],pdst)//is a vec4,this is fine\n  ;dplot=min(dplot,pdst-2.)\n  ;ddot=min(ddot,edst-2.)\n  ;vec3 irr=colorMeIrrationally(i);\n  ;float ass=min(dline(u,q,e,1./e_px_per_unit),dline(u,e-t,e+t,0.))*e_px_per_unit-.25\n  ;dcol=mix(dcol,irr,step(ass,dwhite))//this could be alpha compisitioning instead.\n  ;dwhite=min(dwhite,ass)\n  //;if(uvmin.z<1e-3)\n  ;alph[i]=mix(2.,.0,smoothstep(-.01,.01,uvmin.z));\n ;}}\n ;const vec3 axis_color=vec3(.12,.15,.25)//draw\n //;vec3 c=mix(vec3(.2),vec3(.6),vec3(deb1))// bg color\n ;vec3 c=vec3(.4)\n //;c=vec3(.4)*dcol//nope,but awesome in its own right\n //;c=mix(c,c,.2+deb1*.5)\n //;c=colorMeIrrationally(getSmallestPosPositive(roots2))\n ;c*=.95+.05*cos(60.*d)//ellipse isolines\n ;vec2 g=abs(v-.25*floor(4.*v+0.5))//squares\n //;c=mix(c,axis_color,0.5*ss10(min(g.x,g.y)*g_px_per_unit))\n ;c=mix(c,axis_color,ss10(abs(v.y)*g_px_per_unit-1.))// x-axis \n ;c=mix(c,vec3(.025),ss10(dplot-1.))//plot graph over x\n ;c=mix(c,vec3(0),.6*exp(-.5*dwhite)*dcol)//slight dark shadow/glow for ellipse figure\n ;c=mix(c,vec3(1),smoothstep(.5,-.5,smoothstep(-.05,.05,abs(d)-.075)))//ellipse figure better estimate\n //;c=max(c,vec3(smoothstep(.01,-.01,abs(d)-.1)))\n ;float hair=4./max(iResolution.x,iResolution.y)\n ;c+=vec3(smoothstep(hair,-hair,abs(d)))//debug core shape hairline overlay,if this is visible with minimal moire,all is fine\n //;c=mix(c,vec3(.025),ss10(ddot)*dcol)//dark dot outlines \n ;for(int i=0;i<4;++i\n){vec3 d=colorMeIrrationally(i)\n  //for the below line the alph[i] params are sometimes sorted poorly,and should be alph=alph.xzyw in some cases.\n  //;alph=mix(alph,alph.xzyw,step(u.x,0.))\n  //;alph=mix(alph,alph.xzyw,step(0.,u.y))\n  //this is rare and not too much of a visual error in the debugger.\n  //;c=mix(c,vec3(alph[i]),ss10(dwhite)*dcol)//ellipse figure //dwhite is actually a low precision estimate.\n  ;c=mix(c,vec3(1),ss10(dwhite)*dcol)//ellipse figure //dwhite is actually a low precision estimate.\n  ;c=mix(c,d,ss10(d_axis_root[i])*alph[i])//roots on x-axis\n  ;c=mix(c,d,ss10(d_ellipse_root[i])*alph[i])//roots on ellipse\n  ;}\n //;c=mix(c,vec3(.025),ss10(dq-2.));c=mix(c,vec3(1),ss10(dq))//draggable dot and itsoutline\n //;c=pow(c,vec3(1./2.2))//gamma correction\n ;O=vec4(c,1);}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}