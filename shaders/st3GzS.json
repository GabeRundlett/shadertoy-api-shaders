{
    "Shader": {
        "info": {
            "date": "1636331523",
            "description": "My first shader. I'm learning the ropes of C++ and webgl, as I'm used to javascript.",
            "flags": 0,
            "hasliked": 0,
            "id": "st3GzS",
            "likes": 2,
            "name": "Raymarching with color!",
            "published": 3,
            "tags": [
                "raymarching",
                "stuff"
            ],
            "usePreview": 0,
            "username": "RayWorld",
            "viewed": 106
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define HIT_DIST 0.01 \n#define rot2(a)      mat2(cos(a),-sin(a),sin(a),cos(a)) // V.xy *= rot2(a.z)\n\nvec3 bezierPos(vec3 anchor1, vec3 handle1, vec3 handle2, vec3 anchor2, float t) {\n    vec3 point = anchor1 * (-pow(t,3.)+3.*pow(t,2.)-3.*t+1.);\n    point += handle1 * (3.*pow(t,3.)-6.*pow(t,2.)+3.* t);\n    point += handle2 * (-3.*pow(t,3.)+3.*pow(t,2.));\n    point += anchor2 * (pow(t,3.));\n    return point;\n}\n\nvec3 getCameraPos() {\n    float pathProgress = float(iFrame)/float(120);\n    int bezierID = int(mod(pathProgress,3.0));\n    float bezierProgress = mod(pathProgress,1.0);\n    vec3 position = vec3(0.,1.,0.);\n    switch (bezierID) {\n        case 0:\n        position = bezierPos(vec3(0.,1.,0.),vec3(-0.5,1.,-1.),vec3(-1.,1.,-5.2),vec3(1.,1.,-5.),bezierProgress);\n        break;\n        case 1: \n        position = bezierPos(vec3(1.,1.,-5.),vec3(3.,1,-5.),vec3(6.,1.,-2.5),vec3(6.,1.,0.),bezierProgress);\n        break;\n        case 2:\n        position = bezierPos(vec3(6.,1.,0.),vec3(6.,1.,1.),vec3(0.5,1.,1.),vec3(0.,1.,0.),bezierProgress);\n        break;\n    }\n    return position;\n}\n\nfloat sphereSDF(vec3 pos,float radius) {\n    return length(pos) - radius;\n}\n\nfloat cubeSDF(vec3 pos, vec3 scale) {\n    vec3 offset = abs(pos) - scale;\n    float unsignedDist = length(max(offset,0.));\n    float signedDist = max(max(min(offset, 0.).x,min(offset, 0.).y),min(offset, 0.).z);\n    return signedDist + unsignedDist;\n}\n\nfloat torusSDF(vec3 pos, vec2 radii) {\n    return length( vec2(length(pos.xz)-radii.x,pos.y) )-radii.y;\n}\n\nvec3 rotateYZ(vec3 vector, float angle) {\n    vector.zy *= rot2(angle);\n    return vector;\n}\n\nvec3 rotateXZ(vec3 vector, float angle) {\n    vector.zx *= rot2(angle);\n    return vector;\n}\n\nvec3 rotateXY(vec3 vector, float angle) {\n    vector.yx *= rot2(angle);\n    return vector;\n}\n\nfloat boolOperation(float subjectDist, float actorDist, int operation) {\n    float returnValue = subjectDist;\n    switch (operation) {\n        case 0:\n        //Union\n        returnValue = min(subjectDist,actorDist);\n        break;\n        case 1:\n        //Difference\n        returnValue = max(subjectDist, -actorDist);\n        break;\n        case 2:\n        //Intersect\n        returnValue = max(subjectDist,actorDist);\n        break;\n    }\n    return returnValue;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smoothBoolOperation(float subjectDist, float actorDist, int operation,float k) {\n    float returnValue = subjectDist;\n    switch (operation) {\n        case 0:\n        //Union\n        returnValue = smin(subjectDist, actorDist, k);\n        break;\n        case 1:\n        //Difference\n        returnValue = smin(-subjectDist, actorDist, k);\n        break;\n        case 2:\n        //Intersect\n        returnValue = smin(-subjectDist, -actorDist, k);\n        break;\n    }\n    return returnValue;\n}\n\nvec4 getDist(vec3 center) {\n    vec4 minDist = vec4(0.5,0.5,1.,101.);\n    vec4 plane = vec4(0.25, 1.0, 0.3, center.y);\n    vec4[] objects = vec4[](\n        vec4(0.25,0.5,1.0,mix(cubeSDF(center - vec3(0.0,2.0,7.0),vec3(0.5,1.5,0.5)),sphereSDF(center-vec3(0.0,2.0,7.0),1.0),0.5+0.5*sin(iTime))),\n        vec4((1.+cos(iTime))/2.,(1.+cos(iTime+radians(120.)))/2.,1.0,torusSDF(center - vec3(3,0.5,7),vec2(1,0.5)))\n    );\n    if (minDist.w > plane.w) minDist = plane;\n    int objectCount = objects.length();\n    for (int i = 0; i < objectCount; i++) {\n        if (minDist.w > objects[i].w) minDist = objects[i];\n    }\n    return minDist;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.0;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p).w;\n        dO += dS;\n        if(dO>MAX_DIST || dS<HIT_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).w,\n        getDist(p-e.yxy).w,\n        getDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 1);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = rayMarch(p+n*HIT_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvec3 colorFromScene(vec3 rayOrigin, vec3 rayDirection, vec3 lightDir) {\n    vec3 returnValue = vec3(0.5,0.5,1);\n    //march to scene\n    float sceneDist = rayMarch(rayOrigin, rayDirection);\n    vec3 landingPosition = rayOrigin + rayDirection * (sceneDist - 0.1);\n    vec4 colorContender = getDist(rayOrigin + rayDirection * sceneDist);\n    if (colorContender.w < HIT_DIST) {\n        // if hit march towards light\n        float dif = getLight(landingPosition);\n        returnValue = colorContender.xyz * dif;\n        \n    }    \n    return returnValue;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraPosition = getCameraPos();\n    vec2 rotations = vec2(0.,0.);\n    float theta = rotations.x;\n    float phi = rotations.y;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 rayDir = normalize(vec3(uv.xy,1));\n    rayDir.zy *= rot2(phi);\n    rayDir.zx *= rot2(theta);\n    vec3 col = colorFromScene(cameraPosition, rayDir, vec3(1,0,0));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}