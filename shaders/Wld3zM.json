{
    "Shader": {
        "info": {
            "date": "1575927914",
            "description": "This shader was made for someone very special. It is based on an infinity mirror we gazed at for a long time.\n\nRobRob\n\nNote: There are probably better techniques for rendering scenes like these. If so, please let me know. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "Wld3zM",
            "likes": 28,
            "name": "Inside an Infinity Mirror",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "rgb",
                "bloom",
                "rainbow",
                "modulo",
                "mirror",
                "infinity",
                "robrob"
            ],
            "usePreview": 0,
            "username": "RobRob",
            "viewed": 2039
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n// International License.\n\n// Created by RobRob for display on shadertoy.com.\n\n// Number of spheres that spawn randomly.\n#define SPHERE_AMOUNT 14.\n\n// Determines how quickly the camera moves through space.\n#define MOVEMENT_SPEED 4.\n\n// Determines how long it takes before the spectrum repeats itself.\n// Values between [0, 1] make it go faster, values larger than 1 make it go slower.\n#define SPECTRUM_SPEED 4.\n\n// Determines how often colours repeat. Larger values will show more coloured 'stripes'.\n#define SPECTRUM_REPETITION 2.\n\n// All lights will spawn between [-interval, interval] on the x and y-axes.\n#define INTERVAL 40.\n\n// Repetition period per axis. Set to 0 for no repetitions.\n// This case means repetition on the y and z axes.\n#define REPEAT vec3(0., 5., 5.)\n\n#define MAX_STEPS 50\n#define MAX_DIST 1000.\n#define SURF_DIST .02\n#define Z_PLANE 15.\n#define FLOAT_MAX 3.402823466e+38\n#define WORLD_UP vec3(0., 1., 0.)\n#define WHITE vec3(1.)\n\n// Credits to David Hoskins for the hash21() function.\n// Can be found at https://www.shadertoy.com/view/3t23DD\n// Licensed under\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Note that the function in this shader was modified slightly.\n\n// Take a float as input and return two random floats in range [0, 1].\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.2602, .0905, .2019));\n\tp3 += dot(p3, p3.yzx + 19.98);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// Return the distance to the closest sphere from point p.\nfloat GetSphereDist(vec3 p) {\n    \n    // All spheres will have this radius.\n    // Note that there appear to be more spheres along the\n    // z-axis due to the repeated rendering that we do below.\n    \n    // Radius will be in range [0.09, 0.99]\n    float radius = (sin(iTime / 6.) + 1.1) * .09;\n    \n    float minDist = FLOAT_MAX;\n    \n    // Calculate the distance to the closest sphere.\n    // Note that the position of the spheres is randomly generated\n    // based on 'i' in the loop below.\n    for (float i = 0.; i < SPHERE_AMOUNT; i++) {\n        // Every sphere's 'real' position will be at z = Z_PLANE.\n        // However, due to the repeated rendering (see below)\n        // there appear to be many more spheres.\n        vec3 pos = vec3(hash21(i), Z_PLANE);\n        \n        // Convert values from [0, 1] to [-interval, interval].\n        pos.xy = pos.xy * INTERVAL * 2. - INTERVAL;\n            \n    \t// Repeater set-up based on Bekre's UFO shader, retrieved from:\n    \t// https://www.shadertoy.com/view/4dXGD4\n        \n        // Do the same as:\n\t\t// vec3 repeater = mod(p - pos, REPEAT) - 0.5 * REPEAT;\n        // But make mod(x, 0) = x, which is not defined on all platforms.\n        vec3 repeater = p - pos;\n        for(int zeroOneTwo = 0; zeroOneTwo < 3; zeroOneTwo++) {\n            if (REPEAT[zeroOneTwo] > 0.) {\n                repeater[zeroOneTwo] = mod(repeater[zeroOneTwo], REPEAT[zeroOneTwo]);\n            }\n        }\n        repeater -= 0.5 * REPEAT;\n        \n\t\tfloat dist = length(repeater) - radius;\n        \n        if (dist < minDist) {\n            minDist = dist;\n        }    \n    }\n    \n    return minDist;\n}\n\n// Return (distance, distance to closest object,\n// x-coordinate of hit, y-coordinate of hit).\n// Distance is -1 if there is no hit.\nvec4 RayMarch(vec3 origin, vec3 direction) {\n\t\n    float distance = 0.;\n    float closest = FLOAT_MAX;\n    vec2 closestPoint = vec2(0.);\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        \n    \tvec3 p = origin + direction * distance;        \n        float sphereDistance = GetSphereDist(p);\n        \n        distance += sphereDistance;\n        \n        // If the calculated distance to the closest sphere\n        // is smaller than what it was, update it and\n        // update the hit point as well.\n        if (sphereDistance < closest ) {\n            closest = sphereDistance;\n            closestPoint = p.xy;\n        }\n        \n        if (distance > MAX_DIST) {\n            // No hit\n            return vec4(-1, closest, closestPoint);\n        }\n        \n        if (sphereDistance < SURF_DIST) {\n            // Sphere hit\n            return vec4(distance, 0, closestPoint);\n        }\n    }\n    \n    // No hit\n    return vec4(-1, closest, closestPoint);\n}\n\n// Starting point of the application.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Basic camera and raymarching setup adapated from\n    // \"ShaderToy Tutorial - CameraSystem\"\n    // found at https://www.shadertoy.com/view/4dfBRf\n\t// by Martijn Steinrucken aka BigWings/CountFrolic - 2017\n    // Licensed under\n\t// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    // The middle pixel will become (0, 0).\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;    \n    \n    // Set the camera position.\n    vec3 cameraPos = vec3(0., 1., iTime * MOVEMENT_SPEED);\n    \n    // Set the point we look at.\n    float t = iTime / 4.;\n    vec3 look = cameraPos + vec3(cos(t), sin(t), 3.);\n    \n    // Calculate the camera parameters.\n    vec3 forward = normalize(look - cameraPos);\n    vec3 right = normalize(cross(WORLD_UP, forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    // Calculate the 3D coordinate of the current pixel.\n    vec3 intersection = cameraPos + forward + uv.x * right + uv.y * up;\n    \n    // Calculate the ray from the camera through this pixel.\n    vec3 cameraDir = normalize(intersection - cameraPos);\n\n    // Perform ray marching.\n    vec4 rayMarch = RayMarch(cameraPos, cameraDir);\n    \n    // The distance from the camera to the object\n    // if the ray hits, or -1 for no hit.\n    float distance = rayMarch.x;\n    \n    if (distance == -1.) {\n        // No hit, calculate bloom.\n        \n        // The coordinates of the point closest to the ray.\n        vec2 xy = rayMarch.zw;\n        \n        // Convert the coordinates from [-interval, interval]\n        // to [0, 1].\n        xy = (xy + INTERVAL) / (2. * INTERVAL);\n        \n        // Calculate the bloom color based on the point's coordinates and the time.\n        \n        // Calculation based on defcon8's RGB Rainbow shader found at\n        // https://www.shadertoy.com/view/MsByzV\n        vec3 col =\n            sin(\n            \tSPECTRUM_REPETITION * (xy.x + xy.y + iTime / SPECTRUM_SPEED)\n                + vec3(0, 2, 4)\n        \t)\n            * .5 + .5;\n        \n        // The distance from the ray to the closest point.\n        float closest = rayMarch.y;\n        \n        // Bloom calculation adapted from takumifukasawa's\n        // emissive cube shader found at\n        // https://www.shadertoy.com/view/wd2SWD\n        vec3 bloom = col * pow(closest + 1., -2.);\n        \n        fragColor = vec4(bloom, 1.);        \n    } else {\n        // Hit a sphere, render white.\n        fragColor = vec4(WHITE, 1.);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}