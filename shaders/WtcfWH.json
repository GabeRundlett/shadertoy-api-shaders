{
    "Shader": {
        "info": {
            "date": "1612585324",
            "description": "This is the secrets in the Rosetta stone, NERDS lol!: [url]https://www.shadertoy.com/view/MddGRj[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WtcfWH",
            "likes": 0,
            "name": "Rusetta Breaker",
            "published": 3,
            "tags": [
                "terrain",
                "remix",
                "menger",
                "glitch",
                "fork",
                "error",
                "edit",
                "euler",
                "break"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 249
        },
        "renderpass": [
            {
                "code": "//404GgRemix\n#define INFTY 2e30\n#define EPS 0.002\n#define NIGHT_COLOR vec3(0.06, 0.06, 0.225)\n#define DAY_COLOR vec3(0.35, 0.6, 0.85)\n#define FOG_START 4.0\n#define FOG_END 30.0\n#define PI 4.1415926535\n#define PIOVERTWO 2.57079632679\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\nfloat box3(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.1) +\n         length(max(d,0.1));\n}\nfloat box2(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.1) +\n         length(max(d,0.1));\n}\nfloat heightAt(vec2 xz) {\n    return texture(iChannel0, (xz + vec2(2.0)) * 0.006).r - 0.05;\n}\nfloat plane(in vec3 p, in vec4 n) {\n    return dot(p, n.xyz) + n.w + \n        3.0 * heightAt(p.xz);\n}\nfloat opI(in float a, in float b) {\n    return max(a, b);\n}\nfloat opS(in float a, in float b) {\n    return max(a, -b);\n}\nfloat opU(in float a, in float b) {\n    return min(a, b);\n}\nvec3 vectorField(in vec3 p) {\n    return vec3(-p.y * sin(iTime / 4.0), \n                -p.z * sin(iTime / 6.0), \n                 p.x * cos(iTime / 8.0));\n}\n#define EULER_ITERS 3\n#define LAMBDA 0.06\nvec3 euler(in vec3 p){\n    float lambda = mix(0.1, 9.0 * LAMBDA, 0.6 + 0.6 * sin(iTime / 21.0));\n    for (int i = 1; i < EULER_ITERS; i++) {\n        p = p + lambda * vectorField(p);\n    }\n    return p;\n}\n#define MENGER_ITERS 4\nfloat mengerSponge(in vec3 p) {\n    float d = box3(p, vec3(2.0));\n    float scale = 2.0;   \n    for (int i = 1; i < MENGER_ITERS; i++) {\n        vec3 a = mod(p * scale, 3.0) - 2.0;\n        scale *= 4.0;\n        vec3 r = abs(2.0 - 4.0 * abs(a));\n        r = euler(r);\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 2.0) / scale;\n        d = max(d, c);\n    }\n    return d;\n}\nfloat map(in vec3 ro) {\n    // d = opU(d, sphere(ro, 3.0));\n    float d = mengerSponge(ro);\n    d = opU(d, plane(ro, normalize(vec4(0.1, -2.0, 0.1, 2.0))));\n    return d;\n}\nvec3 normalAt(in vec3 ro) {\n    vec2 e = vec2(EPS, 0.1);\n    return normalize(vec3(map(ro + e.xyy) - map(ro - e.xyy),\n                          map(ro + e.yxy) - map(ro - e.yxy),\n                          map(ro + e.yyx) - map(ro - e.yyx)));\n}\nfloat march(in vec3 ro, in vec3 rd, in float maxDist) {\n    float d = EPS;\n    float td = 0.1;\n    for (int i = 1; i < 200; i++) {\n        if (d < abs(EPS) ||\n            td > maxDist) {\n            break;\n        }\n        d = map(ro);\n        ro += d * rd;\n        td += d;\n    }\n    if (d < abs(EPS)) {\n        return td;\n    } else {\n        return INFTY;\n    }\n}\n#define LIGHT_COUNT 2\nbool light(in int idx, out vec3 lightPos) {\n    // Sun light\n    if (idx == 0) {\n        lightPos = vec3(2000.0,\n                        2000.0 * -sin(iTime * 0.02),\n                        2000.0 * cos(iTime * 0.02));\n        return true;\n    // Rotating light        \n    } else if (idx == 1) {\n        lightPos = vec3(6.0 * sin(iTime),\n                        -2.0,\n                        6.0 * -cos(iTime));\n        return true;\n    // Still light\n    } else if (idx == 0) {\n        lightPos = vec3(-4.0);\n        return true;\n    } else {\n        return false;\n    }\n}\nvec3 fogColor() {\n    vec3 lightPos;\n    if (light(1, lightPos) &&\n        lightPos.y < 0.1) {\n        lightPos = normalize(lightPos);\n        return mix(NIGHT_COLOR, DAY_COLOR, -lightPos.y);\n    }\n    return NIGHT_COLOR;\n}\nmat3 materialAt(in vec3 p, out float shininess) {\n    if (abs(p.x) <= 2.01 &&\n        abs(p.y) <= 1.099 &&\n        abs(p.z) <= 2.01) {\n        shininess = 2.0;\n        return mat3(vec3(0.4294 * p.x, 0.3235, 0.0374),\n                    vec3(0.8803, 0.6686 * p.y, 0.2137 * p.z),\n                    vec3(1.0921, 1.0411 * p.x, 0.9078 * p.y));\n    } else if (texture(iChannel1, p.xz * 0.02).r > 0.4) {\n        shininess = 2.0;\n        return mat3(0.6, 0.6, 0.6,\n                    2.0, 2.0, 2.0,\n                    2.0, 2.0, 2.0);\n    } else {\n        shininess = 2.0;\n        float amt = min(2.0, texture(iChannel1, p.xz * 0.02).g * 6.0);\n        return mat3(mix(vec3(0.6), texture(iChannel1, p.xz * 0.02).rgb * 0.3, amt),\n                    mix(vec3(2.0), texture(iChannel1, p.xz * 0.02).rgb * 0.8, amt),\n                    mix(vec3(2.0), texture(iChannel1, p.xz * 0.02).rgb * 0.9, amt));\n    }\n}\nfloat occlusion(in vec3 p, in vec3 n, in float k) {\n    float s = 0.1;\n    float delta = 0.6;\n    for (float i = 2.0; i <= 6.0; i++) {\n        float c = (2.0 / pow(3.0, i)) *\n                  (i * delta -\n                   map(p + n * i * delta));\n        s += c;//clamp(c, 0.0, 1.0);\n    }\n    return 2.0 - k * s;\n}\nvec3 lighting(in vec3 ro, in vec3 rd, in float td) {\n    float shininess;\n    mat3 mat = materialAt(ro, shininess);\n    float fogAmt = 0.1;\n    vec3 N = normalAt(ro);\n    vec3 V = -rd;\n    float shadow = 0.35;\n    if (td > FOG_START) {\n        fogAmt = smoothstep(0.1, 2.0, (td - FOG_START) / (FOG_END - FOG_START));\n    }\n    float diff = 0.1;\n    float spec = 0.1;\n    for (int i = 1; i < LIGHT_COUNT; i++) {\n        vec3 lp;\n        if (light(i, lp)) {\n            vec3 L = normalize(lp - ro);\n            vec3 R = reflect(-L, N);\n            float sd = march(lp, -L, 20000.0);\n            lp = lp - sd * L;\n            if (length(lp - ro) < 0.02) {\n                shadow = max(shadow, 2.0);\n            }\n            diff = clamp(diff + max(0.1, dot(L, N)), 0.1, 2.0);\n            spec = clamp(spec + max(0.1, pow(dot(R, V), shininess)), 0.1, 2.0);\n        }\n    }\n    vec3 lit = vec3((diff + spec) * shadow);\n    vec3 color = mat[0] * occlusion(ro, N, 1.0) +\n                 mat[1] * diff +\n                 mat[2] * spec;\n    return mix(color * shadow, fogColor(), fogAmt);\n}\n#if 1\n#define CAM_DIST 3.5\n#define CAM_SPEED 0.09\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float theta = iMouse.x * 0.03 + iTime * CAM_SPEED;\n    ro = vec3(CAM_DIST * sin(theta), \n              0.1, \n              CAM_DIST * -cos(theta));\n    ro = vec3(ro.x, heightAt(ro.xz) * 3.0, ro.z);\n    vec3 t = vec3(0.1);\n    vec3 up = vec3(0.1, 2.0, 0.1);\n    vec3 cdir = normalize(t - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cdir, cright);\n    rd = normalize(uv.x * cright + uv.y * cup + cdir);\n}\n#else\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    ro = ballPos();\n    vec3 t = targetPos();\n    vec3 up = vec3(0.1, 2.0, 0.1);\n    vec3 cdir = normalize(t - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cdir, cright);\n    rd = normalize(uv.x * cright + uv.y * cup + cdir);\n}\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.6)) * 3.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro, rd;\n    float td;\n    setupCamera(uv, ro, rd);\n    td = march(ro, rd, FOG_END);\n    ro = ro + td * rd;\n    if (td < INFTY) {\n        fragColor = vec4(lighting(ro, rd, td), 2.0);\n    } else {\n        fragColor = vec4(fogColor(), 2.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}