{
    "Shader": {
        "info": {
            "date": "1714571106",
            "description": "A simple 2D rendering shader for circles, rectangles, rounded rectangles, and triangles. Feel free to use, but please credit the author ðŸ˜‰",
            "flags": 0,
            "hasliked": 0,
            "id": "MftSDf",
            "likes": 1,
            "name": "2D Shape Renderer",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "kamikoto00",
            "viewed": 66
        },
        "renderpass": [
            {
                "code": "const float PI = radians( 180. );\nconst float Inf = 1. / 0.;\nconst float NaN = 0. / 0.;\n\nconst vec2 upRight = vec2( 1, -1 );\n\nconst float defaultSharpness = 0.5;\n\nconst float timeScale = 1.;\n\nstruct RenderContext {\n  vec2 uv;\n  float time;\n  vec3 color;\n};\n\nstruct Circle {\n  vec2 center;\n  float radius;\n  vec4 color;\n};\n\nstruct Rect {\n  vec2 center;\n  vec2 size;\n  float rotation;\n  vec4 color;\n};\n\nstruct RoundedRect {\n  vec2 center;\n  vec2 size;\n  float rotation;\n  float radius;\n  vec4 color;\n};\n\nstruct Triangle {\n  vec2 a;\n  vec2 b;\n  vec2 c;\n  vec4 color;\n};\n\nstruct Transform2D {\n  mat2 matrix;\n  vec2 translation;\n};\n\nTransform2D createTransform( vec2 pos, vec2 scale, float rotation, vec2 skew );\nTransform2D createTransform( vec2 pos, vec2 scale, float rotation );\nTransform2D createTransform( vec2 pos, vec2 scale );\nTransform2D createTransform( vec2 pos, float rotation );\nTransform2D createTransform( vec2 pos );\nTransform2D createTransform( );\n\nTransform2D inverseTransform( Transform2D transform );\nvoid applyTransform( inout vec2 uv, Transform2D transform );\nvoid applyInverseTransform( inout vec2 uv, Transform2D transform );\n\nfloat maxV( vec2 v );\nfloat maxV( vec3 v );\nfloat maxV( vec4 v );\nfloat minV( vec2 v );\nfloat minV( vec3 v );\nfloat minV( vec4 v );\n\nfloat cross2( vec2 a, vec2 b );\nmat2 rotationMat2( float angle );\n\nvoid draw( inout RenderContext context, Circle circle, bool inverse, float sharpness );\nvoid draw( inout RenderContext context, Circle circle, bool inverse );\nvoid draw( inout RenderContext context, Circle circle, float sharpness );\nvoid draw( inout RenderContext context, Circle circle );\nvoid draw( inout RenderContext context, Rect rect, bool inverse, float sharpness );\nvoid draw( inout RenderContext context, Rect rect, bool inverse );\nvoid draw( inout RenderContext context, Rect rect, float sharpness );\nvoid draw( inout RenderContext context, Rect rect );\nvoid draw( inout RenderContext context, RoundedRect roundedRect, bool inverse, float sharpness );\nvoid draw( inout RenderContext context, RoundedRect roundedRect, bool inverse );\nvoid draw( inout RenderContext context, RoundedRect roundedRect, float sharpness );\nvoid draw( inout RenderContext context, RoundedRect roundedRect );\nvoid draw( inout RenderContext context, Triangle triangle, bool inverse, float sharpness );\nvoid draw( inout RenderContext context, Triangle triangle, bool inverse );\nvoid draw( inout RenderContext context, Triangle triangle, float sharpness );\nvoid draw( inout RenderContext context, Triangle triangle );\nvoid beginContainer( inout RenderContext context, Transform2D transform );\nvoid endContainer( inout RenderContext context, Transform2D transform );\n\nvoid scene( inout RenderContext context ) {\n  Transform2D container = createTransform( vec2( 0. ), context.time );\n  beginContainer( context, container );\n    draw( context, Circle( vec2( 0., 0.25 ), 0.25, vec4( 1, 0, 0, 0.7 ) ) );\n    draw( context, Rect( vec2( 0. ), vec2( 0.25, 0.5 ), 0., vec4( 0, 1, 0, 0.7 ) ) );\n    draw( context, RoundedRect( vec2( 0.2, 0. ), vec2( 0.25, 0.5 ), 0.5, 0.1, vec4( 0, 0, 1, 0.7 ) ) );\n    Transform2D container2 = createTransform( vec2( 0.5 ), vec2( 1. ), 0.0, vec2( 0.0 ) );\n    beginContainer( context, container2 );\n      draw( context, Triangle( vec2( 0.0, -0.1 ), vec2( -0.1, 0.1 ), vec2( 0.1, 0.1 ), vec4( 1, 1, 0, 0.7 ) ) );\n    endContainer( context, container2 );\n  endContainer( context, container );\n  draw( context, Circle( vec2( 0. ), 1., vec4( 0, 0, 0, 1 ) ), true );\n  draw( context, Rect( vec2( 0. ), vec2( 2. ), 0., vec4( 0, 0, 0, 1 ) ), true, Inf );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n  float time = timeScale * iTime;\n  vec2 uv = ( fragCoord * 2. - iResolution.xy ) / minV( iResolution.xy ) * upRight;\n  RenderContext context = RenderContext( uv, time, vec3( 0. ) );\n  //checkerboard\n  context.color = vec3( fract( uv.x * 10. ) < 0.5 != fract( uv.y * 10. ) < 0.5 ) * 0.5 + 0.25;\n  scene( context );\n  fragColor = vec4( context.color, 1 );\n}\n\nfloat maxV( vec2 v ) {\n  return max( v.x, v.y );\n}\n\nfloat maxV( vec3 v ) {\n  return max( maxV( v.xy ), v.z );\n}\n\nfloat maxV( vec4 v ) {\n  return max( maxV( v.xy ), maxV( v.zw ) );\n}\n\nfloat minV( vec2 v ) {\n  return min( v.x, v.y );\n}\n\nfloat minV( vec3 v ) {\n  return min( minV( v.xy ), v.z );\n}\n\nfloat minV( vec4 v ) {\n  return min( minV( v.xy ), minV( v.zw ) );\n}\n\nmat2 rotationMat2( float angle ) {\n  float s = sin( angle );\n  float c = cos( angle );\n  return mat2( c, -s, s, c );\n}\n\nfloat cross2( vec2 a, vec2 b ) {\n  return a.x * b.y - a.y * b.x;\n}\n\nvoid draw( inout RenderContext context, Circle circle, bool inverse, float sharpness ) {\n  float alpha = ( distance( context.uv, circle.center ) - circle.radius ) * maxV( iResolution.xy ) * sharpness;\n  alpha = clamp( alpha * ( float( inverse ) - 0.5 ) + circle.radius * 0.5, 0., 1. ) * circle.color.a;\n  context.color = mix( context.color, circle.color.rgb, alpha );\n}\n\nvoid draw( inout RenderContext context, Circle circle, bool inverse ) {\n  draw( context, circle, inverse, defaultSharpness );\n}\n\nvoid draw( inout RenderContext context, Circle circle, float sharpness ) {\n  draw( context, circle, false, sharpness );\n}\n\nvoid draw( inout RenderContext context, Circle circle ) {\n  draw( context, circle, false );\n}\n\nvoid draw( inout RenderContext context, Rect rect, bool inverse, float sharpness ) {\n  vec2 d = abs( ( context.uv - rect.center ) * rotationMat2( rect.rotation ) ) - rect.size * 0.5;\n  float alpha = maxV( d ) * maxV( iResolution.xy ) * sharpness;\n  alpha = clamp( alpha * ( float( inverse ) - 0.5 ) + minV( rect.size ) * 0.5, 0., 1. ) * rect.color.a;\n  context.color = mix( context.color, rect.color.rgb, alpha );\n}\n\nvoid draw( inout RenderContext context, Rect rect, bool inverse ) {\n  draw( context, rect, inverse, defaultSharpness );\n}\n\nvoid draw( inout RenderContext context, Rect rect, float sharpness ) {\n  draw( context, rect, false, sharpness );\n}\n\nvoid draw( inout RenderContext context, Rect rect ) {\n  draw( context, rect, false );\n}\n\nvoid draw( inout RenderContext context, RoundedRect roundedRect, bool inverse, float sharpness ) {\n  vec2 uv = abs( ( context.uv - roundedRect.center ) * rotationMat2( roundedRect.rotation ) ) - roundedRect.size * 0.5;\n  vec2 cuv = uv + roundedRect.radius;\n  float rectAlpha = maxV( uv );\n  float cornerAlpha = length( cuv ) - roundedRect.radius;\n  float alpha = mix( rectAlpha, cornerAlpha, float( minV( cuv ) > 0. ) );\n  alpha *= maxV( iResolution.xy ) * sharpness;\n  alpha = clamp( alpha * ( float( inverse ) - 0.5 ) + minV( roundedRect.size ) * 0.5, 0., 1. ) * roundedRect.color.a;\n  context.color = mix( context.color, roundedRect.color.rgb, alpha );\n}\n\nvoid draw( inout RenderContext context, RoundedRect roundedRect, bool inverse ) {\n  draw( context, roundedRect, inverse, defaultSharpness );\n}\n\nvoid draw( inout RenderContext context, RoundedRect roundedRect, float sharpness ) {\n  draw( context, roundedRect, false, sharpness );\n}\n\nvoid draw( inout RenderContext context, RoundedRect roundedRect ) {\n  draw( context, roundedRect, false );\n}\n\nvoid draw( inout RenderContext context, Triangle triangle, bool inverse, float sharpness ) {\n  vec2 uv = context.uv;\n  vec2 a = triangle.a;\n  vec2 b = triangle.b;\n  vec2 c = triangle.c;\n  float area = cross2( b - a, c - a );\n  float alpha = cross2( b - uv, c - uv ) / area;\n  float beta = cross2( c - uv, a - uv ) / area;\n  float gamma = 1.0 - alpha - beta;\n  float finalAlpha = minV( vec3( 1. - abs( alpha - 1. ), 1. - abs( beta - 1. ), 1. - abs( gamma - 1. ) ) );\n  finalAlpha = finalAlpha * maxV( iResolution.xy ) * sharpness * ( 0.5 - float( inverse ) ) * 2. + abs( area ) * 0.5;\n  finalAlpha = clamp( finalAlpha, 0., 1. ) * triangle.color.a;\n  context.color = mix( context.color, triangle.color.rgb, finalAlpha );\n}\n\nvoid draw( inout RenderContext context, Triangle triangle, bool inverse ) {\n  draw( context, triangle, inverse, defaultSharpness );\n}\n\nvoid draw( inout RenderContext context, Triangle triangle, float sharpness ) {\n  draw( context, triangle, false, sharpness );\n}\n\nvoid draw( inout RenderContext context, Triangle triangle ) {\n  draw( context, triangle, false );\n}\n\nTransform2D createTransform( vec2 pos, vec2 scale, float rotation, vec2 skew ) {\n  float sx = sin(-skew.x);\n  float cx = cos(-skew.x);\n  float sy = sin(skew.y);\n  float cy = cos(skew.y);\n  float s = sin(rotation);\n  float c = cos(rotation);\n  return Transform2D(\n    mat2(\n      scale.x * ( c * cy - s * sy ), -scale.x * ( s * cx + c * sx ),\n      scale.y * ( c * sy + s * cy ), -scale.y * ( s * sx - c * cx )\n    ),\n    pos\n  );\n}\n\nTransform2D createTransform( vec2 pos, vec2 scale, float rotation ) {\n  return createTransform( pos, scale, rotation, vec2( 0. ) );\n}\n\nTransform2D createTransform( vec2 pos, vec2 scale ) {\n  return createTransform( pos, scale, 0.0 );\n}\n\nTransform2D createTransform( vec2 pos, float rotation ) {\n  return createTransform( pos, vec2( 1.0 ), rotation );\n}\n\nTransform2D createTransform( vec2 pos ) {\n  return createTransform( pos, 0.0 );\n}\n\nTransform2D createTransform( ) {\n  return createTransform( vec2( 0.0 ) );\n}\n\nTransform2D inverseTransform( Transform2D transform ) {\n  return Transform2D( inverse( transform.matrix ), -transform.translation * transform.matrix );\n}\n\nvoid applyTransform( inout vec2 uv, Transform2D transform ) {\n  uv = uv * transform.matrix + transform.translation;\n}\n\nvoid applyInverseTransform( inout vec2 uv, Transform2D transform ) {\n  uv = ( uv - transform.translation ) * inverse( transform.matrix );\n}\n\nvoid beginContainer( inout RenderContext context, Transform2D transform ) {\n  applyInverseTransform( context.uv, transform );\n}\n\nvoid endContainer( inout RenderContext context, Transform2D transform ) {\n  applyTransform( context.uv, transform );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}