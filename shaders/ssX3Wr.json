{
    "Shader": {
        "info": {
            "date": "1615768551",
            "description": "3 simple drop in grid functions - click a grid to show it as full screen\nbaked shader info used here - https://www.youtube.com/watch?v=MpwcOnrWffQ",
            "flags": 0,
            "hasliked": 0,
            "id": "ssX3Wr",
            "likes": 15,
            "name": "GridX3",
            "published": 3,
            "tags": [
                "grid",
                "simplex",
                "square",
                "distance",
                "edge",
                "hex",
                "tri"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 450
        },
        "renderpass": [
            {
                "code": "// Simple Hex, Tri and Square grids (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 15/03/2021\n\n// nice hex function from - https://www.shadertoy.com/view/lldfWH\n// All 3 Grid functions return the same:\n// ret.x  - distance to border\n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    //id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    //id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43,length(triuv),triuv);\n}\n/*\n// triangle grid equiv\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    const vec2 s = vec2(1, .8660254); // Sqrt (3)/2\n    uv /= s;\n    float ys = mod(floor(uv.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    vec4 ip4 = floor(uv.xyxy + ipY) - ipY + .5; \n    vec4 p4 = fract(uv.xyxy - ipY) - .5;\n    float itri = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    p4 = itri>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);  \n\n    vec2 ep = p4.xy;\n    float off = 0.14433766666667*itri;\n    ep.y = (ep.y + off) * itri;\n    \n    // inline sdEqTri\n    const float k = 1.7320508;//sqrt(3.0);\n    ep.x = abs(ep.x) - 0.5;\n    ep.y = ep.y + 0.5/k;\n    if( ep.x+k*ep.y>0.0 ) ep = vec2(ep.x-k*ep.y,-k*ep.x-ep.y)/2.0;\n    ep.x -= clamp( ep.x, -1.0, 0.0 );\n    float edge = -length(ep)*sign(ep.y);    // dist to edge\n    \n    id = p4.zw;\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    p4.y+=off;\n    return vec4(abs(edge),length(p4.xy),p4.xy);\n}\n*/\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    uv += 0.5;\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n// Demo 3xGrids or Let the user select a grid with mouse...\nfloat SelectGrid(float xx)\n{\n    float gridtype = 0.5;\n    if (iMouse.z>0.5)\n        xx = ((iMouse.x-.5*iResolution.x) / iResolution.x)+0.5;\n    if (xx > 0.66)\n        gridtype=2.5;\n    else if (xx > 0.33)\n        gridtype = 1.5;\n    return gridtype;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n    float yy = ((fragCoord.y-.5*iResolution.y) / iResolution.x)+0.5;\n\n    // dirty grid switching\n    vec2 id;\n    vec4 h;\n    float gridtype = SelectGrid(xx);\n    if (gridtype>= 2.0)\n        h = SquareGrid(uv*8.0, id);\n    else if (gridtype>=1.0)\n        h = HexGrid(uv*8.0, id);\n    else\n        h = TriGrid(uv*8.0, id);\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.35,0.22,0.35);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 33.5\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv*vv); // white edge\n    finalcol = mix(vec3(0.0),finalcol,smoothstep(0.0, 0.035, h.y-0.035)); // black outline centre\n    vv = smoothstep(0.0, 0.055, h.y);\n    finalcol = mix(bordercol,finalcol, vv*vv);  // white centre\n\n    if (iMouse.z<0.5)\n    {\n        if (uv.y < 0.0)\n            finalcol = vec3(h.x,h.x,h.x); // just show cell edge distances in bottom half of screen\n        // add some red divider lines\n        float dd = max( step(abs(xx-0.33),0.0025),step(abs(xx-0.66),0.0025));\n        dd = max(dd,step(abs(yy-0.5),0.0025));\n        finalcol = dd<1.0 ? finalcol : vec3(1.0,0.3,0.3);\n    }\n\n    //finalcol = vec3(h.x,h.x,h.x); // just show cell edge distance\n    //finalcol = vec3(h.zw,0.0);    // just show cell uv\n    //finalcol = vec3(h.y,h.y,h.y); // just show cell centre distance\n    fragColor = vec4(finalcol,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}