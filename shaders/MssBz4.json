{
    "Shader": {
        "info": {
            "date": "1495142753",
            "description": "bloom experiment...",
            "flags": 32,
            "hasliked": 0,
            "id": "MssBz4",
            "likes": 10,
            "name": "TriforceTunnel",
            "published": 3,
            "tags": [
                "tunnel",
                "raymarch",
                "bloom"
            ],
            "usePreview": 0,
            "username": "nshelton",
            "viewed": 872
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec2 delta = vec2(uv - 0.5) * 0.02;\n    vec3 col = vec3(0.0);;\n    \n    col += texture(iChannel0, uv- 2.0 * delta).rgb * vec3(1.0, 0.2, 0.0);\n    col += texture(iChannel0, uv- 1.0 * delta).rgb * vec3(0.5, 0.5, 0.0);\n    col += texture(iChannel0, uv).rgb              * vec3(0.2, 1.0, 0.2);\n    col += texture(iChannel0, uv+ 1.0 * delta).rgb * vec3(0.0, 0.5, 0.5);\n    col += texture(iChannel0, uv+ 2.0 * delta).rgb * vec3(0.0, 0.2, 1.0);\n    \n    col = col / 2.0;\n    \n    fragColor = vec4(col, 1.0);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 q = p;\n    vec3 c = vec3(0.1);\n    p.z = mod(p.z,c.z)-0.5*c.z;\n    \n    p = rotationMatrix(vec3(0,0,1), q.z + sin(iTime/100.0) * 100.0) * p;\n    \n    float rad = 0.3;\n        \n\tfloat outer = sdTriPrism(p, vec2(rad, 0.001));\n    float inner = sdTriPrism(p, vec2(0.99 * rad, 0.2));\n    \n    float ring1 = opS(inner, outer);\n    \n    rad /= 3.0;\n\tmat3 halfTriRot = rotationMatrix(vec3(0,0,1), 3.1415 / 3.0);\n\n    outer = sdTriPrism(p, vec2(rad, 0.001));\n    inner = sdTriPrism(halfTriRot * p, vec2(0.5 * rad, 0.2));\n    \n    float ring2 = opS(inner, outer);\n    \n    rad = 1.0;\n\n    outer = sdTriPrism(halfTriRot * p, vec2(rad, 0.01));\n    inner = sdTriPrism(halfTriRot * p, vec2(0.4 * rad, 0.2));\n    \n    ring2 = min(opS(inner, outer), ring2);\n    \n\n    float dist = min(ring1, ring2);\n    return vec2(dist, ring1);\n    \n}\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = iTime /  10.0;\n        \n    vec2 m = sin(vec2(1.57079632, 0) + iTime/10.);\n    rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);\n    \n    \n}\n\n\nvec3 normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    \n/*\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n*/\t\n}\n//https://iquilezles.org/articles/fog\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float b = 3.0 ;\n    float fogAmount = 1.0 - exp( -distance*b );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.0,0.1,0.4), \n                           vec3(0.0,0.9,0.7),\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 _p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    \n    getCamPos(cam, ray);\n    \n    float depth = 0.0, iter = 0.0;\n    vec2 d = vec2(0.0);\n    vec3 p;\n    float mat;\n    bool hit = false;\n    \n    for( int i = 0; i < 50; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d.x < 0.001) {\n         \thit = true;   \n            break;\n        }\n                   \n\t\tdepth += d.x;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 50.0);\n    if ( hit)\n    {\n        float ss = sin(p.z * 3.0)* 0.5 + 0.5;   \n\n        if (d.y == d.x ){\n    \t    col = vec3(ss,1,0);\n            \n        }else{\n            \n            col *= vec3(ss,1.0 - ss,0.0) * (0.5 + 0.5 * dot(ray,-normal(p))) * 0.4;\n            \n            //fake green lighting from emissive lines\n            \n            col += vec3(1.0, 1.0, 0.0) * (1.0 / (0.2 * d.y * d.y)) * 0.001;\n            col = applyFog(col, depth, ray, vec3(1.0, 0.0, 0.0)) ;\n\n        }\n           \n    }\n    else\n    {\n        d.y = 0.0;\n\t\tcol = applyFog(col, depth, ray, vec3(1.0, .0, 0.0)) ;\n\n    }\n    \n\n    fragColor = vec4(col , d.y/2.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 total = vec4(0.0);\n\tvec2 delta = vec2(1.5, 0.0) / iResolution.x;\n    //const float weights[9] = float[9](0.091637,0.105358,0.1164,0.123573,0.126061,0.123573,0.1164,0.105358,0.091637);\n    const float weights[9] = float[9](1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n    \n    total += texture(iChannel0, uv - 4.0 * delta) * weights[0];\n    total += texture(iChannel0, uv - 3.0 * delta) * weights[1];\n    total += texture(iChannel0, uv - 2.0 * delta) * weights[2];\n    total += texture(iChannel0, uv - 1.0 * delta) * weights[3];\n    total += texture(iChannel0, uv - 0.0 * delta) * weights[4];\n    total += texture(iChannel0, uv + 1.0 * delta) * weights[5];\n    total += texture(iChannel0, uv + 2.0 * delta) * weights[6];\n    total += texture(iChannel0, uv + 3.0 * delta) * weights[7];\n    total += texture(iChannel0, uv + 4.0 * delta) * weights[8];\n    \n    fragColor = total/9.0;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 total = vec4(0.0);\n\tvec2 delta = vec2(0.0, 1.5) / iResolution.y;\n\n    //const float weights[9] = float[9](0.091637,0.105358,0.1164,0.123573,0.126061,0.123573,0.1164,0.105358,0.091637);\n\n    const float weights[9] = float[9](1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n    total += texture(iChannel0, uv - 4.0 * delta) * weights[0];\n    total += texture(iChannel0, uv - 3.0 * delta) * weights[1];\n    total += texture(iChannel0, uv - 2.0 * delta) * weights[2];\n    total += texture(iChannel0, uv - 1.0 * delta) * weights[3];\n    total += texture(iChannel0, uv - 0.0 * delta) * weights[4];\n    total += texture(iChannel0, uv + 1.0 * delta) * weights[5];\n    total += texture(iChannel0, uv + 2.0 * delta) * weights[6];\n    total += texture(iChannel0, uv + 3.0 * delta) * weights[7];\n    total += texture(iChannel0, uv + 4.0 * delta) * weights[8];\n    \n    fragColor = total/9.0;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    vec3 blur = texture(iChannel1, uv).rgb;\n    base = vec3((base.r + base.g));\n\tblur = vec3(length (blur));\n    //base.b = 0.0;\n   // blur.g = 0.0;\n    \n\tvec3 col = base + blur * (0.5+ 0.5 * pow(cos(iTime), 10.0) );\n\n    \n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n        fragColor = vec4(col/2.0, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}