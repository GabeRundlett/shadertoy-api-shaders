{
    "Shader": {
        "info": {
            "date": "1512834157",
            "description": "Using a mixture of a cross-over tile and double arc tile to produce a pipe pattern. It's a 2D effect, but rendered in a pseudo 3D style.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlXBzl",
            "likes": 29,
            "name": "2D Pipe Pattern",
            "published": 3,
            "tags": [
                "2d",
                "shadow",
                "truchet",
                "pattern",
                "tile",
                "layer"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1947
        },
        "renderpass": [
            {
                "code": "/*\n\n\t2D Pipe Pattern\n\t---------------\n\n\tUsing a mixture of a cross-over tile and double arc tile to produce a pipe pattern.\n\tIt's a 2D effect, but is rendered in an oldschool psuedo 3D game style... kind of. :)\n\n\tI like coding in psuedo 3D, because it's relaxing, and it's fun composing the illusion\n\tof depth and lighting...  I also like it because the physics police can't really \n\tcomplain that the mock physical setting isn't fake enough. :D\n\n\tAnyway, there's nothing here that hasn't been done before. It's a relatively brief \n\texample, and it's all pretty easy to code. If you can draw 2D shapes over other 2D \n\tshapes, then it shouldn't present too much of a challenge.\n\n\n\tSimilar examples:\n\n\t// Another dual tiled Truchet example.\n\tTruchet Roads - morgaza\n\thttps://www.shadertoy.com/view/4lsyDX\n\n\t// The 3D counterpart. Not as relaxing to code this one, but still doable. :)\n\tDual 3D Truchet Tilesv- Shaen\n\thttps://www.shadertoy.com/view/4l2cD3\n\n*/\n\n// I put this here for anyone who wants to see the outlines of the individual Truchet tiles.\n//#define SHOW_SINGLE_TILES\n\n// I put these in out of sheer boredom. The idea was to provide a little extra visual \n// interest... I'll leave them in as a default, but I'm still not quite sure about them. :)\n#define ENVIRONMENTAL_LIGHTS\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(1, 57, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n\n// IQ's 2D box function. Necessary for correct box shadows.\nfloat sdBox(vec2 p, vec2 b){\n  \n  return length(max(abs(p) - b, 0.));\n  //vec2 d = abs(p) - b;\n  //return min(max(d.x,d.y), 0.) + length(max(d,0.0));\n}\n\n// Background lines. Horizonal only, or horitonal and vertical, \n// as the case may be.\nfloat bgLines(vec2 p){\n   \n  p = abs(fract(p) - .5);\n  #ifdef SHOW_SINGLE_TILES\n  return min(p.x, p.y);  \n  #else\n  return p.x;\n  #endif\n    \n}\n\n// Vec2 to vec3 hash. Works well enough, but I should probably substitute it for \n// one of Dave Hoskins's more robust versions.\nvec3 hash23(vec2 p){\n    \n    vec3 dt;\n    dt.x = dot(p, vec2(1.361, 113.947));\n    dt.y = dot(p + 7.54, vec2(1.361, 113.947));\n    dt.z = dot(p + 23.893, vec2(1.361, 113.947)); \n    \n    return fract(sin(dt)*43758.5453);\n    \n}\n\n// Background pipe shadows. A bit wasteful, considering that you could put a \n// blurry grid in the background, and the shadows would almost look the same, but\n// something in my mind won't quite accept it. :)\nfloat truSh(vec2 p, float lW){\n   \n    \n    // Two tile Truchet system. Pretty standard.\n    vec2 ip = floor(p);\n    \n    // Three random numbers, used for tile selection and tile flipping.\n    vec3 rnd = hash23(ip);\n    \n    // Grid.\n    p -= ip + .5;\n    \n    // Depending on the random number, select the tile, and flip it if necessary.\n    if(rnd.z>.35){\n        // Cross rotation. Flipping has no effect.\n    \tif(rnd.x > .5) p = p.yx;\n    }\n    else if(rnd.y > .5) p.y = -p.y; // Dual arc flipping. Rotation does the same thing.\n    \n        // Distance field variables.\n    float d1, d2, d3, d4;\n    \n    \n    if(rnd.z>.35){\n        \n        // Cross tile.\n        d1 = abs(p.y) - lW;\n        d2 = abs(p.x) - lW;\n        \n    }\n    else { \n        \n        // Dual arc tile.\n        d1 = length(p - .5) - .5;\n        d2 = length(p + .5) - .5;\n        d1 = abs(d1) - lW;\n        d2 = abs(d2) - lW;\n        \n    }\n    \n    // Joins.\n    d3 = sdBox(vec2(p.x, abs(p.y) - .5 + lW/3.), vec2(lW + .03, lW/6.));\n \td4 = sdBox(vec2(p.y, abs(p.x) - .5 + lW/3.), vec2(lW + .03, lW/6.));\n\n    \n    // Overall object.\n    return min(min(d1, d2), min(d3, d4));\n}\n\n/*\n// Altermative, cheaper shadow. Just a grid. Almost works... almost. :)\nfloat truShFake(vec2 p){\n   \n  p = abs(fract(p) - .5);\n  return min(p.x, p.y);\n}\n*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates. I've coded it for the 800 by 450 window, so have put some mild\n    // restrictions on the resolution to account for blurriness, Moire patterns at smaller\n    // canvas sizes, etc.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/clamp(iResolution.y, 350., 600.);\n    \n    // Mild lens distortion. It's a cool effect, but I wasn't feeling it for this example.\n    //uv *= 1. + dot(uv, uv)*.03;\n    \n    \n    // Scale. Analogous to the field of view.\n    const float sc = 4.;\n\n    // Sizing the scene and moving it.\n    vec2 p = uv*sc + vec2(sin(iTime*3.14159/16.)*2., 1.*iTime);\n    \n    // Putting a light slightly up to the right, just to match the fake drop shadows.\n    // It's used for a bit of subtle attenuation.\n    vec3 lp = vec3(vec2(sin(iTime*3.14159/16.), 1.*iTime) + .5, -1);\n    \n    // Keeping a copy of the sized screen coordinates.\n    vec2 oP = p;\n    \n    \n    // GRID SETUP.\n    //\n    // Grid square (tile) ID.\n    vec2 ip = floor(p);\n    \n    // Three random numbers, used for tile selection and tile flipping.\n    vec3 rnd = hash23(ip);\n    \n    // Partition the grid. Equivalent to: p = fract(p) - .5;\n    p -= ip + .5;\n    \n    // Depending on the random number, select the tile, and flip it if necessary.\n    if(rnd.z>.35){\n        // Cross rotation. Flipping has no effect.\n    \tif(rnd.x > .5) p = p.yx;\n    }\n    else if(rnd.y > .5) p.y = -p.y; // Dual arc flipping. Rotation does the same thing.\n\n        \n    \n    // THE BACKGROUND.\n    //\n    // Background: Not sure why I vignetted it, because it gets attenuated later... I'll\n    // amalgamate the two when I get time.\n    vec3 bg = vec3(1.1, 1, .9)*vec3(.85, .75, .65)*max(1. - length(uv)*.35, 0.);\n\n    \n    // Pipe pattern (dual Truchet) drop shadow.\n    float tru = truSh(oP + .1, .15);\n    //float tru = truShFake(oP + .1) - .15; // Fake shadow grid. \n    \n    // Put the drop shadow on the background.\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .15, tru))*.35);    \n    \n        \n\n    // Putting some lines on the background. I made it up as I went along, so I\n    // wouldn't take it too seriously.\n    #ifdef SHOW_SINGLE_TILES\n    const float scl = 1.;\n    #else\n    const float scl = .5;\n    #endif\n    float vor = bgLines((oP - (scl<.75? 0.: .5))*scl);\n    float sq = vor - .03*scl;\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .1*scl, sq))*.7);\n    sq = vor - (.075 + .01)*scl;\n    sq = abs(sq) - .0075*scl;\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .01*scl, sq))*.9);    \n    sq = vor;\n    sq = abs(sq) - .0075*scl;\n    bg = mix(bg, vec3(0), (1. - smoothstep(0., .01*scl, sq))*.9);\n\n    // Quick, diagonal line pattern. Pretty standard way to make one.   \n    float diag = clamp(sin((oP.x - oP.y)*6.283*20.)*1. + .95, 0., 1.)*.5 + .5;      \n    // Applying it to the background.\n\tbg = mix(bg, vec3(0), (smoothstep(0., .01*scl, vor - .0075*sc))*(1. - diag)*.9);\n   \n  \n\n    // MAIN OBJECT COMPOSITION.\n    //\n    // Scene color. Set it to the pre-prepared background.\n    vec3 col = bg;\n    vec3 jCol = vec3(1, .7, .5); //  Join color.\n    vec3 pCol = vec3(.95, .98, 1); // Pipe color.\n    float lW = .125; // Pipe width. \n    const float shadow = .35; // Drop shadow factor.\n    const float lnTrans = .9; // Shape line transparency.\n    \n    const float shPow = 4.; // Shade power.\n    const float shAmp = 1.1; // Shade amplitude.\n    const float shAmb = .1; // Shade ambience.\n    \n    \n    #ifdef ENVIRONMENTAL_LIGHTS\n    // Environmental light display: Interesting, but needs some tweaking. In case it needs to be said, I've \n    // added it in for visual interest. However, I can't really think of a physical reason why it'd be there...\n    // And why isn't at least some light registering on the back wall? ... So many unanswered questions. :D\n    tru = truSh(oP, .0);\n    float tru2 = truSh(r2(-3.14159/3.)*oP*3. + .5 + iTime*.35, .0);\n \tfloat lgtMsk = (1. - smoothstep(0., lW, tru))*(1. - smoothstep(0., .15, tru2));\n    #endif\n    \n    // OBJECT DISTANCE FIELDS.\n    //\n    // Distance and shading variables.\n    float d1, d2, d3, d4, d5, sh1, sh2, sh3, sh4, sh5;\n    \n    \n    // Apply the distance fields and shades for the overlayed straight pipe tile, and for\n    // the quarter bent pipe tile. The code below looks fiddly, but it's all pretty simple.\n    // Draw a rectange, or an arc, etc. Shade and so forth.\n    //\n    // Rendering more straight pipes than curved ones. Pipe bends tend to occur less.\n    if(rnd.z>.35){ \n        \n        // The overlayed straight pipes.\n        \n        // Vertical and horizontal pipes.\n        d1 = abs(p.y) - lW;\n        d2 = abs(p.x) - lW;\n        \n        #ifdef ENVIRONMENTAL_LIGHTS\n        // Adding the moving lights. I hacked this in. The cross over pipe needs a bit of masking,\n        // logic, due to one pipe going under the other. It doesn't look right without it.        \n        if(rnd.x<=.5) pCol = mix(pCol, vec3(2, 3, 4), (1. - smoothstep(0., .05, d2+lW))*lgtMsk*.5);\n\t\tpCol = mix(pCol, vec3(2, 2.5, 3), (smoothstep(0., .02, d2))*lgtMsk*.35);\n        #endif\n\n    }\n    else {\n        \n        // The quarter pipe bends. Two on each tile. I'm rendering both for simplicity.\n        // Plus, I wanted to ensure that the shadows rendered correctly. Having said that,\n        // I'll come back to this and cut down on the double rendering when I have time.\n        \n        // Two arcs (quarter pipes).\n        d1 = length(p - .5) - .5;\n        d2 = length(p + .5) - .5;\n        d1 = abs(d1) - lW;\n        d2 = abs(d2) - lW;\n        \n        #ifdef ENVIRONMENTAL_LIGHTS\n        // Adding the environmental lighting to the pipes.\n        pCol = mix(pCol, vec3(2, 2.5, 3), lgtMsk*.35);\n        #endif\n\n\n        \n    }\n    \n    #ifdef ENVIRONMENTAL_LIGHTS  \n    // Adding the environmental lighting to the joins.\n    jCol = mix(jCol, vec3(2, 2.5, 3), lgtMsk*.15);\n    #endif\n    \n    // Joins. They're the same for each tile, so can be taken outside the \"if\" statement.\n    d3 = sdBox(vec2(p.x, abs(p.y) - .5 + lW/3.25), vec2(lW + .03, lW/6.));\n    d4 = sdBox(vec2(p.y, abs(p.x) - .5 + lW/3.25), vec2(lW + .03, lW/6.));\n\n    // Extra shadowing, to place over the bottom pipe. Makes the shadows a little more realistic.\n    d5 = length(p) - .2;\n    \n    \n    // LIGHTING THE OBJECTS.\n    //\n    // Using the distance field to shade the objects. \n    sh1 = (-d1 + lW)/lW/2.;\n    sh2 = (-d2 + lW)/lW/2.;\n    float d3in = abs(p.x) - lW - .03;\n    float d4in = abs(p.y) - lW - .03;\n    sh3 = (-d3in + lW)/lW/2.;\n    sh4 = (-d4in + lW)/lW/2.;\n\n    // Tube ribbed lines.\n    sh1 *= clamp(sin(d1*6.283*24.)*.5 + 1., 0., 1.);\n    sh2 *= clamp(sin(d2*6.283*24.)*.5 + 1., 0., 1.);\n\n\n    // Ramping up the shading for a more metallic look.\n    sh1 = pow(max(sh1, 0.), shPow)*shAmp + shAmb;\n    sh2 = pow(max(sh2, 0.), shPow)*shAmp + shAmb;\n    sh3 = pow(max(sh3, 0.), shPow)*shAmp + shAmb;\n    sh4 = pow(max(sh4, 0.), shPow)*shAmp + shAmb;\n\n    sh5 = (cos(p.y*6.283*1.5)*.5 + 1.25);\n    sh5 = pow(sh5, 1.)*sh2;\n    \n    // RENDERING THE LAYERS.\n    //\n    // In short, render a drop shadow, sharp dark egde, then apply the main \n    // color and pattern. Pretty standard stuff.\n    //\n    // Drop shadow.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .2, d1 - .03))*shadow);\n    // Dark edge.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, d1 - .02))*lnTrans);\n    // Main color and pattern.\n    col = mix(col, pCol*sh1, 1. - smoothstep(0., .01, d1));\n    \n    // Fake drop shadow for the bottom straight tube - cast by the top one.\n    if(rnd.z>.35) col = mix(col, vec3(0), (1. - smoothstep(0., .2, d5))*.5); \n    col = mix(col, vec3(0), (1. - smoothstep(0., .2, d2 - .03))*shadow);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, d2 - .02))*lnTrans);\n    col = mix(col, pCol*sh2, 1. - smoothstep(0., .01, d2));\n    \n    \n    // Extra lighting on the top cross section to give a slight bending impression...\n    // I doubt it's fooling anyone. :)\n    if(rnd.z>.35) col = mix(col, pCol*sh5, (1. - smoothstep(0., .01, d2))*.5);\n    \n    // Adding the joins - Pipes first. Joins afterward.\n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, d4 - .02))*shadow);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, d4 - .02))*lnTrans);\n    col = mix(col, jCol*sh4, 1. - smoothstep(0., .01, d4));\n        \n    col = mix(col, vec3(0), (1. - smoothstep(0., .1, d3 - .02))*shadow);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .01, d3 - .02))*lnTrans);\n    col = mix(col, jCol*sh3, 1. - smoothstep(0., .01, d3));\n \n    \n    \n    \n    \n\n    // Very fake light attenuation. Using the shading information to pretend there's \n    // some 3D depth, then calculating the distance to the light hovering above it.\n    float atten = length(lp - vec3(oP, -col.x));\n    col *= vec3(1.15)*1./(1. + atten*atten*.05);\n    \n    // Adding some grunge, just to break things up a little. Comment this section\n    // out, and the example looks too clean.\n    float fBm = noise3D(vec3(oP*32., 1. - col.x))*.66 + noise3D(vec3(oP*64., 2. - 2.*col.x))*.34;\n    col *= fBm*.5 + .75;\n    \n    \n   \n    /*\n    // Cheap postprocess hash. Interesting, and looks cool with other examples, but \n\t// possibly a little too much grunge, in this instance. Anyway, I've left it here \n\t// for anyone who's like to take a look.\n    float gr = dot(col, vec3(.299, .587, .114))*1.15;\n    oP = r2(3.14159/3.)*oP;\n    if(gr<.4) col *= clamp(sin((oP.x - oP.y)*6.283*96./sc)*1. + .95, 0., 1.)*.4 + .6;\n    oP = r2(3.14159/3.)*oP;\n    if(gr<.55) col *= clamp(sin((oP.x - oP.y)*6.283*96./sc)*1. + .95, 0., 1.)*.4 + .6;\n    oP = r2(3.14159/3.)*oP;\n    if(gr<.75) col *= clamp(sin((oP.x - oP.y)*6.283*96./sc)*1. + .95, 0., 1.)*.4 + .6;\n    */\n\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}