{
    "Shader": {
        "info": {
            "date": "1722199449",
            "description": "Uhhhhhhhhhhhhhh go away.",
            "flags": 0,
            "hasliked": 0,
            "id": "XcByWh",
            "likes": 1,
            "name": "SpaceSpheresRenderer",
            "published": 3,
            "tags": [
                "spheres",
                "diffuse",
                "stupid",
                "lame",
                "boring",
                "idk"
            ],
            "usePreview": 0,
            "username": "alexnompe",
            "viewed": 78
        },
        "renderpass": [
            {
                "code": "struct Sphere \n{\n    float radius;\n    vec3 position;\n    vec3 color;\n    vec3 atmosphereColor;\n    float atmosphereRadius;\n    bool emissive;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Sphere spheres[4] = Sphere[4](\n    Sphere(100.0,\n    vec3(iResolution.x/2.0,iResolution.y/2.0, 0.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(0.4,0.2,0.3),\n    110.0,\n    false),\n    Sphere(50.0,\n    vec3(iResolution.x/2.0-300.0*cos(iTime*1.5), iResolution.y/2.0+50.0*sin(iTime*1.5), 300.0*sin(iTime*1.5)),\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.1, 0.0, 0.2),\n    55.0,\n    false),\n    Sphere(20.0,\n    vec3(iResolution.x/2.0-300.0*cos(iTime*1.5)+90.0*sin(iTime*4.0), iResolution.y/2.0+50.0*sin(iTime*1.5)+10.0*cos(iTime*4.0), 300.0*sin(iTime*1.5)+90.0*cos(iTime*4.0)),\n    vec3(0.8, 0.8, 0.8),\n    vec3(0.0),\n    0.0,\n    false),\n    Sphere(200.0,\n    vec3(iResolution.x/2.0+1000.0*sin(iTime/6.0), iResolution.y/2.0+100.0*cos(iTime/6.0), 1000.0*cos(iTime/6.0)),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.0),\n    0.0,\n    true));\n    \n    Sphere renderOrder[spheres.length()] = spheres;\n    \n    vec3 col = vec3(0.0);\n    \n    float ratio = iResolution.x / iResolution.y;\n    \n    vec3 viewCoord = vec3(iMouse.xy,0.0);\n    \n    float maxCameraZ = 5000.0;\n    \n    int contributingColors = 0;\n    \n    for (int i = 0; i < renderOrder.length(); i++)\n    {\n        float z = pow(distance(renderOrder[i].position.xy, fragCoord), 3.0);\n        \n        float zDistanceMultiplier = (2000.0 - renderOrder[i].position.z) / 2000.0;\n        \n        if (z <= pow(renderOrder[i].radius*zDistanceMultiplier, 3.0))\n        {\n            contributingColors += 1;\n        }\n    }\n    \n    if (contributingColors >= 1)\n    {\n        for (int n = renderOrder.length()-1; n > 0; n--)\n        {\n            bool swapped = false;\n            \n            for (int i = 0; i < n; i++)\n            {\n                if (renderOrder[i].position.z < renderOrder[i + 1].position.z)\n                {\n                    swapped = true;\n                    Sphere comparingSave = renderOrder[i];\n                    renderOrder[i] = renderOrder[i + 1];\n                    renderOrder[i + 1] = comparingSave;\n                }\n            }\n            \n            if (!swapped)\n            {\n                break;\n            }\n        }\n    }\n    \n    vec3 lightPosition = vec3(spheres[3].position.xy,-spheres[3].position.z);\n    vec3 lightColor = spheres[3].color;\n    \n    for (int i = 0; i < renderOrder.length(); i++)\n    {\n        float z = pow(distance(renderOrder[i].position.xy, fragCoord), 3.0);\n        \n        float zDistanceMultiplier = (2000.0 - renderOrder[i].position.z) / 2000.0;\n        \n        //if (i == 3)\n        //{\n        //    renderOrder[i].color = vec3(1.0,0.0,0.0);\n        //    renderOrder[i].emissive = true;\n        //}\n        \n        if (renderOrder[i].position.z >= -maxCameraZ)\n        {\n            if (!renderOrder[i].emissive)\n            {\n                col += (renderOrder[i].atmosphereColor+lightColor/distance(lightPosition,renderOrder[i].position)/2000.0) / z * pow(renderOrder[i].atmosphereRadius*zDistanceMultiplier, 3.0);\n                if (z <= pow(renderOrder[i].radius*zDistanceMultiplier, 3.0))\n                {\n                    vec2 uv = vec2(ratio, 1.0) * (2.0 * (fragCoord.xy - (renderOrder[i].position.xy) + iResolution.xy/2.0) / iResolution.xy - 1.0) * 177.0 / (renderOrder[i].radius * zDistanceMultiplier);\n                    \n                    vec3 lightDirection = lightPosition-vec3(renderOrder[i].position.x,renderOrder[i].position.y,-renderOrder[i].position.z);\n                    \n                    float dist = 1.0-z/pow(renderOrder[i].radius*zDistanceMultiplier, 3.0);\n                    \n                    vec3 currentPointCoord = vec3(fragCoord, z);\n                    \n                    vec3 normal = vec3(uv, dist);\n                    \n                    float diffuse = max(0.0, dot(normal, normalize(lightDirection)));\n                    \n                    col = (renderOrder[i].color+lightColor/distance(lightPosition,renderOrder[i].position)/200.0)*diffuse;\n                    //col = normal;\n                    //contributingColors += 1;\n                }\n            }\n            else\n            {\n                col += renderOrder[i].color / z * pow(renderOrder[i].radius*zDistanceMultiplier, 3.0);\n                if (z <= pow(renderOrder[i].radius*zDistanceMultiplier, 3.0))\n                {\n                    col = renderOrder[i].color;\n                }\n            }\n        }\n    }\n    \n    //if (contributingColors == 1)\n    //{\n    //    col = vec3(1.0);\n    //}\n    //else if (contributingColors == 2)\n    //{\n    //    col = vec3(1.0, 1.0, 0.0);\n    //}\n    //else if (contributingColors == 3)\n    //{\n    //    col = vec3(1.0, 0.0, 0.0);\n    //}\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}