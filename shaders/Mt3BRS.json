{
    "Shader": {
        "info": {
            "date": "1539967031",
            "description": "when using the common tab for everything (audiovisual)\n, the common tab may as well be a canvas that uses the same namespaces as glslsandbox.com\nand have a context frame that ports glslsandbox into shadertoy",
            "flags": 1,
            "hasliked": 0,
            "id": "Mt3BRS",
            "likes": 6,
            "name": "sandbox common canvas",
            "published": 3,
            "tags": [
                "sandbox",
                "canvas",
                "frame",
                "context",
                "framing"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 786
        },
        "renderpass": [
            {
                "code": "//_start_ ShadertoyImage \n\n//all code is in the [Common tab]\nvoid mainImage(out vec4 o, in vec2 u\n){o=EnttryImage(iMouse.xyzw,iResolution.xyz,iTime)//entry point to [common tab]\n ;//o=vec4(.5+.5*cos(iTime+u.xyx+vec3(0,2,4)),1)//basic shader to debug basics\n ;}\n\n/*\n//memo: namespaces of glslsandbox:\nfloat time;\nvec3 mouse;\nvec2 resolution;\nvec4 colFrag;//this actually works to evade opengl-reserved-namespace gl_FragColor (within shadertoy.com\n#define gl_FragColor colFrag\n//#define gl_FragCoord uvFrag\n/**/\n\n//__end__ ShadertoyImage \n//__start_ boilerplate that ports glslSandbox to work within shadertoy Common tab\n/*\nvoid main2debug(void\n){vec3 c=vec3(1,0,1)\n ;c.xyz=gl_FragCoord.xyz/resolution.xyz//debug override\n ;c.z=length(gl_FragCoord.xy/resolution.xy-mouse.xy/resolution.xy)\n ;c.z=smoothstep(.01,-.01,c.z-.1)//CoC\n ;c.z=mix(1.-c.z,(gl_FragCoord.z/resolution.z),c.z)//xor-fold\n ;gl_FragColor = vec4(c, 1);}\n\n//rename main() to main2() to evade a reserved namespace\nvec4 EnttryImage(vec4 m,vec3 r,float t\n){//context and porting (glslsandbox within shadertoy) version 1 \n ;//-no mouse.z support\n ;//- no support for [backbuffer], [double buffering] of glslsandbox\n ;//u=u/iResolution.xy \n ;time=t\n ;mouse=vec3(m.xy,0)\n ;resolution=r.xyz\n ;main2()\n ;//main2debug()//to debug mouse and this canvas, all the way down the contexts.\n ;return colFrag;\n ;return vec4(0)\n ;}\n/**/\n//__end_ boilerplate that ports glslSandbox to work within shadertoy Common tab\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//__start__ Header Intro (abstract)\n\n//context and porting (glslsandbox within shadertoy)\n//core shader parents:\n//Available also on Shadertoy: parent: https://www.shadertoy.com/view/4ssGzS\n//just to go full-circle:      parent: http://glslsandbox.com/e#49795.0\n//\n//the core shader looks a lot smarter than it actually is, it is a bit of an imposter.\n//at least its not using SSAO\n\n//___end___ Header Intro (abstract)\n//__start__ glslSandboxCanvas (within shadertoy common tab)\n\n/*\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n/**/\n//we erase the above header of glslsandbox, as its already included in the shadertoy boilerplate\n//but with different labels/domains for the almost same uniforms:\n//glslsandbox within opengl context:\n//gl_FragCoord of shadertoy   is context-sensetive (distinguishes VR and 2d screens)\n//gl_FragCoord of shadertoy   is a vec2, wrapped in a bifocal vec2 uvMap fragCoord in 3d space; [void mainVR(..., fragCoord)]\n//gl_FragCoord of shadertoy   is a vec2, wrapped in a 3d uvMap fragCoord; [void mainImage(out vec4 fragColor,in vec2 fragCoord)]\n//gl_FragCoord of glslsandbox is a vec3, .z  intends to scroll through the .z-domain with mousewheel, rarely used\n//    iMouse   of shadertoy   is a vec4  .yz are the .xy locale where you started holding down left mouse\n//     mouse   of glslsandbox is a vec3  the context of .z is LIKE a zooming mousewheel, but rarely used.\n//iResolution  of shadertoy   is a vec3 .z was intented for [projection mapping], but is now mostly a buffer for tiny shaders.\n// resolution  of glslsandbox is a vec2\n//\n//porting works, because; glslsandboxUniformDomainCount \n//                        < shadertoyUniformDomainCount\n//but glslsandbox may imply/expect a vec2 where shadertoy provides a ved3...\n//but these errors are simple, just fill the extra domains with 0.\n\n//mainVR() input of shadertoy asserts;\n//- 1 unit==1 meter scaling\n//- average distance between (focal points of) 2 eyes (of a bifocal dual-frustrum) is .063 (meters)\n//it is easy to define a mainVR() that contains mainImage()\n// as a 3d hologram within VR (and not a flat screen in 3d space)\n//, half a dozen shadertoy shaders have done that.\n//, but the FoW of mainVR() is still a bit low, or easily nauseating\n//,see how googleEarthVR solves periperal vission nausea.\n\n//(by glslsandbox) reserved namespaces are at least re-defined as global namespace\n//and substituted by non-reserved namespaces, for a quick evasion for even more porting\n//the idea here is to \n//put [[[glslsandbox code, inside of] shadertoy code, inside of] the code of other boilerplates]\n//global vars are bad style; incompatible (compiling failure) within some opengl versions/contexts.\nfloat time;\nvec3 mouse;\nvec3 resolution;\nvec4 colFrag;//this actually works to evade opengl-reserved-namespace gl_FragColor (within shadertoy.com\n#define gl_FragColor colFrag\n//#define gl_FragCoord uvFrag\n\n//we rename the [main()] function of glslsandbox to [main2()]\n//we copy that into the copmmon-tab of shadertoy.com\n//we put the entryImage() function as a porting-boilerplate below it.\n//and the shadertoy image-tab content reduces to\n/*\nvoid mainImage(out vec4 o, in vec2 u\n){o=EnttryImage(iMouse.xyzw,iResolution.xyz,iTime)\n ;//o=vec4(0.5 + 0.5*cos(iTime+u.xyx+vec3(0,2,4)),1)\n ;}\n\n*/\n\n/*\n\n//Reproducing the famous Cornell Box through Raymarching, fake soft-shadows\n//, fake indirect lighting, ambient occlusion and antialiasing.\n//this is not even half decent BRDF performance\n//, because it no (double) buffer for incremental averaging.\n//\n//this is more about the above mentioned [[[canvas] in a canvas] in a canvas] porting idea.\n//but when you think #nocontext \"canvas\" for shading, thats usually a [Cornell Box]\n//and this shader is a simple version of a [Cornell Box].\n//\n// The Cornell Box - @h3r3 - http://www.postronic.org/h3/pid69.html\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Reproducing the famous Cornell Box through Raymarching, fake soft-shadows,\n// fake indirect lighting, ambiend occlusion and antialiasing.\n// Reference data: http://www.graphics.cornell.edu/online/box/\n// Reference image: http://www.graphics.cornell.edu/online/box/box.jpg\n/**/\n\n// Set ANTIALIAS_ALWAYS to false if the animation is too slow\n#define ANTIALIAS_ALWAYS false\n#define ANTIALIAS_SAMPLES 1\n#define ANIMATE_CAMERA\n\n#define PI acos(-1.)\n#define EXPOSURE 34.\n#define GAMMA 2.2\n#define SOFT_SHADOWS_FACTOR 4.\n#define MAX_RAYMARCH_ITER 256\n#define MAX_RAYMARCH_ITER_SHADOWS 128\n#define MIN_RAYMARCH_DELTA 0.0015\n#define GRADIENT_DELTA 0.0002\n#define OBJ_FLOOR\t\t1.\n#define OBJ_CEILING\t\t2.\n#define OBJ_BACKWALL\t3.\n#define OBJ_LEFTWALL\t4.\n#define OBJ_RIGHTWALL\t5.\n#define OBJ_LIGHT\t\t6.\n#define OBJ_SHORTBLOCK\t7.\n#define OBJ_TALLBLOCK\t8.\n\n//RGB wavelengths: 650nm, 510nm, 475nm\n const vec3 lightColor       =vec3(16.86,8.76,3.2)+vec3(0,2,.5)//color-temperature modifier\n;const vec3 lightDiffuseColor=vec3(.78)\n;const vec3 leftWallColor    =vec3(.611,.0555,.062)\n;const vec3 rightWallColor   =vec3(.117, .4125, .115)\n;const vec3 whiteWallColor   =vec3(.7295, .7355, .729)\n;const vec3 cameraTarget     =vec3(556,548.8,559.2)*.5\n;\n\nfloat sdBox(vec3 p, vec3 b\n){vec3 d=abs(p)-b//box (sharp corners, upper bound)\n ;return min(max(d.x,max(d.y, d.z)),0.)+length(max(d,0.))//box to boxRounded\n ;}\n\nvec3 rotateX(vec3 p, float a){float c=cos(a);float s=sin(a);return vec3(  p.x      ,c*p.y-s*p.z, s*p.y+c*p.z);}\nvec3 rotateY(vec3 p, float a){float c=cos(a);float s=sin(a);return vec3(c*p.x+s*p.z,  p.y      ,-s*p.x+c*p.z);}\nvec3 rotateZ(vec3 p, float a){float c=cos(a);float s=sin(a);return vec3(c*p.x-s*p.y,s*p.x+c*p.y,         p.z);}\n\nvec2 mapBlocks(vec3 p, vec3 ray_dir//use ray_dir for some optimizations\n){vec2 res=vec2(OBJ_SHORTBLOCK, sdBox(rotateY(p + (vec3(mouse.x *2.0-1.0, -mouse.y, 0.0)) * 310.0 + vec3(-186, -82.5, -169.5), 0.29718), vec3(83.66749, 83.522452, 82.5)));\n ;vec2 obj1=vec2(OBJ_TALLBLOCK, sdBox(rotateY(p +vec3(-368.5,-165,-351.5),-.30072115), vec3(87.02012, 165, 83.6675)));\n ;if (obj1.y < res.y) res = obj1\n ;return res;}\n\nvec2 map(vec3 p, vec3 ray_dir//use ray_dir for some optimizations\n){vec2 res = vec2(OBJ_FLOOR, p.y)\n ;vec2 obj1 = vec2(OBJ_CEILING, 548.8 - p.y);if (obj1.y < res.y) res = obj1\n ;vec2 obj2 = vec2(OBJ_BACKWALL, 559.2 - p.z);if (obj2.y < res.y) res = obj2\n ;vec2 obj3 = vec2(OBJ_LEFTWALL, 556. - p.x);if (obj3.y < res.y) res = obj3\n ;vec2 obj4 = vec2(OBJ_RIGHTWALL      , p.x);if (obj4.y < res.y) res = obj4\n ;vec2 obj5 = vec2(OBJ_LIGHT, sdBox(p + vec3(-278, -548.8, -292), vec3(65, 0.05, 65)))\n ;if (obj5.y < res.y) res = obj5;vec2 obj6 = mapBlocks(p, ray_dir)\n ;if (obj6.y < res.y) res = obj6;return res;}\n\n\nvec2 map(vec3 p){return map(p,vec3(0));}\n\nvec3 gradientNormal(vec3 p//6tap 3d derivative. \n){vec2 e=vec2(0,GRADIENT_DELTA)\n ;return normalize(vec3\n (map(p+e.yxx).y-map(p-e.yxx).y\n ,map(p+e.xyx).y-map(p-e.xyx).y\n ,map(p+e.xxy).y-map(p-e.xxy).y));}\n\n\nfloat hash1(vec2 n\n){return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat raymarch(vec3 ray_start, vec3 ray_dir, out float dist, out vec3 p, out int iterations\n){dist = 0.0 + 110.1*hash1(gl_FragCoord.xy + time)\n ;float minStep = .01\n ;vec2 mapRes\n ;for (int i = 1; i <= MAX_RAYMARCH_ITER; i++\n ){p = ray_start + ray_dir * dist\n  ;mapRes = map(p, ray_dir)\n  ;if (mapRes.y < MIN_RAYMARCH_DELTA\n  ){iterations = i\n   ;return mapRes.x\n   ;}\n  ;dist += max(mapRes.y, minStep)\n  ;}\n ;return -1.;}\n\nbool raymarch_to_light(vec3 ray_start, vec3 ray_dir, float maxDist, float maxY, out float dist, out vec3 p, out int iterations, out float light_intensity\n){dist = 0.0 + 10.1*hash1(gl_FragCoord.xy + time)\n ;float minStep = 0.01\n ;light_intensity = 1.\n ;float mapDist\n ;for (int i = 1; i <= MAX_RAYMARCH_ITER_SHADOWS; i++\n ){p = ray_start + ray_dir * dist\n  ;mapDist = mapBlocks(p, ray_dir).y\n  ;if (mapDist < MIN_RAYMARCH_DELTA\n  ){iterations = i\n   ;return true;}\n  ;light_intensity = min(light_intensity, SOFT_SHADOWS_FACTOR * mapDist / dist)\n  ;dist += max(mapDist, minStep)\n  ;if(dist>=maxDist||p.y>maxY)break\n ;}\n ;return false;}\n\nvec3 interpolateNormals(vec3 a, vec3 b, float c\n){;return normalize(mix(a,b,vec3(smoothstep(0.,1.,c))));}\n\nfloat ambientOcclusion(vec3 p, vec3 n\n){float step = 8.\n ;float ao = 0.\n ;float dist\n ;for (int i = 1; i <= 3; i++\n ){dist = step * float(i)\n  ;ao += max(0., (dist - map(p + n * dist).x) / dist)\n  ;}\n ;return 1.-ao * 0.1;}\n\nvec3 render(vec3 ray_start, vec3 ray_dir\n){float dist; vec3 p; int iterations\n ;float objectID = raymarch(ray_start, ray_dir, dist, p, iterations)\n ;vec3 color = vec3(0)\n ;if(p.z >= 0.\n ){if (objectID == OBJ_FLOOR) color = whiteWallColor\n  ;else if(objectID==OBJ_CEILING   )color=whiteWallColor\n  ;else if(objectID==OBJ_BACKWALL  )color=whiteWallColor\n  ;else if(objectID==OBJ_LEFTWALL  )color=leftWallColor\n  ;else if(objectID==OBJ_RIGHTWALL )color=rightWallColor\n  ;else if(objectID==OBJ_LIGHT     )color=lightDiffuseColor\n  ;else if(objectID==OBJ_SHORTBLOCK)color=whiteWallColor\n  ;else if(objectID==OBJ_TALLBLOCK )color=whiteWallColor\n  ;if (objectID == OBJ_LIGHT)color *= lightColor\n  ;else\n   {float lightSize = 25.\n   ;vec3 lightPos = vec3(278, 548.8 -50., 292 - 50)\n   ;if (objectID == OBJ_CEILING)  lightPos.y -= 550.\n   ;lightPos.x = max(lightPos.x - lightSize, min(lightPos.x + lightSize, p.x))\n   ;lightPos.y = max(lightPos.y - lightSize, min(lightPos.y + lightSize, p.y))\n   ;vec3 n = gradientNormal(p)\n   ;vec3 l = normalize(lightPos - p)\n   ;float lightDistance = length(lightPos - p)\n   ;float atten = ((1. / lightDistance) * .5) + ((1. / (lightDistance * lightDistance)) * .5)\n   ;vec3 lightPos_shadows = lightPos + vec3(0, 140, -50)\n   ;vec3 l_shadows = normalize(lightPos_shadows - p)\n   ;float dist; vec3 op; int iterations; float l_intensity\n   ;bool res = raymarch_to_light(p + n * .11, l_shadows, lightDistance, 400., dist, op, iterations, l_intensity)\n   ;if (res && objectID != OBJ_CEILING) l_intensity = 0.\n   ;l_intensity = max(l_intensity,.25)\n   ;vec3 c1 = color * max(0., dot(n, l)) * lightColor * l_intensity * atten\n   ;vec3 c2_lightColor = lightColor * leftWallColor * .08\n   ;float c2_lightDistance = p.x\n   ;float c2_atten = 1. / c2_lightDistance\n   ;vec3 c2_lightDir0 = vec3(-1,0,0)\n   ;vec3 c2_lightDir1 = normalize(vec3(-300., 548.8/2.,559.2/2.) - p)\n   ;float c2_perc = min(p.x * .01, 1.)\n   ;vec3 c2_lightDirection = interpolateNormals(c2_lightDir0, c2_lightDir1, c2_perc)\n   ;vec3 c2 = color * max(0., dot(n, c2_lightDirection)) * c2_lightColor * c2_atten\n   ;vec3 c3_lightColor = lightColor * leftWallColor * .08\n   ;float c3_lightDistance = 555. - p.x\n   ;float c3_atten = 1. / c3_lightDistance\n   ;vec3 c3_lightDir0 = vec3(1,0,0)\n   ;vec3 c3_lightDir1 = normalize(vec3(556. + 300., 548.8/2.,559.2/2.) - p)\n   ;float c3_perc = min((556. - p.x) * .01, 1.)\n   ;vec3 c3_lightDirection = interpolateNormals(c3_lightDir0, c3_lightDir1, c3_perc)\n   ;vec3 c3 = color * max(0., dot(n, c3_lightDirection)) * c3_lightColor * c3_atten\n   ;float ao = ambientOcclusion(p, n)\n   ;color = color * .0006 + c1\n   ;color+=c2+c3 // Fake indirect lighting\n   ;color *= ao\n ;}}return color;}\n\nvec3 rotateCamera(vec3 ray_start, vec3 ray_dir//should be quaternion rotation, but is not!\n){ray_dir.x = -ray_dir.x // Flip the x coordinate to match the scene data\n ;vec3 target = normalize(cameraTarget - ray_start)\n ;float angY = atan(target.z, target.x)\n ;ray_dir = rotateY(ray_dir, PI/2. - angY)\n ;float angX = atan(target.y, target.z)\n ;ray_dir = rotateX(ray_dir, - angX)\n #ifdef ANIMATE_CAMERA\n ;float angZ = smoothstep(0., 1., (time - 5.) * .1) * sin(time * 2.1 + .77) * .05\n ;ray_dir = rotateZ(ray_dir, angZ)\n #endif\n ;return ray_dir;}\n\nvec3 moveCamera(vec3 ray_start\n){ray_start += vec3(278, 273, -800)\n #ifdef ANIMATE_CAMERA\n ;vec3 ray_start_a = ray_start\n +vec3(cos(time * 0.8) * 180., cos(time * 0.9) * 180., (cos(time * .3) + 1.) * 390.)\n ;return mix(ray_start, ray_start_a, smoothstep(0., 1., (time - 5.) * .1));}\n #else\n ;return ray_start ;}\n #endif\n\n\n\nvoid main2(void\n){vec3 ray_start = vec3(0, 0, -1.4)\n ;vec3 color = vec3(0)\n ;if (ANTIALIAS_ALWAYS || time < 5.\n ){float d_ang = 2.*PI / float(ANTIALIAS_SAMPLES)\n  ;float ang = d_ang * .333\n  ;float r = .4\n  ;for (int i = 0; i < ANTIALIAS_SAMPLES; i++//AntiAlias multitap\n  ){vec2 position = vec2((gl_FragCoord.x + cos(ang)*r - resolution.x *.5) / resolution.y, (gl_FragCoord.y + sin(ang)*r - resolution.y *.5) / resolution.y)\n   ;vec3 ray_s = moveCamera(ray_start)\n   ;vec3 ray_dir = rotateCamera(ray_s,normalize(vec3(position, 0) - ray_start))\n   ;color += render(ray_s, ray_dir)\n   ;ang += d_ang\n  ;}\n  ;color /= float(ANTIALIAS_SAMPLES)\n ;}else// NO ANTIALIAS\n  {vec2 position = vec2((gl_FragCoord.x - resolution.x *.5) / resolution.y, (gl_FragCoord.y - resolution.y *.5) / resolution.y)\n  ;vec3 ray_s = moveCamera(ray_start)\n  ;vec3 ray_dir = rotateCamera(ray_s, normalize(vec3(position, 0) - ray_start))\n  ;color += render(ray_s, ray_dir)\n ;}\n ;color *= EXPOSURE\n ;color = pow(color,vec3(1./GAMMA))\n ;gl_FragColor = vec4(color, 1)\n ;}\n\n/*\n//memo: namespaces of glslsandbox:\nfloat time;\nvec3 mouse;\nvec2 resolution;\nvec4 colFrag;//this actually works to evade opengl-reserved-namespace gl_FragColor (within shadertoy.com\n#define gl_FragColor colFrag\n//#define gl_FragCoord uvFrag\n*/\n\n//___end___ glslSandboxCanvas (within shadertoy common tab)\n//__start__ boilerplate that ports glslSandbox to work within shadertoy Common tab\n\nvoid main2debug(void\n){vec3 c=vec3(1,0,1)\n ;c.xyz=gl_FragCoord.xyz/resolution.xyz//debug override\n ;c.z=length(gl_FragCoord.xy/resolution.xy-mouse.xy/resolution.xy)\n ;c.z=smoothstep(.01,-.01,c.z-.1)//CoC\n ;c.z=mix(1.-c.z,(gl_FragCoord.z/resolution.z),c.z)//xor-fold\n ;gl_FragColor = vec4(c, 1);}\n\n//rename main() to main2() to evade a reserved namespace\nvec4 EnttryImage(vec4 m,vec3 r,float t\n){//context and porting (glslsandbox within shadertoy) version 1 \n ;//-no mouse.z support\n ;//- no support for [backbuffer], [double buffering] of glslsandbox\n ;//u=u/iResolution.xy \n ;time=t\n ;mouse=vec3(m.xy,0)\n ;resolution=r.xyz\n ;main2()\n ;//main2debug()//to debug mouse and this canvas, all the way down the contexts.\n ;return colFrag;\n ;return vec4(0)\n ;}\n\n//___end___ boilerplate that ports glslSandbox to work within shadertoy Common tab",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}