{
    "Shader": {
        "info": {
            "date": "1722191729",
            "description": "i have created a small website https://shaderclock.deno.dev/ where i want to have multiple shader clocks , and one gets loaded randomly \nif you want to participate make sure to add the tag 'shaderclockdenodev'",
            "flags": 0,
            "hasliked": 0,
            "id": "MfjcWz",
            "likes": 3,
            "name": "daily shader clock 4",
            "published": 3,
            "tags": [
                "daily",
                "shaderclockdenodev"
            ],
            "usePreview": 0,
            "username": "jonasfrey",
            "viewed": 142
        },
        "renderpass": [
            {
                "code": "// Fork of \"daily shader clock 3 \" by jonasfrey. https://shadertoy.com/view/Xc2yzD\n// 2024-07-28 17:27:46\n\n\nfloat f_n_sd_ring( in vec2 p, float n_ang_nor, in float r, in float th )\n{\n    float n_tau = 6.2831;\n    float n_radians = ((n_tau)*(n_ang_nor-.5)*.5);\n    float n2 = n_tau-n_tau*(n_ang_nor/2.)+n_tau/2.;\n    p = p*mat2(cos(n2), -sin(n2), sin(n2), cos(n2));\n    vec2 n = vec2(sin(n_radians), cos(n_radians)); \n    p.x = abs(p.x);\n    \n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n\n    return max( abs(length(p)-r)-th*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-th*0.5)))*sign(p.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trn = (fragCoord.xy-iResolution.xy*.5)/min(iResolution.y, iResolution.x);\n    o_trn*=2.;\n    float n_tau = 6.2831;\n    \n    \n    float n_sec = iDate.w;\n    float n_sec_mod = mod(n_sec , 60.);\n    float n_sec_mod_nor = n_sec_mod / 60.;\n    float n_sec_mod_nor_snp = floor(n_sec_mod) / 60.;\n    float n_min_mod = floor(mod(n_sec, 60.*60.));\n    float n_min_mod_nor = n_min_mod / (60.*60.);\n    float n_min_mod_nor_snp = (floor(n_min_mod_nor*12.))/12.;\n    float n_hou_mod = floor(mod(n_sec, 60.*60.*12.));\n    float n_hou_mod_nor = n_hou_mod / (60.*60.*12.);\n    float n_hou_mod_nor_snp = (floor(n_hou_mod_nor*12.))/12.;\n    \n    float n_aa = (1./(iResolution.x+iResolution.y)/2.)*8.;\n    float n_its = 3.;\n    float n_it_nor_one = 1./n_its;\n    vec4 o_col = vec4(0.);\n    float n_max = 0.;\n    for(float n_it_nor = 0.; n_it_nor < 1.; n_it_nor+=n_it_nor_one){\n\n        float[] anmt = float[] (\n            n_hou_mod_nor_snp, \n            n_min_mod_nor_snp, \n            n_sec_mod_nor_snp\n        );\n        float[] and = float[] (\n            12., \n            12., \n            60.\n        );\n        \n        float nd = and[int((n_it_nor)*3.)];\n        nd = nd/2.;\n        float nmt = anmt[int((n_it_nor)*3.)];\n        \n        vec2 o_p = vec2(\n            (n_it_nor*3.)-1.,\n            0.\n        )-o_trn;\n        float n_ang_nor1 = fract(.5+atan(o_p.x, o_p.y)/n_tau);\n        float n_radius = .3+sin(n_ang_nor1*nd*n_tau)*.05;\n        vec2 op1 = o_p+ vec2(\n            sin(n_ang_nor1*n_tau), \n            cos(n_ang_nor1*n_tau)\n        )*n_radius;\n        vec2 op2 = o_p+ vec2(\n            sin(0.*n_tau), \n            cos(0.*n_tau)\n        )*n_radius;\n        vec2 op3 = o_p+ vec2(\n            sin(nmt*n_tau), \n            cos(nmt*n_tau)\n        )*n_radius;\n        float n = length(op1);\n        if(nmt < n_ang_nor1){\n            n = min(length(op2), length(op3));\n        }\n        n = 1.-pow(n, 1./3.);\n        n_max = max(n, n_max);\n        o_col += vec4(n);\n        \n    }\n\n    fragColor = vec4(n_max);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}