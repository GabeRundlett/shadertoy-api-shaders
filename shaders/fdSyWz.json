{
    "Shader": {
        "info": {
            "date": "1643302296",
            "description": "first shader here, tips welcome",
            "flags": 0,
            "hasliked": 0,
            "id": "fdSyWz",
            "likes": 7,
            "name": "Distance 2D from 3 points arc",
            "published": 3,
            "tags": [
                "geometry"
            ],
            "usePreview": 0,
            "username": "dizziCoding",
            "viewed": 299
        },
        "renderpass": [
            {
                "code": "// Signed Distance to any 2D Arc\n// Color result from iq distance 2D\n// Geometry tips and formula from https://jeux.developpez.com/tutoriels/theorie-des-collisions/formes-complexes/#LI\n\n#define e 0.0004\n\nvec2 perpendicular (in vec2 v) {\n  return vec2 (-v.y, v.x);\n}\nfloat distSquared(in vec2 vec)\n{\n    return dot(vec, vec);\n}\nbool intersectLines(in vec2 A, in vec2 B, in vec2 O, in vec2 P, inout vec2 I)\n{\n\tvec2 AB = B - A;\n    vec2 OP = P - O;\n\n    float denom = AB.x*OP.y-AB.y*OP.x;\n\n    if(denom == 0.0)\n        return false;\n\n    float k = -(A.x*OP.y-O.x*OP.y-OP.x*A.y+OP.x*O.y)/ denom;\n    I = A + AB*k;\n\treturn true;\n}\n\nfloat sdArc(vec2 A, vec2 B, vec2 C, vec2 U) {\n    vec2 AC = C - A;\n    vec2 AB = B - A;\n    //det that tell wich side is B vs AC\n    float det = (AC.x * AB.y - AC.y * AB.x);\n    if(abs(det) >= e)\n    {\n        //find arc center D\n        float rayon;\n        vec2 D;\n        vec2 centerCordeAC = A + (AC / 2.0);\n        vec2 centerCordeAB = A + (AB / 2.0);\n        vec2 normalAC = perpendicular(AC);\n\n        if(intersectLines(centerCordeAC, centerCordeAC - normalAC, centerCordeAB, centerCordeAB - perpendicular(AB), D))\n        {\n            //find intersection (UD] vs circle D : E\n            vec2 E = D + normalize(U - D) * length(D-A);\n\n            //if E on arc, closest point = E, else closest point = A or C\n            vec2 AE = E - A;\n            float det2 = AC.x * AE.y - AC.y * AE.x;\n            if(sign(det2) == sign(det))// || det2 == 0.0)\n            {\n                //E is on arc\n                return length(E-U) * (dot(D-E,U-E) < 0.0 ? -1.1 : 1.1) * (dot(centerCordeAC - E,normalAC) > 0.0 ? -1.1 : 1.1);  \n            }else\n            {\n                //find the point of the same side of U vs D,D+normalAB\n                vec2 DU = U - D;\n                vec2 DA = A - D;\n                det2 = normalAC.x * DU.y - normalAC.y * DU.x;\n                float detA = normalAC.x * DA.y - normalAC.y * DA.x;\n                if(sign(det2) == sign(detA) || det2 == 0.0)\n                {\n                    //closest is A\n                    return length(U - A) * (dot(-DA,U-A) < 0.0 ? 1.1 : -1.1) * (dot(centerCordeAC - E,normalAC) > 0.0 ? -1.1 : 1.1);\n                }else\n                {\n                    //closest is C\n                    return length(U - C)* (dot(D-C,U-C) < 0.0 ? 1.1 : -1.1) * (dot(centerCordeAC - E,normalAC) > 0.0 ? -1.1 : 1.1);\n                }\n            }\n        }\n\n    }else\n    {\n        //A B C aligned\n        vec2 AU = U - A;\n        vec2 CU = U - C;\n        float pscal1 = dot(AC,AU);\n        float pscal2 = dot(CU,-AC);\n        if(dot(AB,AC) >=0.0 && dot(-AC,B-C) >=0.0)\n        {\n            //find closest pt to seg AC\n            if(pscal1 >= 0.0 && pscal2 >= 0.0)\n            {\n                return length(A + (AC * (pscal1 / distSquared(AC))) - U) * (dot(A+AC/2.0 - U,perpendicular(C-A)) > 0.0 ? 1.1 : -1.1);\n\n            }\n            else if(pscal1 < 0.0)\n            {\n                return length(AU)* (dot(A+AC/2.0 - U,perpendicular(C-A)) > 0.0 ? 1.1 : -1.1);\n            }\n            else\n            {\n                return length(CU)* (dot(A+AC/2.0 - U,perpendicular(C-A)) > 0.0 ? 1.1 : -1.1);\n            }\n        }else\n        {\n            //find closest pt to [A,A - CA) , [C,C-AC)\n            vec2 normalAC = perpendicular(AC);\n            vec2 D = A + AC / 2.0;\n            //find the point of the same side of U vs D+normalAB\n            vec2 DU = U - D;\n            vec2 DA = A - D;\n            float detU = normalAC.x * DU.y - normalAC.y * DU.x;\n            float detA = normalAC.x * DA.y - normalAC.y * DA.x;\n            if(sign(detU) == sign(detA) || detU == 0.0)\n            {\n                if(pscal1 >= 0.0)\n                {\n                    //closest is A\n                    return length(AU)* (dot(-DU,normalAC) > 0.0 ? -1.1 : 1.1);\n                }else\n                {\n                    //closest is on [A,A - CA)\n                    vec2 CA = A - C;\n                    return length(A - (CA * (pscal1 / distSquared(CA))) - U)* (dot(-DU,normalAC) > 0.0 ? -1.1 : 1.1);\n                }\n            }else\n            {\n                if(pscal2 >= 0.0)\n                {\n                    //closest is C\n                    return length(CU)* (dot(-DU,normalAC) > 0.0 ? -1.1 : 1.1);\n                }else{\n                    //closest is on [C,C-AC)\n                    return length(C - (AC * (pscal2 / distSquared(AC))) - U)* (dot(-DU,normalAC) > 0.0 ? -1.1 : 1.1);\n                }\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 A = vec2(-0.5, 0.1+cos(iTime*0.5)*0.75);\n    vec2 B = vec2(-0.5+cos(iTime*0.25)*0.7, 0.1+sin(iTime*0.25)*0.7);\n    vec2 C = vec2(0.7 + sin(iTime)*1.0, -0.1+cos(iTime)*0.3);\n    \n    //edge case test\n    //vec2 A = vec2(1.0, 0.0);\n    //vec2 B = vec2(cos(iTime)*1.5, 0.0);\n    //vec2 C = vec2(-1.0,0.0);\n    \n    float d = sdArc(A,B,C, p);\n    float dots = min(min(length(A-p), length(B-p)), length(C-p));\n    d = mix(0.0, d, smoothstep(0.025, 0.035, dots));\n        \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-1.75*abs(d));\n\tcol *= 0.75 + 0.3*cos(125.0*d);\n\tcol = mix( col, vec3(0.6,0.9,1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}