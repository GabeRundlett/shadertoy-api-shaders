{
    "Shader": {
        "info": {
            "date": "1564489944",
            "description": "Sausage mecanic",
            "flags": 32,
            "hasliked": 0,
            "id": "tlsSD2",
            "likes": 63,
            "name": "Wild Sausages",
            "published": 3,
            "tags": [
                "collision",
                "dynamic",
                "sausage",
                "mecanic"
            ],
            "usePreview": 0,
            "username": "iapafoto",
            "viewed": 995
        },
        "renderpass": [
            {
                "code": "//-----------------------------------------------------\n// Created by sebastien durand - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n//\n// Simulate sausages.\n//\n//-----------------------------------------------------\n// [dr2]            More Balls               - https://www.shadertoy.com/view/MsfyRn\n// [iq]             Capsule - soft shadow    - https://www.shadertoy.com/view/MlGczG\n// [iq]             Balls and shadows        - https://www.shadertoy.com/view/lsSSWV\n// [Shane]          Desert Canyon            - https://www.shadertoy.com/view/Xs33Df\n//-----------------------------------------------------\n\n    \n//#define WITH_SHADOWS // only for sphere mode for the moment \n#define WITH_AO\n\n#define SAUSAGES // else display element spheres\n\n\n// -----------------------------------------------------------\n\nconst vec3 light = normalize( vec3(-.4, .3, -1.5) );\nconst float dstFar = 999.;\n\nvec3 vnBall;\nint idBall;\n\n\n// +-------------------------------------+\n// |         Geometric tools             |\n// +-------------------------------------+\n\n// Distance to point\nfloat dista(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\nbool cube(vec3 ro, vec3 rd, vec3 sz) {\n\tvec3 m = 1./rd, k = abs(m)*sz,\n         a = -m*ro-k*.5, b = a+k;\n    float tn = max(max(a.x,a.y),a.z);\n\treturn tn>0. && tn<min(min(b.x,b.y),b.z);\n}\n\n\n#ifdef SAUSAGES\n\n//-------------------------------------------------------------------------------------------\n// Capsules related functions\n//-------------------------------------------------------------------------------------------\n// [iq] Capsule - soft shadow - https://www.shadertoy.com/view/MlGczG\n//-------------------------------------------------------------------------------------------\n\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k ) {\n    vec3 ba =  b - a, oa = ro - a;\n    // closest distance between ray and segment\n\tfloat oad  = dot( oa, rd ), dba  = dot( rd, ba ),\n\t\t  baba = dot( ba, ba ), oaba = dot( oa, ba );\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\tth.x = max(   th.x, .0001 );\n\tth.y = clamp( th.y, .0, 1. );\n\tvec3  p =  a + ba*th.y, q = ro + rd*th.x;\n    float d = length( p-q )-r;\n    // fake shadow\n    float s = clamp( k*d/th.x, 0., 1. );\n    return s*s*(3.-2.*s);\n}\n\n// intersect capsule\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r ) {\n    vec3  ba = pb - pa, oa = ro - pa;\n    float baba = dot(ba,ba), bard = dot(ba,rd),\n    \t  baoa = dot(ba,oa), rdoa = dot(rd,oa), oaoa = dot(oa,oa);\n    float a = baba - bard*bard,\n          b = baba*rdoa - baoa*bard,\n          c = baba*oaoa - baoa*baoa - r*r*baba,\n          h = b*b - a*c;\n    if( h>=0.) {\n        float t = (-b-sqrt(h))/a,\n              y = baoa + t*bard;\n        // body\n        if (y>0. && y<baba) return t;\n        // caps\n        vec3 oc = y<=0. ? oa : ro - pb;\n        b = dot(rd,oc);\n        h = b*b - dot(oc,oc) + r*r;\n        if (h>0.) return -b - sqrt(h);\n    }\n    return -1.;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r ) {\n    vec3  ba = b - a, pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return (pa - h*ba)/r;\n}\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r ) {\n    vec3 ba = b - a, pa = p - a,\n         d = pa - ba * clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    float l = length(d), o = 1. - max(0.,dot(-d,n))*r*r/(l*l*l);\n    return sqrt(o*o*o);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd ) {\n\tfloat res = .0;\n    for (int n = 0; n<NB_ELT; n+=CHAIN) {\n        vec4 p = Load(iChannel0, POSITION, n+(CHAIN/2));\n        if (length(ro-p.xyz)<2.+p.w*float(CHAIN)) {\n            vec4 pmem =Load(iChannel0, POSITION, n);\n            for (int i =1; i<CHAIN; i++) {\n                p = Load(iChannel0, POSITION, n+i);\n                // if (length(ro-p.xyz)<2.) { \n                res = max( res, capShadow(ro,rd, p.xyz, pmem.xyz, p.w, 1.5) );\n                // }\n                pmem = p;\n            }\n        }         \n        \n    }\n    return 1.;//-res;\t\t\t\t\t  \n}\n\nfloat occlusion( in vec3 pos, in vec3 nor ) {\n\tfloat res = 1.;\n    for (int n = 0; n<NB_ELT; n+=CHAIN) {\n        vec4 p = Load(iChannel0, POSITION, n+(CHAIN/2));\n        if (length(pos-p.xyz)<p.w*float(CHAIN)+1.) {\n            vec4 pmem = Load(iChannel0, POSITION, n);\n            for (int i =1; i<CHAIN; i++) {\n                p = Load(iChannel0, POSITION, n+i);\n                res *= capOcclusion(pos, nor, p.xyz, pmem.xyz, p.w); \n                pmem = p;\n            }\n        }\n    }\n    return res;\t\t\t\t\t  \n}\n\nfloat BallHit(vec3 ro, vec3 rd) {\n    vec4 p;\n    float d, dMin = dstFar;\n    for (int n =0; n<NB_ELT; n+=CHAIN) {\n        p = Load(iChannel0, POSITION, n+(CHAIN/2));\n        if (length(ro-p.xyz)-p.w*float(CHAIN)<dMin && dista(ro,rd,p.xyz)<p.w*float(CHAIN)) {\n            vec4 pmem = Load(iChannel0, POSITION, n);\n            for (int i =1; i<CHAIN; i++) {\n                p = Load(iChannel0, POSITION, n+i);\n                d = capIntersect(ro, rd, pmem.xyz, p.xyz, p.w);\n                if (d > 0. && d < dMin) {\n                    dMin = d;\n                    vnBall = capNormal(ro+rd*d,pmem.xyz, p.xyz, p.w);\n                    idBall = n;\n                }\n                pmem = p;\n            }\n        }\n    }\n    return dMin;\n}\n\n\n#else  \n\n//-------------------------------------------------------------------------------------------\n// Spheres related functions\n//-------------------------------------------------------------------------------------------\n// [iq] Balls and shadows - https://www.shadertoy.com/view/lsSSWV\n//-------------------------------------------------------------------------------------------\n\nfloat sphShadow(in vec3 ro, in vec3 rd, in vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd ),\n          c = dot( oc, oc ) - sph.w*sph.w;\n    return step( min( -b, min( c, b*b - c ) ), 0. );\n}\n            \nvec2 sphDistances(in vec3 ro, in vec3 rd, in vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd ),\n     c = dot( oc, oc ) - sph.w*sph.w,\n     h = b*b - c,\n     d = sqrt( max(0.,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.)) );\n}\n\nfloat sphSoftShadow(in vec3 ro, in vec3 rd, in vec4 sph) {\n    vec2 r = sphDistances( ro, rd, sph );\n    return r.y>0. ? max(r.x,0.)/r.y : 1.;\n}    \n            \nfloat sphOcclusion(in vec3 pos, in vec3 nor, in vec4 sph) {\n    vec3  r = sph.xyz - pos;\n    float l = length(r), d = dot(nor,r), res = d;\n    if (d<sph.w) \n        res = pow(clamp((d+sph.w)/(2.*sph.w),0.,1.),1.5)*sph.w;\n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0., 1. );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd ) {\n\tfloat res = 1.;\n    for (int n = 0; n<NB_ELT; n+=CHAIN) {\n        vec4 p = Load(iChannel0, POSITION, n+(CHAIN/2));\n        if (length(ro-p.xyz)<2.+p.w*float(CHAIN)/* && dista(ro,rd,p.xyz)<p.w*float((CHAIN))*/) {\n            for (int i=0; i<CHAIN; i++) {\n                p = Load(iChannel0, POSITION, n+i);\n                if (length(ro-p.xyz)<2.) { \n                    res = min( res, 8.0*sphSoftShadow(ro,rd, p) );\n                }\n            }\n        }         \n    }\n    return res;\t\t\t\t\t  \n}\n\nfloat occlusion( in vec3 pos, in vec3 nor ) {\n\tfloat res = 1.;\n    for (int n = 0; n<NB_ELT; n+=CHAIN) {\n        vec4 p = Load(iChannel0, POSITION, n+(CHAIN/2));\n        if (length(pos-p.xyz)<p.w*float(CHAIN)+1.) {\n            for (int i=0; i<CHAIN; i++) {\n                p = Load(iChannel0, POSITION, n+i);\n                res *= 1. - sphOcclusion( pos, nor, p ); \n            }\n        }\n    }\n    return res;\t\t\t\t\t  \n}\n\nfloat BallHit(vec3 ro, vec3 rd) {\n    vec4 p;\n    vec3 u;\n    float b, d, w, dMin = dstFar;\n    for (int n = 0; n<NB_ELT; n+=CHAIN) {\n        p = Load(iChannel0, POSITION, n+(CHAIN/2));\n        if (length(ro-p.xyz)-p.w*float(CHAIN)<dMin && dista(ro,rd,p.xyz)<p.w*float(CHAIN)) {\n            for (int i =0; i<CHAIN; i++) {\n                p = Load(iChannel0, POSITION, n+i);\n                if (length(ro-p.xyz)-p.w<dMin) {\n                    u = ro - p.xyz;\n                    b = dot (rd, u);\n                    w = b * b - dot (u, u) + p.w * p.w;\n                    if (w >= 0.) {\n                        d = - b - sqrt (w);\n                        if (d > 0. && d < dMin) {\n                            dMin = d;\n                            vnBall = (u + d * rd) / p.w;\n                            idBall = n;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dMin;\n}\n\n#endif\n\n\n// +--------------------------------+\n// |          Rendering             |\n// +--------------------------------+\n\n//------------------------------------------------------------------------\n// [Shane] - Desert Canyon - https://www.shadertoy.com/view/Xs33Df\n//------------------------------------------------------------------------\nvec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in float id, in float dis ) {    \n#ifdef WITH_AO\n    float occ = occlusion( pos, nor );\n    occ = pow(occ,2.);\n    occ = occ*.5 + .5*occ*occ;\n#else\n    float occ = 1.f;\n#endif\n\n#ifdef WITH_SHADOWS\n    float shd = shadow(pos+rd*.01, light );\n#else \n    float shd = 1.f;\n#endif\n    // Sausage Color \n    vec3 col = .5*mix(vec3(1,0,0), vec3(0,1,1), id/float(CHAIN)/7.);    \n    vec3 ref = reflect(rd,nor);\n    float dif = max( dot( light, nor ), 0.), // Diffuse term.\n    \t  spe = pow(max( dot( reflect(-light, nor), -rd ), 0.), 29.), // Specular term.\n    \t  fre = clamp(1. + dot(rd, nor), 0., 1.); // Fresnel reflection term.\n    // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n    // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n    // used to give a hard clay consistency... It \"kind of\" works.\n    float Schlick = pow( 1. - max(dot(rd, normalize(rd + light)), 0.), 5.);\n    float fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n    // Overal global ambience.\n    float amb = .6*fre*fre2 + .06*occ;\n    \n    float h = dot(pos,vec3(127.1,311.7,758.5453123));\t\n\tcol *= .6+.4*fract(sin(h)*43758.5453123);\n    // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n    return (col*(dif + .1) + fre2*spe*2.)*shd*occ + amb*col;\n}    \n\n\n// Render scene using raytracing (to save gpu)\nvec4 ShowScene (vec3 ro, vec3 rd, vec3 backColor) {\n    if (cube(ro,rd, CUBE_SIZE*2.-1.)) { // Full scene bounding box\n        float d = BallHit (ro, rd);\n        if (d < dstFar) {\n            vec3 pos = ro + d*rd, nor = vnBall;\n            return vec4(shade(rd, pos, nor, 63.*(.5+.5*cos(float(2*idBall))), d), d);\n        } \n    }\n    return vec4(backColor, 20);\n}\n\n\n// Create camera base matrix\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n    cr = .1*cos(.1*iTime);\n\tvec3 w = normalize(ta-ro),\n\t \t p = vec3(0., sin(cr), -cos(cr)),\n         u = normalize( cross(w,p) ),\n         v = normalize( cross(u,w) );\n    return mat3(u,v,w);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord) {\n    \n    // Normalize pixels\n    vec2 canvas = iResolution.xy,\n         uv = 2. * fragCoord.xy/canvas - 1.;\n    uv.x *= canvas.x / canvas.y;\n    \n\t// Camera      \n    float gAnim = mod(iTime,35.);\n\n    // Distance\n    float camDist;\n    camDist = mix(3.5,4.5, smoothstep(9.,11.,gAnim));\n    camDist = mix(camDist,6., smoothstep(17.,23.,gAnim));\n    camDist = mix(camDist,3.5, smoothstep(34.,35.,gAnim));\n    \n    // Target\n    vec3 ta;\n    ta = mix(vec3(0,0,.8*CUBE_SIZE.z), vec3(0), smoothstep(10.,12.,gAnim));\n    ta = mix(ta, vec3(0,0,.8*CUBE_SIZE.z), smoothstep(33.,35.,gAnim));\n    \n    // Camera position\n    vec3 a = mix(vec3(cos(.5*iTime), sin(.5*iTime), -.5),vec3(1,1,-.5), smoothstep(1.,0.,iTime)); \n    vec3 ro = ta + camDist*pow(float(NB_LELT),.45)*(.9+.1*cos(iTime))*a;\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 1.);\n    \n    // current ray direction\n    vec3 rd = ca * normalize( vec3(uv.xy, 4.5) );\n\n    // Background color\n    vec2 q = fragCoord.xy/canvas;\n    float h = dot(vec3(q,1.),vec3(127.1,311.7,758.5453123));\t\n\tvec3 backColor = vec3(.2) + .05*fract(sin(h)*43758.5453123);\n    \n    // Render scene (xyz = color, w = distance)\n    vec4 result = ShowScene (ro, rd, backColor);\n    \n    // Post traitment\n   \tvec3 col = pow(1.5*result.xyz,vec3(.6));\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .25);\n        \n    fragColor = vec4(col, result.w);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-----------------------------------------------------\n// Created by sebastien durand - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n//\n// Simulate and make evolved a population of 280 creatures in real time.\n// Lots of comments in the code for those who are interested by how it works (Far far the most algorithmic shader I have ever made!)\n// [Use mouse to watch other creatures]\n//\n//-----------------------------------------------------\n// [dr2]            More Balls               - https://www.shadertoy.com/view/MsfyRn\n// [iq]             Capsule - soft shadow    - https://www.shadertoy.com/view/MlGczG\n// [iq]             Balls and shadows        - https://www.shadertoy.com/view/lsSSWV\n// [Shane]          Desert Canyon            - https://www.shadertoy.com/view/Xs33Df\n//-----------------------------------------------------\n\n\n#define NB_LINES    17  // Number of lines of sausages\n#define NB_LELT     56  // Number of sausages parts \n#define NB_ELT  (NB_LELT*NB_LINES) \n    \n#define CHAIN 7\n\n\n// -- PHYSICS -------------------------------------------------\n\n#define DT            .008  // Step for mecanic calculus (.004 = real time => time beween two frame at 240fps)\n#define DENSITY       1000. // kg/m3 (density of water here)\n#define GRAV          9.81  // m/s-1 (on earth)\n\n\n// +----------------------------------------------------------+\n// |       !!!!  DO NOT CHANGE AFTER THIS LINE !!!!           |  \n// +----------------------------------------------------------+\n\n// -- Step of the algorithm -----------------------------------\n\n#define STAGE_INIT            0  // First initialisation\n#define STAGE_SIMULATE        1  // Make Sausage dance\n// At end go back to\n\n#define NO_LINK               0xFFFF\n\n// -- Position of elements in BufferPicture ------------------\n#define LINE_CONF\t    NB_LINES\n\n#define POSITION        0\n#define ORIENTATION     1\n#define VELOCITY        2\n#define ROT_VELOCITY    3\n#define LINK            4\n\n// -- Constants ----------------------------------------------\n#define PI              3.141592653589\n#define CUBE_SIZE       vec3(6,6,6)\n\n// -- Functions ----------------------------------------------\n#define CON_TO(c)       int(c)%1000\n#define CON_AT(c)       (int(c)%10000)/1000\n#define CON_TYPE(c)     int(c)/10000\n\n\n// Force of muscles and ligaments\nconst float dSpringK = 6000.;\n\nvec4 gRotTetra[4];\n\n\n// +---------------------------+\n// |        Save / Load        |\n// +---------------------------+\n\nvec4 LoadConf (sampler2D txBuf, int idVar) {\n    return texelFetch(txBuf, ivec2(idVar, LINE_CONF), 0);\n}\n\nvec4 Load(sampler2D txBuf, int kind, int eltId) {\n    int line = eltId/NB_LELT;\n    eltId = eltId%NB_LELT;\n    return texelFetch(txBuf, ivec2(NB_LELT*kind + eltId, line), 0);\n}\n\nvoid Save(int kind, int eltId, vec4 val, inout vec4 fCol, vec2 fCoord) {\n    int line = eltId/NB_LELT;\n    eltId = eltId%NB_LELT;\n\tvec2 iFrag = floor(fCoord);\n    if ((NB_LELT*kind + eltId) == int(iFrag.x) && line == int(iFrag.y)) fCol = val;\n}\n\n\n// +---------------------------+\n// |        Quaternions        |\n// +---------------------------+\n\nvec4 Quaternion(vec3 n, float a) {\n    return normalize(vec4(n*sin(a*.5), -cos(a*.5)));\n}\n\n// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/arithmetic/index.htm\nvec4 QtMul(vec4 q1, vec4 q2) {\n    return vec4(cross(q1.xyz,q2.xyz) + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dot(q1.xyz,q2.xyz));\n}\n\n\n//-----------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\n\nmat3 QtToRMat(vec4 q) {\n    mat3 m;\n    float a1, a2, s;\n    q = normalize (q);\n    s = q.w * q.w - 0.5;\n    m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n    a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n    a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n    a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n    return 2. * m;\n}\n\n//-----------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nvec4 RMatToQt(mat3 m) {\n    vec4 q;\n    const float tol = 1e-6;\n    q.w = .5 * sqrt(max(1. + m[0][0] + m[1][1] + m[2][2], 0.));\n    if (abs(q.w) > tol) \n        q.xyz = vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4.*q.w);\n    else {\n        q.x = sqrt (max(.5 * (1. + m[0][0]), 0.));\n        if (abs (q.x) > tol) \n            q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n        else {\n            q.y = sqrt (max (.5 * (1. + m[1][1]), 0.));\n            if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n            else q.z = 1.;\n        }\n    }\n    return normalize (q);\n}\n\n//-----------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nmat3 LpStepMat (vec3 a) {\n    mat3 m1, m2;\n    vec3 t, c, s;\n    float b1, b2;\n    t = .25 * a * a;\n    c = (1. - t) / (1. + t);\n    s = a / (1. + t);\n    m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n    b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n    m1[0][1] = b1 + b2;    m2[1][0] = b1 - b2;\n    b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n    m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n    b1 = c.y * s.z;\n    m1[1][0] = - b1;       m2[0][1] = b1;  \n    b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n    m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n    b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n    m1[1][2] = b1 + b2;    m2[2][1] = b1 - b2;\n    m1[2][0] = s.y;        m2[0][2] = - s.y;\n    b1 = s.x * c.y;\n    m1[2][1] = - b1;       m2[1][2] = b1;\n    b1 = c.x * c.y;\n    m1[2][2] = b1;         m2[2][2] = b1;\n    return m1 * m2;\n}\n\n\n// +------------------------------------------------------+\n// |                      UTILS                           |\n// +------------------------------------------------------+\n\nbool getConnexionBases(sampler2D txBuf, vec4 connexions, int con_pos, vec4 qm1, out vec4 pc2, out mat3 rot1, out mat3 rot2) {\n    if (int(connexions[con_pos]) == NO_LINK)\n        return false;\n    \n    int other_con_pos = CON_AT(connexions[con_pos]),\n        parentId =      CON_TO(connexions[con_pos]);\n\n    pc2 =      Load(txBuf, POSITION,    parentId);\n    vec4 qm2 = Load(txBuf, ORIENTATION, parentId);\n\n    // Orientation of connexion point\n    if (con_pos == 0) {\n        rot1 = QtToRMat(qm1);\n        rot2 = QtToRMat(QtMul(qm2,gRotTetra[other_con_pos]));\n    } else {\n        rot1 = QtToRMat(QtMul(qm1,gRotTetra[con_pos]));\n        rot2 = QtToRMat(qm2);\n    }\n    return true;\n}\n\n\n// +------------------------------------------------------+\n// |                    STAGE INIT                        |\n// +------------------------------------------------------+\n// Init links of elements \nvec4 InitLinks(int eltId) {\n\tif (eltId%CHAIN == 0)\n    \treturn vec4(NO_LINK, 20000+eltId+1, NO_LINK, NO_LINK);\n    if (eltId%CHAIN == CHAIN-1)\n        return vec4(21000+eltId-1, NO_LINK, NO_LINK, NO_LINK);\n    return vec4(21000+eltId-1 , 20000+eltId+1, NO_LINK, NO_LINK);\n}\n\n// +------------------------------------------------------+\n// |                 STAGE_MAKE_BODY                      |\n// +------------------------------------------------------+\n// Create Initial Pos from ADN\n\nvoid InitSausagesPositions(sampler2D txBuf, int eltId, out vec3 rm, out vec4 qm, out float rad) {\n    int creatureId = eltId/NB_LELT;\n    eltId = eltId%NB_LELT;\n    float idChain = float(eltId/CHAIN);\n    float ca = cos(idChain), sa = sin(idChain);\n    rm = vec3(float(NB_LINES)*.25-float(creatureId)*.5, float(eltId%CHAIN - CHAIN/2)*.5, 2.-.5*float(eltId/CHAIN));\n    rm.xy *= mat2(ca,sa,-sa,ca);\n    qm = vec4(0,0,0,-1);\n    rad = .25;\n}\n\n\n// +---------------------------------------------------+\n// |                 Animate creatures                 |\n// +---------------------------------------------------+\n\n// Spring force\nvoid applyForce(vec4 pc1, mat3 rot1, vec4 pc2, mat3 rot2, vec3 n1, vec3 n2,float springLen, inout vec3 am, inout vec3 wam, float kForce) {\n    vec3 p1 = pc1.xyz + pc1.w*rot1*n1,\n     \t p2 = pc2.xyz + pc2.w*rot2*n2,\n         v = p1 - p2;\n    float dLen = length(v);\n\tvec3 springForce = kForce* (dLen-springLen) * v/dLen;\n    am -= springForce;\n    wam -= cross(p1 - pc1.xyz, springForce);\n}\n\n//-----------------------------------------------------------\n// Adapted from\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\n//-----------------------------------------------------------\nvoid Simulate(float time, sampler2D txBuf, int eltId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float rad) {\n\n    // Friction between Elements of the elements of sausages\n    const float fricNB = 5., fricSB = 5., fricSWB = 10., fricTB = 40.;\n    \n    // Friction to the ground\n    const float fricN = 240., fricS = 240., fricSW = 160., fricT =248.;\n    \n    vec3  vmN, wmN, dr, dv, am, wam;\n    float rSep, radSum, fc, ft, ms, h, fOvlap = 3.*15000.;\n        \n    vec4 pc1 = Load(txBuf, POSITION, eltId);\n    qm = Load(txBuf, ORIENTATION,    eltId);\n    vm = Load(txBuf, VELOCITY,       eltId).xyz;\n    wm = Load(txBuf, ROT_VELOCITY,   eltId).xyz;\n\n    rm = pc1.xyz;\n    rad = pc1.w;\n\n    ms = rad*rad*rad*DENSITY; // Mass\n\n    am = wam = vec3(0); // Sum or forces\n \n    // Slow it a bit\n    vm *= .99;\n    wm *= .97;\n\n    // Check intersection between Elements of the creature\n    for (int n =0; n<NB_LELT*NB_LINES; n+=CHAIN) {\n        vec4 p = Load(txBuf, POSITION, n+(CHAIN/2));\n\n        if (length(p.xyz-pc1.xyz)-pc1.w*float(CHAIN)<pc1.w) {\n            for (int i = 0; i < CHAIN; i++) {\n                vec4 pc2 = Load(txBuf, POSITION, n+i);\n\n                dr = pc1.xyz - pc2.xyz;\n\n                rSep = length(dr);\n                radSum = pc1.w + pc2.w;\n\n                if (n+i != eltId && rSep < radSum) {\n\n                    // Impulsion de contact\n                    fc = fOvlap * (radSum / rSep - 1.);\n\n                    vmN = Load(txBuf, VELOCITY, n+i).xyz;\n                    wmN = Load(txBuf, ROT_VELOCITY, n+i).xyz;\n\n                    dv = vm - vmN;\n                    h = dot(dr, dv) / (rSep)*(rSep);\n\n                    // friction\n                    fc = max(fc - fricNB * h, 0.);\n                    am += fc * dr;\n                    dv -= h * dr + cross ((2.*pc1.w * wm + 2.*pc2.w * wmN) / (2.*pc1.w + 2.*pc2.w), dr);\n                    ft = min (fricTB, fricSB * abs (fc) * rSep / max (0.001, length (dv)));\n\n                    am -= ft * dv;\n                    wam += (ft / rSep) * cross (dr, dv);\n                }\n            }\n        }\n    }\n    \n    \n    vec4 connexions = Load(txBuf, LINK, eltId);\n    mat3 rot1, rot2, rot = QtToRMat(qm);\n    \n    int creatureId = eltId/NB_LELT;\n    // For each possible connexions to other Elts\n    for (int con_pos=0; con_pos<2; con_pos++) {\n        vec4 pc2; \n        \n        if (getConnexionBases(txBuf, connexions, con_pos, qm, pc2, rot1, rot2)) {\n            \n\t        int move_con = CON_TYPE(connexions[con_pos]);\n            float anim = .14*cos(time*5. + float(creatureId) + float(move_con/10)*6.28),\n\t\t\t \t  a = PI*2.*float(move_con)/8.,\n             \t  ca = cos(a), sa = sin(a),\n            \t  kForce = dSpringK*mix(5., 100.*(pc1.w*pc1.w*pc1.w + pc2.w*pc2.w*pc2.w), .6); // biggest link => strongest\n                        \n            // Ligaments\n            if (con_pos == 0)\n                applyForce(pc1, rot1, pc2, rot2, vec3(0,0,1), vec3(0,0,-1),  0., am, wam, 2.*kForce);\n            else \n                applyForce(pc1, rot1, pc2, rot2, vec3(0,0,-1), vec3(0,0,1),  0., am, wam, 2.*kForce);\n            \n            applyForce(pc1, rot1, pc2, rot2, vec3(ca,sa,0), vec3(ca,sa,0), pc1.w+pc2.w, am, wam, 2.*kForce);\n            applyForce(pc1, rot1, pc2, rot2,-vec3(ca,sa,0),-vec3(ca,sa,0), pc1.w+pc2.w, am, wam, 2.*kForce);\n\t\t\t\n            // Muscles\n            applyForce(pc1, rot1, pc2, rot2, vec3(sa,ca,0),vec3(sa,ca,0), (pc1.w+pc2.w)*(1.+anim), am, wam, kForce);\n            applyForce(pc1, rot1, pc2, rot2,-vec3(sa,ca,0),-vec3(sa,ca,0), (pc1.w+pc2.w)*(1.-anim), am, wam, kForce);\n        }\n    }\n    \n\n    // Intersection with the ground \n    float radAv = rad + .5;\n    vec4 drw = vec4 ((CUBE_SIZE - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n\n    for (int nf = 0; nf < 3; nf ++) {\n\n        dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n        rSep = length (dr);\n\n        if (rSep < radAv) {\n            // Out of the ground\n            rm -= .5*normalize(dr)*(rSep-radAv);\n\n            fc = fOvlap * (radAv / rSep - 1.);\n            dv = vm;\n            h = dot (dr, dv) / (rSep * rSep);\n            fc = max (fc - fricN * h, 0.);\n\n            am += fc * dr;\n            dv -= h * dr + cross (wm, dr);\n\n            ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n            am -= ft * dv;\n            wam += (ft / rSep) * cross (dr, dv);\n        }\n\n    }\n    \n    // Moving gravity\n    vec3 vGrav;\n    float anim = mod(time,35.);\n\n    if (anim<10.){\n  \t \tvGrav = vec3(0,0,1); // Classic\n    } else if (anim<20.){\n     \tvGrav = 4.*normalize(pc1.xyz)-pc1.xyz;  // Sphere r=4\n    } else { \n    \tvGrav = pc1.xyz;\t// From center => cube formation\n    }\n    if (length(vGrav) != 0.)\n        vGrav /= length(vGrav);\n    \n    am += vGrav * ms*GRAV;\n \n   // Integrate all\n    vm += DT * am/ms;\n    rm += DT * vm;\n    wm += DT * wam / (ms*rad);\n  \n    qm = normalize(QtMul(RMatToQt(LpStepMat(.5 * DT * wm)), qm));\n}\n\n\n// +---------------------------+\n// |         Main Loop         |\n// +---------------------------+\n\nvoid mainLoop(float iTime, vec4 iMouse, vec2 iResolution, int iFrame, sampler2D txBuf, out vec4 fragColor, in vec2 fragCoord) {\n\n    gRotTetra[0] = vec4(0,0,0,1);\n    gRotTetra[1] = vec4(0,0,0,-1);\n\n    vec4 configuration = LoadConf(txBuf, 3);\n    \n    int stage, nextStage;\n    \n    if (iFrame == 0) {\n        stage = STAGE_INIT;       // Init first ADN\n\n    } else {\n        stage = int(configuration.z);\n        nextStage = stage;\n    }\n\n    vec2 iFrag = floor(fragCoord);\n    int pxId = int(iFrag.x);\n        \n    // By default : do not change value \n    fragColor = texelFetch(txBuf, ivec2(iFrag), 0);\n        \n    // Win some cycles \n    if (iFrag.y >= float(NB_LINES+1)) {      \n\t\treturn;\n    }\n\n    // Configuration\n    if (int(iFrag.y) == LINE_CONF) {  \n\n        if (pxId == 3) {\n            // Change states (sequence of actions)\n            if (stage == STAGE_INIT) {\n                nextStage = STAGE_SIMULATE;\n            } \n\n            configuration = vec4(0, 0, nextStage, 0);\n        }\n\t\t\n\t\t// Save config\n        fragColor = configuration;\n\n    } else {\n\n\t\tint eltId = pxId%NB_LELT + int(iFrag.y)*NB_LELT;\n\t\tint varColId = pxId/NB_LELT;\n        \n        vec4 p, qm;\n    \tvec3 rm, vm, wm;\n        float rad;\n        \n\t// -- Init ---------------------------------------------------------\n\n        if (stage == STAGE_INIT) {\n  \t\t\tif (varColId == LINK) {\n                fragColor = InitLinks(eltId);\n                \n            } else if (varColId == VELOCITY || varColId == ROT_VELOCITY) {\n                fragColor = vec4(0); // Static at starts\n         \n            } else if (varColId == POSITION || varColId == ORIENTATION) {\n                       \n\t\t\t\t// ------------------------------------------------------------------\n                // Init positions and orientations\n                InitSausagesPositions(txBuf, eltId, rm, qm, rad);\n                // Save Positon and Orientation\n                fragColor = varColId == POSITION ? vec4(rm, rad) : qm;\n            }\n         \n        }  else if (stage == STAGE_SIMULATE) {\n \t\t\t\n            if (varColId < LINK) {    \n\t            // Do physical simulation\n                Simulate(iTime, txBuf, eltId, rm, vm, qm, wm, rad);\n\t\t\t\t\n                // Save new positions, orientation and speeds\n                fragColor = varColId == POSITION ? vec4(rm, rad) :\n\t\t\t\t\t\t    varColId == ORIENTATION ? qm :\n\t\t\t\t\t\t    varColId == VELOCITY ? vec4(vm,0) : vec4(wm,0);\n            }\n        }\n    }\n    \n\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n   mainLoop(iTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n   mainLoop(iTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n   mainLoop(iTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n   mainLoop(iTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}