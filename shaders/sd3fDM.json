{
    "Shader": {
        "info": {
            "date": "1656569949",
            "description": "Simple a quick performance test designed to tank your FPS to see which operation is faster.",
            "flags": 0,
            "hasliked": 0,
            "id": "sd3fDM",
            "likes": 2,
            "name": "PerfTest Texture VS Cell Tiling",
            "published": 3,
            "tags": [
                "voronoi",
                "test",
                "fast",
                "performance",
                "cell",
                "speed"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 169
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nThis is a perfromance test to see what it takes to make a cheap voronoi faster \nthan a texture lookup. As it turns out you have to cut almost everything.\n\nTwo layers of rotated sphere square grids are all that is allowed. \nI wonder what one can still add to make it more irregular, while being faster\nthan a texturelookup. This may be usefull for animation that supplements a more\ncomplex shader. \n\nIf you want to test for yourself the tests are in the main. Just comment in\nthe test of your choice and up the repeat number. \n\nThese are a variant of Shane's Cellular Tiling \n(https://www.shadertoy.com/view/4scXz2, https://www.shadertoy.com/view/MdKXDD).\nIt is also better commented than mine so check them out. \n\nIf you want select the \"seed\" for your pattern see my variant\n(https://www.shadertoy.com/view/NscBWM).\n*/\n\n// loads a texture pretend its a voronoi noise texture\nfloat loadTexture(vec2 uv) {       \n    return texture(iChannel0, uv).x;\n}\n\n// load a volumetric Texture pretend its a 3D voronoi noise texture\nfloat load3DTexture(vec3 uvw) {       \n    return texture(iChannel1, uvw).x;\n}\n\n// Wrappable circle distance. The squared distance, to be more precise.\nfloat drawShape(in vec2 p){\n    p = fract(p) - .5;    \n    return dot(p, p);\n}\n\n// Celluar Tiling from Shane https://www.shadertoy.com/view/4scXz2\n// Draw some cirlcles on a repeatable tile. The offsets were partly based on science, but\n// for the most part, you could choose any combinations you want.\nfloat cellTex(in vec2 p) {  \n    float c = .25; // Set the maximum, bearing in mind that it is multiplied by 4.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    c = min(c, drawShape(p - vec2(.80, .62)));\n    c = min(c, drawShape(p - vec2(.38, .20)));\n    \n    c = min(c, drawShape(p - vec2(.60, .24)));\n    c = min(c, drawShape(p - vec2(.18, .82)));\n\n    // Draw four smaller circles at various positions on the tile.\n    // By the way, when using rotation, decreasing the size is optional.\n    p *= 1.4142;  \n    //p = p.yx; // Extra option, or addition.\n    c = min(c, drawShape(p - vec2(.46, .30)));\n    c = min(c, drawShape(p - vec2(.04, .88))); \n  \n    // More shapes produce a more convincing pattern, but you could cut\n    // these two out and still produce a decent image.\n    c = min(c, drawShape(p - vec2(.06, .54)));\n    c = min(c, drawShape(p - vec2(.64, .12)));  \n    \n    return sqrt(c*4.);    \n}\n\n// Rotating Celluar Tiling from Shane https://www.shadertoy.com/view/4scXz2\nfloat rotCellTex(in vec2 p) {  \n    float c = .25; // Set the maximum, bearing in mind that it is multiplied by 4.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    c = min(c, drawShape(p - vec2(.80, .62)));\n    c = min(c, drawShape(p - vec2(.38, .20)));\n    \n    // Rotate the layer (coordinates) by 120 degrees. Layer rotation \n    // drastically improves randomness, for very little extra cost.\n    p = mat2(.5, -.866, .866, .5)*(p - .5); // \n    c = min(c, drawShape(p - vec2(.60, .24)));\n    c = min(c, drawShape(p - vec2(.18, .82)));\n\n    // Draw four smaller circles at various positions on the tile.\n    // By the way, when using rotation, decreasing the size is optional.\n    p *= 1.4142;  \n    //p = p.yx; // Extra option, or addition.\n    c = min(c, drawShape(p - vec2(.46, .30)));\n    c = min(c, drawShape(p - vec2(.04, .88))); \n\n    // Rotate the layer (coordinates) by 120 degrees. \n    p = mat2(.5, -.866, .866, .5)*(p - .5);   \n    // More shapes produce a more convincing pattern, but you could cut\n    // these two out and still produce a decent image.\n    c = min(c, drawShape(p - vec2(.06, .54)));\n    c = min(c, drawShape(p - vec2(.64, .12)));  \n    \n    return sqrt(c*4.);    \n}\n\n// creates a sphere grid of the squared distance to the center\nfloat sphereGrid(vec2 uv) {\n    vec2 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define cos1            1.0049000034 //cos((pi * 24.)/180.)*1.1\n#define sin1            0.4474103074 //sin((pi * 24.)/180.)*1.1\n// makes a tiling cell pattern with 3 levels\nfloat cellTiling3(vec2 uv) {\n    float c = sphereGrid(uv);// first grid\n        \n    mat2 m = mat2(cos1, -sin1, sin1, cos1); // rotation/scale matric\n    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    c = min(c, sphereGrid(uv)); // blending the voronoi with\n    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    c = min(c, sphereGrid(uv)); // blending the voronoi with \n    \n    return sqrt(c)*1.5; //sqrt for center distance, 1.5 for 0-1 range\n}\n\n// makes a tiling cell pattern with 2 levels\nfloat cellTiling2(vec2 uv) {\n    float c = sphereGrid(uv);// first grid\n    \n    mat2 m = mat2(cos1, -sin1, sin1, cos1); // rotation/scale matric\n     \n    uv *= m; //gets rotated and scaled\n    c = min(c, sphereGrid(uv)); // blending the voronoi with\n    \n    return sqrt(c)*1.5; //sqrt for center distance, 1.5 for 0-1 range\n}\n\n// makes a tiling cell pattern with 2 levels squared very repeating pattern\nfloat cellTiling2squared(vec2 uv) {\n    float c = sphereGrid(uv);// first grid\n        \n    mat2 m = mat2(cos1, -sin1, sin1, cos1); // rotation/scale matric     \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    c = min(c, sphereGrid(uv)); // blending the voronoi with\n        \n    return c*2.; //squared for center distance, 2. for 0-1 range\n}\n\n#define cos2            0.5334260858 //cos((pi * 55.)/180.)*.93\n#define sin2            0.7618114012 //sin((pi * 55.)/180.)*.93\n// makes a tiling flashing pattern https://www.desmos.com/calculator/kcmr5ftqqw\nfloat flashyTiling(vec2 uv, float bias) {\n    vec2 offset = vec2(iTime*.2, iTime*1.); //movement\n    \n    float grid1 = sphereGrid(uv - offset); // first grid\n    \n    mat2 m = mat2(cos2, -sin2, sin2, cos2); // rotation/scale matric    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    float grid2 = sphereGrid(uv +offset.xy); // blending the voronoi with \n    \n    float comb = (-grid1 -grid2 +bias)*(1./bias); // inverting adding bias\n    comb = clamp(comb, 0., 1.); //saturate\n    return comb; //sqrt for center distance, 1.5 for 0-1 range\n}\n\n#define pi              3.1415926536\n// sine grid, a tiny bit faster than spheregrid\nfloat bubble(vec2 uv) {\n    vec2 d = sin(uv); //remove pi for pi sized grid\n    return abs(d.x*d.y);    \n}\n\n// makes a faster tiling flashing pattern https://www.desmos.com/calculator/bnpkohjent\nfloat sflashyTiling(vec2 uv, float bias) {\n    vec2 offset = vec2(iTime*.6, iTime*3.); //movement\n    \n    float grid1 = bubble(uv - offset); // first grid\n    \n    mat2 m = mat2(cos2, -sin2, sin2, cos2); // rotation/scale matric    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    float grid2 = bubble(uv +offset.xy); // blending the voronoi with \n    \n    float comb = (grid1 +grid2 +bias-2.)*(1./bias); // inverting adding bias\n    comb = clamp(comb, 0., 1.); //saturate to catch rounding errors\n    return comb; //0-1 range\n}\n\n// creates a 3D sphere grid of the squared distance to the center\nfloat sphereGrid(vec3 uv) {\n    vec3 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define cos3             0.8973775077 //cos((pi * 33.)/180.)*1.07\n#define sin3             0.5827637675 //sin((pi * 33.)/180.)*1.07\n#define sqrCos3          0.7526041040 //cos((pi * 33.)/180.)^2 *1.07\n#define sqrSin3          0.3173958960 //sin((pi * 33.)/180.)^2 *1.07\n#define sinCos3         -0.4887468198 //-sin((pi * 33.)/180.)*cos((pi * 33.)/180.)*1.07\n// makes a 3D tiling cell pattern with two levels\nfloat cellTiling3D(vec3 uvw) {\n    float c = sphereGrid(uvw); // first grid\n    \n    // rotation/scale matric desmos.com/calculator/refsu6mvlj\n    mat3 m = mat3(cos3, sinCos3, sqrSin3,\n                  sin3, sqrCos3, sinCos3,\n                  0., sin3, cos3);\n    uvw *= m; //each iteration gets rotated and scaled one addional time\n    c = min(c, sphereGrid(uvw)); // blending the voronoi with \n    \n    return sqrt(c); //sqrt for center distance, 1.5 for 0-1 range\n}\n\n#define cos4             0.8660254038 //cos((pi * 30.)/180.)*1.\n#define sin4             0.5 //sin((pi * 30.)/180.)*1.\n#define cos5             0.5 //cos((pi * 60.)/180.)*1.\n#define sin5             0.8660254038 //sin((pi * 60.)/180.)*1.\n// makes a 3D tiling cell pattern with two levels with different rotation\nfloat cellTiling3D2(vec3 uvw) {\n    // rotation/scale matric desmos.com/calculator/refsu6mvlj\n    mat3 mY = mat3(cos4, 0., sin4,\n                   0., 1., 0.,\n                  -sin4, 0., cos4); // rotation matric Y Axis\n    float c = sphereGrid(uvw*mY); // first grid    \n\n    mat3 mX = mat3(1., 0., 0.,\n                   0., cos5, -sin5,\n                   0., sin5, cos5); // rotation matric X Axis  \n    c = min(c, sphereGrid(uvw*mX)); // blending the grids \n    \n    return sqrt(c); //sqrt for center distance, 1.5 for 0-1 range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 8.0; //Hex Grid Size\n    vec2 uv = fragCoord/iResolution.y*gridRes; //square UVs\n    \n    // if you get around 144 fps use a higher repeat value\n    int repeat = 1; //2000 is enough for RTX2070\n    float test;\n    for(int i=0; i<repeat; i++) {  \n        float per = sin(float(i)); //new permutation each iteration\n        vec2 a = uv + per; \n        \n        // use which ever you wish to test\n        //float grid = loadTexture(a); //loading a texture: 75fps\n        //float grid = load3DTexture(vec3(a,per)); //loading voltex: 63fps\n        //float grid = cellTex(a); //cheap shanes cell grid: 32fps\n        //float grid = rotCellTex(a); //rotated shanes cell grid: 29fps\n        float grid = cellTiling3(a); //my 3 cell grid: 67fps\n        //float grid = cellTiling2(a); //my 2 cell grid: 86fps\n        //float grid = cellTiling2squared(a); //my squared 2 cell grid: 99fps      \n        //float grid = flashyTiling(a, .2); //flashing variant: 85 fps\n        //float grid = sflashyTiling(a*pi, .6); //sine flashing variant: 95fps\n        //float grid = cellTiling3D(vec3(a,per)); //my 2 cell 3d grid: 68fps\n        //float grid = cellTiling3D2(vec3(a,per)); //my 2 cell 3d grid v2: 68fps\n        \n        test += grid; //adding to output so every iteration matters\n    }\n        \n    // Output to screen\n    fragColor = vec4(fract(test));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}