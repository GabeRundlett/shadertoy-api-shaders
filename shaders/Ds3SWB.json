{
    "Shader": {
        "info": {
            "date": "1680313203",
            "description": "tan(VanDamme) is too funny\n\nKeys:\nm               - toggle magnitude levels\np                - toggle phase levels\ntab             - toggle video source\nmouse       - select quadrant\nl                 - lock mouse down",
            "flags": 16,
            "hasliked": 0,
            "id": "Ds3SWB",
            "likes": 5,
            "name": "Complex domain warping (cont'd)",
            "published": 3,
            "tags": [
                "video",
                "warping",
                "complex",
                "contours"
            ],
            "usePreview": 0,
            "username": "eo",
            "viewed": 188
        },
        "renderpass": [
            {
                "code": "\n/*\nForked from https://shadertoy.com/view/clfSRM\n\nVisualizing complex functions:\n\n  ┌────────────────┬───────────────┐\n  │     cos(z)     │   pow(z,z)    │\n  ├────────────────┼───────────────┤\n  │     exp(z)     │    log(z)     │\n  └────────────────┴───────────────┘\n\nEach function takes in a complex value z (i.e. 2d coordinate xy) and\ncomputes a new complex value, usually different from the input.\nAt each input xy, the video is sampled using the computed xy,\ngiving a warping effect.\n\nPressing tab switches to a domain coloring view. For more info\nabout that, see \"Domain coloring w/ level curves\"\nhttps://shadertoy.com/view/clfSRM\n*/\n\n// Control appearance\n#define MAG_LEVELS 4\n#define PHASE_LEVELS 12\n#define LEVELS_CONTRAST 0.25\n#define ZOOM 0.5\n\n\nfloat get_level_scale(vec2 polar_mag_angle, bool enable_mag, bool enable_phase) {\n\n    /*\n    Calculates a scaling term used to darken the resulting image\n    in such a way that magnitude/phase contour lines appear,\n    acting a bit like polar coordinate grid-lines\n    */\n\n    // Set up the number of magnitude & phase levels\n    float mag_level = fract(float(MAG_LEVELS) * polar_mag_angle.x);\n    float phase_level = fract(float(PHASE_LEVELS) * polar_mag_angle.y);\n    \n    // Include mag/phase leveling, based on enabling inputs\n    mag_level = mix(1.0, mag_level, float(enable_mag));\n    phase_level = mix(1.0, phase_level, float(enable_phase));\n    float leveling = mag_level * phase_level;\n    \n    // Adjust scaling for better aesthetics\n    return (1.0 - LEVELS_CONTRAST) + LEVELS_CONTRAST * leveling;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Read keyboard\n    bool show_video = !get_key_toggle(iChannel0, KEY_tab);\n    bool show_mag_levels = !get_key_toggle(iChannel0, KEY_m);\n    bool show_phase_levels = !get_key_toggle(iChannel0, KEY_p);\n    bool hold_mouse = get_key_toggle(iChannel0, KEY_l);\n    \n    // For clarity, figure out which quadrant we're in\n    vec2 cartesian_xy = get_cartesian_coords(fragCoord.xy, iResolution);\n    float aspect = iResolution.x / iResolution.y;\n    bool is_right = cartesian_xy.x > 0.0;\n    bool is_top = cartesian_xy.y > 0.0;\n    bool top_left = !is_right && is_top;\n    bool top_right = is_right && is_top;\n    bool bot_left = !is_right && !is_top;\n    bool bot_right = is_right && !is_top;\n    \n    // Get a centered (-1 to +1) z coordinate for each of the 4 cells\n    vec2 cell_offset = vec2(aspect*(is_right ? 1.0:-1.0), is_top ? 1.0:-1.0);\n    vec2 cell_z = (2.0*cartesian_xy - cell_offset) / ZOOM;\n    \n    // Override quadrant rendering if the mouse is pressed\n    bool mouse_is_down = (iMouse.z > 0.0) || hold_mouse;\n    if (mouse_is_down){\n        cell_z = cartesian_xy / ZOOM;\n        bool m_is_right = iMouse.x > iResolution.x*0.5;\n        bool m_is_top = iMouse.y > iResolution.y*0.5;\n        top_left = !m_is_right && m_is_top;\n        top_right = m_is_right && m_is_top;\n        bot_left = !m_is_right && !m_is_top;\n        bot_right = m_is_right && !m_is_top;\n    }\n    \n    // Select one of the functions!\n    vec2 f_of_z = vec2(1);\n         if (top_left)     f_of_z = tan2d(cell_z);\n    else if (top_right)    f_of_z = pow2d(cell_z, cell_z);\n    else if (bot_left)     f_of_z = exp2d(cell_z);\n    else if (bot_right)    f_of_z = log2d(cell_z);\n    \n    // Calculate scaling for constant mag/phase level indicators\n    vec2 polar = get_polar(f_of_z);\n    float level_scale = get_level_scale(polar, show_mag_levels, show_phase_levels);   \n    \n    // Toggle video imagery vs. domain coloring image\n    vec3 out_rgb;   \n    if (show_video) {\n        out_rgb = sample_video_warped(iChannel1, f_of_z * ZOOM, iResolution);\n    } else {\n        vec3 phase_color = angle_to_rgb(polar.y);\n        out_rgb = phase_color * level_scale;\n    }\n    \n    // Add quadrant dividing lines\n    if (!mouse_is_down) {\n        float divider_line = smoothstep(0.0, 0.00001*iResolution.y, min(abs(cartesian_xy.x), abs(cartesian_xy.y)));\n        out_rgb *= 1.0 - LEVELS_CONTRAST*(1.0 - divider_line);\n    }\n    \n    fragColor = vec4(out_rgb, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// For clarity\n#define TWOPI 6.28318530718\n#define KEY_tab   9\n#define KEY_m    77\n#define KEY_p    80\n#define KEY_l    76\n#define is_near_zero(v) abs(v) < 0.0001\n\n\n// From iq:\n// https://www.shadertoy.com/view/ll2GD3\nvec3 angle_to_rgb(float num_0_to_1)\n{\n    vec3 brightness = vec3(0.6);\n    vec3 saturation = vec3(0.525);\n    vec3 rgb_phase = vec3(0.0, 0.33, 0.67);\n    return brightness + saturation * cos( TWOPI * (num_0_to_1 + rgb_phase) );\n}\n\n\n// -------------------------------------------------------------------------------\n// Sampling functions\n\nvec2 get_cartesian_coords(vec2 xy_px, vec3 res) {\n\n    /*\n    Maps xy 'pixel' coordinates (eg. fragCoord or iMouse)\n    into centered normalized cartesian (not stretched) coordinates.\n    Can think of the result as being 'graph paper' coordinates\n    - The center of the screen maps to (0, 0)\n    - The top of the screen has a y value of +1\n    - The bottom of the screen has a y value of -1\n    - The left & right edge x values will be -/+ the aspect ratio (ex: 16/9)\n    */\n\n    return (2.0*xy_px - res.xy) / res.y;\n}\n\nbool get_key_toggle(sampler2D keyboard_channel, int key_code) {\n    return bool(texelFetch(keyboard_channel, ivec2(key_code, 2), 0).x);\n}\n\nvec3 sample_video_warped(sampler2D channel, vec2 warp_uv, vec3 res) {\n\n    /*\n    Helper used to sample from videos using warped coordinates.\n    The coords are assumed to be calculated on a centered,\n    non-stretched coordinate system, which must be undone\n    to properly sample the video\n    */\n    \n    vec2 aspect_correction = vec2(res.y / res.x, 1.0);\n    vec2 sample_coords = 0.5 * (1.0 + warp_uv * aspect_correction);\n    return texture(channel, fract(sample_coords)).rgb;\n}\n\n\n// -------------------------------------------------------------------------------\n// Functions for complex number arthimetic\n\nvec2 mult2d(vec2 a, vec2 b) {\n\n    /*\n    Multiplication defined for 2D coordinates\n    (i.e. complex numbers)\n    \n    a = ax + i*ay\n    b = bx + i*by\n    \n    a*b = (ax + i*ay)*(bx + i*by)\n        = ax*bx + ax*i*by + i*ay*bx + i*ay*i*by\n        = ax*bx - ay*by + i*ax*by + i*ay*bx\n        = (ax*bx - ay*by) + i*(ax*by + ay*bx)\n    */\n    \n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);    \n}\n\nvec2 div2d(vec2 a, vec2 b) {\n\n    /*\n    Division defined for 2D coordinates\n    (i.e. complex numbers)\n    \n    a = ax + i*ay\n    b = bx + i*by\n    b' = bx - i*by  ->  (aka 'b conjugate')\n    \n    a   a   b'  ax + i*ay   bx - i*by \n    ─ = ─ * ─ = ───────── * ─────────\n    b   b   b'  bx + i*by   bx - i*by\n    \n        (ax*bx + ay*by) + i*(ay*bx - ax*by)\n      = ───────────────────────────────────\n                  bx*bx + by*by\n    */\n    \n    // Bail on divide-by-zero\n    if (is_near_zero(b.x) && is_near_zero(b.y)) {\n        return vec2(0,0);\n    }\n\n    float numer_real = a.x*b.x + a.y*b.y;\n    float numer_imag = a.y*b.x - a.x*b.y;\n    float denom = b.x*b.x + b.y*b.y;\n    \n    return vec2(numer_real, numer_imag)/denom;\n}\n\nvec2 exp2d(vec2 xy) {\n    float theta = atan(xy.y, xy.x);\n    return exp(xy.x)*vec2(cos(xy.y), sin(xy.y));\n}\n\nvec2 log2d(vec2 xy) {\n    // This is the natural log, aka ln\n    return vec2(log(length(xy)), atan(xy.y, xy.x));\n}\n\nvec2 sin2d(vec2 xy) {\n    vec2 iz = vec2(-xy.y, xy.x);\n    return div2d((exp2d(iz) - exp2d(-iz)), vec2(0,2));\n}\n\nvec2 cos2d(vec2 xy) {\n    vec2 iz = vec2(-xy.y, xy.x);\n    return 0.5*(exp2d(iz) + exp2d(-iz));\n}\n\nvec2 tan2d(vec2 xy) {\n    return div2d(sin2d(xy), cos2d(xy));\n}\n\nvec2 pow2d(vec2 xy, vec2 p) {\n\n    // Couldn't figure this one out on my own, it's from:\n    // https://mathworld.wolfram.com/ComplexExponentiation.html\n\n    // For convenience\n    float arg_z = atan(xy.y, xy.x);\n    float len_z = length(xy);\n    float len_zz = len_z*len_z;\n    \n    // For clarity\n    float arg_term = p.x*arg_z;\n    float ln_term = p.y*log(len_zz)*0.5;\n    float theta_term = arg_term + ln_term;\n    \n    float scale_term = pow(len_z, p.x) * exp(-p.y*arg_z);    \n    return scale_term * vec2(cos(theta_term), sin(theta_term));\n}\n\nvec2 get_polar(vec2 xy) {\n    \n    /*\n    Get polar coordinates from xy\n    Resulting magnitude is stored in .x, angle in .y\n    Note, the angle value is unitless, 0 to 1 (not radians!)\n    */\n\n    float magnitude = sqrt(length(xy));\n    float angle_minus_pi_to_pi = atan(-xy.y, xy.x);\n    float angle_norm = angle_minus_pi_to_pi/TWOPI;\n    \n    return vec2(magnitude, fract(angle_norm));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}