{
    "Shader": {
        "info": {
            "date": "1610576831",
            "description": "bcjal",
            "flags": 0,
            "hasliked": 0,
            "id": "WsBcWc",
            "likes": 1,
            "name": "SHaDoW",
            "published": 3,
            "tags": [
                "noob"
            ],
            "usePreview": 0,
            "username": "merrecurent_",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "float distance_from_figure(vec3 p, vec3 c_1, float r_1, vec3 c_2, float r_2, float altitude)\n{\n\treturn min(min(length(p-c_1) - r_1 + sin(5.0*p.x + 3.*iTime) * sin(5.*p.y-2.*iTime) * sin(4.*p.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)),\n               length(p-c_2) - r_2), p.y - altitude);\n}\n\nfloat map_the_world(vec3 p)\n{\t\n    float sphere_0 = distance_from_figure(p, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.);    \n    return sphere_0;\n}\n    \n\nvec3 calculate_normal (vec3 p)\n{\n\tconst vec3 small_step = vec3(.001, 0., 0.);\n    \n    float gradient_x = map_the_world(p + small_step.xyy)\n        \t\t\t - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy)\n        \t\t\t - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx)\n        \t\t\t - map_the_world(p - small_step.yyx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\n\nvec3 ray_march(vec3 ro, vec3 rd, vec3 backtrack)\n{\n\tfloat total_distance_traveled = 0.;\n    const int NUMBER_OF_STEPS = 250;\n    const float MINIMUM_HIT_DISTANCE = .001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.;\n    \n    for (int i=0; i < NUMBER_OF_STEPS; ++i)\n    {\n    \t//Calculate our current position along the ray\n        vec3 current_position = ro + total_distance_traveled*rd;\n        \n        //assume that sphere is centered at the origin\n        float distance_to_closest = map_the_world(current_position);\n        \n        if(distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            \n            //we hit smthg\n            \n            vec3 normal = calculate_normal(current_position);\n            vec3 light_position = vec3(5.*cos(iTime), -10., 5.*sin(iTime));\n            vec3 direction_to_light = normalize(current_position - light_position);\n            float diffuse_intensity = max(0., dot(normal, direction_to_light));\n            float spectral_intensity = pow(max(0., dot(normalize(rd), reflect(direction_to_light, normal))), 1.5);\n            \n            if (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.)\n                == length(current_position - vec3(0.)) - 1. + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)))\n            {\n            \t\n                \n            \t//each component of the normal will be in the -1<>1 range\n            \n            \treturn vec3(1., .5, .23)*(diffuse_intensity + spectral_intensity);\n                \n                \n                /*insert reflection function here\n                float reflection_distance = 0.;\n                const int MAX_REFLECTIONS_NUMBER = 10;\n                const float MAX_REFLECTION_DISTANCE = 1.;\n                const float REFLECTION_HIT = .0005;\n                \n                //backtrack_01 and _02 are going to be my new rd vector\n                \n                //to obtain the new current_position vector:\n                //vec3 current_pos_new = current_position + rd_new + direction_to_light;\n                if (dot(normal, backtrack) >= 0)\n                \tfor(int j=0; j < MAX_REFLETIONS_NUMBER; ++j)\n                \t{\n                \t\n                    \tvec3 current_pos_new = ro +  rd_new*reflection_distance;\n                    \tfloat distance_to_close_new = map_the_world(current_pos_new);\n                    \n                    \tif(distance_to_close_new < MINIMUM_HIT_DISTANCE)\n                    \t{\n                    \t\n                        \tvec3 normal_new = calculate_normal(current_position_new);\n                        \tfloat diffuse_intensity_new = max(0., dot(normal, direction_to_light));\n                        \n                        \tif (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.)\n                \t\t\t\t== length(current_position - vec3(0.)) - 1. + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)))\n            \t\t\t\t{\n                            \n                            \n                            \n                        \t}\n                        \n                    \t}\n                    \n                \t}\n                */\n                \n            }\n            \n            else if (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7,-2.) == length(current_position - vec3(4., 0., 4.)) - 1.7\n                                         && length(current_position) < 5.906775)\n            {\n            \treturn vec3(.07, .78, .07)*.8 + .5*diffuse_intensity;\n            }\n            else  //if it hits the plane\n            {\n                float distance_to_sphere = length(cross(current_position - light_position, light_position))/length(current_position - light_position)\n                    \t\t\t\t\t + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime));\n                if (distance_to_sphere < 1.) {\n                \treturn vec3(1., .5, .23)*.3 - diffuse_intensity;\n                }\n                    \n                else return vec3(1., .5, .23)*(.75 + .45*diffuse_intensity);\n            }\n        }\n        \n        if(total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        \n        total_distance_traveled += distance_to_closest;\n        \n    }\n    return vec3(.22, .69, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //set up camera\n    vec3 camera_position = vec3(0., 0., -5.);\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv.x, uv.y, 1.);\n    \n    vec3 backtrack = vec3(uv.x, uv.y, 1.);\n    \n    \n    vec3 shaded_color = ray_march(ro, rd, backtrack);\n    \n    fragColor = vec4(shaded_color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}