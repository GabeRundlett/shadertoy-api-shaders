{
    "Shader": {
        "info": {
            "date": "1481149777",
            "description": "Three different fractal materials bumped on 3D superformula generated shapes.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtcXRs",
            "likes": 9,
            "name": "[ #01 ] - SF 3D",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "fractal",
                "superformula"
            ],
            "usePreview": 0,
            "username": "Yrai",
            "viewed": 858
        },
        "renderpass": [
            {
                "code": "#define TIME iTime\n#define RES  iResolution\n#define PI 3.141592653589793\n\n#define MARCH_STEPS 128\n#define MARCH_RANGE 100.\n#define MARCH_PERC  .00001\n\n\n#define SUPERFORMULA_2D(m,a,b,n1,n2,n3,phi) pow(pow(abs(cos(m*phi/4.)/a), n2) + pow(abs(sin(m*phi/4.)/b), n3), -n1)\n\n\n#define X_ROT(a) mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a))\n#define Y_ROT(a) mat3(cos(a),0.,-sin(a),0.,1.,0.,sin(a),0.,cos(a))\n#define Z_ROT(a) mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.)\n\n\n#define DOMAIN(uv,s) (2.*uv-RES.xy)/RES.y*s\n\n\nfloat modelGeometry(vec3 pos);\nvec3 calcNormal(vec3 pos);\nfloat superformula3D(\n    vec3 p,\n    float m1, float a1, float b1, float n11, float n21, float n31,\n    float m2, float a2, float b2, float n12, float n22, float n32\n);\n\nvec3 shadeFractalBump(vec3 pos, vec3 rayDirection);\n\nvec3 rayDirection;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = DOMAIN(fragCoord, 2.);\n\tvec3 fpc = vec3(0.);\n    \n    /* Camera */\n   \tvec3 rayOrigin = vec3(3.0*sin(TIME), 3.*cos(TIME), -3.0*cos(TIME));\n\tvec3 ww = normalize(-rayOrigin);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rayDirection = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n    \n    /* Raymarching */\n    float currDistance = 1.;\n    float distanceMarched = 0.;\n    for(int i=0; i<MARCH_STEPS; i++) {\n    \tif(currDistance < MARCH_PERC || distanceMarched > MARCH_RANGE)\n            break;\n        \n        currDistance = modelGeometry(rayOrigin + distanceMarched * rayDirection);\n        distanceMarched += currDistance;\n    }\n    \n    /* Shading */\n    if(distanceMarched < MARCH_RANGE) {\n    \tvec3 pos = vec3(rayOrigin + distanceMarched * rayDirection);\n        fpc = shadeFractalBump(pos,rayDirection);\n    }\n    \n    fragColor = vec4(fpc,1.);\n}\n\nfloat modelGeometry(vec3 pos) {\n    float m1 = floor(mod(TIME,20.)+1.);\n    float m2 = floor(mod(TIME,20.)+1.);\n    float n11 = floor(abs(1.3*sin(TIME)))+1.;\n    float n12 = floor(abs(1.3*cos(TIME)))+1.;\n    \n    float d = superformula3D(pos,\n        m1,n11,1.,-1.,1.,10.,\n        m2,n12,1.,1.,1.,1.\n    );\n    float s = d*.5;\n    float dEps = superformula3D(pos + rayDirection*s,\n        m1,n11,1.,-1.,1.,10.,\n        m2,n12,1.,1.,1.,1.\n    );\n    float dr = (d-dEps)/s;\n    \n    return (d / (4.5+max(dr, 0.)));\n\n}\n\nfloat superformula3D(\n    vec3 p,\n    float m1, float a1, float b1, float n11, float n21, float n31,\n    float m2, float a2, float b2, float n12, float n22, float n32\n) {\n    float d = length(p); \n    float theta = atan(p.z/p.x); \n    float phi = asin(p.y/d); \n   \n    float r1 = SUPERFORMULA_2D(m1, a1, b1, n11, n21, n31, theta);\n    float r2 = SUPERFORMULA_2D(m2, a2, b2, n12, n22, n32, phi);\n    \n    vec3 q = r2 * vec3(r1*cos(theta)*cos(phi), r1*sin(theta)*cos(phi), sin(phi));\n\treturn (d - length(q));\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(MARCH_PERC, 0.0);\n    return normalize(vec3(\n        modelGeometry(pos + e.xyy) - modelGeometry(pos - e.xyy),\n        modelGeometry(pos + e.yxy) - modelGeometry(pos - e.yxy),\n        modelGeometry(pos + e.yyx) - modelGeometry(pos - e.yyx)\n    ));\n}\n\nvec3 fractalMaterial1(vec2 p) {\n\tfloat x = 0.;\n    float y = 0.;\n    float v = 100000.;\n    float j = 100000.;\n    vec3 col = vec3(0.);\n    for(int i=0; i<100;i++) {\n    \tfloat xt = x*x-y*y+p.x;\n        y = 2.*x*y+p.y;\n        x = xt;\n        v = min(v, abs(x*x+y*y));\n        j = min(j, abs(x*y));\n        if(x*x+y*y >= 8.) {\n        \tfloat d = (float(i) - (log(log(sqrt(x*x+y*y))) / log(2.))) / 50.;\n            v = (1. - v) / 2.;\n            j = (1. - j) / 2.;\n            col = vec3(d+j,d,d+v);\n            return col;\n        }\n    }\n}\n\nvec3 fractalMaterial2(vec2 p) {\n\tvec3 col = vec3(100);\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tp = abs(p)/dot(p, p) - vec2(0.5, 0.3);\n\t\tcol = min(col, vec3(abs(p.x), length(p), abs(3.0*p.y)));\n\t}\n\t\n\treturn col;\n}\n\nvec3 fractalMaterial3(vec2 uv) {\n    const int MAGIC_BOX_ITERS = 15;\n\tconst float MAGIC_BOX_MAGIC = .55;\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    uv.x += 0.4;\n    vec3 p = 0.5*M*vec3(uv, 1.0);\n        p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    tot *= 0.03;\n    return vec3(tot*uv.x, tot*tot, 4.*tot*uv.y*uv.y);\n}\n\nvec3 matcube(vec3 p, vec3 n) {\n\tvec3 m = pow(abs(n), vec3(10.0));\n\t\n    float timeSwitch = floor(mod(TIME,15.));\n    \n    vec3 x,y,z;\n    if(timeSwitch >=0. && timeSwitch <= 5.) {\n        x = fractalMaterial2(p.yz);\n        y = fractalMaterial2(p.xz);\n        z = fractalMaterial2(p.xy);\n    }\n    else if(timeSwitch >=5. && timeSwitch <= 10.){\n        x = fractalMaterial1(p.yz);\n        y = fractalMaterial1(p.xz);\n        z = fractalMaterial1(p.xy);\n    }\n    else {\n        x = fractalMaterial3(p.yz);\n        y = fractalMaterial3(p.xz);\n        z = fractalMaterial3(p.xy);\n    }\n    \n\treturn (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 matbump(vec3 p, vec3 n) {\n\tvec3 gs = vec3(0.21, 0.72, 0.07);\n\tvec2 h = vec2(0.015, 0.0);\n\t\n\tfloat res = dot(gs, matcube(p, n));\n\tmat3 m = mat3(\n\t\tmatcube(p - h.xyy, n),\n\t\tmatcube(p - h.yxy, n),\n\t\tmatcube(p - h.yyx, n)\n\t);\n\t\n\tvec3 g = (gs*m - res)/h.x;\n\tg -= n*dot(g, n);\n\t\n\treturn g;\n}\n\nvec3 shadeFractalBump(vec3 pos, vec3 rayDirection) {\n    vec3 nor = calcNormal(pos);\n    vec3 sn = normalize(nor + 0.04*matbump(pos, nor));\n    vec3 sn2 = normalize(nor + 0.4*matbump(pos, nor));\n    vec3 ref = normalize(reflect(rayDirection, sn));\n    \n    vec3 col = vec3(0.);\n    col += pow(clamp(dot(-rayDirection, ref), 0.0, 1.0), 10.0);\n    col += pow(clamp(1.0 + dot(rayDirection, sn2), 0.0, 1.0), 2.0);\n    col *=3.0*matcube(pos, nor);\n    return col;\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}