{
    "Shader": {
        "info": {
            "date": "1706265028",
            "description": "Editable B-spline curve - see source for usage",
            "flags": 32,
            "hasliked": 0,
            "id": "Xc2SWh",
            "likes": 24,
            "name": "Spline Editor",
            "published": 3,
            "tags": [
                "interactive",
                "bspline"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 440
        },
        "renderpass": [
            {
                "code": "// \"Spline Editor\" by dr2 - 2024\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n Use mouse to move spline control points and orient view.\n Buttons:\n   red/green - view or edit mode\n   yellow/blue/gray - change control point horizontal position or height, or inactive\n In edit mode, click near dark spot on base to select control point\n (Based on \"Spline Waltz\")\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrEECaps2Df (vec2 p, vec2 v1, vec2 v2, float rc);\nvec4 SphHit (vec3 ro, vec3 rd, float rad);\nvec4 CylHit (vec3 ro, vec3 rd, float rad, float len);\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len);\nfloat Maxv2 (vec2 p);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nvec2 Rot2D (vec2 q, float aa);\nmat3 StdVuMat (float el, float az);\nvec4 Loadv4 (int idVar);\n\nvec3 ltDir;\nvec2 mProj;\nfloat tCur, dstFar;\nint nFrame, idObj, nSubdiv, nCPoint, fDat, mouseProj, mouseSel, idCHit, cpSel;\nconst int idTrSeg = 1, idCPoint = 2, idVCol = 3, idCon = 4, idBas = 5;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec3 GetCnPoint (int n)\n{\n  return Loadv4 (n + fDat).xyz;\n}\n\nvec3 GetTrkPt (int n)\n{\n  return Loadv4 (n + nCPoint + fDat).xyz;\n}\n\nvec4 ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 rMat;\n  vec4 db4;\n  vec3 vn, vnn, rc, rt;\n  float dMin, dm, len;\n  int nTrSeg, kk;\n  nTrSeg = nCPoint * nSubdiv;\n  dMin = dstFar;\n  dm = dstFar;\n  rc = GetTrkPt (nTrSeg - 1);\n  for (int k = VAR_ZERO; k < nTrSeg; k ++) {\n    rt = rc;\n    rc = GetTrkPt (k);\n    len = length (rc - rt);\n    rMat = DirToRMatT ((rc - rt) / len, vec3 (0., 0., 1.));\n    db4 = CapsHit ((ro - 0.5 * (rc + rt)) * rMat, rd * rMat, 0.08, 0.5 * len);\n    if (db4.x < dm) {\n      dm = db4.x;\n      vnn = rMat * normalize (db4.yzw);\n    }\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vnn;\n    idObj = idTrSeg;\n  }\n  dm = dstFar;\n  for (int k = VAR_ZERO; k < nCPoint; k ++) {\n    db4 = SphHit (ro - GetCnPoint (k), rd, 0.07);\n    if (db4.x < dm) {\n      dm = db4.x;\n      vnn = db4.yzw;\n    }\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vnn;\n    idObj = idCPoint;\n  }\n  dm = dstFar;\n  for (int k = VAR_ZERO; k < nCPoint; k ++) {\n    rc = GetCnPoint (k);\n    db4 = CylHit ((ro - rc * vec3 (1., 0.5, 1.)).xzy, rd.xzy, 0.04, 0.5 * rc.y);\n    if (db4.x < dm) {\n      dm = db4.x;\n      vnn = db4.ywz;\n      idCHit = k;\n    }\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vnn;\n    idObj = idVCol;\n  }\n  dm = dstFar;\n  for (int k = VAR_ZERO; k < nCPoint; k ++) {\n    rc = GetCnPoint (k);\n    kk = nSubdiv * (k - 1);\n    if (kk < 0) kk += nTrSeg;\n    rt = GetTrkPt (kk);\n    len = length (rc - rt);\n    rMat = DirToRMatT ((rc - rt) / len, vec3 (0., 0., 1.));\n    db4 = CapsHit ((ro - 0.5 * (rc + rt)) * rMat, rd * rMat, 0.03, 0.5 * len);\n    if (db4.x < dm) {\n      dm = db4.x;\n      vnn = rMat * normalize (db4.yzw);\n    }\n  }\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vnn;\n    idObj = idCon;\n  }\n  dm = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  if (dm < dMin) {\n    dMin = dm;\n    vn = vec3 (0., 1., 0.);\n    idObj = idBas;\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 db4;\n  vec3 col, vn;\n  vec2 sc, sp;\n  float t, h;\n  int nTrSeg;\n  nTrSeg = nCPoint * nSubdiv;\n  db4 = ObjHit (ro, rd);\n  if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    if (idObj == idTrSeg) {\n      col = vec3 (0.2, 1., 0.2);\n    } else if (idObj == idCPoint) {\n      col = vec3 (1., 0.2, 0.2);\n    } else if (idObj == idVCol) {\n      col = vec3 (0.4, 0.4, 1.);\n      h = GetCnPoint (cpSel).y;\n      if (cpSel == idCHit && (mouseSel == 1 && ro.y < 0.5 && fract (2. * tCur) < 0.7 ||\n         mouseSel == 2 && abs (ro.y - 2. * h * abs (fract (0.5 * tCur) - 0.5)) < 0.1 * h))\n         col = vec3 (1., 0.5, 0.3);\n    } else if (idObj == idCon) {\n      col = vec3 (1., 1., 0.2);\n    } else if (idObj == idBas) {\n      col = vec3 (0.45, 0.45, 0.5) * (1. - smoothstep (9.5, 10., length (ro.xz))) *\n         (1. - 0.1 * step (0.47, Maxv2 (abs (fract (2. * ro.xz) - 0.5))));\n      t = 1.;\n      for (int k = VAR_ZERO; k < nCPoint; k ++) t = min (t, length (ro.xz - GetCnPoint (k).xz));\n      col *= 0.7 + 0.3 * smoothstep (0.1, 0.12, t);\n      t = 1.;\n      sc = GetTrkPt (nTrSeg - 1).xz;\n      for (int k = VAR_ZERO; k < nTrSeg; k ++) {\n        sp = sc;\n        sc = GetTrkPt (k).xz;\n        t = min (t, PrEECaps2Df (ro.xz, sp, sc, 0.02));\n      }\n      col *= 0.5 + 0.5 * smoothstep (0., 0.02, t);\n      if (mouseSel > 0) {\n        t = length (ro.xz - mProj);\n        if (t < 0.2) col *= (mouseSel == 1) ? vec3 (2., 1.5, 1.) : vec3 (1., 1.5, 2.);\n      }\n    }\n    col *= (0.5 + 0.5 * max (dot (vn, ltDir), 0.));\n  } else {\n    col = vec3 (0.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 wgBxC[2], ro, rd, col, oPos;\n  vec2 canvas, uv, cc;\n  float el, az, zmFac, sr, asp;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  nSubdiv = int (stDat.x);\n  nCPoint = int (stDat.y);\n  cpSel = int (stDat.z);\n  stDat = Loadv4 (1);\n  mPtr.xyz = stDat.xyz;\n  mouseProj = int (stDat.w);\n  mouseSel = mouseProj;\n  if (mPtr.z <= 0.) mouseSel = 0;\n  stDat = Loadv4 (2);\n  el = stDat.x;\n  az = stDat.y;\n  mProj = stDat.zw;\n  oPos = Loadv4 (3).xyz;\n  wgBxC[0] = Loadv4 (4).xyz;\n  wgBxC[1] = Loadv4 (5).xyz;\n  fDat = 6;\n  zmFac = 4.;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * oPos;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float aa = float (VAR_ZERO); aa < naa; aa ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * aa + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  cc = vec2 (1., 0.2);\n  col = mix (((mouseProj > 0) ? cc.yxy : cc.xyy * (0.5 + 0.5 * step (0.3, fract (2. * tCur)))),\n     col, smoothstep (2., 2.2, abs (length (0.5 * uv - wgBxC[0].xy) - wgBxC[0].z) * canvas.y));\n  col = mix (((mouseProj > 0) ? ((mouseProj == 1) ? cc.xxy : cc.yyx) : 2. * cc.yyy),\n     col, smoothstep (2., 2.2, abs (length (0.5 * uv - wgBxC[1].xy) - wgBxC[1].z) * canvas.y));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrEVCaps2Df (vec2 p, vec3 u, float rc)\n{\n  return length (p - clamp (dot (p, u.xy), 0., u.z) * u.xy) - rc;\n}\n\nfloat PrEECaps2Df (vec2 p, vec2 v1, vec2 v2, float rc)\n{\n  return PrEVCaps2Df (p - v1, vec3 (normalize (v2 - v1), length (v2 - v1)), rc);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float c, d, t;\n  c = dot (rd, ro);\n  t = c * c + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (t > 0.) {\n    d = - c - sqrt (t);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, vn;\n  float dMin, d, c1, c2, t, srdz;\n  dMin = dstFar;\n  c1 = dot (rd.xy, rd.xy);\n  c2 = dot (rd.xy, ro.xy);\n  t = c2 * c2 - c1 * (dot (ro.xy, ro.xy) - rad * rad);\n  if (t > 0.) {\n    srdz = sign (rd.z);\n    if (c1 > 0.) {\n      d = - c2 - sqrt (t);\n      if (d > 0.) {\n        d /= c1;\n        s = ro + d * rd;\n      } else s.z = len;\n    } else s.z = len;\n    if (abs (s.z) < len) {\n      dMin = d;\n      vn = vec3 (s.xy / rad, 0.);\n    } else if (srdz * ro.z < - len) {\n      d = - (srdz * ro.z + len) / abs (rd.z);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xy) < rad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdz);\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, vn;\n  float dd, d, c1, c2, t;\n  dd = dstFar;\n  c1 = dot (rd.xy, rd.xy);\n  c2 = dot (rd.xy, ro.xy);\n  t = c2 * c2 - c1 * (dot (ro.xy, ro.xy) - rad * rad);\n  if (t > 0. && c1 > 0.) {\n    d = - c2 - sqrt (t);\n    d /= c1;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dd = d;\n      vn = vec3 (s.xy, 0.);\n    } else {\n      ro.z -= len * sign (s.z);\n      c2 = dot (rd, ro);\n      t = c2 * c2 - (dot (ro, ro) - rad * rad);\n      if (t > 0.) {\n        d = - c2 - sqrt (t);\n        if (d > 0.) {\n          dd = d;\n          vn = ro + d * rd;\n        }\n      }\n    }\n  }\n  return vec4 (dd, vn);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = normalize (cross (vu, vd));\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nvec2 Rot2D (vec2 q, float aa)\n{\n  vec2 cs;\n  cs = sin (aa + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define YK min(HV,0)\n#define RS iChannel0\n#define Vo iChannelResolution[0].xy\nfloat Qh;int HV,Lr,Gk,XY;const float TD=128.;const float Xq=3.1415927;vec2 FT(vec2 Cx,float BL){vec2 NK;NK=sin(BL+vec2(0.5*Xq,0.));return vec2(dot(Cx,vec2(NK.x,-NK.y)),dot(Cx.yx,NK));}mat3 Ow(float SR,float Fh){vec2 Sj,GS,Jp;Sj=vec2(SR,Fh);GS=cos(Sj);Jp=sin(Sj);return mat3(GS.y,0.,-Jp.y,0.,1.,0.,Jp.y,0.,GS.y)*mat3(1.,0.,0.,0.,GS.x,-Jp.x,0.,Jp.x,GS.x);}vec4 SA(int LI){float ZJ;ZJ=float(LI);return texture(RS,(vec2(mod(ZJ,TD),floor(ZJ/TD))+0.5)/Vo);}void La(int LI,vec4 WZ,inout vec4 UC,vec2 Wn){vec2 Pv;float ZJ;ZJ=float(LI);Pv=abs(Wn-vec2(mod(ZJ,TD),floor(ZJ/TD))-0.5);if(max(Pv.x,Pv.y)<0.5)UC=WZ;}vec3 GB(int Ez){return SA(Ez+XY).xyz;}vec3 Im(int Ez){vec3 TU;float Bu;Bu=float(Ez)/float(Gk);TU.xz=FT(vec2(4.+2.*sin(10.*Xq*Bu),0.),2.*Xq*Bu);TU.xz+=FT(vec2(1.,0.),2.*Xq*(11.*Bu));TU.y=1.6+0.4*sin(8.*Xq*float(Ez)/float(Gk))+1.*sin(2.*Xq*(13.*Bu));return TU;}vec3 JX(int Ez){vec3 w[4];float Pv,HE;int Pe;Pe=Ez/Lr;Pv=float(Ez-Pe*Lr)/float(Lr);for(int QP=0;QP<=3;QP++){w[QP]=GB(Pe);if(++Pe==Gk)Pe=0;}for(int JG=0;JG<3;JG++){HE=1./float(3-JG);for(int QP=0;QP<3-JG;QP++)w[QP]=mix(w[QP+1],w[QP],(float(QP+1)-Pv)*HE);}return w[0];}void mainImage(out vec4 Df,in vec2 EQ){mat3 Cg;vec4 ML,Zs,Bd;vec3 DR[2],Av,Qy,Ei,VF;vec2 Nt,ID,XH;float Fh,SR,FC,Dw,Rg,Pv,CO;int AM,Nc,VW,LZ,Ko,Zb;Nt=floor(EQ);AM=int(Nt.x+TD*Nt.y);XY=6;Lr=8;Gk=20;Nc=Gk*Lr;Zb=AM-XY;if(Nt.x>=TD||Zb>=Gk+Nc)discard;\nHV=iFrame;ID=iResolution.xy;Qh=iTime;Zs=iMouse;Zs.xy=Zs.xy/ID-0.5;\nDw=ID.x/ID.y;if(HV<=1){Fh=0.;SR=-0.15*Xq;Qy=vec3(0.,0.2,-20.);VW=0;CO=0.;LZ=-1;DR[0]=vec3(0.46*Dw,0.44,0.022);DR[1]=vec3(0.46*Dw,0.35,0.022);if(Zb>=0&&Zb<Gk)VF=Im(Zb);}else{ML=SA(0);LZ=int(ML.z);CO=ML.w;ML=SA(1);Bd.xyz=ML.xyz;VW=int(ML.w);ML=SA(2);SR=ML.x;Fh=ML.y;Qy=SA(3).xyz;DR[0]=SA(4).xyz;DR[1]=SA(5).xyz;if(Zb>=0&&Zb<Gk)VF=GB(Zb);}if(Zs.z>0.){if(length(Zs.xy*vec2(Dw,1.)-DR[0].xy)<DR[0].z){if(Bd.z<=0.)VW=(VW>0)?0:1;}else if(length(Zs.xy*vec2(Dw,1.)-DR[1].xy)<DR[1].z){if(Bd.z<=0.&&VW>0)VW=(VW==1)?2:1;}else if(VW==0){Fh=2.*Xq*Zs.x;SR=-0.15*Xq+Xq*Zs.y;}}else if(VW==0){Fh=0.2*Xq*sin(0.01*2.*Xq*Qh);}SR=clamp(SR,-0.4*Xq,-0.05*Xq);FC=4.;if(Zs.z>0.&&VW>0){Cg=Ow(SR,Fh);Ei=Cg*Qy;Av=Cg*normalize(vec3(2.*Zs.xy*vec2(Dw,1.),FC));XH=(Ei.xz-(Ei.y/Av.y)*Av.xz);if(Bd.z<=0.){CO=Zs.y;Rg=1.;for(int QP=YK;QP<Gk;QP++){Pv=length(XH-GB(QP).xz);if(Pv<Rg){Rg=Pv;Ko=QP;}}if(Rg<0.4)LZ=Ko;else LZ=-1;}if(LZ>=0&&LZ==Zb){if(VW==1)VF.xz=XH;else if(VW==2)VF.y=clamp(VF.y+0.5*(Zs.y-CO),0.1,5.);}}if (AM==0)ML=vec4(float(Lr),float(Gk),float(LZ),CO);else if(AM==1)ML=vec4(Zs.xyz,float(VW));else if(AM==2)ML=vec4(SR,Fh,XH);else if(AM==3)ML=vec4(Qy,0.);else if(AM==4)ML=vec4(DR[0],0.);else if(AM==5)ML=vec4(DR[1],0.);else if(Zb<Gk)ML=vec4(VF,0.);else if(Zb<Gk+Nc)ML=vec4(JX(Zb-Gk),0.);La(AM,ML,Df,EQ);}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}