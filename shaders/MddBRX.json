{
    "Shader": {
        "info": {
            "date": "1526220186",
            "description": "GLSL Sound Practice",
            "flags": 8,
            "hasliked": 0,
            "id": "MddBRX",
            "likes": 9,
            "name": "GLSL Sound1",
            "published": 3,
            "tags": [
                "sound"
            ],
            "usePreview": 0,
            "username": "setchi",
            "viewed": 730
        },
        "renderpass": [
            {
                "code": "#define BPM 130.0\n\nvec2 rotate(vec2 st, float angle)\n{\n    st -= 0.5;\n    st *= mat2(cos(angle), -sin(angle),\n               sin(angle),  cos(angle));\n    st += 0.5;\n    return st;\n}\n\nvec2 move(vec2 st, float offset)\n{\n    float t = iTime;\n    return st + vec2(sin(offset + t),\n                     sin(offset + t * 3.));\n}\n\nfloat hex(vec2 st, float r)\n{\n    st = rotate(st, iTime * 3.);\n    st = abs(st);\n    return max(st.x - r, max(st.x + st.y * 0.57735, st.y * 1.1547) - r);\n}\n\nfloat circle(vec2 st, float size)\n{\n    return step(length(0. - st), size);\n}\n\nfloat ripple(vec2 st, float t, float offs)\n{\n    float d = hex(st, 0.005);\n    float outer = step(d, mix(0.20 + offs, 0.45 + offs, t) * 3.);\n    float inner = step(d, mix(0.15 - offs, 0.50 - offs, t) * 3.);\n    return clamp(outer - inner, 0., 1.);\n}\n\nvec2 hex_ripple(vec2 st, float t)\n{\n    vec2 ret;\n    const int n = 5;\n\n    for (int i = 0; i < n; i++)\n    {\n    \tret.x += ripple(move(st, float(i) * 2.), t, 0.01);\n    \tret.y += ripple(move(st, float(i) * 2.), t, 0.);\n    }\n\n    return clamp(ret, 0., 1.);\n}\n\nvec4 palette(int index)\n{\n    index = int(mod(float(index), 5.));\n    if (index == 0) return vec4(1.00, 0.18, 0.42, 1);\n    if (index == 1) return vec4(0.41, 0.08, 0.35, 1);\n    if (index == 2) return vec4(1.00, 0.88, 0.00, 1);\n    if (index == 3) return vec4(0.41, 0.08, 0.35, 1);\n    if (index == 4) return vec4(1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    st.x *= iResolution.x / iResolution.y;\n\n    float beat = iTime * BPM / 60.0;\n    float measure = floor((beat + 1.) / 8.);\n\n    float kick = mod(beat,1.) * 1.2;\n    float hihat = mod(beat + 0.5, 1.) * 0.2;\n\n    float color = 0.;\n    color = mix(color, 1., circle(st, mix(0.83, 0.63, kick + hihat)));\n    color = mix(color, 2., circle(st, mix(0.80, 0.60, kick + hihat)));\n\n    float bass = max(.0, mod(beat - 1., 8.) - 7.);\n    if (bass > 0.)\n    {\n        color = mix(color, 3., hex_ripple(st, bass).x);\n        color = mix(color, 4., hex_ripple(st, bass).y);\n    }\n\n    fragColor = palette(int(color + mod(measure, 2.)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ------\n\n// Thanks to https://github.com/FMS-Cat/20180310-glsl-music/\n\n#define PI 3.141592654\n#define TAU 6.283185307\n#define BPM 130.0\n\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define saturateA(i) clamp(i,-1.,1.)\n#define lofi(i,j) floor((i)/j)*j\n#define b2t(i) ((i)/BPM*60.0)\n#define noten(i) 440.0*pow(2.0,(float(i)+trans)/12.0)\n\n// -----\n\n// general functions\n\nvec4 random2D( vec2 _v ) {\n  return vec4(fract(sin(dot(_v, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\nvec4 random( float _v ) {\n  return random2D( _v * V.yy );\n}\n\n// -----\n\n// Instruments\n\nvec2 kick2( float _phase ) {\n  if ( _phase < 0.0 ) { return V.xx; }\n  return V.yy * sin( _phase * 300.0 - exp( -_phase * 100.0 ) * 30.0 ) * exp( -_phase * 5.0 );\n}\n\nvec2 snare( float _phase ) {\n  if ( _phase < 0.0 ) { return V.xx; }\n  return saturateA( (\n    random( _phase / 0.034 ).xy +\n    sin( _phase * 2500.0 * vec2( 1.005, 0.995 ) - exp( -_phase * 400.0 ) * 30.0 )\n  ) * 2.0 * exp( -_phase * 23.0 ) );\n}\n\nvec2 hihat( float _seed, float _dec ) {\n  return random( _seed ).xy * exp( -_dec );\n}\n\nvec2 bass( float _freq, float _phase ) {\n  if ( _phase < 0.0 ) { return V.xx; }\n  vec2 p = _freq * vec2( 0.999, 1.001 ) * _phase * TAU;\n  float dl = exp( -_phase * 1.0 );\n  float ds = exp( -_phase * 14.0 );\n  return sin(\n    p +\n    sin( p ) * 1.5 * dl +\n    sin( p + sin( p * 10.0 ) * 2.5 * ds ) * 3.0 * ds +\n    sin( p + sin( p * 18.0 ) * 1.5 * ds ) * 0.5 * dl\n  ) * 0.5 * dl;\n}\n\n// -----\n\nvec2 mainSound( in int samp,float time) {\n  float t = time;\n    \n  float beat = t * BPM / 60.0;\n  float beatf = fract(beat);\n  float measure = floor(beat / 4.0);\n  \n  vec2 ret = V.xx;\n  float trans = 3.0;\n\n  float kickTime = b2t(beatf);\n  ret += kick2(kickTime);\n\n  float bassTime = max(.0, mod(beat - 1., 8.) - 7.);\n  ret += bassTime * bass(noten(-29), b2t(lofi(beatf, 0.001)) * 0.5);\n\n  if (mod(beat, 8.) > 7.) {\n    ret += snare(b2t(max(.0, mod(beat, 8.) - 7.)));\n\n  } else {\n  \tret += hihat(time, b2t(mod(beat + 0.5, 1.) * 50.));\n  }\n\n  return saturateA(ret);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}