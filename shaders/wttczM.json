{
    "Shader": {
        "info": {
            "date": "1608853572",
            "description": "tracejopaewjpoajwerojawerawerw",
            "flags": 0,
            "hasliked": 0,
            "id": "wttczM",
            "likes": 1,
            "name": "Ray marched mirror spheres",
            "published": 3,
            "tags": [
                "tracejopaewjpoajwerojawerawerw"
            ],
            "usePreview": 0,
            "username": "cas",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "//created by Cas Brugman\n//WIP\n\n    //constants\nconst float PI = 3.14159;\nconst int RAY_MAX_STEPS = 500;\nconst float RAY_COLLISION_DISTANCE = 0.01;\nconst float RAY_MAX_DISTANCE = 1000.0;\n\n    //enum\nconst int TYPE_SPHERE = 0;\nconst int TYPE_FLOOR = 1;\n\n\n    //vec3 helpers\nvec3 RotateVec3X(vec3 vec, float rotation)\n{\n    mat3 mat;\n    mat[0] = vec3(1, 0, 0);\n    mat[1] = vec3(0, cos(rotation), -sin(rotation));\n    mat[2] = vec3(0, sin(rotation), cos(rotation));\n    \n    return vec * mat;\n}\n\nvec3 RotateVec3Y(vec3 vec, float rotation){\n    mat3 mat;\n    mat[0] = vec3(cos(rotation), 0, sin(rotation));\n    mat[1] = vec3(0, 1, 0);\n    mat[2] = vec3(-sin(rotation), 0, cos(rotation));\n    \n    return vec * mat;\n}\n\n    //structs\nstruct Sphere \n{\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\nstruct Floor\n{\n    float height;\n    vec3 color;\n};\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float fov;\n};\n\n    //directions\nvec3 CameraDirection()\n{\n    vec2 mouseUV = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    if(mouseUV == vec2(0,0))\n    {\n        mouseUV = vec2(.5, .5);\n    }\n    \n    vec2 angle = vec2(-mouseUV.x * PI * 2.0, -mouseUV.y * PI + PI / 2.0);\n    \n    vec3 vec = vec3(0,0,1);\n    vec = RotateVec3X(vec, angle.y);\n    vec = RotateVec3Y(vec, angle.x);\n    \n    return vec;\n}\n\nvec3 RayDirection(vec3 direction, vec2 UV, float fov)\n{\n    vec2 signedUV = UV * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 aspectSignedUV = vec2(signedUV.x, signedUV.y / aspect);\n    vec2 offset = aspectSignedUV * tan(fov / 2.0);\n    \n    vec3 front = (direction);\n    vec3 right = normalize(cross(front, vec3(0,1,0)));\n    vec3 up = cross(right, front);\n    \n    return normalize(front + right * offset.x + up * offset.y);\n}\n\n    //scene\nSphere[] spheres = Sphere[]\n(\n    Sphere(vec3(0,0,-5), 1.0, vec3(1,0,0)),\n    Sphere(vec3(0,1.7,-5), 0.5, vec3(0,0,1)),\n    Sphere(vec3(2,0,-5), 0.5, vec3(1,1,0))\n\n);\n    \nFloor[] floors = Floor[]\n(\n    Floor(-1.2, vec3(0,1,1))\n);\n    \n        //distance functions\nfloat distanceSphere(vec3 position, Sphere sphere)\n{\n    return distance(position, sphere.position) - sphere.radius;\n}\n    \nint ClosestSphere(vec3 position)\n{\n    float dist = RAY_MAX_DISTANCE;\n    int closest;\n    for(int i = 0; i < spheres.length(); i++)\n    {\n        Sphere sphere = spheres[i];\n        float currentDist = distanceSphere(position, sphere);\n        if (dist > currentDist)\n        {\n            dist = currentDist;\n            closest = i;\n        }\n    }\n        \n    return closest;\n}\n\nfloat distanceFloor(vec3 position, Floor floorr)\n{\n    return distance(position.y, floorr.height);\n}\n\nint ClosestFloor(vec3 position)\n{\n    float dist = RAY_MAX_DISTANCE;\n    int closest;\n    for(int i = 0; i < floors.length(); i++)\n    {\n        Floor floorr = floors[i];\n        float currentDist = distanceFloor(position, floorr);\n        if (dist > currentDist)\n        {\n            dist = currentDist;\n            closest = i;\n        }\n    }\n        \n    return closest;\n}\n\n    //raymarch\nstruct MarchResult\n{\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    int type;\n    int id;\n};\n\nMarchResult March(vec3 origin, vec3 direction)\n{\n    vec3 position = origin;\n    Sphere sphere;\n    float currentDistance = RAY_MAX_DISTANCE;\n    int id = -1;\n    int type = -1;\n        \n    for(int iStep = 0; distance(origin, position) < RAY_MAX_DISTANCE && iStep < RAY_MAX_STEPS; iStep++)\n    {\n        id = ClosestSphere(position);\n        \n        type = TYPE_SPHERE;\n        currentDistance = distanceSphere(position, spheres[id]);\n        \n        if(currentDistance < RAY_COLLISION_DISTANCE)\n        {\n            break;\n        }\n        \n        id = ClosestFloor(position);\n        type = TYPE_FLOOR;\n        currentDistance = min(currentDistance, distanceFloor(position, floors[id]));\n        \n        if(currentDistance < RAY_COLLISION_DISTANCE)\n        {\n            break;\n        }\n                \n        position += direction * currentDistance;\n    }\n    \n    bool hit = currentDistance < RAY_COLLISION_DISTANCE;\n    vec3 normal = vec3(0);\n    \n    if (type == TYPE_SPHERE)\n    {\n        normal = normalize(position - spheres[id].position);\n    }\n    \n    if (type == TYPE_FLOOR)\n    {\n        normal = vec3(0,1,0);\n    }\n    \n    return MarchResult(hit, position, normal, type, id);\n}\n\nvec3 Ray2(vec3 origin, vec3 direction)\n{\n    MarchResult result = March(origin, direction);\n    \n    vec3 color = texture(iChannel0, direction).rgb;\n    \n    if (result.hit){\n    \n        if (result.type == TYPE_SPHERE)\n        {\n            color = spheres[result.id].color;            \n        }\n\n        if (result.type == TYPE_FLOOR)\n        {\n            color = floors[result.id].color;\n        }\n        \n        //color = result.normal;\n        \n    }\n    \n    return color; \n}\n\nvec3 Ray(vec3 origin, vec3 direction)\n{\n    MarchResult result = March(origin, direction);\n    \n    vec3 color = texture(iChannel0, direction).rgb;\n    \n    if (result.hit){\n        //color = spheres[result.id].color * dot(result.normal, vec3(0,1,0));\n        color = Ray2(result.position + result.normal * 0.2, reflect(direction, result.normal));            \n        \n        \n        //color = result.normal;\n        \n    }\n    \n    return color;   \n}\n\n    //main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord/iResolution.xy;\n    \n    float factor = 0.5;\n    float dist = 2.0;\n    vec3 position = vec3(sin(iTime * factor) * dist, sin(iTime * 0.2) + 1.0 , cos(iTime * factor) * dist);\n    \n    Camera camera = Camera(position, CameraDirection(), radians(90.0));\n    fragColor.rgb = Ray(camera.position, RayDirection(camera.direction, UV, camera.fov));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}