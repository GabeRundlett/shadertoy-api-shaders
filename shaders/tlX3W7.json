{
    "Shader": {
        "info": {
            "date": "1572574371",
            "description": "A MOS 6502 emulator with Apple 1 emulation sort of tacked on.\nBoots into Woz Monitor, type E000R to start BASIC.\nSee code comments for details.",
            "flags": 48,
            "hasliked": 0,
            "id": "tlX3W7",
            "likes": 106,
            "name": "Apple I Emulator",
            "published": 3,
            "tags": [
                "basic",
                "terminal",
                "apple",
                "emulator",
                "6502"
            ],
            "usePreview": 1,
            "username": "Flyguy",
            "viewed": 26355
        },
        "renderpass": [
            {
                "code": "/*\nSee Common tab for emulator settings, visual settings can be found below.\n\n--------------------------------\n\nDebugging values on the right:\nProgram Counter, Opcode, Average Speed (% of max), Average Speed (instuctions/sec)\n\nAccumulator, X Index, Y Index, Stack Pointer\n\nFlags (NV1BDIZC)\n\n--------------------------------\n\nBuffers:\nA - \"Microcode\" lookup table\nB - RAM/IO\nC - 6502 Emulator\n\n--------------------------------\n\nSome details on using Wozmon:\nhttps://www.sbprojects.net/projects/apple1/wozmon.php\n\nSome basic commands in Wozmon (# = hex digit)\n#### <enter> -> Examine specifed address. (ex. FF00)\n####.#### <enter> -> Examine address range. (ex. FF00.FFFF)\n####:## ## ... <enter> -> Deposit values at specified address. (ex. 0010:00 01 02 ..)\n####R <enter> -> Start execution at specified address (ex. E000R)\n\n--------------------------------\n\nApple I Integer BASIC Manual:\nhttps://archive.org/stream/apple1_basic_manual/apple1_basic_manual_djvu.txt\n\n\"Hello World\" example:\n10 PRINT\"HELLO, WORLD!\"\n20 GOTO 10\nRUN\n\n--------------------------------\n\nFAQ:\nWhy doesn't backspace work?\n> Backspace is supported by Wozmon/Basic, they print \"_\"s to indicate deleted characters.\n  The Apple 1's terminal hardware didn't support deleting characters, the emulator reflects this behavior.\n\nThe text on screen doesn't match what I'm typing.\n> The keyboard texture only provides the keycode, which doesn't have a direct relation to the character typed.\n  There's a mapping table for US QWERTY and AZERTY, each different layout would need it's own mapping table.\n\nHow fast is it?\n> By default, it's set to 600 instructions per frame, at 60fps this is roughly equivalent to a 6502 at 0.072MHz.\n  If your GPU can handle it, increasing CYCLES to 8333 would be roughly equivalent to a 6502 at 1MHz.\n  CACHE_SIZE will need to be increased as well otherwise it will bottleneck the CPU, reducing speed as a result.\n  \n> The emulated terminal is set to handle 40 chars/frame, whereas the Apple 1's terminal could only handle 1 char/frame.\n  This can be adjusted by changing DSPBUF_SIZE.\n*/\n\n//Display settings\n#define CHAR_SIZE vec2(2.0/3.0,1.0)     //Terminal character size\n#define TERM_TCOL vec4(0.0,1.0,0.5,0.0) //Terminal text color\n#define TERM_BCOL (TERM_TCOL*0.1)       //Terminal background color\n#define TERM_SCANVIS 0.75               //Scanline visibility (0 = off)\n#define TEXT_SCALE vec2(0.03,0.05)      //Text size for debug prints\n\nvec2 gUV = vec2(0);\nvec4 gFrag = vec4(0);\n\n//Print a hexadecimal value 'v' at point 'p' with 'n' digits\nvoid PrintHex(vec2 p, float v, float n)\n{\n    vec2 uv = gUV;\n    uv -= p;\n    v = abs(floor(v));\n    vec2 t = floor(uv / TEXT_SCALE);\n    float ox = (1.0 - (TEXT_SCALE.x/TEXT_SCALE.y))/2.;\n    uv = mod(uv, TEXT_SCALE) / TEXT_SCALE.y;\n    uv.x += ox;\n    if(t.y == 0.0 && t.x >= 0.0 && t.x < n)\n    {\n        float d = mod(floor(v / pow(16.0, n - 1.0 - t.x)), 16.0);\n        vec2 choff = (d < 10.0) ? vec2(d, 12.0) : vec2(d - 9.0, 11.0);\n        gFrag += texture(iChannel2, ((uv + choff)/16.0), -100.0).r;\n    }\n}\n\n//Print a decimal value 'v' at point 'p'\nvoid PrintDec(vec2 p, float v)\n{\n    vec2 uv = gUV;\n    uv -= p;\n    v = abs(floor(v));\n    vec2 t = floor(uv / TEXT_SCALE);\n    float ox = (1.0 - (TEXT_SCALE.x/TEXT_SCALE.y))/2.;\n    uv = mod(uv, TEXT_SCALE) / TEXT_SCALE.y;\n    uv.x += ox;\n    float dl = max(1.0,1.0+floor(0.001+log(v)/log(10.0)));\n    if(t.y == 0.0 && t.x >= 0.0 && t.x < dl)\n    {\n        float d = mod(floor(v / pow(10.0, dl - t.x - 1.0)), 10.0);\n        \n        gFrag += texture(iChannel2, ((uv + vec2(d,12))/16.0), -100.0).r;\n    }\n}\n\n//Print a binary value 'v' at point 'p' with 'n' digits\nvoid PrintBin(vec2 p, float v, float n)\n{\n    vec2 uv = gUV;\n    uv -= p;\n    v = abs(floor(v));\n    vec2 t = floor(uv / TEXT_SCALE);\n    float ox = (1.0 - (TEXT_SCALE.x/TEXT_SCALE.y))/2.;\n    uv = mod(uv, TEXT_SCALE) / TEXT_SCALE.y;\n    uv.x += ox;\n    if(t.y == 0.0 && t.x >= 0.0 && t.x < n)\n    {\n        float d = mod(floor(v / exp2(n - t.x - 1.0)), 2.0);\n        gFrag += texture(iChannel2, ((uv + vec2(d,12))/16.0), -100.0).r;\n    }\n}\n\n//Convert ASCII code to UV coords in the font texture.\nvec2 AsciiToUv(int ascii)\n{\n    if(ascii < 0x20){ascii = 0x20;} //Don't print control chars\n    return vec2(fract(float(ascii)/16.0), (15.0-floor(float(ascii)/16.0))/16.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gUV = fragCoord.xy / iResolution.y;\n    \n    vec2 cursor = texelFetch(iChannel0, CURSOR_BASE,0).zw;\n    vec2 charUv = fragCoord/iResolution.xy * vec2(TERM_SIZE) / CHAR_SIZE;\n    vec2 charPos = floor(charUv);\n    charPos.y = float(TERM_SIZE.y) - charPos.y - 1.0;\n    \n    //Scale & Center the character UVs.\n    charUv = CHAR_SIZE*fract(charUv)/16.0 + (1.0-CHAR_SIZE)/2.0/16.0;\n\t\n    //Calculate scroll offset and read the charater to print.\n    float scroll = max(0.0, cursor.y - float(TERM_SIZE.y)+1.0);\n    charPos.y = mod(charPos.y + scroll, float(TERM_SIZE.y));\n    int char = int(texelFetch(iChannel0, ivec2(charPos),0).y);\n\n    //Blink cursor\n    if(charPos == mod(cursor,vec2(TERM_SIZE)) )\n    {\n        char = (fract(iTime)<0.5) ? 0x40 : 0x20; //0x40 = @, 0x20 = Space\n    }\n    \n    //Draw terminal\n    gFrag = mix(TERM_BCOL, TERM_TCOL,\n                textureLod(iChannel2, charUv + AsciiToUv(char), 1.).x); //Draw chars\n    gFrag *= TERM_SCANVIS * mod(fragCoord.y,2.0) + (1.0-TERM_SCANVIS); //Scan lines\n\tgFrag *= float(IN_RECT(charPos, vec2(0), vec2(TERM_SIZE))); //Clip edges of terminal.\n    \n    //Draw debug values\n    //Top row\n    vec4 debug = READ_VAR4(0, iChannel1);\n    PrintHex(vec2(1.20,0.95), debug.x, 4.0); //Current PC\n    PrintHex(vec2(1.35,0.95), debug.y, 2.0); //Current opcode\n    PrintDec(vec2(1.45,0.95), debug.z); //Percent of max speed\n    PrintDec(vec2(1.55,0.95), debug.w); //Cycles per second\n    \n    //Middle row\n    debug = READ_VAR4(1, iChannel1);\n    PrintHex(vec2(1.20,0.85), debug.x, 2.0); //A\n    PrintHex(vec2(1.30,0.85), debug.y, 2.0); //X\n    PrintHex(vec2(1.40,0.85), debug.z, 2.0); //Y\n    PrintHex(vec2(1.50,0.85), debug.w, 2.0); //SP\n    \n    //Bottom row\n    debug = READ_VAR4(2, iChannel1);\n    PrintBin(vec2(1.20,0.75), debug.x, 8.0); //PSW/Flags (NV1BDIZC)\n    \n    fragColor = gFrag;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nMicrocode ROM\nUsed as a lookup table to decode the 6502 opcodes into a simpler form.\n\nALU instruction format:\nDST, SRC, ADDRMODE, OPERATION\n\nControl flow instruction format:\nXXX, FLAG, ADDRMODE, OPERATION\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        int addr = int(fragCoord.x);\n        ivec4 op = ivec4(1);\n        \n        switch(addr)\n        {\n            //ADC\n            case(0x69): op = ivec4(ACC,MEM,IMM,ADC); break; \n            case(0x65): op = ivec4(ACC,MEM,ZPG,ADC); break; \n            case(0x75): op = ivec4(ACC,MEM,ZPX,ADC); break; \n            case(0x6D): op = ivec4(ACC,MEM,ABS,ADC); break; \n            case(0x7D): op = ivec4(ACC,MEM,ABX,ADC); break; \n            case(0x79): op = ivec4(ACC,MEM,ABY,ADC); break; \n            case(0x61): op = ivec4(ACC,MEM,IDX,ADC); break; \n            case(0x71): op = ivec4(ACC,MEM,IDY,ADC); break; \n\n            //AND \n            case(0x29): op = ivec4(ACC,MEM,IMM,AND); break; \n            case(0x25): op = ivec4(ACC,MEM,ZPG,AND); break; \n            case(0x35): op = ivec4(ACC,MEM,ZPX,AND); break; \n            case(0x2D): op = ivec4(ACC,MEM,ABS,AND); break; \n            case(0x3D): op = ivec4(ACC,MEM,ABX,AND); break; \n            case(0x39): op = ivec4(ACC,MEM,ABY,AND); break; \n            case(0x21): op = ivec4(ACC,MEM,IDX,AND); break; \n            case(0x31): op = ivec4(ACC,MEM,IDY,AND); break; \n\n            //ASL\n            case(0x0A): op = ivec4(ACC,ACC,NON,ASL); break; \n            case(0x06): op = ivec4(MEM,MEM,ZPG,ASL); break; \n            case(0x16): op = ivec4(MEM,MEM,ZPX,ASL); break; \n            case(0x0E): op = ivec4(MEM,MEM,ABS,ASL); break; \n            case(0x1E): op = ivec4(MEM,MEM,ABX,ASL); break; \n\n            //BIT\n            case(0x24): op = ivec4(ACC,MEM,ZPG,BIT); break; \n            case(0x2C): op = ivec4(ACC,MEM,ABS,BIT); break; \n\n            //CMP\n            case(0xC9): op = ivec4(ACC,MEM,IMM,CMP); break; \n            case(0xC5): op = ivec4(ACC,MEM,ZPG,CMP); break; \n            case(0xD5): op = ivec4(ACC,MEM,ZPX,CMP); break; \n            case(0xCD): op = ivec4(ACC,MEM,ABS,CMP); break; \n            case(0xDD): op = ivec4(ACC,MEM,ABX,CMP); break; \n            case(0xD9): op = ivec4(ACC,MEM,ABY,CMP); break; \n            case(0xC1): op = ivec4(ACC,MEM,IDX,CMP); break; \n            case(0xD1): op = ivec4(ACC,MEM,IDY,CMP); break; \n\n            //CPX\n            case(0xE0): op = ivec4(XRE,MEM,IMM,CMP); break; \n            case(0xE4): op = ivec4(XRE,MEM,ZPG,CMP); break; \n            case(0xEC): op = ivec4(XRE,MEM,ABS,CMP); break; \n\n            //CPY\n            case(0xC0): op = ivec4(YRE,MEM,IMM,CMP); break; \n            case(0xC4): op = ivec4(YRE,MEM,ZPG,CMP); break; \n            case(0xCC): op = ivec4(YRE,MEM,ABS,CMP); break; \n\n            //DEC\n            case(0xC6): op = ivec4(MEM,MEM,ZPG,DEC); break; \n            case(0xD6): op = ivec4(MEM,MEM,ZPX,DEC); break; \n            case(0xCE): op = ivec4(MEM,MEM,ABS,DEC); break; \n            case(0xDE): op = ivec4(MEM,MEM,ABX,DEC); break; \n            case(0xCA): op = ivec4(XRE,XRE,NON,DEC); break; \n            case(0x88): op = ivec4(YRE,YRE,NON,DEC); break; \n\n            //INC \n            case(0xE6): op = ivec4(MEM,MEM,ZPG,INC); break; \n            case(0xF6): op = ivec4(MEM,MEM,ZPX,INC); break; \n            case(0xEE): op = ivec4(MEM,MEM,ABS,INC); break; \n            case(0xFE): op = ivec4(MEM,MEM,ABX,INC); break; \n            case(0xE8): op = ivec4(XRE,XRE,NON,INC); break; \n            case(0xC8): op = ivec4(YRE,YRE,NON,INC); break; \n\n            //EOR \n            case(0x49): op = ivec4(ACC,MEM,IMM,EOR); break; \n            case(0x45): op = ivec4(ACC,MEM,ZPG,EOR); break; \n            case(0x55): op = ivec4(ACC,MEM,ZPX,EOR); break; \n            case(0x4D): op = ivec4(ACC,MEM,ABS,EOR); break; \n            case(0x5D): op = ivec4(ACC,MEM,ABX,EOR); break; \n            case(0x59): op = ivec4(ACC,MEM,ABY,EOR); break; \n            case(0x41): op = ivec4(ACC,MEM,IDX,EOR); break; \n            case(0x51): op = ivec4(ACC,MEM,IDY,EOR); break; \n\n            //LDA\n            case(0xA9): op = ivec4(ACC,MEM,IMM,MOV); break; \n            case(0xA5): op = ivec4(ACC,MEM,ZPG,MOV); break; \n            case(0xB5): op = ivec4(ACC,MEM,ZPX,MOV); break; \n            case(0xAD): op = ivec4(ACC,MEM,ABS,MOV); break; \n            case(0xBD): op = ivec4(ACC,MEM,ABX,MOV); break; \n            case(0xB9): op = ivec4(ACC,MEM,ABY,MOV); break; \n            case(0xA1): op = ivec4(ACC,MEM,IDX,MOV); break; \n            case(0xB1): op = ivec4(ACC,MEM,IDY,MOV); break; \n\n            //LDX\n            case(0xA2): op = ivec4(XRE,MEM,IMM,MOV); break; \n            case(0xA6): op = ivec4(XRE,MEM,ZPG,MOV); break; \n            case(0xB6): op = ivec4(XRE,MEM,ZPY,MOV); break; \n            case(0xAE): op = ivec4(XRE,MEM,ABS,MOV); break; \n            case(0xBE): op = ivec4(XRE,MEM,ABY,MOV); break; \n\n            //LDY\n            case(0xA0): op = ivec4(YRE,MEM,IMM,MOV); break; \n            case(0xA4): op = ivec4(YRE,MEM,ZPG,MOV); break; \n            case(0xB4): op = ivec4(YRE,MEM,ZPX,MOV); break; \n            case(0xAC): op = ivec4(YRE,MEM,ABS,MOV); break; \n            case(0xBC): op = ivec4(YRE,MEM,ABX,MOV); break; \n\n            //LSR\n            case(0x4A): op = ivec4(ACC,ACC,NON,LSR); break; \n            case(0x46): op = ivec4(MEM,MEM,ZPG,LSR); break; \n            case(0x56): op = ivec4(MEM,MEM,ZPX,LSR); break; \n            case(0x4E): op = ivec4(MEM,MEM,ABS,LSR); break; \n            case(0x5E): op = ivec4(MEM,MEM,ABX,LSR); break; \n\n            //NOP \n            case(0xEA): op = ivec4(NOR,NOR,NON,NOP); break; \n\n            //ORA \n            case(0x09): op = ivec4(ACC,MEM,IMM,OR ); break; \n            case(0x05): op = ivec4(ACC,MEM,ZPG,OR ); break; \n            case(0x15): op = ivec4(ACC,MEM,ZPX,OR ); break; \n            case(0x0D): op = ivec4(ACC,MEM,ABS,OR ); break; \n            case(0x1D): op = ivec4(ACC,MEM,ABX,OR ); break; \n            case(0x19): op = ivec4(ACC,MEM,ABY,OR ); break; \n            case(0x01): op = ivec4(ACC,MEM,IDX,OR ); break; \n            case(0x11): op = ivec4(ACC,MEM,IDY,OR ); break; \n\n            //STACK \n            case(0x48): op = ivec4(STK,ACC,NON,MOV); break; //PHA\n            case(0x08): op = ivec4(STK,PSW,NON,MOV); break; //PSW\n            case(0x68): op = ivec4(ACC,STK,NON,MOV); break; //PLA\n            case(0x28): op = ivec4(PSW,STK,NON,MOV); break; //PLP\n\n            //ROL\n            case(0x2A): op = ivec4(ACC,ACC,NON,ROL); break; \n            case(0x26): op = ivec4(MEM,MEM,ZPG,ROL); break; \n            case(0x36): op = ivec4(MEM,MEM,ZPX,ROL); break; \n            case(0x2E): op = ivec4(MEM,MEM,ABS,ROL); break; \n            case(0x3E): op = ivec4(MEM,MEM,ABX,ROL); break; \n\n            //ROR \n            case(0x6A): op = ivec4(ACC,ACC,NON,ROR); break; \n            case(0x66): op = ivec4(MEM,MEM,ZPG,ROR); break; \n            case(0x76): op = ivec4(MEM,MEM,ZPX,ROR); break; \n            case(0x6E): op = ivec4(MEM,MEM,ABS,ROR); break; \n            case(0x7E): op = ivec4(MEM,MEM,ABX,ROR); break; \n\n            //SBC\n            case(0xE9): op = ivec4(ACC,MEM,IMM,SBC); break; \n            case(0xE5): op = ivec4(ACC,MEM,ZPG,SBC); break; \n            case(0xF5): op = ivec4(ACC,MEM,ZPX,SBC); break; \n            case(0xED): op = ivec4(ACC,MEM,ABS,SBC); break; \n            case(0xFD): op = ivec4(ACC,MEM,ABX,SBC); break; \n            case(0xF9): op = ivec4(ACC,MEM,ABY,SBC); break; \n            case(0xE1): op = ivec4(ACC,MEM,IDX,SBC); break; \n            case(0xF1): op = ivec4(ACC,MEM,IDY,SBC); break; \n\n            //STA \n            case(0x85): op = ivec4(MEM,ACC,ZPG,MOV); break; \n            case(0x95): op = ivec4(MEM,ACC,ZPX,MOV); break; \n            case(0x8D): op = ivec4(MEM,ACC,ABS,MOV); break; \n            case(0x9D): op = ivec4(MEM,ACC,ABX,MOV); break; \n            case(0x99): op = ivec4(MEM,ACC,ABY,MOV); break; \n            case(0x81): op = ivec4(MEM,ACC,IDX,MOV); break; \n            case(0x91): op = ivec4(MEM,ACC,IDY,MOV); break; \n\n            //STX\n            case(0x86): op = ivec4(MEM,XRE,ZPG,MOV); break; \n            case(0x96): op = ivec4(MEM,XRE,ZPY,MOV); break; \n            case(0x8E): op = ivec4(MEM,XRE,ABS,MOV); break; \n\n            //STY \n            case(0x84): op = ivec4(MEM,YRE,ZPG,MOV); break; \n            case(0x94): op = ivec4(MEM,YRE,ZPX,MOV); break; \n            case(0x8C): op = ivec4(MEM,YRE,ABS,MOV); break; \n\n            //REGISTER TRANSFERS\n            case(0xAA): op = ivec4(XRE,ACC,NON,MOV); break; //TAX\n            case(0xA8): op = ivec4(YRE,ACC,NON,MOV); break; //TAY\n            case(0xBA): op = ivec4(XRE,SPT,NON,MOV); break; //TSX\n            case(0x8A): op = ivec4(ACC,XRE,NON,MOV); break; //TXA\n            case(0x9A): op = ivec4(SPT,XRE,NON,MOV); break; //TXS\n            case(0x98): op = ivec4(ACC,YRE,NON,MOV); break; //TYA\n\n            //---------------------------------------------------\n            \n            //BRANCHES/CONTROL FLOW\n            case(0x90): op = ivec4(NOR,  C,REL,BCL); break; //BCC\n            case(0xB0): op = ivec4(NOR,  C,REL,BSE); break; //BCS\n            case(0xF0): op = ivec4(NOR,  Z,REL,BSE); break; //BEQ\n            case(0xD0): op = ivec4(NOR,  Z,REL,BCL); break; //BNE\n            case(0x30): op = ivec4(NOR,  N,REL,BSE); break; //BMI\n            case(0x10): op = ivec4(NOR,  N,REL,BCL); break; //BPL\n            case(0x50): op = ivec4(NOR,  V,REL,BCL); break; //BVC\n            case(0x70): op = ivec4(NOR,  V,REL,BSE); break; //BVS\n\n            case(0x00): op = ivec4(NOR,  B,REL,BRK); break; //BRK\n\n            case(0x18): op = ivec4(NOR,  C,REL,FCL); break; //CLC\n            case(0xD8): op = ivec4(NOR,  D,REL,FCL); break; //CLD\n            case(0x58): op = ivec4(NOR,  I,REL,FCL); break; //CLI\n            case(0xB8): op = ivec4(NOR,  V,REL,FCL); break; //CLV\n            case(0x38): op = ivec4(NOR,  C,REL,FSE); break; //SEC\n            case(0xF8): op = ivec4(NOR,  D,REL,FSE); break; //SED\n            case(0x78): op = ivec4(NOR,  I,REL,FSE); break; //SEI\n\n            case(0x6C): op = ivec4(NOR,NOR,IND,JMP); break; //JMP\n            case(0x4C): op = ivec4(NOR,NOR,ABS,JMP); break; //JMP\n\n            case(0x20): op = ivec4(NOR,NOR,ABS,JSR); break; //JSR\n            case(0x60): op = ivec4(NOR,NOR,NON,RTS); break; //RTS\n            case(0x40): op = ivec4(NOR,NOR,NON,RTI); break; //RTS\n            \n            default: op = ivec4(NOR,NOR,NON,NOP); break; \n        }\n        \n        fragColor = vec4(op);\n    }\n    else\n    {\n    \tfragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Emulator Parameters\n#define KBD_LAYOUT 0            //0 = QWERTY(US) / 1 = AZERTY\n#define CYCLES 600              //Max cycles per frame.\n#define CACHE_SIZE 67           //Size of the RAM cache, large values will impact the frame rate.\n#define MEM_SIZE ivec2(256,256) //Size of the memory area 256*256=65536 bytes.\n#define RESET_VECTOR 0xFFFC     //Location to read the starting address from\n#define STACK_BASE 0x100        //Stack base address\n#define TERM_SIZE ivec2(40,24)  //Terminal size (chars)\n#define DSPBUF_SIZE 40          //Terminal buffer size (max characters per frame)\n\n//Feedback variable locations\n#define MEM_BASE ivec2(0,0)    //RAM\n#define CURSOR_BASE ivec2(0,0) //Terminal cursor\n#define STATE_BASE ivec2(0,0)  //CPU State\n#define CACHE_BASE ivec2(1,0)  //RAM Cache\n#define VAR_BASE ivec2(0,1)    //Misc persistent variables\n#define DSPBUF_BASE ivec2(0,2) //DSP/Terminal buffer\n\n//Apple I PIA Registers\n#define KBD 0xD010   //Keyboard input\n#define KBDCR 0xD011 //Bit 7 = key was pressed\n#define DSP 0xD012   //Terminal output/Bit 7 = wait (PEEK/POKE -12270 in BASIC) \n#define DSPCR 0xD013 //Terminal control register\n\n//Bit Masks\n#define DATA_BITS 8\n#define ADDR_BITS 16\n#define DATA_MASK ((1<<DATA_BITS) - 1)\n#define ADDR_MASK ((1<<ADDR_BITS) - 1)\n\n//Microcode labels\n//Data Sources (X, Y)\n//Flags (NV1BDIZC) (Y)\n#define C 0 //Carry\n#define Z 1 //Zero\n#define I 2 //Interrupt Enabled\n#define D 3 //Decimal Mode\n#define B 4 //Break\n//unused  5 //Always 1\n#define V 6 //Overflow\n#define N 7 //Negative\n\n//Registers\n#define NOR 8  //No Register\n#define ACC 9  //Accumulator\n#define XRE 10 //X Index\n#define YRE 11 //Y Index\n#define STK 12 //Stack (read = pull, write = push)\n#define SPT 13 //Stack Pointer \n#define PSW 14 //Processor Status Word (Flags)\n#define IPT 15 //Instruction Pointer (PC)\n#define MEM 16 //Memory\n \n//Address Modes (Z)\n#define NON 0  //No address\n#define IND 1  //addr = mem16[fetch16()]\n#define ABS 2  //addr = fetch16()\n#define REL 3  //addr = PC + signed8(fetch8())\n#define IMM 4  //addr = PC\n#define ZPG 5  //addr = fetch8()\n#define ZPX 6  //addr = fetch8() + X\n#define ZPY 7  //addr = fetch8() + Y\n#define IDX 8  //addr = mem16[fetch8() + X]\n#define IDY 9  //addr = mem16[fetch8()] + Y\n#define ABX 10 //addr = fetch16() + X\n#define ABY 11 //addr = fetch16() + Y\n\n//Operations (W)\n#define NOP 0  //No Operation\n#define MOV 1  //Move\n#define INC 2  //Increment\n#define DEC 3  //Decrement\n#define ADC 4  //Add w/ Carry\n#define SBC 5  //Subtract w/ Borrow\n#define AND 6  //Bitwise AND\n#define OR  7  //Bitwise OR\n#define EOR 8  //Bitwise EOR\n#define ASL 9  //Arithmatic Shift Left\n#define LSR 10 //Logical Shift Right\n#define ROL 11 //Rotate Bits Left\n#define ROR 12 //Rotate Bits Right\n#define CMP 13 //Compare\n#define BIT 14 //Check Bits\n#define BRK 15 //Break\n#define JMP 16 //Jump\n#define JSR 17 //Jump To Subroutine\n#define RTS 18 //Return From Subroutine\n#define RTI 19 //Return From Interrupt\n#define BSE 20 //Branch If Flag Is Set\n#define BCL 21 //Branch If Flag Is Clear\n#define FSE 22 //Set Flag\n#define FCL 23 //Flag Clear\n\n//Current state of the cpu\n//A = Accumulator Register\n//X,Y = Index Registers\n//SP = Stack Pointer\n//PSW = Processor Status Word (Flags Register)\n//PC = Program Counter\nstruct CPUState\n{\n\tint reg_A,     //8\n        reg_X,     //8\n        reg_Y,     //8\n        reg_SP,    //8\n        reg_PSW,   //8 - N,V,1,B,D,I,Z,C\n        reg_PC;    //16 \n};\n\n//Pack / unpack CPU state to/from an ivec4\n//ivec4([0:8,A:8] ,[X:8,Y:8], [SP:8, FLAGS:8], [PC:16])\nivec4 pack_cpu_state(CPUState state)\n{\n    ivec4 packed = ivec4(0);\n    \n    packed.x = state.reg_A & DATA_MASK;\n    packed.y = ((state.reg_X & DATA_MASK) << DATA_BITS) | (state.reg_Y & DATA_MASK);\n    packed.z = ((state.reg_SP & DATA_MASK) << DATA_BITS) | (state.reg_PSW & DATA_MASK);\n    packed.w = state.reg_PC & ADDR_MASK;\n    \n    return packed;\n}\n    \nCPUState unpack_cpu_state(ivec4 packed)\n{\n\tCPUState state;\n    state.reg_A = packed.x & DATA_MASK;\n    state.reg_X = (packed.y >> DATA_BITS) & DATA_MASK;\n    state.reg_Y = packed.y & DATA_MASK;\n    state.reg_SP = (packed.z >> DATA_BITS) & DATA_MASK;\n    state.reg_PSW = packed.z & DATA_MASK;\n    state.reg_PC = packed.w & ADDR_MASK;\n    \n    return state;\n}\n\n//Global Functions\n/*\nGet 'n' bits from 'v' at index 'i' \nExample: n = 5, i = 2\n   |-n-|\nv:00000000\n       |\ni:76543210\n*/\n#define GETBITS(v,n,i) (((v) >> (i)) & ((1<<(n))-1))\n\n//Get bit 'i' from 'v'\n#define GETBIT(v,i) (((v) >> (i))&1)\n\n//Set bit 'i' to 'b' in value 'v', 'b' accepts integer or boolean input.\n#define BSET(v,i,b) ((v) = bool(b) ? ((v) | (1<<(i))) : ((v) & ~(1<<(i))))\n\n//Create a mask of 'n' bits Example:n = 3, returns 00000111\n#define BITMASK(n) ((1<<(n))-1)\n\n//Get high/low byte of 16-bit value\n#define HI(v) ((v >> 8) & 0xFF) \n#define LO(v) (v & 0xFF)\n\n//Write a,b,c,d to variable group 'i'\n#define WRITE_VAR4(i,a,b,c,d) if(uv == (VAR_BASE+ivec2(i,0))){frag=vec4(a,b,c,d);}\n\n//Read variable group 'i' from previous frame.\n#define READ_VAR4(i,c) texelFetch(c,VAR_BASE+ivec2(i,0),0)\n\n//Is point 'p' is inside the rectangle at point 'o' with size 's'?\n#define IN_RECT(p,o,s) (all(greaterThanEqual(p, o)) && all(lessThan(p, (o) + (s))))\n\n//Hash used for the hash-map cache.\nint hash(int i)\n{\n    uint x = uint(i);\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = (x >> 16) ^ x;\n    return int(x % uint(CACHE_SIZE));  \n}\n\n//Unsigned 8-bit number to signed 8-bit number.\n//Used for branch offsets and checking for overflow\nint signed8(int u8)\n{\n    u8 &= DATA_MASK;\n    return GETBIT(u8, 7)==1 ? -(0x100-u8) : u8;\n}\n\n//Maps a linear address to a location in a 2D region.\nivec2 map_region(int addr, ivec2 base, ivec2 size)\n{\n    return ivec2(addr % size.x, (addr / size.x) % size.y) + base;\n}\n\n//Maps a location in a 2D region to a linear address.\nint unmap_region(ivec2 uv, ivec2 base, ivec2 size)\n{\n    uv -= base;\n    return (uv.x + uv.y * size.x);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Memory / Cache write-back / IO handling\n\n//Globals\nivec2 uv;\nvec4 frag;\nivec2 cursor = ivec2(0,0);\n\n//ROM definition helpers\n#define START_ROM(start) ptr=0,addr16=(addr-(start))/16;\n#define R(a,b,c,d,e,f,g,h) if(ptr==addr16){ret=uvec4(a,b,c,d);}ptr++;if(ptr==addr16){ret=uvec4(e,f,g,h);}ptr++;\n#define END_ROM() if(addr16 > ptr){ret=uvec4(0);}\n\n//Returns the rom data to be loaded into memory.\n//Doesn't use arrays as I found they increased the already long compile times.\nint rom(int addr)\n{\n    int ptr = 0, addr16 = 0;\n    uvec4 ret = uvec4(0); \n    \n    //Apple I Integer Basic\n    //Patched 0xE3D6 = 0x12, 0xE3DB = 0x12, to point to the correct terminal output register.\n    //This worked on real hardware due to register mirroring which is not emulated.\n    START_ROM(0xE000);\n    R(0x4cb0e2ad,0x11d010fb,0xad10d060,0x8a2920f0,0x23a9a085,0xe44cc9e3,0xa920c524,0xb00ca98d);\n    R(0xa00720c9,0xe3a9a088,0xd0f8a000,0xb1e2e6e2,0xd002e6e3,0x602015e7,0x2076e5a5,0xe2c5e6a5);\n    R(0xe3e5e7b0,0xef206de0,0x4c3be0a5,0xca85e2a5,0xcb85e3a5,0x4c85e6a5,0x4d85e7d0,0xde2015e7);\n    R(0x206de5a5,0xe485e2a5,0xe585e3b0,0xc786d8a9,0xa085fa20,0x2ae09885,0xe4202ae0,0xaa202ae0);\n    R(0x201be520,0x18e084fa,0xaa10180a,0x10e9a5e4,0xd0032011,0xe08a20c9,0xe3a92520,0x1ae0aa30);\n    R(0xf585e4c9,0x01d005a6,0xd84ccde3,0x4884cea2,0xed86cfc9,0x519004c6,0xcfe95048,0xb1ceaa88);\n    R(0xb1ce10fa,0xe0c0b004,0xe00030f2,0xaa68e901,0xd0e924e4,0x300320f8,0xefb1ce10,0x10aa293f);\n    R(0x85e41869,0xa020c9e3,0x88e0c090,0xec200ce0,0x68c95df0,0xa4c928d0,0x8af09e20,0x18e19550);\n    R(0xd5789011,0xa02b4ce0,0xe32034ee,0xd55090f4,0x20e4ef95,0x784c23e8,0x2034eef0,0xe738e901);\n    R(0x602018e1,0x955018f5,0x784c02e1,0xa014d0d6,0x2018e1e8,0xb55085da,0x65ce48a8,0xb57885db);\n    R(0x65cf48c4,0xcae5cbb0,0xe3a5da69,0xfe85daa9,0xffa865db,0x85dbc8b1,0xdad9cc00,0xd00f98f0);\n    R(0xf56891da,0x99cc0088,0x10f7e860,0xeaa080d0,0x95a90020,0x0ae7a002,0x9478200a,0xe7a9bf20);\n    R(0xc9e3a000,0x209ee294,0x78eaeaea,0xb55185ce,0xb57985cf,0xe8e820bc,0xe1b54ed5,0x76b015f6);\n    R(0x4ea8b1ce,0xb450c4e4,0x9004a083,0xd0c191da,0xf65090e5,0xb4508a91,0xdae8e860,0xb55185da);\n    R(0x38e90285,0xe4b57985,0xdbe90085,0xe5a000b1,0xe418e5da,0x85e460b5,0x5385ceb5,0x7b85cfb5);\n    R(0x5185dab5,0x7985dbe8,0xe8e8a000,0x947894a0,0xc89450b5,0x4dd57508,0x48b54fd5,0x77900768);\n    R(0x28b00256,0x5060a8b1,0xce85e468,0xa828b0f3,0xb1dac5e4,0xd0edf64f,0xf64db0d7,0x20d7e14c);\n    R(0x36e72054,0xe206ce26,0xcf900d18,0xa5e665da,0x85e6a5e7,0x65db85e7,0x88f00906,0xe626e710);\n    R(0xe44c7ee7,0xa5e62008,0xe7a5e795,0xa006e590,0x284c6fe7,0xa95585e5,0x205be2a5,0xce85daa5);\n    R(0xcf85db20,0x15e784e6,0x84e7a5cf,0x1009ca06,0xe5206fe7,0x2015e7a0,0x1060206c,0xeef0c5ff);\n    R(0xc984d002,0x46f8c9df,0xf011c99b,0xf0069900,0x02c8100a,0xa08b20c4,0xe3a00188,0x30f62003);\n    R(0xe0eaea20,0xc9e3c98d,0xd0d6a9df,0x99000260,0x20d3ef20,0xcde346d9,0xa9be20c9,0xe3a00084);\n    R(0xfa24f810,0x0ca6f6a5,0xf7201be5,0xa9a020c9,0xe3a2ff9a,0x209ee284,0xf18a85c8,0xa2202091);\n    R(0xe4a5c869,0x0085e0a9,0x00aa6902,0x85e1a1e0,0x29f0c9b0,0xf0034c83,0xe8a002b1,0xe099cd00);\n    R(0x88d0f820,0x8ae3a5f1,0xe5c8c904,0xf0a891e0,0xa5caf1e0,0x85e4a5cb,0xe90085e5,0xa5e4c5cc);\n    R(0xa5e5e5cd,0x9045a5ca,0xf1e085e6,0xa5cbe900,0x85e7b1ca,0x91e6e6ca,0xd002e6cb,0xa5e2c5ca);\n    R(0xa5e3e5cb,0xb0e0b5e4,0x95caca10,0xf9b1e0a8,0x88b1e091,0xe698d0f8,0x24f81009,0xb5f775f5);\n    R(0x95f7e8f0,0xf7107e00,0x000000a0,0x14d07120,0x15e7a5e2,0x85e6a5e3,0x85e72075,0xe5a5e285);\n    R(0xe4a5e385,0xe5d00e20,0x15e7206d,0xe5a5e685,0xe2a5e785,0xe3a000a5,0xcac5e4a5,0xcbe5e5b0);\n    R(0x16a5e4d0,0x02c6e5c6,0xe4a5e6d0,0x02c6e7c6,0xe6b1e491,0xe690e0a5,0xe685caa5,0xe785cb60);\n    R(0x20c9e3c8,0xb900eb30,0xf7c98dd0,0x06a90085,0x24a98de6,0x242c12d0,0x30fb8d12,0xd060a006);\n    R(0x20d3ee24,0xd930034c,0xb6e24c9a,0xeb2a69a0,0xdd0002d0,0x53b1fe0a,0x300688b1,0xfe3029c8);\n    R(0x86c89848,0xa200a1fe,0xaa4a4948,0x11fec9c0,0x9001e8c8,0xd0f368a8,0x8a4cc0e4,0xe6f1a6f1);\n    R(0xf0bc9d00,0x0260a6c8,0xa9a0e8dd,0x0002b0fa,0xb1fe293f,0x4ad0b6bd,0x0002b006,0x693fc91a);\n    R(0x906f694f,0xc90a9069,0xa6fdc8b1,0xfe29e0c9,0x20f07ab5,0xa885c8b5,0xd185f188,0xb1fe0a10);\n    R(0xfa88b038,0x0a3035b4,0x5884ffb4,0x80e810da,0xf0b3c97e,0xb022ca10,0x04a00610,0x299480a4);\n    R(0xff9458a4,0xc894a8a4,0xf194d129,0x1fa8b920,0xec0aa8a9,0x762a85ff,0xd001c8c8,0x86fdb1fe);\n    R(0x3084d005,0xa00e4ce0,0xe3c903b0,0xc34aa6c8,0xe8bd0002,0x9004c9a2,0xf00ac9df,0xf00686c8);\n    R(0x201ce4c8,0x88a6fdb1,0xfe880a10,0xcfb45884,0xffb480e8,0xb1fe299f,0xd0ed85f2,0x85f39848);\n    R(0x86fdb4d0,0x84c918a9,0x0a85f9a2,0x00c8b900,0x02290f65,0xf2488a65,0xf3301caa,0x68c6f9d0);\n    R(0xf285f286,0xf3c4f1d0,0xdea4c9c8,0x84f1201c,0xe468a8a5,0xf3b0a9a0,0x00108b85,0xf386f2a2);\n    R(0x0486c9a9,0xb085f9a5,0xf2dd63e5,0xa5f3fd68,0xe5900d85,0xf3a5f2fd,0x63e585f2,0xe6f9d0e7);\n    R(0xa5f9e8ca,0xf00ec9b0,0xf00285c9,0x24c93004,0xa5faf00b,0x20c9e324,0xf8100499,0x0002c8ca);\n    R(0x10c16001,0x0a64e810,0x00000003,0x27a5ca85,0xe6a5cb85,0xe7e8a5e7,0x85e5a5e6,0x85e4c54c);\n    R(0xa5e5e54d,0xb026a001,0xb1e4e5ce,0xc8b1e4e5,0xcfb019a0,0x00a5e671,0xe485e690,0x03e6e718);\n    R(0xc8a5cef1,0xe4c8a5cf,0xf1e4b0ca,0x6046f8a5,0x4c85caa5,0x4d85cba5,0x4a85cca5,0x4b85cda9);\n    R(0x0085fb85,0xfc85fea9,0x00851d60,0xa5d06905,0x85d2a5d1,0x690085d3,0xa5d2c5ca,0xa5d3e5cb);\n    R(0x90034c6b,0xe3a5ce91,0xd0a5cfc8,0x91d0a5d2,0xc891d0a5,0xd3c891d0,0xa900c891,0xd0c891d0);\n    R(0xa5d285cc,0xa5d385cd,0xa5d09043,0x85ce84cf,0x20ffe630,0x0ec940f0,0x0a4c28e6,0x06c949d0);\n    R(0x07a94985,0xcf20ffe6,0xa54b85d1,0xa54a85d0,0xc5cca5d1,0xe5cdb094,0xb1d0c8c5,0xced006b1);\n    R(0xd0c5cff0,0x0ec8b1d0,0x48c8b1d0,0x85d168a0,0x00f0dba5,0xd0690320,0x0ae7a5d1,0x69009578);\n    R(0xa5cfc940,0xd01c8898,0x200ae788,0x9478a003,0xf678c8b1,0xd030f910,0x09a90085,0xd485d5a2);\n    R(0x2048a000,0xb1e01018,0x0a308120,0xffe62008,0xe720ffe6,0x95a024d4,0x1001ca20,0xffe6b0e6);\n    R(0xc928d01f,0xa5e0200a,0xe7a5e195,0x7824d430,0x0ba90120,0x0ae7a900,0x9578f678,0x20ffe630);\n    R(0xf9b0d324,0xd41006c9,0x04b0d046,0xd4a885d6,0xb998e929,0x550a85d7,0x68a8b998,0xe929aac5);\n    R(0xd7b00998,0x4820ffe6,0xa5d69095,0xb910ea85,0xceb988ea,0x85cf20fc,0xe64cd8e6,0x6cce00e6);\n    R(0xe0d002e6,0xe1b1e060,0x9477ca30,0x03955060,0xa0664ce0,0xe3a000b5,0x5085ceb5,0xa085cfb5);\n    R(0x78f00e85,0xcfb1ce48,0xc8b1ce85,0xcf6885ce,0x88e86020,0x4ae72015,0xe7982008,0xe795a0c5);\n    R(0xced006c5,0xcfd002f6,0x50602082,0xe72059e7,0x2015e724,0xcf301bca,0x602015e7,0xa5cfd004);\n    R(0xa5cef0f3,0xa9ff2008,0xe795a024,0xcf30e920,0x15e79838,0xe5ce2008,0xe798e5cf,0x5023a000);\n    R(0x1090206f,0xe72015e7,0xa5ce85da,0xa5cf85db,0x2015e718,0xa5ce65da,0x2008e7a5,0xcf65db70);\n    R(0xdd95a060,0x2015e7a4,0xcef00588,0xa5cff00c,0x60a52409,0x07a8c8a9,0xa020c9e3,0xc424b0f7);\n    R(0x6020b1e7,0x2015e7a5,0xcf100aa9,0xad20c9e3,0x2072e750,0xef8884d5,0x86cfa6ce,0x201be5a6);\n    R(0xcf602015,0xe7a5ce85,0xf6a5cf85,0xf78884f8,0xc8a90a85,0xf484f560,0x2015e7a5,0xcea4cf10);\n    R(0xf22015e7,0xb55085da,0xb57885db,0xa5ce91da,0xc8a5cf91,0xdae86068,0x6824d510,0x0520cde3);\n    R(0x46d560a0,0xff84d760,0x20cdeff0,0x07a92585,0xd68884d4,0xe860a5ca,0xa4cbd05a,0xa041a5fc);\n    R(0xc908b05e,0xa8e6fca5,0xe0990001,0xa5e19908,0x01a5dc99,0x1001a5dd,0x99180120,0x15e7206d);\n    R(0xe59004a0,0x37d03ba5,0xe4a4e585,0xdc84dd2c,0x11d0304f,0x18690390,0x01c8a2ff,0x86d99a85);\n    R(0xe084e120,0x79e624d9,0x104918a0,0x00a5dc71,0xdca4dd90,0x01c8c54c,0xd0d1c44d,0xd0cda034);\n    R(0x46d94ce0,0xe3a04aa5,0xfcf0f7c6,0xfca8b90f,0x0185dcb9,0x170185dd,0xbeff00b9,0x0701a88a);\n    R(0x4c7ae8a0,0x6320c4e3,0xa001b1dc,0xaac8b1dc,0x201be54c,0xb3e2c6fb,0xa05ba5fb,0xf0c4a8b5);\n    R(0x50d91f01,0xd0f0b578,0xd92701d0,0xe9b92f01,0x85dab937,0x0185db20,0x15e7ca20,0x93e72001);\n    R(0xe8caa4fb,0xb9670195,0x9fb95f01,0xa0002008,0xe72082e7,0x2059e720,0x15e7a4fb,0xa5cef005);\n    R(0x59370110,0x12b93f01,0x85dcb947,0x0185ddbe,0x4f01b957,0x01d087c6,0xfb60a054,0xa5fbc908);\n    R(0xf09ae6fb,0xa8b55099,0x2001b578,0x99280160,0x2015e7a4,0xfba5ce99,0x5f01a5cf,0x996701a9);\n    R(0x01992f01,0xa9009937,0x01a5dc99,0x3f01a5dd,0x994701a5,0xe0994f01,0xa5e19957,0x01602015);\n    R(0xe7a4fba5,0xce992f01,0xa5cf4c66,0xe9000000,0x00000000,0x00000000,0x000000ab,0x03030303);\n    R(0x03030303,0x03030303,0x03033f3f,0xc0c03c3c,0x3c3c3c3c,0x3c300fc0,0xccff5500,0xabab0303);\n    R(0xffff55ff,0xff55cfcf,0xcfcfcfff,0x55c3c3c3,0x55f0f0cf,0x56565655,0xffff5503,0x03030303);\n    R(0x0303ffff,0xff030303,0x03030303,0x03030303,0x03030303,0x0300ab03,0x57030303,0x03070303);\n    R(0x03030303,0x03030303,0x0303aaff,0xffffffff,0x17ffff19,0x5d354bf2,0xec876fad,0xb7e2f854);\n    R(0x80968582,0x2210334a,0x13060b4a,0x0140477a,0x00ff2309,0x5b16b6cb,0xfffffbff,0xff24f64e);\n    R(0x595000ff,0x23a36f36,0x23d71c22,0xc2aeba23,0xffff2130,0x1e03c420,0x00c1ffff,0xffa0301e);\n    R(0xa4d3b6bc,0xaa3a0150,0x7ed8d8a5,0x3cff165b,0x2803c41d,0x000c4e00,0x3e00a6b0,0x00bcc657);\n    R(0x8c0127ff,0xffffffff,0xe8ffffe8,0xe0e0e0ef,0xefe3e3e5,0xe5e7e7ee,0xefefe7e7,0xe2efe7e7);\n    R(0xececece7,0xececece2,0x00ffe8e1,0xe8e8efeb,0xffffe0ff,0xffefeeef,0xe7e700ff,0xe8e7e7e7);\n    R(0xe8e1e2ee,0xeeeeeee8,0xffffe1e1,0xefeee7e8,0xeee7ffff,0xffeee1ef,0xe7e8efef,0xebe9e8e9);\n    R(0xe9e8e8e8,0xe8ffe8e8,0xe8eee7e8,0xefefeeef,0xeeefeeee,0xefeeeeee,0xe1e8e8ff,0xffffffff);\n    R(0xbeb3b2b7,0xb637d4cf,0xcfa0cccf,0xce47d3d9,0xced4c158,0xcdc5cda0,0xc6d5cc4c,0xd4cfcfa0);\n    R(0xcdc1ced9,0xa0d0c1d2,0xc5ce53d3,0xd4d2c9ce,0x47cecfa0,0xc5ce44c2,0xc1c4a0c2,0xd2c1cec3);\n    R(0x48beb8a0,0xc7cfd3d5,0xc253c2c1,0xc4a0d2c5,0xd4d5d24e,0xbeb8a0c6,0xcfd253c2,0xc1c4a0ce);\n    R(0xc5d854d3,0xd4cfd0d0,0xc5c4a0c1,0xd420aaaa,0xaa20a0c5,0xd2d20dbe,0xb2b535d2,0xc1cec745);\n    R(0xc4c94dd3,0xd4d2a0cf,0xd6c64cdc,0x0dd2c5d4,0xd9d0c5a0,0xccc9cec5,0x8d3f46d9,0x90034cc3);\n    R(0xe8a6cf9a,0xa6cea08d,0xd002a099,0x20c4e386,0xceba86cf,0xa0fe84d9,0xc884c820,0x99e284f1);\n    R(0xa220a930,0x2091e4e6,0xd9a6cea4,0xc80a85ce,0xc8b90002,0xc974f0d2,0x49b0c90a,0xb0f0c8c8);\n    R(0x84c8b900,0x0248b9ff,0x01a00020,0x08e76895,0xa0a5cec9,0xc7d00320,0x6fe74c01,0xe8ffffff);\n    R(0x502013ec,0xd015200b,0xecd01020,0x82e7206f,0xe7500320,0x82e72059,0xe756504c,0x36e7ffff);\n    R(0xc1ff7fd1,0xccc7cfce,0xc59a988b,0x969593bf,0xb2322d2b,0xbcb0acbe,0x358e61ff,0xffffddfb);\n    R(0x20c9ef15,0x4f100520,0xc9ef354f,0x955010cb,0x4cc9ef40,0x608d608b,0x007e8c33,0x00006003);\n    R(0xbf120040,0x89c9479d,0x17689d0a,0x0040608d,0x608b007e,0x8c3c0000,0x6003bf1b,0x4b67b4a1);\n    R(0x078c07ae,0xa9aca867,0x8c07b4af,0xacb0679d,0xb2afacaf,0xa3678c07,0xa5abafb0,0xf4aea9b2);\n    R(0xb07f0e27,0xb4aea9b2,0xb07f0e28,0xb4aea9b2,0xb06407a6,0xa967afb4,0xafa778b4,0xa5ac787f);\n    R(0x02ada5b2,0x67a2b5b3,0xafa7eeb2,0xb5b4a5b2,0x7e8c39b4,0xb8a5ae67,0xb0a5b4b3,0x27afb407);\n    R(0x9d19b2af,0xa67f0537,0xb4b5b0ae,0xa97f0528,0xb4b5b0ae,0xa97f052a,0xb4b5b0ae,0xa9e4aea5);\n    R(0x00ffff47,0xa2a1b47f,0x0d30ada9,0xa47f0d23,0xada9a467,0xacaca1a3,0x004080c0,0xc1800047);\n    R(0x8c688cdb,0x679b689b,0x508c638c,0x7f015107,0x88298480,0xc4805771,0x078814ed,0xa5adafac);\n    R(0xeda5ada9,0xa8f2afac,0xafa37108,0x88aea5ac,0x68830868,0x9d087107,0x886076b4,0xafae768d);\n    R(0x768b5107,0x8819b8a4,0xaeb2f2b3,0xb5f3a2a1,0xeea7b3e4,0xaeb2eba5,0xa5b05107,0x883981c1);\n    R(0x4f7f0f2f,0x00510688,0x29c20c82,0x578c6a8c,0x42aea5a8,0xb460aea5,0xa8b44f7e,0x1e358c27);\n    R(0x51078809,0x8bfee4af,0xadf2afe4,0xaea1dcde,0x9cdd9cde,0xdd9ec3dd,0xcfcacdcb,0x00479dad);\n    R(0xa5adafac,0x769dada5,0xada9a8e6,0xa6af608c,0x20afb4b5,0xa1f2aca3,0xf2a3b360,0x8c20aca5);\n    R(0xa4eeb5b2,0x60aeb5b2,0xf4b3a9ac,0x608c20b4,0xb3a9ac7a,0x7e9a2220,0x006003bf,0x6003bf1f);\n    R(0x20b1e7e8,0xe8b54f85,0xdab57785,0xdbb44e98,0xd576b009,0xb1da20c9,0xe3c84c0f,0xeea9ff85);\n    R(0xd560e8a9,0x00957895,0xa0b57738,0xf54f9550,0x4c23e8ff,0x2015e7a5,0xcfd028a5,0xce602034);\n    R(0xeea4c8c9,0x30b021c0,0x28b01d60,0xeaea2034,0xee60ea8a,0xa201b4ce,0x944cb448,0x94cacaf0);\n    R(0xf5aa60a0,0x774ce0e3,0xa07bd0f9,0x2054e2a5,0xdad007a5,0xdbd0034c,0x7ee706ce,0x26cf26e6);\n    R(0x26e7a5e6,0xc5daa5e7,0xe5db900a,0x85e7a5e6,0xe5da85e6,0xe6ce88d0,0xe160ffff,0xffffffff);\n    R(0x2015e76c,0xce00a54c,0xd002c64d,0xc64ca548,0xd002c649,0xc648a000,0xb14c9148,0xa5cac54c);\n    R(0xa5cbe54d,0x90e04c53,0xeec928b0,0x9ba8a5c8,0x60eaea98,0xaaa06e20,0xc4e38aa8,0x20c4e3a0);\n    R(0x724cc4e3,0x2015e706,0xce26cf30,0xfab0dcd0,0x04c5ceb0,0xd6602015,0xe7b1ce94,0x9f4c08e7);\n    R(0x2034eea5,0xce482015,0xe76891ce,0x60ffffff,0x206ceea5,0xce85e6a5,0xcf85e74c,0x44e220e4);\n    R(0xee4c34e1,0x20e4eeb4,0x78b55069,0xfeb00188,0x85da84db,0x1865ce95,0x509865cf,0x9578a000);\n    R(0xb550d1da,0xc8b578f1,0xdab0804c,0x23e82015,0xe7a54e20,0x08e7a54f,0xd004c54e,0x6900297f);\n    R(0x854f95a0,0xa011a54f,0x0a186940,0x0a264e26,0x4f88d0f2,0xa5ce2008,0xe7a5cf95,0xa04c7ae2);\n    R(0x2015e7a4,0xcec44ca5,0xcfe54d90,0x1f8448a5,0xcf85494c,0xb6ee2015,0xe7a4cec4,0xcaa5cfe5);\n    R(0xcbb00984,0x4aa5cf85,0x4b4cb7e5,0x4ccbeeea,0xeaeaea20,0xc9ef2071,0xe14cbfef,0x2003eea9);\n    R(0xff85c8a9,0x748d0002,0x602036e7,0xe82036e7,0xb55060a9,0x00854a85,0x4ca90885,0x4ba91085);\n    R(0x4d4cade5,0xd578d001,0x184c02e1,0x20b7e54c,0x36e820b7,0xe54c5be8,0xe080d001,0x884c0ce0);\n    END_ROM();\n    \n    //Woz Monitor\n    START_ROM(0xFF00);\n    R(0xD858A07F,0x8C12D0A9,0xA78D11D0,0x8D13D0C9,0xDFF013C9,0x9BF003C8,0x100FA9DC,0x20EFFFA9);\n    R(0x8D20EFFF,0xA0018830,0xF6AD11D0,0x10FBAD10,0xD0990002,0x20EFFFC9,0x8DD0D4A0,0xFFA900AA);\n    R(0x0A852BC8,0xB90002C9,0x8DF0D4C9,0xAE90F4F0,0xF0C9BAF0,0xEBC9D2F0,0x3B862886,0x29842AB9);\n    R(0x000249B0,0xC90A9006,0x6988C9FA,0x90110A0A,0x0A0AA204,0x0A262826,0x29CAD0F8,0xC8D0E0C4);\n    R(0x2AF09724,0x2B5010A5,0x288126E6,0x26D0B5E6,0x274C44FF,0x6C240030,0x2BA202B5,0x27952595);\n    R(0x23CAD0F7,0xD014A98D,0x20EFFFA5,0x2520DCFF,0xA52420DC,0xFFA9BA20,0xEFFFA9A0,0x20EFFFA1);\n    R(0x2420DCFF,0x862BA524,0xC528A525,0xE529B0C1,0xE624D002,0xE625A524,0x290710C8,0x484A4A4A);\n    R(0x4A20E5FF,0x68290F09,0xB0C9BA90,0x0269062C,0x12D030FB,0x8D12D060,0x0000000F,0x00FF0000);\n    END_ROM();\n    \n \n    addr %= 16;\n    \n    return 0xFF & int(ret[addr/4] >> (24 - 8*(addr % 4)));\n}\n\n//Write and 8-bit value 'v' to address 'addr'\nvoid writeMem(int addr, int v)\n{\n    addr &= ADDR_MASK;\n    v &= DATA_MASK;\n\tivec2 aLoc = map_region(addr, MEM_BASE, MEM_SIZE);\n    if(uv == aLoc)\n    {\n    \tfrag.x = float(v);   \n    }\n}\n\n//Read 8-bit value from memory\n//Checks if an address is cached.\n//If so, returns cached result\n//If not, reads from the memory buffer\nint readMem8(int addr)\n{\n    addr &= ADDR_MASK;\n    \n    ivec4 cr = ivec4(texelFetch(iChannel0, CACHE_BASE+ivec2(hash(addr),0),0));\n    bvec2 cmp = equal(cr.xz, ivec2(addr+1));\n    int result = int(texelFetch(iChannel1, map_region(addr, MEM_BASE, MEM_SIZE), 0).x);;\n    \n    if(any(cmp))\n    {\n    \tresult = cmp.x ? cr.y : cr.w;\n    }\n    \n    return result;\n}\n\nint keyCodeToAscii(int keycode, bool shift, bool altgr)\n{\n    //The keyboard texture doesn't provide ascii values or handle shift keys\n    //This array only contains the keys to be remapped, if a key isn't present, they keycode is used.\n    //X = keycode\n    //Y = ASCII\n    //Z = ASCII w/ Shift\n    //W = ASCII w/ AltGr\n\tivec4[] keyCodeMap = ivec4[](\n        #if(KBD_LAYOUT == 0) //QWERTY\n        ivec4(0x08,0xDF,0xDF,0x00),ivec4(0x30,0x30,0x29,0x00),ivec4(0x31,0x31,0x21,0x00),ivec4(0x32,0x32,0x40,0x00),\n        ivec4(0x33,0x33,0x23,0x00),ivec4(0x34,0x34,0x24,0x00),ivec4(0x35,0x35,0x25,0x00),ivec4(0x36,0x36,0x5E,0x00),\n        ivec4(0x37,0x37,0x26,0x00),ivec4(0x38,0x38,0x2A,0x00),ivec4(0x39,0x39,0x28,0x00),ivec4(0xBA,0x3B,0xBA,0x00),\n        ivec4(0xBB,0x3D,0x2B,0x00),ivec4(0xBC,0x2C,0xBC,0x00),ivec4(0xBD,0x2D,0x5F,0x00),ivec4(0xBE,0x2E,0xBE,0x00),\n        ivec4(0xBF,0x2F,0xBF,0x00),ivec4(0xC0,0x60,0x7E,0x00),ivec4(0xDB,0xDB,0x7B,0x00),ivec4(0xDC,0xDC,0x7C,0x00),\n        ivec4(0xDD,0xDD,0x7D,0x00),ivec4(0xDE,0x27,0x22,0x00)\n        #endif\n        #if(KBD_LAYOUT == 1) //AZERTY (Thanks to FabriceNeyret2)\n        ivec4(0x08,0xDF,0xDF,0x00),ivec4(0x30,0x40,0x30,0x40),ivec4(0x31,0x26,0x31,0x00),ivec4(0x32,0x7E,0x32,0x00),\n        ivec4(0x33,0x22,0x33,0x00),ivec4(0x34,0x27,0x34,0x00),ivec4(0x35,0x28,0x35,0x00),ivec4(0x36,0x2D,0x36,0x00),\n        ivec4(0x37,0x60,0x37,0x00),ivec4(0x38,0x5F,0x38,0x00),ivec4(0x39,0x5E,0x39,0x00),ivec4(0x3A,0x40,0x3A,0x00),\n        ivec4(0xBA,0x24,0x00,0x00),ivec4(0xBB,0x3D,0x2B,0x00),ivec4(0xBC,0x2C,0x3F,0x00),ivec4(0xBD,0x2D,0x5F,0x00),\n        ivec4(0xBE,0x3B,0x2E,0x00),ivec4(0xBF,0x3A,0x2F,0x00),ivec4(0xC0,0x5B,0x25,0x00),ivec4(0xDB,0x29,0x5D,0x00),\n        ivec4(0xDC,0x3C,0x3E,0x00),ivec4(0xDD,0x29,0x5D,0x00),ivec4(0xDE,0x27,0x22,0x00),ivec4(0xDF,0x21,0xDF,0x00)     \n        #endif\n\t);\n    \n    int ascii = keycode;\n    \n    for(int i = 0;i < keyCodeMap.length();i++)\n    {\n        ivec4 map = keyCodeMap[i];\n        if(map.x == keycode)\n        {\n        \tascii = shift ? map.z:\n            \t\taltgr ? map.w:\n            \t\t\t    map.y;\n        }\n    }\n    \n    return ascii;\n}\n\n//Scans the keyboard and outputs the first pressed key it finds.\nint scanKeyboard()\n{\n    bool shift = (texelFetch(iChannel2,ivec2(16,0),0).x != 0.0);\n    bool altgr = (texelFetch(iChannel2,ivec2(18,0),0).x != 0.0);\n    \n    for(int i = 0;i < 256;i++)\n    {\n        float keypressed = texelFetch(iChannel2,ivec2(i,1),0).x;\n        \n        if(keypressed != 0.0 && i != 16 && i != 18)\n        {            \n        \treturn keyCodeToAscii(i, shift, altgr) | 0x80; //Apple 1 software expects bit 7 to be set.\n        }\n    }\n    \n    return 0x00;\n}\n\n//Reads characters from the display buffer & handles cursor positioning/scrolling.\nvoid updateTerminal()\n{\n    cursor = ivec2(texelFetch(iChannel1, CURSOR_BASE, 0).zw); //Read the cursor from the previous frame.\n\n    int char = 0;\n    \n    //Loop through the display buffer and write them to the display.\n    for(int i = 0;i < DSPBUF_SIZE;i++)\n    {\n        char = int(texelFetch(iChannel0, DSPBUF_BASE+ivec2(i,0), 0).x);\n        \n        if(char != 0x00) //Assume 0x00 = no character\n        {\n            //Go to next line if CR is printed or if the cursor is off the edge of the screen.\n            if(char == 0x0D || cursor.x >= TERM_SIZE.x)\n            {\n                cursor.x = 0;\n                cursor.y++;\n\n                //Once the cursor reaches the bottom of the screen, all further lines will scroll it up.\n                if(cursor.y >= TERM_SIZE.y-1)\n                {\n                    //Clear next line to scroll\n                    if(uv.x >= 0 && uv.y == (cursor.y % TERM_SIZE.y))\n                    {\n                        frag.y = 0.0;\n                    }\n                }\n            }\n\n            //Don't print control charaters.\n            if(char >= 0x20)\n            {\n                //Save the character at the cursor pos and move the cursor.\n                if(uv == cursor % TERM_SIZE)\n                {\n                    frag.y = float(char);\n                }\n                cursor.x++;\n            }\n\n            //Clear DSP after writing to the screen.\n            //Bit 7 clear indicates the terminal is ready.\n            writeMem(DSP, 0x00);\n        }\n    }\n    \n    //Save cursor position.\n    if(uv == CURSOR_BASE)\n    {\n    \tfrag.zw = vec2(cursor);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = ivec2(fragCoord);\n    frag = texelFetch(iChannel1, uv, 0);\n    \n    if(IN_RECT(uv, MEM_BASE, MEM_SIZE))\n    {\n        //Write cache from CPU buffer back to memory\n        int addr = unmap_region(uv, MEM_BASE, MEM_SIZE);\n        ivec4 cr = ivec4(texelFetch(iChannel0, CACHE_BASE+ivec2(hash(addr),0),0));\n        if(cr.x != 0){writeMem(cr.x-1, cr.y);}\n        if(cr.z != 0){writeMem(cr.z-1, cr.w);}\n\t\t\n        //Initialize memory on frame 0\n        if(iFrame == 0)\n        {\n            int addr = unmap_region(uv, MEM_BASE, MEM_SIZE);\n\n            writeMem(addr, rom(addr));\n        }\n        \n        //Current key pressed.\n        if(addr == KBD)\n        {\n            int key = scanKeyboard();\n\t\t\tif(key != 0)\n            {\n            \twriteMem(KBD, key);\n            }\n        }\n        \n        //Set bit 7 of KBDCR to 1 to indicate a ket press is available.\n        if(addr == KBDCR)\n        {\n            int key = scanKeyboard();\n            if(key != 0)\n            {\n            \twriteMem(KBDCR, 0x80);\n            }\n        }\n        \n        updateTerminal();\n    }\n    fragColor = frag;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\nMOS 6502 Emulator\n\nDecimal mode & illegal opcodes are not implemented.\n\nInstructions are decoded into a simplified form using the \"microcode\" table in Buffer A.\n\nUses a hash-map based cache to keep track of changed values in RAM without a large array\nthe full size of RAM or searching the entire cache for each read/write.\nThis can sometimes get bottlenecked due to the cache size, reducing the speed as a result.\nThe cache is somewhat small since large arrays have a significant performance impact.\n\nCalculates the hash of the destination address mod cache size.\nIndexes the cache with the hash result.\nChecks the cache at the location to see if it's free (2 slots per cache entry)\nIf it's free, writes the address & value to the cache.\nIf it's in use, sets 'collision' to true to stop the emulator and purge the cache.\n\nThe cache functions assume an address of 0 in the cache array is a unused slot.\nThe address+1 is saved to the cache array. When read, the address-1 is returned.\nThis assumes the array is automatically initialized to 0, though this may be undefined behavior on some systems.\n*/\n\n//Globals\nivec2 uv;\nvec4 frag;\nCPUState cpu, lastState;\nbool collision = false, displayReady = false;\nivec4[CACHE_SIZE] cache;\nint[DSPBUF_SIZE] dsp_buffer;\nint dsp_ptr = 0;\n\n//Writes the cache to the backbuffer for write-back.\nvoid saveCache()\n{\n    if(IN_RECT(uv, CACHE_BASE, ivec2(CACHE_SIZE,1)))\n\t{\n        frag = vec4(cache[uv.x - CACHE_BASE.x]);\n    }\n    \n    if(IN_RECT(uv, DSPBUF_BASE, ivec2(DSPBUF_SIZE,1)))\n\t{\n        frag = vec4(dsp_buffer[uv.x - DSPBUF_BASE.x],0,0,0);\n    }\n}\n\n//Writes CPU state to the backbuffer\nvoid saveState(CPUState state)\n{\n    if(uv == STATE_BASE)\n    {\n    \tfrag = vec4(pack_cpu_state(state));   \n    }\n}\n\n//Read CPU stste from last frame\nCPUState readState()\n{\n\treturn unpack_cpu_state(ivec4(texelFetch(iChannel1, STATE_BASE, 0)));\n}\n\nvoid writePIA(int addr, inout int v)\n{\n    if(addr == DSP) //Set bit 7 of DSP if written to\n    {\n        //If the display isn't ready, write null chars (0).\n        //7th bit is dropped as some chars from wozmon/basic have the 7th bit set which \n        v = displayReady ? v & 0x7F : 0x00;\n        \n        if(dsp_ptr < DSPBUF_SIZE)\n        {\n        \tdsp_buffer[dsp_ptr++] = v;\n            \n            if(dsp_ptr >= DSPBUF_SIZE)\n            {\n                v |= 0x80; //Set bit 7 (terminal wait) if the buffer is full.\n            }\n        }\n        else\n        {\n            v |= 0x80; //Keep bit 7 set if written to after the buffer is full.\n        }\n    }\n\n    if(addr == DSPCR) //Set display ready flag if DSPCR != 0\n    {\n        displayReady = (v != 0); \n    }   \n}\n\n//Writes an address & value to the cache, written to memory next frame.\n//collision = true if the cache location is in use.\nvoid writeMem(int addr, int v)\n{\n    addr &= ADDR_MASK;\n    v &= DATA_MASK;\n    \n    writePIA(addr, v);\n    \n    int ci = hash(addr);\n    ivec4 cr = cache[ci];\n    \n    if(cr.x == 0 || cr.x == addr+1)\n    {\n    \tcache[ci].xy = ivec2(addr+1, v);\n        return;\n    }\n    else if(cr.z == 0 || cr.z == addr+1)\n    {\n        cache[ci].zw = ivec2(addr+1, v);\n        return;\n    } \n    \n    collision = true;\n}\n\n\nvoid readPIA(int addr)\n{\n    if(addr == KBD) //Clear KBDCR if KBD is read\n    {\n        writeMem(KBDCR,0x00);\n    }\n}\n\n//Read 8-bit value from memory\n//Checks if an address is cached.\n//If so, returns cached result\n//If not, reads from the memory buffer\nint readMem8(int addr)\n{\n    addr &= ADDR_MASK;\n    \n    readPIA(addr);\n    \n    ivec4 cr = cache[hash(addr)]; \n    bvec2 cmp = equal(cr.xz, ivec2(addr+1));\n    int result = int(texelFetch(iChannel0, map_region(addr, MEM_BASE, MEM_SIZE), 0).x);;\n    \n    if(any(cmp))\n    {\n    \tresult = cmp.x ? cr.y : cr.w;\n    }\n    \n    return result;\n}\n\n//Read 16-bit value from memory (low byte 1st)\nint readMem16(int addr)\n{\n\tint lo = readMem8(addr);\n    int hi = readMem8(addr+1);\n    return (hi << DATA_BITS) | lo;\n}\n\n//Fetch 8-bit value at current PC\nint fetch8()\n{\n\tint result = readMem8(cpu.reg_PC);\n    cpu.reg_PC++;\n    return result;\n}\n\n//Fetch 16-bit value at current PC\nint fetch16()\n{\n\tint lo = readMem8(cpu.reg_PC);\n    cpu.reg_PC++;\n    int hi = readMem8(cpu.reg_PC);\n    cpu.reg_PC++;\n    return (hi << DATA_BITS) | lo;\n}\n\n//Set negative & zero flags based on A register\nvoid setNZ()\n{\n    BSET(cpu.reg_PSW, N, GETBIT(cpu.reg_A, N));\n    BSET(cpu.reg_PSW, Z, cpu.reg_A == 0);\n}\n\n//Set negative & zero flags based on value 'v'\nvoid setNZ(int v)\n{\n    BSET(cpu.reg_PSW, N, GETBIT(v, N));\n    BSET(cpu.reg_PSW, Z, v == 0);\n}\n\nint decodeAddress(int mode)\n{\n    int addr = 0;\n    \n    if(mode == NON)\n    {\n        //Do nothing    \n    }\n    \n    if(mode == IND)\n    {\n        int indAddr = fetch16();\n        int pcLo = readMem8(indAddr);\n        int pcHi = readMem8((indAddr&0xFF00) | (indAddr+1)&0xFF);\n        addr = (pcHi << 8) | pcLo;\n    }\n    \n    if(mode == ABS)\n    {\n        addr = fetch16();\n    }\n    \n    if(mode == REL)\n    {\n        addr = signed8(fetch8()) + cpu.reg_PC;\n    }\n    \n    if(mode == IMM)\n    {\n        addr = cpu.reg_PC;\n        cpu.reg_PC++;\n    }\n    \n    if(mode == ZPG)\n    {\n        addr = fetch8();\n    }\n    \n    if(mode == ZPX)\n    {\n        addr = (fetch8() + cpu.reg_X) & DATA_MASK;\n    }\n    \n    if(mode == ZPY)\n    {\n        addr = (fetch8() + cpu.reg_Y) & DATA_MASK;\n    }\n    \n    if(mode == IDX)\n    {\n        addr = readMem16((fetch8() + cpu.reg_X) & DATA_MASK);\n    }\n    \n    if(mode == IDY)\n    {\n        addr = readMem16(fetch8());\n        addr = (addr & 0xFF00) | ((addr + cpu.reg_Y) & 0xFF); //Page boundary bug\n    }\n    \n    if(mode == ABX)\n    {\n        addr = (fetch16() + cpu.reg_X) & ADDR_MASK;\n    }\n    \n    if(mode == ABY)\n    {\n        addr = (fetch16() + cpu.reg_Y) & ADDR_MASK;\n    }\n    \n    return addr;\n}\n\nint readRegister(int reg, int mode, out int addr)\n{\n    int val = 0;\n  \n    if(reg == NON)\n    {\n        //Do nothing    \n    }\n    \n    if(reg == ACC)\n    {\n        val = cpu.reg_A;\n    }\n    \n    if(reg == XRE)\n    {\n        val = cpu.reg_X;\n    }\n    \n    if(reg == YRE)\n    {\n        val = cpu.reg_Y;\n    }\n    \n    if(reg == STK) //Pop on read\n    {\n        cpu.reg_SP = (cpu.reg_SP+1) & DATA_MASK; \n        val = readMem8(STACK_BASE + cpu.reg_SP);\n    }\n    \n    if(reg == SPT)\n    {\n        val = cpu.reg_SP;\n    }\n    \n    if(reg == PSW)\n    {\n        val = cpu.reg_PSW;\n    }\n    \n    if(reg == IPT)\n    {\n        val = cpu.reg_PC;\n    }\n    \n    if(reg == MEM)\n    {\n        addr = decodeAddress(mode);\n        val = readMem8(addr);\n    }\n    \n    return val;\n}\n\nint readRegister(int reg, int mode)\n{\n    int tmp = 0;\n    return readRegister(reg,mode,tmp);\n}\n\nvoid writeRegister(int reg, int addr, int val)\n{\n    if(reg == NON)\n    {\n        //Do nothing    \n    }\n    \n    if(reg == ACC)\n    {\n        cpu.reg_A = val;\n    }\n    \n    if(reg == XRE)\n    {\n        cpu.reg_X = val;\n    }\n    \n    if(reg == YRE)\n    {\n        cpu.reg_Y = val;\n    }\n    \n    if(reg == STK) //Push on write\n    {\n        writeMem(STACK_BASE + cpu.reg_SP, val);\n        cpu.reg_SP = (cpu.reg_SP-1) & DATA_MASK;\n    }\n    \n    if(reg == SPT)\n    {\n        cpu.reg_SP = val;\n    }\n    \n    if(reg == PSW)\n    {\n        cpu.reg_PSW = val;\n    }\n    \n    if(reg == IPT)\n    {\n        cpu.reg_PC = val;\n    }\n    \n    if(reg == MEM)\n    {\n        writeMem(addr, val);\n    }\n}\n\n\nvoid executeOp(ivec4 ucode)\n{\n    int dst = ucode.x;  //Destination Register\n    int src = ucode.y;  //Source Register\n    int mode = ucode.z; //Address Mode (for MEM/Branches)\n    int oper = ucode.w; //Operation\n    \n    int tmp = 0;\n    int dstAddr = 0;\n    int dstVal = (dst != STK) ? readRegister(dst, mode, dstAddr) : 0;\n\tint srcVal = (!(src == MEM && dst == MEM)) ? readRegister(src, mode) : 0; \n    \n    if(oper == NON)\n    {\n        //Do nothing    \n    }\n    \n    if(oper == MOV) //Move/Copy\n    {\n        dstVal = srcVal;\n        if(dst != PSW && dst != MEM && dst != STK && dst != SPT)\n        {\n        \tsetNZ(dstVal);\n        }\n    }\n    \n    if(oper == INC) //Increment\n    {\n        dstVal = (dstVal + 1) & DATA_MASK;\n        setNZ(dstVal);\n    }\n    \n    if(oper == DEC) //Decrement\n    {\n        dstVal = (dstVal - 1) & DATA_MASK;\n        setNZ(dstVal);\n    }\n    \n    if(oper == ADC || oper == SBC) //Add with carry / Subtract with borrow\n    {\n        srcVal = (oper == SBC) ? (~srcVal) & DATA_MASK : srcVal; //Invert source bits for SBC\n        \n        int carry = GETBIT(cpu.reg_PSW, C);\n        int tmp_unsigned = dstVal + srcVal + carry;\n        int tmp_signed = signed8(dstVal) + signed8(srcVal) + carry;\n        \n        //C=1 if unsigned add result is >255\n        BSET(cpu.reg_PSW, C, tmp_unsigned > 0xFF);\n        //V=1 if signed add result is outside the range of a signed 8-bit number (-128 - 127)\n        BSET(cpu.reg_PSW, V, tmp_signed < -128 || tmp_signed > 127);\n        \n        dstVal = tmp_unsigned & DATA_MASK;\n        setNZ(dstVal);\n    }\n\n    if(oper == AND) ///Bitwise AND\n    {\n        dstVal = dstVal & srcVal;\n        setNZ(dstVal);\n    }\n    \n    if(oper == OR ) //Bitwise OR \n    {\n        dstVal = dstVal | srcVal;\n        setNZ(dstVal);\n    }\n    \n    if(oper == EOR) //Bitwise XOR\n    {\n        dstVal = dstVal ^ srcVal;\n        setNZ(dstVal);\n    }\n    \n    if(oper == ASL) //Shift bits left, MSB shifted into C\n    {\n        dstVal = (dstVal << 1);\n        BSET(cpu.reg_PSW, C, GETBIT(dstVal, 8));\n        dstVal &= DATA_MASK;\n\t\t\n        setNZ(dstVal);\n    }\n    \n    if(oper == LSR) //Shift bits right, LSB shifted into C\n    {\n        BSET(cpu.reg_PSW, C, GETBIT(dstVal, 0));\n        dstVal = (dstVal >> 1) & DATA_MASK;\n\t\t\n        setNZ(dstVal);\n    }\n    \n    if(oper == ROL) //Shift bits left, C shifted into LSB, MSB shifted into C\n    {\n        dstVal = (dstVal << 1);\n        dstVal |= GETBIT(cpu.reg_PSW, C);\n        BSET(cpu.reg_PSW, C, GETBIT(dstVal, 8));\n        dstVal &= DATA_MASK;\n\n        setNZ(dstVal);\n    }\n    \n    if(oper == ROR) //Shift bits right, C shifted into MSB, LSB shifted into C\n    {\n        dstVal |= GETBIT(cpu.reg_PSW, C) << 8;\n        BSET(cpu.reg_PSW, C, GETBIT(dstVal, 0));\n        dstVal = (dstVal >> 1) & DATA_MASK;\n\n        setNZ(dstVal);\n    }\n    \n    if(oper == CMP) //Compare DST & SRC (C = DST >= SRC, N = MSB of result, Z = DST == SRC)\n    {\n        tmp = dstVal - srcVal;\n        BSET(cpu.reg_PSW, C, dstVal >= srcVal);\n        BSET(cpu.reg_PSW, N, GETBIT(tmp & DATA_MASK, N));\n        BSET(cpu.reg_PSW, Z, tmp == 0);\n    }\n    \n    if(oper == BIT) //N = SRC[7], V = SRC[6], Z = (SRC & DST) == 0\n    {\n        BSET(cpu.reg_PSW, N, GETBIT(srcVal, 7));\n        BSET(cpu.reg_PSW, V, GETBIT(srcVal, 6));\n        BSET(cpu.reg_PSW, Z, (dstVal & srcVal) == 0);\n    }\n    \n    if(oper == BRK) //Break\n    {\n        writeRegister(STK, NON, LO(cpu.reg_PC));\n        writeRegister(STK, NON, HI(cpu.reg_PC));\n        writeRegister(STK, NON, cpu.reg_PSW);\n        cpu.reg_PC = readMem16(0xFFFE);\n        BSET(cpu.reg_PSW, B, 1);\n        BSET(cpu.reg_PSW, I, 1);\n    }\n    \n    if(oper == JMP) //Jump to address\n    {\n        cpu.reg_PC = decodeAddress(mode);\n    }\n    \n    if(oper == JSR) //Jump to subroutine (Push PC-1 into stack, Jump to address)\n    {\n        int newPC = decodeAddress(mode);\n        cpu.reg_PC = (cpu.reg_PC - 1) & ADDR_MASK;\n        writeRegister(STK, NON, HI(cpu.reg_PC));\n        writeRegister(STK, NON, LO(cpu.reg_PC));\n        cpu.reg_PC = newPC;\n    }\n    \n    if(oper == RTS) //Return from subroutine (Pop PC off stack + 1)\n    {   \n        int pcLo = readRegister(STK, NON); \n        int pcHi = readRegister(STK, NON); \n            \n        cpu.reg_PC = ((pcHi << 8 | pcLo) + 1) & ADDR_MASK;\n    }\n    \n    if(oper == RTI) //Return from interrupt (Pop PSW & PC off stack)\n    {\n        cpu.reg_PSW = readRegister(STK, NON);\n        \n        int pcLo = readRegister(STK, NON); \n        int pcHi = readRegister(STK, NON); \n            \n        cpu.reg_PC = (pcHi << 8 | pcLo) & ADDR_MASK;\n    }\n    \n    if(oper == BSE) //Jump to address if flag is set\n    {\n        tmp = decodeAddress(mode);\n        if(GETBIT(cpu.reg_PSW, src) == 1)\n        {\n            cpu.reg_PC = tmp;\n        } \n    }\n    \n    if(oper == BCL) //Jump to address if flag is clear\n    {\n        tmp = decodeAddress(mode);\n        if(GETBIT(cpu.reg_PSW, src) == 0)\n        {\n            cpu.reg_PC = tmp; \n        }\n    }\n    \n    if(oper == FSE) //Set flag\n    {\n        BSET(cpu.reg_PSW, src, 1);\n    }\n    \n    if(oper == FCL) //Clear flag\n    {\n        BSET(cpu.reg_PSW, src, 0);\n    }\n\n    writeRegister(dst, dstAddr, dstVal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = ivec2(fragCoord);\n    frag = texelFetch(iChannel1, uv, 0);\n    \n    bool isCPU = uv == STATE_BASE;\n    bool isCache = IN_RECT(uv,CACHE_BASE,ivec2(CACHE_SIZE,1));\n    bool isVariable = IN_RECT(uv,VAR_BASE,ivec2(8,1));\n    bool isDisplayBuffer = IN_RECT(uv,DSPBUF_BASE,ivec2(DSPBUF_SIZE,1));\n    \n    if(isCPU || isCache || isVariable || isDisplayBuffer)\n    {\n        int hitrate = 0;\n\t\tint opcode = 0;\n        ivec4 ucode = ivec4(0);\n        cpu = readState();\n        displayReady = bool(READ_VAR4(2,iChannel1).y);\n        \n        //Initial CPU state\n        if(iFrame == 0)\n        {\n            cpu.reg_A = 0;\n            cpu.reg_X = 0;\n            cpu.reg_Y = 0;\n            cpu.reg_SP = 0xFD;\n            cpu.reg_PSW = 0x00;\n            cpu.reg_PC = readMem16(RESET_VECTOR);;\n            lastState = cpu;\n            saveState(cpu);\n            displayReady = false;\n        }\n        \n        cpu.reg_PSW |= 0x20; //Unused flag 5 should always be 1\n        \n        for(int i = 0;i < CYCLES;i++)\n        {\n            lastState = cpu;\n            opcode = fetch8();\n\t\t\tucode = ivec4(texelFetch(iChannel2,ivec2(opcode,0),0));\n            executeOp(ucode);\n            \n            if(collision)\n            {\n                //If there's a cache collision, stop the loop until the next frame to clear the cache.\n            \tcpu = lastState;\n                break;\n            }\n                \n            hitrate++;\n        }\n\t\t\n        saveState(cpu); //Save the CPU state\n        saveCache(); //Save the cache to be written back to RAM\n        \n        //Debuging values\n        WRITE_VAR4(0,\n              lastState.reg_PC,\n              opcode,\n              0.02*(float((100*hitrate)/CYCLES) - frag.z)+frag.z,\n              0.02*(float(hitrate)/iTimeDelta - frag.w)+frag.w);\n        \n        WRITE_VAR4(1, cpu.reg_A, cpu.reg_X, cpu.reg_Y, cpu.reg_SP);\n        WRITE_VAR4(2, cpu.reg_PSW, int(displayReady), 0, 0);\n    }\n    \n    fragColor = frag;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}