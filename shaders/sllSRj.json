{
    "Shader": {
        "info": {
            "date": "1626101005",
            "description": "Sommarhack 2021 - Rising phoenix\nWanted to use the distance field created earlier\nMusic: https://soundcloud.com/no-om-uo-n/sommarhack-2020\n",
            "flags": 64,
            "hasliked": 0,
            "id": "sllSRj",
            "likes": 10,
            "name": "Sommarhack 2021 - Rising phoenix",
            "published": 3,
            "tags": [
                "stars",
                "sommarhack"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 452
        },
        "renderpass": [
            {
                "code": "// Sommarhack 2021 - Rising phoenix\n// Wanted to use the distance field created earlier\n// Music: https://soundcloud.com/no-om-uo-n/sommarhack-2020\n\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            (mod(iTime, 3.0*60.0+12.0))\n#define TTIME           (TAU*TIME)\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SCA(a)          vec2(sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n#define DOT2(x)         dot(x, x)\n#define BREAK           16.1\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat hash(float co) {\n  co += 123.4;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat moon(vec2 p, float d, float ra, float rb ) {\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n// Imprecise faster version\nfloat fastMoon(vec2 p, float d, float ra, float rb) {\n  float d0 = length(p) - ra;\n  float d1 = length(p-vec2(d, 0.0)) - rb;\n  return max(d0, -d1);\n}\n\nfloat roundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(DOT2(p-vec2(1,k)))  :\n           sqrt(min(DOT2(p-vec2(0,h)),\n                    DOT2(p-vec2(1,0))));\n}\n\nfloat plane(vec2 p, vec3 pp) {\n  return dot(p, pp.xy) + pp.z;\n}\n\n\nfloat summerhack(vec2 p) {\n  // As the moon shapes are mostly used for cut-outs I think there is less need for exact\n  //  moon distance and therefore rely on fastMoon instead\n  vec2 op = p;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.385);\n  float d0 = circle(p0, 0.605);\n  vec2 p1 = p;\n  p1 -= vec2(0.0, -0.375);  \n  float d1 = vesica(p1, vec2(0.04, 0.569))-(mix(0.005, 0.035, smoothstep(0.1, 0.2, p1.y)));\n  \n  vec2 p2 = p;\n  p2 -= vec2(0.0, 0.4);\n  p2 = -p2.yx;\n  float d2 = fastMoon(p2, 0.075, 0.33, 0.275);\n  \n  vec2 p3 = p;\n  p3 -= vec2(0.0, 0.65);\n  float d3 = circle(p3, 0.367);\n  \n  vec2 p4 = p;\n  p4 -= vec2(0.0, 0.43);\n  float d4 = circle(p4, 0.29);\n  \n  vec2 p5 = p;\n  p5 -= vec2(-0.185, 0.12);\n  float d5 = circle(p5, 0.30);\n  \n  vec2 p6 = p;\n  p6 -= vec2(0.12, -0.19);\n  p6 *= ROT(0.65);\n  float d6 = vesica(p6, vec2(0.15, 0.024))-0.0175;\n  \n  vec2 p7 = p;\n  p7 -= vec2(0.0, 0.735);\n  p7 = -p7.yx;\n  float d7 = fastMoon(p7, 0.13, 0.68, 0.595);\n  \n  vec2 p8 = p;\n  p8 -= vec2(0.0, 0.7);\n  p8 = -p8.yx;\n  float d8 = fastMoon(p8, 0.1, 0.477, 0.4676);\n\n  vec2 p9 = p;\n  p9 -= vec2(0.25, 0.72);\n  p9.x = -p9.x;\n  float d9 = fastMoon(p9, 0.188, 0.73, 0.775);\n\n  vec2 p10 = op;\n  p10 -= vec2(0.0, 0.28);\n  p10 = p10.yx;\n  p10.x *= sign(op.x);\n  p10.x += (-sign(op.x)+1.0)*-0.0775;\n  float d10 = moon(p10, 0.045, 0.105, 0.095);\n\n  vec2 p11 = p;\n  p11 -= vec2(0.0, -0.78);\n  p11 = p11.yx;\n  float d11 = roundedCross(p11, 0.55);\n  \n  vec2 p12 = p;\n  float d12 = plane(p12, vec3(normalize(vec2(-4.0, 1.0)), 0.315));\n  \n  vec2 p13 = p;\n  p13 -= vec2(-0.05, -0.805);\n  float d13 = circle(p13, 0.175);\n\n  vec2 p14 = p;\n  p14 -= vec2(0.0, -0.88);\n  float d14 = p14.y;\n  \n  vec2 p15 = p;\n  p15 -= vec2(0.45, -0.4);\n  p15 = p15.yx;\n  float d15 = fastMoon(p15, 0.14, 0.4, 0.4);\n\n  vec2 p16 = op;\n  p16 -= vec2(-0.095, 0.323);\n  // Cheat to remove discontinuity in distance field due to hacking on d10\n  float d16 = length(p16); \n    \n  d11 = max(d11, -d12);\n  d11 = max(d11, -d13);\n  d11 = max(d11, -d14);\n  d11 = max(d11, -d15);\n\n  float dn = d3;\n  dn = min(dn, d4);\n  dn = min(dn, d2);\n  dn = min(dn, d5);\n  dn = min(dn, d6);\n  dn = min(dn, d7);\n  dn = min(dn, d8);\n  dn = min(dn, d9);\n\n  float d = d0;\n  d = max(d, -dn);\n  d = min(d, d1);\n  d = min(d, d10);\n  d = min(d, d11);\n  d = min(d, d16);\n  \n\n  return d;\n}\n\nfloat beat() {\n  float fft = 0.0;\n  fft += texture(iChannel0, vec2(0.1, 0.25)).x; \n  fft += texture(iChannel0, vec2(0.2, 0.25)).x; \n  fft += texture(iChannel0, vec2(0.3, 0.25)).x; \n  fft += texture(iChannel0, vec2(0.4, 0.25)).x; \n  fft *= 0.25;\n  return fft;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd, float b) {\n  b *= step(BREAK, TIME);\n\n  const vec3 l = normalize(vec3(0.0, 0.0, 1));\n  vec3 baseCol = vec3(0.5, 0.66, 1.0)+b*b*vec3(1.0);\n  return 1.25*baseCol*pow(max(dot(l, normalize(rd*vec3(1.0, 0.33, 1.0))), 0.0), mix(250.0, 200.0, b));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p, float b) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  \n  vec3 skyCol = skyColor(ro, rd, b);\n\n  float aa = TIME*0.125;\n  rd.yx *= ROT(aa);\n  float a = atan(rd.y, rd.x);\n\n  vec3 col = skyCol;\n  const float mm = 5.0;\n  for(float i = 0.0; i < mm; ++i) {\n    float ma = a;\n    float ii = i/(mm-1.0);\n    float sz = 31.0+i*64.0;\n    float slices = TAU/sz; \n    float na = mod1(ma, slices);\n\n    float hh = hash(na+113.0*i);\n    float h1 = hh;\n    float h2 = fract(hh*113.0);\n    float h3 = fract(hh*127.0);\n\n    float tr = mix(0.25, 2.0, h1);\n    vec2 tc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), tr);\n    vec3 tcp = ro + tc.y*rd;\n    vec2 tcp2 = vec2(tcp.z+h2*2.0, atan(tcp.y, tcp.x));\n  \n    float sx = mix(0.75, 1.5, h3);\n    vec2 tnp2 = mod2(tcp2, vec2(sx, slices));\n    tcp2.y *= tr*PI;\n    float h4 = hash(tnp2.x+hh);\n    float h5 = fract(113.0*h4);\n    tcp2.x += 0.4*sx*h4;\n    float d = length(tcp2)-0.001;\n\n    float si = exp(-(100.0+1.4*sz)*max(d, 0.0));\n\n    vec3 hsv = vec3(-0.0-0.4*h4, mix(0.4, 0.00, ii), 1.0);\n    vec3 bcol = hsv2rgb(hsv)*3.0;\n    vec4 scol = vec4(bcol*sqrt(si), sqrt(si)*exp(-0.05*tc.y*tc.y));\n\n    col = alphaBlend(col, scol);\n  }\n\n  return col;\n}\n\nvec3 overlay(vec3 col, vec2 p, vec2 q, float b) {\n  vec2 op = p;\n  float aa = 2.0/RESOLUTION.y;\n\n  float dist = PCOS(80.0*(op.y-TTIME/30.0))*PCOS(23.0*length(op+op.x-TTIME/43.0));\n  float fade = mix(0.7, 1.0, smoothstep(15.0, 20.1, TIME))*mix(0.945, 0.95, smoothstep(0.5, 1.0, q.y)*dist)*0.97;\n\n  vec2 pi = p;\n  float off = sqrt(p.x*p.x+p.y*p.y);\n  const float coff = PI;\n  float angle = off+mix(coff*0.42, -coff*0.42 , fade);\n  float split = angle+coff;\n  int nsplit = int(mod1(split, coff));\n  split = (nsplit & 1) == 0 ? split : -split;\n\n  const float zi = 1.0;\n  pi /= zi;\n  float di  = summerhack(pi);\n  float dii = abs(di-0.0125) - 0.0025;\n  di = min(di, dii);\n  di *= zi;\n  \n  float dg = di;\n\n  const vec3 lcol2 = vec3(2.0, 1.55, 1.25).zyx*0.85;\n\n  float gmix = pow(abs(cos(angle)), 14.0);\n  float gmix2 = abs(1.0/tanh_approx(split))*0.5;\n\n  dg = abs(dg-0.025);\n  float glow = exp(-10.0*max(dg+0., 0.0));\n  vec3 glowCol = mix(lcol2.zyx*lcol2.zyx/6.0, lcol2.zyx, glow*glow)*gmix2;\n  col = mix(col, vec3(mix(vec3(0.9), sqrt(glowCol*0.5), gmix)), smoothstep(-aa, aa, -di));\n  col += glowCol*glow*gmix;\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME;\n  vec3 ro   = vec3(0.0, 0, tm);\n  vec3 dro  = normalize(vec3(0.20, 0.2, 1.0));\n  dro.xz *= ROT(0.2*sin(0.05*tm));\n  dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)));\n  vec3 up = vec3(0.0,1.0,0.0);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  float b = beat();\n  \n  vec3 col = color(ww, uu, vv, ro, p, b);\n  \n  if (TIME > BREAK) {\n    col = overlay(col, p, q, b);\n  }\n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  \n  col += smoothstep(2.0+0.25*length(p), 0.0, TIME);\n  col += smoothstep(BREAK-0.4+length(p)*0.15, BREAK, TIME)*smoothstep(BREAK+3.0+length(p), BREAK, TIME);\n  \n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 27794,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/no-om-uo-n/sommarhack-2020"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}