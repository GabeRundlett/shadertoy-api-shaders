{
    "Shader": {
        "info": {
            "date": "1588674498",
            "description": "Ray-surface intersection for a cone or other quadric requires solving a quadratic equation and numeric errors can occur. One type, noticeable here at the cone apex, is fixable by moving the ray origin closer to the surface.",
            "flags": 16,
            "hasliked": 0,
            "id": "wdlBR2",
            "likes": 6,
            "name": "Raytracing a Cone",
            "published": 3,
            "tags": [
                "raytracing",
                "quadric",
                "cone",
                "quadratic",
                "hyperboloid"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Ray tracing a cone, showing effect of rounding errors on quadratic solution.\n// See https://www.shadertoy.com/view/WdXfR2 for similar problems with sphere.\n//\n// Errors are particularly pronounced at cone apex, even at smaller distances,\n// can be significantly reduced by moving the projection point closer to the\n// surface (compare LHS of image with RHS, zoom in with 'z').\n//\n// Despite shader name, it also does hyperboloids and spheres (illustrating\n// another, possibly GPU dependent, source of numeric error).\n//\n// Matthew Arcus, mla, 2020.\n//\n// <mouse>: rotate cone\n// b: background\n// c: clip cone\n// h: hyperboloid\n// q: quality\n// x: sphere\n// z: extra zoom in\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nint quality = 0;\n\n// NB: This solves Ax^2 + 2Bx + C = 0 (with factor of 2 on B)\nbool quadratic(float A, float B, float C, out vec2 t) {\n  // Sometimes should also check for A = 0 or C = 0\n  float D = B*B-A*C;\n  if (D < 0.0) return false;\n  float x,y;\n  if (true) {\n    // The wrong way, but doesn't seem to cause problems\n    // with this shader.\n    x = (-B-sqrt(D))/A;\n    y = (-B+sqrt(D))/A;\n  } else {\n    // The right way\n    x = B <= 0.0 ? -B-sqrt(D) : -B+sqrt(D);\n    y = C/x;\n    x /= A;\n  }\n  // Return solutions in order\n  t = x < y ? vec2(x,y) : vec2(y,x);\n  return true;\n}\n\nbool dohyperboloid = false;\nbool doclip = true;\nbool dosphere = true;\n\nint checkcone(vec3 p) {\n  float height = dohyperboloid ? 2.0 : 1.0;//exp(iTime);\n  if (doclip && abs(p.y) > height) return 0;\n  float N = 16.0;\n  float i = floor(N*(atan(p.z,p.x))/PI);\n  float j = floor(N*p.y/height);\n  return int(mod(i+j,2.0));\n}\n\nint intersectcone(vec3 p, vec3 r, out vec3 n) {\n  float k = 0.0;\n  if (quality == 1) {\n    // Move projection point to be orthogonal to cone apex.\n    k = -dot(p,r); p += k*r;\n  }\n  // Quadric equation is: (p*X).p = 0\n  // So solve: ((p+tr)*X).(p+tr) = 0\n  vec3 X = dosphere ? vec3(1) : vec3(1,-1,1);\n  // Since r is normalized, can take a shortcut for a sphere.\n  float A = dosphere ? 1.0 : dot(r*X,r);\n  float B = dot(p*X,r);\n  float C = dot(p*X,p);\n  if (dosphere) C -= 1.0;\n  else if (dohyperboloid) C += sin(0.2*iTime);// Hyperboloid\n  vec2 t;\n  if (!quadratic(A,B,C,t)) return 0;\n  int type;\n  vec3 q;\n#if 0\n  // Do people prefer assignments in conditionals,\n  if (!(t.x+k >= 0.0 && (type = checkcone(q = p+t.x*r)) != 0) &&\n      !(t.y+k >= 0.0 && (type = checkcone(q = p+t.y*r)) != 0)) {\n    return 0;\n  }\n#elif 0\n  // or using a one-iteration loop and break/return?\n  for(;;) {\n    if (t.x+k >= 0.0) {\n      q = p+t.x*r;\n      type = checkcone(q);\n      if (type != 0) break;\n    }\n    if (t.y+k >= 0.0) {\n      q = p+t.y*r;\n      type = checkcone(q);\n      if (type != 0) break;\n    }\n    return 0;\n#else\n  // Or just this?\n  type = 0;\n  if (t.x+k >= 0.0) {\n     q = p+t.x*r;\n     type = checkcone(q);\n  }\n  if (type == 0 && t.y+k >= 0.0) {\n     q = p+t.y*r;\n     type = checkcone(q);\n  }\n  if (type == 0) return 0;\n#endif\n  \n  n = normalize(q*X);\n  if (dot(n,r) > 0.0) n = -n;\n  return type;\n}\n\nint intersectscene(vec3 p, vec3 r, out vec3 n) {\n  return intersectcone(p,r,n);\n}\n\nvec3 getcolor(vec3 p) {\n  return abs(p);\n}\n\nvec3 raycolor(vec3 p, vec3 r, vec3 light) {\n  vec3 n;\n  int type = intersectscene(p,r,n);\n  if (type == 0) {\n    return vec3(0);\n  } else {\n    float ambient = 0.3;\n    float diffuse = 0.3;\n    vec3 basecolor = getcolor(n);\n    if (type == 2) basecolor *= 0.8;\n    vec3 color = basecolor*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r)),5.0);\n    //vec3 speccol = vec3(1);\n    vec3 speccol = basecolor;\n    color += 0.5*specular*speccol;\n    return color;\n  }\n}\n\nvec2 rotate(vec2 p, float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (true) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n    p.xy = rotate(p.xy,iTime * 0.125);\n  }\n  return p;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_H = 72;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dohyperboloid = key(CHAR_H);\n  dosphere = key(CHAR_X);\n  doclip = !key(CHAR_C);\n  vec3 light = vec3(0.5,1.0,-1.0);\n  light = transform(light);\n  light = normalize(light);\n  float camera = 1.0;\n  float t = iTime;\n  t = mod(t,20.0);\n  camera *= exp(t);\n  vec3 p = vec3(0,0,-camera);\n  p = transform(p);\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      if (key(CHAR_Z)) uv *= 0.1; \n      vec3 r = vec3(uv,camera);\n      r = normalize(r);\n      r = transform(r);\n      if (uv.y < 0.0) r = normalize(r); // Normalize after transform\n      if (uv.x < 0.0 || key(CHAR_Q)) quality = 1;\n      vec3 c = raycolor(p,r,light);\n      if (c == vec3(0) && key(CHAR_B)) c = pow(texture(iChannel0,uv).xyz,vec3(2.2));\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}