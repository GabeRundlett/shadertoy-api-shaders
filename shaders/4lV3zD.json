{
    "Shader": {
        "info": {
            "date": "1473594695",
            "description": "Approach to an efficient raymarcher with focus on precision, small source code.\nended up proving that READING a Buffer is not a bottleneck. so it likely is writing syncronization that lags.\nhere BufA gives the option to read|write ASYNCRONOUSLY from self",
            "flags": 32,
            "hasliked": 0,
            "id": "4lV3zD",
            "likes": 3,
            "name": "ollj basic1 curtain",
            "published": 3,
            "tags": [
                "grid",
                "buffer",
                "curtain"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 757
        },
        "renderpass": [
            {
                "code": "//the lower half of this image shows bufferA's lower half.\n//the upper half of this image shows the image of bufferA's upper half\n//... stretched over *((n-w)/n), flipped and shfted.\n//so that the white field is hidden.\n//bufferA may use the white part of itself to buffer any variables.\n\n//Curtain function:\n//one common problem is:\n//you would like to buffer rotations of kinematic systems\n//instead of calculating them for each fragment.\n//but reading from other buffers is a bottleneck in a javascript canvas.\n//\n//this spkits a buffer in 2 images at [st]\n//the white left side is used to buffer data in fragments\n//the right side is used to buffer an image\n//that is calculated with the data from the same buffer.\n//\n//this mainImage function then stretches the image over the data.\n\n//function to test if there is a difference in reading from buffer.self\n//to reading from buffer.other.\nfloat BufferReadBenchmark(float r){\n const int side=2;//till sep 12 this value was set much higher, leading to client crashes....\n for(int i=0;i<side;i++){\n  for(int j=0;j<side;j++){\n   for(int k=0;k<side;k++){\n//    for(int l=0;l<side;l++){\n//  for(int m=0;m<side;m++){\n//   for(int n=0;n<side;n++){\n   r+=texture(iChannel0,vec2(i-j+k)).x;\n //}}}\n}}}return r;}\n//this benchmark function hows that the performance problem is not in reading from a buffer.\n//so its mor likely the writng in a buffer \n//and the synchronizazion that isa latency bottleneck.\n//as in; buffer1 wont start computing any fragment of a fram\n//before every singlke fragment of buffer0 is done computing for the same frame.\n//and ths bottleneck is eliminated by using one buffer for 2 things.\n\n\n//a, range [0,n] projected to [w,n]\nfloat curtain(float a,float n,float w){\n return n-(n-a)*((n-w)/n)//scaled by *((n-w)/n)\n;}\n//a, range [0,n] projected to [1,n]\nfloat curtain1(float a,float n){\n return n-(n-a)*((n-1.)/n);}\n\n//ill admit that \n//just drawing a black frame to hide data \n//might be more efficient\n//and not stretch the image to a blurry mess.\n\n\nvoid mainImage(out vec4 r,in vec2 i){\n float test=BufferReadBenchmark(0.);\n float st=sin(iTime+test-test)*.25+.25;\n if(i.y>iResolution.y*.5) \n  i.x=curtain(i.x,iResolution.x,iResolution.x*st);\n r=vec4(test);\n r=texture(iChannel0,i/iResolution.xy);}\n//instead of doig multiple texture reads, \n//we just do one texture() call.\n//because texture() tends to be a bottleneck, \n//especially with shaertoy's javascript boilerplate.",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//the idea is to store buffered pixel in the same buffer as the image that these determine.\n//buffered pixel may store quaternion rotations or particle positions...\n//buffered pixel area is white in this one.\n//storing data and image in the same buffer removes synchronization,\n//as it changes the order of operations to something less prdictable,\n//a all fragments are calculated in parallel, \n//they may at ifferent times read|write data pixels.\n\n//the loss of syncing is traded for the gain \n//of not needing to calculate the same (inverse) kinematics for each fragment.\n\n//the loss of synchronizazion avtually equals very lazy motion blur.\n\n//\n//the hope is that less synchroniation results in better framerates.\n//this makes sense for systems were snchronizzion is secondary.\n//especially systems that initially read a lit if data, then calculate a lot.\n//and then write some data, \n//this makes sense for the fragments hat calculate inverse kinematic for the next frame.\n//hopefully AFTER every fragment has read the previous data.\n//because it likely is computationally more complex to clculate ik|physics \n//than to raymarch a scene that was set by the physics calculation of the previous frame.\n\n//defines can have parametric axes|VectorFields\n#define ifvp(A)if(fract(v.A*iResolution.A/i)<1./i)r*=pow(.99,i);\n\nfloat grid(vec2 v){float r=1.,i=1.;\nfor(int e=0;e<16;e++){i*=2.;\n ifvp(x);ifvp(y);\n }return r;}\n\n//function to test if there is a difference in reading from buffer.self\n//to reading from buffer.other.\nfloat BufferReadBenchmark(float r){\n const int side=2;//till sep 12 this value was set much higher, leading to client crashes....\n for(int i=0;i<side;i++){\n  for(int j=0;j<side;j++){\n   for(int k=0;k<side;k++){\n   r+=texture(iChannel0,vec2(0.0)).x;\n }}}return r;}\n\nvoid mainImage(out vec4 r, in vec2 i){\n float test=BufferReadBenchmark(0.);\n float st=sin(iTime+test-test)*.25+.25;\n if (i.x<vec2(st*iResolution.x).x)r=vec4(1);\n //white line on left border.\n //in here you may have BuffA read from itself. \n //which could be faster (at leas on some boilerplates)?\n //wither way, you can merge multiple buffers into one.\n else {\n //the actual image. here a pixel perfect grid to visualize blur\n     \n vec2 v=i.xy/iResolution.xy;\n //r=vec4(v,0.5+0.5*sin(iTime),1.0);\n r=vec4(test);\n r=vec4(v,1.,1.)*grid(v);\n}}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}