{
    "Shader": {
        "info": {
            "date": "1713637528",
            "description": "Use the mouse to look around :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4fcXRN",
            "likes": 6,
            "name": "cola bottle",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "raymarch",
                "marching",
                "bottle",
                "cola"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 155
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define ZERO min(iFrame, 0)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define NEAR 0.003\n#define FAR 60.0\n#define STEPS 60\n#define AMBIENT 0.1\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sclamp(in float v, in float mi, in float ma, in float k) {return smin(smax(v, mi, k), ma, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat ssign(float x, float k) { float s = smoothstep(-k, k, x); return mix(s, sign(x), 0.5*clamp(max(0.0, 1.0-(abs(s)*2.5))*max(0.0, 1.0-k), 0.0, 1.0));}\n\nvec3 thash(vec2 p, float seed) {\n    return textureLod(iChannel0, ((p  + seed) / 256.0), 0.0).xyz;\n}\n\nvec3 tnoise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(thash(id+vec2(0,0),s),thash(id+vec2(1,0),s),lv.x),\n             mix(thash(id+vec2(0,1),s),thash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nvec3 tnoise(vec2 p, float s, float freq, float warp, const in int oct) {\n  vec3 n = vec3(0.0);\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*tnoise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n.x*6.28), cos(n.y*6.28));\n\n  }\n  return n / div;\n}\n\n\nstruct Light {\n  vec3 p;\n  vec3 dir;\n  vec3 color;\n  float strength;\n  int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIRECTIONAL 2\n\nvec3 getLightDir(Light light, vec3 p) {\n  switch (light.type) {\n    case LIGHT_AMBIENT: return normalize(light.p); break;\n    case LIGHT_POINT: return normalize(light.p - p); break;\n    case LIGHT_DIRECTIONAL: return normalize(-light.dir); break;\n    default: return normalize(vec3(1, 2, 3)); break;\n  }\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 N) {\n  vec3 L = getLightDir(light, p);\n  float NdotL = max(AMBIENT, dot(N, L));\n  switch (light.type) {\n    case LIGHT_AMBIENT: return NdotL * light.strength * light.color; break;\n    case LIGHT_POINT: return pow(NdotL * light.strength * light.color, vec3(2.0)) / max(0.0000353, pow(distance(light.p, p), 2.0));\n    case LIGHT_DIRECTIONAL: {\n      return light.color * light.strength * NdotL * smoothstep(0.8, 1.0, dot(\n        normalize(light.p - p),\n        L\n      )); break;\n    }\n  }\n\n  return vec3(0.5);\n}\n\nstruct Material {\n  float rough;\n  float spec;\n  float z;\n  float ior;\n};\n\n#define NEW_MATERIAL Material(0.0, 0.0, 0.0, 0.0)\n\nstruct Object {\n  int id;\n  vec3 p;\n  vec3 q;\n};\n\n#define NEW_OBJECT Object(-1, vec3(0.0), vec3(0.0))\n\nstruct Data {\n  vec3 p;\n  vec3 n;\n  float d;\n  float sig;\n  int skip;\n  Object o;\n  Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, 1.0, -1, NEW_OBJECT, NEW_MATERIAL)\n\n\nfloat cylSDF(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ba = b - a;\n  vec3 pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, max(p.y, p.z)));\n}\n\n#define SAMPLE(ID, DIST) if (DIST < dist) { dist = DIST; id = ID; }\n\n#define ID_BODY 0\n#define ID_CAP 1\n#define ID_TABLE 2\n#define ID_GROUND 3\n\nfloat bodySDF(vec3 p, float h, float r) {\n    float dm = abs(p.y-(h*0.5));\n    float k = r;\n    r = mix(r, k*2.25, slt(abs(p.y-(h*0.5)), h*0.3333, 0.6)*slt(p.y, h*0.9, 1.2));\n    r = mix(r, k*2.25, slt(p.y, 0.9, 0.45));\n    return cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), r);\n}\n\nfloat capSDF(vec3 p, float h, float r) {\n    return cylSDF(p, vec3(0, h, 0), vec3(0, h+0.25, 0), r*1.1);\n}\n\nfloat bottleSDF(vec3 p, inout Data data) {\n    int id = data.o.id;\n    float dist = data.d;\n    float h = 3.0;\n    float r = 0.3;\n    \n    if (data.skip != ID_BODY) {\n        float body = bodySDF(p, h, r);\n        SAMPLE(ID_BODY, body);\n    }\n    float cap = capSDF(p, h, r);\n    SAMPLE(ID_CAP, cap);\n    data.o.id = id;\n    return dist;\n}\n\nfloat tableSDF(vec3 p) {\n    float w = 8.0;\n    float depth = 4.0;\n    float bh = 0.25;\n    float h = 6.0;\n    float r = 0.3333;\n    \n    float dist = FAR;\n    float board = boxSDF(p, vec3(w, bh, depth));\n    dist = min(dist, board);\n    \n    float inset = r*2.0;\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)), vec3(w-inset, -h, depth-inset), vec3(w-inset, 0, depth-inset), r);\n    \n    dist = min(dist, leg);\n    \n    return dist;\n    \n}\n\nfloat groundSDF(vec3 p) {\n    if (p.y > 11.0) return p.y;\n    vec3 n1 = tnoise(p.xz, 11.14925, 0.1, 0.1, 3);\n    float h = n1.x*(10.*(1.0+(n1.y*n1.y)))*smoothstep(16.0, 30.0, length(p.xz));\n    return p.y - h;\n}\n\nfloat sdf(vec3 p, inout Data data) {\n    int id = data.o.id;\n    float dist = data.d;\n    \n    float bottle = bottleSDF(p - vec3(0, 6.253, 0), data);\n    id = data.o.id;\n    dist = bottle;\n    \n    \n    float table = tableSDF(p - vec3(0, 6, 0));\n    \n    SAMPLE(ID_TABLE, table);\n    data.o.id = id;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ID_GROUND, ground);\n    data.o.id = id;\n        \n    return dist;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = data.sig * sdf(p, data);\n        if (abs(next) >= FAR) return false;\n        if (abs(next) <= (NEAR*(1.0 + abs(d)))) break;\n        d += next;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NEAR, 0);\n    vec3 n = normalize(sdf(p, data) - vec3(\n        sdf(p - e.xyy, data),\n        sdf(p - e.yxy, data),\n        sdf(p - e.yyx, data)\n    ));\n    \n    data.p = p;\n    data.n = n;\n    data.d = d;\n    \n    return true;\n}\n\nfloat getShadow(vec3 ro, float NdotL, Light light) {\n    Data data = NEW_DATA;\n    float init = NEAR*9.0;\n    float d = init;\n    vec3 L = getLightDir(light, ro);\n    vec3 rd = L;\n    float ad = 0.0;\n    \n    for (int i = ZERO; i < 32; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        //if (next >= FAR) return 1.0;\n        if (next <= -NEAR) break;\n        ad += next;\n        d += clamp(next, 0.005, 2.0);\n    }\n    \n    if (d <= init) return 1.0;\n    float s = ad / (1.0 + ad);\n    \n    return clamp(s*s*s*s, AMBIENT, 1.0);\n}\n\n\nvec3 forEachLight(Light light, vec3 ro, vec3 rd, Data data, vec3 diffuse) {\n  vec3 p = data.p;\n  vec3 N = data.n;\n  vec3 L = getLightDir(light, p);\n  float NdotL = dot(N, L);\n  vec3 att = getLightAtt(light, p, N);\n  vec3 ref = reflect(N, L);\n  float VdotR = max(0.0, dot(rd, ref));\n  float spec = pow(VdotR, 24.0)*data.m.spec;\n  float shadow = (data.sig < 0.0) ? 1.0 : (NdotL <= 0.015) ? max(AMBIENT, abs(NdotL)) : getShadow(data.p, NdotL, light);\n  return ((diffuse + spec) * att) * shadow;\n}\n\nvec3 getAlbedoCap(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = mix(mix(p.xy, p.yz, (abs(dot(n, vec3(1, 0, 0))))), p.xz, (abs(dot(n, vec3(0, 1, 0)))));\n\n\n    col = vec3(0.99, 0.1, 0.045);\n    \n    \n    return col;\n}\n\n\nfloat chr(vec2 p, int c) {\n    if (c == 32) return 0.0;\n    p = (((p-vec2(0, 1))+vec2(float(int(1.0+float(c-97))),\n    int(-6 - (c > 111 ? 1 : 0))))/16.);\n    return texture(iChannel1, p).x;\n}\n\n\n#define TEXT(P, CHARS)\\\n{\\\n  int chars[] = int[] CHARS;\\\n  int len = chars.length();\\\n  vec2 id = floor((P)*(float(len/2)+1.));\\\n  vec2 lv = fract((P)*(float(len/2)+1.));\\\n  int idx = int(id.x);\\\n  text += (idx < 0 || idx >= len || abs(lv.x-0.9)<0.1 || abs(lv.y-0.9)<0.1) ? 0.0 : \\\n      chr(lv, chars[idx]);\\\n}\n\n\nvec3 getAlbedoBody(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    p.y -= 6.0;\n    vec3 n = data.n;\n    vec2 uv = mix(mix(p.xy, p.yz, (abs(dot(n, vec3(1, 0, 0))))), p.xz, (abs(dot(n, vec3(0, 1, 0)))));\n\n    col = vec3(0.45, 0.1, 0.1);\n    \n    float pm = abs((p.y)-1.5);\n    float label = slt(pm, 0.5, 0.02);\n    \n    col = mix(col, vec3(1.0), label);\n    \n    vec2 coord = p.xy;//mix(p.xy, p.zy, floor(abs(dot(n, vec3(1, 0, 0)))));\n    \n    coord.y += 0.1;\n    coord.x += 0.5;\n    coord *= 1.1;\n    float text = 0.0;\n    TEXT(coord, (99, 111, 108, 97))\n    col = mix(col, vec3(0.0), text*label*float(p.y > 1.4 && p.y < 1.7));\n    \n    //col = mix(col, vec3(0.0), sc);\n    \n    data.m.ior = 1.490*max(0.0, 1.0-label);\n    \n    return col;\n}\n\nvec3 getAlbedoTable(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = mix(mix(p.xy, p.yz, (abs(dot(n, vec3(1, 0, 0))))), p.xz, (abs(dot(n, vec3(0, 1, 0)))));\n\n    \n    vec3 n1 = tnoise(uv, 0.31254, 2.0, 0.03, 2);\n    vec3 n2 = tnoise(uv, 4.49583, 3.0, 0.03, 2);\n    \n    vec3 c1 = vec3(0.4, 0.2, 0.05);\n    vec3 c2 = vec3(0.5, 0.21, 0.09);\n    vec3 c3 = vec3(0.49, 0.29, 0.005);\n    vec3 c4 = vec3(0.4, 0.2, 0.1);\n    \n    \n    float px = 0.5+0.5*sin((2.0*n1.z+uv.x*6.28+2.2*(cos(uv.y*6.28+2.0*n1.x)))*(1.0+n2.y));\n    float py = 0.5+0.5*cos((2.0*n1.x+uv.x*6.28+2.2*(sin(uv.y*6.28+2.0*n1.y)))*(1.0+n2.x));\n    \n    col = mix(col, c1, n1.x);\n    col = mix(col, c2, n1.y);\n    col = mix(col, c3, n1.z);\n    col = mix(col, c4, n2.x);\n    col = mix(col, col*col, px*n1.x*n2.y);\n\n    data.m.spec = n2.x*max(0.0, 1.0-max(px, py))*n2.x*n2.x*0.5;\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 c1 = vec3(0.1, 0.7, 0.05);\n    vec3 c2 = vec3(0.25, 0.69, 0.09);\n    vec3 c3 = vec3(0.09, 0.39, 0.02);\n    vec3 c4 = vec3(0.25, 0.39, 0.05);\n    \n    vec3 n1 = tnoise(p.xz, 0.211155);\n    vec3 n2 = tnoise(p.xz*0.25, 10.44233);\n    vec3 n3 = tnoise(p.xz*0.25, 16.66343, 2.0, 0.05, 2);\n    \n    col = mix(c1, c2, n1.x);\n    col = mix(col, c3, n1.y);\n    col = mix(col, c4, smoothstep(0.4, 0.7, n3.x));\n    col = mix(col, col*col, n2.x);\n    \n    return col;\n}\n\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.o.id) {\n        case ID_CAP: return getAlbedoCap(data); break;\n        case ID_BODY: return getAlbedoBody(data); break;\n        case ID_TABLE: return getAlbedoTable(data); break;\n        case ID_GROUND: return getAlbedoGround(data); break;\n    }\n    \n    return vec3(0.48);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 getColor(vec3 ro, vec3 rd, inout Data data) {\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(1, 3, -1), vec3(0.0), vec3(0.97, 0.89, 0.79), 2.0, LIGHT_AMBIENT);\n    \n    if (march(ro, rd, data)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        col += forEachLight(light, ro, rd, data, diffuse);\n    } else {\n        col += getSky(rd);\n    }\n    \n    return max(col, vec3(0.0));\n}\n\n\nvoid mainImage(out vec4 o, in vec2 fc)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc.xy - 0.5 * R.xy) / R.y;\n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy) / R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0, 1.9, -5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    if (m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float ten = sgt(iTime, 8.0, 0.5)*slt(iTime, 12.0, 0.5);\n        ro.z -= mix((0.5+0.5*sin(iTime))*3.0, 0.0, ten);\n        float ang = mix(iTime, 0.0, ten);\n        //ro.yz *= rot(ang);\n        ro.xz *= rot(ang);\n       // rd.yz *= rot(ang);\n        rd.xz *= rot(ang);\n    }\n    \n    ro.y += 6.0;\n    \n    Data data = NEW_DATA;\n    col += getColor(ro, rd, data);\n    \n    if (data.m.ior > 0.01) {\n        vec3 n = data.n;\n        vec3 p = data.p;\n        float ior = data.m.ior;\n        \n        vec3 enterDir = refract(rd, n, 1.0/ior);\n        Data enterData = NEW_DATA;\n        enterData.sig = -data.sig;\n        \n        \n         vec3 enterP = p+(n*enterData.sig*NEAR*10.);\n        vec3 enterCol = getColor(enterP, enterDir, enterData);\n        \n        \n        Data exitData = NEW_DATA;\n        exitData.sig = -enterData.sig;\n        exitData.skip = ID_BODY;\n        vec3 exitDir = refract(enterDir, enterData.n, ior);\n\n        \n        if (length(exitDir) < 0.000001) {\n          exitDir = reflect(enterDir, enterData.n);\n          exitData.sig *= -1.0;\n        }\n        \n       \n        vec3 exitP = enterData.p+(enterData.n*NEAR*enterData.sig);\n        vec3 exitCol =  getColor(exitP, exitDir, exitData);\n        col =  exitCol * enterCol* M_PI;\n    }\n    \n    col = aces(col);\n    col = pow(col, vec3(1.0/2.2));\n    \n    o = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}