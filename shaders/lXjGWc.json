{
    "Shader": {
        "info": {
            "date": "1710445743",
            "description": "I once saw a documentary about forests and took a screenshot which I have finally shaderfied. \nWould be a nice background, but it's a too slow for that.\n\nBut if you have a minute, just let yourself be enchanted...\n\nclick and move mouse for cam rotation.",
            "flags": 64,
            "hasliked": 0,
            "id": "lXjGWc",
            "likes": 25,
            "name": "Magical Forest",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "tree",
                "bubble",
                "forest",
                "spring"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 496
        },
        "renderpass": [
            {
                "code": "//                     = Magical Forest =         \n//               by Maximilian Knape ·∑>|  2024            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(.8) //vec3(.4545)\n\n#define MAX_STEPS 300\n#define MAX_DIST 300.\n#define MIN_DIST 20.\n#define STEP_FAC .8\n\n#define SURF_DIST .002\n#define SURF_MUL 400.\n#define SURF_EXP 7.\n\n#define PP_CONT 0.3\n#define PP_VIGN 2.0\n\n#define PI 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n\nvec2 Map(const in vec3 p) \n{    \n    float d = MAX_DIST, col = 2.5;\n    float l = length(p.xz);\n    \n    //floor\n    float ground = max(p.y + (cos(p.x/80.-.8)+sin(p.z/50.+1.5))*20., -0.5);\n    if (ground < 15.) ground -= sqrt(noise(1.8*p.xz-p.yx))*1.5 - sin(noise(p.xz/20.)*5.)*1.6;\n    col = mix(col, 1.9, step(ground, d));\n    d = min(ground, d);\n\n    //tree\n    if (l < 20.) return vec2(min(d, 20.), col);\n    vec2 pos = round(p.xz/40.)*40.;\n    pos.x += sin(pos.y/47.-pos.x*16.+.232)*12.;\n    pos.y += sin(pos.x/31.+pos.y*23.+.263)*12.;\n    float tree = length(p.xz-pos.xy)-(2.+hash(pos.x+pos.y)*2.) * step(-ground,-2.);\n    \n    //sticks\n    float sf = 12. + sin((pos.x+pos.y+p.y)/ 50.)*3.;\n    vec2 sp = vec2(S(5., 30., ground)*sf/2., 0)*Rot(pos.x+pos.y-round((p.y+p.x)/sf));\n    float sh = round(p.y / sf) * sf + pow(length(p.xz-pos), 3.)/3e2;\n    float stick = sdCapsule(p, vec3(pos+sp*max(1.2,sh/80.), sh).xzy, vec3(pos-sp*sh/60., sh).xzy, .1+sh/2e3);\n    tree = smin(stick, tree, 1.2);\n    \n    col = mix(col, 0.7, step(tree, d));\n    d = smin3(tree, d, 16.);\n    \n    float dis = length(p);\n    if (dis > 150. || d <= 0.) return vec2(d, col);\n    \n    //bubble\n    vec3 pp = vec3(sin(iTime/11.),sin(iTime/3.)/10.+.5, -cos(-iTime/13.))*110.;\n    float bubble = length(p - pp) - 1. - sin(ground/2.)*.3 + max(-5., 1.-d);\n    col = mix(col, 4.3, step(bubble, d));\n    d = min(bubble*.8, d);\n    \n    if (bubble <= 0.) return vec2(d, col);\n    \n    //particles\n    pp = abs(fract(p/20.)*40.)-20.;\n    float particle = length(pp - 30.*sin(vec3(iTime/3.-tree/4.-ground/10.)+p/80.)) - .4*S(1.,50.,dis);\n    col = mix(col, 3.99, step(particle, d));\n    d = min(particle, d);\n\n    return vec2(d, col);\n}\n\nvec3 Palette(const in int index, const in vec3 p)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., 1., 1.);\n        case 1: return vec3(.6, 1., .1)*.8;\n        case 2: return vec3(1., .85, .6);\n        case 3: return vec3(1., 1., 1.);\n        case 4: return sin(p/5.)*.3+.7;\n    }\n    return vec3(0.);\n}\n\n#define Pow(x) x*x\nvec3 RTM(const in vec3 ro, const in vec3 rd, const in vec2 fc) \n{\n    int steps;\n    float sum = 0.;\n\tfloat s = 1.;\n    float d = MIN_DIST;\n    const float a = 1. / float(MAX_STEPS); \n    vec3 p = vec3(0), col = vec3(1);\n    \n    d += (fract(1e3* sin( dot(fc,vec2(114,211.1) )))-.5)*5.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {    \n        float sd = (SURF_DIST * (pow(d/MAX_DIST, SURF_EXP)*SURF_MUL+1.));\n        if (s < sd || d > MAX_DIST) break;\n        \n        steps = i;\n        p = ro + rd*d;\n        \n        vec2 map = Map(p);\n        col = mix(col, Palette(int(floor(map.y)), p), .02 * (1.-sum));\n        \n        s = max(abs(map.x), 2. * sd);\n        d += s * STEP_FAC * (1.1 - fract(map.y));\n        \n        sum += a;\n        \n        if (floor(map.y) <= 1. && map.x < 0.1) break;\n    }\n    \n    float dis = d / MAX_DIST;\n    col *= sum - pow(.95 - dis, SURF_EXP);\n    \n    float bg = max(0., 1.3 - dis*dis * max(0., (1.-abs(max(rd.y*2.5, 0.)-1.))) * noise(normalize(rd.xz)*77.)); //bg trees\n    if (dis > .95) bg = max(0., bg - S(.97, 1.02, (dot(rd, normalize(vec3(sin(iTime/5.), .02, cos(iTime/7.)+.1)))))); //black creature\n    col += dis*dis * max(0., dot(rd, vec3(0,1.+Pow(sin(iTime/3.))*.3,0))) * Palette(2, p) * bg; //sun\n    \n    \n    return col;\n}\n\nvec4 PP(in vec3 col, const in vec2 uv)\n{\n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.1) m = vec2(.6, .65);\n\n    vec3 ro = vec3(0., 0., -40.);\n    ro.yz *= Rot(-m.y * PI + PI*.5);\n    ro.xz *= Rot(-m.x * PI*2. - PI);\n    vec3 rd = R(uv, ro, vec3(0., 0., 0.), 0.9);\n    \n    vec3 col = RTM(ro, rd, fragCoord);\n    \n    fragColor = PP(col , uv);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 36687,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/anders-frunck/forest-soundscape"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//   -----= Inigo Quilez =-----\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat smin3( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat hash(float n) { return fract(sin(n)*43758.5453123); }\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\n//   -------= IQ END =-------\n\nmat2 Rot(in float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l, in float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}