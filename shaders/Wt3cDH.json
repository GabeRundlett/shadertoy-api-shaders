{
    "Shader": {
        "info": {
            "date": "1608977662",
            "description": "Even permutations of 5 elements correspond to rotations of a dodecahedron.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wt3cDH",
            "likes": 16,
            "name": "Dodecahedral Permutations",
            "published": 3,
            "tags": [
                "quaternion",
                "stereographic",
                "dodecahedron",
                "permutation",
                "a5",
                "slerp"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Dodecahedral Permutations, Matthew Arcus, mla, 2020\n// The alternating group A5 as rotations of a dodecahedron.\n// \n// The group A5 (the group of even permutations of five objects) has\n// 60 elements, there are 60 rotations of a dodecahedron & in fact\n// the two groups are isomorphic.\n//\n// The isomorphism can be constructed as follows: color the\n// dodecahedron vertices as for the compound of five tetrahedra;\n// there is then one diagonal for each color pair, and the end\n// vertices of each diagonal are each adjacent to three vertices in\n// the three remaining colours, so to select permutation\n// c0,c1,c2,c3,c4, find diagonal c0-c4, rotate so c0 is 'uppermost',\n// then rotate about diagonal to put c1,c2,c3 in correct positions.\n//\n// Here the dodecahedron vertices are stereographically projected to\n// the plane, then rotated to form the sixty A5 permutations with the\n// colors, in order BRGBY, of the central vertex, the three vertices\n// around the centre, clockwise from top, and the outermost vertex.\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Dodecahedron vertices, aligned with z-axis.\n// vertex[i] = -vertex[(i+10)%20]\nconst int N = 20; // Number of vertices\nvec3 vertex[N] = vec3[]\n  (vec3(0,0,1),\n\n   vec3(0,0.6667,0.7453),\n   vec3(0.5773,-0.3333,0.7453),\n   vec3(-0.5773,-0.3333,0.7453),\n\n   vec3(-0.5773,0.7453,0.3333),\n   vec3(-0.9342,0.1274,0.3333),\n   vec3(-0.3568,-0.8727,0.3333),\n   vec3(0.3568,-0.8727,0.3333),\n   vec3(0.9342,0.1273,0.3333),\n   vec3(0.5773,0.7453,0.3333),\n\n   vec3(0,0,-1),\n\n   vec3(0,-0.6667,-0.7453),\n   vec3(-0.5773,0.3333,-0.7453),\n   vec3(0.5773,0.3333,-0.7453),\n\n   vec3(0.5773,-0.7453,-0.3333),\n   vec3(0.9342,-0.1274,-0.3333),\n   vec3(0.3568,0.8727,-0.3333),\n\n   vec3(-0.3568,0.8727,-0.3333),\n   vec3(-0.9342,-0.1273,-0.3333),\n   vec3(-0.5773,-0.7453,-0.3333));\n\n// Compound of five tetrahedra colouring.\nint colorindex[N] = int[] (0,1,2,3,4,2,4,1,4,3, 4,2,3,1,3,0,2,0,1,0);\n\nvec3 color[6] = vec3[](vec3(0),vec3(1,0,0),vec3(0,1,0),\n                       vec3(0,0,1),vec3(1,1,0),vec3(0.9));\n\n// Quaternions\n\n// R3 rotation of p with quaternion q\nvec3 qrot(vec3 p, vec4 q) {\n  return p + 2.0*cross(q.xyz,cross(q.xyz,p)+q.w*p);\n}\n\nvec4 qpow (vec4 q, float t) {\n  // Maybe use an approximation for small q.xyz\n  if (q.xyz == vec3(0)) return vec4(vec3(0),pow(q.w,t));\n  float r = length(q);\n  float phi = acos(q.w/r);\n  vec3 n = normalize(q.xyz);\n  return pow(r,t)*vec4(sin(t*phi)*n,cos(t*phi));\n}\n\n// For normalized q\nvec4 qpow1 (vec4 q, float t) {\n  if (q.xyz == vec3(0)) return vec4(0,0,0,1);\n  float phi = acos(q.w);\n  vec3 n = normalize(q.xyz);\n  return vec4(sin(t*phi)*n,cos(t*phi));\n}\n\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 qconj(vec4 p) {\n  return vec4(-p.xyz,p.w);\n}\n\nvec4 qinv(vec4 p) {\n  return qconj(p)/dot(p,p);\n}\n\nvec4 qdiv(vec4 p, vec4 q) {\n  return qmul(p,qinv(q));\n}\n\nvec4 qabs(vec4 p) {\n  // Convert to quaternion with q.w >= 0\n  return p.w >= 0.0 ? p : -p;\n}\n\n// slerp: spherical interpolation between q0 and q1\n// This is basically (q1/q0)^t * q0\n// Be careful with operation order here.\n// Assumes q0,q1 normalized so q1/q0 = q1*q0'\n// The qabs ensures we go the short way round.\nvec4 slerp(vec4 q0, vec4 q1, float t) {\n  return qmul(qpow1(qabs(qmul(q1,qconj(q0))),t),q0);\n}\n\n#define DEFSWAP(T) \\\nvoid swap(inout T p, inout T q) { T t = p; p = q; q = t; }\n\nDEFSWAP(int)\nDEFSWAP(vec3)\n\n// Find rotation that maps p,q onto r,s\n// Reflect p to r, q to q', then q' to s\nvec4 getrotation(vec3 p, vec3 q, vec3 r, vec3 s) {\n  if (p == r) {\n    if (q == s) return vec4(0,0,0,1); // Nothing to do\n    swap(p,q); swap(r,s);\n  }\n  vec3 n1 = r-p;\n  vec4 q1 = vec4(n1,0); // Reflect p to r\n  q = q-2.0*dot(n1,q)/dot(n1,n1)*n1;\n  vec3 n2 = distance(q,s) < 0.01 ? cross(r,q+s) : s-q;\n  vec4 q2 = vec4(n2,0);\n  vec4 t = qmul(q2,q1);\n  return normalize(t);\n}\n\n// Given three elements of a permutation, c0, c1, c2, find\n// v0 with color(v0) = c0 and color(-v0) = c2, then find\n// v1 adjacent to v0 with color(v1) = c1. This is always\n// possible with the \"5 tetrahedron\" colouring.\nivec2 getvertices(ivec3 p) {\n  int i,j;\n  for (i = 0; i < N; i++) {\n    // The opposite vertex is 10 places on\n    if (colorindex[i] == p[0] && colorindex[(i+N/2)%N] == p[2]) break;\n  }\n  for (j = 0; j < N; j++) {\n    // Find unique closest vertex with correct color\n    if (colorindex[j] == p[1] && distance(vertex[i],vertex[j]) < 1.0) break;\n  }\n  return ivec2(i,j);\n}\n\nvec3 invert(vec3 p, vec3 centre, float r2) {\n  p -= centre;\n  p *= r2/dot(p,p);\n  p += centre;\n  return p;\n}\n\nvec3 istereo(vec2 p2) {\n  // Inverse stereographic projection by inversion\n  vec3 p = vec3(p2,0);\n  vec3 centre = vec3(0,0,-1);\n  float r2 = 2.0;\n  p = invert(p,centre,r2);\n  return p;\n}\n\n// For k = 2n, find the nth even permutation\n// For k = 2n+1, find the nth odd permutation\n// Return first, second and last elements of permutation\n// Given the parity, the other two elements are determined.\nivec3 getperm(int k) {\n  const int N = 5;\n  int a[N] = int[](0,1,2,3,4);\n  int p = 24;\n  int inversions = 0;\n  for (int i = N-1; i > 1; i--) {\n    int k1 = k/p;\n    inversions += i-k1;\n    k = k%p;\n    int tmp = a[k1];\n    for (int j = k1; j < i; j++) {\n      a[j] = a[j+1];\n    }\n    a[i] = tmp;\n    p /= i;\n  }\n  if (inversions%2 != k%2) swap(a[0],a[1]);\n  // Perms are in lexicographic reverse order\n  return ivec3(a[4],a[3],a[0]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p2 = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  p2 *= 5.0;\n  vec3 p = istereo(p2);\n  float cycle = 4.0;\n  float transition = 2.0;\n  int n = int(iTime/cycle);\n  ivec3 perm0 = getperm(n%60*2);\n  ivec3 perm1 = getperm((n+1)%60*2);\n  ivec2 vv0 = getvertices(perm0);\n  ivec2 vv1 = getvertices(perm1);\n  vec4 q0 = getrotation(vertex[0],vertex[1],vertex[vv0[0]],vertex[vv0[1]]);\n  vec4 q1 = getrotation(vertex[0],vertex[1],vertex[vv1[0]],vertex[vv1[1]]);\n  float t = smoothstep(1.0,2.0,transition*fract(iTime/cycle));\n  vec4 q = slerp(q0,q1,t);\n  q = normalize(q); // Just in case\n  p = qrot(p,q);\n  vec3 col = color[5];\n  float dwidth = 0.3;\n  for (int i = 0; i < N; i++) {\n    float d = acos(clamp(dot(p,vertex[i]),-1.0,1.0));\n    col = mix(color[colorindex[i]],col,smoothstep(0.0,max(0.01,fwidth(d)),d-dwidth));\n  }\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}