{
    "Shader": {
        "info": {
            "date": "1533958729",
            "description": "My entry for the 2018 Shadertoy Competition :)",
            "flags": 0,
            "hasliked": 0,
            "id": "MltcDB",
            "likes": 115,
            "name": "[SH18] Ink Drawing",
            "published": 3,
            "tags": [
                "raymarching",
                "npr",
                "human",
                "sh18",
                "statue"
            ],
            "usePreview": 1,
            "username": "lnae",
            "viewed": 2724
        },
        "renderpass": [
            {
                "code": "#define STEPS 64.\n#define STEPS_SHADOW 32.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n#define EPSOUT 0.01\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat hash2(vec2 p){\n\treturn fract(12345.6789 * sin(dot(p, vec2(12.345, 67.891))));\n}\n\nfloat hash3(vec3 p){\n\treturn fract(12345.6789 * sin(dot(p, vec3(12.34, 56.78, 91.01))));\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smoothmax(float a, float b, float k){\n\treturn -smoothmin(-a, -b, k);\n}\n\nfloat smoothabs(float p, float k){\n\treturn sqrt(p * p + k * k) - k;\n}\n\nfloat noise2(vec2 p){\n\tvec2 c = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    return mix(mix(hash2(c), hash2(c + vec2(1., 0.)), f.x), mix(hash2(c + vec2(0., 1.)), hash2(c + vec2(1., 1.)), f.x), f.y);\n}\n\nfloat noise3(vec3 p){\n\tvec3 c = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    vec3 o = vec3(1., 0., 0.);\n    return mix(mix(mix(hash3(c + o.yyy), hash3(c + o.xyy), f.x), mix(hash3(c + o.yxy), hash3(c + o.xxy), f.x), f.y),\n               mix(mix(hash3(c + o.yyx), hash3(c + o.xyx), f.x), mix(hash3(c + o.yxx), hash3(c + o.xxx), f.x), f.y), \n               f.z);\n}\n\nfloat fbm2(vec2 p){\n\treturn 0.5 * noise2(p) + 0.25 * noise2(2. * rot(2.) * (p + 1.)) + 0.125 * noise2(4. * rot(4.) * (p + 2.)) + 0.0625 * noise2(8. * rot(6.) * (p + 3.)) + 0.0625 * noise2(16. * rot(8.) * (p + 4.));\n}\n\n\nfloat fbm3(vec3 p){\n\treturn 0.5 * noise3(p) + 0.25 * noise3(2. * (p + 1.)) + 0.125 * noise3(4. * (p + 2.)) + 0.0625 * noise3(8. * (p + 3.)) + 0.0625 * noise3(16. * (p + 4.));\n}\n\nfloat distEllipsoid(vec3 p, vec3 r){\n    float lg = length(p /(r * r));\n\treturn (length(p / r) - 1.) * (length(p / r)) / lg;\n\t//return (length(p / r) - 1.) * (r.x + r.y + r.z) / 3.;//max(max(r.x, r.y), r.z);\n\n}\n\nfloat distScene(vec3 pos, out float colorVariation){\n    pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    colorVariation = 0.;\n    \n    //main sphere\n    vec3 p = pos;\n    p.y -= 0.5;\n    float dist = length(p) - 0.13;\n    \n    //hair + back of the head\n    p = pos;\n    p.y -= 0.51;\n    p.z += 0.04;\n    dist = smoothmin(dist, length(p) - 0.14, 0.02);\n    \n    p.yz = rot(0.3) * p.yz;\n    float f = acos(p.z / 0.16);\n    float angle = atan(p.y, p.x);\n    float hair = -100. * (length(p) - 0.16) - noise2(50. * vec2(angle + 0.01 * sin(50. * f), 0.25 * f));\n    colorVariation += smoothstep(0.25, 0.75, hair);\n    dist -= 0.002 * smoothstep(0., 1., 0.5 * hair);\n    \n    p.z += 0.15;\n    float div = 2. * PI / 18.;\n    angle += 0.5 * PI + 0.5 * div;\n    float c = floor((angle) / div);\n    angle = mod(angle, div) - 0.5 * div;\n    float r = length(p);\n    p.x = r * cos(angle);\n    p.y = r * sin(angle);\n    \n    p.xz = rot(1.) * p.xz;\n    p.xy = rot(35. * p.z + 3.5 * hash2(vec2(c))) * p.xy;\n    p.xy = abs(p.xy);\n    float att = 0.3 * p.z * p.z;\n    float distHair = length(p.xy - vec2(0.01 - 1. * att, 0.01 - 1. * att)) - 0.01 + att;\n    distHair = smoothmax(distHair, length(p - vec3(0., 0., -0.06)) - 0.055, 0.02) - 0.02 * noise3(50. * p);\n    dist = smoothmin(dist, distHair, 0.01);\n    if(dist == distHair) colorVariation = 1.;\n    \n    //chin\n    dist = smoothmin(dist, length(pos - vec3(0., 0.3, 0.105)) - 0.01, 0.2);\n    \n    //nose\n    p = pos;\n    p.y -= 0.41;\n    p.z -= 0.135;\n    p.yz = rot(-0.65) * p.yz;\n    dist = smoothmin(dist, distEllipsoid(p, vec3(0.01, 0.035, 0.0075)), 0.04);\n    \n    //neck\n    p = pos;\n    p.z += 0.05;\n    float distNeck = length(p.xz) - 0.05;\n    distNeck = max(distNeck, p.y - 0.4);\n    dist = smoothmin(dist, distNeck, 0.05);\n    \n    //torso\n    p = pos;\n    p.y -= 0.05;\n    dist = smoothmin(dist, length(p) - 0.15, 0.05);\n    \n    //shoulders\n    p = pos;\n    p.x = smoothabs(p.x, 0.01);\n    dist = smoothmin(dist, length(p - vec3(0.15, 0.15, -0.04)) - 0.055, 0.15);\n    \n    //eye sockets\n    p = pos;\n    p.x = smoothabs(p.x, 0.01);\n    p -= vec3(0.05, 0.44, 0.15);\n    dist = smoothmax(dist, -(length(p) - 0.045), 0.02);\n    \n    //brow bone\n    p.z += 0.045;\n    p.y -= 0.055;\n    p.xz = rot(-0.25) * p.xz;\n    p.yz = rot(1.2) * p.yz;\n    p.xy = rot(-8. * (p.x + 0.04)) * p.xy;\n    dist = smoothmin(dist, distEllipsoid(p, vec3(0.03, 0.01, 0.01)), 0.035);\n    \n    //eyebrow\n    p = pos;\n    p.x = abs(p.x) - 0.0725;\n    p.z -= 0.13;\n    p.y -= 0.495;\n    p.xy = rot(-10. * p.x - 0.25) * p.xy;\n    p.x += 0.0275;\n    p.xz = rot(-10. * p.x) * p.xz;\n    float distEyebrow = distEllipsoid(p, vec3(0.025, 0.007, 0.01));\n    p.x -= 0.025;\n    distEyebrow = smoothmin(distEyebrow, distEllipsoid(p, vec3(0.04, 0.005, 0.01)), 0.01);\n    p.y /= 3.;\n    float eyebrow = -100. * (distEyebrow - 0.004) + 0.5 * noise2(400. * p.xy);\n    eyebrow = smoothstep(0.3, 0.7, eyebrow);\n    colorVariation += eyebrow;\n    dist -= 0.001 * eyebrow;\n    \n    //eyes\n    p = pos;\n    p.x = abs(p.x);\n    p -= vec3(0.05, 0.45, 0.095);\n    dist = smoothmin(dist, length(p) - 0.02, 0.01);\n    p.z -= 0.02;\n    p.x -= 0.005;\n    float eyeColor = -50. * (length(p) - 0.025);\n    colorVariation += smoothstep(0.4, 0.6, eyeColor);\n    colorVariation -= smoothstep(0.45, 0.55, -25. * (length(p - vec3(sign(pos.x) * 0.01, -0.0075, 0.)) - 0.025));\n    \n    //eyelids\n    p.x += 0.0045;\n    p.y -= 0.016;\n    p.xy = rot(-20. * p.x + 0.3) * p.xy;\n    p.xz = rot(-20. * p.x) * p.xz;\n    float distEyelids = distEllipsoid(p, vec3(0.035, 0.005, 0.01));\n    float distEyelashes = abs(p.y + 0.003);\n    p.x -= 0.005;\n    distEyelashes = smoothmax(distEyelashes, length(p) - 0.036, 0.01);\n\tdist = smoothmin(dist, distEyelids, 0.005);\n    colorVariation += smoothstep(0.4, 0.6, -60. * (distEyelashes - 0.01) + 0.15 * noise2(600. * p.xy));\n    \n    //cheeks\n    p = pos;\n    p.x = abs(p.x);\n    dist = smoothmin(dist, length(p - vec3(0.05, 0.385, 0.08)) - 0.01, 0.1);\n    \n    //jaw\n    p = pos;\n    p.x = abs(p.x);\n    dist = smoothmin(dist, length(p - vec3(0.03, 0.34, 0.045)) - 0.005, 0.1);\n    \n    //nose part 2\n    p = pos;\n    p.y -= 0.385;\n    p.z -= 0.155;\n    dist = smoothmin(dist, length(p) - 0.003, 0.025);\n    p.z += 0.01;\n    p.y += 0.004;\n    dist = smoothmin(dist, length(p) - 0.006, 0.01);\n    p.x = abs(p.x) - 0.015;\n    dist = smoothmin(dist, length(p) - 0.006, 0.0125);\n    \n    //ears    \n    p = pos;\n    p.x = abs(p.x);\n    p -= vec3(0.11, 0.4, -0.03);\n    p.xz = rot(0.3) * p.xz;\n    p.yz = rot(-0.4) * p.yz;\n    p.xy = rot(-0.5) * p.xy;\n    dist = smoothmin(dist, distEllipsoid(p, vec3(0.0075, 0.04, 0.025)), 0.015);\n    p -= vec3(0.0175, -0.01, 0.01);\n    dist = smoothmax(dist, -(length(p) - 0.015), 0.02);\n    \n    //mouth    \n    dist = smoothmin(dist, distEllipsoid(pos - vec3(0., 0.345, 0.115), vec3(0.04, 0.03, 0.02)), 0.015);\n    p = pos;\n    p.y -= 0.345;\n    p.z -= 0.14;\n    p.yz = rot(-0.9) * p.yz;\n    p.xz = rot(-15. * p.x) * p.xz;\n    float distLips = distEllipsoid(p, vec3(0.03, 0.0075, 0.0075));\n    p.y -= 0.009;\n    p.z -= 0.001;\n    distLips = smoothmax(distLips, -(length(p) - 0.008), 0.01);\n    \n    p = pos;\n    p.y -= 0.325;\n    p.z -= 0.126;\n    p.yz = rot(0.25) * p.yz;\n    p.xz = rot(-10. * p.x) * p.xz;\n    distLips = smoothmin(distLips, distEllipsoid(p, vec3(0.035, 0.0125, 0.02)), 0.00003);\n    dist = smoothmin(dist, distLips, 0.0075);\n    \n    p = pos;\n    p.x = abs(p.x);\n    p -= vec3(0.036, 0.33, 0.1275);\n    dist = smoothmax(dist, -(length(p) - 0.001), 0.02);\n    \n    //cut\n    p = pos;\n    p.x = abs(p.x);\n    p.xy = rot(0.3) * p.xy;\n    dist = smoothmax(dist, -p.y + 0.075, 0.01); \n    dist = smoothmin(dist, max(pos.y - 0.055, length(pos.xz) - 0.075) + 0.005 * sin(100. * pos.y), 0.1);\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float c;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c) - distScene(p - vec3(EPSN, 0., 0.), c),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c) - distScene(p - vec3(0., EPSN, 0.), c),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c) - distScene(p - vec3(0., 0., EPSN), c))));\n}\n\nfloat getShadow(vec3 pos, vec3 light, vec3 normal){\n\tvec3 shadowRay = normalize(light - pos);\n    pos += 3. * EPS * normal;\n    float totDist = 3. * EPS;\n    float prevDist = totDist;\n    float shadow = 1.;\n    float dist, c;\n\n    for(float s = 0.; s < STEPS_SHADOW; s++){\n        dist = distScene(pos, c);\n        shadow = min(shadow, 4. * dist / totDist);\n        if(abs(dist) < EPS){\n            shadow = 0.;\n            break;\n        }\n        dist = 0.997 * dist + 0.003 * hash3(pos + sin(iTime));\n        pos += shadowRay * dist;\n        totDist += dist;\n        if(totDist > 2.) break;\n    }\n    return clamp(shadow, 0., 1.);\n}\n\nvec3 render(vec2 uv){\n\tvec3 col = 0.95 - 0.025 * vec3(smoothstep(0.6, 0.3, fbm2(75. * uv)));\n    vec3 ink = vec3(0.15, 0.2, 0.3);\n    \n    //camera\n    vec3 eye = vec3(0., 0., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    ray.yz = rot(0.12) * ray.yz;\n    eye.yz = rot(0.12) * eye.yz;\n    \n   \t//raymarch\n    vec3 pos = eye;\n    float s, colorVariation, prevDist, totDist = 0., outline = 1.;\n    bool hit = false;\n    float dist = distScene(pos, colorVariation);\n    float maxDist = 7.;\n        \n    for(s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation);\n        if(dist > prevDist && dist < EPSOUT){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS || totDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totDist += dist;\n    }\n    \n    if(totDist < maxDist) hit = true;\n    float f = fbm3(10. * pos);\n    float sf = smoothstep(0.5, 0.6, f);\n    \n    vec3 normal = getNormal(pos);\n    \n    //col = 0.75 * vec3(s / STEPS)  + 0.25 * (0.5 + normal);\n    if(hit) col = mix(col, ink, colorVariation);\n    \n    //outline\n    outline = clamp(outline / EPSOUT, 0., 1.);\n\toutline = smoothstep(0.5, 0.7, outline + 0.5 * f);\n    col = mix(ink, col, outline);\n    \n    vec3 light = vec3(5., 7., 10.);\n    light.yz = rot(0.3) * light.yz;\n    \n    //white highlight\n    float shine = 10.;\n    vec3 refl = reflect(normalize(pos - light), normal);\n    float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n    spec = smoothstep(0.45, 0.55, spec - 0.5 * f);\n    if(hit) col = mix(col, vec3(1.), (1. - 0.5 * colorVariation) * spec);\n    \n    //shadows\n    float shadow = getShadow(pos, light, normal);\n    shadow = smoothstep(0.5, 0.7, shadow + 0.5 * f);\n    if(length(pos) < 1.)col = mix(ink, col, shadow);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}