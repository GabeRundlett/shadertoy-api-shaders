{
    "Shader": {
        "info": {
            "date": "1699148390",
            "description": "Generates an infinite map with 5 distinct biomes",
            "flags": 0,
            "hasliked": 0,
            "id": "cttyDH",
            "likes": 4,
            "name": "Biome Generator / Biome Boundary",
            "published": 3,
            "tags": [
                "procedural"
            ],
            "usePreview": 0,
            "username": "kp1197",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "#define ANIMATE vec2(iTime/3.,0.)\n\nconst float ZOOM = 10.;\nconst float WORLD_SCALE = 8000.;\n\n// concentration parameter - higher value results in less material 'bleeding'\n// if your weights are between 0.0 and 1.0 you shouldn't need to adjust\nconst float K = 20.;\n\n// if weights are between 0.0 and 1.0 you shouldn't need to adjust\nconst float NULL_WEIGHT = 10.;\n\n\n\n///  2 out, 2 in...\nvec2 hash(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat simplex_noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n\n\nconst mat2 mtx = mat2( vec2(0.80,  0.60), vec2(-0.60,  0.80 ));\n\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\tf += simplex_noise(p); \n\tp = mtx*p*1.99;\n\tf += 0.50000*simplex_noise(p ); \n\tp = mtx*p*1.99;\n\tf += 0.25000*simplex_noise(p  ); \n\tp = mtx*p*1.99;\n\tf += 0.125000*simplex_noise(p); \n\tp = mtx*p*1.99;\n\tf += 0.062500*simplex_noise(p); \n\tp = mtx*p*1.99;\t\n\treturn f / 0.9375;\n}\n\nfloat clamp_fbm(float value) {\n\treturn smoothstep(0.2, 0.6, value);\n}\n\nfloat adventure_zoneness(vec2 p) {\n\treturn clamp_fbm(fbm( p ));\n}\n\nfloat danger_zoneness(vec2 p) {\n\treturn clamp_fbm(fbm((p + vec2(1000.))));\n}\n\nfloat deadly_zoneness(vec2 p) {\n\treturn clamp_fbm(fbm((p + vec2(2000.))  ));\n}\n\nfloat abyss_zoneness(vec2 p) {\n\treturn  clamp_fbm(fbm((p + vec2(3000.))  ));\n}\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n// mixes between A, B, C and D by picking the max weight in `vec4 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_4_(vec4 materials, vec3 A, vec3 B, vec3 C, vec3 D, vec3 NULL) {\n\tfloat softmaxDenominator = exp(K * materials.x) + \n        exp(K * materials.y) + \n        exp(K * materials.z) + \n        exp(K * materials.w) + \n        exp(NULL_WEIGHT);\n\tfloat sm_a = exp(K * materials.x) / softmaxDenominator;\n\tfloat sm_b = exp(K * materials.y) / softmaxDenominator;\n\tfloat sm_c = exp(K * materials.z) / softmaxDenominator;\n\tfloat sm_d = exp(K * materials.w) / softmaxDenominator;\n\tfloat sm_null = exp(NULL_WEIGHT) / softmaxDenominator;\n    return sm_a * A + sm_b * B + sm_c * C + sm_d * D + sm_null * NULL;\n}\n\nvec3 softmaxmix_4(vec4 materials, vec3 A, vec3 B, vec3 C, vec3 D) {\n\tvec4 softmaxed_materials = exp(K * materials) / dot(exp(K * materials), vec4(1.));\n    return softmaxed_materials.x * A + softmaxed_materials.y * B + softmaxed_materials.z * C + softmaxed_materials.w * D;\n}\n\nfloat indecision_4_(vec4 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n\tfloat softmaxDenominator = exp(K * materials.x) + exp(K * materials.y) + exp(K * materials.z) + exp(K * materials.w) + exp(NULL_WEIGHT);\n\tfloat sm_a = exp(K * materials.x) / softmaxDenominator;\n\tfloat sm_b = exp(K * materials.y) / softmaxDenominator;\n\tfloat sm_c = exp(K * materials.z) / softmaxDenominator;\n\tfloat sm_d = exp(K * materials.w) / softmaxDenominator;\n\tfloat sm_null = exp(NULL_WEIGHT) / softmaxDenominator;\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = (sm_a * log(sm_a) +\n\t\t\t\t\t sm_b * log(sm_b) +\n\t\t\t\t\t sm_c * log(sm_c) +\n\t\t\t\t\t sm_d * log(sm_d) +\n\t\t\t\t\t sm_null * log(sm_null)) / log(1./5.);\n    return normalized_entropy;\n}\n\nvec2 to_world(vec2 a) {\n    vec2 world_uv  = ( vec4(a.x, a.y, 0., 1.)).xy; \n\tvec2 p = ZOOM * world_uv / WORLD_SCALE;// + vec2(iTime/10.,0.);\n    return p;\n}\n\nfloat surf_highlights(vec2 p) {\n    return dot(hash(p), hash(p + 100.));\n}\n\nvec3 SPHERE_CENTER = vec3(0.0,0.0,4.0);\nfloat SPHERE_RADIUS = 1.0;\n\nfloat sphereDist(vec3 p) {\n    return length(p - SPHERE_CENTER) - SPHERE_RADIUS;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    vec2 screen_uv = fragCoord / iResolution.xx - 0.5*vec2(1.,iResolution.y/iResolution.x);\n    vec3 ray = normalize(vec3(screen_uv, 1.));\n    vec2 p = screen_uv + ANIMATE;\n\n\t// zones\n\tfloat a = (adventure_zoneness(p));\n\tfloat b = (danger_zoneness(p));\n\tfloat c = (deadly_zoneness(p));\n\tfloat d = (abyss_zoneness(p));\n    \n    // value of current zone\n    float level = softmaxmix_4(vec4(a,b,c,d), vec3(a), vec3(b), vec3(c), vec3(d)).x;\n    \n    // lighting\n    float dLdx = dFdx(level);\n    float dLdy = dFdy(level);\n    vec3 normal = normalize(vec3(dLdx, dLdy,1.));\n    vec3 lightDir = normalize(vec3(0.9,0.5,1.));\n    float lighting = pow(abs(dot(normal,lightDir)),2.);\n    \n\n    vec2 warped_p = p.xy*5. + 0.25 * simplex_noise(p.xy);\n\tfloat coast_highlight = level + 1.5;\n\tvec3 water = coast_highlight*hsv2rgb(vec3(0.6, 1., 0.5)); //vec3(120,180,120)/255.0;\n\tvec3 a_color = 0.6 * lighting + 0.4 * texture(iChannel0, warped_p).rgb;//hsv2rgb(vec3(0.4, 1., 0.5)); //vec3(68,188,216)/255.0;\n\tvec3 b_color = 0.6 * lighting + 0.4 * vec3(1.5,1.5,0.6) * texture(iChannel1, warped_p).rgb;//hsv2rgb(vec3(0.6, 1., 0.5));//vec3(24,116,165)/255.0;\n\tvec3 c_color = 0.6 * lighting + 0.4 * texture(iChannel2, warped_p).rgb;//hsv2rgb(vec3(0.8, 1., 0.5)); //vec3(101,36,23)/255.0;\n\tvec3 d_color = 0.6 * lighting + 0.4 * vec3(0.6,1.5,0.6) * texture(iChannel3, warped_p).rgb;//hsv2rgb(vec3(0.9, 0.5, 0.5)); //vec3(0.)/255.0;\n\t\n\t// zone base color for viz\n\tvec3 color = softmaxmix_4_(vec4(a, b, c, d), a_color, b_color, c_color, d_color, water);\n\t\n\tfloat borders = abs(indecision_4_(vec4(a, b, c, d)));\n    \n    vec3 base_color = mix(color, d_color, borders);\n    vec3 tinted_color =  base_color * vec3(1.5,0.8,0.5);\n    \n    fragColor.rgb = pow(tinted_color, vec3(0.8));\n\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}