{
    "Shader": {
        "info": {
            "date": "1570137213",
            "description": "A mouse with its cheese surprised by a guy standing at the door.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sGGWD",
            "likes": 6,
            "name": "Shadertober 03 Bait",
            "published": 3,
            "tags": [
                "raymarching",
                "mouse",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 567
        },
        "renderpass": [
            {
                "code": "#define VOLUME 0.001\n#define PI 3.14159\n#define MAXSTEP 64\n\nfloat Vignette(vec2 uv, float force)\n{\n    return 1.0 - pow(length(uv), force);\n}\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdScaledSphere(vec3 p, vec3 s, float r)\n{\n    return float(length(p/s)*s)-r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCheese( vec3 p, vec2 h )\n{\n    p.zy *= rot(PI/2.0);\n    p.xy *= rot(PI/2.0);\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Scene setup\n\nfloat map(vec3 pos)\n{\n    float t = 0.0;\n    \n    t = sdPlane(pos);\n    \n    // mouse\n    vec3 mP = pos + vec3(-.3, 0.0, 2.0);\n    float body = sdScaledSphere(mP, vec3(.5, .5, 1.0), 0.2);\n    \n    vec3 hP = mP + vec3(0.0, -0.15, 0.3);\n    hP.zx *= rot(-PI/4.0+sin(iTime*10.)*.01);\n    float head = sdSphere(hP, .15);\n    vec3 eyeP = hP + vec3(0.05, -0.1, 0.1);\n    head = sSDF(sdSphere(eyeP, .01), head);\n    vec3 ore1P = hP + vec3(0.1, -0.1,  0.0);\n    float ore1 = sdSphere(ore1P, .05);\n    vec3 ore2P = hP + vec3(-0.1, -0.1,  0.0);\n    float ore2 = sdSphere(ore2P, .05);\n    vec3 musP = hP + vec3(0.0, -0.03, 0.15);\n    float mus = sdSphere(musP, .05);\n    vec3 stachP = hP + vec3(0.0, -0.05, 0.15);\n    float stch = sdBox(stachP, vec3(.1, 0.002, 0.002));\n    stachP = hP + vec3(0.0, -0.05, 0.15);\n    stachP.xy *= rot(PI/8.0);\n    stch = uSDF(stch, sdBox(stachP, vec3(.1, 0.002, 0.002)));\n    stachP.xy *= rot(PI/-4.0);\n    stch = uSDF(stch, sdBox(stachP, vec3(.1, 0.002, 0.002)));\n    vec3 tailP = mP + vec3(0.2, 0.09, -0.3);\n    tailP.zx *= rot(PI/16.0+sin(iTime)*0.1);\n    float tail = sdCappedCylinder(tailP, 0.2, 0.1);\n    tailP += vec3(0.03, 0.0, 0.1);\n    tail = sSDF(sdCappedCylinder(tailP, 0.2, 0.2), tail);\n    \n    float ores = uSDF(ore1, ore2);\n    float mouse = uSDF(body, head);\n    mouse = uSDF(mouse, ores);\n    mouse = uSDF(mouse, mus);\n    mouse = uSDF(mouse, stch);\n    mouse = uSDF(mouse, tail);\n    \n    // wall\n    vec3 wallP = pos + vec3(0.0, -1.0, -2.0);\n    float wallBase = sdBox(wallP, vec3(20.0, 30.0, 0.1));\n    vec3 doorP = pos + vec3(2.0, 0.0, -2.0);\n    float door = sdBox(doorP, vec3(1.0, 3.5, 1.0));\n    float wall = sSDF(door, wallBase);\n    \n    // legs\n    vec3 leg1P = pos + vec3(2.0, 1.0, -2.0);\n    float leg1 = sdBox(leg1P, vec3(.15, 3.0, 0.15));\n    vec3 leg2P = pos + vec3(2.6, 1.0, -2.0);\n    float leg2 = sdBox(leg2P, vec3(.15, 3.0, 0.15));\n    float legs = uSDF(leg1, leg2);\n    vec3 pat1p = pos + vec3(2.0, -0.1, -1.8);\n    float pat1 = sdBox(pat1p, vec3(.1, .1, .4));\n    vec3 pat2p = pos + vec3(2.6, -0.1, -1.8);\n    float pat2 = sdBox(pat2p, vec3(.1, .1, .4));\n    float pats = uSDF(pat1, pat2);\n    legs = uSDF(legs, pats);\n    \n    // cheese\n    vec3 cP = pos + vec3(0.05, 0.0, 2.3);\n    float cheese = sdCheese(cP, vec2(0.15, 0.1));\n    cheese = sSDF(sdSphere(cP+vec3(0.1, -0.1, 0.0), .05), cheese);\n    cheese = sSDF(sdSphere(cP+vec3(-0.1, -0.1, 0.0), .03), cheese);\n    cheese = sSDF(sdSphere(cP+vec3(0.0, -0.1, -0.1), .05), cheese);\n    cheese = sSDF(sdSphere(cP+vec3(0.0, -0.1, 0.1), .05), cheese);\n    \n    t = uSDF(t, mouse);\n    t = uSDF(t, cheese);\n    t = uSDF(t, wall);\n    t = uSDF(t, legs);\n    \n    return t;\n}\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<MAXSTEP ; i++)\n    {\n        float ray = map(ro + rd * t);\n        \n        if(ray < (0.0001*t))\n        {\n            float ao = float(i)/64.;\n            return t;\n        }\n        \n        t += ray;\n    }\n    \n    return -1.0;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t);\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{\n    float t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t == -1.0)\n    {\n        \n        col = vec3(1.0+rd.y)*(1.0-step(rd.y, -0.2));\n        col *= 1.0-step(uv.x, 0.5); // hide background color from left wall\n        \n    }\n    else\n    {\n        vec3 N = GetNormal(pos);\n        vec3 L = vec3(-4.0, 1.0, 8.0);\n        float light = dot(N,L);\n        float shade = GetShadow(pos, L, 8.0);\n        float rim = smoothstep(1. - .9, 1.0, 1.0-dot(N, rd));\n        \n        col = vec3(1.0);\n        col *= shade;\n        col *= light;\n        \n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 1.0 * forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cp = vec3(0.0, 0.6, -3.0);\n    vec3 ct = vec3(0.0, -0.8, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = Render(cp, vd, screenUV);\n    \n    // compo\n    \n    \n    col -= mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), screenUV.y)*.2+sin(iTime)*.1;\n    col *= Vignette(uv, 1.0);\n   \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}