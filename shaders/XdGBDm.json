{
    "Shader": {
        "info": {
            "date": "1529013713",
            "description": "Fork of Uiharu's [url=https://shadertoy.com/view/ldVBDD]Electronic clock[/url]\n\nGetting faster compiling by reducing the code size and getting rid of arrays.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdGBDm",
            "likes": 16,
            "name": "Faster electronic clock",
            "published": 3,
            "tags": [
                "time",
                "clock",
                "led",
                "date"
            ],
            "usePreview": 0,
            "username": "ABizard",
            "viewed": 808
        },
        "renderpass": [
            {
                "code": "// Fork of \"Electronic clock\" by Uiharu. https://shadertoy.com/view/ldVBDD\n// 2018-06-14 17:12:11\n\n// Shortening the code to make it faster to compile,\n// and normalizing coordinates\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //font size:\n    const float k = 0.13;\n    //font thickness:\n    const float R = 0.3;\n    //char spacing:\n    const float S = 3.5;\n    //dots spacing:\n    const float D = 1.;\n    //shaking center:\n    const vec2 O = vec2(0);\n    \n    // Normalize coordinates to [-1,1]\n    vec2 pos = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    // Transform coordinates once to apply font size\n    pos /= k;\n    \n    float light = 0.;\n    \n    // Number of seconds since midnight\n    // iDate.w already cycles to 0 at midnight\n    // However, if using somehow the number of seconds since a precise date,\n    // one can simply use date = mod(seconds_since_date,86400.);\n    float date = iDate.w;\n    \n    // ### Draw the dots ###\n    \n    // As (0,0) is the center of the screen,\n    // we can draw only one dot by using abs(pos),\n    // which will duplicate the dot along the two dimensions,\n    // resulting in 4 symmetric dots\n    float blink = mod(floor(date), 2.);\n    light += d_dot(abs(pos),vec2(S+D,1),R) * blink;\n    \n    \n    // ### Draw the digits ###\n    \n    // Center the clock on the screen\n    // The initial center is at the center of the most-right digit,\n    // so move it right between the two minutes digits :\n    // We move for 2.5 digits space, plus the dot spacing.\n    pos.x -= 2.5*S+2.*D;\n    \n    // Number to divide date with\n    // (1 for seconds, 10 for seconds decades, 60 for minutes, etc) \n    float T=1.;\n    // Loop over the 6 digits of the clock, starting with seconds\n    for(float i = 0.; i < 6.; i++)\n    {\n        // Modulo for each digit (10 for units, 6 for decades)\n        float t = mod(i,2.)==0. ? 10. : 6.;\n                                             // offset for each digit + offset every two digits for dots\n        light += draw_num(rotate_around_point(pos  +  i*vec2(S,0)     +   (i-mod(i,2.))*vec2(D,0),\n                                              // shake the digit\n                                              .1*sin(.05 / (pow(0.5, i)*mod(date,T))),  O),\n                          R, int(mod(date / T, t)));\n        // Update T for next digit\n        T*=t;\n    }\n    \n    vec3 col = vec3(0.4, 0.2, 1.0) * 0.1;\n    fragColor = vec4(col*light,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Draw a segment of thickness R between p1 and p2\nfloat d_seg(vec2 pos, vec2 p1, vec2 p2, float R)\n{\n    // Segment unitary vector\n\tvec2 v = normalize(p2-p1);\n    // Compute the projection of pos on the segment (clamped at segment edges)\n    vec2 proj = p1 + v*clamp(dot(pos-p1,v),0.,length(p2-p1));\n\treturn max(1. / abs(length(pos-proj)-R) - 1., 0.);\n}\n\n// Draw a dot of thickness R at p\nfloat d_dot(vec2 pos, vec2 p, float R)\n{\n\treturn max(1. / abs(length(pos-p)-R) - 1., 0.);\n}\n\n#define ROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// Rotate the vector pos around rotation_center\nvec2 rotate_around_point(vec2 pos, float angle, vec2 rotation_center){\n    return (pos-rotation_center)*ROT(angle)+rotation_center;\n}\n\n// Draw a digit of size (2,4) centered on (0,0)\nfloat draw_num(vec2 pos, float R, int num){\n    float line = 0.;\n    if(num==0 || num==2 || num==6 || num==8)              // bottom left\n        line += d_seg(pos, vec2(-1,-2), vec2(-1, 0), R);\n    if(num!=1 && num!=2 && num!=3 && num!=7)              // top left\n        line += d_seg(pos, vec2(-1, 0), vec2(-1, 2), R);\n    if(num!=1 && num!=4)                                  // top\n        line += d_seg(pos, vec2(-1, 2), vec2( 1, 2), R);\n    if(num!=5 && num!=6)                                  // top right\n        line += d_seg(pos, vec2( 1, 2), vec2( 1, 0), R);\n    if(num!=2)                                            // bottom right\n        line += d_seg(pos, vec2( 1, 0), vec2( 1,-2), R);\n    if(num!=1 && num!=4 &&num!=7)                         // bottom\n        line += d_seg(pos, vec2( 1,-2), vec2(-1,-2), R);\n    if(num!=0 && num!=1 && num!=7)                        // center\n        line += d_seg(pos, vec2(-1, 0), vec2( 1, 0), R);\n    return line;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}