{
    "Shader": {
        "info": {
            "date": "1586377183",
            "description": "Visualizing the basins of attraction of an alternating gradient descent to two different curves.\nFor many curve combinations, the resulting image is fractal.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sScWR",
            "likes": 6,
            "name": "Bezout Basins",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "math",
                "curve"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 351
        },
        "renderpass": [
            {
                "code": "/*\nVisualization of the basins of attraction of an alternating gradient descent\nto two different algebraic curves.\nThis iteration can be used to find the intersections of these curves.\n\nIf the curves have intersections, points near these intersections converge\nto these intersections, but there are also other points of attraction sometimes.\n\nFor every pixel, the color is choosen according to the point\nto which the pixel coordinate converges under the iteration,\nquite similar to newton fractals.\n\nThe name i've choosen comes from the related Bezout's Theorem\n(see https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem)\nand because it's an alliteration, of course!\n\nYou can play around with different curve combinations below.\n\nIf you uncomment MOUSE_ITERATION, the point to which the\ncurrent mouse position converges is shown.\n*/\n\nfloat fac;\nconst float pi=3.14159265358979;\n\nconst int num_iterations=24;\nconst int aa=2;\n\n//#define MOUSE_ITERATION\n\n#define CURVE1(p,grad) saddle(p,grad)\n#define CURVE2(p,grad) circle(p,grad)\n\n//#define CURVE1(p,grad) parabola(p,grad)\n//#define CURVE2(p,grad) circle(p,grad)\n\n//#define CURVE1(p,grad) trifoil(p*fac,grad);grad*=fac\n//#define CURVE2(p,grad) deltoid(p,grad)\n\n//#define CURVE1(p,grad) deltoid(p,grad)\n//#define CURVE2(p,grad) deltoid(p*vec2(-1,1)*fac,grad);grad*=fac*vec2(-1,1)\n\n//#define CURVE1(p,grad) lemniscate(p,grad)\n//#define CURVE2(p,grad) parabola(p,grad)\n\n//#define CURVE1(p,grad) circle(p,grad)\n//#define CURVE2(p,grad) bicorn(p,grad)\n\n//#define CURVE1(p,grad) devil(p,grad)\n//#define CURVE2(p,grad) lemniscate(p,grad)\n\n//#define CURVE1(p,grad) kappa(p,grad)\n//#define CURVE2(p,grad) deltoid(p,grad)\n\n//#define CURVE1(p,grad) neile(p,grad)\n//#define CURVE2(p,grad) lemniscate(p,grad)\n\n//#define CURVE1(p,grad) trisectrix(p.yx,grad);grad=grad.yx\n//#define CURVE2(p,grad) parabola(p,grad)\n\n//#define CURVE1(p,grad) ampersand(p.yx*fac,grad);grad=grad.yx*fac\n//#define CURVE2(p,grad) bicorn(p*vec2(1,-1),grad);grad*=vec2(1,-1)\n\n//#define CURVE1(p,grad) saddle(p,grad)\n//#define CURVE2(p,grad) squircle(p*fac,grad);grad=grad*fac\n\n//#define CURVE1(p,grad) hyperbola(p,grad)\n//#define CURVE2(p,grad) saddle(p,grad)\n\nfloat hyperbola(vec2 p, out vec2 grad){\n\tgrad = p.yx;\n\n\treturn p.x*p.y-fac*fac;\n}\n\nfloat squircle(vec2 p, out vec2 grad){\n\tfloat x_2 = p.x*p.x;\n\tfloat y_2 = p.y*p.y;\n\n\tgrad = 4.*vec2(x_2*p.x,y_2*p.y);\n\t\n\treturn x_2*x_2+y_2*y_2-.27;\n}\n\nfloat ampersand(vec2 p, out vec2 grad){\n\tfloat x_2 = p.x*p.x;\n\tfloat y_2 = p.y*p.y;\n\n\tgrad=vec2(((-24.*p.x+63.)*p.x-38.-12.*y_2)*p.x+11.*y_2,(-16.*y_2+(-12.*p.x+22.)*p.x+6.)*p.y);\n\t\n\tfloat tmp=(x_2+y_2-2.*p.x);\n\treturn (y_2-x_2)*(p.x-1.)*(2.*p.x-3.)-4.*tmp*tmp;\n}\n\nfloat trisectrix(vec2 p, out vec2 grad){\n\tfloat x_2 = p.x*p.x;\n\tfloat y_2 = p.y*p.y;\n\n\tgrad=2.*vec2((p.x-fac)*3.*p.x+y_2,(fac+2.*p.x)*p.y);\n\n\treturn 2.*p.x*(x_2+y_2)-fac*(3.*x_2-y_2);\n}\n\nfloat trifoil(vec2 p, out vec2 grad){\n\tfloat y_2=p.y*p.y;\n\n\tgrad=vec2(((4.*p.x-3.)*p.x+4.*y_2)*p.x+3.*y_2,(4.*y_2+(4.*p.x+6.)*p.x)*p.y);\n\n    return (((p.x - 1. )*p.x+2.*y_2)*p.x+3.*y_2)*p.x + y_2*y_2;\n}\n\nfloat deltoid(vec2 p, out vec2 grad){\n\tfloat y_2=p.y*p.y;\n\n\tgrad = vec2(((-4.*p.x+24.)*p.x+(-4.*y_2-36.))*p.x -24.*y_2,  (-4.*y_2 + (-4.*p.x-48.)*p.x -36.  ) * p.y);\n\n\treturn (((-p.x+8.)*p.x-18.-2.*y_2)*p.x-24.*y_2)*p.x + (-y_2-18.)*y_2+27.;\n}\n\nfloat circle(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x,2.*p.y);\n\treturn p.x*p.x+p.y*p.y-.27*.27;\n}\n\nfloat saddle(vec2 p, out vec2 grad){\n\tgrad = vec2(fac*3.*p.x*p.x,-1.);\n\treturn fac*p.x*p.x*p.x-p.y;\n}\n\nfloat parabola(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x,-1.);\n\treturn p.x*p.x-p.y;\n}\n\nfloat kappa(vec2 p, out vec2 grad){\n\tfloat x_2=p.x*p.x;\n\tfloat y_2=p.y*p.y;\n\n\tgrad = vec2((2.*x_2+y_2)*2.*p.x,(x_2-fac*fac)*2.*p.y);\n\treturn x_2*(x_2+y_2) - fac*fac * y_2;\n}\n\nfloat neile(vec2 p, out vec2 grad){\n\tgrad = vec2(-3.*fac*fac*p.x*p.x,2.*p.y);\n\treturn p.y*p.y-fac*fac*p.x*p.x*p.x;\n}\n\nfloat lemniscate(vec2 p, out vec2 grad){\n\tfloat x_2 = p.x*p.x;\n\tfloat y_2 = p.y*p.y;\n\n\tgrad = vec2((x_2+(y_2-fac*fac))*4.*p.x,(y_2+x_2+fac*fac)*4.*p.y);\n\n\treturn (x_2+y_2)*(x_2+y_2)-2.*fac*fac*(x_2-y_2);\n}\n\nfloat bicorn(vec2 p, out vec2 grad){\n\tfloat x_2=p.x*p.x;\n\tfloat y_2=p.y*p.y;\n\n\tgrad = vec2((-2.*x_2+(2.*fac-4.*p.y)*fac-y_2)*p.x,((2.*fac-3.*p.y)*fac-2.*x_2)*fac-x_2*p.y)*2.;\n\n\tfloat tmp=x_2+2.*fac*p.y-fac*fac;\n\treturn y_2*(fac*fac-x_2)-tmp*tmp;\n}\n\nfloat devil(vec2 p, out vec2 grad){\n\tfloat x_2=p.x*p.x;\n\tfloat y_2=p.y*p.y;\n\n\tgrad = 2.*vec2((-2.*x_2+1.)*p.x,(2.*y_2-fac*fac)*p.y);\n\n\treturn (-x_2+1.)*x_2+(y_2-fac*fac)*y_2;\n}\n\nmat2 rot(float angle){\n\treturn mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\n\nvec2 iteration(vec2 p){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1=CURVE1(p,p_grad1);\n\tp-=(p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\tp_val2=CURVE2(p,p_grad2);\n\tp-=(p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\treturn p;\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction =atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= aspect_ratio;\n\n\tvec2 mouse = (iMouse.xy+1.) / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= aspect_ratio;\n\n\tvec2 mouse2 = iMouse.zw / iResolution.xy;\n\tmouse2-=.5;\n\tmouse2.x *= aspect_ratio;\n\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\n\tconst float axis_width = .005;\n\n\tvec3 bg_col = vec3(0);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 second_curve_col = vec3(0,1,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\n    float border = 2./iResolution.y;\n\n\t#ifdef MOUSE_ITERATION\n\tfac=exp(mouse2.y*10.);\n\tfloat zoom = exp(mouse2.x*10.);\n\n\tvec2 p0=zoom*mouse;\n\t#else\n    float zoom;\n    if(iMouse.xy==vec2(0)){\n        fac=7.1;\n        zoom=1.;\n    }\n    else{\n\t\tfac=exp(mouse.y*10.);\n\t\tzoom = exp(mouse.x*10.);\n    }\n\t#endif\n\n\tuv*=zoom;\n\tborder*=zoom;\n\n\tfloat curve_dis = 1e38;\n\tfloat second_curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\n\tconst mat2 aa_rot=mat2(1.,.5,-.5,1.);\n\n\tvec3 col_sum=vec3(0);\n\n\tfor(int x=0;x<aa;x++){\n\t\tfor(int y=0;y<aa;y++){\n\t\t\tvec2 aa_offset=(vec2(x,y)-.5*(float(aa)-1.))/float(aa);\n\t\t\taa_offset*=zoom*vec2(aspect_ratio,1)/iResolution.xy;\n\t\t\tvec2 p1=uv+aa_offset;\n\n\t\t\tfor(int i=0;i<num_iterations;i++){\n\t\t\t\tp1=iteration(p1);\n\t\t\t}\n\n\t\t\tcol_sum+=pow(to_col(p1),vec3(2.2));\n\t\t}\n\t}\n\n\tbg_col=pow(col_sum/(float(aa)*float(aa)),vec3(1.0/2.2));\n\tbg_col*=.75;\n\n\t#ifdef MOUSE_ITERATION\n\tdot_dis=min(dot_dis,distance(uv,p0)-dot_size*zoom);\n\tfloat p0_val1, p0_val2;\n\tvec2 p0_grad1, p0_grad2;\n\tfor(int i=0;i<num_iterations;i++){\n\t\tp0=iteration(p0);\n\t}\n\n\tdot_dis=min(dot_dis,distance(uv,p0)-dot_size*zoom);\n\t#endif\n\n\tfloat val1, val2;\n\tvec2 grad1, grad2;\n\n\tval1=CURVE1(uv,grad1);\n\tcurve_dis=min(curve_dis,abs(val1)/length(grad1));\n\n\tval2=CURVE2(uv,grad2);\n\tsecond_curve_dis=min(second_curve_dis,abs(val2)/length(grad2));\n\n\taxis_dis=min(axis_dis, abs(uv.x));\n\taxis_dis=min(axis_dis, abs(uv.y));\n\n\tvec3 color = bg_col;\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(second_curve_col,color,smoothstep(0., border, second_curve_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}