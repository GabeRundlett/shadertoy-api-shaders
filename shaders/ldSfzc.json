{
    "Shader": {
        "info": {
            "date": "1501549781",
            "description": "Napoleon's problem is one of the famous compass construction problem.\n\nUse keyboard to navigate (A,D, Right, Left).\n\nI you find misprint plz tell me.",
            "flags": 48,
            "hasliked": 0,
            "id": "ldSfzc",
            "likes": 16,
            "name": "[SH17C] Napoleon's problem",
            "published": 3,
            "tags": [
                "compass",
                "construction",
                "sh17c",
                "napoleon"
            ],
            "usePreview": 0,
            "username": "Zabidon",
            "viewed": 805
        },
        "renderpass": [
            {
                "code": "// License: Do What The F**k You Want To But It's Not My Fault Public License v1 (WTFNMFPL-1.0)\n// Created by Osipov Kirill --- zabidon, KirillD503\n\n#define PI2 6.2831853\n#define BLUR_SIZE 1.\n#define EPS 0.001\n\n#define C_CIRCLE_RAD 0.8\n\n#define C1_CIRCLE_RAD 0.6\n#define C2_CIRCLE_RAD C1_CIRCLE_RAD\n#define C3_CIRCLE_RAD 0.8 - 0.35\n#define C4_CIRCLE_RAD 0.6\n#define LINE_WIDTH 0.01\n\n#define POINT_SIZE 0.02\n\n#define TEXT_COLOR vec4(0.2, 0.2, 0.2, 1)\n\n#define START_DRAW_ORIGIN_CIRCLE 5.\n#define DURATION_DRAW_ORIGIN_CIRCLE 4.\n#define ORIGINAL_CIRCLE_COLOR vec4(0,0,0,1)\n\n#define START_FIRST_STEP 9.\n#define START_DRAW_FIRST_CIRCLE 16.\n#define DURATION_DRAW_FIRST_CIRCLE 4.\n#define FIRST_CIRCLE_COLOR vec4(1,0,0,1)\n\n#define START_SECOND_STEP 21.\n#define START_DRAW_SECOND_CIRCLES 29.\n#define DURATION_DRAW_SECOND_CIRCLES 4.\n#define SECOND_CIRCLES_COLOR vec4(0,0,1,1)\n\n#define START_THIRD_STEP 34.\n#define START_DRAW_THIRD_CIRCLE 43.\n#define DURATION_DRAW_THIRD_CIRCLE 4.\n#define THIRD_CIRCLE_COLOR vec4(0.0,1.0,0.0,1)\n\n#define START_FOURTH_STEP 48.\n#define START_DRAW_FOURTH_CIRCLES 56.\n#define DURATION_DRAW_FOURTH_CIRCLES 4.\n#define FOURTH_CIRCLES_COLOR vec4(0.64,0.16,0.16,1)\n\n#define START_CONCLUSION_STEP 61.\n\n// The \"char\" function is taken from https://www.shadertoy.com/view/llySRh\n// Thanks to FabriceNeyret2\nfloat char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return 0.;\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) ).x;\n}\n\nfloat smoothgrid(vec2 uv, float spacing, float thickness, float alpha) {\n    float thick = .5 * max(thickness, 2./iResolution.y);\n    vec2 rep = mod(uv, vec2(spacing)) - thick;\n    vec2 lines = vec2(alpha) * smoothstep(1., 0., abs(rep) / thick);\n    return 1. - max(lines.x, lines.y);\n}\n\nfloat segment(vec2 uv, vec2 origin, float inner_dist, float outer_dist, float start_angle, float end_angle) {\n    vec2 dest = uv - origin;\n    float d = length(dest);\n    float screen_d = BLUR_SIZE * fwidth(d);\n    float inner_circle = smoothstep(inner_dist + screen_d, inner_dist - screen_d, d);\n    float outer_circle = smoothstep(outer_dist + screen_d, outer_dist - screen_d, d);\n    float circle = outer_circle - inner_circle;\n    \n    float angle = atan(dest.y, dest.x) / PI2;\n    angle = fract(angle);\n    float screen_a = BLUR_SIZE * fwidth(angle);\n    float segment = smoothstep(end_angle + screen_a, end_angle - screen_a, angle);\n    \n    segment -= smoothstep(start_angle + screen_a, start_angle - screen_a, angle);\n    // fix problems caused by antialiasing\n    segment *= smoothstep(0.0, screen_a, angle);\n    segment = mix(segment, 1.0, step(1.0, end_angle - start_angle));\n    \n    return circle * segment;\n}\n\n//============================================================\n// BEGIN UTIL\n//============================================================\n\nvec4 load_vec4(int var_id) {\n  float id = float(var_id);\n  vec2 var_coord = (vec2(\n          mod(id, iResolution.y),\n          floor(id / iResolution.y)\n  \t\t) + 0.5) / iResolution.xy;\n  return texture(iChannel0, var_coord);\n}\n\n\n//============================================================\n// END UTIL\n//============================================================\n\n// decode\n// a = \"string\"; console.log(a.split(\"\").map(e=>e.charCodeAt(0)).join())\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 origin = vec2(0);\n    float inner_dist = 0.75;\n    float outer_dist = 0.85;\n    float start_angle = 0.1;\n    float end_angle = 0.7;\n\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n \tvec2 or_uv = uv;\n    \n    vec4 main_color = vec4(0.8, 0.9, 0.9, 1.0);\n    vec4 color = main_color * smoothgrid(uv / 4.07 + 20., 0.02, 0.001, 0.3);\n        \n    vec3 rgb = vec3( 1.0, 0.4, 0.1 );\n\n    float string_offset = 0.;\n\tvec2 text_uv = uv + vec2(1.6, -0.72);\n    \n    vec4 timeline_date = load_vec4(0);\n    float t = timeline_date[0];\n    \n    if (t > 0.) {\n        // \"Problem: find the center of a given circle with compass alone.\"\n        const int string_task[] = int[](80,114,111,98,108,101,109,58,32,102,105,110,100,32,116,104,101,32,99,101,110,116,101,114,32,111,102,32,97,32,103,105,118,101,110,32,99,105,114,99,108,101,32,119,105,116,104,32,99,111,109,112,97,115,115,32,97,108,111,110,101,46);\n        for (int i=0; i < string_task.length(); i++) {\n            if (t < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(float(i) * 1.2, string_offset) / 24.) * 10., string_task[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n    }\n\t\n    uv -= vec2(0, -0.1);\n    uv += mix(vec2(0), vec2(-0.5, 0), clamp((t - START_FIRST_STEP) / 2., 0., 1.));\n    uv *= mix(vec2(1), vec2(1.2), clamp((t - START_FIRST_STEP) / 2., 0., 1.));\n    uv *= mix(vec2(1), vec2(1.25), clamp((t - START_SECOND_STEP) / 2., 0., 1.));\n    uv += mix(vec2(0), vec2(-0.3, 0), clamp((t - START_SECOND_STEP) / 2., 0., 1.));\n   // uv += mix(vec2(0), vec2(-0.1, 0), clamp((t - START_THIRD_STEP) / 2., 0., 1.));\n    \n    // original circle\n    if (t > START_DRAW_ORIGIN_CIRCLE) {\n        float d = mix(0., 1.1, (t - START_DRAW_ORIGIN_CIRCLE) / DURATION_DRAW_ORIGIN_CIRCLE);\n        float s = mix(1., 0.2, clamp((t - 61.) / 4., 0., 1.));\n        float inten_original_circle = segment(\n            uv, vec2(0.0), (C_CIRCLE_RAD - LINE_WIDTH / 2.),\n            C_CIRCLE_RAD + LINE_WIDTH / 2., 0., d\n        );\n\n        color = mix(color, ORIGINAL_CIRCLE_COLOR, inten_original_circle);\n    }\n\n    // first circle\n    if (t > START_FIRST_STEP) {\n        // \"1) Let A be a point of the given circle.\"\n        const int string_1_step_1[] = int[](49,41,32,76,101,116,32,65,32,98,101,32,97,32,112,111,105,110,116,32,111,102,32,116,104,101,32,103,105,118,101,110,32,99,105,114,99,108,101,46);\n        string_offset -= 3.7;\n        for (int i=0; i < string_1_step_1.length(); i++) {\n            if (t - START_FIRST_STEP < float(i) / 10.) {\n                break;\n            }\n\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_1_step_1[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n        // \"Draw a red circle centered at A\"\n        const int string_1_step_2[] = int[](68,114,97,119,32,97,32,114,101,100,32,99,105,114,99,108,101,32,99,101,110,116,101,114,101,100,32,97,116,32,65);\n        string_offset -= 2.;\n        for (int i=0; i < string_1_step_2.length(); i++) {\n            if (t - START_FIRST_STEP - 4. < float(i) / 10.) {\n                break;\n            }\n\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_1_step_2[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n\n        // \"meeting the black circle at B and C.\"\n        const int string_1_step_3[] = int[](109,101,101,116,105,110,103,32,116,104,101,32,98,108,97,99,107,32,99,105,114,99,108,101,32,97,116,32,66,32,97,110,100,32,67,46);\n        string_offset -= 2.;\n        for (int i=0; i < string_1_step_3.length(); i++) {\n            if (t - START_FIRST_STEP - 7. < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_1_step_3[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n\n        float d = mix(0., 1.1, (t - START_DRAW_FIRST_CIRCLE) / DURATION_DRAW_FIRST_CIRCLE);\n        float inten_c1 = segment(\n            uv, vec2(C_CIRCLE_RAD, .0), C1_CIRCLE_RAD - LINE_WIDTH / 2.,\n            C1_CIRCLE_RAD + LINE_WIDTH / 2., 0., d\n        );\n        color = mix(color, FIRST_CIRCLE_COLOR, inten_c1);\n\n        if (t > START_DRAW_FIRST_CIRCLE + 4.) {\n            // B\n            color = mix(color, vec4(0,0,0,1), char((uv - vec2(0.56, -.66)) * 12., 66));\n            // C\n            color = mix(color, vec4(0,0,0,1), char((uv - vec2(0.56, .57)) * 12., 67));\n\n            color = mix(color, SECOND_CIRCLES_COLOR, segment(uv, vec2(0.575, -.556215), -POINT_SIZE, POINT_SIZE, -0.1, 1.));\n            color = mix(color, SECOND_CIRCLES_COLOR, segment(uv, vec2(0.575, .556215), -POINT_SIZE, POINT_SIZE, -0.1, 1.));\n        }\n    }\n\n    if (t > START_SECOND_STEP) {\n        // \"2) Draw two blue circles centered at B and C,\"\n        const int string_2_step_1[] = int[](50,41,32,68,114,97,119,32,116,119,111,32,98,108,117,101,32,99,105,114,99,108,101,115,32,99,101,110,116,101,114,101,100,32,97,116,32,66,32,97,110,100,32,67,44);\n        string_offset -= 3.9;\n        for (int i=0; i < string_2_step_1.length(); i++) {\n            if (t - START_SECOND_STEP < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_2_step_1[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n\n        // \"with radius AB, crossing at point E.\"\n        const int string_2_step_2[] = int[](119,105,116,104,32,114,97,100,105,117,115,32,65,66,44,32,99,114,111,115,115,105,110,103,32,97,116,32,112,111,105,110,116,32,69,46);\n        string_offset -= 2.;\n        for (int i=0; i < string_2_step_2.length(); i++) {\n            if (t - START_SECOND_STEP - 4.5 < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_2_step_2[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n\n        float d = mix(0., 1.1, (t - START_DRAW_SECOND_CIRCLES) / DURATION_DRAW_SECOND_CIRCLES);\n        float inten_c21 = segment(\n            uv, vec2(0.575, -.556215), C2_CIRCLE_RAD - LINE_WIDTH / 2.,\n            C2_CIRCLE_RAD + LINE_WIDTH / 2., 0., d\n        );\n        float inten_c22 = segment(\n            uv, vec2(0.575, .556215), C2_CIRCLE_RAD - LINE_WIDTH / 2.,\n            C2_CIRCLE_RAD + LINE_WIDTH / 2., 0., d\n        );\n\n        color = mix(color, SECOND_CIRCLES_COLOR, inten_c21);\n        color = mix(color, SECOND_CIRCLES_COLOR, inten_c22);\n\n        if (t > START_DRAW_SECOND_CIRCLES + 4.) {    \n            // D\n            color = mix(color, vec4(0,0,0,1), char((uv - vec2(0.32, 0.01)) * 12., 69));\n            color = mix(color, THIRD_CIRCLE_COLOR, segment(uv, vec2(0.35, 0.0), -POINT_SIZE, POINT_SIZE, -0.1, 1.));\n        }\n    }\n\n    if (t > START_THIRD_STEP) {\n        // \"3) Draw a green circle centered at E with\"\n        const int string_3_step_1[] = int[](51,41,32,68,114,97,119,32,97,32,103,114,101,101,110,32,99,105,114,99,108,101,32,99,101,110,116,101,114,101,100,32,97,116,32,69,32,119,105,116,104);\n        string_offset -= 3.9;\n        for (int i=0; i < string_3_step_1.length(); i++) {\n            if (t - START_THIRD_STEP < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_3_step_1[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n\n        // \"radius AE meeting red circle at F and G.\"\n        const int string_3_step_2[] = int[](114,97,100,105,117,115,32,65,69,32,109,101,101,116,105,110,103,32,114,101,100,32,99,105,114,99,108,101,32,97,116,32,70,32,97,110,100,32,71,46);\n        string_offset -= 2.;\n        for (int i=0; i < string_3_step_2.length(); i++) {\n            if (t - START_THIRD_STEP - 4. < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_3_step_2[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n\n        float d = mix(0., 1.1, (t - START_DRAW_THIRD_CIRCLE) / DURATION_DRAW_THIRD_CIRCLE);\n        float inten_c3 = segment(\n            uv, vec2(0.35, 0.0), C3_CIRCLE_RAD - LINE_WIDTH / 2.,\n            C3_CIRCLE_RAD + LINE_WIDTH / 2., 0., d\n        );\n\n        color = mix(color, THIRD_CIRCLE_COLOR, inten_c3);\n\n        if (t > START_DRAW_THIRD_CIRCLE + 4.) {\n            // E\n            color = mix(color, vec4(0,0,0,1), char((uv - vec2(0.39, -0.43)) * 12., 70));\n            // G\n            color = mix(color, vec4(0,0,0,1), char((uv - vec2(0.34, 0.45)) * 12., 71));\n\n\n            color = mix(color, FOURTH_CIRCLES_COLOR, segment(uv, vec2(0.4, -0.447214), -POINT_SIZE, POINT_SIZE, -0.1, 1.));\n            color = mix(color, FOURTH_CIRCLES_COLOR, segment(uv, vec2(0.4, 0.447214), -POINT_SIZE, POINT_SIZE, -0.1, 1.));\n        }\n    }\n\n    if (t > START_FOURTH_STEP) {\n        // \"4) Draw two brown circles centered\"\n        const int string_4_step_1[] = int[](52,41,32,68,114,97,119,32,116,119,111,32,98,114,111,119,110,32,99,105,114,99,108,101,115,32,99,101,110,116,101,114,101,100);\n        string_offset -= 3.9;\n        for (int i=0; i < string_4_step_1.length(); i++) {\n            if (t - START_FOURTH_STEP < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_4_step_1[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n\n        // \"at F and G with radius AF crossing at O.\"\n        const int string_4_step_2[] = int[](97,116,32,70,32,97,110,100,32,71,32,119,105,116,104,32,114,97,100,105,117,115,32,65,70,32,99,114,111,115,115,105,110,103,32,97,116,32,79,46);\n        string_offset -= 2.;\n        for (int i=0; i < string_4_step_2.length(); i++) {\n            if (t - START_FOURTH_STEP - 4. < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(i, string_offset) / 24.) * 12., string_4_step_2[i]);\n            color = mix(color, TEXT_COLOR, inten);\n        }\n\n        float d = mix(0., 1.1, (t - START_DRAW_FOURTH_CIRCLES) / DURATION_DRAW_FOURTH_CIRCLES);\n        float inten_c41 = segment(\n            uv, vec2(0.4, -0.447214), C4_CIRCLE_RAD - LINE_WIDTH / 2.,\n            C4_CIRCLE_RAD + LINE_WIDTH / 2., 0., d\n        );\n        float inten_c42 = segment(\n            uv, vec2(0.4, 0.447214), C4_CIRCLE_RAD - LINE_WIDTH / 2.,\n            C4_CIRCLE_RAD + LINE_WIDTH / 2., 0., d\n        );\n\n        color = mix(color, FOURTH_CIRCLES_COLOR, inten_c41);\n        color = mix(color, FOURTH_CIRCLES_COLOR, inten_c42);\n\n        if (t > START_DRAW_FOURTH_CIRCLES + 4.) {\n            // O\n            color = mix(color, vec4(0,0,0,1), char((uv - vec2(-0.03, 0.03)) * 10., 79));\n            color = mix(color, ORIGINAL_CIRCLE_COLOR, segment(uv, vec2(0.0), -POINT_SIZE, POINT_SIZE, 0., 1.));\n        }\n    }\n\n    if (t > START_CONCLUSION_STEP) {\n        // \"O is the sought center of the given (black) circle.\"\n        const int string_result[] = int[](79,32,105,115,32,116,104,101,32,115,111,117,103,104,116,32,99,101,110,116,101,114,32,111,102,32,116,104,101,32,103,105,118,101,110,32,40,98,108,97,99,107,41,32,99,105,114,99,108,101,46);\n        string_offset -= 13.6;\n        for (int i=0; i < string_result.length(); i++) {\n            if (t - START_CONCLUSION_STEP < float(i) / 10.) {\n                break;\n            }\n            float inten = char((text_uv - vec2(float(i) * 1.2, string_offset) / 24.) * 10., string_result[i]);\n            color = mix(color, vec4(0.2,0.2,0.2,1), inten);\n        }\n    }\n\n    // HACK:\n    if (t > START_DRAW_ORIGIN_CIRCLE + 4.) {\n        // A\n        color = mix(color, vec4(0,0,0,1), char((uv - vec2(0.83, -0.035)) * 12., 65));\n        color = mix(color, FIRST_CIRCLE_COLOR, segment(uv, vec2(C_CIRCLE_RAD, .0), -POINT_SIZE, POINT_SIZE, -0.1, 1.));\n    }\n    \n    vec4 noise = texture(iChannel2, or_uv).xxxx;\n\n    fragColor = color + (noise - 0.5) * 0.1;  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\n\nbool is_pressed(int key) {\n\treturn texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.0;\n}\n\n//============================================================\n// BEGIN UTIL\n//============================================================\n\nvec4 load_vec4(int var_id) {\n  float id = float(var_id);\n  vec2 var_coord = (vec2(\n          mod(id, iResolution.y),\n          floor(id / iResolution.y)\n  \t\t) + 0.5) / iResolution.xy;\n  return texture(iChannel0, var_coord);\n}\n\nvoid save_vec4(int var_id, vec4 val, inout vec4 fragColor, vec2 fragCoord) {\n  float id = float(var_id);\n  vec2 d = abs(fragCoord - vec2(\n          mod(id, iResolution.y),\n          floor(id / iResolution.y)\n  \t\t) - 0.5);\n  if (max(d.x, d.y) < 0.5)\n      fragColor = val;\n}\n\n//============================================================\n// END UTIL\n//============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data;\n    if (iFrame < 10) {\n        data = vec4(0., 0., 0., 0.);\n    } else {\n        data = load_vec4(0);\n    }\n    \n    data[0] += iTimeDelta;\n\n    if (is_pressed(KEY_RIGHT) || is_pressed(KEY_D))\n        data[0] += 5.;\n    else if (is_pressed(KEY_LEFT) || is_pressed(KEY_A))\n        data[0] -= 5.;\n    data[0] = mod(data[0], 100.);\n        \n    save_vec4(0, data, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}