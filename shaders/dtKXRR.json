{
    "Shader": {
        "info": {
            "date": "1685906022",
            "description": "Simple fract repetition time based pattern derived from this tutorial by Kishimisu https://www.youtube.com/watch?v=f4s1h2YETNY",
            "flags": 0,
            "hasliked": 0,
            "id": "dtKXRR",
            "likes": 3,
            "name": "Interference Candy",
            "published": 3,
            "tags": [
                "2d",
                "psychedelic",
                "colourful"
            ],
            "usePreview": 0,
            "username": "Pink",
            "viewed": 194
        },
        "renderpass": [
            {
                "code": "//Based on https://www.youtube.com/watch?v=f4s1h2YETNY\n//License: MIT\n//inline comments may not be completely accurate.\n\nvec3 palette (float dist)\n{\n    //make a distance based colour gradient\n    vec3 a = vec3(0.5,0.0,0.5);\n    vec3 b = vec3(0.25,0.25,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a+b*cos(6.28318*(c*dist*d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //speed of ring movement (0.1 - 1.0 are good values)\n    float speed = 0.1;\n    //multiplier for number of colour rings (more rings more complex pattern)\n    float ringmultiplier = 4.0;\n    //width of colour regions (too high and you'll just get white as it uses additive colouring)\n    float ringwidth = 8.0;\n    //sort of smoothing between black and colour (0.1-0.4 are good)\n    float smoothing = 0.4;\n    //Iterations of fract (repeat of the pattern, set to 1 to see the basic pattern)\n    float iter = 8.0;\n    //Zoom amount, smaller = more zoomed in.\n    float zoom = 2.0;\n\n    float myTime = iTime*0.5;\n\n    // Centered aspect corrected normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = ((fragCoord * 2.0 - iResolution.xy) / iResolution.y);\n\n    //copy of uv before we mess with it in fract.\n    vec2 uv0 = uv;\n    \n    uv *= (zoom * sin(myTime*0.05));\n    //initialise output colour (we add to this in the loop)\n    vec3 outCol = vec3(0.0);\n\n    for(float i = 0.0; i < iter; i++)\n    {\n        //repeat pattern\n        uv = fract(uv * (1.25 + (sin((myTime * 0.1) * i))))-0.5;\n\n        //distance from centre \n        float dist = length(uv);\n\n        // Time varying simple pixel color\n        //vec3 col = 0.5 + 0.5 * cos((myTime*i*0.1) + uv.xyx + vec3(0,2,4));\n\n        //distance/time varying pixel colour gradient\n        vec3 col = palette(length(uv0) + myTime * (i*0.01));\n\n        //time based distance with modifiers for speed, width, and number of rings\n        dist = sin((dist + (myTime * speed)) * ringmultiplier * 2.0) / ringwidth;\n\n        //absolute the distance to invert negative values\n        dist = abs(dist);\n\n        //take the inverse of the distance (effectively inverts what gets coloured in);\n        dist = 0.001 / dist;\n\n        //smoothstep colour to give clean edges.\n        col = col * smoothstep(0.0, 0.5-smoothing, dist);\n\n        outCol += col + dist;\n    }\n    \n    // Output to screen\n    fragColor = vec4(outCol,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}