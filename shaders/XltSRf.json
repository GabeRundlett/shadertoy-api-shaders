{
    "Shader": {
        "info": {
            "date": "1482017924",
            "description": "Distance field pylons, in grass. Following a Catmull-Rom spline, with some added effects.",
            "flags": 112,
            "hasliked": 0,
            "id": "XltSRf",
            "likes": 40,
            "name": "Pylon",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "spline",
                "rain",
                "temporal",
                "pylon",
                "txaa"
            ],
            "usePreview": 1,
            "username": "Dave_Hoskins",
            "viewed": 2109
        },
        "renderpass": [
            {
                "code": "// Pylon by David Hoskins.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// It's meant to be some kind of defunct power grid or something, I don't really know.\n\n// Point this channel0 to Buf B for just the rendering.\n// 'Buf A' for manual/auto camera stuff\n// 'Buf B' does the main rendering / text info.\n// 'Buf C' for rain blobs on the camera.\n// 'Buf D' for temporal anti-aliasing.\n// 'Image' does the final colouring.\n\nvec3 post(vec3 rgb, vec2 xy)\n{\n\t// Then...\n\t#define CONTRAST 1.3\n\t#define SATURATION 1.\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t// Vignette...\n\trgb *= .5+0.5 *pow(60.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.5);\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy / iResolution.xy;\n    col = texture(iChannel0, p);\n    col = vec4(post(col.rgb, p), 1.0);// *  smoothstep(0.0, 4.0, iTime), 1.0);\n    //col = col*col*(3.0-2.0*col);\n\tcol = pow(col, vec4(0.45));\n\n\n}\n\n//----------------------------------------------------------------------------------------",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 20013,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/deeperlevel/zzzzra-le-labyrinthe-lineaire"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Movement...\n// Use this and the SEE_NUMBERS define in B to plot new points with a flying camera.\n\n// #define FLY_CAMERA\n\n// * * CONTROLS * *\n// WASD or CURSOR keys\n// Mouse drag to turn.\n// SHIFT & SPACE for 2X & 4X speed\n\n#define NUM_POINTS 61\n\n#define INVERT_Y 0\n#define ACCEL .01\n#define DECAY  .85 // how much velocity is preserved per frame (proportionally)\n#define MAX_SPEED  .1\n#define TAU 6.28318530718\n\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\nconst int KEY_W\t\t= 87;\nconst int KEY_A\t\t= 65;\nconst int KEY_S\t\t= 83;\nconst int KEY_D\t\t= 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE\t= 32;\nconst int KEY_SHIFT\t= 16;\n\nvec3 camPos[NUM_POINTS];\n         \n\n//----------------------------------------------------------------------------------------\nfloat ReadKey( int key )\n{\n   \treturn step(.5,texture( iChannel3, vec2( (float(key)+.5)/256.0, .25)).x);\n}\n\n//----------------------------------------------------------------------------------------\nfloat Scale = 4.;\nfloat MinRad2 = 0.25;\nfloat sr = 4.0;\nvec3 fo =vec3 (0.7,.9528,.9);\nvec3 gh = vec3 (.8,.7,0.5638);\nvec3 gw = vec3 (.3, 0.5 ,.2);\n\n#ifndef FLY_CAMERA\n\n// Catmull-rom spline\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n\n    vec3 c2 = -.5 * p0\t+ 0.5*p2;\n\tvec3 c3 = p0\t\t+ -2.5*p1 + 2.0*p2 + -.5*p3;\n    vec3 c4 = -.5 * p0\t+ 1.5*p1 + -1.5*p2 + 0.5*p3;\n\treturn(((c4 * t + c3) * t + c2) * t + p1);\n}\n\n//-----------------------------------------------------------------------------------------------------------\nvec3 getPosAtTime(float t)\n{\n    int i = int(t);\n    uvec4 id = uvec4(i-1, i, i+1, i+2);\n    id %= uint(camPos.length());\n    vec3 p0 = camPos[id.x];\n    vec3 p1 = camPos[id.y];\n    vec3 p2 = camPos[id.z];\n    vec3 p3 = camPos[id.w];\n\n\n    return spline(p0, p1, p2, p3, fract(t));\n\n} \n\n#endif\t\n//-----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    #ifdef FLY_CAMERA\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec3 camPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 ).xyz;\n            vec3 camVel = texture( iChannel0, vec2(3.5,.5)/iResolution.xy, -100.0 ).xyz;\n            float time  = (iTime-texture( iChannel0, vec2(4.5,.5)/iResolution.xy, -100.0 ).x)*30.0;\n             if (iFrame == 0)\n\t\t    {\n        \t\tfragColor = vec4(-161.0, 6.8, 507., 0.0);\n            }else\n            {\n                camVel *= time*(1.0+ReadKey(KEY_SHIFT)+ReadKey(KEY_SPACE));\n                vec3 oldCam = camPos;\n                camPos += camVel;\n            \tfragColor = vec4(camPos, 0);\n            }\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = texture( iChannel0, vec2(2.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.) *360.0;\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n\t\t\t\tif (iFrame == 0)\n\t\t    \t{\n        \t\t\tfragColor = vec4(.0, .75, .0,0);\n            \t}else\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camVel = texture( iChannel0, vec2(3.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 );\n            \n            camRot*= TAU/360.;\n            \n            vec3 forward = vec3(0,0,ACCEL);\n            vec3 right \t = vec3(ACCEL,0,0);\n\n            forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n            right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(KEY_W)-ReadKey(KEY_S)+ReadKey(KEY_UP)-ReadKey(KEY_DOWN)) * forward;\n            camVel.xyz += (ReadKey(KEY_D)-ReadKey(KEY_A)+ReadKey(KEY_RIGHT)-ReadKey(KEY_LEFT)) * right;\n            \n\n            camVel *= DECAY; // exponential decay\n            float lim = length(camVel);\n            if (lim > MAX_SPEED)\n            {\n                camVel = normalize(camVel) * MAX_SPEED;\n            }\n        \n            \n            fragColor = camVel;\n        }else if ( int(fragCoord.x) == 4 )\n        {\n            fragColor = vec4(iTime, 0,0,0);\n        }\n\n    }\n    #else\n    // Catmull-rom spline coords...\n    camPos[0] = vec3(-161.5,24.3,505.7);\n    camPos[1] = vec3(-161.7, 21.5, 489.3);\n    camPos[2] = vec3(-161.6, 22., 485.5);\n    camPos[3] = vec3(-162.2, 22.4, 480.8);\n    camPos[4] = vec3(-161.4, 20.5, 472.1);\n    camPos[5] = vec3(-161.0, 16.5, 466.);\n    camPos[6] = vec3(-162.6, 9.3, 457.3);\n    camPos[7] = vec3(-161.9, 6.0, 445.7);\n    camPos[8] = vec3(-161.7, 9.3, 437.);\n    camPos[9] = vec3(-166.6, 12.4, 432.2);\n    camPos[10] = vec3(-175.3, 13.1, 426.2);\n    camPos[11] = vec3(-179.4, 22.0, 454.7);\n    camPos[12] = vec3(-166.5, 20.1, 464.9);\n    camPos[13] = vec3(-161.0, 18.0, 465.4);\n    camPos[14] = vec3(-151.3, 13.9, 465.);\n    camPos[15] = vec3(-135.8, 10.4, 465.7);\n    camPos[16] = vec3(-131.8, 6.2, 473.7);\n    camPos[17] = vec3(-131.7, 6.9, 485.8);\n    camPos[18] = vec3(-130.7, 16.2, 499.8);\n    camPos[19] = vec3(-130.1, 21.9, 508.6);\n    camPos[20] = vec3(-130.0, 26.8, 537.8);\n    camPos[21] = vec3(-130.6, 36.1, 564.5);\n    camPos[22] = vec3(-141.5, 26.8, 590.0);\n    camPos[23] = vec3(-154.7, 15.8, 584.2);\n    camPos[24] = vec3(-161.5, 12.4, 583.7);\n    camPos[25] = vec3(-166.6, 12.6, 581.6);\n    camPos[26] = vec3(-163.6, 13.2, 587.4);\n    camPos[27] = vec3(-159.6, 13.2, 587.7);\n    camPos[28] = vec3(-153.6, 13.5, 588.3);\n    camPos[29] = vec3(-137.2, 13.4, 591.0);\n    camPos[30] = vec3(-121.8, 12.8, 585.7);\n    camPos[31] = vec3(-116.8, 11.3, 576.4);\n    camPos[32] = vec3(-109., 6.6, 556.7);\n    camPos[33] = vec3(-106.5, 3.9, 552.);\n    camPos[34] = vec3(-103.7, 3.9, 548.9);\n    camPos[35] = vec3(-102.9, 4.3, 545.6);\n    camPos[36] = vec3(-102.7, 5.9, 542.0);\n    camPos[37] = vec3(-103.1, 5.4, 538.2);\n    camPos[38] = vec3(-104.1, 6.5, 535.6);\n    camPos[39] = vec3(-105.5, 8.2, 532.6);\n    camPos[40] = vec3(-110.1, 11.5, 524.5);\n    camPos[41] = vec3(-126.1, 14.4, 522.5);\n    camPos[42] = vec3(-144.2, 12.9, 513.4);\n    camPos[43] = vec3(-133.2, 9.6, 533.0);\n    camPos[44] = vec3(-131.7, 8.0, 541.1);\n    camPos[45] = vec3(-125.7, 4.8, 556.5);\n    camPos[46] = vec3(-130.0, 5.6, 571.7);\n    camPos[47] = vec3(-129.6, 6.9, 580.7);\n    camPos[48] = vec3(-129.8, 18.6, 594.0);\n    camPos[49] = vec3(-130.1, 25.5, 600.6);\n    camPos[50] = vec3(-132.0, 41.1, 610.8);\n    camPos[51] = vec3(-132.0, 45.7, 654.6);\n    camPos[52] = vec3(-145.0, 24.6, 663.5);\n    camPos[53] = vec3(-143.0, 13.1, 656.9);\n    camPos[54] = vec3(-140.0, 8.9, 605.2);\n    camPos[55] = vec3(-138.0, 8.3, 582.1);\n    camPos[56] = vec3(-136.8, 6.8, 576.4);\n    camPos[57] = vec3(-138.8, 6.6, 568.6);\n    camPos[58] = vec3(-147.8, 10.6, 540.7);\n    camPos[59] = vec3(-155.8, 17.6, 520.7);\n    camPos[60] = vec3(-161.9, 19.5, 513.9);\n        \n    float t = iTime*.5;\n \n \n     if ( int(fragCoord.x) <= 1)\n     {\n\n\t\tvec3 pos = getPosAtTime(t);\n        if ( int(fragCoord.x) == 0)\n        {\n\t\t\tfragColor = vec4(pos, 1.0);\n        }else\n        if ( int(fragCoord.x) == 1)\n        {\n            // Get look at target\n            vec3 tar1 = getPosAtTime(t+.1);\n            vec3 tar = getPosAtTime(t+.2);\n            tar = (tar+tar1)*.5;\n            pos = tar - pos;\n            // Euler rotation angles...\n            vec3 rot = vec3(0);\n            rot.y = (atan(pos.x, pos.z))*360./TAU;\n            rot.x = (clamp(-pos.y*.5, -.8, 1.))*360./TAU-3.141;\n\t\t\tfragColor = vec4(rot,0);\n\n        }\n\t}\n    else if ( int(fragCoord.x) == 6)\n    {\n\t\tvec3 pos = getPosAtTime(t+1.);\n\t\tfragColor = vec4(pos,0);\n\t}\n    else if ( int(fragCoord.x) == 7)\n    {\n\t\tfragColor = vec4(t,0,0,0);\n\t}\n        \n    #endif\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Pylon, by Dave Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Use this to see the positional data for manual spline plotting...\n//#define SEE_NUMBERS\n\n//-------------------------------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .95, .8)\n#define HASHSCALE .1031\n#define TAU 6.28318530718\n\nfloat gTime = 0.0;\nfloat movement = 0.0;\nvec3 fogColour = vec3(.1,.1, .085);\nvec2 id;\nvec3 sunLight;\n\n#ifdef SEE_NUMBERS\nvec2 vFontSize = vec2(8.0, 15.0);\t// Multiples of 4x5 work best\n\n\n//-------------------------------------------------------------------------------------------------\nfloat DigitBin(const in int x)\n{\n    return x==0 ? 480599.0\n         : x==1 ? 139810.0\n         : x==2 ? 476951.0\n         : x==3 ? 476999.0\n         : x==4 ? 350020.0\n         : x==5 ? 464711.0\n         : x==6 ? 464727.0\n         : x==7 ? 476228.0\n         : x==8 ? 481111.0\n         : x==9 ? 481095.0\n         :             0.0;\n}\n\n//=================================================================\nfloat PrintValue(const in vec2 pos, \n                 const in vec2 vPixelCoords, \n                 const in float fValue, \n                 const in float fMaxDigits, \n                 const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (pos.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t  if((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) \n              fCharBin = 1792.0;\n\t\t} else {\n\t\t\tif(fDigitIndex == -1.) {\n\t\t\t\tif(fDecimalPlaces > 0.) fCharBin = 2.;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.) fDigitIndex += 1.;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) \n                                       + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n//=================================================================\n#endif\n\n//-------------------------------------------------------------------------------------------------\n// From https://www.shadertoy.com/view/4djSRW\nfloat Hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) * HASHSCALE);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\nfloat Hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nvec3 GetSky(vec3 pos)\n{\n    pos *= 4.;\n    pos.y += iTime;\n\tfloat t = Noise(pos);\n    t += Noise(pos * 2.1) * .5;\n    t += Noise(pos * 4.3) * .25;\n    t += Noise(pos * 7.9) * .125;\n\treturn (t) * fogColour + vec3(.1,.1,.1);\n}\n\n//----------------------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    x *= 100.;\n   vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash(p), Hash(p+ vec2(1.0, 0.0)),f.x),\n                    mix( Hash(p+ vec2(.0, 1.0)), Hash(p+ vec2(1.0, 1.0)),f.x),f.y);\n//  float res = texture(iChannel2, x).x;\n    return res;\n}\n//----------------------------------------------------------------------------------------\nfloat box(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n//----------------------------------------------------------------------------------------\nmat2 rotMat(float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\treturn mat2(c, s, -s, c);\n}\n\n//----------------------------------------------------------------------------------------\nfloat de(vec3 p)\n{\n    p*= .5;\n\tvec4 q = vec4(p, 1);\n\tq.xyz = q.xzy;\n    id = floor(2.5+q.xy/16.0);\n\tq.xy = mod(q.xy + 8., 16.0) -8.;\n\tq.z -= 8.0;\n    float m = 0.0;\n  \n    m = gTime*5.9;\n    m *= movement*smoothstep(-.2, .2, q.z);\n    \n    mat2 m1 = rotMat(-(.3+sin(id.y-m)*.05-.08));\n    mat2 m2 = rotMat(-.4*(1.+sin(id.x)*.4));\n\n\tfor(int i = 0; i < 6; i++)\n    {\n\t\tq.xyz = abs(q.xyz + 1.) - 1.5;\n\t\tq *= 1.5;\n\t\tq.xz = m1 * q.xz;\n\t\tq.zy = m2 * q.zy;\n\t}\n\t\n\tfloat f = box(q.zy, vec2(1.4))/q.w;\n\t\n\treturn f;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture( sam, p.yz ).xzy;\n\tvec3 y = texture( sam, p.zx ).xyz;\n\tvec3 z = texture( sam, p.xy ).yzx;\n\tvec3 col = (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n    \n    return col;\n}\n\n//----------------------------------------------------------------------------------------\nvec4 colour(vec3 p, vec3 nor, float ty)\n{\n    vec4 col;\n    if (ty == 0.0)\n    {\n    \tcol.xyz = texCube(iChannel1, p.xyz*.1, nor);\n        col.xyz = pow(col.xyz, vec3(2.))*1.;\n        float f = col.x+col.y+col.z;\n        if (f < .2) col.x = mix(col.x, 1., smoothstep(0.0, .02, f)*abs(sin(iTime*(.8+movement)-p.y*.1)));\n        \n        col = col *.75 +.2;\n        col.y = abs(sin(id.y*2.+id.x*2.)*col.y);\n        col.z = abs(cos(id.y*id.x)*col.z);\n        col.w = .3;\n    }\n    else\n    {\n        col.xyz = (1.0-texture(iChannel1, p.xz*.01).yzx)*.2+vec3(0.0,.05,0.0);\n        col.w = .04;\n    }\n    return col;\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat Terrain( in vec2 p)\n{\n\tfloat type = 0.0;\n\tvec2 pos = p*0.00025;\n\tfloat w = 10.0;\n\tfloat f = -4.0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = w * 0.52;\n\t\tpos *= 2.;\n\t}\n    return f;\n}\n//----------------------------------------------------------------------------------------\nvec2 map(in vec3 p)\n{\n    float r = 0.0;\n\tfloat h = p.y-Terrain(p.xz);\n    if (h < 3.0) r= pow(Noise(p.xz*.2),2.2)*Noise(p*.007)*3.;// ...Grass\n    h -= r;\n    float d = de(p);\n    if (h < d)\n\t    return vec2(h, 1.0 + h);\n    else\n        return vec2(d, 0.0);\n}\n\n//----------------------------------------------------------------------------------------\nfloat mapShad(in vec3 p)\n{\n\tfloat h = p.y-Terrain(p.xz);\n    float d = de(p);\n    return min(h, d);\n}\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = .1;\n\tfloat h;\n\t\n    for (int i = 0; i < 7; i++)\n\t{\n        vec3 p =  ro + rd*t;\n        //if (p.y > 20.0) break;\n\t\th = mapShad(p);\n\t\tres = min(4.*h / t, res);\n\t\tt += h;\n\t}\n    return max(res, .2);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 DoLighting(in vec4 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d, in float sh)\n{\n\tvec3 col = mat.xyz * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) * sh;\n    col += mat.xyz *(max(dot(-sunLight,normal), 0.0));\n    \n    normal = reflect(eyeDir, normal); // Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 10.0)  * SUN_COLOUR * mat.w *sh;\n    // Abmient..\n\tcol += .04 * max(normal.y, 0.1);\n    \n    \n\treturn col;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR, 0.0);\n\treturn normalize( vec3(\n           mapShad(p+eps.xyy) - mapShad(p-eps.xyy),\n           mapShad(p+eps.yxy) - mapShad(p-eps.yxy),\n           mapShad(p+eps.yyx) - mapShad(p-eps.yyx) ) );\n}\n\n//----------------------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD, in float t)\n{\n\t\n\tvec3 p;\n\tfor( int j=0; j < 100; j++ )\n\t{\n\t\tif (t > 150.0) break;\n\t\tp = rO + t*rD;\n\t\tvec2 de = map(p);\n\t\tif(de.x < .01)\n        {\n            break;\n        }\n\n\t\tt += de.x*.9;\n\t}\n\treturn t;\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n    sunLight  = normalize(vec3(  .8, .8,  0.8 ));\n    vec3 cameraPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 ).xyz;\n    vec4 camRot    = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 );\n    vec4 box\t   = texture( iChannel0, vec2(6.5,.5)/iResolution.xy, -100.0 );\n\tgTime    \t   = texture( iChannel0, vec2(7.5,.5)/iResolution.xy, -100.0 ).x+5.;\n    vec4 cam = camRot * TAU/ 360.0;\n    vec3 col = vec3(.3);\n    movement = smoothstep(8.0, 16.0, gTime) * smoothstep(60.0, 50.0, gTime);\n\n  \n\tvec3 dir = normalize( vec3(uv, sqrt(max(1. - dot(uv.xy, uv.xy)*.1, 0.))));\n    \n    float roll = .05 * sin(iTime*.3);\n    dir.xy = dir.xy*cos(roll) + sin(roll)*vec2(1,-1)*dir.yx;\n    dir.zy = dir.zy*cos(cam.x) + sin(cam.x)*vec2(1,-1)*dir.yz;\n    dir.xz = dir.xz*cos(cam.y) + sin(cam.y)*vec2(1,-1)*dir.zx;\n    \n    float lightning = 0.0;\n\tfloat f = mod(gTime, 15.);\n    if (f < .8)\n\t{\n\t\tf = smoothstep(.44, .0, f)* 1.5;\n\t\tlightning = mod(-gTime*(1.5-Hash(gTime*2.8)*.001), 1.0) * f;\n\t}\n\tvec3 flash = clamp(vec3(.4, .3, .8) * lightning, 0.0, 1.0)*.5;\n    dir.y += lightning*.1;\n    \n   \tfloat dis = Scene(cameraPos, dir, 01.* Hash(fragCoord));\n  \tvec3 sky = GetSky(dir);\n    //sky = ;\n\n    vec3 normal;\n    float sha;\n   \tif (dis  < 100.0)\n    {\n\t\tvec3 pos = cameraPos + dir * dis;\n\t\tsha = Shadow(pos, sunLight);\n        \n\t\tvec2 de = map(pos);\n\t\tfloat f = Noise(pos*vec3(30.0, 2.0, 30.0)+vec3(0.0, gTime*14.0, 0.0))+.4;\n\t\tnormal = GetNormal(pos, .01);\n\t\tvec4 alb =\tcolour(pos, normal, de.y);\n//         if (de.y >= 1.0)\n\t\t//{\n\t\t\t//alb -= clamp(sha-pow((de.y-1.0), .5)*5., .0, 1.0);\n//        }else\n//        {\n\t\t\talb *= f;\n//\t\t}\n\n\t\tvec3 mat = DoLighting(alb, pos, normal, dir, dis, sha);\n\t\tcol = mix(sky,mat, clamp(exp(-dis*dis*.0004),0.0, 1.0));\n\n\t}else\n\t{\n\t    col = sky;//+fogColour;\n\t}\n    \n    col += pow(max(dot(sunLight, dir), 0.0), 1.3)  * SUN_COLOUR * .05;\n    \n    //col = clamp(col, 0.0,  1.0);\n    \t// Rain & Lightning together... \n\tvec2 st =  uv * vec2(1.8, .04)+vec2(iTime*.01-uv.y*.2, iTime*.4+camRot.x*31.);\n\t// I'm adding two parts of the texture to stop repetition...\n\tf = max(texture(iChannel3, st*.1).y, texture(iChannel2, st*.05).x);\n\tf = clamp(pow(abs(f), 10.0) * 1.0, 0.0, xy.y);\n\tcol = mix(col, fogColour*.2, f);\n    col+= lightning*.12;\n \n\t   \n\tcol = col * smoothstep(.0, 2.0, iTime)+flash;\n    //---------------------------------\n\n    #ifdef SEE_NUMBERS\n    col+=PrintValue(fragCoord, vec2(20.0, 50.0),  cameraPos.x, 8.,1.);\n    col+=PrintValue(fragCoord, vec2(80.0, 50.0), cameraPos.y, 8.,1.);\n    col+=PrintValue(fragCoord, vec2(140.0, 50.0), cameraPos.z, 8.,1.);\n    #endif\n\n\tfragColour=vec4(col, 1.);\n}\n\n//--------------------------------------------------------------------------",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Rain on the 'camera'...\n\n#define TAU 6.28318530718\nvec2 camRot;\n//----------------------------------------------------------------------------------------\n// From https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE .1031\nfloat Hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+ 0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n//----------------------------------------------------------------------------------------\n\nfloat fbm(vec2 p)\n{\n    p *= vec2(24, 8.);\n    p.y+=iTime*.7;\n    vec3 q =vec3(p, iTime);\n     float f = 0.0;\n    float a = 1.;\n    for (int i = 0; i < 3; i++)\n    {\n        f += Noise(q) * a;\n        a *= .5;\n        q *= 2.;\n    }\n    return clamp(f-.6+smoothstep(-10., 60., camRot.x)*.85 ,0.0, .04);\n}\n    \n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tvec3 col;\n\tfloat m = (iMouse.x/iResolution.x)*20.0;\n\tfloat gTime = ((iTime)*.2+m);\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tcamRot = texture( iChannel3, vec2(1.5,.5)/iResolution.xy, -100.0 ).xy;\n    \n    vec2 cam = -camRot * TAU/ 360.0;\n    vec3 dir = vec3(0,0,1);\n    dir.zy = dir.zy*cos(cam.x) + sin(cam.x)*vec2(1,-1)*dir.yz;\n    dir.xz = dir.xz*cos(cam.y) + sin(cam.y)*vec2(1,-1)*dir.zx;\n \n\n\tvec3 nor  \t= vec3(0.0,\t\t    fbm(xy), 0.0);\n\tvec3 v2\t\t= nor-vec3(.002,\tfbm(xy+vec2(.002,0.0)), 0.0);\n\tvec3 v3\t\t= nor-vec3(0.0,\tfbm(xy+vec2(0.0,.002)), .002);\n\tnor = cross(v2, v3);\n\tnor = normalize(nor);\n\n    vec2 off = xy+vec2(sin(nor.x)*.03,nor.z*.03);\n    col = texture(iChannel0, off).xyz;\n    col += max(dot(nor, dir), 0.0)*.01;\n\n\tfragColour=vec4(col, 1.);\n}\n\n//--------------------------------------------------------------------------",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 lastColour  = texture(iChannel1, uv);\n    vec4 newColour = texture(iChannel0, uv);\n    float blur = (iTimeDelta/.07);\n    \n    newColour = newColour * blur + lastColour * (1.0-blur);\n        \n    fragColor = newColour;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}