{
    "Shader": {
        "info": {
            "date": "1660251181",
            "description": "Asked as a challenge in: https://thebookofshaders.com/07/",
            "flags": 0,
            "hasliked": 0,
            "id": "wsBczG",
            "likes": 2,
            "name": "Mondrianesque",
            "published": 3,
            "tags": [
                "2d",
                "beginner",
                "painting",
                "mondrian",
                "bookofshaders"
            ],
            "usePreview": 0,
            "username": "bikemule",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "// Width of box borders\n#define W .005\n// Background/border color\nconst vec3 bgColor = vec3(0.,0.,0.);\n\n/* \nLines all the way across at these points, horizontal and vertical\n\nIt would be nice to randomly generate these, but I'm not sure how to generate\nsomething that will be random, but consistent every frame.\n\nNoise channel could provide repeatability?\n*/\n\n// horizontal\nconst float xlines[4] = float[4](0.2,0.45,0.7,0.83);\n// vertical\nconst float ylines[6] = float[6](0.1, 0.33, 0.55, 0.6, 0.7, 0.92);\n\nvec3 inLines(in vec2 p) {\n    \n    // Draw horizontal lines\n    for(int i=0; i<xlines.length(); i++){\n        if(p.x < (xlines[i] + W) && p.x > (xlines[i] - W)){\n            return bgColor;\n        }\n    }\n    \n    // Draw vertical lines\n    for(int i=0; i< ylines.length(); i++) {\n        if(p.y < (ylines[i] + W) && p.y > (ylines[i] - W)) {\n            return bgColor;\n        }\n    }\n    \n    // Determine color inside boxes.\n    // TODO: Store the boxes w/ colors in some better data format\n    \n    // Easier to think of the ordering of the boxes as starting at the bottom \n    // First 4 boxes (0-3) of first col and first 2 of last col\n    if(p.x < xlines[0] && p.y < ylines[3] || p.y < ylines[1] && p.x > xlines[3]) {\n\t    return vec3(0.9, 0.2, 0.2);  // Red\n    } else if (p.x > xlines[2] && p.x < xlines[3] && p.y < ylines[4] && p.y > ylines[0]) {\n      \t// Second through fifth boxes of 4th col\n        return vec3(.2, 0.2, .9);  // Blue\n    } else if (p.x > xlines[2] && p.y > ylines[5]) {\n        // last box of last two cols\n        return vec3(.95,.99,0.);  // Yellow\n    } else\n        return vec3(1.);  // Default to white\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // Output to screen, inLines() returns color\n    fragColor = vec4(inLines(uv),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}