{
    "Shader": {
        "info": {
            "date": "1724266484",
            "description": "i know it is quite cut off but its more performant this way",
            "flags": 0,
            "hasliked": 0,
            "id": "4cffzf",
            "likes": 9,
            "name": "daily shader clock 10",
            "published": 3,
            "tags": [
                "daily",
                "shaderclockdenodev"
            ],
            "usePreview": 0,
            "username": "jonasfrey",
            "viewed": 112
        },
        "renderpass": [
            {
                "code": "#define n_tau radians(360.0)\n\nvec2 f_o_rotd(\n    vec2 o, \n    float n_ang_nor\n){\n    float nrad = n_ang_nor*n_tau; \n    float nsin = sin(nrad);\n    float ncos = cos(nrad);\n    return o*mat2(ncos, -nsin, nsin, ncos);\n   \n}\n\nfloat f_n_segment(vec2 o_trn_nor_pix) {\n    vec2 o_scl_screen = iResolution.xy;\n    o_trn_nor_pix = abs(o_trn_nor_pix);\n    float n1 = o_trn_nor_pix.x;\n    float nrad = -(1./8.)*n_tau; \n    float nsin = sin(nrad);\n    float ncos = cos(nrad);\n    float nh = 0.25;\n    vec2 o2 = f_o_rotd(o_trn_nor_pix+vec2(0., -nh),-(1./8.));\n    float n2 = o2.x; \n    return max(n1,n2);\n}\n\nfloat f_n_sevensegmentdisplay(\n    vec2 o_trn_nor, \n    float n_num\n){\n    o_trn_nor *= 3.;\n     float[] a = float[] (\n         f_n_segment(f_o_rotd(o_trn_nor, 0.25)),\n         f_n_segment(f_o_rotd(o_trn_nor+vec2(-.5,0.5), 0.0)), \n         f_n_segment(f_o_rotd(o_trn_nor+vec2(.0, 1.), 0.25)),\n         f_n_segment(f_o_rotd(o_trn_nor+vec2(.5,0.5), 0.0)),\n         f_n_segment(f_o_rotd(o_trn_nor+vec2(.5,-0.5), 0.0)),\n         f_n_segment(f_o_rotd(o_trn_nor+vec2(.0, -1.), 0.25)),\n         f_n_segment(f_o_rotd(o_trn_nor+vec2(-.5, -.5), 0.0))\n     );\n     float[] a_n = float[] (\n         //0\n         min(min(min(min(min(a[1],a[2]),a[3]),a[4]),a[5]),a[6]),\n         //1 \n         min(a[6], a[1]),\n         //2 \n         min(min(min(min(a[5],a[6]),a[0]),a[3]),a[2]),\n         //3\n         min(min(min(min(a[0],a[1]),a[2]),a[5]),a[6]),\n         //4\n         min(min(min(a[0],a[1]),a[4]),a[6]),\n         //5\n         min(min(min(min(a[0],a[1]),a[2]),a[4]),a[5]),\n         //6\n         min(min(min(min(min(a[0],a[1]),a[2]),a[3]),a[4]),a[5]),\n         //7 \n         min(min(a[1],a[5]),a[6]),\n         //8\n         min(min(min(min(min(min(a[0],a[1]),a[2]),a[3]),a[4]),a[5]),a[6]),\n         //9\n         min(min(min(min(min(a[0],a[1]),a[2]),a[4]),a[5]),a[6]), \n         //A\n         min(min(min(min(min(a[0],a[1]),a[3]),a[4]),a[5]),a[6])\n         \n     );\n     \n    return a_n[int(n_num)];\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    float n_sec = iDate.w;\n    float n_sec_mod = mod(n_sec , 60.);\n    float n_sec_mod_nor = n_sec_mod / 60.;\n    float n_sec_mod_nor_snp = floor(n_sec_mod) / 60.;\n    float n_min_mod = floor(mod(n_sec, 60.*60.));\n    float n_min_mod_nor = n_min_mod / (60.*60.);\n    float n_min_mod_nor_snp = (floor(n_min_mod_nor*24.))/24.;\n    float n_hou_mod = floor(mod(n_sec, 60.*60.*24.));\n    float n_hou_mod_nor = n_hou_mod / (60.*60.*24.);\n    float n_hou_mod_nor_snp = (floor(n_hou_mod_nor*24.))/24.;\n    float n_numbers = 4.;\n    \n    float n_x_to_y = (iResolution.x/n_numbers) / iResolution.y;\n    float n_min_scl = min(iResolution.x, iResolution.y);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    float n_zoom = 3.;\n    uv -= 0.5;\n    uv *= n_zoom;\n    uv += 0.5;\n    vec2 o_trn = (fragCoord.xy - iResolution.xy*.5) / n_min_scl;\n    o_trn*= n_zoom;\n    uv = clamp(uv, 0., 1.);\n    uv.x -= uv.y*0.03;\n    uv.x *= n_numbers;\n    float n_idx = floor(uv.x);\n    vec2 o = fract(uv)-.5;\n    //o = abs(o);\n    float num = (n_idx < 2.) ? floor(n_hou_mod_nor*24.) : floor(n_min_mod_nor*60.);//iTime;//2182.;\n    float nn = mod(floor(num/pow(10.,(1.-mod(n_idx,2.)))),10.);\n    o *= vec2(n_x_to_y, 1.);\n    o *= 1.8;\n    float n = f_n_sevensegmentdisplay(o, nn);\n    //float nglow = 1.-pow(abs(n-.1), 1./3.);\n    float naa = 1./iResolution.x;\n    float nw = 0.15;\n    float nss = smoothstep(nw, nw-naa*60., n);\n    float nb = 0.14;\n    float nglow = 1.-(-nb * (1./(nb+abs(n-nw)))+1.);\n    float nrdot = 0.035;\n    float n_dot = smoothstep(\n        nrdot,\n        nrdot-naa*20.,\n        length(vec2(o_trn.x-0.03, abs(o_trn.y)-0.1))\n    );\n    n_dot *= float(fract(n_sec) > .5);\n    vec3 o_red = vec3(\n            0.8, \n            0.12, \n            0.12\n    );\n    float n_ang_nor = fract(atan(o_trn.x, o_trn.y)/n_tau);\n    float n_ang_nor_snapped = (floor(n_ang_nor*60.)/60.)+(1./60./2.);\n    vec2 o_trn2 = vec2(\n        sin(n_ang_nor_snapped*n_tau),\n        cos(n_ang_nor_snapped*n_tau)\n    )*6.;\n\n    float n_seg1 = f_n_segment(\n        f_o_rotd(\n            (o_trn*5.)-o_trn2,\n            n_ang_nor_snapped\n        )\n    );\n    float n_seg = 1.-(-nb * (1./(nb+abs(n_seg1-nw)))+1.);\n    float n_seg2 = smoothstep(nw, nw-naa*60., n_seg1);\n    n_seg += n_seg2;\n    n_seg *= float(n_sec_mod_nor > n_ang_nor_snapped);\n    n_seg2 *= float(n_sec_mod_nor > n_ang_nor_snapped);\n\n    fragColor = vec4(\n        nss*o_red*8.+(nglow)*o_red\n        +n_dot \n        +n_seg*o_red+n_seg2,\n        1.\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}