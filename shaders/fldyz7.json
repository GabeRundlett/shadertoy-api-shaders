{
    "Shader": {
        "info": {
            "date": "1659477861",
            "description": "Adapted from Inigo Quilez (https://iquilezles.org/).",
            "flags": 0,
            "hasliked": 0,
            "id": "fldyz7",
            "likes": 3,
            "name": "Pink Blob",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "nsbalbi",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "// Heavily adapted from Inigo Quilez (https://iquilezles.org/)\n\nconst float D_MAX = 5.0;  // max marching distance\n\n#define PI 3.1416\n\n// SDFs\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n// Scene SDF\nfloat sceneSDF(vec3 p) {    \n  // return sdSphere(samplePoint, 0.5);\n  float d1 = sdSphere(p, 0.5);\n\n  float df = 8.0;  // frequency\n  float da = 0.1;  // amplitude\n  float d2 = da * sin(df * (p.x + 0.25*PI*iTime))*sin(df * p.y)*sin(df * p.z);\n\n  return d1 + d2;\n}\n\n// Calculates surface normal\nvec3 calcNormal( in vec3 pos ) {\n  vec2 e = vec2(1.0,-1.0)*0.5773;\n  const float eps = 0.0005;  // small increment epsilon\n  return normalize( e.xyy*sceneSDF( pos + e.xyy*eps ) + \n          e.yyx*sceneSDF( pos + e.yyx*eps ) + \n          e.yxy*sceneSDF( pos + e.yxy*eps ) + \n          e.xxx*sceneSDF( pos + e.xxx*eps ) );\n}\n\n#define AA 2  // number of anti-aliasing passes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // camera movement\t\n\t// float angle = 0.25 * PI * u_time + 0.75 * PI;\n\t// vec3 eye = vec3( 1.2*cos(angle), 0.4, 1.2*sin(angle) );\n  // vec3 center = vec3( 0.0, 0.0, 0.0 );\n\tvec3 eye = vec3( 1., 0.4, -1.);\n  vec3 center = vec3( 0., 0., 0.);\n  // camera matrix\n  vec3 ww = normalize( center - eye );  // vect from center to eye\n  vec3 uu = normalize( cross(ww, vec3(0.0,1.0,0.0)) );  // cross with up\n  vec3 vv = normalize( cross(uu, ww) );\n\n  vec3 tot = vec3(0.0);\n  \n  #if AA>1  // anti-aliasing passes\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ ) {\n    // pixel coordinates\n    vec2 offset = vec2(float(m),float(n)) / float(AA) - 0.5;  // offset for anti-aliasing passes\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+offset))/iResolution.y;\n    #else    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    #endif\n\n    // create view ray\n    vec3 ray = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    float dTot = 0.0;\n    for( int i=0; i<256; i++ ) {\n      vec3 pos = eye + dTot*ray;\n      float d = sceneSDF(pos);\n      if( d < 0.0001 || dTot > D_MAX ) break;\n      dTot += d;\n    }\n    \n    // shading/lighting\t\n    vec3 color = vec3(0.0);\n    if( dTot < D_MAX ) {\n      vec3 pos = eye + dTot * ray;  // position of point on surface\n      vec3 normal = calcNormal(pos);  // surface normal\n      float diffuse = clamp( dot(normal, vec3(0.6)), 0.0, 1.0 );\n      float ambient = 0.5 + 0.5 * dot(normal, vec3(0.0,1.0,0.0));\n      color = vec3(0.5882, 0.302, 0.302) * ambient + vec3(0.098, 0.1843, 0.5882) * diffuse;\n    }\n\n    // gamma        \n    color = sqrt( color );\n    tot += color;\n    #if AA>1\n  }\n  tot /= float(AA*AA);  // take mean if multiple anti-aliasing passes\n  #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}