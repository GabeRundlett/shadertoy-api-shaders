{
    "Shader": {
        "info": {
            "date": "1665192077",
            "description": "A new look for Dynamic Editable Terrain. Sky still from xor's Nimbostratus: https://www.shadertoy.com/view/Xl\n*mouse to lower terrain*\n*(0-9) + mouse to raise terrain to that height*\n*WASD/QE/RF to fly*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "7tKBDm",
            "likes": 18,
            "name": "Dynamic Editable Terrain 2",
            "published": 3,
            "tags": [
                "terrain",
                "automata",
                "cellular",
                "tiltshift",
                "ising",
                "annealing",
                "atomaton"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 318
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// A new look for Dynamic Editable Terrain https://www.shadertoy.com/view/NlyBWm\n//\n// I was trying to move away from the 8-bit/minecraft look of the first Dynamic Editable\n// terrain. My hope was to approach photoreal, and I'm not sure how close I got but I\n// think the result is pretty interesting anyway.\n//\n// I'm pretty new at trying to achieve realistic images, so I struggled quite a lot with\n// the noise and I'm just barely satisfied with the results. All suggestions are welcome!\n//\n// Changes since Dynamic Editable Terrain 1.0:\n// \n//  * Automaton fiddled to avoid flat-topped areas\n//  * Sand no longer appears on steep cliffsides\n//  * Snow layer for the tallest mountains\n//  * Tree line above which vegetation becomes sparse\n//  * Minecraft-eque pixel splotches removed. replaced with noise\n//  * Rendering sea floor\n//  * Noise added to color and SDF to try to create more natural-looking surfaces\n//  * Noise-based water reflection animation\n//  * Keyboard camera control\n//  * Camera collision\n//  * Motion blur\n//  * Trees!\n//\n// Buffer A computes the terrain\n// Buffer B renders with ray march\n// Buffer C renders xor's Nimbostratus for the sky: https://www.shadertoy.com/view/Xl\n// Image applies tilt-shift lens effect and motion blur\n//\n// --------------------------------------------------------------------------------------------\n\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n// Added: tilt-shift lens, motion blur\n\nint           N =  13;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U, vec2 o) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P+o*float(k - N*N/2)/float(N*N)) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float depth = texelFetch(iChannel0, ivec2(u), 0).w;\n    \n    vec4 camera = texelFetch(iChannel1, ivec2(0, 1), 0);\n    vec4 prevCamera = texelFetch(iChannel1, ivec2(0, 2), 0);\n    \n    mat2 r = rot2(camera.w);\n    vec3 localCamera;\n    localCamera.xz = r * camera.xz;\n    localCamera.y = abs(camera.y);\n    vec3 localPrevCamera;\n    localPrevCamera.xz = r * prevCamera.xz;\n    localPrevCamera.y = abs(prevCamera.y);\n\n    vec2 motionBlur = 3.*(localCamera.xy - localPrevCamera.xy) / depth\n        - 4.*(localCamera.z - localPrevCamera.z) * (u - iResolution.xy * vec2(0.5, 0.9)) / (depth * iResolution.y)\n        + 5. * (camera.w - prevCamera.w) * depth * vec2(0.1, 0.0);\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a tilt-shift lens effect.\n    float centerDepth = texelFetch(iChannel0, ivec2(iResolution.xy*vec2(0.5, 0.4) / pow(2., 6.)), 6).w;\n    w = (abs(depth-centerDepth)) * 0.04 - 0.000;// + 1.5/iResolution.y;\n    \n    if (w > 0.0)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / R.y;  \n            O = convol2D(U, motionBlur);\n        }\n    }\n    else\n    {\n        O = texture(iChannel0, u/iResolution.xy);\n        //O = vec4(1,0,0,1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --------------------------------------------------------------------------------------------\n// Computes the terrain height by attempting to match nearby pixels when near the camera.\n// This buffer is set up for wrapping, and hopefully there are no visible artifacts when\n// the camera wraps around.\n//\n// The celllar automaton happens in the r channel, but the g b and a channels are used\n// to compute a blurred gradient of the r channel, which ends up in a. This is used for\n// tree placement.\n// --------------------------------------------------------------------------------------------\n\nconst int MAX_DIRECTIONS = 64;\n\nfloat melt(vec3 h)\n{\n    return floor((h.x + 0.7*pow(h.y, 0.2))*(float(MAX_DIRECTIONS))* 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    vec3 h = hash(uvec3(ifc.y, ifc.x, iFrame + int(iDate.w)));\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n    vec4 state = texelFetch(iChannel2, ivec2(0), 0);\n\n    float directions = float(MAX_DIRECTIONS);\n    \n    if (iFrame == 0 || state.z < 0.)\n    {\n        fragColor.x = melt(h);\n        fragColor.yzw = vec3(0);\n    }\n    else\n    {\n        float time = float(iTime);\n        vec2 mouse = iMouse.xy;\n\n        // Apply heat everywhere but a circle around the camera position\n        vec4 camera = texelFetch(iChannel2, ivec2(0, 1), 0);\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(camera, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n        \n        vec2 p = mod(cameraPos.xz * iResolution.y * 0.1, iResolution.xy);\n\n        float TEMP_SCALE = 3.0 / iResolution.y;\n        float t = distance(p, fragCoord)*TEMP_SCALE;\n        \n        // Copy the circle multiple times to handle wraparound conditions\n        t = min(t, distance(p + iResolution.xy*vec2(1, 0), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(0, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, 0), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(0, -1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(1, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, -1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(1, -1), fragCoord)*TEMP_SCALE);\n        \n        // Handle mouse input\n        if (iMouse.z > 0. && iMouse.w < 0. && state.xy != vec2(0))\n        {\n            vec3 fromLookAt, fromPos, fromFwd, fromLeft, fromUp;\n            fxCalcCamera(camera, fromLookAt, fromPos, fromFwd, fromLeft, fromUp);\n\n        \tvec3 rayFrom = fxCalcRay(state.xy, iResolution, fromFwd, fromUp, fromLeft);\n        \tvec3 rayTo = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n            float fromT = (cameraPos.y - WATER_HEIGHT) / rayFrom.y;\n            vec3 fromHit = cameraPos - fromT * rayFrom;\n            vec2 projFrom = mod(fromHit.xz * iResolution.y * 0.1, iResolution.xy);\n            float toT = (cameraPos.y - WATER_HEIGHT) / rayTo.y;\n            vec3 toHit = cameraPos - toT * rayTo;\n            vec2 projTo = mod(toHit.xz * iResolution.y * 0.1, iResolution.xy);\n            \n            if (distance(projFrom, projTo) < iResolution.y * 0.3)\n            {\n                float dist = linePointDist2(projFrom, projTo, fragCoord);\n\n                float targetHeight = 0.;\n                for (int i = 1; i <= 9; ++i)\n                {\n                    if (keyDown(KEY_0 + i))\n                    {\n                        targetHeight = float(i)*2. + 30.;\n                    }\n                }\n\n                if (dist < iResolution.y*0.25)\n                {\n                    if (fragColor.r > targetHeight)\n                    {\n                        fragColor.r -= 0.01 * iResolution.y / (dist + 3.0);\n                    }\n                    else if (fragColor.r < targetHeight)\n                    {\n                        fragColor.r +=  0.01 * iResolution.y / (dist + 3.0);\n                    }\n                }\n            }\n        }\n        fragColor.r = clamp(fragColor.r, 0., float(MAX_DIRECTIONS));\n    \n        float annealChance = mix(0.08, 0.5, smoothstep(1200., 3000., iResolution.y));\n        if (state.w < 5.) annealChance *= 10.;\n        if (t > 1.1 + 0.9 * h.z)\n        {\n            // Melting temp\n            fragColor.x = melt(h);            \n        }\n        else if (h.y < annealChance)\n        {\n            // Count how many neighbors in range have each possible direction\n            int counts[MAX_DIRECTIONS];\n            for (int i = 0; i < int(directions); ++i)\n            {\n                counts[i] = 0;\n            }\n\n            const int RANGE = 2;\n            for (int x = -RANGE; x <= RANGE; ++x)\n            {\n                for (int y = -RANGE; y <= RANGE; ++y)\n                {\n                    ivec2 ni = ifc + ivec2(x, y);\n                    if (ni == ivec2(0)) continue; // Ignore state pixel\n                    vec4 n = texture(iChannel0, (vec2(ni) + 0.5) / iResolution.xy);\n                    counts[int(n.x)]++;\n                }\n            }\n\n            // Find the direction most popular among neighbors\n            int bestCount = -1;\n            int bestDir;\n            bool unique;\n\n            for (int d = 0; d < int(directions); ++d)\n            {\n                if (counts[d] > bestCount)\n                {\n                    bestCount = counts[d];\n                    bestDir = d;\n                    unique = true;\n                }\n                else if (counts[d] == bestCount)\n                {\n                    unique = false;\n                }\n            }\n\n            if (unique)\n            {\n                fragColor.x = float(bestDir) + 2.0*sign(fragColor.x - float(bestDir));\n            }\n        }\n        \n        // g computes a gradient of r\n        ivec2 delta = ivec2(1, 0);\n        fragColor.g = abs(texelFetch(iChannel0, ifc + delta.xy, 0).r - texelFetch(iChannel0, ifc - delta.xy, 0).r) +\n            abs(texelFetch(iChannel0, ifc + delta.yx, 0).r - texelFetch(iChannel0, ifc - delta.yx, 0).r);\n        \n        vec2 blurs = vec2(0);\n        const int BLUR_SIZE = 3;\n        for (int x = -BLUR_SIZE; x <= BLUR_SIZE; ++x)\n        {\n            for (int y = -BLUR_SIZE; y <= BLUR_SIZE; ++y)\n            {\n                blurs += texelFetch(iChannel0, ifc + ivec2(x, y), 0).gb / (1. + length(vec2(x, y)));\n            }\n        }\n        \n        // b and a contain blurs of g\n        fragColor.ba = 2.*blurs / float((BLUR_SIZE + BLUR_SIZE + 1) * (BLUR_SIZE + BLUR_SIZE + 1));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float LAYER_HEIGHT = 0.002;\n\nconst float WATER_HEIGHT = 63.*LAYER_HEIGHT;\nconst float BEACH_HEIGHT = 66.*LAYER_HEIGHT;\nconst float TREELINE_HEIGHT = 70.*LAYER_HEIGHT;\nconst float SNOW_HEIGHT = 80.*LAYER_HEIGHT;\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat2 rot2(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nconst float PI = 3.141592653589793;\n\nvoid fxCalcCamera(in vec4 camState, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraPos = camState.xyz;\n    cameraPos.y = abs(cameraPos.y);\n    cameraLookAt = cameraPos + vec3(sin(camState.w), -0.1  - 1.0 * cameraPos.y, cos(camState.w));\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_0 48\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_R 82\n#define KEY_F 70\n#define KEY_Q 81\n#define KEY_E 69",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// --------------------------------------------------------------------------------------------\n// Render the scene via ray marching, with shadows and water reflections.\n// --------------------------------------------------------------------------------------------\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// Create infinite copies of an object -  https://iquilezles.org/articles/distfunctions\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nconst float TREE_REP = 0.004;\n\nvoid doTree(in vec3 p, float splotchesGrass, float t, inout float d, inout int mat)\n{\n    vec2 closest = opRep(p.xz, TREE_REP);\n    vec3 hsh = hash(uvec3(abs(trunc((p.xzz - 0.0015) / 0.003))));\n\n    float treeH = (textureLod(iChannel0, (p.xz - closest)*0.1, 0.).x + textureLod(iChannel0, (p.xz - closest)*0.1, 1.).x) * LAYER_HEIGHT;\n    if (treeH > BEACH_HEIGHT && treeH < TREELINE_HEIGHT)\n    {\n        vec3 tree = vec3(closest.x, p.y, closest.y);\n        float TREE_RAND = 0.015;\n        vec3 tree2 = tree * vec3(4. + 0.*hsh.z, 1., 2.) - vec3((hsh.y - 0.5)* TREE_RAND, treeH + 0.002, (hsh.z - 0.5) * TREE_RAND);\n        float treeSize = 0.002 * (1. - smoothstep(0.8, 0.9, t));\n        float dSphere = sdSphere(tree2, treeSize);\n        if (dSphere < d)\n        {\n            d = dSphere;\n            mat = 1;\n        }\n    }\n}\n\nfloat scene(vec3 p, float t, out int mat)\n{\n    mat = 0;\n    p.x *= iResolution.y/iResolution.x;\n    \n    vec2 hz = textureLod(iChannel0, p.xz*0.1, 1.).xw * 2.; // use mip to smooth terrain\n    float height = p.y - max(0.,hz.x)*LAYER_HEIGHT;\n    float d = min(height, p.y + .05);\n    if (d < .04)\n    {\n        hz = hz * .5 + textureLod(iChannel0, p.xz*0.1, 0.).xw; // only do high-rez fetch if we're close\n        height = p.y - max(0.,hz.x)*LAYER_HEIGHT;\n        d = min(height, p.y + .05);\n        \n        float lodLow = 1. - smoothstep(0.5, 1.4, t);\n        if (lodLow > 0. && d < 0.005)\n        {\n            float smoothToBeach = 1.6 + smoothstep(BEACH_HEIGHT, 1.15 * BEACH_HEIGHT, p.y) - smoothstep(0.97*WATER_HEIGHT, WATER_HEIGHT, p.y);\n            float rockBump = textureLod(iChannel2, p.xz, 0.).r - 0.5;\n\n            height -= rockBump * rockBump * 0.01 * lodLow * smoothToBeach;\n\n            // rock high lod\n            if (!((p.y < BEACH_HEIGHT && p.y > WATER_HEIGHT) || p.y >= SNOW_HEIGHT))\n            {\n                height -= (textureLod(iChannel2, p.xz*40., 3.).r - 0.5)*0.01 * max(0., lodLow - 0.3) * smoothToBeach;\n            }\n\n            float lodHigh = 1. - smoothstep(0.4, 0.8, t);\n            if (lodHigh > 0.)\n            {\n                // snow/sand roughness\n                height -= (textureLod(iChannel2, p.xz*20.0, 0.).r - 0.5) * 0.0007 * lodHigh;\n            }\n\n            d = min(height, p.y + .05);\n\n            if (hz.y < 7.8)\n            {\n                float splotchesGrass = 0. + 0.8 * texture(iChannel2, p.xz*1.0).r * lodLow;//(hGrass.x * 0.5 + 0.5); // Use x,z splotch pattern for grass, to fix rendering artifact\n                doTree(p, splotchesGrass, t, d, mat);\n            }\n        }\n    }\n    \n    return d;\n}\n\nvec3 grad(vec3 p, float t, float d)\n{\n    vec2 delta = vec2(d, 0);\n    int mat;\n    return normalize(\n           vec3(scene(p + delta.xyy, t, mat) - scene(p - delta.xyy, t, mat),\n                scene(p + delta.yxy, t, mat) - scene(p - delta.yxy, t, mat),\n                scene(p + delta.yyx, t, mat) - scene(p - delta.yyx, t, mat)));\n}\n\nconst float MAX_T = 6.0;\nconst float SDF_EPSILON = 0.0005;\nvec3 rayMarch(vec3 pos, vec3 dir, out float t, out int mat)\n{\n    t = 0.;\n    mat = 0;\n    for (int i = 0; i < 250; ++i)\n    {\n        float d = scene(pos, t, mat);\n        \n        if (d < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        float slowdown = max(d * 1., 0.1);\n        t += d * slowdown;\n\n        pos += dir * d * slowdown;\n    }\n \n    return pos;\n}\n\nconst vec3 lightDir = normalize(vec3(0, 0.4, 1));\n\nvec3 getColor(vec3 hitPos, vec3 normal, float t, int mat)\n{\n    if (mat == 1) return vec3(0.15, 0.3, 0);\n    vec3 color;\n    if (hitPos.y < WATER_HEIGHT - 0.000)\n    {\n        color = vec3(0.3, 0.5, 0.1);\n    }\n    else\n    {\n        float lodSplotches = 1. - smoothstep(0.25, 0.5, t);\n        float splotches = mix(1., 0.3 + 0.5 * texture(iChannel2, hitPos.xz*20.).r + 0.5 * texture(iChannel2, hitPos.xz*40.).r, lodSplotches);//(h.x * 0.5 + 0.5);\n        float spec = pow(max(0., dot(normal, lightDir)), 10.);\n        color = vec3(0.9, 0.9, 0.8) * splotches + spec * .5;\n        float upness = dot(normal, vec3(0, 1, 0));\n        if (upness > 0.5)\n        {\n            float splotchesGrass = 0.1 + 0.9 * texture(iChannel2, hitPos.xz*8.0).r;//(hGrass.x * 0.5 + 0.5); // Use x,z splotch pattern for grass, to fix rendering artifact\n            float splotchesGrass2 = 0.3 + 0.7 * texture(iChannel2, hitPos.xz*2.0).r;//(hGrass.x * 0.5 + 0.5); // Use x,z splotch pattern for grass, to fix rendering artifact\n            vec3 grassColor = mix(vec3(0.0, 0.2, 0.), vec3(0.6, 0.5, 0.), square(splotchesGrass2));\n            if (hitPos.y < TREELINE_HEIGHT + (splotchesGrass - 0.5)*0.03) color = mix(color, grassColor * splotches * (splotches + .1), smoothstep(0.5, 0.8, upness));\n            float lodSnow = 1. - smoothstep(0.1, .8, t);\n            if (hitPos.y > SNOW_HEIGHT + lodSnow * (splotchesGrass - 0.5)* 0.01) color = vec3(2) + spec;\n        }\n        if (hitPos.y <= BEACH_HEIGHT - 0.001*splotches) color = mix(color, vec3(1.1, 1.0, 0.7) * splotches, smoothstep(0.8, 0.95, upness));\n    }\n    return color;\n}\n\nvec4 render(vec3 cameraPos, vec3 rayDir, bool doShadow, out vec3 hitPos, out vec3 normal)\n{\n    float t; int mat;\n    hitPos = rayMarch(cameraPos, rayDir, t, mat);\n\n    normal = grad(hitPos, t, 0.001);\n    vec3 offsetPos = hitPos + normal*SDF_EPSILON;\n\n    // Compute color\n    vec3 color = getColor(hitPos, normal, t, mat);\n    \n    // Apply light and shadow\n    const float AMBIENT = 0.2;\n\n    float shadowT = MAX_T;\n    vec3 reflectedColor = vec3(0);\n    \n    if (doShadow)\n    {\n        rayMarch(offsetPos, lightDir, shadowT, mat);\n    }    \n    \n    if (shadowT < MAX_T)\n    {\n        color = color * AMBIENT;\n    }\n    else\n    {\n        float dp = max(0., dot(normal, lightDir));\n        color = color * (dp*0.5 + AMBIENT);\n    }\n    \n    // Fade at distance\n    if (t >= 0.0)\n    {\n        vec3 sky = texture(iChannel1, rayDir.xy * 0.6 + 0.5).xyz;\n        color = mix(color, sky, smoothstep(0.0, MAX_T*.7, t));\n    }\n    \n    return vec4(color + reflectedColor, t);\n}\n\nvoid aaImage( out vec4 fragColor, vec2 fragCoord )\n{   \n    vec4 oldColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    float time = float(iTime);\n    vec2 mouse = iMouse.xy;\n\n    vec4 camera = texelFetch(iChannel1, ivec2(0, 1), 0);\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(camera, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    \n    vec3 hitPos, normal;\n    vec4 colorT = render(cameraPos, rayDir, true, hitPos, normal);\n\n    // Handle reflections\n    if (hitPos.y <= WATER_HEIGHT)\n    {\n        float waterDepth = WATER_HEIGHT - hitPos.y;\n        float correctT = waterDepth / rayDir.y;\n        hitPos += correctT * rayDir;\n        const float WATER_BUMP_RATE = 0.7;\n        float waterBumpR, waterBumpT = modf(iTime * WATER_BUMP_RATE, waterBumpR);\n        vec3 waterBump = mix(texture(iChannel2, hitPos.xz*0.5 + waterBumpR*0.1).rgb,\n                                   texture(iChannel2, hitPos.xz*0.5 + (waterBumpR + 1.) * 0.1).rgb, waterBumpT);\n\n        vec3 reflectRayDir = normalize(rayDir * vec3(1,-1,1) + waterBump * 0.5);\n        \n        vec3 reflectHitPos, reflectNormal;\n        vec4 reflectColorT = render(hitPos, reflectRayDir, false, reflectHitPos, reflectNormal);\n        \n        colorT.xyz = colorT.xyz / max(vec3(1), waterDepth*vec3(800., 800., 300.));\n        \n        float shadowT; int mat;\n        rayMarch(hitPos, lightDir, shadowT, mat);\n        if (shadowT >= MAX_T)\n        {\n            float dp = max(0., dot(reflectRayDir, lightDir));\n            reflectColorT.rgb += pow(dp, 12.) * 0.;\n        }\n        \n        colorT.rgb = mix(colorT.rgb, reflectColorT.rgb * 1.6, 0.2);\n    }\n    \n    fragColor = mix(oldColor, colorT, 0.9);\n    \n#if 0 // Debug terrain texture\n    //fragColor = sin(texelFetch(iChannel0, ivec2(fragCoord), 0).r + vec4(2, 3, 4, 5));\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0).aaaa * .3;\n    fragColor.w = 0.;\n#endif\n}\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{   \n#if AA < 2\n    aaImage(fragColor, fragCoord);\n#else\n    vec4 accum = vec4(0);\n    for (int x = 0; x < AA; ++x)\n    {\n        for (int y = 0; y < AA; ++y)\n        {\n            vec2 aaCoord = fragCoord + vec2(float(x),float(y)) / float(AA) - 0.5;\n            vec4 aaColor;\n            aaImage(aaColor, aaCoord);\n            accum += aaColor;\n        }\n    }\n    fragColor = accum * 1. / float(AA * AA);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --------------------------------------------------------------------------------------------\n// Render sky and maintain persistent state.\n// --------------------------------------------------------------------------------------------\n\nvoid updateState(inout vec4 state)\n{\n    if (iFrame == 0)\n    {\n        state = vec4(0, 0, 0, 1);\n    }\n    else\n    {\n        state.xy = iMouse.xy;\n        \n        if (keyClick(KEY_SPACE) || abs(state.z) != iResolution.x * iResolution.y)\n        {\n            state.z = -iResolution.x * iResolution.y;\n            \n            state.w = 1.;\n        }\n        else\n        {\n            state.z = abs(state.z);\n        }\n        \n        if (state.w == 0.) state.w = 1.;\n        state.w += sign(state.w);\n    }\n}\n\nvoid updateCamera(inout vec4 camera, in vec4 state)\n{\n    if (iFrame == 0 || state.z < 0.)\n    {\n        camera = vec4(0, -0.2, 0, 0);\n    }\n    else\n    {\n        const float MOVE_SPEED = 0.002;\n        vec3 camMove = vec3(0);\n        if (keyDown(KEY_W))\n        {\n            camMove.z += MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_S))\n        {\n            camMove.z -= MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_A))\n        {\n            camMove.x += MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_D))\n        {\n            camMove.x -= MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_R))\n        {\n            camMove.y += MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_F))\n        {\n            camMove.y -= MOVE_SPEED;\n            camera.y = abs(camera.y);\n        }\n        \n        if (camera.y < 0.)\n        {\n            camMove.z += MOVE_SPEED;\n            camMove.y -= 0.001*sin(state.w*0.008) - 0.00001;\n            camera.w -= 0.002*sin(state.w*0.005);\n        }\n        \n        const float TURN_RATE = 0.02;\n        if (keyDown(KEY_Q))\n        {\n            camera.w += TURN_RATE;\n            camera.y = abs(camera.y);\n        }\n        if (keyDown(KEY_E))\n        {\n            camera.w -= TURN_RATE;\n            camera.y = abs(camera.y);\n        }\n        \n        camMove.xz *= rot2(camera.w);\n        camera.xyz += camMove;\n        \n        vec2 pos1 = (camera.xz + 2.*vec2(sin(camera.w), cos(camera.w))) * iResolution.xz * 0.1;\n        float height1 = textureLod(iChannel2, pos1, 15.).r * LAYER_HEIGHT;\n        vec2 pos2 = camera.xz * iResolution.xz * 0.1;\n        float height2 = textureLod(iChannel2, pos2, 15.).r * LAYER_HEIGHT;\n        float height = max(height1, height2);\n        \n        if (abs(camera.y) < height + 0.1)\n        {\n            camera.y = mix((height + 0.1) * sign(camera.y), camera.y, 0.95);\n        }\n        if (abs(camera.y) < height + 0.01)\n        {\n            camera.y = mix((height + 0.01) * sign(camera.y), camera.y, 0.5);\n        }\n        if (abs(camera.y) < height)\n        {\n            camera.y = height * sign(camera.y);\n        }\n        float MAX_HEIGHT = 0.6;\n        camera.y = clamp(camera.y, -MAX_HEIGHT, MAX_HEIGHT);\n    }\n}\n\n// xor's Nimbostratus: https://www.shadertoy.com/view/XlfyD7\nfloat Speed = .001;\nvec3 Light = vec3(.6,.2,.8);\n    \nfloat Map(vec3 Position)\n{\n    vec3 P = (Position*0.5+texture(iChannel0,Position*2.+iTime*Speed*.2).xyz*.02);\n    \n    float C = texture(iChannel0,P).r;\n    C *= texture(iChannel0,P*vec3(.5,1,.5)).g;\n    C = C*.9+.1*pow(texture(iChannel0,P*5.1).a,2.);\n    return max((C-.3)*sqrt((Position.z-.1)/.3),0.)/.5;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc == ivec2(0))\n    {\n        fragColor = texelFetch(iChannel1, ifc, 0);\n        updateState(fragColor);\n        return;\n    }\n\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    if (ifc == ivec2(0, 1))\n    {\n        fragColor = texelFetch(iChannel1, ifc, 0);\n        updateCamera(fragColor, state);\n        return;\n    }\n    if (ifc == ivec2(0, 2))\n    {\n        vec4 prevCamera = texelFetch(iChannel1, ivec2(0, 1), 0);\n        fragColor = prevCamera;\n        return;\n    }\n    \n    vec3 R = vec3((fragCoord-.5*iResolution.xy)/iResolution.y,1);\n    vec3 P = vec3(0,iTime*Speed,0);\n    \n    vec4 C = vec4(0);\n    for(float I = .2;I<.5;I+=.01)\n    {\n        float M1 = Map(P+R*I);\n        float M2 = Map(P+R*I+Light*.01);\n        C += vec4((.6+vec3(.6,.5,.4)*(exp(-M2*10.)-M1)),1)*M1*(1.-C.a);\n        if (C.a>.99) break;\n    }\n\tfragColor = C+vec4(vec3(.5,.7,.9)-R.y*.4,1)*(1.-C.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}