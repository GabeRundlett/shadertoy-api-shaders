{
    "Shader": {
        "info": {
            "date": "1640832362",
            "description": "Randomly evolving plane waves",
            "flags": 0,
            "hasliked": 0,
            "id": "slKXWw",
            "likes": 2,
            "name": "plane waves",
            "published": 3,
            "tags": [
                "raymarching",
                "repetition",
                "tensorfield"
            ],
            "usePreview": 0,
            "username": "medium_fi",
            "viewed": 269
        },
        "renderpass": [
            {
                "code": "const int MAX_ITER = 100;\nconst float EPSILON = 1E-5;\n\nvec3 rotate(vec3 v, vec3 k, float angle){\n    k = normalize(k);\n    float c = cos(angle);\n    float s = sin(angle);\n    return v * c + cross(k, v) * s + k * dot(k, v) * (1. - c);\n}\n\nvec3 rotateAxes(vec3 v, vec3 a1, vec3 a2) {\n    vec3 n1 = normalize(a1);\n    vec3 n2 = normalize(cross(a2, a1));\n    vec3 n3 = normalize(cross(n2, n1));\n    mat3 R = mat3(n1, n2, n3);\n    return v*R;\n}\n\nvoid field(in vec3 x, out vec3 a1, out vec3 a2, out vec3 l) {\n    float t = iTime * 2.;\n    \n    // x = x * 0.5;\n    int K = 3;\n    vec3 v = vec3(0.);\n    for (int i = 0; i < 3; i++) {\n        float j = float(i) + t/7721.;\n        // Random direction\n        vec3 n = normalize(vec3(cos(j*71.), cos(j*31.), cos(j*141.)));\n        // Random frequency\n        float c = cos(j*37.);\n        float f = cos(j*17.);\n        float p = cos(j*139.);\n        v = v + n * sin(f * (dot(n, x) - c * t) + p);\n    }\n    \n    a1 = -normalize(v);\n    a2 = normalize(cross(a1, vec3(1.,0.,0.)));\n    float s = pow(3., 2. * clamp(length(v) / float(K), 0., 1.) - 1.);\n    l = 2. * vec3(0.1 * s, 0.03 / s, 0.03 / s);\n}\n\nfloat sdB( vec3 p, vec3 l) // IQ\n{\n    vec3 q = abs(p) - l;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sceneD(vec3 x, out vec3 col) {\n    float t = iTime;\n    \n    float rep = 0.5;\n    vec3 xf = mod(x + 0.5 * rep, rep) - 0.5 * rep;\n    vec3 xi = x - xf; \n    \n    vec3 a1 = vec3(0.);\n    vec3 a2 = vec3(0.);\n    vec3 l = vec3(0.);\n    field(xi, a1, a2, l);\n    l = clamp(l, 0., rep/4.);\n    \n    vec3 xfr = rotateAxes(xf, a1, a2);\n    float d = sdB(xfr, l);\n    col = abs(a1);\n    return d;\n}\n\nvec3 sceneNormal(vec3 p) {\n  vec2 dx = vec2(1.0, -1.0) * EPSILON;\n  vec3 col = vec3(0.);\n  return normalize(\n    dx.xyy * sceneD(p + dx.xyy, col) + dx.yxy * sceneD(p + dx.yxy, col) +\n    dx.yyx * sceneD(p + dx.yyx, col) + dx.xxx * sceneD(p + dx.xxx, col)\n   );\n}\n\nfloat tf(float d) {\n    return 0.7 / (1. + exp(10. * abs(d - 0.1))); \n}\n\n\nvec4 rayMarch(vec3 x, vec3 u, float stopDistance, out vec3 col) {\n\n    vec4 fragColor = vec4(0.);\n    vec3 acc = vec3(0.);\n\n    // Ray marching\n    float dp = 0.;\n    float depth = 0.;\n    float iter = 0.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 xi = x + depth * u;\n        float d = sceneD(xi, col);\n        \n        //d = max(d, 1.);\n        float clip = 0.3;\n        if (depth < clip && d  < clip) d = clip;\n        \n        depth += d;\n        iter += 1.;\n        \n        // Accumulate\n        acc = acc + (col * tf(d) - 0.1) * (dp + d)/ 2.;\n        \n        if (d <= stopDistance) break;\n        dp = d;\n    }\n    vec3 xf = x + depth * u;\n    fragColor = vec4(acc, 0.);\n    \n    if (true) {\n    // Compute boring lighting\n    vec3 n = sceneNormal(xf);\n    vec3 lightPosition = vec3(2., 2. , 7.);\n    vec3 lightDirection =  normalize(lightPosition - xf);\n    float light = clamp(dot(n,lightDirection), 0., 1.);\n    light = (0.5 * light + 0.5) * clamp(100. / pow(depth, 3.), 0., 1.);\n    //fragColor = fragColor + vec4( vec3(light) * col, 1.);\n\n    // Compute fun lighting\n    fragColor = 0.5 * fragColor + 1. * vec4( (1. - vec3(iter)/100.) * col, 1.);\n    }\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 camera = vec3(0, 0, 5.);\n    vec3 direction = normalize(vec3(uv, -1.));\n    \n    float t = 0.1 * iTime * 0.5 + 10.;\n    vec3 transform = vec3(cos(t) * 2., sin(t) * 1.2, 0.1);\n    float angle = t;\n    camera = rotate(camera, transform, angle);\n    direction = rotate(direction, transform, angle);\n    \n    // Find surface and normal\n    vec3 col = vec3(0.);\n    fragColor = rayMarch(camera, direction, 0.001, col);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}