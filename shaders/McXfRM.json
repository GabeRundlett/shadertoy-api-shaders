{
    "Shader": {
        "info": {
            "date": "1723497408",
            "description": "egg with energy https://glslsandbox.com/e#58284.2",
            "flags": 0,
            "hasliked": 0,
            "id": "McXfRM",
            "likes": 0,
            "name": "egg with energy",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 78
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 128\n#define MAX_DISTANCE 3.\n#define MIN_DISTANCE 0.001\n#define SPEED 3.\n#define SIZE 3.\n#define SPHERE_SIZE 1.2\n\nfloat n21(vec2 p) {\n    return fract(sin(p.x*123.453 + p.y*4567.543) * 67894.432 );\n}\n\nfloat hexDist(vec2 uv) {\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(vec2(1., 1.73))));\n}\n\nvec4 hexCoords(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * .5;\n\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n\n    if (length(a) < length(b)) {\n        gv = a;\n    } else {\n        gv = b;\n    }\n\n    float x = atan(gv.x, gv.y);\n    float y = .5 - hexDist(gv);\n\n    vec2 id = uv - gv;\n\n    return vec4(x, y, id.xy);\n}\n\nvec3 getTexture(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float size = 3.;\n\n    vec2 ouv = uv;\n\n    vec2 id = floor(uv*size);\n    uv = fract(uv*size) - .5;\n\n    vec3 c = vec3(0.);\n\n    for(int x = -1 ; x <= 1 ; x++) {\n        for(int y = -1 ; y <= 1 ; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 nid = id + offset;\n            float n = n21(nid);\n            if (n > .2) {\n                float n1 = fract(n*123.456);\n                float n2 = fract(n*5678.543);\n                vec3 color = vec3(n, n1, n2);\n                vec2 shift = vec2(n1 - .5, n2 - .5)*sin(iTime + n*n1 + n2);\n                c = max(c, ((0.01 + 0.02*n2)/length(uv - offset - shift)) * color);\n            }\n        }\n    }\n\n    col += c;\n\n    return col;\n}\n\nfloat getHeight(vec3 p, vec4 hex) {\n    float base = 0. + sin(hex.a/hex.b + iTime*2.)*.02;\n    base = clamp(hex.y/2., 0., base + SPHERE_SIZE/30.);\n    return base;\n}\n\n\n\n#define PI 3.141592653\n#define TWO_PI 2.0*PI\n\n#define time iTime\n\nfloat render(vec3 p0) {\n\nfloat dist = 0.;\nfloat mindist = 1e10;\n\nvec3 p1 = vec3(0.);\nfor (float i1=0.0;i1<=PI;i1+=.1) {\nfor (float i2=0.0;i2<=PI;i2+=.1) {\n\np1.x = cos(time+i1) * sin(2.*i2);// +\np1.y = sin(-time+i1) * cos(2.*i2) ;\np1.z = 1.0;\n\np1.x *= (i1+0.1);\np1.y *= (i1+0.1);\n\ndist = -0.022 + distance(p1, vec3(p0.x,p0.y,1.));\nmindist = min(mindist,dist);\n}\n}\n#define time iTime\n#define resolution iResolution.xy\nreturn 1./(256.*abs(mindist));\n}\nvec3 palette( float t3 ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t3+d) );\n}\n\n\nconst float count = 10.0;\nconst float speed = 05.0;\n\n\nfloat Hash( vec2 p, in float s)\n{\n    vec3 p2 = vec3(p.xy,27.0 * abs(sin(s)));\n    return fract(sin(dot(p2,vec3(27.1,61.7, 12.4)))*273758.5453123);\n}\n\n\nfloat noise(in vec2 p, in float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f * (3.0-2.0*f);\n    \n    \n    return mix(mix(Hash(i + vec2(0.,0.), s), Hash(i + vec2(1.,0.), s),f.x),\n               mix(Hash(i + vec2(0.,1.), s), Hash(i + vec2(1.,1.), s),f.x),\n               f.y) * s;\n}\n\n\nfloat fbm(vec2 p)\n{\n    float v = - noise(p * 02., 0.25);\n    v += noise(p * 01., 0.5) - noise(p * 01., 0.25);\n    v += noise(p * 02., 0.25) - noise(p * 02., 0.125);\n    v += noise(p * 04., 0.125) - noise(p * 08., 0.0625);\n    v += noise(p * 08., 0.0625) - noise(p * 16., 0.03125);\n    v += noise(p * 16., 0.03125);\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n\n    vec2 uv = fragCoords.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\nuv *= 3.;\nfloat worktime = time * speed;\n    \n\n    uv.x *= resolution.x/resolution.y;\n    \n    \n    vec3 finalColor2 = vec3( 0.0, 0.0, 0.0 );\n    for( float i = 1.0; i < count; i++ )\n    {\n        float t = abs(1.0 / ((uv.x + fbm( uv + worktime / i )) * (i * 100.0)));\n        finalColor2 +=  t * vec3( i * 0.075, 0.5, 2.0 );\n    }\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 col = vec3(0.);\n\n    float a = iTime;\n\n    vec3 ro = vec3(0., 0., -2.);\n    vec3 lookat = vec3(0., 0., 3.);\n    float zoom = 1.;\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(i - ro);\n    vec2 uv0 = uv;\nvec3  finalColor;\n   \n    for (float i = 0.0; i < 10.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d+finalColor2;\n    }\n\n    float ds, dt = 0.;\n    vec3 p;\n    float x,y = 0.;\n    vec2 suv;\n    vec4 hex;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n\n        x = acos(p.y/length(p));\n        y = atan(p.z, p.x) + iTime/SPEED;\n\n        suv = vec2(x, y);\n\n        hex = hexCoords(suv*SIZE);\n        float base = SPHERE_SIZE + sin(hex.a*hex.b + iTime*10.)*.0;\n\n        dt = length(p) - (base + getHeight(p, hex));\n        ds += dt * .6;\n\n        if (abs(dt) < MIN_DISTANCE || ds > MAX_DISTANCE) {\n            break;\n        }\n    }\n\n    float t2 = iTime*3.;\n\n    if (dt < MIN_DISTANCE) {\n        col += getTexture(suv);\n        //vec4 hex = hexCoords(suv*SIZE);\nfloat t = iTime;\n        float b = smoothstep(.9, 1., sin(t + sin(t)/cos(t + sin(t*3.+t))) * .5 + .5);\n\n        vec3 gridColor = mix(vec3(0., 1., 1.), mix(vec3(1.,0.,0.), vec3(0.,1.,0.), sin(iTime)), cos(iTime/2.));\n\n        col += pow(.005/hex.y, .6) * gridColor * b*finalColor+finalColor2;\n\n        col += vec3(n21(hex.ba + 100.))*.6;\n    } else {\n        col = getTexture(uv + vec2(iTime/(SPEED*2.)*render(vec3(uv.xy,0.0)), 0.));\n    }\n\n    fragColor = vec4(clamp(col, 0., 1.), 1.);\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}