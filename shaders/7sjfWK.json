{
    "Shader": {
        "info": {
            "date": "1647157573",
            "description": "just working out torus UVs",
            "flags": 0,
            "hasliked": 0,
            "id": "7sjfWK",
            "likes": 7,
            "name": "torus UVs",
            "published": 3,
            "tags": [
                "torus"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "// CC0: elenzil\n\n// return UV coords for torus with major axis = y\n// todo: incorporate fabrice's conformal mapping: https://www.shadertoy.com/view/sdd3R4\n// thanks: oneshade !\nvec2 torusUV(in vec3 p, in float majorRadius) {\n    float f = atan(p.z, p.x);\n    float g = atan(p.y, length(p.xz) - majorRadius);\n    return vec2(f, g) / PI * 0.5 + 0.5;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////\n\n\nconst int   gMarchMaxSteps      = 150;\nconst float gMarchUnderStep     = 0.7;\nconst float gMarchHorizon       = 100.0;\nconst float gMarchHorizonSq     = gMarchHorizon * gMarchHorizon;\nconst float gMarchEps           = 0.001;\nconst float gNormEps            = gMarchEps;\n\n// for development: bigger pixels = clearer problems\nconst float gDownRes            = 1.0;\n\n\nconst uint  gMaximumRaysInQueue = 20u;\n\n// the maximum total number of calls to Map().\nconst float gMaxTotalMapIters   = float(gMarchMaxSteps) * 10.0;\n\n// the least significant ray which will be processed\nconst float gMinRayContribution = 0.001;\nconst float gMinRayContribSq    = gMinRayContribution * gMinRayContribution;\n\n\n\nfloat gSSZoom = 1e9;\nfloat gSSEps = 1e9;\nfloat gT = 1e9;\nfloat gTotalMapIters = 0.0;\n\n// distance from camera to center of scene\nfloat gCamDist     = 20.0;\nvec3  gSceneCenter = gVBig;\nvec3  gLightDir    = gVBig;\nvec2  gTorusDims   = gVBig.xy;\nvec3  gTorusPos    = gVBig;\nfloat gHexTileFac  = 0.67;\n\n\nvec2 gMouse   = gVBig.xy;  // 0 to RES\nvec2 gSSMouse = gVBig.xy;  // 0 to 1\n\nstruct ray_t {\n    vec3 ro;\n    vec3 rd;\n    bool internal;\n    bool shadow;\n    vec3 contribution;\n};\n\nstruct marchResult_t {\n    float t;\n    uint  m;\n};\n\n\n// \"diffuse\"  includes regular diffuse plus ambient\n// \"specular\" includes reflection and transmission\nstruct material_t {\n    vec3 c1;\n    vec3 c2;\n    \n    // 0 = all diffuse, 1 = all specular\n    float diffuseVsSpecular1;\n    float diffuseVsSpecular2;\n    \n    // 0 = all reflection, 1 = all transmission\n    // scoped to 'specular'\n    float reflectionVsTransmission;\n    \n    // Lambert's linear attenuation coefficient\n    float attenuationCoefficient;    \n};\n\nconst uint kMSky   = 0u;\nconst uint kMFloor = 1u;\nconst uint kMTorus = 2u;\nconst uint kMBall  = 3u;\n\n\n// scoped to 'diffuse'.\nvec3 gAmbientLight     = gVBig;\nvec3 gDirectionalLight = gVBig;\n\n\nmaterial_t[] kMaterials = material_t[] (\n    // sky\n    material_t (\n        1.0 * vec3(0.1, 0.2, 1.0),\n        1.0 * vec3(0.3, 0.05, 0.1),\n        0.0, 0.0,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // floor\n    material_t (\n        gV1 * 0.8,\n        gV1 * 0.8,\n        0.4, 0.02,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // torus\n    material_t (\n        gV1 * 0.8,\n        gV1 * 0.0,\n        0.1, 0.1,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    )\n);\n\nvoid configMaterials() {\n    float ambientLightAmt = 0.3;\n    float directionalLightAmt = 1.0 - ambientLightAmt;\n    \n    gAmbientLight     = ambientLightAmt * sky(gV1n);\n    gDirectionalLight = clamp(directionalLightAmt * sky(-gLightDir) * 3.0, 0.0, 1.0);\n}\n\n\n// queue of ray_t's. ------------------------------\n#define QTYPE ray_t\nconst uint gQCapacity = gMaximumRaysInQueue;\nconst uint gQNumSlots = gQCapacity + 1u; QTYPE gQ[gQNumSlots]; uint gQHead = 0u; uint gQTail = 0u;\nuint QCount    ()           { if (gQHead >= gQTail) {return gQHead - gQTail;} else { return gQNumSlots - (gQTail - gQHead); } }\nuint QSpaceLeft()           { return gQCapacity - QCount(); }\nbool QIsFull   ()           { return QSpaceLeft() == 0u;}\nbool QIsEmpty  ()           { return QCount() == 0u; }\nvoid QEnqueue  (QTYPE item) { gQHead = (gQHead + 1u) % gQNumSlots; gQ[gQHead] = item; }\nQTYPE QDequeue ()           { gQTail = (gQTail + 1u) % gQNumSlots; return gQ[gQTail]; }\n//-------------------------------------------------\n\nvec3 toSpaceTorus(in vec3 p) {\n    vec3 pt = p - dot(gTorusDims, vec2(1.0)) * gVy;\n    pt.xy *= rot2(PI/2.0);\n    return pt;\n}\n\nvoid configGlobals1() {\n    gT       = mod(iTime, gMaxTime);\n    \n    gSSZoom  = 1.2;\n    gSSEps   = 4.0 / MINRES / gSSZoom;\n    \n    gMouse   = length(iMouse.xy) < 50.0 ? (vec2(sin(gT * 0.05107), -sin(gT * 0.051)) * 0.5 + 0.5) * RES.xy : iMouse.xy;\n    gSSMouse = gMouse/RES.xy;\n    \n    gLightDir     = normalize(-gVy + gVz * 0.4);\n    float sunTime = 40.0;\n    gLightDir.yx *= rot2(PI/2.0 * 1.01 * sin(sunTime) * sign(cos(sunTime)));\n    gLightDir.xz *= rot2(gT * 0.005);\n    \n    gTorusDims.x = mix(3.0, 9.0, smoothstep(-0.8, 0.8, sin(gT * 0.0)));\n    gTorusDims.y = mix(1.0, gTorusDims.x * 0.7, smoothstep(-0.8, 0.8, sin(gT * 0.1)));\n    gTorusPos    = dot(gTorusDims, vec2(1.0)) * gVy;\n    gSceneCenter = gTorusPos;\n\n    configMaterials();\n}\n\n\nmarchResult_t map(vec3 p) {\n    gTotalMapIters += 1.0;\n        \n    float d1 = p.y;\n    vec3 ps = abs(p.xyz);\n    float sr = 6.0;\n    ps -= vec3(50.0, sr, 50.0);\n    ps.y = mod(ps.y + sr, sr * 2.0) - sr;\n    d1 = min(d1, length(ps) - 6.0);\n\n    vec3 pt = toSpaceTorus(p);\n\n    float thick = 0.5;\n    float sep = (gTorusDims[0] + gTorusDims[1] * 2.0) * 2.0 / 12.0;\n    float gap = (sep - thick) / 2.0 * smoothstep(-0.1, 0.1, cos(10.0 + gT * 0.15 - floor((p.y + sep/2.0)/sep) * 0.05));\n    float d2 = sdTorus(pt, gTorusDims);\n    float noMoreVariableNames = mix(gTorusDims[1], thick, smoothstep(-0.1, 0.1, cos(2.0 + gT * 0.15 + floor((p.y + sep/2.0)/sep) * 0.05)));\n    d2 = max(d2, -sdTorus(pt, gTorusDims - vec2(0.0, noMoreVariableNames)));\n    \n    d2 = max(d2, -(abs(mod(pt.x + sep/2.0, sep) - sep/2.0) - gap));\n    \n    marchResult_t ret = marchResult_t(1e9, kMSky);\n    if (d1 < ret.t) { ret = marchResult_t(d1, kMFloor); }\n    if (d2 < ret.t) { ret = marchResult_t(d2, kMTorus); }\n    \n    return ret;\n}\n\nvoid getCamPosDir(out vec3 camPos, out vec3 camDir) {\n    float y    = smoothstep(0.05, 0.95, gSSMouse.y);\n    camPos     = gVz * gCamDist;\n    camPos.yz *= rot2((0.4 - y * 0.5) *  PI / 2.0);\n    camPos.xz *= rot2((gSSMouse.x * 2.0 - 1.0) * -PI * 1.1);\n    camPos    += gSceneCenter + gVy * 3.0;\n    \n    camDir     = normalize(gSceneCenter - camPos);\n}\n\nray_t getCamRay(in vec2 uv, float camZoom, in vec3 contribution) {\n    vec3 camPos;\n    vec3 camDir;\n    getCamPosDir(camPos, camDir);\n    ray_t ray;\n    ray.ro           = camPos;\n    ray.rd           = getCamRayDir(camDir, uv, camZoom);\n    ray.internal     = map(camPos).t < 0.0;\n    ray.shadow       = false;\n    ray.contribution = contribution;\n    return ray;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) {\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*gNormEps).t;\n    }\n    return normalize(n);\n}\n\nmarchResult_t march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    vec3 p = ro;\n    \n    for (int n = 0; dot(p, p) < gMarchHorizonSq; ++n) {\n        marchResult_t mr = map(p);\n        if (mr.t < gMarchEps || n == gMarchMaxSteps) {\n            return marchResult_t(t, mr.m);\n        }\n        \n        t += mr.t * gMarchUnderStep;\n        p = ro + t * rd;\n    }\n    \n    return marchResult_t(1e9, 0u);\n}\n\n\nvec3 sky(vec3 dir) {\n    vec3 ret = simple_sky(gVy * -1.5, dir, -gLightDir);\n    // ungamma.\n    // I'm not sure if this is 'correct'\n    // but without it there are nasty pops in the post-sunset darkness.\n    ret = pow(ret, vec3(1.5));\n    return ret;\n}\n\nstruct materialProps_t {\n    vec3 albedo;\n    vec3 emissive;\n    float diffuse_vs_specular;  // 0 = diffuse 1 = specular\n};\n\n\nmaterialProps_t getMaterialProps(in vec3 p, uint m) {\n    materialProps_t ret;\n    \n    material_t mat = kMaterials[m];\n    \n    ret.albedo              = mat.c1;\n    ret.emissive            = gV0;\n    ret.diffuse_vs_specular = mat.diffuseVsSpecular1;\n\n    // special cases\n    switch (m) {\n        case kMFloor: {\n            float theta = atan(p.z, p.x);\n            theta += 0.02 * length(p.xz);\n            float f = smoothstep(-0.01, 0.01, sin(theta * 6.0 + PI/6.0));\n            ret.albedo              = mix(mat.c1, mat.c2, f);\n            ret.diffuse_vs_specular = mix(mat.diffuseVsSpecular1, mat.diffuseVsSpecular2, f);\n            break;\n        }\n        case kMTorus: {\n            ret.albedo = gV0;\n            \n            vec2 uv = torusUV(toSpaceTorus(p), gTorusDims[0]);\n            \n            uv += gT * vec2(0.01, 0.05);\n            \n            uv = fract(uv);\n            \n            vec2 scale = vec2(90.0, 31.0);\n            \n            vec2 tmp = uv * scale;\n            vec2 ht  = hextile(tmp);\n\n            if (ht.x < -scale.x + 0.001) {\n                ht.x = 0.0;\n            }\n            if (ht.y < -scale.y / 1.75) {\n                ht.y = 0.0;\n            }\n            \n            float h = hash12(ht);\n            \n            ret.albedo              = mix(mat.c1, mat.c2, h);\n            ret.diffuse_vs_specular = mix(mat.diffuseVsSpecular1, mat.diffuseVsSpecular2, h);\n            \n            // dots, but some glitch at the seams.\n            // ret.diffuse_vs_specular *= 0.1 + 0.9 * smoothstep(0.3, 0.31, length(tmp));\n            \n            break;\n        }\n    }\n    \n    \n    return ret;\n}\n\nvec3 processRays() {\n\n    vec3 rgb = gV0;\n\n    while (!QIsEmpty() && gTotalMapIters < gMaxTotalMapIters) {\n        ray_t ray = QDequeue();\n        \n        vec3 rayRGB = gV0;\n\n        marchResult_t mr = march(ray.ro, ray.rd);\n        \n        if (ray.shadow) {\n            if (mr.t > 1e4) {\n                rgb += ray.contribution;\n            }\n        }\n        else {\n            if (mr.t < 1e4) {\n                vec3 p = ray.ro + ray.rd * mr.t;\n\n                vec3 n = calcNormal(p);\n\n                materialProps_t mp = getMaterialProps(p, mr.m);\n\n                vec3 albedo = mp.albedo;\n\n                float specAmt = mp.diffuse_vs_specular;\n                float diffAmt = 1.0 - specAmt;\n\n                float maximumDirectionalContribution = max(0.0, dot(n, -gLightDir));\n\n                vec3 directionalAmt = gDirectionalLight * maximumDirectionalContribution;\n                vec3 diffContrib = directionalAmt * albedo * diffAmt;\n\n                if (gLightDir.y < 0.0) {\n                    if (maximumDirectionalContribution > 0.0 && !ray.internal && !QIsFull() && dot(diffContrib, diffContrib) > gMinRayContribSq) {\n                        ray_t shdwRay;\n                        shdwRay.ro           = p + n * gMarchEps * 2.0;\n                        shdwRay.rd           = -gLightDir;\n                        shdwRay.contribution = ray.contribution * diffContrib;\n                        shdwRay.internal     = false;\n                        shdwRay.shadow       = true;\n                        QEnqueue(shdwRay);\n                    }\n                    else {\n                        rayRGB += diffContrib;\n                    }\n                }\n                \n                rayRGB += albedo * gAmbientLight;\n                rayRGB += mp.emissive;\n\n                vec3 specContrib = ray.contribution * specAmt;\n\n                if (!QIsFull() && dot(specContrib, specContrib) > gMinRayContribSq) {\n                    ray_t rflRay;\n                    rflRay.ro = p + n * gMarchEps * 2.0;\n                    rflRay.rd = reflect(ray.rd, n);\n                    rflRay.contribution = specContrib;\n                    rflRay.internal = ray.internal;\n                    rflRay.shadow       = false;\n                    QEnqueue(rflRay);\n                }\n\n            }\n            else {\n                rayRGB += sky(ray.rd);\n            }\n            rgb += ray.contribution * rayRGB;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    configGlobals1();\n    \n    vec2 uv = (floor((XY - RES.xy/2.0)/gDownRes)) / MINRES * 2.0 * gSSZoom * gDownRes;\n    \n    QEnqueue(getCamRay(uv, 2.0, gV1));\n    \n    vec3 rgb = processRays();\n    \n    rgb = pow(rgb, vec3(1.0/2.2));\n    \n    RGBA = vec4(rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES     (iResolution)\n#define MINRES  (min(RES.x, RES.y))\n#define ZERO    (min(iFrame,0))\n\n\nconst float PI       = 3.14159265359;\nconst float gMaxTime = 3e3;   // numerical precision gets bad above this\n\nconst vec3 gV0   = vec3(0.0);\nconst vec3 gV1   = vec3(1.0);\nconst vec3 gV1n  = normalize(gV1);\nconst vec3 gVx   = vec3(1.0, 0.0, 0.0);\nconst vec3 gVy   = vec3(0.0, 1.0, 0.0);\nconst vec3 gVz   = vec3(0.0, 0.0, 1.0);\nconst vec3 gVBig = vec3(1e13);\n\nvec3 sky(vec3 dir);\n\n// general math\nmat2 rot2(float theta) { float c = cos(theta); float s = sin(theta); return mat2(c, s, -s, c); }\n\nfloat square(float a) { return a * a; }\nfloat selfDot(vec2 a) { return dot(a, a); }\nfloat selfDot(vec3 a) { return dot(a, a); }\n\n// author: Neil Mendoza   license: unknown    link: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis\n//mat4 rotationMatrix(vec3 axis, float angle) {     axis = normalize(axis);     float s = sin(angle);     float c = cos(angle);     float oc = 1.0 - c;          return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,                0.0,                                0.0,                                0.0,                                1.0); \n\n\n// author: blackle mori   license: unknown    link: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\nreturn mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle);\n}\n\n// SDF manipulators\nfloat opU(float a, float b) {\n    return min(a, b);\n}\nfloat opS(float a, float b) {\n    return -min(-a, b);\n}\n\n// SDF primitives\n\nfloat sdPlaneY(vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nvec3 getCamRayDir(vec3 camDir, vec2 uv, float zoom) {\n\n    vec3 camFw = normalize(camDir);\n    vec3 camRt = normalize(cross(camFw, gVy));\n    vec3 camUp = cross(camRt, camFw);\n    \n    uv /= zoom;\n    \n    return normalize(camFw + camRt * uv.x + camUp * uv.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n\n\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// { 2d cell id, distance to border, distance to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\n\n\n\n// author: sam hocevar, license: WTFPL, link: https://stackoverflow.com/a/17897228\nvec3 rgb2hsv(vec3 c) {   vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);     vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));     vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));     float d = q.x - min(q.w, q.y);     float e = 1.0e-10;     return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }\nvec3 hsv2rgb(vec3 c) {   vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\n\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\n\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\nvec3 simple_sun(vec3 dir, vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 p, vec3 d, vec3 lightDir)\n{\n    vec3 sun = simple_sun(d, lightDir);\n    vec3 sky = d * 0.25 + 0.25;\n    return clamp(max(sun, sky), 0.0, 1.0);\n}\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}