{
    "Shader": {
        "info": {
            "date": "1680942427",
            "description": "An improved falling sand cellular automata simulation\n\nControls:\nMouse to draw\n0-9 Select material\nArrow keys to move camera\n-/+ Zoom in/out\n[ / ] Change mouse radius",
            "flags": 48,
            "hasliked": 0,
            "id": "msBSWK",
            "likes": 46,
            "name": "Falling Sand CA Ultimate",
            "published": 3,
            "tags": [
                "automata",
                "falling",
                "cellular",
                "sand",
                "margolus"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 1014
        },
        "renderpass": [
            {
                "code": "// Fork of \"Falling Sand CA v2\" by gelami. https://shadertoy.com/view/DsSSRd\n// 2022-12-12 20:12:05\n\n// Falling Sand CA Ultimate by gelami\n// https://www.shadertoy.com/view/msBSWK\n\n/*\n *  An improved falling sand cellular automaton simulation\n *  \n *  Cells are processed in 2x2 blocks to simplify the neighborhood checks\n *  and allows them to be processed in parallel without race conditions.\n *  The blocks are then offset using a cyclic Margolus neighborhood offset to prevent bias\n *  Has multiple types of materials that can interact with each other different\n *\n *  The biggest change from the previous iterations is the introduction of\n *  swaps instead of a 1D linear mapping of state in each block.\n *  Each cell in a 2x2 block can switch its position with another cell in the same block,\n *  Leading to a simpler model that can support multiple types of materials\n *  \n *  Controls:\n *  Mouse: Draw Material\n *  0 - 9: Select Material Type\n *  \n *  Arrow Keys: Move Camera\n *  Plus/Minus: Zoom in/out\n *  Left/Right Brackets: Change Mouse Radius\n *  \n *  Space: Clear\n *  R: Reset\n *\n *  1: Smoke\n *  2: Fire\n *  3: Lava\n *  4: Water\n *  5: Sand\n *  6: Stone\n *  7: Wood\n *  8: Grass\n *  9: Wall\n *  0: Eraser\n *  \n *  This is one of 4 shaders that explores falling sand cellular automata in the GPU\n * \n *  Previous entries:\n *  Falling Sand CA v1 - gelami\n *  https://www.shadertoy.com/view/DsjSzc\n *  \n *  Falling Sand CA v2 - gelami\n *  https://www.shadertoy.com/view/DsSSRd\n *  \n */\n\n// Pixel Art Filtering by Klems\n// https://www.shadertoy.com/view/MllBWf\nvec2 getCoordsAA(vec2 uv)\n{\n    float w = 1.0; // 1.5\n    vec2 fl = floor(uv + 0.5);\n    vec2 fr = fract(uv + 0.5);\n    vec2 aa = fwidth(uv) * w * 0.5;\n    fr = smoothstep(0.5 - aa, 0.5 + aa, fr);\n    \n    return fl + fr - 0.5;\n}\n\nvec4 sampleTexAA(sampler2D ch, vec2 uv, vec2 res)\n{\n    return texture(ch, getCoordsAA(uv) / res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+4);\n    vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n    vec4 mouse = texelFetch(iChannel0, IRES-ivec2(2, 1), 0);\n    float scale = scene.x;\n    vec2 center = scene.zw;\n    float radius = mouse.x;\n    float id = mouse.y;\n    float px = 1.0 / scale;\n    \n    fragCoord -= RES * 0.5;\n    fragCoord /= scale;\n    fragCoord += center;\n    \n    fragColor = sampleTexAA(iChannel2, fragCoord, RES);\n    \n    vec2 mousePos = (iMouse.xy - RES * 0.5) / scale + center;\n    float brush = smoothstep(0.0, px, abs(length(fragCoord - mousePos) - radius));\n    \n    float bleft = texelFetch(iChannel3, ivec2(KEY_BRACKET_LEFT, 0), 0).r;\n    float bright = texelFetch(iChannel3, ivec2(KEY_BRACKET_RIGHT, 0), 0).r;\n        \n    if (iMouse.z > 0.0 || bleft > 0.0 || bright > 0.0)\n        fragColor = mix(fragColor, vec4(0.8), 1.0-brush);\n    \n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define BUFFER_OFFSET 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    // Keyboard functions\n    if (p == IRES-1)\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(SCALE, 0, ZOOM_POINT);\n            return;\n        }\n        \n        vec4 prev = texelFetch(iChannel0, p, 0);\n    \n        float up = texelFetch(iChannel3, ivec2(KEY_UP, 0), 0).r;\n        float down = texelFetch(iChannel3, ivec2(KEY_DOWN, 0), 0).r;\n        float left = texelFetch(iChannel3, ivec2(KEY_LEFT, 0), 0).r;\n        float right = texelFetch(iChannel3, ivec2(KEY_RIGHT, 0), 0).r;\n    \n        float zoomin = texelFetch(iChannel3, ivec2(KEY_PLUS, 0), 0).r;\n        float zoomout = texelFetch(iChannel3, ivec2(KEY_MINUS, 0), 0).r;\n\n        vec2 speed = vec2(15.0 / prev.x);\n        float zoom = log2(prev.x + 1.0) * 0.08;\n        \n        if (zoomin > 0.0)\n            prev.x += zoom;\n        if (zoomout > 0.0)\n            prev.x -= zoom;\n        \n        prev.x = max(prev.x, 1.0);\n    \n        prev.w += up * speed.y;\n        prev.w -= down * speed.y;\n        prev.z -= left * speed.x;\n        prev.z += right * speed.x;\n        \n        prev.zw = clamp(prev.zw, RES * 0.5 / prev.x, RES - RES * 0.5 / prev.x);\n        \n        fragColor = prev;\n        return;\n        \n    } else if (p == IRES - ivec2(2, 1))\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(MOUSE_RADIUS, SAND, 0, 0);\n            return;\n        }\n        \n        vec4 prev = texelFetch(iChannel0, p, 0);\n                \n        for (int i = 0; i < 10; i++)\n        {\n            if (texelFetch(iChannel3, ivec2(KEY_0 + i, 0), 0).r > 0.0)\n                prev.y = float(i);\n        }\n        \n        float bleft = texelFetch(iChannel3, ivec2(KEY_BRACKET_LEFT, 0), 0).r;\n        float bright = texelFetch(iChannel3, ivec2(KEY_BRACKET_RIGHT, 0), 0).r;\n        \n        float radiusChange = 0.2;\n        prev.x -= bleft * radiusChange;\n        prev.x += bright * radiusChange;\n        \n        prev.x = max(prev.x, 1.0);\n        \n        if (iMouse.z > 0.0)\n        {\n            prev.zw = iMouse.xy;\n        } else {\n            prev.zw = vec2(0);\n        }\n        \n        fragColor = prev;\n        return;\n    }\n    \n    float space = texelFetch(iChannel3, ivec2(KEY_SPACE, 0), 0).r;\n    float reset = texelFetch(iChannel3, ivec2(KEY_R, 0), 0).r;\n    \n    if (space > 0.0)\n    {\n    \n        fragColor = vec4(AIR, 0, fragCoord / RES);\n        return;\n    }\n    \n    if (iFrame < 2 || reset > 0.0)\n    {\n        if (fragCoord.y == 0.5)\n        {\n            fragColor = vec4(WALL, 0, fragCoord / RES);\n            return;\n        }\n        \n        vec4 tex = texture(iChannel1, fragCoord / RES);\n        float id = mod(round(tex.x * WALL * 3.0 - 1.0), WALL+1.0);\n        \n        if (id == LAVA && tex.y < 0.2)\n            id = SMOKE;\n        if (id == STONE && tex.z < 0.3)\n            id = SAND;\n        if (id == PLANT && hash(state) < 0.8)\n            id = WATER;\n        \n        //float id = hash(state) < 0.05 ? SAND : AIR;\n        fragColor = vec4(id, 0, fragCoord / RES);\n        return;\n    }\n\n    vec2 mousePos = vec2(0);\n    // Mouse interaction\n    if (iMouse.z > 0.0)\n    {\n        mousePos = iMouse.xy;   \n    } else {\n        //mp = vec2(sin(iTime * 0.9) * 0.4 * RES.x + RES.x * 0.5, RES.y * 0.8);\n    }\n    \n    if (mousePos != vec2(0))\n    {\n        vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n        vec4 mouse = texelFetch(iChannel0, IRES-ivec2(2, 1), 0);\n        float scale = scene.x;\n        vec2 center = scene.zw;\n        float radius = mouse.x;\n        float id = mouse.y;\n        vec2 prevMousePos = mouse.zw;\n        \n        if (prevMousePos != vec2(0))\n        {\n            vec2 m = (mousePos - RES * 0.5) / scale + center;\n            vec2 mp = (prevMousePos - RES * 0.5) / scale + center;\n            float d = sdSegment(fragCoord, m, mp);\n            //float d = length(fragCoord - m);\n\n            if (d < radius && hash(state) < MOUSE_STRENGTH)\n            {\n                fragColor = vec4(id, 0, fragCoord / RES + iTime * 0.1);\n                return;\n            }\n        }\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n    fragColor.y = getOpacity(fragColor.x);\n    if (fragColor.x == FIRE || fragColor.x == LAVA)\n        fragColor.y = 0.0;\n    //fragColor.y = float(fragColor.x != AIR);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define SCALE 2.0\n\n#define MOUSE_RADIUS 3.0\n#define MOUSE_STRENGTH 0.5\n\n#define IMPROVED_OFFSET\n\n//#define RAINBOW_MODE\n\n#define ZOOM_POINT vec2(RES * 0.5 / SCALE)\n\n#define AIR 0.0\n#define SMOKE 1.0\n#define FIRE 2.0\n#define LAVA 3.0\n#define WATER 4.0\n#define SAND 5.0\n#define STONE 6.0\n#define WOOD 7.0\n#define PLANT 8.0\n#define WALL 9.0\n\n#define EPSILON 1e-4\n\n#define RES iResolution.xy\n#define IRES ivec2(iResolution.xy)\n\n#define sampleTex0(p) texelFetch(iChannel0, ivec2(p) % IRES, 0)\n#define sampleTex1(p) texelFetch(iChannel1, ivec2(p), 0)\n\n#define PI (acos(-1.0))\n#define TAU (2.0 * PI)\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_0 = 48;\n\nconst int KEY_PLUS = 187;\nconst int KEY_MINUS = 189;\n\nconst int KEY_BRACKET_LEFT = 219;\nconst int KEY_BRACKET_RIGHT = 221;\n\nconst int KEY_SPACE = 32;\nconst int KEY_R = 82;\n\n// 1D LOD Gaussian blur from Fabrice\n// https://www.shadertoy.com/view/WtKfD3\nvec4 gaussian1D(sampler2D tx, vec2 U, vec2 D, vec2 R)\n{\n    const int N = 32;\n    const float w = 0.1;\n    \n    float z = ceil(max(0., log2(w*R.y/float(N))));\n    \n    vec4  O = vec4(0);                                                      \n    float r = float(N-1)/2., g, t=0., x;                                    \n    for( int k=0; k<N; k++ ) {                                              \n        x = float(k)/r-1.;                                                  \n        t += g = exp(-8.0*x*x );                                            \n        O += g * texture(tx, (U+w*x*D) *R.y/R, z );     \n    }                                                                       \n    return O/t;                                                             \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(0)); }\n\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\n// RNG\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// Modified to work with 4 values at once\nuvec4 hash4i(inout uint y)\n{\n    uvec4 x = y * uvec4(213u, 2131u, 21313u, 213132u);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    y = x.x;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvoid swap(inout vec4 a, inout vec4 b)\n{\n    vec4 tmp = a;\n    a = b;\n    b = tmp;\n}\n\nvec4 sampleCells(sampler2D ch, ivec2 p, ivec2 res)\n{\n    if (p.x == 0 && p.y == 0)\n        return vec4(WALL, 0, 0, 0);\n        \n    if (p.x < 0 || p.x >= res.x || p.y < 0 || p.y >= res.y)\n        return vec4(WALL, 0, 0, 0);\n    \n    if (p.x >= res.x-1 || p.y >= res.y-1)\n        return vec4(WALL, 0, 0, 0);\n    \n    p = clamp(p, ivec2(0), res-1);  \n    \n    vec4 tex = texelFetch(ch, ivec2(p), 0);\n    \n    return tex;\n}\n\nivec2 getMargolusOffset(int frame)\n{\n#ifndef IMPROVED_OFFSET\n    frame = frame % 2;\n    if (frame == 1)\n        return ivec2(1, 1);\n    return ivec2(0, 0);\n#else\n    frame = frame % 4;\n\n    if (frame == 1)\n        return ivec2(1, 1);\n    else if (frame == 2)\n       return ivec2(0, 1);\n    else if (frame == 3)\n        return ivec2(1, 0);\n    return ivec2(0, 0);\n#endif\n}\n\nint cellToID(vec4 p)\n{\n    return int(dot(p, vec4(1, 2, 4, 8)));\n}\n\nvec4 IDToCell(int id)\n{\n    return vec4(id%2, (id/2)%2, (id/4)%2, (id/8)%2);\n}\n\nfloat getOpacity(float id)\n{\n    if (id == SMOKE)\n        return 0.2;\n    else if (id == FIRE)\n        return 0.8;\n    else if (id == LAVA)\n        return 0.9;\n    else if (id == WATER)\n        return 0.4;\n    else if (id >= SAND)\n        return 1.0;\n    return 0.0;\n}\n\nvec4 simulate(sampler2D ch, ivec2 p, ivec2 res, int frame, int bof)\n{\n    ivec2 of = getMargolusOffset(frame + bof);\n        \n    p += of;\n    \n    ivec2 fp = (p / 2) * 2;\n    ivec2 fr = p & 1;\n    int x = fr.x + (fr.y) * 2;\n    \n    fp -= of;\n    p -= of;\n    \n    vec4 t00 = sampleCells(ch, fp + ivec2(0, 0), res);\n    vec4 t10 = sampleCells(ch, fp + ivec2(1, 0), res);\n    vec4 t01 = sampleCells(ch, fp + ivec2(0, 1), res);\n    vec4 t11 = sampleCells(ch, fp + ivec2(1, 1), res);\n    \n    if (t00.x == AIR && t10.x == AIR &&\n        t01.x == AIR && t11.x == AIR)\n        return vec4(0);\n    \n    vec4 tn00 = sampleCells(ch, fp + ivec2(0, -1), res);\n    vec4 tn10 = sampleCells(ch, fp + ivec2(1, -1), res);\n    \n    ivec2 o = ivec2(fr.x, fr.y);\n    \n    vec4 v = hash43(uvec3(fp, frame));\n    vec4 v2 = hash43(uvec3(fp, frame/8));\n    \n    if (v.x < 0.5)\n    {\n        swap(t00, t10);\n        swap(t01, t11);\n    }\n    \n    // Sand\n    if ((t01.x == SAND && t11.x < SAND ||\n        t01.x < SAND && t11.x == SAND) &&\n        t00.x < SAND && t10.x < SAND && v.y < 0.4)\n    {\n        swap(t01, t11);\n    }\n    if (t01.x == SAND)\n    {\n        if (t00.x < SAND)\n        {\n            if (v.z < 0.9) swap(t01, t00);\n        } else if (t11.x < SAND && t10.x < SAND)\n        {\n            swap(t01, t10);\n        }\n    }\n    if (t11.x == SAND)\n    {\n        if (t10.x < SAND)\n        {\n            if (v.z < 0.9) swap(t11, t10);\n        } else if (t00.x < SAND && t01.x < SAND)\n        {\n            swap(t11, t00);\n        }\n    }\n    \n    // Stone\n    if ((t01.x == STONE && t11.x < SAND ||\n        t01.x < SAND && t11.x == STONE) &&\n        t00.x < SAND && t10.x < SAND && v.y < 0.05)\n    {\n        swap(t01, t11);\n    }\n    if (t01.x == STONE && v.z < 0.8)\n    {\n        if (t00.x < SAND)\n        {\n            swap(t01, t00);\n        } else if (t11.x < SAND && t10.x < SAND)\n        {\n            swap(t01, t10);\n        }\n    }\n    if (t11.x == STONE && v.z < 0.8)\n    {\n        if (t10.x < SAND)\n        {\n            swap(t11, t10);\n        } else if (t00.x < SAND && t01.x < SAND)\n        {\n            swap(t11, t00);\n        }\n    }\n    \n    // Water\n    if ((t00.x == WATER || t10.x == WATER ||\n         t01.x == WATER || t11.x == WATER))\n    {\n        if (t00.x == FIRE)\n        {\n            t00.x = SMOKE;\n        }\n        if (t10.x == FIRE)\n        {\n            t10.x = SMOKE;\n        }\n        if (t01.x == FIRE)\n        {\n            t01.x = SMOKE;\n        }\n        if (t11.x == FIRE)\n        {\n            t11.x == SMOKE;\n        }\n    }\n    \n    bool a = false;\n    if (t01.x == WATER)\n    {\n        if (t00.x < WATER && v.z < 0.95)\n        {\n            //if (v.z < 0.9)\n                swap(t01, t00);\n                a = true;\n        } \n        else if (t11.x < WATER && t10.x < WATER && v.x < 0.2)\n        {\n            swap(t01, t10);\n            a = true;\n        }\n    }\n    if (t11.x == WATER)\n    {\n        if (t10.x < WATER && v.z < 0.95)\n        {\n            //if (v.z < 0.9)\n                swap(t11, t10);\n                a = true;\n                \n        } else if (t01.x < WATER && t00.x < WATER && v.x < 0.2)\n        {\n            swap(t11, t00);\n            a = true;\n        }\n    }\n    //if (t00.x >= WATER && t10.x >= WATER)\n    //if (v.w < 1.0)\n    if (!a)\n    {\n        if ((t01.x == WATER && t11.x < WATER ||\n            t01.x < WATER && t11.x == WATER) &&\n            (t00.x >= WATER && t10.x >= WATER || v.w < 0.8))\n        {\n            swap(t01, t11);\n        }\n        if ((t00.x == WATER && t10.x < WATER ||\n            t00.x < WATER && t10.x == WATER) &&\n            (tn00.x >= WATER && tn10.x >= WATER || v.w < 0.8))\n        {\n            swap(t00, t10);\n        }\n    }\n    \n    \n    // Lava\n    if ((t00.x == LAVA && t10.x < LAVA ||\n        t00.x < LAVA && t10.x == LAVA) && v.y < 0.2)\n    {\n        swap(t00, t10);\n    }\n    if (t01.x == LAVA)\n    {\n        if (t00.x == WATER)\n        {\n            t01.x = STONE;\n            t00.x = SMOKE;\n        }\n        if (t11.x == WATER)\n        {\n            t01.x = STONE;\n            t11.x = SMOKE;\n        }\n        if (t00.x < LAVA)\n        {\n            if (v.z < 0.5) swap(t01, t00);\n        } \n        else if (t11.x < LAVA && t10.x < LAVA)\n        {\n            swap(t01, t10);\n        }\n    }\n    if (t11.x == LAVA)\n    {\n        if (t01.x == WATER)\n        {\n            t11.x = STONE;\n            t01.x = SMOKE;\n        }\n        if (t10.x == WATER)\n        {\n            t11.x = STONE;\n            t10.x = SMOKE;\n        }\n        if (t10.x < LAVA)\n        {\n            if (v.z < 0.5) swap(t11, t10);\n        }\n        else if (t01.x < LAVA && t00.x < LAVA)\n        {\n            swap(t11, t00);\n        }\n    }\n    \n    \n    // Smoke\n    if (t00.x == SMOKE && t01.x > SMOKE && v.w < 0.02)\n    {\n        t00.x = AIR;\n    }\n    \n    if ((t00.x == SMOKE && t10.x < SMOKE ||\n        t00.x < SMOKE && t10.x == SMOKE) && v.y < 0.1)\n    {\n        swap(t00, t10);\n    }\n    if ((t01.x == SMOKE && t11.x < SMOKE ||\n        t01.x < SMOKE && t11.x == SMOKE) && v.y < 0.1)\n    {\n        swap(t01, t11);\n    }\n    if (t00.x == SMOKE)\n    {\n        if (t01.x < SMOKE)\n        {\n            if (v.z < 0.2)\n                swap(t00, t01);\n        } else if (t10.x < SMOKE)\n        {\n            swap(t00, t10);\n        }\n    }\n    if (t10.x == SMOKE)\n    {\n        if (t11.x < SMOKE)\n        {\n            if (v.z < 0.2)\n                swap(t10, t11);\n        } else if (t00.x < SMOKE)\n        {\n            swap(t10, t00);\n        }\n    }\n    \n    \n    // Fire\n    if ((t00.x == FIRE || t10.x == FIRE ||\n         t01.x == FIRE || t11.x == FIRE ||\n         t00.x == LAVA || t10.x == LAVA ||\n         t01.x == LAVA || t11.x == LAVA) && v.x < 0.03)\n    {\n        if (t00.x == WOOD || t00.x == PLANT)\n        {\n            t00.x = FIRE;\n        }\n        if (t10.x == WOOD || t00.x == PLANT)\n        {\n            t10.x = FIRE;\n        }\n        if (t01.x == WOOD || t00.x == PLANT)\n        {\n            t01.x = FIRE;\n        }\n        if (t11.x == WOOD || t00.x == PLANT)\n        {\n            t11.x == FIRE;\n        }\n    }\n    \n    if ((t01.x == FIRE && t11.x < FIRE ||\n        t01.x < FIRE && t11.x == FIRE) && v.y < 0.05)\n    {\n        swap(t01, t11);\n    }\n    if (t00.x == FIRE)\n    {\n        if (t01.x == AIR && v.w < 0.005)\n        {\n            t01.x = SMOKE;\n        }\n        \n        if (v.x < 0.002)\n        {\n            t00.x = SMOKE;\n        } else if (v.z < 0.05)\n        {\n            if (t01.x < FIRE)\n            {\n                    swap(t00, t01);\n            } else if (t10.x < FIRE)\n            {\n                swap(t00, t10);\n            }\n        }\n    }\n    if (t10.x == FIRE)\n    {\n        if (v.x < 0.002)\n        {\n            t10.x = SMOKE;\n        }\n        else if (v.z < 0.05)\n        {\n            if (t11.x < FIRE)\n            {\n                swap(t10, t11);\n            } else if (t00.x < FIRE)\n            {\n                swap(t10, t00);\n            }\n         }\n    }\n    \n    // Plant\n    if (t00.x == PLANT && t01.x == WATER && t10.x != PLANT &&\n       (tn00.x == SAND || tn00.x == PLANT) && v.w < 0.01)\n    {\n        t01.x = PLANT;\n    }\n    if (t01.x == PLANT)\n    {\n        if (t00.x < SAND)\n        {\n            swap(t01, t00);\n        }\n    }\n    \n    \n    if (v.x < 0.5)\n    {\n        swap(t00, t10);\n        swap(t01, t11);\n    }\n    \n    switch (x)\n    {\n        case 0:\n            return t00;\n        case 1:\n            return t10;\n        case 2:\n            return t01;\n        case 3:\n            return t11;\n    }\n    \n    return vec4(0);\n}\n\n// https://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);\n    return vec3(H, C, Q.x);\n}\n  \nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + EPSILON);\n    return vec3(HCV.x, S, HCV.z);\n}\n\nvec3 RGBtoHSL(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);\n    return vec3(HCV.x, S, L);\n}\n\n\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;\n}\n\nvec3 HSLtoRGB(in vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define BUFFER_OFFSET 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+1);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || p == IRES-ivec2(2, 1) || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define BUFFER_OFFSET 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+2);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || p == IRES-ivec2(2, 1) || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\n// Cheap mipmap blur from Michael Moroz\n// https://www.shadertoy.com/view/WsVGWV\nfloat weight(float t, float log2radius, float gamma)\n{\n    return exp(-gamma*pow(log2radius-t,2.));\n}\n\nvec4 sampleBlurred(sampler2D ch, vec2 uv, float radius, float gamma)\n{\n    vec4 pix = vec4(0.);\n    float norm = 0.;\n    // Weighted integration over mipmap levels\n    for(float i = 0.; i < 10.; i += 1.0)\n    {\n        float k = weight(i, log2(radius), gamma);\n        pix += k*texture(ch, uv, i); \n        norm += k;\n    }\n    \n    return pix / norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+3);\n    vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n    float scale = scene.x;\n    vec2 center = scene.zw;\n    \n    // Culling\n    /*\n    vec2 bl = center - RES * 0.5 / scale - 1.0;\n    vec2 tr = center + RES * 0.5 / scale + 1.0;\n    \n    if (fragCoord.x < bl.x || fragCoord.x >= tr.x ||\n        fragCoord.y < bl.y || fragCoord.y >= tr.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }*/\n\n    vec4 data = sampleTex0(fragCoord);\n    float id = data.x;\n    \n    vec4 rand = hash42(uvec2(fragCoord));\n    \n    vec2 uv = fragCoord / RES;\n    \n    if (id == WATER || id == LAVA)\n    {\n        float a = (texture(iChannel2, uv * 4.0).r + iTime * 0.5) * TAU;\n        uv += 1.2 * vec2(cos(a), sin(a)) / RES * vec2(RES.y / RES.x, 1.0);\n    }\n    vec3 bg = texture(iChannel1, uv * 2.0, 2.0).rgb * 0.25;//vec3(26, 29, 33) / 255.0;\n    bg = round(bg * 64.0) / 64.0;\n    \n    vec3 col;\n    \n    if (id == SMOKE)\n        col = vec3(0.5);\n    else if (id == FIRE)\n        col = vec3(1.0, 0.25, 0);\n    else if (id == LAVA)\n        col = vec3(1.0, 0.4, 0);\n    else if (id == WATER)\n        col = vec3(0.2, 0.3, 0.9);\n    else if (id == SAND)\n        col = vec3(225, 177, 89) / 255.0;\n    else if (id == STONE)\n        col = vec3(0.25);\n    else if (id == WOOD)\n        col = vec3(0.196,0.129,0.102);\n    else if (id == PLANT)\n        col = vec3(0.4, 0.65, 0.1);\n    else if (id == WALL)\n        col = vec3(0.09, 0.08, 0.13);\n    else\n        col = vec3(bg);\n    \n    vec3 hsl = RGBtoHSL(col);\n    \n    if (id != WATER)\n    {\n        vec3 r2 = rand.xyz;\n        if (id == LAVA)\n            r2 = 0.5 + 0.5 * sin((r2 + iTime * 0.4) * TAU);\n        \n        hsl.x = hsl.x + (r2.z - 0.5) * 8.0 / 255.0;\n        hsl.y = hsl.y + (r2.x - 0.5) * 20.0 / 255.0;\n        hsl.z = hsl.z + (r2.y - 0.5) * 16.0 / 255.0;\n\n        vec3 rgb = HSLtoRGB(hsl);\n        col = rgb;\n    }\n    \n#ifdef RAINBOW_MODE\n    hsl = vec3(fract(data.z * 4.0 + data.x * 1.2232), 0.5 + 0.5 * fract(data.w * 4.0), 0.5);\n    col = mix(col, HSLtoRGB(hsl), 0.5);\n#endif\n\n    float r = rand.w;\n    if (id == LAVA)\n        r = 0.5 + 0.5 * sin((r - iTime * 0.4) * TAU);\n    col *= 0.9 + 0.1 * r;\n    \n    bg *= 0.9 + 0.1 * rand.z;\n    \n    /*\n    vec2 ldir = normalize(vec2(0, 1));\n    \n    vec2 n = vec2(0);\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            if (x == 0 && y == 0)\n                continue;\n            float b = float(sampleTex0(fragCoord + vec2(x, y)).x != AIR);\n            \n            n += vec2(x, y) * (1.0 - b) * (abs(x) + abs(y) < 2 ? 1.0 : sqrt(2.0) / 2.0);\n        }\n    }\n    \n    n = normalize(n);\n    */\n    \n    //float dif = max(dot(n, ldir), 0.0);\n    //float sha = max(dot(n, -ldir), 0.0);\n    \n    float up = sampleTex0(fragCoord + vec2(0, 1)).x;\n    float down = sampleTex0(fragCoord - vec2(0, 1)).x;\n    float dif = float(up < id);\n    float sha = float(down < id);// * float(!(down >= SAND && id >= SAND));\n    \n    float occ = sampleBlurred(iChannel0, fragCoord / RES, 16.0, 0.5).y;\n    occ = saturate((1.0 - occ) / 0.25);\n    \n    col *= 0.2 + 0.8 * occ;\n    col *= 0.6 + 0.4 * max(dif, 1.0 - sha);\n    col += col * 0.3 * dif;\n    \n    float op = getOpacity(id);\n    \n    col = mix(bg, col, op);\n    \n    //col = vec3(bg);\n    \n    fragColor = vec4(col, occ);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}