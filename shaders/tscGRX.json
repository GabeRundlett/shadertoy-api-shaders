{
    "Shader": {
        "info": {
            "date": "1568946268",
            "description": "A shader from 2015 with some very cheap improvements included.",
            "flags": 0,
            "hasliked": 0,
            "id": "tscGRX",
            "likes": 17,
            "name": "Elevated coast modernized",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "terrain",
                "normals",
                "fog"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 657
        },
        "renderpass": [
            {
                "code": "// Modernized version of Elevated coast @ https://www.shadertoy.com/view/4l23Rh\n// Changes:\n//\n// - addition of distance fog\n// - reduced normal shimmering by taking into account pixel footprint\n// - simple mouse controls\n// - increase of terrain noise levels\n// - sky reacts to mouse movement (how did I miss this one..?)\n//\n// Original shader with changes incorporated follows:\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n#define time -iTime\n\n\nfloat dh;\n\n                                 \nconst mat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nconst mat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\nvec3 noised(in vec2 p){//noise with derivatives\n\tfloat res=0.;\n    vec2 dres=vec2(0.);\n    float f=1.;\n    mat2 j=m2;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        float a=p.x+sin(2.*p.y);\n        res+=sin(a);\n        dres+=cos(a)*vec2(1.,2.*cos(2.*p.y))*j;\n        j*=m2*f;\n        \n\t}        \t\n\treturn vec3(res,dres)/3.;\n}\n\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f )+.5)/f;       \n\t    f *=2.;\n        p=im2*p;\n       \n\t}\n\treturn 1.-r*.5;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += (1.-abs(noise( p*f +.9*time)))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*(r-.2*iTime/(.1-f));\n\t}\n\treturn r/4.+.5;\n}\n\n\n\nfloat terrainIq( in vec2 x )//from IQ's Elevated : https://www.shadertoy.com/view/MdX3Rr\n{\n\tvec2  p = x;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn .3*a+.5;\n}\n\nfloat swissTurbulence(vec2 p )//from http://www.decarpentier.nl/scape-procedural-extensions\n{\n     \n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float warp = 0.15;\n    float sum = 0.;\n     float freq = 1.0, amp = 1.0;\n     vec2 dsum = vec2(0.);\n     for(int i=0; i < 7; i++)\n     {\n         vec3 n = noised((p + warp * dsum)*freq);\n         sum += amp * (1. - abs(n.x));\n         dsum += amp * n.yz * -n.x;\n         freq *= lacunarity;\n         amp *= gain * clamp(sum,0.,1.);\n    }\n    return sum/3.;\n}\n\nfloat jordanTurbulence(vec2 p)//from http://www.decarpentier.nl/scape-procedural-extensions\n{\n    \n    \n    float lacunarity = 2.0;\n    float gain1 = 0.8;\n    float gain = 0.5;\n    float warp0 = 0.4;\n    float warp = 0.35;\n    float damp0 = 1.0;\n    float damp = 0.8;\n    float damp_scale = 1.0;\n    vec3 n = noised(p);\n    vec3 n2 = n * n.x;\n    float sum = n2.x;\n    vec2 dsum_warp = warp0*n2.yz;\n    vec2 dsum_damp = damp0*n2.yz;\n\n    float amp = gain1;\n    float freq = lacunarity;\n    float damped_amp = amp * gain;\n\n    for(int i=1; i < 8; i++)\n    {\n        n = noised(p * freq + dsum_warp.xy);\n        n2 = n * n.x;\n        sum += damped_amp * n2.x;\n        dsum_warp += warp * n2.yz;\n        dsum_damp += damp * n2.yz;\n        freq *= lacunarity;\n        amp *= gain;\n        damped_amp = amp * (1.-damp_scale/(1.+dot(dsum_damp,dsum_damp)));\n    }\n    return sum/2.+.5;\n}\n\nfloat rocks(vec2 p){\n   //return jordanTurbulence(p );\n   // return swissTurbulence(p );\n   return terrainIq(p);\n   //return fbmabs(p)*.5+.5;   \n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-rocks(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p,float px)\n{\n\t//const vec2 e = vec2(0.004, 0.0);\n    vec2 e = vec2(px, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        2.0*e.x,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p,float px)\n{\n\t//const vec2 e = vec2(0.002, 0.0);\n    vec2 e = vec2(px, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        2.0*e.x,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\t\n\t//return sin(vec3(1.7,1.5,1.)+1.8- .9*fbmabs(p*4.-.02*time))+.2;\n    return sin(vec3(1.7,1.5,1)+ .7+ .9*fbmabs(p*4.-.02*time))+.25;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 35.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    \n    p.zx = p.xz;\n    p.z=-p.z;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n   \tvec3 sd = rd;\n\tvec3 ro = vec3(0.0, 2.0, -2.+.2*time);\n    if(iMouse.y>iResolution.y*0.125) {\n        ro.xy += 2.0 * (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        sd = normalize(vec3(p + 0.125 * (2.0 * iMouse.xy - iResolution.xy) / iResolution.y, -2.));\n    }\n    vec3 li = normalize(vec3(-2., 2., -4.));\n    ro = transform(ro);\n\trd = transform(rd);\n\tsd = transform(sd);\n    \n    //sky\n    col = sky(sd.xz*(.1+sd.y));\n    \n    \n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        //if(dh<0.)t-=dh;\n        vec3 pos = ro + t * rd;\n    vec3 p1 = t * normalize(vec3(p+1./iResolution.y,-2.));\n    vec3 p2 = t * normalize(vec3(p-1./iResolution.y,-2.));\n    float px = distance(p1,p2);\n        \n        float k=rocks(pos.xz)*2.;\n        \n        vec3 nor = normalRocks(pos.xz,px);\n        float r = max(dot(nor, li),0.05)/2.;\n        if(dh<0.&&dh>-.02)r+=.5*exp(20.*dh);\n        \n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<0.02){\n        \tvec3 nor = normalSea(pos.xz,px);\n        \tnor = reflect(rd, nor);\n            col1+=vec3(0.9,.2,.05)*dh*.4;\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \tcol1 +=.2* sky(nor.xz/(.5+nor.y));\n            \n        }\n\t    col = mix(.1+col1,col,clamp(exp2(smoothstep(0.,35.,t))-1.,0.,1.));\n        \n\t}\n    \n   \tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}