{
    "Shader": {
        "info": {
            "date": "1490841523",
            "description": "Simple metaball, there are 3 lights using Cook-Torrance and Oren-Nayar",
            "flags": 0,
            "hasliked": 0,
            "id": "lsScz1",
            "likes": 16,
            "name": "Metaball - reflection/refraction",
            "published": 3,
            "tags": [
                "procedural",
                "metaball",
                "environment"
            ],
            "usePreview": 0,
            "username": "Karambit",
            "viewed": 2295
        },
        "renderpass": [
            {
                "code": "/*=========================================================================================\n\nBy Imanol Fotia.\nhttp://www.imanolfotia.com\n\nMIT License\n=========================================================================================*/\n\nvec2 q; \nvec3 normal;\nvec3 ro;\nfloat metallic = 1.0;\nfloat roughness = 0.2;\n#define PI 3.14159265359\n#define Scale vec3(.8, .8, .8)\n#define K 19.19\n\n vec3 colors[4];\n\nuniform float time;\n\nfloat degToRad(float d) \n{\n    return d * PI / 180.0;\n}\n\nvec3 hash(vec3 a)\n{\n    a = fract(a * Scale);\n    a += dot(a, a.yxz + K);\n    return fract((a.xxy + a.yxx)*a.zyx);\n}\n\nmat4 makeYRotation(in float angleInRadians) \n{\n  float c = cos(degToRad(angleInRadians));\n  float s = sin(degToRad(angleInRadians));\n  mat4 r;\n  r[0].xyzw = vec4(c, 0, -s, 0);\n  r[1].xyzw = vec4(0, 1, 0, 0);\n  r[2].xyzw = vec4(s, 0, c, 0);\n  r[3].xyzw = vec4(0, 0, 0, 1);\n\n  return r;\n}\n\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = mat3(inverse(m))*p;\n    return q;\n}\n\nvec2 sdSphere( vec3 p, float s, int id)\n{\n\treturn vec2(length(p)-s, id);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k = 1.0;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvec2 map( in vec3 p)\n{\n\tvec2 res;// = 0.0;\n\tfloat mins = 0.0;\n\tvec3 q = p + vec3(-cos(iTime)*3.0, sin(iTime)*3.0-4.0, cos(iTime)*3.0+2.0);\n\tvec2 resSph = sdSphere(q, 3.2, 0);\n\n\tq = p + vec3(-sin(iTime)*2.0, cos(iTime)*2.0-4.0, sin(iTime)*2.0+2.0);\n\tvec2 resSph2 = sdSphere(q, 2.5, 1);\n\n\tq = p + vec3(sin(iTime)*2.0, cos(iTime)*2.0-4.0, -cos(iTime)*2.0+2.0);\n\tvec2 resSph3 = sdSphere(q, 3.0, 2);\n\n\n\tq = p + vec3(cos(iTime)*2.0, sin(iTime)*2.0-4.0, -sin(iTime)*2.0+2.0);\n\tq = opTx(q, makeYRotation(iTime*15.0));\n\tvec2 resSph4 = sdSphere(q, 2.8, 3);\n\n\tq = p + vec3(cos(iTime)*2.0, cos(iTime)*2.0-4.0, 0.0);\n\tfloat torus = sdTorus(q, vec2(1.0, 0.5));\n    \n\n\tres.x = (smin(smin(smin(resSph2.x, resSph.x), smin(resSph3.x, resSph4.x)), torus));\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x));\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 100.0;\n\tvec2 h          = vec2(1.0, 0.0);\n    vec2 t          = vec2(0.0, 0.0);\n    for( int i=0; i<50; i++ )\n    {\n        if( h.x<0.001 || t.x>maxd ) break;\n\t    h = map( ro+rd*t.x);\n        t.x += h.x;\n    }\n        t.y = h.y;\n\n    if( t.x>maxd ) t.x=-1.0;\n\t\n    return t;\n}\n\nfloat orenNayarDiffuse(\n  vec3 ld,\n  vec3 vd,\n  vec3 sn,\n  float r,\n  float a) {\n  \n  float LdotV = dot(ld, vd);\n  float NdotL = dot(ld, sn);\n  float NdotV = dot(sn, vd);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1., max(NdotL, NdotV), step(.0, s));\n\n  float sigma2 = r * r;\n  float A = 1. - .5 * (sigma2/((sigma2 + .33) + .000001));\n  float B = .45 * sigma2 / (sigma2 + .09) + .00001;\n    \n  float ga = dot(vd-sn*NdotV,sn-sn*NdotL);\n\n  return max(0., NdotL) * (A + B * max(0., ga) * sqrt((1.0-NdotV*NdotV)*(1.0-NdotL*NdotL)) / max(NdotL, NdotV));\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n  \n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n  \n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n  \n    return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n  \n    return ggx1 * ggx2;\n}\nvec3 F;\nvec3 kS;\nvec3 kD;\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nvec3 lighting(in vec3 n, in vec3 lp, in vec3 p, in float id)\n{\n\n    n = normalize(n);\n    vec3 ld = normalize(lp - p);\n    vec3 vd = normalize(ro - p);\n\tfloat diff = (orenNayarDiffuse(ld, vd, n, roughness, 1.0));\n\t//diff *= colors[int(floor(id))];\n\n\n\tvec3 F0 = vec3(0.04);\n    F0      = mix(F0, vec3(1.0), metallic);\n\n    F = fresnelSchlickRoughness(max(dot(n, vd), 0.0), F0, roughness);\n    //F.x = clamp(F.x, 0.03, 1.0);\n    //F.y = clamp(F.y, 0.03, 1.0);\n    //F.z = clamp(F.z, 0.03, 1.0);\n    kS = F;\n    kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n\n\tvec3 H = normalize(vd + ld);\n        float distance = length(lp - p);\n        float attenuation;// = 100.0/pow(distance, 2.0);\n        vec3 radiance     = vec3(1.0) /* attenuation*/;        \n        \n        // cook-torrance brdf\n        float NDF = DistributionGGX(n, H, clamp(roughness, 0.03, 1.0));        \n        float G   = GeometrySmith(n, vd, ld, roughness);      \n        \n        vec3 nominator    = NDF * G * F;\n        float denominator = (4.0 * max(dot(vd, n), 0.0) * max(dot(ld, n), 0.0)) + 0.001; \n        vec3 brdf = nominator / denominator;\n            \n        // add to outgoing radiance Lo\n        float NdotL = diff; //max(orenNayarDiffuse(L, V, Normal, clamp(Specular, 0.03, 1.0), 1.0), 0.0);//               \n        vec3 Lo = (kD * vec3(1.0) / PI + brdf) * radiance * NdotL; \n    \treturn Lo /** vec3(cos(iTime) * 0.5 + 0.5, sin(iTime) * 0.5 + 0.5, -cos(iTime) * 0.5 + 0.5 );*/;\n\n}\n\nfloat calcShadow(in vec3 p, in vec3 lp)\n{\n    vec3 lightdir = normalize(p-lp);\n    vec2 ld2 = intersect(lp, lightdir);\n    vec3 pos = lp+lightdir*ld2.x;\n    float l1 = length(pos-p);\n        return smoothstep(4.0, 0.0, l1);\n}\n\nvoid camera( vec3 hp, vec3 i , vec2 fragCoord, out vec3 rd) {\n    float fRatio = iResolution.x / iResolution.y; // Aspect Ratio\n\n    vec3 f   = normalize(i - hp);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n    vec2 vvc = 2.*fragCoord.xy/iResolution.xy-1.;\n    vvc.y /= fRatio;\n\n    vec3 ro = hp;\n    vec3 r = normalize(cross(f, vUp));\n    vUp    = cross(r, f);\n    rd = normalize( r * vvc.x + vUp * vvc.y + f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tq = uv * 2.0 - 1.0;\n\tq.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.0); \n\n    \n    \n    float nRotate = iTime *0.05; \n\n    float h  = PI * (m.x - nRotate);\n    float e  = mix(0.0, 2.5, m.y); \n    float d  = 17.0; // eye distance\n\n    // ro RayOrigin\n    ro  = vec3(sin(h) * cos(e), 0.1, cos(h) * cos(e)) * d;\n    vec3 ta = vec3(0.0, 0.1, 0.0);\n    vec3 rd;\n    camera( ta + ro, ta, fragCoord, rd);\n    rd += ta;\n\tvec3 col = vec3(0.0);\n    vec2 t = intersect(ro,rd);\n    \n\tvec3 F0 = vec3(0.04);\n    F0      = mix(F0, vec3(1.0), metallic);\n    if( t.x>0.0 )\n    {\n    \tvec3 pos = ro+rd*t.x;\n        float d =  max(0.0, 5.0 - t.x)/2.0;\n        normal = calcNormal(pos);\n        vec3 points[3];\n        points[0] = vec3(0.0, 10.0, 10.0);\n    \tpoints[1] = vec3(10.0, 10.0, 10.0);\n    \tpoints[2] = vec3(-10.0, 10.0, 10.0);\n        vec3 light = vec3(0.0);\n        float idc = t.y;\n        for(int i = 0; i < 3 ; ++i)\n        {\n        \tlight += lighting(normal, vec3(points[i]).rgb, pos, idc);\n        }\n        \n    \tvec3 vd = normalize(ro - pos);\n    \tfloat ff = dot(vd, normal);\n        \n        \n    \tvec3 ibl = texture(iChannel0, normalize(reflect(vd, normal)), 0.0).rgb * max(1.0-ff, 0.1);\n    \tibl += texture(iChannel0, normalize(refract(vd, -normal, 1.05)), 0.0).rgb * ff;\n        \n\t\tvec3 IBL = ibl*metallic;\n        \n        light += IBL;\n        light += vec3(0.1);\n        \n        col = light;\n    }\n    else\n        col = texture(iChannel0, -rd).rgb;\n    \n    //col = col / (col + vec3(1.0));\n    \n   // col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}