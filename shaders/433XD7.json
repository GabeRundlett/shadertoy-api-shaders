{
    "Shader": {
        "info": {
            "date": "1719405064",
            "description": "Assorted solids and text. Trying to find faster rotations (frame rate more than golfing).\nAn SDF for text?  WIP",
            "flags": 0,
            "hasliked": 0,
            "id": "433XD7",
            "likes": 3,
            "name": "Partially Platonic",
            "published": 3,
            "tags": [
                "text",
                "platonic",
                "solids"
            ],
            "usePreview": 0,
            "username": "dray",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\n\n#define max3(V) max((V).x,max((V).y,(V).z))\n#define min3(V) min((V).x,min((V).y,(V).z))\n#define minabs(A,B) min(abs(A),abs(B))\n#define minabs3(V) min(abs((V).x),minabs((V).y,(V).z))\n\n\n#define MARGIN .1\n\n// Taylor series of cosinus and sinus\t\n#define COS(T) ( 1.0 - (T)*(T)*.5 )\n#define SIN(T) ( (T) - (T)*(T)*(T)**.167 )\n\n\n\n\n#define COST(T) (abs(fract(T)*4.-2.)-1.)\n#define SINT(T) COST((T)+.25)\n#define xROTT(V,T) vec2( (V).x*COST(T) + (V).y*SINT(T), (V).y*COST(T) - (V).x*SINT(T) )\n\n#define ROTT(V,T) vec2( (V).x*cos(T) + (V).y*sin(T), (V).y*cos(T) - (V).x*sin(T) )\n\n#define ROTATE \\\n    rot *= iTime*1.5; \\\n    /*p.xz = ROTT((p.xz),rot.z);*/ \\\n    p.xy = ROTT((p.xy),rot.x); \\\n    p.yz = ROTT((p.yz),rot.y); \\\n\n\n// 3d rotate P on axis A by angle a : https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define rot3d(P,A,a)  ( mix( dot(P,A)*A , P, cos(a) ) + sin(a)*cross(P,A)  )\n#define ROT3d(PT,AXIS,ANG)   cos(ANG)*(PT)\n\n#define xROTATE \\\n    rot *= iTime; \\\n    p.xz *= mat2(cos(rot.z+vec4(0,11,33,0))); \\\n    p.xy *= mat2(cos(rot.x+vec4(0,11,33,0))); \\\n    p.yz *= mat2(cos(rot.y+vec4(0,11,33,0))); \\\n\n#define zROTATE \\\np *= rotationMatrix(5.*sin(vec3(rot.x,rot.y,rot.z)+iTime),iTime);\n\n#define jROTATE \\\n    p = rot3d(p,rot,0.);\n\n\n\nvec2 rot2d(vec2 inp,float ang) {\n  float s = sin(ang);\n  float c = cos(ang);\n  return vec2( inp.x * c + inp.y * s, inp.y * c - inp.x * s ); \n}\n\n    \nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    //http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// originally https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Rotate-About-A-Node.html\nvec3 RotateAboutA(vec3 I,vec3 A,float R)\n{\n    float s = sin(R);\n    float c = cos(R);\n    float h = 1.0 - c;\n\n    A = normalize(A);\n\n    float xx = A.x*A.x;\n    float yy = A.y*A.y;\n    float zz = A.z*A.z;\n    \n    float xy = A.x*A.y;\n    float yz = A.y*A.z;\n    float zx = A.z*A.x;\n    \n    float xs = A.x*s;\n    float ys = A.y*s;\n    float zs = A.z*s;\n\n    return I * mat3(\n        h * xx + c,    h * xy - zs,     h * zx + ys,\n        h * xy + zs,   h * yy + c,      h * yz - xs,\n        h * zx - ys,   h * yz + xs,     h * zz + c\n    );\n    \n}\n\n\n\n\n    \n//#define ROTATE    \n\n// sdf of orthogonal box at 0, originally iq https://www.shadertoy.com/view/Xds3zN\nfloat BoxSDF(vec3 p,vec3 orig,vec3 box,vec3 rot)\n{\n    p -= orig;\n    ROTATE\n    vec3 d = abs(p) - box; // everything is symmetrical so just 3 sides need examination\n    return min(max3(d),.0) + length(max(d,.0));\n}\n\n/*\nfloat CubeSDF(vec3 pt,vec3 orig,float siz,float rot1,float rot2) { // orthagonal cube distance\n    vec3 d = abs(pt) - orig;\n    return min(max3(d),.0) + length(max(d,.0));    \n    //float d = length(pt) - siz; // enclosing sphere\n    //if ( d > MARGIN ) return d; // this is less than step size \n    //return minabs3(pt)-siz;\n    //float ang = atan2(pt.x,pt.y);\n    //ang = mod(ang,PI/2.)\n}\n*/\n\nfloat  plane(vec3 p,vec3 origin,vec3 normal){ \n   return dot(p-origin,normal);   \n}\n\n#define Max4(A,B,C,D) max(max(A,B),max(C,D))\n\n// originally https://www.shadertoy.com/view/MtV3Dy\nfloat tetrahedron(vec3 p,float d) {\n    float dn =1./sqrt(3.);\n    //The tetrahedran is the intersection of four planes:\n#if 0\n    float sd1 = plane(p,vec3(d,d,d),vec3(-dn,dn,dn)); \n    float sd2 = plane(p,vec3(d,-d,-d),vec3(dn,-dn,dn));\n    float sd3 = plane(p,vec3(-d,d,-d),vec3(dn,dn,-dn));\n    float sd4 = plane(p,vec3(-d,-d,d),vec3(-dn,-dn,-dn));\n#elif 0\n    float sd1 = dot(p-vec3(d,d,d),vec3(-dn,dn,dn)); \n    float sd2 = dot(p-vec3(d,-d,-d),vec3(dn,-dn,dn));\n    float sd3 = dot(p-vec3(-d,d,-d),vepc3(dn,dn,-dn));\n    float sd4 = dot(p-vec3(-d,-d,d),vec3(-dn,-dn,-dn));\n#elif 0\n    p *= dn;\n    d *= dn;\n    float x1 = p.x - d;\n    float x2 = p.x + d;\n    float y1 = p.y - d;\n    float y2 = p.y + d;\n    float z1 = p.z - d;\n    float z2 = p.z + d;\n    float sd1 = -x1 + y1 + z1;\n    float sd2 =  x1 - y2 + z2;\n    float sd3 =  x2 + y1 - z2;\n    float sd4 = -x2 - y2 - z1;\n#elif 1\n    //p *= dn;\n    //d *= dn;\n/*    \n    float sd1 = d - p.x + p.y - d + p.z - d;\n    float sd2 = p.x - d - p.y - d + p.z + d;\n    float sd3 = p.x + d + p.y - d - p.z - d;\n    float sd4 = -p.x - d - p.y - d + d - p.z;\n*/\n/*\n    float sd1 = -p.x + p.y + p.z - d;\n    float sd2 =  p.x - p.y + p.z - d;\n    float sd3 =  p.x + p.y - p.z - d;\n    float sd4 = -p.x - p.y - p.z - d;\n*/\n    float sd1 = -p.x + p.y + p.z;\n    float sd2 =  p.x - p.y + p.z;\n    float sd3 =  p.x + p.y - p.z;\n    float sd4 = -p.x - p.y - p.z;\n    return (Max4(sd1,sd2,sd3,sd4) - d)/sqrt(3.);\n#endif    \n    //max intersects shapes\n    return Max4(sd1,sd2,sd3,sd4);\n}\n\nfloat TetrahedronSDF(vec3 p,vec3 orig,float d,vec3 rot) {\n    p -= orig;\n    ROTATE\n    return tetrahedron(p,d);\n}\n\nfloat OctahedronSDF(vec3 p,vec3 orig,float d,vec3 rot) {\n    p -= orig;\n    ROTATE\n    //The octahedron is the intersection of two dual tetrahedra.  \n    float a = tetrahedron(p,d);\n    float b = tetrahedron(-p,d);\n    return max(a,b);\n}\n\nfloat  doubleplane(vec3 p, vec3 origin, vec3 normal){ \n   return max(dot(p - origin,normal),dot(-p - origin,normal));   \n}\n\n//Golden mean and inverse -  for the icosohedron and dodecadron\n#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\n#define max6(A,B,C,D,E,F) max(max(max(A,B),max(C,D)),max(E,F))\n\nfloat DodecahedronSDF(vec3 p,float d,vec3 orig,vec3 rot) {\n    p -= orig;\n    ROTATE\n    //Some vertices of the icosahedron.\n    //The other vertices are cyclic permutations of these, plus the opposite signs.\n    //We don't need the opposite sign because we are using double planes - two faces for the price of one. \n    vec3 v = normalize(vec3(0.0,1.0,PHI));\n    vec3 w = normalize(vec3(0.0,1.0,-PHI));\n#if 0    \n    //The dodecahedron is dual to the icosahedron. The faces of one corespond to the vertices of the oyther.\n    //So we can construct the dodecahedron by intersecting planes passing through the vertices of the icosohedran.\n    float ds = doubleplane(p,d*v,v);\n    ds = max(doubleplane(p,d*w,w),ds); \n    ds = max(doubleplane(p,d*v.zxy,v.zxy),ds);\n    ds = max(doubleplane(p,d*v.yzx,v.yzx),ds);\n    ds = max(doubleplane(p,d*w.zxy,w.zxy),ds);\n    ds = max(doubleplane(p,d*w.yzx,w.yzx),ds);\n#elif 0    \n    p = abs(p); // it is symetrical, so skip double plane\n    float d1 = dot(p-d*v,v);\n    float d2 = dot(p-d*w,w); \n    float d3 = dot(p-d*v.zxy,v.zxy);\n    float d4 = dot(p-d*v.yzx,v.yzx);\n    float d5 = dot(p-d*w.zxy,w.zxy);\n    float d6 = dot(p-d*w.yzx,w.yzx);\n    float ds = max6(d1,d2,d3,d4,d5,d6);\n#else\n    p = abs(p);\n    \n    //float d1x = 0.; //p.x*v.x - d*v.x*v.x;\n    float d1y = p.y*v.y - d*v.y*v.y;\n    float d1z = p.z*v.z - d*v.z*v.z;\n    float d1 = d1y + d1z; // dot(p-d*v,v);  \n\n    //float d2x = 0.; //p.x*v.x - d*v.x*v.x;\n    float d2y = p.y*w.y - d*w.y*w.y;\n    float d2z = p.z*w.z - d*w.z*w.z;\n    float d2 =  d2y + d2z; // dot(p-d*w,w);\n    \n    float d3x = p.x*v.z - d*v.z*v.z;\n    //float d3y = 0.; // p.y*v.x - d*v.x*v.x;\n    float d3z = p.z*v.y - d*v.y*v.y;\n    float d3 =  d3x + d3z; // dot(p-d*v.zxy,v.zxy);\n  /*  \n    float d4x = p.x*v.y - d*v.y*v.y;\n    float d4y = p.y*v.z - d*v.z*v.z;\n    float d4z = p.z*v.z - d*v.x.z*v.x;  */\n    float d4 = dot(p-d*v.yzx,v.yzx);\n    float d5 = dot(p-d*w.zxy,w.zxy);\n    float d6 = dot(p-d*w.yzx,w.yzx);\n    float ds = max6(d1,d2,d3,d4,d5,d6);\n#endif\n    return ds;\n} \n\nfloat SphereSDF(vec3 pt,vec3 orig,float siz) {\n    return distance(pt,orig) - siz;\n}\n\nfloat DogSDF(vec3 p,vec3 orig,vec3 siz,vec3 rot) {\n    p -= orig;\n    ROTATE\n    p *= siz;\n    return length(p)-1.;\n}\n\nfloat TextSDF(vec3 p,vec3 orig,float sz,int cha,vec3 rot) {\n    p -= orig;\n    vec3 sv = p;\n    ROTATE\n    vec3 d = abs(p) - vec3(sz*.5,sz*.5,0); // everything is symmetrical so just 3 sides need examination\n    float dst =  min(max3(d),.0) + length(max(d,.0));\n    return dst > .1 || texelFetch( iChannel0, ivec2( (cha&15)<<6, (64*15)-(((cha>>4)&15)<<6)) + ivec2(p*64./sz+32.), 0 ).x > 0. ? dst : .03;\n}\n\n/*\nfloat StrSDF(vec3 p,vec3 orig,float sz,int chas[6],vec3 rot) {\n    p -= orig;\n    ROTATE\n    vec3 d = abs(p) - vec3(sz*.5*6.,sz*.5,0); // everything is symmetrical so just 3 sides need examination\n    float dst =  min(max3(d),.0) + length(max(d,.0));\n    if ( dst > .1 ) return dst;\n    int cha = chas[0];\n    return texelFetch( iChannel0, ivec2( (cha&15)<<6, (64*15)-(((cha>>4)&15)<<6)) + ivec2(p*64./sz+32.), 0 ).x > 0. ? dst : .01;\n}\n*/\n\nvec3 Light;\n\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n\nint depth;\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n    T(SphereSDF(pt,vec3(-15.+cos(iTime),-4.+sin(iTime)*1.,3.+cos(iTime)),2.));\n    T(TextSDF(pt,vec3(-2,-5,7),7.,int(iTime*8.),vec3(.5,.6,.7)));\n    T(DogSDF(pt,vec3(-12,12,40),vec3(.1,.1,.3),vec3(2.2,1.66,2.5)));\n    T(BoxSDF(pt,vec3(1,1,2),vec3(1.5,1.2,2),vec3(1.2,2.66,3.5)));\n    T(BoxSDF(pt,vec3(-4,-1,-3),vec3(3.5,1.2,2),vec3(2.2,1.66,4.5)));\n    T(TetrahedronSDF(pt,vec3(8,-2,4),2.5,vec3(1.2,2.66,3.5)));\n    T(OctahedronSDF(pt,vec3(17,2,5),3.,vec3(2.2,1.66,1.5)));\n    T(TetrahedronSDF(pt,vec3(-8,2,4),2.5,vec3(1.7,2.,1.3)));\n    T(OctahedronSDF(pt,vec3(-17,8,5),6.,vec3(1.2,1.66,1.5)));\n    T(DodecahedronSDF(pt,8.5,vec3(8,-2,30),vec3(1.2,.66,.5)));\n    T(DogSDF(pt,vec3(-12,-8,40),vec3(.3,.1,.3),vec3(1.2,2.4,1.5)));\n    T(TextSDF(pt,vec3(10,10,25),8.,cP,vec3(1.,3.,1.)));\n    T(DogSDF(pt,vec3(23,13,30),vec3(.4,.2,.99),vec3(.6,.7,.5)));\n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 300; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) break;\n        if ( obj.x < .001 ) return vec4( pos, obj.y );\n        /*\n        if ( distance( pos, vec3(25,18,50) ) < 6. )  {\n            //float t = dir.z; dir.z=dir.x; dir.x=t;\n            beg = vec3( 10, 10., -24.);\n            //return vec4( pos, 5 );\n        }\n        */\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\nfloat sqrN(float i,int n)\n{\n  while ( n-- > 0 ) i *= i;\n  return i;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    \n    uv /= 5.;\n    vec4 M = iMouse;\n    vec4 mm = (M+M-R.xyxy)/min(R.x,R.y) * 80.;\n    //vec3 cam = vec3( mm.x, mm.z, mm.y-64.);\n    //vec3 cam = vec3( 0, 0, mm.y-64.);\n    vec3 cam = vec3( 0, 0, -64.);\n    vec3 camdir = normalize( vec3( uv, 1. ) );\n\n    vec4 hit = March( cam, camdir );\n\n    Light = vec3( 0, 10, -10 );\n    vec3 dir = normalize( Light - hit.xyz );\n\n    vec3 norm = Normal(hit.xyz);\n    float difu = dot( norm, dir );\n    difu = .3 + .7*difu;\n    \n    //O = vec4(0);\n    \n    //O = difu/sqrt( sin( vec4(0,21,23,0) + hit.w*.4 ));\n    \n    #define col4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    \n    O = sqrt( col4(hit.w*.4) );\n    O *= difu + sqrN(difu,9);\n    \n    //O = mix( mix(vec4(.1),col4(iTime*10.),.1), O, difu );\n    \n    //O = .5 + .5 * sin( vec4(0,21,23,0) + uv.x * TAU * 2. );\n    //O = col4(uv.x*TAU*2.);\n\n    //O = vec4(texture(iChannel0,U/R.x*2.).x);\n    //O = vec4( texelFetch(iChannel0,ivec2(U)*4+ivec2(64,64)*0,0).x );  // 64x64 chars in 16x16 matrix\n    //int cha = cF;\n    //O = vec4( texelFetch(iChannel0,ivec2((cha&15)<<6,(64*15)-(((cha>>4)&15)<<6)) + ivec2(U)%64,0).x );  // 64x64 chars in 16x16 matrix\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define cSp  32 //\n#define cExcl 33 // !\n#define cDQuot 34 // \"\n#define cHash 35 // #\n#define cDlr 36 // $\n#define cPct 37 // %\n#define cAmp 38 // &\n#define cSQuot 39 // '\n#define cLPar 40 // (\n#define cRPar 41 // )\n#define cAster 42 // *\n#define cPlus 43 // +\n#define cComma 44 // ,\n#define cMinus 45 // -\n#define cPeriod 46 // .\n#define cSlash 47 // /\n#define c0 48 // 0\n#define c1 49 // 1\n#define c2 50 // 2\n#define c3 51 // 3\n#define c4 52 // 4\n#define c5 53 // 5\n#define c6 54 // 6\n#define c7 55 // 7\n#define c8 56 // 8\n#define c9 57 // 9\n#define cColo 58 // :\n#define cSemi 59 // ;\n#define cLss 60 // <\n#define cEql 61 // =\n#define cGtr 62 // >\n#define cQuest 63 // ?\n#define cAt 64 // @\n#define cA 65 // A\n#define cB 66 // B\n#define cC 67 // C\n#define cD 68 // D\n#define cE 69 // E\n#define cF 70 // F\n#define cG 71 // G\n#define cH 72 // H\n#define cI 73 // I\n#define cJ 74 // J\n#define cK 75 // K\n#define cL 76 // L\n#define cM 77 // M\n#define cN 78 // N\n#define cO 79 // O\n#define cP 80 // P\n#define cQ 81 // Q\n#define cR 82 // R\n#define cS 83 // S\n#define cT 84 // T\n#define cU 85 // U\n#define cV 86 // V\n#define cW 87 // W\n#define cX 88 // X\n#define cY 89 // Y\n#define cZ 90 // Z\n#define cLbrack 91 // [\n#define cBslash 92 // \\\n#define cRbrack 93 // ]\n#define cTilde 94 // ^\n#define cUnder 95 // _\n#define cTick 96 // `\n#define ca 97 // a\n#define cb 98 // b\n#define cc 99 // c\n#define cd 100 // d\n#define ce 101 // e\n#define cf 102 // f\n#define cg 103 // g\n#define ch 104 // h\n#define ci 105 // i\n#define cj 106 // j\n#define ck 107 // k\n#define cl 108 // l\n#define cm 109 // m\n#define cn 110 // n\n#define co 111 // o\n#define cp 112 // p\n#define cq 113 // q\n#define cr 114 // r\n#define cs 115 // s\n#define ct 116 // t\n#define cu 117 // u\n#define cv 118 // v\n#define cw 119 // w\n#define cx 120 // x\n#define cy 121 // y\n#define cz 122 // z\n#define cLbrace 123 // {\n#define cBar 124 // |\n#define cRbrace 125 // }\n#define cSquig 126 // ~\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}