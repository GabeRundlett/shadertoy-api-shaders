{
    "Shader": {
        "info": {
            "date": "1554674991",
            "description": "Happy birthday Leon :love:\n\npage 1 : Happy Plant : Lnae \npage 2 : Daily 2017-05-13 : Koltes \npage 3 : Crypt Roots : Leon\npage 4 : Sky Path : NuSan \npage 5 : Etching : LsdLive \n",
            "flags": 32,
            "hasliked": 0,
            "id": "WsBXzy",
            "likes": 2,
            "name": "Shader of a Fazine of shaders",
            "published": 3,
            "tags": [
                "raymarching",
                "book",
                "cookie",
                "fanzine",
                "leon"
            ],
            "usePreview": 0,
            "username": "antonOTI",
            "viewed": 542
        },
        "renderpass": [
            {
                "code": "/*\nHappy birthday Leon <3\n\npage 1: Happy Plant by Lnae - shadertoy.com/view/4ltyD4\npage 2: Daily 2017-05-13 by Koltes - shadertoy.com/view/Md2yDd\npage 3: Crypt Roots by Leon - shadertoy.com/view/wdXSWn\npage 4: Sky Path by NuSan - shadertoy.com/view/3sBGzV\npage 5: Etching by LsdLive - shadertoy.com/view/tsfSWr\n*/\n\n\n// from http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nfloat HammersleyDistribution(uint bits) \n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley2d(uint i, uint N)\n{\n    return vec2(float(i) / float(N), HammersleyDistribution(i));\n}\n\n#define INF 60.\n#define time (iTime * .5)\n#define PI 3.14159\n#define HPI 1.57079\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n\n  return mat2(ca, -sa, sa ,ca);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n#define ADD(other) dist = min(dist, other)\nvec3 puv = vec3(0.);\n\nconst float closed = PI * .9;\nconst float open = .125;\nconst float diff = closed - open;\n\nfloat map(vec3 p)\n{\n \tfloat dist = 1000.;\n    \n\tp.xz *= rot(sin(iTime * .1));\n \tp.yz *= rot(PI * .5);\n    \n  vec3 cp = p; \n    \n  vec3 pageBox = vec3(4.,.025,4. * iResolution.y / iResolution.x);\n\n  float ins = smoothstep(-.125,.125,p.x);\n  float angle = -open;\n  p.xy *= rot(angle * ins - angle *.5);\n    \n    \n  float page = sdBox(p, pageBox);  \n\n  ADD(page);\n\n  if(page < .01)\n  {\n    puv.xy = (p.xz / pageBox.xz ) * .5 + .5;\n\n    if(p.y < 0.)\n    { \n      puv.z = 1.;\n    }\n    else\n    {\n      if(p.x < 0.)\n      {\n        puv.z = 2.;\n        puv.x = -puv.x + 2.;\n      }\n      else\n      {\n        puv.z = 6.;\n        puv.x *= -1.;\n      }\n    }\n  }\n\n  p = cp;\n    \n  p.y -= .02;\n  angle -= (sin(time * .5) * .7 + .8);\n  \n  p.xy *= rot(angle * ins - angle *.5);\n  page = sdBox(p, pageBox);  \n  ADD(page);\n\n  if(page < .01)\n  {\n    puv.xy = (p.xz / pageBox.xz ) * .5 + .5;\n\n    if(p.y < 0.)\n    { \n      if(p.x < 0.)\n      {\n        puv.z = 2.;\n        puv.x = puv.x + 1.;\n      }\n      else\n      {\n        puv.z = 6.;\n        puv.x =puv.x -1.;\n      }\n    }\n    else\n    {\n      if(p.x < 0.)\n      {\n        puv.z = 3.;\n        puv.x = puv.x  - 1.;\n      }\n      else\n      {\n        puv.z = 5.;\n        puv.x = -puv.x  + 3.;\n      }\n    }\n  }\n\n\n  p = cp;\n  p.y -= .02;\n  angle -= (sin(time * .25) * .7 + .8);\n  \n  p.xy *= rot(angle * ins - angle *.5);\n  page = sdBox(p, pageBox);  \n\n\n  ADD(page);\n  if(page < .01)\n  {\n    puv.xy = (p.xz / pageBox.xz ) * .5 + .5;\n    if(p.y < 0.)\n    { \n      if(p.x < 0.)\n      {\n        puv.z = 3.;\n        puv.x *= -1.;\n      }\n      else\n      {\n        puv.z = 5.;\n        puv.x = puv.x +2.;\n      }\n    }\n    else\n    {\n      puv.z = 4.;\n        puv.x = puv.x +2.;\n    }\n  }\n  \n  return dist;\n}\n\nvec3 normal(vec3 p, float cd)\n{\n    vec2 e = vec2(.01,.0);\n    return normalize(vec3(cd - map(p + e.xyy),\n                    cd - map(p + e.yxy),\n                    cd - map(p + e.yyx)));\n}\n\nvoid ray(inout vec3 cp, in vec3 rd, out float st, out float cd)\n{\n  for(; st < 1.; st += 1./200.)\n  {\n    cd = map(cp);\n    if(cd < .01 || cd > INF)\n    {\n      break;\n    }\n    \n    cp += rd * cd * st ;\n  }\n}\n\nvec3 lookAt(vec3 cp, vec3 tp, vec2 uv)\n{\n  vec3 fd = normalize(tp - cp);\n  vec3 ri = cross(fd, vec3(0.,1.,0.));\n  vec3 up = cross(ri, fd);\n  return normalize(fd + ri * uv.x + up * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 subject = vec3(0.);\n  vec2 lookP = iMouse.xy / iResolution.xy * PI * 2. - 1.;\n    \n  vec3 eye = vec3(10. * cos(lookP.x), lookP.y * 10.,-10. * sin(lookP.x ));\n  vec3 rd = lookAt(eye, subject, uv);\n  vec3 cp = eye;\n  float st;\n  float cd;\n  ray(cp, rd, st, cd);\n\n  vec3 col = mix(vec3(.8,.8,.81), vec3(1.,1.,.95), sin(length(uv * .8) * PI - PI * .5));\n  if(cd < .01)\n  {\n      col = vec3(0.);\n      vec3 norm = normal(cp, cd);\n      float ins = dot(norm, normalize(eye - subject)) * .01;\n      // ins = fwidth(ins);\n      const uint N = 32u;\n      \tfor(uint i= 0u; i < N; ++i)\n        {\n\t      \tvec3 suv = puv;\n        \n            suv.xy += hammersley2d(i, N) * ins;\n            \n          if(suv.z == 1.)\n          {\n              col += texture(iChannel3, suv.xy).rgb * (1. - st);\n          }\n          else if(puv.z == 2.)\n          {\n              suv.x -= 1.;\n              suv.x *= .5;\n              col += texture(iChannel2, suv.xy).rgb * (1. - st);\n          }\n          else if(puv.z == 3.)\n          {\n              suv.x += 1.;\n              suv.x *= .5;\n              col += texture(iChannel1, suv.xy).rgb * (1. - st);\n          }\n          else if(puv.z == 4.)\n          {\n              suv.x -= 1.;\n              suv.x *= .5;\n              col += texture(iChannel0, suv.xy).rgb * (1. - st);\n          }\n          else if(puv.z == 5.)\n          {\n              suv.x -= 1.;\n              suv.x *= .5;\n              col += texture(iChannel1, suv.xy).rgb * (1. - st);\n          }\n          else if(puv.z == 6.)\n          {\n              suv.x += 1.;\n              suv.x *= .5;\n              col += texture(iChannel0, suv.xy).rgb * (1. - st);\n          }\t\n      }\n      \n      col /= float(N);\n  }\n\n//  fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n  fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n\n\n#define PI 3.14159\n\n#define REP(p, r) (mod(p + r/2.,r) - r/ 2.)\n\n#define TIME (iTime + 91.8)\n\n// Shader By Leon from :\n// https://www.shadertoy.com/view/wdXSWn\n\n\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot (float a) { float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = 0.5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 3.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward + right * anchor.x + up * anchor.y);\n}\nvoid moda(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map (vec3 pos) {\n  float chilly = noise(pos * 2.);\n  float salty = fbm(pos*20.);\n  \n  pos.z -= salty*.04;\n  salty = smoothstep(.3, 1., salty);\n  pos.z += salty*.04;\n  pos.xy -= (chilly*2.-1.) * .2;\n    \n  vec3 p = pos;\n  vec2 cell = vec2(1., .5);\n  vec2 id = floor(p.xz/cell);\n  p.xy *= rot(id.y * .5);\n  p.y += sin(p.x + .5);\n  p.xz = repeat(p.xz, cell);\n    \n  vec3 pp = p;\n  moda(p.yz, 5.0);\n  p.y -= .1;\n  float scene = length(p.yz)-.02;\n    \n  vec3 ppp = pos;\n  pp.xz *= rot(pp.y * 5.);\n  ppp = repeat(ppp, .1);\n  moda(pp.xz, 3.0);\n  pp.x -= .04 + .02*sin(pp.y*5.);\n  scene = smoothmin(length(pp.xz)-.01, scene, .2);\n\n  p = pos;\n  p.xy *= rot(-p.z);\n  moda(p.xy, 8.0);\n  p.x -= .7;\n  p.xy *= rot(p.z*8.);\n  p.xy = abs(p.xy)-.02;\n  scene = smoothmin(scene, length(p.xy)-.005, .2);\n\n  return scene;\n}\n\nvec3 getNormal (vec3 pos) {\n  vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n  return normalize( e.xyy*map( pos + e.xyy ) + e.yyx*map( pos + e.yyx ) + e.yxy*map( pos + e.yxy ) + e.xxx*map( pos + e.xxx ) );\n}\n\nvoid shaderLeon( out vec4 fragColor, in vec2 fragCoord , in vec2 resolution)\n{\n  vec2 uv = (fragCoord.xy-0.5*resolution.xy)/resolution.y;\n  vec3 eye = vec3(.1,.1,-iTime*.1-4.);\n  vec3 at = vec3(0,0,eye.z-2.0);\n  vec3 ray = look(eye, at, uv);\n  vec3 pos = eye;\n  float dither = random(uv+fract(iTime));\n  float total = dither * .2;\n  float shade = 0.0;\n  const float count = 60.0;\n  for (float index = count; index > 0.0; --index) {\n    pos = eye + ray * total;\n    float dist = map(pos);\n    if (dist < 0.001 + total * .003) {\n      shade = index / count;\n      break;\n    }\n    dist *= 0.5 + 0.1 * dither;\n    total += dist;\n  }\n  vec3 normal = getNormal(pos);\n  vec3 color = vec3(0);\n  color += smoothstep(.3, .6, fbm(pos*100.)) * .2;\n  color += vec3(0.839, 1, 1) * pow(clamp(dot(normal, normalize(vec3(0,2,1))), 0.0, 1.0), 4.);\n  color += vec3(1, 0.725, 0.580) * pow(clamp(dot(normal, -normalize(pos-at)), 0.0, 1.0), 4.);\n  color += vec3(0.972, 1, 0.839) * pow(clamp(dot(normal, normalize(vec3(4,0,1))), 0.0, 1.0), 4.);\n  color += vec3(0.972, 1, 0.839) * pow(clamp(dot(normal, normalize(vec3(-5,0,1)))*.5+.5, 0.0, 1.0), 4.);\n  color = mix(vec3(0), color, clamp(dot(normal, -ray), 0.0, 1.0));\n  color *= pow(shade, 1.0/1.2);\n  fragColor = vec4(color, 1);\n}\n\n// By Lnae From :\n// https://www.shadertoy.com/view/4ltyD4\n\n#define PHI 1.618\n#define STEPS 50.\n#define EPS 0.00001\n#define EPSN 0.001\n#define EPSOUT 0.008\n#define NB_LEAVES 16.\n\n\nfloat hash31(vec3 p){\n\treturn fract(123456.789 * sin(dot(p, vec3(12.34, 56.78, 91.01))));\n}\n\nfloat smoothmin2(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * (a - b) / k, 0., 1.);\n    return mix(a, b, f) - k * f * (1. - f);\n}\n\nfloat smoothmax(float a, float b, float k){\n\treturn -smoothmin2(-a, -b, k);\n}\n\nfloat smoothabs(float p, float k){\n\treturn sqrt(p * p + k * k) - k;\n}\n\n\nfloat noise31(vec3 p){\n\tvec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    vec3 c = floor(p);\n  \n    return mix(mix(mix(hash31(c), hash31(c + vec3(1., 0., 0.)), f.x),\n               \t   mix(hash31(c + vec3(0., 1., 0.)), hash31(c + vec3(1., 1., 0.)), f.x),\n               \t   f.y),\n               mix(mix(hash31(c + vec3(0., 0., 1.)), hash31(c + vec3(1., 0., 1.)), f.x),\n               \t   mix(hash31(c + vec3(0., 1., 1.)), hash31(c + vec3(1., 1., 1.)), f.x),\n               \t   f.y),\n               f.z);  \n}\n\nfloat fbm31(vec3 p){\n\tvec3 pos = 10. * p;\n    float c = 0.5;\n    float res = 0.;\n    for(int i = 0; i < 4; i++){\n        pos.xy = rot(2.) * pos.xy;\n        pos = pos * 2. + 2.;\n    \tres += c * noise31(pos);\n        c /= 2.;\n    }\n    return res;\n}\n\nfloat distLeaf(vec3 pos, float angle, float size, out float color){\n    float radius = size;\n    float c = 0.95 * radius;\n    pos.xy = rot(angle) * pos.xy;\n\n    //main part\n    pos.y -= 0.02;\n    pos.x -= 0.25 * radius;\n    pos.z = smoothabs(pos.z, 0.0075);\n\tpos.y = -abs(pos.y);\n    float dist = length(pos - vec3(0., c, -0.05)) - radius;\n    \n    //color\n    float r = length(pos.xz) / radius;\n    color = 0.5 + 0.5 * cos(12. * r);\n    \n    //tip\n    pos.x -= 0.175 * radius;\n    pos.z += 0.45 * c;\n   \treturn smoothmin2(dist, length(pos - vec3(0., c, 0.)) - (radius * 1.05), 0.005);\n}\n\nfloat distScene(in vec3 pos, out int object, out float colorVariation){\n    \n    pos.yz = rot(0.5 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;\n    pos.xz = rot(0.25 * iTime) * pos.xz;\n    pos.y += 0.2;\n    \n    float f = noise(100. * pos);\n    float sf = smoothstep(0.4, 0.5, f);\n    \n    //floor\n    float dist = pos.y;\n    object = 0;\n    colorVariation = 0.;\n    \n    //pot\n    vec3 p = pos;\n    p.y -= 0.155;\n    float distPot = length(p) - 0.2;\n    distPot = smoothmax(distPot, p.y - 0.097, 0.01);\n    distPot = smoothmax(distPot, -(length(p) - 0.18), 0.01);\n    distPot = max(distPot, -(p.y + 0.15));\n    dist = min(dist, distPot);\n    \n    if(dist == distPot){\n        object = 1;\n        float angle = atan(p.z, p.x);\n        colorVariation = 0.9 * smoothstep(0.2, 0.35, 0.5 * sin(3. * sin(20. * angle)) + 0.4 * (f - 0.5)) + 0.1 * sf;\n    }\n    \n    //ground\n    float distGround = max(p.y - 0.06 + 0.01 * (noise(150. * p) - 0.5), length(p) - 0.18);\n    dist = min(dist, distGround);\n    \n    if(dist == distGround){\n        object = 2;\n        colorVariation = 0.;\n    }\n    \n\t//plant\n    p = pos;\n    p.y -= 0.2;\n    float distPlant = 100.;\n    float anim = 0.05 * (0.5 + 0.5 * sin(5. * iTime));\n    float leafAngle = 1.2;\n    float offset = 0.01;\n    float size = 0.2;\n    float leafRot = 2. * PI / PHI;\n    float leafColor, lc, d;\n    \n    for(float i = 0.; i < NB_LEAVES; i++){\n        p.xz = rot(leafRot) * p.xz;\n        leafAngle *= 0.92;\n        size *= 1.04;\n        offset += 0.002;\n        d = distLeaf(p - vec3(offset, 0., 0.), leafAngle + anim, size, lc);\n        distPlant = min(distPlant, d); \n        if(d == distPlant) leafColor = lc;\n    }\n    dist = min(dist, distPlant);\n    \n    if(dist == distPlant){\n        object = 3;\n        colorVariation = 0.8 * smoothstep(0.75, 0., leafColor + 0.4 * f) + 0.2 * sf;\n    }\n               \n    return dist;\n\n}\n\nvec3 getNormal2(vec3 p){\n    float c;\n    int o;\n\treturn normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o, c) - distScene(p - vec3(EPSN, 0., 0.), o, c),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.), o, c) - distScene(p - vec3(0., EPSN, 0.), o, c),\n                          distScene(p + vec3(0., 0., EPSN), o, c) - distScene(p - vec3(0., 0., EPSN), o, c)));\n}\n\nvec3 render(vec2 uv){\n    \n    vec3 inkColor = vec3(0.15, 0.25, 0.4);\n    vec3 col = inkColor;\n    \n    //raymarch\n    vec3 eye = vec3(0., 0., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    int o;\n    float dist, step, c, prevDist;\n    bool hit = false;\n    vec3 pos = eye;\n    dist = distScene(pos, o, c);\n    float outline = 1.;\n    \n    for(step = 0.; step < STEPS; step++){\n        prevDist = dist;\n    \tdist = distScene(pos, o, c);\n        if(dist > prevDist + EPS && dist < EPSOUT ){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n    \tpos += dist * ray;\n    }\n    outline /= EPSOUT;\n    \n    vec3 normal = getNormal2(pos);\n    float f = fbm31(pos);\n    \n    //shading\n    if(hit){\n    \tvec3 light = vec3(5., 5., 5.);\n        light.yz = rot(0.5) * light.yz;\n        float shine = 30.;\n        \n        //paper\n        if(o == 0){\n        \tcol = 1. - 0.025 * vec3(smoothstep(0.6, 0.2, fbm31(vec3(uv * 6.,1.))));\n        }\n        //pot\n        if(o == 1) col = mix(vec3(0.6, 0.6, 0.85), vec3(1.), 0.8 * c);\n        if(o == 2) col = vec3(0.6, 0.6, 0.6);\n        //plant\n        if(o == 3) {\n            col = mix(vec3(0.55, 0.86, 0.75), vec3(0.96, 0.6, 0.85), c);\n\t\t\tshine = 5.;\n        }\n        \n        //diffuse\n        vec3 l = normalize(light - pos);\n        float diff = dot(normalize(normal + 0.2 * vec3(f - 0.5)), l);\n        diff = smoothstep(0.4, 0.5, diff + 0.3 * f);\n        if(o != 0) col = mix(col, vec3(0.1, 0.3, 0.75), 0.3 * (1. - diff));\n        \n        //specular\n        vec3 refl = reflect(-l, normal);\n        float spec = pow(dot(normalize(eye - pos), refl), shine);\n        spec = smoothstep(0.5, 0.6, spec + 0.5 * f);\n        col += 0.01 * shine * spec;\n        \n        //outline\n        outline = smoothstep(0.75, 0.95, outline + 0.9 * f);\n        col = mix(inkColor, col, outline);\n    }  \n    return col;\n}\n\nvoid shaderLnae( out vec4 fragColor, in vec2 fragCoord, vec2 resolution )\n{\n    vec2 uv = (fragCoord - 0.5 * resolution.xy) / resolution.x;\n    uv.x = abs(uv.x);\n    uv.x -= .12;\n    uv *= 3.;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    vec2 resolution = iResolution.xy;\n    resolution.x *= 2.;\n    \n    fragCoord.x *= 2.;\n    \n    if(fragCoord.x < iResolution.x)\n    {\n        fragCoord.x += iResolution.x * .5;\n\n        shaderLnae(fragColor, fragCoord, resolution);\n    }\n    else\n    {\n        fragCoord.x -= iResolution.x * .5;\n    \tshaderLeon(fragColor, fragCoord, resolution);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// by NuSan from :\n// https://www.shadertoy.com/view/3sBGzV\n\n#define MARCH_STEPS 100\n#define time (iTime * .125)\nfloat PI = acos(-1.0);\n\nfloat box(vec3 p, vec3 s) {\n\n  vec3 ap=abs(p)-s;\n  return length(max(vec3(0),ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.6)*0.7;\n  off.x += sin(p.z*0.17)*1.5;\n\n  off.y += cos(p.z*0.27)*0.5;\n  off.y += cos(p.z*0.34)*0.25;\n  return off;\n}\n\nfloat stair(vec3 p, float s1, float s2) {\n\n  p.z = (fract(p.z/s1-0.5)-0.5)*s1;\n  p.yz *= rot(PI*0.25);\n  float b = box(p, vec3(s2,s1,s1));\n\n  return b;\n}\n\nfloat map(vec3 p) {\n\n  float rep = 10.0;\n  p.y -= max(0.0,abs(p.x)-10.0)*0.3;\n  p.x = (fract(p.x/rep-0.5)-0.5)*rep;\n  \n  p += tunnel(p);\n\n  vec3 rp = p;\n  float boxrep = 10.0;\n  rp.z = (fract(rp.z/boxrep-0.5)-0.5)*boxrep;\n\n  vec3 rp2 = p;\n  float boxrep2 = 1.0;\n  rp2.x=abs(rp2.x)-0.4;\n  rp2.z = (fract(rp2.z/boxrep2-0.5)-0.5)*boxrep2;\n\n  float b = box(rp + vec3(0,-9,0), vec3(0.6,10.5,0.6));\n  vec3 rp3 = rp + vec3(0,1.5,0);\n  rp3.xy *= rot(PI*0.3);\n  rp3.yz *= rot(PI*0.3);\n  float b2 = box(rp3, vec3(0.7));\n  b2 = max(b2, p.y+1.5);\n  b = min(b, b2);\n\n  \n\n  float st = stair(p, 0.1, 0.4);\n  float st2 = stair(p + vec3(0,0.7,0), 0.6, 0.4);\n\n  b = max(b, -st2);\n\n  float c = box(rp2 + vec3(0,0.3,0), vec3(0.05,0.3,0.2));\n  rp2.y = abs(rp2.y + 0.43)-0.1;\n  c = min(c, box(rp2, vec3(0.03,0.03,1.0)));\n  \n  \n\n  return min(c,min(b, st));\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*723.588+uv.yx*413.877),vec2(9865.535)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*435.232)*7412.223);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)),rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 10.0));\n}\n\nfloat curve2(float t, float d) {\n  float g=t/d;\n  float ig = floor(g);\n  float fg = fract(g);\n  fg = smoothstep(0.0,1.0,fg);\n  fg = pow(fg,rnd(ig)*2.0+0.5);  \n  //fg = smoothstep(0,1,fg);\n  return (ig+fg)*d;\n}\n\nvoid shaderNuSan( out vec4 fragColor, in vec2 fragCoord , in vec2 resolution)\n{\n  vec2 uv = vec2(fragCoord.x / resolution.x, fragCoord.y / resolution.y);\n  uv -= 0.5;\n  uv /= vec2(resolution.y / resolution.x, 1);\n\n  float rand=rnd(uv);\n  float dither = 0.8+0.1*rand;\n\n  vec3 s=vec3(0,-1,0);\n  vec3 t=vec3(0,-0.3,3);\n  vec3 tar=vec3(0,-0.7,3);\n\n  float motion = curve2(time*1.5, 0.8)*3.0;\n  s.z += motion;\n  t.z += motion;\n  //tar.z += time*1.5*3.0;// + pow(curve(time, 0.7),2)*5.0;\n  float offset = 15.0;\n  tar.z += (curve2(time*1.5-offset, 1.1)+offset)*3.0 + pow(curve(time, 0.9),3.0)*5.0;\n\n  s-=tunnel(s);\n  vec3 offt = tunnel(t);\n  t-=offt;\n  tar-=tunnel(tar);\n\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz, vec3(0,1,0) - offt*0.2));\n  vec3 cy=normalize(cross(cz,cx));\n\n  vec3 r = normalize(cx*uv.x + cy*uv.y + cz*(0.7+sin(time*2.0)*0.4));\n  \n  vec3 col = vec3(0);\n  vec3 l = normalize(vec3(-0.7,-1.0,-0.5));\n\n  vec3 back = mix(vec3(0.1,0.3,1.0)*0.1, vec3(1.0,0.3,0.5)*0.5, pow(r.y*0.5+0.5,2.0));\n\n  vec3 p = s;\n  float dd=0.0;\n  int i=0;\n  float at=0.0;\n  float at2 = 0.0;\n  for(i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p) * dither;\n    if(d<0.001) {\n      vec3 n=norm(p);\n      float fog = clamp(1.0-dd*0.018, 0.0, 1.0);\n      float bot = pow(clamp(-(p.y-10.0)*.1,0.0,1.0),2.0)*fog;\n\n      float aodist = 0.3;\n      float ao = clamp(map(p+n*aodist)/aodist,0.0,1.0);\n      ao = mix(ao,1.0,0.3);\n      \n      float f = pow(1.0-dot(n,-r), 2.0);\n      col += vec3(0.3,0.4,0.7)*max(0.0, dot(n,l)) * bot * ao;\n      col += 4.0*f * back*2.0 * (-n.y*0.5+0.5) * bot*ao;\n\n      dd = mix(100.0, d, bot);\n      \n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=d*r;\n    dd+=d;\n\n    at += exp(-length(tar-p)*7.0);\n    at2 += exp(-d*0.1)*0.05;\n  }\n  if(i>99) dd=100.0;\n\n  col += vec3(1,0.3,0.5) * at * 3.3;\n  col += vec3(1,0.3,0.5) * at2 * 0.2;\n  col += back*0.05 * exp(dd*0.05);\n\n\n  fragColor = vec4(col, 1);\n}\n\n// By Koltes from :\n// https://www.shadertoy.com/view/Md2yDd\n\n#define TAU 6.2831853\n#define INF 10.\n\nconst vec3 GREEN=vec3(0.098, 0.588, 0.011);\nconst vec3 PINK=vec3(1, 0.058, 0.247);\n\nstruct M{float d;vec3 c;};M m;\nM mmin(M a, M b){if(a.d<b.d)return a;else return b;}\nM mmax(M a, M b){if(a.d>b.d)return a;else return b;}\n\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat amod(float a,float m){return mod(a,m)-m*.5;}\n\nfloat random(float x){return fract(sin(x*136.+4375.));}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat leaf(vec3 p, float rmax){\n    const float amax=1.;\n    float a=atan(p.z,p.x);\n    float r=cos(a/amax*TAU*.25)*rmax;\n    float d=max((abs(a)-amax)*r, length(p.xz)-r);\n    d=max(d,abs(p.y+pow(p.x,2.)*.2+exp(-abs(p.z)*5.*exp(-length(p.xz)*5.))*.2)-.01);\n    return d;\n}\n\nvoid map2(vec3 p){\n    p.xz*=rz2(TAU*.25+sin(iTime*.2)*.5);\n    p.xy*=rz2(.8);\n    p.xz*=rz2(iTime*.5);\n    float l=length(p.xz);\n    float at=atan(p.z,p.x);\n\n    float d=INF;\n    \n    for(int ri=0;ri<15;++ri){\n        float RATIO=float(ri)/15.;\n        float ANGLE=random(float(ri))*TAU;\n        float SPANANGLE=2.0-RATIO*1.;\n        float RADIUS=.1+.6*RATIO;\n        float HEIGHT=mix(.8,1.,sqrt(RATIO));\n        float OPENING=mix(-.1,.5,RATIO);\n        \n    \tfloat a=amod(at-ANGLE,TAU);\n        float dr=min(d,(abs(a)-SPANANGLE)*l);\n        float r=atan(p.y*5.)*4./TAU*RADIUS;\n        r+=smoothstep(HEIGHT-.5,HEIGHT+.5,p.y)*OPENING*RADIUS;\n        dr=max(dr,-length(p.xz)+r);\n        dr=max(dr,length(p.xz)-r-.02);\n        dr=max(dr,max(p.y-HEIGHT+pow(a,2.)*.2,0.));\n        d=min(d,dr);\n    }\n    \n    d=max(d,max(-p.y,0.));\n    M mleaves=M(d,PINK);\n    \n    d=length(p.xz)-exp(-pow(p.y-0.3,2.)*10.)*.3;\n    d=max(d,-p.y-.2);\n    d=smin(d,length(p.xz-vec2(pow(p.y+.2,2.)*.2,0.))-.03,.02);\n    d=max(d,p.y-.2);\n    d=max(d,-p.y-2.);\n    \n    for(int li=0;li<5;++li){\n        float RATIO=float(li)/5.;\n        vec3 q=p;\n        q.x-=pow(q.y+.2,2.)*.2;\n        q.y+=.4+float(li)*.3+random(float(li))*.05;\n        q.yz*=rz2(-(p.y+.2)*.2);\n        q.xz*=rz2(fract(sin(float(li)*13.+45.))*TAU);\n        d=smin(d,leaf(q,.5+RATIO*.3),.08);\n    }\n    \n    M mbulb=M(d,GREEN);\n    \n    m=mmin(mleaves,mbulb);\n}\n\nvoid shaderKoltes( out vec4 fragColor, in vec2 fragCoord , in vec2 resolution)\n{\n\tvec2 uv = fragCoord.xy / resolution.xy;\n    vec2 v=uv*(1.-uv);\n    uv-=.5;\n    uv.x*=resolution.x/resolution.y;\n    uv.x = abs(uv.x);\n    uv.x -= .45;\n    \n    vec3 ro=vec3(uv,-2),rd=vec3(uv,1),mp=ro;\n    int i;\n    for(i=0;i<50;++i){map2(mp);if(m.d<.001)break;mp+=rd*.5*m.d;}\n    float ma=1.-float(i)/50.;\n    vec3 c=m.c;\n    c*=ma;\n    if(length(mp)>INF){\n        c=vec3(0.058, 1, 0.631)*.2;\n    }\n    c=pow(c,vec3(1./2.2));\n    c *= pow(v.x*v.y * 25.0, 0.25);\n\tfragColor = vec4(c, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    vec2 resolution = iResolution.xy;\n    resolution.x *= 2.;\n    \n    fragCoord.x *= 2.;\n    if(fragCoord.x < iResolution.x)\n    {\n        fragCoord.x += iResolution.x * .5;\n\n        shaderNuSan(fragColor, fragCoord, resolution);\n    }\n    else\n    {\n        fragCoord.x -= iResolution.x * .5;\n    \tshaderKoltes(fragColor, fragCoord, resolution);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\nfrom https://www.shadertoy.com/view/tsfSWr\n@lsdlive\nCC-BY-NC-SA\n\nStatic image generated with sphere-tracing algorithm for the printed Cookie Fanzine #001.\nhttps://twitter.com/CookieDemoparty/status/1098933599817089025\n\nYou can use the mouse to explore this shader.\n\n\nGeometries are generated with sphere-tracing algorithm:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nMore about triplanar mapping:\nhttps://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/\n\nSome notation:\nro: ray origin\np: position (usually in world space)\nn: normal\nrd: ray direction from eye to position on the surface (eye or view vector)\nld: light direction\n\n*/\n\n// Put this to 3, slow down the GPU, but give better results,\n// mainly because of the use of non-screenspace dithering.\nconst int ANTIALIAS = 1;\n\n#define luma(c) (c.r * .299 + c.g * .587 + c.b * .114)\n\nvec3 palette(float x) {\n\treturn mix(\n\t\tmix(vec3(.009, .01, .042), vec3(.55, .42, .53), smoothstep(.23, .4, x)),\n\t\tmix(vec3(.83, .81, .88), vec3(.93, .88, .93), smoothstep(.44, .5, x)),\n\t\tx\n\t);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\t// Explained here why you still get an anti-clockwise rotation with this matrix:\n\t// https://www.shadertoy.com/view/wdB3DW\n\treturn mat2(c, s, -s, c);\n}\n\nvoid apply_transform(inout vec3 p) {\n\t\tp.xz *= r2d(2.8);\n}\n\nvec3 re(vec3 p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\nvoid amod2(inout vec2 p, float d) {\n\t// should be atan(p.y, p.x) but I had this function for a while\n\t// and putting parameters like this add a PI/6 rotation.\n\tfloat a = re(vec3(atan(p.x, p.y)), d).x; \n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp = abs(p) - d;\n\tif (p.y > p.x)p = p.yx;\n}\n\n// chamfer minimum from hglib\n// http://mercury.sexy/hg_sdf/\nfloat cmin(float a, float b, float k) {\n\treturn min(min(a, b), (a - k + b) * sqrt(.5));\n}\n\n// signed cross\nfloat sc(vec3 p, float s) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - s;\n}\n\n// octahedron\nfloat od(vec3 p, float s) {\n\treturn dot((p), normalize(sign(p))) - s;\n}\n\n// box\nfloat box(vec3 p, vec3 b) {\n\tb = abs(p) - b;\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\n}\n\nfloat de(vec3 p) {\n\tapply_transform(p);\n\n\n\tp.xy *= r2d(3.14 / 2.);\n\n    \n    // Plane in the background\n\tvec3 q = p;\n\tp.xy *= r2d(3.14 / 4.);\n\tfloat m = .25;\n\tp.z = mod(p.z - m * .5, m) - m * .5;\n\tp.xy += 4.5;\n\tfloat b1 = box(p, vec3(.02, 23.5, .1));\n\n\n    // Two spheres\n\tp = q;\n    p -= vec3(0, .3, .6);\n\tfloat sph1 = length(p) - .3;\n    p -= vec3(-.1, .4, 1.5);\n\tfloat sph2 = length(p) - .05;\n\n    // Fractal shape\n\tp = q;\n\tmo(p.xz, vec2(2.8));\n\tmo(p.xy, vec2(1.2));\n\n\tmo(p.xz, vec2(2.03, .3));\n\tp.xy *= r2d(3.14 / 2.2);\n\n\tmo(p.xz, vec2(.5, .4));\n\tamod2(p.xz, 8.);// experimental value, should be 6.28/n\n\n    // Construct the main shape\n\tfloat d = od(p, .7);\n\td = cmin(d, sc(p, .03), .3);\n\td = max(d, box(p, vec3(4)));\n\n\t// Add other shapes\n\td = min(d, b1);\n\td = min(d, sph1);\n\td = min(d, sph2);\n\n\treturn d;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\treturn normalize(vec3(\n\t\tde(p + e.xyy) - de(p - e.xyy),\n\t\tde(p + e.yxy) - de(p - e.yxy),\n\t\tde(p + e.yyx) - de(p - e.yyx)\n\t));\n}\n\n// dithering\nfloat tex2D(vec2 uv) {\n\tfloat res_pixelate = 40.; // = iResolution (pixelated)\n\tvec2 pix_coord = floor(uv * res_pixelate); // = fragCoord (pixelated)\n\tuv = pix_coord / res_pixelate;\n\n\t// if you use bayer texture, don't forget to put \"nearest\" in the options\n\treturn texture(iChannel0, pix_coord / 8.).r;\n}\n\n// triplanar\nfloat tex3D(vec3 p, vec3 n) {\n\tfloat blend_exponent = 32.;\n\tvec3 weight = pow(abs(n), vec3(blend_exponent));\n\tweight /= (weight.x + weight.y + weight.z);\n\n\treturn\n\t\ttex2D(p.yz) * weight.x +\n\t\ttex2D(p.zx) * weight.y +\n\t\ttex2D(p.xy) * weight.z;\n}\n\n// from iq\nfloat calculate_ao(vec3 p, vec3 n) {\n\tconst float AO_SAMPLES = 5.;\n\tfloat r = 0., w = 1., d;\n\n\tfor (float i = 1.; i < AO_SAMPLES + 1.1; i++) {\n\t\td = i / AO_SAMPLES;\n\t\tr += w * (d - de(p + n * d));\n\t\tw *= .5;\n\t}\n\n\treturn 1. - clamp(r, 0., 1.);\n}\n\nvoid shaderLsdLive(out vec4 fragColor, in vec2 fragCoord , in vec2 resolution)\n{\n    vec3 ro = vec3(cos(iTime)*.2, sin(iTime)*.05, -3. + .3 * sin(iTime));\n\tvec3 col = vec3(0);\n\n\tfor (int j = 0; j < ANTIALIAS; j++) {\n\t\tfor (int i = 0; i < ANTIALIAS; i++) {\n\t\t\tvec2 off = vec2(float(i), float(j)) / float(ANTIALIAS);\n\n\t\t\tvec2 uv = (fragCoord.xy + off) / resolution.xy - .5;\n\t\t\tuv.x *= resolution.x / resolution.y;\n\n\t\t\t// it was faster to move the frame like this for the composition\n\t\t\tuv -= vec2(.4, .08);\n\n            vec3 rd = normalize(vec3(uv, .6 - length(uv)));// cheap lens distortion\n            vec3 p;\n            \n\t\t\tfloat t = 0., tmax = 25.;\n\t\t\tfor (float i = 0.; i < 1.; i += .01) {\n\t\t\t\tp = ro + rd * t;\n\t\t\t\tfloat d = de(p);\n\t\t\t\tif (d < .001 || t > tmax)\n                    break;\n\t\t\t\tt += d;\n\t\t\t}\n\n\t\t\tvec3 c = vec3(.4, .1, .1);\n\t\t\tif (t <= tmax) {\n\t\t\t\tvec3 n = normal(p);\n                vec3 ld = normalize(vec3(1, 1, -3));\n\t\t\t\tfloat dotNL = max(0., dot(n, ld));\n\t\t\t\tfloat ao = calculate_ao(p, n);\n\n\t\t\t\tapply_transform(p);\n\t\t\t\tapply_transform(n);\n\n\t\t\t\tfloat dither_pattern = tex3D(p, n);\n\n\t\t\t\tvec3 albedo = vec3(smoothstep(-.5, 1., n.y),\n\t\t\t\t\tsmoothstep(-1., 1., n.y),\n\t\t\t\t\tsmoothstep(-.2, 1., n.y));\n\n\t\t\t\tc = albedo * ao * (.5 * dotNL + .5);\n\t\t\t\tc = step(dither_pattern, c);\n\t\t\t\tc = palette(luma(c));\n\t\t\t}\n\n\t\t\tcol += c;\n\n\t\t}\n\t}\n\tcol /= float(ANTIALIAS * ANTIALIAS);\n\n\t// gamma\n\tcol = pow(col, vec3(.4545));;\n\t// vignetting\n\tvec2 q = fragCoord / resolution.xy;\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\n\n\tfragColor = vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    vec2 resolution = iResolution.xy;\n    resolution.x *= 2.;\n    \n    fragCoord.x *= 2.;\n    if(fragCoord.x < iResolution.x)\n    {\n        fragCoord.x += iResolution.x * .5;\n\n        shaderLsdLive(fragColor, fragCoord, resolution);\n    }\n    else\n    {\n        fragCoord.x -= iResolution.x * .5;\n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define INF 100.\n#define PI 3.14159\n\nmat2 rot(float a){ float ca= cos(a); float sa = sin(a); return mat2(ca,-sa,sa,ca);}\n\nfloat r(vec2 n)\n{\n    return fract(cos(dot(n,vec2(36.26,73.12)))*354.63);\n}\nfloat noise21(vec2 n)\n{\n    vec2 fn = floor(n);\n    vec2 sn = smoothstep(vec2(0),vec2(1),fract(n));\n    \n    float h1 = mix(r(fn),r(fn+vec2(1,0)),sn.x);\n    float h2 = mix(r(fn+vec2(0,1)),r(fn+vec2(1)),sn.x);\n    return mix(h1,h2,sn.y);\n}\nfloat value(vec2 n)\n{\n    float total;\n    total = noise21(n/32.)*0.5875+noise21(n/16.)*0.2+noise21(n/8.)*0.1\n            +noise21(n/4.)*0.05+noise21(n/2.)*0.025+noise21(n)*0.0125;\n \treturn total;\n}\n\nvec4 hexGrid(vec2 p)\n{\n    \n    vec2 r = vec2(1.,1.73);\n    vec2 h = r * .5;\n    \n    vec2 a = mod(p, r) - h;\n    vec2 b = mod(p - h,r) - h;\n \n    \n    vec2 uv = length(a) < length(b) ? a : b;\n    \n    return vec4(length(uv),atan(uv.y,uv.x),p - uv);\n}\n\nfloat map(vec3 p)\n{\n\tfloat dist = 10.;\n    \n    vec3 cp = p;\n    vec4 hex = hexGrid(p.xy * 2. * length(p.xy * 4.));\n    p.xy += (noise21(hex.zw + iTime)- .5) * .25;\n    \n    return length(p) - 1.;\n}\n\nvoid ray(inout vec3 cp, vec3 rd, out float st, out float cd)\n{\n    st = 0.;\n    cd = 0.;\n    for(; st < 1.;  st += 1./64.)\n    {\n        cd = map(cp);\n        if(cd < .01 || cd > INF)\n        {\n            break;\n        }\n        cp += rd * cd * .5;\n    }\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.01,.0);\n    float m = map(p);\n    return normalize(vec3(\n    \tm - map(p + e.xyy),\n    \tm - map(p + e.yxy),\n    \tm - map(p + e.yyx)\n    ));\n}\n\nvec4 pageColor = vec4(1.,1.,.95,1.);\n\nvoid render1( out vec4 fragColor, vec2 coord, vec2 resolution)\n{\n\n    vec2 uv = (coord - resolution.xy * .5) / resolution.x;\n    uv *= 2.;\n    vec3 eye = vec3(0.,0.,-5.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 cp = eye;\n    float st = 0.; float cd = 0.;\n    ray(cp, rd, st, cd);\n    \n    fragColor = pageColor;\n    if(cd < .01)\n    {\n        vec3 norm = normal(cp);\n        float f = fwidth(dot(rd, norm));\n    \tfragColor = vec4(f);\n    \tfragColor = 1. - fragColor;\n    }\n}\n\nvoid render2( out vec4 fragColor, vec2 coord, vec2 resolution)\n{\n    vec2 uv = (coord - resolution.xy * .5) / resolution.x;\n    uv.x = abs(uv.x)*.5 ;\n    uv.y -= uv.x * .75;\n    float f = length(uv);\n    \n    f = step(f,.075);\n    \n    fragColor =  mix(pageColor, vec4(1.,0.,0.,1.), f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    vec2 resolution = iResolution.xy;\n    resolution.x *= 2.;\n    \n    fragCoord.x *= 2.;\n    if(fragCoord.x < iResolution.x)\n    {\n        fragCoord.x += iResolution.x * .5;\n\n        render1(fragColor, fragCoord, resolution);\n    }\n    else\n    {\n        fragCoord.x -= iResolution.x * .5;\n        render2(fragColor, fragCoord, resolution);\n        \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}