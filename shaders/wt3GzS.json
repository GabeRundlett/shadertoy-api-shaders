{
    "Shader": {
        "info": {
            "date": "1576680631",
            "description": "Sample a triangle uniformly with no rejected random point, with const density ( i.e. prop to area ).\nIllustrating tech Report [url]https://eheitzresearch.wordpress.com/749-2/[/url]\nAlternate white vs blue boise, dots vs splats.   Mouse control top vertex.",
            "flags": 0,
            "hasliked": 0,
            "id": "wt3GzS",
            "likes": 12,
            "name": "const-density triangle sampling",
            "published": 3,
            "tags": [
                "sampling",
                "bluenoise"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 501
        },
        "renderpass": [
            {
                "code": "// implementing a subset of \"A Low-Distortion Map Between Triangle and Square\"\n// techreport: https://eheitzresearch.wordpress.com/749-2/\n\n#define D 2000.                               // density\n#define HUE 0                                 // 1: display Voronoi / colored splats\n\n#define hash2(i)  fract(sin( i * vec2(12.9898, 78.233) ) * 43758.5453)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = 1.*iTime;           \n    bool  blue  = fract(t/12.) > .5 ,         // sample white vs blue noise\n          splat = fract(t/12.+.25) > .5;      // display dots vs splats\n\n    vec2  R = iResolution.xy,\n          m = iMouse.xy,\n          U = ( 2.* u - R ) / R.y, P,\n         P0 = vec2(-1), P0U = P0-U,           // triangle 3 vertices\n         P1 = vec2(.5,0) +.5*cos(t+vec2(0,11)), \n         P2 = length(m)<20. ? vec2(0,.5) : (2.*m-R)/R.y;\n    \n    mat2  M = mat2( P1-P0, P2-P0 );           // triangle frame\n    float s = abs(determinant(M))/2.,         // triangle area\n          d = 1e5, v,k, N = D*s, l = sqrt(N);\n    \n    for( float i = 1.; i <= N; i++) {\n        P = hash2(i);                         // uniform hash on canonical square\n        if (blue) P = vec2(fract(i/l),i/N) + (P-.5)/l; // blue noise case\n        if (P.y > P.x) P.y -= P.x *= .5;      // square-triangle iso-mapping\n        else           P.x -= P.y *= .5;\n      //int c = int(P.y > P.x); P[c] -= P[1-c] *= .5; // more expensive\n      //if (P.x+P.y > 1.) P = 1.-P;           // simpler but not bijective (required for bluenoise or stratified)\n\n      //P = P0 + P.x*(P1-P0) + P.y*(P2-P0);   // barycentric coordinates\n      //d = min(d, dot(P-U,P-U) );            // get sample closest to cur pixel\n      //                                      Optimized version:\n        P = P0U + M*P;                        // barycentric coordinates\n#if !HUE\n        if (!splat) d = min(d, dot(P,P) );    // get sample closest to cur pixel\n        else    O += max( 0., 1. -.3*sqrt(D)*length(P) ) / 16.; // splats\n#else\n        if (!splat) { v = dot(P,P); if (v<d) d=v,k=i; }         // closest id (for Voronoi)\n        else    O += max( 0., 1. -.3*sqrt(D)*length(P) ) / 16.  // splats (colored)\n                    *hue(i*331.7)*1.5; \n#endif\n    }\n    \n    if (!splat) O += smoothstep(3./R.y,0.,sqrt(d)-.002); // draw dot\n#if HUE\n    if (!splat && d<2./D) O = hue(hash2(k+.5).x);        // draw Voronoi\n#else\n    O = pow(O, vec4(1./2.2));                            // to sRGB\n#endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}