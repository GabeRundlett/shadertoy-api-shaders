{
    "Shader": {
        "info": {
            "date": "1491251655",
            "description": "It is is unique because it takes into account the ray's 4th coordinate.\n\nNo GPU sound? Your graphics card may not have enough power for GPU sound. Here's the shader without GPU sound:\nhttps://www.shadertoy.com/view/MdjyzD",
            "flags": 9,
            "hasliked": 0,
            "id": "Md2cRD",
            "likes": 5,
            "name": "Raymarching 4D",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "vr",
                "4draymarching",
                "dimensional"
            ],
            "usePreview": 0,
            "username": "hopskotchrainbow",
            "viewed": 1556
        },
        "renderpass": [
            {
                "code": "#define pi 3.14152865\n\n#define eps 0.001\n#define edge 0.00125\n#define shading 0.00125\n#define ev vec3(shading, 0.0, 0.0)\n\n#define time iTime\n\nstruct bit3d_shape\n{\n\tvec3 diffuse;\n\tvec3 ambient;\n\tvec3 glowcolor;\n\tfloat glow;\n\tfloat surface;\n\tvec3 specular;\n\tfloat specPower;\n\tint portal;\n\tfloat ambientOcclusion;\n\tfloat reflection;\n\tbool stepk;\n};\nstruct bit3d_coordinate\n{\n\tvec3 position;\n\tint portal;\n};\n\nstruct bit3d_Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n\tint maxIterations;\n\tint iters;\n\tfloat dist;\n\tbit3d_coordinate coord;\n\tbit3d_shape target;\n\tbool hit;\n\tvec3 normal;\n\tbool inside;\n};\n\n\n\n// Official HSV to RGB conversion\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nfloat direction(vec2 uv) {\n\tfloat a = atan(uv.x,uv.y)/radians(360.0);\n\ta += 0.5;\n\treturn a*360.0;\n}\n\nvoid rotate(inout vec2 uv, float angle) {\n\tfloat rad = radians(angle);\n\tuv = vec2(uv.x*cos(rad)-uv.y*sin(rad),\n\t\tuv.x*sin(rad)+uv.y*cos(rad));\n}\n\nvec2 direction(vec3 v)\n{\n\treturn vec2(\n\t\tdirection(v.xz)+180.0,\n\t\tdirection(vec2(\n\t\t\tlength(v.xz),\n\t\t\tv.y\n\t\t))+90.0\n\t);\n}\n\nvoid rotate(inout vec3 v, vec3 angle) {\n\trotate(v.zy, angle.x);\n\trotate(v.xz, angle.y);\n\trotate(v.xy, angle.z);\n}\n\n// union\nbit3d_shape op_union(bit3d_shape primary, bit3d_shape secondary) {\n\tbit3d_shape shape3d = primary;\n\tif (secondary.surface < primary.surface) shape3d = secondary;\n\treturn shape3d;\n}\n\n// intersection\nfloat op_intersect(float primary, float secondary) {\n\treturn max(primary, secondary);\n}\n\n// mixing\nfloat op_mix(float primary, float secondary, float factor) {\n\tfloat h = clamp((primary-secondary)/factor+1.0,0.0,1.0);\n\tfloat j = mix(primary, secondary, pow(h,3.0));\n\treturn j;\n}\n\n// subtraction\nfloat op_subtract(float primary, float secondary) {\n\treturn max(primary, -secondary);\n}\n\n// sphere\nfloat sphere(vec3 l, vec3 size) {\n\tvec3 sqf = sqrt(size);\n\tvec3 m = l/(sqf);\n\tif (length(m) > 1.0)\n\t{\n\t\tm = normalize(m);\n\t}\n\tm *= sqf;\n\treturn length(l-m);\n}\n\n// box\nfloat box(vec3 l, vec3 size) {\n\tvec3 m = clamp(l, -size/2.0,size/2.0);\n\treturn distance(l, m);\n}\n\n// cylinder\nfloat cylinder(vec3 l, vec2 scale, float bottom, float top) {\n\tvec2 scf = l.xz/scale;\n\tif (length(scf) >= 1.0) scf = normalize(scf);\n\tfloat coDist = distance(l.xz, scf*scale);\n\tfloat cg = max(l.y-bottom, top-l.y);\n\treturn max(cg, coDist);\n}\n\n\nvec3 path(float k, int id) {\n\tvec2 nv = vec2(cos(k*0.7),sin(k*0.7))*0.6;\n\treturn vec3(nv,k*1.3);\n}\n\nvec3 pathdir(float k, int id) {\n\treturn normalize(path(k+eps, id)-path(k, id));\n}\n\nvoid forward(inout vec3 point, vec3 target) {\n\tvec2 dh = direction(target);\n\trotate(point, -vec3(dh.yx,0.0));\n}\n\nvoid forward(inout vec3 point, vec3 target, float inverse) {\n\tvec2 dh = direction(target);\n\trotate(point, -vec3(mix(dh.yx,-dh.yx,inverse),0.0));\n}\n\nfloat capsphere(vec3 h, float radius) {\n\tvec2 orig = h.xy;\n\tif (length(orig) >= radius) {\n\t\torig = normalize(orig)*radius;\n\t}\n\treturn length(vec3(h.xy-orig.xy,h.z));\n}\n\nfloat speed(float k, int id) {\n\treturn distance(path(k,id),path(k+eps,id))/eps;\n}\n\nfloat crossh(vec3 p) {\n\tfloat m = max(max(abs(p.x),abs(p.y)),abs(p.z));\n\tfloat n = min(min(abs(p.x),abs(p.y)),abs(p.z));\n\tfloat d = (abs(p.x)+abs(p.y)+abs(p.z))/3.0;\n\treturn min(abs(n-m)+d/length(p),n);\n}\n\nvoid scene(\n\tinout bit3d_shape shape,\n\tbit3d_coordinate coord\n)\n{\n\tvec3 frame = (abs(fract(coord.position/16.0)-0.5)-0.5)*16.;\n\tvec3 utframe = (fract(coord.position/16.0+0.5)-0.5)*16.0;\n\n\tshape.diffuse = vec3(0.11,0.5,0.89);\n\tshape.ambient = vec3(0.0);\n\tshape.specular = vec3(0.2);\n\tshape.specPower = 5.0;\n\tshape.glow = 0.0;\n\tshape.stepk = false;\n\tshape.reflection = 0.0;\n\tshape.ambientOcclusion = 0.5;\n\tfloat holes = min(length(frame.xy)-0.8,length(frame.zy)-0.8);\n\tholes = min(holes,length(frame.xz)-0.1);\n\tfloat setcube = op_mix(box(frame,vec3(5.0)),holes,0.52);\n\tfloat h = op_subtract(0.2-holes,box(frame,vec3(5.0)));\n\tsetcube = op_mix(setcube,(1.0-crossh(frame)),0.3);\n\tif (coord.portal == 0) {\n\t\tshape.surface = 0.2-setcube;\n\t\tif (holes >= 0.2) {\n\t\t\tshape.reflection = 0.0;\n\t\t\tshape.ambientOcclusion = 0.54;\n\t\t} else if (h < 0.2 && shape.surface <= edge*2.0) {\n\t\t\tshape.portal = 1;\n\t\t}\n\t} else if (coord.portal == 1) {\n\t\tvec3 hu = utframe;\n\t\thu.y-= pow(abs(hu.x),0.75);\n\t\tshape.surface = op_mix(pow(capsphere(hu,5.77),0.25)-1.0,-0.5+sphere(frame,vec3(1.7,1.7,1.)),0.9);\n\t\tif (h > 0.2 && shape.surface <= edge) shape.portal = 0;\n\t shape.diffuse = vec3(0.9,0.5,0.7);\n\t shape.ambientOcclusion = 0.8;\n\t}\n}\n\nfloat scenef(bit3d_coordinate l) {\n\tbit3d_shape shape;\n\tshape.portal = l.portal;\n\tscene(shape, l);\n\treturn shape.surface;\n}\n\nbit3d_coordinate cadd(bit3d_coordinate v, vec3 n) {\n\tbit3d_coordinate a;\n\ta.portal = v.portal;\n\ta.position = v.position+n;\n\treturn a;\n}\n\nvec3 bit3d_normal(bit3d_coordinate l) {\n\treturn normalize(vec3(\n\t\tscenef(cadd(l, ev.xyz))-scenef(cadd(l,0.0-ev.xyz)),\n\t\tscenef(cadd(l, ev.yxz))-scenef(cadd(l,0.0-ev.yxz)),\n\t\tscenef(cadd(l, ev.zyx))-scenef(cadd(l,0.0-ev.zyx))\n\t));\n}\n\nvoid fire(inout bit3d_Ray ray, int firstPortal) {\n\tray.coord.position = ray.origin;\n\tvec3 d = normalize(ray.direction);\n\tbit3d_coordinate coord = ray.coord;\n\tcoord.position = ray.origin;\n\tcoord.portal = firstPortal;\n\tbit3d_shape shape = ray.target;\n\tray.hit = false;\n\tray.iters = 0;\n\tray.dist = 0.0;\n\tray.inside = true;\n\tshape.portal = firstPortal;\n\tray.maxIterations = max(ray.maxIterations, 256);\n\twhile (ray.iters < ray.maxIterations && ray.dist < length(ray.direction)) {\n\t\tray.iters += 1;\n\t\tfloat zh = shape.surface;\n\t\tbool kh = shape.stepk;\n\t\tint pl = shape.portal;\n\t\tscene(shape, coord);\n\t if (ray.dist > edge) ray.inside = false;\n\t \tif (shape.surface <= edge && shape.portal == coord.portal) {\n\t\t \tray.hit = true;\n\t\t \tray.normal = bit3d_normal(coord);\n\t\t \tbreak;\n\t\t }\n\t\tfloat hy = max(shape.surface,0.0);\n\t\tif (kh) {hy = 0.075;}\n\t\tcoord.position += d*hy;\n\t coord.portal = shape.portal;\n\t\tray.dist += hy;\n\t}\n\tray.target = shape;\n\tray.coord = coord;\n}\n\nbit3d_Ray rayof(vec3 o, vec3 t, int mi) {\n\tbit3d_Ray r;\n\tr.origin = o;\n\tr.direction = t;\n\tr.maxIterations = mi;\n\treturn r;\n}\n\nvec3 LightPosition(bit3d_Ray r) {\n\treturn path(time+2.0,0)+vec3(0.0,0.2,0.0);\n}\n\nvec4 materialColor(bit3d_Ray ray) {\n\tvec3 lightpos = LightPosition(ray);\n\tvec4 m = vec4(0.0);\n\tif (ray.hit) {\n\t\tbit3d_shape target = ray.target;\n\t\tvec3 vn = normalize(ray.direction);\n\t\tvec3 im = lightpos;\n\t\tvec3 vm = normalize(ray.coord.position-im);\n\t\tvec3 vi = normalize(vm-im);\n\t\tvec3 h = normalize(ray.coord.position-lightpos);\n\t\tbit3d_Ray hray = rayof(ray.coord.position-h*edge*2.,h*(length(ray.direction)-ray.dist),ray.maxIterations-ray.iters);\n\t\tfloat byshade = 1.0;\n\n\t\tfloat diffuse = dot(ray.normal, vi)*byshade;\n\t\tdiffuse = pow(clamp(diffuse+target.ambientOcclusion, target.ambientOcclusion, 1.0),1.0);\n\t\tfloat specm = pow(max(dot(vi, ray.normal),0.0),target.specPower);\n\t\tm.a = clamp(1.0-(pow(float(ray.iters)/float(ray.maxIterations),0.2)*pow(distance(ray.coord.position,ray.origin)/length(ray.direction)*24.0,0.01)),0.0,1.0);\n\t\tm.a *= 1.0-(ray.dist/length(ray.direction));\n\t\tm.rgb = mix(target.ambient+mix(target.diffuse*diffuse,target.diffuse+target.specular,specm),target.glowcolor, target.glow*(1.0-diffuse));\n\t}\n\tm.rgb = clamp(m.rgb, 0.0, 1.0);\n\treturn m;\n}\n\nvoid blend(inout vec4 fragColor, vec4 c) {\n\tfragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n\tfragColor.a = max(fragColor.a, c.a);\n}\n\nvoid blend(\n\tsampler2D sampler,\n    vec2 fragCoord,\n    inout vec4 fragColor,\n\tvec2 origin,\n\tvec2 size,\n\tfloat rotation,\n\tfloat alpha\n) {\n vec2 c = fragCoord.xy-origin;\n c /= size;\n rotate(c, rotation);\n c += 0.5;\n if (c.x>= 0.0 && c.y >= 0.0 && c.x < 1.0 && c.y < 1.0) {\n \tvec4 t = texture(sampler, c);\n \tt.a *= alpha;\n \tblend(fragColor, t);\n }\n}\n\nvoid blend(inout vec4 fragColor, bit3d_Ray ray) {\n\tvec4 color = materialColor(ray);\n\tbit3d_Ray refl = ray;\n\tint iei = ray.iters;\n\twhile (iei > 0) {\n\t\tfloat rh = refl.target.reflection;\n\t\tint iters = refl.iters;\n\t\tif ((!ray.hit) || rh <= 0.0) break;\n\t\tfloat gz = length(refl.direction)-refl.dist;\n\t\trefl.origin = refl.coord.position;\n\t\trefl.direction = reflect(normalize(refl.direction), refl.normal)*gz;\n\t\trefl.maxIterations = ray.maxIterations;\n\t\trefl.origin += normalize(refl.direction)*shading;\n\t\tfire(refl, refl.coord.portal);\n\t\tiei -= iters;\n\t\tvec4 c2 = materialColor(refl);\n\t\tcolor.rgb = mix(color.rgb, c2.rgb, rh);\n\t\tcolor.a = mix(color.a,color.a*c2.a,rh);\n\t}\n\tblend(fragColor, color);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 b = pathdir(time, 0);\n    vec3 o = path(time, 0);\n    vec3 unv = normalize(rd)*64.0;\n    rotate(unv, vec3(direction(b),0.0));\n    bit3d_Ray ray = rayof(o, unv, 8);\n    fire(ray, 0);\n    vec4 c = vec4(vec3(0.0),1.0);\n    blend(c, ray);\n\tfragColor = vec4(c.rgb,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy / 2.0;\n    uv /= max(iResolution.x,iResolution.y);\n    vec2 uv2 = fragCoord.xy/iResolution.xy;\n    vec3 b = pathdir(time, 0);\n    vec3 o = path(time, 0);\n    vec3 unv = vec3(uv, 1.0)*32.0;\n    rotate(unv, vec3(direction(b),0.0));\n    bit3d_Ray ray = rayof(o, unv, 8);\n    fire(ray, 0);\n    vec4 c = vec4(vec3(0.0),1.0);\n    blend(c, ray);\n\tfragColor = vec4(c.rgb,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.14152865\n\n#define eps 0.001\n#define edge 0.00125\n#define shading 0.00125\n#define ev vec3(shading, 0.0, 0.0)\n\n#define sqrs(x) sqrt(abs(x))*sign(x)\n#define pows(x,y) pow(abs(x),y)*sign(x)\n\nstruct bit3d_shape\n{\n\tvec3 diffuse;\n\tvec3 ambient;\n\tvec3 glowcolor;\n\tfloat glow;\n\tfloat surface;\n\tvec3 specular;\n\tfloat specPower;\n\tint portal;\n\tfloat ambientOcclusion;\n\tfloat reflection;\n\tbool stepk;\n};\nstruct bit3d_coordinate\n{\n\tvec3 position;\n\tint portal;\n};\n\nstruct bit3d_Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n\tint maxIterations;\n\tint iters;\n\tfloat dist;\n\tbit3d_coordinate coord;\n\tbit3d_shape target;\n\tbool hit;\n\tvec3 normal;\n\tbool inside;\n};\n\n\n\n// Official HSV to RGB conversion\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nfloat direction(vec2 uv) {\n\tfloat a = atan(uv.x,uv.y)/radians(360.0);\n\ta += 0.5;\n\treturn a*360.0;\n}\n\nvoid rotate(inout vec2 uv, float angle) {\n\tfloat rad = radians(angle);\n\tuv = vec2(uv.x*cos(rad)-uv.y*sin(rad),\n\t\tuv.x*sin(rad)+uv.y*cos(rad));\n}\n\nvec2 direction(vec3 v)\n{\n\treturn vec2(\n\t\tdirection(v.xz)+180.0,\n\t\tdirection(vec2(\n\t\t\tlength(v.xz),\n\t\t\tv.y\n\t\t))+90.0\n\t);\n}\n\nvoid rotate(inout vec3 v, vec3 angle) {\n\trotate(v.zy, angle.x);\n\trotate(v.xz, angle.y);\n\trotate(v.xy, angle.z);\n}\n\n// union\nbit3d_shape op_union(bit3d_shape primary, bit3d_shape secondary) {\n\tbit3d_shape shape3d = primary;\n\tif (secondary.surface < primary.surface) shape3d = secondary;\n\treturn shape3d;\n}\n\n// intersection\nfloat op_intersect(float primary, float secondary) {\n\treturn max(primary, secondary);\n}\n\n// mixing\nfloat op_mix(float primary, float secondary, float factor) {\n\tfloat h = clamp((primary-secondary)/factor+1.0,0.0,1.0);\n\tfloat j = mix(primary, secondary, pow(h,3.0));\n\treturn j;\n}\n\n// subtraction\nfloat op_subtract(float primary, float secondary) {\n\treturn max(primary, -secondary);\n}\n\n// sphere\nfloat sphere(vec3 l, vec3 size) {\n\tvec3 sqf = sqrt(size);\n\tvec3 m = l/(sqf);\n\tif (length(m) > 1.0)\n\t{\n\t\tm = normalize(m);\n\t}\n\tm *= sqf;\n\treturn length(l-m);\n}\n\n// box\nfloat box(vec3 l, vec3 size) {\n\tvec3 m = clamp(l, -size/2.0,size/2.0);\n\treturn distance(l, m);\n}\n\n// cylinder\nfloat cylinder(vec3 l, vec2 scale, float bottom, float top) {\n\tvec2 scf = l.xz/scale;\n\tif (length(scf) >= 1.0) scf = normalize(scf);\n\tfloat coDist = distance(l.xz, scf*scale);\n\tfloat cg = max(l.y-bottom, top-l.y);\n\treturn max(cg, coDist);\n}\n\n\nvec3 path(float k, int id) {\n\tvec2 nv = vec2(cos(k*0.7),sin(k*0.7))*0.6;\n\treturn vec3(nv,k*1.3);\n}\n\nvec3 pathdir(float k, int id) {\n\treturn normalize(path(k+eps, id)-path(k, id));\n}\n\nvoid forward(inout vec3 point, vec3 target) {\n\tvec2 dh = direction(target);\n\trotate(point, -vec3(dh.yx,0.0));\n}\n\nvoid forward(inout vec3 point, vec3 target, float inverse) {\n\tvec2 dh = direction(target);\n\trotate(point, -vec3(mix(dh.yx,-dh.yx,inverse),0.0));\n}\n\nfloat capsphere(vec3 h, float radius) {\n\tvec2 orig = h.xy;\n\tif (length(orig) >= radius) {\n\t\torig = normalize(orig)*radius;\n\t}\n\treturn length(vec3(h.xy-orig.xy,h.z));\n}\n\nfloat speed(float k, int id) {\n\treturn distance(path(k,id),path(k+eps,id))/eps;\n}\n\nfloat crossh(vec3 p) {\n\tfloat m = max(max(abs(p.x),abs(p.y)),abs(p.z));\n\tfloat n = min(min(abs(p.x),abs(p.y)),abs(p.z));\n\tfloat d = (abs(p.x)+abs(p.y)+abs(p.z))/3.0;\n\treturn min(abs(n-m)+d/length(p),n);\n}\n\nvoid scene(\n\tinout bit3d_shape shape,\n\tbit3d_coordinate coord\n)\n{\n\tvec3 frame = (abs(fract(coord.position/16.0)-0.5)-0.5)*16.;\n\tvec3 utframe = (fract(coord.position/16.0+0.5)-0.5)*16.0;\n\n\tshape.diffuse = vec3(0.11,0.5,0.89);\n\tshape.ambient = vec3(0.0);\n\tshape.specular = vec3(0.2);\n\tshape.specPower = 5.0;\n\tshape.glow = 0.0;\n\tshape.stepk = false;\n\tshape.reflection = 0.0;\n\tshape.ambientOcclusion = 0.5;\n\tfloat holes = min(length(frame.xy)-0.8,length(frame.zy)-0.8);\n\tholes = min(holes,length(frame.xz)-0.1);\n\tfloat setcube = op_mix(box(frame,vec3(5.0)),holes,0.52);\n\tfloat h = op_subtract(0.2-holes,box(frame,vec3(5.0)));\n\tsetcube = op_mix(setcube,(1.0-crossh(frame)),0.3);\n\tif (coord.portal == 0) {\n\t\tshape.surface = 0.2-setcube;\n\t\tif (holes >= 0.2) {\n\t\t\tshape.reflection = 0.0;\n\t\t\tshape.ambientOcclusion = 0.54;\n\t\t} else if (h < 0.2 && shape.surface <= edge*2.0) {\n\t\t\tshape.portal = 1;\n\t\t}\n\t} else if (coord.portal == 1) {\n\t\tvec3 hu = utframe;\n\t\thu.y-= pow(abs(hu.x),0.75);\n\t\tshape.surface = op_mix(pow(capsphere(hu,5.77),0.25)-1.0,-0.5+sphere(frame,vec3(1.7,1.7,1.)),0.9);\n\t\tif (h > 0.2 && shape.surface <= edge) shape.portal = 0;\n\t shape.diffuse = vec3(0.9,0.5,0.7);\n\t shape.ambientOcclusion = 0.8;\n\t}\n}\n\nfloat scenef(bit3d_coordinate l) {\n\tbit3d_shape shape;\n\tshape.portal = l.portal;\n\tscene(shape, l);\n\treturn shape.surface;\n}\n\nbit3d_coordinate cadd(bit3d_coordinate v, vec3 n) {\n\tbit3d_coordinate a;\n\ta.portal = v.portal;\n\ta.position = v.position+n;\n\treturn a;\n}\n\nvec3 bit3d_normal(bit3d_coordinate l) {\n\treturn normalize(vec3(\n\t\tscenef(cadd(l, ev.xyz))-scenef(cadd(l,0.0-ev.xyz)),\n\t\tscenef(cadd(l, ev.yxz))-scenef(cadd(l,0.0-ev.yxz)),\n\t\tscenef(cadd(l, ev.zyx))-scenef(cadd(l,0.0-ev.zyx))\n\t));\n}\n\nvoid fire(inout bit3d_Ray ray, int firstPortal) {\n\tray.coord.position = ray.origin;\n\tvec3 d = normalize(ray.direction);\n\tbit3d_coordinate coord = ray.coord;\n\tcoord.position = ray.origin;\n\tcoord.portal = firstPortal;\n\tbit3d_shape shape = ray.target;\n\tray.hit = false;\n\tray.iters = 0;\n\tray.dist = 0.0;\n\tray.inside = true;\n\tshape.portal = firstPortal;\n\tray.maxIterations = max(ray.maxIterations, 256);\n\twhile (ray.iters < ray.maxIterations && ray.dist < length(ray.direction)) {\n\t\tray.iters += 1;\n\t\tfloat zh = shape.surface;\n\t\tbool kh = shape.stepk;\n\t\tint pl = shape.portal;\n\t\tscene(shape, coord);\n\t if (ray.dist > edge) ray.inside = false;\n\t \tif (shape.surface <= edge && shape.portal == coord.portal) {\n\t\t \tray.hit = true;\n\t\t \tray.normal = bit3d_normal(coord);\n\t\t \tbreak;\n\t\t }\n\t\tfloat hy = max(shape.surface,0.0);\n\t\tif (kh) {hy = 0.075;}\n\t\tcoord.position += d*hy;\n\t coord.portal = shape.portal;\n\t\tray.dist += hy;\n\t}\n\tray.target = shape;\n\tray.coord = coord;\n}\n\nbit3d_Ray rayof(vec3 o, vec3 t, int mi) {\n\tbit3d_Ray r;\n\tr.origin = o;\n\tr.direction = t;\n\tr.maxIterations = mi;\n\treturn r;\n}\n\nvec2 shift( vec3 sound ) {\n    float x = max(sound.x, 0.0);\n    float y = max(sound.y, 0.0);\n    vec2 v = vec2(x, y);\n    float m = 0.0;\n    if (sound.z >= 0.0) {\n        m = 1.0/sqrt(sound.z+1.0);\n    } else {\n        m = 1.0-abs(sound.z/6.0);\n    }\n    return v*m;\n}\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat waveform( float time, float freq ) {\n    return pows(sqrs(sin(time*(250.0+freq*750.0))),0.7);\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    bit3d_Ray ray = rayof(path(time,0), pathdir(time,0)*24.0, 2);\n    fire(ray,0);\n    float z = 0.0;\n    if (ray.hit) {\n        float d1 = ray.dist/length(ray.direction);\n        float d2 = float(ray.iters)/float(ray.maxIterations);\n        z = waveform(time, d1)*waveform(time, d2);\n    }\n    return vec2( z ) * shift(ray.coord.position);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}