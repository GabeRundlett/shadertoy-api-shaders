{
    "Shader": {
        "info": {
            "date": "1689752140",
            "description": "Doraemon using ray tracing\nrolling balls\nPyramid",
            "flags": 64,
            "hasliked": 0,
            "id": "msjfDD",
            "likes": 0,
            "name": "assign5_task2",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Luna",
            "viewed": 127
        },
        "renderpass": [
            {
                "code": "//============================================================================\n// PROJECT ID: SWS3005_11\n//\n// GROUP NUMBER: 11\n//\n// STUDENT NAME: LI YAO\n// NUS User ID.: t0930394\n//\n// STUDENT NAME: WANG HONGBO\n// NUS User ID.: t0930184\n//\n// STUDENT NAME: YOU XINYI\n// NUS User ID.: t0930404\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/view/msjfDD\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n\n\n//============================================================================\n// Initialize the Doraemon \n//============================================================================\nvoid InitDoraemon() {\n    //  Head\n    if (iTime>=13.0){\n    Sphere[0].center = vec3( 0.0, 1.4, 0.0 );\n    Sphere[0].radius = 0.5;\n    Sphere[0].materialID = 3;\n    }\n\n    //  Body\n    if (iTime>=5.0){\n    Stick[0].vertexA = vec3( 0.0, 1.4, 0.0 );\n    Stick[0].vertexB = vec3( 0.0, 0.7, 0.0 );\n    Stick[0].radius = 0.35;\n    Stick[0].materialID = 3;\n    }\n\n    // arm\n    if (iTime>=8.0){\n    float hand=0.1;\n    vec3 x = vec3( -0.7, 0.7, 0.0 );\n    vec3 y = vec3( -0.4, 0.9, 0.0 );\n    float r = sqrt( (x.x-y.x)*(x.x-y.x) + (x.y-y.y)*(x.y-y.y) + (x.z-y.z)*(x.z-y.z));\n    float w = 60.0;\n    float temp = 6.283185 * iTime / 120.0 * w;\n    float t = 1.0 / 3.0 * sin(temp);\n    Sphere[1].center.x = y.x - r * cos(-t );\n    Sphere[1].center.y = y.y - r * sin(-t ); \n    Sphere[1].center.z = y.z;\n    Sphere[1].radius = hand+0.03;\n    Sphere[1].materialID = 4;\n    Stick[1].vertexA = Sphere[1].center;\n    Stick[1].vertexB = vec3( -0.4, 1.0, 0.0 );\n    Stick[1].radius = hand;\n    Stick[1].materialID = 3;\n\n    Sphere[2].center = vec3( 0.7, 0.7, 0.0 );\n    Sphere[2].radius = hand+0.03;\n    Sphere[2].materialID = 4;\n    Stick[2].vertexA = vec3( 0.4, 0.9, 0.0 );\n    Stick[2].vertexB = Sphere[2].center;\n    Stick[2].radius = hand;\n    Stick[2].materialID = 3;\n    }\n    // leg\n    if (iTime>=2.0)\n    {\n    float leg=0.15;\n    float dis=0.2;\n    Stick[3].vertexA = vec3( -0.2, dis+0.3, 0.0 );\n    Stick[3].vertexB = vec3( -0.2, dis+0.05, 0.0 );\n    Stick[3].radius = leg;\n    Stick[3].materialID = 3;\n    Stick[4].vertexA = vec3( -0.2, dis+0.05, 0.0 );\n    Stick[4].vertexB = vec3( -0.2, dis, 0.0 );\n    Stick[4].radius = leg;\n    Stick[4].materialID = 4;\n\n    Stick[5].vertexA = vec3( 0.2, dis+0.3, 0.0 );\n    Stick[5].vertexB = vec3( 0.2, dis+0.05, 0.0 );\n    Stick[5].radius = leg;\n    Stick[5].materialID = 3;\n    Stick[6].vertexA = vec3( 0.2, dis+0.05, 0.0 );\n    Stick[6].vertexB = vec3( 0.2, dis, 0.0 );\n    Stick[6].radius = leg;\n    Stick[6].materialID = 4;\n    }\n\n\n   // bell\n   if (iTime>=13.0){\n    Sphere[3].center = vec3( 0.0, 1.05, 0.40 );\n    Sphere[3].radius = 0.08;\n    Sphere[3].materialID = 9;\n   }\n\n    // tail\n    if (iTime>=13.0){\n    Sphere[4].center = vec3( 0.0, 0.8, -0.35 );\n    Sphere[4].radius = 0.08;\n    Sphere[4].materialID = 6;\n    }\n\n    // nose\n    if (iTime>=13.0){\n    Sphere[5].center = vec3( 0.0, 1.6, 0.5 );\n    Sphere[5].radius = 0.07;\n    Sphere[5].materialID = 6;\n    }\n\n    // eyes\n    if (iTime>=13.0){\n    Ellipsoid[0].center = vec3(-0.1,1.8,0.38);\n    Ellipsoid[0].rad.x = 0.08;\n    Ellipsoid[0].rad.y = 0.1;\n    Ellipsoid[0].rad.z = 0.01;\n    Ellipsoid[0].materialID=4;\n    Ellipsoid[1].center = vec3(0.1,1.8,0.38);\n    Ellipsoid[1].rad.x = 0.08;\n    Ellipsoid[1].rad.y = 0.1;\n    Ellipsoid[1].rad.z = 0.01;\n    Ellipsoid[1].materialID=4;\n\n    Ellipsoid[2].center = vec3(-0.1,1.8,0.39);\n    Ellipsoid[2].rad.x = Ellipsoid[0].rad.x*0.25;\n    Ellipsoid[2].rad.y =  Ellipsoid[0].rad.y *0.25;\n    Ellipsoid[2].rad.z = 0.01;\n    Ellipsoid[2].materialID=7;\n    Ellipsoid[3].center = vec3(0.1,1.8,0.39);\n    Ellipsoid[3].rad.x = Ellipsoid[0].rad.x*0.25;\n    Ellipsoid[3].rad.y =  Ellipsoid[0].rad.y *0.25;\n    Ellipsoid[3].rad.z = 0.01;\n    Ellipsoid[3].materialID=7;\n    }\n\n}\n\nvoid InitBambooCopter(vec3 center) {\n    float zoom = 2.5;\n    float sizeOfCircle = 0.1* zoom;\n    float xPos = center.x;\n    float yPos = center.y + sizeOfCircle;\n    float zPos = center.z;\n    for (int i = 0; i < NUM_ROLLING_BALLS; i++)\n    {\n        float angle = 2.0 * PI / float(NUM_ROLLING_BALLS);\n        RollingBalls1[i].center.x = xPos + sizeOfCircle * sin(float(i) * angle + iTime * 12.0);\n        RollingBalls1[i].center.y = yPos;\n        RollingBalls1[i].center.z = zPos + sizeOfCircle * cos(float(i) * angle + iTime * 12.0);\n        RollingBalls1[i].radius = 0.03 ;\n        RollingBalls1[i].materialID = 5;\n    }\n    Stick[13].vertexA = center + vec3(0.0, sizeOfCircle*0.9, 0.0);\n    Stick[13].vertexB = center;\n    Stick[13].radius = 0.03;\n    Stick[13].materialID = 5;\n\n}\nvoid initDoor()\n{\n    Box[0].size = vec3(.4,.8,.05);\n    Box[0].center = vec3(-2.0,0.9,2.0);\n    Box[0].materialID = 2;\n\n    Sphere[7].center =Box[0].center+vec3(-0.15,0.0,0.07);\n    Sphere[7].radius = 0.07;\n    Sphere[7].materialID = 0;\n\n}\n\nvoid initLight()\n{\n    // Lighting Coeffecient\n    float lightCoeff = 1.0 / 12.5;\n\n    // Light 1.\n    Light[0].position = vec3(2.0*cos(1.1*iTime)+0.5, 8.0, 2.0*sin(1.1*iTime)+2.0) * 1.2;\n    Light[0].I_a      = vec3(7.0, 1.0, 4.0) * lightCoeff;\n    Light[0].I_source = vec3(7.0, 1.0, 4.0) * lightCoeff;\n\n    // Light 2.\n    Light[1].position = vec3(2.0*cos(1.1*iTime+PI*0.667)+0.5, 8.0, 2.0*sin(1.1*iTime+PI*0.667)+2.0) * 1.2;\n    Light[1].I_a      = vec3(1.0, 4.0, 7.0) * lightCoeff;\n    Light[1].I_source = vec3(1.0, 4.0, 7.0) * lightCoeff;\n\n    // Light 3.\n    Light[2].position = vec3(2.0*cos(1.1*iTime+PI*1.333)+0.5, 8.0, 2.0*sin(1.1*iTime+PI*1.333)+2.0) * 1.2;\n    Light[2].I_a      = vec3(4.0, 7.0, 1.0) * lightCoeff;\n    Light[2].I_source = vec3(4.0, 7.0, 1.0) * lightCoeff;\n    \n\n    Light[3].position = vec3( 0.0, 4.0, 8.0 );\n    Light[3].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[3].I_source = vec3( 1.0, 1.0, 1.0 ) * 0.3;\n\n}\nfloat seed;\n\nvoid initBouncingBall()\n{\n    Sphere[6].center = vec3( 1.5 * cos(iTime), 0.5 + abs(cos(6.2831 * iTime)), 1.5 *sin(iTime) );\n    Sphere[6].radius = 0.5;\n    Sphere[6].materialID = 1;\n}\n\nvoid InitRollingPyrimid(){\n    // size\n    float size = 1.1;\n    float ballRad = 0.2;\n\n    // translate direction\n    vec3 transDirec = vec3(3.0, 1.5 * ballRad, -0.5);\n    int num_sph=8;\n    for (int i = num_sph; i < NUM_SPHERES; i++){\n        Sphere[i].radius = ballRad;\n        Sphere[i].materialID = 8;\n    }\n\n    Sphere[num_sph].center = size * vec3(0.0, sqrt(6.0), 0.0) + transDirec;\n    Sphere[num_sph+1].center = size * vec3(cos(iTime)         , 0.0, sin(iTime)         ) + transDirec;\n    Sphere[num_sph+2].center = size * vec3(cos(iTime+PI*0.667), 0.0, sin(iTime+PI*0.667)) + transDirec;\n    Sphere[num_sph+3].center = size * vec3(cos(iTime+PI*1.333), 0.0, sin(iTime+PI*1.333)) + transDirec;\n\n    Stick[7].vertexA = Sphere[num_sph].center; Stick[7].vertexB = Sphere[num_sph+1].center;\n    Stick[8].vertexA = Sphere[num_sph].center; Stick[8].vertexB = Sphere[num_sph+2].center;\n    Stick[9].vertexA = Sphere[num_sph].center; Stick[9].vertexB = Sphere[num_sph+3].center;\n    Stick[10].vertexA = Sphere[num_sph+1].center; Stick[10].vertexB = Sphere[num_sph+2].center;\n    Stick[11].vertexA = Sphere[num_sph+1].center; Stick[11].vertexB = Sphere[num_sph+3].center;\n    Stick[12].vertexA = Sphere[num_sph+2].center; Stick[12].vertexB = Sphere[num_sph+3].center;\n\n    Stick[7].radius = ballRad / 2.5; Stick[7].materialID = 3;\n    Stick[8].radius = ballRad / 2.5; Stick[8].materialID = 3;\n    Stick[9].radius = ballRad / 2.5; Stick[9].materialID = 3;\n    Stick[10].radius = ballRad / 2.5; Stick[10].materialID = 3;\n    Stick[11].radius = ballRad / 2.5; Stick[11].materialID = 3;\n    Stick[12].radius = ballRad / 2.5; Stick[12].materialID = 3;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n\n    Plane[2].A = 0.0;\n    Plane[2].B = 1.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 10.0;\n    Plane[2].materialID = 4;\n\n    Plane[3].A = 1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = -10.0;\n    Plane[3].materialID = 0;\n\n    Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 10.0;\n    Plane[4].materialID = 4;\n\n\n\n    InitDoraemon();\n    if (iTime>=23.0){\n    initDoor();\n    }\n    if (iTime>=18.0){\n    vec3 center = vec3(0.0, 2.0, 0.0);\n    InitBambooCopter(center);\n    }\n    if (iTime>=25.0){\n    // Initialize the rolling pyrimid\n    InitRollingPyrimid();\n    }\n    if (iTime>=27.0){\n    initBouncingBall();\n    }\n    \n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // center sphere material.\n    Material[1].k_d = vec3( 1.0, 1.0, 1.0 );\n    Material[1].k_a = 0.0 * Material[1].k_d;\n    Material[1].k_r = 0.8 * Material[1].k_d;\n    Material[1].k_rg = 1.2 * Material[1].k_r;\n    Material[1].n = 128.0;\n    Material[1].ior = 4.5;\n    Material[1].fuzz = -1.0;\n\n    // Pink material.\n    Material[2].k_d = vec3(232.0,107.0,163.0) / 255.0;;\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r =0.5* Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    //  Blue material\n    Material[3].k_d = vec3( 0.0, 0.62, 0.91 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 0.2*Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n\n    //  White material\n    Material[4].k_d = vec3( 200.0,200.0, 200.0) / 255.0;\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = vec3(0.0);;\n    Material[4].k_rg = vec3(0.0);\n    Material[4].n = 128.0;\n\n    //  Bamboo Copter Yellow material\n    Material[5].k_d = vec3(235.0, 188.0, 59.0) / 255.0;\n    //Material[5].k_d = vec3( 1.0, 0.84134, 0.0 );\n    Material[5].k_a = 0.2 * Material[5].k_d;\n    Material[5].k_r = 1.5 * Material[5].k_d;\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 128.0;\n\n    //  Red material\n    Material[6].k_d = vec3(0.9, 0.0314, 0.0667);\n    Material[6].k_a = 0.2 * Material[6].k_d;\n    Material[6].k_r = 1.0 * Material[6].k_d;\n    Material[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].n = 64.0;\n\n    //  Black material\n    Material[7].k_d = vec3( 0.0, 0.0, 0.0 );\n    Material[7].k_a = 0.2 * Material[7].k_d;\n    Material[7].k_r = 2.0 * Material[7].k_d;\n    Material[7].k_rg = 0.5 * Material[7].k_r;\n    Material[7].n = 64.0;\n\n    // Balls - Silver material.\n    Material[8].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[8].k_a = 0.2 * Material[8].k_d;\n    Material[8].k_r = 2.0 * Material[8].k_d;\n    Material[8].k_rg = 0.5 * Material[8].k_r;\n    Material[8].n = 64.0;\n\n    //  Bell Yellow material\n    Material[9].k_d = vec3(255.0, 228.0, 59.0) / 255.0;\n    //Material[5].k_d = vec3( 1.0, 0.84134, 0.0 );\n    Material[9].k_a = 0.2 * Material[9].k_d;\n    Material[9].k_r = 1.5 * Material[9].k_d;\n    Material[9].k_rg = 0.5 * Material[9].k_r;\n    Material[9].n = 128.0;\n\n\n    initLight();\n}\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay(in Ray_t ray, out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg,out float ior, out float fuzz)\n{\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;\n    vec3 nearest_hitPos;\n    vec3 nearest_hitNormal;\n    int nearest_hitMatID;\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    \n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    temp_hasHit=false;\n    \n    \n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n\n        if (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }\n    }\n\n    //head\n    if (IntersectSphere(Sphere[0], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n    {\n        temp_hasHit = true;\n        if (temp_t < nearest_t)\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            vec3 temp = temp_hitPos - Sphere[0].center;\n            float r = Sphere[0].radius * 0.8;\n            //is in face\n            if(temp.x * temp.x + (temp.y - (-Sphere[0].radius + r)) * (temp.y - (-Sphere[0].radius + r)) <= r*r && temp.z > 0.0){\n                //is in mouth\n                nearest_hitMatID = 4;//white\n                if(-r <= temp.y && temp.y <= 0.0)\n                    if(-0.75 * Sphere[0].radius <= temp.x && temp.x <=0.75 * Sphere[0].radius)\n                        if(temp.y >= 64.0 / 45.0 * (temp.x - 0.75 * Sphere[0].radius) * (temp.x + 0.75 * Sphere[0].radius))\n                            nearest_hitMatID = 6;//red\n                            \n            }\n            else\n                nearest_hitMatID = Sphere[0].materialID;//blue\n        }\n    }\n    //others\n    for (int i = 1; i < NUM_SPHERES; i++)\n    {\n        float temp_t;\n        if (IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n\n    //body\n    if (IntersectStick(Stick[0], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n    {\n        temp_hasHit = true;\n        if (temp_t < nearest_t)\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n\n            float r = 0.85 * Stick[0].radius;\n            vec3 temp = temp_hitPos - Stick[0].vertexB;\n            vec3 bottom = Stick[0].vertexA - Stick[0].vertexB;\n            float x = temp.x - 0.5 * bottom.x;\n            float y = temp.y - 0.2 * bottom.y;\n            //is in belly\n            if(x * x + y * y <= r * r && temp.z > 0.0){\n                float rr = 0.77 * r;\n                if(x * x + y * y <= rr * rr && temp.z > 0.0 && y <= 0.0){\n                    float rrr = 0.73 * r;\n                    if(x * x + y * y <= rrr * rrr && temp.z > 0.0 && y <= -0.04)\n                        nearest_hitMatID = 4;\n                    else\n                        nearest_hitMatID = 7;\n                }\n                    \n                    \n                else\n                nearest_hitMatID = 4;\n            }\n                \n            else\n            nearest_hitMatID = Stick[0].materialID;\n        }\n    }\n    //others\n    for (int i = 1; i < NUM_STICKS; i++)\n    {\n        float temp_t;\n        if (IntersectStick(Stick[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Stick[i].materialID;\n            }\n        }\n    }\n\n    for (int i = 0; i < NUM_Ellipsoids; i++)\n    {\n        float temp_t;\n        if (IntersectEllipsoid(Ellipsoid[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Ellipsoid[i].materialID;\n            }\n        }\n    }\n\n    for (int i = 0; i < NUM_ROLLING_BALLS; i++)\n    {\n        float temp_t;\n        if (IntersectSphere(RollingBalls1[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = RollingBalls1[i].materialID;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_ROLLING_BALLS; i++)\n    {\n        float temp_t;\n        if (IntersectSphere(RollingBalls2[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = RollingBalls2[i].materialID;\n            }\n        }\n    }\n\n        \n    for (int i = 0; i < NUM_BOXS; i++)\n    {\n\n        if (IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            temp_hasHit = true;\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n            }\n        }\n    }\n    hasHitSomething=temp_hasHit;\n\n\n    hasHit = hasHitSomething;\n    if (!hasHitSomething)\n        return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3(0.0);\n    \n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    Ray_t shadowRay;\n    shadowRay.o = nearest_hitPos;\n\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        bool intersect = false;\n\n        // Check for shadow by casting a shadow ray to each light source.\n\n        for (int j = 0; j < NUM_PLANES; j++)\n        {\n            if (IntersectPlane(Plane[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n        for (int j = 0; j < NUM_SPHERES; j++)\n        {\n            if (IntersectSphere(Sphere[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n\n        for (int j = 0; j < NUM_STICKS; j++)\n        {\n            if (IntersectStick(Stick[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n\n\n        for (int j = 0; j < NUM_ROLLING_BALLS; j++)\n        {\n            if (IntersectSphere(RollingBalls1[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n        for (int j = 0; j < NUM_ROLLING_BALLS; j++)\n        {\n            if (IntersectSphere(RollingBalls2[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n\n        for (int j = 0; j < NUM_BOXS; j++)\n        {\n            if (IntersectBox(Box[j], shadowRay, DEFAULT_TMIN, distance(Light[i].position,nearest_hitPos)))\n            {\n                intersect = true;\n                break;\n            }\n        }\n        if (!intersect)\n        {\n            I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, intersect, Material[nearest_hitMatID], Light[i]);\n        }\n        \n    }\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    ior = Material[nearest_hitMatID].ior;\n    fuzz = Material[nearest_hitMatID].fuzz;\n\n    return I_local;\n}\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\n    // Position the camera.\n    vec2 mouse_pos = iMouse.xy /iResolution.xy;\n    vec3 cam_pos = 3.0 * normalize(vec3(sin(0.35 * iTime + 3.0*mouse_pos.x), 0.2 + 0.8 * mouse_pos.y, \n                   abs(cos(0.35 * iTime + 3.0*mouse_pos.x)))) + vec3(0.0,2.0,4.0);\n   // vec3 cam_pos = vec3( 0.0, 2.0, 3.0 );\n    vec3 cam_lookat = vec3( 0.0, 0.0, -1.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    vec3 er = normalize(vec3(pixel_pos,pixel_pos_z));\n    pRay.d = normalize(mat3(cam_x_axis,cam_y_axis,cam_z_axis)*er);\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay[TOTAL_RAY_NUM];\n    nextRay[0] = pRay;\n    nextRay[0].should_cast = true;\n    nextRay[0].weight = 1.0;\n    \n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        float ior,fuzz;\n        \n        vec3 I_local;\n        //Cast at least one ray\n        //Maybe we need to cast more ray\n        for(int i=0;i<TOTAL_RAY_NUM;++i)\n        {\n            if(!nextRay[i].should_cast)\n                break;\n            I_local += CastRay( nextRay[i], hasHit, hitPos, hitNormal, k_rg,ior,fuzz)*nextRay[i].weight;\n            nextRay[i].should_cast = false;\n        }\n        \n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n        \n        vec3 reflected = reflect(nextRay[0].d, hitNormal);\n        \n        if(ior<0.0){ \n            if(fuzz<0.0){\n                //For specular surface, we only cast one ray\n                nextRay[0] = Ray_t( hitPos, reflected,true,1.0);\n            }else{\n                //For glossy surface, we need to sample more ray\n                for(int i=0;i<GLOSSY_RAY_NUM;++i){\n                    nextRay[i] = Ray_t( hitPos, reflected+fuzz*random_in_unit_sphere(seed),true,GLOSSY_RAY_WEIGHT);\n                    //refresh seed\n                    seed = hash1(seed);\n                }\n            }\n        }\n        else{\n        //For trasparent surface,we trace one or two ray\n            vec3 dir = nextRay[0].d;\n            if(dot(-dir,hitNormal)>=0.0){\n                ior = 1.0/ior;\n            }else{\n                hitNormal = -hitNormal;\n            }\n            float cos_theta = min(dot(-dir, hitNormal), 1.0);\n            float sin2_theta = 1.0 - cos_theta*cos_theta;\n            bool total_internal_reflect = ior*ior*sin2_theta > 1.0;\n            if(total_internal_reflect){\n            //For total internal reflection, we only cast one ray\n               nextRay[0] = Ray_t( hitPos, reflected,true,1.0);\n            }\n            else{\n            //We cast one ray for reflection, one ray for refraction\n               float reflective = reflectance(cos_theta,ior);\n               nextRay[0] = Ray_t(hitPos,reflected,true,reflective);\n               nextRay[1] = Ray_t(hitPos,refract(-dir,hitNormal,ior),true,1.0-reflective);\n            }\n       }\n    }\n    fragColor = vec4( I_result, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 34026,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/shekhar-tyagi/doraemon-theme-song"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//============================================================================\n// Constants.\n//============================================================================\n\n\nconst float PI = 3.1415926536;\n\nconst float TAU = 2.0*PI;\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\n\nfloat cuberoot( float x ) { return sign(x)*pow(abs(x),1.0/3.0); }\n\nvec3 random_in_unit_sphere(float seed) {\n    float u = hash1(seed);\n    float v = hash1(seed);\n    float theta = u*2.0*PI;\n    float phi = acos(2.0*v-1.0);\n    float r = cuberoot(hash1(seed));\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r*sinPhi*cosTheta;\n    float y = r*sinPhi*sinTheta;\n    float z = r*cosPhi;\n    return vec3(x,y,z);\n}\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 3;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 4;\nconst int NUM_MATERIALS = 11;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 20;\nconst int NUM_STICKS = 40;\nconst int NUM_Ellipsoids=10;\nconst int NUM_ROLLING_BALLS = 8;\nconst int NUM_BOXS = 2;\n// Constants for ray numbers\nconst int TOTAL_RAY_NUM = 10;\nconst int GLOSSY_RAY_NUM = 10;\nconst float GLOSSY_RAY_WEIGHT = 1.0/float(GLOSSY_RAY_NUM);\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n    bool should_cast;\n    float weight;\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Stick_t {\n    vec3 vertexA;\n    vec3 vertexB;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Ellipsoid_t {\n    vec3 center;\n    vec3 rad;       // radius of x,y,z axis\n    int materialID;\n};\n\nstruct Box_t{\n    vec3 center;\n    vec3 size;\n    int materialID;\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n    float ior;  // Index of Refraction\n    float fuzz; // fuzz parameter\n};\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nStick_t Stick[NUM_STICKS];\nEllipsoid_t Ellipsoid[NUM_Ellipsoids];\nSphere_t RollingBalls1[NUM_ROLLING_BALLS];\nSphere_t RollingBalls2[NUM_ROLLING_BALLS];\nBox_t Box[NUM_BOXS];\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 V = ray.o - sph.center;\n    float a0 = dot(V, V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n    float discriminate = DdotV * DdotV - a0;\n\n    if (DdotV <= 0.0) {\n\n        if (discriminate >= 0.0) {\n            t = -DdotV - sqrt(discriminate);\n            hitPos = ray.o + t * ray.d;\n            hitNormal = normalize(hitPos - sph.center);\n            return (t >= tmin && t<= tmax);\n        }\n    }\n    return false;\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 V = ray.o - sph.center;\n    float a = dot(V,V) - sph.radius * sph.radius;\n    float DdotV = dot(ray.d, V);\n    float discriminate = DdotV * DdotV - a;\n    if (DdotV <= 0.0) {\n\n        if (discriminate >= 0.0) {\n            float t1 = -DdotV - sqrt(discriminate);\n            float t2 = -DdotV + sqrt(discriminate);\n            return ((t1 >= tmin && t1<= tmax) || (t2 >= tmin && t2 <= tmax));\n        }\n    }\n    return false;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\n\n// reference from https://www.shadertoy.com/view/Xt3SzX of capIntersect() and capNormal\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the normal vector at the specified position on the stick surface.\n/////////////////////////////////////////////////////////////////////////////\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectStick( in Stick_t stk, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    t = capIntersect( ray.o, ray.d, stk.vertexA, stk.vertexB, stk.radius );\n\n    if (t >= 0.0 && t <= tmax){\n        hitPos = ray.o + t * ray.d;\n        hitNormal = capNormal(hitPos, stk.vertexA, stk.vertexB, stk.radius);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectStick( in Stick_t stk, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t = capIntersect( ray.o, ray.d, stk.vertexA, stk.vertexB, stk.radius );\n    if (t >= 0.0 && t >= tmin && t <= tmax){\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n// reference from https://www.shadertoy.com/view/llsSzn of eliIntersect() and eliNormal\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between an ellipsoid and a ray.\n/////////////////////////////////////////////////////////////////////////////\nfloat eliIntersect( in vec3 ro, in vec3 rd,in Ellipsoid_t sph )\n{\n    vec3 oc = ro - sph.center;\n    \n    vec3 ocn = oc / sph.rad;\n    vec3 rdn = rd / sph.rad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.0);\n\tif( h<0.0 ) return -1.0;\n\treturn (-b - sqrt( h ))/a;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the normal vector at the specified position on the ellipsoid surface.\n/////////////////////////////////////////////////////////////////////////////\nvec3 eliNormal( in vec3 pos, in Ellipsoid_t sph )\n{\n    return normalize( (pos-sph.center)/sph.rad );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between an ellipsoid and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectEllipsoid( in Ellipsoid_t tr, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    t = eliIntersect( ray.o, ray.d, tr );\n\n    if (t >= 0.0 && t <= tmax){\n        hitPos = ray.o + t * ray.d;\n        hitNormal = eliNormal(hitPos, tr);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between an ellipsoid and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectEllipsoid( in Ellipsoid_t tr, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t = eliIntersect( ray.o, ray.d, tr );\n    if (t >= 0.0 && t >= tmin && t <= tmax){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance.\n    float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n    r0 = r0*r0;\n    float temp = 1.0-cosine;\n    float temp2 = temp*temp;\n    return r0 + (1.0-r0)*temp*temp2*temp2;\n}\n\nbool IntersectBox( in Box_t box, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    vec3 ro = ray.o;\n    ray.o -= box.center;\n    vec3 m = sign(ray.d)/max(abs(ray.d), 1e-8);\n    vec3 n =m*ray.o;\n    vec3 k = abs(m)*box.size;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if( tN>tF || tF<=0.0) return false;\n    \n    if(tN >= tmin && tF<=tmax){\n        t = tN;\n        hitPos = ro + t*ray.d;\n        hitNormal = -sign(ray.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return true;\n    }\n    if(tF >= tmin && tF <= tmax){\n        t = tF;\n        hitPos = ro + t*ray.d;\n        hitNormal = -sign(ray.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return true;\n    }\n    \n    return false;\n}\n\nbool IntersectBox( in Box_t box, in Ray_t ray, in float tmin, in float tmax )\n{\n    ray.o -= box.center;\n    vec3 m = sign(ray.d)/max(abs(ray.d), 1e-8);\n    vec3 n =m*ray.o;\n    vec3 k = abs(m)*box.size;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if( tN>tF || tF<=0.0) return false;\n    \n    return (tN >= tmin && tF<=tmax)||(tF >= tmin && tF <= tmax);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}