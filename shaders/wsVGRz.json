{
    "Shader": {
        "info": {
            "date": "1569848432",
            "description": "My first attempt at SDF ray marching.\nIt is a shader interpretation of MC Escher's drawings of the mosk of Cordoba.\nMany thanks to Bigwings, iq and Shane for the learning material.\nMusic by : Blanloeil Nino",
            "flags": 64,
            "hasliked": 0,
            "id": "wsVGRz",
            "likes": 18,
            "name": "Cordoba",
            "published": 3,
            "tags": [
                "raymarching",
                "reflexion",
                "escher",
                "softshadows",
                "marble"
            ],
            "usePreview": 0,
            "username": "PixelPhil",
            "viewed": 740
        },
        "renderpass": [
            {
                "code": "//\n// This is my first attempt at a ray marching shader\n// It is inspired of MC Escher's drawings of the Cordoba mosk.\n//\n// https://hotelviento10.es/en/art/77-the-drawings-of-cordoba-by-m-c-escher\n//\n// It was mostly developped during the 8 train hours of a week-end away from my workstation\n// so one of my objectives was to keep a decent framerate on my laptop and, although\n// the fan is screaming like hell I managed to maintain a 25fps preview which is not bad.\n// I might push the rendering a bit with AA and motion blur later.\n//\n// I'm also quite confident there is an enormous room for optimization.\n//\n// I started writing this thing after watching the Youtube intro to ray marching by BigWing\n// and studiying a few shaders by iq and Shane so kudos to these guys.\n// \n// Although I've been doing 'regular\" 3D code for quite some years now discovering the\n// wonders of Signed distance Fields and their properties feels like. I would never have\n// believed that I could achieve such an elaborate result (soft shadows, reflections,\n// procedural marble, AO & all) in less than 600 lines of code before comments.\n// This is truly opening new doors in my mind.\n//\n// I first implemented the shadows using a classic ray marching scheme an tried to soften\n// them by Jittering the light position and averaging a bunch of sample, the result was\n// super noisy and very slow. Thanks to iq's latest shader I figured out the concept of\n// using 'penumbra' to get soft shadows in a single ray cast and implemented it for a\n// huge improvement. At first I struggled a bit with it as my SDF turned non-eucydean when\n// I tried to blend my arches into my pillars with mix.There were many artefacts, missed\n// details and misplaced shadows. I took a bit of time to rework my SDF with a cone\n// intersection which fixed everything for a very similar shape.\n//\n\n// EDIT 3/01/2020 : Replace the Silly 3D texture for Noise with procedural Perlin noise\n//\t\t\t\t\tIt only ended up being used for the floor and the ceiling anyways\n\n\n#define MAX_DST 40.0\n#define FOG_DST 5.0\n#define MIN_DST 0.001\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// A 2d Noise texture I use for the marble\nfloat Noise(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\nfloat NoisePM(vec2 uv)\n{\n    return Noise(uv) * 2.0 - 1.0;\n}\n\n\n// A basic Perlin-style marble that I hacked quite a bit\nfloat marble(vec3 pos)\n{\n    /*\n    vec3 marbleAxis = vec3(0.5, 0.4, -0.1);\n  \n\tvec3 mfp = (pos + dot(pos, marbleAxis) * marbleAxis * 2.0) * 0.02;*/\n    \n\tfloat marble = 0.0;\n    \n    pos *= 1.0;\n    \n\tmarble += abs(NoisePM(pos.xz));\n\tmarble += abs(NoisePM(pos.xz * 4.0)) * 0.5;\n\tmarble += abs(NoisePM(pos.xz * 8.0)) * 0.3;\n    //marble += abs(NoisePM(pos.xz * 16.0)) * 0.15;\n\n    \n\tmarble /= (1.0 + 0.5 + 0.3 /*+ 0.15*/);\n\tmarble = pow(1.0 - marble, 3.0) * 1.5;\n    \n\treturn marble;\n}\n\nvec3 marble(vec3 pos, vec3 col1, vec3 col2)\n{\n\treturn mix( col1, col2, marble(pos) );\n}\n\n// box distance function (stolen from iq)\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n// cylinder distance function (stolen from iq)\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n// cone distance function\nfloat sdCone(vec3 p, vec2 c)\n{\n    float q = length(p.xz);\n    return dot(c, vec2(q, p.y));\n}\n\n// boolean add with y as material id\nvec2 combine(vec2 a, vec2 b)\n{\n    return (a.x < b.x ? a : b);   \n}\n\n// boolean subtract with y as material id\nvec2 subtract(vec2 a, vec2 b)\n{\n    b.x = -b.x;\n    return (a.x > b.x ? a : b);\n}\n\nfloat subtract(float a, float b)\n{\n    return max(a, -b);\n}\n\n// boolean intersect with y as material id\nvec2 inter(vec2 a, vec2 b)\n{\n    return (a.x > b.x ? a : b);\n}\n\n\n// Material ids\n//\n//0.0 -> floor\n//1.0 -> Ceiling\n//2.0 -> Ceiling wall\n//3.0 -> higer arch\n//4.0 -> Pillar\n//5.0 -> Lower arch\n\nvec2 SDF(vec3 pos)\n{\n    vec2 floorVal = vec2(pos.y + 0.5, 0.0); // ground plane\n    \n    // Bend space to mirror-tile the arches on both x and z\n    pos.x = abs(mod(pos.x, 2.0) - 1.0);\n    pos.z = abs(mod(pos.z, 4.0) - 2.0);\n    \n    \n    float ceilValue = 4.5 - pos.y;\n    ceilValue = min(ceilValue, sdBox(pos - vec3(0.0, 4.3, 0.0), vec3(0.2, 0.2, 4.0)));\n    vec2 ceilVal = vec2(ceilValue, 1.0); // Ceiling and beams with label 1.0\n    \n    \n    vec2 dist = combine(floorVal, ceilVal);\n    \n    vec2 arch1 = vec2(sdCylinder(pos, vec3(1.0, 3.0, -0.3),vec3(1.0, 3.0, 0.3), 1.15), 3.0);\n    arch1 = combine(arch1, vec2(sdBox(pos - vec3(0.0, 5.0, 0.0), vec3(2.0, 1.4, 0.23)), 3.5));\n    vec2 arch1Neg = vec2(sdCylinder(pos, vec3(1.0, 3.0, -0.4),vec3(1.0, 3.0, 0.4), 0.78), 3.0);\n    arch1 = subtract(subtract(arch1, arch1Neg), vec2(pos.y - 3.0, 3.0));\n\n    \n    float colDist = length(pos.xz) - 0.15;\n    float pillarBox  = sdBox(pos - vec3(0.0, 1.85, 0.0), vec3(0.16, 1.2, 0.3));\n    float pillarBox2 = sdBox(pos - vec3(0.0, 1.85, 0.0), vec3(0.22, 1.2, 0.2));\n    float cone = sdCone(pos - vec3(0.0, 1.2, 0.0), normalize(vec2(2.0, -1.0)));\n    \n\tpillarBox = min(pillarBox, pillarBox2);    \n    pillarBox = max(pillarBox, cone);\n    pillarBox = min(pillarBox, colDist);\n\n    vec2 pillar = vec2(pillarBox, 4.0);\n\n\n    \n    arch1 = combine(pillar, arch1);\n    \n    \n    float arch2 = sdCylinder(pos, vec3(1.0, 1.8, -0.15),vec3(1.0, 1.8, 0.15), 1.13);\n    float arch2Neg = sdCylinder(pos, vec3(1.0, 1.8, -0.6),vec3(1.0, 1.8, 0.6), 0.8);\n    \n    arch2 = subtract(subtract(arch2, arch2Neg), pos.y - 2.0);\n    \n    vec2 arch2Value = vec2(arch2, 5.0);\n    \n    dist = combine(dist, arch1);\n    dist = combine(dist, arch2Value);\n    \n    \n     \n    \n\treturn dist;// + Noise(pos * 3.0) * 0.0003 // a bit of noise make refections an highlights richer\n}\n\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst)\n{\n    vec2 dst = SDF(pos);\n    //return dst;\n    \n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        t += dst.x;\n        pos += dst.x * dir;\n        dst = SDF(pos);\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\n// A marble pattern with .a as Speculairty/Reflection\nvec4 floorColor(vec3 pos)\n{\n    vec2 uvs = fract(pos.xz * vec2(0.5, 0.25));\n    vec2 ids = floor(uvs);\n    \n    bool mask1 = uvs.x > uvs.y;\n    bool mask2 = uvs.x > 1.0- uvs.y;\n\n    float mask = mask2 ^^ mask1 ? 0.0 : 1.0;\n    \n    vec3 baseCol = mix(vec3(0.2, 0.6, 0.3),vec3(0.6, 0.2, 0.4), mask);\n    \n    float marble = marble(pos * 4.0);\n\n    return  vec4(baseCol * (1.0 - marble * 0.2), 1.1 + marble);\n}\n\n\n// The stripes in polar space\nfloat ArchPattern(vec3 pos, float height)\n{\n    pos.x = abs(mod(pos.x, 2.0) - 1.0);\n    \n    vec2 delta = pos.xy - vec2(1.0, height);\n    float angle = atan(delta.y, delta.x);\n    \n    return S(0.26, 0.25, abs(fract(angle * 2.8) - 0.5));\n}\n\n\nvec3 archesColor(vec3 pos, float matId)\n{\n        float arch = 1.0;\n        \n        if (matId < 3.1)\n        {\n            arch = ArchPattern(pos, 3.0);\n        }\n        else if (matId > 4.9)\n        {\n            arch = ArchPattern(pos, 1.8);\n        }\n        \n        //vec3 mainColor = mix(vec3(0.90, 0.70, 0.60) * 0.9, vec3(0.80, 0.5, 0.40) * 0.9, S(2.0, 1.5, pos.y));\n        \n        vec3 col = mix(vec3(0.7, 0.41, 0.40) * 0.8, vec3(1.0, 0.8, 0.70), arch); \n        //vec3 col2 = mix(vec3(0.8, 0.53, 0.52), mainColor, arch);\n        \n    \t// The marble onthe colums didn't add that much to the look\n        return col;//marble(pos + col, col2, col);\n}\n\n\n// Some pretty shitty procedural wood (but it's barely visible)\nvec3 ceilingColor(vec3 pos)\n{\n    float p = pos.x * 5.0;\n    \n    p += Noise(pos.xy * vec2(0.5, 0.05) + pos.y * 0.1) * 3.0;\n    \n    float wood = fract(sin(p) * 2.0);\n    \n    return mix(vec3(0.69, 0.55, 0.4) * 0.8, vec3(0.5, 0.25, 0.15), wood);\n}\n\n\nvec4 MatColor(float matId, vec3 pos)\n{\n    if (matId < 0.1)\n    {\n        return floorColor(pos);\n    }\n    else if (matId < 1.1)\n    {\n        return vec4(ceilingColor(pos), 0.1);\n    }\n    else\n    {\n        return vec4(archesColor(pos, matId), 1.0);\n    }\n}\n\n// inspired by\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 pos, vec3 lPos)\n{\n    lPos.xyz += (vec3(N2(pos.xy), N2(pos.yz), N2(pos.zx)) - 0.5)* 0.03; //jitters the banding away\n    \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += dir * MIN_DST * 10.0;  // Get out of the surface\n    \n    vec2 dst = SDF(pos); // Get the SDF\n    \n    // Start casting the ray\n    float t = 0.0;\n    float obscurance = 1.0;\n    \n    while (t < len)\n    {\n        if (dst.x < MIN_DST) return 0.0; \n        \n        obscurance = min(obscurance, (20.0 * dst.x / t)); \n        \n        t += dst.x;\n        pos += dst.x * dir;\n        dst = SDF(pos);\n    }\n    \n    return obscurance;     \n}\n\n\nfloat shadow(vec3 p, vec3 n, vec3 lPos)\n{\n    return shadow(p + n * MIN_DST * 4.0, lPos);\n}\n\n// Computes the X of a pseudo-random path that will never \n// bump into pillar With agivent z and a seed value\nfloat CamX(float camZ, float seed)\n{\n    float normalized = (camZ - 2.0) / 4.0; // nomalize Z on the column grid\n    \n    float ratio = fract(normalized);  // 0.0 -> between cells\n    float cur = floor(normalized);    // current cell id\n    float next = cur + 1.0;\n    \n    // Pick random arches (0.0, 1.0 ou 2.0) for the current and next cell\n    cur = floor(N2(vec2(cur, seed)) * 2.9) * 4.0 - 2.0;\n    next = floor(N2(vec2(next, seed)) * 2.9) * 4.0 - 2.0;\n\n    // Cosine interpolate between the two\n    ratio = (1.0 - cos(ratio * 3.14)) * 0.5;\n    return mix(cur, next, ratio);\n}\n\n// Camera position from z\nvec3 CamPos(float z)\n{\n    float x = CamX(z, 666.0);\n    float y = 1.0 + sin(z * 0.14); // going up & down\n    return vec3(x, y, z);\n}\n\nconst vec3 fogColor = vec3(1.5f, 1.0f, 0.6); \nconst vec3 lightCol =  vec3(2.0, 1.5, 1.0);\n\n// A simpler rendering for reflections (diffuse only)\nvec3 reflection(vec3 pos, vec3 ref, vec3 lightPos)\n{\n    pos += ref * MIN_DST * 4.0;\n    \n    vec2 d = castRay(pos, ref, MAX_DST, MIN_DST);\n    \n    vec3 nPos = pos + ref * d.x;\n\n    float hAtten = sat((5.0 - nPos.y) / 3.0);\n    \n    if (d.x > MAX_DST)\n    {\n        return fogColor * hAtten; \n    }\n    else   \n    {\n   \n        vec3 col = MatColor(d.y, nPos).rgb;// * atten;\n      \t  \n      \tvec3 pointDir = lightPos - nPos;\n        float len = length(pointDir);\n        \n                \n        vec3 n = calcNormal(nPos);\n        \n        float atten = sat(1.0 - len / 20.0);\n        \n        atten *= shadow(nPos, n, lightPos);\n        \n        pointDir /= len;\n        \n        float diffuse = sat(dot(n, pointDir));\n        \n        col *= (diffuse * (atten * atten) * hAtten);\n        \n        return col;\n    }\n}\n\n// Main rendering\nvec3 render(vec2 uv, float time)\n{\n    float camZ = time * 0.6;\n    \n    // Compute camera position and 3-Axis base\n    vec3 camPos = CamPos(camZ);\n    vec3 nextPos = CamPos(camZ + 2.5);\n    vec3 camDir = normalize(nextPos - camPos);\n    vec3 camRight = normalize(vec3(-camDir.z, 0.0, camDir.x));\n    vec3 camUp = cross(camRight, camDir);\n    \n    // Compute ray\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir * 1.8 + (camRight * uv.x)  +  (camUp * uv.y));\n    \n \t// Liighting & sading\n    vec3 lightDir = normalize(vec3(1.0, -0.4, 1.0));\n \n    float lightZ = camZ - 1.0;\n    float lightX = CamX(lightZ, 576.0);\n    \n    vec3 lightPos = vec3(lightX, 1.5, lightZ);\n    \n    vec2 d = castRay(rayPos, rayDir, MAX_DST, MIN_DST);\n    \n    vec3 col;\n    \n    if (d.x > MAX_DST)\n    {\n        col = fogColor; \n    }\n    else   \n    {\n        //float field = fract(d * 1.0);\n\t    col = vec3(d.y / 8.0);//\n        vec3 pos = camPos + rayDir * d.x;\n        \n        vec4 mat = MatColor(d.y, pos);\n        \n        vec3 n = calcNormal(pos);\n        \n\n        vec3 pointDir = lightPos - pos;\n        float len = length(pointDir);\n        \n        float atten = sat(1.0 - len / 20.0);\n        \n        pointDir /= len;\n        \n        //float ambient = (n.y + 0.5) * 0.1;// mix(vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.0), n.y * 0.5 + 0.5);\n        \n        float lambertPoint = 0.0;\n        \n \t\tatten *= atten;\n     \n        float shadow = shadow(pos, n, lightPos); \n        \n        lambertPoint = sat(dot(n, pointDir));\n        \n        lambertPoint *= shadow * atten; \n        \n        vec3 ref = reflect(rayDir, n);\n        float specular =  sat(dot(pointDir, ref));\n        \n        specular = specular * specular * shadow * atten;\n\n        vec3 diffuseCol = lambertPoint * lightCol;\n        \n        vec3 specularCol = vec3(specular);\n        \n        col = (mat.rgb * diffuseCol) + mat.a * specularCol;\n        \n        float dst = 1.0 - sat(SDF(pos + n * 0.5).x * 1.0);\n\n        col *= vec3((1.0 - dst * dst) * 0.7 + 0.3); // Fake AO\n        \n        if (mat.a > 1.05) // Reflections on the floor\n        {\n            float fresnel = abs(dot(n, rayDir));\n            col += reflection(pos, ref, lightPos) * atten * fresnel;// * mat.a;\n        }\n        \n        float fogDst = sat(d.x / MAX_DST);\n\n        col = mix(col, fogColor, pow(fogDst, 1.5));\n    }\n    \n    return col;\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // an attempt a 4X Multisampling, quite slow, not neat\n\t/*\n    vec4 offset = vec4(-0.25,0.25,-0.25,0.25) / iResolution.y;\n    float noize = N2(uv) * 0.005;\n  \tvec3 col = render(uv + offset.zx, iTime);\n    col += render(uv + offset.yw, iTime + 0.005 + noize);\n    col += render(uv + offset.wx, iTime + 0.01 + noize);\n    col += render(uv + offset.xz, iTime + 0.015 + noize);\n    col /= 4.0;\n\t*/\n    \n    vec3 col = render(uv, iTime + 9.0); // +9 is for a nicer thumbnail\n    \n    // Gamma correction\n    float gamma = 0.85;\n    col = vec3(pow(col.r, gamma), pow(col.g, gamma), pow(col.b, gamma));\n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 19777,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/blanloeil-nino/arabian-flute"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}