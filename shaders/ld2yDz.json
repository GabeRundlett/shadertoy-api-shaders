{
    "Shader": {
        "info": {
            "date": "1491741372",
            "description": "6 Shaders mapped on each face of a cube in Amiga 1990 style.\nCoded for fun and because I love cubes",
            "flags": 64,
            "hasliked": 0,
            "id": "ld2yDz",
            "likes": 31,
            "name": "6 Shaders Cube",
            "published": 3,
            "tags": [
                "raymarching",
                "cube",
                "amiga",
                "scroll",
                "raster"
            ],
            "usePreview": 1,
            "username": "Himred",
            "viewed": 1964
        },
        "renderpass": [
            {
                "code": "// 6 shaders mapped on the 6 faces of a cube without any buffer\n//\n// Coded because I love cubes (don't ask me why)\n// and also love the retro amiga scene.\n//\n// The six shaders I love and I used here:\n//\n// Face 1: WWDC14 by capnslipp - https://www.shadertoy.com/view/XdfyRB\n// Face 2: Plasma by Klk - https://www.shadertoy.com/view/XsVSzW\n// Face 3: YaraGui by dila - https://www.shadertoy.com/view/ldlyWS\n// Face 4: Combustible Voronoi by Shane - https://www.shadertoy.com/view/4tlSzl\n// Face 5: Ring twister by Flyguy - https://www.shadertoy.com/view/Xt23z3\n// Face 6: Glenz by myself - https://www.shadertoy.com/view/4lt3R7 \n//\n// The rasterization is from: https://www.shadertoy.com/view/MdS3Rz by Hlorenzi\n// The sinus croll is by myself improved by gPlatl\n//\n// Tune is from the game Xenon2 on Amiga\n\n\nvec3 xcolor = vec3(0.2, 0.5, 1.0);\nvec2 xtp  = vec2(0);  // text position\nvec2 xpos;\nfloat tau = atan(1.0) * 8.0;\nfloat pi = atan(1.0) * 4.0;\nfloat aaSize = 0.0;\nvec3 cubevec;\n\n#define FONT_SIZE1 0.45\n#define FONT_SIZE2 0.3\n#define FONT_SPACE 0.42\n#define SIN_FREQ 0.75\n#define SIN_SPEED 3.0\n#define SCROLL_LEN 65.\n#define SCROLL_SPEED 2.0\n#define SIN_AMP 0.5\n#define S(a) c+=char(float(a)); xtp.x-=FONT_SPACE;\n#define xtime iTime\n#define NUM_FACES 4\n#define IN_RADIUS 0.25\n#define OUT_RADIUS 0.70\n#define XSCROLL_SPEED -0.9\n#define COLOR_1 0.50, 0.90, 0.95\n#define COLOR_2 0.95, 0.60, 0.10\n\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\nvec3 Bars(vec2 uv)\n{\n    //vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.1, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.1, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.1, 1.0);\n    return color;\n}\n\nvec3 Twister(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat Cube( vec3 p )\n{\n    p=Twister(p);\n    cubevec.x = sin(iTime);\n    cubevec.y = cos(iTime);\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\nvec4 Glenz(in vec2 uv )\n{\n    float pat = iTime*5.0;\n    float Step = 1.0;\n    float Distance = 0.0;\n    float Near = -1.0;\n    float Far = -1.0;\n    vec3 lightPos = vec3(1.5, 0, 0);\n    vec2 p = -1.0 + uv *2.0;\n    vec2 kp=uv;\n    vec4 m = iMouse / iResolution.xxxx;\n    float hd=-1.;\n    \n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n            \t\tif(hd<0.) hd=Distance;\n                    if( Near < 0.0 ) Near = Far;\n            \t\tif(m.z<=0.0) Distance += 0.05; else break; // 0.05 is a magic number \n                }\n        }\n\n    vec3 Color=Bars(uv);\n    if( Near > 0.0 )\n    \t{\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n    return vec4( Color, 1.0 );\n}\n\n\n\nvec4 slice(float x0, float x1, vec2 uv)\n{\n    float u = (uv.x - x0)/(x1 - x0);\n    float w = (x1 - x0);\n    vec3 col = vec3(0);\n    col = mix(vec3(COLOR_1), vec3(COLOR_2), u);\n    col *= w / sqrt(2.0 * IN_RADIUS*IN_RADIUS * (1.0 - cos(tau / float(NUM_FACES))));\n    col *= smoothstep(0.05, 0.10, u) * smoothstep(0.95, 0.90, u) + 0.5;\n    uv.y += iTime * XSCROLL_SPEED; //Scrolling\n    col *= (-1.0 + 2.0 * smoothstep(-0.03, 0.03, sin(u*pi*4.0) * cos(uv.y*16.0))) * (1.0/16.0) + 0.7;\n    float clip = 0.0;\n    clip = (1.0-smoothstep(0.5 - aaSize/w, 0.5 + aaSize/w, abs(u - 0.5))) * step(x0, x1);\n    return vec4(col, clip);\n}\n\nvec4 Ring(in vec2 uv)\n{\n    aaSize = 2.0 / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + pi);\n    uvr.x -= OUT_RADIUS;\n    vec3 col = vec3(0.05);\n    float angle = uvr.y + 2.0*iTime + sin(uvr.y) * sin(iTime) * pi;\n    \n    for(int i = 0;i < NUM_FACES;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + tau * (float(i) / float(NUM_FACES)));\n        float x1 = IN_RADIUS * sin(angle + tau * (float(i + 1) / float(NUM_FACES)));\n        vec4 face = slice(x0, x1, uvr);\n        col = mix(col, face.rgb, face.a); \n    }\n\treturn vec4(col, 1.0);\n}\n\n\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i;\n    vec3 L = vec3(7.4, 5.6, 4.4);\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L);\n}\n\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat xvoronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d;\n}\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., p.z+iTime*1.5);\n\n    const int iter = 5;\n    float tot = 0., sum = 0., amp = 1.;\n\n    for (int i = 0; i < iter; i++) {\n        tot += xvoronoi(p + t) * amp;\n        p *= 2.0;\n        t *= 1.5;\n        sum += amp;\n        amp *= 0.5;\n    }\n    return tot/sum;\n}\n\nvec4 Voronoi(in vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n\tuv += vec2(sin(iTime*0.5)*0.25, cos(iTime*0.5)*0.125);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\tfloat cs = cos(iTime*0.25), si = sin(iTime*0.25);\n\trd.xy = rd.xy*mat2(cs, -si, si, cs); \n\tfloat c = noiseLayers(rd*2.);\n\tc = max(c + dot(hash33(rd)*2.-1., vec3(0.015)), 0.);\n    c *= sqrt(c)*1.5;\n    vec3 col = firePalette(c);\n    col = mix(col, col.zyx*0.15+c*0.85, min(pow(dot(rd.xy, rd.xy)*1.2, 1.5), 1.));\n    col = pow(col, vec3(1.5));\n\treturn vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n\nfloat char(float ch)\n{\n  vec4 f = texture(iChannel0,clamp(xtp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n  return f.x;\n}\n\nvec4 ScrollText(vec2 xuv)\n{\n    xtp = xuv / FONT_SIZE1;  // set font size\n    xtp.x = 2.0*(xtp.x -4. +mod(xtime*SCROLL_SPEED, SCROLL_LEN));\n    xtp.y = xtp.y +1.7 +SIN_AMP*sin(xtp.x*SIN_FREQ +xtime*SIN_SPEED);\n    float c = 0.0;\n    \n    S(32.);S(32.);S(32.);S(32.);S(32.);S(32.);S(72.);S(101.);S(108.);S(108.);S(111.);S(32.);\n    S(115.);S(104.);S(97.);S(100.);S(101.);S(114.);S(116.);S(111.);S(121.);S(32.);S(33.);S(33.);\n    S(32.);S(84.);S(104.);S(105.);S(115.);S(32.);S(105.);S(115.);S(32.);S(97.);S(32.);S(99.);\n    S(117.);S(98.);S(101.);S(32.);S(119.);S(105.);S(116.);S(104.);S(32.);S(97.);S(32.);S(115.);\n    S(104.);S(97.);S(100.);S(101.);S(114.);S(32.);S(109.);S(97.);S(112.);S(112.);S(101.);S(100.);\n    S(32.);S(111.);S(110.);S(32.);S(101.);S(97.);S(99.);S(104.);S(32.);S(102.);S(97.);S(99.);\n    S(101.);S(32.);S(99.);S(111.);S(100.);S(101.);S(100.);S(32.);S(105.);S(110.);S(32.);S(49.);\n    S(57.);S(57.);S(48.);S(32.);S(97.);S(109.);S(105.);S(103.);S(97.);S(32.);S(114.);S(101.);\n    S(116.);S(114.);S(111.);S(32.);S(115.);S(116.);S(121.);S(108.);S(101.);S(32.);S(46.);S(46.);\n    S(46.);S(46.);S(32.);S(73.);S(32.);S(106.);S(117.);S(115.);S(116.);S(32.);S(109.);S(105.);\n    S(120.);S(101.);S(100.);S(32.);S(115.);S(101.);S(118.);S(101.);S(114.);S(97.);S(108.);S(32.);\n    S(115.);S(104.);S(97.);S(100.);S(101.);S(114.);S(115.);S(32.);S(116.);S(111.);S(103.);S(101.);\n    S(116.);S(104.);S(101.);S(114.);S(32.);S(46.);S(46.);S(46.);S(46.);S(32.);S(82.);S(101.);\n    S(97.);S(100.);S(32.);S(116.);S(104.);S(101.);S(32.);S(99.);S(111.);S(100.);S(101.);S(32.);\n    S(102.);S(111.);S(114.);S(32.);S(99.);S(114.);S(101.);S(100.);S(105.);S(116.);S(115.);S(32.);\n    S(46.);S(46.);S(46.);S(46.);S(46.);S(32.);S(73.);S(32.);S(99.);S(111.);S(100.);S(101.);\n    S(100.);S(32.);S(116.);S(104.);S(105.);S(115.);S(32.);S(98.);S(101.);S(99.);S(97.);S(117.);\n    S(115.);S(101.);S(32.);S(73.);S(32.);S(108.);S(111.);S(118.);S(101.);S(32.);S(99.);S(117.);\n    S(98.);S(101.);S(115.);S(32.);S(97.);S(110.);S(100.);S(32.);S(65.);S(109.);S(105.);S(103.);\n    S(97.);S(32.);S(46.);S(46.);S(46.);S(46.);S(46.);S(32.);S(72.);S(105.);S(109.);S(114.);\n    S(101.);S(100.);S(32.);S(46.);S(46.);S(46.);S(46.);S(32.);S(69.);S(79.);S(84.);S(32.);\n    S(46.);S(46.);S(46.);S(46.);\n    return c * vec4(xpos, 0.5+0.5*sin(2.0*xtime),1.0);\n}\n\n\nvec4 Plasma(vec2 uv )\n{\n\tfloat time=iTime*1.0;\n\tuv = (uv-0.0)*6.0;\n    vec2 uv0=uv;\n\tfloat i0=1.0;\n\tfloat i1=1.0;\n\tfloat i2=1.0;\n\tfloat i4=0.0;\n\tfor(int s=0;s<7;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(cos(uv.y*i0-i4+time/i1),sin(uv.x*i0-i4+time/i1))/i2;\n        r+=vec2(-r.y,r.x)*0.3;\n\t\tuv.xy+=r;\n        \n\t\ti0*=1.93;\n\t\ti1*=1.15;\n\t\ti2*=1.7;\n\t\ti4+=0.05+0.1*time*i1;\n\t}\n    float r=sin(uv.x-time)*0.5+0.5;\n    float b=sin(uv.y+time)*0.5+0.5;\n    float g=sin((uv.x+uv.y+sin(time*0.5))*0.5)*0.5+0.5;\n\treturn vec4(r,g,b,1.0);\n}\n\nfloat sdBoxXY( vec3 p, vec3 b )\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nmat2 rot(float x) {\n\treturn mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat map(vec3 p) {\n    float k = 0.5 * 2.0;\n\tvec3 q = (fract((p - vec3(0.25, 0.0, 0.25))/ k) - 0.5) * k;\n    vec3 s = vec3(q.x, p.y, q.z);\n    float d = udRoundBox(s, vec3(0.1, 1.0, 0.1), 0.05);\n    \n    k = 0.5;\n    q = (fract(p / k) - 0.5) * k;\n    s = vec3(q.x, abs(p.y) - 1.5, q.z);\n    float g = udRoundBox(s, vec3(0.17, 0.5, 0.17), 0.2);\n    \n    float sq = sqrt(0.5);\n    vec3 u = p;\n    u.xz *= mat2(sq, sq, -sq, sq);\n    d = max(d, -sdBoxXY(u, vec3(0.8, 1.0, 0.8)));\n    \n    return smin(d, g, 16.0);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec4 Room(vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float gt = iTime / 5.0;\n    vec3 r = normalize(vec3(uv, 1.7 - dot(uv, uv) * 0.1));\n    float sgt = sin(gt * 3.141592 * 2.0);\n    r.xy *= rot(sgt * 3.141592 / 8.0);\n    r.xz *= rot(3.141592 * 0.0 + gt * 3.141592 * 2.0);\n    r.xz *= rot(3.141592 * -0.25);\n\n    vec3 o = vec3(0.0, 0.0, gt * 5.0 * sqrt(2.0) * 2.0);\n    o.xz *= rot(3.141592 * -0.25);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float fd = map(w);\n\n    vec3 col = vec3(0.514, 0.851, 0.933) * 0.5;\n    vec3 ldir = normalize(vec3(-1, -0.5, 1.1));\n\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd * 100.0);\n    float front = max(dot(r, -sn), 0.0);\n    float ref = max(dot(r, reflect(-ldir, sn)), 0.0);\n    float grn = pow(abs(sn.y), 3.0);\n\n    vec3 cl = vec3(grn);\n    cl += mix(col*vec3(1.5), vec3(0.25), grn) * pow(ref, 16.0);\n    cl = mix(col, cl, fog);\n\n\treturn vec4(cl, 1.0);\n}\n\nvec4 t(vec2 uv)\n{\n    float j = sin(uv.y * 3.14 + iTime * 5.0);\n    float i = sin(uv.x * 15.0 - uv.y * 2.0 * 3.14 + iTime * 3.0);\n    float n = -clamp(i, -0.2, 0.0) - 0.0 * clamp(j, -0.2, 0.0);\n    return 3.5 * (vec4(xcolor, 1.0) * n);\n}\n\nvec4 Twirl(vec2 p)\n{\n    vec2 uv;\n    p=-1.+2.*p;\n    \n    float r = sqrt(dot(p, p));\n    float a = atan(\n        p.y * (0.3 + 0.1 * cos(iTime * 2.0 + p.y)),\n        p.x * (0.3 + 0.1 * sin(iTime + p.x))\n    ) + iTime;\n    \n    uv.x = iTime + 1.0 / (r + .01);\n    uv.y = 4.0 * a / 3.1416;\n    \n    return mix(vec4(0.0), t(uv) * r * r * 2.0, 1.0);\n}\n\nvec4 MetaShader(vec2 uv,int shader)\n{\nif(uv.x<0.005 || uv.y<0.005 || uv.x>0.995 || uv.y>0.995) return vec4(0.8,0.8,0.8,1.);   \nif(shader==0) return Twirl(uv);\nif(shader==1) return Plasma(uv);\nif(shader==2) return Room(uv);\nif(shader==3) return Voronoi(uv);\nif(shader==4) return Ring(uv);\nif(shader==5) return Glenz(uv);\nreturn vec4(0);\n}\n\nvec4 inTriangle(vec2 p0, vec2 p1, vec2 p2, vec2 p)\n{\n\tfloat a = 0.5*(-p1.y*p2.x + p0.y*(-p1.x + p2.x) + p0.x*(p1.y - p2.y) + p1.x*p2.y);\n\tfloat s = 1.0/(2.0*a)*(p0.y*p2.x - p0.x*p2.y + (p2.y - p0.y)*p.x + (p0.x - p2.x)*p.y);\n\tfloat t = 1.0/(2.0*a)*(p0.x*p1.y - p0.y*p1.x + (p0.y - p1.y)*p.x + (p1.x - p0.x)*p.y);\n\t\n\tif (s > 0.0 && t > 0.0 && 1.0 - s - t > 0.0) {\n\t\treturn vec4(1.0,s,t,1.0-s-t);\n\t} else {\n\t\treturn vec4(0.0,s,t,1.0-s-t);\n\t}\n}\n\nvoid triangle(inout vec4 c, vec2 p, int shader, vec3 p0, vec3 p1, vec3 p2, vec2 t0, vec2 t1, vec2 t2)\n{\n\tfloat rx = iTime/3.;\n\tfloat ry = iTime;\n\tfloat rz = iTime;\n\t\n\tfloat cx = cos(rx); float sx = sin(rx);\n\tfloat cy = cos(ry); float sy = sin(ry);\n\tfloat cz = cos(rz); float sz = sin(rz);\n\t\n\tmat4 transform1 =\n\t\tmat4(1, 0, 0, 0,\n      \t\t 0, 1, 0, 0,\n      \t\t 0, 0, 1, 0,\n\t\t\t 0, 0, -2.5, 1);\n\t\n\tmat4 transform2 =\n\t\tmat4(cz*cy, -sz*cy, sy, 0,\n\t\t\t sz*cx + cz*sy*sx, cz*cx - sz*sy*sx, -cy*sx, 0,\n\t\t\t sz*sx - cz*sy*cx,cz*sx + sz*sy*cx, cy*cx, 0,\n\t\t\t 0, 0, 0, 1);\n\t\n\tfloat n = 1.0;\n\tfloat f = 10.0;\n\tfloat r = 1.0 * iResolution.x / iResolution.y;\n\tfloat t = 1.0;\n\tmat4 projection =\n\t\tmat4(n/r, 0, 0, 0,\n      \t\t 0, n/t, 0, 0,\n      \t\t 0, 0, -(f+n)/(f-n), -1,\n\t\t\t 0, 0, -(2.0*f*n)/(f-n), 0);\n\t\n\tvec4 pt0 = vec4(0,0,0,0);\n\tvec4 pt1 = vec4(0,0,0,0);\n\tvec4 pt2 = vec4(0,0,0,0);\n\t\n\tpt0 = projection * transform1 * transform2 * vec4(p0,1);\n\tpt1 = projection * transform1 * transform2 * vec4(p1,1);\n\tpt2 = projection * transform1 * transform2 * vec4(p2,1);\n\t\n\t\n\tvec4 test = inTriangle(pt0.xy / pt0.w, pt1.xy / pt1.w, pt2.xy / pt2.w, p);\n\t\n\tif (test.x != 0.0) {\n\t\tfloat z = ((pt1.z * test.y) / pt1.w +\n\t\t\t\t   (pt2.z * test.z) / pt2.w +\n\t\t\t\t   (pt0.z * test.w) / pt0.w) /\n\t\t\t\t\t(test.y / pt1.w +\n\t\t\t\t\t test.z / pt2.w +\n\t\t\t\t\t test.w / pt0.w);\n\t\tif (z < c.w) {\n\t\t\tfloat tx = ((t1.x * test.y) / pt1.w +\n\t\t\t\t\t\t(t2.x * test.z) / pt2.w +\n\t\t\t\t\t\t(t0.x * test.w) / pt0.w) /\n\t\t\t\t\t   (test.y / pt1.w +\n\t\t\t\t\t\ttest.z / pt2.w +\n\t\t\t\t\t\ttest.w / pt0.w);\n\t\t\t\n\t\t\tfloat ty = ((t1.y * test.y) / pt1.w +\n\t\t\t\t\t\t(t2.y * test.z) / pt2.w +\n\t\t\t\t\t\t(t0.y * test.w) / pt0.w) /\n\t\t\t\t\t   (test.y / pt1.w +\n\t\t\t\t\t\ttest.z / pt2.w +\n\t\t\t\t\t\ttest.w / pt0.w);\n\n            c=MetaShader(vec2(tx,ty),shader);\n            c.w=z;\n\t\t}\n\t}\n}\n\nvec4 pixel(vec2 p)\n{\n\tvec4 color = vec4(0,0,0,1000);   \n\ttriangle(color,p,0,vec3(-1,-1,-1),vec3(1,-1,-1), vec3(-1,1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,0,vec3(1,-1,-1),vec3(1,1,-1),vec3(-1,1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\t\n\ttriangle(color,p,1,vec3(1,1,1),vec3(-1,1,1),vec3(1,-1,1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,1,vec3(-1,1,1),vec3(-1,-1,1),vec3(1,-1,1),vec2(1,0),vec2(1,1),vec2(0,1));   \n    triangle(color,p,2,vec3(-1,1,-1),vec3(-1,1,1),vec3(-1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,2,vec3(-1,1,1),vec3(-1,-1,1),vec3(-1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\t\n    triangle(color,p,3,vec3(1,1,-1),vec3(1,1,1),vec3(1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,3,vec3(1,1,1),vec3(1,-1,1),vec3(1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));   \n    triangle(color,p,4,vec3(-1,1,-1),vec3(-1,1,1),vec3(1,1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,4,vec3(-1,1,1),vec3(1,1,1),vec3(1,1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\n    triangle(color,p,5,vec3(-1,-1,-1),vec3(-1,-1,1),vec3(1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,5,vec3(-1,-1,1),vec3(1,-1,1),vec3(1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));   \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - vec2(1.0,1.0);\n\tfragColor = pixel(uv);\n    xpos = fragCoord.xy / iResolution.xy; //  0 .. 1\n    vec4 sc = 2.*ScrollText(uv);\n    fragColor+=sc;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 7938,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/reginhart22/yhaiemj4lbmp"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}