{
    "Shader": {
        "info": {
            "date": "1706939132",
            "description": "sky shader\neasier to tune + faster to render\n10 pts to whoever figures out how to stop the star tiles from rotating when looking up and turning",
            "flags": 48,
            "hasliked": 0,
            "id": "Ddtfz7",
            "likes": 4,
            "name": "non pbr sky",
            "published": 3,
            "tags": [
                "3d",
                "sky"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 167
        },
        "renderpass": [
            {
                "code": "const int maxStarsPerPoint = 40;\n\n//cloud color gradients (rgb = color, a = color mid point)\nconst vec4 skyGrad[] = vec4[](\n    vec4(0,0,0.02,0.2),\n    vec4(0.176,0.341,0.725,0.25),\n    vec4(0.243,0.671,0.996,0.3),\n    vec4(0.243,0.671,0.996,0.7),\n    vec4(0.176,0.341,0.725,0.75),\n    vec4(0,0,0.02,0.8),\n    vec4(0,0,0.02,1)\n);\n\nconst vec4 horizonGrad[] = vec4[](\n    vec4(0.1,0.1,0.15,0.2),\n    vec4(0.918,0.412,0.282,0.25),\n    vec4(0.996,0.992,0.945,0.3),\n    vec4(0.996,0.992,0.945,0.7),\n    vec4(0.918,0.412,0.282,0.75),\n    vec4(0.1,0.1,0.15,0.8),\n    vec4(0.1,0.1,0.15,1)\n);\n\nconst vec4 sliderGrad[] = vec4[](\n    vec4(0.051,0.106,0.227,0.15),\n    vec4(1.000,0.384,0.180,0.25),\n    vec4(0.384,0.729,0.996,0.35),\n    vec4(0.384,0.729,0.996,0.65),\n    vec4(1.000,0.384,0.180,0.75),\n    vec4(0.051,0.106,0.227,0.85),\n    vec4(0.051,0.106,0.227,1)\n);\n\n//gets a color at a position on a gradient\nvec3 grad(vec4[7] grad, float x){\n    x = fract(x);\n    for (int i = 0; i < grad.length(); i++){\n        if (grad[i].a > x){\n            vec4 gradStart = grad[i - 1];\n            vec4 gradEnd = grad[i];\n            return mix(gradStart.rgb,gradEnd.rgb,smoothstep(gradStart.a,gradEnd.a,x));\n        }\n    }\n}\n\nvec2 castToView(Camera cam, vec3 p){\n    p = p*transpose(cam.rotmat);\n    float t = cam.frustum/p.z;\n    if (t < cam.frustum) return vec2(-999);\n    return t*p.xy;\n}\n\nvec4 renderMoon(Camera cam, vec3 moonpos, float time){\n    if (dot(moonpos, cam.ray.direction) < 0.0){\n        float stage = time/10.0;\n        vec3 z = normalize(vec3(0,moonpos.z,-moonpos.y));\n        vec2 uv = vec2(dot(cross(-moonpos,z), cam.ray.direction),dot(z,cam.ray.direction))*25.0;\n        uv.x *= sign(moonpos.y);\n        float l = dot(uv,uv);\n        if (l < 1.0){\n            uv /= sqrt(1.0 - l) + 1.0;\n            vec2 p = vec2(uv.x - time, uv.y);\n            float v = abs(voronoi2d(p*2.0) - 0.5)*1.5 + abs(voronoi2d(p*8.0) - 0.3) + abs(voronoi2d(p*16.0)*0.4 - 0.1);\n            v /= 0.75 + 0.7 + 0.3;\n            vec3 lightColor = vec3(1);\n            vec3 darkColor = vec3(0.016,0.071,0.122);\n            vec4 col = vec4(mix(darkColor,lightColor,1.0 - v),smoothstep(1.0,0.94,l));\n            float k = (2.0*asin(mod(stage,2.0) - 1.0)/3.14159)*sqrt((1.0 - uv.y*uv.y));\n            float s = sign(mod(stage,4.0) - 2.0);\n            if (s*uv.x < s*k){\n                col.rgb = mix(col.rgb,vec3(0.04),smoothstep(0.0,0.1,s*(k - uv.x))*0.97);\n            }\n            return col;\n        }\n    }\n    return vec4(0);\n}\n\nvec3 getStars(Camera cam, float timeFactor, float angle, vec3 light){\n    mat3 rotmat = rotationMatrix(vec3(0,0,angle));\n    vec3 rd = cam.ray.direction*rotmat;\n    vec4 data = inverseSF(rd);\n    float d = data.a;\n    vec3 point = data.xyz;\n    vec2 uvCenter = castToView(cam, point*inverse(rotmat));//cast point to view\n    float scatter = 1.0 - voronoi3d(rd*40.0) + (1.0 - voronoi3d(rd*80.0))*0.5 - voronoi3d(rd*4.0);\n    float milky = 0.6 - abs(dot(rd,vec3(0.3714,0.5571,0.7428)));\n    vec3 col = blackBody(milky*0.2 + scatter*0.1 + rd.y*0.1)*max(timeFactor + 0.1,0.0);\n    \n    float milkydot = 1.0 - abs(dot(point,vec3(0.3714,0.5571,0.7428)));\n    vec2 starSpread = hash23(point) + max(milkydot*milkydot*2.0 - 1.0 + point.y*0.5,0.0);\n        \n    for (int i = 0; i < int(float(maxStarsPerPoint)*(starSpread.x+0.1)); i++){\n        vec4 rand = hash43(point + float(i));\n        if ((rand.z = min(rand.z + timeFactor - 0.1,rand.z)) < 0.0) continue;\n        float stardist = distance(floor(((rand.xy*2.0 - 1.0)*0.05 + uvCenter)*cam.res)/cam.res,cam.uv);\n        col += max((fpow(rand.z,0.9) + starSpread.y - stardist*1e3),0.0)*min(d*1000.0,1.0)*blackBody(fpow(rand.z,0.3))*4.0;\n    }\n    //moon has to occulude stars\n    vec4 moon = renderMoon(cam, -light, angle);\n    col = mix(col,moon.rgb*clamp(timeFactor + 0.3,0.1,1.0),moon.a);\n    return col;\n}\n\n//renders a lens flare\nvec3 renderLensFlare(Camera cam, vec3 light){\n    vec3 lr = -light*transpose(cam.rotmat);\n    if (lr.z > 0.0){\n        vec2 luv = lr.xy*cam.frustum/lr.z;\n        float ld = distance(luv, cam.uv);\n        vec2 ln = (luv - cam.uv)/ld;\n                \n        //ghosts\n        vec3 ghosts = vec3(0);\n        ghosts += renderhex(cam.uv, -luv*0.25, 0.35, vec3(0.25,0.75,0));\n        ghosts += renderhex(cam.uv, luv*0.25, 0.125, vec3(1,0.5,0.5));\n        ghosts += renderhex(cam.uv, luv*0.1, 0.4, vec3(1,1,1));\n        ghosts += renderhex(cam.uv, luv*1.8, 0.5, vec3(0,0.5,0.75));\n        ghosts += renderhex(cam.uv, luv*1.25, 0.2, vec3(1,1,0.5));\n        ghosts += renderhex(cam.uv, -luv*1.25, 1.25, vec3(0.5,0.5,0.25));\n        ghosts += fpow(1.0 - abs(distance(luv*0.8,cam.uv) - 0.35),0.985)*vec3(0.059,0.039,0.000);\n        ghosts /= 8.0 + distance(cam.uv,luv);\n        \n        float flare = fpow(textureLod(iChannel2,ln*0.25,0.0).r,0.3)*0.003/ld;\n        float bloom = fpow(max(1.0 - ld,0.0) + 0.02,0.95);\n        vec3 mainflare = vec3(1.0,0.8,0.1)*min(bloom + flare,1.0);\n        \n        float fadeout = 1.0 - clamp((light.y - 0.)*5.0,0.0,1.0);\n        \n        return (ghosts + mainflare)*fadeout;\n    }\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //cam setup\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n    Ray ray = cam.ray;\n    \n    //other useful vars\n    float sunAngle = texelFetch(iChannel0, ivec2(7,0), 0).x;\n    bool isPlaying = texelFetch(iChannel0, ivec2(7,0), 0).w == 1.0;\n    float time = sunAngle/TAU;\n    float d = 1.0 - 1.0/exp(abs(ray.direction.y));\n    vec3 lightDirection = vec3(cos(sunAngle + PI/2.0),sin(sunAngle + PI/2.0),0);\n    float ld = (dot(ray.direction,lightDirection) + 1.0)*15.0;\n    \n    vec3 col = vec3(0);\n\n    //base sky color\n    float dither = texelFetch(iChannel1,ivec2(mod(fragCoord,1024.0)),0).x*0.1;\n    vec3 basecol = mix(grad(horizonGrad,time),grad(skyGrad,time),clamp(smin(mix(d,sqrt(d),max(lightDirection.y,0.0)),ld,0.1) + dither,0.0,1.0));\n    col = basecol;\n        \n    col += getStars(cam, lightDirection.y, -sunAngle, lightDirection);\n    col += renderLensFlare(cam,lightDirection);\n\n\n    //UI\n\n    //position of slider handle\n    vec2 slideruv = (fragCoord - iResolution.xy/2.0)/iResolution.y - vec2(0.78,-0.4);\n    float pxunit = 1.0/iResolution.y;\n    vec2 pos = vec2(cos(sunAngle),sin(sunAngle))*sliderRadius;\n    \n    float innerdist = sliderWidth - abs(length(slideruv) - sliderRadius);\n    float handledist = sliderWidth - distance(slideruv,pos);\n    col = mix(col, grad(sliderGrad, atan(slideruv.y,slideruv.x)/TAU), smoothstep(0.0, pxunit, innerdist)); //slider background\n    col = mix(col, vec3(0), smoothstep(0.0, pxunit, 2.0*pxunit-abs(innerdist))); //slider border\n    col = mix(col, vec3(1), smoothstep(0.0, pxunit, handledist)); //handle\n    col = mix(col, vec3(0), smoothstep(0.0, pxunit, 2.0*pxunit-abs(handledist))); //handle border\n    \n    \n    if (isPlaying){\n        float pausedist1 = sdBox(slideruv,vec2(-0.018,-0.025),vec2(-0.007, 0.025)) - 0.003;\n        float pausedist2 = sdBox(slideruv,vec2(0.007,-0.025),vec2(0.018, 0.025)) - 0.003;\n        col = mix(col, vec3(1), smoothstep(0.0, pxunit, -min(pausedist1,pausedist2)));\n        col = mix(col, vec3(0), smoothstep(0.0, pxunit, 2.0*pxunit-abs(-min(pausedist1,pausedist2))));\n    } else {\n        float playdist = -(sdTriangle(slideruv,vec2(-0.0125,0.025),vec2(-0.0125,-0.025),vec2(0.025,0.0)) - 0.003);\n        col = mix(col, vec3(1), smoothstep(0.0, pxunit, playdist)); //play button\n        col = mix(col, vec3(0), smoothstep(0.0, pxunit, 2.0*pxunit-abs(playdist)));\n    }\n\n    // gamma correction\n    fragColor = col.rgbb;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define TAU 6.283185\n#define maxsteps 20\n#define maxlightsteps 4\n#define far 500.0\n#define cameraFrustum 0.7\nconst float sliderWidth = 0.02;\nconst float sliderRadius = 0.07;\nconst bool doDeadZone = true;\nconst bool doPlay = true;\nconst float sliderInitialValue = 1.5;\n\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    mat3 rotmat;\n    float frustum;\n    vec2 res;\n    vec2 uv;\n};\n\nstruct Hit {\n    bool hit;\n    float dist;\n    vec3 point;\n};\n\n//fakes x^n for various effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return ((a+b) - sqrt(h*h+k))*0.5;\n}\n\nfloat smin2( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat voronoi2d(vec2 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            n = smin2(n,distance(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv),8.0);\n        }\n    }\n    return n;\n}\n\nfloat voronoi3d(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n            for (int z = -1; z <= 1; z++){\n                vec3 k = vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)) - fract(uv);\n                n = min(n,dot(k,k));\n            }\n        }\n    }\n    if (n == 0.0) return 0.0;\n    return sqrt(n);\n}\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    vec3 uvd = normalize(uv);\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 ro = uv*rotmat + cameraPos;\n    vec3 rd = uvd*rotmat;\n    return Camera(cameraPos, Ray(ro, rd), rotmat, frustumLength, resolution, uv.xy);\n}\n\n//https://www.shadertoy.com/view/Nlc3zf\nfloat sdBox(vec2 position, vec2 start, vec2 stop) {\n   position = abs(position - (stop+start)/2.0) - (stop-start)/2.0;\n   return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0);\n}\n\n//https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// written by iq https://www.shadertoy.com/view/lllXz4\n// Spherical Fibonnacci points, as described by Benjamin Keinert, Matthias Innmann, Michael Sanger and Marc Stamminger in their paper\n\nvec4 inverseSF( vec3 p ) \n{\n    const float kTau = 6.28318530718;\n    const float kPhi = (1.0+sqrt(5.0))/2.0;\n    const float kNum = 2048.0;\n\n    float k  = max(2.0, floor(log2(kNum*kTau*0.5*sqrt(5.0)*(1.0-p.z*p.z))/log2(kPhi+1.0)));\n    float Fk = pow(kPhi, k)/sqrt(5.0);\n    vec2  F  = vec2(round(Fk), round(Fk*kPhi)); // |Fk|, |Fk+1|\n    \n    vec2  ka = 2.0*F/kNum;\n    vec2  kb = kTau*(fract((F+1.0)*kPhi)-(kPhi-1.0));    \n\n    mat2 iB = mat2( ka.y, -ka.x, kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    vec2 c = floor(iB*vec2(atan(p.y,p.x),p.z-1.0+1.0/kNum));\n\n    float d = 8.0;\n    float d2 = 8.0;\n    vec3 pos = vec3(0,0,1);\n    for( int s=0; s<4; s++ ){\n        vec2  uv = vec2(s&1,s>>1);\n        float id = clamp(dot(F, uv+c),0.0,kNum-1.0); // all quantities are integers\n        \n        float phi      = kTau*fract(id*kPhi);\n        float cosTheta = 1.0 - (2.0*id+1.0)/kNum;\n        float sinTheta = sqrt(1.0-cosTheta*cosTheta);\n        \n        vec3 q = vec3(cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float tmp = dot(q-p, q-p);\n        if (tmp < d){\n            d2 = d;\n            d = tmp;\n            pos = q;\n        } else if (tmp < d2){\n            d2 = tmp;\n        }\n    }\n    return vec4(pos, abs(sqrt(d)-sqrt(d2)));\n}\n\n//https://www.shadertoy.com/view/4tdGWM\nvec3 blackBody(float t){\n    if (t <= 0.0) return vec3(0);\n    return vec3(1, 3.375, 8.0)/(t*(exp(vec3(1,1.5,2.0)/t) - 1.0));\n}\n\nfloat sdHex(vec2 p){\n    p = abs(p);\n\tvec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n\treturn dot(step(q.xy,q.yx), 1.0-q.yx);\n}\n\nvec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n    uv -= p;\n    if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n        return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.3,sdHex(uv*5.0/s)));\n    }\n    return vec3(0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        vec4 prevdata = texelFetch(iChannel0, ivec2(7,0), 0);\n        \n        if (iFrame <= 1){\n            col = vec2(0.35,0.09).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0 && prevdata.z != 1.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity*iTimeDelta*60.0;\n        \n        if (position.y < -500.0){\n            position = vec3(0,24,0);\n        }\n        \n        if (iFrame == 0){\n            position = vec3(0,-40,0);\n        }\n        col.xyz = position;\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    \n    //time slider\n    if (floor(fragCoord) == vec2(7,0)){\n        vec4 prevdata = texelFetch(iChannel0, ivec2(7,0), 0); //previous slider pos\n        vec2 m = (iMouse.xy - iResolution.xy/2.0)/iResolution.y - vec2(0.78,-0.4);\n        float r1 = length(m);\n        if (iMouse.w > 0.0){ //setup on click\n            if (r1 < sliderRadius - sliderWidth - 0.01) {\n                prevdata.w = float(prevdata.w == 0.0);\n            }\n            if (distance(m,vec2(cos(prevdata.x), sin(prevdata.x))*sliderRadius) <= sliderWidth){\n                vec2 d = normalize(m);\n                col.y = atan(d.y,d.x) - prevdata.x;\n                col.x = prevdata.x;\n                col.z = 1.0;\n            }\n        }\n        if (doPlay && prevdata.w != 0.0){\n            prevdata.x -= 0.001;\n        } \n        if (iMouse.z > 0.0 && (prevdata.z == 1.0 || col.z == 1.0)){ //update while held\n            col.z = 1.0;\n            col.y = iMouse.w > 0.0 ? col.y : prevdata.y;\n            vec2 d = m/r1; //direction from (0,0) to mouse in uv coords                \n            if (r1 < sliderRadius-sliderWidth && doDeadZone) { //creates center dead zone\n                col.x = prevdata.x;\n            } else {\n                vec2 h = vec2(cos(prevdata.x + col.y),sin(prevdata.x + col.y))*r1;\n                vec2 p = vec2(cos(prevdata.x),sin(prevdata.x))*sliderRadius;\n                col.x = atan(d.y,d.x);\n                if (distance(h,p) > sliderWidth){ //keeps the handle under the cursor\n                    if (sliderWidth - abs(r1 - sliderRadius) < 0.0){ //cursor isn't on the track\n                        col.y = 0.0;\n                    } else { //don't ask\n                        float o = acos((r1*r1 + p.x*p.x + p.y*p.y - sliderWidth*sliderWidth)/(2.0*r1*sliderRadius));\n                        col.y = sign(dot(vec2(-p.y,p.x),h))*o;\n                    }\n                }\n                col.x -= col.y;\n            }\n        } else { //store when not clicked\n            col.z = 0.0;\n            col.x = prevdata.x;\n        }\n        col.w = prevdata.w;\n        if (iFrame == 0) col.x = sliderInitialValue; //set initial value\n    }\n    \n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}