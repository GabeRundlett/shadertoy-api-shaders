{
    "Shader": {
        "info": {
            "date": "1549473691",
            "description": "an octree version of [url=https://www.shadertoy.com/view/ts23zy]Twisted Eye (Voxeltraced)[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "3dSGzc",
            "likes": 10,
            "name": "twisted eye with octree",
            "published": 3,
            "tags": [
                "octree"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 730
        },
        "renderpass": [
            {
                "code": "#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n//subdivision size (tree*tree*tree), 2.0 is default octree\n#define tree 2.0\n//the voxel size before you subdivide\n#define startsize 3.0\n//subdivide limit\n#define detail 5\n\n#define steps 600\n#define maxdistance 30.0\n#define PI 3.14159\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// From IQ\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n//value noise by Elyxian https://www.shadertoy.com/view/ts23zy\nfloat valueNoise(vec2 p) {\n    \n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(hash12(i + add.yy), hash12(i + add.xy), f.x),\n        mix(hash12(i + add.yx), hash12(i + add.xx), f.x),\n        f.y);\n    return res;\n        \n}\n\nfloat valueNoise(vec3 p) {\n    \n\tvec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(\n        \tmix(hash13(i + add.yyy), hash13(i + add.xyy), f.x),\n        \tmix(hash13(i + add.yxy), hash13(i + add.xxy), f.x),\n        f.y),\n        mix(\n            mix(hash13(i + add.yyx), hash13(i + add.xyx), f.x),\n        \tmix(hash13(i + add.yxx), hash13(i + add.xxx), f.x),\n        f.y),\n        f.z);\n    return res;\n        \n}\n\n\nfloat tower(vec3 p, vec2 t, vec3 h) {\n\t\n    vec3 q = abs(p.xzy) - h;\n    float val = sdTorus(max(q, 0.0), t) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return val;\n\n}\n\nfloat distanceMap(vec3 p) {\n    \n    // Get height of terrain\n    float height = -2.8;\n    height += 0.50 * valueNoise(p.xz * 0.25 + vec2(13.4, 71.2));\n    height += 0.20 * valueNoise(p.xz * 0.50 + vec2(51.5, 41.4));\n    height += 0.10 * valueNoise(p.xz * 1.00 + vec2(23.4, 94.3));\n    \n    float dist = p.y - height;\n    dist *= 0.5;\n    \n    // Apply the sphere effect\n    float sphereRadius = 8.0;// + iTime * 0.3;\n    dist = max(dist, length(p) - sphereRadius);\n    \n    // Rings\n    int outerRingCount1 = 12;\n    float distFromCenter1 = 2.5;\n    vec2 torusParams = vec2(3.3 + 0.5 * sin(iTime / 3.0), 0.12 + 0.03 * sin(iTime));\n    \n    for (int i = 0; i < outerRingCount1; i++) {\n        float perc = float(i)/float(outerRingCount1);\n        vec3 pos = vec3(\n            distFromCenter1 * sin(2.0*PI*perc + iTime*0.1),\n            3.8 + distFromCenter1 * cos(2.0*PI*perc + iTime*0.1),\n            0.0//-5.0 * smoothstep(0.0, 1.0, -0.3 + sin(6.0*perc * 2.0*PI + iTime))\n            );\n        float tDist = tower(p - pos, torusParams, vec3(0.0));\n        dist = min(dist, tDist);\n    }   \n              \n\treturn dist;\n    \n}\n\n//0 is empty, 1 is subdivide and 2 is full\nint getvoxel(vec3 p, float size) {\n    \n    p += size*0.5;\n    \n    //vec3 lp = fract(p)-0.5;\n    \n    //float len = length(lp)-0.2;\n    \n    float len = distanceMap(p);\n    \n    if (len > size*sqrt(3.0)*0.5) return 0;\n    if (len < -size*sqrt(3.0)*0.5) return 2;\n    return 1;\n    \n}\n\n//ray-cube intersection, on the inside of the cube\nvec3 voxel(vec3 ro, vec3 rd, vec3 ird, float size)\n{\n    size *= 0.5;\n    \n    vec3 hit = -(sign(rd)*(ro-size)-size)*ird;\n    \n    return hit;\n}\n\nvec3 getDiffuse(vec3 p) {\n    \n    //vec3 col = normalize(hash33(p));\n    \n    vec3 col = vec3(0.701, 0.572, 0.368) + hash33(p) * 0.1;\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) /iResolution.y;\n    \n    vec3 ro = vec3(0,0,-10);\n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    //if the mouse is in the bottom left corner, don't rotate the camera\n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    \tro.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \tro.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    ro += vec3(0,1,0);\n    \n    vec3 cam = ro;\n    \n    float size = startsize;\n    vec3 lro = mod(ro,size);\n    vec3 fro = ro-lro;\n    vec3 ird = 1.0/max(abs(rd),0.001);\n    vec3 mask;\n    bool exitoct = false;\n    int recursions = 0;\n    float dist = 0.0;\n    int i;\n    vec3 normal = vec3(0.0);\n    \n    //the octree traverser loop\n    //each iteration i either:\n    // - check if i need to go up a level\n    // - check if i need to go down a level\n    // - check if i hit a cube\n    // - go one step forward if octree cell is empty\n    // - repeat if i did not hit a cube\n    for (i = 0; i < steps; i++)\n    {\n        if (dist > maxdistance) break;\n        int voxelstate = getvoxel(fro,size);\n        \n        //i go up a level\n        if (exitoct)\n        {\n            \n            vec3 newfro = floor(fro/size/tree+0.5/tree)*size*tree;\n            \n            \n        \tint voxelstate = getvoxel(fro,size);\n            if (voxelstate == 1) {\n                exitoct = false;\n                continue;\n            }\n            \n            lro += fro-newfro;\n            fro = newfro;\n            \n            recursions--;\n            size *= tree;\n            \n            exitoct = (abs(mod(dot(fro,mask)/size+0.5,tree)-0.5+step(dot(rd,mask),0.0)*(tree-1.0))<0.1);\n        }\n        //subdivide\n        else if(voxelstate == 1&&recursions<=detail)\n        {\n            //if(recursions>detail) break;\n            \n            recursions++;\n            size /= tree;\n            \n            //find which of the 8 voxels i will enter\n            vec3 mask2 = clamp(floor(lro/size),0.0,tree-1.0);\n            fro += mask2*size;\n            lro -= mask2*size;\n        }\n        //move forward\n        else if (voxelstate == 0||voxelstate == 2||recursions > detail)\n        {\n            if (voxelstate == 2) {\n                break;\n            }\n            \n            //raycast and find distance to nearest voxel surface in ray direction\n            //i don't need to use voxel() every time, but i do anyway\n            vec3 hit = voxel(lro, rd, ird, size);\n            \n            if (hit.x < min(hit.y,hit.z)) {\n                mask = vec3(1,0,0);\n            } else if (hit.y < hit.z) {\n                mask = vec3(0,1,0);\n            } else {\n                mask = vec3(0,0,1);\n            }\n            \n            //mask = vec3(lessThan(hit,min(hit.yzx,hit.zxy)));\n            float len = dot(hit,mask);\n            \n            \n            \n            //moving forward in ray direction, and checking if i need to go up a level\n            dist += len;\n            lro += rd*len-mask*sign(rd)*size;\n            fro = fro+mask*sign(rd)*size;\n            \n            exitoct = abs(mod(dot(fro,mask)/size+0.5,tree)-0.5-step(dot(rd,mask),0.0)*(tree-1.0)) < 0.1;\n            normal = mask;\n        }\n    }\n    ro += rd*dist;\n    if(i < steps && dist < maxdistance)\n    {\n        vec3 color = getDiffuse(fro/size);\n        \n        normal *= -sign(rd);\n        \n        float phong = max(dot(normal,normalize(vec3(1,2,-1))),0.1);\n        \n        color *= phong;\n        \n    \tfragColor = vec4(color,1.0);\n    } else {\n        fragColor = vec4(0.8);\n    }\n    //fragColor = vec4(float(i)/float(steps));\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}