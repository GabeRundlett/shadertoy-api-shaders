{
    "Shader": {
        "info": {
            "date": "1676049766",
            "description": "A starter project",
            "flags": 32,
            "hasliked": 0,
            "id": "ctSXDW",
            "likes": 3,
            "name": "basic_pt",
            "published": 3,
            "tags": [
                "3d",
                "cubemap",
                "pathtracer"
            ],
            "usePreview": 1,
            "username": "RubberDuck55",
            "viewed": 205
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.a),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_DIST 1000.0\n#define SURF_DIST 0.001\n#define MAX_STEP 500\n\n#define NUM_OBJECTS 5\n#define BOUNCES 3\n\n#define DIFF 0\n#define REFL 1\n#define EMIT 2\n#define REFR 3 // Not working \n#define CHEK 4 // Based on x,y not normal\n\nfloat seed;\n\nstruct Material {\n    int id;\n    vec3 col;\n    float aux;\n};\n\nstruct ray {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 n, rd, ro;\n    Material mat;\n};\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 lerp (vec3 v1, vec3 v2, float t) {\n    return v1 * (vec3(1.) - t) + v2 * t;\n}\n\nvoid init_rand (vec2 p) {\n    p = vec2(mod(p.x, 32.321), mod(p.y, 526.834));\n    float s = sin(p.x * 453.432) * 342.324 - cos(p.y * 345.468) * 732.345;\n    seed = s;\n}\n\nfloat rand () {\n    seed += fract(sin(seed * 0.523454) * 5773.7327);\n    return fract(sin(seed * 0.493732) * 3427.6872);\n}\n\nvec3 rand_hemisphere (vec3 n) {\n    float phi = (rand()-0.5) * 3.1415 * 2.;\n    float theta = (rand()-0.5) * 3.1415 * 2.;\n    \n    vec3 vec = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n    return dot(vec, n) < 0. ? vec*-1. : vec;\n}\n\nvec3 rand_hemisphere_weighted (vec3 rd, vec3 n, float t) {\n    vec3 rh = rand_hemisphere (n);\n    vec3 er = reflect(rd, n);\n    \n    return lerp(rh, er, t);\n}\n\nmat2 rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat distMat (vec3 p, out Material s) {\n    Material closest;\n    float minD = MAX_DIST;\n    \n    float ds = length(p-vec3(3., 0.5, 0.4))-1.5;\n    float ms = length(p)-1.;\n    float es = length(p-vec3(-3, 0.7, 0.9))-1.7;\n    float g = p.y+1.;\n    float light = length(p-vec3(0.,2.,0.))-0.5;\n    \n    minD = min(min(ms, g), min( ds, es));\n    \n    if(minD == ms)\n        closest = Material(REFL, vec3(0.5,1.,0.9), 1.0);\n    if(minD == ds)\n        closest = Material(REFL, vec3(1., 0.9, 0.5), 0.5);\n    if(minD == es)\n        closest = Material(EMIT, vec3(1.,0.5,0.5), 2.0);\n    if(minD == g)\n        closest = Material(CHEK, vec3(1.), 1.0);\n    \n    s = closest;\n    \n    return minD;\n}\n\n// Returns distance(float)\nfloat dist (vec3 p) {\n    Material d;\n    return distMat(p, d);\n}\n\n// Returns a normal(vec3) from a point\nvec3 normal(vec3 p){\n  float d = dist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n    dist(p-e.xyy),\n    dist(p-e.yxy),\n    dist(p-e.yyx));\n  \n  return normalize(n);\n}\n\n// Returns object (hit|?|, pos, dist, n|ormal|, rd, ro)\nray raymarch (vec3 ro, vec3 rd) {\n    \n    bool hit = false;\n    \n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * dO;\n        float d = dist(p);\n        \n        if(d <= SURF_DIST) {\n            hit = true;\n            break;\n        }\n        if(dO >= MAX_DIST) {\n            hit = false;\n        }\n        \n        dO += d;\n    }\n    \n    vec3 p = ro+rd * dO;\n    \n    vec3 n = vec3(0,1,0);\n    if(hit){\n        n = normal(p);\n    }\n    \n    Material outM;\n    distMat(p, outM);\n    \n    return ray(hit, p, dO, n, ro, rd, outM);\n}\n\nvec3 color (in vec3 ro, in vec3 rd) { \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    \n    for (int i = 0; i < BOUNCES; i++) {\n        vec3 col = vec3(0.);\n        ray r = raymarch(ro, rd);\n        \n        col = r.mat.col;\n        \n        ro = r.pos + r.n * SURF_DIST * 2.0;\n        \n        if(r.mat.id == DIFF){\n            rd = rand_hemisphere(r.n);\n        }\n        \n        if(r.mat.id == CHEK){\n            rd = rand_hemisphere(r.n);\n            col = lerp(vec3(0.3),vec3(0.4),round(0.5+0.25*(sin(r.pos.x)+sin(r.pos.z))));\n        }\n        \n        if(r.mat.id == REFL){\n            float a = r.mat.aux;\n            rd = rand_hemisphere_weighted(rd, r.n, a);\n        }\n        if(r.mat.id == EMIT) {\n            rd = vec3(0);\n            \n            fcol *= col * r.mat.aux;\n            tcol += fcol;\n            \n            continue;\n        }\n        \n        if(r.hit == false) {\n            col = texture(iChannel1, r.ro).rgb * 0.7;\n            rd = vec3(0.);\n            \n            fcol *= col;\n            tcol += fcol;\n            \n            continue;\n        }\n        \n        fcol *= col;\n        tcol += fcol * 0.01;\n    }\n    \n    return tcol;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord/iResolution.xy)-.5)/vec2(iResolution.y/iResolution.x, 1.);\n    \n    init_rand(uv + iTime + 1.0);\n    \n    // Setup for raycast\n    vec2 tv = (((fragCoord+vec2(rand(),rand()))/iResolution.xy)-.5)/vec2(iResolution.y/iResolution.x, 1.);\n    vec3 ro = vec3(0,0,-5.);\n    vec3 rd = normalize(vec3(tv, 1.));\n    \n    // Rotations\n    vec2 m = iMouse.xy / iResolution.xy - 0.5;\n    \n    rd.yz *= rot(-m.y);\n    rd.xz *= rot(-m.x);\n    ro.yz *= rot(-m.y);\n    ro.xz *= rot(-m.x);\n    \n    \n    \n    vec3 col = color(ro, rd);\n    \n    //vec3 col = vec3(raymarch(p, rd).hit ? vec3(1.) : vec3(0.));\n    \n    \n    // Fog\n    // col *= 1.-clamp(o.dist*0.01, 0.0, 1.0);\n\n    if(texelFetch(iChannel0, ivec2(0), 0).xyzw == vec4(iResolution.xy, iMouse.xy)){\n        fragColor = vec4(col, 1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else {\n        fragColor = vec4(col, 1.0);\n    }\n    \n    if(ivec2(fragCoord) == ivec2(0))\n        fragColor = vec4(iResolution.xy, iMouse.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}