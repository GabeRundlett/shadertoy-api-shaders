{
    "Shader": {
        "info": {
            "date": "1579370135",
            "description": "Praise the Sun!",
            "flags": 0,
            "hasliked": 0,
            "id": "wdGGDh",
            "likes": 12,
            "name": "Judgement of the Sun",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "sun",
                "sinusoidal",
                "solaire",
                "praise"
            ],
            "usePreview": 0,
            "username": "irwatts",
            "viewed": 430
        },
        "renderpass": [
            {
                "code": "// Judgement of the Sun\n\n// Many thanks to IQ\n// https://iquilezles.org/articles/smin\n// Polynomial Cubic Smooth Min (k = 0.1);\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a,b)-h*h*h/(6.0*k*k);\n}\n\n// Noise\nfloat randFloat(float n)\n{\n \treturn fract( sin( n*64.19 )*420.82 );\n}\nvec2 randVec2(vec2 n)\n{\n \treturn vec2(randFloat( n.x*12.95+n.y*43.72 ),randFloat( n.x*16.21+n.y*90.23 )); \n}\nfloat worley(vec2 n, float s)\n{\n    float dist = 2.0;\n    for( int x=-1;x<=1;x++ )\n    {\n        for( int y=-1;y<=1;y++ )\n        {\n            vec2 p = floor( n/s )+vec2(x,y);\n            float d = length( randVec2( p )+vec2(x,y)-fract( n/s ) );\n            if ( d < dist )\n            {\n             \tdist = d;   \n            }\n        }\n    }\n    return dist;\n}\n\nfloat wave(float dist, float offset)\n{\n    return (0.01*sin(29.0*dist-0.9*(iTime+offset)))\n        +(0.005*sin(72.0*dist-3.1*(iTime+offset)))\n        +(0.003*sin(96.0*dist-4.2*(iTime+offset)));\n}\n\n// Clouds\nvoid clouds(inout vec3 col, in vec2 uv)\n{\n    float noise = 0.8*worley(uv*64.0+vec2(-20.42*iTime,0.0), 128.0)+0.15*worley(uv*64.0+vec2(923.324-1.2*iTime,10.234), 5.0);\n    float grain = randFloat(uv.x*12.95+uv.y*43.72+0.001*noise);\n    noise -= grain*0.05;\n    vec3 lightDir = normalize(vec3(-0.25, 0.75, 0.1));\n    vec3 norm = normalize(vec3(worley(uv*256.0+vec2(90.1921,403.32), 32.0-8.0*noise)-0.5, 0.4*(worley(uv*(64.0+128.0*noise)+vec2(90.1921,3.14159), 24.0)-0.5), 0.5));\n    float lightDot = dot(lightDir, norm);\n    float disp = 10.0*wave(lightDot+uv.y,0.0);\n    float light = clamp(0.64+lightDot, 0.0, 1.0);\n    \n    col = mix(vec3(0.1,0.42,0.64), col, light);\n}\n\n// Sun Arms\nconst vec3 ARMS_COLOR = vec3(0.4745098, 0.1098039, 0.1647059);\nconst vec3 ARMS_END_COLOR = vec3(0.3803922, 0.1254902, 0.1647059);\nconst vec3 ARMS_SPLOTCH_COLOR = vec3(0.1901961, 0.0627451, 0.0823530);\nconst float ARMS_INNER_RADIUS = 0.18;\nconst float ARMS_OUTLINE = 0.005;\nconst float ARMS_FEATHER = 0.0025;\nconst float ARMS_LENGTH = 0.48;\nconst float ARMS_THICKNESS = 0.042;\n\nvoid arms(inout vec3 col, in vec2 uv, in vec2 id)\n{\n    float dist = 1.0;\n    float innerDist = length(uv)-ARMS_INNER_RADIUS;\n    \n    //float thickness = pow((ARMS_THICKNESS*cos((2.6/ARMS_LENGTH)*dist)),0.9);\n    float thickness = (1.0-pow(clamp(innerDist/(ARMS_LENGTH-ARMS_INNER_RADIUS),0.0,1.0),2.0))\n        *ARMS_THICKNESS;\n    \n    vec3 armColor = mix(ARMS_COLOR, ARMS_END_COLOR, \n                        clamp(innerDist/(ARMS_LENGTH-ARMS_INNER_RADIUS),0.0,1.0));\n    \n    float armDist = 0.0;\n    // Horizontal '-'\n    armDist = length(uv+vec2(clamp(-uv.x,-ARMS_LENGTH,ARMS_LENGTH),\n                             wave(innerDist,12.92*id.x)))-thickness+0.006;\n    dist = min(dist, armDist);\n    // Vertical '|'\n    armDist = length(uv+vec2(wave(innerDist,91.42*id.y),\n                             clamp(-uv.y,-ARMS_LENGTH,ARMS_LENGTH)))-thickness+0.006;\n    dist = min(dist, armDist);\n    // Diagonal '\\'\n    armDist = abs(uv.x+uv.y-wave(innerDist,69.32*(id.x+3.0*id.y)))\n        +0.012*abs(uv.x-uv.y)-thickness*1.4;\n    dist = min(dist, armDist);\n    // Diagonal '/'\n    armDist = abs(uv.x-uv.y+-wave(innerDist,128.13*(id.x+3.0*id.y)))\n        +0.012*abs(uv.x+uv.y)-thickness*1.4;\n    dist = min(dist, armDist);\n    \n    dist = smin(dist, innerDist, 0.05);\n    \n    // Background Sky Blue\n    col = mix(col, vec3(0.1,0.42,0.64), dist*2.0 );\n    \n    float outlineMask = smoothstep(ARMS_OUTLINE+ARMS_FEATHER,ARMS_OUTLINE,dist);\n    col = mix(col, vec3(0.0), outlineMask);\n    float armsMask = smoothstep(ARMS_FEATHER,0.0,dist);\n    float noise = 0.42*worley(uv*512.0, 32.0);\n    col = mix(col, armColor*(1.0+noise), armsMask);\n    \n    // Splotches\n    float splotchMask = pow(abs(1.0-worley(uv*(512.0), 12.0+20.0*wave(innerDist,42.13))), 4.0)*smoothstep(0.1, 0.0, innerDist)*\n        smoothstep(ARMS_FEATHER+0.03,0.0,dist+0.04);\n    col = mix(col, ARMS_SPLOTCH_COLOR, splotchMask);\n}\n\n// Sun Center\nconst vec3 CENTER_COLOR = vec3(0.6823529, 0.7058824, 0.3294118);\nconst float CENTER_RADIUS = 0.14;\nconst float CENTER_OUTLINE = 0.006;\nconst float CENTER_FEATHER = 0.004;\n\nvoid center(inout vec3 col, in vec2 uv)\n{\n    float dist = length(uv)-CENTER_RADIUS;\n    float outlineMask = smoothstep(CENTER_OUTLINE+CENTER_FEATHER,CENTER_OUTLINE,dist);\n    col = mix(col, vec3(0.0), outlineMask);\n    float centerMask = smoothstep(CENTER_FEATHER,0.0,dist);\n    //col = mix(col, CENTER_COLOR, centerMask);\n    //col = mix(col, CENTER_COLOR, 0.3*pow(1.0-dist,3.0));\n    // Shading\n    vec3 lightDir = normalize(vec3(-0.5, -0.042, 0.2));\n    float light = clamp(dot(lightDir, normalize(vec3(uv/CENTER_RADIUS, \n                                                     sqrt(1.0-clamp(dot(uv, uv),0.0,1.0))))), 0.0, 1.0);\n    //light = pow(light, 0.5);\n    float cells1 = 1.0-pow(worley(uv*1024.0, 32.0+100.0*wave(dist,189.37)), 0.2);\n    float cells2 = 1.0-pow(worley(uv*1024.0, 24.0+100.0*wave(dist,42.13)), 0.2);\n    float noise = 0.8*smin(cells1, cells2, 0.5);\n    float shading = 1.6*(1.0-((1.0-light)*(0.2+noise)));\n    //shading = light;\n    vec3 centerColor = mix(CENTER_COLOR, shading*CENTER_COLOR, 0.42);\n    col = mix(col, centerColor, centerMask);\n    \n}\n\n// Sun Face\nconst float BROW_WIDTH = 0.032;\nconst float BROW_THICKNESS = 0.0025;\nconst float BROW_L_X = -0.045;\nconst float BROW_L_Y = -0.074;\nconst float BROW_R_X = 0.06;\nconst float BROW_R_Y = -0.072;\nconst float SOCKET_WIDTH = 0.038;\nconst float SOCKET_THICKNESS = 0.001;\nconst float SOCKET_L_X = -0.053;\nconst float SOCKET_L_Y = -0.052;\nconst float SOCKET_R_X = 0.06;\nconst float SOCKET_R_Y = -0.052;\nconst float NOSE_HEIGHT = 0.035;\nconst float NOSE_THICKNESS = 0.0025;\nconst float NOSE_X = -0.015;\nconst float NOSE_Y = -0.029;\nconst float NOSTRILS_WIDTH = 0.02;\nconst float NOSTRILS_THICKNESS = 0.003;\nconst float NOSTRILS_X = 0.0;\nconst float NOSTRILS_Y = 0.015;\nconst float EYE_RADIUS = 0.005;\nconst float EYE_L_X = -0.052;\nconst float EYE_L_Y = -0.04;\nconst float EYE_R_X = 0.06;\nconst float EYE_R_Y = -0.04;\nconst float MOUTH_WIDTH = 0.042;\nconst float MOUTH_THICKNESS = 0.001;\nconst float MOUTH_Y = 0.05;\nconst float CHIN_WIDTH = 0.015;\nconst float CHIN_HEIGHT = 0.015;\nconst float CHIN_THICKNESS = 0.002;\nconst float CHIN_X = 0.0;\nconst float CHIN_Y = 0.08;\nconst float FACE_FEATHER = 0.0025;\n\nvoid face(inout vec3 col, in vec2 uv)\n{\n    float dist = 1.0;\n    float thickness = 0.0;\n    float disp = 0.0;\n    \n    vec2 eyesOffset = vec2(0.008*(sin(iTime*0.2+0.42)+0.42*sin(iTime*0.31)+0.1*sin(iTime*1.3)),0.0);\n    \n    // Left Eyebrow\n    thickness = BROW_THICKNESS+(0.001*sin(54.0*uv.x+2.1));\n    disp = (0.006*sin(50.0*uv.x+4.9));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          BROW_L_X-BROW_WIDTH,BROW_L_X+BROW_WIDTH),\n                                    BROW_L_Y-disp))-thickness);\n    \n    // Right Eyebrow\n    thickness = BROW_THICKNESS+(0.0015*sin(54.0*uv.x-2.9));\n    disp = (0.006*sin(90.0*uv.x+1.1));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          BROW_R_X-BROW_WIDTH,BROW_R_X+BROW_WIDTH),\n                                    BROW_R_Y-disp))-thickness);\n    // Left Eye Socket\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-1.8));\n    disp = (0.004*sin(80.0*uv.x+4.2+eyesOffset.x*42.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.005),\n                                    SOCKET_L_Y-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.002*sin(54.0*uv.x+2.2));\n    disp = (0.013*sin(120.0*uv.x+1.2));\n    dist = smin(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH+0.0008,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.072),\n                                    SOCKET_L_Y+0.004-disp))-thickness,\n               0.01);\n    thickness = SOCKET_THICKNESS+(0.0003*sin(80.0*uv.x-3.1));\n    disp = (0.003*sin(120.0*uv.x+2.2+eyesOffset.x*200.1));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH+0.02,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.015),\n                                    SOCKET_L_Y+0.022-disp))-thickness);\n    \n    // Right Eye Socket\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-2.9));\n    disp = (0.005*sin(100.0*uv.x+1.1+eyesOffset.x*42.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH,\n                                          SOCKET_R_X+SOCKET_WIDTH),\n                                    SOCKET_R_Y-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-2.9));\n    disp = (0.02*sin(70.0*uv.x-3.2));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH-0.01,\n                                          SOCKET_R_X-0.04),\n                                    SOCKET_R_Y+0.022-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.0003*sin(54.0*uv.x-2.9));\n    disp = (0.01*sin(70.0*uv.x-4.5+eyesOffset.x*60.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH+0.015,\n                                          SOCKET_R_X+SOCKET_WIDTH-0.008),\n                                    SOCKET_R_Y+0.015-disp))-thickness);\n    \n    // Nose Bridge\n    thickness = NOSE_THICKNESS+(0.0015*sin(54.0*uv.y-2.9));\n    disp = (0.003*sin(120.0*uv.y-3.1));\n    dist = smin(dist, length(uv+vec2(NOSE_X-disp,\n                              clamp(-uv.y,NOSE_Y-NOSE_HEIGHT,NOSE_Y+NOSE_HEIGHT)))-thickness, \n                0.01);\n    // Nose Nostrils\n    thickness = NOSTRILS_THICKNESS+(0.002*sin(54.0*uv.x+1.0));\n    disp = (0.004*sin(160.0*uv.x-2.4));\n    dist = smin(dist, length(uv+vec2(clamp(-uv.x,NOSTRILS_X-NOSTRILS_WIDTH,\n                                          NOSTRILS_X+NOSTRILS_WIDTH),NOSTRILS_Y-disp))-thickness,\n               0.02);\n\n    // Left Eyeball\n    dist = min(dist, length(uv+vec2(EYE_L_X+eyesOffset.x,EYE_L_Y+eyesOffset.y))-EYE_RADIUS);\n    // Right Eyeball\n    dist = min(dist, length(uv+vec2(EYE_R_X+eyesOffset.x,EYE_R_Y+eyesOffset.y))-EYE_RADIUS);\n    \n    // Mouth\n    thickness = MOUTH_THICKNESS+(0.0015*sin(54.0*uv.x-1.7));\n    disp = (0.002*sin(120.0*uv.x-2.4));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,-MOUTH_WIDTH,MOUTH_WIDTH),\n                                    MOUTH_Y-disp))-thickness);\n    \n    // Chin\n    thickness = CHIN_THICKNESS+(0.005*sin(54.0*uv.x+0.4));\n    disp = (0.003*sin(80.0*(CHIN_X+uv.x)-2.8));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,CHIN_X-CHIN_WIDTH,CHIN_X+CHIN_WIDTH),\n                                    CHIN_Y-disp))-thickness);\n    thickness = CHIN_THICKNESS+(0.0005*sin(54.0*uv.y-2.9));\n    disp = (0.006*sin(120.0*(CHIN_Y+uv.y)+3.9));\n    dist = min(dist, length(uv+vec2(CHIN_X-0.022-disp,\n                              clamp(-uv.y,CHIN_Y+0.02-CHIN_HEIGHT,\n                                    CHIN_Y+0.01+CHIN_HEIGHT)))-thickness);\n    \n    col = mix(col, vec3(0.0), smoothstep(FACE_FEATHER,0.0,dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-(0.5*iResolution.xy))/iResolution.y;\n    //cuv *= 1.0+(0.5*sin(iTime*0.5));\t// Scale in out\n    vec3 col = vec3(1.0);\n    vec2 id = floor(uv*2.0);\n    clouds(col, cuv);\n    arms(col, cuv, id);\n    center(col, cuv);\n    face(col, cuv);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}