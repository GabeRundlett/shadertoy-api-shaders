{
    "Shader": {
        "info": {
            "date": "1698839462",
            "description": "How to use it?\nSave the picture from z=1 to z=textureSize/amount in full screen mode.If texture size is 128 and the amount is 8,you will get 16 pictures and cut each the size to 128x1024.Create a new 128x16384 picture and splicing them from top to bottom.",
            "flags": 0,
            "hasliked": 0,
            "id": "cltyzr",
            "likes": 1,
            "name": "3D Procedural Texture Generator",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "cube",
                "texture",
                "color",
                "coordinate"
            ],
            "usePreview": 0,
            "username": "blackholes",
            "viewed": 273
        },
        "renderpass": [
            {
                "code": "const int colorType=0;\nint z=\n1\n;\n//z:coordnate xyz\n\nconst int amount=8;//How much be shown at once\nconst float textureSize=128.f;//texture3D size:128x128x128\n#define PI 3.1415926535f\nfloat j;\nvec3 r;\nvec3 random3(vec3 c) {\n\tj = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333,G3 =  0.1666667;\n/* 3d simplex noise */\nvec3 s,x,e,i1,i2,x1,x2,x3;\nvec4 w,d;\nfloat simplex3d(vec3 p) {\np*=0.5f;\n//p.z*=0.5f;\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t s = floor(p + dot(p, vec3(F3)));\n\t x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t e = step(vec3(0.0), x - x.yzx);\n\t i1 = e*(1.0 - e.zxy);\n\t i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t x1 = x - i1 + G3;\n\t x2 = x - i2 + 2.0*G3;\n\t x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return 30.f/15.f*dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.545f*simplex3d(m)+\n    0.545f*simplex3d(m/exp(1.f))+\n    0.545f*simplex3d(m/exp(2.f));\n}\n\nfloat devide(float x)\n{\nif(x<0.5f)\nreturn x*x*2.f;\nelse\n{\nreturn 1.f-(x-1.f)*(x-1.f)*2.f;\n}\n}\n\n\tfloat value;\n    vec2 p;\n    vec3 p3;\n    const vec3 GRID_DIMS = textureSize*vec3(0.5f, 0.5f, 0.5f);\nvec3 a;\nvec3 m;\nvec3 color,color1,color2;\nbool isBright;\nint z2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tp.x = fragCoord.x;\n    p.y = iResolution.y-fragCoord.y;\nz=(z-1)*amount;\n    if(p.x>=0.f&&p.x<textureSize&&\n    p.y>=0.f&&p.y<textureSize*float(amount)\n    )\n    {\n    for(int i=1;i<=amount;i++)\n    {\n    if(p.y>=textureSize*float(i-1)&&p.y<textureSize*float(i))\n    {\n    p3.y=p.y-textureSize*float(i-1);\n    z2=z+i;\n    }\n    }\n    p3 = vec3(p.x,p3.y, float(z2)-0.5f);\n    if(p3.z>=0.f&&p3.z<textureSize)\n    {\n      \n        if(colorType==0)\n        {//COORDINATE\n            vec3 coordinate3D=p3/textureSize;\n            color=coordinate3D;\n        }\n         if(colorType==1)\n        {//3D NOISE\n            color=0.6f+vec3(0.2f)*simplex3d(p3);\n        }\n        if(colorType==2)\n        {//3D FRACTAL\n            color=0.6f+vec3(0.2f)*simplex3d_fractal(p3);\n        }\n    }\n}\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}