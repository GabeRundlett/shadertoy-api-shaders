{
    "Shader": {
        "info": {
            "date": "1686945333",
            "description": "Rudimentary highlighter of \"smooth components\" of a 2D scene.\nNeeds some time to converge, more time if resolution is higher.\nClick around, some components are invisibly small.",
            "flags": 48,
            "hasliked": 0,
            "id": "DdlyRB",
            "likes": 2,
            "name": "Component Highlighter",
            "published": 3,
            "tags": [
                "graph",
                "interactivity",
                "persistence",
                "computation"
            ],
            "usePreview": 0,
            "username": "cuzzo008",
            "viewed": 184
        },
        "renderpass": [
            {
                "code": "#define IMG_CHAN iChannel0\n#define COMP_CHAN iChannel1\n#define BLURRED_IMG_CHAN iChannel2\n\n// direction should be normalized\nfloat shimmer(vec2 coord, vec2 direction, float width, float len, float rate, float gleam, float gleamRate) {\n    float isoLine = mod(dot(coord, direction.yx) + (iTime * len) / rate, len);\n    isoLine = mix(len - isoLine, isoLine, step(0.0, isoLine));\n    float sine = sin(isoLine * PI / width);\n    float glimmer = sin(iTime* PI / gleamRate);\n    glimmer = (1.0 - gleam) + gleam*(glimmer * glimmer);\n    return glimmer * mix(sine * sine, 0.0, step(width, isoLine));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixelCoord = ivec2(fragCoord);\n    ivec2 mouseCoord = ivec2(iMouse.xy);\n    \n    vec4 pixelComponentID = texelFetch(COMP_CHAN, pixelCoord, 0);\n    vec4 mouseComponentID = texelFetch(COMP_CHAN, mouseCoord, 0);\n    bool sameComponent = all(equal(pixelComponentID, mouseComponentID));\n    \n    vec4 baseColor = texelFetch(IMG_CHAN, pixelCoord, 0);\n    vec2 shimmerCoord = fragCoord;\n    vec2 shimmerDirection = vec2(-sqrt(2.0)/2.0, sqrt(2.0)/2.0);\n    // radial shimmering from mouseclick point\n    // shimmerCoord = fragCoord - iMouse.xy;\n    // shimmerDirection = -normalize(shimmerCoord).yx;\n    float scalar = shimmer(shimmerCoord, shimmerDirection, 15.0, 120.0, 1.0, 0.6, 1.59283);\n    \n    fragColor = mix(0.75 * baseColor, (0.90 * baseColor) + 0.1*scalar * vec4(1.0), float(sameComponent));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DOWN_PRESSED() texelFetch(KEY_CHAN, ivec2(KEY_DOWN, 0), 0).r\n\nconst float PI = radians(180.0);\nconst int KEY_DOWN  = 40;\n\nconst float distThreshold = 0.01; // Tweak me!\nconst float distThresholdSquared = distThreshold * distThreshold;\n\nconst float blurRadius = 5.0; // Tweak me!\nconst float blurRadiusCeil = ceil(blurRadius);\nconst float blurRadiusSquared = blurRadius * blurRadius;\nfloat blurredPixelWeight(float squaredDist) {\n    return mix(0.0, inversesqrt(1.0 + squaredDist), step(squaredDist, blurRadiusSquared));\n}\n\n/* The main thing that needs adjustment is the color distance function should correspond\n * better to human perception.  Maybe we need some kind of edge detection buffer too.\n * Could consider using some 2D linear-best-fit ideas.\n */",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Buffer A holds the source image to analyze\n\n#define IMG_CHAN iChannel0\n#define IMG_CHAN_RES ivec2(iChannelResolution[0].xy)\n#define SELF_CHAN iChannel1\n#define SELF_CHAN_RES ivec2(iChannelResolution[1].xy)\n#define KEY_CHAN iChannel3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 10 && DOWN_PRESSED() == 0.0) {\n        fragColor = texelFetch(SELF_CHAN, ivec2(fragCoord), 0);\n    } else {\n        fragColor = texelFetch(IMG_CHAN, ivec2(fragCoord) % IMG_CHAN_RES, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer B holds a processed version of Buffer A\n\n#define IMG_CHAN iChannel0\n#define SELF_CHAN iChannel1\n#define IMG_CHAN_RES ivec2(iChannelResolution[1].xy)\n#define KEY_CHAN iChannel3\n\nvec4 blur(vec2 coord) {\n    vec4 aggr = vec4(0.0);\n    float aggrWeight = 0.0;\n    for (float i = -blurRadiusCeil; i <= blurRadiusCeil; i++) {\n        for (float j = -blurRadiusCeil; j <= blurRadiusCeil; j++) {\n            vec2 pixelOffset = vec2(i, j);\n            ivec2 pixelCoord = ivec2(coord + pixelOffset);\n            float withinBounds = float(   pixelCoord.x >= 0\n                                       && pixelCoord.y >= 0\n                                       && pixelCoord.x < IMG_CHAN_RES.x\n                                       && pixelCoord.y < IMG_CHAN_RES.y);\n            float squaredDistance = dot(pixelOffset, pixelOffset);\n            float weight = blurredPixelWeight(squaredDistance);\n            \n            aggrWeight += weight;\n            aggr += weight * texelFetch(IMG_CHAN, ivec2(pixelCoord), 0);        \n        }\n    }\n    return aggr / aggrWeight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 10 && DOWN_PRESSED() == 0.0) {\n        fragColor = texelFetch(SELF_CHAN, ivec2(fragCoord), 0);\n    } else {\n        fragColor = blur(fragCoord);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/* Buffer C holds per-pixel component identification info\n * Component IDs propagate at a rate of 1 pixel per frame\n * Component IDs are the pair .xy of a pixel color, initially\n * the coordinates of the pixel.\n * Could use sequential ints for a nice speed boost, but I was a\n * bit worried about resolutions exceeding 16.7 MP getting buggy.\n */ \n\n#define IMG_CHAN iChannel0\n#define SELF_CHAN iChannel1\n#define SELF_CHAN_RES ivec2(iChannelResolution[1].xy)\n#define KEY_CHAN iChannel3\n\nconst ivec2[] neighborhood = ivec2[](\n    ivec2(-1, -1),\n    ivec2(-1, 0),\n    ivec2(-1, 1),\n    ivec2(0,-1),\n    ivec2(0,1),\n    ivec2(1,-1),\n    ivec2(1,0),\n    ivec2(1,1)\n);\n\n/*\nconst ivec2[] neighborhood = ivec2[](\n    ivec2(-1,0),\n    ivec2(0,-1),\n    ivec2(0,1),\n    ivec2(1,0)\n);\n*/\n\n// Could possibly be done faster with some clever tricks?\n// In general this method takes 2n - 1 comparisons for dimension n.\nvec2 lexicographicMin(vec2 v1, vec2 v2) {\n    vec2 minimum = mix(v1, v2, step(v2.y, v1.y));\n    minimum = mix(v1, minimum, step(minimum.x, v1.x));\n    minimum = mix(v2, minimum, step(minimum.x, v2.x));\n    return minimum;\n}\n\nfloat distanceWithinThreshold(vec3 c1, vec3 c2) {\n    vec3 diff = c1 - c2;\n    float squaredDist = dot(diff, diff);\n    return step(squaredDist, distThresholdSquared);\n}\n\nvec2 minOfNeighborhood(ivec2 centerCoord) {\n    ivec2 texelCoord = centerCoord;\n    vec2 minimum = texelFetch(SELF_CHAN, centerCoord, 0).xy;\n    vec3 centerColor = texelFetch(IMG_CHAN, centerCoord, 0).xyz;\n    for (int i = 0; i < neighborhood.length(); i++) {\n        texelCoord = centerCoord + neighborhood[i];\n        texelCoord.x = clamp(texelCoord.x, 0, SELF_CHAN_RES.x - 1);\n        texelCoord.y = clamp(texelCoord.y, 0, SELF_CHAN_RES.y - 1);\n        vec2 candidateMinimum = texelFetch(SELF_CHAN, texelCoord, 0).xy;\n        vec3 candidateColor = texelFetch(IMG_CHAN, texelCoord, 0).xyz;\n        candidateMinimum = mix(minimum, candidateMinimum, distanceWithinThreshold(centerColor, candidateColor));\n        minimum = lexicographicMin(minimum, candidateMinimum);\n    }\n    return minimum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 10 && DOWN_PRESSED() == 0.0) {\n        fragColor = vec4(minOfNeighborhood(ivec2(fragCoord)), 0.0, 0.0);\n    } else {\n        fragColor = vec4(fragCoord, 0.0, 0.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}