{
    "Shader": {
        "info": {
            "date": "1506143454",
            "description": "Optimized for mobile, click the screen to adjust distortion",
            "flags": 0,
            "hasliked": 0,
            "id": "XtfcDS",
            "likes": 18,
            "name": "Stereo AR test scene",
            "published": 3,
            "tags": [
                "raymarch",
                "ar",
                "vr"
            ],
            "usePreview": 0,
            "username": "KylBlz",
            "viewed": 1043
        },
        "renderpass": [
            {
                "code": "//Some kind of uhh... device... for umm... yeah.\n//#define NO_SCENE\n//#define NO_GLASSES\n\n#define PI 3.14159265\n#define zFar 100.\n//eyebox\n#define IPD 0.2\n//raymarch steps\n#define steps 64\n//min dist considered hit\n#define minC .002\n#define tex(a,b) textureLod(a,b,1.5)\n\n//the current camera location and initial ray dir\nvec3 camLoc, rayDir;\n\n//tools\nvec3 rotateXY(vec3 p, vec2 angle) {\n    vec2 c = cos(angle), s = sin(angle);\n    p.yz *= mat2 (c.x,s.x,-s.x,c.x);\n    p.xz *= mat2 (c.y,s.y,-s.y,c.y);\n    return p;\n}\n//used for depth testing\nvec2 lt(const vec2 l, const vec2 r) { \n    return (l.x < r.x)? l: r;\n}\n\n\n//light location, size\nconst int mtLight = 1;\nvec4 light = vec4(vec3(1.,-.5,-3.), 0.1);\nvec3 lightCol = vec3(1., .75, .5);\nfloat brightness = 1.;\n//light functions\nfloat map_light(vec3 ro) {\n    return distance(ro, light.xyz) - light.w;\n}\nvec3 map_light_norm(vec3 ro) { \n    return normalize(ro - light.xyz);\n}\nvec3 map_light_pm(in vec3 ro, in vec3 rd) { \n    vec3 nrm = map_light_norm(ro);\n    return lightCol*brightness*max(0.,dot(-rd, nrm));\n}\nvec3 map_light_rgb(vec3 ro, vec3 rd, vec3 nrm) { \n    return map_light_pm(ro, rd);\n}\nvec3 map_light_ray(vec3 ro, vec3 rd, vec3 nrm) {\n    return rd;\n}\n\n\n//glass sphere location, size\nconst int mtGsph = 2;\nvec4 Gsphere = vec4(vec3(1.2, 0., -2.), 0.8);\n//glass sphere functions\nfloat map_Gsph(vec3 ro) {\n    return distance(ro, Gsphere.xyz) - Gsphere.w;\n}\nvec3 map_Gsph_norm(vec3 ro) {\n    return normalize(ro - Gsphere.xyz);\n}\nvec3 map_Gsph_pm(vec3 ro) { \n    return vec3(0.);\n}\nvec3 map_Gsph_rgb(vec3 ro, vec3 rd, vec3 nrm) { \n    return .5*(Gsphere.z - ro.zzz);\n}\nvec3 map_Gsph_ray(vec3 ro, vec3 rd, vec3 nrm) {\n\treturn refract(rd, nrm, 0.85);\n}\n\n\n//reflective sphere location, size\nconst int mtSsph = 3;\nvec4 Ssphere = vec4(vec3(-1., 0.5, -5.), 0.5);\n//reflective sphere functions\nfloat map_Ssph(vec3 ro) {\n    return distance(ro, Ssphere.xyz) - Ssphere.w;\n}\nvec3 map_Ssph_norm(vec3 ro) { \n    return normalize(ro - Ssphere.xyz); \n}\nvec3 map_Ssph_pm(vec3 ro, vec3 rd) {\n    vec3 nrm = map_Ssph_norm(ro);\n    float dst = distance(Ssphere.xyz, ro);\n    float fade = max(0., dot(rd, -nrm));\n    vec3 rotnrm = rotateXY(nrm, vec2(0., iTime*.5));\n    vec3 col = textureLod(iChannel0, rotnrm, 1./dst + 1.*(1.-fade)).rgb;\n    return col*col*fade;\n}\nvec3 map_Ssph_rgb(vec3 ro, vec3 rd, vec3 nrm) {\n    return map_Ssph_pm(ro, rd);\n}\nvec3 map_Ssph_ray(vec3 ro, vec3 rd, vec3 nrm) {\n    return reflect(rd, nrm);\n}\n\n\n//aabb Center Size\nstruct box { vec3 c, s; };\nconst int mtBox = 5;\nbox b1 = box(vec3(0.,-1.5,0.), vec3(.5));\nfloat map_box(in vec3 ro) {\n  vec3 d = abs(b1.c - ro) - b1.s;\n  return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));\n}\nvec3 map_box_norm(vec3 ro) { \n    vec3 d = ro - b1.c;\n    //do a nice bevel\n    return normalize(step(b1.s * .95, abs(d))*sign(d));\n}\nvec3 map_box_pm(vec3 ro, float d) {\n    return vec3(0.);\n}\nvec3 map_box_rgb(vec3 ro, vec3 rd, vec3 nrm) {\n    //sample Ssphere\n    vec3 smp = normalize(ro - Ssphere.xyz),\n         rotnrm = rotateXY(smp, vec2(0., iTime*.5)),\n         col = tex(iChannel0, rotnrm).rgb;\n\t//sample light\n    float lightcontrib = max(0., dot(normalize(light.xyz - ro), nrm)),\n          ssphcontrib = max(0., dot(-smp, nrm));\n    return col*col*ssphcontrib + lightCol*lightcontrib*brightness;\n}\nvec3 map_box_ray(vec3 ro, vec3 rd, vec3 nrm) {\n    return reflect(rd, nrm);\n}\n\n\n//gets normal\nvec3 map_nrm(vec3 ro, int c) { \n    if (c == mtLight)\t return map_light_norm(ro);\n    else if (c == mtSsph)return map_Ssph_norm(ro);\n    else if (c == mtGsph)return map_Gsph_norm(ro);\n    else if (c == mtBox) return map_box_norm(ro);\n    else return vec3(0., 1., 0.);\n}\n//gets surface color\nvec3 map_rgb(vec3 ro, vec3 rd, vec3 nrm, vec3 c) {\n    int cy = int(c.y);\n    //emissive surfaces\n    if (cy == mtLight)\t  return map_light_rgb(ro, rd, nrm);\n    else if (cy == mtSsph)return map_Ssph_rgb(ro, rd, nrm);\n\t//use total dist (c.z) for ghetto AO\n    else if (cy == mtGsph)return map_Gsph_rgb(ro, rd, nrm) * c.z;\n    else if (cy == mtBox) return map_box_rgb(ro, rd, nrm) * c.z;\n    else return vec3(0.0);\n}\n//map light interactions\nvec3 map_ray(vec3 ro, vec3 rd, vec3 nrm, int c) { \n    if (c == mtLight)\t return map_light_ray(ro, rd, nrm);\n    else if (c == mtSsph)return map_Ssph_ray(ro, rd, nrm);\n    else if (c == mtGsph)return map_Gsph_ray(ro, rd, nrm);\n    else if (c == mtBox) return map_box_ray(ro, rd, nrm);\n    else return rd;\n}\n//returns { c(dist, mat, td), color(rgb), ro(xyz), rd(xyz) }\nmat4 map(vec3 pos, vec3 ro, vec3 rd, float t, float dt) {\n    //get distances\n    vec2 Gsphres = vec2(map_Gsph(pos), mtGsph),\n         Ssphres = vec2(map_Ssph(pos), mtSsph),\n         litres = vec2(map_light(pos), mtLight),\n         boxres = vec2(map_box(pos), mtBox);\n\n    //get total distance to other objects (non emissive)\n    float td = max(Gsphres.x, 0.) +\n               max(boxres.x, 0.);\n\n    //depth check and ambient occlusion\n    vec3 c = vec3(lt(lt(lt(Ssphres, Gsphres), litres), boxres), 1.-1./(1.+td*td));\n    \n    mat4 outp = mat4(vec4(c, 0.),\n                     vec4(0.), \n                     vec4(ro, 0.), \n                     vec4(rd, 0.));\n    \n    //get the normal of the closest touching thing\n    if (c.x < t*minC) { //if (c.x < minC) {\n        outp[0].w = 1.;\n        //get normal\n        vec3 nrm = map_nrm(pos, int(c.y));\n        //get color sample\n        outp[1].rgb += map_rgb(pos, rd, nrm, c) * float(steps) / 5.;\n        //get new ray info\n        outp[2].xyz = pos;\n        outp[3].xyz = map_ray(pos, rd, nrm, int(c.y));\n    \n    }\n    //sample participating media\n    outp[1].rgb += (\n    \t    map_Ssph_pm(pos, rd)  / (.5+Ssphres.x*Ssphres.x) +\n            map_light_pm(pos, rd) / (1.+5.*litres.x*litres.x)\n    );\n    \n    return outp;\n}\n\n\n//marches scene\nvec3 march( vec3 _ro, vec3 _rd) {\n    vec3 ro = _ro, rd = _rd, nrm;\n    //start at starting loc\n    float t = 0., dt = 0., ld = 0.;\n    //sdf results\n    mat4 c = mat4(0.);\n    //march vars\n    vec3 col = vec3(0.), pos = ro;\n    //the march loop\n    for( int i=0; i<steps; i++ ) {        \n        //step the ray and update position\n        t += dt;\n        //position to test depth functions\n        pos = ro+rd*t;\n        //get sdf results\n        c = map(pos, ro, rd, t, dt);\n        //update light\n        col += c[1].rgb;\n        ro = c[2].xyz;\n        rd = c[3].xyz;\n        //control step size\n        ld = dt;\n        //step slower closer to the camera\n        dt = min(.2, c[0].x);\n    }\n    \n    //final color\n    return col / float(steps) * 5.;\n}\n\nvec2 distort(float x, float x2, float x3, float x4, float y, float y2, float y3, float y4) {\n    return vec2(\n        \t        0.027935f +\n            x*      1.095561f +\n            y*      0.012740f +\n            x2*    -0.039869f +\n            x*y*    0.124914f +\n            y2*     0.002292f +\n            x3*    -0.292835f +\n            x2*y*  -0.034783f +\n            x*y2*  0.012176f + // un fisheye\n            y3*     0.004875f +\n            x4*   -0.036597f + // unsquish towards eyes\n            x3*y*  -0.110877f +\n            x2*y2* -0.043108f +\n            x*y3*  -0.062561f +\n            y4*     0.019749f\n            ,       0.016951f +\n            x*     0.042731f + // sad face\n            y*      1.076121f +\n            x2*     0.185902f +\n            x*y*   0.060663f + // like looking at a plane side on\n            y2*     0.029832f +\n            x3*    -0.044401f +\n            x2*y*  -0.349245f +\n            x*y2*  -0.008731f +\n            y3*    -0.212708f +\n            x4*    -0.175194f +\n            x3*y*  -0.064730f +\n            x2*y2* -0.232783f +\n            x*y3*   0.054503f +\n            y4*    -0.127740f\n\t);\n}\nvec2 getDistortion(in float LRValue, in float isFunctionForRightEye, in vec2 uv) {\n\t//sample at c,r or -c,r depending on which eye (LRValue) and which the function was designed for (isFunctionForRightEye)\n    float lrx = uv.x * LRValue * isFunctionForRightEye;\n    float x2 = lrx * lrx, x3 = x2 * lrx, x4 = x3 * lrx,\n          y2 = uv.y * uv.y, y3 = y2 * uv.y, y4 = y3 * uv.y;\n    vec2 res = vec2(lrx, uv.y) - distort(lrx, x2, x3, x4, uv.y, y2, y3, y4);\n    res.x *= LRValue * isFunctionForRightEye;\n    //texCoords are c, r from -1 to 1\n    return vec2(uv.x, uv.y) + res;\n}\n//LRValue * isFunctionForRightEye * \n\nvoid mainImage( out vec4 fC, in vec2 fX ) {\n    //get input, update camera\n    camLoc = vec3(0.1 + sin(iTime*.5), -sin(iTime * 0.125) + 1., 5.);\n    //do stereo render\n    float eye = 1.;\n    //place 0,0 in center from -1 to 1 ndc\n    vec2 uv = fX.xy * 2./iResolution.xy - 1.;\n\t//shift to the right eye\n    uv.x = uv.x * 2. - 1.;\n    //split into two eyes\n    if (uv.x < -1.) {\n        uv.x += 2.;\n        eye = -1.;\n   \t\tcamLoc.x += IPD;\n    } else {\n   \t\tcamLoc.x -= IPD;\n    }\n\n#ifndef NO_GLASSES\n    //do distortion correction\n    vec2 eyebox = iMouse.xy/iResolution.xy * vec2(0.14, 0.07);\n    if (dot(eyebox, eyebox) < .0001) eyebox = vec2(0., .001);\n    vec2 dlta = vec2(0.);\n    uv = getDistortion(eye, -1., uv);\n    \n#endif   \n#ifdef NO_SCENE\n    fC = vec4(vec3(sign(fract(uv.x*5.)-.5) * sign(fract(uv.y*5.)-.5)), 1.);\n    return;\n#endif\n    \n\tvec3 camRot = vec3(sin(iTime*0.125)*0.3-0.3, PI, 0.);\n    //camRot is angle vec in rad\n    vec3 camDir = normalize(vec3(uv, 2.0));\n    rayDir = normalize(rotateXY(camDir, camRot.xy));\n    \n    //update stuff\n    light.x = 2. * sin(iTime*PI*0.3) + 1.;\n    light.z = 2. * cos(iTime*PI*0.3) - 3.;\n    brightness = 3.+3.*sin(iTime)*sin(iTime);\n    //calculate stuff\n    vec3 col = march(camLoc, rayDir);\n    //output\n    fC = vec4(pow(clamp(col, vec3(0.), vec3(1.)), vec3(.8)), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}