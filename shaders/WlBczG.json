{
    "Shader": {
        "info": {
            "date": "1594822024",
            "description": "A basic hyperbolic Poincare tiling example to provide a basis for anyone who'd like to make one.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlBczG",
            "likes": 54,
            "name": "Hyperbolic Poincare Tiling",
            "published": 3,
            "tags": [
                "escher",
                "truchet",
                "geometry",
                "art",
                "hyperbolic",
                "impossible",
                "poincare"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1260
        },
        "renderpass": [
            {
                "code": "/*\n\n\tHyperbolic Poincare Tiling\n\t--------------------------\n\n\n\tThis is a simpler hyperbolic polygonal tiling of the Poincare disc that\n    I've put together to accompany the more involved example I posted earlier.\n\n\tIn regard to the Poincare disc side of things, it was helpful to reference\n\tMLA, SL2C and STB's examples -- All authors have really nice work on here,\n\twhich is well worth the look. STB provided me with the link that he used\n    for his \"Hyperbolic Poincaré transformed\" example which enabled me to \n\tstreamline the setup code quite a bit. In fact, I'd imagine that once \n    someone like Fabrice Neyret gets a hold of it, you'll see a two tweet\n\tPoincare tiling. :)\n\n    Anyway, the code is very basic, but I've put in a reasonably thorough\n\texplanation, along with some useful links, so hopefully that'll be enough\n\tto give people a start.\n\n\tBy the way, the default setting is the standard triangle configuration\n\tyou'll see around. However, I've colored the triangle segments to match\n    ajoining ones, and put lines from the triangle center to the vertices to \n    produce the cube look. This is one of countless arrangements and patterns \n    that you may have seen around. I'm hoping others will put up a few more on \n    Shadertoy at some stage.\n\n\n\n    Poincare disc examples:\n\n    // The hyperbolic transformation itself is based on STB's example here,\n    // which I'm assuming was in turn based on a slide presentation by\n    // Vladimir Bulatov: http://www.bulatov.org/math/1001/index.html\n\t//\n    Hyperbolic Poincaré transformed - stb\n\thttps://www.shadertoy.com/view/3lscDf\n\n\n\t// Like everyone else, I love the following example. However, be warned that \n    // it involves complex geometry. :)  Seriously though, Mattz can come up with \n    // solutions to problems in a few minutes that have utterly confounded me for \n    // weeks.\n    //\n\tHyperbolic Wythoff explorer - mattz \n\thttps://www.shadertoy.com/view/wtj3Ry\n\n\n    // The shader that this particular one accompanies.\n    Hyperbolic Poincare Weave - Shane\n    https://www.shadertoy.com/view/tljyRR\n\n*/\n\n// Here's a more Earth tone-looking palette for people who require something\n// less cheery looking... OK, by \"people,\" I mean, me. :D\n//#define EARTH_TONES\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// P represents the number of polygon vertices, and Q is the number of \n// adjacent polygons to each vertex within the Poincare disc.\n//\n// For tilings to work, the following must be true: (P − 2)*(Q − 2)>4.\n//\n// For instance, 3 and 7 will work, but 4 and 4 will not.\n//\n// 3-7, 3-8, 4-5 , 5-4, 6-4, 7-3.\n//\nconst int N\t\t= 3;\t// Polygon vertices.\nconst int Q\t\t= 8;\t// Polygons meeting at a vertex.\n\n#define PI\t\t3.14159265\n#define TAU\t    6.28318531\n\n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec3 initDomain(){\n    \n\t// There are quite a few ways to calculate the initial circular domain \n    // values, simply because there are several solutions to the same geometric \n    // problems, which is all this is. In fact, as geometric situations go,\n    // this is not a particularly difficult one to solve.\n    \n    // Essentially, you're going to be reflecting points about polygonal edges, \n    // so you'll need the distance from your initial circle center to that of \n    // the center of the circle that runs adjacent to the current domain edges in\n    // order to perform a hyperbolic reflection. You'll need the radius of that \n    // circle as well. The distance and radius will depend directly upon how\n    // how many edges your polygon has and how many adjacent polygons (the\n    // number that meet at a vertex point) there are.\n\n    // The following is some highschool level circle and triangle geometry to \n    // get the values we're after. Of course, none of this will mean much without \n    // some imagery to refer to. Shadertoy user, SLB, provided me with a link\n    // to a setup image that made life much easier. Without too much trouble,\n    // it's possible to use whatever trigonometric identities you want to \n    // arrive at the following. In fact, with more effort, I'm pretty sure it'd\n    // be possible to do better. Here's the link:\n    //\n    // The Hyperbolic Chamber - Jos Leys\n    // http://www.josleys.com/article_show.php?id=83\n    //\n    // I also find the imagery on the following page helpful as well:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n   \n    float a = sin(PI/float(N)), b = cos(PI/float(Q));\n\tfloat d2 = cos(PI/float(N) + PI/float(Q))/a;\n\tfloat r2 = 1./(b*b/a/a - 1.);\n\t// Distance between adjacent polygon centers, the adjacent polygon radius,\n    // and the current polygon radius. We're assuming no negatives, but I'm \n    // capping things above zero, just in case.\n\treturn sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.));  \n   \n\n}\n\n// Globle polygon value. Not used here, but normally, it'd be the focus.\n//float gPoly;\n\n// Count variable, which is seful for all kinds of things. It's a measure\n// of how many iterations were required to get to the current polygon.\n// The center polygon would have a count of one, and should increase as we \n// radiate outwards.\nfloat count;\n\n\n// Hyperbolically reflecting the polygon across each of it's edges\n// via an inverse Mobius transform.\nvec2 transform(vec2 p, vec3 circ) {\n    \n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n     \n    float ia = (floor(atan(p.x, p.y)/TAU*float(N)) + .5)/float(N);\n    vec2 vert = rot2(ia*TAU)*vec2(0, circ.x);\n   \n    float rSq = circ.y*circ.y;\n    \n    // Circle inversion, which relates back to an inverse Mobius\n    // transformation. There are a lot of topics on just this alone, but \n    // the bottom line is, if you perform this operation on a point within\n    // the Poincare disk, it will be reflected. It's similar to the\n    // \"p /= dot(p, p)\" move that some may have used before.\n    vec2 pc = p - vert;\n    float lSq = dot(pc, pc);\n    \n    // If the distance (we're squaring for speed) from the current point to\n    // any vertex point is within the circle limits, hyperbolically reflect it.\n    if(lSq<rSq){\n         \n        p = pc*rSq/lSq + vert;\n        //p = rot2(TAU/float(N))*p; // Experimenting with rotation.\n        \n        // Maintaining chirality. I can thank MLA for this bit. If you \n        // don't do this, the coordinates will lose their polarity...\n        // I originally didn't do this. :D\n        //p.x = -p.x;\n        \n        // If we have a hit, increase the counter. This value can be useful\n        // for coloring, and other things.\n        count++;\n         \n    }\n    \n   \n    /* \n    // If you're after a CSG polygon to work with, the following should work.\n    // I've lazily set it to a global, but there'd be cleaner ways to work \n    // the calculations in.\n    float poly = (length(p) - circ.z);\n    poly = max(poly, -(length(pc) - circ.y));\n    gPoly = min(gPoly, poly);\n    */\n    return p;\n}\n\n\n// Very handy. I should write my own, but this works. I\n// rearranged it a bit, but it's the same function.\n//\n// Smooth Floor - Anastadunbar \n// https://www.shadertoy.com/view/lljSRV\nfloat floorSm(float x, float c) {\n    \n    float ix = floor(x); x -= ix;\n    return (pow(x, c) - pow(1.- x, c))/2. + ix;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// Mouse pointer inversion.\nvec2 mouseInversion(vec2 p){\n    \n    // Mouse coordinates.\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    // Hack for the zero case instance. If someone has a better way,\n    // feel free to let me know.\n    if(length(m) < 1e-3) m += 1e-3; \n    // A hack to stop some craziness occurring on the border.\n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n    \n    // Taking the mouse point and inverting it into the circle domain.\n    // Feel free to check some figures, but all will get mapped to \n    // values that lie within circle radius.\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m; \n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x; // Keep chirality. MLA does this. \n    \n    return p;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    // Aspect correct coordinates: Actually, fragCoord is already in \n    // aspect correct form, so shifting and scaling is all that is\n    // required in this particular pixel shader environment.\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    /*\n    // Moving to the half plane model.\n    const float sc = 2.;\n    uv.y += sc/2. + 1.;\n    uv /= dot(uv, uv)/sc;\n    uv.y -= 1.; \n    */\n    \n    // Contracting things just a touch to fit the Poincare domain on \n    // the canvas.\n    uv *= 1.05;\n    \n     \n    // Hyperbolic the hyperbolic... I made that up, but it spherizes things \n    // a bit, which looks interesting.\n    //uv *= (1. + dot(uv, uv))/2.;\n   \n    \n    // Poincare coordinates.\n    vec2 p = uv;\n   \n\n    // A bit of mouse inversion and rotation to begin with. You'll\n    // see this a lot in various hyperbolic examples, and others.\n    p = mouseInversion(p);\n        \n    // Perform some free rotation.\n    p = rot2(iTime/16.)*p;\n    \n   \n    // Inversion count. It's used for all kinds of things, like \n    // random number production, etc.\n    count = 0.;\n    \n    // Globale polygon value. Not used here, but I'll use it when I make\n    // an extruded raymarched version.\n    //gPoly = 1e5;\n    \n    // Filling in the domain origin information: From left to right, it \n    // returns the distance between adjacent polygon centers, the adjacent \n    // polygon radius, and the current polygon radius. These values remain\n    // the same for all polygons throughout the hyperbolic plane, so this \n    // is all that's required to tile the disc.\n    vec3 domInfo = initDomain();    \n    \n    // Handling the imagery outside the Poincare circle domain by inverting or\n    // mirroring it back into the circle so that it shows up... or something\n    // to that effect... It's been a while. Either way, this is what you do\n    // if you want to see the outside pattern. :)\n    //\n    // By the way, if you want to get more of an intuitive feel for circle \n    // inversion, I recommend Numberphile's \"Epic Circles\" video, here:\n    // https://www.youtube.com/watch?v=sG_6nlMZ8f4\n    if(length(p)> 1.) p /= dot(p, p); \n  \n    \n    // Performing multiple reflective inversions to fill out the disk. Due \n    // to the nature of the hyperbolic transform, the polygon tiles get \n    // smaller as you approach the outer disk, and never reach the edge. \n    // There are a bunch of proofs in complex analysis that illustrate\n    // this, but nothing shows it as well as a computer program. :)\n    // Drop the number of iterations and you'll see the process unfold.\n    //\n    // One more important thing I should mention is that there's a test\n    // within the transform function (if you're outside the domain) that \n    // would allow you to break early, but I'm bypassing that for \n    // simplicity. The function is cheap, so I'm letting it run through, \n    // but when speed is an issue, it should be considered.\n    for(int i=0; i<24; i++){\n        p = transform(p, domInfo);\n    }\n    \n    \n    // From here on in, it's just rendering code. None of it is difficult, or\n    // particularly interesting. Once you have the local cell coordinates,\n    // you can render whatever you want. In this case, I've produced some\n    // colors according to whatever polygon segment where in, some dark \n    // center to polygon vertex point lines, and some shading lines with a\n    // dark box -- The last two are based on the center to edge mid point \n    // lines. All very simple.\n  \n   \n    // Vertex lines and edge mid point lines, and points.\n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    \n    // Initial point set to the boundary of whatever circle we're in.\n    vec2 v0 = vec2(0, domInfo.z), m0;\n    \n    // I'm being lazy and looping around the polygon vertices and mid\n    // points to produce the line information. I could just as easily\n    // do the repeat polar thing. I also believe it's easier to read for\n    // those trying to decipher this.\n    for(int i = 0; i<N; i++){\n\n        // Mid edge points. Note that interpolating from one edge vertex\n        // to the other won't give the correct results due to the\n        // hyperbolic nature of the local space, so we're rotating between\n        // vertex points and setting the distance do the correct distance\n        // measured out in the initialization function.\n        m0 = (rot2(PI/float(N))*v0)*(domInfo.x - domInfo.y)/domInfo.z;\n         \n        // Center to vertex distances. \n        ln = min(ln, lBox(p, vec2(0), v0, .007));\n        // Center to edge mid point distances. \n        ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n        \n        // Vertex points.\n        pnt = min(pnt, length(p - v0));\n \n        // Rotating to the next vertex point.\n        v0 = rot2(TAU/float(N))*v0;\n    }\n    \n \n    // Setting a ring distance field, then using that to add more to the \n    // smoothing factor to alleviate aliasing around the borders. It's \n    // hacky, and no substitute for super sampling, but it works well \n    // enough here.\n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;//(count*count + 1.);//fwidth(shape);// \n\n \n    \n    // Setting the color, according to the polygon segment angle. It works\n    // well for this configuration, and others where the adjacent polyongs,\n    // Q are even, but breaks with odd Q, in which case you have to render in\n    // other lines.\n    float angl = mod(atan(p.x, p.y), TAU)*float(N)/TAU;\n    float triSeg = floorSm(angl, .15);  // Note the smooth floor function.\n    triSeg = (triSeg + .5)/float(N);\n\n    // IQ's versatile palette routine. It's one of my favorites.\n    #ifdef EARTH_TONES\n    vec3 oCol = .55 + .45*cos(triSeg*TAU/3.5 + vec3(0, 1, 2)/1.1);\n    #else\n    vec3 oCol = .55 + .45*cos(triSeg*TAU + vec3(0, 1, 2)).yxz;\n    #endif\n    \n    // Line pattern.\n    //float pat = clamp(sin(ln2*TAU*40.)*2. + 1., 0., 1.)*.4 + .8;\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n    \n    // Some subtle polygon segment (cube face) shading.\n    float sh = clamp(.65 + ln/domInfo.z*4., 0., 1.);\n    \n    // The background color. It looks interesting enough like this, but the lines\n    // give it additional depth.\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    // Rendering the lines.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    // The dark boxes on the inside of the ring only.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - .085)));\n\n    \n    // Polygon vertex points and central point.\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    \n    // A quick background image... Definitely needs more effort. :)\n    #ifdef EARTH_TONES\n    vec3 bg = vec3(.85, .4, .3);//.55 + .45*cos(TAU/6. + vec3(0, 1, 2)/1.2);\n    #else\n    vec3 bg = vec3(.4, .2, 1);\n    #endif\n    bg *= .3*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n   \n    // Putting in the outer ring. I did this in a hurry, so you could do it in\n    // fewer steps for sure. Think of it as a lesson on what not to do. :D\n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    /*\n    // Dial markings -- Hours and seconds, for whatever reason. Hmmm, might be too much,\n    // so I'm leaving it out. Yet, another five minutes I'll never get back. :D\n    uv = rot2(iTime/16.)*uv; float ang = atan(uv.x, uv.y)/TAU;\n    float dial = abs(fract(ang*12.) - .5)*2. - .025;\n    dial = min(abs(fract(ang*60.) - .5)*2. - .05, dial);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., max(abs(cir - 1.) - .03, dial)))*.95);\n    */\n    // Shadow.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n\n  \n    // Toning things down ever so slightly. \"1. - exp(col*a)\" is used as a toning\n    // device... I'm toning things down a little bit. I prefer not to post process\n    // too much, but sometimes, it can help tie things together when the\n    // background tones don't match the foreground, and so forth. Sometimes, \n    // multiplying everything by a single subtle sepia color, or whatever can help\n    // tie things together overall. Anyway, comment the line out, and you'll see\n    // that it tones down the highlights just a little.    \n    col = mix(col, 1. - exp(-col), .35);\n    \n    // Rough gamma correction, then present to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}