{
    "Shader": {
        "info": {
            "date": "1620503162",
            "description": "Made this to use it as my wallpaper.\nCan be customized from the [Common] tab.",
            "flags": 32,
            "hasliked": 0,
            "id": "ss2SzG",
            "likes": 2,
            "name": "voronoi kaleidoscope wallpaper",
            "published": 3,
            "tags": [
                "voronoi",
                "kaleidoscope",
                "wallpaper",
                "onedark"
            ],
            "usePreview": 0,
            "username": "Azorlogh",
            "viewed": 442
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////\n// Shader by Azorlogh                //\n//                                   //\n// Check out Common tab to customize //\n///////////////////////////////////////\n\nvec3 render_bg(vec2 pos) {\n\t\tfloat time = iTime*0.1*BACKGROUND_SPEED;\n\t\tpos *= 10.0;\n\t\tpos = rotate(pos, 0.3);\n\t\tpos = mod(pos+time, vec2(1.0));\n\t\tvec2 dist = smoothstep(0.12, 0.15, min(pos, 1.0-pos));\n\t\treturn mix(THEME[0].rgb*1.2, THEME[0].rgb, max(dist.x, dist.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\n\t// background\n\t#ifdef BACKGROUND_TRANSPARENT\n\t\tfragColor = vec4(0);\n\t#else\n\t\tvec2 pos = (gl_FragCoord.xy-iResolution.xy/2.0) / (iResolution.y/2.0);\n\t\tfragColor = vec4(render_bg(pos), 1);\n\t#endif\n\n\t// shadow\n\t#ifdef SHADOW_ENABLE\n\t\tvec4 blurry_pattern = texture(iChannel1, uv);\n\t\tfragColor = fragColor*(1.0-blurry_pattern.a*SHADOW_OPACITY);\n\t#endif\n\t\n\t// pattern\n\tvec4 pattern = texture(iChannel0, uv);\n\tfragColor = alphaBlend(fragColor, pattern);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 kaleido(vec2 p, float time) {\n\tp = abs(p);\n\tp = rotate(p, time*0.1);\n\tp = rotate(p, TAU/16.0+time*0.02);\n\tp = abs(p);\n\tp -= time;\n\treturn p;\n}\n\nconst float NB_COLORS_F = float(NB_COLORS);\n// edge distance algorithm by Inigo Quilez: https://iquilezles.org/articles/voronoilines\nvec4 voronoi(vec2 pos, float time, vec2 center, out float closest_dst) {\n\tvec2 p = vec2(floor(pos));\n\tvec2 f = fract(pos);\n\tint closest_color;\n\tvec2 closest_pos;\n\tvec2 closest_coord;\n\tfloat fade = 0.0;\n\t// first pass: acquire closest point\n\tclosest_dst = 100.0; // represents the closest square distance to a point\n\tfor (int i=-1; i<=1; i++) {\n\t\tfor (int j=-1; j<=1; j++) {\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 rand = hash22(vec2(p) + b)*2.0-1.0;\n\t\t\tfloat phase = rand.x*time*TAU + rand.y;\n\t\t\tvec2 rel_pos = b + 0.3*vec2(cos(phase), sin(phase)) - f;\n\t\t\tfloat dst = dot(rel_pos, rel_pos);\n\t\t\tif (dst < closest_dst) {\n\t\t\t\tclosest_color = int(rand.x*NB_COLORS_F);\n\t\t\t\tclosest_pos = rel_pos;\n\t\t\t\tclosest_coord = b;\n\t\t\t\tclosest_dst = dst;\n\t\t\t\tfade = length(vec2(p)+b-center) - FADE_RADIUS;\n\t\t\t}\n\t\t}\n\t}\n\t// second pass: acquire distance to edge\n\tclosest_dst = 100.0; // now represents the closest distance to an edge\n\tfor( int j=-2; j<=2; j++ ) {\n\t\tfor( int i=-2; i<=2; i++ ) {\n\t\t\tvec2 b = closest_coord + vec2(i, j);\n\t\t\tvec2 rand = hash22(vec2(p) + b)*2.0-1.0;\n\t\t\tfloat phase = rand.x*time*TAU + rand.y;\n\t\t\tvec2 rel_pos = b + 0.3*vec2(cos(phase), sin(phase)) - f;\n\t\t\tif (i != 0 || j != 0) {\n\t\t\t\tfloat dst = dot(0.5*(closest_pos+rel_pos), normalize(rel_pos-closest_pos));\n\t\t\t\tif (dst < closest_dst) {\n\t\t\t\t\tclosest_dst = min(closest_dst, dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfloat alpha = clamp(1.0-fade, 0.0, 1.0);\n\treturn THEME[closest_color] * vec4(1, 1, 1, alpha);\n}\n\nvec4 render(vec2 pos, float time) {\n\tpos = kaleido(pos/SCALE, time);\n\tfloat edge_dist;\n\tvec4 color = voronoi(pos, time, vec2(-time), edge_dist);\n\tcolor.a = mix(color.a, 0.0, 1.0 - smoothstep(0.0, 0.03, edge_dist));\n\treturn color;\n}\n\nconst float PATTERN_SIZE = (FADE_RADIUS + sqrt(2.0)/2.0 + 0.3 + 1.0)*SCALE + 0.04;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord-iResolution.xy/2.0) / (iResolution.y/2.0);\n\tfragColor = vec4(0);\n\tif (length(pos) > PATTERN_SIZE) {\n\t\treturn;\n\t}\n\tfloat time = iTime*TIME_SCALE + TIME_OFFSET;\n\tvec4 pcol = render(pos, time);\n\tfragColor = alphaBlend(fragColor, pcol);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n\tfloat sum = 0.0;\n\tfor (int i=-3*SIGMA; i<=3*SIGMA; i++) {\n\t\tfloat fact = normpdf(float(i), float(SIGMA));\n\t\tcol += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(i,0), 0)*fact;\n\t\tsum += fact;\n\t}\n\tcol /= sum;\n\tfragColor = vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//////-- CONFIGURATION --//////\n\n//// BACKGROUND ////\n// #define BACKGROUND_TRANSPARENT\nconst float BACKGROUND_SPEED = 1.0;\n\n//// SHADOWS ////\n#define SHADOW_ENABLE\nconst float SHADOW_OPACITY = 0.5; // TODO: 0 to disable\nconst int   SHADOW_SIZE    = 6;\n\n//// PATTERN ////\nconst float FADE_RADIUS = 3.0;    // amount of cells before fading\nconst float TIME_SCALE  = 1.0;    // how fast it changes\nconst float TIME_OFFSET = 0.0;    // change this to start from a different pattern\nconst float SCALE       = 0.1;    // size of the whole pattern\nconst int   NB_COLORS   = 10;     // number of colors for the theme\nconst vec4 THEME[NB_COLORS] = vec4[NB_COLORS](\n\tvec4( 40,  44,  51,   0)/255.0,\n\tvec4( 40,  44,  51,   0)/255.0,\n\tvec4( 40,  44,  51,   0)/255.0,\n\tvec4(244, 107, 116, 255)/255.0,\n\tvec4(152, 195, 121, 255)/255.0,\n\tvec4(299, 192, 122, 255)/255.0,\n\tvec4( 98, 174, 239, 255)/255.0,\n\tvec4(199, 120, 221, 255)/255.0,\n\tvec4( 85, 182, 194, 255)/255.0,\n\tvec4(171, 178, 191, 255)/255.0\n);\n\n//////-- END OF CONFIGURATION --//////\n\n\n\nconst float TAU = 6.2831853071796;\nvec2 rotate(vec2 v, float a) { float c = cos(a), s = sin(a); return mat2( c, s, -s, c )*v; }\n\nvec4 alphaBlend(vec4 a, vec4 b) {\n\tvec4 c;\n\tc.a = b.a + a.a*(1.0-b.a);\n\tc.rgb = (b.rgb*b.a + a.rgb*a.a*(1.0-b.a))/c.a;\n\treturn c;\n}\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894*exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nconst int SIGMA = SHADOW_SIZE;\n\n/////////////////////////////////////////////////////////////////\n// credit: David Hoskins https://www.shadertoy.com/view/XdGfRR //\n#define UI0 1597334673U                                        //\n#define UI1 3812015801U                                        //\n#define UI2 uvec2(UI0, UI1)                                    //\n#define UI3 uvec3(UI0, UI1, 2798796415U)                       //\n#define UIF (1.0 / float(0xffffffffU))                         //\nvec2 hash21(uint q){uvec2 n=q*UI2;n=(n.x^n.y)*UI2;             //\nreturn vec2(n)*UIF;}                                           //\nvec2 hash22(vec2 p){uvec2 q=uvec2(ivec2(p))*UI2;               //\nq=(q.x^q.y)*UI2;return vec2(q)*UIF;}                           //\n/////////////////////////////////////////////////////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n\tfloat sum = 0.0;\n\tfor (int i=-3*SIGMA; i<=3*SIGMA; i++) {\n\t\tfloat fact = normpdf(float(i), float(SIGMA));\n\t\tcol += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,i), 0)*fact;\n\t\tsum += fact;\n\t}\n\tcol /= sum;\n\tfragColor = vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}