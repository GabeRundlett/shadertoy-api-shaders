{
    "Shader": {
        "info": {
            "date": "1688667099",
            "description": "Standard raymarch to a plane distorted by a Fractional Brownian Motion (FBM).\n\nI removed any polinomial component from the noise function to keep sharp edge.",
            "flags": 0,
            "hasliked": 0,
            "id": "msXBD8",
            "likes": 5,
            "name": "Plane distortion",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "Moumouke",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "float hash1(vec2 p) {\n\tp = 57.0 * fract(p * 1.4142135623);\n\treturn fract(p.x * p.y);\n}\n\nfloat noise(vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 w = fract(x);\n    vec2 s = vec2(1.,0.);\n\n\tfloat a = hash1(p + s.yy);\n\tfloat b = hash1(p + s.xy);\n\tfloat c = hash1(p + s.yx);\n\tfloat d = hash1(p + s.xx);\n\n\treturn 2.*(a + (b - a) * w.x + (c - a) * w.y + (a - b - c + d) * w.x * w.y);\n}\n\nfloat c01(float p) {\n\treturn clamp(p, 0.0, 1.0);\n}\n\nconst mat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm(vec2 x) {\n\tfloat f = 1.9;\n\tfloat s = 0.55;\n\tfloat a = 0.0;\n\tfloat b = 0.5;\n\tfor (int i = 0; i < 5; i++) {\n\t\tvec2 offset = vec2(1.0, 1.5) * float(i);\n\t\tfloat n = noise(x + offset);\n\t\ta += b * n;\n\t\tb *= s;\n\t\tx = f * m * x;\n\t}\n\treturn a;\n}\n\nfloat sdfPlane(vec3 p) {\n\tvec3 p2 = p;\n\treturn p.y + fbm(p2.xz * 0.8) * cos(iTime / 2.0);\n}\n\nfloat sdf(vec3 p) {\n\treturn sdfPlane(p + vec3(10., 2., 10.));\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(\n\t\te.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx)\n\t);\n}\n\nvec3 normal(vec3 point) {\n\tconst vec3 smallStep = vec3(0.00001, 0, 0);\n\n\treturn normalize(\n\t\tvec3(\n\t\t\tsdf(point + smallStep.xyy) - sdf(point - smallStep.xyy),\n\t\t\tsdf(point + smallStep.yxy) - sdf(point - smallStep.yxy),\n\t\t\tsdf(point + smallStep.yyx) - sdf(point - smallStep.yyx)\n\t\t)\n\t);\n}\n\nfloat raymarch(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat distance = 0.0;\n\tfloat maxDistance = 50.0;\n\tfloat minHitDistance = 0.001;\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tif (distance > maxDistance) break;\n\n\t\tvec3 pos = rayOrigin + rayDirection * distance;\n\n\t\tfloat res = sdf(pos);\n\n\t\tif (res < minHitDistance) return distance + res;\n\n\t\tdistance += res * 0.4;\n\t}\n\n\treturn -1.0;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 256; i++) {\n\t\tfloat h = sdf(ro + rd * t);\n\n\t\tif (t > tmax) return res;\n\t\tif (h < 0.001) return 0.0;\n\t\tres = min(res, 18.0 * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nvec3 directionalLight(\n\tvec3 rayDirection,\n\tvec3 normal,\n\tvec3 point,\n\tvec3 baseColor,\n\tvec3 lightDir,\n\tvec3 lightColor,\n\tfloat shininess\n) {\n\tlightDir = normalize(lightDir);\n\tvec3 hal = normalize(lightDir - rayDirection);\n\tfloat diffuse = dot(normal, lightDir);\n\tdiffuse = c01(diffuse);\n\tdiffuse *= shadow(point, lightDir, 0.02, 2.5);\n\n\tfloat pho = c01(pow(dot(normal, hal), shininess));\n\tfloat spe = pho * diffuse * 0.3;\n\n\treturn baseColor * 2.2 * diffuse * lightColor + 5.0 * spe * lightColor * 0.4;\n\n}\n\nvec3 lightning(float distance, vec3 col, vec3 point, vec3 rayDirection, vec3 rayOrigin, vec3 normal) {\n\tvec3 newColor = col;\n\n\tnewColor += directionalLight(rayDirection, normal, point, col, vec3(2.0, 2.0, 2.0), vec3(0.902, 0.902, 0.902), 32.0);\n\n    return newColor / 2.;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n\tvec3 col = vec3(0.0);\n\n\tfloat hit = raymarch(rayOrigin, rayDirection);\n\n\tif (hit > 0.0) {\n\t\tvec3 point = rayOrigin + rayDirection * hit;\n\t\tvec3 normal = calcNormal(point);\n\t\t\n        col =  vec3(0.3451, 0.3176, 0.3098);\n\t\tcol = lightning(hit, col, point, rayDirection, rayOrigin, normal);\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat camspeed = .4 * iTime;\n\tvec3 ta = vec3(0.0);\n\tvec3 ro = vec3(5.2 * cos(camspeed), 3.0, 5.2 * sin(camspeed));\n\n\tvec3 cf = normalize(-ro);\n\tvec3 cs = normalize(cross(cf, vec3(sin(0.0), cos(0.0), 0.0)));\n\tvec3 cu = normalize(cross(cs, cf));\n\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(p.x * cs + p.y * cu + 2.5 * cf);\n\n\tvec3 col = render(ro, rd);\n\tcol = pow(col, vec3(1.0 / 2.2));\n\n\tfragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}