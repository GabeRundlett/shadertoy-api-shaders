{
    "Shader": {
        "info": {
            "date": "1640651697",
            "description": "Dark and Ominous - just how I like my coffee.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlGSzw",
            "likes": 36,
            "name": "Cubic Hash Inversion",
            "published": 3,
            "tags": [
                "raymarching",
                "domain",
                "polar",
                "rep",
                "blackle"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 603
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Cubic Hash Zone | @byt3_m3chanic \n    \n    Something I've been toying around with but hate most of\n    my shaders recently... though with enough effects, \n    anything looks good. Some more attempts at hatching and \n    other ways to stylize a shader.\n    \n    Thank you @blackle @mla @Shane and @iq for help, hints,\n    and knowledge.\n    \n    suggested music for viewing \n    \n    Synaesthesia | Flotation\n    https://www.youtube.com/watch?v=4p6OhXgu9T4\n    \n*/\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    100.\n\n//keeping things deterministic\nfloat u_hash = 1.97323;\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nfloat hash31(vec3 p3){\n    p3 += u_hash; p3  = fract(p3 * .1031); p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return length(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\n\n//@blackle https://www.shadertoy.com/view/Wl3fD2\n//nonzero sign function\nfloat nonZeroSign(float x) {\n    return x < 0. ? -1. : 1.;\n}\n\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(nonZeroSign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,nonZeroSign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,nonZeroSign(p.z));\n    return vec3(0);\n}\n\nmat2 rx,ry;\nvec3 hit,hitpoint,sid,gid;\nvec3 bxs = vec3(1.9,1.9,.845),cxs = vec3(3.8,1.9,.845);\n\nvec2 map (in vec3 p) { \n    vec2 res = vec2(MAX_DIST,0.);\n    p.zy*=ry;\n    p.xz*=ry;\n    vec3 g = p;\n    \n    //@mla inversion\n    float k = 9.0/dot(p,p); \n    p *= k;\n    //@blackle https://www.shadertoy.com/view/Wl3fD2\n    vec3 center = floor(p) + .5;\n    vec3 neighbour = center + face(p - center);\n    float hs = hash31(center+fract(u_hash*3.));\n    \n    //using some hash to random the layout\n    float m = hs;\n    if(hs>.75) m = 5.;\n    if(hs>.5 && hs<.75) m = 4.;\n    if(hs>.25 && hs<.5) m = 2.;\n    if(hs<.25) m = 3.;\n\n    vec3 pos  = p - center;\n    vec3 npos = p - neighbour;\n\n    float worst = box(npos, vec3(.25))-.005;\n    float me = hs>.25? hs<.6? length(pos)-(.3): box(pos, vec3(.25))-.005 : worst;\n    float thk = .045;\n    float bm = length(pos.xz)-thk;\n    bm = min(bm,length(pos.xy)-thk);\n    bm = min(bm,length(pos.zy)-thk);\n    bm = max(bm,box(p,bxs));\n    //clip objects.\n    me = max(me,-bm);\n    if(hs>.58&&hs<.65) me = max(me,-(length(pos)-.225));\n\n    me = max(me,box(p,cxs));\n    if(me<res.x) {\n        res = vec2(me,m);\n        hit=pos;\n        gid=center;\n    }\n    if(bm<res.x) {\n        res = vec2(bm,3.);\n        hit=pos;\n        gid=center;\n    }    \n\n    float mul = 1.0/k;\n    res.x *= mul / 1.56;\n    res.x=max(res.x,-(length(g)-.05));\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n//@iq \nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// the rnd background patterns\nvec3 pattern(vec2 suv, vec3 clr) {\n    suv*=rot((PI*sin(u_hash)) );\n    suv-=T*.01;\n    float hs = fract(u_hash*4.3);\n    if(u_hash>.75){\n        vec2 f = fract(hs>.5?suv*5.:suv*15.)-.5;\n        clr = mix(clr,clr*.7,sin(f.x+f.y)>0.?1.:0.);\n    } else if(u_hash>.5){\n        vec2 f = fract(hs>.5?suv*8.:suv*4.)-.5;\n        clr = mix(clr,clr*.7,f.x*f.y>0.?1.:0.);\n    } else if(u_hash>.25){\n        vec2 f = fract(hs>.5?suv*8.:suv*4.)-.5;\n        clr = mix(clr,clr*.7,mod(floor(f.x),3.)==0.?1.:0.);\n    } else {\n        vec2 f = fract(suv*8.)-.5;\n        float d = length(f)-.25;\n        d=hs>.5?abs(abs(abs(abs(d)-.075)-.075)-.075)-.025:abs(abs(d)-.075)-.025;\n        clr = mix(clr,clr*.7,smoothstep(.01,.011,d));\n    }\n    return clr;\n}\n\n//@Shane ao\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.1325/3.75; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, .075, 1.);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, in vec2 F) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(9.*sin(T*.2),25,9.*cos(T*.2));\n\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),0.,1.);\n    float spec = pow(max(dot(reflect(l, n), rd ), .1), 12.);\n    \n    float shdw = 1.0,t=.01;\n    for( int i =1; i<19; i++ ) {\n        float h = map(p + l*t).x;\n        if( h<1e-3 ) { shdw = 0.; break; }\n        shdw = min(shdw, 28.*h/t);\n        t += h;\n        if( shdw<.1 || t>45. ) break;\n    }\n\n    diff=mix(diff,diff*shdw,.5); \n    float ao = calcAO(p,n);\n    \n    //dithering and hatching tricks.. \n    ao=smoothstep(.2,.51,ao);\n    ao=clamp(ao,.3,.9);\n    vec3 sdif = vec3(ao*diff+.15);\n    if(diff<.5&&(mod(F.x,4.)==mod(F.y,4.))) sdif=sdif*.3;\n    if(diff<.175&&(mod(1.-F.y,4.)==mod(F.x,4.))) sdif=sdif*.25;\n    if(diff<.125&&(mod(F.x,1.)==mod(F.y,2.))) sdif=sdif*.2;\n    if(diff<.100&&(mod(1.-F.x,2.)==mod(F.y,2.))) sdif=sdif*.1;\n    if(diff<.015&&(mod(F.x,1.)==mod(F.y,1.))) sdif=sdif*.3;\n\n    if(spec>.45&&(mod(F.x,4.)==mod(F.y,4.))) sdif+=.15;\n    if(spec>.65&&(mod(1.-F.x,2.)==mod(F.y,2.))) sdif+=.15;\n    \n    return sdif;//diff*vec3(1);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    u_hash+=iDate.z+floor(T*.13);\n    float thash = fract(u_hash*u_hash*2.3);\n    if(thash>.75){\n       bxs = vec3(1.9,1.9,1.9);\n       cxs = vec3(1.9,.845,3.8);\n    }else if(thash>.5){\n       bxs = vec3(1.9,1.9,.845);\n       cxs = vec3(3.8,1.9,.845);\n    }else if(thash>.25){\n       bxs = vec3(1.9,1.9,.845);\n       cxs = vec3(.845,4.9,1.9);\n    }else{\n       bxs = vec3(.845,1.9,3.8);\n       cxs = vec3(1.9,.845,3.8);\n    }\n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 duv=uv;\n    float zoom = 10.;\n\n    vec3 ro = vec3(uv*zoom,-zoom-13.25);\n    vec3 rd = vec3(0,0,1.);\n    \n    float hash  = fract(u_hash*2.27)*PI2;\n    rx = rot(-.68+hash);\n    ry = rot((T*.01)+(u_hash>.5?-(hash+.68):-(hash+.68)));\n\n    vec3  p = ro + rd * .1;\n    float atten = .95;\n    float k = 1.,o = 1.,b = 3.;\n    \n    // loop inspired/adapted from @blackle \n    // https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<150;i++)\n    {\n        vec2 ray = map(p);\n \n        vec3 n=vec3(0);\n        float fresnel=0.;\n        float d = i<32?ray.x*.825:ray.x;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-6) {\n            hitpoint=hit;\n            sid=gid;\n            o*=1e-5;\n            \n            C=mix(C,C+shade(p,rd,d,ray.y,n,F)*atten,1.);\n            if(b<1.)break;\n            b--;\n            atten *= m==3.?.45:.95;\n            p += rd*.025;\n            k = sign(map(p).x);\n          \n            if(m==3.){\n                rd=reflect(-rd,n);\n                p+=n*.01;\n                b--;\n            }else{\n                b--;\n                rd=refract(rd,n,.87);\n            }\n        }\n        if(distance(p,rd)>25.) { break; }\n    }\n    \n    float mask = smoothstep(.3,.8,length(uv)-.4);\n    float over = smoothstep(.1,.45,length(uv)-.3);\n\n    vec3 clr = mix(vec3(.5),vec3(.0) ,clamp(mask,0.,.5) );\n    clr = mix(pattern(uv,clr),vec3(.01), clamp(abs(.5+.5*cos(T*.2)),0.,1.) );\n    C = mix(C,mix(vec3(.05),vec3(.9),clr),o);\n\n    float hs = hash21(duv);\n    if(fract(hs*5.)>.65) C = clamp(C-.075,vec3(0),vec3(1));\n    \n    // Output to screen\n    C=sqrt(smoothstep(0.,1.,C));\n    O = vec4(C,1.0);\n}\n\n//end",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}