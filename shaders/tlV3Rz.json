{
    "Shader": {
        "info": {
            "date": "1578180044",
            "description": "adf",
            "flags": 32,
            "hasliked": 0,
            "id": "tlV3Rz",
            "likes": 4,
            "name": "asdfasdfgasdfgdsafa",
            "published": 3,
            "tags": [
                "asdf"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    #define tx(u) texture(iChannel0, u)\n    \n    #define pi acos(-1.)\n    #define tau (2.*pi)\n    #define taps 1\n    \n    float distToCenter = length(camera);\n    \n    //float range = pow((abs(tx(uv).z - 0.5)*0.02)*5., 2.);\n    float range = abs(tx(uv).z - distToCenter*0.02)*0.000;\n    vec3 accum = vec3(0);\n    for (int i = 0; i < taps ; i++){\n        float idx = float(i)/float(taps);\n        vec2 offs =  vec2(sin(idx*tau),cos(idx*tau))*range;\n    \taccum += tx(uv + offs ).xyz;\n    \n    }\n    \n    vec3 col = accum/float(taps);\n\n    \n    col *= 1. - pow(length(uv - 0.5)*2. - 0.5, 4.)*1.;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define focusD(d) \n\n#define iTime (iTime + 3.)\n\n  #define ZOOMFACTOR  (sin(iTime*0.4) + sin(iTime*0.5)*1.4)\n  #define ZOOM (20. + (sin(iTime) - ZOOMFACTOR*2.))\n  #define ROTSPEED 0.1\n//#define camera vec3(0. + sin(iTime*ROTSPEED)*ZOOM,0.01 + sin(ZOOMFACTOR*1.)*4. ,0. + cos(iTime*ROTSPEED)*ZOOM)\n#define camera vec3(0. + sin(iTime*ROTSPEED)*ZOOM + ZOOM,0.01 + sin(ZOOMFACTOR*1.)*4. ,20.)\n// thx inigo quilez! \nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\n#define dmin(a, b) (a.x < b.x) ? a : b\n\n#define fov 0.5\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n  vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*fov + up*uv.y*fov;\n}\n\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI acos(-1.)\n#define tau (1.*pi)\n\n#define dmin(a, b) (a.x < b.x) ? a : b // takes 2 vec2, does a minimum of them \n#define dmax(a, b) (a.x > b.x) ? a : b\n\n#define pmod(p, x) (mod(p,x) - x*0.5)\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n\n// Thx knighty and tdhooper for icosahedron!! \n// https://www.shadertoy.com/view/XlX3zB\n//\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nint Type=4;\n\nvec3 nc,pab,pbc,pca;\nvec3 icoF0;\nvec3 icoF1a;\nvec3 icoA0;\nvec3 icoB0;\nvec3 icoC0;\nvec3 icoA1;\nvec3 icoB1;\nvec3 icoC1;\nvec3 fold1;\nvec3 fold2;\nvec3 fold3;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n    vec3 A = pbc;\n    vec3 C = reflect(A, normalize(cross(pab, pca)));\n    vec3 B = reflect(C, normalize(cross(pbc, pca)));\n    \n    icoF0 = pca;\n    \n\ticoA0 = A;\n\ticoC0 = B;\n\ticoB0 = C;\n\n    vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n    vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n    fold1 = normalize(cross(p1, p2));\n    \n    // Get corners of triangle created by fold\n    vec3 A2 = reflect(A, fold1);\n    vec3 B2 = p1;\n    vec3 C2 = p2;\n    \n    icoF1a = pca;\n    \n    icoA1 = A2;\n    icoB1 = normalize(B2);\n    icoC1 = normalize(C2);\n    \n    p1 = bToC(A2, B2, C2, vec3(.5, .0, .5));\n    p2 = bToC(A2, B2, C2, vec3(.5, .5, .0));\n    fold2 = normalize(cross(p1, p2));\n    \n\tp1 = bToC(A2, B2, C2, vec3(.0, .5, .5));\n    fold3 = normalize(cross(p2, p1));\n}\n\n\n\nfloat pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    float i = 0.;\n    \n    if (subdivisions > 0) {\n\n        // Fold in corner A \n        i += pReflect(p, fold1, 0.) / 2. + .5;\n        \n        if (subdivisions > 1) {\n            \n            // Fold in corner A\n            pReflect(p, fold2, 0.);\n            \n            // Fold in corner B\n            pReflect(p, fold3, 0.);\n        }\n    }\n\n    return i;\n}\n  \n  \n#define modMult 1.2 \n\n\n// thx Luna for dividing space thingie\n\nvec2 map(vec3 p) {\n    float distBetweenZ = 6.7;\n    float zId = floor(p.z/distBetweenZ);\n    p.z = pmod(p.z, distBetweenZ);\n    \n    \n    p.xy *= rot( (sin(iTime) - iTime*sin(zId*521424.2524) ) * 0.5);\n    for (int i = 0; i < 4; i++){\n        p = abs(p);\n    \tp.xy *= rot(0.4 + sin(zId*0.2)*0.1);\n        \n        //p.xz *= rot(0.05);\n        p -= 0.9;\n        p.x -= float(i)*0.7 + sin(zId*0.1);\n    }\n        p.y -= 2.4;\n    \n    \n  p.y *= 0.8 + sin(ZOOMFACTOR + 2.)*0.1;\n  vec2 d = vec2(10e9);\n    \n  vec3 z = p;\n  \n  z.y *= modMult;\n  \n  float floorId = floor(z.y);\n    \n    \n    \n  vec3 q = p;\n    \n \n  z.y = pmod(z.y, 1.);\n    \n    \n  //p.xz *= rot(fract(sin(floorId)*124314.124 )* iTime*sign(sin(floorId*5214242.4412))*0.4);\n  \n  float i = pModIcosahedron(p, 1);\n  p -= 4.;\n    \n  \n  float dObject = p.z + 0.5;\n  \n  \n  float dFloor =  abs(z.y) - 0.01 ;\n  \n  floorId = mod(floorId + zId, 3.);\n  if (floorId == 0.) {\n    dFloor -= length(sin(p*vec3(1,1,2.7)))*0.1;\n    dFloor = max(dFloor, -sin(p.x*4. + p.y*2.));\n  }\n  if (floorId == 1.) {\n    //dFloor -= length(sin(p*vec3(1,1,2.7)))*0.1;\n    dFloor = opSmoothIntersection(dFloor - 0.1, sin(p.z*5. + p.x*4.),0.5);\n  }\n     if (floorId == 2.) {\n    //dFloor -= length(sin(p*vec3(1,1,2.7)))*0.1;\n  } \n  \n  \n  d = dmin(d,vec2(max(dObject,dFloor), floorId));\n  \n    \n   i = pModIcosahedron(q, 2);\n  \n    q -= 20.3;\n  \n    //d = dmin(d,vec2(abs(q.z - 9.) - 0.1, 1.));\n    \n    \n  d.x *= 0.25; \n  \n  \n  \n  return d;\n  \n}\n\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.001, 0.);\n  return normalize(map(p).x - vec3(\n    map(p - t.xyy).x,\n    map(p - t.yxy).x,\n    map(p - t.yyx).x\n  ));\n}\n\n\n\nvec3 glow = vec3(0);\n\n#define spectra(x,t) (0.5 + 0.6*sin(vec3(0.8,0.4,0.9)*t + x)) \n\n\n// ------- Main ------- //\nvec4 render(vec2 uv) {\n  vec3 col = vec3 (0);\n\n  initIcosahedron();\n  \n    \n  vec3 ro = camera;\n    \n  vec3 lookAt = vec3(0.001,0. + sin(iTime)*0.2,-20.  + iTime);\n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  vec3 p = ro; float t = 0., tBeforeRefraction = 0.;\n  \n  \n  float side = 1.;\n  \n  bool refracted = false;\n  bool didHit = false;\n    \n  vec3 attenuation = vec3(1);\n  \n  #define ITERS 300\n  for (int i = 0; i <= ITERS; i++) {\n    vec2 d = map(p);\n    d.x = d.x * side;\n    glow += spectra(d.x - 8. + p.z*0.25 - sin(iTime), 18.)*0.1;\n    if(d.x < 0.001) {\n    \n      vec3 n = getNormal(p) * side;\n      \n      //vec3 l = normalize(vec3(sin(iTime*0.28),sin(iTime*0.6), cos(iTime*0.25)))*25.21;;\n      vec3 l = normalize(vec3(1,1,-1))*25.21;\n      vec3 lDir = normalize(l - p);\n      vec3 lDirB = normalize(vec3(1));\n      \n      vec3 l1Col = vec3(0.98,0.02,0.68);\n      vec3 l2Col = vec3(0.1,0.2,0.95);\n      //vec3 lDir = normalize(vec3(1));\n      vec3 h = normalize(lDir - rd);\n      vec3 hB = normalize(lDirB - rd);\n      \n      float lightAttenuation= 1./(length(p - l)*length(p - l));\n      float lBAttenuation = 0.02;\n      \n      float diff = max(dot(lDir,n), 0.);\n      float fres = pow(1. - abs(dot(n, -rd)), 9.);\n      float spec = pow(max(dot(h, n), 0.), 1.);\n        \n      float diffB = max(dot(lDirB,n), 0.);\n      float fresB = pow(max(dot(n, -rd), 0.), 4.);\n      float specB = pow(max(dot(hB, n), 0.), 1.);\n      \n      //col += 1.;\n          if (!didHit){\n          \ttBeforeRefraction = t;\n          }      \n      \n      if (d.y == 1.) { // refract\n        vec3 surfaceCol = vec3(0.9,0.9,1);\n        refracted = true;\n        side = -side;\n        ro = p;\n        rd = refract(rd, n, 1. + rd.y*0.02 + length(sin(p.xz))*0.001);\n        t = 0.;\n        d.x = 0.2;\n        const float shininess = 0.9;\n        col += mix(vec3(diff)*l1Col*surfaceCol,vec3(fres * spec*l1Col), shininess)*attenuation;\n        col += mix(vec3(diffB)*l2Col*surfaceCol,vec3(fresB * specB*l2Col), shininess)*lBAttenuation;\n        \n        col = clamp(col, 0., 1.);\n        //col += glow*0.001;\n        attenuation *= 0.9;\n\n        \n      } else if (d.y == 0.) { // diffuse\n        vec3 albedo = vec3(.1,.9,0.9);\n      \t\ttBeforeRefraction = t;\n        col += mix(vec3(diff*albedo)*l1Col,vec3(pow(fres, 10.) * spec*l1Col), 0.9)*attenuation;\n        col += mix(vec3(diffB)*l2Col,vec3(pow(fresB, 10.) * specB*l2Col), 0.3)*lBAttenuation;\n        rd = refract(rd, n, 1. + rd.y*0.2);\n        break; \n      } else if (d.y == 2.) { //reflect\n        refracted = true;\n        col += mix(vec3(diff)*l1Col,vec3(fres* spec*l1Col), 0.8)*attenuation;\n        col += mix(vec3(diffB)*l2Col,vec3(fresB* specB*l2Col), 0.8)*lBAttenuation;\n        rd = reflect(rd, n  + sin(n.y*0.1 + p.x*0.1)*0.05);\n        ro = p;\n        t = 0.;\n        d.x = 0.1;\n        attenuation *= vec3(0.8,0.7,0.9)*0.1;\n        \n      }\n      \n      attenuation *= lightAttenuation;\n      didHit = true;\n      \n      }\n    if(t > 100. || i == ITERS ) {\n        if (!didHit) {\n      \t\ttBeforeRefraction = t;\n        }\n      break;\n    }\n      \n    t += d.x;\n    p = ro + rd*t;\n  }\n  col += glow*0.003*vec3(0.3,0.,0.2);\n  col *= 2.;\n  col *= vec3(1.17,1.1,1);\n\n    col = max(col, vec3(0.));\n\n  col = pow(col, vec3(0.45));\n\n  //col = mix(col, vec3(0)*0., clamp(vec3(pow(0.1 + tBeforeRefraction*0.01,1.5)*1.4),vec3(0.),vec3(1.)));      \n    \n  col = clamp(col, 0. ,1.);\n  return vec4(col, t);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}