{
    "Shader": {
        "info": {
            "date": "1511745104",
            "description": "An arbitrary linear transformation of the plane—including shearing or nonuniform scaling—maps a circle to an ellipse in general.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlXfDH",
            "likes": 21,
            "name": "Linear map: circle to ellipse",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "math",
                "diagram"
            ],
            "usePreview": 0,
            "username": "Reedbeta",
            "viewed": 9160
        },
        "renderpass": [
            {
                "code": "vec2 rotate(vec2 v, float angle)\n{\n    float cosA = cos(angle), sinA = sin(angle);\n    return v.x * vec2(cosA, sinA) + v.y * vec2(-sinA, cosA);\n}\n\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderCircle(vec2 center, float radius, vec2 pos, inout vec3 fragColor)\n{\n    float dist = length(pos - center) - radius;\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.005, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.375 - 6.0 * 0.0075;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.0 - vec2((1.0*aspect)/2.0, 1.0/2.0);\n\n    // animate the grid a bit with rotation, shear, and nonuniform scale\n    pos *= vec2(sin(iTime*0.72) * 0.5 + 1.0, 1.0);\n    pos = rotate(pos, cos(iTime) * 0.1);\n    pos.x += pos.y * sin(iTime*0.89) * 0.5;\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n    renderCircle(vec2(0), 0.375, pos, fragColor.rgb);\n    renderAxes(vec2(0), pos, fragColor.rgb);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}