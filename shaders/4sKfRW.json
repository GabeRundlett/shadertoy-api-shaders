{
    "Shader": {
        "info": {
            "date": "1527789172",
            "description": "Worley noise with fbm warping",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKfRW",
            "likes": 5,
            "name": "Warped Worley",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "fbm",
                "worley"
            ],
            "usePreview": 0,
            "username": "wizgrav",
            "viewed": 518
        },
        "renderpass": [
            {
                "code": "// worley noise from glslify\n\nvec3 permute(vec3 x) {\n    return mod((34.0 * x + 1.0) * x, 289.0);\n  }\n\nvec3 dist(vec3 x, vec3 y,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) :  (x * x + y * y);\n}\n\n  vec2 worley(vec2 P, float jitter, bool manhattanDistance) {\n  float K= 0.142857142857; // 1/7\n  float Ko= 0.428571428571 ;// 3/7\n  \tvec2 Pi = mod(floor(P), 289.0);\n   \tvec2 Pf = fract(P);\n  \tvec3 oi = vec3(-1.0, 0.0, 1.0);\n  \tvec3 of = vec3(-0.5, 0.5, 1.5);\n  \tvec3 px = permute(Pi.x + oi);\n  \tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n  \tvec3 ox = fract(p*K) - Ko;\n  \tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n  \tvec3 dx = Pf.x + 0.5 + jitter*ox;\n  \tvec3 dy = Pf.y - of + jitter*oy;\n  \tvec3 d1 = dist(dx,dy, manhattanDistance); // d11, d12 and d13, squared\n  \tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n  \tox = fract(p*K) - Ko;\n  \toy = mod(floor(p*K),7.0)*K - Ko;\n  \tdx = Pf.x - 0.5 + jitter*ox;\n  \tdy = Pf.y - of + jitter*oy;\n  \tvec3 d2 = dist(dx,dy, manhattanDistance); // d21, d22 and d23, squared\n  \tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n  \tox = fract(p*K) - Ko;\n  \toy = mod(floor(p*K),7.0)*K - Ko;\n  \tdx = Pf.x - 1.5 + jitter*ox;\n  \tdy = Pf.y - of + jitter*oy;\n  \tvec3 d3 = dist(dx,dy, manhattanDistance); // d31, d32 and d33, squared\n  \t// Sort out the two smallest distances (F1, F2)\n  \tvec3 d1a = min(d1, d2);\n  \td2 = max(d1, d2); // Swap to keep candidates for F2\n  \td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n  \td1 = min(d1a, d2); // F1 is now in d1\n  \td2 = max(d1a, d2); // Swap to keep candidates for F2\n  \td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n  \td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n  \td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n  \td1.y = min(d1.y, d1.z); // nor in  d1.z\n  \td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n  \treturn sqrt(d1.xy);\n  }\n\n// HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\nvec3 hsv2rgb( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 1.;\n    float freq = 8.;\n    float asum = 0.;\n    float res = 0.;\n    for(int i=0; i < 3; i++) {\n        res += worley(uv * freq , 1., false).x * amp;\n        asum += amp;\n        freq *= 2.;\n        amp *= 0.5;\n    }\n    return res / asum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y += iTime * 0.033;\n    float q = fbm(uv);\n\tfloat c = fbm(uv  + iTime* vec2(0.033, 0.066) + q );\n    \n    vec3 col = hsv2rgb(vec3(q,q * c,c));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}