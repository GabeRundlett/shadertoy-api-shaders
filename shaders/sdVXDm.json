{
    "Shader": {
        "info": {
            "date": "1634781872",
            "description": "yuh",
            "flags": 0,
            "hasliked": 0,
            "id": "sdVXDm",
            "likes": 3,
            "name": "newton fractal gaurav",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "gauravity",
            "viewed": 251
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926538\n\nvec2 mult(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x * b.y + a.y * b.x);\n}\n//https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\nfloat atan2(in float y, in float x)\n{\n    float s = (abs(x) > abs(y))?1.:0.;\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec2 powc(vec2 x, float n) {\n     float ang = atan2(x.y, x.x);\n     float modulus = length(x);\n     float newAng = n * ang;\n     float newMod = pow(modulus, n);\n     return newMod*vec2(cos(newAng), sin(newAng));\n     \n}\n\n\nvec2 conj(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nfloat mod2(vec2 a)\n{\n    return a.x*a.x + a.y*a.y;\n}\n\nvec2 inv(vec2 x) {\n    return conj(x) / mod2(x);\n}\nvec2 f(vec2 x) {\n    return vec2(-1, 0) + powc(x, 3.);\n}\n\nvec2 fp(vec2 x) {\n  \n     return 3.0*powc(x, 2.); //+ 2.0*x + vec2(1.0, 0);\n}\n\nvec2 newt(vec2 x) {\n     return x - mult(f(x), inv(fp(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.x;\n    vec2 xy = uv*2.0 -vec2(1.0, iResolution.y/iResolution.x);\n    vec2 x = mult(xy*16.0 / pow(iTime, 2.), vec2(cos(iTime), sin(iTime)));\n    \n    vec3 col = vec3(152.,125.,124.)/255.;\n    for (int i =0; i < 100; i++){\n       float qTime = mod(iTime, 10.0);\n       if (qTime > 5.0) {\n       qTime = 10.0-qTime;\n       }\n       if (float(i) >= qTime*24.0) {\n           break;\n        }\n        x =newt(x);\n     \n    }\n    vec2 unity = vec2(cos(2.*PI/3.), sin(2.*PI/3.));\n    vec2 u2 = powc(unity, 2.);\n    vec2 o = vec2(1., 0.);\n    \n    float di = mod2(x - unity);\n    float dni = mod2(x - u2);\n    float dn1 = mod2(x - o);\n    if (dni < di && dni < dn1) {\n       col = vec3(160., 156., 176.)/255.;\n    }\n    else if (di < dn1) {\n       col = vec3(255.,193.,69.)/255.;\n    }\n\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}