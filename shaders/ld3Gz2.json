{
    "Shader": {
        "info": {
            "date": "1450918438",
            "description": "Procedural modeling and procedural lighting. Shading is a mix of procedural and textures. SDF rendered through raymarching. Info: [url]https://iquilezles.org/articles/raymarchingdf/[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ld3Gz2",
            "likes": 927,
            "name": "Snail",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield",
                "sdf",
                "snail"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 220156
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// You can buy a metal print of this shader here:\n// https://www.redbubble.com/i/metal-print/Snail-by-InigoQuilez/39845499.0JXQP\n\n\n// antialiasing - make AA 2, meaning 4x AA, if you have a fast machine\n#define AA 1\n\n#define USE_TEXTURES 1\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n#if 1\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n#else\n    float k0 = length((p-c)/r);\n    float k1 = length((p-c)/(r*r));\n    return k0*(k0-1.0)/k1;\n#endif    \n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nvec2 udSegment( vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    vec3 h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//---------------------------------------------------------------------------\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 forwardSF( float i, float n ) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//---------------------------------------------------------------------------\n\nconst float pi = 3.1415927;\n\n//---------------------------------------------------------------------------\n\nfloat mapShell( in vec3 p, out vec4 matInfo ) \n{\n    p -= vec3(0.05,0.12,-0.09);    \n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    float np = (log(   r)/b-t)/(2.0*pi);\n    float nm = (log(0.11)/b-t)/(2.0*pi);\n    float n = min(np,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + 2.0*pi*ni));\n    float r2 = r1 * 3.019863;\n    \n    //-------\n\n    float h1 = q.z + 1.5*r1 - 0.5; float d1 = sqrt((r1-r)*(r1-r)+h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5; float d2 = sqrt((r2-r)*(r2-r)+h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n\n    float di = textureLod( iChannel2, vec2(t+r,0.5), 0. ).x;\n    d += 0.002*di;\n    \n    matInfo = vec4(dx,dy,r/0.4,t/pi);\n\n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d;\n}\n\n#if USE_TEXTURES==0\nfloat voronoi( in vec2 x, float w, float s )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec2 m = vec2( 8.0, 0.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i),float(j) );\n        vec3  r = hash3( n + g );\n\t\tfloat d = length(g - f + r.xy);\n        float c = s*(0.1+0.9*r.z);\n        d = min(d*1.25,1.0);\n        // do the smooth min for distances and color\n\t\tfloat h = smoothstep( -1.0, 1.0, (m.x-d)/w );\n\t    m = mix( m, vec2(d,c), h ) - h*(1.0-h)*w/(1.0+3.0*w);\n    }\n    \n\treturn m.y*(1.0-m.x);\n}\n#endif\n\nfloat text1( in vec2 p )\n{\n    #if USE_TEXTURES==1\n        return textureLod( iChannel1, p, 0.0 ).x;\n    #else\n        float f = max( voronoi(  7.5*p, 0.3, 1.00 ),\n                       voronoi( 13.0*p, 0.3, 0.75 ) );\n        return 0.5*smoothstep(0.0,1.0,f);\n    #endif\n}\n\nvec2 mapSnail( vec3 p, out vec4 matInfo )\n{\n    const vec3 head = vec3(-0.76,0.6,-0.3);\n    \n    vec3 q = p - head;\n\n    // body\n    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.1,0.0), head+vec3(0.04,0.01,0.0), p );\n    float d1 = b1.x;\n    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));\n    b1 = sdBezier( vec3(-0.085,0.0,0.0), vec3(-0.1,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );\n    float d2 = b1.x;\n    d2 -= 0.1 - 0.06*b1.y;\n    d1 = smin( d1, d2, 0.03 );\n    matInfo.xyz = b1.yzw;\n\n    d2 = sdSphere( q, vec4(0.0,-0.06,0.0,0.085) );\n    d1 = smin( d1, d2, 0.03 );\n    d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );\n    \n    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;\n\n    vec3 sq = vec3( q.xy, abs(q.z) );\n    \n    // top antenas\n    vec3 af = 0.05*sin(0.5*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );\n    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );\n    float d3 = b2.x;\n    d3 -= 0.03 - 0.025*b2.y;\n    d1 = smin( d1, d3, 0.04 );\n    d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.016) + vec4(af,0.0) );\n    d1 = smin( d1, d3, 0.01 );    \n    \n    // bottom antenas\n    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );\n    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.2,0.18)+bf );\n    d3 = b3.x;\n    d3 -= 0.025 - 0.02*b3.y;\n    d1 = smin( d1, d3, 0.06 );\n    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );\n    d1 = smin( d1, d3, 0.02 );\n    \n    // bottom\n    vec3 pp = p-vec3(-0.17,0.15,0.0);\n    float co = 0.988771078;\n    float si = 0.149438132;\n    pp.xy = mat2(co,-si,si,co)*pp.xy;\n    d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );\n    d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );\n    \n    // disp\n    float dis = text1(5.0*p.xy);\n    float dx = 0.5 + 0.5*(1.0-smoothstep(0.5,1.0,b1.y));\n    d1 -= 0.005*dis*dx*0.5;\n        \n    return vec2(d1,1.0);\n}\n    \nfloat mapDrop( in vec3 p )\n{\n    p -= vec3(-0.26,0.25,-0.02);\n    p.x -= 2.5*p.y*p.y;\n    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );\n}\n\nfloat mapLeaf( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    \n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n \n    p.y += 0.2*exp2(-abs(2.9*p.z) );\n    \n    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);\n    float rr = sin( ph );\n    rr = rr*rr;    \n    rr = rr*rr;    \n    p.y += 0.005*rr;\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;\n    \n    rr = sin( ph*2.0 );\n    rr = rr*rr;    \n    rr *= 0.5+0.5*sin( p.x*12.0 );\n\n    float ri = 0.035*rr;\n    \n    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );\n\n    float d2 = p.y-0.02;\n    \n    return smax( d, -d2, 0.02 );\n}\n\nvec2 mapOpaque( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    // leaf    \n    vec2 res = vec2( mapLeaf( p ), 4.0);\n    \n    // stem\n    vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );\n    float d3 = b3.x - 0.04 + 0.02*b3.y;\n    if( d3<res.x ) res = vec2(d3,3.0);\n    \n   \t// snail \n    float boundingVolume = sdCapsule(p, vec3(0.0), vec3(-0.6,0.7,0.0), 0.55);\n    if( boundingVolume<res.x )\n    {\n    vec2 tmp = mapSnail( p, matInfo );\n    if( tmp.x<res.x  ) { res = tmp; }\n    \n    // shell\n    float bb = length( p-vec3(0.25,0.3,-0.1) )-0.6;\n    if( bb<res.x )\n    {\n    vec4 tmpMatInfo;\n    float d4 = mapShell( p, tmpMatInfo );    \n    if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }\n    }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormalOpaque( in vec3 pos, in float eps )\n{\n    vec4 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapOpaque( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapOpaque( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapOpaque( pos + e.xxx, kk ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapOpaque(pos+eps*e,kk).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n//=========================================================================\n\nfloat mapLeafWaterDrops( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    vec3 s = p;\n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n  \n    vec3 q = p;\n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = r*(1.0-r)*(1.0-r)*6.0;\n    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );\n    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );\n    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );\n    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );\n\n    d3 = max( d3, p.y-0.01);\n    \n    return min( min(d1,d4), min(d2,d3) );\n}\n\nvec2 mapTransparent( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    float d5 = mapDrop( p );\n    vec2  res = vec2(d5,4.0);\n\n    float d6 = mapLeafWaterDrops( p );\n    res.x = min( res.x, d6 );\n\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormalTransparent( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapTransparent( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapTransparent( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapTransparent( pos + e.xxx, kk ).x );\n}\n\n//=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash1(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.1;\n        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\nfloat calcSSS( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.002 + 0.11*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        occ += (h-mapOpaque(pos-h*dir, kk).x);\n    }\n    occ = clamp( 1.0 - 11.0*occ/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec4 kk;    \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = mapOpaque(ro + rd*t, kk ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nconst vec3 sunDir = normalize( vec3(0.2,0.1,0.02) );\n\nvec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )\n{\n    float eps = 0.002;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalOpaque( pos, eps );\n\n    vec3 mateD = vec3(0.0);\n    vec3 mateS = vec3(0.0);\n    vec2 mateK = vec2(0.0);\n    vec3 mateE = vec3(0.0);\n\n    float focc = 1.0;\n    float fsha = 1.0;\n\n    if( m<1.5 ) // snail body\n    {\n        float dis = text1( 5.0*pos.xy );\n\n        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );\n        be = 1.0-smoothstep( -0.01, 0.01, be );        \n        \n        float ff = abs(matInfo.x-0.20);\n        \n        mateS = 6.0*mix( 0.7*vec3(2.0,1.2,0.2), vec3(2.5,1.8,0.9), ff );\n        mateS += 2.0*dis;\n        mateS *= 1.5;\n        mateS *= 1.0 + 0.5*ff*ff;\n        mateS *= 1.0-0.5*be;\n        \n        mateD = vec3(1.0,0.8,0.4);\n        mateD *= dis;\n        mateD *= 0.015;\n        mateD += vec3(0.8,0.4,0.3)*0.15*be;\n        \n        mateK = vec2( 60.0, 0.7 + 2.0*dis );\n        \n        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );\n        f = 1.0-pow( f, 8.0 );\n        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);\n        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);\n        \n        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));\n        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );\n    }\n\telse if( m<2.5 ) // shell\n    {\n        mateK = vec2(0.0);\n        \n        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );\n        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );\n        \n        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );\n        \n        float ff = 2.0*matInfo.w+matInfo.z;        \n        float ral = 0.4 + 0.4*(0.26*sin(ff*6.283185* 1.0+0.0)+\n                               0.23*sin(ff*6.283185* 3.0+2.0)+\n                               0.20*sin(ff*6.283185* 8.0+1.0)+\n                               0.17*sin(ff*6.283185*17.0+3.0)+\n                               0.14*sin(ff*6.283185*25.0+2.0));\n        mateD *= 0.25 + 0.75*ral;\n        \n        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );\n        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));\n        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );\n        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;\n\n        mateK = vec2( 64.0, 0.2 );\n        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;\n    }\n    else if( m<3.5 ) // plant\n    {\n        mateD = vec3(0.05,0.1,0.0)*0.2;\n        mateS = vec3(0.1,0.2,0.02)*25.0;\n        mateK = vec2(5.0,1.0);\n        \n        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n        mateD += 0.2*fre*vec3(1.0,0.5,0.1);\n        \n        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;\n        mateS *= 0.5 + 1.5*te;\n        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);\n    }\n    else //if( m<4.5 ) // leaf\n    {\n        vec3 p = pos - vec3(-1.8,0.6,-0.75);\n        vec3 s = p;\n        p = mat3(0.671212, 0.366685, -0.644218,\n                -0.479426, 0.877583,  0.000000,\n                 0.565354, 0.308854,  0.764842)*p;\n\n        vec3 q = p;\n        p.y += 0.2*exp(-abs(2.0*p.z) );\n\n        float v = smoothstep( 0.01, 0.02, abs(p.z));\n        \n        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );\n\n        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;\n\n        float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n        r = r*(1.0-r)*(1.0-r)*6.0;\n        float ff = length(p.xz/vec2(2.0,r));\n\n        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );\n        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );\n        mateD *= 1.0 + 0.25*te;\n        mateD *= 0.8;\n        \n        mateS = vec3(0.15,0.2,0.02)*0.8;\n        mateS *= 1.0 + 0.2*rr;\n        mateS *= 0.8;\n\n        mateK = vec2(64.0,0.25);\n        \n        //---------------------\n        \n        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);\n        nor = normalize( nor );\n\n        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );\n        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );\n        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );\n        float dd = min(d1,min(d2,d4));\n        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);\n        \n        d1 = abs( sdCircle( q.xz, vec2( 0.5, 0.20), 1.0*0.15 ));\n        d2 = abs( sdCircle( q.xz, vec2( 0.8,-0.15), 0.5*0.15 ));\n        d4 = abs( sdCircle( q.xz, vec2(-0.5,-0.20), 1.0*0.04 ));\n        dd = min(d1,min(d2,d4));\n        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);\n        \n        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );\n        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );\n        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;\n        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    \n    }\n  \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n    float sss = calcSSS( pos, nor );\n    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;\n    \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    dif1 *= fsha;\n    float sha = 1.0; if( dif1>0.0001 ) sha=calcSoftShadow( pos, sunDir, 20.0 ); \n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    // illumination\n    vec3 col = vec3(0.0);\n    col += 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;               // sun\n    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);    // sky\n    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;                // bounce\n\n    col *= mateD;\n\n    col += 0.4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS; // sss\n    col = pow(col,vec3(0.6,0.8,1.0));\n    \n    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;   // sun lobe1\n    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y; // sun lobe2\n\tcol += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0)); // sky\n\n    col += mateE;\n\n    return col;        \n}\n\nvec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )\n{\n    vec3 oriCol = col;\n    \n    float dz = depth - t;\n    float ao = clamp(dz*50.0,0.0,1.0);\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormalTransparent( pos, 0.002 );\n    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    vec3  ref = reflect( -rd, nor );\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );\n\n    float ds = 1.6 - col.y;\n    \n    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );\n\n    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );\n    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);\n    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    \n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );\n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );\n    #if USE_TEXTURES==1\n    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,text1( 0.8*nor.xy ))*(0.1+0.9*fre*fre);\n    #else\n    col += vec3(0.8,1.0,0.8)*0.65*smoothstep(0.3,0.6,text1( 0.7*nor.xy ))*(0.1+0.9*fre*fre);\n    #endif\n    \n    // hide aliasing a bit\n    return mix( col, oriCol, smoothstep(0.6,1.0,fre) ); \n}\n\n//--------------------------------------------\n\nvec2 intersectOpaque( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapOpaque( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x*0.9;\n    }\n\treturn res;\n}\n\nvec2 intersectTransparent( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTransparent( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x;\n    }\n\treturn res;\n}\n\nvec3 background( in vec3 d )\n{\n    // cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                                     d.xy/d.z;\n    // fancy blur\n    vec3  col = vec3( 0.0 );\n    for( int i=ZERO; i<200; i++ )\n    {\n        float h = float(i)/200.0;\n        float an = 31.0*6.2831*h;\n        vec2  of = vec2( cos(an), sin(an) ) * h;\n\n        vec3 tmp = texture( iChannel2, uv*0.25 + 0.0075*of, 4.0 ).yxz;\n        col = smax( col, tmp, 0.5 );\n    }\n    \n    return pow(col,vec3(3.5,3.0,6.0))*0.2;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 q )\n{\n    //-----------------------------\n\n    vec3 col = background( rd );\n    \n    //-----------------------------\n    \n    float mindist = 1.0;\n    float maxdist = 4.0;\n\n    vec4 matInfo;\n    vec2 tm = intersectOpaque( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeOpaque( ro, rd, tm.x, tm.y, matInfo );\n        maxdist = tm.x;\n    }\n\n    //-----------------------------\n    \n    tm = intersectTransparent( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeTransparent( ro, rd, tm.x, tm.y, matInfo, col, maxdist );\n    }\n\n    //-----------------------------\n    \n    float sun = clamp(dot(rd,sunDir),0.0,1.0);\n    col += 1.0*vec3(1.5,0.8,0.7)*pow(sun,4.0);\n\n    //-----------------------------\n\n    col = pow( col, vec3(0.45) );\n    \n    col = vec3(1.05,1.0,1.0)*col*(0.7+0.3*col*max(3.0-2.0*col,0.0)) + vec3(0.0,0.0,0.04);\n\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    return clamp( col, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt )\n{\n    vec3 w = normalize(ro-rt);\n    float m = sqrt(1.0-w.y*w.y);\n    return mat3( w.z,     0.0, -w.x, \n                 0.0,     m*m, -w.z*w.y,\n                 w.x*m, w.y*m,  w.z*m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    #if AA<2\n        vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        vec2  q = fragCoord/iResolution.xy;\n        float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n        vec3  ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n        vec3  ta = vec3(-0.6,0.2,0.0);\n        mat3  ca = setCamera( ro, ta );\n        vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n        vec3 col = render( ro, rd, q );\n    #else\n        vec3 col = vec3(0.0);\n        for( int m=ZERO; m<AA; m++ )\n        for( int n=ZERO; n<AA; n++ )\n        {\n            vec2 rr = vec2(float(m),float(n))/float(AA);\n\n            vec2 p = (2.0*(fragCoord+rr)-iResolution.xy)/iResolution.y;\n            float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n            vec2 q = (fragCoord+rr)/iResolution.xy;\n\n            vec3 ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n            vec3 ta = vec3(-0.6,0.2,0.0);\n            mat3 ca = setCamera( ro, ta );\n            vec3 rd = normalize( ca * vec3(p,-2.8) );\n\n\t\t    col += render( ro, rd, q );\n        }    \n        col /= float(AA*AA);\n    #endif\n\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}