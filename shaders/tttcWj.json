{
    "Shader": {
        "info": {
            "date": "1609971564",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "tttcWj",
            "likes": 13,
            "name": "Day 386",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 385\" by jeyko. https://shadertoy.com/view/wl3yWj\n// 2021-01-06 11:49:58\n\n// shadows and smoothops from iq\n\n// FXAA from mudlord?\n\n// cyclic noise from nimitz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    col = pow(col,vec3(1.5,.951,0.99 + dot(uv,uv)*0.0));\n    \n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(2.4,0.8,1.24)*1.7),0.4);\n    \n    col *= 1.3;\n    col = 1. - exp(-col*2.);\n    //col = mix(acesFilm(col), col, 0.2);\n    \n    col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec2 dmin(vec2 d, float db, float dbid){return d.x < db ? d : vec2(db,dbid);}\nvec2 dmin(vec2 d, vec2 b){return d.x < b.x ? d : b;}\n\nfloat wallNoise = 0.;\nfloat wallNoiseB = 0.;\n\nfloat T = 0.;\nfloat tid = 0.;\n\n\n\nvec3 uvJello = vec3(0);\n\n\nvec2 sdWall(vec3 p){\n    p.x -= T*1.;\n\n    p.xy *= rot(0.55);\n    \n    vec3 op = p;    \n    vec2 d = vec2(abs(-p.z + 7.) + 0.02, ID_WALL_A);\n    \n    \n    d.x -= (wallNoise = cyclicNoise(vec3(p.xy,0.1)*15.))*0.05;\n    \n    p.y = pmod(p.y,1.5);\n    \n    p.x = pmod(p.x,2.);\n    \n    p.x = abs(p.x);\n    \n    p.xy *= rot(0.425);\n    \n    d.x = opSmoothSubtraction( -d.x, abs(p.y) - 0.2, 0.05 );\n\n    \n    \n    \n    p = op;\n    \n    \n    vec2 dWallB = vec2(-p.z + 7.1, ID_WALL_B);\n    \n    dWallB.x -= (wallNoiseB = cyclicNoiseB(vec3(p.x,p.y*0.5,0.1)*15.))*0.05;\n    \n    \n    d = dmin(d,dWallB);\n    //d = dWallB;\n    \n    \n    \n    //d.x += smoothstep(0.15,0.,length(p.xy) - 0.05)*0.02;\n\n    return d;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec2 sdSticks(vec3 psticks, float repd){\n\n    vec2 id = floor(psticks.xz/repd);\n    psticks.xz = pmod(psticks.xz,repd);\n\n    psticks.x*= 2.5;\n    psticks.z*=1.5;\n    \n    psticks.xy *= rot(-0.5*pi);\n    psticks.yz *= rot(.5*pi);\n    \n    psticks.xy *= rot(2.5*pi*sin(id.x));\n    psticks.yz *= rot(.25*pi*sin(id.x));\n    \n    \n    float dsticks = sdVerticalCapsule( psticks, 0.08, 0.05 );\n        \n    //dsticks = length(psticks) - 0.04;\n    return vec2(dsticks,ID_STICKS);\n}\n\nvec2 sdJelloTube(vec3 p){\n    p.x += 3.5;\n    //p.zy *= rot( -T + p.x*(4.-smoothstep(1.,0.,p.x - 0.)*0.4));\n    \n    //#define jellorot(b,a) ((b)*(4.-smoothstep(1.,0.,b - 0.)*0.4) + a)\n    \n    vec3 op = p;\n    \n    p.yz *= rot(((p.x)*(3. - smoothstep(1.,0.,p.x)*2.  - smoothstep(0.,1.,p.x )*1.5)) - T*(2.) );\n    \n    op.yz *= rot( (0. -  T*4. + op.x*0.65));//*(4.-smoothstep(1.,0.,p.x - 0.)*0.4) );\n    \n    //op.yz *= rot(jellorot(0.));\n    \n    op.y += 0.5 - 0.9*smoothstep(0.,5.,p.x) + sin(p.x*2. + T*2.)*0.7;\n    \n    float ydisp = 0.5 - 0.4*smoothstep(0.,9.,p.x) + 0.4*smoothstep(0.,5.,p.x - 2.) + sin(p.x + T)*0.;\n    p.y -= ydisp;\n    \n    float w = width + smoothstep(0.,7.,p.x)  + smoothstep(0.,27.,p.x)*2. ;\n    \n    float d = length(p.yz) - w;\n    \n    float dSprout = length(op.yz) - w;\n    \n    \n    float sc =  smoothstep(0.4,1.4,p.x)*(1. - smoothstep(0.,0.4,ydisp)*0.);\n    d = opSmoothSubtraction( -d, -p.x, 1.7 );\n    \n    dSprout = opSmoothSubtraction(-dSprout, p.x - 1.4, 0.5);\n    \n    //d = opSmoothUnion(d,dSprout,0.6);\n    \n    vec2 pc = vec2(atan(p.t,p.z)/pi,length(p.zx));\n    \n    float disp = sin(pc.x*pi*10.);\n    \n    disp = mix(disp, asin(disp),0.);\n    d -= disp*0.05*sc;\n    \n    \n    uvJello = p;\n    \n    return vec2(d, ID_JELLO);\n}\n\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    vec2 dwall = sdWall(p); \n    vec2 djellotube = sdJelloTube(p);\n\n    \n    #if 1\n    p.yz *= rot(1.25*pi);\n    djellotube.x = min(djellotube.x, sdJelloTube(p).x);\n    p.yz *= rot(-.5*pi);\n    //djellotube.x = min(djellotube.x, sdJelloTube(p).x);\n    #endif\n    /*\n    \n    */\n    //p.yz *= rot(.5*pi);\n\n    //djellotube.x = min(djellotube.x, sdJelloTube(p).x);\n\n    d = dmin(d, djellotube);\n    d = dmin(d, dwall);\n    \n    return d;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.4;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float precis){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*precis).x;\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    T = iTime*.35 + texture(iChannel0,fragCoord.xy/8.).x/100.;\n   \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy)/iResolution.xy;\n    \n    muv = muv*2. - 1.;\n    if (muv.x < -0.85){\n        muv -= muv;\n    }\n    \n    vec3 ro = vec3(0);\n    \n    ro.z -= 1.;\n    \n    //float pu = sin(iTime*0.5);\n    \n    \n    //pu = pow(abs(pu),6.) * sign(pu);\n    float md = 2.5;\n    float modulator = pow(smoothstep(0.,1.,fract(T/md*1.)),6.);\n    if(mod(floor(T/md),2.)==0.)\n        modulator = 1. - modulator;\n    float pu = mix(-1.,0.2,modulator);\n    \n    ro.x -= 1.25 + pu;\n    \n    ro.y += 0.24;\n    \n    ro *= 1.9;\n    \n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.z += muv.x;\n    lookAt.y += muv.y;\n    \n    \n    vec3 rd = getRd(ro, lookAt, uv, 5.);\n    \n    \n    vec3 col = vec3(0);\n    \n    vec3 lDir = normalize(vec3(-2.5,1,-1.));\n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d;\n    \n    vec3 atten = vec3(1.);\n    \n    \n    vec3 hitCol = vec3(0);\n    \n    int maxIters = 300;\n    \n    \n    vec3 reflalbedo = mix(ambientCol, lightCol,0.5);\n    for(int i = 0; i < maxIters; i++){\n\n        p = ro + rd*(t += d.x*stepSz);\n        d = map(p);\n\n        if(d.x < eps){\n            hit = true;\n            break;\n        }\n\n    }\n\n    \n    vec3 n = getNormal(p,eps);\n                    \n    {\n        #define AO(n,a) clamp(map(p + normalize(mix(n,lDir,0.4))*a).x/a, 0., 1.)\n        \n        //#define SSS(n,a) clamp(1. - 2.*map(p + normalize(n)*a).x/a, 0., 1.)\n        #define SSS(n,a) clamp( 1.*map(p + normalize(n)*a).x/a, 0., 1.)\n        \n        float aoo = AO(n,0.5);\n        float ao = aoo*AO(n,0.2)*AO(n,0.04)*1.;\n        //float ao = AO(n,1.);\n        \n        //ao = 1.;\n        \n        //float SSS = AO(lDir,0.04)*AO(lDir,0.5)*AO(-n,0.9);\n        //float SSS = AO(-n,0.2);\n        //float SSS = SSS(vec3(0,0.5,1),1.)*SSS(vec3(0,-0.4,1),1.)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        \n        float SSS = SSS(vec3(-0.,0.5,0.9),0.4)*1.*SSS(vec3(-0.4,-0.5,0.2),0.4)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        //float SSS = SSS(vec3(-0.,0.5,0.9),0.4)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        \n        //float SSS = 0.;\n        //ao = 0.;\n        \n        //SSS = 0.;\n        \n        //SSS = pow(SSS*4.,4.);\n        //SSS= 0.1;\n        \n        vec3 halfV = normalize(lDir - rd);\n        float fres = pow(1.-max(dot(-rd, n),0.0001),3.);\n        float spec = pow(max(dot(n,halfV),0.),8.);\n        float diff = dot(n,lDir);\n                     \n        vec3 albedo = vec3(0.);\n        vec3 sssalbedo = vec3(0.);\n        \n        \n        float shad = softshadow( p, lDir, 0.01, 20., 2.);\n        \n        shad = min(shad,diff);\n        \n        vec3 colJello = vec3(0);\n        {\n            map(p);\n            albedo = jelloCol;\n            /*\n            albedo = mix(albedo,albedo*vec3(1.4,0.5,0.1),smoothstep(-2.,1.5,dot(normalize(uvJello),n)));\n            \n            albedo = mix(albedo,albedo*vec3(.7,0.6,0.4),smoothstep(1.,-2.,dot(normalize(uvJello),n)));\n            \n            colJello = albedo*lightCol;\n\n            colJello = mix(colJello, reflalbedo, clamp(fres + spec,0.,1.)*ao*0.3);\n            \n            colJello = mix((colJello + colJello*ambientCol)*0.5, colJello, ao);\n            colJello = mix((colJello + colJello*ambientCol)*0.5,colJello, shad);\n            */\n            \n            //map(p);\n            albedo = jelloCol;\n            \n            vec3 jellouv =  uvJello;\n            //jellouv =  uvJelloTube;\n            \n            //jellouv.yz*=rot(-length(jellouv.yz)*8. - 1.);\n            vec3 pjellouv = vec3(atan(jellouv.z,jellouv.y)/pi ,length(jellouv.yz), jellouv.x);\n            \n            \n            pjellouv.xy *= rot(0.5*pi);\n            float md = 1./4.;\n            \n            //pjellouv.x -= pjellouv.y/width*2./pi;\n            //pjellouv.x -= length(p.yz)*4./pi;\n            //pjellouv *= rot(-length(jellouv.x)*1. + length(jellouv.x)*4. + length(jellouv.xz )*2. );\n            \n            pjellouv.x -= jellouv.x/width/1.;\n            \n            \n            //pjellouv.x -= mod(jellouv.x,width*4.)/(width*4.);//*width*pi/0.25;\n            \n            \n            float id = floor(pjellouv.x/md );\n            float idb = floor(pjellouv.y/width*2.5);\n            \n            \n            if(length(jellouv.yz) < 0.4){\n                //id = 1.;\n            }\n            \n            float r = fract(sin(id*10.215)*14.25)*1.;\n            float rb = fract(sin(idb*20.215)*1.)*1.;\n            \n            albedo.xz *= rot(-r*0.24);\n            albedo += 1.;\n            albedo.xy *= rot(-r*0.2);\n            albedo.yz *= rot(-r*0.1);\n            //albedo.xz *= rot(-sin(rb*420.)*0.1);\n            albedo.xz *= rot(-0. + sign(sin(rb*20.))*0.1);\n            \n            albedo -= 1.;\n            albedo.xz *= rot(-sign(rb)*0.1);\n            \n            //albedo.xy *= rot(-sin(rb*20.)*0.15);\n            albedo = mix(albedo,sssJelloCol,SSS);\n            \n            colJello = albedo*lightCol;\n\n            colJello = mix(colJello, reflalbedo, clamp(fres + spec,0.,1.)*ao*0.3);\n            \n            colJello = mix((colJello + colJello*ambientCol)*0.5, colJello, ao);\n            colJello = mix((colJello + colJello*ambientCol)*0.5,colJello, shad);\n            \n        }\n        //ao = clamp(ao,0.,1.);\n        ao = aoo;\n        \n        vec3 colWall = vec3(0);\n        {\n        \n            albedo = wallCol;\n\n            colWall = albedo;\n            \n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colWall = mix(colWall, reflalbedo, clamp(fres + spec,0.,1.)*0.2);\n\n            colWall = mix( (colWall + colWall*ambientCol)*0.3, colWall, shad);\n            \n            colWall = mix( (colWall + colWall*ambientCol)*0., colWall, ao);\n            \n        \n        }\n        vec3 colWallB = vec3(0);\n        {\n        \n            albedo = wallColB;\n\n            colWallB = albedo;\n            \n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colWallB = mix(colWallB, reflalbedo, clamp(fres + spec,0.,1.)*0.2);\n\n            colWallB = mix( (colWallB + colWallB*ambientCol)*0.3, colWallB, shad);\n            \n            colWallB = mix( (colWallB + colWallB*ambientCol)*0., colWallB, ao);\n            \n        \n        }\n        vec3 colStikcs = vec3(0);\n        {\n        \n            albedo = vec3(0.1,0.2,0.2);\n\n            colStikcs = albedo;\n            \n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colStikcs = mix(colStikcs, reflalbedo, clamp(fres + spec,0.,1.)*0.);\n\n            colStikcs = mix( (colStikcs + colStikcs*ambientCol)*0.3, colStikcs, shad);\n            \n            colStikcs = mix( (colStikcs + colStikcs*ambientCol)*0.5, colStikcs, ao);\n            \n        \n        }\n        \n        hitCol += colJello*float(floor(d.y) == ID_JELLO);\n        hitCol += colWall*float(d.y == ID_WALL_A);\n        hitCol += colWallB*float(d.y == ID_WALL_B);\n        hitCol += colStikcs*float(d.y == ID_STICKS);\n\n        \n        \n        //hitCol = mix(hitCol, hitCol + hitCol*ambientCol, shad);\n    \n    } \n    {\n        //col += ambientCol*atten;\n    }\n    \n    if(hit)\n        col += hitCol*atten;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nfloat FXAAamt = 1.;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ID_JELLO 1.\n#define ID_WALL_A 4.\n#define ID_WALL_B 5.\n#define ID_STICKS 6.\n\n\n#define stepSz 0.36\n#define eps 0.001\n\n#define maxRefractions 3\n\n#define ambientCol vec3(0.3,0.2,0.5)\n#define wallCol vec3(0.1,0.4,0.25)*1.3\n#define wallColB vec3(0.15,0.4,0.3)*1.2\n#define lightCol vec3(0.95,0.85,0.9)\n\n#define jelloCol vec3(0.5,0.3,0.4)*1.4\n#define sssJelloCol vec3(0.9,0.3,0.3)*1.\n\n#define width 0.4\n\n#define pi acos(-1.)\n\n\n\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv, float sc){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir)); \n    vec3 up = normalize(cross(dir, right));    \n    ro += right*uv.x*sc;\n    ro += up*uv.y*sc;\n    return dir;\n}\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.5;\n    const float lacunarity = 1.5;\n    const int octaves = 2;\n    \n    const float warp = 0.75;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //return 1. - abs(noise)*0.5;\n    return (noise*0.25 + 0.5);\n}\n\n\nfloat cyclicNoiseB(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.2;\n    const int octaves = 2;\n    \n    const float warp = .45;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //return 1. - abs(noise)*0.5;\n    return (noise*0.25 + 0.5);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}