{
    "Shader": {
        "info": {
            "date": "1601516266",
            "description": "So I herd you like regular geometry.\n\nCode is a bloody mess but I finally got my beautiful Spidron Hexagon going.\n\nMight add fun colors later.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sdcRl",
            "likes": 10,
            "name": "Spidron Hexagon",
            "published": 3,
            "tags": [
                "triangle",
                "spiral",
                "hexagon",
                "regular",
                "spidron"
            ],
            "usePreview": 0,
            "username": "timeisbeautifulhere",
            "viewed": 392
        },
        "renderpass": [
            {
                "code": "\n//https://en.wikipedia.org/wiki/Spidron#/media/File:Spidron_Hexagon.JPG\n\n//No fun constants to play with, sorry :(\n#define PI 3.14159\n#define START_CIRCUMRADIUS 3.0\n\n#define LINE_WIDTH 0.005\n\n#define RAD(deg) (deg*PI/180.0)\n\n#define TIME_CONST 1.5\n\n//Magic numbers for identifying points on/in triangles\n#define ON_TRIANGLE 123\n#define NOT_IN_TRIANGLE -1\n\nfloat THIRTY = RAD(30.0);\nfloat SIXTY = RAD(60.0);\n\n//Find closest point on a line segment, given a point p3.\n//Then compute whether it is \"on\" the line by computing\n//distance from the segment.\n//Thank you Paul Bourke http://paulbourke.net/geometry/pointlineplane/\nbool on_segment(vec2 p1, vec2 p2, vec2 p3, float thickness){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    //Check within bounds of segment\n    if(u<0.0||u>1.0)\n        return false;\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\treturn distance(point_on_line, p3)<=thickness;\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nbool in_triangle(vec2 p1, vec2 p2, vec2 p3, vec2 uv){\n    \n    //Delicious math\n    float l1 =\n        ((p2.y-p3.y)*(uv.x-p3.x)+(p3.x-p2.x)*(uv.y-p3.y))/\n        ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n    \n    float l2 = \n        ((p3.y-p1.y)*(uv.x-p3.x)+(p1.x-p3.x)*(uv.y-p3.y))/\n        ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n    \n    float l3 = 1.0 - l1 - l2;\n    \n    return l1>=0. && l1<=1. &&\n        l2>=0. && l2<=1. &&\n        l3>=0. && l3<=1.;\n}\n\n//Cross product to see if point is on left side of segment\n//https://stackoverflow.com/a/3461533\nbool isLeft(vec2 p1, vec2 p2, vec2 p3){\n     return ((p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)) > 0.0;\n}\n\n//Return kth point of hexagon by rotating\n//it along the circumradius\nvec2 hex_point(int k, float radius, float rotation){\n    \n    float deg = float(k)*SIXTY + rotation;\n    \n    float x = -1.0*cos(deg) - 0.0*sin(deg),\n        y = -1.0*sin(deg) - 0.0*cos(deg);\n    \n    return vec2(\n        x*radius,\n        y*radius\n    );\n}\n\n//Find closest hex point uv would be near by\n//calculating its rotation.\n//ie, if uv was 60 degrees from origin, it'd be at the\n//second hexagon point.\nint hex_point_n(vec2 uv, float rotation){\n    float point_rads = atan(uv.y,uv.x) + PI - rotation;\n    point_rads = mod(point_rads, 2.0*PI);\n    \n    return int(round(point_rads/SIXTY));\n}\n\n//hex_point_n, but floor instead of round\nint prev_hex_point_n(vec2 uv, float rotation){\n    float point_rads = atan(uv.y,uv.x) + PI - rotation;\n    point_rads = mod(point_rads, 2.0*PI);\n    \n    return int(floor(point_rads/SIXTY));\n}\n\n\n//Circumradius of nth hexagon in spidron hexagon.\nfloat circumradius_n(float circumradius, int n){\n    float R = circumradius;\n    \n    //Size of subsequent hexagons is a geometric series\n    //derived from the difference of the inradius and the\n    //height of the isosceles triangle touching the outer hexagon.\n    //Math simplified into a constant.\n    \n    float series_const = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    return R * pow(series_const, float(n));\n}\n\n//Circumradius of next hexagon in spidron hexagon\nfloat next_circumradius(float circumradius){\n    float R = circumradius;\n    float series_const = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    return R * series_const;\n}\n\n//Find closest hexagon a point would be near\nint closest_hex(vec2 uv, float start_radius){\n    \n    //Treating circumradius of hexagons as a \n    //geometric series x=aq^n, find n using logs\n    //https://math.stackexchange.com/a/447670\n    float x = length(uv),\n        a = start_radius,\n        q = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    float n = (log(x) - log(a))/log(q);\n    \n    int hex_num = int(floor(n));\n    \n    //Found the correct circumradius we're in,\n    //now check if it's outside the hexagon bounds\n    \n    //Get points of closest hex edge\n    float rotation=0.0;\n    if(hex_num%2==1)\n        rotation = THIRTY;\n    float circumradius = circumradius_n(start_radius,hex_num);\n    int hex_k = prev_hex_point_n(uv, rotation);\n    vec2 p1 = hex_point(hex_k, circumradius, rotation),\n        p2 = hex_point(hex_k+1, circumradius, rotation);\n    \n    //If it's outside, this belongs to the\n    //previous outer hexagon\n    if(!isLeft(p1,p2,uv))\n       hex_num -= 1;\n    \n    return hex_num;\n}\n\n//Determine if uv is on a hexagon edges for a given circumradius\nbool on_hex(vec2 uv, float circumradius, float rotation){\n    \n    int p1_k = prev_hex_point_n(uv, rotation);\n    \n    vec2 p1=hex_point(p1_k%6, circumradius, rotation),\n        p2=hex_point((p1_k+1)%6, circumradius, rotation);\n    \n    return on_segment(p1,p2,uv, LINE_WIDTH);\n}\n\n//Check if uv is on or near an equilateral triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint in_equilateral(vec2 uv, float circumradius, float rotation){\n    \n    //Points of closest equilateral can be derived from current\n    //and \"next\" (smaller) hexagon.\n    //Points are are hex point n of cur hexagon,\n    //n-1 of next hexagon, and n of next hexagon\n    \n    float next_radius = next_circumradius(circumradius);\n    float next_rotation = mod(rotation + THIRTY, 2.0*PI);\n    if(next_rotation<0.0)\n        next_rotation+= 2.0*PI;\n    \n    int cur_n = hex_point_n(uv, rotation),\n        next_n = cur_n;\n    \n    vec2 p1 = hex_point(cur_n, circumradius, rotation),\n        p2 = hex_point(next_n-1, next_radius, next_rotation),\n        p3 = hex_point(next_n, next_radius, next_rotation);\n    \n    if(in_triangle(p1,p2,p3,uv))\n        return cur_n%6;\n    \n    if(on_segment(p1,p2,uv,LINE_WIDTH) ||\n        on_segment(p2,p3,uv,LINE_WIDTH) ||\n        on_segment(p3,p1,uv,LINE_WIDTH))\n        return ON_TRIANGLE;\n    \n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an isosceles triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint in_isosceles(vec2 uv, float circumradius, float rotation){\n    \n    //Points of closest isosceles can be derived from current\n    //and \"next\" (smaller) hexagon.\n    //Points are are hex point n of cur hexagon,\n    //n+1 of cur hexagon, and n of next hexagon\n    \n    float next_radius = next_circumradius(circumradius);\n    float next_rotation = mod(rotation + THIRTY, 2.0*PI);\n    if(next_rotation<0.0)\n        next_rotation+= 2.0*PI;\n    \n    int cur_n = prev_hex_point_n(uv, rotation),\n        next_n = cur_n;\n    \n    vec2 p1 = hex_point(cur_n, circumradius, rotation),\n        p2 = hex_point(cur_n+1, circumradius, rotation),\n        p3 = hex_point(next_n, next_radius, next_rotation);\n    \n    if(in_triangle(p1,p2,p3,uv))\n        return cur_n%6;\n    \n    if(on_segment(p1,p2,uv,LINE_WIDTH) ||\n        on_segment(p2,p3,uv,LINE_WIDTH) ||\n        on_segment(p2,p1,uv,LINE_WIDTH))\n        return ON_TRIANGLE;\n    \n    return NOT_IN_TRIANGLE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [-1,1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //Treat start_radius as a geometric series (x=aq^n)\n    //and linearly \"expand\" spidron by scaling n\n    float a = START_CIRCUMRADIUS,\n        q = (cos(THIRTY) - (tan(THIRTY)/2.0)),\n        n = -(iTime*TIME_CONST);\n    \n    //Loop it to avoid large numbers.\n    if(n<12.0)\n    \tn = -12.0 + mod(n, 12.0);\n    \n    //Start radius of first hexagon of structure\n    float start_radius = a * pow(q,n);\n\n    vec3 col = vec3(1.0);\n    \n    //Find which hexagon we're in\n    int closest = closest_hex(uv, start_radius);\n    float circumradius = circumradius_n(start_radius, closest);\n    float rotation = 0.0;\n    if(closest%2==1)\n        rotation = THIRTY;\n    \n    //Check if/which \"stripe\" we're in\n    //by checking if we're in any triangles\n    int on_stripe = -1;\n    \n    int eq_check = in_equilateral(uv, circumradius, rotation);\n    if(eq_check != NOT_IN_TRIANGLE && eq_check != ON_TRIANGLE){\n        on_stripe = eq_check;\n    }\n    \n    int iso_check = in_isosceles(uv, circumradius, rotation);\n    if(iso_check != NOT_IN_TRIANGLE && iso_check != ON_TRIANGLE){\n        on_stripe = iso_check;\n    }\n    \n    //Color\n    if(on_stripe != -1){\n        if(rotation>0.0)\n            on_stripe+=1;\n        on_stripe+=closest/2;\n        on_stripe%=6;\n        \n        float val = float(on_stripe)/6.0;\n        if(on_stripe%2==0){\n        \tcol=vec3(val,0.0,val);\n        }\n        else{\n            col=vec3(0.0,val,val);\n        }\n    }\n    \n    //Lines\n    if(eq_check == ON_TRIANGLE || on_hex(uv, circumradius, rotation))\n        col=vec3(1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}