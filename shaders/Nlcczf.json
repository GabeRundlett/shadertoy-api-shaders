{
    "Shader": {
        "info": {
            "date": "1660225774",
            "description": "Another shader written on the mobile phone during travel. Slightly modified to fit shadertoy horizontal framing and resolution better.\nThere are some aliasing artifacts on the horizontal lines. But I probably won't ever fix them :P",
            "flags": 0,
            "hasliked": 0,
            "id": "Nlcczf",
            "likes": 94,
            "name": "Traveling by the mountains",
            "published": 3,
            "tags": [
                "2d",
                "mountains",
                "ink",
                "paper"
            ],
            "usePreview": 0,
            "username": "detectiveLosos",
            "viewed": 3925
        },
        "renderpass": [
            {
                "code": "float getH(\n    float pos,\n    out vec2 from, out vec2 to, out float blend\n)\n{\n    float n;\n\n    float i = floor(pos);\n    float f = pos - i;\n    vec2 rand = vec2(0.4, 0.95);\n\n    // x is i-offset, y is peak height.\n    vec2 sub = vec2(0.5, 0.0);\n    vec2 add = vec2(0.5, 1.1 - rand.y);\n    vec2 l = (hash21((i-1.0)) - sub) * rand + add;\n    vec2 c = (hash21(i) - sub) * rand + add;\n    vec2 r = (hash21((i+1.0)) - sub) * rand + add;\n\n    l.x = (i - 1.0) + l.x;\n    c.x = i + c.x;\n    r.x = (i + 1.0) + r.x;\n\n    if(pos < c.x)\n    {\n        from = l;\n        to = c;\n    }\n    else\n    {\n        from = c;\n        to = r;\n    }\n\n    // Make 90-degree angle mountains\n    // between from-to points by creating mid point.\n    //if(false)\n    {\n        float tl = 0.5*(to.x - from.x - to.y + from.y);\n        vec2 mid = to + vec2(-1.0, 1.0)*tl;\n\n        if(pos < mid.x)\n        {\n            to = mid;\n        }\n        else\n        {\n            from = mid;\n        }\n    }\n\n    // Linearly interpolate between from-to points.\n    blend = ((pos - from.x) / (to.x - from.x));\n    n = lerp(from.y, to.y, blend);\n\n    return n;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord.y -= -0.1*iResolution.y + 0.1*iResolution.y*cos((fragCoord.x / iResolution.x - 0.5)*M_PI*0.5);\n\n\n    float mx = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord.xy / mx;\n    vec2 nuv = fragCoord.xy / iResolution.xy;\n    vec2 pos = uv - (iResolution.xy)*0.5/mx;\n    \n    float col = 1.0;\n\n    float sNoise = optimizedSnoise(vec2(pos.x*15.0, 0.0));\n\n    // Sun.\n    vec3 circle = sdgCircle(pos + vec2(0.2, -0.05), 0.1);\n    col *= saturate(400.0*abs(circle.x) - 1.0*(0.5 + sin(sNoise*5.0 + 0.5*iTime)));\n    col *= saturate(1.3 - saturate(-circle.x*800.0 - 7.0)*cos(circle.x*800.0 - 1.0*(1.0 + cos(sNoise*5.0+0.5*iTime))));\n\n    // Deform.\n    pos -= 0.5*vec2(pos.y, - pos.x);\n\n    // Horizontal scroll.\n    pos.x += iTime*0.01;\n\n    // Wiggle animation.\n    /*\n    float t = 0.25*sin(iTime*0.25);\n    vec2 newX = vec2(cos(t), sin(t));\n    vec2 newY = vec2(-newX.y, newX.x);\n    pos = newX*pos.x + newY*pos.y;\n    //*/\n\n    float scaleX = 5.0;\n    vec2 from, to; float blend;\n    float noise = getH(\n        scaleX*pos.x, // In\n        from, to, blend // Out\n    );\n    \n    \n    \n    // Additional wiggle to the lines.\n    noise -= 0.05*sNoise;\n\n    float posY = 0.3;\n    float scaleY = 1.0 / scaleX; //0.05;\n\n    float scaledNoise = scaleY*noise;\n    float mountHeight = posY + scaledNoise;\n\n    float hatchLength = length(to - from);\n    float hatchWidth = lerp(0.5, 3.0, 1.0 - saturate(pcurve(blend, 2.0*hatchLength, 2.0))); //lerp(1.5, 5.0, 1.0 - saturate(pcurve(blend, 2.0*hatchLength, 2.0))) / iResolution.y;\n    //hatchWidth = lerp(0.0, 1.0, blend);\n    col = min(col, iResolution.y*(abs(nuv.y - mountHeight) - hatchWidth/iResolution.y));\n    \n    \n\n    // Hatching inside mountains.\n    float mountGrad = saturate(scaledNoise - nuv.y + posY) / scaledNoise;\n    if(\n        //false &&\n        (nuv.y < mountHeight - 0.0025) && (nuv.y > posY)\n    )\n    {\n        col = ((\n            + lerp(0.5, 3.0, mountGrad)*abs(cos((1.0-pow(0.025*sNoise + mountGrad, 0.5))*(lerp(1.0, noise, 0.8))*M_PI*25.0))\n            + saturate(3.0 + 10.0*cos(pos.x * 32.0 - cos(pow(mountGrad, 1.25)*13.0)))\n            - saturate(3.0 + 10.0*cos(2.0 + pos.x * 32.0 - cos(pow(mountGrad, 1.25)*13.0)))\n        ));\n    }\n\n    \n    // Horizon.\n    float belowHorizon = saturate(1.0 - (posY - nuv.y) / posY + 0.01*sNoise);\n    float aboveHorizonMask = saturate(iResolution.y*(belowHorizon - 1.0 + 1.0/iResolution.y));\n    col = min(col, max(aboveHorizonMask, saturate(max(\n        saturate(1.1 - belowHorizon*belowHorizon),\n        saturate(abs(cos(0.2*belowHorizon*belowHorizon*M_PI*450.0*posY)))\n        + saturate(0.5 + cos(pos.x * 27.0 + cos(belowHorizon*belowHorizon*belowHorizon*13.0)))\n        - saturate(-0.5 + cos(pos.x * 32.0 + cos(belowHorizon*belowHorizon*belowHorizon*13.0)))\n    ))));\n    \n    \n    // Clouds.\n    //if(false)\n    {\n        float clouds = saturate(\n            2.0*abs(optimizedSnoise(nuv * vec2(2.0, 4.0) + vec2(0.05*iTime, 0.0)) - 0.5)\n            + 1.0*optimizedSnoise(nuv * vec2(5.0, 16.0) + vec2(0.2*iTime, 0.0))\n        );\n        col = max(col, saturate((nuv.y + 0.25)*clouds*clouds - 1.0 + clouds));\n    }\n    \n    // Colorize.\n    fragColor.a = 1.0;\n    //fragColor.rgb = vec3(col);\n    /*\n    fragColor.rgb = lerp(\n        vec3(0.3, 0.0, 0.5),\n        vec3(0.7, 0.75, 0.79),\n        col\n    );\n    //*/\n    //*\n    fragColor.rgb = lerp(\n        vec3(0.0, 0.2, 0.45),\n        //vec3(0.7, 0.75, 0.79),\n        //vec3(0.9),\n        vec3(0.8, 0.85, 0.89),\n        1.0-col\n    );\n    //*/\n\n    // Grains.\n    fragColor.rgb += 1.5*0.75*((rand2(uv)-.5)*.07);\n    \n    // Vigente.\n    vec2 vigenteSize = 0.3*iResolution.xy;\n    float sdf = -sdRoundedBox(fragCoord.xy - iResolution.xy*0.5, vigenteSize, vec4(0.25*min(iResolution.x, iResolution.y))) / vigenteSize.x;\n    float percent = 0.8;\n    sdf = (saturate(percent + sdf) - percent) / (1.0 - percent);\n    sdf = lerp(1.0, sdf, 0.05);\n    fragColor.rgb *= sdf;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define M_PI 3.14159265359\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define pack(x) (x*0.5+0.5)\n#define unpack(x) (x*2.0 - 1.0)\n#define lerp(a,b,x) mix(a,b,x)\n#define rgb(r, g, b) (vec3(r, g, b)*0.0039215686)\n\n// Directions\nconst ivec2 center = ivec2(0, 0);\nconst ivec2 up = ivec2(0, 1);\nconst ivec2 down = ivec2(0, -1);\nconst ivec2 right = ivec2(1, 0);\nconst ivec2 left = ivec2(-1, 0);\nconst ivec2 upRight = up + right;\nconst ivec2 upLeft = up + left;\nconst ivec2 downRight = down + right;\nconst ivec2 downLeft = down + left;\n\nconst vec2 centerf = vec2(0, 0);\nconst vec2 upf = vec2(0, 1);\nconst vec2 downf = vec2(0, -1);\nconst vec2 rightf = vec2(1, 0);\nconst vec2 leftf = vec2(-1, 0);\nconst vec2 upRightf = normalize(upf + rightf);\nconst vec2 upLeftf = normalize(upf + leftf);\nconst vec2 downRightf = normalize(downf + rightf);\nconst vec2 downLeftf = normalize(downf + leftf);\n\nfloat smootherstep(float a, float b, float x)\n{\n    x = saturate((x - a) / (b - a));\n    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat segment(float value, float segments)\n{\n    return float(int(value*segments))/segments;\n}\n\nvec3 sdgCircle( in vec2 p, in float r )\n{ float d = length(p); return vec3( d-r, p/d ); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat pcurve(float x, float a, float b)\n{\n    float k = pow(a+b,a+b)/(pow(a,a)*pow(b,b));\n    return k*pow(x,a)*pow(1.0-x,b);\n}\n\nfloat rand2(vec2 p) {\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p)\n{\n    return fract(sin(vec2(\n        dot(p, vec2(127.1, 311.7)),\n        dot(p, vec2(269.5, 183.3))\n    ))*43758.5453);\n}\n\n\n//==== Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8 ====//\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\nvec4 glslmod(vec4 x, vec4 y) { return x - y * floor(x / y); }\nvec3 glslmod(vec3 x, vec3 y) { return x - y * floor(x / y); }\nvec2 glslmod(vec2 x, vec2 y) { return x - y * floor(x / y); }\nvec3 permute_optimizedSnoise2D(in vec3 x) { return glslmod(x*x*34.0 + x, vec3(289.0)); }\nfloat optimizedSnoise(in vec2 v) {\n    vec2 i = floor((v.x + v.y)*.36602540378443 + v);\n    vec2 x0 = (i.x + i.y)*.211324865405187 + v - i;\n    float s = step(x0.x, x0.y);\n    vec2 j = vec2(1.0 - s, s);\n    vec2 x1 = x0 - j + .211324865405187;\n    vec2 x3 = x0 - .577350269189626;\n    i = glslmod(i, vec2(289.));\n    vec3 p = permute_optimizedSnoise2D(permute_optimizedSnoise2D(i.y + vec3(0, j.y, 1)) + i.x + vec3(0, j.x, 1));\n    vec3 m = max(.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x3, x3)), 0.);\n    vec3 x = fract(p * .024390243902439) * 2. - 1.;\n    vec3 h = abs(x) - .5;\n    vec3 a0 = x - floor(x + .5);\n    return .5 + 65. * dot(pow(m, vec3(4.0))*(-0.85373472095314*(a0*a0 + h * h) + 1.79284291400159), a0 * vec3(x0.x, x1.x, x3.x) + h * vec3(x0.y, x1.y, x3.y));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}