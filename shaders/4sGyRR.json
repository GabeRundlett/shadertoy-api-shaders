{
    "Shader": {
        "info": {
            "date": "1520702535",
            "description": "render some images, mostly repeating old code.",
            "flags": 32,
            "hasliked": 0,
            "id": "4sGyRR",
            "likes": 18,
            "name": "Spudsville2018",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "dof",
                "pathtracer",
                "kleinian",
                "montecarlo"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 1751
        },
        "renderpass": [
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if(iFrame>0)\n    {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n        col = pow(col, vec3(0.45));\n    }\n\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Another simple pathtracer with phong model.\n\n#define SAMPLES 1\n#define LIGHT_SAMPLES 1\n#define MAX_DEPTH 4\n#define DE_ITER 10\n\n#define PI 3.1415926\n\nfloat seed;\nfloat rnd() \n{ \n    return fract(sin(seed++)*43758.5453123); \n}\n\n\n\n//==========  spudsville ===========================\nconst vec3 c = vec3(.808, .7, 1.137);\nfloat f(vec3 p)\n{\n\tfloat scale = 1.0;\n\t\n\tfor(int i=0; i < DE_ITER;i++)\n\t{\n\t\tp = 2.0*clamp(p, -c, c) - p;\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = max((1.)/(r2), 0.03);\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 3.;\n\tfloat n = l * p.z;\n\trxy = max(rxy, -(n) / (length(p))-0.02);\n\treturn (rxy) / abs(scale);\n}\n\n//from Dave_Hoskins: https://www.shadertoy.com/view/llX3zr\nvec3 get_material(vec3 p)\n{\n    float col\t= 0.0;\t\t\n\tfor( int i=0; i < DE_ITER+1;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -c, c)-p;\n\t\tcol += abs(p1.z-p.z);\n\t\tp = p1;\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = max((1.)/(r2), .03);\n\t\tp *= k;\n\t}\n\treturn (0.5+0.5*sin(col*vec3(1.75, -1.,4.6)));\n}\n\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 0.0;\n    float tmax = 1.5;\n    float t = 0.001;\n    for(int i=0; i<30; i++ )\n    {\n        float h = f(ro+rd*t);\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n    if( t>tmax ) res = 1.0;\n    return res;\n}\n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float t = 0.01;\n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = f(p);\n        if(res < 0.0001 || res > 100.)\n            break;\n        t += res;\n    }\n    \n    if(res > 100.) t = -1.;\n    return t;\n}\n\n\nvec3 get_normal(vec3 pos)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\treturn normalize(vec3(\n           f(pos+eps.xyy) - f(pos-eps.xyy),\n           f(pos+eps.yxy) - f(pos-eps.yxy),\n           f(pos+eps.yyx) - f(pos-eps.yyx)));\n}\n\n\nfloat schlick_fresnel(float rs, float cos_theta) \n{\n    return rs + pow(1.0 - cos_theta, 5.) * (1. - rs);\n}\n\n// http://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.z < -0.999999) {\n        b1 = vec3(0 , -1, 0);\n        b2 = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tb1 = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tb2 = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nvec3 local_to_world(vec3 local_dir, vec3 normal)\n{\n    vec3 a,b;\n    basis(normal, a, b);\n\treturn local_dir.x*a + local_dir.y*b + local_dir.z*normal;\n}\n\nvec3 spherical_to_cartesian(float rho, float phi, float theta) {\n    float sin_theta = sin(theta);\n    return vec3( sin_theta*cos(phi), sin_theta*sin(phi), cos(theta))*rho;\n}\n\nvec3 sample_hemisphere_cos_weighted(vec3 n, float Xi1, float Xi2) \n{\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = 2. * PI * Xi2;\n\n    return local_to_world(spherical_to_cartesian(1.0, phi, theta), n);\n}\n\nvec3 sample_phone_specular(vec3 n, float roughness, float Xi1, float Xi2)\n{\n    float theta = acos(pow(Xi1, 1./(roughness + 1.)));\n    float phi = 2. * PI * Xi2;\n    return local_to_world(spherical_to_cartesian(1., phi, theta), n);\n}\n\n\nvec3 sun_col = 6.0*vec3(1.0,0.8,0.6);\nvec3 sun_dir = normalize(vec3(4.0,2.,2.));\nvec3 sky_col = vec3(0.5, 0.8, 1.);\nconst float shininess = 32.;\nconst float spec_weight = 0.3;\n\n// standard phong brdf\n// kd*(1./pi) + ks*((n+2)/2pi * (reflect * eye)^n\nvec3 brdf(vec3 wi, vec3 wo, vec3 n, vec3 x)\n{\n\tvec3 wr = reflect(-wi, n);\n    vec3 wh = normalize(wi + wo);\n    \n    float F = schlick_fresnel(0.1, max(0., dot(wi, wh)));\n    \n    vec3 mtl = get_material(x);\n    \n    float diff = (1. - F) * 1./PI;\n    float spec = F * ((shininess + 2.)/(2.*PI)) * \n    pow(max(0., dot(wr, wo)), shininess);\n   \n    \n    vec3 diff_refl = diff * mtl;\n    vec3 spec_refl = spec * vec3(1.);\n    \n    return mix(diff_refl, spec_refl, spec_weight);\n}\n\n// randomly picking sun or sky\nvoid light_pick(vec3 n, out vec3 Li, out vec3 wi)\n{\n    if(rnd() > 0.3)\n    {\n        Li = sun_col;\n        wi = sun_dir;\n    }\n    else\n    {\n        Li = sky_col;\n        \n        float Xi1 = rnd();\n        float Xi2 = rnd();\n\n        wi = sample_hemisphere_cos_weighted(n, Xi1, Xi2);\n    }\n}\n\nvec3 sample_light(vec3 x, vec3 n, vec3 rd)\n{\n    vec3 Lo = vec3(0.);\n    \n    for(int i = 0; i < LIGHT_SAMPLES; ++i)\n    {\n        vec3 Li, wi;\n        light_pick(n, Li, wi);\n        \n        float cos_theta = max(0., dot(n, wi));\n        \n        if(cos_theta > 0.00001)\n        {\n        \tfloat sha = shadow(x, wi);\n        \tLo += Li * brdf(wi, -rd, n, x) * cos_theta * sha;\n        }\n    }\n    \n    Lo /= float(LIGHT_SAMPLES);\n    \n    return Lo;\n}\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n   \tvec3 acc = vec3(0.);\n    float dist = 0.;\n    \n    float t = intersect(ro, rd);\n    \n    if(t < 0.)\n    {\n        return sky_col;\n    }\n    \n    dist = t;\n    \n    for(int i = 0; i < MAX_DEPTH; ++i)\n    {        \n        \n        vec3 x = ro + t * rd;\n        vec3 n = get_normal(x);\n        \n        acc += sample_light(x, n, rd);\n        \n        float Xi1 = rnd();\n        float Xi2 = rnd();\n\n        // sample the next ray\n        if(rnd() > spec_weight)\n        {\n        \trd = sample_hemisphere_cos_weighted(n, Xi1, Xi2);\n        }\n        else\n        {\n            rd = sample_phone_specular(n, shininess, Xi1, Xi2);\n        }\n        \n        ro = x;\n        rd = normalize(rd);\n        \n        t = intersect(ro, rd);\n        \n        if(t < 0.)\n        {\n            break;\n        }\n    }\n    acc = mix(acc, sky_col, 1.0-exp(-0.01*dist*dist)); \n\n    return acc;\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 cf = normalize(ta - ro);\n    vec3 cs = normalize(cross(cf, vec3(0,0,1)));\n    vec3 cu = normalize(cross(cs, cf));\n    return mat3(cs, cu, cf);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\n    vec3 ro = vec3(-14.4, -9.4, -2.24);\n    vec3 ta = vec3(-30.4, -9.3, -1.1);\n\n    \n    vec2 offset = -0.5 + vec2(rnd(), rnd());\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+offset)) / iResolution.y;\n\n    vec3 cf = normalize(ta - ro);\n    vec3 cs = normalize(cross(cf, vec3(0,0,1)));\n    vec3 cu = normalize(cross(cs, cf));\n    mat3 cam = mat3(cs, cu, cf);\n    \n    vec3 rd = normalize(cam * vec3(p, 3.));\n    \n    // DoF\n    vec3 fp = ro + rd * 0.2;\n\tro += (cs*rnd() + cu*rnd())*0.0015;\n\trd = normalize( fp - ro );\n    \n \tvec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    if(iFrame==0) col = vec3(0.0);\n    \n    vec3 col_acc = vec3(0.);\n    for(int i = 0; i < SAMPLES; ++i)\n    {\n        col_acc += radiance(ro, rd);\n    }\n    \n    col_acc /= float(SAMPLES);\n     \n   \tcol += col_acc;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}