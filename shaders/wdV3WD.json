{
    "Shader": {
        "info": {
            "date": "1570244774",
            "description": "It's chilly in here",
            "flags": 0,
            "hasliked": 0,
            "id": "wdV3WD",
            "likes": 3,
            "name": "Shadertober 04 - Freeze",
            "published": 3,
            "tags": [
                "freeze",
                "inktober",
                "shadertober",
                "backwardscaptain"
            ],
            "usePreview": 0,
            "username": "BackwardsCap",
            "viewed": 386
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 20.0\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0)/k;\n    return min(a,b)-h*h*k*(1.0/4.0);\n}\n\n\nfloat elipsoid(vec3 p, vec3 r)\n{\n    float k=length(p/r);\n    float k1 = length(p/(r*r));\n    return k*(k-1.)/k1;\n}\n\nfloat box(vec3 p, vec3 b, float r)\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0))-r + min(max(d.x,max(d.y,d.z)),0.0);\n    \n}\n\nfloat cyl (vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y))-vec2(h,r);\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0));\n    \n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nvec2 map(vec3 p)\n{\n    float f=clamp((1.+cos(iTime/3.)),0.0,1.0);\n    float r = 0.0;\n    \n    float id = mod(floor((9.5+iTime)/18.85),2.);\n    \n    float s = elipsoid(p+vec3(0,1.1,0.),vec3(3.+cos(length(p+p.x))/2.+sin(length(p+p.z))/2.,.3+f*2.,3));\n    float b=box(p,vec3(1.,1.,1.),.05);\n    float c = cyl(p+vec3(0,3.05,0),5.+p.y,2.);\n    \n    \n    vec3 sp=p+vec3(0.,2.36-f*2.,0.);\n    float snowman  =smin(sphere(sp,1.),\n                        smin(sphere(sp+vec3(0.,-.3-f,0),.7),\n                           sphere(sp+vec3(0.,.7-f*3.,0.),.5),.2),.2);\n    \n    \n    float ta = snowman;\n    if(id==1.)ta=b;\n    \n   \tfloat i=mix(s,ta,f);\n    r=min(i,c);\n    \n    float m=0.0;\n    \n    if(r==i)\n    {\n        m=2.+f;\n    }\n    else if(r==c)m=1.;\n    \n    return vec2(r,m);\n}\n\nvec3 normal(vec3 p)\n{\n    float eps = 0.0005;\n    return normalize(vec3(\n        map(vec3(p.x+eps,p.y,p.z)).x-map(vec3(p.x-eps,p.y,p.z)).x,\n        map(vec3(p.x,p.y+eps,p.z)).x-map(vec3(p.x,p.y-eps,p.z)).x,\n        map(vec3(p.x,p.y,p.z+eps)).x-map(vec3(p.x,p.y,p.z-eps)).x\n        \n    ));\n    \n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float m = 0.0;\n    float t = 0.0;\n    for(int i=0;i<128;i++)\n    {\n        vec3 p = ro+rd*t;\n        vec2 h = map(p);\n        m=h.y;\n        if(h.x<0.0001)break;\n        t+=h.x;\n        if(t>MAX_DIST)break;\n    }\n    \n    if(t>MAX_DIST)t=-1.;\n    \n    return vec2(t,m);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec2 r)\n{\n    vec3 col =vec3(-0.1-rd.y,0.3,1.4);\n\n    if(r.x>0.0)\n    {\n        vec3 p = ro+rd*r.x;\n        vec3 n=normal(p);\n        vec3 mate = vec3(0.2);\n        if(r.y<.5)\n        {\n            mate=vec3(.1,.1,0.1);\n        }\n        else if(r.y<1.5){\n            \n            mate=vec3(0.1,0.1,0.2);\n        }\n        else if(r.y<3.5)\n        {\n            vec3 wc = vec3(.0,.2,1.+(1.+cos(iTime-p.x*2.)*.2+sin(iTime-p.z*4.)/2.));\n            vec3 sc = vec3(.6,1.,3.)*(1.5);\n            mate=mix(wc, sc, r.y-2.);\n            \n        }\n        \n        vec3 sun = normalize(vec3(-0.2,.25,0.2));\n        float dif = clamp(dot(sun,n),0.0,1.0);\n        float sha = step(ray(p+n*.001,sun).x,0.0);\n        float sky = clamp(0.5+0.5*dot(n,vec3(0.,1.,0.)),0.,1.);\n        float bou = clamp(0.5+0.5*dot(n,vec3(0.,-1.,0.)),0.,1.);\n        \n        col = mate*dif*sha;\n        col+= mate*vec3(0.5,0.2,0.1)*sky;\n        col+= mate*vec3(0.3,0.2,0.1)*bou*.5;\n    }\n\t\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 r)\n{\n    \n    vec3 col =  color(ro,rd,r);\n    vec3 p = ro+rd*r.x;\n    vec3 n = normal(p);\n\n    if(r.x>0.0)\n    {\n\n\t\tvec3 nc = col;\n        if(r.y>=2.)\n        {\n            nc=color(p,n,r);\n            rd = reflect(rd,n);\n            ro=p+n*.001;\n            r = ray(ro,rd);\n            p=ro+r.x*rd;\n            vec3 c = color(p,normal(p),r);\n            nc+=c/10.;\n        }\n        col=mix(col,mix(col,nc,(1.+(2.-r.y))),1.-((2.-r.y)));\n\n    }\n    \n    col=pow(col,vec3(.454545));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dist = -8.+(1.+sin(iTime/10.))/2.;\n    vec3 ro = vec3(dist*cos(iTime/5.),2.5,dist*sin(iTime/5.));\n    vec3 ta = vec3(0.,0.,0.);\n    \n    vec3 camForward = normalize(ta-ro);\n    vec3 camUp = normalize(cross(camForward,vec3(0,1,0)));\n    vec3 camRight = normalize(cross(camUp,camForward));\n    \n    vec3 rd = normalize(uv.x*camUp+uv.y*camRight+2.*camForward);\n    \n    vec2 r = ray(ro,rd);\n    \n\tvec3 col = render(ro,rd,r); \n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}