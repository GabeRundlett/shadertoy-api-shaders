{
    "Shader": {
        "info": {
            "date": "1498773637",
            "description": "Smoothed hexagonal lattice-based Voronoi landscape with fireball; mouse enabled. Details in the source.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsffWs",
            "likes": 14,
            "name": "Smoothed Voronoi Landscape",
            "published": 3,
            "tags": [
                "voronoi",
                "raymarch",
                "landscape"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 906
        },
        "renderpass": [
            {
                "code": "// \"Smoothed Voronoi Landscape\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Smoothed honeycomb-based Voronoi landscape with fireball; mouse enabled.\n\n Voronoi patterns are discussed in several articles at  iquilezles.org. Cell\n edges are generated by computing d_2 - d_1, where d_k is the distance to the\n k-th nearest cell center, or some extension of this to reduce artifacts. These\n methods all produce sharp corners, which lead to sharp edges when used for\n landscape generation.\n\n The method employed here is based on smoothmin (d_3, d_2, epsilon) - d_1, which\n reduces the severity of the problem (contrast with \"Flaming Sphere 2\").\n\n Explore the effect by changing DLEVEL:\n   DLEVEL = 5 full image\n   DLEVEL = 4 no fireball\n   DLEVEL = 3 no surface texturing or shadows\n   DLEVEL = 2 no noise in polygon positioning\n   DLEVEL = 1 no polygon corner smoothing\n*/\n\n#define DLEVEL 5\n\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noiseff (float p);\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 flPos, qHit, qnHit, fBallPos, sunDir;\nvec2 gVec[7], hVec[7];\nfloat tCur, dstFar, fBallRad;\nconst float pi = 3.14159;\n\n#define SQRT3 1.73205\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\n#define EPS 0.1  // controls smoothing\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n#if DLEVEL >= 2\n  return vec4 (SmoothMin (sd.y, sd.z, EPS) - sd.x, udm.xy, Hashfv2 (udm.zw));\n#else\n  return vec4 (min (sd.y, sd.z) - sd.x, udm.xy, Hashfv2 (udm.zw));\n#endif\n}\n\nfloat GrndHt (vec2 p)\n{\n  vec4 sv;\n  float h1, h2, r, s;\n#if DLEVEL >= 3\n  r = 0.2 * length (Noisev3v2 (0.3 * p));\n#else\n  r = 0.;\n#endif\n  sv = HexVor (0.05 * p + r);\n  s = (0.8 + 0.5 * sv.w);\n  h1 = s * smoothstep (0.1, 0.4 + 0.1 * sv.w, sv.x);\n  h2 = 2. * s * smoothstep (0.2, 0.4 + 0.1 * sv.w, max (0.,\n     (0.45 - dot (sv.yz, sv.yz))));\n  return 3. * SmoothMax (h1, h2, 0.4) - 0.5;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, 0.4 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  float h;\n  h = GrndHt (p.xz);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy), e.x, h - GrndHt (p.xz + e.yx)));\n}\n\nfloat FBallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float h, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  h = dstFar;\n  if (d >= 0.) {\n    h = - b - sqrt (d);\n    qHit = ro + h * rd;\n    qnHit = (qHit - p) / s;\n  }\n  return h;\n}\n\nfloat FBallLum (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, fr, f;\n  p = ro + dHit * rd - fBallPos;\n  dp = (fBallRad / 30.) * rd;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    q = 4. * p;   q.y -= 5. * tCur;\n    f = Fbm3 (q);\n    q = 7. * p;   q.y -= 9. * tCur;\n    f += Fbm3 (q);\n    s = length (p);\n    fr = max (1. - 0.9 * s / fBallRad, 0.);\n    g += max (0.15 * fr * (f - 0.55), 0.);\n    if (s > fBallRad || g > 1.) break;\n  }\n  return g;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.2, 0.3, 0.55) + 0.1 * pow (1. - max (rd.y, 0.), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = 0.5 * Fbm2 (0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz));\n  col = SkyBg (rd) + 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 16; j ++) {\n    p = ro + rd * d;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.3;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 flmCol, col, vn;\n  float dstGrnd, dstFbHit, fIntens, f, sh;\n  HexVorInit ();\n#if DLEVEL == 5\n  dstFbHit = FBallHit (ro, rd, fBallPos, fBallRad);\n  fIntens = (dstFbHit < dstFar) ? FBallLum (ro, rd, dstFbHit) : 0.;\n#endif\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro);\n    sh = 1.;\n#if DLEVEL >= 4\n    vn = VaryNf (1.3 * ro, vn, 3.);\n    sh = GrndSShadow (ro, sunDir);\n#endif\n    col = mix (vec3 (0.9), vec3 (1.), clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.));\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) +\n       0.2 * max (dot (vn, - sunDir), 0.) +\n       0.8 * sh * max (0., max (dot (vn, sunDir), 0.))) +\n       0.2 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), max (f * f - 0.1, 0.));\n  } else col = SkyCol (ro, rd);\n#if DLEVEL == 5\n  if (dstFbHit < dstFar) {\n    ro += rd * dstFbHit;\n    rd = reflect (rd, qnHit);\n    col = 0.9 * col + 0.08 + 0.25 * max (dot (qnHit, sunDir), 0.) * (1. +\n       4. * pow (max (0., dot (sunDir, rd)), 128.));\n  }\n  f = clamp (0.7 * fIntens, 0., 1.);\n  f *= f;\n  flmCol = (1. + 0.4 * Noiseff (10. * tCur)) *\n     mix (vec3 (1., 0.4, 0.1), vec3 (1., 1., 0.5), f * f);\n  col = mix (col, flmCol, min (1.2 * fIntens * fIntens, 1.));\n  if (dstFbHit < dstFar) {\n    dstGrnd = GrndRay (ro, rd);\n    col = mix (col, ((dstGrnd < dstFar) ? vec3 (0.4, 0.4, 0.5) :\n       SkyCol (ro, rd)), pow (1. - abs (dot (rd, qnHit)), 3.));\n  }\n#endif\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     26. * sin (0.0032 * t), 1. + 3. * sin (0.021 * t) * sin (1. + 0.023 * t), t);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 2.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 5. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  VuPM (10. * tCur);\n  ro = flPos;\n  rd = normalize (vec3 (uv, 2.5));\n  if (mPtr.z > 0.) {\n    az = -2. * pi * mPtr.x;\n    el = -0.1 * pi + pi * mPtr.y;\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n       mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    rd = vuMat * rd;\n  } else {\n    rd = rd * flMat;\n  }\n  fBallRad = 3.;\n  fBallPos = TrackPath (10. * (tCur + 5. + 4. * sin (0.5 * tCur)));\n  fBallPos.y += 10.;\n  ro.y += 12.;\n  sunDir = normalize (vec3 (cos (0.01 * tCur), 0.7, - sin (0.01 * tCur)));\n  dstFar = 200.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, cHashA3.xy));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}