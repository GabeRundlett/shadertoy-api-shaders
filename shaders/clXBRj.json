{
    "Shader": {
        "info": {
            "date": "1693151959",
            "description": "Based on https://www.shadertoy.com/view/ldc3z4\n\nimproved trails by drawing straight line-segments instead of points\nforked to look more like https://www.youtube.com/watch?v=G6jni8AtHkQ&t=151s",
            "flags": 32,
            "hasliked": 0,
            "id": "clXBRj",
            "likes": 8,
            "name": "Fork PS2 menu s hyphellux 505",
            "published": 3,
            "tags": [
                "ps2",
                "playstation"
            ],
            "usePreview": 0,
            "username": "hyphellux",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = uv-.5; suv.x /= iResolution.y/iResolution.x;\n\tfragColor = texture(iChannel0,uv)+(texture(iChannel1,uv))+vec4((1.-((length(suv)-0.2)+0.2)*2.)*vec3(0.1,0.12,0.3),0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nmat3 r(float a)\n{\n    float ax = xSpeed*a;\n    float ay = ySpeed*a;\n    float az = zSpeed*a;\n\n\tfloat cy = cos(ay);\n    float sy = sin(ay);\n\t//p.x = cy * q.x + sy * q.z;\n\t//p.z = -sy * q.x + cy * q.z;\n\n\tfloat cz = cos(az);\n    float sz = sin(az);\n\t//r.x = cz * p.x - sz * p.y;\n\t//r.y = sz * p.x + cz * p.y; =>\n\t//r.x = cz * (cy * q.x + sy * q.z) - sz * q.y;\n\t//r.y = sz * (cy * q.x + sy * q.z) + cz * q.y;\n    //r.z = -sy * q.x + cy * q.z;\n    \n    \n\tfloat cx = cos(ax);\n    float sx = sin(ax);\n\t//s.y = cx * r.y - sx * r.z;\n\t//s.z = sx * r.y + cx * r.z;=>\n\t//s.x = cz * (cy * q.x + sy * q.z) - sz * q.y;\n\t//s.y = cx * (sz * (cy * q.x + sy * q.z) + cz * q.y) - sx * (-sy * q.x + cy * q.z);\n\t//s.z = sx * (sz * (cy * q.x + sy * q.z) + cz * q.y) + cx * (-sy * q.x + cy * q.z);\n    \n\t//s.x = (cz*cy)*q.x          - sz*q.y    + (cz * sy) * q.z;\n\t//s.y = (cx*sz*cy+sx*sy)*q.x + cx*cz*q.y + (cx*sz*sy-sx*cy)*q.z;\n\t//s.z = (sx*sz*cy-cx*sy)*q.x + sx*cz*q.y + (sx*sz*sy-cx*cy)*q.z;\n    float sxsz = sx*sz;\n    float cxsz = cx*sz;\n    mat3 qtos = mat3(\n        cz*cy, (cxsz*cy+sx*sy), (sxsz*cy-cx*sy),\n        -sz,   cx*cz,            sx*cz,\n        cz*sy, (cxsz*sy-sx*cy), (sxsz*sy-cx*cy)\n    );\n    return qtos;\n\n}\n\nvec3 dirDist(float dir, float dist) {\n    return vec3(cos(dir)*dist,sin(dir)*dist,0.0);\n}\n// \"Converted\" from \"C++\" from here: https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\nfloat segment_distance_square(vec2 v, vec2 w, vec2 p) {\n  // Return minimum distance between line segment vw and point p\n    vec2 dvec = v-w;\n  float l2 = dot(dvec,dvec);  // i.e. |w-v|^2 -  avoid a sqrt\n  //if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  // We clamp t from [0,1] to handle points outside the segment vw.\n  float t = clamps(dot(p - v, w - v) / l2);\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  dvec = p- projection;\n  return dot(dvec,dvec);\n}\n\nfloat animation(vec2 uv, float time, float timeDelta) {\n    float circles_square = 1000.;\n    float prevtime = time - max(0., timeDelta-0.005 ); // 0.005 to reduce double drawing\n    mat3 rPrev = r(prevtime);\n    mat3 rCurr = r(time);\n    float DISTANCE = 0.2;\n    for (float k = 0.; k < DOTS; k++) {\n        float pointspeed = k*0.1;\n        float DIRECTION = time*pointspeed;\n        float PREVDIRECTION = prevtime*pointspeed;\n        vec3 POSITION = rCurr*dirDist(DIRECTION,DISTANCE);\n        vec3 PREVPOSITION = rPrev*dirDist(PREVDIRECTION,DISTANCE);\n        float segDist = segment_distance_square(PREVPOSITION.xy, POSITION.xy ,uv);\n        circles_square = min(circles_square, segDist );\n    }\n    float circles = clamps(1.0-sqrt(circles_square)*20.0);\n    return circles;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = uv-.5; suv.x /= iResolution.y/iResolution.x;\n    float time = iTime;\n    float timeDelta = iTimeDelta;\n    vec3 drawing = vec3(0.0);\n    if(0.25<uv.x && 0.75>uv.x && 0.20<uv.y && 0.80>uv.y)\n    {\n        drawing = \n            vec3(animation(suv, time, timeDelta));\n    }\n    \n    drawing = vec3(pow(drawing,vec3(2.5,1.8,1.)));\n\tfragColor = vec4(drawing,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvec2 circle(float a){return vec2(cos(a),sin(a));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 d = vec4(0);\n    vec2 p = circle((1.)*pi*1.);\n    p.x /= iResolution.x/iResolution.y;\n    d = max(d,texture(iChannel1,uv+(p*0.00001)));\n\n\tfragColor = pow(texture(iChannel0,uv),vec4(9.))+(clamps(d)*pow(0.00001,iTimeDelta));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define clamps(x) clamp(x,0.,1.)\n#define DOTS 7.\n\nfloat pi = 3.14159265358979323;\n\n\nconst float xSpeed = 0.52;\nconst float ySpeed = 1.1;\nconst float zSpeed = 2.15;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}