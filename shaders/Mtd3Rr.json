{
    "Shader": {
        "info": {
            "date": "1467768599",
            "description": "Test your SH16A entry in Shadertoy! The reference shader is in buffer A, and your shader goes in buffer B. The fraction of pixels that match is displayed, and you can also click to highlight differences. May not be reliable, double check with resemble.js!",
            "flags": 32,
            "hasliked": 0,
            "id": "Mtd3Rr",
            "likes": 2,
            "name": "SH16A Shader Comparator",
            "published": 3,
            "tags": [
                "comparison",
                "multipass",
                "parallel",
                "sh16a",
                "comparator"
            ],
            "usePreview": 0,
            "username": "fb39ca4",
            "viewed": 1098
        },
        "renderpass": [
            {
                "code": "//This is not an SH16A entry!\n\n/*\nBuffer A: Reference shader\nBuffer B: Paste your shader in here\nClick to highlight differences\nGreen: Fraction of pixels which match, x10000.\nCyan: Count of pixels which match.\nMagenta: Count of pixels which do not match.\nYellow: Total number of pixels in image\n*/\n\n//Uncomment this to look under the hood of the counting algorithm\n//#define SHOW_COUNT_BUFFER\n\n// Begin PrintDigit code from P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n//End PrintDigit code\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 texCoord = fragCoord / iResolution.xy;\n    vec3 reference = texture(iChannel0, texCoord).rgb;\n    vec3 test;\n    vec3 display = test = texture(iChannel1, texCoord).rgb;\n    #ifdef SHOW_COUNT_BUFFER\n    display = texture(iChannel2, texCoord).rgb;\n    #endif\n\tvec3 indicator = vec3(0,1,0);\n    vec3 color = any(greaterThanEqual(abs( floor(255.*clamp(reference.xyz,0.,1.))\n-floor(255.*clamp(test.xyz,0.,1.))).xyz, vec3(1.))) && all(greaterThan(iMouse.zw, vec2(0))) ? indicator : display;\n    vec4 stored = texture(iChannel2, vec2(.5 / iResolution.xy)) * 255.;\n    float total = dot(stored, vec4(1, 0x100, 0x10000, 0x1000000));\n    float match = total / (iResolution.x * iResolution.y);\n    color = mix(color, match > .99 ? vec3(0,1,0) : vec3(1,0,0), PrintValue(fragCoord, vec2(0.0, iResolution.y - 40.0), vec2(16.,30.), match * 10000., 4.0, 0.0));\n    color = mix(color, vec3(0,1,1), PrintValue(fragCoord, vec2(iResolution.x - 9. * 19.0, iResolution.y - 40.0), vec2(16.,30.), total, 9.0, 0.0));\n    color = mix(color, vec3(1,0,1), PrintValue(fragCoord, vec2(iResolution.x - 9. * 19.0, iResolution.y - 80.0), vec2(16.,30.), ceil(iResolution.x * iResolution.y - total), 9.0, 0.0));\n    color = mix(color, vec3(1,1,0), PrintValue(fragCoord, vec2(iResolution.x - 9. * 19.0, iResolution.y - 120.0), vec2(16.,30.), iResolution.x * iResolution.y, 9.0, 0.0));\n    \n    fragColor.rgb = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sdPlane( in vec3 p, in vec4 s )\n{\n\treturn p.y + s.w;\n}\n\nfloat sdSphere( in vec3 p, in float s )\n{\n    return sqrt(p.x*p.x+p.y*p.y+p.z*p.z)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nvec2 opU( in vec2 d1, in vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( sdPlane(pos,vec4(0.0,1.0,0.0,0.0)), 13.0 );\n\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.40,-2.0), 0.40 ), 0.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.25,-1.0), 0.25 ), 0.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.40, 0.0), 0.40 ), 1.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.25, 1.0), 0.25 ), 1.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-2.0,0.40, 2.0), 0.40 ), 2.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.25,-2.0), 0.25 ), 2.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.40,-1.0), 0.40 ), 3.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.25, 0.0), 0.25 ), 3.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.40, 1.0), 0.40 ), 4.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3(-1.0,0.25, 2.0), 0.25 ), 4.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.40,-2.0), 0.40 ), 5.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.25,-1.0), 0.25 ), 5.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.40, 0.0), 0.40 ), 6.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.25, 1.0), 0.25 ), 6.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 0.0,0.40, 2.0), 0.40 ), 7.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.25,-2.0), 0.25 ), 7.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.40,-1.0), 0.40 ), 8.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.25, 0.0), 0.25 ), 8.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.40, 1.0), 0.40 ), 9.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 1.0,0.25, 2.0), 0.25 ), 9.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.40,-2.0), 0.40 ), 10.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.25,-1.0), 0.25 ), 10.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.40, 0.0), 0.40 ), 11.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.25, 1.0), 0.25 ), 11.0 ) );\n    res = opU( res, vec2( sdSphere( pos-vec3( 2.0,0.40, 2.0), 0.40 ), 12.0 ) );\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n    float m = 0.0;\n    for( int i=0; i<=63; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<0.0 || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<0.0 || t>tmax ) break;\n        t += res.x;\n    }\n\n    if( t>tmax ) return 1.0;\n    return 0.0;\n}\n\nfloat calcOcclusionArlo( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-map( pos + h*dir ).x);\n    }\n    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) + rd.y*vec3(0.8,0.8,0.8);\n    vec2 res = castRay(ro,rd, 0.0, 20.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos );\n        vec3  ref = reflect( rd, nor );\n        float ang = 5.0*atan( pos.x, pos.z );\n        float coa = cos(ang);\n\n             if( m< 0.5 ) col = vec3(1.00, 0.00, 0.00);\n        else if( m< 1.5 ) col = vec3(0.92, 0.03, 0.06);\n        else if( m< 2.5 ) col = vec3(0.84, 0.06, 0.12);\n        else if( m< 3.5 ) col = vec3(0.76, 0.09, 0.18);\n        else if( m< 4.5 ) col = vec3(0.68, 0.12, 0.24);\n        else if( m< 5.5 ) col = vec3(0.60, 0.15, 0.30);\n        else if( m< 6.5 ) col = vec3(0.52, 0.18, 0.36);\n        else if( m< 7.5 ) col = vec3(0.44, 0.21, 0.42);\n        else if( m< 8.5 ) col = vec3(0.36, 0.24, 0.48);\n        else if( m< 9.5 ) col = vec3(0.28, 0.27, 0.54);\n        else if( m<10.5 ) col = vec3(0.20, 0.30, 0.60);\n        else if( m<11.5 ) col = vec3(0.12, 0.33, 0.66);\n        else if( m<12.5 ) col = vec3(0.04, 0.36, 0.72);\n\t\telse \n        {\n            if( mod( mod(floor(pos.x),2.0) + mod(floor(pos.z),2.0), 2.0 ) < 0.5 )\n            {\n                col = vec3(0.4, 0.4, 0.4);\n            }\n            else\n            {\n                col = vec3(0.5, 0.5, 0.5);\n                vec2 uv = 256.0*0.1*pos.xz;\n            \tcol *= texture( iChannel0, (floor(uv)+ 0.5)/256.0, -100.0 ).x;\n            }\n\n            if( max( abs(pos.x), abs(pos.z)) < 1.5 )\n            {\n                vec2 q = mod(pos.xz+0.5,1.0)-0.5;\n                col *= smoothstep( 0.0, 0.5, sqrt(q.x*q.x+q.y*q.y) );\n            }\n\n            col *= pow(abs(tan(ang)*coa),2.0) + pow(abs(coa),2.0);\n        }\n        \n\n        // lighitng        \n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = 0.5+0.5*nor.y; if( amb<0.0 ) amb=0.0; else if( amb>1.0 ) amb=1.0;\n        float dif = dot( normalize(nor), lig ); if( dif<0.0 ) dif=0.0; else if( dif>1.0 ) dif=1.0;\n\t\tfloat spe = pow(clamp( dot(normalize(ref), lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= shadow( pos, lig, 0.01, 2.5 );\n\n\t\tvec3 lin = vec3(0.0, 0.0, 0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n        lin += 0.50*amb*vec3(0.50,0.70,1.00);\n\t\tcol = col*lin;\n\t\tcol += 1.0*spe*dif*vec3(1.0,1.0,1.0);\n    }\n\n\treturn col;\n}\n\nvec3 cross_product( in vec3 a, in vec3 b )\n{\n    return vec3( a.y*b.z - a.z*b.y,\n                -a.x*b.z + a.z*b.x,\n                 a.x*b.y - a.y*b.x );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross_product(cw,cp) );\n\tvec3 cv = normalize( cross_product(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid almostMainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat time = 50.0;\n\n\t// camera\t\n\tvec3 ro = vec3( 3.0*cos(0.1*time), 2.0, 3.0*sin(0.1*time) );\n\tvec3 ta = vec3( 0.0, -0.2, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 6.283185 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.5) );\n    \n    fragColor=vec4( col, 1.0 );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float numTiles = 16.;\n\tfloat rangeStart = iResolution.x / numTiles * mod(float(iFrame), numTiles);\n\tfloat rangeEnd = iResolution.x / numTiles * (mod(float(iFrame), numTiles) + 1.);\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    if (fragCoord.x >= rangeStart && fragCoord.x < rangeEnd) almostMainImage(fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*fb39ca4's SH16A entry\n\n  This would have not been possible without support and collaboration from\n  coyote, P_Malin, knarkowicz, iq, Stubbe, reinder, and many others in the\n  Shadertoy community. Actually, this shader is P_Malin's and knarkowicz's\n  as well since we converged on the same thing with different variable\n  names. Best of luck to everyone competing in the next two weeks.\n*/\n\n#define V vec3(\n#define N normalize(V\n/*\np: Ray Position\nd: Ray Direction. Also temporarily used to calculate checkerboard.\nn: Normal\nc: (0,1,0) vector initially, then color\ng: iResolution initially, then Grid Position\nw: temporary for constructing camera matrix\no: Fragment Output Color. o.a used to calculate sphere color.\nr: Fragment Coordinate\n*/\nvoid mainImage(out vec4 o, vec2 r) {\n    //Initialize variables\n    vec3   p = V 2, .851, -2.87677), \n        c = V 1, 0, 0),\n        n = c,  \n        w = N.2 * n + p)),\n        d = N cross(w, n))),\n    //    g;\n    //d = w = mat3(d, cross(d, w), w) * N+vec2(960,540)-r,1080));    \n        g = iResolution;\n    d = w = mat3(d, cross(d, w), w) * N.5*g.xy-r, g.y));\n    //Raymarch\n    for (int i = 0; i < 128; i++) \n        g = clamp(ceil(p - .5), -2., 2.),\n        g.x = .4 - .3 * fract(o.a = g.y * 2.5 + g.z * .5),                      \n        p -= i == 63 ? \n            d = mod(p, 2.) - 1.,\n            c = p.x > .02 ?\n                n = N p - g)), \n        \t\tc + c + .02 * V-8, 3, 6) * V int(o.a + 6.))\n            :\n                V.0 < d.y * d.z ? \n                \t.8 \n                :\n                \ttexture( iChannel0, .1 * p.yz).r) * smoothstep(0., .5, length(p - sign(g - g * c))),\n            d = N-7, 6, 5)),\n            d * .01\n        : d * min(length(p - g) - g, p).x;\n    //Shading and output\n    o.rgb = sqrt(\n        dot(n, -d) * V.9<p.x ) * (\n            pow(max(dot(reflect(w, n), d), 0.), 16.) + \n            c * V.6,.51,.33)\n        )\n        + c * ++n.x * V.5,.7,1) / 8.\n    );\n}\n\n//Experimented with some code to set the normal on the outside of the ternary statement, but setting the color was shorter in the end\n/*n = N(p.y > .01 ?\n\tc = c + c + .02 * V(3,-8,6) * floor(o.a / 2. + 6.),\n\tp - g \n: (\n\tc = V(r.x * r.y > 0. ? .8 : texture( iChannel0, .1*p.xz).r) * smoothstep(0., .5, length((p - sign(g)).xz)),\n\tn\n)),*/\n\n//Before refactoring into 1 loop\n\n/*#define M ); for (int i = 0; i < 64; i++) g = clamp(ceil(p - .5), -2., 2.), g.y = .4 - .3 * fract(o.a = g.x * 2.5 + g.z * .5), p -= d * min(length(p - g) - g, p).y; o.grb\n\nvoid mainImage(out vec4 o, vec2 r) {\n    V p = V(.851,2,-2.87677), n = V(0,1,0), w= N(.2*n + p), c = N(cross(w, n)), g = iResolution, d; \n    d = w = mat3(c, cross(w, c), w) * N(V(r - g.xy / 2., g.y)\n    \n    M = mod(p, 2.) - 1.;\n    c = p.y > .01 ? n+n + (n = N(p - g), .02 * V(3,-8,6) * floor(o.a + 6.))\n        : V(o.y * o.z > 0. ? .8 : texture( iChannel0, .1*p.xz).r)\n    \t\t* smoothstep(0., .5, length(p - sign(g - g * n)));\n   \n    p -= .01 * (d = N(V(6, -7, 5))\n\n    M = sqrt(\n    \tdot(n, -d)*V(p.y>2.)*(\n            pow(max(dot(reflect(w, n), d), 0.),16.) + \n            c*V(.51,.6,.33)\n        )\n        + c * ++n.y * V(7,5,10) / 80.\n    );\n\n}*/\n\n              \n//This is what the shader looked like when I first wrote it, before the agressive minification.\n/*\nvec3 rayPos, rayDir, normal, gridPos, rayU, rayV, rayW, color;\nfloat ambient, diffuse, specular, paletteIdx;\n\nvoid rayMarch() {\n    for (int i = 0; i < 64; i++) {\n        gridPos = clamp(floor(rayPos + .5), -2., 2.);\n        gridPos.y = mod(gridPos.x + gridPos.z, 2.) < .5 ? .4 : .25;\n        rayPos += rayDir * min(length(rayPos - gridPos) - gridPos.y, rayPos.y);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    \n    fragCoord = 2. * fragCoord / iResolution.xy - 1.;\n    fragCoord.x *= iResolution.x / iResolution.y;\n    rayPos = vec3(3.*cos(5.), 2., 3.*sin(5.));\n    rayW = normalize(-vec3(0,.2,0)-rayPos);\n    rayU = normalize(cross(rayW, vec3(0,1,0)));\n    rayV = cross(rayU, rayW);\n    rayDir = mat3(rayU, rayV, rayW) * normalize(vec3(fragCoord, 2.));\n    rayMarch();\n    normal = rayPos.y > .001 ? normalize(rayPos - gridPos) : vec3(0,1,0);    \n    rayW = rayDir;\n    paletteIdx = floor(gridPos.x*2.5+gridPos.z*.5+6.);\n    color = mod(floor(rayPos.x)+floor(rayPos.z), 2.) < 0.5 ? vec3(.4) : .5*texture( iChannel0, .1*rayPos.xz + vec2(37,17)/256.).yyy;\n    color *= smoothstep(0., .5, length(rayPos.xz - clamp(gridPos.xz, -1., 1.)));\n    color = rayPos.y > .01 ? vec3(1.-paletteIdx*.08,paletteIdx*.03,paletteIdx*.06) : color;\n    rayDir = normalize(vec3(-.6, .7, -.5));\n    rayPos += .1 * rayDir;\n    rayMarch();\n    ambient = clamp(.5+.5*normal.y, 0., 1.);\n    diffuse = clamp(dot(normal, rayDir), 0., 1.) * float(rayPos.y > 2.5);\n    specular =  pow(clamp( dot(normalize(reflect(rayW, normal)), rayDir), 0.0, 1.0 ),16.0);\n    color = specular*diffuse + color*(1.2*diffuse*vec3(1,.85,.55)+.5*ambient*vec3(.5,.7,1));\n    fragColor.rgb = sqrt(color);\n}\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n/*MIT License\n\nCopyright (c) 2016 fb39ca4\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/*\nThis buffer counts the number of pixels that meet the condition in compare,\nand leaves the the total in the lower left corner of the buffer. Note it is\nan integer packed into RGBA8 format for compatibility with WebGL implementations\nthat do not use floating point textures.\n\nThe counting is incremental, taking up to 11 frames to complete at most\ncommon resolutions, so this cannot be used for comparing animations.\n*/\n\nvec4 getA(vec2 c) {\n\treturn texture(iChannel0, c / iChannelResolution[2].xy);\n}\n\nvec4 getB(vec2 c) {\n\treturn texture(iChannel1, c / iChannelResolution[2].xy);\n}\n\nvec4 getC(vec2 c) {\n\treturn c.x < iResolution.x && c.y < iResolution.y ? texture(iChannel2, c / iChannelResolution[2].xy) * 255. : vec4(0);\n}\n\nfloat compare(vec2 c) {\n\treturn float(all(lessThan(abs( floor(255.*clamp(getA(c).xyz,0.,1.)) -floor(255.*clamp(getB(c).xyz,0.,1.))).xyz, vec3(1.))));  \n}\n\nvec4 scale(vec4 a) {\n \treturn a / 255.;   \n}\n\nvec4 carry(vec4 a) {\n\ta.w = mod(a.w + floor(a.z / 256.), 256.);\n\ta.z = mod(a.z + floor(a.y / 256.), 256.);\n\ta.y = mod(a.y + floor(a.x / 256.), 256.);\n\ta.x = mod(a.x, 256.);\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = floor(fragCoord) + .5;\n    vec4 total = vec4(0);\n    total.x = compare(c);\n    float scale = 1.;\n    //This loop needs to run ceil(log2(max(iResolution.x, iResolution.y))) - 1 times.\n    //11 is sufficient for 4K resolution.\n    for (int i = 0; i < 11; i++) {\n\t\tscale *= 2.;\n        if (mod(c.x, scale) >= 1. || mod(c.y, scale) >= 1.) {\n        \tbreak;\n        }\n        total += getC(c + scale * vec2(0,.5))\n            + getC(c + scale * vec2(.5,0))\n            + getC(c + scale * vec2(.5,.5));\n        total = carry(total);\n\n    }\n    fragColor = total / 255.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}