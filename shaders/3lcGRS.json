{
    "Shader": {
        "info": {
            "date": "1576850648",
            "description": "Windy Afternoon is a raymarched scene I created to study and implement a few techniques.\n\nPlay with it enabling features such as AA, Volumetric Light and curtain translucency.",
            "flags": 32,
            "hasliked": 0,
            "id": "3lcGRS",
            "likes": 20,
            "name": "Windy Afternoon",
            "published": 3,
            "tags": [
                "raymarch",
                "window",
                "room",
                "mood"
            ],
            "usePreview": 0,
            "username": "crocidb",
            "viewed": 832
        },
        "renderpass": [
            {
                "code": "/* \n * Windy Afternoon is a raymarched scene I created to study and implement a few techniques.\n *\n * You can disable/enable BLOOM and GRAIN here, but refer to `Buffer A` for more experimental\n * effects such as Anti-Aliasing, Volumetric Light and Translucent Curtain. \n */\n\n// Comment these lines to disable the effect\n#define BLOOM\n#define GRAIN\n\n#define BLOOM_SAMPLES 7\nfloat threshold = 0.4;\n\nvec4 bloom(vec2 uv)\n{\n    vec4 bloom = vec4(0.0);\n    vec4 col = vec4(0.0);\n    \n    for (int x = -BLOOM_SAMPLES; x < BLOOM_SAMPLES; x++)\n    for (int y = -BLOOM_SAMPLES; y < BLOOM_SAMPLES; y++)\n    {\n        col = texture(iChannel0, uv + vec2(x, y) * vec2(.0019));\n        float val = ((0.3 * col.r) + (0.59 * col.g) + (0.11 * col.b));\n        if (val < threshold) col = vec4(0.0);\n        \n        bloom += col;\n    }\n    \n    bloom /= float((2 * BLOOM_SAMPLES) * (2 * BLOOM_SAMPLES));\n    \n    return bloom;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec4 color = texture(iChannel0, uv);\n#ifdef BLOOM\n    color += bloom(uv) * 0.7;\n#endif\n\n#ifdef GRAIN\n    vec2 guv = uv + noise(vec2(iTime)) + noise(vec2(uv));\n    float h = hash12(guv)*0.3+0.7;\n    color = color * mix(1.0, h, clamp(color.y, 0.7, 1.0));\n#endif\n    \n    // gamma\n    color.xyz = pow( color.xyz, vec3(0.785) );\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// SDF\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// SDF Operators\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n// Noise\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st)\n{\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    \n    float r = mix( mix( dot( random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return r * .5 + .5;\n}\n\nfloat fbm(vec2 st)\n{\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n// Noise and FBM (as seen on iq tutorials)\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/* \n * Some of the implementations for these techniques might be very naive, so that's why they're\n * very heavy, so please be careful, or it might crash WebGL.\n * \n * The ideal would be for it to run Antialiasing 3, activate Volumetric Light and Translucent\n * curtain, but it gets very slow. I'm accepting suggestions on how to make it better.\n */\n\n/* \n * Antialiasing: Any number above 1 will make it look much better, specially above 3.\n */\n#define AA 2\n\n/* \n * Volumetric Light: One of the most costing features here, but really adds something to the scene.\n * You can control how many steps the algorithm will make on VOLUMETRIC_STEPS below.\n */\n//#define VOLUMETRIC_ACTIVE\n\n/*\n * Translucent Curtain: To emulate the translucency of the curtain, I'm dropping some of its pixels.\n * The problem with that approach is that I introduced conditions for the dropped pixels, what makes\n * it very slow. Also, it will only look good enough if combined with AA >= 3.\n * I could implement another pass of rays and rendering on the back of curtain to blend with its colors,\n * but honestly I don't know if that would be any better.\n */\n#define TRANSLUCENT_CURTAIN\n\n/*\n * Frame: disable this and you'll get a mouse freelook at the scene. Nothing really \n * interesting out of frame though.\n */\n#define FRAME\n\n\n#define VOLUMETRIC_STEPS\t16\n\n\n#define ZERO (min(iFrame,0))\n#define MAX_STEPS\t\t\t150\n#define MAX_DIST\t\t\t18.0\n#define SURFACE_DIST\t\t0.006\n\n\nvec3 light_pos = vec3(-7.0, 6.5, 12.0);\nvec3 ro = vec3(0.0, 2.8, 2.0);\n\nfloat oTime;\n\nvec2 closest(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p)\n{\n    // wall\n    vec3 wp = vec3(5.0, 0.0, 0.0);\n    vec3 ws = vec3(.2, 5.0, 5.0);\n    float w = sdBox(abs(p) - wp, ws);\n    w = min(w, sdBox(abs(p) - wp.zyx, ws.zyx));\n    //w = min(w, sdBox(p - vec3(0.0, 4.4, 0.0), vec3(5.0, 0.2, 5.0))); // Ceiling\n\n    w = opSmoothSubtraction(sdBox(p - vec3(2.0, 2.6, 5.0), vec3(0.8, 1.1, 1.0)), w, .03);\n    vec2 wall = vec2(w, 1.0);\n    \n    // window\n    float wi = sdBox(abs(abs(p) - vec3(1.95, 2.6, 4.95)) - vec3(0.78, 0.0, 0.0), vec3(0.05, 1.1, 0.19));\n    wi = min(wi, sdBox(p - vec3(1.95, 1.5, 4.9), vec3(1.0, 0.1, 0.4))) - .02;\n    \n    wi = min(wi, sdBox(p - vec3(1.95, 2.6, 4.9), vec3(0.8, 0.07, 0.07)));\n\twi = min(wi, sdBox(p - vec3(2.65, 3.2, 4.9), vec3(0.07, 0.57, 0.07)));\n    \n    wi = min(wi, sdBox(p - vec3(1.95, 3.15, 4.9), vec3(0.8, 0.02, 0.02)));\n    \n    wi = min(wi, sdBox(p - vec3(2.12, 3.2, 4.9), vec3(0.02, 0.57, 0.02)));\n    wi = min(wi, sdBox(p - vec3(1.7, 3.2, 4.9), vec3(0.02, 0.57, 0.02)));\n    \n    // floor wooden things\n    wi = min(wi, sdBox(p - vec3(1.95, 0.0, 4.92), vec3(3.0, 0.13, 0.17)));\n    wi = min(wi, sdBox(p - vec3(4.92, 0.0, 1.9), vec3(0.17, 0.13, 3.0)));\n    \n    vec2 window = vec2(wi - 0.01, 3.0);\n    \n    // curtains\n    float c = MAX_DIST + 1.0;\n#ifdef TRANSLUCENT_CURTAIN\n    if (int(p.x * 10000.0) % 100 != 0 && int(p.y * 10000.0) % 100 != 0)\n#endif\n    {\n        \n    \tvec3 cp = p - vec3(1.31, 3.0, 4.68);\n        cp -= vec3(0.0, 0.01 + sin(p.x * 10.0 + iTime) * .02, 0.024) * sin(p.x * 15.0 + oTime * .5) * noise(p.xy * 2.5 + oTime) * 2.5;\n        //cp += vec3(0.0, 0.0, 0.02) * (pow((4.3 - p.y) * 0.9, 4.1)) * .01;\n        cp -= vec3(-0.01, 0.0, 0.036) * sin(p.y * 6.0 + oTime * 1.4) * (pow((4.8 - p.y) * 0.9, 4.1)) * .06;\n        //cp += noise(p.xy * 2.0 + oTime) * .09 * (1.3 - p.x) / 0.6;\n        //cp += abs(noise(p.xy * 1.0 + oTime) * 0.14 * (3.0 - p.y) / 1.0) * vec3(1.0, 1.0, 0.0);\n        c = sdBox(cp, vec3(0.62, 1.0, 0.015)) - .050;\n    }\n    vec2 curtain = vec2(c, 4.0);\n    \n    // tree trunk\n    vec3 ttp = p - vec3(-2.10, 2.0, 8.0);\n    ttp.xy += pow((ttp.y + 2.9), 4.6) * -.0001 * (sin(noise(vec2(oTime * 0.442, oTime * .552))) + 1.0);\n    float tt = sdCappedCylinder(ttp, 0.02, 3.0);\n    \n    // floor\n    float f = dot(p, vec3(0.0, 1.0, 0.0));\n    vec2 flo = vec2(min(f, tt), 2.0);\n    \n    return closest(closest(closest(wall, flo), window), curtain);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e).x;\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec3 p;\n    vec2 obj;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = ro + t * rd;\n       \t\n        obj = map(p);\n        \n        if (obj.x < SURFACE_DIST || t > MAX_DIST) break;\n        \n        t += obj.x;\n    }\n    \n    obj.x = t;\n    return obj;\n}\n\n// Lighting\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.002f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec2 obj = map(p + n * t);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 2.2) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nfloat getVisibility(vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < MAX_DIST)\n\t{\n\t\tvec2 o = map(p0 + rd * t);\n\n\t\tif(o.x < SURFACE_DIST)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\n\t\tt += o.x;\n\t}\n\n\treturn f;\n}\n\nvec3 volumetricLight(vec3 p, vec3 ro, vec3 rd, vec2 uv)\n{\n#ifdef VOLUMETRIC_ACTIVE\n    vec3 col = vec3(0.0);\n    float val = 0.0;\n    \n   \tp -= rd * noise(9090.0*uv) * 0.6;\n    vec3 s = -rd * 2.2 / float(VOLUMETRIC_STEPS);\n    \n    for (int i = 0; i < VOLUMETRIC_STEPS; i++)\n    {\n        float v = getVisibility(p, light_pos, 250.0) * .015;\n        p += s;\n        float t = exp(p.z - 3.0);\n        val += v * t;\n    }  \n    \n    return vec3(min(val, .8));\n#else\n    return vec3(0.0);\n#endif\n}\n\n// Texturing\nvec2 triplanar(vec3 p, vec3 normal)\n{\n    if (abs(dot(normal, vec3(0.0, 1.0, 0.0))) > .8)\n    {\n        return p.xz;\n    }\n    else if (abs(dot(normal, vec3(1.0, 0.0, 0.0))) > .8)\n    {\n        return p.yz;\n    }\n    else\n    {\n        return p.xy;\n    }\n}\n\nvec3 textureWood(vec2 uv)\n{\n    uv.x *= .6;\n    \n    float no = noise(vec2(1.2, 2.4) + uv * 6.);\n\n    float n0 = .6 + .4 * smoothstep(\n        .24,\n        0.55,\n        fbm(vec2(uv.x * 10., uv.y * 30.) + vec2(15.0, 10.0)));\n    uv += no;\n    float n1 = fbm(vec2(uv.x * 5., uv.y * 20.) + vec2(2.0, 2.0));\n    float n2 = smoothstep(\n        1.0,\n        0.3,\n        fbm(vec2(uv.x * 1., uv.y * 10.)));\n    \n    vec3 col = n0 * n1 * n2 * vec3(1.92, 1.4, 1.15);\n    return pow(col, vec3(2.1));\n}\n\nvec3 textureWall(vec2 uv)\n{\n    vec2 iuv = floor(uv * 10.0);\n    vec3 col = clamp(smoothstep(0.14, 0.65, noise(uv * 10.4) * fbm(uv * 18.0)) + .9, 0.0, 1.0) * vec3(0.5);\n    return col;\n}\n\nvec3 textureFloor(vec2 uv)\n{\n    vec2 iuv = floor(uv * 10.0);\n    float v = float(mod(iuv.x + iuv.y, 2.0) <= 0.01);\n    vec3 col = vec3(0.4 + 0.5 * v) * fbm(uv * 15.5) * vec3(0.75, 0.68, 0.591);\n    return col;\n}\n\n\n// Renderer\nvec3 render(vec2 obj, vec3 p, vec3 rd, vec2 uv)\n{\n    vec3 col;\n    \n    vec3 normal = calcNormal(p);\n    float fog;\n    \n    if (obj.x >= MAX_DIST)\n    {\n        col = vec3(1.0, 0.6, 0.4) * (uv.y + .6);\n    }\n    else\n    {\n        float diffuse = dot(normalize(light_pos - p), normal);\n        fog = pow((obj.x / MAX_DIST), 8.3);\n        float aa = ambientOcclusion(p, normal);\n        float shadow = getVisibility(p, light_pos, 240.0);\n        \n        if (obj.y >= 4.0) // Curtain\n        {\n            vec2 uv = triplanar(p, normal) * 9.0;\n            vec3 t = textureFloor(uv) * vec3(0.85, 0.37, 0.631);\n            \n            float d = min(abs(dot(-normalize(light_pos - p), normal)), 0.7) * 0.8;\n            \n            col = t * smoothstep(0.1, 1.0, aa) * 1.5;\n            col *=  (p.x - 1.2);\n            col += d * t;\n            col += shadow * vec3(0.3, 0.2, 0.1);\n        }\n        else if (obj.y >= 3.0) // Window wood\n        {\n            vec2 uv = triplanar(p, normal) * 0.8;\n            vec3 t = textureWood(uv) * 1.1;\n            \n            col = t * aa * .2;\n            col += diffuse * t * shadow;\n            col += shadow * vec3(0.3, 0.2, 0.1);\n            \n            col += volumetricLight(p, ro, rd, uv) * vec3(1.0, 0.95, 0.8) * .4;\n        }\n        else if (obj.y >= 2.0) // Floor\n        {\n            if (p.z > 6.0)\n            {\n                vec2 uv = triplanar(p, normal) * 8.168 + 1.1;\n                vec3 t = textureFloor(uv) * .7;\n                \n                col = vec3(0.12, 0.16, 0.04) * 26.0 * t;\n            }\n            else\n            {\n                vec2 uv = triplanar(p, normal) * 0.168 + 1.1;\n                vec3 t = textureFloor(uv) * .7;\n\n                col = t;\n                col += diffuse * t * shadow;\n                col += shadow * vec3(0.3, 0.2, 0.1);\n                col *= aa * aa;\n            }\n        }\n        else if (obj.y >= 1.0) // Walls\n        {\n            vec2 uv = triplanar(p, normal) * 3.0;\n            \n            uv = mod(uv * 0.02 + 0.5, 1.0);\n            vec3 t = textureWall(uv) * vec3(0.905, 0.854, 0.684);\n            \n            col = t * aa * .5;\n            col += diffuse * t * shadow;\n            col += shadow * vec3(0.3, 0.22, 0.16) * 2.0;\n            col *= aa;\n            \n            col += volumetricLight(p, ro, rd, uv) * vec3(1.0, 0.95, 0.8);\n        }\n    }\n    \n    return mix(col, vec3(1.0, 0.6, 0.4) * (uv.y + .6), fog);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    oTime = iTime * 2.0;\n#ifdef FRAME\n    vec3 ta = vec3(1.3, 2.4 + sin(oTime * .3) * .08, 2.9 + cos(oTime * .2) * .06);\n#else    \n    float d = 1.0;\n    float v = ((iMouse.x / iResolution.x) - .5) * -5.;\n    vec3 ta = ro + vec3(sin(v) * d, clamp((iMouse.y / iResolution.y) - .5, -0.5, 0.5), cos(v) * d);\n#endif\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for(int m=ZERO; m<AA; m++)\n    for(int n=ZERO; n<AA; n++)\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else    \n    \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif       \n        // Ray direction\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n        vec3 vv = normalize(cross(uu, ww));\n        \n        vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.3 * ww);\n        \n        // render\t\n        vec2 obj = rayMarch(ro, rd);\n        vec3 p = ro + obj.x * rd;\n    \n   \t\tvec3 col = render(obj, p, rd, uv);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n        \n\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}