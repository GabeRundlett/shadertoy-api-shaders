{
    "Shader": {
        "info": {
            "date": "1462968272",
            "description": "Stochastic multipass renderer for arbitrary malformed distance fields.\nUse mouse to change position. (when changing to fullscreen, drag mouse to restart)\nUse patience to complete the render.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XdKXzh",
            "likes": 9,
            "name": "Any DE",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "distancefield",
                "ray",
                "iterative",
                "stochastic",
                "multipass"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 974
        },
        "renderpass": [
            {
                "code": "/* https://www.shadertoy.com/view/XdKXzh\n * Stochastic multipass renderer for arbitrary malformed distance fields.\n * (cc) 2016, Stefan Berke\n *\n * No raytracing, no raymarching, no fudging. \n * Just random sampling, which completely ignores the gradient of the distance field.\n * Means, the common DE() function is only used to find the surface point at 0.0,\n * all estimates of a distance to this surface are discarded.\n *\n * Pixels in the renderbuffer contain the current surface normal (xyz) \n * and distance between camera and surface (w) in range [0,1]. \n * Each frame, a point between 0.0 and previous-distance is sampled,\n * with a tendency to sample closer to the previous-distance.\n * Eventually the closest point to the camera is found.\n * Can take a couple of minutes for all noise artifacts to disappear.\n * \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec4 c = texture(iChannel0, uv);\n    vec3 n = c.xyz;\n\n    // color from normal\n    vec3 col = vec3(.3+.2*n);\n\t\n    // some lighting\n    float a = iTime / 3.;\n    float d = max(0., dot(n, normalize(vec3(sin(a),cos(a),-2))));\n    col += .7 * pow(d,2.);  \n    \n    a = iTime * .26;\n    vec3 lightpos = .1*vec3(sin(a),cos(a*.618),.1);\n    d = max(0., dot(n, normalize(lightpos)));\n    col += 1.7 * pow(d,4.);  \n    \n    // distance attenuation\n    float dist = 1.-pow(1.-c.w,11.);\n    col = mix(col, vec3(0), dist);\n    \n    col = pow(col, vec3(1./2.));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* https://www.shadertoy.com/view/XdKXzh\n * Stochastic multipass renderer for arbitrary malformed distance fields.\n * (cc) 2016, Stefan Berke\n *\n * No raytracing, no raymarching, no fudging. \n * Just random sampling, which completely ignores the gradient of the distance field.\n * Means, the common DE() function is only used to find the surface point at 0.0,\n * all estimates of a distance to this surface are discarded.\n *\n * Pixels in the renderbuffer contain the current surface normal (xyz) \n * and distance between camera and surface (w) in range [0,1]. \n * Each frame, a point between 0.0 and previous-distance is sampled,\n * with a tendency to sample closer to the previous-distance.\n * Eventually the closest point to the camera is found.\n * Can take a couple of minutes for all noise artifacts to disappear.\n * \n */\n\n// maximum distance to render\nconst float max_t = 5.5;\n\n// The Kaliset as notoriously-hard-to-render-example\nfloat kali(in vec3 uvw);\n\n// PLUG YOUR DISTANCE ESTIMATION HERE\nfloat DE(in vec3 p)\n{\n    return kali(p);\n}\n\n// Determines inside (true) or outside of DE value\nbool DE_inside(in float d)\n{\n    return d <= 0.; // for signed DFs\n    //return d <= 0.001; // for unsigned DFs\n}\n\n// Classic DE gradient for surface normal \nvec3 DE_norm(in vec3 p)\n{\n    vec2 e = vec2(0.0001,0.);\n    return normalize(vec3(\n        DE(p + e.xyy) - DE(p - e.xyy),\n        DE(p + e.yxy) - DE(p - e.yxy),\n        DE(p + e.yyx) - DE(p - e.yyx)));\n}\n\n\n\nfloat kali(in vec3 uvw)\n{\n    vec3 av = vec3(0.), dif = av;\n    \n    vec3 p = uvw, prevp;\n    const int num = 11;\n    for (int i=0; i<num; ++i)\n    {\n        p = abs(p) / dot(p,p);\n\n        // sample average and average change\n        av += p;        \n        if (i > 0)\n        \tdif += abs(p-prevp);\n        prevp = p;\n        \n        // magic param\n        if (i < num-1)\n        \tp -= vec3(.7);\n    }\n    av /= float(num);\n    dif / float(num);\n\n    // return 'something'\n    return dif.x-dif.y+5.;\n}\n\n\n\n// -------- renderer ----------\n\nfloat pixhash(in vec2 p) { return fract(sin(p.x*3.+p.y*1.618)*(7713.+p.x-p.y)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * 2.;\n\n    // ray direction\n    vec3 rd = normalize(vec3(uv,1.5-.5*length(uv)));\n\n    // mouse xy\n    vec2 ofs = iMouse.xy/iResolution.xy-.5;\n    // sort of anti-aliasing\n    ofs += pixhash(fragCoord*.9+cos(iDate.wz)) / iResolution.xy;\n    // ray origin\n\tvec3 ro = vec3(ofs,-2.3);\n    \n    // previous color and distance\n    vec4 pix = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    // closest distance in neighbourhood\n    float nMinDist = \n        min(texture(iChannel0, (fragCoord.xy+vec2(-1,-1)) / iResolution.xy).w,\n    \tmin(texture(iChannel0, (fragCoord.xy+vec2( 1,-1)) / iResolution.xy).w,\n        min(texture(iChannel0, (fragCoord.xy+vec2( 1, 1)) / iResolution.xy).w,\n            texture(iChannel0, (fragCoord.xy+vec2(-1, 1)) / iResolution.xy).w)));\n     \n    // reset rendering on mouse-move\n    if (iMouse.z > .5 || iFrame == 0)\n    {\n        pix = vec4(0,0,0,1);\n    }\n    float minDist = pix.w;\n    \n    // sometimes use neighbour distance for evaluation\n    // which helps to find edges and tiny things faster\n    float curMinDist = pixhash(fragCoord*1.1+sin(iDate.wz)) > .9 ? nMinDist*1.1 : minDist;\n    \n    // check point at current minDist minus random-value\n    float depth = pixhash(fragCoord + sin(iDate.zw));\n\tdepth = max(0., curMinDist-pow(depth,11.));\n    \n    // evaluate DE\n    float t   = max_t * depth;    \n    vec3  p   = ro + t * rd;\n    float d   = DE(p);\n    bool  hit = DE_inside(d);\n    \n    // store found surface normal and distance\n    if (hit && depth <= minDist)\n    {\n    \tminDist = depth;\n\t    pix.xyz = DE_norm(p);\n    }\n    \n\tfragColor = vec4(pix.xyz, minDist);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}