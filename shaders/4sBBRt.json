{
    "Shader": {
        "info": {
            "date": "1501596796",
            "description": "bisymmetry envelopes\n\nis a generalization of\nhttps://www.shadertoy.com/view/Ml3fWj",
            "flags": 0,
            "hasliked": 0,
            "id": "4sBBRt",
            "likes": 0,
            "name": "mStretch bisymmetry context",
            "published": 3,
            "tags": [
                "mouse",
                "envelope",
                "modulation",
                "bisymmetry",
                "modem",
                "context"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "/*\nthe BISYMETRY PRINCIPLE:\n- utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - In a quest to increase symmetry for performance and modular shaders.\n- Only write atomic special cases and transformations, \n- ...to construct general functions from.\n- Instead of writing a general function, \n- ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- this way general functions can be made into special \"shortcut\" functions more easily.\n- this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- this whole structure screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this structure more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\"\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n\n------------\n\n[envelope]s and [window function]s and [Passband]s are pretty much mean the same to me now.\ni just lack a noun for min||max([window function],[envelope]) that is not [MoDem] or [context]\nhttps://en.wikipedia.org/wiki/Context_(computing)\nhttps://en.wikipedia.org/wiki/Modulation\nFor a lack of a better term, the terms I use are knowinggly fuzzy.\n\nthey come down to y=f(x) that often are only, or especially \n...focused on (inout) ranges [-.5..+.5] to [-3.14..+3.14]\n...while their parameters (like uv or scaling) are any range.\n\n[window function]s \n- tend to have smoother derivatives, nicer Local Lipschitz Constants. they include \n- https://en.wikipedia.org/wiki/Window_function\n[envelope]s tend to be more symmetric and opften less less continuous. they include \n- https://en.wikipedia.org/wiki/Envelope_(waves)\n- where continuity is easily broken due to Fourier Transform (of a square,triangle,seesaw wave)\n-\n- means envelopeD(log(envelopeE())), for lack of a better term.\n- ... where envelopeA()=envelopeB(envelopeC())\n- does not mean \n- https://en.wikipedia.org/wiki/Envelope_(mathematics)\n*/\n\n/*\nnotes to self, for improvement:\nuse #define to take a domain (x,y, z or w) as function parameter \nyour #define basically defines patterns over single domains, \nand their context lies on how these \n#defines are utilized min() mic() smin() swiveled or otherwise transformed.\n\n\nthe comments of\nhttps://www.shadertoy.com/view/MdSfzt\nare all about \n- line breaks in a define\n- using a buffer texture and a single define to display a string.\nthis is a current process...\n*/\n\n//sharpness of FullScreenAntiAliasing\n#define fsaa 5./iResolution.y\n//maximum view zoom\n#define viewZoom 20.\n\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n#define mainImage(o,u)o=vec4(co(u),1.);\n\n//3.14=ratio of unitCircleCircumference to diameter=\n#define pi acos(-1.)\n//0.61=golden ratio; phi-1=1/phi,smaller solution\n#define phi (sqrt(5.)*.5-.5)\n//1.61=Golden Ratio; Phi-1=1/Phi,larger  solution\n#define Phi (sqrt(5.)*.5+.5)\n\n//modulo tiled grid.\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));                   \n u.x*=u.x;return u.x*u.x;}\n\nfloat sawCos(vec2 u){//u*=2.;//sale here, or better outside of this function.\n u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c) with a hint of s, diminishing over c.\n#define sci() mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//use a matrix as if it is a list.\nfloat gm3(mat3 a,int n){return a[n/3][n%3];}\n//return a[int(n/3.)][int(mod(n,3.))];}//float variant\n#define gp(a) gm3(co,a)\n\n//vector dotproduct with vecN(1) is a faster sum.\n//float sum(float a,float b,float c,float d){return dot(vec4(a,b,c,d),vec4(1.));}\n//float sum(float a,float b,float c){return dot(vec3(a,b,c),vec3(1.));}\n\n/*\n//just some demo y=f(x) functions\nfloat fx(vec2 u,vec2 m){\n float x=u.x;\n float logE = log(x);\n float expE = exp(x);\n float pow3 = (x*1.)*(x*x);\n float pow4 = (x*x )*(x*x);\n mat3 co=mat3(-10,8,-6,5,-6,4,-7,-2,1);//9 coeficients to a polynomial should be enough\n //co=1.co; //reciprocal coeficcients\n //co*=.1;//smaller coefficients\n //float polyn=x*gm3(co,0)-u.y;\n   \n float polyn=x*(gp(0)+x*(x*(gp(1)+x*(x*(gp(2)+x*(x*(gp(3)+x*gp(4)+x*(gp(5)))))))));\n float cosine=cos(x*.1)*10.;//a large amplitude large interval cosine.\n x*=.1;\n float fourier=cos(x*gp(0))\n              +cos(x*gp(1)*2.)\n              +cos(x*gp(2)*3.)\n              +cos(x*gp(3)*5.)\n              +cos(x*gp(4)*7.)\n              +cos(x*gp(5)*13.);//cosines, scaled by primes.\n    \n //return fourier;\n \n //return cosine;\n //return logE; //makes negative blue green, i see no way to cath this NaN\n return fourier+cosine+x*x;\n}\n/**/\n\n//m.y sets zoom (makes sense for waveforms)\n//length sets zoom\n//#define scaledot(u) length(m)*u\n//length*length sets zoom, for EXTREME zoom out\n//#define scaledot(u) dot(m,m)*u\n//near main axes, zoom in\n//#define scaledot(u) min(abs(m.x),abs(m.y)   )*u\n//mix of axial distances sets zoom\n//#define scaledot(u) mix(abs(m.x),abs(m.y),.5)*u\n#define scaledot(u) u=min(abs(m.x),abs(m.y))*u\n\n\nfloat mStretch(vec2 u,vec2 m){\n float b=.5*sign(u.x)*m.x;\n float c=(sign(abs(u.x)-m.x));\n u.x*=-.5;\n return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x;\n //if(abs(u.x)>m.x)return -u.x+m.x*sign(u.x);return 0.; //branching variant can be faster\n}\n//#define mStretch(v,m) mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n\nfloat mouseNeg(float c,float m){return sign(c)*min(m,abs(c));}\n//mix c and m where m is a disturbing distance field [m]  as \"mouse pointer\" in field [c]\nfloat mouseDif(float c,float m){//return sign(c)*max(-sign(c)*c,m);//alternative to below\n //return min(c*sign(m),m);//shorter variant of below\n float s=sign(m)*c;m-=s;return s+.5*(m-abs(m));}\n\nvec3 co(vec2 u){\n vec4 m=vec4(fr(iMouse.xy),fr(iMouse.zw));u=fr(u);//put vec2(0) in the center of the view, adjust for aspect ratio.\n if(m.w<=0.){m.xy=vec2(3,2)+viewZoom*.3*vec2(cos(iTime)*Phi,sin(iTime*.61));} //if(mouse up) autoMouse\n //   else m=fr(iMouse.xy);\n //scaledot(u);scaledot(m);//scale view, depending on m\n //u+=m;m+=m;//move view center away from vec2(0)\n vec3 c;//color composition\n c.r=mStretch(u,m.xy)+u.y;//distance field at u, set by parameters m\n \n \n float d=sin(iTime)*.5+.5;\n //if (sign(c.r)>sign(cur))c.r=-c.r;\n float mo=length(u-m.zw);//distance to mouse cursor\n float e=length(u-m.zw)-1.;//distance to where mouse was pushed down\n c.r=min(c.r,e);\n    \n      \n //c.r=mouseDif(c.r,mo);\n //c.r=mouseNeg(c.r,mo);\n //c.r=mouseDif(mouseNeg(c.r,mo),mo);\n //c.r=mouseNeg(mouseDif(c.r,mo),mo);\n //c.r=mix(mouseDif(c.r,mo),mouseNeg(c.r,mo),.5);\n c.gb=u; \n c=sawCos3(c,.9);//smoothest gradient visualization so far\n c.gb+=vec2(sawCos(length(u),.5)*.003);//show circles around (0,0)\n \n //the color mix below usually looks nice, \n //but hues cyclically bleed into another, causing some optical illusions if one domain is very low\n //it also means if any domain is NaN, it becomes 0.\n if(isnan(c.r))c.r=0.;//projecting NaN to 0.\n if(isnan(c.b))c.b=0.;//projecting NaN to 0.\n if(isnan(c.g))c.g=0.;//projecting NaN to 0.\n c=sqrt(c);//more evenly gamma correcting\n c=max(vec3(0),c);\n return c*.5+c.yzx*.25;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}