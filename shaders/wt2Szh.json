{
    "Shader": {
        "info": {
            "date": "1565093577",
            "description": "Ellipse normals and tangents, ellipses and their opposites, are all connected by straight edges and parallel lines.",
            "flags": 0,
            "hasliked": 0,
            "id": "wt2Szh",
            "likes": 2,
            "name": "Ellipse Normals in relation",
            "published": 3,
            "tags": [
                "normal",
                "ellipse",
                "tangent"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 435
        },
        "renderpass": [
            {
                "code": "// Ellipse Normals in relation\n// Timo Kinnunen 2019\n//\n// Exploring the relations between normal vectors 90 degrees apart on an ellipse and its opposite.\n//\n// Based on More Accurate Ellipse Normal @ https://www.shadertoy.com/view/3s23zz by scratch13764\n#define H .8\n#define W .5\n\nfloat ifLE(float a, float b, float eps) {\n    //if (a <= b) return 1.; else return 0.;\n    //return float(a <= b);\n    //return float(a - b <= .0);\n    //return float(b - a >= .0);\n    //return step(.0,b - a);\n    return smoothstep(.0,eps,b - a);\n}\nfloat Ellipse (vec2 p, float w, float h)\n{\n    //if (length(vec2(p.x/w,p.y/h)) <= .5) return 1.; else return 0.;\n    //return float(length(vec2(p.x/w,p.y/h)) <= .5);\n    //return float(length(vec2(p.x/w,p.y/h)) - .5 <= .0);\n    //return float(.5 - length(vec2(p.x/w,p.y/h)) >= .0);\n    //return step(.0,.5 - length(vec2(p.x/w,p.y/h)));\n    //return ifLE(length(vec2(p.x/w,p.y/h)),.5,.005);\n    float a = length(vec2(p.x/w,p.y/h));\n    float b = .5;\n    float eps = .005;\n    //return ifLE(a,b,eps);\n    eps *= 450./iResolution.y;\n    return ifLE(a,b+0.5*eps,eps);\n}\nfloat ifLE(float a, float b) {\n    //return ifLE(a,b,0.00000005*b);\n    //return ifLE(a,1.00000005*b,0.00000005*b);\n    //return ifLE(a,1.05*b,0.05*b);\n    //return ifLE(a,1.5*b,0.5*b);\n    //return ifLE(a,1.000000025*b,0.000000050*b);\n    //return ifLE(a,1.025*b,0.050*b);\n    //return ifLE(a,1.25*b,0.50*b);\n    float eps = 0.50*b;\n    eps *= 450./iResolution.y;\n    return ifLE(a,b+0.5*eps,eps);\n}\n\nvec2 EllipsePoint (float t, float w, float h) //Point on an ellipse at a certain angle, stretched circle\n{\n    return vec2(sin(t)*w / 2., cos(t)*h / 2.);\n}\n\nfloat sdLine( vec2 p, vec2 a, vec2 b ) //Line segment SDF made by Inigo Quilez (Thanks!)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\nfloat bump(float x) { return clamp(min(x,4.-x),0.,1.); }\nfloat act(float x, float which, float total) { return bump(mod(x-4.*which,4.*total)); }\nvoid mainImage( out vec4 u, in vec2 o )\n{\n    vec2 p = (o - .5*iResolution.xy)/iResolution.y;\n    vec4 col = vec4(.5);\n    \n    float pw = .2;\n    \n    col = mix (col, vec4(.8), Ellipse (p, W + pw, H + pw));\n    col = mix (col, vec4(.7), Ellipse (p, H, W) * .5);\n    col = mix (col, vec4(1.), Ellipse (p, W, H));\n    col = mix (col, vec4(.7), Ellipse (p, H, W) * .25);\n    \n    //Ellipse Normal Calculations and drawing\n    float t1 = (iTime / 15.) * radians(360.);\n    float t2 = t1 + radians(90.);\n    vec2 j = EllipsePoint (t1, W + pw, H + pw);\n    vec2 k = EllipsePoint (t1, H + pw, W + pw);\n    vec2 l = EllipsePoint (t2, W + pw, H + pw);\n    vec2 a = EllipsePoint (t1, W, H);\n    vec2 b = EllipsePoint (t1, H, W);\n    vec2 c = EllipsePoint (t2, W, H);\n    vec2 d = EllipsePoint (t2, H, W);\n    vec2 nk = normalize(k)*.1;\n    vec2 nl = normalize(l)*.1;\n    vec2 na = normalize(a)*.1;\n    vec2 nb = normalize(b)*.1;\n    vec2 nc = normalize(c)*.1;\n    vec2 nd = normalize(d)*.1;\n    \n    float total = 4.;\n    float ref = iTime/2.;\n    float act1 = 1.-act(ref,3.,total);\n    //float act2 = 1.-act(ref,2.,total);\n    float act3 = 1.-act(ref,1.,total);\n    float act4 = 5.*act(ref,2.,total);\n    \n    col = mix(col, vec4(1,1,0,0), ifLE( sdLine(p, a+(j-a-nl)*act1, a+(j-a+nl)*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,1,1,0), ifLE( sdLine(p, a+(j-a   )*act1, a+(j-a+nk)*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,1,1,0), ifLE( sdLine(p, a+(j-a   )*act1, a  ), .005)*.5*act1);//better incorrect normal\n    col = mix(col, vec4(1,0,0,0), ifLE( sdLine(p, a*act3   , a+na*act1), .005)*.5*act1);//bad stretched circle normal\n    col = mix(col, vec4(0,0,0,0), ifLE( sdLine(p, a-nb*act4, a+nb     ), .005)*.5     );//Correct normal - thanks IQ!\n    col = mix(col, vec4(0,1,0,0), ifLE( sdLine(p, a-nc     , a+nc     ), .005)*.5     );\n    col = mix(col, vec4(0,0,1,0), ifLE( sdLine(p, a-0.     , a+nd*act1), .005)*.5*act1);\n    col = mix(col, vec4(1,0,0,0), ifLE( sdLine(p, b-na*act4, b+na     ), .005)*.5     );\n    col = mix(col, vec4(0,0,0,0), ifLE( sdLine(p, b*act3   , b+nb*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,1,0,0), ifLE( sdLine(p, b-0.     , b+nc*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,0,1,0), ifLE( sdLine(p, b-nd     , b+nd     ), .005)*.5     );\n    col = mix(col, vec4(1,0,0,0), ifLE( sdLine(p, c-na     , c+na     ), .005)*.5     );\n    col = mix(col, vec4(0,0,0,0), ifLE( sdLine(p, c-0.     , c+nb*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,1,0,0), ifLE( sdLine(p, c*act3   , c+nc*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,0,1,0), ifLE( sdLine(p, c-nd*act4, c+nd     ), .005)*.5     );\n    col = mix(col, vec4(1,0,0,0), ifLE( sdLine(p, d-0.     , d+na*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,0,0,0), ifLE( sdLine(p, d-nb     , d+nb     ), .005)*.5     );\n    col = mix(col, vec4(0,1,0,0), ifLE( sdLine(p, d-nc*act4, d+nc     ), .005)*.5     );\n    col = mix(col, vec4(0,0,1,0), ifLE( sdLine(p, d*act3   , d+nd*act1), .005)*.5*act1);\n\n    u = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}