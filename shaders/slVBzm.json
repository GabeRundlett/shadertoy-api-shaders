{
    "Shader": {
        "info": {
            "date": "1664298325",
            "description": "implement 128³ voxel storage.  SPACE toggles animated/still volume.\n setVoxel( P in [0,1]³ )  in CubeA\n getVoxel( P in [0,1]³ )  in Image.\ntrilinearly interpolated, but MIPmap is not implemented.\n\nNote that we could store more, e.g. 192x192x150 RGBA\n",
            "flags": 16,
            "hasliked": 0,
            "id": "slVBzm",
            "likes": 31,
            "name": "storing voxels",
            "published": 3,
            "tags": [
                "volume",
                "voxels",
                "cubemapa"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 612
        },
        "renderpass": [
            {
                "code": "// using \"one more cubemap access\" https://shadertoy.com/view/3tGBDz\n\nvec4 getVoxel(vec3 q) {  // ----------- should really be in Common, but iChannel0 forbiden there... :-( \n    if ( q.x<0. || q.y < 0. || q.z < 0. || q.x > 1. || q.y > 1. || q.z > 1. ) return vec4(0);\n    float t = 64.* fract(2.*q.z); \n    int   n = q.z<.5 ? 0 : 1,\n          i = int(t);\n    vec4 O =       T( ( q.xy + vec2( i%8, i/8 ) )/8., n ); // return O; // uncomment to cancel z-interpolation\n    i++; if (i>63) n++, i -= 64; // if (n>1) return O;     // attention: borders interpolate to other faces\n    return mix( O, T( ( q.xy + vec2( i%8, i/8 ) )/8., n ), fract(t) ); // +.05;\n }\n\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))                      // rotation \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,T, s=1.57;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -40.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,r,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n //   p += .5/128.* texelFetch(iChannel1,ivec2(U)%1024,0).x * D; // jitter against pseudo-shading banding\n    \n    O = vec4(0);\n    p += 19.*D;\n    float dx = 1.;\n    for ( float i=0.; i<200.; i+=dx )                      // march scene\n        q = p + i/128. * D,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57),  q+=.5,\n        O += (1.-O.a)* dx* .6* getVoxel(q);\n\n    O += (1.-O.a) * vec4(.2,.3,.4,1);\n // O = sqrt(O);                                           // to sRGB\n \n // U /= R.y, O = T(U,0), U = floor(8.*U), O.x += mod(U.x+U.y,2.) ; if (U.x >7.) O-=O; // debug\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Note that MIPmap works in direction xy, but not z. ( to be implemented ).\n// Only 2 faces are used over 6: Other volumes could be used to store velocity or shadowing data.\n// For efficiency we rely on hardware texture interpolation, but you could implement degree 3 to improve quality.\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n#define H(p) fract( sin((p+17.1)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*3e4 )\n\nfloat _z = .3;\nvec3 hash( vec3 x ) \n{\n // float s = 0.;                          // standard Perlin noise\n    float s = mod(x.x+x.y+x.z,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(x.x)+floor(x.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                         // flow noise universal rotation direction\n // s *= iTime;                           // same rotation speed at all scales\n    s *= iTime/ _z;                       // rotation speed increase with small scale    \n\n    x = 2.*H(x) - 1.;\n    x.xy *= mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n    return x;\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n\n#define P(x,y,z) dot( hash( i + vec3(x,y,z) ) , f - vec3(x,y,z) )\n    return mix( mix( mix( P(0,0,0), P(1,0,0), u.x),\n                     mix( P(0,1,0), P(1,1,0), u.x), u.y),\n                mix( mix( P(0,0,1), P(1,0,1), u.x),\n                     mix( P(0,1,1), P(1,1,1), u.x), u.y) , u.z );\n}\n\nfloat perlin( vec3 p )  //fractal noise\n{\t\n    mat3 m =  mat3(2); // mat2( 1.6,  1.2, -1.2,  1.6 );\n           // mat3( 1.6,  1.2, 1.4,    1.3, -1.2,  1.6, -1.4, -1.6, 1.2 ) / 2.;\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 5; i++, s /= 2. ) {  _z = s; // for flownoise\n        v += s*noise( p ); p *= m; p-=.5;\n    }\n    return v/2.;\n}\n\nvec4 getVoxel(vec3 q) {  // ----------- should really be in Common, but iChannel0 forbiden there... :-( \n// ( used only for shadowing )\n    if ( q.x<0. || q.y < 0. || q.z < 0. || q.x > 1. || q.y > 1. || q.z > 1. ) return vec4(0);\n    float t = 64.* fract(2.*q.z); \n    int   n = q.z<.5 ? 0 : 1,\n          i = int(t);\n    vec4 O =       T( ( q.xy + vec2( i%8, i/8 ) )/8., n ); return O;\n    i++; if (i>63) n++, i -= 64; // if (n>1) return O;\n    return mix( O, T( ( q.xy + vec2( i%8, i/8 ) )/8., n ), fract(t) ); // +.05;\n }\n\n\nvec4 setVoxel( vec3 P ) {  // ---------- set your volume definition here. \n\n // P = floor(P*128.); return vec4(P.z==float(iFrame%128));    // debug\n\n    P = 2.*P-1.;                                               // centering\n    vec4 O;\n // O = vec4( length( P ) < .8 );\n // O = vec4( smoothstep( 4.* 2./128., 0., abs( length(P) -.8 ) ) );\n // O = vec4(max(0., noise( 8.*P + 171.) ));\n // O = vec4(max(0., perlin( 4.*P + 171.) ));\n // O = vec4( .3* smoothstep( .1, 0., abs( length( P+ perlin(4.*P) ) -.8) ) );\n    float v = .1 * smoothstep( .1, 0., abs( length( P+ perlin(4.*P) ) -.8) ); O = v* vec4(exp(-v/vec3(8,.25,.12)),1);\n // O = vec4( smoothstep( .3, 0., abs( length(P) -.75 ) ) * max(0., perlin(4.*P) ) );\n // float v = smoothstep( .3, 0., abs( length(P) -.75 ) ) * max(0., perlin(4.*P) ); O = v* vec4(exp(v*vec3(1,.1,.01)),1);\n // float v = smoothstep( .3, 0., abs( length(P) -.75 ) ) * .4*smoothstep(.05,.2, perlin(4.*P) ); O = v* vec4(exp(v*vec3(1,.1,.01)),1);\n \n    // ---------------------------------- computing shadows -------------------\n    // ( maybe would be cleaner to stores light in a separate volume.\n    //   e.g. it would allows to have still density with animated shadowing ).\n    float t = 1.; P = .5+.5*P;\n    for (float z = P.z; z < 1.; z += 1./128. )\n        t *= 1.- getVoxel( vec3(P.xy,z) ).a;\n    O.rgb *= .1 + 2.*exp(-3.*t);\n    return O;\n}\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n    if (D[n]<0.) n += 3;\n    \n    if ( n > 1 ) { O*=0.; return; }                            // we use only 2 faces.\n    if ( keyToggle(32) && iFrame>0 ) { O = texture(iChannel0,D); return; }        // uncomment if data not evolving.\n\n    U = ( 8.*floor(U) + .5 ) / 1024.;\n    vec2 I = floor(U);                                         // tile ID = (I,n)\n    vec3 P = vec3( fract(U), ( I.x +8.*I.y + 64.*float(n) +.5 ) /128. ); // 3D pos in normalized volume [0,1]³ of resolution 128³\n    O = setVoxel(P);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "\nvec3 E;\n#define T(U,n) ( E = vec3( 2.*fract(U) -1., 1 )                                 \\\n                   * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),         \\\n                 E = (n)%3 != 2 ? E.yzx : E.xzy,                                \\\n                 texture( iChannel0, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) ) \\\n               )\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}