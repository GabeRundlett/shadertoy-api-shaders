{
    "Shader": {
        "info": {
            "date": "1610218858",
            "description": "Playing with refraction and reflection. Good resources:\n\nhttps://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\nhttps://www.shadertoy.com/view/4tyXDR\nhttps://www.shadertoy.com/view/4dVBz3",
            "flags": 0,
            "hasliked": 0,
            "id": "3l3cDN",
            "likes": 5,
            "name": "Transparent boxes",
            "published": 3,
            "tags": [
                "refraction",
                "transparent",
                "reflect"
            ],
            "usePreview": 0,
            "username": "maksy",
            "viewed": 594
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592\n#define MAX_STEPS 150\n#define MAX_DIST 150.0\n#define SURF_DIST .0001\n\n#define GROUND 0\n#define SKY 1\n#define BOX 2\n#define BOX2 3\n#define BOX3 4\n#define MENGERSPONGE 5\n\n// How reflective the object is regardless of fresnel\n#define OBJECT_REFLECTIVITY 0.3\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n\nconst vec3 LIGHT_DIR = vec3(1, 3, 8);\n\nstruct Obj\n{\n\tint type;\n    float dist;\n    vec3 position;\n    vec3 normal;\n};\n\nstruct Shading\n{\n    Obj intersection;\n    bool transparent;\n    bool mirror;\n    vec3 color; \n    \n    // Refractive index inside the object\n    float refractiveIndex;\n    \n    // How much of each color the object absorbs over distance\n    vec3 absorbance;\n};\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBar(vec2 p, float width)\n{\n    vec2 d = abs(p) - width;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + 0.01 * width;\n}\n\nfloat sdCrossBar(vec3 p, float x)\n{\n    float bar_x = sdBar(p.yz, x);\n    float bar_y = sdBar(p.zx, x);\n    float bar_z = sdBar(p.xy, x);\n    return min(bar_z, min(bar_x, bar_y));\n}\n\nfloat sdMengerSponge(vec3 p)\n{\n    float d = sdBox(p, vec3(4.0));\n    float one_third = 1.0 / 3.0;\n    for (float i = 0.0; i < 3.0; i++) \n    {\n        float k = pow(one_third, i);\n        float kh = k * 0.5;\n        d = max(d, -sdCrossBar(mod(p + kh, k * 2.0) - kh, k * one_third));\n    }\n    return d;\n}\n\nObj getDist(vec3 p) \n{    \n    float boxDist = sdBox(p-vec3(-3, 2, -12), vec3(3, 4, 3));\n    float boxDist2 = sdBox(p-vec3(-14, 2, 0), vec3(3, 4, 3));    \n    float boxDist3 = sdBox(p-vec3(-3, 2, 12), vec3(3, 4, 3));  \n    float mengerSpongeDist = sdMengerSponge(p - vec3(10,2, 0));\n       \n    float height = -2.;\n    float planeDist = p.y - height;\n   \n    Obj obj = Obj(GROUND, planeDist, p, vec3(0.));\n    if (boxDist < planeDist)\n        obj = Obj(BOX, boxDist, p, vec3(0.));\n    \n    if (boxDist2 < planeDist && boxDist2 < obj.dist)\n        obj = Obj(BOX2, boxDist2, p, vec3(0.));\n    \n    if (boxDist3 < planeDist && boxDist3 < obj.dist)\n        obj = Obj(BOX3, boxDist3, p, vec3(0.));\n    \n    if (mengerSpongeDist < planeDist && mengerSpongeDist < obj.dist)\n        obj = Obj(MENGERSPONGE, mengerSpongeDist, p, vec3(0.));\n\n    return obj;\n}\n\n// Use offset samples to compute normal\nvec3 calcNormal(vec3 p) \n{\n\tfloat d = getDist(p).dist;\n    \n    vec2 e = vec2(.01, 0.);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).dist,\n        getDist(p-e.yxy).dist,\n        getDist(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\n// Ambient occlusion by iq.\nfloat calcAO(vec3 pos, vec3 normal)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    \n    for(int i = 0; i < 15; i++)\n    {\n        float r = 0.01 + 0.1*float(i);\n        vec3 aopos =  normal * r + pos;\n        \n        Obj intersection = getDist(aopos);\n             \n        if (intersection.type != BOX && intersection.type != BOX3) \n        {\n            float d = getDist( aopos ).dist;\n            occ += (r - d)*sca;\n            \n            sca *= 0.85;\n        }\n    }\n    return clamp( 1.0 - occ /3.14, 0.0, 1.0 );    \n}\n\n// Soft shadows by iq. Casts a ray from the origin ro (an object surface) in \n// the direction rd. Returns a lower value (darker shadow) when there is more\n// stuff nearby as we step along the shadow ray.\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 16; i++)\n    {\n\t\tfloat h = getDist(ro + rd*t).dist;\n        res = min(res, 1.0 * h/t);\n        t += clamp(h, 0.02, .50);\n        \n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n \nfloat fresnelAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // Adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n}\n\n// Basic raymarching loop\nObj castRay(vec3 ro, vec3 rd) \n{   \n    float t = 0.0;\n    \n    Obj intersection;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\t\n        vec3 p = ro + rd*t;\n        intersection = getDist(p); \n        \n        // This makes the bottom of a box completely transparent\n        if (intersection.type == GROUND)\n            t += intersection.dist;\n        else\n            t += abs(intersection.dist);\n        \n        // The ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) \n        {\n        \tintersection = Obj(SKY, t, p, vec3(0.));\n            break;\n        }\n\n        // The ray has marched close enough to an object\n        if (abs(intersection.dist) < SURF_DIST) \n        {\n            intersection = Obj(intersection.type, t, p, vec3(0.));\n        \tbreak;\n        }\n        \n        intersection.dist = t;\n    }\n    \n    return intersection;\n}\n\n// Calculates the color of the ground. Adds a checkerboard texture, ambient occlusion \n// diffuse lightning, soft shadows and fog.\nvec3 groundColor(Obj intersection, vec3 rayDir, vec3 skyColor) \n{  \n    float f = mod( floor(.5*intersection.position.x) + floor(.5*intersection.position.z), 2.0);\n    vec3 color = 0.4 + 0.3*f*vec3(1.0);\n                          \n    float fogAmount = pow(1. - pow(rayDir.y, 2.), 3.);\n               \n    vec3 N = calcNormal(intersection.position);\n    float occ = calcAO(intersection.position, N );\n        \n    float diffuse = clamp( dot( N, normalize(LIGHT_DIR) ), 0.0, 1.0 );    \n    float shadow = softShadow(intersection.position, LIGHT_DIR, .55, 2. );\n    \n    color += diffuse * shadow;\n    color *= occ;           \n    color = mix(color, skyColor, fogAmount);\n    \n    return color;\n}\n\n// Intersects an object and returns its shading properties.\nShading intersect(vec3 rayOrig, vec3 rayDir) \n{\n    Shading shading;\n    \n    Obj obj = castRay(rayOrig, rayDir);\n    \n    shading.intersection = obj;\n    shading.transparent = false;\n    shading.mirror = false;\n    shading.absorbance = vec3(0.);\n\n    vec3 skyColor = vec3(0.2);\n    \n    if (obj.type != GROUND || obj.type != SKY) \n    {\n        shading.intersection.normal = calcNormal(obj.position);\n    }\n    \n    if (obj.type == GROUND) \n    {\n        shading.intersection.normal = vec3(0.0, 1.0, 0.0);\n        shading.color = groundColor(obj, rayDir, skyColor);            \n    } \n    else if (obj.type == SKY) \n    { \n        shading.color = skyColor;\n        shading.intersection.normal = vec3(0.0);    \n    } \n    else if (obj.type == MENGERSPONGE) \n    {    \n       float ao = calcAO(shading.intersection.position, shading.intersection.normal);\n       shading.color = vec3(0.1, 0.3, 0.1);       \n       shading.color *= ao;        \n    } \n    else if (obj.type == BOX) \n    {     \n       shading.transparent = true;\n       shading.color = vec3(0., 0., 0.05);\n       shading.refractiveIndex = 1.125;\n       shading.absorbance = vec3(.81, .81, .40);        \n    } \n    else if (obj.type == BOX2) \n    {       \n       shading.mirror = true;\n       shading.color = vec3(0., 0., 0.2);    \n    } \n    else if (obj.type == BOX3)\n    {     \n       shading.transparent = true;\n       shading.refractiveIndex = 1.;\n       shading.absorbance = vec3(.01, .81, .81);\n       shading.color = vec3(.3, 0., 0.);\n    }   \n   \n    return shading;\n}\n\n// If a ray hits a transparent object, the refracted ray is bounced \n// inside the object to get the refracted color.\nvec3 getInternalColor(vec3 hitPos, vec3 normal, vec3 camDir, float refractiveIndex, \n                      vec3 absorbance)\n{\n    vec3 rayDir = refract(camDir, normal, REFRACTIVE_INDEX_OUTSIDE / refractiveIndex);\n    \n    // Move the ray slightly inside the object to prevent it hitting\n    // the same object again.\n    vec3 rayPos = hitPos + rayDir * .001;\n        \n    float multiplier = 1.0;\n    float absorbDistance = 0.0;  \n   \n    vec3 refractedColor = vec3(0.0);\n    \n    for (int i = 0; i < 3; i++) \n    {    \n        Shading shading = intersect(rayPos, rayDir);\n        rayPos = shading.intersection.position;\n        \n        bool incoming = dot(rayDir, shading.intersection.normal) < 0.0;\n        vec3 orientingNormal = -shading.intersection.normal;\n        if (incoming)\n            orientingNormal = shading.intersection.normal;\n            \n        // Calculate Beer's law absorption.       \n        absorbDistance += shading.intersection.dist;\n        vec3 absorb = exp(-absorbance * absorbDistance);\n        \n        float reflectMultiplier = fresnelAmount(refractiveIndex, REFRACTIVE_INDEX_OUTSIDE,\n                                                orientingNormal, rayDir);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // Add the color of the point outside hit by the refracted ray.\n        vec3 refractDir = refract(rayDir, orientingNormal, \n                                  refractiveIndex / REFRACTIVE_INDEX_OUTSIDE);            \n        shading = intersect(rayPos+ refractDir*0.01, refractDir);\n        refractedColor += shading.color * refractMultiplier * multiplier * absorb;\n          \n        // Follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, orientingNormal);\n\n        // Move the ray slightly down the reflect path to prevent it hitting\n        // the same object again.\n        rayPos += rayDir * .01;\n        \n        multiplier *= reflectMultiplier;\n    }\n    \n    return refractedColor;\n}\n\nvec3 renderScene(vec3 camPos, vec3 camDir) \n{                                \n    Shading shading = intersect(camPos, camDir);\n    \n    float reflectMultiplier = fresnelAmount(REFRACTIVE_INDEX_OUTSIDE, shading.refractiveIndex,\n                                            shading.intersection.normal, camDir);\n    float refractMultiplier = 1.0 - reflectMultiplier;\n  \n    // Get the reflected color\n    vec3 reflectedCol = vec3(0.0);\n    if (shading.mirror)\n    {\n        vec3 reflectDir = reflect(camDir, shading.intersection.normal);\n        Shading reflected = intersect(shading.intersection.position + reflectDir*0.01, reflectDir);\n        reflectedCol = reflected.color * reflectMultiplier;\n    }\n    \n    // If the object isn't transparent return, otherwise bounce the reflected ray inside\n    // the box to get the refracted color.\n    if (!shading.transparent) \n        return shading.color + reflectedCol;\n    \n    vec3 refractedCol = getInternalColor(shading.intersection.position, shading.intersection.normal,\n                                         camDir, shading.refractiveIndex, shading.absorbance);\n    refractedCol *= refractMultiplier;\n   \n   return shading.color + reflectedCol + refractedCol;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) \n{  \n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nmat2 rotate(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n        \n    // camera\n    vec3 camPos = vec3(16., 10., -28.);\n    camPos.yz *= rotate(-m.y*3.14+1.);\n    camPos.xz *= rotate(-m.x*6.2831);\n    \n    vec3 camTarg = vec3(-2., 0., 2.);\n    mat3 camMat = lookAt(camPos, camTarg, 0.0);\n    \n    vec3 camDir = normalize(camMat * vec3(uv.xy, 1.0));\n    \n    vec3 col = renderScene(camPos, camDir);\n\n    // gamma correction\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}