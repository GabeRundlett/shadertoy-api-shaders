{
    "Shader": {
        "info": {
            "date": "1657096257",
            "description": "various ways of visualising magnetic fields, overlayed.",
            "flags": 0,
            "hasliked": 0,
            "id": "sd3fWS",
            "likes": 8,
            "name": "magnets_3viz",
            "published": 3,
            "tags": [
                "physics",
                "fields",
                "electric",
                "magnet"
            ],
            "usePreview": 0,
            "username": "zithral",
            "viewed": 260
        },
        "renderpass": [
            {
                "code": "\n\nfloat Sigmoid (float x) {\n    return 2.0 / (1.0 + exp(-x)) - 1.0; \n}\n\nvec3 hue2rgb(float h){\n    vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tau = 2.*3.141;\n    \n    const int num = 4;\n    vec2[num] ps = vec2[](\n        vec2(.3, .7),\n        vec2(.7, .3),\n        vec2(.5, .8),\n        vec2(.4, .6)\n    );\n    float[num] cs = float[](+1., +1., -1., -1.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    float t = 0.1 * iTime;\n    \n    vec3 col = vec3(0.);\n    float sum = 0.;\n    vec2 forces = vec2(0.);\n    for (int i = 0; i < num; i++) {\n        vec2 p = ps[i] * iResolution.xy;\n        float rand = fract(sin(1000.*float(i+1)));\n        vec2 offs = 0.2*iResolution.x*(1.1-rand)*vec2(cos(tau*t*rand), sin(tau*t*rand));\n        p += offs;\n        \n        \n        float c = cs[i];\n        \n        vec2 dir = p - uv;\n        float d = length(dir);\n        \n        if (d < 10.) {\n            if (c == +1.) {\n                col = vec3(1., 0.5, 0.);\n            } else {\n                col = vec3(0., 0.5, 1.);\n            }\n        }\n        \n        float f = 1./(d*d);\n        \n        sum += c * f;\n        forces += c * f * dir;\n    }\n    \n    \n    forces /= length(forces);\n    float ang = atan(forces.y, forces.x) / tau;\n    if (col == vec3(0)) {\n        col = vec3(0.1);\n        col = 0.5*hue2rgb(ang);\n        \n        float rad = 25.;\n        float size = 2.1*rad;\n        vec2 compass = round(uv/size) * size;\n        vec2 dir1 = compass - uv;\n        vec2 dir2 = -dir1;\n        float len = length(dir1);\n        if (len < rad) {\n            col = vec3(0.2);\n            len /= rad;\n            dir1 /= length(dir1);\n            dir2 /= length(dir2);\n            \n            if (length(forces-dir1) < 0.5*(1.-len)) {\n                col = vec3(0., 0.5, 1.);\n            }\n            if (length(forces-dir2) < 0.5*(1.-len)) {\n                col = vec3(1., 0.5, 0.);\n            }\n        }\n    }\n    \n    \n    \n    \n    \n    if (col != vec3(0)) {\n        sum = Sigmoid(50000.*sum);\n        float val = abs(sum);\n        \n        val = floor(fract(8.*(abs(sum)-.01))+.05);\n        \n        //float val = min(1., 1. - 1./(abs(sum)));\n        if (0.1 < val) {\n            if (sum > 0.) {\n                col = vec3(val, 0., 0.);\n            } else {\n                col = vec3(0., val, val);\n            }\n        }\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}