{
    "Shader": {
        "info": {
            "date": "1466619519",
            "description": "Recover ozone absorption from spectrum to xyz to rgb",
            "flags": 0,
            "hasliked": 0,
            "id": "ldySWV",
            "likes": 12,
            "name": "O3 Spectrum to RGB absorption",
            "published": 3,
            "tags": [
                "ozoneabsoprtion"
            ],
            "usePreview": 0,
            "username": "SebH",
            "viewed": 1579
        },
        "renderpass": [
            {
                "code": "\n// An attempt to convert Ozone spectrum absorption to RGB absoprtion\n// By Sebastien Hillaire https://twitter.com/SebHillaire\n// Thanks to H3r2tic for the SRGBGamut clipping function\n\n\n// Spectrum to xyz approx function from \"Simple Analytic Approximations to the CIE XYZ Color Matching Functions\"\n// http://jcgt.org/published/0002/02/01/paper.pdf\n//Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\nfloat t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374);\nfloat t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323);\nfloat t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\nreturn 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\nfloat t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247);\nfloat t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\nreturn 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\nfloat t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278);\nfloat t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\nreturn 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n// Ozone absorption from Preetham, table 2\n// https://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\nfloat getAbsorption(float wavelength)\n{\n\tconst float step = 10.0;\n\n\tif (wavelength < 450.0)\n\t\treturn 0.0;\n\n\tif (wavelength <= 450.0 + step)\n\t\treturn 0.003;\n\tif (wavelength <= 460.0 + step)\n\t\treturn 0.006;\n\tif (wavelength <= 470.0 + step)\n\t\treturn 0.009;\n\tif (wavelength <= 480.0 + step)\n\t\treturn 0.014;\n\tif (wavelength <= 490.0 + step)\n\t\treturn 0.021;\n\n\tif (wavelength <= 500.0 + step)\n\t\treturn 0.03;\n\tif (wavelength <= 510.0 + step)\n\t\treturn 0.04;\n\tif (wavelength <= 520.0 + step)\n\t\treturn 0.048;\n\tif (wavelength <= 530.0 + step)\n\t\treturn 0.063;\n\tif (wavelength <= 540.0 + step)\n\t\treturn 0.075;\n\tif (wavelength <= 550.0 + step)\n\t\treturn 0.085;\n\tif (wavelength <= 560.0 + step)\n\t\treturn 0.103;\n\tif (wavelength <= 570.0 + step)\n\t\treturn 0.12;\n\tif (wavelength <= 580.0 + step)\n\t\treturn 0.12;\n    if (wavelength <= 590.0 + step)\n\t\treturn 0.115;\n\n\tif (wavelength <= 600.0 + step)\n\t\treturn 0.125;\n\tif (wavelength <= 610.0 + step)\n\t\treturn 0.125;\n\tif (wavelength <= 620.0 + step)\n\t\treturn 0.105;\n\tif (wavelength <= 630.0 + step)\n\t\treturn 0.09;\n\tif (wavelength <= 640.0 + step)\n\t\treturn 0.079;\n\tif (wavelength <= 650.0 + step)\n\t\treturn 0.067;\n\tif (wavelength <= 660.0 + step)\n\t\treturn 0.057;\n\tif (wavelength <= 670.0 + step)\n\t\treturn 0.048;\n\tif (wavelength <= 680.0 + step)\n\t\treturn 0.036;\n\tif (wavelength <= 690.0 + step)\n\t\treturn 0.028;\n\n\tif (wavelength <= 700.0 + step)\n\t\treturn 0.023;\n\tif (wavelength <= 710.0 + step)\n\t\treturn 0.018;\n\tif (wavelength <= 720.0 + step)\n\t\treturn 0.014;\n\tif (wavelength <= 730.0 + step)\n\t\treturn 0.011;\n\tif (wavelength <= 740.0 + step)\n\t\treturn 0.0;\n\tif (wavelength <= 750.0 + step)\n\t\treturn 0.009;\n\tif (wavelength <= 760.0 + step)\n\t\treturn 0.007;\n\tif (wavelength <= 770.0 + step)\n\t\treturn 0.004;\n\n\treturn 0.0;\n}\n\nvec3 xyzToRgb(vec3 XYZ)\n{\n\tfloat r =  3.240479 * XYZ.x + -1.537150 * XYZ.y + -0.498535 * XYZ.z;\n\tfloat g = -0.969256 * XYZ.x +  1.875991 * XYZ.y +  0.041556 * XYZ.z;\n\tfloat b =  0.055648 * XYZ.x + -0.204043 * XYZ.y +  1.057311 * XYZ.z;\n\t\n    return vec3(r,g,b);\n}\n\n#if 1\n    #define SPECTRUM_START 360\n    #define SPECTRUM_BIN   43\n    #define SPECTRUM_STEP  10\n#else\n\t// only absorption range (invalid, we need to avaluate full rgb range)\n    #define SPECTRUM_START 450\n    #define SPECTRUM_BIN   33\n    #define SPECTRUM_STEP  10\n#endif\n\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \n// intersect the intersection point may be stored in the floats i_x and i_y.\nvec2 get_line_intersection(float p0_x, float p0_y, float p1_x, float p1_y, \n    float p2_x, float p2_y, float p3_x, float p3_y)\n{\n    float s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1_x - p0_x;     s1_y = p1_y - p0_y;\n    s2_x = p3_x - p2_x;     s2_y = p3_y - p2_y;\n\n    float s, t;\n    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0)\n    {\n        // Collision detected\n        return vec2(p0_x + (t * s1_x), p0_y + (t * s1_y));\n    }\n\n    return vec2(p0_x, p0_y);\n}\n\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 s0, vec2 s1)\n{\n    return get_line_intersection(p0.x, p0.y, p1.x, p1.y, s0.x, s0.y, s1.x, s1.y);\n}\n\nvec3 constrainXYZToSRGBGamut(vec3 col)\n{\n    vec2 xy = col.xy / (col.x + col.y + col.z);\n    \n    vec2 red = vec2(0.64, 0.33);\n    vec2 green = vec2(0.3, 0.6);\n    vec2 blue = vec2(0.15, 0.06);\n    vec2 white = vec2(0.3127, 0.3290);\n    \n    const float desaturationAmount = 0.1;\n    xy = mix(xy, white, desaturationAmount);\n    \n    xy = intersectSegment(xy, white, red, green);\n    xy = intersectSegment(xy, white, green, blue);\n    xy = intersectSegment(xy, white, blue, red);\n    \n    // Desaturation?\n    col = vec3(\n        col.y/xy.y * xy.x,\n        col.y,\n        col.y/xy.y * (1.0 - xy.x - xy.y)\n    );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //\n    // Draw debug XYZ and absorption curves at the bottom\n    //\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\n    \n    float X = xFit_1931(wavelength);\n    float Y = yFit_1931(wavelength);\n    float Z = zFit_1931(wavelength);\n    \n    vec3 outColor = vec3(0.0);\n    \n    // Display XYZ spectrum curve\n    float H = uv.y*4.0;\n\toutColor = vec3(X>H?1.0:0.0,Y>H?1.0:0.0,Z>H?1.0:0.0);\n   \n    // Overlay absorption spectrum\n    float absorbtion = getAbsorption(wavelength);\n    outColor = absorbtion > uv.y \n        ? vec3(0.4,0.4,0.4)*0.9 + outColor*0.1 : outColor;\n    \n    \n    \n    \n    //\n    // Spectrum -> xyz -> rgb absorption gradient\n    //\n    \n    float step = 10.0;\n    float spectrum[SPECTRUM_BIN];\n    for(int i=0; i<SPECTRUM_BIN; ++i)\n    {\n        #if 1\n        spectrum[i] = 0.014;// uniform band distribution\n        #else\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\n    \tfloat X = xFit_1931(w);\n    \tfloat Y = yFit_1931(w);\n    \tfloat Z = zFit_1931(w);\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\n        #endif\n    }\n    \n    float depth = uv.x * 1000.0;\n    \n    // Compute spectrum after absorption\n    float spectrum2[SPECTRUM_BIN];\n    for(int i=0; i<SPECTRUM_BIN; ++i)\n    {\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\n        spectrum2[i] = spectrum[i] * exp(-depth * getAbsorption(w));\n    }\n    \n    vec3 colorXYZ = vec3(0.0, 0.0, 0.0);\n    vec3 color2XYZ = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<SPECTRUM_BIN; ++i)\n    {\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\n        \n        float dw = float(SPECTRUM_STEP);\n        \n        colorXYZ.x += spectrum[i] * xFit_1931(w) * dw;\n        colorXYZ.y += spectrum[i] * yFit_1931(w) * dw;\n        colorXYZ.z += spectrum[i] * zFit_1931(w) * dw;\n\n        color2XYZ.x += spectrum2[i] * xFit_1931(w) * dw;\n        color2XYZ.y += spectrum2[i] * yFit_1931(w) * dw;\n        color2XYZ.z += spectrum2[i] * zFit_1931(w) * dw;\n\t}\n    \n    vec3 color = xyzToRgb(colorXYZ);\n    vec3 color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\n    \n    //\n    // draw debug recovered absorption curve in the middle\n    //\n#if 1\n    float scrBottom = 0.5;\n    float scrHeight = 0.4;\n    if(uv.y>scrBottom)\n    {\n        // Make the attenuated color safe (R and G goes negative :/)\n        // changing this \"fixes\" red and green absorption \n        // but it is till fucked up. Also absorption get smaller with distance\n        // which should not happen, it should remain roughly constant.\n        // It matches the negative color which really says: \n        //        -> RGB from spectrum reconstruction is fucked up\n        // But I want absortpion in that space and not another one.\n        vec3 fixedColor2 = color2;\n        #if 0\n        fixedColor2 = max(color2, vec3(0.00000000000001));\n        #endif\n        \n\t\tvec3 ozoneA = log(color / fixedColor2) / depth;\n        ozoneA *= 100.0; // 1/cm to 1/m\n        outColor = vec3(0.25);\n        \n        float yMin = 0.0;\n        float yMax = 18.0;\n        \n        vec3 scrOzoneA = (ozoneA-yMin)/(yMax-yMin);\n        float scrY = (uv.y - scrBottom) / scrHeight;\n        \n        if(scrOzoneA.r > scrY) outColor.r = 0.9;\n        if(scrOzoneA.g > scrY) outColor.g = 0.9;\n        if(scrOzoneA.b > scrY) outColor.b = 0.9;\n    }\n#endif\n    \n    \n    \n    //\n    // draw debug color gradient at the top\n    //\n    if(uv.y>0.9)\n    {\n        vec3 finalColor = color2;\n        //finalColor = mix(finalColor, vec3(1,1,1)*color2XYZ.y, 0.0);\n        //finalColor = -finalColor;\n        \n        //finalColor = -finalColor * 4.0;//reveal negative values... :/\n        \n        finalColor = max(vec3(0.0),finalColor);\n        finalColor = pow(finalColor, vec3(1.0/2.2));\n    \toutColor = finalColor;\n        \n        if(uv.y>0.95)\n        {\n            // Compare with coefficient recoverd using mean on valid range\n            vec3 aborptionFit = vec3(21.012, 6.825, 0.386);\n            outColor = color * exp(-depth*0.01*aborptionFit);\n        }\n    }\n    \n    \n    \n\tfragColor = vec4(outColor,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}