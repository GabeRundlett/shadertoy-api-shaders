{
    "Shader": {
        "info": {
            "date": "1693675501",
            "description": "Hold mouse button for \"soft\" transitions.\n\nEach transition runs twice, to-and-back, when BOUNCE_TIME is true.\n\nFullscreen is better\n",
            "flags": 0,
            "hasliked": 0,
            "id": "DtSBRz",
            "likes": 6,
            "name": "9 Centered Transitions",
            "published": 3,
            "tags": [
                "plasma",
                "spiral",
                "transition",
                "transitions"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 218
        },
        "renderpass": [
            {
                "code": "/*\n\n9 Transitions by misol101\n\nHold mouse button for \"soft\" transitions.\n\nEach transition runs twice, to-and-back, when BOUNCE_TIME is true.\n\nFullscreen is better.\n\n*/\n\n//spiral\nvoid fx1( out vec4 O, in vec2 u )\n{\n    vec2 uv = u/iResolution.xy -.5;\n\n    float l = length(uv)/3.;\n    float a = atan(uv.y, uv.x);\n\n    float b1 = sin(100.*(sqrt(l)-0.02*a-0.3*((iTime*50.+uv.y*(0.+cos(iTime*0.72)*150.9)+uv.x*(0.+cos(iTime*0.14)*100.9))/140.)))*2.54;\n    float b2 = l*2.5;\n    \n    float g=max(b1/16.,0.09)+sin((a/2.5+iTime/2.5)*25.)*13.*(b2*b2);\n    float b=sin((a/5.+iTime/3.5)*25.)*0.71*b2*b2*42.+0.62;\n    \n    vec3 col = vec3(b1*b1*b1*0.1+.62,\n                    b1/3.5+b1*b*0.2-g/2.-.32,\n                    b1/8.+b1*g*0.26+b/3.+.45);\n\n    col = col*min(l*l*940000.,1.);\n    float c1=max(col.x,max(col.y,col.z));\n    c1=c1*c1*0.27;\n\n    O = vec4(c1,c1,c1,1.0);\n}\n\n// plasma\nvoid fx2( out vec4 O, in vec2 u )\n{\n    vec2  R = vec2(0.,iResolution.y+sin(iTime/25.0)*8.24),\n          p = 5.*( u+u+vec2(800.,cos((iTime+5.)/10.0)*1000.) - R ) / R.y,\n          r = p-p;\n    \n    for(float f=1.; f < 2.5; f *= 1.05 )\t\n\t\tr += sin( p*f +iTime*0.85) / f,\n        p = p * mat2(8,6,-8,6)*.1 + r*.4;\n\n    float l = length(r);\n    vec3 c = vec3(l*0.29, l*l*0.024, l*l*l*0.0016);\n\n    vec2 uv = u/iResolution.xy;\n    vec3 c2 = -0.3 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    O = vec4(c+c2, 0.);\n}\n\nfloat transition(vec2 uv, int index, bool distinct) {\n\n    float t = getTime(iTime, interval / speed);\n\n    t = mod(t * speed, interval) - 0.25;\n    t = clamp(t, 0., interval - 0.25);\n\n    float a = length(uv) + 0.25;\n\n    float t2 = t + tmod(index, uv);\n\n    if (distinct) {\n        if (a >= t2 - EDGE_SMOOTH && a < t2)\n            t2 = smoothstep(0.,1.,(t2-a) / EDGE_SMOOTH);\n        else\n            t2 = step(a, t2); // a<n?1:0\n    }\n    else\n        t2 = clamp(t2 - 0.25, 0., 1.);\n\n    return t2;\n}\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n\n    vec4 px1, px2;\n    fx1(px1, u);\n    fx2(px2, u);\n\n    int index = (int(iTime / (interval*(BOUNCE_TIME? 2.:1.) / speed))) % NOF_TRANSITIONS;\n\n    if (!BOUNCE_TIME && (index & 1) == 1) { vec4 tmp=px1; px1=px2; px2=tmp; }\n\n    vec2 uv = u/iResolution.y -.5;\n    uv.x += (1. - iResolution.x/iResolution.y) * 0.5;\n\n    float t = transition(uv, index, iMouse.z < 1. );\n\n    O = mix(px1, px2, t);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int NOF_TRANSITIONS = 9;\n\nconst float EDGE_SMOOTH = 0.0; // 0.03\n\nconst bool BOUNCE_TIME = true;\n\nfloat getTime(float time, float interval) {\n    if (!BOUNCE_TIME)\n        time = mod(time, interval);\n    else {\n        time = mod(time, interval*2.);\n        if (time >= interval) time = max(interval*2. - time, 0.);\n    }\n    return time;\n}\n\nconst float interval = 2.0;  // actual time of one transition: interval / speed\nconst float speed = 0.33;\n\nfloat tmod(int index, vec2 uv) {\n    switch(index) {\n\n        case 0: return sin(((uv.x+0.53)/(uv.y+0.53)*200.+uv.y*100.)*0.2)*0.25;\n        \n        case 1: return sin(uv.x*200.)*0.125 + cos(uv.y*200.)*0.125;\n\n        case 2: return sin(uv.x*200.*0.166)*0.125 + cos(uv.y*200.*0.25)*0.125;\n\n        case 3: return sin((uv.x*100.*uv.y*100.)/3.)*0.15*cos((uv.y*200.*uv.y*200.)/5.)*1.5;\n\n        case 4: return sin(uv.x*200.)*0.25;\n\n        case 5: return sin((uv.x*200.+uv.y*100.)*0.1)*0.25;\n\n        case 6: return sin((uv.x*200.-uv.y*300.)*0.35)*0.14+cos((uv.y*66.)*0.3)*0.09;\n\n        case 7: return sin((uv.x*200.+uv.y*100.)*0.2)*0.06;\n\n        case 8: return sin((uv.x*100.*uv.y*100.)*0.1)*0.25;\n\n        default: return 0.;\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}