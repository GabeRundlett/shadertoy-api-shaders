{
    "Shader": {
        "info": {
            "date": "1621909228",
            "description": "amogus",
            "flags": 96,
            "hasliked": 0,
            "id": "ftsGDn",
            "likes": 38,
            "name": "amogus",
            "published": 3,
            "tags": [
                "amogus"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 1077
        },
        "renderpass": [
            {
                "code": "// ####### amogus #######\n// Made by Zi7ar21 on May 24th, 2021 at 20:20 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/ftsGDn\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Final Image\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = clamp(pow(color/(color+1.0), vec3(1.0/gamma)), 0.0, 1.0);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 27237,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ser-g-o/amogus"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### Preprocessor #####\n\n/*\n#if __VERSION__ < 300\n#error This shader requires GLSL 300 ES to run!\n#endif\n*/\n\n// Page 6:\n// https://www.khronos.org/files/webgl20-reference-guide.pdf\n// - Debug info off by default, no need to disable it\n// - Optimization on by default, no need to enable it\n\n// Old version but also useful:\n// https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf\n\n//#pragma debug(on)\n//#pragma optimize(off)\n\n//#pragma debug(off)\n//#pragma optimize(on)\n\n// ##### Parameters #####\n\n#define gamma 2.2\n\n#define camfov  1.00\n#define hitDist 1E-4\n#define maxDist 8.00\n#define maxStep 512U\n\n#define MAX_BOUNCES 8u\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\n// aaaaah stuff below shart I will replace later\n\n// Traditional Input Names\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffers\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// ##### RNG #####\n// Taken from michael0884's Usage of PCG Random\n// (He has since improved these, I like the old ones though... yeet!)\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n// https://www.pcg-random.org/\n\nuint ns;\n#define INIT_RNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n\n// PCG Random Number Generator\nvoid pcg()\n{\n    uint state = ns * 0x2C9277B5u + 0xAC564B05u;\n    uint word  = ( (state >> ( (state >> 28u) + 4u) ) ^ state ) * 0x108EF2D9u;\n    ns = (word >> 22U) ^ word;\n}\n\n// Random Floating-Point Scalars/Vectors\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random Vectors\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(two_pi*Z.y), sin(two_pi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(two_pi*Z.z), sin(two_pi*Z.z), cos(two_pi*Z.w));}\nvec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(two_pi*Z.z), sin(two_pi*Z.z), cos(two_pi*Z.w), sin(two_pi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Material Datatype\nstruct material {\n    uint ID;\n    vec3 albedo;\n    vec3 normal;\n    float rough;\n};\n\n// Material Properties Lookup\nmaterial getMaterial(material materialProperties)\n{\n    uint ID = materialProperties.ID;\n    materialProperties.albedo = ID == 0U ? vec3(0.6) : (ID == 1U ? vec3(0.5, 0.25, 0.125) : vec3(0.8));\n    materialProperties.rough  = ID == 0U ? 1.0 : (ID == 1U ? 0.2 : 0.05);\n    return materialProperties;\n}\n\n// Smooth Boolean Operations\nfloat smoothUnion(float d0, float d1, float k)\n{\n    float h = clamp(0.5+0.5*(d1-d0)/k, 0.0, 1.0);\n    return mix(d1, d0, h)-k*h*(1.0-h);\n}\n\nfloat smoothSubtraction(float d0, float d1, float k)\n{\n    float h = clamp(0.5-0.5*(d1+d0)/k, 0.0, 1.0);\n    return mix(d1,-d0, h)+k*h*(1.0-h);\n}\n\nfloat smoothIntersection(float d0, float d1, float k) {\n    float h = clamp(0.5-0.5*(d1-d0)/k, 0.0, 1.0);\n    return mix(d1, d0, h)+k*h*(1.0-h);\n}\n\n// I saw red vent! sus! sus! impasta!\nfloat amogus(vec3 pos, out uint id)\n{\n    if(length(pos.xz) > 1.5)\n    {\n        return length(pos.xz)-1.0;\n    }\n\n    // Cylinder\n    float bean = max(length(pos.xz)-0.5, abs(pos.y)-0.25);\n\n    // Cylinder Caps\n    bean = min(bean, min(length(pos-vec3(0.0, 0.25, 0.0))-0.5, length((pos+vec3(0.0, 0.25, 0.0))*vec3(1.0, 2.0, 1.0))-0.5));\n\n    // Legs\n    float legs = max(length(vec2(abs(pos.x)-0.25, pos.z))-0.2, abs(pos.y+0.6)-0.15);\n    legs = min(legs, length(vec3(abs(pos.x)-0.25, pos.y+0.45, pos.z))-0.2);\n\n    // Legs\n    bean = smoothUnion(bean, legs, 0.2);\n\n    // Backpack\n    bean = smoothUnion(bean, max(max(abs(pos.x)-0.5, abs(pos.y-0.1)-0.5), abs(pos.z-0.5)-0.2), 0.05);\n\n    float visor = length((pos+vec3(0.0, -0.2, 0.5))*vec3(1.0, 2.0, 3.0))-0.35;\n\n    id = bean < visor ? 1U : 2U;\n\n    // Return the Sussy Bean Man\n    return min(bean, visor);\n}\n\n// Scene Distance Estimator\nfloat DE(vec3 pos, out uint id)\n{\n    // Scene Floor\n    float DE0 = pos.y;\n\n    // Bean Man\n    float DE1 = amogus(pos-vec3(0.0, 0.75, 0.0), id);\n\n    id = DE0 < DE1 ? 0U : id;\n    return min(DE0, DE1);\n}\n\n// Tetrahedron Numerical Normals\nvec3 getNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n    uint n;\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist, n)+\n    k.xyy*DE(pos+k.xyy*hitDist, n)+\n    k.yxy*DE(pos+k.yxy*hitDist, n)+\n    k.yyx*DE(pos+k.yyx*hitDist, n));\n}\n\n// Distance Estimator Ray-Marching\nfloat intersectDE(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    float t = 0.0;\n\n    for(uint i = 0U; i < maxStep; i++)\n    {\n        if(t > maxDist)\n        {\n            break;\n        }\n\n        float td = DE(ro+rd*t, materialProperties.ID);\n\n        if(td < hitDist)\n        {\n            materialProperties.normal = getNormal(ro+rd*t);\n            return t-hitDist;\n        }\n\n        t += td*0.5;\n    }\n\n    return -1.0;\n}\n\n// Scene Intersection Function\nfloat intersect(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    float t0 = intersectDE(ro, rd, materialProperties);\n\n    materialProperties = getMaterial(materialProperties);\n\n    return t0;\n}\n\nvec3 skyColor(vec3 dir)\n{\n    if(dot(dir, normalize(vec3(-1.0, 0.5, -1.0))) > 0.8)\n    {\n        return vec3(10.0);\n    }\n\n    return vec3((max(dot(dir, vec3(0.0, 1.0, 0.0)), 0.0)*0.8)+0.2);\n}\n\n// Render the Frame and Calculate Shading\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    vec3 raypos = ro;\n\n    material materialProperties;\n\n    vec3 attenuation = vec3(1.0);\n\n    for(uint i = 0U; i < MAX_BOUNCES; i++)\n    {\n        float t = intersect(raypos, rd, materialProperties);\n\n        if(t < 0.0)\n        {\n            return attenuation*skyColor(rd);\n        }\n\n        raypos += rd*t;\n        raypos += materialProperties.normal*hitDist;\n        attenuation = clamp(attenuation*materialProperties.albedo, 0.0, 1.0);\n        rd = reflect(rd, normalize(nrand3(materialProperties.rough, materialProperties.normal)));\n    }\n\n    return vec3(-1.0);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Progressive Rendering\n    fragColor = frame != 0 ? texel0 : vec4(0.0);\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, gl_FragCoord.xy)-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n    const vec3 ro = vec3(1.5, 0.75, -1.5);\n    mat3 rotmat = mat3(0.5, 0.0, 0.5, 0.0, 1.0, 0.0, -0.5, 0.0, 0.5);\n    rotmat[0] = normalize(rotmat[0]);\n    //rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Frame\n    vec3 color = radiance(ro, rd);\n\n    // Output the Rendered Frame\n    fragColor += any(lessThan(color, vec3(0.0))) || any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### IMAGE EXPORT #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Render Buffer\n    vec4 texel = texel0;\n\n    // Output the Final Image\n    fragColor = vec4(texel0.a == 0.0 ? texel0.rgb : texel0.rgb/texel.a, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}