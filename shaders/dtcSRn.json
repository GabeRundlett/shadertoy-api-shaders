{
    "Shader": {
        "info": {
            "date": "1684936872",
            "description": "Did you know we can evaluate a 2D bicubic with just 4 fetches rather than 16 ? → top-left.\ntop-right: cubic smoothstep between values\nbottom: bilinear, nearest. \nFrom GPU Gems2 \"Fast Third-Order Texture Filtering\"\nextend easily to 3D. But B-Spline, not CR",
            "flags": 32,
            "hasliked": 0,
            "id": "dtcSRn",
            "likes": 29,
            "name": "cheap bicubic evaluation",
            "published": 3,
            "tags": [
                "2d",
                "bicubic",
                "interpolation"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "// ref: https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-20-fast-third-order-texture-filtering\n// code & discussion:   https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl/42179924#42179924\n// ( thanks Mathéo for pointing ! :-) )\n\n#define CH   iChannel0                       // try me ! :-)\n#define R    vec2(textureSize(CH,0))         // texture size\n#define T(d) texture(CH, (I+d) / R )         // fetch pixel I+offset d\n\nvec4 cubic(float v){                         // prepare cubic coefficients for B-spline\n vec3  n = vec3(1,2,3) - v;\n return n*n*n / 6. * mat4x3(1,0,0, -4,1,0, 6,-4,1, -3,3,-1) + vec4(0,0,0,1);\n}\n// Catmull-Rom coefficients would allows true interpolation passing through values, but this would requires negative bilinear coefficients...\n\nvec4 biCubic(vec2 U )                        // ← the magic is here\n{\n    vec2 F = fract(U), I = floor(U);\n    vec4 X = cubic(F.x),\n         Y = cubic(F.y),\n         Z = vec4(X.yw, Y.yw),\n         s = vec4(X.xz, Y.xz) + Z,\n         d = vec4(-1,1,-1,1) +.5 + Z / s;\n\n    s.xz /= s.xz + s.yw;\n\n    return mix( mix( T(d.yw), T(d.xw), s.x),\n                mix( T(d.yz), T(d.xz), s.x), \n                s.z);\n}\n\nvec4 pseudoCubic(vec2 U )\n{\n    vec2 F = fract(U), I = floor(U);\n    F *= F*(3.-F-F);                          // = smoothstep\n    vec4 d = vec4(.5,-.5,.5,-.5) + 1.;\n    return mix( mix( T(d.yw), T(d.xw), F.x),  // = texelFetch\n                mix( T(d.yz), T(d.xz), F.x), \n                F.y);\n\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 r = iResolution.xy,\n         U = u/8.; // + iTime;\n    O =  u.x < r.x*.6\n           ? u.y > r.y*.4 \n                     ? biCubic( U )                          // true biCubic\n                     : texture(CH, U/R )                     // bilinear = T(I+F)\n           : u.y > r.y*.4 \n                     ? pseudoCubic( U )                      // smoothstep between pixels = T(I+smoothstep(F))\n                     : texture(CH, (floor(U)+.5)/R );        // nearest  = T(I+.5) = texelFetch(iChannel0, ivec2(mod(U,R)), 0 );\n\n // O = .5+.5*sin(31.4*O);                 \n    O = sqrt(O.rrrr);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy/8.;\n    O = vec4( step( abs( length(u-R/2.) - R.y/4. ), .5) );\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}