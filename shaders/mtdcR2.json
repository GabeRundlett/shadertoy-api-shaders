{
    "Shader": {
        "info": {
            "date": "1699448961",
            "description": "floor()-LATTICED Gilbert tessellation,where a straight main road is either horizontal or vertical, and randomly shifted, and that then bleeds into its 2 neighbor tiles,BUT on a hex lattice (instead of rectangle-lattice,by jt) ,making barycentric borders.",
            "flags": 0,
            "hasliked": 0,
            "id": "mtdcR2",
            "likes": 10,
            "name": "Hex/Barycentric ⅁I⅂ᗺƎꓤꓕ┣┳┻┫Tiles",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "hexagon",
                "road",
                "tile",
                "tesselation",
                "gilbert"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 273
        },
        "renderpass": [
            {
                "code": "//A proper noun for this may be \"Gilbert tessellation\", to look up in math texts.\n//https://en.wikipedia.org/wiki/Gilbert_tessellation\n\n//On shadertoy, for speed, we tend to do floor()-lattices before doing a Voronoi.\n//same seems to be true for gilbert tesselation, for speed on smaller neighborhoods.\n\n// parent shader \"Hexagonal Grid Traversal - 2D\" \n// was Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//removed the traversal and the AA, but really needed everything else.\n//especially hexagonGetID() and id2center()\n\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/NlKfWt\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/7ldfzS\n//honorable aunt                    wiggles around: https://www.shadertoy.com/view/DsGBDK\n//honorable uncle    working in industrial storage: https://www.shadertoy.com/view/dtccWn\n//in memory to         something similar was tried: https://www.shadertoy.com/view/clfSDj\n\n//+acos(-1.) offsets the period, because this version demoes what i added shifted-tile-colors\n#define timeOscillator cos(iTime*.6+acos(-1.))*.5+.5\n\n#define rot(a) ;mat2 m=rotby(acos(a));u*=m;center*=m\n//rmax paints a road in locally offset-rotated uv, of height [h]\n#define rmax r=max(r,1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h))))\n\n// return the hexagon that p belongs to\nivec2 uv2id(vec2 p\n){vec2  q=vec2( p.x, p.x*.5+p.y*0.8660254037)\n ;ivec2 i = ivec2(floor(q))\n ;vec2  f =       fract(q)\n ;int v = mod3(i.x+i.y)\n ;ivec2 id = i + v\n ;if( v==2 ) id -= (f.x>f.y)?ivec2(1,2):ivec2(2,1)\n ;return ivec2( id.x, (2*id.y-id.x)/3 );}\n\n// return the center of an hexagon\nvec2 id2center(ivec2 id\n){return vec2(float(id.x),float(id.y)*1.732050807);}\n\n//=============================================================\n\n//*.89 to account for \"road width\" in a hacky way.\nfloat h21(ivec2 i\n){return sin(float(15*i.x)+cos(float(33*i.y)))*.5*.85\n ;}\n \n//extra roads need anarbitiarily different alternative hash.\nfloat h21b(ivec2 i\n){return sin(float(33*i.x)-cos(float(15*i.y)))*.5*.85\n ;}\n\n//brightness factor of gilbert-tesselated-tiles\n#define gttb .3\n\n//green tiles with magenta/pink/purple roads\n//branches always go off clockwise of trunks\nvec3 road0(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){float r=0.,l=0.;rmax//purple main road trunk (is not a fork, sets 2 adjacent forks)\n ;if(u.y-center.y<h//top or bottom forks?\n ){//bottom 2 forks are h21b() hashed, not set by neighbors.\n  ;float h=h21b(i+ivec2(-1,1))\n  ;rot(.5)//height of bottom adjacent yellow\n  ;rmax\n   ;if(u.y-center.y<h\n   ){float h=h21b(i+ivec2(1,1))\n    ;rot(.5)//height of bottom adjacent blue \n    ;rmax\n    ;if(u.y-center.y>h)l=1.;else l=.84\n   ;}\n ;}else{//top 2 forks are set by adacent main roads\n  ;float h=h21(i+ivec2(-1,1))//height of top adjacent blue\n  ;rot(.5)\n  ;rmax\n  ;l=.6\n  ;if(u.y-center.y>h\n  ){float h=h21(i+ivec2(1,1))//height of top adjacent burple\n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y>h)l=.2;else l=.4\n  ;}\n ;}\n \n ;r*=r+.5 //optional; fallof quadratically\n ;return vec3(r,l*gttb,r)\n ;}\n\n//blue tiles with yellow roads\n//branches always go off clockwise of trunks\nvec3 road1(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){float r=0.,l=.6;rot(-.5);rmax//vellow tiles main road trunk\n ;if(u.y-center.y<h\n  ){//2 bottom road forks\n   ;float h=-h21b(i+ivec2(1,-1))//height left adjacent blue\n   ;rot(.5)\n   ;rmax\n   ;l=.4\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21b(i+ivec2(-2,2))//height of top left adjacend purple\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;rot(.5)\n    ;rmax\n    ;if(u.y-center.y>h)l=1.;else l=0.\n    ;}\n  ;}else{\n   ;float h=-h21(i+ivec2(2,0))//height of right adjacent red\n   //-h21 is negated cause a clockwise meets a counterclockwise!!\n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n   ;}else{\n    ;float h=-h21(i+ivec2(1,-1))//height of right adjacent red\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;rot(.5)\n    ;rmax\n    ;if(u.y-center.y>h)l=.2;else l=.8\n   ;}\n  ;}\n  \n ;r*=r+.5 //optional; fallof quadratically\n ;return vec3(r,r,l*gttb)\n ;}\n\n//red tiles with cyan/lightBlue roads\n//branches always go off clockwise of trunks\n//BUT NOT HERE\n//...swapping 1 branch with its trunk to ddisrupt large troiangles\n//that emerge from [all forks branch clockwise]\nvec3 road2(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){mat2 m=rotby(acos(.5));u*=m;center*=m\n ;float r=0.,l=.8;rmax //blue main trunk\n ;if(u.y-center.y<h\n  ){//2 top branches\n   ;float h=h21(i+ivec2(-1,-1))//height \n   ;rot(.5)\n   ;rmax\n   ;l=.6\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21(i+ivec2(-2,0))//height \n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n    ;if(u.y-center.y>h)l=0.;else l=.2\n   ;}\n  ;}else{//2 bottom branches\n      //this trunk was swapped with its branch below\n      ;float h=h21b(i+ivec2(2,2))//connect to right yellow tile \n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n  ;if(u.y-center.y<h\n   ){}else{\n    \n    //this branch was swapped with its trunk above\n  ;float h=h21b(i+ivec2(1,-1))//connect to top right purple tile \n  ;rot(.5)\n  ;rmax\n      ;if(u.y-center.y>h)l=.4;else l=1.\n   ;}\n  ;}\n ;r*=r+.5 //optional; fallof quadratically\n ;return vec3(l*gttb,r,r)\n ;}\n\n\nvec3 roads(vec2 u,ivec2 i,int t//uvScreen,hexID,hexType\n){const float kPtRa = 0.3;\n ;vec2 center=id2center(i);\n ;//vec2 r=1.-smoothstep(-v*0.5,v*0.5,vec2(sdDisk(u,center,kPtRa)))\n ;vec3 r;\n ;float h=h21(i)\n ;     if(t==0)r=road0(u,center,kPtRa,h,i)\n ;else if(t==1)r=road1(u,center,kPtRa,h,i)\n ;else         r=road2(u,center,kPtRa,h,i)\n ;r=mix(vec3(max(max(r.x,r.y),r.z)),r,timeOscillator)//mix road color\n ;return r\n ;}\n\nvec3 render(vec2 u,vec2 v\n){ ;// scale image\n ;u*= mix(22.,9.,timeOscillator)//zoom scale image\n ;v*= mix(22.,9.,timeOscillator)//zoom scale image\n ;ivec2 i=uv2id(u)\n ;int t=(mod3(i.x))\n ;float backgroundBrightness=.5\n ;vec3 col=mix(vec3(0),-.3+.8*vec3(t)/2.*backgroundBrightness,timeOscillator)//mix background tiles showing\n //;vec3 col=mix(vec3(0),vec3(.33),timeOscillator)\n ;col=max(col,roads(u,i,t))*2.\n //vec3  col=vec3(fract(float(i)/3.))\n ;// draw ray\n ;// prepare for hex-traverse\n ;return col;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){if(iMouse.w<0.)u-=iMouse.xy\n ;vec3 c=render((u-iResolution.xy)/iResolution.y,1./iResolution.xy)\n ;o=vec4(c,1);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat sdSegment( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );}\n\n//i could still keeps the unrotated u AND center, and avoid cumulative-rotation-precision-losses.\n//i think i can not get away with less total rotations.\n\n/*\n//hoped to minimize trigonometry rotations but it seems fruitless\n//currently need to rotate uv AND center for each added rotated road.\n//because both are needed to be independently in thebranch condition.\n\n\n//\n//i need to not only rotate a line, but also offset its height, and that rotates 2 points again.\n//using line, so i only need to rotate 1 point\nfloat line( vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\treturn length( pa - ba*h );\n}\n\n//return distance of p to line trough a and vec2(0)\nfloat l0( vec2 p, vec2 a){\n    vec2 b=vec2(0);\n\tvec2 pa=p-a, ba = b-a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\treturn length( pa - ba*h );\n;}*/\n\nfloat sdDisk( vec2 p, vec2 a, float r ){\n\treturn length(p-a)-r;}\n\n//return matrix that rotates by t\nmat2 rotby(float t\n){float ct=cos(t),st=sin(t)\n ;return mat2(ct,-st, st, ct);}\n\n//rotate 60deg clockwise\n#define r60 (mat2(-1,sqrt(3.),-1,-sqrt(3.))*.5)\n\nint   mod3(int   n){return (n<0) ? 2-((2-n)%3) : n%3;}\n//ivec2 mod3(ivec2 n){return ivec2(mod3(n.x),mod3(n.y));}//not needed\n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}