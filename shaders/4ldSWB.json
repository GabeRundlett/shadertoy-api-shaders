{
    "Shader": {
        "info": {
            "date": "1481500402",
            "description": "Edit 2024: The music from Soundcloud keeps getting removed, so I set it to one of Shadertoy's defaults for now.\n\nFeedback welcome. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4ldSWB",
            "likes": 22,
            "name": "Daft Punk - Guy Helmet",
            "published": 3,
            "tags": [
                "daft",
                "punk"
            ],
            "usePreview": 1,
            "username": "lara",
            "viewed": 1251
        },
        "renderpass": [
            {
                "code": "#define S 256   // Steps\n#define R 1.    // Sub steps\n#define P 0.001 // Precision\n#define D 20.   // Max distance\n#define A 5.    // AO steps\n\n#define T iTime\n#define PI 3.1415926\n#define TAU (PI*2.0)\n\nstruct Ray { vec3 o, d; }, _ray;\nstruct Camera { vec3 p, t; }, _cam;\nstruct Hit { vec3 p; float t, d; };\n\nfloat _d,_s;\nfloat _dvisor;\nfloat _dframe;\nfloat _dsignal;\nfloat _dcurtain;\n\n/* ============= */\n/* === UTILS === */\n/* ============= */\n\nfloat hash21(vec2 n)\n{\n    return fract(sin(dot(n,vec2(50159.91193,49681.51239)))*73943.1699);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdPlane(vec3 p,vec3 n,float s)\n{\n    n = normalize(n);\n    return -dot(n*s-p,n);\n}\n\nfloat sdBox(vec3 p,vec3 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,max(p.y,p.z)),0.);\n}\n\nfloat sdLine(vec3 p,vec3 a,vec3 b,float r)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n/* ============= */\n/* === SCENE === */\n/* ============= */\n\nfloat sdBase(vec3 p)\n{\n    float d;\n    \n    // base\n    d = smin(sdEllipsoid(p,vec3(.7,1,1)),sdEllipsoid(p-vec3(0,-.8,-0.),vec3(.7,1,1)),.5);\n    d = smin(d,length(p-vec3(0,.2,.3))-1.,.5);\n    d = smin(d,length(p-vec3(0,-.7,.3))-1.,.5);\n    // side cutoff\n    d = smax(d,sdPlane(vec3(abs(p.x),p.yz),vec3(1,0,0),1.),0.3);\n    \n    return d;\n}\n\nfloat scene(vec3 p)\n{\n    _d = 1e10;\n    \n    float d,s;\n    \n    s = 0.15;\n    \n    // visor/frame separation surface\n    d = sdPlane(p,vec3(0,1,-3.5),0.);\n    d = smin(d,sdPlane(p,vec3(0,1,0),0.4),s);\n    d = smax(d,sdPlane(p,vec3(0,0,-1),0.25),s*4.);\n    d = smin(d,sdPlane(p,vec3(0,1,-0.5),-0.36),s);\n    \n    _dframe = smax(d,sdBase(p),0.02);\n    _dvisor = max(-d,sdBase(p));\n    \n    // back carve out (upper)\n    d = sdPlane(p,vec3(0,1,-3.5),-0.2);\n    d = smax(d,sdPlane(p,vec3(0,-1,-1),-.6),0.1);\n    d = smax(d,sdPlane(p,vec3(0,-1,0),-.15),0.1);\n    d = smax(-d,_dframe,0.02);\n    d = smin(d,sdEllipsoid(p-vec3(0,.2,.3),vec3(.9,1,1)),0.05);\n    \n    _dframe = d;\n\n    // back carve out (lower)\n    d = sdPlane(p,vec3(0,1,0),-.15);\n    d = smax(d,sdPlane(p,vec3(0,-.1,-1),-.8),0.1);\n    d = smax(-d,_dframe,0.02);\n    d = smin(d,sdEllipsoid(p-vec3(0,-.3,.3),vec3(.9,1,1)),0.05);\n    \n    vec3 q = p-vec3(0,-.05,0);\n    \n    float x = abs(q.x)+.03;\n    \n    // side extrusion\n    d = smin(d,smax(length(vec2(max(q.y,0.),q.z-.2))-.3,abs(x-1.)-.05,0.02),0.1);\n    d = smax(d,-max(max(length(vec2(max(q.y,0.),q.z-.2))-.2,abs(x-1.07)-.05),-q.y-.45+q.z*.15),0.02);\n    d = min(d,smax(length(vec2(q.y,q.z-.2))-.13+(x-1.1)*.2,abs(x-1.05)-.1,0.02));\n    d = smax(d,-max(length(vec2(q.y,q.z-.2))-.11,abs(x-1.14)-.02),0.02);\n    \n    // engravings\n    d = smax(d,-sdLine(vec3(abs(p.x),p.yz),vec3(.9,.6,.4),vec3(.97,.1,.3),.015),0.01);\n    \n    // chin emphasis\n    d = smin(d,sdBox(p-vec3(0,-1.1,-.8),vec3(.3,.05,0)),.3);\n    \n    // lower cutoff\n    d = smax(d,sdPlane(p,vec3(0,-1,0.35),0.7),0.1);\n    \n    // hollow out\n    float dbase = -sdBase(p*1.2)/1.2;\n    d = smax(d,dbase,0.1);\n    _dvisor = smax(_dvisor,dbase,0.1);\n    \n    _dframe = d;\n    \n    _dsignal = max(length(vec2(q.y,q.z-.2))-.11,abs(x-1.12)-.01);\n    _dcurtain = abs(length(p)-4.)-P;\n    \n    _d = min(_d,_dvisor);\n    _d = min(_d,_dframe);\n\t_d = min(_d,_dsignal);\n    _d = min(_d,_dcurtain);\n    \n    //_d = min(_d,length(p.xz)-.01);\n    //_d = min(_d,length(p.yz)-.01);\n    //_d = min(_d,length(p.xy)-.01);\n    \n    return _d;\n}\n\n/* ================ */\n/* === MARCHING === */\n/* ================ */\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(P,0);\n    \n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\nHit march(Ray r)\n{\n    float t = 0.0, d;\n    \n    for(int i = 0; i < S; i++)\n    {\n        d = scene(r.o+r.d*t);\n        t += d/R;\n        \n        if (d < P || t > D) { _s = float(i); break; }\n    }\n    \n    return Hit(r.o+r.d*t, t, d);\n}\n\nRay lookAt(Camera cam, vec2 uv)\n{\n    vec3 d = normalize(cam.t-cam.p);\n    vec3 r = normalize(cross(d, vec3(0,1,0)));\n    vec3 u = cross(r, d);\n\n    return Ray(cam.p,normalize(r*uv.x + u*uv.y + d));\n}\n\n/* =============== */\n/* === SHADING === */\n/* =============== */\n\nfloat getAmbientOcclusion(Hit h) \n{\n    float t = 0., a = 0.;\n    \n    for(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i/A*.1);\n        t += d;\n    }\n\n    return clamp(t/A*20.,0.,1.);\n}\n\nvec4 textureBlend(sampler2D t, vec2 uv, float f)\n{\n    float l = length(uv);\n    float a1 = (atan(uv.y, uv.x)+PI)/TAU;\n    float a2 = (atan(uv.y,-uv.x)+PI)/TAU;\n\n    f = pow(abs(1.-min(abs(pow(abs(a1*f-f/2.),2.)),1.))*abs(1.-pow(abs(a1*f-f/2.),4.)),5.);\n\n    // blend one part of the texture over the region where the seam would show\n\n    return mix(texture(t,vec2(a2,l)),texture(t,vec2(a1,l)),f);\n}\n\nvec3 texCurtain(vec3 p)\n{\n\tvec2 q = normalize(p.xz)*1.5;\n    float d = textureBlend(iChannel0,q,8.).x;\n    //float a = pow(texture(iChannel0,vec2(0.3,0.5)).x,2.);\n   \treturn max(vec3(smoothstep(d+.2,d,abs(p.y))),.1);// + pow(_s/float(S),3.-a)*vec3(1,.6,0)*500.*max(a-.1,0.);\n}\n\nvec3 getColor(Hit h)\n{\n    if (h.d > P) { return vec3(0); }\n    \n    vec3 light = vec3(-1,2,-1); //_cam.p;\n    \n    vec3 c = vec3(0);\n    vec3 n = getNormal(h.p);\n    vec3 r = normalize(reflect(_cam.p-h.p,n));\n    vec3 rt = texture(iChannel1,r).rgb;\n\n    float diff = max(dot(n, normalize(light-h.p)),.4);\n    float spec = max(dot(reflect(normalize(h.p-light),n),normalize(_cam.p-h.p)),0.);\n    \n    if (_d == _dvisor)\n    {\n        vec2 q = h.p.yz * rot(.7);\n        \n        float f = (atan(q.y,q.x)+PI)/TAU;\n        float t = abs(abs(h.p.x)-h.p.z*.1-0.83)-.1;\n        float d = smoothstep(t+.02,t+.05,0.);\n        float x = texture(iChannel0,vec2(floor(f*21.)/21.,0.5)).x;\n        \n        // gaps\n        d *= ((1.-pow(abs(sin((f-.5)*21.*PI)),18.)-.5)+1.)/2.;\n        // cutoff\n        t = -h.p.y-abs(h.p.z)*.5;\n        d *= smoothstep(t,t+.05,0.);\n        \n        _ray.o = h.p-r*.1;\n        _ray.d = -r;\n        \n        h = march(_ray);\n        \n        c = mix(vec3(0),hsv2rgb(vec3(floor(f*21.)/7.,.8,pow(max(x-.15,0.)*2.5,3.))),d) + pow(spec,40.) + texCurtain(h.p)*.1;\n    }\n    else if (_d == _dframe)\n    {\n        _ray.o = h.p-r*.1;\n        _ray.d = -r;\n        \n        h = march(_ray);\n        c = texture(iChannel1,getNormal(h.p)).rgb*vec3(1,.9,.4) + pow(spec,40.);\n    }\n    else if (_d == _dsignal)\n    {\n        float a = pow(texture(iChannel0,vec2(.3,.5)).x,2.);\n        float d = abs(h.p.y+0.05-(abs(mod(abs(clamp(h.p.z*1.5-.22,0.,.16)*40./PI*2.-1.),4.)-2.)-1.)*.07)-.01;\n        \n        c = mix(vec3(0),vec3(0,.5+a*3.,0),step(d,0.));\n    }\n    else if (_d == _dcurtain)\n    {\n        c = texCurtain(h.p);\n    }\n\n    return pow(abs(c*getAmbientOcclusion(h)),vec3(1.2))*1.2;\n}\n\n/* ============ */\n/* === MAIN === */\n/* ============ */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.yy;\n    vec2 uvm = iMouse.xy/iResolution.xy;\n    \n    _cam = Camera(vec3(0,.5,-2.5), vec3(0));\n\n    if (iMouse.x > 10. || iMouse.y > 10.)\n    {\n        _cam.p.yz *= rot(-(uvm.y-.4)*2.);\n        _cam.p.xz *= rot((uvm.x-.5)*2.*PI);\n    }\n    else\n    {\n        _cam.p.xz *= rot(sin((T+1.)*.25)*2.);\n    }\n    \n    _ray = lookAt(_cam,uv);\n    \n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)/iResolution.xy)*0.25;\n    \n    f += (hash21(uv+iTime*.001)-.5)*.05;\n    \n    fragColor = vec4(getColor(march(_ray))*f, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}