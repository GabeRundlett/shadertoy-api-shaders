{
    "Shader": {
        "info": {
            "date": "1419015939",
            "description": "Yesterday, I found out about bidirectional path tracing. I didn't read the articles, but looked at the images and I tried to implement something myself. Therefore, I think most of the math will be incorrect - but it looks nice. Only diffuse lighting.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtfGR4",
            "likes": 51,
            "name": "Bidirectional path tracing",
            "published": 3,
            "tags": [
                "box",
                "tracing",
                "cornell",
                "path",
                "bidirectional"
            ],
            "usePreview": 0,
            "username": "reinder",
            "viewed": 8049
        },
        "renderpass": [
            {
                "code": "// Bidirectional path tracing. Created by Reinder Nijhoff 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MtfGR4\n//\n\n#define eps 0.0001\n#define LIGHTPATHLENGTH 2\n#define EYEPATHLENGTH 3\n#define MAXPATHLENGTH 4\n#define SAMPLES 12\n\n#define FULLBOX\n\n#define DOF\n#define ANIMATENOISE\n#define MOTIONBLUR\n\n#define MOTIONBLURFPS 12.\n\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*1.3\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\nstruct LightPathNode {\n    vec3 color;\n    vec3 position;\n    vec3 normal;\n};\n    \n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 rv2 = hash2(seed);\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nvec3 randomSphereDirection(inout float seed) {\n    vec2 h = hash2(seed) * vec2(2.,6.28318530718)-vec2(1,0);\n    float phi = h.y;\n\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nvec3 randomHemisphereDirection( const vec3 n, inout float seed ) {\n\tvec3 dr = randomSphereDirection(seed);\n\treturn dot(dr,n) * dr;\n}\n\n//-----------------------------------------------------\n// renderer\n//-----------------------------------------------------\n\nvec4 lightSphere;\nLightPathNode lpNodes[LIGHTPATHLENGTH];\n\nvoid initLightSphere( float time ) {\n\tlightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7),0.5);\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\n\tvec2 res = vec2( 1e20, -1.0 );\n    float t;\n\t\n\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., 1., 0.); }\n\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., 0.,-1.); }\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\n#ifdef FULLBOX\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., -1., 0.); }\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3(-1., 0., 0.); }\n#endif\n\n\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = nSphere( ro+t*rd, vec4( 1.5,1.0, 2.7,1.0) ); }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 4.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\n    float t;\n\t\n\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\n\n    return false; // optimisation: planes don't cast shadows in this scene\n}\n\nvec3 calcColor( in float mat ) {\n\tvec3 nor = vec3(0.0);\n\t\n\tif( mat<4.5 ) nor = LIGHTCOLOR;\n\tif( mat<3.5 ) nor = WHITECOLOR;\n    if( mat<2.5 ) nor = GREENCOLOR;\n\tif( mat<1.5 ) nor = REDCOLOR;\n\tif( mat<0.5 ) nor = WHITECOLOR;\n\t\t\t\t\t  \n    return nor;\t\t\t\t\t  \n}\n\n//-----------------------------------------------------\n// lightpath\n//-----------------------------------------------------\n\nvoid constructLightPath(inout float seed) {\n    vec3 ro = normalize( hash3(seed)-vec3(0.5) );\n    vec3 rd = randomHemisphereDirection( ro, seed );\n    ro = lightSphere.xyz + ro*0.5;\n    vec3 color = LIGHTCOLOR;\n    \n    lpNodes[0].position = ro;\n    lpNodes[0].color = color;\n    lpNodes[0].normal = rd;\n    \n    for( int i=1; i<LIGHTPATHLENGTH; ++i ) {\n        lpNodes[i].position = lpNodes[i].color = lpNodes[i].normal = vec3(0.);\n    }\n    \n    for( int i=1; i<LIGHTPATHLENGTH; i++ ) {\n\t\tvec3 normal;\n        vec2 res = intersect( ro, rd, normal );\n        if( res.y > -0.5 && res.y < 4. ) {\n            ro = ro + rd*res.x;\n            color *= calcColor( res.y );\n            lpNodes[i].position = ro;\n            lpNodes[i].color = color;\n            lpNodes[i].normal = normal;\n\n            rd = cosWeightedRandomHemisphereDirection( normal, seed );\n        } else break;\n    }\n}\n\n//-----------------------------------------------------\n// eyepath\n//-----------------------------------------------------\n\nvec3 traceEyePath( in vec3 ro, in vec3 rd, inout float seed ) {\n    vec3 col = vec3(0.);\n    vec3 basecol = vec3(1.);\n    \n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\n        vec3 normal;\n        \n        vec2 res = intersect( ro, rd, normal );\n        if( res.y < -0.5 ) return col;\n        if( res.y > 3.5 ) {\n            return col + basecol*LIGHTCOLOR / float( j+1 ); \n        }\n        \n        ro = ro + res.x * rd;\n        rd = cosWeightedRandomHemisphereDirection( normal, seed );\n        \n        basecol *= calcColor( res.y );\n        \n\t    for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\n            if( i+j >= MAXPATHLENGTH ) continue;\n            \n            vec3 lp = lpNodes[i].position - ro;\n            vec3 lpn = normalize( lp );\n            vec3 lc = lpNodes[i].color;\n            \n            if( !intersectShadow(ro, lpn, length(lp)-eps) ) {\n                col += clamp( dot( lpn, normal ), 0., 1.) * lc * basecol\n                    * clamp(  dot( lpNodes[i].normal, -lpn ), 0., 1.)\n                    * clamp( 1./dot(lp,lp), 0., 1. )\n                    / float( i+j+1 );\n            }\n        }\n    }    \n    return col;\n}\n\n//-----------------------------------------------------\n// main\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n#ifdef ANIMATENOISE\n    float seed = p.x + fract(p.y * 18753.43121412313) + fract(12.12345314312*iTime);\n#else\n    float seed = p.x + fract(p.y * 18753.43121412313);\n#endif\n    \n    vec3 ro = vec3(2.78, 2.73, -8.00);\n    vec3 ta = vec3(2.78, 2.73,  0.00);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n\n    vec3 col = vec3(0.0);\n    vec3 tot = vec3(0.0);\n    vec3 uvw = vec3(0.0);\n\n    for( int a=0; a<SAMPLES; a++ ) {\n        \n        vec2 rpof = 4.*(hash2(seed)-vec2(0.5)) / iResolution.xy;\n\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\n        \n#ifdef DOF\n\t    vec3 fp = ro + rd * 12.0;\n   \t\tvec3 rof = ro + (uu*(hash1(seed)-0.5) + vv*(hash1(seed)-0.5))*0.125;\n    \trd = normalize( fp - rof );\n#else\n        vec3 rof = ro;\n#endif        \n        \n#ifdef MOTIONBLUR\n        initLightSphere( iTime + hash1(seed) / MOTIONBLURFPS );\n#else\n        initLightSphere( iTime );        \n#endif\n        \n        constructLightPath(seed);\n        col = traceEyePath( rof, rd, seed );\n\n        tot += col;\n        \n        seed = mod( seed*1.1234567893490423, 13. );\n    }\n    \n    tot /= float(SAMPLES);\n\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}