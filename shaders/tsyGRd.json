{
    "Shader": {
        "info": {
            "date": "1570737073",
            "description": "Still toying with kifs.\nuse the mouse to enable anaglyphe.\n\nTraining for the cookie party ;)\nhttps://2019.cookie.paris/",
            "flags": 0,
            "hasliked": 0,
            "id": "tsyGRd",
            "likes": 3,
            "name": "Anaglyphe Dojo 04",
            "published": 3,
            "tags": [
                "kifs",
                "training",
                "anaglyphe"
            ],
            "usePreview": 0,
            "username": "antonOTI",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "#define  PI 3.14159\n#define ANAGLYPHE 1.\n#define SCREEN_SHOT\n#ifdef SCREEN_SHOT\n#define TIME (13.5)\n#else\n#define TIME (iTime + 1.5)\n#endif\n\nfloat kifDist(vec2 uv, float a,float stepp)\n{\n    \n    uv *= 2.;\n    \n    float overAngle = -1. / 4. * PI ;\n    uv.y = abs(uv.y);\n    uv.y += tan(overAngle) * .5;\n    \n    vec2 n =vec2(sin(overAngle), cos(overAngle)); \n    \n    uv.x = abs(uv.x);\n    uv -= n * min(0., dot(uv - vec2(.5,0.), n)) * 2.;\n    \n    n = vec2(sin(a), cos(a));\n    \n    uv.x += .5;\n    \n    for(float it = 0.; it < 5.; ++it)\n    {\n        uv *= 3.;\n        uv.x -=1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -=.5;\n        \n       // uv.y = min(uv.y, r);\n        uv.x = max(uv.x, stepp);\n        uv -= n * min(0., dot(uv, n)) * 2.;\n        \n        //uv *= rot(TIME);\n    }\n        \n    float f = length(uv - vec2(clamp(uv.x,-1.,1.), 0.));\n    \n    return f;\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    float a = 2. / 3. * PI + sin(TIME) * PI * .33;\n    float f = kifDist(uv, a);\n\n    \n    \n    col += smoothstep(.5, .0,f);\n    \n    fragColor = vec4(col,0.);\n}*/\n\nfloat solid(vec3 p)\n{\n    float r = TIME;\n    for(float i = 1.; i < 7.; ++i)\n    {\n        p.xz *= rot(r);\n        p.yz *= rot(r);\n        p.xz *= rot(-r);\n        r *= .75;\n        p = abs(p);\n    }\n    \n    return max( p.x ,max( p.y, p.z)) ;\n}\n\nfloat map(vec3 p)\n{\n    float sold =  solid(p + vec3(0.,0.,30.)) -1.;\n    \n    p.x = abs(p.x);\n    p.xy *= rot(p.z * .0025);\n    p.z -= TIME * 10.;\n    float a = 2./3. * PI;\n    \n    float av = p.z * .00125 + TIME * .25;\n    //av = floor(av) + sin(fract(av) * PI) * .5 + .5;\n    a += sin(av );\n    float stepp = sin(p.z * .05) * .5 - .5 ;\n    float dist = abs(kifDist(p.xy *.0025, a, stepp)) - 1.;\n    \n    //dist = min(dist,sold);\n    \n    return dist;\n}\n\n// End of custom part.\n\nconst float grain = .01;\nconst float fieldOfView = 1.5;\nfloat divergence = 0.2;\n\nfloat raymarch ( vec3 eye, vec3 ray ) {\n    float dither = random(ray.xy+fract(iTime));\n    float total = dither;\n    const int count = 60;\n    for (int index = count; index > 0; --index) {\n        float dist = map(eye+ray*total);\n        dist *= 0.9+.025*dither;\n        total += dist;\n        if (dist < 0.001 * total)\n            return float(index)/float(count);\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float anaglypheEnable = ANAGLYPHE;\n    divergence *= anaglypheEnable;\n    \n    vec3 eyeLeft = vec3(-divergence,0,5.);\n    vec3 eyeRight = vec3(divergence,0,5.);\n    vec3 rayLeft = look(eyeLeft, vec3(0), uv, fieldOfView);\n    vec3 rayRight = look(eyeRight, vec3(0), uv, fieldOfView);\n    float red = raymarch(eyeLeft, rayLeft);\n    float cyan = raymarch(eyeRight, rayRight);\n    fragColor = vec4(red,vec2(cyan),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Anaglyph Quick Sketch\n// An example on how to render stereoscopic anaglyph image\n// It will be the theme of https://2019.cookie.paris/\n// And the content of the 3rd issue of https://fanzine.cookie.paris/\n// Licensed under hippie love conspiracy\n\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\n\nvec3 look (vec3 eye, vec3 target, vec2 anchor, float fov) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * fov + right * anchor.x + up * anchor.y);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}