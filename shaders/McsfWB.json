{
    "Shader": {
        "info": {
            "date": "1724327715",
            "description": "Path traced marbles and lights with defocus blur\nClick to reset\n\nTechnically this is not the correct way to do path tracing since the scene changes with each ray because of RNG, but it ended up making these crystal balls look like soap bubbles.",
            "flags": 32,
            "hasliked": 0,
            "id": "McsfWB",
            "likes": 1,
            "name": "Million de bulles",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "Docteur_Raton",
            "viewed": 138
        },
        "renderpass": [
            {
                "code": "vec4 reconstructImage(vec2 fragCoord)\n{\n\tvec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\tcolor.rgb = color.rgb / color.a;\n\tcolor.a = 1.;\n\n\treturn color;\n}\n\nvec3 applyGammaCorrection(vec3 color)\n{\n\treturn pow(color, vec3(1. / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tfragColor = reconstructImage(fragCoord);\n\tfragColor.rgb = applyGammaCorrection(fragColor.rgb);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PROPERTY_LAMBERTIAN 0\n#define PROPERTY_METAL 1\n#define PROPERTY_DIELECTRIC 2\n#define PROPERTY_DIFFUSE_LIGHT 3\n\nstruct Material\n{\n\tint property;\n\tvec3 albedo;\n\n\t// For metals.\n\tfloat fuzz;\n\n\t// For dielectrics.\n\tfloat refractionIndex;\n\n    // For lights.\n\tvec3 lightColor;\n};\n\nstruct HitRecord\n{\n\tfloat dist;\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Tracing\n{\n\tRay ray;\n\tHitRecord hit;\n};\n\nstruct Camera\n{\n\tvec3 origin;\n\tvec3 lookAt;\n\tvec3 horizontal;\n\tvec3 vertical;\n\tfloat lensRadius;\n\tvec3 u;\n\tvec3 v;\n\tvec3 w;\n};\n\nconst float pi = acos(-1.);\nconst float renderDistance = 100.;\nvec3 s = vec3(0., 1., -1.);\n\nint randomSeed = 0;\nint timeIndependentSeed = 17;\n\nfloat dot2(float x)\n{\n\treturn x * x;\n}\n\nfloat dot2(vec3 v)\n{\n\treturn dot(v, v);\n}\n\n// https://www.shadertoy.com/view/XlGcRh\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat generateRandom()\n{\n\tint m = 1 << 16 + 1;\n\trandomSeed = (75 * randomSeed + 74) % m;\n\n\treturn float(randomSeed) / float(m);\n}\n\nvec3 generateRandomUnit()\n{\n\tvec3 p = s.xxx;\n\tdo\n\t{\n\t\tp.x = generateRandom();\n\t\tp.y = generateRandom();\n\t\tp.z = generateRandom();\n\t\tp = 2. * p - 1.;\n\t} while (dot2(p) >= 1.);\n\n\treturn normalize(p);\n}\n\nfloat generateTimeIndependentRandom()\n{\n\tint m = 1 << 16 + 1;\n\ttimeIndependentSeed = (75 * timeIndependentSeed + 74) % m;\n\n\treturn float(timeIndependentSeed) / float(m);\n}\n\nvec3 generateTimeIndependentRandomUnit()\n{\n\tvec3 p = s.xxx;\n\tdo\n\t{\n\t\tp.x = generateTimeIndependentRandom();\n\t\tp.y = generateTimeIndependentRandom();\n\t\tp.z = generateTimeIndependentRandom();\n\t\tp = 2. * p - 1.;\n\t} while (dot2(p) >= 1.);\n\n\treturn normalize(p);\n}\n\nCamera createCamera(vec3 origin, vec3 lookAt, vec3 vup,\n\tfloat verticalFovDegrees, float aspectRatio, float aperture)\n{\n\tvec3 w = normalize(lookAt - origin);\n\tvec3 u = normalize(cross(w, vup));\n\tvec3 v = normalize(cross(u, w));\n\tfloat verticalFovGradians = radians(verticalFovDegrees);\n\tfloat halfHeight = tan(.5 * verticalFovGradians);\n\tfloat halfWidth = aspectRatio * halfHeight;\n\tfloat focusDist = length(lookAt - origin);\n\tvec3 horizontal = halfWidth * focusDist * u;\n\tvec3 vertical = halfHeight * focusDist * v;\n\n\treturn Camera(origin, lookAt, horizontal, vertical, .5 * aperture, u, v, w);\n}\n\nTracing traceSphere(Tracing tracing, vec3 center, float radius, Material material)\n{\n\tvec3 ro = tracing.ray.origin - center;\n\tvec3 rd = tracing.ray.direction;\n\tfloat discriminant = dot2(dot(ro, rd)) - dot2(rd) * (dot2(ro) - dot2(radius));\n\tif (discriminant < 0.)\n\t\treturn tracing;\n\tfloat distCur = (-dot(ro, rd) - sqrt(discriminant)) / dot2(rd);\n\tif (distCur < 0.001 || distCur >= tracing.hit.dist)\n\t\treturn tracing;\n\ttracing.hit.dist = distCur;\n\ttracing.hit.position = tracing.ray.origin + distCur * rd;\n\ttracing.hit.normal = normalize(tracing.hit.position - center);\n\ttracing.hit.material = material;\n\t\n\treturn tracing;\n}\n\nTracing tracePlane(Tracing tracing, vec3 normal, vec3 point, Material material)\n{\n\tvec3 ro = tracing.ray.origin;\n\tvec3 rd = tracing.ray.direction;\n\tfloat distCur = dot(point - ro, normal) / dot(rd, normal);\n\tif (distCur < 0.001 || distCur >= tracing.hit.dist)\n\t\treturn tracing;\n\ttracing.hit.dist = distCur;\n\ttracing.hit.position = tracing.ray.origin + distCur * rd;\n\ttracing.hit.normal = normal;\n\ttracing.hit.material = material;\n\t\n\treturn tracing;\n\n}\n\nvec2 generateAntiAliasingOffset()\n{\n\treturn vec2(generateRandom(), generateRandom()) / iResolution.xy;\n}\n\nvec3 findScatterDirectionLambertian(Tracing tracing)\n{\n\treturn normalize(tracing.hit.normal + generateRandomUnit());\n}\n\nvec3 findScatterDirectionMetal(Tracing tracing)\n{\n\tvec3 rd = reflect(tracing.ray.direction, tracing.hit.normal);\n\trd += tracing.hit.material.fuzz * generateRandomUnit();\n\tbool isScattered = dot(rd, tracing.hit.normal) > 0.;\n\trd = isScattered ? normalize(rd) : s.xxx;\n\n\treturn rd;\n}\n\nfloat findReflectivity(float refractionIndicesRatio, float incidentCosine)\n// Uses Schlick's approximation.\n{\n\tfloat r0 = (refractionIndicesRatio - 1.) / (refractionIndicesRatio + 1.);\n\tr0 = r0 * r0;\n\n\treturn r0 + (1. - r0) * pow(1. - incidentCosine, 5.);\n}\n\nbool isReflected(float refractionIndicesRatio, float incidentCosine)\n{\n\tfloat probability = findReflectivity(refractionIndicesRatio,\n\t\tincidentCosine);\n\n\treturn generateRandom() < probability;\n}\n\nvec3 findScatterDirectionDielectric(Tracing tracing)\n{\n\tfloat cosine = dot(-tracing.ray.direction, tracing.hit.normal);\n\tbool entering = cosine > 0.;\n\tif (entering && isReflected(1. / tracing.hit.material.refractionIndex, cosine))\n\t\treturn reflect(tracing.ray.direction, tracing.hit.normal);\n\tfloat sign;\n\tfloat ratio;\n\tif (entering)\n\t{\n\t\tsign = 1.;\n\t\tratio = 1. / tracing.hit.material.refractionIndex;\n\t}\n\telse\n\t{\n\t\tsign = -1.;\n\t\tratio = tracing.hit.material.refractionIndex;\n\t}\n\tvec3 rd = refract(tracing.ray.direction, sign * tracing.hit.normal, ratio);\n\trd = normalize(rd);\n\n\treturn rd;\n}\n\n// Returns a ray with direction (0., 0., 0.) if the ray is absorbed instead.\nRay scatter(Tracing tracing)\n{\n\tvec3 rd = s.xxx;\n\tswitch (tracing.hit.material.property)\n\t{\n\tcase PROPERTY_LAMBERTIAN:\n\t\trd = findScatterDirectionLambertian(tracing);\n\t\tbreak;\n\tcase PROPERTY_METAL:\n\t\trd = findScatterDirectionMetal(tracing);\n\t\tbreak;\n\tcase PROPERTY_DIELECTRIC:\n\t\trd = findScatterDirectionDielectric(tracing);\n\t\tbreak;\n\t}\n\tvec3 ro = tracing.hit.position;\n\n\treturn Ray(ro, rd);\n}\n\nMaterial createMaterialLambertian(vec3 albedo)\n{\n\treturn Material(PROPERTY_LAMBERTIAN, albedo, 0., 0., s.xxx);\n}\n\nMaterial createMaterialMetal(vec3 albedo, float fuzz)\n{\n\treturn Material(PROPERTY_METAL, albedo, fuzz, 0., s.xxx);\n}\n\nMaterial createMaterialDielectric(float refractionIndex)\n{\n\treturn Material(PROPERTY_DIELECTRIC, s.yyy, 0., refractionIndex, s.xxx);\n}\n\nMaterial createMaterialDiffuseLight(vec3 lightColor)\n{\n\treturn Material(PROPERTY_DIFFUSE_LIGHT, s.xxx, 0., 0., lightColor);\n}\n\nTracing traceWorld(Ray ray)\n{\n\tMaterial blankMaterial = Material(0, s.xxx, 0., 0., s.xxx);\n\tHitRecord hit = HitRecord(renderDistance, s.xxx, s.yxx, blankMaterial);\n\tTracing tracing = Tracing(ray, hit);\n\tfor (float i = 0.; i < 40.; ++i)\n\t{\n\t\tvec3 randomPosition = generateTimeIndependentRandomUnit();\n\t\tfloat randomValue = generateTimeIndependentRandom();\n\t\tint randomProperty = int(floor(6. * generateTimeIndependentRandom()));\n\t\tswitch (randomProperty)\n\t\t{\n\t\t// case PROPERTY_LAMBERTIAN:\n\t\t//   \ttracing = traceSphere(tracing, vec3(1., 1., 1.) * randomPosition + 2. * s.xxz, .25 * (randomValue + .5), createMaterialLambertian(.5 + .5 * randomPosition));\n\t\t//   \tbreak;\n\t\t// case PROPERTY_METAL:\n\t\t// \ttracing = traceSphere(tracing, vec3(1.2, 1.2, 1.) * randomPosition + 2. * s.xxz, .25 * (randomValue + .5), createMaterialMetal(.5 + .5 * randomPosition, randomValue));\n\t\t// \tbreak;\n\t\tcase PROPERTY_DIELECTRIC:\n\t\t\ttracing = traceSphere(tracing, vec3(1.4, 1.2, 1.) * randomPosition + 2. * s.xxz, .25 * (randomValue + .5), createMaterialDielectric(1. + 10. * randomValue));\n\t\t \tbreak;\n\t\tdefault:\n\t\t \ttracing = traceSphere(tracing, vec3(7. * normalize(randomPosition.xy), 2. * randomPosition.z) + 2. * s.xxz, 1. * randomValue, createMaterialDiffuseLight(5. * (randomPosition + 1.)));\n\t\t \tbreak;\n\t\t}\n\t}\n\n\treturn tracing;\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 generatePalette(float t)\n{\n\t// vec3 a = vec3(0.788, 0.680, 0.680);\n\t// vec3 b = vec3(0.130, 0.130, 0.130);\n\t// vec3 c = vec3(1.000, 1.000, 1.000);\n\t// vec3 d = vec3(0.000, 0.333, 0.667);\n\n\tvec3 a = vec3(0.948, 0.840, 0.840);\n\tvec3 b = vec3(0.170, 0.170, 0.170);\n\tvec3 c = vec3(1.000, 1.000, 1.000);\n\tvec3 d = vec3(0.000, 0.333, 0.667);\n\t\n\treturn .85 * (a + b * cos(2. * pi * (c * t + d)));\n}\n\nvec3 generateSky(vec3 attenuation, vec3 rayDirection)\n{\n\treturn attenuation * generatePalette(.35 * (dot(rayDirection.xy, vec2(1., 2.)) + 1.));\n}\n\nvec3 findRayColor(Ray ray)\n{\n\tvec3 attenuation = s.yyy;\n\tfloat maxReflections = 10.;\n\tfor (float iReflection = 0.; iReflection < maxReflections; ++iReflection)\n\t{\n\t\tTracing tracing = traceWorld(ray);\n\t\tif (tracing.hit.dist >= renderDistance)\n\t\t\treturn generateSky(attenuation, tracing.ray.direction);\n\t\tif (tracing.hit.material.property == PROPERTY_DIFFUSE_LIGHT)\n\t\t\treturn attenuation * tracing.hit.material.lightColor;\n\t\tray = scatter(tracing);\n\t\tif (ray.direction == s.xxx)\n\t\t// Absorption.\n\t\t\treturn s.xxx;\n\t\tattenuation *= tracing.hit.material.albedo;\n\t}\n\n\treturn s.xxx;\n}\n\nRay createRay(Camera camera, vec2 uv)\n{\n\tvec3 random = camera.lensRadius * generateRandomUnit();\n\tvec3 rd = camera.lookAt - camera.origin + uv.x * camera.horizontal + uv.y * camera.vertical;\n\n\tvec3 offset = camera.u * random.x + camera.v * random.y;\n\trd -= offset;\n\trd = normalize(rd);\n\n\t// Might be useless.\n\trd += vec3(generateAntiAliasingOffset(), 0.);\n\trd = normalize(rd);\n\t\n\tvec3 ro = camera.origin + offset;\n\n\treturn Ray(ro, rd);\n}\n\nvec3 render(vec2 uv)\n{\n\tfloat numRays = 5.;\n\tCamera camera = createCamera(4.5 * s.xxz, 2. * s.xxz, s.xyx, 45., 1., .2);\n\tvec3 colTotal = s.xxx;\n\tfor (float iRay = 0.; iRay < numRays; ++iRay)\n\t{\n\t\tRay ray = createRay(camera, uv);\n\t\tcolTotal += findRayColor(ray);\n\t}\n\n\treturn colTotal / numRays;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\trandomSeed = int(1128.418231543 * hash12(uv + iTime * s.xy));\n\tfragColor = step(0., -iMouse.z) * texelFetch(iChannel0, ivec2(fragCoord), 0) + vec4(render(uv), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}