{
    "Shader": {
        "info": {
            "date": "1556330126",
            "description": "This modification of the LibXOR Color model shader (https://www.shadertoy.com/view/MttBD7) allows you to drag and change control bits on the bottom. White bits: mix -- Red: color1 hue shift (0, 7.5, 15, 180) -- Green: color2 hue shift -- Blue: negative.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlfGWN",
            "likes": 5,
            "name": "LibXOR Color Model (clickable)",
            "published": 3,
            "tags": [
                "color",
                "palette",
                "colormixing"
            ],
            "usePreview": 0,
            "username": "microwerx",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "vec3 getColor(int index) {\n    if (index == 0) return vec3(0.000, 0.000, 0.000); //Black\n    if (index == 1) return vec3(0.333, 0.333, 0.333); //Gray33\n    if (index == 2) return vec3(0.667, 0.667, 0.667); //Gray67\n    if (index == 3) return vec3(1.000, 1.000, 1.000); //White\n    if (index == 4) return vec3(1.000, 0.000, 0.000); //Red\n    if (index == 5) return vec3(0.894, 0.447, 0.000); //Orange\n    if (index == 6) return vec3(0.894, 0.894, 0.000); //Yellow\n    if (index == 7) return vec3(0.000, 1.000, 0.000); //Green\n    if (index == 8) return vec3(0.000, 0.707, 0.707); //Cyan\n    if (index == 9) return vec3(0.000, 0.447, 0.894); //Azure\n    if (index == 10) return vec3(0.000, 0.000, 1.000); //Blue\n    if (index == 11) return vec3(0.447, 0.000, 0.894); //Violet\n    if (index == 12) return vec3(0.894, 0.000, 0.447); //Rose\n    if (index == 13) return vec3(0.500, 0.250, 0.000); //Brown\n    if (index == 14) return vec3(0.830, 0.670, 0.220); //Gold\n    if (index == 15) return vec3(0.250, 0.500, 0.250); //ForestGreen\n    return vec3(0.0);\n}\n\nvec3 getColorHSLuv(int index) {\n    const float f = 0.333333333;\n    const float g = 0.666666667;\n    const float z = 0.000000000;\n    const float d = 1.000000000;\n    const float dhsl = (360.0 / 12.0) / 360.0;\n    const float dhsluv = 360.0 / 12.0;\n    if (index == 0) return vec3(z, z, z);  // Black\n    if (index == 1) return vec3(f, f, f); // Gray33\n    if (index == 2) return vec3(g, g, g); // Gray67\n    if (index == 3) return vec3(d, d, d);  // White\n    return hsluvToRgb(float(index - 4) * dhsluv, 100.0, 50.0);\n}\n\nvec3 complementary(vec3 rgb) {\n    vec3 hsl = rgb2hsl(rgb);\n    hsl.r += 0.5;\n    if (hsl.r > 1.0) hsl.r -= 1.0;\n    return hsl2rgb(hsl);\n}\n\nvec3 modHSL(vec3 rgb, float dh) {\n    vec3 hsl = rgb2hsl(rgb);\n    hsl.r += dh / 360.0;\n    if (hsl.r > 1.0) hsl.r -= 1.0;\n    return hsl2rgb(hsl);\n}\n\n\nvec3 modHSLuv(vec3 rgb, float dh) {\n    vec3 hsl = rgbToHsluv(rgb);\n    hsl.r += dh;\n    if (hsl.r > 360.0) hsl.r -= 360.0;\n    return hsluvToRgb(hsl);\n}\n\nfloat modulus(float x, float a) {\n    return x - a * floor(x / a);\n}\n\nvoid bitfield(out vec3 color, in vec2 uv) {\n    int t = int(float(iMouse.x) / float(iResolution.x) * 255.99);\n    float bits = float(t);\n    float bit1 = mod(bits,   2.0); bits -= bit1; bit1 = bit1 > 0.0 ? 1.0 : 0.0;\n    float bit2 = mod(bits,   4.0); bits -= bit2; bit2 = bit2 > 0.0 ? 1.0 : 0.0;\n    float bit3 = mod(bits,   8.0); bits -= bit3; bit3 = bit3 > 0.0 ? 1.0 : 0.0;\n    float bit4 = mod(bits,  16.0); bits -= bit4; bit4 = bit4 > 0.0 ? 1.0 : 0.0;\n    float bit5 = mod(bits,  32.0); bits -= bit5; bit5 = bit5 > 0.0 ? 1.0 : 0.0;\n    float bit6 = mod(bits,  64.0); bits -= bit6; bit6 = bit6 > 0.0 ? 1.0 : 0.0;\n    float bit7 = mod(bits, 128.0); bits -= bit7; bit7 = bit7 > 0.0 ? 1.0 : 0.0;\n    float bit8 = mod(bits, 256.0); bits -= bit8; bit8 = bit8 > 0.0 ? 1.0 : 0.0;\n    \n    int test = t;\n\n    int index1 = int(uv.x);\n    int index2 = int(uv.y);\n\n        // Show counter on bottom right\n    if (index2 == 1) {\n        const vec3 BLK = vec3(0.0, 0.0, 0.0);\n        const vec3 RED = vec3(1.0, 0.0, 0.0);\n        const vec3 GRN = vec3(0.0, 1.0, 0.0);\n        const vec3 BLU = vec3(0.0, 0.0, 1.0);\n        const vec3 WHT = vec3(1.0, 1.0, 1.0);\n        if (index1 == 15 && (test & 1)   != 0) color = WHT;\n        else if (index1 == 14 && (test & 2)   != 0) color = WHT;\n        else if (index1 == 13 && (test & 4)   != 0) color = WHT;\n        else if (index1 == 12 && (test & 8)   != 0) color = WHT;\n        else if (index1 == 11 && (test & 16)  != 0) color = WHT;\n        else if (index1 == 10 && (test & 32)  != 0) color = WHT;\n        else if (index1 ==  9 && (test & 64)  != 0) color = WHT;\n        else if (index1 ==  8 && (test & 128) != 0) color = WHT;\n        else if (index1 >= 8) color = RED;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int maxColorIndex = 16;\n    const float maxColors = 16.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(maxColors) * fragCoord/iResolution.xy;\n    \n    // int t = int(floor(mod(iTime, 16.0)));\n    int t = int(float(iMouse.x) / float(iResolution.x) * 255.99);\n    float bits = float(t);//floor(iTime * 4.0);\n    float bit1 = mod(bits,   2.0); bits -= bit1; bit1 = bit1 > 0.0 ? 1.0 : 0.0;\n    float bit2 = mod(bits,   4.0); bits -= bit2; bit2 = bit2 > 0.0 ? 1.0 : 0.0;\n    float bit3 = mod(bits,   8.0); bits -= bit3; bit3 = bit3 > 0.0 ? 1.0 : 0.0;\n    float bit4 = mod(bits,  16.0); bits -= bit4; bit4 = bit4 > 0.0 ? 1.0 : 0.0;\n    float bit5 = mod(bits,  32.0); bits -= bit5; bit5 = bit5 > 0.0 ? 1.0 : 0.0;\n    float bit6 = mod(bits,  64.0); bits -= bit6; bit6 = bit6 > 0.0 ? 1.0 : 0.0;\n    float bit7 = mod(bits, 128.0); bits -= bit7; bit7 = bit7 > 0.0 ? 1.0 : 0.0;\n    float bit8 = mod(bits, 256.0); bits -= bit8; bit8 = bit8 > 0.0 ? 1.0 : 0.0;\n    \n    // un/comment out below to see blending\n    //bit1=bit2=bit3=0.0;\n\n    float mixture = bit1 + 2.0*bit2 + 4.0*bit3;\n    int shift1 = int(bit4 + 2.0*bit5);\n    int shift2 = int(bit6 + 2.0*bit7);\n    bool negative = bit8 > 0.0;\n    bool click = false;//iMouse.z > 0.5;\n    \n    int i = 0;\n    int j = 0;\n    if (uv.x >= maxColors) i++;\n    if (uv.y >= maxColors) j++;\n    int index1 = int(uv.x); if (index1 >= maxColorIndex) index1 -= maxColorIndex;\n    int index2 = int(uv.y); if (index2 >= maxColorIndex) index2 -= maxColorIndex;\n    float mixAmount = 1.0 * float(mixture) / 8.0;\n    /*\n    if (i == 0) mixAmount = 0.5;\n    if (i == 1) mixAmount = 0.75;\n    if (i == 2) mixAmount = 0.5;\n    if (i == 3) mixAmount = 1.0;\n    */\n    vec3 color1 = click ? getColorHSLuv(index1) : getColor(index1);\n    vec3 color2 = click ? getColorHSLuv(index2) : getColor(index2);\n    \n    const float hueshift1 = 7.5;\n    const float hueshift2 = 15.0;\n    const float hueshift3 = 180.0;\n    \n    if (click) {\n        if (index1 >= 4) {\n            if (shift1 == 1) color1 = modHSLuv(color1, hueshift1);\n            if (shift1 == 2) color1 = modHSLuv(color1, hueshift2);\n            if (shift1 == 3) color1 = modHSLuv(color1, hueshift3);\n        }\n\n        if (index2 >= 4) {\n            if (shift2 == 1) color2 = modHSLuv(color2, hueshift1);\n            if (shift2 == 2) color2 = modHSLuv(color2, hueshift2);\n            if (shift2 == 3) color2 = modHSLuv(color2, hueshift3);        \n        }\n    } else {\n        if (index1 >= 4) {\n            if (shift1 == 1) color1 = modHSL(color1, hueshift1);\n            if (shift1 == 2) color1 = modHSL(color1, hueshift2);\n            if (shift1 == 3) color1 = modHSL(color1, hueshift3);\n        }\n\n        if (index2 >= 4) {\n            if (shift2 == 1) color2 = modHSL(color2, hueshift1);\n            if (shift2 == 2) color2 = modHSL(color2, hueshift2);\n            if (shift2 == 3) color2 = modHSL(color2, hueshift3);        \n        }\n    }\n  \n    vec3 from_gamma = vec3(1.0);\n    vec3 to_gamma = vec3(1.0);\n    vec3 color = vec3(0.0);\n    if (index1 <= index2) {\n        float t = mixAmount;\n        color = (1.0 - t) * pow(color1,from_gamma) + t * pow(color2,from_gamma);\n        if (negative) {\n            color = vec3(1.0) - color;\n        }\n        color = pow(color, to_gamma);\n    }\n\n    // Show counter on bottom right\n    if (index2 == 0) {\n        const vec3 RED = vec3(1.0, 0.0, 0.0);\n        const vec3 GRN = vec3(0.0, 1.0, 0.0);\n        const vec3 BLU = vec3(0.0, 0.0, 1.0);\n        const vec3 WHT = vec3(1.0, 1.0, 1.0);\n        if (index1 == (maxColorIndex-1) && bit1 == 1.0) color = WHT * bit1;\n        if (index1 == (maxColorIndex-2) && bit2 == 1.0) color = WHT * bit2;\n        if (index1 == (maxColorIndex-3) && bit3 == 1.0) color = WHT * bit3;\n        if (index1 == (maxColorIndex-4) && bit4 == 1.0) color = RED * bit4;\n        if (index1 == (maxColorIndex-5) && bit5 == 1.0) color = RED * bit5;\n        if (index1 == (maxColorIndex-6) && bit6 == 1.0) color = GRN * bit6;\n        if (index1 == (maxColorIndex-7) && bit7 == 1.0) color = GRN * bit7;\n        if (index1 == (maxColorIndex-8) && bit8 == 1.0) color = BLU * bit8;\n    }\n    \n    // vec3 color;\n    //bitfield(color, uv);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n    return (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n    return sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n    vec3 len = y / (sin(theta) - x * cos(theta));\n    if (len.r < 0.0) {len.r=1000.0;}\n    if (len.g < 0.0) {len.g=1000.0;}\n    if (len.b < 0.0) {len.b=1000.0;}\n    return len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub0 = L + 16.0;\n    float sub1 = sub0 * sub0 * sub0 * .000000641;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bounds0x = top1 / bottom;\n    vec3 bounds0y = top2 / bottom;\n\n    vec3 bounds1x =              top1 / (bottom+126452.0);\n    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n    float hrad = radians(H);\n\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bound0x = top1 / bottom;\n    vec3 bound0y = top2 / bottom;\n\n    vec3 bound1x =              top1 / (bottom+126452.0);\n    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n    const mat3 m = mat3( \n        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n    \n    return hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    const mat3 m = mat3(\n        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n    );\n    return hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n    float X = tuple.x;\n    float Y = tuple.y;\n    float Z = tuple.z;\n\n    float L = hsluv_yToL(Y);\n    \n    float div = 1./dot(tuple,vec3(1,15,3)); \n\n    return vec3(\n        1.,\n        (52. * (X*div) - 2.57179),\n        (117.* (Y*div) - 6.08816)\n    ) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n    float L = tuple.x;\n\n    float U = tuple.y / (13.0 * L) + 0.19783000664283681;\n    float V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n    float Y = hsluv_lToY(L);\n    float X = 2.25 * U * Y / V;\n    float Z = (3./V - 5.)*Y - (X/3.);\n\n    return vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n    float L = tuple.x;\n    float U = tuple.y;\n    float V = tuple.z;\n\n    float C = length(tuple.yz);\n    float H = degrees(atan(V,U));\n    if (H < 0.0) {\n        H = 360.0 + H;\n    }\n    \n    return vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n    float hrad = radians(tuple.b);\n    return vec3(\n        tuple.r,\n        cos(hrad) * tuple.g,\n        sin(hrad) * tuple.g\n    );\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n    return xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n    return luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n    return lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n    return lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n    return lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n    return lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n    return xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\n\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}\n\nvec3 rgb2hsl(vec3 rgb) {\n    float cmin = min(rgb.r,min(rgb.g,rgb.b));\n    float cmax = max(rgb.r,max(rgb.g,rgb.b));\n    float diff = cmax - cmin;\n    float l = 0.5*(cmin+cmax);\n    float s = 0.0;\n    float h = 0.0;\n    float r = rgb.r;\n    float g = rgb.g;\n    float b = rgb.b;\n    if (diff < 1.0/255.0) {\n        return vec3(h,s,l);\n    } else {\n        if (l < 0.5) {\n            s = diff / (cmax + cmin);\n        } else {\n            s = diff / (2.0 - cmax - cmin);\n        }\n        \n        float r2 = (cmax - r) / diff;\n        float g2 = (cmax - g) / diff;\n        float b2 = (cmax - b) / diff;\n\n        if (r == cmax) \n        {\n            h = (g == cmin ? 5.0 + b2 : 1.0 - g2);\n        }\n        else if (g == cmax) \n        {\n            h = (b == cmin ? 1.0 + r2 : 3.0 - b2);\n        }\n        else \n        {\n            h = (r == cmin ? 3.0 + g2 : 5.0 - r2);\n        }\n        h /= 6.0;\n        \n        if (h < 0.0) h += 1.0;\n        else if (h > 1.0) h -= 1.0;\n    }\n    return vec3(h, s, l);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}