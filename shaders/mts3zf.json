{
    "Shader": {
        "info": {
            "date": "1672191513",
            "description": "A variant of David Hoskins' \"Rough Seas\" shader with a more dynamic wave animation.",
            "flags": 8,
            "hasliked": 0,
            "id": "mts3zf",
            "likes": 24,
            "name": "Turbulent Seas",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "sound",
                "sea",
                "rough"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 563
        },
        "renderpass": [
            {
                "code": "// Rough Seas, by Dave Hoskins.\n// https://www.shadertoy.com/view/dtXGW4\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n#define FAR 1000.\n#define FOG_COLOUR vec3(.4,.4,.5)\n#define SKY_TOP vec3(.2, 0.21, 0.26)\n\nvec3 camPos;\nfloat time;\nvec3 skyColour;\nconst vec3 sunDir = normalize(vec3(4,8,18));\n\n//------------------------------------------------------------------------------\n// Hashes from here: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Pretty basic smoothed noise...\n//------------------------------------------------------------------------------\nfloat noise2D(in vec2 p)\n{\n\treturn (sin(p.x)+cos(p.y))/2.;\n}\n\nfloat noise3D(in vec3 p)\n{\n    const vec2 add = vec2(1.0, 0.0);\n\n    vec3 f = fract(p); \n    f *= f * (3.0-2.0*f);\n    p = floor(p);\n\n    float h = mix(\n                    mix(mix(hash13(p), hash13(p + add.xyy),f.x),\n                        mix(hash13(p + add.yxy), hash13(p + add.xxy),f.x), f.y),\n                    mix(mix(hash13(p + add.yyx), hash13(p + add.xyx),f.x),\n                        mix(hash13(p + add.yxx), hash13(p + add.xxx),f.x), f.y),\n                 f.z);\n    return h*h*h*2.;\n}\n\n\n//------------------------------------------------------------------------------\n// A very basic sky...\nvec3 sky(vec3 dir)\n{\n \n    return mix(FOG_COLOUR, SKY_TOP ,abs(dir.y)*1.7);\n}\n\n//-----------------------------------------------------------------\n// This creates the sea, it's complexity is governed by the incoming iteration count...\nconst float COSR = cos(.43);\nconst float SINR = sin(.52);\nconst mat2 rot2D = mat2(COSR, SINR, -SINR, COSR) * 1.4;\nfloat oceanFundamental(vec2 p, float d, float tim, float iter)\n{\n    float a =noise2D(p*.01)*8.+3.0;\n    float h = 0.0;\n    float it = 1./iter;\n    float spr = 0.0;\n    p.x -= tim*5.0;\n\n    p *= .025;// ...Scale it\n\n    for (float i = 0.0; i <= 1.0; i += it)\n    {\n        float t = (2.-i) * tim*.5;\n        float r =noise2D(p*2.1) * i;\n        vec2 y1 = (cos(p-t)+1.0);\n        vec2 y2 = (1.0-abs(sin(p-t)));\n        \n        y1 = mix(y1, y2, r);\n          \n        float s = y1.x + y1.y;\n        \n        h += s*a;\n        \n        a *= .59;\n        p = p * rot2D;\n        p += 19.9+r/2.+iTime/2.;\n    }\n\n    return h;\n}\n\n// Map the ocean relative to the point...\n//-----------------------------------------------------------------\nfloat map(in vec3 p, in float d, float iter)\n{\n    float h = oceanFundamental(p.xz, d, time, iter);\n    return p.y-h;\n}\n\n// Bog standard ray marching, there's so much noise that any misses get lost...ðŸ¤ž\n//-----------------------------------------------------------------\nvec2 rayMarch(vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    float spr = 0.0;\n    for ( int i = 0; i < 120; i++)\n    {\n        vec3 pos = p + dir*d;\n\n        float hh = oceanFundamental(pos.xz, d, time, 7.);\n        float h = pos.y-hh;\n        \n        if (h < 0.1 || d > FAR)\n        {\n            break;\n        }\n        float wind = noise3D(pos*.08) * noise3D(pos*3.5+vec3(0, time*h*.1,0));\n        spr += max(20.-h, 0.0) * smoothstep(20.0, .0,max(h, 0.0))*smoothstep(FAR, 150.0,d)*smoothstep(30., 80.0, hh)\n        * wind;\n\n\n        //if (h < 0.0) h *= .5;\n        d+= h*.7;\n    }\n    return vec2(d, min(spr*.03, 1.0));\n}\n\n//------------------------------------------------------------------------------\n// Get a view of pixel using Euler...\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//------------------------------------------------------------------------------\n\n// I forgot where this came from, it using a higher iteration than the ray march...\nvec3 normal(vec3 pos, float ds)\n{\n    ds *= 2./iResolution.y;\n    ds = max(ds*ds, .1);\n\n    float c = map(pos, 0., 14.);\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 0.0, 14.),\n                          map(pos + eps_zero.yxy, 0.0, 14.),\n                          map(pos + eps_zero.yyx, 0.0, 14.)) - c);\n}\n\n//------------------------------------------------------------------------------\n\n// I was using my 2 tweet water caustic here,\n// but some compilers opimized it broken with the rest of the code\n// So I opted for a basic voronoi cell thing...\nfloat waterPattern(vec2 p)\n{\n    p *=.02;\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float wp = 1e10;\n    for (int i = -1;i<=1;i++)\n    {\n        for (int j = -1;j<=1;j++)\n        {\n            vec2 g = vec2(i, j);\n            vec2 o = hash22(n+g);\n            \n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d < wp)\n            {\n                wp = d;\n            }\n        }\n    }\n    return pow(wp, 3.5);\n}\n\n\n//------------------------------------------------------------------------------\nfloat waveDepth(vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    for( float i = 3.0; i < 25.0; i+=5.)\n    {\n        float h = map(p + dir*i, i, 7.);\n        if (h > 0.) break;\n        d += -h;\n    }\n    return clamp(1.0-d*.02, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec3 lighting(vec3 pos, vec3 nor, in vec3 dir,in vec3 mat)\n{\n    vec3 col;\n    col = mat * max(dot(sunDir, nor), 0.0);\n    vec3 ref = reflect(dir, nor);\n    float fres = clamp(pow( 1.+dot(nor, dir), 5. ), 0.0, 1.0);\n    col = mix(col, sky(nor), .3);\n    col = mix(col, sky(ref), fres);\n    return col;\n}\n\n//------------------------------------------------------------------------------\nvec3 diffuse(in vec3 pos, in vec3 nor, in float dep)\n{\n    pos.x -= time*1.8;\n    vec3 mat = vec3(.1,.2,.4);\n    float h = smoothstep(0., 1.0,nor.y);\n    \n    mat += h*.1;\n\n    mat = mix(mat, vec3(.4,.8,.7), dep);\n\n\n    // Add different frequencies of voronoi cells...\n    float foam = waterPattern(pos.xz*vec2(.5,1.)+99.)*15.;\n    foam += waterPattern(pos.xz*3.63)*10.;\n    foam += waterPattern(pos.xz*12.)*3.;\n    \n    foam = clamp(foam, 0.0, 1.0);\n    \n\n    mat = mat+foam * dep*dep*3.;\n\n    return mat;\n}\n\n//------------------------------------------------------------------------------\n// Exponential fader...\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvoid mainImage( out vec4 outCol, in vec2 coord )\n{\n    // Take into account non-square viewport to keep aspect ratio of shapes..\n    // Zero in centre and .5 at the max Ys\n    vec2 uv = (coord-iResolution.xy*.5)/iResolution.y;\n\n    vec2 mouse = vec2(0);\n    if (iMouse.z > 0.) mouse = (iMouse.xy-iResolution.xy*.5) /iResolution.y;\n    \n\n    vec3 colour = vec3(0);\n    // Find a good point in time with time blurring for the top of the display...\n    float f = coord.y/iResolution.y;\n    time = iTime+10.;\n\n    // Set colour to zero then call the rayMarcher to get distant object...\n\n    camPos = vec3(time*.01,100,0);\n    float h = (sin(time*.65)+1.0)*40.+ 10.;\n\n    float oce = 0.0;\n\n    // Bounce along the average wave height for a set time...\n    for (float i = 0.0; i < 4.0; i++)\n    {\n        oce += oceanFundamental(camPos.xz, 0.0, time + i, 7.0);\n    }\n    oce = (oce / 4.0)+140.0;\n    oce= h-oce;\n    if (oce < 0.0)\n    {\n        // Don't lock any movement - it's the sea!\n        h = h+pow(-oce, .3)*4.;\n    }\n\n\n    // Setup camera...\n    vec3 col;\n    vec3 dir  = vec3(0,0, 1.);\n    dir = viewMat (uv.y -.3, uv.x-2.+time*.25 + mouse.x*6.28) * dir;\n\n    camPos.y = h;\n    vec2 dis = rayMarch(camPos, dir);\n\n\n    if (dis.x < FAR)\n    {\n        // The position is the start position plus the normalised direction X distance...\n        vec3  pos = camPos + dir * dis.x; // ...wave hit position\n        vec3  nor = normal(pos, dis.x);   // ... Normal\n         // The depth of the wave in forward direction, it's simple but effective in helping the water transparent effect...\n        float dep = waveDepth(pos+dir*.3, dir);\n        vec3  mat = diffuse(pos, nor, dep);\n\n        col = lighting(pos, nor, dir, mat);\n        col = mix(col, FOG_COLOUR, smoothstep(250.0, FAR, dis.x));\n    }else\n    {\n        col = sky(dir);\n    }\n    colour += col;\n\n\n    colour = mix(col, vec3(.55,.56,.59),dis.y);\n\n    // Some adjustment..\n    colour = colour*.5 + smoothstep(0.0, 1.0, colour)*.5;\n    \n    vec2 xy = coord/iResolution.xy;\n    colour *= 0.5 + .5*pow( 80.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .5);  // ...Vignette.\n    outCol = vec4(fader(0.0, 4.0, iTime)*sqrt(colour), 1);\n}\n\n//-----------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// Rough Seas, by Dave Hoskins.\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n\nvec2 noise2D(in float p)\n{\n\tfloat f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 res = mix(hash21(p), hash21(p + 1.0), f);\n    return res-.5;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v, aud;\n    float t= time;\n    \n    \n    // Add vary volumes of different frequencies...\n    v = noise2D(t*.6)*.5+.5;\n    aud = noise2D(t*320.) * v;\n    \n    v = noise2D(t*.3)*.8+.2;\n    aud += noise2D(t*800.)*v;\n\n    v = noise2D(t*.3)*.8;\n    aud += noise2D(t*1900.)*v;\n\n\n    v = (noise2D(-t*.4)+noise2D(-t*.3))*.3;\n    aud += noise2D(t*4400.)*v;\n\n    v = (noise2D(t*.7) +noise2D(t*.22))*.2;\n    aud += noise2D(t*10200.)*v;\n\n\n    aud = clamp(aud, -1.0, 1.0) * fader(.0, 1.0,time) * fader(180.0, 170.0,time);\n    \n    return aud;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}