{
    "Shader": {
        "info": {
            "date": "1684627321",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n",
            "flags": 32,
            "hasliked": 0,
            "id": "dtGGWw",
            "likes": 27,
            "name": "Year of Truchets #022",
            "published": 3,
            "tags": [
                "raymarching",
                "tv",
                "truchet",
                "inversion"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 251
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #022\n    05/20/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define PI  3.14159265359\nvec2 curvature = vec2(8.,12.);\n\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.325);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.9, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.9, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n   \n    fragColor = baseColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #022\n    05/20/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    75.\n\n// globals & const\nvec3 hit,hp;\nmat2 flip,turn,r90;\n\nconst vec3 size = vec3(1.25);\nconst vec3 hlf = size/2.;\nconst vec3 bs = hlf;\nconst vec3 grid = vec3(4.);\nconst vec3 lrid = vec3(3.);\nconst float thick = .055;\n\nvec3 hue(float t){ return .5 + .4*cos(PI2*t*(vec3(.95,.97,.98)*vec3(0.957,0.439,0.043))); }\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat glow = 0.;\n\nvec2 map(vec3 p, float sg){\n    vec2 res = vec2(1e5,0);\n  \n    //@mla inversion\n    float k = (9.+2.*sin(T*.1))/dot(p,p); \n    p *= k;\n\n    p.yz*=flip; p.xz*=turn;\n\n    vec3 q = p;\n    vec3 r = p+hlf;\n    \n    vec3 id = floor((q + hlf)/size)-grid;\n    vec3 ir = floor((r + hlf)/size)-lrid;\n    \n    float chk2 = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n    \n    q = q-size*clamp(round(q/size),-grid,grid);\n    r = r-size*clamp(round(r/size),-lrid,lrid);\n\n    float hs = hash21(id.xz+id.y);\n    float hf = hash21(ir.xz+ir.y+floor(T*.75));\n    \n    if(hs>.5) q.xz*=r90;\n    if(chk2>.5) q.zy*=r90;\n\n    float xhs = fract(2.31*hs+id.y);\n    float trh = 1e5, trx = 1e5, srh = 1e5, dre = 1e5, jre=1e5;\n\n    vec2 qv = vec2(q.xy-hlf.xy);\n    trh = trs(vec3(q+vec3(0,hlf.x,-hlf.y)).yxz,vec2(hlf.x,thick));\n    trx = trs(q+vec3(hlf.x,0,hlf.z),vec2(hlf.x,thick));\n    jre = trs(vec3(q-vec3(hlf.xy,0)).yzx,vec2(hlf.x,thick));\n\n    srh = min(trh,jre);\n    srh = min(srh,trx);\n    srh=max(srh,box(q,bs));\n\n    if(srh<res.x ) {\n        float mt = mod(floor(xhs*20.),4.)+2.;\n        res = vec2(srh,mt);\n    } \n\n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,0,hlf),thick*.85,thick*1.5);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,0,hlf),thick*.85,thick*1.5),crt);\n    crt = min(cap(vec3(q.xz,abs(q.y))-vec3(0,0,hlf),thick*.85,thick*1.5),crt);\n\n    if(crt<res.x) {\n       res = vec2(crt,12.);\n    } \n    \n    float gb = length(r)-(hlf.x*.25); \n    if(sg==1.  && hf>.85 ) { glow += .0001/(.0001+gb*gb);}\n    if(gb<res.x && hf>.85) {\n       res = vec2(gb,11.);\n    } \n    \n    // compensate for the scaling that's been applied\n    float mul = 1./k;\n    res.x = res.x* mul / 1.25;\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = 1e-4*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,12);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    // mouse //\n    float x = M.xy==vec2(0) ? .35 : (M.y/R.y * 2.-1.)*PI;\n    float y = M.xy==vec2(0) ? .06 : (M.x/R.x * 2.-1.)*PI;\n\n    float fl = y+(T*.135)+180./PI;\n    float fx = .28*cos(fl*2.);\n    flip=rot(fx);\n    turn=rot(fl);\n    \n    r90=rot(1.5707);\n\n    vec3 C = vec3(.0), p = ro;\n    float m = 0., d = 0.;\n    \n    for(int i=0;i<128;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p,1.);\n        if(ray.x<d*1e-4||d>MAX_DIST)break;\n        d += i<42? ray.x*.3: ray.x * .8;\n        m  = ray.y;\n    } \n\n    if(d<MAX_DIST)\n    {\n\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-10,10,10);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),0. , 1.);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n\n    }\n\n    vec3 Fog = mix(vec3(.05),vec3(.75),(uv.y+.45)*.25);\n    \n    C = mix(C,Fog,1.-exp(-.0001*d*d*d));\n    C = mix(C,vec3(.49,.98,.52),clamp(glow*.75,0.,1.));\n    \n    float vw = .6+.5*sin(d*.5+T*.85);\n    float fade = clamp((d*.01)+vw,0.,1.);\n    vec3 clr = m==4.? vec3(.62,.36,.95): m==2. ? vec3(.95,.36,.87) : vec3(.36,.66,.95);\n    if(m!=11.&&m!=12.) C = mix(C,clr,smoothstep(.35,.1,fade)); \n    \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}