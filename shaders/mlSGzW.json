{
    "Shader": {
        "info": {
            "date": "1672927308",
            "description": "An elliptic curve and a curve derived from the lagrange multiplier with respect to the distance to the mouse point.\nBackground is the visualization of the basins of attraction for an iteration which computes the intersection of both curves.",
            "flags": 0,
            "hasliked": 0,
            "id": "mlSGzW",
            "likes": 5,
            "name": "Elliptic curve lagrange mult.",
            "published": 3,
            "tags": [
                "2d",
                "distancefield",
                "distance",
                "curve",
                "implicit",
                "lagrange",
                "ellipticcurve"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 254
        },
        "renderpass": [
            {
                "code": "/*\nThis is a variaton of https://www.shadertoy.com/view/DsjXRh\nwhich uses an elliptic curve in place of the ellipse.\n\nUpdate: Added parametrization of the lagrange curve and dot oscillating around the mouse.\n*/\n//#define SHOW_DISTANCE_FIELD\n\nvec3 bg_col = vec3(1);\nvec3 elliptic_col = vec3(0,0,1);\nvec3 lag_curve_col = vec3(0,1,0);\nvec3 dot_col = vec3(0);\n\nfloat line_width = .001;\nfloat dot_size = .01;\n\nfloat zoom = 2.;\n\nconst int num_iterations = 16;\nint aa = 2;\n\nconst float pi = 3.1415925;\n\nconst float a_param = -.3;\nconst float b_param = .3;\n\nfloat elliptic_curve(vec2 p, out vec2 grad){\n\tgrad = vec2(3.*p.x*p.x + a_param, -2.*p.y);\n\treturn (p.x*p.x + a_param) * p.x + b_param - p.y*p.y;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n\tgrad = vec2(6.*p.x*(p.y-p2.y)+2.*p.y, 3.*p.x*p.x + 2.*p.x - 2.*p2.x + a_param);\n\treturn p.x*(3.*p.x*(p.y - p2.y) + 2.*p.y) - 2.*p.y*p2.x + (p.y-p2.y)*a_param;\n}\n\nvec2 lagrange_curve_parametric(float t, vec2 p0){\n    return vec2(1./t, (a_param*t*t + 3.)*p0.y/(((a_param-2.*p0.x)*t + 2.)*t + 3.));\n}\n\nvec2 iteration(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1 = elliptic_curve(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\tp_val2 = lagrange_curve(p,p2,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\treturn p;\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction = atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n    mouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 2./iResolution.y;\n\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tuv *= zoom;\n\tmouse *= zoom;\n\tborder *= zoom;\n\n\tconst mat2 aa_rot = mat2(1.,.5,-.5,1.);\n\n\tvec3 col_sum = vec3(0);\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\taa = 1;\n\tmouse = uv;\n\t#endif\n\n\tvec2 p1;\n\tfor(int x = 0;x<aa;x++){\n\t\tfor(int y = 0;y<aa;y++){\n\t\t\tvec2 aa_offset = (vec2(x,y)-.5*(float(aa)-1.))/float(aa);\n\t\t\taa_offset *= zoom*vec2(aspect_ratio,1)/iResolution.xy;\n\t\t\tp1 = uv+aa_offset;\n\n\t\t\tfor(int i = 0;i<num_iterations;i++){\n\t\t\t\tp1 = iteration(p1, mouse);\n\t\t\t}\n\n\t\t\tcol_sum += pow(to_col(p1),vec3(2.2));\n\t\t}\n\t}\n\n\tbg_col = pow(col_sum/(float(aa)*float(aa)),vec3(1.0/2.2));\n\tbg_col *= .75;\n\n\tvec3 color = bg_col;\n\tfloat dis = 1e38;\n\n\tvec2 elliptic_grad;\n\tfloat elliptic_val = elliptic_curve(uv, elliptic_grad);\n\n\tdis = min(dis, abs(elliptic_val / length(elliptic_grad)) - line_width);\n\tcolor = mix(elliptic_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n\tvec2 lag_curve_grad;\n\tfloat lag_curve_val = lagrange_curve(uv,mouse,lag_curve_grad);\n\n\tdis = min(dis, abs(lag_curve_val / length(lag_curve_grad)) - line_width);\n\tcolor = mix(lag_curve_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n    \n    float t0 = 1. / mouse.x;\n    vec2 pt = lagrange_curve_parametric(t0+.1*sin(3.*iTime),mouse);\n\n\tdis = min(dis, distance(uv,p1) - dot_size);\n    dis = min(dis, distance(uv,pt) - dot_size);\n\tcolor = mix(dot_col,color,smoothstep(0.,border,dis));\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\tdis = distance(uv,p1);\n\tfloat sgn = 1.;\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\t#endif\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}