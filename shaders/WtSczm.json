{
    "Shader": {
        "info": {
            "date": "1593946888",
            "description": "Deep zoom (x10^12) into Mandelbrot set using double-precision emulation  (single-precision is limited to about 10^5). See source for activation.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtSczm",
            "likes": 7,
            "name": "Mandelbrot Trillion-Fold Zoom",
            "published": 3,
            "tags": [
                "fractal",
                "precision"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 994
        },
        "renderpass": [
            {
                "code": "// \"Mandelbrot Trillion-Fold Zoom\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Deep zoom (x10^12) into Mandelbrot set using double-precision emulation\n (single-precision is limited to about 10^5).\n 3 color modes (Julia version coming soon)\n*/\n\n#define DP_VERS  0   // NOTE: must change 0->1 for this to work (not by default) !!!\n\n#define AA       0   // set = 1 for antialiasing (recommended)\n\n/*\n Based on an (interactive) CUDA-GPU learning exercise from the distant past.\n\n Double-precision emulation in software:\n \n Some of the earlier web reference material has disappeared.\n Discussion in blog.hvidtfeldts.net/index.php/2012/07/double-precision-in-opengl-and-webgl.\n Code available at hvidtfeldts.net/WebGL-DP/webgl.html.\n Double emulation based on GLSL Mandelbrot Shader by Thasler (www.thasler.org/blog - gone!).\n Also appears in NVIDIA CUDA Mandelbrot example.\n Modified code to prevent GLSL compiler screwup: LMLB / Mandelbrot WebGL Example (Syntopia 2012).htm.\n Idea goes back to Knuth, Dekker and others; survey in andrewthall.org/papers/df64_qf128.pdf.\n Emulation originated with Fortran-90 double-single package by Bailey (crd.lbl.gov/~dhbailey/mpdist -\n gone/redirected, no mention on new website).\n\n Software emulated dp can be faster than hardware dp - depends on GPU (emulated dp Mandelbrot\n using CUDA on Quadro P4000 is 1.5-2x faster than hw dp).\n (Note: Quadro P4000 dp hardware is nominally 1/32x speed of sp; contrast with Tesla K20 where\n it is 1/2x-1/3x.)\n\n \"Do-nothing\" functions are used prevent GLSL compiler destructively rearranging code;\n used only where needed, unlike LMLB version which uses them for all ops (CUDA version of\n program doesn't need them - Linux NVIDIA driver 384.130).\n\n Apparently even this trick is not enough for some compilers - see below.\n This could probably be simplified but I have no machine for testing.\n\n Scale factor is shown (log of value).\n*/\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nint nFrame;\nfloat nFrameF, scale, sclTarg, frmCyc;\nconst float pi = 3.1415927;\n\n#if DP_VERS\n\n#define GOOD_FP  0   // set = 1 if the GLSL compiler behaves (else just get sp results)\n    \n#if ! GOOD_FP \n\nfloat nFrameF1, nFrameF2, nFrameF3;\n\n#define VAR_ZERO1 min (nFrameF1, 0.)  // following iq's suggestion\n#define VAR_ZERO2 min (nFrameF2, 0.)\n#define VAR_ZERO3 min (nFrameF3, 0.)\n\nfloat FFAdd (float a, float b) \n{\n  return mix (a, a + b, (b != 0.) ? 1. : VAR_ZERO1);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (a, a - b, (b != 0.) ? 1. : VAR_ZERO2);\n}\n\nfloat FFSub2 (float a, float b)\n{\n  return mix (a, a - b, (b != 0.) ? 1. : VAR_ZERO3);\n}\n\n#endif\n\nvec2 DvFromF (float a)\n{\n  return vec2 (a, 0.);\n}\n\nvec2 DvAdd (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if GOOD_FP\n  t1 = va.x + vb.x;\n  e = t1 - va.x;\n  t2 = ((vb.x - e) + (va.x - (t1 - e))) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x + vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (vb.x, e), va.x - FFSub2 (t1, e)) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\nvec2 DvSub (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if GOOD_FP\n  t1 = va.x - vb.x;\n  e = t1 - va.x;\n  t2 = ((- vb.x - e) + (va.x - (t1 - e))) + va.y - vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x - vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (- vb.x, e), va.x - FFSub2 (t1, e)) + va.y - vb.y;\n  vc.x = t1 - t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#define DSPLIT 8193.\n\nvec2 DvMul (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float ma, mb, sa1, sa2, sb1, sb2, c1, c2, t, t1, t2, e;\n#if GOOD_FP\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = ma - (ma - va.x);\n  sb1 = mb - (mb - vb.x);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = t1 - c1;\n  t2 = ((c2 - e) + (c1 - (t1 - e))) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = FFSub (ma, FFSub2 (ma, va.x));\n  sb1 = FFSub (mb, FFSub2 (mb, vb.x));\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = FFSub (t1, c1);\n  t2 = FFAdd (FFSub (c2, e), c1 - FFSub2 (t1, e)) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#endif // DP_VERS\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col;\n  float ns, w, colTyp;\n#if DP_VERS\n  vec2 xMidv, yMidv, x, y, xx, yy, cx, cy, s;\n#else\n  float xMid, yMid, x, y, xx, yy, cx, cy, s;\n#endif\n#if DP_VERS\n  xMidv = vec2 (-1.2499080e+07 / (4096. * 4096.), 6.40919e-09); // (externally) converted values\n  yMidv = vec2 (2.2692490e+06 / (4096. * 4096.),  4.4428e-08);\n  const float nsMax = 8192.;\n#else\n  xMid = -7.45003217010e-01; // original values (extra precision for conversion)\n  yMid = 1.35257824980e-01;\n  const float nsMax = 1024.;\n#endif\n  colTyp = floor (mod (float (nFrame) / frmCyc, 3.));\n#if DP_VERS\n  cx = DvAdd (DvMul (DvFromF (uv.x), DvFromF (scale)), xMidv);\n  cy = DvAdd (DvMul (DvFromF (uv.y), DvFromF (scale)), yMidv);\n  w = (cx.x + 0.25) * (cx.x + 0.25) + cy.x * cy.x;\n  x = DvFromF (0.);\n  y = DvFromF (0.);\n#else\n  cx = uv.x * scale + xMid;\n  cy = uv.y * scale + yMid;\n  w = (cx + 0.25) * (cx + 0.25) + cy * cy;\n  x = 0.;\n  y = 0.;\n#endif\n  ns = 0.;\n  col = vec3 (0.);\n  if (w > 0.25) {\n    for (float n = float (VAR_ZERO); n < nsMax; n ++) {\n      ++ ns;\n      if (scale > 0.02 && n > 512.) break; // reduced initial iterations\n#if DP_VERS\n      xx = DvMul (x, x);\n      yy = DvMul (y, y);\n      y = DvMul (x, y);\n      y = DvAdd (DvAdd (y, y), cy);\n      x = DvAdd (DvSub (xx, yy), cx);\n      s = DvAdd (xx, yy);\n      if (s.x + s.y > 256. * 256.) break;\n#else\n      xx = x * x;\n      yy = y * y;\n      y = 2. * x * y + cy;\n      x = xx - yy + cx;\n      s = xx + yy;\n      if (s > 256. * 256.) break;\n#endif\n    }\n    if (ns < nsMax - 1.) {\n#if DP_VERS\n      ns -= log2 (log2 (s.x + s.y)) - 4.;  // see iq's article on color smoothing \n#else\n      ns -= log2 (log2 (s)) - 4.;\n#endif\n      if (colTyp == 0.) col = HsvToRgb (vec3 (mod (ns / 512., 1.), 1., 1.));\n      else if (colTyp == 1.) col = 0.55 + 0.45 * cos (3. + vec3 (0., 0.5, 1.) + 0.15 * ns);\n      else if (colTyp == 2.) col = HsvToRgb (vec3 (mod (0.5 * log2 (ns) +\n         mod (4. * float (nFrame) / frmCyc, 1.), 1.), 1., 1.));\n    }\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv, uvv;\n  float asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  nFrame = iFrame;\n  asp = canvas.x / canvas.y;\n  nFrameF = float (nFrame);\n#if DP_VERS\n#if ! GOOD_FP \n  nFrameF1 = float (nFrame + 1);\n  nFrameF2 = nFrameF1 - 0.1;\n  nFrameF3 = nFrameF1 - 0.2;\n#endif\n#endif\n  frmCyc = 3000.;\n#if DP_VERS\n  sclTarg = 1e-12;\n#else\n  sclTarg = 3e-6;\n#endif\n  scale = 2. * pow (sclTarg, SmoothBump (0.25, 0.75, 0.23, mod (nFrameF / frmCyc, 1.)));\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (uvv);\n    }\n  } else col = vec3 (0.82);\n  col = mix (col, vec3 (0., 0., 0.5), ShowInt (0.5 * uv - vec2 (0.4 * asp, -0.4),\n     vec2 (0.06 * asp, 0.05), 2., floor (1. - log2 (scale) / log2 (10.))));\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}