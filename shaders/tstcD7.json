{
    "Shader": {
        "info": {
            "date": "1601079691",
            "description": "fractals",
            "flags": 0,
            "hasliked": 0,
            "id": "tstcD7",
            "likes": 3,
            "name": "Fractal Sky #2",
            "published": 3,
            "tags": [
                "mandelbrot",
                "fractals"
            ],
            "usePreview": 0,
            "username": "NivBehar",
            "viewed": 240
        },
        "renderpass": [
            {
                "code": "#define ITERATIONS 150\n#define COLOR_REPEAT 0.6\n#define MANDELBROT_SHADE 2072.\n#define time iTime\n#define HEX_DIST 1.\n#define HAIR_DIST 21.\n#define PI 3.141592654\n#define _DotsSize 0.213\n#define _DotsSmoothness 0.221\n\nvec2 rot(vec2 p, vec2 pivot, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n    p += pivot;\n\n    return p;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n\n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat TriangleDist(vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\nvec3 iterate(vec2 UV , float distance_type)\n{\n    //cool shit: https://www.shadertoy.com/view/wdBfDK\n    //UV = _MandelbrotArea.xy + (UV-0.5)*_MandelbrotArea.zw;\n    //UV = rot(UV, _MandelbrotArea.xy, _MandelbrotAngle);\n\n    vec3 col;\n\n    float dots_dist = 1e20f;\n    vec2 z = UV;\n    // shape = z for regular mandelbrot set\n    // a; 0       ; (GOLDEN-2); 0.285; 0.285; 0.45  ; -0.70176; -0.835 ; -0.8 ; -0.7269; -0.754\n    // b; 1-GOLDEN; (GOLDEN-1); 0    ; 0.01 ; 0.1428; -0.3842 ; -0.2321; 0.156; 0.1889; -0.066\n    //float[1] shapes;\n    //float2 shapes[11] = {z, float2(0, 1-GOLDEN), float2(GOLDEN-2, GOLDEN-1), float2(0.285, 0.), float2(0.285, 0.01), float2(0.45, 0.1428), float2(-0.70176, -0.3842), float2(-0.835, -0.2321),\n        //float2(-0.8, 0.156), float2(-0.7269, 0.1889), float2(-0.754, -0.066)};\n    vec2 shape;\n    shape = vec2(0.285, 0.0103);\n    //shape = float2(_fractal_shape_a, _fractal_shape_b);\n    //if(shape.x == 0 && shape.y == 0)\n    //    shape = z;\n    vec2 prev_z;\n    vec2 z_dots;\n    vec4 z_hc;\n    float dist_from_mandelbrot = 1e20f;\n    float r = 20.;\n\n    vec2 hc2;\n    int i = 0;\n    for(i = 0; i<ITERATIONS; i++ )\n    {\n        prev_z = z;\n        if(distance_type == HEX_DIST)\n        {\n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 1. + 10.*HexDist(0.5 + 2.*sin(cos(z2)*0.5)*cos(cos(z2*3.)));\n        }\n        if(distance_type == HAIR_DIST)\n        {   \n            //vec2 z1 = 13.*z/dot(z,z+0.1*sin(z));\n            //z1 +=time;\n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 10. + 15.*TriangleDist(sin(cos(z2*PI + PI)*0.5 + 5.)*sin(cos(z2*PI)), vec2(100.,3.2));\n            //float r2 = 5 + 15*TriangleDist(sin(cos(z2*PI+time*1)*0.5 + 5)*cos(cos(z2*PI)), float2(50,-0.6));\n            //r = lerp(r,r2, 0.4 + 0.4*sin(time));\n            //r = 5+TriangleDist(z*3, float2(_test1,_test2));\n        }\n\n        //r = HexCoords(0.5 + 0.25*sin(cos(z*2 + time)*0.1)*cos(cos(z*3) + 0.25*sin(cos(prev_z*2)) )).y*10;\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + shape;\n        //float z_hash = N22(z);\n        if(length(z) > r)\n            //if(dot(z, prev_z) > r)\n            break;\n        //return 0.0;\n\n\n        z_dots = z + rot(z,prev_z,time*0.2);\n        z_dots = vec2(HexDist(z_dots));\n        z_hc = HexCoords(z_dots);\n\n        //z_dots = pMod2(z_dots,4);\n\n        dots_dist = min( dots_dist, dot(z_dots,z_dots) );\n        //dots_dist = min( dots_dist, dot(z_hc.x,z_hc.y) );\n        dist_from_mandelbrot = min(dist_from_mandelbrot, dot(z,z));\n\n        //hc2 = min(hc2, HexCoords(prev_z).xy);\n    }\n\n    if(i >= ITERATIONS)\n        return vec3(0.);\n\n    float fraciter = log2( log(length(z)) / log(r) );\n    float j = float(i);\n    //j -= fraciter;\n\n    //float2 hc = HexCoords(dots_dist).xy;\n\n    //col = smoothstep(0,dist, sin(hc.y*15)*cos(hc.y*15));\n    //float dots_size = 1;\n    //float dots_smoothness = 0.9;\n    float dots = smoothstep(_DotsSize - _DotsSmoothness, _DotsSize, dots_dist);\n    //dots = smoothstep(0.9, 1, dots_dist);\n    dots = clamp(0.,1.,dots);\n\n    //col = smoothstep(0,dist, );\n    //float3 tex = tex2D(_MainTex, hc2);\n    //col = tex;\n    //col = dots;\n\n    vec3 beat = vec3(time*0.4);//(_smooth_bass2 + _smooth_mid2 + _smooth_treb2)*0.001 + (_bass2 + _mid2 + _treb2)*0.003;\n    // Color 1\n    vec3 a1 = vec3(0.5, 0.5, 0.5);\n    vec3 b1 = vec3(0.75, 0.55, 0.85);\n    vec3 c1 = beat; // animate \\ offset\n    vec3 d1 = vec3(0.0, 0.1, 0.2);\n    // Color 2\n    vec3 a2 = vec3(0.5, 0.5, 0.5);\n    vec3 b2 = vec3(0.75, 0.55, 0.85);\n    vec3 c2 = vec3(1.0, 1.0, 0.5); // animate \\ offset\n    vec3 d2 = vec3(0.8, 0.9, 0.3);\n    // Color 3 - blue to gray\n    vec3 a3 = vec3(0.5, .5, 1.);\n    vec3 b3 = vec3(0.5, 0.5, 0.);\n    vec3 c3 = vec3(0., 0., 0.); // animate \\ offset\n    vec3 d3 = vec3(0., 0., 0.);\n    // Color 4 - black and white\n    vec3 a4 = vec3(1, 1, 1);\n    vec3 b4 = vec3(1.0, 1.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 1.0); // animate \\ offset\n    vec3 d4 = vec3(1.0, 1.0, 1.0);\n    \n    vec3 a5 = vec3(0.3, 0.27, 0.5);\n    vec3 b5 = vec3(0.9, 0.45, 0.75);\n    vec3 c5 = vec3(beat); // animate \\ offset\n    vec3 d5 = vec3(.8, 0.9, 0.25);\n    \n    // Color choise\n    //vec3 a = mix(a1, a2, 0.*time*0.02);\n    //vec3 b = mix(b1, b2, 0.*time*0.02);\n    //vec3 c = mix(c1, c2, 0.*time*0.02);\n    //vec3 d = mix(d1, d2, 0.*time*0.02);\n\n    vec3 col1 = a1 + b1 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d1 + c1));\n    vec3 col2 = a2 + b2 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d2 + time*0.2));\n    vec3 col3 = a3 + b3 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d3 + c3 ));\n    vec3 col4 = a4 + b4 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d4 + c4));\n    vec3 col5 = a5 + b5 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d5 + c5));\n\tvec3 col6 = mix(col1, col5, abs(col1-col5));\n    col = col1;\n    \n    \n    //col = mix(col1, col4, 0.5 + 0.5*sin(float(i)));\n    //col = vec3(clamp(0.,1.,fraciter));\n    //col = mix(col, col2, fraciter);\n    //col = col2;\n    //col = vec3(dist_from_mandelbrot);\n\n    dist_from_mandelbrot = smoothstep(0., j/(MANDELBROT_SHADE), dist_from_mandelbrot);\n    //dist_from_mandelbrot = smoothstep(0, (_MandelbrotArea.z)*0.1, dist_from_mandelbrot); // shade depends on the zoom \n\n    dist_from_mandelbrot = clamp(0.,1.,dist_from_mandelbrot);\n\n    if(distance_type == HEX_DIST)\n    {\n        float leaves = smoothstep(0.,0.7,fraciter);\n        float leaves_edges = smoothstep(0.3,0.,fraciter);\n        //float leaves_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //leaves_edges *= leaves_edges_tips;\n        col *= leaves;\n        //col += leaves_edges;\n        //col *= dist_from_mandelbrot;\n\n    }\n    if(distance_type == HAIR_DIST)\n    {\n        float hair = smoothstep(0.,1.5,fraciter);\n        float hair_edges = smoothstep(0.18,0.,fraciter);\n        float hair_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //hair_edges *= hair_edges_tips; // to avoid pxieli edges of the hairs\n        col *= hair;\n        //col += hair_edges;\n\n        // add dots\n        //col *= (dist_from_mandelbrot);\n\n        //float id = j;\n        //float hash = N11(id + floor(-time*2));\n        //col += 0.1*(1-dist_from_mandelbrot) * (col3);\n        //col = col3;\n    }\n\n\n\n    //col = hash+0.1;\n\n\n    //col *= hair_edges2*dist_from_mandelbrot;\n    //col = col4;\n    //col = fraciter;\n\n    //col *= dots;\n    //col += (1-dots)*dist_from_mandelbrot*col3;\n    //col *= smoothstep(0.8,0.,fraciter);\n    //col = dots;\n    //col = fraciter;\n    //col = 1-dots;\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;// = fragCoord/iResolution.xy;\n    \n    float zoom = 3.;\n\n    //uv += 0.4;\n    //uv = 0.7*uv/dot(uv,uv);\n    //uv += vec2(cos(0.1*iTime), sin(0.1*iTime));\n\n    #if 1\n    int AA = 2;\n    vec3 col = vec3(0.);\n    // anti-aliasing from https://www.shadertoy.com/view/Mss3R8\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\n        uv = (fragCoord+of)/iResolution.xy;\n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n\t   col += iterate( uv, HAIR_DIST );\n\t}\n\tcol /= float(AA*AA);\n    \n    #else\n    \n    uv = fragCoord/iResolution.xy;\n    uv*=zoom;\n    uv.x-= zoom/2.;\n    uv.y -= zoom/2.;\n\tvec3 col = iterate(uv, HAIR_DIST);\n    \n    #endif\n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}