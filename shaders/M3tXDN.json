{
    "Shader": {
        "info": {
            "date": "1719174003",
            "description": "exploring some more ideas with chained reaction diffusion systems\nbest at 640x360\n\nbuffer A accumulates motion\nbuffer B does reaction diffusion pushed by the motion\nbuffer C does pretty rendering with feedback\nbuffer D just stores previous mouse state",
            "flags": 32,
            "hasliked": 0,
            "id": "M3tXDN",
            "likes": 3,
            "name": "reaction diffusion experiment 6",
            "published": 3,
            "tags": [
                "reactiondiffusion"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 102
        },
        "renderpass": [
            {
                "code": "const int DEBUG = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    \n    // fetch buffers\n    vec4 buffA = texture(iChannel0,uv);\n    vec4 buffB = texture(iChannel1,uv);\n    vec4 buffC = texture(iChannel3,uv);\n\n    // debug\n    if (DEBUG==1)\n        fragColor = buffA;\n    if (DEBUG==2)\n        fragColor = 1.-buffB;\n    if (DEBUG==3)\n        fragColor = buffB - buffA;\n    if (DEBUG==4)\n        fragColor = vec4(buffB.ab, buffA.ab);\n    if (DEBUG!=0) return;\n\n    vec3 col = buffC.rgb;\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// bastardized from https://www.shadertoy.com/view/WtsSz2\n// wyattflanders.com/MeAndMyNeighborhood.pdf\n\nvec4 TA(in vec2 U, in float mip) {\n    return texture(iChannel0,U/R,mip);\n}\nvec4 TA(in vec2 U) {\n    return texelFetch(iChannel0,ivec2(U),0);\n}\n#define TD(U) texelFetch(iChannel2,ivec2(U),0)\n#define lastMouse texelFetch(iChannel2,ivec2(0),0)\n\nvec4 Field (vec2 position) {\n    // Rule 1 : All My Energy transates with my ordered Energy\n    vec2 velocityGuess = TA(position,1.5).xy;\n    vec2 positionGuess = position - velocityGuess;\n\treturn TA(positionGuess);\n}\n\n\nvoid mainImage( out vec4 Energy, in vec2 Me ) {\n    // do fluid:\n    Energy  =  Field(Me);\n    // Neighborhood :\n    vec4 pX  =  Field(Me + vec2(1,0));\n    vec4 pY  =  Field(Me + vec2(0,1));\n    vec4 nX  =  Field(Me - vec2(1,0));\n    vec4 nY  =  Field(Me - vec2(0,1));\n    \n    vec4 Emip = TA(Me,1.5);\n    \n    vec4 Eavg = (pX+pY+nX+nY+Energy+Emip)/6.;\n    Energy = mix(Energy, Eavg, 0.2);\n    \n    Energy *= 0.998; \n    \n    //Boundary conditions :\n    if(Me.x<10.||Me.y<10.||R.x-Me.x<10.||R.y-Me.y<10.)\n    \tEnergy.xy *= 0.;\n    \n    // Mouse input  :  \n    if (iMouse.z > 0.) {\n        vec2 mouseDiff = iMouse.xy - lastMouse.xy;\n        if (iMouse.w > 0.) mouseDiff *= 0.;\n        float speed = length(mouseDiff);\n        if (length(Me-iMouse.xy) < (5. + min(speed*.4,R.x/25.))) {\n            vec2 spread = Me-iMouse.xy;\n            vec2 offset = mix(spread*3., mouseDiff, smoothstep(0.,1.,speed));\n            Energy.xy = mix(Energy.xy, mouseDiff+spread*3., 0.1);\n            Energy.w = 1.;\n        }\n    } else {\n        if (do_auto_dot) {\n            if (length(Me-auto_dot_pos) < 10.) {\n                vec2 spread = Me-auto_dot_pos;\n                Energy.xy = mix(Energy.xy, spread*3., 0.1);\n                Energy.w = 1.;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// reaction diffusion - \nvec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 2./R;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.02;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = .2;\n    float dB = .105;\n    float feed = 0.06 + .02*sin(iTime-cdist*2.);\n    float k = 0.06 + .02*sin(iTime*1.5-cdist*3.);\n    // k=.04787   f=.01793\n    k = .0478;\n    feed = .0179;\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\n#define lastMouse texelFetch(iChannel2,ivec2(0),0)\nvoid mainImage( out vec4 fragColor, in vec2 XY )\n{\n    // skip the edges to avoid artifacts\n    bool tRow = R.y-XY.y<1.5;\n    bool bRow = XY.y<1.5;\n    bool lRow = R.x-XY.x<1.5;\n    bool rRow = XY.x<1.5;\n    if (tRow||bRow||lRow||rRow) {fragColor = vec4(0.);return;}\n    // set up uvs\n    vec2 uv = XY/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    vec2 uvc = (XY*2. - R.xy)/R.y;\n    vec2 muvc = (iMouse.xy*2. - R.xy)/R.y;\n    vec2 uvcPolar = toPolar(uvc);\n    \n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    vec4 buffA = texture(iChannel1,uv);\n    \n    uv -= buffA.xy/3000.;\n    \n    fragColor.ab = setAB(uv,cdist);\n    \n    \n    // Mouse input  :  \n    if (iMouse.z > 0.) {\n        vec2 mouseDiff = iMouse.xy - lastMouse.xy;\n        if (iMouse.w > 0.) mouseDiff *= 0.;\n        float speed = length(mouseDiff);\n        if (length(XY-iMouse.xy) < (5. + min(speed,R.x/25.))) {\n            fragColor.b = 1.;\n        }\n    } else {    \n        if (do_auto_dot) {\n            if (length(XY-auto_dot_pos) < 10.) {\n                vec2 spread = XY-auto_dot_pos;\n                fragColor.b = 1.;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R (iResolution.xy)\n\n#define TT (iTime*.25)\n#define do_auto_dot (fract(TT)<0.15)\n#define auto_dot_pos (hash21(floor(TT))*R)\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 rotate(vec2 v, float a) {\n    return v * rot(a);\n}\n\nfloat nsin(in float a) {\n    return sin(a)*0.5+0.5;\n}\n\nvec2 toPolar(in vec2 uv) {\n    return vec2(\n        length(uv),\n        atan(uv.y,uv.x)\n    );\n}\nvec2 toCartesian(in vec2 uv) {\n    return vec2(\n        uv.x * cos(uv.y),\n        uv.x * sin(uv.y)\n    );    \n}\n\nfloat brightness(in vec3 col) {\n    return (col.r+col.g+col.b)/3.;\n}\n\n// hashes from Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// 3D noise from IQ\n// returns 3D value noise\nfloat noise( in vec3 x ) {\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash33( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash33( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash33( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash33( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash33( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash33( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash33( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash33( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int DEBUG = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    \n    // fetch buffers\n    vec4 buffA = texture(iChannel0,uv);\n    vec4 buffB = texture(iChannel1,uv);\n\n    // colorize\n    vec3 col = buffB.bbb / buffB.aaa;\n    col = smoothstep(0.2,0.9,col);\n    \n    col *= buffA.a;\n    col.b += buffA.b*0.4;\n    col.r += buffA.b*buffA.b*buffA.b*0.8;\n    col.g *= 1.-buffA.b;\n    col -= smoothstep(0.5,0.9,buffA.b);\n    col.b += smoothstep(0.99,1.,buffA.b)*.7;\n    \n    col.r *= .2;\n    col.b *= uv.y;\n    \n    col = 1. - col;\n    col.r *= col.r;\n    col.r *= col.b;\n    col.b *= col.r;\n    col = 1. - col;\n    \n    col = mix(col,texture(iChannel3,uv).rgb,0.99-brightness(col)*.1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// store last mouse pos in 0,0 pixel\nvoid mainImage( out vec4 C, in vec2 XY ) {\n    C = (XY.x>0.5 || XY.y>0.5) ? vec4(0) : iMouse;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}