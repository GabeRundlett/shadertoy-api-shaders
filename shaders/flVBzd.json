{
    "Shader": {
        "info": {
            "date": "1665078875",
            "description": "derived from https://www.shadertoy.com/view/ldGyWR with russian comments translated to english\n\nmade get_eye() always return false",
            "flags": 0,
            "hasliked": 0,
            "id": "flVBzd",
            "likes": 1,
            "name": " Color lines - No Eyes",
            "published": 3,
            "tags": [
                "colors",
                "gradient"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 197
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n//https://www.shadertoy.com\n\n#define time (iTime*.5)\n#define mouse (u_mouse/iResolution)\n#define resolution iResolution\n\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat sin01( in float angle ) { return .5 + .5*sin( angle ); }\nfloat cos01( in float angle ) { return .5 + .5*cos( angle ); }\nfloat cosft( in float from, in float to, in float val ) { return from + cos01( val )*(to - from); }\nfloat sinft( in float from, in float to, in float val ) { return from + sin01( val )*(to - from); }\n\nfloat RandFloat( int i ) { return (fract( sin( float( i ) ) * 43758.5453 )); }\nint RandInt( int i ) { return int( 100000.0*RandFloat( i ) ); }\n\nvec3 hsb2rgb( in vec3 c )\n{\n\tvec3 rgb = clamp( abs( mod( c.x*6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0 ) - 1.0, 0.0, 1.0 );\n\trgb = rgb * rgb*(3.0 - 2.0*rgb);\n\treturn c.z * mix( vec3( 1.0 ), rgb, c.y );\n}\n\nvec3 HsvToRgb( vec3 c )\n{\n    float s = c.y;\n\tfloat s_n = c.z - s * .5;\n\treturn vec3( s_n ) + vec3( s ) * cos( 2.0 * pi * (c.x + vec3( 1.0, 0.6666, .3333 )) );\n}\n\n//####################\n//[-1;+1]\nfloat VFx_t( float x, float t,float id )\n{\n\t//return cos(x+-1.780);\n    float da = RandFloat(int(id)) * 1.;\n\tfloat amplitude = 1.;\n\tfloat frequency = 1.;\n\tfloat y = sin( x * frequency );\n\tfloat t_t = 0.01*(-t * 130.0);\n\ty += sin( x*frequency*(2.1+da) + t_t )*4.5;\n\ty += sin( x*frequency*(1.72+da) + t_t * 1.121 )*4.0;\n\ty += sin( x*frequency*(2.221+da) + t_t * 0.437 )*5.0;\n\ty += sin( x*frequency*(3.1122+da) + t_t * 4.269 )*2.5;\n\ty *= amplitude * 0.06;\n\treturn y;\n}\n\nfloat VFx_t01( float x, float t, float id){ return .5 + .5*VFx_t( x, t, id );}\n\nfloat Fx( float x, vec2 scale )\n{\n\n    const float d_sig = 5.;\n    float sc_y = scale.y/d_sig;\n\tfloat ret = smoothstep( -scale.x, 0., x ) - smoothstep( .0, +scale.x, x );\n\n\tret *= sc_y;\n\tfloat sig = sign( sc_y );\n\tret = smoothstep( .0, sig * d_sig, ret - sig ) * sc_y;\n\treturn ret;\n}\n\n//#undef time\n//#define time (10.*1.936)\n\n//#define TEST_ONCE_4_CONSTANT_EYES\n#ifndef TEST_ONCE_4_CONSTANT_EYES\n\n#define COUNT_L 15\n\nconst float max_w = 0.5 / float( COUNT_L );\n\nconst vec2 scale = vec2( .1, 2. )*5.;\nconst vec2 d_uv = vec2( 0., -.3 );\n#else\n#define COUNT_L 8\n\nconst float max_w = .000025 / float( COUNT_L );\n\nconst vec2 scale = vec2( .1, 2. )*3.;\nconst vec2 d_uv = vec2(-0.150,-0.420);\n#endif\n\nvec3 color = vec3( 0 );\n//#define FUNC_VFX(id)\t ( max_w * (1. + VFx_t(id , time )) )\n#define FUNC_VFX(id)\t ( max_w * (1. + VFx_t((id) + uv.y, uv.y - time, id )) )\nstruct Line\n{\n\tfloat id;\n\tfloat id_2;\n\n\tfloat xs;\n\tfloat Vx;\n\tfloat c_pos;\n\n\tfloat eye_l;\n\tfloat eye_r;\n\n\tfloat eye_fl;\n\tfloat eye_fr;\n    \n\tvec2 eye_pos; //todo delete x is always c_pos\n\n\tvec3 color_eye;\n\n\tvec2 scale_eye;\n};\n\nLine setLine(in Line line_in,in vec2 uv){\n    Line line = line_in;\n    line.xs = line.id / float( COUNT_L );\n\tline.id_2 = RandFloat( int(line.id) ) * 2.;\n\tline.Vx = FUNC_VFX( line.id_2 );\n\tline.c_pos = line.xs + line.Vx;\n    return line;\n}\n\nLine setLine( in vec2 uv )\n{\n    Line line;\n\tline.id = floor( uv.x * float( COUNT_L ) );\n    return setLine(line, uv);\n}\n\nLine setLine( in vec2 uv, in float id )\n{\n    Line line;\n\tline.id = id;\n    return setLine(line, uv);\n}\n\n//____________________________________________________________\n// https://www.shadertoy.com/view/MlXyWM\n//original type\n//const int recursionCount\t\t= 8;\t// how deep to recurse\nfloat GetRecursionFade( int recursionCount, int r, float timePercent )\n{\n\tif (r > recursionCount)\n\t\treturn timePercent;\n\n\t// fade in and out recusion\n\tfloat rt = max( float( r ) - timePercent, 0.0 );\n\tfloat rc = float( recursionCount );\n\treturn rt / rc;\n}\n\nvec3 CombinePixelColor( int recursionCount, vec3 color, float timePercent, int i, int r )\n{\n\tvec3 myColor = vec3\n\t(\n\t\tmix( -0.1, 0.1, RandFloat( i + r ) ),\n\t\tmix( 0.0, 0.8, RandFloat( i + r + 100 ) ),\n\t\tmix( 0.0, 0.8, RandFloat( i + r + 200 ) )\n\t);\n\n\t// combine with my color\n\tfloat f = GetRecursionFade( recursionCount, r, timePercent );\n\tmyColor.y = pow( myColor.y, 4.0 );\n\tmyColor.z = pow( myColor.z, 4.0 );\n\tcolor += myColor * f;\n\treturn color;\n}\n\nvec3 FinishPixel( vec3 color, vec2 uv )\n{\n\t// color wander\n\tcolor.x += 0.02*time;\n\treturn HsvToRgb( color );\n}\n//____________________________________________________________\n\nbool get_eye( in Line line_in,out Line line, in vec2 uv )\n{\n#if 1\nreturn false;\n#else\n    line = line_in;\n    //скорость раскрытия\n    //expansion speed\n\t//---\n    const vec2 max_scale = vec2( (4.32), (6.680) );\n\t//line.scale_eye = vec2(max_scale.x,1.15) ;\n\tline.scale_eye = max_scale * 1.;\n\n\tfloat udid = RandFloat( int( line.id ) );\n\t//t = .94;\n\t//t= .89+.04*sinft(.0,1.,line.id+t);\n\tfloat t_time = time * .3;\n\tline.scale_eye *= sinft( .0, 1.3, t_time + udid * scale.y );\n\t//line.scale_eye *= sinft(.0,1., t_time+line.id*t*scale.y );\n\n#ifdef TEST_ONCE\n\t//test open eye\n\tline.scale_eye = max_scale * clamp( 0.968, .0, 1. );\n    line.scale_eye = max_scale * sinft(.9,1.2,time*2.);//0.936;\n#endif\n\n    // movement speed\n\tline.eye_pos.y = scale.y*(-1. + 3.*fract( .25*time*udid ));\n\tline.eye_pos.x = line.c_pos;\n\n#ifdef TEST_ONCE\n\t//test pos eye\n\tline.eye_pos.y = 0.084;\n#endif\n\n\tline.eye_fl = Fx( line.eye_pos.y - uv.y, -line.scale_eye );\n\tline.eye_fr = Fx( line.eye_pos.y - uv.y, line.scale_eye );\n\n\t//color += plot_Fy( pos_eye.x + fl ,color, uv);\n\t//color += plot_Fy( pos_eye.x + fr ,color, uv);\n    //line itself (line.xs + line.Vx) + eye\n\tline.eye_l = line.c_pos + line.eye_fl;\n\tline.eye_r = line.c_pos + line.eye_fr;\n\n\tconst float dw = .0001;\n\tfloat fill = smoothstep( line.eye_l, line.eye_l + dw, uv.x )\n\t\t- smoothstep( line.eye_r, line.eye_r + dw, uv.x );\n    \n\n\tif (fill > .00001)\n\t{\n        float t_l = smoothstep(line.eye_pos.x, line.eye_l, uv.x);\n        float t_r = smoothstep(line.eye_pos.x, line.eye_r, uv.x);\n        float to_dark_1 = pow(t_l + t_r, 2.9);\n        \n        \n        float max_r = pow(Fx( line.eye_pos.y , line.scale_eye ) , .04);\n        float to_dark_2 = \n             //smoothstep(.0, \n                            length( (line.eye_pos - uv) * line.scale_eye *vec2(2.,1.) / scale)// /max_r\n                        \n                        //, max_r*.25)\n            ;\n#if 0\n        //center positions\n        float it = to_dark_2*10.;\n        float ret = it - floor(it);\n        line.color_eye = vec3(\n        //to_dark_2\n            ret\n             //+\n            //smoothstep(line.eye_r, line.eye_pos.x, uv.x)\n        );\n        \n        //line.color_eye = plot_Fy(line.eye_pos.x ,line.color_eye ,uv);\n        //line.color_eye = plot_Fx(line.eye_pos.y ,line.color_eye ,uv);\n        \n        //line.color_eye = plot_Fy(line.eye_l ,line.color_eye ,uv);\n        //line.color_eye = plot_Fy(line.eye_r ,line.color_eye ,uv);\n        return true;\n#endif\n        \n\n        //__________________________________________________________________________________________\n        //first option\n\tvec3 ret_col1 = vec3(to_dark_2);\n#if 1\n\t{\n        ret_col1 = hsb2rgb(\n\t\t\tvec3(\n\t\t\t\tRandFloat( int(\n\t\t\t\t\tto_dark_2*30. + line.id_2*line.id + time * 10.\n\t\t\t\t\t) )\n\t\t\t\t,\n\t\t\t\t1., 1.-to_dark_1\n\t\t\t) );\n\t}\n\n#endif\n//uv second)\nvec3 ret_col2 = vec3(.0);\n#if 1   \n\t{\n        float rand_id = RandFloat( int( line.id_2 ));\n\t\tfloat iterations = to_dark_2 * (25.*sinft( .5, 1., time ) + rand_id )+ time * -.5;\n\t\tfloat pct2 = iterations - floor( iterations );\n\t\t//_____\n\t\tconst int recursionCount = 5;\n\t\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t\t\tret_col2 = CombinePixelColor( recursionCount, ret_col2, pct2, int( iterations + rand_id * time ), r );\n\n\t\tret_col2.x += time * 1.5;\n\t\tret_col2 = HsvToRgb( ret_col2 );\n\t}\n#endif\n     \n        ret_col2 = mix(ret_col2,vec3(.0),to_dark_1);\n\t\tcolor = mix(\n            ret_col1,\n            ret_col2,\n            //0.\n            sinft(.0,1.,time*udid)\n        );\n\n        //color = vec3(to_dark_2);\n\n\n#if 0 //type eye\n\t\tif (mod( line.id, 2. ) > .5)return true;\n\t\tvec2 tuv = line.eye_pos - uv;\n\t\ttuv *= line.scale_eye / scale;\n\t\t//tuv.y *= line.scale_eye.y / (scale.y*.25);\n\n\t\tfloat angle = atan( tuv.y, tuv.x ) + time * 5.;\n\t\tfloat r = length( tuv ) / line.scale_eye.x*2.5;\n\n\n\t\tfloat sign = mod( r, sinft( .5, 1.000,\n\t\t\t\t\t\t\t\t\ttime*.5\n\t\t) ) >= 0.25 ? -1. : +1.;\n\t\t//sign = 1.;\n\n\t\tfloat it_sp = 100.*(-1.620 * sqrt( r ) + angle * (-.060 * sign));\n\n\t\tfloat sp = cos( it_sp );\n\t\tfloat sp_2 = sp;\n\t\tsp = sp > .5*r ? 1. : .0;\n\n\t\t//line.color_eye = vec3(sp);\n\t\t//line.color_eye = mix(vec3(sp), line.color_eye ,sinft(.0, 1., time*4.) );\n\t\t///*\n\t\tline.color_eye = mix(//hsb2rgb(vec3(sp,sp,to_dark)), \n\t\t\t\t\t\t\t  vec3( sp ),\n\t\t\t\t\t\t\t  hsb2rgb( vec3(\n\t\t\t\t\t\t\t\t  RandFloat( int(\n\t\t\t\t\t\t\t\t\t  sign*(r + time * .5)*10.\n\t\t\t\t\t\t\t\t\t  ) )\n\t\t\t\t\t\t\t\t  , 1., to_dark_2 ) ),\n\n\t\t\t\t\t\t\t  sinft( .0, 1.5, time ) * sp_2 * r );\n\t\t/**/\n\n\n\n#endif\n\t\treturn true;\n\t\t//line.color_eye = vec3(t_eye);\n\t}\n    return false;\n#endif\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n//###################################################\n    \n\tuv.x *= resolution.x / resolution.y;\n\n\tuv += d_uv;\n\tuv *= scale;\n    \n\tLine line_c = setLine( uv ); \n    Line line_l = setLine(uv, line_c.id - 1. );\n\tLine line_r = setLine(uv, line_c.id + 1. );\n\tfloat id2 = line_c.id;\n\tfloat t_s1 = line_c.c_pos;\n\tfloat t_s2 = line_r.c_pos;\n   \n    bool hasEye = get_eye( line_c,line_c, uv );\n    color += line_c.color_eye;\n  \n\tif (uv.x < line_c.c_pos)\n\t{//l - c\n\t\tid2 = line_l.id;\n\t\tt_s1 = line_l.c_pos;\n\t\tt_s2 = line_c.c_pos;\n\n\t\thasEye = hasEye || get_eye(line_l, line_l, uv );\n\n\t\tcolor += line_l.color_eye;\n        \n\t\tt_s1 += line_l.eye_fr;\n\t\tt_s2 += line_c.eye_fl;\n\n\t}\n\telse\n\t{\n\t\t// c - r\n\t\thasEye = hasEye || get_eye(line_r, line_r, uv );\n\n        color += line_r.color_eye;\n        \n\t\tt_s1 += line_c.eye_fr;\n\t\tt_s2 += line_r.eye_fl;\n\t}\n\n\t\n\tfloat pct = smoothstep( t_s1, t_s2, uv.x );\n\t//color lines\n    //pct - bw gradient from the center (transition saturation here)\n\tpct = pow( 1.760*pct*(1.0 - pct), 1.1 );//0.376 );\n\t\t\t\t\t\t\t\t\t\t\t//pct = 1.-pct;\n\t\t\t\t\t\t\t\t\t\t\t///______________________\n                                            //gradient color type\n    \n    //first option\n\tvec3 ret_col1 = vec3(pct);\n#if 1    // makes lines colored\n\t{\n#define gen_col(val) VFx_t01( id2 + pct * uv.y + (val), (val) + uv.y + time + floor(pct*60.), id2)\n\t\tfloat r = gen_col( 0.450 );\n\t\tfloat g = gen_col( 1.3445 );\n\t\tfloat b = gen_col( 2.021 );\n\t\tret_col1 += (vec3( r, g, b )*pct) / (-.25888) + pct;\n\t\tret_col1 += hsb2rgb( vec3(\n\t\t\tRandFloat( int(\n\t\t\t(id2*10.0001 + pct * 3. + time * .1) / .1\n\t\t\t\t) ) + fract( time*.2 )\n\t\t\t, 1., pct ) );\n\t}\n\n//second)\n    vec3 ret_col2 = vec3(.0);\n\t{\n        //bw gradient multiply it and move it over time\n\t\t//float iterations =  pct*10. + u_time*-.5;//original\n\t\tfloat iterations = pct * (100.*sinft( .5, 1., time ) + RandFloat( int( id2 ) )) + time * -.5;\n\t\tfloat pct2 = iterations - floor( iterations );\n\t\t//_____\n\t\tconst int recursionCount = 5;\n\t\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t\t\tret_col2 = CombinePixelColor( recursionCount, ret_col2, pct2, int( iterations + id2 * time ), r );\n\t\t//original\n\t\t//new_color =  FinishPixel(new_color, uv);\n\n\t\t//color.x += 0.02*u_time;\n\t\t//return HsvToRgb(color);\n\n\t\tret_col2.x += time * .5;\n\t\tret_col2 = HsvToRgb( ret_col2 );\n\t}\n    if(!hasEye){\n\t\tcolor = mix(ret_col1,ret_col2,sinft(.0,\n                                            //3. * sinft(.125,1.,time)\n                                            1.\n                                            ,time));\n        //color = vec3(pow(.5,1.-pct));\n        //color =  ret_col2;\n    }\n    //else color = vec3(1.);\n    \n#else\n    color = vec3(pct);\n#endif\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}