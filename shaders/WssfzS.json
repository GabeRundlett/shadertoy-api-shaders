{
    "Shader": {
        "info": {
            "date": "1589069117",
            "description": "SDF   -> https://iquilezles.org/articles/distfunctions/distfunctions.htm\nheart -> https://www.youtube.com/watch?v=aNR4n0i2ZlM",
            "flags": 0,
            "hasliked": 0,
            "id": "WssfzS",
            "likes": 6,
            "name": "rayMarch_sphere+heart",
            "published": 3,
            "tags": [
                "raymarch",
                "sphere",
                "heart"
            ],
            "usePreview": 0,
            "username": "elle",
            "viewed": 544
        },
        "renderpass": [
            {
                "code": "#define PI\t\t3.14159265\n#define EPS\t0.001\n#define MAX_STEPS 200\n#define MAX_DIST 100.0\n#define BOARD_SQUARE 1.0\n#define SPHERE1 0\n#define SPHERE2 1\n#define SPHERE3 2\n#define HEART\t3\n#define PLANE\t4\n\n\nstruct Intersect {\n    int\t\tidx;\n    float\tdist;};\n\nstruct Point\t{\n\tvec3\tpos;\n    vec3\tcol;};\n    \nvec3 diffCol[] = vec3[](vec3(0.0, 0.0, 1.0),\n\t\t\t\t\t\tvec3(1.0, 0.0, 1.0),\n\t\t\t\t\t\tvec3(0.0, 1.0, 0.3),\n\t\t\t\t\t\tvec3(1.0, 0.1, 0.1));\n\nfloat diff[] =  float[](0.4, 0.5,  0.4,  0.8,  0.7);\nfloat spec[] =  float[](0.9, 1.2,  1.1,  1.9,  0.3);\nfloat specPow[]=float[](8.0, 16.0, 16.0, 32.0, 4.0);\n\nvec3 lightPos = vec3(-3.0, 3.0, 5.0);\n\nfloat sphereDist(in vec3 pos, in float radius, in vec3 center)\n{\n    return (length(pos + center) - radius);\n}\n\nfloat planeDist(in vec3 pos, in vec4 normal)\n{\n    return (dot(pos, normal.xyz) + normal.w);\n}\n\nfloat heartDist(vec3 q, float r)\n{\n    float ani = pow(0.5 + 0.5 * sin(7.0 * iTime + q.y / 20.0), 4.0);\n    q *= 1.0 - 0.2 * vec3(1.0,0.5,1.0)*ani;\n    q.y -= 0.2 * ani;\n    float x = abs(q.x);\n        \n    float y = q.y;\n    float z = q.z;\n    y = -0.5 + y * 1.2 - x * sqrt(max((5.0 - x) / 10.0, 0.0));\n    float res = sqrt(x*x + y*y + z*z) - r;\n    return res;\n}\n\n\nIntersect sceneDist(vec3 pos)\n{\n\tfloat SINt = sin(iTime);\n    float SINt03 = sin(iTime * 0.3);\n    float COSt03 = cos(iTime * 0.3);\n    float sphereD1_1 = sphereDist(pos, 1.8, vec3(0, 0.1, 0));\n\tfloat sphereD1_2 = sphereDist(pos, 1.8, vec3(0, 0.1 - 2.0*(0.5 + 0.5 * SINt), 0));\n    float sphereD2 = sphereDist(pos, 0.7, vec3(2.8 * COSt03, SINt, 2.8 * SINt03));\n    float sphereD3 = sphereDist(pos, 0.5, vec3(3.8 * SINt03, cos(iTime), 3.8 * COSt03));\n    float planeD = planeDist(pos, vec4(0.0, 1.0, 0.0, 2.2));\n    float heartD = heartDist(pos, 0.5);\n    Intersect res;\n    \n    // hollow sphere\n\tsphereD1_1 = abs(sphereD1_1) - 0.03;\n\tsphereD1_1 = max(sphereD1_1, pos.y);\n\tsphereD1_2 = abs(sphereD1_2) - 0.03;\n\tsphereD1_2 = max(sphereD1_2, - (pos.y - 2.0 * (0.5 + 0.5 * SINt)));\n\n    res.dist = min(min(min(min(min(sphereD1_1, sphereD1_2), sphereD2), sphereD3), planeD), heartD);\n    if (res.dist == sphereD1_1 || res.dist == sphereD1_2)\n        res.idx = SPHERE1;\n    else if (res.dist == sphereD2)\n\t\tres.idx = SPHERE2;\n    else if (res.dist == sphereD3)\n\t\tres.idx = SPHERE3;\n    else if (res.dist == heartD)\n        res.idx = HEART;     \n    else\n        res.idx = PLANE;\n    return (res);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    sceneDist(vec3(p.x + EPS, p.y, p.z)).dist - sceneDist(vec3(p.x - EPS, p.y, p.z)).dist,\n    sceneDist(vec3(p.x, p.y + EPS, p.z)).dist - sceneDist(vec3(p.x, p.y - EPS, p.z)).dist,\n    sceneDist(vec3(p.x, p.y, p.z  + EPS)).dist - sceneDist(vec3(p.x, p.y, p.z - EPS)).dist));\n}\n\nIntersect rayMarch(vec3 ro, vec3 rd)\n{\n    Intersect d;\n    Intersect intersect;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        d = sceneDist(ro + intersect.dist * rd);\n        intersect.dist += d.dist;\n        if (intersect.dist < EPS || intersect.dist >= MAX_DIST)\n            break;\n    }\n    intersect.idx = d.idx;\n    return (intersect);\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float min_t, in float max_t, in float k)\n{\n    float res = 1.0;\n    for (float t = min_t; t < max_t;)\n    {\n        float dist = sceneDist(ro + rd * t).dist;\n        if (dist < EPS)\n            return 0.0;\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return (res);\n}\n\nvec3 boardColor(vec3 p)\n{\n    vec3 pos = vec3(p.x, p.y, p.z - (0.7 * iTime));\n    \n    if ((mod(pos.x,(BOARD_SQUARE * 2.0)) < BOARD_SQUARE && mod(pos.z,(BOARD_SQUARE * 2.0)) > BOARD_SQUARE) ||\n        (mod(pos.x,(BOARD_SQUARE * 2.0)) > BOARD_SQUARE && mod(pos.z,(BOARD_SQUARE * 2.0)) < BOARD_SQUARE))\n\t\treturn vec3(1.0);\n    else\n\t\treturn vec3(0.0);\n}\n\nvec3 getLight(int idx, vec3 pos, vec3 eye)\n{\n    vec3 diffuseCol;\n    if (idx == PLANE)\n        diffuseCol = boardColor(pos);\n    else\n        diffuseCol = diffCol[idx];\n    vec3 specularCol = vec3(1.0);\n    vec3 Norm = getNormal(pos);\n    vec3 Ldir = normalize(lightPos - pos);\n    vec3 View = normalize(eye - pos);\n    vec3 Refl = normalize(reflect(-Ldir, Norm));\n\n    float dotLN = dot(Ldir, Norm);\n    float dotRV = dot(Refl, View);\n\n    // light not visible\n    if (dotLN < 0.0)\n        return vec3(0.0);\n\n    // light reflection in opposite direction, apply only diffuse lighting\n    if (dotRV < 0.0)\n        return 1.7 * (diffuseCol * dotLN) * diff[idx];\n\n    vec3 half_direction = normalize(normalize(Ldir) + View);\n    float specular = pow(max(dot(half_direction, Norm), 0.0), specPow[idx]);\n    return 1.7 * diffuseCol * dotLN * diff[idx] + specularCol * specular * spec[idx];\n}\n\nPoint getColor(vec3 ro, vec3 rd, vec3 eye)\n{\n    Point point;\n    Intersect intersect = rayMarch(ro, rd);\n    point.pos = ro + intersect.dist * rd;\n    if (intersect.dist > MAX_DIST - EPS)\n        point.col = vec3(0.0, 0.0, 1.0 - 2.0 * rd.y); //background\n    else\n    {    \n\t\t//ambient\n        vec3 ambientCol = vec3(0.2, 0.4, 0.7);    \n    \tvec3 ambientLight = 0.25 * vec3(1.0);\n    \tpoint.col = ambientLight * ambientCol;\n\n    \t//shadow\n    \tvec3 shadowDir = normalize(lightPos - point.pos);\n    \tfloat shadow = getShadow(point.pos + shadowDir, shadowDir, 0.0, MAX_DIST, 8.0);\n\n    \t//diffuse + specular\n    \tvec3 blinn_phong = getLight(intersect.idx, point.pos, eye) * shadow;\n    \tpoint.col += blinn_phong;\n    }\n    return point;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 ro = vec3(mouse.x, mouse.y, 8.0);\n\n    Point point = getColor(ro, rd, ro);\n\tvec3 color = point.col;   \n    \n    vec3 rd1 = rd - (2.0 * dot(rd, getNormal(point.pos)) * getNormal(point.pos));\n    Point point2 = getColor(point.pos + rd1, rd1, ro);\n    color = mix(color, point2.col, 0.22);\n    \n    vec3 rd2 = rd1 - (2.0 * dot(rd1, getNormal(point2.pos)) * getNormal(point2.pos));\n    Point point3 = getColor(point2.pos + rd2, rd2, ro);\n    color = mix(color, point3.col, 0.12);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}