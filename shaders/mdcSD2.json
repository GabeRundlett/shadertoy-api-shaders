{
    "Shader": {
        "info": {
            "date": "1680442100",
            "description": "billiard thing made more or less completely with gpt4. I mean it took me insane amount of energy to guide it but I avoided writing the code myself lol",
            "flags": 0,
            "hasliked": 0,
            "id": "mdcSD2",
            "likes": 7,
            "name": "billiard (GPT4) (wip)",
            "published": 3,
            "tags": [
                "3d",
                "ai",
                "billiard",
                "chatgpt",
                "gpt4"
            ],
            "usePreview": 0,
            "username": "valyagolev",
            "viewed": 217
        },
        "renderpass": [
            {
                "code": "// Written using ChatGPT (GPT4)\n\n// Constants\nconst float tableWidth = 0.8;\nconst float tableHeight = 0.4;\nconst float ballRadius = 0.03;\n\n// Ball colors\nconst vec4 whiteBallColor = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 ballColor1 = vec4(0.8, 0.0, 0.0, 1.0);\nconst vec4 ballColor2 = vec4(0.0, 0.8, 0.0, 1.0);\nconst vec4 ballColor3 = vec4(0.0, 0.0, 0.8, 1.0);\n\n// Ball positions relative to the table (center of the table is at (0.5, 0.5))\nconst vec2 whiteBallInitialPosition = vec2(0.5 - 0.25 * tableWidth, 0.5);\nconst vec2 ballPosition1 = vec2(0.5 + 0.25 * tableWidth, 0.5);\nconst vec2 ballPosition2 = vec2(0.5 + 0.25 * tableWidth + ballRadius * 2.0, 0.5 + ballRadius * sqrt(3.0) / 2.0);\nconst vec2 ballPosition3 = vec2(0.5 + 0.25 * tableWidth - ballRadius * 2.0, 0.5 + ballRadius * sqrt(3.0) / 2.0);\n\n// Camera properties\nconst vec3 cameraPosition = vec3(0.5, 0.5, 1.5);\nconst vec3 cameraTarget = vec3(0.5, 0.5, 0.0);\nconst float cameraAngle = -0.2;\n\nconst float strikeTime = 1.0; // Time (in seconds) it takes for the cue to strike the ball\nconst float backOffTime = 0.2; // Time (in seconds) it takes for the cue to go back after the strike\nconst float whiteRollTime = 1.0;\nconst float ballsRollTime = 1.0;\n\nconst float totalTime = (strikeTime + backOffTime + whiteRollTime + ballsRollTime);\n\nvec2 whiteBallPosition()\n{\n    float t = mod(iTime, totalTime);\n    vec2 direction = normalize(ballPosition3 - whiteBallInitialPosition);\n\n    // White ball rolling after being hit\n    if (t >= (strikeTime + backOffTime) && t < (strikeTime + backOffTime + whiteRollTime))\n    {\n        float rollProgress = (t - (strikeTime + backOffTime)) / whiteRollTime;\n        vec2 newPosition = whiteBallInitialPosition + direction * rollProgress * (length(whiteBallInitialPosition - ballPosition3) - 2.0 * ballRadius);\n        return newPosition;\n    }\n    // White ball goes back a bit after the hit at a 30-degree angle\n    else if (t >= (strikeTime + backOffTime + whiteRollTime) && t < totalTime)\n    {\n        float backOffProgress = (t - (strikeTime + backOffTime + whiteRollTime)) / ballsRollTime;\n        vec2 backOffDirection = vec2(-direction.x * cos(radians(30.0)) - direction.y * sin(radians(30.0)), direction.x * sin(radians(30.0)) + direction.y * cos(radians(30.0)));\n        vec2 newPosition = (ballPosition3 - direction * 2.0 * ballRadius) + backOffDirection * backOffProgress * ballRadius * 2.0;\n        return newPosition;\n    }\n    // White ball remains in its initial position or at the end of the backoff motion\n    else\n    {\n        return whiteBallInitialPosition;\n    }\n}\n\nvec2 ballPosition3Updated()\n{\n    float t = mod(iTime, totalTime);\n\n    // Time intervals for the ball movement\n    float forwardTime = 0.1;\n    float backwardTime = 0.2;\n    float rollTime = ballsRollTime * 0.4;\n\n    vec2 direction = normalize(whiteBallInitialPosition - ballPosition3);\n\n    if (t >= (strikeTime + backOffTime + whiteRollTime) && t < (strikeTime + backOffTime + whiteRollTime + forwardTime))\n    {\n        float forwardProgress = (t - (strikeTime + backOffTime + whiteRollTime)) / forwardTime;\n        vec2 newPosition = ballPosition3 + direction * forwardProgress * ballRadius * 0.5;\n        return newPosition;\n    }\n    else if (t >= (strikeTime + backOffTime + whiteRollTime + forwardTime) && t < (strikeTime + backOffTime + whiteRollTime + forwardTime + backwardTime))\n    {\n        vec2 forwardPosition = ballPosition3 + direction * ballRadius * 0.5;\n        float backwardProgress = (t - (strikeTime + backOffTime + whiteRollTime + forwardTime)) / backwardTime;\n        vec2 backwardDirection = vec2(direction.x * cos(radians(-20.0)) - direction.y * sin(radians(-20.0)), direction.x * sin(radians(-20.0)) + direction.y * cos(radians(-20.0)));\n        vec2 newPosition = forwardPosition + backwardDirection * backwardProgress * ballRadius;\n        return newPosition;\n    }\n    else if (t >= (strikeTime + backOffTime + whiteRollTime + forwardTime + backwardTime) && t < (strikeTime + backOffTime + whiteRollTime + forwardTime + backwardTime + rollTime))\n    {\n        vec2 backwardPosition = ballPosition3 + direction * ballRadius * 0.5 + vec2(direction.x * cos(radians(-50.0)) - direction.y * sin(radians(-20.0)), direction.x * sin(radians(-20.0)) + direction.y * cos(radians(-20.0))) * ballRadius;\n        float rollProgress = (t - (strikeTime + backOffTime + whiteRollTime + forwardTime + backwardTime)) / rollTime;\n        vec2 newPosition = backwardPosition - direction * rollProgress * ballRadius * 2.0;\n        return newPosition;\n    }\n    else\n    {\n        return ballPosition3;\n    }\n}\n\n\n\nfloat cueDist()\n{\n    float maxDist = 0.3; // Maximum distance the cue moves back before striking\n    float backOffDist = 0.01; // Distance the cue moves back after striking the ball\n\n    float t = mod(iTime, totalTime);\n\n    if (t < strikeTime)\n    {\n        return mix(maxDist, 0.0, t / strikeTime);\n    }\n    else if (t >= strikeTime)// + backOffTime)\n    {\n        return 0.01;\n    }\n    else\n    {\n        float backOffProgress = (t - strikeTime) / backOffTime;\n        return mix(0.01, backOffDist, backOffProgress);\n    }\n}\n\n\n\nvec4 drawBall(in vec2 uv, in vec2 ballCenter, in vec4 ballColor)\n{\n    // Calculate the distance from the center of the ball\n    float distanceToBall = length(uv - ballCenter);\n\n    // Check if the point is inside the ball\n    bool insideBall = distanceToBall <= ballRadius;\n\n    if (!insideBall)\n    {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    // Calculate the z-coordinate of the point on the ball's surface\n    float z = sqrt(ballRadius * ballRadius - distanceToBall * distanceToBall);\n\n    // Calculate the surface normal (in 3D)\n    vec3 surfaceNormal = normalize(vec3(uv - ballCenter, z));\n\n    // Define the light source\n    vec3 lightPosition = vec3(0.5, 0.5, 1.0);\n    vec3 lightDirection = normalize(lightPosition - vec3(ballCenter, z));\n\n    // Calculate Lambertian shading\n    float lambert = max(dot(surfaceNormal, lightDirection), 0.0);\n\n    // Define ambient light\n    float ambient = 0.3;\n\n    // Calculate the final color\n    vec4 color = (ambient + lambert) * ballColor;\n\n    return color;\n}\n\n// Simple random function for creating the noise\nfloat rand(vec2 n)\n{\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec4 drawTable(in vec2 uv)\n{\n    // Table color\n    vec4 tableColor = vec4(0.0, 0.5, 0.0, 1.0);\n\n    // Table border color\n    vec4 borderColor = vec4(0.6, 0.3, 0.0, 1.0);\n\n    // Table border size\n    float borderSize = 0.01;\n\n    // Check if the point is inside the table border\n    bool insideBorder = uv.x >= (0.5 - tableWidth / 2.0 - borderSize) && uv.x <= (0.5 + tableWidth / 2.0 + borderSize)\n                        && uv.y >= (0.5 - tableHeight / 2.0 - borderSize) && uv.y <= (0.5 + tableHeight / 2.0 + borderSize);\n\n    // Check if the point is inside the table\n    bool insideTable = uv.x >= (0.5 - tableWidth / 2.0) && uv.x <= (0.5 + tableWidth / 2.0)\n                       && uv.y >= (0.5 - tableHeight / 2.0) && uv.y <= (0.5 + tableHeight / 2.0);\n\n    // Calculate the color of the point\n    vec4 color = insideBorder ? (insideTable ? tableColor : borderColor) : vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Add baize texture to the table surface\n    if (insideTable)\n    {\n        float noise = rand(uv * 25.0);\n        color.rgb *= (1.0 - 0.1 * noise);\n    }\n\n    // Add shading to the borders\n    if (!insideTable && insideBorder)\n    {\n        vec2 borderNormal;\n        if (abs(uv.x - (0.5 - tableWidth / 2.0)) <= borderSize || abs(uv.x - (0.5 + tableWidth / 2.0)) <= borderSize)\n        {\n            borderNormal = vec2(1.0, 0.0);\n        }\n        else\n        {\n            borderNormal = vec2(0.0, 1.0);\n        }\n\n        vec2 lightDirection = normalize(vec2(0.5, 1.0) - uv);\n        float lambert = max(dot(borderNormal, lightDirection), 0.0);\n        color.rgb *= (0.4 + 0.6 * lambert);\n    }\n\n    return color;\n}\n\n\nvec2 project3DTo2D(in vec3 p)\n{\n    return p.xy;\n}\nvec4 drawCue(in vec2 uv, in float dist)\n{\n    // Calculate the direction from the white ball to the center of the triangle formed by the other three balls\n    vec2 triangleCenter = (ballPosition1 + ballPosition2 + ballPosition3) / 3.0;\n    vec2 direction = normalize(triangleCenter - whiteBallInitialPosition);\n\n    // Calculate the cue start and end positions\n    vec2 cueStart = whiteBallInitialPosition - direction * (ballRadius + dist);\n    vec2 cueEnd = cueStart - direction * (ballRadius * 15.0);\n\n    // Define the cue width\n    float cueWidth = 0.005;\n\n    // Calculate the distance from the point (uv) to the cue line\n    float distanceToCue = length((uv - cueStart) - dot(uv - cueStart, cueEnd - cueStart) / dot(cueEnd - cueStart, cueEnd - cueStart) * (cueEnd - cueStart));\n\n    // Check if the point is inside the cue\n    bool insideCue = distanceToCue <= cueWidth;\n\n    // Check if the point is between the start and end positions\n    bool betweenStartAndEnd = dot(uv - cueStart, cueEnd - cueStart) >= 0.0 && dot(uv - cueEnd, cueStart - cueEnd) >= 0.0;\n\n    // Calculate the color of the point\n    vec4 color = insideCue && betweenStartAndEnd ? vec4(1.0, 1.0, 1.0, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Add shading to the cue\n    if (insideCue && betweenStartAndEnd)\n    {\n        float shading = 0.5 + 0.5 * (1.0 - distanceToCue / cueWidth);\n        color.rgb *= shading;\n    }\n\n    // Calculate the shadow projection on the table\n    float shadowWidth = cueWidth * 3.0;\n    float shadowDistanceToCue = length((uv - cueStart) - dot(uv - cueStart, cueEnd - cueStart) / dot(cueEnd - cueStart, cueEnd - cueStart) * (cueEnd - cueStart)) - cueWidth;\n    bool insideShadow = shadowDistanceToCue <= shadowWidth && betweenStartAndEnd;\n\n    // Add the shadow over the table\n    if (insideShadow)\n    {\n        float shadowFactor = 1.0 - 0.3 * (1.0 - shadowDistanceToCue / shadowWidth);\n        color.rgb *= shadowFactor;\n    }\n\n    return color;\n}\n\nvec4 drawCueShadow(in vec2 uv, in float dist)\n{\n    // Calculate the direction from the white ball to the center of the triangle formed by the other three balls\n    vec2 triangleCenter = (ballPosition1 + ballPosition2 + ballPosition3) / 3.0;\n    vec2 direction = normalize(triangleCenter - whiteBallInitialPosition);\n\n    // Calculate the cue start and end positions\n    vec2 cueStart = whiteBallInitialPosition - direction * (ballRadius + dist);\n    vec2 cueEnd = cueStart - direction * (ballRadius * 15.0);\n\n    // Define the shadow width and offset\n    float shadowWidth = 0.008;\n    vec2 shadowOffset = vec2(0.002, -0.002);\n\n    // Calculate the distance from the point (uv) to the cue line\n    float distanceToShadow = length((uv - cueStart - shadowOffset) - dot(uv - cueStart - shadowOffset, cueEnd - cueStart) / dot(cueEnd - cueStart, cueEnd - cueStart) * (cueEnd - cueStart));\n\n    // Check if the point is inside the shadow\n    bool insideShadow = distanceToShadow <= shadowWidth;\n\n    // Check if the point is between the start and end positions\n    bool betweenStartAndEnd = dot(uv - cueStart - shadowOffset, cueEnd - cueStart) >= 0.0 && dot(uv - cueEnd - shadowOffset, cueStart - cueEnd) >= 0.0;\n\n    // Calculate the color of the point\n    vec4 color = insideShadow && betweenStartAndEnd ? vec4(0.0, 0.0, 0.0, 0.3) : vec4(0.0, 0.0, 0.0, 0.0);\n\n    return color;\n}\n\nvec4 drawBallShadow(in vec2 uv, in vec2 ballPosition, in vec4 ballColor)\n{\n    // Define the shadow offset and size\n    vec2 shadowOffset = vec2(0.003, -0.003);\n    float shadowSize = ballRadius * 1.2;\n\n    // Calculate the distance from the point (uv) to the ball position\n    float distanceToShadow = length(uv - ballPosition - shadowOffset);\n\n    // Check if the point is inside the shadow\n    bool insideShadow = distanceToShadow <= shadowSize;\n\n    // Calculate the shadow intensity based on the distance to the shadow\n    float shadowIntensity = smoothstep(shadowSize, shadowSize * 0.9, distanceToShadow);\n\n    // Calculate the color of the point\n    vec4 color = insideShadow ? vec4(0.0, 0.0, 0.0, shadowIntensity * 0.5) : vec4(0.0, 0.0, 0.0, 0.0);\n\n    return color;\n}\n\nvec4 drawScene(in vec3 p)\n{\n    // Project the 3D point to 2D\n    vec2 uv = project3DTo2D(p);\n\n    // Draw the billiard table\n    vec4 color = drawTable(uv);\n\n    // Draw the white ball and its shadow\n    vec4 whiteBall = drawBall(uv, whiteBallPosition(), whiteBallColor);\n    vec4 whiteBallShadow = drawBallShadow(uv, whiteBallPosition(), whiteBallColor);\n    color = mix(color, whiteBallShadow, whiteBallShadow.a);\n\n    // Draw the other balls and their shadows\n    vec4 ball1 = drawBall(uv, ballPosition1, ballColor1);\n    vec4 ball1Shadow = drawBallShadow(uv, ballPosition1, ballColor1);\n    color = mix(color, ball1Shadow, ball1Shadow.a);\n\n    vec4 ball2 = drawBall(uv, ballPosition2, ballColor2);\n    vec4 ball2Shadow = drawBallShadow(uv, ballPosition2, ballColor2);\n    color = mix(color, ball2Shadow, ball2Shadow.a);\n\n    vec4 ball3 = drawBall(uv, ballPosition3Updated(), ballColor3);\n    vec4 ball3Shadow = drawBallShadow(uv, ballPosition3Updated(), ballColor3);\n    color = mix(color, ball3Shadow, ball3Shadow.a);\n\n    // Draw the cue and its shadow\n    vec4 cue = drawCue(uv, cueDist());\n    vec4 cueShadow = drawCueShadow(uv, cueDist());\n    color = mix(color, cueShadow, cueShadow.a);\n\n    // Combine the colors\n    color = mix(color, whiteBall, whiteBall.a);\n    color = mix(color, ball1, ball1.a);\n    color = mix(color, ball2, ball2.a);\n    color = mix(color, ball3, ball3.a);\n    color = mix(color, cue, cue.a);\n\n    return color;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Set up the camera\n    float angle = cameraAngle;\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec3 p = vec3(uv, 0.0);\n    p.xy = rotation * (p.xy - 0.5) + 0.5;\n    p += cameraPosition - cameraTarget;\n\n    // Draw the scene\n    vec4 color = drawScene(p);\n\n    // Output to screen\n    fragColor = color;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}