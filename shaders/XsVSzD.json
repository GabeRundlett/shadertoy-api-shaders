{
    "Shader": {
        "info": {
            "date": "1463247257",
            "description": "Traffic flow and jamming - see the source",
            "flags": 32,
            "hasliked": 0,
            "id": "XsVSzD",
            "likes": 19,
            "name": "Flowing Traffic",
            "published": 3,
            "tags": [
                "lattice",
                "cellularautomaton"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 927
        },
        "renderpass": [
            {
                "code": "// \"Flowing Traffic\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Sets of cars that can travel only north or east are randomly placed on\n  lattice sites. At each time step, all the cars in one of the sets move\n  simultaneously to the adjacent lattice site (boundaries are periodic), but\n  only where the new sites are vacant. The overall behavior changes as a\n  function of the occupation probability (shown as a percentage), ranging\n  from free flow to serious jamming, with other interesting features in\n  between. Lattice size depends on window size. (Use multiple buffers to run\n  faster.)\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar);\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float fProb);\n\nfloat gSize;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv, ut, gPos;\n  float fProb, c;\n  int gSizeSq;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  gSize = (canvas.y > 512.) ? 512. : (canvas.y > 200.) ? 256. : 32.;\n  gSizeSq = int (gSize * gSize);\n  fProb = Loadv4 (0).z;\n  ut = abs (uv) - vec2 (1.);\n  if (max (ut.x, ut.y) > 0.) {\n    col = ShowWg (uv, canvas, vec3 (0.82), fProb);\n  } else {\n    gPos = floor (gSize * (0.5 * uv + 0.5));\n    c = Loadv4 (int (gSize * gPos.y + gPos.x)).x;\n    if (c > 0.) col = vec3 (1., 0., 0.);\n    else if (c < 0.) col = vec3 (0., 1., 0.);\n    else col = vec3 (0.1, 0.1, 0.2);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, gSize), floor (fi / gSize)) + 0.5) /\n     txSize);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.7, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float fProb)\n{\n  vec4 wgBx[1];\n  vec3 cc;\n  vec2 ut, ust;\n  float vW[1], asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.39 * asp, -0.05, 0.012 * asp, 0.18);\n  vW[0] = fProb;\n  for (int k = 0; k < 1; k ++) {\n    cc = vec3 (0.3, 0.3, 1.);\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = vec3 (1., 1., 0.);\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? vec3 (1., 1., 0.) : vec3 (0.6);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 2.);\n    if (abs (max (ut.x, ut.y) - 0.015) < 0.006) col = cc;\n    col = mix (col, cc, ShowInt (0.5 * uv - wgBx[k].xy -\n        wgBx[k].zw * vec2 (1., -1.) - vec2 (0.0045, -0.06),\n        0.028 * vec2 (asp, 1.), 2., clamp (floor (100. * vW[k]), 1., 99.)));\n  }\n  return col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Flowing Traffic\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat itRand, gSize;\nconst float pi = 3.14159;\n\nfloat Step (int sId, float ps)\n{\n  vec2 sv;\n  float c, gp;\n  sv = vec2 (mod (float (sId), gSize), floor (float (sId) / gSize));\n  c = Loadv4 (sId).x;\n  if (ps > 0.) {\n    gp = gSize * sv.y;\n    if (c == 0.) {\n      gp += mod (sv.x - 1., gSize);\n      if (Loadv4 (int (gp)).x > 0.) c = 1.;\n    } else if (c > 0.) {\n      gp += mod (sv.x + 1., gSize);\n      if (Loadv4 (int (gp)).x == 0.) c = 0.;\n    }\n  } else {\n    gp = sv.x;\n    if (c == 0.) {\n      gp += gSize * mod (sv.y - 1., gSize);\n      if (Loadv4 (int (gp)).x < 0.) c = -1.;\n    } else if (c < 0.) {\n      gp += gSize * mod (sv.y + 1., gSize);\n      if (Loadv4 (int (gp)).x == 0.) c = 0.;\n    }\n  }  \n  return c;\n}\n\nfloat Init (int sId, float fProb)\n{\n  float s;\n  s = Hashff (mod (17777.7 * (float (sId + 10) + itRand), 2. * pi));\n  return (s < fProb) ? ((s < 0.5 * fProb) ? 1. : -1.) : 0.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[1], stDat, mPtr, mPtrP;\n  vec2 iFrag, canvas, ust;\n  float tCur, asp, vW, c, nStep, fProb;\n  int pxId, wgSel, wgReg, gSizeSq, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y > 512.) ? 512. : (canvas.y > 200.) ? 256. : 32.;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + gSize * iFrag.y);\n  gSizeSq = int (gSize * gSize);\n  if (iFrag.x >= gSize || pxId >= gSizeSq) discard;\n  doInit = false;\n  wgSel = -1;\n  wgReg = -2;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n    fProb = 0.3;\n    itRand = 0.;\n    doInit = true;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.y;\n    fProb = stDat.z;\n    wgSel = int (stDat.w);\n    mPtrP = vec4 (Loadv4 (1).yzw, 0.);\n    itRand = Loadv4 (2).y;\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.39 * asp, -0.05, 0.012 * asp, 0.18);\n    for (int k = 0; k < 1; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) {\n      wgSel = wgReg;\n      itRand = tCur;\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel >= 0) {\n    for (int k = 0; k < 1; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.05, 0.95);\n        break;\n      }\n    }\n    if (kSel == 0) fProb = vW;\n    doInit = true;\n  }\n  if (doInit) {\n    nStep = 0.;\n    c = Init (pxId, fProb);\n  } else {\n    ++ nStep;\n    c = Step (pxId, mod (nStep, 2.));\n  }\n  stDat = vec4 (c, 0., 0., 0.);\n  if      (pxId == 0) stDat.yzw = vec3 (nStep, fProb, float (wgSel));\n  else if (pxId == 1) stDat.yzw = mPtr.xyz;\n  else if (pxId == 2) stDat.yzw = vec3 (itRand, 0., 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, gSize), floor (fi / gSize)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, gSize), floor (fi / gSize)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}