{
    "Shader": {
        "info": {
            "date": "1496270915",
            "description": "Docahedron dancing on rob hubbard's Warhawk",
            "flags": 64,
            "hasliked": 0,
            "id": "lssfW4",
            "likes": 8,
            "name": "Dance of Dodecahedron",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "dodecahedron",
                "soundcloud",
                "505"
            ],
            "usePreview": 0,
            "username": "flewww",
            "viewed": 1047
        },
        "renderpass": [
            {
                "code": "// Source https://www.shadertoy.com/view/Xs3GRB\n#define PHI (1.618033988749895)\n\n// PHI (sqrt(5)*0.5 + 0.5)\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n\n\n// Scene\n\nvec2 rotate(vec2 v, float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a))*v;\n}\n\nfloat mdist(vec3 pos) {\n    const float radius = 1.;\n    pos.xz = rotate(pos.xz, iTime);\n    pos.xy = rotate(pos.xy, 3.*texture(iChannel0,vec2(0.9,0.)).x);\n    return fDodecahedron(pos, radius, 48.);\n}\n\nvec3 march(vec3 pos, vec3 dir) {\n    for(int i=0; i<50; i++) {\n        float dst = mdist(pos);\n        if (dst < 0.0001) break;\n        pos += dir*dst;\n    }\n    return pos;\n}\n\n// Source: https://en.wikipedia.org/wiki/Phong_reflection_model\nfloat phong(vec3 light, vec3 surf, vec3 norm, vec3 cam) {\n    const float ks = 0.7;\n    const float kd = 0.2;\n    const float ka = 0.1;\n    const float al = 5.;\n    \n    vec3 lm = normalize(light - surf);\n    vec3 rm = reflect(-lm, norm);\n    vec3 v = normalize(cam - surf);\n    \n    float diff = kd*dot(lm,norm);\n    float spec = ks*pow(dot(rm,v), al);\n\treturn clamp(ka + max(diff, 0.) + max(spec, 0.), 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 buv = fragCoord.xy / iResolution.xy;\n    vec2 uv = 2.*buv - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera setting (distance and FOV)\n    vec3 dr = normalize(vec3(uv, -3.));\n    vec3 og = vec3(0.,0.,5.);\n    vec3 lt = vec3(-1.,-1.,2.);\n    \n    vec3 pt = march(og, dr);\n    float ds = length(pt - og);\n\n    fragColor = vec4(0.,1.,0.,0.)*0.2*texture(iChannel0,vec2(buv.x,0.)).x;\n    if (ds < 100.) {\n        vec3 ptx = march(vec3(og.x+0.001,og.y,og.z), dr);\n    \tvec3 pty = march(vec3(og.x,og.y+0.001,og.z), dr);\n        if (length(ptx-og)<100. && length(pty-og)<100.) {\n    \t\tvec3 nrm = normalize(cross(ptx-pt, pty-pt));\n        \tfloat scl = phong(lt, pt, nrm, og);\n\t\tfragColor = vec4(scl,0.,scl,0.);   \n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 18631,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/c64com/warhawk?in=c64com/sets/robhubbard"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}