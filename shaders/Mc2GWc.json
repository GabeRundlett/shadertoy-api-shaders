{
    "Shader": {
        "info": {
            "date": "1704741532",
            "description": "Lorenz Attractor with Chromatic Aberration. #genuary #genuary8",
            "flags": 32,
            "hasliked": 0,
            "id": "Mc2GWc",
            "likes": 17,
            "name": "Lorenz Attractor - Chromatic",
            "published": 3,
            "tags": [
                "rgb",
                "glitch",
                "chromatic",
                "chaos",
                "genuary"
            ],
            "usePreview": 0,
            "username": "insurgentes300",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "#define COLOR_BACK vec3(0.10, 0.10, 0.10)\n#define COLOR_TRACE vec3(0.10, 1.10, 0.50)\n\n// Function to apply lens distortion\nvec2 applyLensDistortion(vec2 uv, float distortionAmount) {\n    vec2 centeredUV = uv - 0.5;\n    float dist = dot(centeredUV, centeredUV);\n    vec2 distortedUV = uv + centeredUV * dist * distortionAmount;\n    return distortedUV;\n}\n\n// Function to add film reel noise\nfloat filmReelNoise(vec2 uv, float time) {\n    float noise = sin(dot(uv + time, vec2(12.9898, 78.233))) * 43758.5453;\n    return fract(noise);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Offset for chromatic aberration with a slight glitch\n    float aberrationOffset = 0.005;\n    float glitchAmount = 0.02;\n\n    float glitchX = mix(1.0, 1.0 + glitchAmount, fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453));\n    float glitchY = mix(1.0, 1.0 + glitchAmount, fract(sin(dot(uv, vec2(39.7424, 76.3456))) * 43758.5453));\n\n    // Define the frequency and amplitude for palpitation\n    float palpitationFrequency = 10.5; // Adjust this value for the frequency of palpitation\n    float palpitationAmplitude = 0.4; // Adjust this value for the amplitude of palpitation\n\n    // Calculate the scale based on a sine function to make it palpitate\n    float time = iTime * palpitationFrequency;\n    float palpitateScale = 1.0 + palpitationAmplitude * sin(time);\n\n    // Draw iChannel0 multiple times bigger but behind\n    float scale = 2.0 * palpitateScale; // Adjust this value to control the overall scale of iChannel0\n    float r_background = texture(iChannel0, uv + vec2(aberrationOffset * glitchX, 0.0) * scale).r;\n    float g_background = texture(iChannel0, uv).g;\n    float b_background = texture(iChannel0, uv - vec2(aberrationOffset * glitchY, 0.0) * scale).b;\n\n    // Blend the background color with the original color from iChannel0\n    float alpha = 0.5; // Adjust this value for the desired alpha\n    vec3 finalColor = mix(vec3(r_background, g_background, b_background), COLOR_BACK, alpha);\n\n    // Apply lens distortion\n    float distortionAmount = 0.01; // Adjust this value for the desired lens distortion\n    uv = applyLensDistortion(uv, distortionAmount);\n\n    // Add moving old TV scan lines\n    float scanLineIntensity = 0.1; // Adjust this value for the intensity of scan lines\n    float scanLineSpacing = 20.0; // Adjust this value for the spacing of scan lines\n    time = iTime * 0.5; // Adjust the multiplier for scan line movement speed\n    float scanLine = mod(floor((uv.y + iTime * 0.2) * iResolution.y / scanLineSpacing), 2.0);\n    finalColor *= 1.0 - scanLineIntensity * scanLine;\n\n    // Add film reel noise\n    time = iTime * 1.0; // Adjust the multiplier for speed\n    float noise = filmReelNoise(uv, time) * 0.15; // Adjust the multiplier for intensity\n\n    // Add the film reel noise to the final color\n    finalColor += vec3(noise);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//https://en.wikipedia.org/wiki/Lorenz_system\n\n//Settings\n#define STEPS 26.0\n#define VIEW_SCALE 0.015\n\n#define SPEED 0.2\n#define INTENSITY 0.3\n#define FADE 0.99\n#define FOCUS 1.\n\n#define MODE xz\n\n//System Parameters\nfloat O = 10.0;\nfloat P = 28.0;\nfloat B = 8.0/3.0;\n\n//Initial Position\nvec3 start = vec3(0.1,0.001,0);\n\n//Calculate the next position \nvec3 Integrate(vec3 cur, float dt)\n{\n\tvec3 next = vec3(0);\n    \n    next.x = O * (cur.y - cur.x);\n    next.y = cur.x * (P - cur.z) - cur.y;\n    next.z = cur.x*cur.y - B*cur.z;\n    \n    return cur + next * dt;\n}\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{   \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    uv -= res/2.0;\n    uv.y += 0.375;\n    float d = 1e6;\n    \n    vec3 last = texture(iChannel0, vec2(0,0)).xyz;\n    vec3 next = vec3(0);\n    \n    for(float i = 0.0;i < STEPS;i++)\n    {\n    \tnext = Integrate(last, 0.016 * SPEED);\n        \n        d = min(d, dfLine(last.MODE * VIEW_SCALE, next.MODE * VIEW_SCALE, uv));\n         \n        last = next;\n    }\n    \n    float c = (INTENSITY / SPEED) * smoothstep(FOCUS / iResolution.y, 0.0, d);\n\t\n\tc += (INTENSITY/8.5) * exp(-1000.0 * d*d);\n    \n    //pixel (0,0) saves the current position.\n    if(floor(fragCoord) == vec2(0,0))\n    {\n        if(iFrame == 0) //Setup initial conditions.\n    \t{\n    \t\tfragColor = vec4(start, 0);\n    \t}\n        else //Save current position.\n        {\n    \t\tfragColor = vec4(next, 0);\n        }\n    }\n    else\n    {\n        vec3 lc = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        fragColor = vec4(vec3(c) + lc * FADE, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}