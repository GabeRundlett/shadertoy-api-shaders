{
    "Shader": {
        "info": {
            "date": "1704277187",
            "description": "RayMarching-Basis",
            "flags": 0,
            "hasliked": 0,
            "id": "lfS3Ww",
            "likes": 0,
            "name": "RayMarching-Basis",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "kenshin",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MIN_DIST .01\n#define MAX_DIST 100.\n\n//plane SDF\nfloat sdfPlane(vec3 p, float h)\n{\n    return p.y - h;\n}\n\n//sphere SDF\nfloat sdfSphere(vec3 p, vec4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\nfloat sdfScene(vec3 p)\n{\n    float plane = sdfPlane(p, .0);\n    float sphere = sdfSphere(p, vec4(.0, 1., 3., 1.));\n    return min(plane, sphere);\n}\n\n//RayMarching\nfloat rayMarching(vec3 rayOrigin, vec3 rayDirection)\n{\n    float t = .0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayOrigin + rayDirection * t;\n        float dist = sdfScene(p);\n        t += dist;\n        if(dist < MIN_DIST || t > MAX_DIST) break;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    float t = sdfScene(p);\n    vec2 uv = vec2(.01, .0);\n    return normalize( t - vec3(\n        sdfScene(p - uv.xyy),\n        sdfScene(p - uv.yxy),\n        sdfScene(p - uv.yyx)\n    ));\n}\n\n//Shading\nvec3 shading(vec3 p)\n{\n    vec3 lightPos = vec3(sin(iTime), 2, cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    return vec3(clamp(dot(l, n), .0, 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //make uv -> [-1, 1] and center locate [0, 0]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rayOrigin = vec3(.0, 1., .0);\n    vec3 rayDirection = vec3(uv, 1.0);\n    \n    //rayMarchin\n    float t = rayMarching(rayOrigin, rayDirection);\n    vec3 p = rayOrigin + rayDirection * t;\n    \n    //shading\n    vec3 col = shading(p);\n    col = pow(col, vec3(2.2));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}