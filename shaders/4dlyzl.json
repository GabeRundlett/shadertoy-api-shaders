{
    "Shader": {
        "info": {
            "date": "1493519822",
            "description": "Reflections, refractions, lights such",
            "flags": 0,
            "hasliked": 0,
            "id": "4dlyzl",
            "likes": 2,
            "name": "SDF platform",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "light",
                "sphere"
            ],
            "usePreview": 0,
            "username": "Xafer",
            "viewed": 381
        },
        "renderpass": [
            {
                "code": "#define NEAR 0.01\n#define FAR 12.0\n\n#define STEP_SIZE 0.1\n#define MAX_ITER 300\n#define MAX_CYCLES 2\n#define DELTA 0.01\n#define A_SPEED 0.3\n#define CAM_DIST 3.3\n\n#define RECAST_MAX 5\n\n#define GLOW_POWER 6.0\n#define GLOW_COLOR vec3(0.2,0.4,0.4)\n#define GRASS_SIZE vec2(0.005,0.4)\n\n#define SKY_COLOR vec3(0.1,0.3,0.4)\n\n\n//Structures\n\nstruct Light\n{\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float intensity;\n};\n    \nstruct lComp\n{\n\tvec3 specular;\n    float specularIntensity;\n    vec3 diffuse;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n    float dist;\n    float near;\n};\n    \nstruct Material\n{\n    vec3 color;\n    float specular;\n    float diffuse;//\n    float ambient;//Ambient light factor\n    float refl;//How reflective is a surface\n    float refr;//Refraction index\n    float opacity;//For refractions\n};\n\n    \n//Signed Distance Functions    \n\nfloat sdSphere(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return -p.y;\n}\n\nfloat sdBox( vec3 p)\n{\n  vec3 d = abs(p) - vec3(1.0);\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opAdd(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat opSub(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opInter(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n\n//Combinations\n    \nfloat walls(vec3 p)\n{\n    p.y -= 1.0;\n    p.y * 2.0;\n    \n    vec3 p2 = p;\n    vec3 p3 = p;\n    \n    float width = 0.1;\n    vec2 dist = vec2(5.0);\n    \n    p2.xz = mod(p2.xz,dist)-(dist/2.0);\n    p2.x /= width;\n    p2.z /= 2.0;\n    \n    p3.xz = mod(p3.xz,dist)-(dist/2.0);\n    p3.z /= width;\n    p3.x /= 2.0;\n    \n    float env = opAdd(sdPlane(p),opAdd(sdBox(p2),sdBox(p3)));\n    \n    env = opSub(max(-p.y - 0.3, p.y + 0.2),max(env,sdSphere(p/(CAM_DIST-0.4))));\n    \n    env = opAdd(env,sdSphere(p/0.7 + vec3(0,0.5,0)));\n    \n    return opSub(sdSphere(p),env);\n}\n\nfloat map(vec3 pos, float factor)\n{\n    return walls(pos);\n}\n\nfloat map(vec3 pos)\n{\n \treturn map(pos,0.0);\n}\n\n//Environment propreties\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 delta = vec2 (DELTA, 0.0);\n\tvec3 normal = normalize (vec3 (\n\t\tmap (p + delta.xyy) - map (p - delta.xyy),\n\t\tmap (p + delta.yxy) - map (p - delta.yxy),\n\t\tmap (p + delta.yyx) - map (p - delta.yyx)));\n\t\n\treturn normalize(normal);\n}\n\n\n\nMaterial getMaterial(vec3 pos)\n{\n    Material mat;\n    mat.color = vec3(sin(pos.y),cos(pos.x),sin(pos.z))/2.0 + 0.5;\n    mat.refl = 0.0;\n    mat.refr = 0.8;\n    mat.opacity = 0.7;\n    \n    mat.color = mix(mat.color,getNormal(pos),0.2);\n    \n    return mat;\n}\n\n//RayMarching\n\nRay march(Ray ray, int iterations)\n{\n    float n = 1.0 / min(iResolution.x, iResolution.y);\n    \n    for(int i = 0; i < iterations; i++)\n    {\n    \tray.near = map(ray.pos,sqrt(ray.dist)*n);\n        \n        if(ray.near < DELTA || ray.dist > FAR)\n            break;\n        \n        float n = ray.near * STEP_SIZE;\n        ray.pos += ray.dir * n;\n        ray.dist += n;\n    }\n    \n    return ray;\n}\n\nlComp getLighting(Ray ray)\n{\n    lComp lightComposition;\n    \n    //Looping through lights\n    Light light;\n    light.radius = 3.5;\n    light.intensity = 1.0;\n    light.pos = vec3(0,-1,0);\n    light.color = vec3(1.0,0.8,0.6);\n    \n    float specular;\n    float diffuse;\n    \n    vec3 rayPos = ray.pos;\n    vec3 dir = light.pos - ray.pos;\n    float lDist = length(dir);\n    \n    dir = normalize(dir);\n    \n    rayPos += DELTA*dir;\n    \n    float near = 0.0;\n    float dist = 0.0;\n    \n    float l;\n    \n    for(int i =0 ; i < MAX_ITER;i++)\n    {\n        near = map(rayPos);\n        l = length(rayPos-light.pos);\n        if(near < DELTA || dist > lDist)\n            break;\n        \n        float n = abs(near * 0.1);\n        \n        rayPos += n*dir;\n        dist += n;\n    }\n    \n    if(near < DELTA)\n        diffuse = 0.0;\n    else if(dist > lDist)\n    {\n        diffuse = max(0.0,1.0 - (lDist/light.radius));\n        specular = dot(reflect(ray.dir,getNormal(ray.pos)),dir)/2.0 + 0.5;\n        specular = -cos(specular*3.1416)/2.0 + 0.5;\n        specular = pow(specular,lDist*lDist);\n        //if(specular > 0.9);\n        //\tspecular /= 20.0;\n    }\n    \n    vec3 normal = getNormal(ray.pos);\n        \n    lightComposition.diffuse = mix(SKY_COLOR, light.color, diffuse);\n    lightComposition.specular = light.color;\n    lightComposition.specularIntensity = specular;\n    \n    return lightComposition;\n}\n\n//Marching through refractions\n\nvec3 getRefraction(Ray ray)\n{\n    vec3 color;\n    float colorFactor;\n    \n    float intensity = 1.0;\n   \tMaterial mat = getMaterial(ray.pos);;\n    \n    for(int i = 0; i < MAX_CYCLES; i++)\n    {\n        vec3 normal = getNormal(ray.pos);\n        ray.dir = refract(ray.dir, normal, mat.refr);\n        \n        vec3 m = ray.dir*DELTA*2.0;\n        \n        int inside = 0;\n        \n        for(int j = 0; j < MAX_ITER && (ray.near < DELTA || inside == 1); j++)\n        {\n            ray.pos += m;\n            ray.dist += DELTA*2.0;\n            ray.near = map(ray.pos);\n        }\n        \n        ray.dir = refract(ray.dir,normal,mat.refr);\n        ray = march(ray,MAX_ITER);\n        \n        if(ray.near > DELTA || ray.dist > FAR)\n        {\n            color += SKY_COLOR*intensity;\n            colorFactor += intensity;\n            break;\n        }\n        \n        lComp lightComposition = getLighting(ray);\n        \n        mat = getMaterial(ray.pos);\n        \n        vec3 col = mix(mat.color * lightComposition.diffuse,lightComposition.specular, lightComposition.specularIntensity);\n        \n        color += mix(col,SKY_COLOR,ray.dist/FAR)*intensity;\n        colorFactor += intensity;\n        \n        intensity *= 1.0 - mat.opacity;\n    }\n    \n    return color/colorFactor;\n}\n\n//Marching through reflections\n\nvec3 getReflection(Ray ray)\n{\n    vec3 color;\n    float colorFactor;\n    \n    float intensity = 1.0;\n    \n    for(int i = 0; i < MAX_CYCLES; i++)\n    {\n        vec3 normal = getNormal(ray.pos);\n        ray.dir = reflect(ray.dir,normal);\n        ray.pos += ray.dir * DELTA;\n        \n        ray = march(ray, MAX_ITER);\n        \n        Material mat = getMaterial(ray.pos);\n        \n        intensity *= mat.refl;\n        \n        lComp lightComposition = getLighting(ray);\n        \n        vec3 col = mix(mat.color * lightComposition.diffuse, lightComposition.specular, lightComposition.specularIntensity);\n        \n        color += mix(col,SKY_COLOR,ray.dist/FAR)*intensity;\n        colorFactor += intensity;\n    }\n    \n    return color/colorFactor;\n}\n\n//Getting the color at the specified point\n\nvec3 getColor(Ray ray)\n{\n    \n    vec3 color;\n    vec3 normal = getNormal(ray.pos);\n    \n    if(ray.dist > FAR)\n    {\n\t\tcolor = SKY_COLOR;\n    }\n    else if(ray.near <= DELTA)\n    {\n        Material mat = getMaterial(ray.pos);\n        \n        color = mat.color;\n        \n        lComp lightComposition = getLighting(ray);\n       \tcolor *= lightComposition.diffuse;\n        \n        if(mat.refr > 0.0)\n            color = mix(getRefraction(ray),color,mat.opacity);\n        \n    \tif(mat.refl > 0.0)\n            color = mix(color,getReflection(ray),mat.refl);\n        \n        color = mix(color, lightComposition.specular, lightComposition.specularIntensity);\n    \n    \tcolor = mix(color, SKY_COLOR , ray.dist/FAR);\n        color = mix(color, SKY_COLOR , dot(ray.dir,normal)/2.0 + 0.5);\n    }\n    \n\treturn color;\n}\n\nvec3 castRay(vec3 origin, vec3 direction)\n{\n    //Generating ray\n    Ray ray;\n    ray.pos = origin;\n    ray.dir = direction;\n    ray.dist = 0.0;\n    \n    //Move the ray to a surface up to far distance\n    ray = march(ray, MAX_ITER*2);\n    \n    return getColor(ray);\n}\n\n//Initialisation\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Setting up screen-correct uv\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - vec2( 1 );\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //Setting up rotation\n    float sa = sin( iTime * A_SPEED );\n    float ca = cos( iTime * A_SPEED );\n    \n    float cDist = CAM_DIST + sin(iTime * A_SPEED);\n    \n    //Creating ray\n    vec3 or = vec3(sa*cDist,0.5,-ca*cDist);\n    vec3 di = -normalize(vec3(uv.x,uv.y,-1.0));\n    \n    //Rotating orientation\n    mat3 r;\n    r[0] = vec3(ca,0,sa);\n    r[1] = vec3(0,1,0);\n    r[2] = vec3(-sa,0,ca);\n    di = r*di;\n    \n    vec3 color = castRay(or,di);\n    \n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}