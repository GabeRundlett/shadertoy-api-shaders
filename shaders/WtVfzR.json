{
    "Shader": {
        "info": {
            "date": "1613765868",
            "description": "Coded live on twitch\nhttps://twitch.tv/antic0re_",
            "flags": 0,
            "hasliked": 0,
            "id": "WtVfzR",
            "likes": 9,
            "name": "19/02/2021 - live",
            "published": 3,
            "tags": [
                "raymarch",
                "clouds",
                "volumetric"
            ],
            "usePreview": 1,
            "username": "anticore",
            "viewed": 466
        },
        "renderpass": [
            {
                "code": "float ni(float x) {\n    //return texture(texFFTIntegrated, x).x;\n    return texelFetch( iChannel0, ivec2(x * 512.,0), 0 ).x * .0;\n}\n\nfloat hash13(vec3 p) {\n    p  = fract(p * .1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec3 hash33(vec3 p3) {\n    vec3 p = fract(p3 * vec3(.1031,.11369,.13787));\n    p += dot(p, p.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p.x + p.y)*p.z, (p.x+p.z)*p.y, (p.y+p.z)*p.x));\n}\n\n\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n  \n    return mat2(c, s, -s, c);\n}\n\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t \n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(hash33(s), x);\n\td.y = dot(hash33(s + i1), x1);\n\td.z = dot(hash33(s + i2), x2);\n\td.w = dot(hash33(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\nfloat snoiseFractal(vec3 m) {\n\treturn   0.5333333* snoise(m)\n\t\t\t\t+0.2666667* snoise(2.0*m)\n\t\t\t\t+0.1333333* snoise(4.0*m)\n\t\t\t\t+0.0666667* snoise(8.0*m);\n}\n\nfloat fbm (in vec3 st, int o) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < o; i++) {\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat worley(vec3 p, float scale){\n\n    vec3 id = floor(p*scale);\n    vec3 fd = fract(p*scale);\n\n    float n = 0.;\n\n    float minimalDist = 1.;\n\n\n    for(float x = -1.; x <=1.; ++x){\n        for(float y = -1.; y <=1.; ++y){\n            for(float z = -1.; z <=1.; ++z){\n\n                vec3 coord = vec3(x,y,z);\n                vec3 rId = hash33(mod(id+coord,scale))*0.5+0.5;\n\n                vec3 r = coord + rId - fd; \n\n                float d = dot(r,r);\n\n                if(d < minimalDist){\n                    minimalDist = d;\n                }\n\n            }//z\n        }//y\n    }//x\n    \n    return 1.0-minimalDist;\n}\n\n\nfloat wfbm (in vec3 st, int o, float s) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < o; i++) {\n        value += amplitude * worley(st, s);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat sdSphere(vec3 p, vec3 pos, float r) {\n    return length(p + pos) - r;\n}\n\nfloat sdBox(vec3 p, vec3 pos, vec3 b) {\n    p += pos;\n    //p.xz *= rot(0.6);\n    //p.xy *= rot(0.5);\n  \n    p.xz *= rot(iTime + ni(0.4));\n    p.xy *= rot(iTime + ni(0.2));\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map(vec3 p) {\n    return vec2(sdBox(p, vec3(0.,0.,5. + sin(ni(0.1) * 100.)), vec3(1., 1., 1.)), 0.);\n}\n\nconst vec3 sundir = normalize( vec3(0.0,-1.0,-0.0) );\n\nvec3 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n  \n    vec4 sum = vec4(0);\n  \n    for (int i = 0; i < 100; i++) {\n        h = map(ro + rd * td);\n        td += max(h.x, 0.01);\n        \n            vec3 ip = ro + rd * td;\n        if (h.y == 0. && h.x < 0.01) {\n            ip.yz *= rot(iTime / 10.);\n            ip.xz *= rot(iTime / 10.);\n            float w = smoothstep(0.6, 1., worley(ip, 2.));\n            float s = snoiseFractal(ip*3.);\n            float f = fbm(ip, 8);\n          \n            //return vec3(1);\n            // F = 1/ e ^(t * d).\n            //c += f * 0.01 * exp(-h.x * 2);\n            //return vec3(w);\n            float den = f;\n            \n            if (den > 0.01) {\n               float df = fbm(ip + 0.1 * sundir, 8);\n               // do lighting\n               float dif = clamp((den - df)/0.3, 0.0, 1.0 );\n               vec3  lin = vec3(0.65,0.65,0.75)*1.1 + 0.8*vec3(sin(ip.x + iTime),0.6,cos(ip.y + iTime))*dif;\n               //return vec3(lin);\n               vec4  col = vec4( mix( vec3(cos(ip.y + iTime / 2.) + 0.5,0.95,sin(iTime / 3. + ip.z) + 0.5), vec3(0.25,0.3,0.35), den ), den );\n                \n               col.xyz *= lin;\n               // fog\n               //col.xyz = mix(col.xyz,vec3(0,0,0), 1.0-exp2(-0.075*t));\n              \n              \n                //return col.xyz;\n               // composite front to back\n               //col.w    = min(col.w*8.0*h.x,1.0);\n               //col.rgb *= col.a;\n              \n               sum += col*0.01*(1.0-sum.a);\n            }\n            \n        }\n    }\n    \n    return sum.xyz;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 ro = vec3(0,0,2);\n  vec3 rd = normalize(vec3(uv, 0) - ro);\n  \n  float w = smoothstep(0.6, 1., worley(vec3(uv * 3., iTime / 20.), 2.));\n  float s = snoise(vec3(uv, iTime));\n  float sf = snoiseFractal(vec3(uv, iTime));\n  float f = fbm(vec3(uv.x, uv.y, iTime), 8);\n  float wf = smoothstep(0.2, 1., wfbm(vec3(uv.x, uv.y, iTime / 10.), 3, 4.));\n  float wff = wf * f;\n  \n  //out_color = vec4(vec3(wff),1);\n  \n  \n  fragColor = vec4(tr(ro, rd, uv), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}