{
    "Shader": {
        "info": {
            "date": "1640887477",
            "description": "Trying to make a cool organic lava lamp with raymarching and randomness.\nIf it's too slow, turn down AA to 1. If you have a really good GPU, you can set it to 3 or 4.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lVSDh",
            "likes": 11,
            "name": "Raymarched lava lamp",
            "published": 3,
            "tags": [
                "raymarching",
                "lava",
                "lamp"
            ],
            "usePreview": 0,
            "username": "nyri0",
            "viewed": 686
        },
        "renderpass": [
            {
                "code": "const float EPS = 0.001;\nconst float L = 10.0;\nconst int FSAA = 2;\n\n// Some colors\nconst vec3 Y1 = vec3(1, 0.9, 0.15);\nconst vec3 Y2 = vec3(1., 0.6, 0.1);\nconst vec3 Y3 = vec3(.9, .6, .1);\nconst vec3 R0 = vec3(.9, .3, .1);\nconst vec3 R1 = vec3(.2, .08, 0.);\nconst vec3 O1 = vec3(.7, .3, 0.);\nconst vec3 O2 = vec3(.2, .07, 0.);\nconst vec3 O3 = vec3(.13, .04, 0.);\n\nfloat sq(float x) {\n    return x * x;\n}\n\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D\n    int n = z.x+z.y*11111;\n    // Hugo Elias hash\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n}\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat gradient_noise(in vec2 uv) {\n    float f = 0.;\n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    return 0.5 + 0.5*f;\n}\n\nfloat simple_gradient_noise(in vec2 uv) {\n    float f = 0.;\n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\t//f += 0.1250*noise( uv ); uv = m*uv;\n\t//f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n// From https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat random(int i, float lo, float hi) {\n    return (hi - lo) * 0.5 * (sin(float(997*i)) + 1.) + lo;\n}\n\nfloat add_ball(int id, vec3 pos, float radius, float period) {\n    int i_period = int(iTime / period);\n    float t = mod(iTime, period) / period;\n    \n    float o = random(id + 13 * i_period, 0., .2);\n    float y = mix(-1., 1., smoothstep(o+0., o+.2, t));\n    y = mix(y, -1., smoothstep(o+.5, o+.8, t));\n    \n    float xlo0 = random(id + 17 * i_period, -0.4, 0.4);\n    float xlo1 = random(id + 17 * (i_period + 1), -0.4, 0.4);\n    float xhi = random(id + 29 * i_period, -0.25, 0.25);\n    float x = mix(xlo0, xhi, smoothstep(o+0., o+.2, t));\n    x = mix(x, xlo1, smoothstep(o+.5, o+.8, t));\n    \n    float zlo0 = random(id + 23 * i_period, -0.2, 0.2);\n    float zlo1 = random(id + 23 * (i_period + 1), -0.2, 0.2);\n    float zhi = random(id + 31 * i_period, -0.2, 0.2);\n    float z = mix(zlo0, zhi, smoothstep(o+0., o+.2, t));\n    z = mix(z, zlo1, smoothstep(o+.5, o+.8, t));\n    \n    vec3 center = vec3(x, y, 2.+z);\n    \n    return length(pos - center) - radius;\n}\n\n// Signed distance function that defines the scene.\nfloat sdf(in vec3 pos) {\n    float sph0_sdf = add_ball(0, pos, 0.2, 40.);\n    float sph1_sdf = add_ball(1, pos, 0.3, 50.);\n    float sph2_sdf = add_ball(2, pos, 0.35, 60.);\n\n    return smin(smin(sph0_sdf, sph1_sdf, .15), sph2_sdf, .15);\n}\n\n// Ray marching engine.\nvoid rayMarcher(in vec2 uv, out bool hit, out float min_dist, out vec3 nml) {\n    uv = uv + vec2(0, .3*simple_gradient_noise(.2*uv));\n\n    float t = 0.0;\n    float dist;\n    vec3 pos;\n    min_dist = L;\n    do {\n        // Orthographic camera\n        pos = vec3(uv, t);\n        dist = sdf(pos);\n        t += dist;\n        min_dist = min(dist, min_dist);\n    } while(t < L && dist > EPS);\n    \n    nml = normalize(vec3(\n        dist - sdf(pos - vec3(EPS, 0, 0)),\n        dist - sdf(pos - vec3(0, EPS, 0)),\n        dist - sdf(pos - vec3(0, 0, EPS))\n    ));\n    \n    hit = dist <= EPS;\n    if(hit) min_dist = 0.;\n}\n\nfloat lamp_sdf(vec2 uv) {\n    float dl = sqrt(0.04*sq(uv.y+0.7)+0.005)-0.75 - uv.x;\n    float dr = sqrt(0.04*sq(uv.y+0.7)+0.005)-0.75 + uv.x;\n    return max(dl, dr);\n}\n\nfloat inner_sdf(vec2 uv) {\n    float dl = 0.08*sq(uv.x) - 0.96 - uv.y;\n    float dh = uv.y + 0.17*sq(uv.x) - 0.97;\n    return max(dl, dh);\n}\n\nvec4 sampleColor(in vec2 sampleCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * sampleCoord / iResolution.xy - 1.0;\n    // Normalized but keeping aspect ratio\n    vec2 uva = vec2(uv.x * aspectRatio, uv.y);\n    \n    // TODO: change shape + gradient behind\n    float d_lamp = lamp_sdf(uva);\n    float d_inner = inner_sdf(uva);\n    \n    vec3 nml;\n    bool hit;\n    float min_dist;\n    rayMarcher(uva, hit, min_dist, nml);\n    \n    float bg_halo_micro = smoothstep(0., .05, min_dist);\n    float bg_halo_macro = smoothstep(0., .6, min_dist);\n    float halo_sides = smoothstep(0., 1., min_dist);\n    float bg_noise = gradient_noise(.2 * uv);\n    float bg_mix = clamp(0.4 * bg_halo_macro + 0.6 * bg_noise, 0., 1.);\n    vec3 bg = mix(O1, O2, bg_mix);\n    bg = mix(R0, bg, bg_halo_micro);\n    bg = mix(mix(Y3, bg, .6 + .4 * smoothstep(0., -0.06+0.01*sin(20.*uva.x+10.*uva.y), d_lamp)),\n             bg, 0.8 * halo_sides);\n    \n    vec3 lightDir = vec3(0, -1, 0);\n    vec3 fg = mix(Y1, Y2, smoothstep(0.1, -0.9, dot(lightDir, nml)));\n    \n    vec3 col = mix(fg, bg, step(EPS, min_dist));\n\n    vec3 back_gradient = mix(R1, vec3(0), smoothstep(.6, 2.5, length(uva)));\n    col = mix(col, vec3(0), smoothstep(0., .005, d_inner));\n    col = mix(col, back_gradient, smoothstep(0., .01, d_lamp));\n\n    // Output to screen\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 colSum = vec4(0);\n    for(int i = 0; i < FSAA; i++) {\n        for(int j = 0; j < FSAA; j++) {\n            colSum += sampleColor(fragCoord + vec2(float(i) / float(FSAA), float(j) / float(FSAA)));\n        }\n    }\n    fragColor = colSum / colSum.w;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}