{
    "Shader": {
        "info": {
            "date": "1649059108",
            "description": "Really liked how this one turned out!",
            "flags": 0,
            "hasliked": 0,
            "id": "ftjyzR",
            "likes": 13,
            "name": "Day 6 - Lambmeow (Mixtape)",
            "published": 3,
            "tags": [
                "noise",
                "reflection",
                "sdf",
                "cd",
                "mixtape"
            ],
            "usePreview": 0,
            "username": "lambmeow",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "//Daily Shader Challenge Day 6\n//Ive learned a lot from this one, there are still some issues with the lighting messing with \n//the rotation of the cd but its in a good enough state for now.\n//huge thanks to Alan Zucconi for the CD shader effect (https://www.alanzucconi.com/2017/07/15/the-nature-of-light/)\n//lopea (https://github.com/lopea)\n\n#define CD 0.\n#define BACK -1.\n#define COVER 1.\n\n//#define ALT_COVER\n\n\n#define time iTime\n\n//////////////////////////////////////////////////////////////////////////////\n//a lazy copy-paste from a previous shader i made lmaoooo\n//https://www.shadertoy.com/view/flXGW7\n//////////////////////////////////////////////////////////////////////////////\n\n//IQ's Gradient noise algorithm\n/////////////////////////////////////////////////////////////////////////////\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,331.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec2 a  = random(i);\n    vec2 b = random(i + vec2(1,0));\n    vec2 c = random(i + vec2(0, 1));\n    vec2 d = random(i + vec2(1, 1));\n    \n    vec2 u = f * f * f *(f *(f*6. - 15.)+10.);\n    \n    return mix(mix ( dot( a, f), dot(b, f - vec2(1, 0)), u.x),\n        mix ( dot( c, f-vec2(0,1)), dot(d, f - vec2(1, 1)), u.x), u.y);\n\n}\n/////////////////////////////////////////////////////////////////////////////\n\n//fractal brownian motion\nfloat fbm(vec2 uv)\n{\n    //store the result of the noise texture\n    float result = 0.;\n    \n    //store the current amplitude value\n    float amplitude = 1.;\n    \n    //iterate a few times to give noise a more detailed look\n    for(int i = 0; i < 8; i++)\n    {\n        //add to the result ( with a few modifications\n        result += noise(uv + vec2( time - float(i)  +10., -time/25.- float(i)/2.)) * amplitude;\n        \n        //shrink the noise texture for the next iteration\n        uv *= 2.;\n        \n        //make next noise iteration less potent \n        amplitude *= 0.5;\n    }\n    \n   \n    return result;\n}\n\nvec4 dith(vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n\n    //set the threshold for color value, will be compared to screen space.\n    float threshold = fbm(vec2(fbm(uv * 10.), fbm(uv * 10. + 3.)));\n    \n    //create the dithering effect by warping the screen coordinates\n    float coord = sin(uv.x * 1000.) * sin(uv.y * 1000.) * .25;\n    \n    //compare warped screen coords to the threshold and create the color value\n    vec3 color = mix(vec3(0, .04, .1), vec3(1,0,.5) , vec3(step(coord, threshold)));\n    \n    //create an outline effect by subracting same algorithm but with a smaller threshold\n    color -= step(clamp(coord, 0., 1.), threshold - .1) * vec3(1);\n    \n    //set the color to the pixel\n    return vec4(color , 1);\n    \n}\n\n//////////////////////////////////////////////////////////////////////////////\n//lazy copy paste ends here\n//////////////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////////////\n//CD - reflectance equations\n//////////////////////////////////////////////////////////////////////////////\n\n\n//color bump equation\nfloat bump(float x, float a, float o)\n{\n    return -a * (x-o) * (x-o) + 1.;\n}\n\nvec3 spectral(float x)\n{\n    return vec3(\n    bump(x,16., .75),\n    bump(x,8., .5),\n    bump(x,16., .25)\n    );\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//Shape helper functions (thanks iq)\n//////////////////////////////////////////////////////////////////////////////\nfloat cyl(vec3 p,float r , float h)\n{\n    vec2 v = abs(vec2(length(p.xy), p.z)) - vec2(r,h);\n    return length(max(v, 0.)) + min(max(v.x,v.y),0.);\n}\n\nfloat cd(vec3 p)\n{\n    return max(-cyl(p, .1, 0.1), cyl(p, 1., 0.001)) - .01; \n}\nfloat sbx(vec2 p , vec2 o, float r)\n{\n    vec2 v = abs(p) - o;\n    \n    return length(max(v,0.)) + min(max(v.x,v.y),0.) - r;\n}\n\nfloat six(vec2 p)\n{\n    p.x -= .019;\n    float ii = min(sbx(p+vec2(-.11,-0.00), vec2(.016, .02), .002),sbx(p+vec2(-.06,0), vec2(.005, .02), .002));\n    float oo = min(sbx(p+vec2(-.11,-0.03), vec2(.004, .03), .003), min(sbx(p+vec2(-.125,0.045), vec2(.007, .03), .003),\n    sbx(p+vec2(-.095,0.045), vec2(.007, .03), .003)));\n    return abs(max(-oo,ii) * 2.) - 0.001;\n}\n\nfloat cov(vec3 p)\n{\n    p.z -= 0.02;\n    return max(cyl(p, .95, .001), -cyl(p, .2, 0.01)); \n}\n\n//////////////////////////////////////////////////////////////////////////////\n//Rendering functions\n//////////////////////////////////////////////////////////////////////////////\n\nmat2 rot(float a)\n{\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, -sa,sa,ca);\n}\nvec2 ss(vec3 p)\n{\n    p.xz *=  rot(time);\n    p.yz *= rot(radians(35.));\n    \n    //create background \n    vec2 res = vec2(abs(length(p)-50.) -.5, BACK);\n    \n    //add cd\n    float cc = cd(p);\n    res.x = min(cc, res.x);\n    \n    if(cc == res.x) res.y = CD;\n    \n    //add cover\n    float cv = cov(p);\n    \n    res.x = min(res.x, cv);\n    if(res.x == cv)\n        res.y = COVER;\n        \n    return res;\n}\n\n//raytrace\nvec2 rt(vec3 ro, vec3 rd, out vec3 p)\n{\n    vec2 dl = vec2(0);\n    float ll = 0.;\n    for(int i = 0 ; i< 255; i ++)\n    {\n        p = ro + rd * ll;\n        dl = ss(p);\n        ll += dl.x;\n        \n        if(dl.x < 0.001 || ll > 100.)\n            break;\n    }\n    \n    return dl;\n}\n\n//normal\nvec3 nn(vec3 p)\n{\n    vec3 n = vec3(0);\n    for(int i = min(iFrame, 0); i < 4; i ++)\n    {\n        vec3 e = 0.5773* (2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*ss(p +e*0.0001).x;\n    }\n    return normalize(n);\n}\n\nmat3 cam(vec3 p, vec3 la)\n{\n    vec3 ww = normalize(la - p);\n    vec3 uu = normalize(cross(ww, vec3(0,1.,0)));\n    vec3 vv = cross(uu,ww);\n    return mat3(uu,vv,ww);\n    \n}\n\nvec4 gc(vec2 u)\n{\n    //create ray info\n    vec3 ro = vec3(.3, 0, -2.5), rd = normalize(vec3(u, 2.));\n    vec3 rod = ro;\n    \n    rd *= cam(ro, vec3(0,0,0));\n    \n    //ro.yz *= rot(radians(35.));\n    vec3 p;\n    vec3 n = nn(p);\n    //get ray march data\n    vec2 rm = rt(ro,rd, p);\n    vec3 lp = vec3 (.31,1,-6), ld = normalize(lp-p);\n    float spec = pow(max(dot(reflect(ld, n), rd),0.),200.); \n    \n                \n               //get relative uv coords\n#ifdef ALT_COVER\n        vec2 uv = vec2(atan(p.y,p.x)/radians(360.), p.y/.95 + 0.5);\n        uv = uv.xx;\n#else\n        vec3 vp = p;\n            //rotate back\n        vp.yz *= rot(-radians(35.));\n        vp.xz *= -rot(time);\n        //apply uv based on dithering\n        vec2 uv = vec2(vp.xy) + .5;\n        uv /= length(vp - ro) * 2.;\n#endif\n    \n    //get color based on id\n    if(rm.y == CD)\n    {\n        //get tangent\n       vec3 tt = (cross(n,normalize(p.xyz)));\n       vec3 col = vec3(0);\n       \n       //get colors relative to tangent\n       float cthl = dot(ld, tt);\n       float cthv = dot(-rd, tt);\n       float u = abs(cthl - cthv);\n\n            if(u == 0.)\n                return vec4(col,0);\n       //start mimicing wave length effect\n       for(int i = 1; i <= 1; i ++)\n       {\n         float ww = u * length(p- ro) * 6./ float(i);\n         col += spectral(ww);\n       }\n       col/= 8.;\n       col = clamp(col, 0.,1.);\n       vec3 off = texture(iChannel1, uv).rgb;\n       return  vec4(0.93) * texture(iChannel0, reflect(rd + off * .044, n)) + vec4(col, 1) ;\n    }\n    else if (rm.y == COVER)\n    {\n        //create cover with noise effect.\n        return mix(dith(uv), vec4(.2,.5,.9,1) , step(six(uv), 0.001)) * max(dot(-ld, n), 0.) + spec;\n    }\n    //background\n    return vec4(mix(vec4(0.1), vec4(.02),abs(u.y)));\n}\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    vec2 r = iResolution.xy, u = (2. * f - r)/r.y;\n    \n    c = gc(u);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}