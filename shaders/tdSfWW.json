{
    "Shader": {
        "info": {
            "date": "1590039117",
            "description": "Time-dependent and time-average energy density radiated by oscillating currents.",
            "flags": 48,
            "hasliked": 0,
            "id": "tdSfWW",
            "likes": 33,
            "name": "Radiation Visualizations 1",
            "published": 3,
            "tags": [
                "dipole",
                "radiation",
                "radio",
                "antenna",
                "quadrupole"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 877
        },
        "renderpass": [
            {
                "code": "\n/*\n\nRadiating Sources Visualization\nCopyright 2020 Theron Tarigo\n\nVisualizes EM radiation from oscillating currents\n\n*/\n\nvec4 readctl (int ch, int n) {return vec4(0.);}\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord ) {\n\n  vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n  color = tonemap(color*.6);\n  fragData.rgb = srgbl_to_srgb(color);\n  fragData.rgb += dither(fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#ifndef HW_PERFORMANCE\n#define SHADERTOY_COMMON_CHECK\nuniform vec3 iResolution;\n#endif\n\n// Work around Shadertoy changes\n#define iMouse vec4(iMouse.xy,sign(iMouse.z)*abs(iMouse.zw))\n\n// Collection of utilities from old shaders\n\nconst float C_pi = 3.1415927;\n\n////// BEGIN Expression Plotter by ttg https://www.shadertoy.com/view/3t3XWf\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n    } \\\n  }\n////// END Expression Plotter\n\n////// BEGIN text encoding https://www.shadertoy.com/view/Wd2SDt\nconst struct CCDS_T {\n  uint\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CCDS = CCDS_T(\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n0x7fu);\n\n#define U4CHAR4(a,b,c,d) ((CCDS.a)+(CCDS.b<<8)+(CCDS.c<<16)+(CCDS.d<<24))\n\n#define STRING16(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af) )\n\n#define STRING32(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf) )\n\n#define STRING64(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df))\n\n#define STRING80(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df,\\\n  e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df),\\\n      U4CHAR4(e0,e1,e2,e3),U4CHAR4(e4,e5,e6,e7),U4CHAR4(e8,e9,ea,eb),U4CHAR4(ec,ed,ee,ef))\n\n#define DEF_DRAW_STRING(N) \\\nfloat draw_string (sampler2D sampler,                    \\\n                   in vec2 uv, const uint[1+N] string) { \\\n  vec2 gx = dFdx(uv/32.), gy = dFdy(uv/16.);             \\\n  int i = int(uv.x);                                     \\\n  int strlen = min(int(string[0]),N*4);                  \\\n  if (uv.x<0.||i>=strlen) return 0.;                     \\\n  int code = int( (string[i/4+1]>>((i%4)*8)) &0xFFu);    \\\n  if (uv.y<0.||uv.y>1.) return 0.;                       \\\n  uv.x=fract(uv.x)/2.+.25; uv.y=1.-uv.y;                 \\\n  uv+=vec2(code%16,code/16);                             \\\n  return textureGrad(sampler,uv/16.,gx*.5,gy*.5).r;    }\nDEF_DRAW_STRING(4)\nDEF_DRAW_STRING(8)\nDEF_DRAW_STRING(16)\nDEF_DRAW_STRING(20)\n#undef DEF_DRAW_STRING\n////// END text encoding\n\n////// BEGIN spectral color tonemap https://www.shadertoy.com/view/wtGXzm\n/*\n\nSpectral tonemap (closest sRGB approximation without banding)\n\nTrying to render spectral colors into screen space with as little desaturation\nas possible given the white-level, and no color banding.\n\n\nMouse: plot R,G,B and Luminance at a horizontal slice through the image.\nHorizontal lines: limits (0 and 1)\n\nTop: Just enough white added so that color-matching RGB values are nonnegative.\nBottom: No white added, negative values get handled by tonemap.\nIn-between: gradient of white.\n\n\n*/\n\n// srgbl - linear srgb\nvec3 wavelength_to_srgbl (float l_nm ) {\n    if (l_nm<370.||l_nm>780.) return vec3(0.);\n    vec4 l = vec4(1.065, 1.014, 1.839, 0.366);\n    vec4 c = vec4(593.,556.3,449.8, 446.);\n    vec4 s = vec4(.056,.075,.051, .043);\n    if (l_nm<446.) s.a = 0.05; // fix creep from violet back to blue\n    if (l_nm>593.) s.r = 0.062; // fix creep from red back to green\n    vec4 v = (log(l_nm)-log(c))/s;\n    vec4 xyzx = l*exp(-.5*v*v);\n    vec3 xyz = xyzx.xyz+vec3(1,0,0)*xyzx.a;\n    const mat3 xyz_to_rgb = \n      mat3(3.240,-.969,.056, -1.537,1.876,-.204, -0.499,0.042,1.057);\n    vec3 rgb = xyz_to_rgb*xyz;\n    return rgb;\n}\n\nfloat rgb_to_lum (vec3 v) {\n  vec3 w = vec3(.213,.715,.072);\n  return dot(w,v);\n}\n\nvec3 rgb_to_hue (vec3 v) {\n  vec2 hv = mat3x2( 1., 0., -.5, .866, -.5,-.866) * v;\n  float h = atan(hv.y,hv.x);\n  v = .5+.5*cos(h-vec3(0,1,2)/3.*2.*C_pi);\n  v -= -log(dot(vec3(1.),exp(-v*10.)))/10.;\n  v/=rgb_to_lum(v);\n  return v;\n}\n\nfloat rgb_to_sat (vec3 v) {\n  v/=rgb_to_lum(v);\n  vec3 h = rgb_to_hue(v);\n  if (any(isnan(h))) return 0.;\n  // doesn't matter which component of (1-v)/(1-h) is used!\n  return dot(vec3(1./3.), (1.-v)/(1.-h) );\n}\n\nvec3 tonemap (vec3 color) {\n  vec3  hue = rgb_to_hue(color);\n  float sat = rgb_to_sat(color);\n  float lum = rgb_to_lum(color);\n\n  // smooth-clamp\n  sat = -log(exp(-sat*10.)+exp(-10.))/10.;\n\n  /* tonemapping options:\n       - desaturate when very bright\n       - smooth-clamp brightness to a maximum that still\n          allows some color variation                              */\n  sat = sat*(exp(-lum*lum*2.));\n  lum = .8*(1.-exp(-lum));\n\n  color = lum*mix(vec3(1.),hue,sat);\n  return color;\n}\n\nvec3 srgbl_to_srgb(vec3 linearRGB) {\n  // https://www.shadertoy.com/view/4tXcWr\n  // By https://www.shadertoy.com/user/Tynach\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n////// END spectral color tonemap\n\n////// BEGIN best integer hash https://www.shadertoy.com/view/WttXWX\nuint triple32(uint x) {\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n////// END best integer hash\n\nint C_iFrame;\n\nvec3 dither (vec2 fc) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(c.x+(c.y<<10)+(uint(C_iFrame)<<20));\n  uvec3 h = (uvec3(z)>>uvec3(0,8,16))&0xFFu;\n  return vec3(ivec3(h)-128)/128./256.;\n}\n\nvec4 paramdither (vec2 fc, int seed) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(uint(seed)+c.x+(c.y<<10)+(uint(C_iFrame)<<20));\n  uvec4 h = (uvec4(z)>>uvec4(0,8,16,24))&0xFFu;\n  return vec4(ivec4(h)-128)/128.;\n}\n\nvec4 boxmuller (vec4 r) {\n  vec4 v;\n  v.xy = sqrt(abs(2.*log(r.x+1e-4)))*vec2(cos(2.*C_pi*r.y),sin(2.*C_pi*r.y));\n  v.zw = sqrt(abs(2.*log(r.z+1e-4)))*vec2(cos(2.*C_pi*r.w),sin(2.*C_pi*r.w));\n  return v;\n}\n\nconst struct KEYCODES_T {\n  int A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,\n  _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,\n  end;\n} KEYCODES = KEYCODES_T(\n 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,\n 48,49,50,51,52,53,54,55,56,57,\n -1\n);\nconst struct KEYSTATES_T { int DOWN,PRESS,TOGGLE; }\n  KEYSTATES = KEYSTATES_T( 0, 1, 2 );\n\n#define KEYBOARD(NAME,STATE) keyboard(KEYCODES.NAME,KEYSTATES.STATE)\n\nivec4 decodeInteger (vec4 e) {\n    return floatBitsToInt(e)&0x3FFFFFFF;\n}\n\nvec4 encodeInteger (ivec4 d) {\n    return intBitsToFloat((d&0x3FFFFFFF)|0x40000000);\n}\n\nconst ivec2 ctlbuf_size = ivec2(256);\n\nvoid ctlbuf_pack (ivec2 pix, out int ch, out int n) {\n  const int bh = 8;\n  const int bw = ctlbuf_size.y/bh;\n  const int nbx = ctlbuf_size.x/bw;\n  ivec2 block = pix/ivec2(bw,bh);\n  ivec2 bpix  = pix%ivec2(bw,bh);\n  n = bpix.y+bh*bpix.x;\n  ch = block.x+nbx*block.y;\n}\n\nivec2 ctlbuf_unpack(int ch, int n) {\n  if (n<0||n>=ctlbuf_size.x) return ivec2(-1);\n  const int bh = 8;\n  const int bw = ctlbuf_size.y/bh;\n  const int nbx = ctlbuf_size.x/bw;\n  ivec2 block = ivec2(ch%nbx, ch/nbx);\n  ivec2 bpix = ivec2(n/bh, n%bh);\n  return ivec2(bw,bh)*block+bpix;\n}\n\nvec4 readctlch (sampler2D samp, int ch, int n) {\n  ivec2 pix = ctlbuf_unpack(ch,n);\n  if (pix==ivec2(-1)) return vec4(0.);\n  return texelFetch(samp, pix, 0);\n}\n\nstruct ui_win_param {\n  vec2 o,s;\n  vec3 bordercolor;\n  bool header;\n};\n\nconst float ui_win_border = 2.;\nconst float ui_win_header = 10.;\n\nvec2 ui_win_viewsize (ui_win_param p) {\n  return p.s-ui_win_border*2. -\n    vec2(0,p.header?ui_win_header:0.);\n}\n\nbool ui_win_draw ( inout vec3 v, vec2 fc, ui_win_param p,\n    out vec2 vs, out vec2 vc ) {\n  vc = fc-p.o-ui_win_border;\n  vs = ui_win_viewsize(p);\n  if (any(lessThan(fc, p.o)) || any(greaterThan(fc, p.o+p.s))) {\n    return false;\n  }\n  if (any(lessThan(fc, p.o+ui_win_border)) ||\n      any(greaterThan(fc,\n        p.o+p.s-ui_win_border-vec2(0,p.header?ui_win_header:0.)\n      ))) {\n    v = p.bordercolor;\n    return false;\n  }\n  return true;\n}\n\n#define COMMONDEF\nvec4 readctl (int ch, int n);\nivec4 readctli (int ch, int n) { return decodeInteger(readctl(ch,n)); }\n\n#define CTL_MOUSETIME 8,0\n#define CTL_MOUSEEASE 8,1\n#define CTL_FPSAVG 8,2\n#define CTL_PERFAVG 8,3\n#define CTL_RESCHG 8,4\n#define CTL_CHGTIME 8,5\n\n#define CTL_WHICHDEMO 10,0\n#define CTL_SCALE 11,0\n#define CTL_OMEGA 11,1\n#define CTL_SHAPE 11,2\n#define CTL_VIS   11,3\n#define CTL_VIEW  11,4\n\n#define CTLCH_WINGEOM 13\n#define CTLCH_WINMOUSE 14\n#define UI_WINDOWS_MAX 10\n\nui_win_param ui_win_param_read (int wid) {\n  ui_win_param p;\n  vec4 v1 = readctl(CTLCH_WINGEOM, wid*2+0);\n  vec4 v2 = readctl(CTLCH_WINGEOM, wid*2+1);\n  p.o = v1.xy; p.s = v1.zw;\n  p.bordercolor = vec3(.1);\n  p.header = false;\n  return p;\n}\n\nconst int wid_ctls_start = 3;\n\nbool windows_init (int wid, out ui_win_param p) {\n  vec2 Res = iResolution.xy;\n  if (wid==0) p = ui_win_param(Res*vec2(0.,.5),Res*vec2(.6,.5),vec3(.5),false);\n    \n  else if (wid==1) p = ui_win_param(Res*vec2(0.),Res*vec2(.6,.5),vec3(.5),false);\n  else if (wid==2) p = ui_win_param(Res*vec2(.6,0.),Res*vec2(.4,.58),vec3(.5),false);\n  else if (wid>=wid_ctls_start && wid<wid_ctls_start+5) {\n    float n = float(wid-wid_ctls_start)+1.;\n    float hs = .08;\n    float h = .06;\n    p = ui_win_param(Res*vec2(0.61,1.-hs*n),Res*vec2(.21,h),vec3(.5),false);\n  }\n  else return false;\n  return true;\n}\n\n#ifdef SHADERTOY_COMMON_CHECK\nvec4 readctl (int ch, int n) {return vec4(0.);}\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define CH_SELF iChannel3\n#define CH_KEYB iChannel2\n\nvec4 readctl (int ch, int n) { return readctlch(CH_SELF, ch, n); }\nbool keyboard (int keycode, int evt) {\n  return texelFetch(CH_KEYB, ivec2(keycode,evt), 0).r>.5;\n}\n\nbool winmouse(int wid, inout vec4 f) {\n  if (wid>UI_WINDOWS_MAX) return false;\n  ui_win_param p = ui_win_param_read(wid);\n  vec3 _1;\n  vec2 vs, vc;\n  if (ui_win_draw(_1, iMouse.zw, p, vs, vc)) {\n    ui_win_draw(_1, iMouse.xy, p, vs, vc);\n    vc = max(vec2(0.),min(vec2(vs),vc));\n    f.xy = vc; f.zw = vc / vs;\n    return true;\n  }\n  return false;\n}\n\nvoid mainImage ( out vec4 f, in vec2 fc ) {\n  int ch, n;\n  ctlbuf_pack(ivec2(fc), ch, n);\n  ivec2 chn = ivec2(ch,n);\n  bool init = (iFrame<2);\n  vec4 forig = texelFetch(CH_SELF, ivec2(fc), 0);\n  f = forig;\n  ivec4 d = decodeInteger(forig);\n  // Keyboard\n  if (ch<3) { f = texelFetch(CH_KEYB, ivec2(n,ch), 0); return; }\n  \n  if (ch==CTLCH_WINGEOM) {\n    int wid = n/2;\n    int s = n%2;\n    if (wid>UI_WINDOWS_MAX) return;\n    ui_win_param p;\n    if (windows_init(wid, p)) {\n      if (s==0) f = vec4(p.o,p.s);\n    } else f=vec4(0.);\n  }\n\n  if (ch==CTLCH_WINMOUSE) {\n    int wid = n;\n    winmouse(wid, f);\n  }\n\n  int preset = -1;\n\n  if (init) {preset=1;}\n\n  if (KEYBOARD(_0,PRESS)) preset = 0;\n  if (KEYBOARD(_7,PRESS)) preset = 1;\n  if (KEYBOARD(_8,PRESS)) preset = 2;\n  if (KEYBOARD(_9,PRESS)) preset = 3;\n  if (preset==0) init = true;\n\n  if (chn==ivec2(CTL_MOUSETIME)) {\n    // x: last down, y: last up\n    if (f.x<f.y && iMouse.z>0.) f.x = iTime;\n    if (f.y<f.x && iMouse.z<0.) f.y = iTime;\n    if (init) f.xy = vec2(-101,-100);\n  }\n\n  if (chn==ivec2(CTL_MOUSEEASE)) {\n    float rate = 4.;\n    f.x = mix(f.x, float(iMouse.z>1.), rate*iTimeDelta);\n  }\n\n  if (chn==ivec2(CTL_FPSAVG)) {\n    f.x = 1./mix(1./f.x, iTimeDelta, .02);\n    if (isnan(f.x)) f.x=20.;\n    f.x=clamp(f.x,1.,500.);\n    f.y=max(f.y,f.x);\n    if (readctl(CTL_RESCHG).zw!=readctl(CTL_RESCHG).xy) f.y=f.x;\n  }\n\n  if (chn==ivec2(CTL_RESCHG)) {\n    f.zw = f.xy;\n    f.xy = iResolution.xy;\n  }\n\n  if (chn==ivec2(CTL_CHGTIME)) {\n    f.z = -1.;\n    vec2 mousetime = readctl(CTL_MOUSETIME).xy;\n    if (iResolution.xy!=readctl(CTL_RESCHG).zw || mousetime.y<mousetime.x) {\n      f.x = iTime;\n      f.z = 1.;\n    }\n  }\n\n  if (chn==ivec2(CTL_PERFAVG)) {\n    vec2 fpsavg = readctl(CTL_FPSAVG).xy;\n    float fpstarg = .9*fpsavg.y;\n    f.x *= pow(fpsavg.x/fpstarg,.1);\n    f.x=clamp(f.x,.2,4.);\n    if (init || iTime<1.) f.x=.1;\n  }\n\n  if (chn==ivec2(CTL_WHICHDEMO)) {\n    for (int i=1; i<6; i++) {\n      if (keyboard(48+i,1)) {\n        d.x = i;\n      }\n    }\n    if (init) d.x = 3;\n    if (preset==1) d.x = 2;\n  }\n\n  if (chn==ivec2(CTL_SCALE)) {\n    float rate = 2.;\n    if (KEYBOARD(A,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (KEYBOARD(S,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (init) f.x = 5.;\n    f.x = clamp(f.x, 1e-1, 5.);\n  }\n\n  if (chn==ivec2(CTL_OMEGA)) {\n    winmouse(3, f.zwxy);\n    if (init) f = vec4(.7,0,0,0);\n  }\n\n  if (chn==ivec2(CTL_SHAPE)) {\n    vec4 m;\n    if(winmouse(4, m)) f.x=m.z;\n    if(winmouse(5, m)) f.y=m.z;\n    if (init) f = vec4(0.1,0,0,0);\n  }\n\n  if (chn==ivec2(CTL_VIS)) {\n    vec4 m;\n    if(winmouse(6, m)) f.x=m.z;\n    if(winmouse(7, m)) f.y=m.z;\n    if (init) f = vec4(0.1,0,0,0);\n  }\n    \n  if (chn==ivec2(CTL_VIEW)) {\n    winmouse(2, f.zwxy);\n    if (init) f = vec4(.2,.6,0,0);\n  }\n\n  if (d!=decodeInteger(forig)) f = encodeInteger(d);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n/*\n\nRadiating Sources Visualization\nCopyright 2020 Theron Tarigo\n\nVisualizes EM radiation from oscillating currents\n\n*/\n\nconst float pi = 3.1415927;\nfloat sinc (float x) { return abs(x)<1e-4?1.:sin(x)/x; }\nfloat square (float a) { return a*a; }\nvec2 compmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 compsin(float x){return vec2(cos(x),sin(x));}\nvec2 compexp(vec2 a){return exp(a.x)*compsin(a.y);}\nvec2 compinv(vec2 a){return vec2(1,-1)*a/dot(a,a);}\nfloat comparg(vec2 a){return atan(a.y,a.x);}\nvec2 comppow(vec2 a, float n){return compsin(comparg(a)*n)*pow(length(a),n);}\n\nint getFrame() { return iFrame; }\nvec4 readctl (int ch, int n) { return readctlch(iChannel3, ch, n); }\nbool keyboard (int keycode, int evt) {\n  return texelFetch(iChannel2, ivec2(keycode,evt), 0).r>.5;\n}\n\nvec3 complex_color (vec2 v) {\n  vec2 vn = normalize(v);\n  vec3 cb = vec3(1.) + vec3(1,-.5,-.5)*vn.x + vec3(0.,.866,-.866)*vn.y;\n  return cb/dot(cb,vec3(.213,.715,.072))*dot(v,v);\n}\n\n// mat2x3 represents a complex vec3:\n// left column Real | right column Imag\n\n// vec2 represents a complex scalar\n// x Real | y Imag\n\nmat2x3 compcross(mat2x3 a, vec3 b) {\n  return mat2x3(cross(a[0],b),cross(a[1],b)); }\nmat2x3 compcross(vec3 a, mat2x3 b) { return -compcross(b,a); }\n\nmat2x3 compcross(mat2x3 a, mat2x3 b) {\n  mat2x3 reprod = compcross(a, b[0]);\n  mat2x3 improd = compcross(a, b[1]);\n  return reprod + mat2x3(-improd[1],improd[0]);\n}\n\nvec3 abscomp(mat2x3 a) { return sqrt(a[0]*a[0]+a[1]*a[1]); }\n\nmat2x3 compmul(mat2x3 a, vec2 b) {\n  return mat2x3(a[0]*b.x-a[1]*b.y,a[0]*b.y+a[1]*b.x); }\n  \nvec3 re_compmul(mat2x3 a, vec2 b) {\n  return vec3(a[0]*b.x-a[1]*b.y); }\n\nmat2x3 compmul(vec3 a, vec2 b) {\n  return mat2x3(a*b.x,a*b.y); }\n\nconst float mu0 = 1.;\nconst float c = 1.;\n\nmat2x3 Bp_dJdl (float omega, vec3 R, vec2 dI, vec3 dl) {\n  mat2x3 Jk = compmul(dl, dI);\n  float k = omega/c;\n  return mu0/(4.*pi) *\n    compmul(\n      compcross(R,Jk),\n      compmul(\n        vec2(0,1) * k / dot(R,R),\n        compexp(vec2(0,1)*k*length(R))\n      )\n    );\n  return mat2x3(0.);\n}\n\nmat2x3 Ep_dJdl (float omega, vec3 R, vec2 dI, vec3 dl) {\n  mat2x3 Bp = Bp_dJdl(omega, R, dI, dl);\n  return c*compcross(Bp,R)/length(R);\n}\n\n\nvec2 gfc = vec2(0.);\nvec2 gmouse = vec2(0.);\n\nfloat contour(float v) {\n  return max(0.,1.-abs(fract(v+.5)-.5)/fwidth(v));\n}\n\nstruct fieldparam {\n  float p0, p1, p2;\n};\n\nvoid fields (fieldparam p, int N, vec3 R, out float Sm, out float avgSm) {\n\n  mat2x3 Bp = mat2x3(0.);\n  mat2x3 Ep = mat2x3(0.);\n  \n  float b = .06;\n  vec2 dI = vec2(1,0)/(b*b)*.05;\n  \n  float omega = 1.*exp2(8.*p.p0);\n  \n  /*for (int i=0; i<N; i++) {\n    float sphi = 2.*pi*float(i)/float(N);\n    vec3 r = b*vec3(cos(sphi),sin(sphi),0.);\n    vec3 dl = b*vec3(-sin(sphi),cos(sphi),0.) * 2.*pi/float(N);\n    Bp += Bp_dJdl(omega, R-r, dI, dl);\n    Ep += Ep_dJdl(omega, R-r, dI, dl);\n  }*/\n  \n  /*for (int i=0; i<N; i++) {\n    float f = -.5+float(i)/float(N);\n    for (int is=0; is<2; is++) {\n      float s = float(is*2-1);\n      vec3 r = b*vec3(-.5*s,0.,f);\n      vec3 dl = b*vec3(0.,0.,1.)*s * 1./float(N);\n      Bp += Bp_dJdl(omega, R-r, dI, dl);\n      Ep += Ep_dJdl(omega, R-r, dI, dl);\n    }\n  }*/\n  \n  for (int i=0; i<N; i++) {\n    float f = float(i)/float(N);\n    for (int is=0; is<4; is++) {\n      float s1 = float((is%2)*2-1);\n      float s2 = float((is/2)*2-1);\n      float a1 = p.p1;\n      float a2 = p.p2;\n      vec3 r = b*vec3(-.5*s1*mix(f,1.,a1),0.,-.5*s2*mix(f,1.,a2));\n      vec3 dl = b*vec3(-.5*s1*(1.-a1),0.,-.5*s2*(1.-a2)) * 1./float(N);\n      vec2 dI = compmul(compsin(omega/c*float(i)*length(dl)),dI)*\n                 s1*s2 / length(vec2(1.-a1,1.-a2));\n      Bp += Bp_dJdl(omega, R-r, dI, dl);\n      Ep += Ep_dJdl(omega, R-r, dI, dl);\n    }\n  }\n  \n  float t = 2.*pi*fract(iTime*.4)/omega;\n  vec3 B = re_compmul(Bp, compexp(vec2(0,-1)*omega*t));\n  vec3 E = re_compmul(Ep, compexp(vec2(0,-1)*omega*t));\n  vec3 S = cross(E,B)/mu0;\n  vec3 avgS = abscomp(compcross(Ep,Bp)/mu0/2.);\n  Sm = length(S)/(omega*omega);\n  avgSm = length(avgS)/(omega*omega);\n}\n\nvec3 fieldvis(fieldparam p, vec3 R, float vscale) {\n  float Sm, avgSm;\n  int N = 32;\n  if (length(R)<1.) N=40;\n  fields(p, N, R, Sm, avgSm);\n\n  vec2 visctl = readctl(CTL_VIS).xy;\n\n  vec3 color = vec3(0.);\n  vec3 color_pnow = vscale*Sm*vec3(1.,.5,0.);\n  vec3 color_pavg = vscale*avgSm*vec3(0,.5,1);\n  color_pnow += contour(max(.5,vscale*Sm*10.))*vec3(0,.5,1)*visctl.y;\n  color_pavg += contour(max(.5,vscale*avgSm*20.))*vec3(2,0,0)*visctl.y;\n  color = mix(color_pnow, color_pavg, visctl.x);\n\n  color += .004;\n  return color;\n}\n\nvec3 fieldvol (fieldparam p, vec3 ro, vec3 rd, float vscale) {\n  float f = 0.;\n  rd/=length(rd);\n  const float zmax = 2.;\n  \n  vec2 visctl = readctl(CTL_VIS).xy;\n  \n  const float dcthres = .05;\n  float cthres1 = dcthres;\n  float cthres2 = dcthres;\n  vec3 v = vec3(0.);\n  float z=.5*paramdither(gfc, 0).x;\n  const int maxiter = 128;\n  int niter = min(maxiter,int(.25*float(maxiter)*readctl(CTL_PERFAVG).x));\n  for (int i=0; i<maxiter && i<niter; i++) {\n    vec3 R = ro+z*rd;\n    float zstep = length(R)*4./float(niter)+.01;\n    float Sm, avgSm;\n    fields(p, 4, R, Sm, avgSm);\n    float w = .1/(z*z*z);\n    if (Sm>cthres1) {\n      cthres1 += dcthres;\n      v += w*vec3(1.,.5,0.)*sqrt(1.-visctl.x)*cthres1/dcthres;\n    }\n    if (avgSm*2.>cthres2) {\n      cthres2 += dcthres;\n      v += w*vec3(0.,.5,1.)*sqrt(visctl.x)*cthres2/dcthres;\n    }\n    z+=zstep;\n  }\n  return v;\n}\n\nuint[5] ctllabels(int id) {\n  if (id==0) return STRING16(15, ome,d,sl,c,_,_,_,_,_,_,_,_,_,_,_,_);\n  if (id==1) return STRING16(15, S,h,a,p,e,_,p,a,r,a,m,_,_1,_,_,_);\n  if (id==2) return STRING16(15, S,h,a,p,e,_,p,a,r,a,m,_,_2,_,_,_);\n  if (id==3) return STRING16(15, N,o,w,_,lt,hm,gt,_,A,v,g,pe,_,_,_,_);\n  if (id==4) return STRING16(15, S,h,o,w,_,C,o,n,t,o,u,r,s,_,_,_);\n}\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord ) {\n  gmouse = iMouse.xy/iResolution.xy;  \n  vec2 Res = iResolution.xy;\n  gfc = fragCoord;\n  C_iFrame = iFrame;\n  \n  float scale = readctl(CTL_SCALE).x;\n  \n  fragData = vec4(0.);\n\n  vec3 color = vec3(0.);\n\n  float omegactl = readctl(CTL_OMEGA).x;\n  vec2 shapectl = readctl(CTL_SHAPE).xy;\n  fieldparam p = fieldparam(omegactl,shapectl.x,shapectl.y);\n  \n  ui_win_param win0 = ui_win_param_read(0);\n  ui_win_param win1 = ui_win_param_read(1);\n  ui_win_param win2 = ui_win_param_read(2);\n\n  vec2 vs, vc;\n  if (ui_win_draw(color, fragCoord, win1, vs, vc)) {\n    vec2 uv = (vc - vec2(.5,.5)*vs) / Res.y;\n    uv/=scale/16.;\n    vec3 R = vec3(uv.x, 0., uv.y);\n    color = fieldvis(p, R, 32.);\n  }\n  if (ui_win_draw(color, fragCoord, win2, vs, vc)) {\n    vec2 uv = (vc - vec2(.5,.5)*vs) / Res.y;\n    uv*=1.;\n    vec2 m = readctl(CTL_VIEW).xy;\n    float th = pi*clamp(1.-m.y,.01,.99), phi = 2.*pi*m.x;\n    vec3 ro = vec3(sin(th)*cos(phi),sin(th)*sin(phi),cos(th))*1.;\n    vec3 rc = -normalize(ro);\n    vec3 rx = cross(rc,vec3(0,0,1));\n    vec3 ry = cross(rx,rc);\n    rx = normalize(rx); ry = normalize(ry);\n    vec3 rd = rc+(uv.x*rx+uv.y*ry)/scale*5.;\n    color = fieldvol(p, ro, rd, 32.);\n    vec4 chgctl = readctl(CTL_CHGTIME);\n    if (chgctl.z<0.) {\n      float mixf;\n      if (readctl(CTL_VIS).x<.99) mixf = 4.*iTimeDelta;\n      else mixf = iTimeDelta/(iTime-chgctl.x-iTimeDelta);\n      color = mix(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, color, clamp(mixf,0.,1.));\n    }\n  }\n  if (ui_win_draw(color, fragCoord, win0, vs, vc)) {\n    vec2 uv = (vc - vec2(.5,.5)*vs) / Res.y;\n    uv/=scale;\n    vec3 R = vec3(uv.x, 0., uv.y);\n    color = fieldvis(p, R, .25);\n  }\n  for (int wid=wid_ctls_start; wid<UI_WINDOWS_MAX; wid++) {\n    int ctlid = wid-wid_ctls_start;\n    vec2 vs, vc;\n    if (ui_win_draw(color, fragCoord, ui_win_param_read(wid), vs, vc)) {\n      float v = 0.;\n      if (wid==3) v = readctl(CTL_OMEGA).x;\n      if (wid==4) v = readctl(CTL_SHAPE).x;\n      if (wid==5) v = readctl(CTL_SHAPE).y;\n      if (wid==6) v = readctl(CTL_VIS).x;\n      if (wid==7) v = readctl(CTL_VIS).y;\n      if (v>(vc/vs).x) color += vec3(.2);\n    }\n    vec2 tuv = vc/vs-vec2(1,0);\n    if (abs(tuv.y-.5)<.5 && tuv.x>0. ) {\n      if (ctlid<5)\n      color+=draw_string(iChannel1,tuv*vec2(17,1)-vec2(1.,0), ctllabels(ctlid));\n    }\n  }\n\n  //color = tonemap(color*.6);\n  //fragData.rgb = srgbl_to_srgb(color);\n  //fragData.rgb += dither(fragCoord);\n  fragData.rgb = (color);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}