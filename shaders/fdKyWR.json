{
    "Shader": {
        "info": {
            "date": "1654690106",
            "description": "remember to travel forward in time only",
            "flags": 32,
            "hasliked": 0,
            "id": "fdKyWR",
            "likes": 4,
            "name": "Gamma Ray Anatomy",
            "published": 3,
            "tags": [
                "hue",
                "feedback",
                "hypnosis"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "// Fork of \"glowdoodle interdimensional\" by ericrosenbizzle. https://shadertoy.com/view/fsycDR\n// 2022-06-08 12:07:34\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 img = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n   \tfragColor = vec4(img, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float rgbToGray(vec3 rgb) {\n\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n\nvec3 hueShift2(vec3 color, float hue)\n{\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // mirror reverse the camera input\n    vec2 pos = fragCoord/iResolution.xy;\n    pos = vec2(1.0 - pos.x, pos.y);\n    \n    vec3 cam = texture(iChannel0,pos).xyz;\n    \n    vec2 offsetPos = fragCoord/iResolution.xy;\n    //offsetPos /= 1.01;\n\n    vec2 center = vec2(0.5, 0.5);\n    vec2 v2 = (fragCoord/iResolution.xy) - center;\n    v2 *= 0.99;\n    offsetPos = v2 + center;\n\n    vec3 image = texture(iChannel1,offsetPos).xyz;\n    \n    float camBrightness = rgbToGray(cam);\n    float imageBrightness = rgbToGray(image);\n    \n    //vec3 shifted = hueShift2(cam, iTime); \n    vec3 shifted = cam;\n    \n    if (camBrightness > imageBrightness) {\n\t    fragColor = vec4(shifted, 1.);\n    } else {\n\t    fragColor = vec4(image, 1.);    \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 hueShift(vec3 color, float hue)\n{\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 filtered = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    // hue shift\n    vec3 shifted = hueShift(filtered, 0.1);\n    //vec3 shifted = filtered;\n    \n    // Slow fade\n    //fragColor = vec4(filtered * 0.999, 1.);\n    fragColor = vec4(shifted * 0.999, 1.);\n    //fragColor = vec4(shifted, 1.);\n    \n    // Click to clear\n    vec4 m = iMouse / iResolution.xxxx;\n    if(m.z>0.0 ) {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define BACKGROUND_COLOR vec3(0.5f, 0.5f, 1.0f)\n\n// The amount of metaballs\n// The more there are, the quicker the same one will reach the same position again\n// This is because the noise texture is finite and sampled based on the ball and time\n// Doesn't actally control the amount of blobs (unrolled loop) but still used in calculations\n#define METABALLS 8\n\n#define METABALL_MIN_RADIUS 0.0625f\n#define METABALL_MAX_RADIUS 0.125f\n\n#define FLOW_TIME_SCALE 0.015625f\n#define UP_FLOW_TIME_SCALE 0.0625f\n#define ROTATION_TIME_SCALE 0.0981747705f\n\n#define CAMERA_OFFSET -2.0f\n#define SPHERE_RADIUS 0.375f\n\n#define MAX_ITERATIONS 8\n#define SDF_EPSILON 1e-6\n\n#define SPECULAR_HIGHLIGHT 1\n#define POINT_LIGHT_POSITION vec3(1.0f, 0.5f, 0.0f)\n#define SPECULAR_DEGREE 6\n\n\n// Cubic interpolation http://paulbourke.net/miscellaneous/interpolation/\nfloat mixCubic(float y0, float y1, float y2, float y3, float mu)\n{\n   float a0, a1, a2, a3, mu2;\n\n   mu2 = mu * mu;\n   a0 = y3 - y2 - y0 + y1;\n   a1 = y0 - y1 - a0;\n   a2 = y2 - y0;\n   a3 = y1;\n\n   return a0 * mu * mu2 + a1 * mu2 + a2 * mu + a3;\n}\n\nvec4 mixCubic(vec4 z, vec4 a, vec4 b, vec4 c, float t){\n    return vec4(\n        mixCubic(z.x, a.x, b.x, c.x, t),\n        mixCubic(z.y, a.y, b.y, c.y, t),\n        mixCubic(z.z, a.z, b.z, c.z, t),\n        mixCubic(z.w, a.w, b.w, c.w, t)\n    );\n}\n\n\n// https://gist.github.com/h3r/3a92295517b2bee8a82c1de1456431dc\nfloat hash(float x, float y){\n    return fract(1e4 * sin(17.0 * x + y * 0.1) * (0.1 + abs(sin(y * 13.0 + x))));\n}\n\nvec4 hash4(float x, float y){\n    return vec4(\n        -0.25f + 0.5f * hash(x + 0.75f, y),\n        -0.25f + 0.5f * hash(x + 0.5f, y),\n        -0.25f + 0.5f * hash(x + 0.25f, y),\n        hash(x, y));\n}\n\n\n// Inigo Quilez MIT licence https://www.shadertoy.com/view/lt3BW2\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n\n// Samples the color from a gradient\nvec3 colorGradient(float x){\n    return vec3(smoothstep(0.25f, 0.4f, x), smoothstep(0.4f, 0.6f, x), smoothstep(0.65f, 0.875f, x));\n}\n\n\n// Samples the noise texture at the given index\nvec4 noiseAtId(int i){\n    return texture(iChannel0, vec3(float(i >> 10) / 32.0f, float(i << 5 >> 10) / 32.0f, float(i << 10 >> 10) / 32.0f));\n}\n\n\n// Samples the noise texture at the given time for the given metaball\nvec4 noise(int ballId, float time){\n    \n    float flooredTime = floor(time);    \n    // int stride = 32768 / METABALLS;\n    //int t = int(flooredTime);\n\n    // vec4 z = noiseAtId(stride * ballId + (t + stride - 1) % stride);\n    // vec4 a = noiseAtId(stride * ballId + t % stride);\n    // vec4 b = noiseAtId(stride * ballId + (t + 1) % stride);\n    // vec4 c = noiseAtId(stride * ballId + (t + 2) % stride);\n\n    vec4 z = hash4(float(ballId), flooredTime - 1.0f);\n    vec4 a = hash4(float(ballId), flooredTime);\n    vec4 b = hash4(float(ballId), flooredTime + 1.0f);\n    vec4 c = hash4(float(ballId), flooredTime + 2.0f);\n\n    return mixCubic(z, a, b, c, time - flooredTime);\n}\n\n\n// Gets the position and radius at a given time for the given metaball\nvec4 getBallInfo(int ballId, float time){\n\n    vec4 res = noise(ballId, time);\n\n    // Scale [0;1] -> [-1;1]\n    res.xyz *= 2.0f;\n    res.xyz += vec3(-1.0f, -1.0f, -1.0f);\n    \n    // Fit noise better\n    // For some reason it's actually on [-0.5,0.5] by now, so rescale\n    // with also some squeezing towards the center for a better look\n    res.x = res.x * res.x + res.x;\n    res.y *= 2.0f;\n    res.z = res.z * res.z + res.z;\n\n    // Updraft\n    res.y += 1.0f + iTime * UP_FLOW_TIME_SCALE;\n    res.y = fract(res.y);\n    res.y = -2.0f + 4.0f * res.y;\n\n    // Density\n    res.w = mix(METABALL_MIN_RADIUS, METABALL_MAX_RADIUS, res.w);\n    res.w *= min(mix(1.0f, 0.0f, res.y), mix(1.0f, 0.0f, -1.0f + 2.0f * length(res.xyz)));\n\n    // Scale to sphere\n    res.xyz *= SPHERE_RADIUS;\n    \n    // Rotate sphere\n    float angle = iTime * ROTATION_TIME_SCALE;\n    float c = cos(angle);\n    float s = sin(angle);\n    res.xyz = mat3(c, 0.0f, -s, 0.0f, 1.0f, 0.0f, s, 0.0f, c) * res.xyz;\n\n    return res;\n}\n\n\n// Samples the SDF at the given coordinates at the given time\nfloat sdfAt(vec3 coords, float time){\n\n    float value = abs(CAMERA_OFFSET) + 2.0 * SPHERE_RADIUS;\n\n    vec4 ballInfoA, ballInfoB;\n\n    ballInfoA = getBallInfo(0, time);\n    ballInfoB = getBallInfo(1, time);\n    float s0 = opSmoothUnion(\n        length(ballInfoA.xyz - coords) - ballInfoA.w,\n        length(ballInfoB.xyz - coords) - ballInfoB.w,\n        0.25f);\n    \n    ballInfoA = getBallInfo(2, time);\n    ballInfoB = getBallInfo(3, time);\n    float s1 = opSmoothUnion(\n        length(ballInfoA.xyz - coords) - ballInfoA.w,\n        length(ballInfoB.xyz - coords) - ballInfoB.w,\n        0.25f);\n    \n    ballInfoA = getBallInfo(4, time);\n    ballInfoB = getBallInfo(5, time);\n    float s2 = opSmoothUnion(\n        length(ballInfoA.xyz - coords) - ballInfoA.w,\n        length(ballInfoB.xyz - coords) - ballInfoB.w,\n        0.25f);\n    \n    ballInfoA = getBallInfo(6, time);\n    ballInfoB = getBallInfo(7, time);\n    float s3 = opSmoothUnion(\n        length(ballInfoA.xyz - coords) - ballInfoA.w,\n        length(ballInfoB.xyz - coords) - ballInfoB.w,\n        0.25f);\n    \n    float t0 = opSmoothUnion(s0, s1, 0.25f);\n    float t1 = opSmoothUnion(s2, s3, 0.25f);\n\n    value = opSmoothUnion(t0, t1, 0.25f);\n    \n    // For some reason I have to unroll this loop (see above)\n    // because (at least on my system) I get artifacts otherwise\n    // The smoothing factor is different for cosmetic reasons\n    // for (int i = 0; i < METABALLS; ++i){\n    // \n    //     vec4 ballInfo = getBallInfo(i, time);\n    //     vec3 delta = ballInfo.xyz - coords;\n    //     \n    //     value = opSmoothUnion(value, length(delta) - ballInfo.w, 0.25f);\n    // }\n        \n    return value;\n}\n\n\n// Gets the full-alpha color of the sphere by sphere-marching\nvec3 getSphereColor(vec3 start, vec3 end, vec3 backgroundColor){\n    \n    vec3 diff = end - start;\n    float maxDist = length(diff);\n    vec3 dir = diff / maxDist;\n    \n    float sdf;\n    float dist = 0.0f;\n    vec3 color = backgroundColor;\n\n    for (int i = 0; dist < maxDist && i < MAX_ITERATIONS; ++i){\n        \n        sdf = sdfAt(start + dist * dir, iTime * FLOW_TIME_SCALE);\n        \n        if (abs(sdf) <= SDF_EPSILON){\n            color = mix(color, colorGradient(0.75f), 1.0f - dist / SPHERE_RADIUS);\n            break;\n        }\n        \n        color = mix(color, colorGradient(0.5f - 2.0f * sdf), 1.0f - dist);\n        \n        dist += sdf;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolution = min(iResolution.x, iResolution.y);\n    \n    // The location of the pixel on the XY plane\n    vec2 viewPlaneLocation = (fragCoord - iResolution.xy* 0.5f) / vec2(resolution, resolution);\n\n    vec3 cameraPosition = vec3(0.0f, 0.0f, CAMERA_OFFSET);\n\n    // The direction of the pixel from the camera\n    vec3 dir = normalize(vec3(viewPlaneLocation, 0.0f) - cameraPosition);\n    \n    // The vector from the camera to the closest point on the ray from the origin\n    vec3 toClosest = dir * dot(dir, -cameraPosition);\n\n    // The distance from the camera to the closest point on the ray from the origin\n    float tcd = sqrt(dot(toClosest, toClosest));\n    \n    // The vector from the origin to the closest point on the ray\n    vec3 closest = cameraPosition + toClosest;\n    \n    // The square distance from the origin to the closest point on the ray\n    float csd = dot(closest, closest);\n    \n    // The distance from the origin to the closest point on the ray\n    float cd = sqrt(csd);\n    \n    // The distance travelled by the ray inside of the sphere to the point\n    // closest to the origin, which is half the distance it travels there total\n    float ttcd = sqrt(abs(SPHERE_RADIUS * SPHERE_RADIUS - csd));\n\n    // The start and end of the ray through the sphere\n    vec3 start = cameraPosition + dir * (tcd - ttcd);\n    vec3 end   = cameraPosition + dir * (tcd + ttcd);\n\n    vec3 backgroundColor = BACKGROUND_COLOR;\n    vec3 color = cd <= SPHERE_RADIUS ? getSphereColor(start, end, backgroundColor) : backgroundColor;\n\n    // Previous version, marching with a fixed stride\n    // vec3 color = backgroundColor;\n    // for (float depth = 3.0f; depth > 1.0f; depth -= 0.0625)\n    //     color = march(color, cameraPosition + depth * dir);\n\n    // Take account of sphere depth\n    color = mix(backgroundColor, color, ttcd / SPHERE_RADIUS);\n\n#if SPECULAR_HIGHLIGHT != 0\n    float plAngle = -iTime * ROTATION_TIME_SCALE;\n    float plc = cos(plAngle);\n    float pls = sin(plAngle);\n\n    vec3 pointLightPosition = mat3(plc, 0.0f, -pls, 0.0f, 1.0f, 0.0f, pls, 0.0f, plc) * POINT_LIGHT_POSITION;\n    vec3 pointLightDirection = -normalize(pointLightPosition - start);\n    vec3 normal = normalize(start);\n    float nDotPLD = dot(normal, pointLightDirection);\n    vec3 reflection = nDotPLD * 2.0f * normal - pointLightDirection;\n\n    float specularAmount = nDotPLD <= 0.0f ? dot(dir, reflection) : 0.0f;\n    for (int i = 0; i < SPECULAR_DEGREE - 1; ++i)\n        specularAmount *= specularAmount;\n    color = cd <= SPHERE_RADIUS ? mix(color, vec3(1.0f, 1.0f, 1.0f), specularAmount) : color;\n#endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .0025;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .005;\nconst float iFeedbackColorShiftImpact = 0.0005;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .01;\nconst float iBlobEdgeSmoothing        = .001;\nconst float iBlob1Radius              = .5;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = -.033;\nconst float iBlob2Radius              = .75;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     =- .0234;\nconst float iBlob2ColorPulseShift     = 0.0750;\nconst float iColorShiftOfRadius       = -.25;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.br/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = mix(repeatedTexture(iChannel2, uv - stShift).rgb,repeatedTexture(iChannel3, uv - stShift).rgb,repeatedTexture(iChannel0, uv - stShift).rgb);\n     vec3 prevColor2 = mix(repeatedTexture(iChannel2, uv - stShift).rgb,repeatedTexture(iChannel3, uv - stShift).rgb , repeatedTexture(iChannel0, uv - stShift).rgb/256.);\n    prevColor +=prevColor2/512.;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n#define iTime iTime / 1.0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}