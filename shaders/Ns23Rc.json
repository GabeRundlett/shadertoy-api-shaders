{
    "Shader": {
        "info": {
            "date": "1617746694",
            "description": "This is a ShaderToy re-creation of \"lightcrypt\" by gopher/Alcatraz. A 256-bytes DOS demo from Revision 2021. I was totally blown away seeing 3D raymarching with lighting & shadows in a 256-bytes demo. Still some things missing, e.g. textures, proportions.",
            "flags": 64,
            "hasliked": 0,
            "id": "Ns23Rc",
            "likes": 6,
            "name": "lightcrypt hommage",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "demo",
                "revision"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 431
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// hommage to \"lightcrypt\" by gopher/Alcatraz - At Revision 2021 I was blown\n// away seeing a 256-bytes DOS demo implementing 3D raymarching with lighting\n// and shadows. I always had a huge facination for this extreme form of size-\n// -coding, but \"lightcrypt\" is on another level in my view.\n//\n// Since this sparked even more interest for that particular demoscene-discipline\n// and I really need to get back into shader-coding, I begin my ventures into\n// size-coding by getting a grip on the elements gopher probably used... only\n// less dense :)\n//\n// See http://www.pouet.net/prod.php?which=88539\n//\n// Author(s):\n//   Mirco \"MacSlow\" MÃ¼ller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat opSmoothSubtract (float a, float b, float k)\n{\n    float h = clamp (.5 - .5*(a+b)/k, .0, 1.);\n    return mix (b, -a, h) + k*h*(1. - h); \n}\n\nfloat cube (vec3 p, float size)\n{\n    vec3 cube = abs (p) - size;\n    return length (max (cube, .0)) + min (max (cube.x, max (cube.y, cube.z)), .0);\n}\n\nfloat scene (vec3 p)\n{\n    float cellSize = 1.; \n    float cellSizeHalf = cellSize*.5;\n    float radius = .6; \n\n    float ground = p.y + .125;\n\n    vec3 repreatedSpace = mod (p + cellSizeHalf, cellSize) - cellSizeHalf;\n    p = repreatedSpace;\n\n    float ball =  length (p) - radius;\n    float box =  cube (p, cellSizeHalf);\n    float cell = opSmoothSubtract (ball, box, .05);\n\n    float d = min (cell, ground);\n\n    return d;\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward*zoom;\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nfloat raymarch (vec3 ro, vec3 rd) \n{\n    float t = .0; \n    float d = .0; \n    vec3 p = vec3 (.0);\n    int iter = 0;\n\n    for (iter = 0; iter < 128; ++iter) {\n        p = ro + d * rd; \n        t = scene (p);\n        if (abs (t) < .0002*(1. + .125*t)) break;\n        d += t*.75;\n    }   \n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (0., .001);\n\n    return normalize (vec3 (scene (p + e.yxx),\n                            scene (p + e.xyx),\n                            scene (p + e.xxy)) - scene(p));\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos)\n{\n  float distanceToLight = distance (lPos, p); \n  vec3 lDir = normalize (lPos - p); \n  float distanceToObject = raymarch (p + .01 * n, lDir);\n  bool isShadowed = distanceToObject < distanceToLight;\n\n  return isShadowed ? .3 : 1.; \n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n)\n{\n    vec3 p = ro + d*rd;\n    vec3 amb = vec3 (.15);\n    vec3 lPos = p + vec3 (1., .25, -3.*cos (.5*iTime));\n    vec3 lPos2 = p + vec3 (-1., .25, -3.*sin (.25*iTime));\n    vec3 lDir = normalize (lPos - p);\n    vec3 lDir2 = normalize (lPos2 - p);\n    //float lDist = distance (p, lPos);\n    //float attn = 1. / (lDist*lDist);\n    float diff = max (dot (n, lDir), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 diffMat = vec3 (.8, .7, .2);\n    vec3 h = normalize (ro + lDir);\n    vec3 h2 = normalize (ro + lDir2);\n    float spec = pow (max (dot (h, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n    float sha = shadow (p, n, lPos);\n    float sha2 = shadow (p, n, lPos2);\n    float ao = ao (p, n, .01, 12, .1);\n\n    return amb + sha*ao*(diff*diffMat + spec) +\n                 sha2*ao*(diff2*diffMat + spec2);\n}\n\nmat2 r2d (float deg)\n{\n  float rad = radians (deg);\n  float c = cos (rad);\n  float s = sin (rad);\n\n  return mat2 (vec2 (c, s), vec2 (-s, c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= .5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\n\n    // build view-ray and camera\n    vec2 offset = vec2 (.125*cos (iTime), -.3*iTime);\n    vec3 ro = vec3 (offset.x, -.025, offset.y + 2.);\n    vec3 aim = vec3 (.0, .5, offset.y);\n    float zoom = 1.25;\n    vec3 rd = camera (uv, ro, aim, zoom);\n    rd.xy *= r2d(4. + 2.*cos (1.25*iTime));\n\n    // do raymarch, normal-calc and shading\n    float d = raymarch (ro, rd);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p);\n    vec3 color = shade (ro, rd, d, n);\n\n    // fog\n    float fog = 1. / (1. + d*d*1.);\n    color *= fog;\n\n    //colored haze\n    color = mix (color, vec3 (.99, .95, .2), pow (1. - 1. / d, 4.));\n\n    // vignette\n    color *= 1. - .625*length (fragCoord.xy/iResolution.xy*2. - 1.);\n\n    // Reinhart tone-mapping\n    color = color / (1. - color);\n\n    // Gamma-correction\n    color = pow (color, vec3 (1./2.2));\n\n    fragColor = vec4 (color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 26507,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/weareoliver/oliver-control"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}