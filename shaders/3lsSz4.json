{
    "Shader": {
        "info": {
            "date": "1562500019",
            "description": "Parametric circle.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsSz4",
            "likes": 0,
            "name": "Parametric circle",
            "published": 3,
            "tags": [
                "2d",
                "circle",
                "rotation",
                "point",
                "parametric"
            ],
            "usePreview": 0,
            "username": "nkaretnikov",
            "viewed": 403
        },
        "renderpass": [
            {
                "code": "// Public domain.\n\n// Constants.\nconst float pi = 3.1415;   \n\n// Colors.\nconst vec3 black = vec3(0.);\nconst vec3 white = vec3(1.);\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0., 0., 1.);\n\n// Parametric equation of a circle.\n// https://en.wikipedia.org/wiki/Parametric_equation#Circle\n// 't' from -pi to pi.\nvec2 pCircle(float r, float t)\n{\n    return vec2(r * sin(t), r * cos(t));\n}\n\n// Draw a circle.\nvec3 circle(vec3 color, vec2 uv, float pos, float r, float blur)\n{    \n    vec3 res = white;\n    \n    // Change the bounds of 't' to draw a part of a circle.\n    // (Not parameterized because it requires additional smoothing.)\n    for (float t = 0.; t < 2. * pi; t += .01) {\n        // Bounds.\n        vec2 c1 = pCircle(pos,     t);\n        vec2 c2 = pCircle(pos - r, t);\n        \n        // Find if a point belongs to a section using the triangle\n        // inequality (comparing to 'eps' due to floating-point).\n        float d1 = distance(c2, uv);\n        float d2 = distance(uv, c1);\n        float d3 = distance(c2, c1);\n               \n    \t// Decreasing this value produces an interesting effect.\n    \tfloat eps = .001;\n        \n\t\tif (abs(d1 + d2 - d3) < eps) {\n            // XXX: This blurs inward, reducing the size of the circle.\n            // XXX: When 'blur' == 1, the circle disappears.\n            res = color;\n            res *= smoothstep(d3, d3 * blur, d1);            \n            res *= smoothstep(d3, d3 * blur, d2);\n            break;\n        }\n        else res -= color;\n    }\n    \n    return res;\n}\n\n// Draw a point.\nvec3 point(vec3 color, vec2 uv, float pos, float r, float t, float blur)\n{  \n\t// Bounds.\n    vec2 c1 = pCircle(pos,     t);\n    vec2 c2 = pCircle(pos - r, t);\n\n    // Multiplying one of the arguments by -1 shifts it by pi.\n    float d1 = distance(uv, c1);\n    float d2 = distance(c1, c2);\n    \n    // XXX: Do not invert colors when 'blur' == 1.\n    vec3 res = vec3(smoothstep(d2, d2 * blur, d1));\n    \n    return res * color;\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Move 0.0 to the center.\n    uv -= .5;\n    \n    // Account for the screen ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Output color.\n    vec3 color = black;\n    \n    color += red;   \n    color -= circle(red - blue, uv, .5, .1, .9);\n    \n    // Without a loop, the parametric equation gives a point\n    // on a circle, which can be used to create a rotating point.\n\t//\n\t// Multiplying 't' by -1 makes it move counterclockwise.\n\t// Multiplying 'iTime' changes the rotation speed.\n    \n    // float t = pi;  // fixed position\n    float speed = 1.;\n    float t = mod(iTime * speed, 2. * pi);  // rotate\n    color -= point(red + blue - green, uv, .45, .01, t, .9);\n    \n    // Output to screen.\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}