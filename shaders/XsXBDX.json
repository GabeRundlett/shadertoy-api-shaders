{
    "Shader": {
        "info": {
            "date": "1498393747",
            "description": "Just for fun, a TRON cover for \"Boreal Spring\" shader: [/url]https://www.shadertoy.com/view/ldXBRH[/url]\n\nUse mouse to look around.",
            "flags": 64,
            "hasliked": 0,
            "id": "XsXBDX",
            "likes": 68,
            "name": "Trip in Tron 3",
            "published": 3,
            "tags": [
                "raytracing",
                "grid",
                "tron",
                "aurora",
                "raymarcing"
            ],
            "usePreview": 1,
            "username": "ocb",
            "viewed": 5809
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Trip in Tron 3\n\n// tron cover for Boreal Spring shader\n// https://www.shadertoy.com/view/ldXBRH\n\n\n// thanks to Dave Hoskins for his function (here named electric())\n// https://www.shadertoy.com/view/MdlXz8\n// function used to render fairyligths surface and path lag \n\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000000.\n\n#define maxTreeH 130.\n#define maxHill 300.\n#define cellH 430. \t/*treeH + maxHill*/\n#define cellD 100.\n#define maxCell 150\n#define TREE_DENSITY (abs(fract(cell.x/10.)-.5)*abs(fract(cell.y/10.)-.5))*10.\n\n// object name\n#define GND -1\n#define SKY -1000\n\n#define REDL 1\n#define MAGL 2\n#define BLUL 3\n#define YELL 4\n\n#define COTTA 10\n#define WALL 11\n#define ROOF 12\n\n#define TREE 20\n\n#define SNOWMAN 40\n#define BELLY 41\n#define HEAD 42\n#define HAT 43\n#define NOZ 44\n\n// ground parameters\n#define SHIFT 0.\n#define AMP 1.\n#define P1 .003\n#define P2 .0039999  /* P1*1.3333 */\n#define P3 .0059661  /* P1*1.9887 */\n\n#define DP2 .0039999 /*.00199995  /* AMP * P2 */\n#define DP3 .0059661 /*.00298305  /* AMP * P3 */\n\n#define NRM 4.   /* (1. + AMP + SHIFT) * 2. */\n\n//*******************************************************************************\n//Global var\n\nint hitObj = SKY;\nfloat T = INFINI;\n\n// object global\n// Ambiance light direction\nvec3 lightRay;\n// lights\nvec3 redO, magO, bluO, yelO;\nfloat redR, magR, bluR, yelR;\n// cotta\nvec3 wallO, roofO;\nfloat wallR, roofR, roofH;\nvec2 cottaCell;\n\n// snowpeople\nvec3 belO, hedO, hatO, nozO;\nfloat belR, hedR, hatH, hatR, nozH, nozR;\nvec2 snowmanCell;\n\n//tree\nvec3 treeO;\nfloat treeR, treeH;\n\n//*******************************************************************************\nfloat rand1 (in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\nfloat rand2 (in vec2 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st.xy,vec2(12.9898,8.233))) * 43758.5453123+time);\n}\n\nfloat pattern(in vec2 st, in float index){\n    if (index > 0.5) return st.x;\n    else return st.y;\n}\n//*******************************************************************************\n// Ground fonction for ray marching *********************************************\nfloat ground(in vec2 p){\n    float len = max(1.,0.0001*length(p));\n    float hx = max(0., (sin(P1*(p.x+p.y)) + AMP*sin(P2*p.x+PIdiv2) + SHIFT) );\n    float hy = max(0., (sin(P1*(p.y+.5*p.x)) + AMP*sin(P3*p.y+PIdiv2) + SHIFT));\n    return maxHill*(hx+hy)/NRM/len;\n}\n\n// derivation of the above function\nvec3 getGndNormal(in vec2 p, in float h) {\n    if(h<.001) return vec3(0.,1.,0.);\n    else{\n        float len = max(1.,0.0005*length(p));\n        float dx = maxHill*( P1*cos(P1*(p.x+p.y)) + DP2*cos(P2*p.x+PIdiv2) )/NRM;\n        float dy = maxHill*( P1*cos(P1*(p.y+.5*p.x)) + DP3*cos(P3*p.y+PIdiv2) )/NRM;\n        return normalize(cross( vec3(1.,dx/len,0.), vec3(0.,dy/len,1.) ));\t\t// divided by len: We may call that \"normal fog\"\n    }\n}\n\n// Ray marching (only for ground)\nfloat gndRayTrace(in vec3 p, in vec3 ray){\n    float t = 0.;\n    float contact = .1;\n    float dh = p.y - ground(p.xz);\n    if(dh<contact) return .0001;\n    for(int i=0; i<100;i++){\n        t += dh;\t\t\t// t = dh/length(ray) but ray normalized\n        p += dh*ray;\n        if(p.y >= cellH && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n        dh = p.y - ground(p.xz);\n        if(abs(dh)<contact)break;\n    }\n    return t;\n}\n\n//*************************************************************************************\n// Primitives solution for raytracing *************************************************\nfloat sfcImpact(in vec3 p, in vec3 ray, in float h){\n    float t = (h-p.y)/ray.y;\n    if (t <= 0.001) t = INFINI;\n    return t;\n}\n\nfloat sphereImpact(in vec3 pos, in vec3 sphO, in float sphR, in vec3 ray){\n    float t = INFINI;\n    vec3 d = sphO - pos;\n    float b = dot(d, ray);\n    \n    if (b >= 0.){\t// check if object in frontside first (not behind screen)\n        float c = dot(d,d) - sphR*sphR;\n    \tfloat disc = b*b - c;\n    \tif (disc >= 0.){\n        \tfloat sqdisc = sqrt(disc);\n            float t1= b + sqdisc;\n            float t2= b - sqdisc;\n        \tt = min(t1,t2) ;\n        \tif (t <= 0.001){\n                t = max(t1,t2);\n                if (t <= 0.001) t = INFINI;\n            } \n        }\n    }\n    return t;\n}\n\nfloat coneImpact(in vec3 pos, in vec3 coneO, in float coneH, in float coneR, in vec3 ray){\n    float t = INFINI, dmin=0.;\n    vec3 d = coneO - pos;\n    float Dy = coneH + d.y;\n    float r2 = coneR*coneR/(coneH*coneH);\n    float b = dot(d.xz, ray.xz);\n    \n    float a = dot(ray.xz,ray.xz);\n    float c = dot(d.xz,d.xz) - r2*Dy*Dy;\n    float c1 = -b + r2*Dy*ray.y;\n    float disc = c1*c1 - (a - r2*ray.y*ray.y) * c;\n    if (disc >= 0.){\n        float sqdis = sqrt(disc);\n        float t1 = (-c1 + sqdis)/(a - r2*ray.y*ray.y);\n        float t2 = (-c1 - sqdis)/(a - r2*ray.y*ray.y);\n\n        float ofc = -ray.y*t1 + Dy;\n        t1 *= step(0.,ofc)*(1.-step(coneH,ofc));\n        if (t1 <= 0.001) t1 = INFINI;\n\n        ofc = -ray.y*t2 + Dy;\n        t2 *= step(0.,ofc)*(1.-step(coneH,ofc));\n        if (t2 <= 0.001) t2 = INFINI;\n\n        t = min(t1,t2);\n    }\n\n\treturn t;\n}\n\nvec2 cylinderImpact(in vec2 pos, in vec2 cylO, in float cylR, in vec2 ray){\n    float t1 = INFINI, t2 = INFINI;\n    vec2 delta = pos - cylO;\n\n    float a = dot(ray,ray);\n    float b = dot(delta, ray);\n    float c = dot(delta,delta) - cylR*cylR;\n    float d = b*b - a*c;\n    \n    if (d >= 0.){\n        float Vd = sqrt(d);\n        t1 = (-b - Vd)/a;\n        t2 = (-b + Vd)/a;\n        if(t1<0.001) t1 = INFINI;\n        if(t2<0.001) t2 = INFINI;\n    }\n    \n\treturn vec2(t1,t2);\n}\n\n//*******************************************************************************************\n// Color and render functions ***************************************************************\nvec3 skyGlow(in vec3 ray){\n    if(ray.y>=0.)return vec3(.5*max(ray.x+.7,0.)*(.8-max(0.,ray.y)), .35,.4)*(1.-ray.y)*(ray.x+1.5)*.4;\n    else return vec3(0.);\n}\n\nvec3 snowColor(in vec3 pos){\n    vec3 col = vec3(.7,.7,.75)+vec3(.05,.05,.05)*rand2(floor(pos.xz*10.), 0.);\n    col += vec3(1.,.7,.8)*step(.997,rand2 (floor(pos.xz*20.), 0.));\n    return col;\n}\n\nvec3 lightColor(in vec3 pos){\n    vec3 color = vec3(0.);\n    color.r += min(1.,3./length(pos-redO));\n    color.rb += min(1.,3./length(pos-magO));\n    color.b += min(1.,6./length(pos-bluO));\n    color.rg += min(1.,2./length(pos-yelO));\n    return color;\n}\n\nvec3 window(in float angl, in vec3 pos){\n    float dh = pos.y-wallO.y-.25*wallR;\n    float an = fract(3.*angl/PI)-.5;\n    return vec3(0.522,0.581,1.000)*(smoothstep(-.9,-.8,-abs(abs(dh)-1.))*( smoothstep(-.04,-.03,-abs(abs(an)-.04)))+.2*(1.-smoothstep(.0,.4,abs(an))));\n    \n}\n\nvec3 winLitcolor(vec3 pos){\n    float r = length(pos.xz-wallO.xz)*.01;\n    if (r<2.5){\n    \tfloat a= fract(3.*atan(pos.z- wallO.z,pos.x - wallO.x)/PI)-.5;\n    \treturn vec3(0.087,0.626,1.000)*.3*smoothstep(-2.,-.0,-r)*smoothstep(.1,.8,r)*smoothstep(-.5,-.0,-abs(a))*smoothstep(-60.,.0,-pos.y+wallO.y);\n    }\n    else return vec3(0.);\n}\n\nvec3 stars(in float a,in vec3 ray){\n    vec2 star = vec2(a,ray.y*.7)*30.;\n    vec2 p = floor(star);\n    if(rand2(p,0.)>.97){\n        vec2 f = fract(star)-.5;\n    \treturn  vec3(.7*smoothstep(0.,.3,abs(fract(iTime*.3+3.*a)-.5))*ray.y * (smoothstep(-.01,-.0,-abs(f.x*f.y))+max(0.,.1/length(f)-.2)));\n    }\n\telse return vec3(0.);\n}\n\nvec3 boreal(in float a,in vec3 ray){\n    vec3 col = vec3(0.);\n    float b = .03*(asin(clamp(6.*a+12.,-1.,1.))+PIdiv2);\n    float c = .2*(asin(clamp(-.2*a*abs(a)-1.67222,-1.,1.))+2.042);\n    float d = .05*(a+1.)*(asin(clamp(a-1.,-1.,1.))+PIdiv2);\n    float rebord = smoothstep(1.83333,1.9,-a);\n    float rebord2 = smoothstep(-2.,-1.9,-a);\n    float var1 = (sin(1./(a+2.2)+a*30. + iTime)+1.)/2.+.5;\n    float var2 = (sin(a*10. - iTime)+1.)/2.+.5;\n    float var3 = (sin(1./(a+.04)+a*10. + iTime)+1.)/2.+.5;\n    col += 2.5*vec3(0.292,ray.y,0.1)*var1*smoothstep(b,b+.5*ray.y,ray.y)*smoothstep(-b-.9*ray.y,-b,-ray.y)*rebord;\n    col += 1.*vec3(.6-ray.y,.5*ray.y,0.15)*var2*smoothstep(c,c+.07,ray.y)*smoothstep(-c-.5,-c,-ray.y)*rebord;\n    col += 2.5*vec3(0.292,ray.y,0.1)*var3*smoothstep(d,d+.5*ray.y,ray.y)*smoothstep(-d-.9*ray.y,-d,-ray.y)*rebord2;\n    col *= .5+.5*smoothstep(-1.,0.,-fract(ray.y+iTime*.1*rand1(floor(a*300.))))*smoothstep(-.7,0.,-abs(fract(a*300.)-.5));\n\treturn col;\n}\n\nvec3 skyColor(in vec3 ray){\n    float a = atan(ray.z,ray.x);\n    vec3 color = skyGlow(ray);\n    color += stars(a,ray);\n    color += boreal(a, ray);\n    return color;\n}\n\nvec3 groundColor(in vec3 pos, in vec3 ray, in vec3 norm){\n    float len = length(pos.xz);\n    float dir = max(0.,dot(-lightRay,norm));\n    vec3 color = snowColor(pos)*(.8*dir+.2);\n    color *= .5+.5*pos.y/maxHill;\n    ray = reflect(ray, norm);\n    ray.y = max(0.,ray.y);\n    color = mix(.9*skyGlow(ray),color,.7);\n    color *= 1.-atan(len/10000.)/PIdiv2;\n    color += vec3(.4*max(ray.x+.7,0.), .35,.4)*(ray.x+1.5)*.4*atan(len/20000.)/PIdiv2;\n    color += .8*lightColor(pos);\n    color += winLitcolor(pos);\n\treturn color;\n}\n\n//**********************************************************************************\n// cotta functions *****************************************************************\nvec3 roofColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float an = atan((p.z - roofO.z),(p.x - roofO.x));\n    float lim = 6.*(.2*sin(6.*an)+1.1);\n    vec3 tile = (smoothstep(.0,.9, abs(fract(p.y)-.5))+smoothstep(0.,.7,abs(fract(20.*an+step(1., mod(p.y,2.0)) * 0.5)-.5)))*vec3(0.085,0.548,0.975);\n    vec3 color = step(-p.y+roofO.y,-lim)*tile + step(p.y-roofO.y,lim)*snowColor(p*5.);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += 1.5*vec3(0.029,0.560,0.975)*smoothstep(.5,1.,1.-dot(ray.xz,(roofO.xz-p.xz)/roofR));\n    color += vec3(0.029,0.560,0.975)*.7*smoothstep(-lim-4.,-lim,roofO.y-p.y)*step(-p.y+roofO.y,-lim);\n    color += vec3(0.102,0.147,0.975)*smoothstep(-3.,0.,-abs(roofO.y-p.y));\n    color += vec3(0.049,0.956,0.975)*.5*smoothstep(-1.,0.,-abs(roofO.y-p.y));\n    color += .8*lightColor(p);\n    return color;\n}\n\nvec3 wallColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float angl = atan((p.z - wallO.z),(p.x - wallO.x));\n    float lim = 1.3*(sin(2.*angl)+1.5);\n    vec3 tile = 2.*(smoothstep(0.,.6,abs(fract(p.y*2.)-.5))+(1.-smoothstep(0.,.1,abs(fract(2.*angl+iTime*rand1(floor(p.y*2.)))-.5))))*vec3(0.037,0.518,0.975);\n    vec3 color = step(p.y,lim)*snowColor(p*5.)*vec3(0.048,0.691,0.990) + step(-p.y,-lim)*tile;\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += window(angl, p);\n    color.b += .5*smoothstep(-lim,0.,-p.y);\n    color += .8*lightColor(p);\n    return color;\n}\n\nbool cottaImpact(in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    float tr = coneImpact(p, roofO, roofH, roofR, ray);\n    float tw = sphereImpact(p, wallO, wallR, ray);\n    float t = min(tr,tw);\n    if(t<T){\n        T=t;\n        p += t*ray;\n        impact = true;\n        if(t == tr){\n            hitObj = ROOF; \n            vec3 norm = normalize(vec3(p.x - roofO.x,roofR*roofR/(roofH*roofH)*(roofH + roofO.y - p.y),p.z-roofO.z));\n            color += .7*roofColor(p, ray, norm);\n        }\n        else{\n            hitObj = WALL;\n            vec3 norm = normalize(p-wallO);\n            color += wallColor(p, ray, norm);\n        }\n    }\n    return impact;\n}\n\n//******************************************************************************************\n// Snowman functions ***********************************************************************\nfloat drawPattern(in vec3 p, in vec3 obj){\n    float a = 4.*atan(p.z-obj.z,p.x-obj.x);\n    vec2 i = floor(vec2(a,p.y));  \n    vec2 f = fract(vec2(a,p.y));  \n\tfloat tile = pattern(f, rand2(i, iTime*.04));\n    return 1.5*(smoothstep(-.1,.0,-abs(tile-.05)));\n}\n\nvec3 bellyColor(in vec3 p, in vec3 ray, in vec3 norm, in vec3 belly){\n    vec3 color = snowColor(norm*30.);\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color *= (1.-step(-.5,-abs(p.z-belly.z))*step(0.,p.x-belly.x)* step(.9, fract((p.y-belly.y)*.4)));\n    color += vec3(0.995,0.234,0.177)*drawPattern(p, belO);\n    color += lightColor(p);\n    color += vec3(0.990,0.395,0.006)*1.5*smoothstep(-3.,0.,-abs(belO.y-1.-p.y));\n    return color;\n}\n\nvec3 headColor(in vec3 p, in vec3 ray, in vec3 norm, in vec3 head){\n    vec3 color = snowColor(norm*30.);\n    color -= (1.-step(.3,length(head.yz+vec2(1.5,1.5)-p.yz)))*step(hedO.x,p.x);\n    color -= (1.-step(.3,length(head.yz+vec2(1.5,-1.5)-p.yz)))*step(hedO.x,p.x);\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += vec3(0.995,0.234,0.177)*drawPattern(p, hedO)*step(-hedO.y+.4*exp(p.x-hedO.x-2.),-p.y);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 hatColor(in vec3 p, in vec3 ray, in vec3 norm){\n    vec3 color = snowColor(p*5.);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += smoothstep(-.3,.0,-abs(fract(p.y*.4)-.5))*vec3(0.995,0.336,0.308);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 nozColor(in vec3 p, in vec3 ray, in vec3 norm){\n    vec3 color = vec3(0.475,0.250,0.002);\n    color *= ((dot(vec3(0.,1.,0.),norm)+1.)*.4 + .2);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 flowpatern(in float a, in float y){\n    vec3 color = vec3(0.);\n    float i = floor(a/PI*10.);\n    float f = fract(a/PI*10.);\n    float s = rand1(i*1.22543)+.2;\n    float proba = rand1(i*1.3377+floor(3.*iTime*s+y/30.));\n    float pattern = smoothstep(-.2,-.1,-abs(f-.5))*rand1(floor((iTime+y)));\n    if(bool(step(.95,proba))) color += vec3(0.990,0.729,0.430)*.9*pattern;\n    else if(bool(step(.8,proba))) color += vec3(0.139,0.990,0.990)*0.3*pattern;\n    return color;\n}\n\nbool caracterImpact(in vec3 pos, in vec3 ray,inout vec3 color){\n    bool impact = false;\n    vec3 p = pos;\n    float tbel = sphereImpact(p, belO, belR, ray);\n    float thed = sphereImpact(p, hedO, hedR, ray);\n    float that = coneImpact(p, hatO, hatH, hatR, ray);\n    float tnoz = coneImpact(vec3(-p.y,p.x,p.z), vec3(-nozO.y,nozO.x,nozO.z), nozH, nozR, vec3(-ray.y,ray.x,ray.z));\n    float t = min(min(min(tbel,thed),that),tnoz);\n    if(t<T){\n        T=t;\n        p += t*ray;\n        impact = true;\n        hitObj = SNOWMAN;\n        if(t == tbel){\n            vec3 norm = normalize(p - belO);\n            color += bellyColor(p, ray, norm, belO);\n        }\n        else if(t == thed){\n            vec3 norm = normalize(p - hedO);\n            color += headColor(p, ray, norm, hedO);\n        }\n        else if(t == that){\n            vec3 norm;\n            norm.xz = p.xz - hatO.xz;\n            norm.y = 0.;\n            norm = normalize(norm);\n            color += hatColor(p, ray, norm);\n        }\n        else{\n            vec3 norm;\n            norm.yz = p.yz - nozO.yz;\n            norm.x = 0.;\n            norm = normalize(norm);\n            color += nozColor(p, ray, norm);\n        }\n    }\n\n    return impact;\n}\n\n//**************************************************************************************\n// Tree functions **********************************************************************\n\nvec3 treeColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float lim = 40.*(.05*sin(.6*p.x)+.5);\n    vec3 color = step(-p.y+treeO.y,-lim)*snowColor(fract(p*5.)) + step(p.y-treeO.y,lim)*vec3(0.019,0.966,0.975);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .1);\n    color += .8*lightColor(p);\n    \n    float border = 1.-dot(ray.xz,(treeO.xz-p.xz)/treeR);\n\tcolor.b += smoothstep(.5,1.,border);\n    color += .3*smoothstep(.7,1.,border);\n    color += .3*smoothstep(-lim-4.,-lim,treeO.y-p.y)*step(-p.y+treeO.y,-lim);\n    color += vec3(0.019,0.966,0.975)*.7*smoothstep(-20.,0.,-abs(treeO.y-p.y));\n\tcolor *= 1.-atan(length(p)/10000.)/PI*2.;\n    return color;\n}\n\nbool getTree(in vec2 cell,inout vec3 treeO, inout float treeH, inout float treeR){\n    bool treeOk = bool(step(TREE_DENSITY,rand2(cell*1.331,1.))) && cell != cottaCell;\t\t\t// check if object depending cell coords\n        if (treeOk){ \n            treeH = (.7*rand2(cell*3.86,0.)+.3)*maxTreeH;\n            treeR = .15*treeH;\n            float lim = (1.-2.*treeR/cellD);\n            treeO = vec3(lim*(rand2(cell*2.23,0.) - 0.5) + cell.x, 0., lim*(rand2(cell*1.41,0.) -0.5)  + cell.y) *cellD;\n            treeO.y += ground(treeO.xz)-11.;\n        }\n    return treeOk;\n}\n\nbool treeImpact(in vec2 cell, in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    bool tree = getTree(cell,treeO, treeH, treeR);\n    if(tree){\n        float t = coneImpact(p, treeO, treeH, treeR, ray);\n        if(t<T){\n            T=t;\n            hitObj = TREE;\n            impact = true;\n            p += t*ray;\n            vec3 norm = normalize(vec3(p.x - treeO.x,treeR*treeR/(treeH*treeH)*(treeH + treeO.y - p.y),p.z-treeO.z));\n            color += .5*treeColor(p, ray, norm);\n        }\n    }\n    return impact;\n}\n\n//***************************************************************************************************\n// fairy light functions ****************************************************************************\nvec3 fairyReflect(in vec3 ray,in vec3 norm){\n    vec3 r = reflect(ray,norm);\n    r.y = abs(r.y);\n    return skyGlow(r);\n}\n\n// thanks to Dave Hoskins...\n// https://www.shadertoy.com/view/MdlXz8\n// function used to render fairyligths surface and path\nfloat electric(in vec2 p){\n\tp = mod(p*TwoPI, TwoPI)-250.0;\n\tvec2 i = p;\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < 5; n++) \n\t{\n\t\tfloat t = 2.*iTime * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1./length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= 5.;\n\tc = 1.12-pow(c, 1.2);\n\treturn pow(abs(c), 8.0);\n}\n//...\n\n\n// set color and render of lights\nvec3 fairyLight(in vec3 ray,in vec3 pos,in int hitObj){\n    float cs;\n    vec3 norm;\n    vec3 refl;\n    vec3 col=vec3(0.);\n    if (hitObj == REDL){\n        vec3 v = pos - redO;\n    \tfloat a = atan(v.x,v.z);\n        col.r += electric(vec2(a/PI+.5, v.y/redR+.5));\n        norm = normalize(redO-pos);\n        col += .5*fairyReflect(ray,norm);\n\t\tcs = dot(ray,norm);\n        col.r += .2*smoothstep(-1.,0.,-cs);\n    }\n    else if (hitObj == MAGL){\n        vec3 v = pos - magO;\n    \tfloat a = atan(v.x,v.z);\n        col.rb += electric(vec2(a/PI+.5, v.y/magR+.5));\n        norm = normalize(magO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col.rb += .2*smoothstep(-1.,0.,-cs);\n    }\n    else if (hitObj == BLUL){\n        vec3 v = pos - bluO;\n    \tfloat a = atan(v.x,v.z);\n        col += vec3(0.,.3,1.)*electric(vec2(a/PI+.5, v.y/bluR+.5));\n        norm = normalize(bluO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col += vec3(0.,.3,1.)*.3*smoothstep(-1.,0.,-cs);\n    }\n\telse if (hitObj == YELL){\n        col.rg += .15;\n        norm = normalize(yelO-pos);\n        cs = dot(ray,norm);\n        col.rg += .3*smoothstep(-1.,0.,-cs);\n    }\n    return col;\n}\n\n// specific raytracing for the lights with transparency parameter\n// if trans = obj then this obj is ignored (transparent)\nfloat lightTrace(in vec3 pos, in vec3 ray,inout int hitLit, in int trans){\n    float t = INFINI, tp; \t\n    \n    if(trans != REDL){\n    \t\ttp = sphereImpact(pos, redO, redR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = REDL;\n    \t\t}\n        }\n    if(trans != MAGL){\n    \t\ttp = sphereImpact(pos, magO, magR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = MAGL;\n    \t\t}\n        }\n    if(trans != BLUL){\n    \t\ttp = sphereImpact(pos, bluO, bluR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = BLUL;\n    \t\t}\n        }\n    if(trans != YELL){\n    \t\ttp = sphereImpact(pos, yelO, yelR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = YELL;\n    \t\t}\n        }\n\n    return t;\n}\n\n//**************************************************************************************\n// Space is divided by a grid. Each element (or cell) of the grid may content one object\n// (for ex: tree) or nothing. Raytracing occur only in local cell if an object is present.\n// Allow lots of objects with only few raytraced object.\n// see demo: https://www.shadertoy.com/view/XdffRN\n\n// Key function to find the next cell of the grid\nvec2 getNextCell(in vec2 p, in vec2 v, in vec2 cell){\n    vec2 d = sign(v);\n\tvec2 dt = ((cell+d*.5)*cellD-p)/v;\n    d *= vec2( step(dt.x-0.02,dt.y) , step(dt.y-0.02,dt.x) );\t\t// -0.020 to avoid cell change for epsilon inside\n    return cell+d;\n}\n\n// call the involved ratrace funtion, depending of kind of object present in cell of the grid\nbool checkCell(in vec2 cell, in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    if(cell == cottaCell) impact = cottaImpact(p, ray, color);   \n    else if(cell == snowmanCell) impact = caracterImpact(p, ray, color);\n    else impact = treeImpact(cell, p, ray, color);\n    return impact;\n}\n\n//**************************************************************************************\n// Fairy lights and camera trajectory management\n\n// to circle around an object\nvec3 circle(in float ti, in vec3 obj){\n    return vec3(80.*cos(ti*TwoPI) + obj.x, 0., 80.*sin(ti*TwoPI) + obj.z);\n}\n\n// kind of free flight\nvec3 freetrack(in float time){\n    return vec3(3000.*cos(time*.02), 0., 3200.*sin(time*.07));\n}\n\n// to smoothly change the trajectory to circle fligth to free flight (or reverse)\nvec3 transfer(in vec3 tr1, in vec3 tr2, in float dti, in float period){\n    float ang = dti*period*PI;\n    return tr1*(1.+cos(ang))/2. + tr2*(1.+cos(ang+PI))/2.;\n}\n\n// track of the lights\n// sometime circle around object, sometime free flight\nvec3 getTrac(in float time){\n    float ti = 27.*fract(time*.01);\n    vec3 track;\n    \n    if(ti<1.) track = circle(ti,wallO);\n    else if(ti<9.) track = transfer(circle(ti,wallO), freetrack(time), ti-1., .125); \t// .125 = 1/(9-1)\n    else if(ti<14.) track = freetrack(time);\n    else if(ti<22.) track = transfer(freetrack(time), circle(ti,hedO), ti-14.,.125);\t// .125 = 1/(22-14)\n    else if(ti<23.) track = circle(ti,hedO);\n    else track = transfer(circle(ti,hedO), circle(ti,wallO), ti-23.,.25);\n       \n    return track;\n}\n\n// track of the camera\n// not the same as fairylight to avoid to get sick when ligth are turning around objects\n// when lights circling, cam is fixed on the object\nvec3 getCam(in float time, in vec3 track){\n    float ti = 27.*fract(time*.01);\n    vec3 cam;\n    \n    if(ti<1.) cam = wallO;\n    else if(ti<5.) cam = transfer(wallO, track, ti-1., .25);\t// .25 = 1/(5-1)\n    else if(ti<18.) cam = track;\n    else if(ti<22.) cam = transfer(track, hedO, ti-18., .25);\n    else if(ti<23.) cam = hedO;\n    else cam = transfer(hedO, wallO, ti-23., .25);\t// .25 = 1/(27-23)\n    \n    return cam;\n}\n\n// local flight of fairylight aroud the main track\nvec3 flyR(in float time){return vec3(20.*sin(time*2.),5.*sin(time*3.),10.*cos(time*2.));}\nvec3 flyM(in float time){return vec3(10.*sin(1.+time*2.),4.*sin(1.6+time*3.),15.*cos(1.+time*2.));}\nvec3 flyB(in float time){return vec3(10.*sin(5.+time*3.),2.*sin(3.+time*2.),10.*cos(5.+time*3.));}\nvec3 flyY(in float time){return vec3(30.*sin(time*3.),abs(15.*sin(time*4.)+4.),20.*cos(time*3.));}\n\n// BACK IN TIME...\n// to generate the glowing path behind the fairiylights\n// without using buffer\nfloat glowTrack(in vec2 obj, in vec2 pos, in int lit){\n    float d = length(obj.xy-pos.xy);\t//current distance from obj at time now\n    \t\t\t\t\t\t\t\t\t// at the speed of the obj, this distance represent a certain amount of time\n    \t\t\t\t\t\t\t\t\t// objective: come back in time to check if position was on the obj path.\n    \n    // first : finding obj speed by derivation dp/dt\n    float past = iTime-.2; //dt\n    // what was the obj position a little time ago (dp)\n    vec2 delta = (getTrac(past)).xz;\n    if(lit == REDL) delta += flyR(past).xz;\n    else if(lit == MAGL) delta += flyM(past).xz;\n    else if(lit == BLUL) delta += flyB(past).xz;\n    \n    // obj speed : dp/dt (here dt = .2)\n    float v = length(obj.xy-delta.xy)/.2;\n    \n    // finding \"time\" to the object at obj speed\n    float backInTime = d/v;\n    float oldTime = iTime-backInTime;\n    \n    // finding obj. pos at this old time\n    vec2 oldTrac = (getTrac(oldTime)).xz;\n    if(lit == REDL) oldTrac += flyR(oldTime).xz;\n    else if(lit == MAGL) oldTrac += flyM(oldTime).xz;\n    else if(lit == BLUL) oldTrac += flyB(oldTime).xz;\n    \n    // finding distance from obj when at this old time\n    float l = length(oldTrac.xy-pos.xy);\n    // if pos was close to obj, then pos is on the track\n    // intensity of the color depends how long before it was... \n    float glow = 1.-step(10.,l);\n    if(bool(glow)) return (1.-smoothstep(2.,10.,l))*(1.-smoothstep(0.,2.,backInTime))*electric(pos.xy*.02);\n    else return 0.;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n        \n    // object def\n    \n    //cotta\n    wallO = vec3(400.,4.,-600.);\n    wallO.y += ground(wallO.xz);\n    wallR = 20.;\n    roofO = wallO+vec3(0.,8.,0.);\n    roofH = 42.;\n    roofR = 22.;\n    cottaCell = vec2(4.,-6.);   //floor(wallO.xz/cellD + .5);\n    \n    //SnowMan\n    belO = vec3(200.,4.,100.);\n    belR = 10.;\n    belO.y = ground(belO.xz);\n    hedO = belO+vec3(0.,13.,0.);\n    hedR = 5.;\n    hatO = belO+vec3(0.,16.,0.);\n    hatH = 15.;\n    hatR = 3.8;\n    nozO = belO+vec3(4.,13.,0.);\n    nozH = 4.;\n    nozR = .8;\n    snowmanCell = vec2(2.,1.);\t\t//floor(belO.xz/cellD + .5);\n    \n    //light\n    vec3 trac = getTrac(iTime);\n    trac.y += ground(trac.xz)+15.;\n    vec3 tracb = getTrac(iTime-.5);\n    tracb.y += ground(tracb.xz)+1.;\n    redO = trac + flyR(iTime);\n    redR = 3.;\n    magO = trac + flyM(iTime);\n    magR = 3.;\n    bluO = trac + flyB(iTime);\n    bluR = 3.;\n    yelO = tracb + flyY(iTime);\n    yelR = 1.;\n    \n    //vec3 camTarget = trac;\n    //vec3 camTarget = tracb;\n    //vec3 camTarget = wallO*(1.+sin(iTime*.2))/2. + trac*(1.+sin(iTime*.2+PI))/2.;\n    //vec3 camTarget = redO;\n    //vec3 camTarget = bluO;\n    //vec3 camTarget = yelO;\n    //vec3 camTarget = (trac+wallO)/2.;\n    //vec3 camTarget = wallO;\n    //vec3 camTarget = roofO;\n    //vec3 camTarget = hedO;\n    //vec3 camTarget = CtreeO+vec3(0.,50.,0.);\n    vec3 camTarget = getCam(iTime, trac);\n    \n    // camera def\n    float \tfocal = 1.;\n    float \trau = 300.*(sin(iTime/7.)+1.) + 50.,\n    \t\t//rau = 80.,\n    \t\talpha,\n    \t\ttheta;\t\n    // to start shader\n    if (iMouse.xy == vec2(0.)){\n        alpha = PIdiv2;\n        theta = .3;\n    }\n    else{\n        alpha = iMouse.x/iResolution.x*4.*PI/*-iTime/5.*/,\n    \ttheta = -iMouse.y/iResolution.y*PIdiv2+PIdiv2-.2;//(sin(iTime/7.)/2.+0.5)*(PI/2.-1.)+0.05;\n    }\n    \n    vec3 pos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha)) + camTarget;\n\tpos.y = max(ground(pos.xz)+15.,pos.y);\t\t//anti-collision\n    \n    vec3 ww = normalize( camTarget - pos );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n    \n\tlightRay = vec3(1.,0.,0.);\t// global var\n\tvec3 GNDnorm = vec3(0.);\n    \n    vec3 color = vec3(.0);\n        \n    vec2 cell, outCell;\n    vec3 p = pos;\n    \n    // first step getting boundarry of interesting areas\n    // find exit cell\n\n    T = gndRayTrace(pos, N_ray);\n    if(T<INFINI){\n        hitObj = GND;\n        vec3 tp = pos+T*N_ray;\n        cell = floor(tp.xz/cellD + .5);\n        outCell = getNextCell(pos.xz,N_ray.xz,cell);\n    }\n    else if(pos.y<cellH){\n        T = sfcImpact(pos, N_ray, cellH);\n        if(T<INFINI){\t\t\t\t\t\t\t\t\t// hitObj = SKY already default value\n            vec3 tp = pos+T*N_ray;\n            cell = floor(tp.xz/cellD + .5);\n            outCell = getNextCell(pos.xz,N_ray.xz,cell);\n            T = INFINI;\t\t\t\t\t\t\t\t\t// T consistant with SKY\n        }\n    }\n    else outCell = floor(pos.xz/cellD + .5);\n\t\n    //if cam above ceiling, find entry cell\n    // ceiling is the upper most top of object\n    // no need the grid above ceiling - no objects possible\n    if(pos.y>=cellH){\n        float t = sfcImpact(pos, N_ray, cellH);\n        if(t<INFINI){\n            p = pos+t*N_ray;\n        }\n    }\n    \n    // MAIN PROCESS\n    // going thru the grid checking for existing object in each cell\n    // if obj: raytrace\n    // if impact: stop the ray\n    // else going again thru the grid\n    bool objImpact = false;\n    cell = floor(p.xz/cellD + .5);\n    for(int i=0; i<maxCell;i++){\n        if(cell == outCell) break;\n        objImpact = checkCell(cell, pos, N_ray, color);\n        if(objImpact) break;\n        cell = getNextCell(pos.xz,N_ray.xz,cell);\n    } \n    \n    // Final position reach by the ray\n    // if object in grid has been hit, color and rendering already (localy) done\n    // if no object, just check for ground hit or sky\n    vec3 finalPos = pos + T*N_ray;\n    \n    if(hitObj == SKY) color += skyColor(N_ray);\n    else if(hitObj == GND){\n        GNDnorm = getGndNormal(finalPos.xz,finalPos.y);\n        color += groundColor(finalPos, N_ray, GNDnorm);\n        float shad = 1.-atan(length(finalPos.xz - pos.xz)/20000.)/PI*1.5;\n        float cut = step(.8,shad);\n\t\t\n        // level lines\n        color.b += .5*smoothstep(-.2,0.,-abs(fract(finalPos.y/cellD*10.)-.5))*shad;\n        \n        // blue pulse line\n        float line = -abs((sin(finalPos.x*.004)+2.)*fract(finalPos.z*.002)-.5);\n        float pulse = fract(.0002*finalPos.x-iTime*.1+3.*sin(floor(finalPos.z*.002)));\n        color.gb += .3*smoothstep(-.01,0.,line)*shad;\n        color.gb += smoothstep(-.02,0.,line) *smoothstep(.98,1.,pulse)*shad;\n        \n    \tvec2 finalCell = floor(finalPos.xz/cellD + .5);\n        // cotta halo\n        if(finalCell == cottaCell)\n            color.b += .8*max(0.,3./(length(wallO.xz-finalPos.xz)-wallR+3.)-.1);\n        // trees halo\n        if(getTree(finalCell,treeO, treeH, treeR)){\n            float glow = max(0.,(2./(length(treeO.xz-finalPos.xz)-treeR+2.)-.1));\n            //color += vec3(0.019,0.966,0.975)*glow*shad*cut;\n    \t\tcolor.gb += 2.*glow*smoothstep(-.4,0.,line)*smoothstep(.0,2.,pulse)*shad*cut;\n        }\n    \t// Snowman halo\n        if(finalCell == snowmanCell)\n            color += .8*vec3(0.990,0.395,0.006)*max(0.,3./(length(belO.xz-finalPos.xz)-belR+1.)-.1);\n    \n        \n        // glowing multi-track\n        // lag behind fairyligths\n        color.r += glowTrack(redO.xz, finalPos.xz, REDL);\n        color.rb += glowTrack(magO.xz, finalPos.xz, MAGL);\n        color.b += 2.*glowTrack(bluO.xz, finalPos.xz, BLUL);\n        \n    }\n    \n    // cylinder of data aroud snowman\n    // done in global matter instead of grid, because grid height is limited to celling (maxHeight)\n    vec2 tc = cylinderImpact(pos.xz, belO.xz, belR, N_ray.xz);\n\tif(tc.x < T){\n        vec3 cpos = pos + tc.x*N_ray;\n        color += vec3(0.990,0.395,0.006)*2./(cpos.y-belO.y+1.);\n        float a  = atan(cpos.z-belO.z, cpos.x-belO.x);\n        color += flowpatern(a, cpos.y);\n    }\n    if(tc.y < T){\n        vec3 cpos = pos + tc.y*N_ray;\n        float a  = atan(cpos.z-belO.z, cpos.x-belO.x);\n        color += .5*flowpatern(a, cpos.y);\n    }\n    \n        \n    // getting lights position (lights independant of cells)\n    int lightNbr;\n    float tlit;\n    tlit = lightTrace(pos,N_ray,lightNbr,0);\t\t// 0 means no transparency requested\n    \n    if(tlit<T){\n        hitObj = lightNbr;\n        vec3 trpos = pos + tlit*N_ray; \n        // adding fairy lights\n    \tcolor += 1.5*fairyLight(N_ray, trpos, hitObj);\n        tlit = lightTrace(pos,N_ray,lightNbr,hitObj);\t\t// hitObj means transparency requested for this obj\n        if(tlit<INFINI){\t\t\t\t\t\t\t\t\t// to make visible the fairy light behind\n            trpos = pos + tlit*N_ray;\n        \tcolor += fairyLight(N_ray, trpos, lightNbr);\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 14687,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/andrewgavrilets/01-carbon-based-lifeforms"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}