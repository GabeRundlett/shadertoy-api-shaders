{
    "Shader": {
        "info": {
            "date": "1608307886",
            "description": "Phase portrait of the complex plane and applying a few iterations of z^2+c.",
            "flags": 0,
            "hasliked": 0,
            "id": "3t3cRr",
            "likes": 6,
            "name": "Mandelbrot domain coloring",
            "published": 3,
            "tags": [
                "mandelbrot",
                "domain",
                "coloring"
            ],
            "usePreview": 0,
            "username": "darkeclipz",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "// https://users.mai.liu.se/hanlu09/complex/domain_coloring.html\n\n#define R iResolution.xy\nfloat pi = 3.14159;\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y - vec2(.5, 0);\n    float t = iTime + 6.;\n    float w = -cos(t / 4.)*.5+.5;\n    \n    // Apply function\n    vec2 z = vec2(0.0), c = uv;\n    for(int i=0; i < 1 + int(16.*w); i++) {\n        z = cpow(z, 2.0) + c;\n    }\n    uv = z;\n    \n    // Calculate polar coordinates\n    float r = sqrt(dot(uv, uv));\n    float theta = atan(uv.y, uv.x+0.000000001);\n    \n    // Normalize theta\n    float thetaNorm = (pi + theta) / (2.*pi);\n    \n    // Color the angle based on rainbow colors, and show the distance\n    float absW = fract(log2(length(uv)));\n    vec3 col = hsb2rgb(vec3(thetaNorm, 1., 1.));\n    // col *= * (0.1*absW + 0.9);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}