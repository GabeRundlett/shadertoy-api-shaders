{
    "Shader": {
        "info": {
            "date": "1564807387",
            "description": "Thought I'd have a go at ray-marching a signed distance field.\nVery much based on iq's work and tutorials.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl2XzR",
            "likes": 2,
            "name": "Spheres and box raymarch test",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf"
            ],
            "usePreview": 0,
            "username": "tmulgrew",
            "viewed": 531
        },
        "renderpass": [
            {
                "code": "const float screenDist = 0.5;\t\t\t\t\t\t\t// Screen distance as a fraction of screen width\nconst vec3 light = normalize(vec3(-0.5, -0.7, -0.2));\nconst int stepCount = 256;\nconst float tmin = 0.01;\nconst float tmax = 200.0;\nconst float pi = 3.14159265;\n\n\nfloat mapsphere(in vec3 p, in vec3 center, float rad) {\n\treturn length(p - center) - rad;   \n}\n\nfloat mapbox(in vec3 p, in vec3 center, in vec3 size) {    \n    vec3 a = abs(p - center) - vec3(size);\n    return max(a.x, max(a.y, a.z));\n}\n\nfloat mapcube(in vec3 p, in vec3 center, float size) {\n \treturn mapbox(p, center, vec3(size));   \n}\n\nfloat mapplane(in vec3 p, in vec3 center, in vec3 n) {\n\treturn dot(p - center, n);\n}\n\nvec3 rotx(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nvec3 roteuler(in vec3 p, in vec3 euler) {\n \treturn roty(rotx(rotz(p, euler.z), euler.y), euler.z);   \n}\n\nvec4 minp(in vec4 a, in vec4 b) {\n\treturn a.w < b.w ? a : b;   \n}\n\nbool checkerboard(in vec2 p) {\n\tfloat x = mod(p.x, 2.0);\n    if (x < 0.0) x += 2.0;\n    float y = mod(p.y, 2.0);\n    if (y < 0.0) y += 2.0;\n    return (x < 1.0) == (y < 1.0);\n}\n\nvec4 map(in vec3 p) { \n    vec4 sphere = vec4(0, 0, 0, 1000);\n    for (int i = 0; i < 10; i++) {\n        float a = float(i) * 2.0*pi / 10.0;\n        float a2 = a + iTime * 0.4;\n        vec3 center = vec3(sin(a2), 0.0, cos(a2)) * 5.0 + vec3(0, 2.0 + sin(float(i)), -10);\n        vec3 col = vec3(sin(a), sin(a + 2.2), sin(a + 4.4)) * 0.75 + vec3(0.5);\n     \tsphere = minp(sphere, vec4(col, mapsphere(p, center, 1.0)));\n    }\n    \n    const vec3 boxCol = vec3(0.6);    \n    vec3 ccenter = vec3(0, 4.0 + sin(iTime) * 1.0,-10);\n    vec3 boxp = ccenter + roteuler(p - ccenter, vec3(iTime * 0.2, iTime * 0.7, iTime * 1.1) * 0.3);\n    vec4 box = vec4(boxCol, mapbox(boxp, ccenter, vec3(3, 2, 0.75)));\n    box.w = max(box.w, 1.0 - length(boxp.xy - ccenter.xy));\n    box.w = max(box.w, 0.5 - length(boxp.yz - ccenter.yz));\n    box.w = max(box.w, 0.5 - length(boxp.xz - ccenter.xz));\n\n    const vec3 planeCol1 = vec3(0, 0.5, 0.75);\n    const vec3 planeCol2 = vec3(0.7, 0.8, 1);\n    vec4 plane = vec4(\n        checkerboard(p.xz * 0.5) ? planeCol1 : planeCol2, \n        p.y - -2.0);\n    \n    return minp(sphere, minp(box, plane));\n}\n\nvec3 getNormal(in vec3 p, float t) {\n    \n\t// Calculate pixel size at point distance. \n    // This will be the distance of the normal samples from the original point.\n    float s = 0.1 / t;\n    \n    // Sample relative distance along each axis\n    float d = map(p).w;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        map(p + vec3(s,0,0)).w - d,\n        map(p + vec3(0,s,0)).w - d,\n        map(p + vec3(0,0,s)).w - d);\n    \n    return normalize(r);\n}\n\nvec3 getScreenRay(in vec2 s) {\n    s -= iResolution.xy / 2.0;\n    return vec3(s / (screenDist * iResolution.x), -1);\n}\n\nvec4 march(in vec3 from, in vec3 delta) {\n    float t = tmin;    \n    for (int i = 0; i < stepCount && t < tmax; i++) {\n     \tvec3 p = from + delta * t;\n        vec4 d = map(p);\n        if (abs(d.w) <= 0.0005 * t)\n            return vec4(d.xyz, t);\n        t += d.w;\n    }\n    \n    return vec4(vec3(0),-1);    \n}\n\nfloat shadow(in vec3 from, in vec3 delta, float k) {\n    float res = 1.0;\n    float t = tmin;    \n    for (int i = 0; i < stepCount && t < tmax; i++) {\n     \tvec3 p = from + delta * t;\n        float d = map(p).w;\n        if (d <= 0.0)\n            return 0.0;\n        res = min(res, k*d/t);\n        t += d;\n    }\n    \n    return res;\n}\n\n// Crude lighting equation\nfloat lighting(in vec3 e, in vec3 n, float diffuse, float specular, float shiny) {\n    \n    // Diffuse term\n    float d = dot(n, -light) * diffuse;\n    \n    // Specular term\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), shiny) * specular;\n\n    return max(d + s, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 fogCol = vec3(0.0, 0.0, 0.2);\n    const float r = 0.6;\n\n    float ang = iTime * 0.03;\n    vec3 from = vec3(0, 3, -10) + roty(vec3(0, 0, 12), ang);\n    vec3 dir = normalize(roty(rotx(getScreenRay(fragCoord), 0.1), ang));\n    \n    vec3 sumCol = vec3(0);\n    float sumf = 1.0;\n    for (int bounce = 0; bounce < 4; bounce++) {    \n        vec4 d = march(from, dir);\n\n        if (d.w < 0.0)\n            break;\n        \n\t\t// Position and normal\n        vec3 p = from + dir * d.w;\n        vec3 n = getNormal(p, d.w);\n\n        // Lighting\n        float l = lighting(dir, n, 1.5, 2.0, 10.0);\n        if (l > 0.0) {\n            // Shadow ray\n            float s = shadow(p, -light, 16.0);\n            l *= s;\n        }\n\n        vec3 col = d.xyz * min(l + 0.2, 1.0);\n        col *= r;\n\n        // Fog\n        float fog = clamp(d.w * d.w / 1200.0, 0.0, 1.0);\n        col = mix(col, fogCol, fog);\n        \n        // Add to sum\n        sumCol += col*sumf;\n        \n        // Calculate reflection vector\n        from = p;\n        dir = normalize(reflect(dir, n));\n  \n        sumf *= (1.0 - r) * (1.0 - fog);\n    }\n    \n    sumCol += fogCol * sumf;\n    \n    fragColor = vec4(sumCol, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}