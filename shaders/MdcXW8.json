{
    "Shader": {
        "info": {
            "date": "1715553585",
            "description": "A revisit to Monte Carlo ray tracing. Not using distance fields this time for speed. Not sure if it really is \"faster\" though. Changing MIN_DELTA, and/or MAX_DISTANCE will not effect speed.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdcXW8",
            "likes": 0,
            "name": "Minimalist II",
            "published": 3,
            "tags": [
                "raytracing",
                "montecarlo"
            ],
            "usePreview": 0,
            "username": "mgattis",
            "viewed": 114
        },
        "renderpass": [
            {
                "code": "// Max ray cast = MAX_REFLECTIONS * MAX_SAMPLES * 2\n\n// This scene is ray traced, so MAX_DISTANCE and MIN_DELTA don't really effect perfomance.\n// Lower the reflections and samples for better performance.\n#define MAX_DISTANCE        (16.0)\n#define MIN_DELTA           (1e-5)\n#define MAX_REFLECTIONS     (4)\n#define MAX_SAMPLES         (64)\n\n// Background\n#define BG_DIRECTION            (vec3(0.0, 0.0, 1.0))\n#define BG_COLOR1               (vec3(1.0, 1.0, 1.0))\n#define BG_COLOR2               (vec3(0.0, 0.5, 1.0))\n#define BG_COLOR3               (vec3(1.0, 1.0, 1.0))\n\n#ifndef M_PI\n#define M_PI                (3.1415926535897932384626433832795)\n#endif\n\n// Fun options to play with\n#define ALBEDO              (0.5)\n#define SHADOW_FUZZ         (0.002)\n#define REFLECT_FUZZ        (0.01) /* 1.0 = Diffuse, 0.0 = Mirrored. */\n#define USE_CUBEMAP\n\nvec2 seed;\n\nfloat rand(float p)\n{\n    return fract(sin(dot(vec2(p - 1.0, p + 1.0) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2n()\n{\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n        fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 ortho(vec3 v)\n{\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3 dir, float power)\n{\n    dir = normalize(dir);\n    vec3 o1 = normalize(ortho(dir));\n    vec3 o2 = normalize(cross(dir, o1));\n    vec2 r = rand2n();\n    r.x=r.x*2.*M_PI;\n    r.y=pow(r.y,1.0/(power+1.0));\n    float oneminus = sqrt(1.0-r.y*r.y);\n    return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n \nvec3 getSample(vec3 dir)\n{\n    return getSampleBiased(dir,0.0); // <- unbiased!\n}\n\nvec3 getCosineWeightedSample(vec3 dir)\n{\n    return getSampleBiased(dir,1.0);\n}\n\nvec3 getConeSample(vec3 dir, float extent)\n{\n    // Formula 34 in GI Compendium\n    dir = normalize(dir);\n    vec3 o1 = normalize(ortho(dir));\n    vec3 o2 = normalize(cross(dir, o1));\n    vec2 r =  rand2n();\n    r.x=r.x*2.*M_PI;\n    r.y=1.0-r.y*extent;\n    float oneminus = sqrt(1.0-r.y*r.y);\n    return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 vRotateX(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c*p.y + s*p.z, -s*p.y + c*p.z);\n}\n\nvec3 vRotateY(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nvec3 vRotateZ(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x + s*p.y, -s*p.x + c*p.y, p.z);\n}\n\nfloat sphere(in vec3 o, in vec3 d, in float r, out vec3 n)\n{\n    float a = dot(d, o);\n    float b = a * a - dot(o, o) + r * r;\n    if (b < 0.0)\n    \treturn MAX_DISTANCE + 1.0;\n    float c = sqrt(b);\n    float l = -a + c;\n    float e = -a - c;\n    float f = min(l, e);\n    if (f < 0.0)\n    {\n        float g = max(l, e);\n        if (g < 0.0)\n            return MAX_DISTANCE + 1.0;\n        n = normalize(o + d * g);\n        return g;\n    }\n    n = normalize(o + d * f);\n    return f;\n}\n\nfloat plane(in vec3 o, in vec3 d, out vec3 n)\n{\n    n = vec3(0.0, 0.0, 1.0);\n    float t = -dot(o, n) / dot(d, n);\n    if (t < 0.0)\n        return MAX_DISTANCE + 1.0;\n    return t;\n}\n\nint castRay(in vec3 origin, in vec3 direction, out float distance, out vec3 normal)\n{\n    distance = MAX_DISTANCE;\n    float tempDist;\n    \n    normal = -direction;\n    vec3 tempNormal;\n    \n    int object = 0;\n\n    tempDist = sphere(origin - vec3(-2.5, 0.0, 1.0), direction, 1.0, tempNormal);\n    if (tempDist < distance)\n    {\n        object = 1;\n        distance = tempDist;\n        normal = tempNormal;\n    }\n    \n    tempDist = sphere(origin - vec3(0.0, 0.0, 1.0), direction, 1.0, tempNormal);\n    if (tempDist < distance)\n    {\n        object = 2;\n        distance = tempDist;\n        normal = tempNormal;\n    }\n    \n    tempDist = sphere(origin - vec3(2.5, 0.0, 1.0), direction, 1.0, tempNormal);\n    if (tempDist < distance)\n    {\n        object = 3;\n        distance = tempDist;\n        normal = tempNormal;\n    }\n    \n    tempDist = plane(origin, direction, tempNormal);\n    if (tempDist < distance)\n    {\n        object = 4;\n        distance = tempDist;\n        normal = tempNormal;\n    }\n    \n    return object;\n}\n\nvec3 getBackground(in vec3 direction)\n{\n#ifdef USE_CUBEMAP\n    return texture(iChannel1, -direction.xzy).rgb;\n#endif\n    \n    float bgVal = dot(direction, BG_DIRECTION);\n    \n    if (bgVal >= 0.0)\n    {\n        bgVal = pow(1.0 - bgVal, 2.5);\n        return mix(BG_COLOR2, BG_COLOR1, bgVal);\n    }\n    \n    return BG_COLOR1;\n}\n\nvec3 getSurfaceColor(in vec3 position, in vec3 direction, in int object)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    if (object == 1)\n    {\n        return vec3(1.0, 0.2, 0.2);\n    }\n    else if (object == 2)\n    {\n        return vec3(0.2, 1.0, 0.2);\n    }\n    else if (object == 3)\n    {\n        return vec3(0.2, 0.2, 1.0);\n    }\n    else if (object == 4)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    \n    return color;\n}\n\nvec3 drawScene(in vec2 uv, in vec3 origin, in vec3 direction)   \n{\n    const vec3 LightVec = normalize(vec3(1.0, 1.0, 2.0));\n    \n    vec3 finalColor = vec3(1.0, 1.0, 1.0);\n    vec3 directLight = vec3(0.0, 0.0, 0.0);\n    \n    int object;\n    float distance;\n    vec3 normal;\n    \n    object = castRay(origin, direction, distance, normal);\n    vec3 position = origin + direction * distance;\n    \n    vec3 rayPosition = position;\n    vec3 rayDirection = direction;\n    vec3 rayNormal = normal;\n    float rayDistance = distance;\n    int rayObject = object;\n    \n    for (int i = 1; i < MAX_REFLECTIONS; i++)\n    {\n        seed = uv * (float(i) + float(iFrame));\n        \n        if (rayObject == 0)\n        {\n            finalColor = directLight + finalColor * getBackground(rayDirection);\n            float fogVal = pow(distance / MAX_DISTANCE, 16.0);\n            finalColor = mix(finalColor, getBackground(direction), fogVal);\n            return finalColor;\n        }\n        \n        finalColor *= getSurfaceColor(rayPosition, rayDirection, rayObject) * ALBEDO;\n\n        vec3 newReflection = normalize(reflect(rayDirection, rayNormal));\n        vec3 newDirection = getConeSample(newReflection, REFLECT_FUZZ);\n        vec3 newPosition = rayPosition + rayNormal * MIN_DELTA;\n\n        float ndotl = dot(rayNormal, LightVec);\n        if (ndotl > 0.0)\n        {\n            float shadowDistance;\n            vec3 shadowNormal;\n            vec3 shadowDirection = getConeSample(LightVec, SHADOW_FUZZ);\n            int shadowObject = castRay(newPosition, shadowDirection, shadowDistance, shadowNormal);\n            if (shadowObject == 0)\n            {\n                float sillum = 0.0; //pow(max(0.0, dot(newDirection, LightVec)), 64.0);\n                directLight += finalColor * ndotl * 2.0 + sillum;\n            }\n        }\n\n        rayObject = castRay(newPosition, newDirection, rayDistance, rayNormal);\n\n        rayPosition = newPosition + newDirection * rayDistance;\n        rayDirection = newDirection;\n    }\n    \n    finalColor = directLight + finalColor * getBackground(rayDirection);\n    float fogVal = pow(distance / MAX_DISTANCE, 16.0);\n    finalColor = mix(finalColor, getBackground(direction), fogVal);\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = 2.0 * iMouse.xy / iResolution.y;\n    mouse -= vec2(iResolution.x / iResolution.y, 1.0);\n    \n    mouse.x *= 2.0;\n    mouse.y *= 0.5;\n    mouse.y += 0.5;\n    \n    float time = iTime * 0.1;\n    mouse.x += time;\n    \n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < MAX_SAMPLES; i++)\n    {\n        seed = fragCoord * (float(iFrame) + float(i));\n        vec2 offset = rand2n();\n        \n        vec2 p = 2.0 * (fragCoord + offset) / iResolution.y;\n        p -= vec2(iResolution.x / iResolution.y, 1.0);\n\n        vec3 origin = vec3(0.0, 5.0, 0.0);\n        origin = vRotateX(origin, -mouse.y);\n        origin = vRotateZ(origin, mouse.x);\n        origin += vec3(0.0, 0.0, 1.0);\n        vec3 direction = vec3(p.x, -1.5, p.y);\n        const float lookAt = -atan(0.5 / 3.0);\n        direction = vRotateX(direction, -mouse.y);\n        direction = vRotateZ(direction, mouse.x);\n        direction = normalize(direction);\n\n        vec3 color = drawScene(p, origin, direction);\n        color = pow(color, vec3(1.0 / 2.2));\n        color = clamp(color, vec3(0.0), vec3(1.0));\n        \n        finalColor += color / float(MAX_SAMPLES);\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}