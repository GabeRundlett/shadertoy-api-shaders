{
    "Shader": {
        "info": {
            "date": "1444349158",
            "description": "http://www.mattolick.com\n\nClicking the screen will subtly highlight and follow the mouse. ",
            "flags": 0,
            "hasliked": 0,
            "id": "ltjSDm",
            "likes": 7,
            "name": "Scanline Noise w/ Mouse Touch",
            "published": 3,
            "tags": [
                "noise",
                "mouse",
                "blending",
                "scanline",
                "blend",
                "tracking",
                "touch"
            ],
            "usePreview": 0,
            "username": "Retrotation",
            "viewed": 2995
        },
        "renderpass": [
            {
                "code": "// defining Blending functions\n#define Blend(base, blend, funcf) \t\tvec4(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b), funcf(base.a, blend.a))\n#define BlendOverlayf(base, blend) \t(base < 0.5 ? (1.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\n#define BlendOverlay(base, blend) \t\tBlend(base, blend, BlendOverlayf)\n#define BlendAddf(base, blend) \t\tmin(base + blend, 1.0)\n#define BlendAdd(base, blend) \t\tmin(base + blend, vec4(1.0))\n\n\n// animated noise function\nfloat snoise(in vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n// distance calculation between two points\nfloat dist(vec2 p0, vec2 pf){\n    return sqrt((pf.x-p0.x)*(pf.x-p0.x)+(pf.y-p0.y)*(pf.y-p0.y));\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// defining extra variables\n\nconst float speed     = 10.00; \n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// FRAGMENT SHADER\n\nvoid mainImage( out vec4 color, in vec2 fragCoord )\n{\n// add some movement\n    vec2  offset = vec2(0.0, iTime) * speed;\n\n    \n    vec2 pixelCoord = fragCoord + offset;\n\n// basic uv sampling\n    vec2 uv = floor(pixelCoord) * 2.0;\n \n// solid color for the background  \n    vec4 backcolor = vec4(0.22, 0.22, 0.22, 1.0);     \n       \n// generate scanlines from noise image, by stretching UV coordinates along Y-axis\n  \tvec4 scanlines = texture(iChannel0, uv  / iResolution.xy * vec2(0.0,1.0));\n  \n// use an 'Overlay' function similar to Photoshop's, to blend the scanlines and backcolor together  \n    vec4 firstpass = BlendOverlay(backcolor, scanlines);\n\n/////////////////////////////    \n   \n\n// generate animated noise    \n    float n = snoise(vec2(pixelCoord.x*cos(iTime),pixelCoord.y*tan(iTime))); \n \n// blend animated noise with the firstpass, using 'Overlay' function defined at the beginning of shader-code\n    vec4 secondpass = BlendOverlay(firstpass, vec4(n, n, n, 1.0));\n    \n/////////////////////////////           \n  \n    \n// calculate the distance between: the current pixel location, and the mouse position\n    float d = dist(fragCoord.xy,iMouse.xy);\n        \n// change the size of the gradient-distance over time, multiplied by \n    d = d*(sin(iTime)+7.0)*0.003;\n    \n// control the falloff of the gradient with a power/exponent, and multiply 'd' by the animated noise\n    d = pow(d*n,0.5);\n  \n// clamp the values of 'd', so that gradientgen cannot go below a 0.05 value\n    d = min(d,1.0);\n  \n// list the max,min gradient values, and linearly interpolate between the values using 'd' as a scale\n    vec4 gradientgen = mix(vec4(0.1, 0.1, 0.1, 1.0), vec4(0.05, 0.05, 0.05, 1.0), d);\n\n// blend the second pass and the mouse-controlled gradient together\n    vec4 thirdpass = BlendAdd(secondpass, gradientgen);\n  \n// final output     \n    color = thirdpass;\n\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}