{
    "Shader": {
        "info": {
            "date": "1691069591",
            "description": "fail",
            "flags": 0,
            "hasliked": 0,
            "id": "dtsczl",
            "likes": 0,
            "name": "z-order fail",
            "published": 3,
            "tags": [
                "morton"
            ],
            "usePreview": 0,
            "username": "pema99",
            "viewed": 164
        },
        "renderpass": [
            {
                "code": "// Switch between methods of converting float -> uint\n#define USE_NEW_MAPPING 0\n\nuint Part1By1(uint x)\n{\n    x &= 0x0000ffffu;                  // x = ---- ---- ---- ---- fedc ba98 7654 3210\n    x = (x ^ (x <<  8)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n    x = (x ^ (x <<  4)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n    x = (x ^ (x <<  2)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n    x = (x ^ (x <<  1)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n    return x;\n}\n\n\nuint MortonCodeEncode2D(uint x, uint y)\n{\n    return (Part1By1(y) << 1) + Part1By1(x);\n}\n\nuvec3 Float3ToUint3(vec3 v)\n{\n    // Reinterpret value as uint\n    uvec3 value_as_uint = uvec3(floatBitsToUint(v.x), floatBitsToUint(v.y), floatBitsToUint(v.z));\n\n    // Invert sign bit of positives and whole of  to anegativesllow comparison as unsigned ints\n    value_as_uint.x ^= (1u + ~(value_as_uint.x >> 31u) | 0x80000000u);\n    value_as_uint.y ^= (1u + ~(value_as_uint.y >> 31u) | 0x80000000u);\n    value_as_uint.z ^= (1u + ~(value_as_uint.z >> 31u) | 0x80000000u);\n\n    return value_as_uint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x /= iResolution.y/iResolution.x;\n    \n    // Grid resolution to display\n    const uint res = 1u << 5u;\n    const uint res2 = res * res;\n    const float fres = float(res);\n    \n    // Scaled uv\n    vec3 vuv = vec3(uv * fres, 0.0);\n    \n    // Map floats to unsigned integers\n    #if USE_NEW_MAPPING\n    uvec3 uuv = Float3ToUint3(vuv); \n    #else\n    uvec3 uuv = uvec3(vuv);\n    #endif\n\n\n    // Find index on curve of pixel\n    uint curveIndex = MortonCodeEncode2D(uuv.x, uuv.y) % res2;\n    vec3 col = vec3(float(curveIndex) / float(res2));\n    \n    // Color one pixel so we can see the Z-order nature of the curve\n    if (curveIndex == uint(iTime*3.) % res2)\n        col = vec3(1.0, 0.0, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}