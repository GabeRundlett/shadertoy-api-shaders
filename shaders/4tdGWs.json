{
    "Shader": {
        "info": {
            "date": "1472467520",
            "description": "One Ray Reproducts 3 Small Rays. (Baby Rays). Then, When The Rays Are Working Together, They\nMake A Smooth Ray And Make The Ray That Spawned Them Much Bigger & smoother.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tdGWs",
            "likes": 1,
            "name": "The Multiplication",
            "published": 3,
            "tags": [
                "rays",
                "light"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 621
        },
        "renderpass": [
            {
                "code": "\nstruct vec5{ float x; float y; float z; float w; float s; };\n//struct vec6{ float x; float y; float z; float w; float s; float a; };\nstruct ray{ vec3 p1; vec3 p2; vec3 p3; vec3 p4; };\nstruct ray2{ vec4 p1; vec4 p2; vec4 p3; };\n//struct ray3{ vec5 p1; vec5 p2; };\nvec5 findPos(vec4 x, vec4 y, float z){\n    vec4 d = max(x, y) - sqrt(z);\n    vec4 i = min(x, y) - sqrt(z);\n    float h = length(step(d, i));\n    vec2 s = vec2(dot(d.xy, vec2(1.1317,2.3135)) - dot(i.xy, vec2(1.1317,2.3135)));\n    return vec5( s.x + h, s.y + h, h + s.x, h + s.y, z );\n}\nvec2 rayPat(ray2 x, ray y)\n{\n    vec4 pat1 = smoothstep(x.p1, x.p2, x.p3);\n    vec3 pat2 = smoothstep(y.p1, y.p2, y.p3) - y.p4;\n    vec4 pat3 = smoothstep(x.p1, x.p2, x.p3) - vec4(smoothstep(y.p1, y.p2, y.p3), length(y.p4));\n    ray2 ipat = ray2(pat1, vec4(pat2, 1.0), pat3);\n    float pa = ipat.p1.x;\n    float pb = ipat.p1.y;\n    float pc = ipat.p1.z;\n    float pd = ipat.p1.w;\n    float p2a = ipat.p2.x;\n    float p2b = ipat.p2.y;\n    float p2c = ipat.p2.z;\n    float p2d = ipat.p2.w;\n    float p3a = ipat.p3.x;\n    float p3b = ipat.p3.y;\n    float p3c = ipat.p3.z;\n    float p3d = ipat.p3.w;\n    \n    float a = smoothstep(pa, pb, pc);\n    float b = smoothstep(pd, p2a, p2b);\n    float c = smoothstep(p2c, p2d, p3a);\n    float d = smoothstep(p3b, p3c, p3d);\n    \n    vec4 q = vec4(a, b, c, d) - max(pat1, pat3);\n    return vec2(q.x + q.y, q.z + q.w);\n}\nvec3 rayPos( ray2 x, ray y, vec4 t, vec4 h, float z )\n{\n    vec2 pattern = rayPat(x, y);\n    vec5 pos = findPos(t / pattern.x, h / pattern.y, z / max(pattern.x, pattern.y));\n    vec3 p = vec3(pattern.x + pos.x, pattern.y + pos.y, pos.z + pos.w) - pos.s;\n    return p;\n}\nray2 x( float t, vec3 pX, vec3 patX )\n{\n    vec4 i = vec4(pX, t) + patX.x;\n    vec4 i2 = vec4(pX, t) + patX.y;\n    vec4 i3 = vec4(pX, t) + patX.z;\n    return ray2(i, i2, i3);\n}\nvec4 sort( float t, vec4 k )\n{\n    return dot(t, t) + dot(k, vec4(0.37,1.136,2.938,6.35)) - k;\n}\nvec3 pS( float t, vec2 uv )\n{\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro = vec3(0.1, 0.1, -3.0);\n    ray2 k = x(t, rd, ro);\n    vec4 j = sort(t, vec4(rd, length(ro)));\n    vec4 l = sort(t, vec4(-rd, length(rd)));\n    float z = length(step(j, l));\n    ray y = ray(cos(rd) + ro, -sin(rd) + ro, sin(rd) + ro, cos(rd) + ro);\n    vec3 rPos = rayPos(k, y, j, l, z);\n    return rPos - (ro+t*rd);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv = uv * 2.0 - 1.0;\n    float t = uv.x / uv.y;\n    for(int i = 0; i < 2; i++){\n    vec3 col = pS(t * (iTime * 1600.0 / 8.0), uv / 2.0 - (iTime*600.0));\n    fragColor = -vec4(cos(uv.y)) + vec4(-0.025, 0.025, 0.6, 1.0);\n\tfragColor /= vec4(col,1.0) - vec4(uv, 1.0, 1.0) - 2.0;\n    fragColor /= vec4(col + cos(uv.y), 2.0);\n        t += length(fragColor) * fragCoord.x;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}