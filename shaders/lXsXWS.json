{
    "Shader": {
        "info": {
            "date": "1709934633",
            "description": "where the distance field is 0, one of the polynomials has a root\nsuffers from accuracy issues\nmove the mouse to change the \"seed\"",
            "flags": 0,
            "hasliked": 0,
            "id": "lXsXWS",
            "likes": 5,
            "name": "smooth complex roots",
            "published": 3,
            "tags": [
                "fractal",
                "complex"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 158
        },
        "renderpass": [
            {
                "code": "//in: complex number in polar coords, out: complex in cartesian\nvec2 pow_complex(vec2 z, float n){\n    float t = z.y*n;\n    return pow(z.x,n)*vec2(cos(t),sin(t));\n}\n\n//need to improve accuracy\ndouble dist(vec2 p, vec2 seed, int n){\n    vec2 z = vec2(length(p),atan(p.y,p.x));\n    double prod = new_double(1.0);\n    for (int j = 0; j < n; j++){\n        vec2 sum = seed;\n        for (int i = 0; i <= n; i++){\n            sum += float((((1 << i) & j) << 1) - 1)*pow_complex(z,float(i));\n        }\n        prod = double_mul(prod, new_double(length(sum)));\n    }\n    return prod;\n}\n\ndouble foo(vec2 p, vec2 seed, int n){\n    double prod = new_double(1.0);\n    for (int k = 1; k < n; k++){\n        prod = double_mul(prod, dist(p, seed, k));\n    }\n    return prod;\n}\n\nvec2 approx_normal(vec2 p, vec2 seed, int n){\n    vec2 e = vec2(0.00001,0);\n    return normalize(vec2(\n        double_sub(foo(p+e, seed, n), foo(p-e, seed, n)).x,\n        double_sub(foo(p+e.yx, seed, n), foo(p-e.yx, seed, n)).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 4.0;\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y*scale;\n    vec2 m = iMouse.xy == vec2(0) ? vec2(0) : (iMouse.xy - iResolution.xy/2.0)/iResolution.y*scale;\n\n    vec2 n = approx_normal(uv,m,15);\n    vec3 col = vec3(n.x*n.x+n.y*0.5,n.y,n.x*0.25-n.y*0.125);\n    //col = vec3(dist(uv,m,15)/50.0);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define double vec2\n\n#define new_double(V) vec2(V,0)\n\n// doubles adapted from\n// https://www.shadertoy.com/view/MtlGDs\n// by nick whitney - nwhit/2015\n\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\n\ndouble double_mul(double dsa, double dsb)\n{\n    vec2 dsc;\n    float c11, c21, c2, e, t1, t2;\n    float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n    cona = dsa.x * split;\n    conb = dsb.x * split;\n    a1 = cona - (cona - dsa.x);\n    b1 = conb - (conb - dsb.x);\n    a2 = dsa.x - a1;\n    b2 = dsb.x - b1;\n\n    c11 = dsa.x * dsb.x;\n    c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));\n\n    c2 = dsa.x * dsb.y + dsa.y * dsb.x;\n\n    t1 = c11 + c2;\n    e = t1 - c11;\n    t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n\n    return dsc;\n}\n\nvec2 double_sub(vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float e, t1, t2;\n\n    t1 = dsa.x - dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}