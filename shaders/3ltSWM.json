{
    "Shader": {
        "info": {
            "date": "1581080877",
            "description": "Here I am trying to finalize all ideas on applying Object-Oriented culture to GLSL. See first comment for details.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ltSWM",
            "likes": 2,
            "name": "Standard library for GLSL OO way",
            "published": 3,
            "tags": [
                "glsl",
                "oop",
                "stdlib"
            ],
            "usePreview": 0,
            "username": "dmitrykolesnikovich",
            "viewed": 451
        },
        "renderpass": [
            {
                "code": "class BouncingCircle extends Circle {    \n    \n    init() \n \n    vec2 position = vec2(-0.2, -0.4);\n    vec4 color = BLUE;\n    float radius = 0.02;    \n    \n    onDraw() {\n       \tfloat movement = abs(sin(t * 3.14) * 0.5);\n        float pulsing =  pow(radius, sin(t * PI + PI / 2.0) * 0.25 + 0.75);\n    \tfloat sortOfHeartBeating = mix(pulsing, movement, abs(sin(t * 3.14)));\n        position += sortOfHeartBeating;\n    \tradius += sortOfHeartBeating;\n    }\n\n   \tsuper(position, radius, color); \n}\n\n/*override*/ void onResize(vec2 size) {\n    uv = (2.0 * uv - size) / size.y; // normalize uv from -1 to 1\n}\n\n/*override*/ void onDrawCanvas() { \n    drawCircle(vec2(0, 0.6), 0.2, RED * (sin(t * PI * 100.0) * 0.3 + 0.7));\n    Parabola(vec2(-1.4, -0.2), 0.5, GREEN);    \n\tLine(vec2(-0.2, -0.2), vec2(-0.5, -0.5), VIOLET); \n    Rectangle(vec2(-0.9, -0.1), vec2(.2), RED);\n    Rhombus(vec2(1.2, 0.4), vec2(0.6, 0.3), GREEN);\n    BouncingCircle();      \n    Triangle(vec2(-1.1, -0.9),  vec2(0, -0.9), vec2(-0.5, -0.6), YELLOW);\n    Pentagon(vec2(0.8, -0.5), 0.3, 0.1, VIOLET);\n    Star(vec2(-0.37, 0.33), .25, .5, YELLOW);\n    Cross(vec2(0, 0), vec2(0.25, 0.1), 0.0, RED);\n    RoundedCross(vec2(0, -0.6), 0.2, 0.05, RED);\n    Polygon(vec2(0, 0), vec2[3](vec2(-0.9, -0.9), vec2(0.2, -0.9), vec2(-0.3, -0.6)), RED);\n}\n\nflush()",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n * Project render settings. \n * \n * Tweak freely to meet your needs.\n */\n\n// TODO parametrize blending\n#define isPlay false\n#define useSRGB true\n#define PI 3.14\n#define AA 0.005 // anti-aliasing TODO find better name\n#define POLYGON_CAPACITY 3 // TODO parametrize somehow instead of using constant\n#define backgroundColor vec4(0)\n\n\n/** \n * Standard library that contains standard \"classes\" like Circle, Rectangle, etc.\n * \n * Not for tweaking. Hardcoded in a stone.\n * \n * Reference: https://iquilezles.org/articles/distfunctions2d\n */\n\n/*private*/ vec4 canvas = backgroundColor; \n/*private*/ vec2 uv;\n\n#define RED vec4(1, 0, 0, 1)\n#define GREEN vec4(0, 1, 0, 1)\n#define BLUE vec4(0, 0, 1, 1)\n#define VIOLET vec4(0.8, 0.8, 1, 1)\n#define YELLOW vec4(1, 1, 0, 1)\n#define t isPlay ? iTime : 0.0\n#define drawDistance(distance) 1. - smoothstep(-AA, AA, distance)\n#define ndot(a, b) a.x*b.x - a.y*b.y\n#define flush() void mainImage(out vec4 fragColor, vec2 fragCoord) { uv = fragCoord; onResize(iResolution.xy); onDrawCanvas(); flushCanvas(fragColor); }\n\nvoid blend(vec4 color) {\n\tcanvas = mix(canvas, vec4(color.rgb, 1), color.a);\n}\n\nvoid flushCanvas(out vec4 fragColor) {\n\tif(useSRGB) canvas.rgb = pow(canvas.rgb, vec3(1.0/2.2));\n    fragColor = canvas;\n}\n\nvoid drawCircle(vec2 position, float radius, vec4 color) {\n    vec2 p = uv - position;\n    float geometry = length(p) - radius;\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Line(vec2 a, vec2 b, vec4 color) {\n    vec2 pa = uv - a; \n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float geometry = length(pa - ba*h);    \n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Rectangle(vec2 position, vec2 size, vec4 color) {\n    vec2 p = uv - position;\n    vec2 d = abs(p) - size;\n    float geometry = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Rhombus(vec2 position, vec2 b, vec4 color) {\n    vec2 p = uv - position;\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    float geometry = d * sign(q.x*b.y + q.y*b.x - b.x*b.y);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Triangle(vec2 p0, vec2 p1, vec2 p2, vec4 color) {\n    vec2 p = uv;\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    float geometry = -sqrt(d.x)*sign(d.y);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Pentagon(vec2 position, float radius, float innerRadius, vec4 color) {\n    vec2 p = uv - position;\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-radius*k.z,radius*k.z),radius);    \n    float geometry = length(p)*sign(p.y);\n    if (innerRadius>0.0) geometry = abs(geometry) - innerRadius;\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Star(vec2 position, float r, float rf, vec4 color) {\n    vec2 p = uv - position;\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    float geometry = length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\n\nvoid Cross(vec2 position, vec2 b, float r, vec4 color) {\n    vec2 p = uv - position;\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    float geometry = sign(k)*length(max(w,0.0)) + r;\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid RoundedCross(vec2 position, float w, float radius, vec4 color) {\n    vec2 p = uv - position;\n    p = abs(p);\n    float geometry = length(p-min(p.x+p.y,w)*0.5) - radius;\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\n// TODO parametrize size of v (now it's constant value POLYGON_CAPACITY = 3)\nvoid Polygon(vec2 position, vec2[POLYGON_CAPACITY] v, vec4 color) {\n    vec2 p = uv - position;\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    int N = v.length();\n    for(int i=0, j=N-1; i<N; j=i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    float geometry = s*sqrt(d);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\nvoid Parabola(vec2 position, float k, vec4 color) {   \n\tvec2 pos = uv - position;    \n    pos.x = abs(pos.x);    \n    float p = (1.0-2.0*k*pos.y)/(6.0*k*k);\n    float q = -abs(pos.x)/(4.0*k*k);    \n    float h = q*q + p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(-q+r,1.0/3.0) - pow(abs(-q-r),1.0/3.0)*sign(q+r) :\n        2.0*cos(atan(r,-q)/3.0)*sqrt(-p);\n    float geometry = length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n    float graphics = drawDistance(geometry);\n    vec4 tint = graphics * color;\n    \n    blend(tint);\n}\n\n/*OO support*/\n\nbool isDrawCircle = false;\n#define class void\n#define extends /*extends*/\n#define Circle () { isDrawCircle = true;\n#define init() /*init*/ }\n#define onDraw() /*ASD*/\n\nvoid super(vec2 position, float radius, vec4 color) {\n\tdrawCircle(position, radius, color);\n}\n\nvoid super(float radius, vec4 color) {\n\t// TODO\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}