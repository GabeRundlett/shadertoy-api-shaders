{
    "Shader": {
        "info": {
            "date": "1528880092",
            "description": "There are keyboard and mouse controls with quaternions.\nControls are taken from here: https://www.shadertoy.com/view/4dccRr\nI am going to update quaternions operations.",
            "flags": 48,
            "hasliked": 0,
            "id": "XdKBWW",
            "likes": 4,
            "name": "Quaternion controls",
            "published": 3,
            "tags": [
                "mouse",
                "keyboard",
                "quaternion"
            ],
            "usePreview": 0,
            "username": "Zabidon",
            "viewed": 1077
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Created by Kirill Osipov --- zabidon\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// QUATERNION OPERATIONS\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvec4 quat_decode(vec4 quat) {\n\treturn normalize(quat * 2. - 1.);\n}\n\nconst float EPSILON = 0.001;\n\n\n// ============================================================\n//                 START RAY MARCHING STUFF\n// ============================================================\n// It is copy/pasted from https://www.shadertoy.com/view/Xds3zN\nfloat plane(vec3 p) {\n\treturn p.y;\n}\n\nvec2 map(vec3 pos) {\n    vec2 res = vec2(plane(pos), 1.0);  \n    return res;\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 marchRay(in vec3 ro, in vec3 rd) {\n    float tmin = 1.0;\n    float tmax = 30.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for (int i=0; i<64; i++) {\n\t    float precis = 0.0004*t;\n\t    vec2 res = map(ro+rd*t);\n        if (res.x < precis || t > tmax) {\n            break;\n        }\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n// ============================================================\n//                 END RAY MARCHING STUFF\n// ============================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 position = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    vec4 rotation = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec4 velocity = texelFetch(iChannel0, ivec2(2,0), 0);\n    \n\trotation = quat_decode(rotation);\n    vec3 forward = quat_rotate(rotation, vec3(0,0,1));\n    \n    vec3 ray = normalize(\n        vec3(\n            (fragCoord.xy-iResolution.xy*.5)/iResolution.x,\n            0.3 - length(max(dot(forward, velocity.xyz), 0.)) / 100.\n        )\n    );\n    ray = quat_rotate(rotation, ray);\n\n    vec3 backgroundColor = ray;\n    // PLACE YOUR RAYMARCHING AND/OR RAYTRACING CODE HERE\n    vec2 factors = marchRay(position, ray);\n    vec3 pos = position + factors.x * ray;\n    \n    vec3 color = vec3(checkersGradBox(pos.xz));\n    float t = factors.x;\n    color = mix( color, backgroundColor, 1.0-exp( -0.0002*t*t*t ) );\n\tfragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The MIT License\n// Created by Kirill Osipov --- zabidon\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst float accel = 1.;\nconst float decay = .9;\n\n// There is a left-handed coordinate system.\n// Directions:\n// X-axis   ---   Right\n// Y-axis   ---   Up\n// Z-axis   ---   Forward\nconst vec3 INIT_TRANSLATION = vec3(0, 1, 0);\nconst vec4 INIT_ORIENTATION = vec4(0, 0, 0, 1);\nconst vec3 INIT_VELOCITY = vec3(0, 0, 0);\n\nconst int Key_Space = 32;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\n\nfloat key_state(int key) {\n\treturn textureLod(iChannel3, vec2((float(key) + .5) / 256.0, .25), 0.0).x;\n}\n// ================================================================\n//                   START QUATERNION OPERATIONS\n// ================================================================\nvec3 quat_rotate(vec4 quat, vec3 dir) {\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvec4 quat_invert(vec4 quat) {\n    return vec4(-quat.xyz, quat.w);\n}\n\n// according to the Tynach's comment \nvec4 quat_multiply(vec4 quat_1, vec4 quat_2) {\n    mat4 quat_1_mat = mat4(\n        quat_1.w, quat_1.z, -quat_1.y, -quat_1.x,\n        -quat_1.z, quat_1.w, quat_1.x, -quat_1.y,\n        quat_1.y, -quat_1.x, quat_1.w, -quat_1.z,\n        quat_1.x, quat_1.y, quat_1.z, quat_1.w\n    );\n\n    return quat_1_mat*quat_2;\n}\n\nvec4 quat_from_axis_angle(vec3 axis, float rad) {\n    vec4 dest;\n    \n    rad = rad / 2.;\n    float s = sin(rad);\n\n    dest.x = s * axis[0];\n    dest.y = s * axis[1];\n    dest.z = s * axis[2];\n    dest.w = cos(rad);\n\n    return normalize(dest);\n}\n\nvec4 quat_encode(vec4 quat) {\n\treturn quat / 2. + 0.5;\n}\n\nvec4 quat_decode(vec4 quat) {\n\treturn quat * 2. - 1.;\n}\n\n// ================================================================\n//                    END QUATERNION OPERATIONS\n// ================================================================\n\n// STORAGE:\n// (0, 0) --- position\n// (1, 0) --- rotation quaternion\n// (2, 0) --- velocity\n// (3, 0) --- last mouse position\n\nvoid init_position(out vec4 fragColor) {\n    fragColor = vec4(INIT_TRANSLATION, 0);\n}\n\nvoid init_rotation(out vec4 fragColor) {\n    fragColor = quat_encode(INIT_ORIENTATION);\n}\n\nvoid init_velocity(out vec4 fragColor) {\n    fragColor = vec4(INIT_VELOCITY, 0);\n}\n\nvoid process_position(out vec4 fragColor) {\n    vec4 position = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 velocity = texelFetch(iChannel0, ivec2(2,0), 0);\n\n    vec4 new_position = position + velocity * iTimeDelta;\n    \n    fragColor = new_position;\n}\n\nvoid process_rotation(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 rotation = texelFetch(iChannel0, ivec2(1,0), 0);\n    rotation = quat_decode(rotation);\n    vec4 last_mouse = texelFetch(iChannel0, ivec2(3,0), 0);\n\n    bool is_pressed = iMouse.w > .5;\n    bool was_press = last_mouse.w > .5;\n\n    vec2 cur_mouse_loc = iMouse.xy / iResolution.xy;\n    vec2 delta_angles = is_pressed && was_press? cur_mouse_loc - last_mouse.xy: vec2(0);\n    float delta_roll = (key_state(Key_Q)-key_state(Key_E))/ 100.;\n\n    vec4 delta_rot_x = quat_from_axis_angle(vec3(0,-1,0), delta_angles.x);\n    vec4 delta_rot_y = quat_from_axis_angle(vec3(1,0,0), delta_angles.y);\n    vec4 delta_rot_z = quat_from_axis_angle(vec3(0,0,1), delta_roll);\n\n    vec4 delta_rot = quat_multiply(delta_rot_y, delta_rot_x);\n    delta_rot = quat_multiply(delta_rot_z, delta_rot);\n    vec4 res_quat = quat_multiply(rotation, delta_rot);\n\n    // TODO: correct up\n    fragColor = quat_encode(normalize(res_quat));\n}\n\nvoid process_velocity(out vec4 fragColor) {\n    vec4 position = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 velocity = texelFetch(iChannel0, ivec2(2,0), 0);\n    vec4 rotation = texelFetch(iChannel0, ivec2(1,0), 0);\n    rotation = quat_decode(rotation);\n    \n    \n    vec3 right = quat_rotate(rotation, vec3(1.0, 0.0, 0.0)) * accel;    \n    velocity.xyz += (key_state(Key_D) - key_state(Key_A)) * right;\n\n    vec3 up = quat_rotate(rotation, vec3(0.0, 1.0, 0.0)) * accel;\n    velocity.xyz += (key_state(Key_R)-key_state(Key_F)) * up;\n\n    vec3 forward = quat_rotate(rotation, vec3(0.0, 0.0, 1.0)) * accel;\n    velocity.xyz += (key_state(Key_W) - key_state(Key_S)) * forward;\n\n    velocity *= 1. - (1. - decay) * (1. - iTimeDelta);\n    \n    fragColor = velocity;\n}\n\nvoid process_mouse(out vec4 fragColor) {\n    fragColor = vec4(iMouse.xy / iResolution.xy, 0, iMouse.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n            init_position(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n            init_rotation(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n            init_velocity(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n            //init_mouse(fragColor);\n        }\n        return;\n    } else {\n        if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n            process_position(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n            process_rotation(fragColor, fragCoord);\n        } else if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n            process_velocity(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n            process_mouse(fragColor);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}