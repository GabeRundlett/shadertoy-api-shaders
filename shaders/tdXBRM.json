{
    "Shader": {
        "info": {
            "date": "1587894754",
            "description": "camera ray, point on a ray, calculate distance between point and ray",
            "flags": 0,
            "hasliked": 0,
            "id": "tdXBRM",
            "likes": 4,
            "name": "On the way to drive home",
            "published": 3,
            "tags": [
                "learning"
            ],
            "usePreview": 0,
            "username": "esnho",
            "viewed": 377
        },
        "renderpass": [
            {
                "code": "#define S(a, b, t) smoothstep(a,b,t)\n\n// inspired from https://www.youtube.com/watch?v=eKtsY7hYTPg\n\nstruct ray {\n    vec3 \to, // origin\n    \t\td; // direction\n};\n\n    ray GetRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {\n        ray a;\n        a.o = camPos;\n\n        vec3 forward = normalize(lookAt-camPos);\n        vec3 right = cross(vec3(0,1,0), forward);\n        vec3 up = cross(forward, right);\n        vec3 centerScreen = a.o + forward * zoom;\n        vec3 intersection = centerScreen + uv.x * right + uv.y * up;\n\n        a.d = normalize(intersection-a.o);\n\n        return a;\n    }\n\n// project a ray and calculate which is the closest point\n// on that ray to an input point\nvec3 ClosestPoint(ray r, vec3 p) {\n    return r.o + max(0.0, dot(p-r.o, r.d))*r.d;\n}\n\n// calculate the distance from a point to a ray\n// first finds the closest point of the ray to the point\n// then calculate the distance\nfloat DistRay(ray r, vec3 p) {\n    return length(p - ClosestPoint(r, p));\n}\n\nfloat Bokeh(ray r, vec3 p, float size, float blur) {\n    float d = DistRay(r, p);\n\n    // smoothstep from the center\n    float c = S(size, size*(1.-blur), d);\n    // ring outside the circle, 70% the width of the circle\n    float ring = S(size*.7, size, d);\n    // mix(inColor, outColor, ring)\n    c *= mix(.7, 1., ring);\n    \n    return c;\n}\n\nfloat  hue2rgb(float p, float q, float t){\n\tif(t < 0.) t += 1.;\n\tif(t > 1.) t -= 1.;\n\tif(t < 1./6.) return p + (q - p) * 6. * t;\n\tif(t < 1./2.) return q;\n\tif(t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n\treturn p;\n}\n\nvec3 HslToRgb(float h, float s, float l){\n    vec3 rgb = vec3(1.);\n\n    if(s == 0.){\n        return rgb; // achromatic\n    }else{\n        float q = l < 0.5 ? l * (1. + s) : l + s - l * s;\n        float p = 2. * l - q;\n        rgb.r = hue2rgb(p, q, h + 1./3.);\n        rgb.g = hue2rgb(p, q, h);\n        rgb.b = hue2rgb(p, q, h - 1./3.);\n    }\n\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(.0, .0, .0);\n    vec3 lookat = vec3(.0, .0, 1.0);\n    // this is the camera ray :)\n    ray r = GetRay(uv, camPos, lookat, 2.);\n    \n    // draw!\n    vec3 frag = vec3(.0);\n    for (float i = 0.; i < 80.; i++) {\n        // the position is a weird lissajous curve\n        vec3 p = vec3(\n            (sin(time+i)+cos(time+i+0.5))*2.,\n            cos(time + i * cos(time*0.1)),\n            (\n                (sin(time+i)*\n                 sin(time+i+0.5)*15.\n                )+7.)\n        );\n        // choosing the side of color wheel, the number\n        // is used to offset color position\n        float side = fract(i/2.) >= 0.5 ? 0. : 0.5;\n        vec3 color = HslToRgb(\n            \t(i/80.) + sin(time*.4) + side,\n            \t1.2,\n            \t0.6);\n        \n        // the circle size vary\n        float circleSize = (abs(cos(i))+.2)*.15;\n        \n        // blending max\n        frag = max(frag, Bokeh(r, p, circleSize, .1) * color);\n    }\n    \n    // Output to screen\n    fragColor = vec4(1.-frag,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}