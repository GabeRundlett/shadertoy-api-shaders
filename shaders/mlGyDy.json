{
    "Shader": {
        "info": {
            "date": "1700591756",
            "description": "A morning cup of coffee just for you, #1 Coder!  Or night cup if you're in a crunch.  My first attempt at a more realistic lighting model.  I think the AA looks ugly, wondering how I can improve the quality. Happy to receive feedback!",
            "flags": 32,
            "hasliked": 0,
            "id": "mlGyDy",
            "likes": 13,
            "name": "Coffee Cup For You",
            "published": 3,
            "tags": [
                "fun",
                "realistic"
            ],
            "usePreview": 0,
            "username": "kp1197",
            "viewed": 235
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n#define TAU 2.*PI\n#define SQRT_3 pow(3.,0.5)\n#define AAMIP 3.\n#define AASTEP vec2(pow(2.,AAMIP)/iResolution.x,0.)\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 e = vec2(1./iResolution.x,0.);\n    vec2 coords = fragCoord.xy / iResolution.xy;\n    vec3 oImg = texture(iChannel0, coords, 0.).xyz;\n    // apply a box filter to a lower mip to reduce blockiness of the mip\n    vec3 filteredImg = (texture(iChannel0, coords + AASTEP.xy, AAMIP).xyz + \n                        texture(iChannel0, coords + AASTEP.xx, AAMIP).xyz +\n                        texture(iChannel0, coords + AASTEP.yx, AAMIP).xyz +\n                        texture(iChannel0, coords - AASTEP.xy, AAMIP).xyz + \n                        texture(iChannel0, coords - AASTEP.xx, AAMIP).xyz +\n                        texture(iChannel0, coords - AASTEP.yx, AAMIP).xyz)/6.;\n    // compare saturation and value between filtered and base image to determine when to blend in filtered img\n    float aaMixSignal = max(2. * abs(hsv(oImg).z - hsv(filteredImg).z), abs(hsv(oImg).y - hsv(filteredImg).y)/TAU);\n    //fragColor.xyz = vec3(aaMixSignal) * filteredImg;\n    fragColor = vec4(mix(oImg, filteredImg, aaMixSignal),1.);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Usual incompatibility suspects: https://www.shadertoy.com/view/lstfD2\n/* Various functions from IQ articles */\n\nfloat dSphere(vec4 p, float r) {\n    return length(p.xyz) - r;\n}\n\nfloat dPlane(vec4 p) {\n    return p.z;\n}\n\nfloat dRoundedCylinder( vec4 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat dCappedTorus( vec4 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p.xyz,p.xyz) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat dCappedCylinder( vec4 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dot2(vec2 x) {\n    return dot(x,x);\n}\n\nfloat dHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    //outNormal = (tN>0.0) ? step(vec3(tN),t1)) : // ro ouside the box\n    //                       step(t2,vec3(tF)));  // ro inside the box\n    //outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// 3d simplex noise: https://www.shadertoy.com/view/XsX3zB\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n// intrinsic rotation about x-axis, y-axis, z-axis respectively, followed by translation \nmat4 transform(in vec3 rot, in vec3 tx) {\n\n    float cos_alpha = cos(rot.z);\n    float sin_alpha = sin(rot.z);\n    float cos_beta = cos(rot.y);\n    float sin_beta = sin(rot.y);\n    float cos_gamma = cos(rot.x);\n    float sin_gamma = sin(rot.x);\n\n    return mat4( cos_alpha * cos_beta,  \\\n        cos_alpha * sin_beta * sin_gamma - sin_alpha * cos_gamma,\\\n        cos_alpha * sin_beta * cos_gamma + sin_alpha * sin_gamma,\\\n        0.,\\\n        sin_alpha * cos_beta,\\\n        sin_alpha * sin_beta * sin_gamma + cos_alpha * cos_gamma, \\\n        sin_alpha * sin_beta * cos_gamma - cos_alpha * sin_gamma, \\\n        0.,\\\n        -sin_beta, \\\n        cos_beta * sin_gamma, \\\n        cos_beta * cos_gamma,\\\n        0.,\\\n        tx.x,tx.y,tx.z,1.);\n}\n\n// https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv(vec3 rgb) {\n \tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n \tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n \tfloat delta = Cmax - Cmin;\n\n \tvec3 hsv = vec3(0., 0., Cmax);\n\n \tif (Cmax > Cmin) {\n \t\thsv.y = delta / Cmax;\n\n \t\tif (rgb.r == Cmax)\n \t\t\thsv.x = (rgb.g - rgb.b) / delta;\n \t\telse {\n \t\t\tif (rgb.g == Cmax)\n \t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n \t\t\telse\n \t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n \t\t}\n \t\thsv.x = fract(hsv.x / 6.);\n \t}\n \treturn hsv;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define MAX_D 50.\n#define MAX_STEPS 300\n#define EPS 1e-5\n#define PI 3.14159\n#define TABLE_MATERIAL_ID 1.\n#define CUP_MATERIAL_ID 2.\n#define TABLE_BEAM_MATERIAL_ID 3.\n#define IDENTITY mat4(1.,0.,0.,0.,  0.,1.,0.,0., 0.,0.,1.,0., 0.,0.,0.,1.)\n#define STEAM_VOLUME_ARGS 1.1, 0.8\n#define VOLUME_STEP 0.1\n\n#define DEBUGGING 1\n#define CHARACTERS iChannel3\n#define WRITE_START vec2 text_uv = fragCoord.xy / iResolution.y; vec2 U = ( text_uv - vec2(.5,.8) ) * 8.; int char_id = -1; vec2 char_pos, dfdx, dfdy; vec2 R = iResolution.xy; vec2 debug_uv = fragCoord.xy / R.y;\n#define TEXT_ARGS char_id, char_pos, dfdx, dfdy\n#define WRITE_FLOAT fragColor += pFloat(U, \n#define CARRIAGE_RETURN , TEXT_ARGS); U.y += 0.8; \n#define WRITE_END fragColor += draw_char(TEXT_ARGS).xxxx;\n\n\nconst vec3 SKY_COLOR      = vec3(1.64,1.27,0.99);\nconst vec3 KEY_COLOR      = vec3(1.64,1.27,0.99);\nconst vec3 INDIRECT_COLOR = vec3(1.,0.6,0.);\nconst vec3 SKY_LIGHT_DIR = normalize(vec3(0.,-0.9,1));\n\n\nconst vec2 e = vec2(10.*EPS,0.);\n\nmat4 tableTx;\nmat4 tableBeamTx;\nmat4 cupTx;\nmat4 handleTx;\nmat4 steamVolumeTx;\n\n\n\n#if DEBUGGING\nvec4 char(vec2 p, int c, inout int char_id, inout vec2 char_pos, inout vec2 dfdx, inout vec2 dfdy) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) { // thighly y-clamped to allow dense text\n        char_id = c;\n\t\tchar_pos = p;\n\t\tdfdx = dFdx;\n\t\tdfdy = dFdy;\n\t}\n    return vec4(0);\n}\nvec4 draw_char(in int char_id, in vec2 char_pos, in vec2 dfdx, in vec2 dfdy) {\n    int c = char_id; vec2 p = char_pos;\n\tvec2 charLoc = p/16.;\n\tfloat charRow = 15.-floor(float(c)/16.);\t\n\tvec2 charFract = fract( vec2(float(c), charRow) / 16. );\n\tvec2 charP = charLoc + charFract;\n    return c < 0 ? vec4(0,0,0,1e5) : textureGrad( CHARACTERS, charP, dfdx, dfdy );\n}\n\nvec4 pInt(vec2 p, float n, inout int char_id, inout vec2 char_pos, inout vec2 dfdx, inout vec2 dfdy) {\n    vec4 v = vec4(0);\n    if (n < 0.) {\n        v += char(p - vec2(-0.5,0), 45, char_id, char_pos, dfdx, dfdy);\n        n = -n;\n\t}\n    for (float i = 7.; i>=0.; i--) {\n        n /=  9.999999; // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.), char_id, char_pos, dfdx, dfdy );\n    }\n\treturn v;\n}\n\n// --- display float8.8\nvec4 pFloat(vec2 p, float n, inout int char_id, inout vec2 char_pos, inout vec2 dfdx, inout vec2 dfdy) {\n    vec4 v = vec4(0);\n    if (n < 0.) {\n\t\tv += char(p - vec2(-.5,0), 45, char_id, char_pos, dfdx, dfdy );\n\t\tn = -n;\n\t}\n    float upper = floor(n);\n    float lower = fract(n)*1e8 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e8) { lower -= 1e8; upper++; }\n    v += pInt(p,upper,char_id,char_pos,dfdx,dfdy); p.x -= 4.;\n    v += char(p, 46,char_id,char_pos,dfdx,dfdy);   p.x -= .5;\n    v += pInt(p,lower,char_id,char_pos,dfdx,dfdy);\n    return v;\n}\n#endif\n\n\n\nvoid matmin(inout float currentD, in float d, inout float currentMaterialID, in float materialID, inout vec4 currentLocalP, in vec4 localP) {\n    float signal = step(d, currentD);\n    currentMaterialID = mix(currentMaterialID, materialID, signal);\n    currentD = mix(currentD, d, signal);\n    currentLocalP = mix(currentLocalP, localP, signal);\n}\n\nfloat textMessage(vec2 surfaceCoordinates) {\n    int char_id = -1; vec2 char_pos, dfdx, dfdy;\n    vec2 p = surfaceCoordinates * vec2(-2.0,2.0) + vec2(0.75,-2.2);\n    float signal = 0.;\n    signal += char(p, 35, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.);\n    signal += char(p, 49, char_id, char_pos, dfdx, dfdy).x; p -= vec2(-1.25,-3.1);\n    signal += char(p, 67, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // C\n    signal += char(p, 79, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // O\n    signal += char(p, 68, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // D\n    signal += char(p, 69, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // E\n    signal += char(p, 82, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // R\n    signal += draw_char(char_id, char_pos, dfdx, dfdy).x;\n    return signal;\n}\n\nvec3 getMaterialColor(vec4 p, vec4 ray, float materialID) {\n    if (materialID < 0.5) {\n        vec4 cubeMapRay = transform(vec3(0.,0.,-1.1*PI),vec3(0.)) * ray;\n        return SKY_COLOR * pow(texture(iChannel1,cubeMapRay.xyz).xyz,vec3(0.8));//vec3(max(0.,ray.z));\n    }\n    else if (materialID < 1.5) {\n        float waterRingSignal = smoothstep(-0.1,-0.03,-abs(1.-length(p.xz-vec2(0.8,0.1)))); //step(abs(1.-length(p.xz-vec2(0.4,0.1))),0.1);\n        vec3 waterRing = mix(vec3(1.), vec3(1.4), waterRingSignal);\n        return pow(texture(iChannel0,p.xy * p.yz).xyz, vec3(waterRing));\n    }\n    else if (materialID < 2.5) {\n        vec2 surfaceCoordinates = vec2(atan(p.z,p.x)-1.5,0.55-p.y);\n        float heartSignal = dHeart(surfaceCoordinates);\n        vec3 icon = mix(vec3(0.25), vec3(0.25,0.5,0.25), step(heartSignal,0.));\n        float textSignal = textMessage(surfaceCoordinates);\n        icon = mix(icon, vec3(1.5), textSignal);\n        return pow(texture(iChannel2,p.xy * p.zz).xyz,vec3(icon));\n    }\n    else if (materialID < 3.5) {\n        return texture(iChannel2, p.xz * p.xy).xyz;\n    }\n    else {\n        return SKY_COLOR;\n    }\n}\n\nfloat map(in vec4 p, in vec4 r, inout vec4 currentLocalP, inout float currentMaterialID) {\n\n    float currentD = MAX_D;\n\n    // table surface\n    vec4 tableP = (tableTx * p);\n    float tableD = dRoundedCylinder(tableP, 2.65, 0.2, 0.1);\n    matmin(currentD, tableD, currentMaterialID, TABLE_MATERIAL_ID, currentLocalP, tableP);\n\n    // table beam\n    vec4 tableBeamP = (tableBeamTx * p);\n    float tableBeamD = dCappedCylinder(tableBeamP, 2.05, 0.312);\n    matmin(currentD, tableBeamD, currentMaterialID, TABLE_BEAM_MATERIAL_ID, currentLocalP, tableBeamP);        \n\n    // cup\n    vec4 cupP = cupTx * p;\n    float cupD = dRoundedCylinder(cupP, 0.5, 0.2, 1.);\n    //matmin(currentD, cupD, currentMaterialID, CUP_MATERIAL_ID, currentLocalP, cupP);\n\n    // handle\n    vec4 handleP = handleTx * p;\n    float handleD = dCappedTorus(handleP, vec2(1,0.0), 0.6, 0.15);\n    \n    // cup/handle smin. TODO: matsmin\n    float mugD = smin(cupD,handleD,0.05);\n    matmin(currentD, mugD, currentMaterialID, CUP_MATERIAL_ID, currentLocalP, cupP); \n    \n    return currentD;\n}\n\nstruct Scene {\n    vec4 localP;\n    vec4 objP;\n    float materialID;\n    vec3 surfaceNormal;\n};\n\n\nScene sceneQuery(in vec4 p, in vec4 r) {\n    float hit = 0.;\n    float currentMaterialID = 0.;\n    float totalD = 0.;\n    vec4 currentLocalP = p;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        \n        float d = map(p, r, currentLocalP, currentMaterialID);\n        totalD += d;\n        \n        if (d < EPS) {\n            hit = 1.;\n            break;\n        }\n        if (totalD > MAX_D) {\n            break;\n        }\n        if (i == MAX_STEPS - 1) {\n            // you tried, raymarcher.  You get an 'A' for effort.\n            hit = 1.;\n        }\n        \n        p += vec4(d * r.xyz, 0.);\n    }\n    currentMaterialID *= hit;\n    vec3 surfaceNormal;\n    if (hit > 0.) {\n        vec4 _p = vec4(0.); float _f = 0.;\n        surfaceNormal = normalize(vec3(\\\n            map(p+e.xyyy,r,_p,_f) - map(p-e.xyyy,r,_p,_f),\n            map(p+e.yxyy,r,_p,_f) - map(p-e.yxyy,r,_p,_f),\n            map(p+e.yyxy,r,_p,_f) - map(p-e.yyxy,r,_p,_f)) / (2.*e.x));\n    }\n    else {\n        surfaceNormal = vec3(0.);\n    }\n    return Scene(currentLocalP, p, currentMaterialID, surfaceNormal);\n}\n\nfloat steamDensity(vec3 steamP) {\n    float density = simplex3d(steamP.xyz - vec3(0.,0.,0.5*iTime));\n    float radialDistance = length(steamP.xy);\n    float verticalDistance = 1.;//abs(steamP.z);\n    float attenuation = pow(max(0.,0.8 - radialDistance)/0.8,1.5);// * pow(max(0.,3.-verticalDistance)/3.,2.);\n    return max(0.,density * attenuation);\n}\n\nvec4 steamInfo(vec3 steamP) {\n    // TODO: directional derivative\n    float density = steamDensity(steamP);\n    const float K = 50.;\n    float dx = steamDensity(steamP + K * e.xyy) - steamDensity(steamP - K * e.xyy);\n    float dy = steamDensity(steamP + K * e.yxy) - steamDensity(steamP - K * e.yxy);\n    float dz = steamDensity(steamP + K * e.yyx) - steamDensity(steamP - K * e.yyx);\n    return vec4(normalize(vec3(dx,dy,dz)/(2.*e.x)), density);\n}\n\n\nvec2 steamVolumeIntersectionD(in vec4 p, in vec4 r) {\n    vec3 steamP = (steamVolumeTx * p).xyz;\n    vec3 steamR = r.xyz; // i'm not rotating the volume in any way, so no need\n    return boxIntersection( steamP, steamR, vec3(1.,1.,2.) );\n}\n\n// i'll leave self shadowing to another exercise\nvec2 steamQuery(in vec4 p, in vec4 r, in vec4 sceneIntersectPos, in vec4 lightPos) {\n    float dSceneIntersection = length(p.xyz - sceneIntersectPos.xyz);\n    vec2 dSteamVolume = max(vec2(0.), steamVolumeIntersectionD(p, r));\n    vec2 dMarchBounds = vec2(min(dSteamVolume.x, dSceneIntersection), min(dSteamVolume.y, dSceneIntersection));\n    float lighting = 0.;\n    float occlusion = 0.;\n    float dSpan = dMarchBounds.y - dMarchBounds.x;\n    float dIncr = VOLUME_STEP/dSpan;\n    for (float dFrac = 0.; dFrac < 1.; dFrac += 0.2) {\n        float d = dMarchBounds.x + dFrac * dSpan;\n        vec3 steamP = (steamVolumeTx * vec4(p.xyz + d * r.xyz,1.)).xyz;\n        vec4 s = steamInfo(steamP.xyz);\n        vec3 steamVolumeNormal = s.xyz;\n        vec3 keyLightDir = normalize(p.xyz - lightPos.xyz);  \n        float density = s.w;\n        lighting += density * VOLUME_STEP * clamp(dot(steamVolumeNormal, keyLightDir), 0., 1.);\n        occlusion += density * VOLUME_STEP;\n    }\n    return vec2(lighting, 5. * occlusion); // i bumped up the occlusion just to make the smoke occlusion more obvious in shadows\n}\n\n// 0.0 -> occluded.  1.0 -> illuminated;\nfloat occlusionQuery(in Scene result, in vec4 lightPos) {\n    vec4 objPos = result.objP;\n    float d = MAX_D;\n    float totalD = 0.;\n    vec4 currentLocalP = lightPos;\n    vec4 lightRay = vec4(normalize(objPos.xyz - lightPos.xyz),1.);\n    float currentMaterialID = 0.;\n    float penumbra = 1.0;\n    vec4 currentPos = lightPos;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float d = map(currentPos, lightRay, currentLocalP, currentMaterialID);\n        totalD += d;\n        float distanceFromObj = length(objPos.xyz - currentPos.xyz);\n        penumbra = min(penumbra, 15. * (d + EPS)/ (distanceFromObj+EPS));\n        if (d < EPS) {\n            // if the object the lightray intersects with is not at objPos, the ray was blocked.\n            float unoccluded = step(length(currentPos.xyz - objPos.xyz), 100.*EPS);\n            float softShadow = penumbra * unoccluded;\n            float steamOcclusion = steamQuery(lightPos, lightRay, objPos, vec4(0.)).y;\n            softShadow -= (softShadow) * steamOcclusion * unoccluded;\n            return softShadow;\n        }\n        if (totalD > MAX_D) {\n            break;\n        }\n        currentPos += vec4(d * lightRay.xyz,0.);\n    }\n    return 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // for debugging / tweaking by mouse\n    float controlSignal1 = (iMouse.x/iResolution.x * 10.);\n    float controlSignal2 = iMouse.y/iResolution.y * 0.1;\n\n    // cam setup\n    vec4 p = vec4(fragCoord/iResolution.xx - 0.5 * vec2(1.,iResolution.y/iResolution.x), -1, 1.).xzyw;\n    vec4 r = vec4(normalize(p.xyz),1.);    \n    float t = 0.1 * iTime + (1.-sign(iMouse.z));\n    float rotateT =  0.25 * sin(t);\n    float viewDistance = 6. + 0.1 * controlSignal1;    \n    vec3 camRx = (vec3(0.,0.,rotateT));\n    p = vec4(vec3(0.,-10.,0.) + (viewDistance) * vec3(sin(rotateT), cos(rotateT), 0.05 - controlSignal2),1.);    \n    r = transform(camRx, vec3(0.)) * r;\n    \n    // pre-calculate rotation matrices\n    // I tweaked all of these by wiring up controlSignal and then copying the value written out to screen\n    tableTx  = inverse(transform(vec3(PI/2.,0.,0.), vec3(0.,-10.,-1.49)));\n    tableBeamTx = inverse(transform(vec3(PI/2.,0.,0.), vec3(0.,-10.,-3.8)));\n    cupTx    = inverse(transform(vec3(PI/2.,0.,0.), vec3(0.,-10.,-0.01))); \n    handleTx = inverse(transform(vec3(PI/2.,0.,-PI/2.), vec3(-1.,-10.,0.)));\n    steamVolumeTx = inverse(transform(vec3(0.,0.,0.), vec3(0.,-10.,2.2)));\n       \n    // raymarch\n    Scene scene = sceneQuery(p,r);\n    \n    // lighting setup\n    vec4 keyLightPos = vec4(8., -4.87,10.,1.);\n    vec3 keyLightDir = normalize(keyLightPos.xyz - scene.objP.xyz);//normalize((transform(vec3(0.616,0.369,0.),vec3(0.)) * vec4(0.,0.,1.,1.)).xyz);\n    vec3 skyLightDir = SKY_LIGHT_DIR; //normalize((transform(vec3(0.,1.42,0.),vec3(0.)) * vec4(0.,0.,1.,1.)).xyz);\n    \n    vec3 keyLightH = normalize(-r.xyz + keyLightDir.xyz);\n    vec3 skyLightH = normalize(-r.xyz + skyLightDir.xyz);\n    \n    // occlusion queries\n    float skyLightOcc = occlusionQuery(scene,  scene.objP + vec4(10.*skyLightDir,0.));\n    float keyLightOcc = occlusionQuery(scene,  keyLightPos);\n    float fakeIndOcc  = occlusionQuery(scene,  scene.objP + vec4(0.,0.,-0.00375,0.)) * float(scene.materialID != TABLE_MATERIAL_ID);\n    \n    vec3 materialColor = getMaterialColor(scene.localP, r, scene.materialID);\n    vec2 steamInfo     = steamQuery(p, r, scene.objP, keyLightPos);\n    \n    vec3 lin = vec3(0.);\n    if (scene.materialID > 0.5) {\n        lin     += 0.16 * vec3(1.); // ambient\n        lin     += 0.55 * skyLightOcc * clamp(dot(skyLightDir,scene.surfaceNormal), 0., 1.) * SKY_COLOR; // sky\n        lin     += 0.25 * keyLightOcc * clamp(dot(keyLightDir,scene.surfaceNormal), 0., 1.) * KEY_COLOR; // key\n        lin     += 0.05 * fakeIndOcc  * clamp(dot(vec3(0.,0.,-1.),scene.surfaceNormal), 0., 1.) * INDIRECT_COLOR; // indirect\n        lin     += 0.15 * keyLightOcc * pow(max(dot(keyLightH, scene.surfaceNormal), 0.), 8.) * SKY_COLOR;\n        lin     += 0.85 * skyLightH   * pow(max(dot(skyLightH, scene.surfaceNormal), 0.), 8.) * KEY_COLOR;\n    }\n    else {\n        lin += 0.3;\n    }\n    lin     += (0.80) * steamInfo.x * KEY_COLOR;\n    \n    vec3 color = pow(abs(materialColor * lin), vec3(1.0/2.2));\n    fragColor = vec4(clamp(color, vec3(0.), vec3(1.)),1.);\n    \n    //fragColor.xyz = vec3(steamInfo.x);\n    \n    /*\n    #if DEBUGGING\n\tWRITE_START\n    WRITE_FLOAT controlSignal1 CARRIAGE_RETURN\n    WRITE_FLOAT controlSignal2 CARRIAGE_RETURN\n    WRITE_END \n    #endif\n    */\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}