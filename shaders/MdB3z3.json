{
    "Shader": {
        "info": {
            "date": "1391553378",
            "description": "just a small test . . . ",
            "flags": 0,
            "hasliked": 0,
            "id": "MdB3z3",
            "likes": 8,
            "name": "Simple Physics",
            "published": 3,
            "tags": [
                "2d",
                "motionblur",
                "physics"
            ],
            "usePreview": 0,
            "username": "mu6k",
            "viewed": 985
        },
        "renderpass": [
            {
                "code": "/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tjust a small test . . . \n\t\n*/\n\n#define max_bounces 16\n\n#define motion_blur\n#define motion_blur_samples 16\n\n//solve 2nd order polynomial, return the maximum of two solutions\n//could have optimised for this particular example... meh...\nfloat second(float a,float b,float c)\n{\n\tfloat x1 = (-b+sqrt((b*b-4.0*a*c)))/(2.0*a);\n\tfloat x2= (-b-sqrt((b*b-4.0*a*c)))/(2.0*a); \n\treturn max(x1,x2);\n}\n\n//compute position after t seconds\n//there is a plane at y=0, need to check for collisions with it\nvec3 physics(vec3 pos, vec3 vel, vec3 acc, float t)\n{\n\t//this loop processes upto max_bounces collisions... nice :)\n\tfor (int i=0; i<max_bounces; i++)\n\t{\n\t\tfloat tc = second(acc.y*.5,vel.y,pos.y);\n\t\t//now we know that there will be a collision with the plane \n\t\t//in exactly tc seconds\n\t\t\n\t\tif (t>tc) //if time is greater than time of collision\n\t\t{\n\t\t\tt-=tc; //process the collision\n\t\t\tpos = pos + vel*tc + acc*tc*tc*.5;\n\t\t\tvel = vel + acc*tc;\n\t\t\tvel.y*=-.6; //make it bounce\n\t\t}\n\t\telse break; //it wont collide, yay!\n\t}\n\n\treturn pos + vel*t + acc*t*t*.5; // x = v*t + .5*a*t^2\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy -.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tuv*=16.0;\n\t\n\tfloat acc = .0;\n\t\n\t//new simulation after every 4 seconds\n\tfloat mt = mod(iTime,4.0);\n\tfloat seed = iTime-mt; //the seed to generate new variables\n\t\n\tfor (int _sample = 0; _sample<motion_blur_samples; _sample++)\n\t{\n\t\t#ifdef motion_blur\n\t\tfloat tnoise = hash(uv.xy+vec2(_sample,_sample))*(1.0/24.0);\n\t\t#else\n\t\tfloat tnoise = .0;\n\t\t#endif\n\t\t\n\t\tvec3 p = (\n\t\t\tphysics(\n\t\t\t\tvec3(sin(seed*.5)*4.0,8.0,.0), //initial position\n\t\t\t\tvec3(cos(seed)*4.0,cos(seed*4.7)*cos(seed*1.7)*16.0-4.0,.0), //initial velocity\n\t\t\t\tvec3(.0,-(sin(seed*3.1)*12.0+21.0),.0),  //acceleration\n\t\t\t\tmt+tnoise ));\n\t\t\n\t\tvec2 temp = uv-p.xy+vec2(.0,3.0+4.0);\n\t\tfloat s = sqrt(dot(temp,temp));\n\t\ts-=1.0;\n\t\ts*=iResolution.y*.05;\n\t\ts = min(1.0,max(.0,s));\n\t\t\n\t\tacc+=s/float(motion_blur_samples);\n\t}\n\t\t\n\tvec3 color = mix(vec3(1.1,.8,.5),vec3(.3,.2,.4),acc);\n\t\n\tcolor = mix(color*color,color,1.4);\n\tcolor *=.8;\n\tcolor -= length(uv)*.005;\n\n\tcolor += hash(uv.xy+color.xy)*.02;\n\t\n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}