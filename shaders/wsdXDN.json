{
    "Shader": {
        "info": {
            "date": "1572043737",
            "description": "Just having fun with music visualization. Enjoy!\nYou can restart music in A buffer.\n\nMusic: Virtual Riot - Energy Drink\nhttps://soundcloud.com/virtual-riot/virtual-riot-did-i-mention-i",
            "flags": 96,
            "hasliked": 0,
            "id": "wsdXDN",
            "likes": 20,
            "name": "Speaker visualizer",
            "published": 3,
            "tags": [
                "visualization",
                "speaker"
            ],
            "usePreview": 0,
            "username": "jaszunio15",
            "viewed": 1514
        },
        "renderpass": [
            {
                "code": "//Shader License: CC BY 3.0\n//Author: Jan Mr√≥z (jaszunio15)\n\n/*\n\tThanks to Inigo Quilez, I leant a lot about SDF's from his articles:\n\thttps://iquilezles.org/articles/distfunctions\n\thttps://iquilezles.org/articles/smin\n*/\n\n\nfloat colorBrightness(vec3 col)\n{\n\treturn col.r + col.b + col.g;\n}\n\nvec2 uvFromCoord(vec2 coord)\n{\n\treturn coord / iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n#ifdef DENOISE\n    vec4 colors[9];\n    int operationIndex = 0;\n    float operationBrightness = 0.0;\n    int beginIndex = 0;\n    int endIndex = 8;\n    \n    float minBrightness = 10.0;\n    int minIndex = 0;\n    float maxBrightness = 0.0;\n    int maxIndex = -1;\n    \n    for (float y = -1.0; y <= 1.0; y++)\n    {\n     \tfor (float x = -1.0; x <= 1.0; x++)\n        {\n            colors[operationIndex].xyz = texture(iChannel0, uvFromCoord(fragCoord + vec2(x,y))).xyz;\n            colors[operationIndex].w = colorBrightness(colors[operationIndex].xyz);\n            operationIndex++;\n        }\n    }\n    \n    for (int i = 0; i < 4; i++)\n    {\n        minBrightness = 10.0;\n    \tmaxBrightness = 0.0;\n        minIndex = -1;\n        maxIndex = -1;\n    \tfor (int j = i; j < 9-i; j++)\n        {\n\t\t\tvec4 col = colors[j];\n            if (col.w < minBrightness)\n            {\n             \tminBrightness = col.w;\n                minIndex = j;\n            }\n            \n            if (col.w > maxBrightness)\n            {\n             \tmaxBrightness = col.w;\n                maxIndex = j;\n            }\n        }\n        \n        vec4 p = colors[beginIndex];\n        colors[beginIndex] = colors[minIndex];\n        colors[minIndex] = p;\n        \n        p = colors[endIndex];\n        colors[endIndex] = colors[maxIndex];\n        colors[maxIndex] = p;\n        \n        beginIndex++;\n        endIndex--;\n    }\n\n    vec4 col = (colors[4] * DENOISE_STRENGTH + texture(iChannel0, uv) * (1.0 - DENOISE_STRENGTH));\n#else\n    vec4 col = texture(iChannel0, uv);\n#endif\n    col = smoothstep(-0.05, 0.8, sqrt(col));\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14\n#define TIME (iTime * 0.2)\n#define RAYMARCH_ITERATIONS 50\n#define FAR_PLANE 10.0\n#define LIGHT_DIRECTION normalize(vec3(0.3, 0.3, (sin(TIME) + 1.0) * 0.1 + 0.03))\n#define AMBIENT_LIGHT 0.05\n\n//uncoment to disable denoising\n#define DENOISE\n#define DENOISE_STRENGTH 0.4\n\nfloat hash13(vec3 x)\n{\n \treturn fract(sin(dot(x, vec3(131.4211, 152.3422, 162.9441))) * 231.421);   \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define FREQ_STEP (1.0 / 512.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x = uv.x * uv.x;\n    float freq = 0.0;\n    for (float bandOffset = -FREQ_STEP * 3.0; bandOffset < FREQ_STEP * 3.1; bandOffset += FREQ_STEP)\n    {\n        freq += texture(iChannel1, vec2(bandOffset + uv.x, 0.0)).x;\n    }\n    freq /= 7.0;\n    freq = freq * freq;\n    \n    //for better preview xD\n    if (iResolution.x < 419.0) freq = smoothstep(0.0, 0.6, freq);\n    \n    fragColor = vec4(1.0, 0.0, 0.0, 0.0) * freq;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 20130,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/virtual-riot/virtual-riot-did-i-mention-i"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define FREQ_STEP (1.0 / 512.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float freq = 0.0;\n    for (float bandOffset = -FREQ_STEP * 3.0; bandOffset < FREQ_STEP * 3.1; bandOffset += FREQ_STEP)\n    {\n        freq += texture(iChannel0, vec2(bandOffset + uv.x, 0.0)).x;\n    }\n    freq /= 7.0;\n    freq = freq;\n    \n    freq = freq * 0.5 + texture(iChannel1, vec2(uv.x, 0.0)).x * 0.5;\n    \n    float line = smoothstep(0.005, 0.0, abs((uv.y - mod(uv.y, FREQ_STEP)) - freq));\n    \n    fragColor = vec4(1.0, 0.0, 0.0, 0.0) * freq + vec4(0.0, 1.0, 0.0, 0.0) * line;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "struct speakerData\n{\n  \tfloat bigMovement;\n    float smallMovement;\n    float hash;\n};\n    \nstruct material\n{\n \tfloat metallic;\n    float smoothness;\n};\n\nmat3x3 rotationMatrix(vec3 angle)\n{\n    return\t\t\t\n          mat3x3(cos(angle.y), 0.0, sin(angle.y),\n                 0.0, 1.0, 0.0,\n                 -sin(angle.y), 0.0, cos(angle.y))\n        \n\n        * mat3x3(1.0, 0.0, 0.0,\n                 0.0, cos(angle.x), sin(angle.x),\n                 0.0, -sin(angle.x), cos(angle.x))\n            \n        * mat3x3(cos(angle.z), sin(angle.z), 0.0,\n                 -sin(angle.z), cos(angle.z), 0.0,\n                 0.0, 0.0, 1.0);\n\n        \n}\n\nfloat sphereSDF(vec3 point, vec3 sphereCenter, float radius)\n{\n \tfloat dist = distance(point, sphereCenter);\n    return dist - radius;\n}\n\nfloat extrudeSDF(float sdf, float radius)\n{\n \treturn sdf - radius;   \n}\n\nfloat ringSDF(vec3 point, float radius, float width, float height)\n{\n    float ring2D = abs(length(point.xy) - radius) - width;\n    vec2 w = vec2( ring2D, abs(point.z) - height );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat torusSDF(vec3 point, float ringPosition, float ringRadius, float lineRadius)\n{\n    point.z -= ringPosition;\n \tvec2 flattedUV = vec2(length(point.xy) - ringRadius, point.z);\n    return length(flattedUV) - lineRadius;\n}\n\nfloat torusSDFRescaled(vec3 point, float ringPosition, float ringRadius, float lineRadius, vec3 scale)\n{\n    point.z -= ringPosition;\n    point *= scale;\n \tvec2 flattedUV = vec2(length(point.xy) - ringRadius, point.z);\n    return length(flattedUV) - lineRadius;\n}\n\nfloat planeSDF(vec3 point, float planeZPos)\n{\n \treturn point.z - planeZPos;   \n}\n\nfloat cylinderSDF(vec3 point, float radius)\n{\n \treturn length(point.xy) - radius;   \n}\n\nfloat coneSDF( vec3 point, vec3 coneCenter, float angle)\n{\n    vec2 c = vec2(sin(angle), cos(angle));\n    vec3 pos = point - coneCenter;\n    \n    return dot(c, vec2(length(pos.xy), pos.z));\n}\n\nfloat addObjectsSmooth(float obj1, float obj2, float smoothness ) \n{\n    float h = clamp( 0.5 + 0.5 * (obj2-obj1) / smoothness, 0.0, 1.0 );\n    return mix( obj2, obj1, h ) - smoothness * h * (1.0 - h); \n}\n\nfloat addObjects(float object, float objectToAdd)\n{\n\treturn min(object, objectToAdd);\n}\n\nfloat multiplyObjects(float object, float objectToMul)\n{\n \treturn max(object, objectToMul);   \n}\n\nfloat sdfObject(vec3 point, speakerData data)\n{\n    float movementRegion = smoothstep(2.12, 1.85, length(point.xy));\n    point.z += movementRegion * 0.23 * data.bigMovement;\n    point.z += (data.hash - 0.5) * data.smallMovement * movementRegion;\n    \n \tfloat object = 9999.9;\n    object = addObjects(object, torusSDF(point, -0.04, 2.0, 0.1));\n    float plane = multiplyObjects(planeSDF(point, 0.0), -sphereSDF(point, vec3(0.0), 2.0));\n    object = addObjectsSmooth(object, plane, 0.01);\n    \n    float insideSpeaker = coneSDF(point, vec3(0.0, 0.0, -1.64), -0.7);\n    \n    float waves = smoothstep(0.45, 0.35, abs(length(point.xy) - 1.35));\n    insideSpeaker -= max(sin(length(point.xy * 60.0)), -0.5) * 0.004 * waves;\n    insideSpeaker = addObjectsSmooth(insideSpeaker, sphereSDF(point, vec3(0.0, 0.0, -1.94), 1.2), 0.04);\n    insideSpeaker = multiplyObjects(insideSpeaker, sphereSDF(point, vec3(0.0), 1.911));\n   \n    object = addObjectsSmooth(object, insideSpeaker, 0.01);\n    \n    float frame = extrudeSDF(ringSDF(point - vec3(0.0, 0.0, 0.0), 2.25, 0.07, 0.005), 0.003);\n    object = addObjectsSmooth(object, frame, 0.01);\n\n    return object;\n}\n\nvec3 getNormal(vec3 hitPoint, speakerData data)\n{\n    float hitPointDist = sdfObject(hitPoint, data);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    normal.x = -hitPointDist + sdfObject(hitPoint + vec3(1.0, 0.0, 0.0) * 0.001, data);\n    normal.y = -hitPointDist + sdfObject(hitPoint + vec3(0.0, 1.0, 0.0) * 0.001, data);\n    normal.z = -hitPointDist + sdfObject(hitPoint + vec3(0.0, 0.0, 1.0) * 0.001, data);\n    return normalize(normal);\n}\n\n\n//xyz - hit point\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection, speakerData data)\n{\n    rayDirection = normalize(rayDirection);\n\tfor (int i = 0; i < RAYMARCH_ITERATIONS; i++)\n    {\n        float distanceToObject = sdfObject(rayOrigin, data);\n        rayOrigin += rayDirection * distanceToObject * 0.6;\n    }\n    \n    return rayOrigin;\n}\n\nfloat lightDotRayMarch(vec3 rayOrigin, vec3 rayDirection, speakerData data)\n{\n    vec3 startRayOrigin = rayOrigin;\n    rayDirection = normalize(rayDirection);\n    float minDist = 10.0;\n    float distanceToObject = 0.0;\n\tfor (int i = 0; i < RAYMARCH_ITERATIONS; i++)\n    {\n        distanceToObject = sdfObject(rayOrigin, data);\n        rayOrigin += rayDirection * distanceToObject * 0.7;\n        \n        minDist = min(minDist, abs(distanceToObject / distance(startRayOrigin, rayOrigin))); \n    }\n    \n    return minDist * smoothstep(0.0, 1.0, distanceToObject);\n}\n\nvec3 castPlaneCoordFromUV(vec2 uv)\n{\n\treturn vec3(uv.x, -0.8, uv.y);\n}\n\n//x - diffuse\n//y - specular\n//z - shadow\nvec3 getLight(vec3 hitPoint, vec3 normal, vec3 lightDirection, vec3 viewDirection, speakerData data, material mat)\n{\n\tfloat diff = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    vec3 halfWay = normalize((lightDirection + viewDirection) * 0.5);\n    float spec = pow(clamp(dot(normal, halfWay), 0.0, 1.0), mat.smoothness);\n    \n    float lightDot = lightDotRayMarch(hitPoint + lightDirection * 0.1, lightDirection, data);\n    float shadow = smoothstep(0.0, 0.1, lightDot);\n    \n    return vec3(diff * (1.0 - mat.metallic), spec * mat.metallic, (shadow + AMBIENT_LIGHT) * 0.8);\n}\n\n//x - diffuse\n//y - specular\nvec2 getCheapLight(vec3 hitPoint, vec3 normal, vec3 lightDirection, vec3 viewDirection, speakerData data, material mat)\n{\n \tfloat diff = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    vec3 halfWay = normalize((lightDirection + viewDirection) * 0.5);\n    float spec = pow(clamp(dot(normal, halfWay), 0.0, 1.0), mat.smoothness);\n    \n    return vec2(diff * (1.0 - mat.metallic), spec * mat.metallic);  \n}\n\nfloat musicVizualization(vec2 uv)\n{\n    float radius = 2.18;\n    float bandsCount = 200.0;\n    vec2 polarUV = vec2(atan(uv.y, uv.x), length(uv));\n    polarUV.x += PI;\n    polarUV.x /= PI * 2.0;\n    \n    \n    float bandX = fract(polarUV.x * bandsCount);\n    \n    polarUV.x -= mod(polarUV.x, 1.0 / bandsCount);\n    polarUV.x = pow(polarUV.x, 0.5);\n    \n    float border = smoothstep(0.4, 0.32, abs(bandX - 0.5));\n    float freq = texture(iChannel1, vec2(polarUV.x * polarUV.x, polarUV.y)).x;\n    freq *= freq * polarUV.x;\n    freq = smoothstep(-0.04, 0.4, freq) * 0.15;\n    return smoothstep(radius, radius + 0.01, polarUV.y) \n        * smoothstep(radius + freq, radius + freq - 0.01, polarUV.y)\n        * border * freq * 7.0;\n}\n\nfloat musicVizualization2(vec2 uv)\n{\n \tfloat len = length(uv);\n    len *= 9.0;\n    float bandX = fract(len);\n    \n    \n    \n    float freq = texture(iChannel1, vec2(fract(floor(len /*+ TIME * 23.0*/) * 0.1 + 0.1), 0.0)).x; \n    freq *= length(uv) + 0.2;\n    freq = smoothstep(0.0, 0.6, freq);\n    freq *= freq * freq;\n    \n    float centerLight = smoothstep(2.0, 0.0, length(uv));\n    centerLight *= pow(textureLod(iChannel1, vec2(0.3, 0.0), 0.5).x, 4.0) * 0.3;\n    \n    float borderWidth = 0.1 + centerLight * 3.0;\n    float border = smoothstep(borderWidth, borderWidth - 0.01, abs(bandX - 0.5));\n    \n    return freq * border * (smoothstep(0.8, 0.6, length(uv))) \n        + centerLight + centerLight * smoothstep(0.8, 0.79, length(uv)) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    vec3 cameraCenter = vec3(sin(TIME * 3.5) * 2.7, cos(TIME * 3.5) * 2.7, cos(TIME * 3.0) * 0.5 + 1.1);\n    vec3 castPlaneCoord = castPlaneCoordFromUV(uv);\n    \n    vec3 angle = vec3(-0.67 - cos(TIME * 3.0) * 0.2, sin(TIME * 2.7) * 0.3, TIME * 3.5);\n    \n        \n    castPlaneCoord *= rotationMatrix(angle);\n    \n    vec3 rayOrigin = cameraCenter;\n    vec3 rayDirection = castPlaneCoord;\n    \n    speakerData data;\n    data.bigMovement = sin(iTime * 100.0) * pow(textureLod(iChannel0, vec2(0.1, 0.0), 0.1).x * 1.0, 4.0) * 0.4;\n    data.bigMovement += sin(iTime * 143.0) * pow(textureLod(iChannel0, vec2(0.05, 0.0), 0.1).x * 1.0, 4.0) * 0.4;\n    //data.bigMovement += sin(iTime * 50.0) * pow(textureLod(iChannel0, vec2(0.02, 0.0), 0.1).x * 1.0, 4.0) * 0.4;\n    data.smallMovement = pow(texture(iChannel0, vec2(0.7, 0.0)).x * 1.4, 2.0) * 0.15;\n    data.hash = smoothstep(0.0, 1.0, hash13(vec3(uv, sin(iTime * 0.1))));\n    \n    vec3 hitPoint = rayMarch(rayOrigin, rayDirection, data);\n    float distanceToHitPoint = distance(cameraCenter, hitPoint);\n    \n    vec3 col = vec3(0.0);\n    if (distanceToHitPoint < FAR_PLANE)\n    {\n        col = vec3(0.1);\n        \n        material mat;\n        float centerRingRegion = smoothstep(0.55, 0.54, abs(length(hitPoint.xy) - 1.35));\n        \n        vec3 visColor = mix(sin(vec3(0.0, 3.0, 4.0) * TIME), vec3(1.0), 0.7) * 1.5;\n        \n        col += centerRingRegion * 0.7 * visColor;\n        mat.metallic = mix(0.8, 0.6, centerRingRegion);\n        mat.smoothness = mix(16.0, 4.0, centerRingRegion);\n        \n        vec3 normal = getNormal(hitPoint, data);\n        data.hash = hash13(vec3(uv, sin(iTime * 0.1)));\n        vec3 light = getLight(hitPoint, normal, LIGHT_DIRECTION, -rayDirection, data, mat);\n        \n        vec3 centerLightDirection = normalize(hitPoint - vec3(0.0, 0.0, -2.0));\n        mat.metallic = 1.0;\n        vec2 centerLight = getCheapLight(hitPoint, normal, -centerLightDirection, -rayDirection, data, mat);\n\n        float musicBounce = pow(textureLod(iChannel1, vec2(0.3, 0.0), 0.5).x, 4.0) * 2.0;\n\n        col = col * (light.x + light.y) * 0.4 * light.z * mix(visColor, vec3(1.0), 0.5) \n            + visColor * musicVizualization(hitPoint.xy) * smoothstep(-0.1, 0.2, musicBounce) * 0.6\n            + visColor * musicVizualization2(hitPoint.xy);\n        col += visColor * (centerLight.x + centerLight.y) * smoothstep(2.0, 1.0, length(hitPoint.xy)) * musicBounce * 3.0;\n        col *= 2.4;\n        col *= smoothstep(3.0, 2.4, length(hitPoint.xy));\n        //col += mix(diffuse, diffuse2, 0.0);\n    }\n    \n\n    // Output to screen\n    float freq = texture(iChannel0, vec2(fragCoord / iResolution.xy)).y;\n    //col = smoothstep(-0.07, 0.8, col);\n    //fragColor = vec4(1.0) * freq;\n    fragColor = vec4(col, 1.0) * 0.7 + texture(iChannel2, fragCoord / iResolution.xy) * 0.3;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}