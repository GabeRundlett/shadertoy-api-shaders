{
    "Shader": {
        "info": {
            "date": "1522029995",
            "description": "Inspired by segmented wood sculpture at https://www.youtube.com/watch?v=V1viPrqDxpo\nInteresting paths from a simple method. With much less gluing and sanding!\nChange nRings; and tweak AA and lengthFunction.\nThanks to iapafoto for major improvements!",
            "flags": 64,
            "hasliked": 0,
            "id": "4dycDW",
            "likes": 22,
            "name": "Endless spherical loop from tori",
            "published": 3,
            "tags": [
                "raymarching",
                "torus",
                "geometry",
                "paths"
            ],
            "usePreview": 0,
            "username": "huttarl",
            "viewed": 822
        },
        "renderpass": [
            {
                "code": "// Increase number of tori for more complexity.\n// #define nRings 7\n#define nRings (iTime / (20.0 * 3.14159))\n\n// Make this 1 if it's too slow.\n#define AA 2\n\n// Change to length, squareLength or hexLength if desired.\n#define lengthFunction length\n\n\n/**\n As in the \"Power of 7\" video https://www.youtube.com/watch?v=V1viPrqDxpo\n make a spherical, endless loop out of a set of tori.\n\n Start with n tori, spaced along the z-axis, centered about the z-axis.\n All tori share the same minor radius.\n The major radius and z displacement of each torus is constrained so that\n (1) the outer edge of each torus is tangent to a sphere centered at the origin, and \n (2) the 2n circles where the tori intersect the X-Z plane are evenly spaced around the\n   equator of the sphere.\n\n Now, rotate the top half of every torus around the y axis by 1/2n rotation (pi/n radians).\n We now have a single continuous loop tracing out the shape of the sphere.\n\n Elaborations:\n x animate the \"now, rotate\" step\n x keep rotating the top and bottom halves of the sphere by pi/n radians, so that\n   each upper half-torus-end gets connected to each lower half-torus-end in turn.\n   So you could now have more different ways of getting a single continuous loop,\n   and some ways of getting multiple separate loops that weren't the original configuration.\n x Of course we want to pause rotation for a while when everything is \"connected\".\n x If it's more convenient, we could change (1) to say that the circle whose radius is the\n   torus's major radius is on the sphere (so the sphere's surface cuts through the torus).\n - Could optionally or cyclically show the enclosing sphere itself, though with transparency.\n x The camera also orbits the scene, varying distance and altitude with sin(t * k). \n - Need some interesting texture on the tori.\n - Change nRings automatically over time. E.g. keep nRings = 2 for 6 steps, nRings = 3 for\n   9 steps, ... nRings = j for 3j steps. The rendering would get slower eventually, with many\n   rings.\n - When changing the number of rings, it would be nice to quickly rotate the whole assembly\n   around the x axis, so that the sudden change is disguised.\n - Maybe color each separate loop its own color. That would require solving which torus half\n   is in which loop, given n and i. Store this in an array mapping each lower half-torus to\n   a loop id. (Note to self: see my python code on how to implement this as a function.)\n - Maybe have some glowing bands, or other markings, flow along each torus. Flow direction\n   would half to take connectivity into account if it's going to match up.\n\n Using much code from IQ's Raymarching Primitives (https://www.shadertoy.com/view/Xds3zN).\n\n Question: Given n rings, with the top halves rotated i steps (i * pi / n radians) around\n the y axis, what is the number of separate loops (paths) in the result?\n So far my best guess is gcd(n, i).\n*/\n\n\nfloat squareLength(vec2 p)\n{\n    return max(abs(p.x), abs(p.y));\n}\n\nfloat hexLength(vec2 p)\n{\n    vec2 a = abs(p);\n    return max((2.0/sqrt(3.0))*a.x, (1.0/sqrt(3.0))*a.x + a.y);\n}\n\n\n//------------------------------------------------------------------\n// Distance functions\n//\n// Each function gives the distance from p to a primitive centered at the origin.\n// The position and orientation of the primitive is fixed. To simulate moving\n// the primitive, transform p in the opposite way.\n//\n// The s and u prefixes tell whether the result is signed or unsigned.\n// A signed function will return negative values for p inside the primitive;\n// an unsigned function will return 0.\n\n// Distance from p to plane (at y = 0)\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\n// Distance from p to torus around z axis with major radius t.x and minor radius t.y\nfloat sdTorus(vec3 p, vec2 t) {\n    return lengthFunction(vec2(lengthFunction(p.xy) - t.x, p.z)) - t.y;\n}\n\n\n//------------------------------------------------------------------\n// CSG operations\n\n// union primitives 1 and 2\n// d1 is a vec2 where .x is the distance, and .y is the color/material code.\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\n// Function of time to give progress, pause, progress, pause.\nfloat anim(float t) {\n    const float k = 4.;\n    // Expand 1 sec to k\n    float t2 = t / k;\n    float d = fract(t2) - (k - 1.) / k;\n    \n    return floor(t2) + smoothstep(0., 1., d * k);       \n}\n\n// Based on http://rosettacode.org/wiki/Greatest_common_divisor#Iterative_Euclid_algorithm\nint gcd(int u, int v) {\n    if (u < 0) u = -u;\n    if (v < 0) v = -v;\n    if (v != 0) {\n        while (((u %= v) != 0) && ((v %= u) != 0));\n    }\n    return (u + v);\n}\n\n// Which loop does lower half of torus i belong to?\n// s = how many steps the top halves are currently rotated.\nint whichLoop(int s, int i) {\n    int numLoops = gcd(nRings, s);\n    i = i % (numLoops * 2);\n    // To consider: collapse the conditional using math.\n    return (i < numLoops) ? i : numLoops * 2 - i - 1;\n}\n    \n#define sphereRadius 0.3\n\n//------------------------------------------------------------------\n// Return (x,y) where x is minimum distance from pos to objects in the scene, and\n// y is the material of the closest object.\nvec2 map(in vec3 pos)\n{\n    // Angular distance between places where rings intersect sphere equator.\n    const float theta = 3.14159 / float(nRings);\n    float minorRadius = min(0.04, sin(theta * 0.5) * sphereRadius * .75);\n    // y offset of tori\n    const float cy = sphereRadius + 0.1;\n    \n    // Rotate pos around z axis.\n    vec3 posrot = pos;\n    float step = anim(iTime * .5);\n    float beta = step * theta,\n          cb = cos(beta), sb = sin(beta);\n    posrot.xz *= mat2(cb, sb, -sb, cb);\n\n    float dtl = 9., dtu=9.; \n    for (int i=0; i < nRings; i++) {\n        float alpha = theta * (float(i) + .5);\n        vec2 offset = vec2(cos(alpha), sin(alpha)) * sphereRadius;\n        // This will have to be optimized ... using something similar to opU()\n        // but saving i, so that we only have to compute whichLoop() once per pixel.\n        // int loop = whichLoop(int(step), i);\n\n        // Distance to lower half-tori.\n        dtl = min(dtl, sdTorus(pos - vec3(0., cy, offset.x), vec2(offset.y, minorRadius)));\n\t\t// Distance to rotated upper half-tori.\n        dtu = min(dtu, sdTorus(posrot - vec3(0., cy, offset.x), vec2(offset.y, minorRadius)));\n    }        \n \n    // Ground plane\n    vec2 res = vec2(pos.y, 1.0);\n    \n    \n    // Union with closest half-torus.\n    return opU(res, vec2(min(max(dtl,  pos.y - cy),\n                             max(dtu, -pos.y + cy)), 25.0));    \n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.001;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n        // Precision threshold grows with distance from ray origin.\n        float precis = 0.0005*t;\n        vec2 res = map(ro + rd*t);\n        // Break when this step advances less than precision threshold.\n        if (res.x < precis || t > tmax) break;\n        t += .75 * res.x;\n        m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n// Cast a shadow ray from origin ro (an object surface) in direction rd\n// to compute soft shadow in that direction. Returns a lower value\n// (darker shadow) when there is more stuff nearby as we step along the shadow ray.\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal( in vec3 pos )\n{\n    // epsilon = a small number\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map( pos + e.xyy ).x + \n                      e.yyx*map( pos + e.yyx ).x + \n                      e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n    /*\n    vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n    */\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    // background sky color gradient\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    // cast ray to nearest object\n    vec2 res = castRay(ro,rd);\n    float t = res.x; // distance\n    float m = res.y; // material code\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor ); // reflected ray\n        \n        // material        \n        col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m < 1.5 )\n        {\n            // gray checkerboard floor material\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighting        \n        float occ = calcAO( pos, nor ); // ambient occlusion\n        vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) ); // sunlight\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 ); // ambient light\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ); // diffuse reflection from sunlight\n        // backlight\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y ); // dome light\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 ); // fresnel\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0); // specular reflection\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n        vec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        col = col*lin;\n\n        // mix in fog?\n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n\n// Compute camera-to-world transformation.\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // camera (ro = ray origin) \n        const float cameraDist = 1.0;\n        vec3 ro = vec3(cameraDist*cos(-0.1*time + 6.0*mo.x), 0.75 + 2.0*mo.y,\n                       -cameraDist*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3(0, 0.4, 0);\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render   \n        vec3 col = render( ro, rd );\n\n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 14138,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/gerlinda-van-den-berg/metamorphosis-2-philip-glass"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}