{
    "Shader": {
        "info": {
            "date": "1634283905",
            "description": "Draw a perpendicular to the circle diameter from a point on the circumference using only a straightedge (and pencil)",
            "flags": 0,
            "hasliked": 0,
            "id": "7sKXRz",
            "likes": 11,
            "name": "Straightedge Construction",
            "published": 3,
            "tags": [
                "sketch",
                "geometry",
                "proof"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "// \"Straightedge Construction\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Draw a perpendicular to the circle diameter from a point on the circumference\n using only a straightedge (and pencil).\n\n Construction steps shown in sequence. As with good Scandinavian furniture and toys,\n written instructions are superfluous.\n The final animated sequence shows that the results are independent of where the\n vertex of the second triangle is located.\n \n Remember:\n   Triangles with the diameter as hypotenuse and a vertex on the circumference are\n   right-angled (Thales).\n   Lines from a vertex that are perpendicular to the opposite edge intersect at a\n   common point (orthocenter).\n*/\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (3.5, 0.02, 3.5), 0.01);\n  DMINQ (1);\n  q.yz -= vec2 (0.07, -3.);\n  d = PrRoundBoxDf (q, vec3 (2.5, 0.01, 0.15), 0.03);\n  DMINQ (2);\n  q = p;\n  q -= vec3 (0.2, 0.05, -2.5);\n  q.xz = Rot2D (q.xz, 0.5 * pi);\n  q *= 2.5;\n  q.y -= 0.35;\n  d = PrRoundCylDf (q, 0.33, 0.03, 5.);\n  d = max (d, - dot (vec2 (q.z, dot (q.xy, cos (2. * pi * floor (16. * (atan (q.y, - q.x) / (2. * pi) +\n     0.5) + 0.5) / 16. + vec2 (0., 0.5 * pi)))), sin (-0.4 * pi + vec2 (0.5 * pi, 0.))) - 1.6);\n  d /= 2.5;\n  DMINQ (3);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (3.7, 0.06, 3.7), 0.02), - PrBox2Df (q.xz, vec2 (3.5, 3.5)));\n  DMINQ (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat DrLine (vec2 p, vec2 a, vec2 b, float w)\n{\n  vec2 v;\n  float s;\n  v = a - b;\n  s = 0.5 * length (v);\n  v = Rot2D (p - b, atan (v.y, - v.x)) + vec2 (s, 0.);\n  return smoothstep (0., 0.02, PrRoundBox2Df (v, vec2 (s, 0.001 * w), 0.0001 * w));\n}\n\nfloat DrSqr (vec2 p, vec2 a, float w)\n{\n  return smoothstep (0., 0.02, PrRoundBox2Df (p - a, vec2 (0.001 * w), 0.0001 * w));\n}\n\nfloat DrDot (vec2 p, vec2 a, float r)\n{\n  return smoothstep (0., 0.02, length (p - a) - 0.001 * r);\n}\n\nfloat Cross2 (vec2 u, vec2 v)\n{\n  return u.x * v.y - u.y * v.x;\n}\n\nvec2 LineInt (vec2 a, vec2 u, vec2 b, vec2 v)\n{\n  return b + (Cross2 (a - b, u) / Cross2 (v, u)) * v;\n}\n\nvec4 GeomCol (vec2 p, vec4 col4)\n{\n  vec3 col;\n  vec2 pc[2], pd[2], pr[2], pt[4], vDir[4], c, sb;\n  float tCyc, tFlic, ang[2], vt[2], rad, lWid, sqSz, dotSz;\n  tCyc = mod (tCur, 26.);\n  tFlic = step (0.5, mod (4. * tCur, 1.));\n  c = vec2 (1., 0.);\n  lWid = 3.;\n  sqSz = 40.;\n  dotSz = 50.;\n  rad = 1.;\n  pd[0] = vec2 (rad, 0.);\n  pd[1] = vec2 (- rad, 0.);\n  ang[0] = 0.2 * pi;\n  ang[1] = (0.6 + 0.2 * sin (max (0., tCyc - 14.))) * pi;\n  for (int k = 0; k < 2; k ++) {\n    pr[k] = Rot2D (pd[0], ang[k]); // triangle vert on circle\n    vDir[k] = normalize (pr[k] - pd[k]);\n    vt[k] = atan (vDir[k].y, - vDir[k].x);\n  }\n  pt[0] = LineInt (pd[0], vDir[0], pd[1], vDir[1]); // top line-line intersect\n  pc[0] = vec2 (pt[0].x, sqrt (rad * rad - pt[0].x * pt[0].x)); // top line-circle intersect\n  pc[1] = pc[0] * vec2 (1., -1.); // bottom line-circle intersect\n  vDir[2] = normalize (pr[0] - pc[0]);\n  pt[1] = LineInt (pc[0], vDir[2], vec2 (0.), vec2 (1., 0.)); // right line-axis intersect\n  pt[2] = LineInt (pd[0], pr[1] - pd[0], pd[1], pr[0] - pd[1]);  // orthocenter\n  vDir[3] = normalize (pt[1] - pc[1]);\n  pt[3] = pc[1] + (sqrt (dot (pc[1], vDir[3]) * dot (pc[1], vDir[3]) + rad * rad - dot (pc[1], pc[1])) -\n     dot (pc[1], vDir[3])) * vDir[3]; // lower-right line-circle intersect\n  sb = vec2 (0.05, -0.05);\n  col = col4.rgb;\n  if (tCyc >= 2.) {\n    col = mix (c.xyy, col, DrDot (p, pr[0], 2. * dotSz));\n  }\n  if (tCyc >= 1.) {\n    col = mix (c.yyx, col, smoothstep (0., 0.02, abs (length (p) - rad)));\n    col = mix (c.yxy, col, smoothstep (0., 0.02, PrRoundBox2Df (p, pd[0], 0.01)));\n  }\n  if (tCyc >= 2. && tCyc < 4.) {\n    col = mix (0.3 * c.xxx, col, max (tFlic, DrLine (p, pr[0], vec2 (pr[0].x, 0.), 3. * lWid)));\n    col = mix (0.3 * c.xxx, col, max (tFlic, DrSqr (p, vec2 (pr[0].x, 0.) + sb.yx, sqSz))); \n  }\n  if (tCyc >= 4.) {\n    for (int k = 0; k < 2; k ++)\n       col = mix (c.yxy, col, DrLine (p, pd[k], pr[0], 2. * lWid));\n    if (tCyc < 10.) col = mix (0.3 * c.xxx, col, DrSqr (Rot2D (p - pr[0], vt[0]), sb, sqSz)); \n  }\n  if (tCyc >= 5.) {\n    col = mix (c.xyy, col, DrDot (p, pr[1], dotSz));\n    for (int k = 0; k < 2; k ++)\n       col = mix (c.yxy, col, DrLine (p, pd[k], pr[1], 2. * lWid));\n    if (tCyc < 10.) col = mix (0.3 * c.xxx, col, DrSqr (Rot2D (p - pr[1], vt[1]), sb.xx, sqSz)); \n  }\n  if (tCyc >= 6.) {\n    for (int k = 0; k < 2; k ++)\n       col = mix (c.yxx, col, DrLine (p, pr[k], pr[k] + 2.9 * vDir[k], lWid));\n    col = mix (c.xyy, col, DrDot (p, pt[0], dotSz));\n    col = mix (0.5 * c.xyx, col, DrDot (p, pt[2], dotSz));\n  }\n  if (tCyc >= 7.) {\n    col = mix (0.8 * c.xxy, col, DrLine (p, pt[0], pt[2] + 1.8 * rad * normalize (pt[2] - pt[0]), lWid));\n    for (int k = 0; k < 2; k ++)\n       col = mix (c.xyy, col, DrDot (p, pc[k], dotSz));\n    if (tCyc < 9.) col = mix (0.3 * c.xxx, col, DrSqr (p, vec2 (pt[0].x, 0.) + sb.xx, sqSz)); \n  }\n  if (tCyc >= 8.) {\n    col = mix (c.yxx, col, DrLine (p, pc[0], pc[0] + 2.7 * vDir[2], lWid));\n    col = mix (c.yxx, col, DrLine (p, pd[0], pd[0] + 1.5 * vec2 (1., 0.), lWid));\n    col = mix (c.xyy, col, DrDot (p, pt[1], dotSz));\n  }\n  if (tCyc >= 9.) {\n    col = mix (c.yxx, col, DrLine (p, pc[1], pt[1], 1.5 * lWid));\n  }\n  if (tCyc >= 10.) {\n    col = mix (c.xyy, col, DrDot (p, pt[3], dotSz));\n    if (tCyc < 14.) {\n      col = mix (0.3 * c.xxx, col, max (tFlic, DrLine (p, pt[3], pr[0], 3. * lWid)));\n      col = mix (0.3 * c.xxx, col, max (tFlic, DrSqr (p, vec2 (pr[0].x, 0.) + sb.yx, sqSz))); \n    } else {\n      col = mix (0.3 * c.xxx, col, DrLine (p, pt[3], pr[0], 3. * lWid));\n    }\n  }\n  if (tCyc >= 0.5) {\n    for (int k = 0; k < 2; k ++)\n       col = mix (0.3 * c.xxx, col, DrDot (p, pd[k], 0.6 * dotSz));\n  }\n  if (col != col4.rgb) col4 = vec4 (col, 0.2);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, r, z, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == 1) {\n      col4 = vec4 (0.95, 0.95, 0.95, 0.);\n      if (qHit.y > 0.) col4 = GeomCol (ro.xz, col4);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.8, 0.7, 0.5, 0.3);\n     } else if (idObj == 3) {\n      r = length (qHit.xy);\n      col4 = mix (vec4 (0.9, 0.7, 0.1, 0.1), vec4 (1., 0.9, 0.1, 0.01), step (0.34, r));\n      col4 = mix (vec4 (0.3, 0.3, 0.3, 0.1), col4, step (0.18, r));\n      col4 = mix (vec4 (0.8, 0.4, 0.1, 0.), col4, step (qHit.z, 4.5));\n      z = abs (qHit.z - 4.2);\n      col4 = mix (vec4 (0.9, 0.9, 1., 0.3), col4, step (0.3, z));\n      col4 = mix (vec4 (0.5, 0.5, 0.5, 0.3), col4, step (0.03, abs (z - 0.27)));\n    } else if (idObj == 4) {\n      col4 = vec4 (0.2, 0.2, 0.5, 0.1);\n    }\n    if (idObj == 2 || idObj == 3 && step (0.3, z) < 0.) nDotL *= nDotL * nDotL;\n    col = col4.rgb * ((0.2 + 0.8 * nDotL) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n  } else {\n    col = vec3 (0., 0., 0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.35 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -0.2, -20.);\n  zmFac = 5.5;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}