{
    "Shader": {
        "info": {
            "date": "1679377759",
            "description": "Mirror Room by DiLemming is one of my favorite shaders.\nI've always wanted to make the smallest raytracer (with reflections) on Shadertoy ... this is my second attempt trying to reach 500 chars.\nCan you make it shorter?",
            "flags": 0,
            "hasliked": 0,
            "id": "dscSRH",
            "likes": 4,
            "name": "Golfing Mirror Room 2-387 chars",
            "published": 3,
            "tags": [
                "raytracing",
                "reflections",
                "mirror",
                "short",
                "golf"
            ],
            "usePreview": 0,
            "username": "GregRostami",
            "viewed": 255
        },
        "renderpass": [
            {
                "code": "// The original Mirror Room by DiLemming is 1911 chars:\n// https://www.shadertoy.com/view/4sS3zc\n// 387 chars - Farbrice and Greg did some further golfing ...\n\n// below, is intersection with sphere center=x, radius=r \n#define S(x)                                                   \\\n    a  = dot(D, X=x+P),                                        \\\n    a -= sqrt( a*a - dot(X, X) + r),                           \\\n    a > 0. && a < t ? t = a, n = normalize(t*D - X) : n,//\n#define v vec3//\n#define K S( sign(D) * 98./R\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    float t, l=0.,                      // t,n: keep temporary hit. a,X: tmp var\n          r, a, T=iTime;                // r: radius param for S ( wall = ~infinite )\n\tv R = iResolution, n, X,            // P+lD = cur point along the ray\n\t  P = v(sin(T*.4), 1, 4),           // moving camera position\n      D = normalize( v( u+u, R) - R  ); // camera points forward\n\t\n\tfor (o *= l; o.a++ < 17.; o.rgb *= 1. - n*n/l)  // 17 reflections\n    \n        t = r = 9e3,              // radius of large spheres that are the walls\n        K.zxx)                     // right & left wall\n        K.xzx)                     // floor & ceiling\n        K    )                     // front & back wall\n        \n        S( v(r=1.,      -2, 1))    // Static Sphere\n        S( v(-1, sin(T)-.9, 0))    // Moving Sphere\n        a = dot (n, D),\n        P -= t*D,\n        D -= 2.* n*a,              // D = reflect(D, n)\n        l += t,\n        o += a*a * 1.4 / l;        // Shading calculations\n}\n\n\n// 399 chars - After applying Fabric's golfing from the other shader ...\n/*\n#define v vec3//\n#define S(x)                                                   \\\n    a  = dot(D, X=x+P),                                          \\\n    a -= sqrt( a*a - dot(X, X) + r),                     \\\n    a > 0. && a < t ? t = a, n = normalize(t*D - X) : n,//\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float t, l=0., r, a, T=iTime;\n\tv R = iResolution, n, N, X,\n         V = v(99, 0, 0),\n\t     P = v(sin(T*.5), 1, 4),          //moving camera position\n         D = normalize( v( u+u, R) - R  ); //camera points forward\n\t\n\tfor (o *= l; o.a++ < 17.; o.rgb *= 1. - n*n/l)  // 17 reflections\n    \n        t = r = 92e2,            //radius of large spheres that are the walls\n        N = sign(D),\n        S( V     * N )          // right & left wall\n        S( V.yxz * N )          // floor & ceiling\n        S( V.zyx * N )          // front & back wall\n        \n        S( v(r=1.,      -2, 1)) // Static Sphere\n        S( v(-1, sin(T)-.9, 0)) // Moving Sphere\n        a = dot (n, D),\n        P -= t*D,\n        D -= 2.* n*a,           // D = reflect(D, n)\n        l += t,\n        o += a*a * 1.4 / l;     // Shading calculations\n}*/\n\n/*\n// 428 chars - Xor dukes it out with Fabrice in an EPIC golfing battle. ;-)\n// Further golfing by Greg ...\n#define v vec3\n#define S(x)                                                   \\\n    b = dot(D, P-x),                                           \\\n    b = -sqrt( b*b - dot(P-x, P-x) + r*r) - b,                 \\\n    b > 0. && b < t ? t = b, p = P + t*D, n = normalize(p - x)*1.01 : n,\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float t, b, l=0., r, T=iTime;\n\tv R = iResolution, p, n, N,\n         V = v(63, 0, 0),\n\t     P = -v(sin(T*.5), 1, 4),        //moving camera position\n         D = normalize( v( u+u, R) - R  );  //camera points forward\n\t\n\tfor (o *= 0.; R.z++ < 17.;  // 16 reflections\n        o += b*b, o.rgb *= 1. - n*n/l)\n        t = r = 60.,//radius of large spheres that are the walls\n        S( V * (N=sign(D)) )     // right & left wall\n        S( V.yxz * N) // floor & ceiling\n        S( V.zyx * N ) //front & back wall\n        \n        S( v(r=1.,      -2, 1)) //Static Sphere\n        S( v(-1, sin(T)-.9, 0)) //Moving Sphere\n\t\tl += t,\n\t\tb = dot (n, D) / l,\n\t\tP = p + n/1e4, \n        D = reflect (D, n);\n\n    o /= .1;\n}\n*/\n\n// 463 chars - More Fabrice MAGIC!\n/*\n#define S(v)                                                   \\\n    b = dot(D, P-v),                                           \\\n    k = -sqrt( b*b - dot(P-v, P-v) + r*r) - b,                 \\\n    k > 0. && k < t ? t = k, p = P + t*D, n =  normalize(p - v) : n,\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float k, t, b, l=0., r, T=iTime;\n\tvec3 R = iResolution, p, n,\n         V = vec3 (53, 0, 0),\n\t     P = vec3(sin(T*.5),-1.5,-4),           //moving camera position\n         D = normalize( vec3( u+u, R.x) - R  ); //camera points forward\n\t\n\tfor (o *= 0.; R.z++ < 17.;  // 16 reflections\n         o = (o + b*b) * (1. - n*n/.1/l/l).rgbb)\n        r = 50., //radius of large spheres that are the walls\n        t = 9.,\n        S(  V )     // right wall\n        S( -V )     // left wall\n        S( -V.yxz ) // floor\n        S(  vec3 (0,51, 0) ) // ceiling\n        S(  V.zyx ) // back wall\n        S( -V.yzx ) // front wall\n        r = 1.,\n        S( vec3 (-1, sin(T)-.9, 0)) //Moving Sphere\n        S( vec3 ( 1,        -2, 2)) //Static Sphere\n\t\tl += t,\n\t\tb = dot (n, D) / l,\n\t\tP = p + n/1e4, \n        D = reflect (D, n*1.01);\n\n    o /= .1;\n}\n*/\n\n// 496 chars - Fabrice golfed away more chars\n/*\n#define S(v)                                                   \\\n    k = dot(D,D), b = dot(D, P-v),                             \\\n    k = (-sqrt(b * b - k * dot(P-v, P-v) + k * r*r) - b) / k;  \\\n    if ( k > 0. && k < t ) t = k, p = P + t*D, n =  (p - v)/r;\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float k, t, b, l=0., r, T=iTime;\n\tvec3 R = iResolution, p, n,\n         V = vec3 (53, 0, 0),\n\t     P = vec3(sin(T*.5),-1.5,-4),           //moving camera position\n         D = normalize( vec3( u+u, R.x) - R  ); //camera points forward\n\t\n\tfor (o *= 0.; R.z++ < 17.;  // 16 reflections\n         o = (o + b*b) * (1. - n*n/.1/l/l).rgbb) {\n        r = 50.; //radius of large spheres that are the walls\n        t = 9.;\n        S(  V );     // right wall\n        S( -V );     // left wall\n        S( -V.yxz ); // floor\n        S(  vec3 (0,51, 0) ); // ceiling\n        S(  V.zyx ); // back wall\n        S( -V.yzx ); // front wall\n        r = 1.;\n        S( vec3 (-1, sin(T)-.9, 0)); //Moving Sphere\n        S( vec3 ( 1,        -2, 2)); //Static Sphere\n\t\tl += t;\n\t\tb = dot (n, D) / l;\n\t\tP = p + n/1e4, \n        D = reflect (normalize(D), n*1.1);\n\t}\n    o /= .1;\n}\n*/\n\n// This version works on my iMac.\n// If the above version doesn't work on your device, try this version:\n// I also like the lowered ceiling\n\n// 520 chars\n/*\n#define S(v,r)                                      \\\n    k = dot(D,D), b = dot(D, P-v),                  \\\n    g = b * b - k * dot(P-v, P-v) + k*r*r,          \\\n    k = (-sqrt(g) - b) / k;                         \\\n    if (g > 0. && k > 0. && k < t ) t = k, p = P + t*D, n =  (p - v)/r;\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float k, t, b, l=0., g, r=50., T=iTime;\n\tvec3 R = iResolution,p,n,\n         V = vec3 (53, 0, 0),\n\t     P = vec3(sin(T*.5),-1.5,-4), \n         D = normalize( vec3( u+u, R.x) - R  );\n\t\n\tfor (o *= 0.; R.z++ < 17.;) {\n        t = 1e9;\n        S( V,r); //right\n        S( -V,r); //left\n        S( -V.yxz,r); //floor\n        S( vec3 (0,51, 0),r); //ceiling\n        S( V.zyx,r); //back\n        S( -V.yzx,r); //front\n        \n        S( vec3 (-1, sin(T)-.9, 0), 1.); //Moving Sphere\n        S( vec3 ( 1,       -2., 2), 1.); //Static Sphere\n\t\tl += t;\n\t\tb = dot (n, D) / l;\n\t\tP = p + n/1e4, \n        D = reflect (normalize(D), n) ;\t\n\t\to = (o + b*b) * (1. - n*n/.1/l/l).rgbb;\n\t}\n    o /= .1;\n}\n*/\n\n// 501 chars - Original shader by Greg. The walls of the room are large spheres.\n/*\n#define S(v,r)                                                 \\\n    k = dot(D,D), b = dot(D, P-v),                             \\\n    k = (-sqrt(b * b - k * dot(P-v, P-v) + k * r*r) - b) / k;  \\\n    if ( k > 0. && k < t ) t = k, p = P + t*D, n =  (p - v)/r;\n    \nvoid mainImage( out vec4 o, vec2 u ) {\n    float k, t, b, l=0., T=iTime,\n          r = 50.; //radius of large sphere\n\tvec3 R = iResolution, p, n,\n         V = vec3 (53, 0, 0),\n\t     P = vec3(sin(T*.5),-1.5,-4),           //moving camera position\n         D = normalize( vec3( u+u, R.x) - R  ); //camera points forward\n\t\n\tfor (o *= 0.; R.z++ < 17.;  // 16 reflections\n         o = (o + b*b) * (1. - n*n/.1/l/l).rgbb) {\n        t = 1e9;\n        S(  V, r );     // right wall\n        S( -V, r );     // left wall\n        S( -V.yxz, r ); // floor\n        S(  V.yxz, r ); // ceiling\n        S(  V.zyx, r ); // back wall\n        S( -V.yzx, r ); // front wall\n        \n        S( vec3 (-1, sin(T)-.9, 0), 1.); //Moving Sphere\n        S( vec3 ( 1,        -2, 2), 1.); //Static Sphere\n\t\tl += t;\n\t\tb = dot (n, D) / l;\n\t\tP = p + n/1e4, \n        D = reflect (normalize(D), n);\n\t}\n    o /= .1;\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}