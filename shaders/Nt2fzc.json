{
    "Shader": {
        "info": {
            "date": "1655027715",
            "description": "A 4Kb Graphics Executable for Shadow Party 2022.\n(2nd Place - Newschool Graphics)\nInspired by the song 'God's Front Porch' by The British IBM and Apollo 11.\n",
            "flags": 64,
            "hasliked": 0,
            "id": "Nt2fzc",
            "likes": 52,
            "name": "God's Front Porch (4Kb)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "4k",
                "demoscene",
                "space",
                "stars",
                "moon",
                "apollo",
                "4kb",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 4679
        },
        "renderpass": [
            {
                "code": "// 'God's Front Porch' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/Nt2fzc (YouTube: https://youtu.be/VXBp4hXvNG0)\n//\n// A 4Kb Graphics Executable for Shadow Party 2022.\n// (2nd Place - Newschool Graphics)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Inspired by the song 'God's Front Porch' by The British IBM\n// and Apollo 11.\n// Michael Collins waited in moon orbit whilst the others got to\n// land on the moon, so was the most isolated human in existence.\n//\n// The quote is actually from Gene Cernan on Apollo 17, but I\n// figure I can be 'inspired' by what I like. :p\n//\n// As always, trying to improve my shader skillz. This time\n// trying out some subtle effects such as glass shine,\n// moon/light glare, and the 'viewing window'.\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - The SDF function only adds fine details if the ray\n//     is near the surface of the ship.\n//   - Shadow calculations exclude the moon.\n//   - The window frame is a 2D effect.\n//   - AA only applied on pixels where the neighbouring\n//     pixel is a significantly different color.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n#define AA\t// Disable if your GPU is melting.\n\n#define MIN_DIST\t.0015\n#define MAX_DIST\t380.\n#define MAX_STEPS\t90.\n#define MAX_RDIST\t320.\n#define MAX_RSTEPS\t40.\n#define SHADOW_STEPS\t30.\n#define LIGHT_RGB\tvec3(2)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, c, i)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, c, i); }\n\nfloat t;\nstruct Hit {\n\tfloat d;\n\tvec3 p;\n\tint id;\n};\n\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .103, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, 270) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nvec3 n3331(vec3 p, vec3 s) {\n    vec3 ns;\n    for (int i = I0; i < 3; i++)\n        ns[i] = n31(p * s[i]);\n    return ns;\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 5.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat opRep(float p, float c) {\n\tfloat c2 = c * .5;\n\treturn mod(p + c2, c) - c2;\n}\n\nvec3 opModPolar(vec3 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.y, p.z) + angle + o, 2. * angle) - angle;\n\treturn vec3(p.x, length(p.yz) * vec2(cos(a), sin(a)));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cone(vec3 p, float h, float r1, float r2) {\n\tvec2 q = vec2(length(p.yz), p.x),\n\t     k1 = vec2(r2, h),\n\t     k2 = vec2(r2 - r1, 2. * h),\n\t     ca = vec2(q.x - min(q.x, (q.y < 0.) ? r1 : r2), abs(q.y) - h),\n\t     cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0., 1.);\n\treturn ((cb.x < 0. && ca.y < 0.) ? -1. : 1.) * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 sky(vec2 rd) {\n\tfloat n,\n\t      b = sat(1. - dot(rd, rd));\n\trd *= 32.;\n\tn = h21(floor(rd));\n\tvec2 uv = fract(rd) + n * 1.6 - 1.3;\n\treturn S(n * .001, 0., dot(uv, uv)) * .2 * n + vec3(pow(b, 12.));\n}\n\nfloat jet(vec3 q, float x) {\n\tfloat d = cone(q, .15, 0., .08 - .007 * (sin(x * 148.5) * .5 + .5));\n\tq.x -= .15;\n\treturn max(d, .05 - length(q));\n}\n\n#define BODY_ID\t1\n#define BODYG_ID\t2\n#define CONE_ID\t3\n#define RADSEPS_ID\t4\n#define WINDOW_ID\t5\n#define ABOVE_ARE_REFLECTIVE\t6\n#define NOZZLE_ID\t7\n#define RADIATORS_ID\t8\n#define MOON_ID\t9\n#define WHITE_ID\t10\n\nHit ship(vec3 p) {\n\tvec3 q;\n\tp.y -= .5;\n\tp.z += 8.;\n\tp.xy *= mat2(.99875, -.04998, .04998, .99875);\n\tp.xz *= mat2(.99022, .13954, -.13954, .99022);\n\tp.yz *= rot(1.3 + t / 60.);\n\tp.y += mix(3.5, 0., t / 20.);\n\n\t// Main body.\n\tfloat f, a,\n\t      d = cyl(p, vec2(2, 2.25));\n\n\t// Scimitar antenna.\n\tHit h = Hit(cyl(p.zyx + vec3(0, 1.9, -.2), vec2(.34, .03)), p, WHITE_ID);\n\n    if (d < 2.) {\n\t\t// We're near the main body - Add details.\n        \n        // Body bumps.\n        q = p.zxy;\n        q.xz *= rot(0.52);\n        q.y = abs(abs(q.y + .48) - .36) - .36;\n        minH(cyl(q, vec2(.15, 2.004)), p, BODYG_ID);\n        \n\t\t// Rivets.\n\t\tq = p;\n\t\tq.x = opRep(q.x, .08);\n\t\tq = opModPolar(q, 18., 0.);\n\t\tq.z = abs(q.z) - .03;\n\t\tq.y -= 1.992;\n\t\tf = length(q) - .012;\n\t\tf = max(f, abs(p.x - .35) - 1.9);\n\t\td = min(d, f);\n\n\t\t// Radiator separators.\n\t\ta = atan(p.y, p.z);\n\t\tf = cos(a * 8.);\n\t\tq = p;\n\t\tq.x += 1.9;\n\t\tminH(cyl(q, vec2(step(f + .5, 0.) * .03 + 1.99, .3)), p, RADSEPS_ID);\n\n\t\t// Radiator grills.\n\t\ta = abs(abs(p.x + .4) - 1.7) - .5;\n\t\ta += step(0., p.x) * step(a + 4.5, 2.1);\n\t\tf = min(1., step(0., f + .25) + step(2., q.x));\n\t\tfloat ox = q.x;\n\t\tq.x = opRep(q.x, .2);\n\t\tf = cyl(q, vec2(1.89 + (f - sat(a)) * .12, .015));\n\t\tf = min(max(f, abs(ox) - .3), max(f, abs(ox - 3.2) - .5));\n\t\td = min(d, f);\n\n\t\t// RCS modules (aka steering thrusters).\n\t\tq = p;\n\t\tq.xzy = opModPolar(q, 4., .78);\n\t\tq.x++;\n\t\tq.z -= 2.;\n\t\tf = box(q, vec3(.24 - q.z * .3, .14 - q.z * .3, .2)); // Base\n\t\tminH(f, p, WHITE_ID);\n\t\tq.z -= .12;\n\t\tvec3 qq = q;\n\t\tq.x = abs(q.x) - .28;\n\t\td = min(d, jet(q, p.x)); // Nozzle pair 1.\n\t\tq = qq.yxz;\n\t\tq.x = abs(q.x) - .14;\n\t\td = min(d, jet(q, q.x)); // Nozzle pair 2.\n\t}\n\n\t// Nose cone.\n\tf = abs(abs(p.x + 3.3) - .9);\n\tf = step(.01, f) * .004;\n\ta = cone(p + vec3(3.7, 0, 0), 1.45, .55 - f, 2.01 - f);\n\td = min(d, a);\n\tif (a < 1.)     {\n\t\t// We're near the nose cone - Add details.\n\t\td += step(abs(p.x + 2.8), .01) * .004;\n\n\t\t// Pitch engines.\n\t\tq = p;\n\t\tq.x += 2.6;\n\t\tq = opModPolar(q, 5., -.22);\n\t\tq.z = abs(q.z) - .16;\n\t\td += .004 * S(.12, .1, length(q.xz));\n\n\t\t// Nose windows.\n\t\tq = p + vec3(3.55 - .3 * step(-1., p.z), 0, 0);\n\t\tf = box(opModPolar(q, 5., .2), vec3(.18, 9, .18));\n\t\td = min(max(d, .15 - f), a + .004);\n\t\td = max(d, .05 - f);\n\t\tminH(a + .05, p, WINDOW_ID);\n\n\t\t// Docking point.\n\t\tq = p;\n\t\tq.x += 5.8;\n\t\tf = length(q) - .1; // End ball.\n\t\tq.x -= .35;\n\t\tf = min(f, cyl(q, vec2(.04, .3))); // Center rod.\n\t\tq.xzy = opModPolar(q, 4., 0.);\n\t\tq.z -= .4;\n\t\tq.x = -sqrt(q.x * q.x + .005);\n\t\tq.xz *= mat2(.70721, .707, -.707, .70721);\n\t\tf = min(f, max(cyl(q, vec2(.03, .5)), q.x)); // Slopey bits.\n\t\td = min(d, f);\n\t}\n\n\t// Exhaust nozzle.\n\tq = p;\n\tq.x -= 3.7;\n\tf = .06 * S(.05, -.05, abs(q.x - .7));\n\td = min(d, cone(q, 1.5, .5 + S(-1.2, 2., q.x), 1.25) - f);\n\tif (p.x > 0.) {\n\t\t// Directional antenna.\n\t\tq = p;\n\t\tq.xz -= 2.;\n\t\tf = cyl(q.zyx, vec2(.06, 1));\n\t\tq.x += .2;\n\t\tq.z--;\n\t\tfloat b = S(-.2, -.5, q.x) * .05 + .06;\n\t\tf = min(f, box(q, vec3(.5, b, b)));\n\t\td = min(d, f);\n\t\tq.x += .5;\n\t\tq.yz = abs(q.yz) - .3;\n\t\tf = abs(length(q) - .53) - .015;\n\t\tf = max(f, .46 - q.x);\n\t\td = min(d, f);\n\t}\n\n\tminH(d, p, BODY_ID);\n\treturn h;\n}\n\nfloat moonSDF(vec3 p) {\n\tp += vec3(118, 164, -460);\n\n\t// Base moon radius.\n\tfloat r = length(p) - 4e2,\n\t      f = 0.;\n\tif (r > 10.) return r;\n\n\t// Add surface details.\n\tfor (float c = .01; c <= .03; c += .01) {\n\t\tvec2 uv = p.xy * c,\n\t\t     dxy = h22(floor(uv)) * .5;\n\t\tuv = fract(uv) - .5 + dxy;\n\t\tfloat d = S(-.1, 0., length(uv) + (max2(dxy) - .5));\n\t\td *= 3.1 - 127. * c + 17e2 * c * c;\n\t\tf += d;\n\t}\n\n\treturn r - f - fbm(p * .1) * 4.;\n}\n\nHit map(vec3 p) {\n\tHit h = ship(p);\n\tminH(moonSDF(p), p, MOON_ID);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .25;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .05,\n\t      mxt = length(p - vec3(-25, 45, -40));\n\tvec3 ld = normalize(vec3(-25, 45, -40) - p);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = ship(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.02, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nvec2 aof(vec3 p, vec3 n, vec2 h) {\n    vec2 ao;\n    for (int i = I0; i < 2; i++)\n        ao[i] = ship(h[i] * n + p).d;\n    return sat(ao / h);\n}\n\nbool reflecting = false;\nvec3 lights(vec3 p, vec3 rd, inout vec3 n, Hit h, inout float r) {\n\tfloat ao, l1, l2, fre, spec,\n\t      freCutOff = .95,\n\t      sha = 1.,\n\t      l3c = 1.;\n\tvec3 c,\n\t     ld = normalize(vec3(-25, 45, -40) - p),\n\t     freRGB = vec3(0);\n\tvec2 spe = vec2(10, 1);\n\tif (h.id == MOON_ID) {\n\t\tl3c = 0.;\n\t\tspe.y = .04;\n\t\tc = vec3(49, 48, 46) / 85e2;\n\t\tc -= .004 * S(.7, 1., -n.z);\n\t\tfreRGB = vec3(1);\n\t\tfreCutOff = .5;\n\t\tif (reflecting) {\n\t\t\t// Less harsh fresnel when rendering a reflection.\n\t\t\tc *= 10.;\n\t\t\tfreRGB = vec3(.2);\n\t\t\tfreCutOff = .05;\n\t\t}\n\t}\n\telse {\n\t\tsha = shadow(p);\n\t\tfloat a = atan(h.p.y, h.p.z) / 6.28318 + .5;\n        vec3 ns = n3331(h.p, vec3(4, 15, 40));\n\t\tif (h.p.x > 3.) {\n\t\t\t// Exhaust Nozzle\n\t\t\tif (h.p.x > 4.35) c = vec3(4.9, 4.8, 4.15) / 255.;\n\t\t\telse {\n\t\t\t\tfloat f = S(.2, 0., abs(fract(a * 12.) - .5)) * .2;\n\t\t\t\tf += S(4.4, 3., h.p.x);\n\t\t\t\tc = mix(vec3(176, 141, 87) / 85e2, vec3(176, 141, 87) / 2550., f);\n\t\t\t\tspe = vec2(5, 4);\n\t\t\t}\n\n\t\t\tc *= .7 + .3 * ns.y;\n\t\t}\n\t\telse {\n\t\t\tif (h.id != RADSEPS_ID) { if ((length(h.p.yz) < 2.1 && abs(h.p.x - 1.3) < .5) || abs(h.p.x + 1.9) < .3) h.id = WHITE_ID; }\n\n\t\t\telse if (abs(h.p.x + 1.8) + step(.22, fract(a * 8. + .6)) < .06) h.id = WHITE_ID;\n\n\t\t\tif (h.id == WINDOW_ID) {\n\t\t\t\tr = 1.;\n\t\t\t\tc = vec3(.01, .01, .013) * .24;\n\t\t\t\tspe = vec2(3, 30);\n\t\t\t}\n\t\t\telse if (h.p.x < -2.3) {\n\t\t\t\t// Nose cone.\n\t\t\t\tr = .8;\n\t\t\t\tfloat f = .1 * sin(a * 2e2);\n\t\t\t\tn.y += f * f;\n\t\t\t\tn += (ns.x - .5 + .1 * ns.y - .05) * .03;\n\t\t\t\tspe = vec2(50, 20);\n\t\t\t\tc = vec3(.001);\n\t\t\t\tc += pow(sat(dot(rd, reflect(ld, n))), 5.) * .03;\n\t\t\t\tc *= .7 + .15 * (ns.y + ns.z);\n\t\t\t}\n\t\t\telse if (h.id == WHITE_ID) {\n\t\t\t\t// White panels.\n\t\t\t\tc = vec3(.45);\n\t\t\t\tc *= .9 + .05 * (ns.y + ns.z);\n\t\t\t\tl3c = .1;\n\t\t\t\tsha = .6 + .4 * sha;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Main body.\n\t\t\t\tr = .1;\n\t\t\t\tn += (ns.x - .5) * .03;\n\t\t\t\tspe = vec2(2, 3);\n\t\t\t\tc = vec3(27, 23, 21) / 255.;\n\t\t\t\tc += pow(sat(dot(rd, reflect(ld, n))), 5.) * .2;\n\t\t\t\tc *= .7 + .15 * (ns.y + ns.z);\n\n\t\t\t\t// Fake paneling.\n\t\t\t\tif (h.id == BODY_ID) {\n\t\t\t\t\tfloat fr, fb,\n\t\t\t\t\t      f = h21(floor(vec2(a * 18., h.p.x * 2.)));\n\t\t\t\t\tc += .04 * (f - .5);\n\t\t\t\t\tspe.y += f;\n\n\t\t\t\t\t// Flag.\n\t\t\t\t\th.p.x += .65;\n\t\t\t\t\th.p.z += .2;\n\t\t\t\t\th.p.xz *= 1.5;\n\t\t\t\t\tf = S(.02, 0., max(abs(h.p.z - .35) - .32, abs(h.p.x + 1.1) - .2));\n\t\t\t\t\tfr = S(-.25, .25, sin(h.p.x * 1e2 - 1.));\n\t\t\t\t\tfb = S(.01, 0., h.p.x + 1.09) * S(.02, 0., .38 - h.p.z);\n\t\t\t\t\tc = mix(c, vec3(.1, 0, 0), fr * f);\n\t\t\t\t\tc = mix(c, vec3(0, 0, .03), fb * f);\n\t\t\t\t\tl3c *= (1. - fr * f);\n\t\t\t\t\tl3c *= (1. - fb * f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    vec2 ao2 = aof(p, n, vec2(0.05, .5));\n\tao = mix(ao2.x, ao2.y, .7);\n\tl1 = sat(.1 + .9 * dot(ld, n));\n\tl2 = sat(.3 + .7 * dot(-vec3(.23487, .32642, -.91558), n));\n\tfre = S(1., freCutOff, 1. + dot(rd, n));\n\tspec = pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y;\n\tfloat spec2 = pow(sat(dot(rd, -n)), 40.) * l3c;\n\tl1 += spec;\n\tl1 *= .01 + .99 * sha;\n\tl2 *= ao;\n\tc = mix(freRGB, (l1 + l2) * c * LIGHT_RGB + spec2 * vec3(.14, .13, .1), fre);\n\tif (!reflecting) c += pow(sat(dot(rd, vec3(-.89443, .44721, 0))), 4.) * .2; // Glare.\n\treturn c;\n}\n\nvec3 scene(vec3 p, vec3 rd) {\n\t// March the scene.\n\tfloat i,\n\t      d = 3.,\n\t      r = 0.;\n\tHit h;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < MIN_DIST || d > MAX_DIST) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tvec3 col,\n\t     n = N(p, d);\n\tif (d > MAX_DIST) return sky(rd.xy);\n\tcol = lights(p, rd, n, h, r);\n\tif (r > 0.) {\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\td = 0.;\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < MIN_DIST * d || d > MAX_RDIST) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tif (d < MAX_RDIST) {\n\t\t\tn = N(p, d);\n\t\t\treflecting = true;\n\t\t\tcol += r * lights(p, rd, n, h, i);\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 35.);\n\tvec3 ro = vec3(-t / 15., 1. - t / 15., -20),\n\t     col = vec3(1);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy,\n\t     cp = vec2(uv.y * .4 - uv.x + .85, uv.x - uv.y + 1.1);\n\tcol *= S(0., .05, min2(cp));\n\tif (col.r > 0.) {\n\t\t// Main scene.\n\t\tvec3 aa = scene(ro, rayDir(ro, uv));\n#ifdef AA\n\t\tif (fwidth(aa.g) > .1) {\n\t\t\tfor (float dx = -.5; dx <= .5; dx++) {\n\t\t\t\tfor (float dy = -.5; dy <= .5; dy++)\n\t\t\t\t\taa += scene(ro, rayDir(ro, uv + vec2(dx, dy) / R.xy));\n\t\t\t}\n\n\t\t\taa *= 0.2;\n\t\t}\n#endif\n\n\t\tcol *= aa;\n\t\tcp = uv * mat2(.95534, -.29552, .29552, .95534);\n\n\t\t// Screen glare.\n\t\tcol += pow(S(-.5, .1, uv.y) * S(.15, 0., abs(cp.x - .72) * (1.5 - uv.y)), 1.3) * vec3(.5, .8, 1) * .025;\n\t}\n\telse {\n\t\t// Viewing window.\n\t\tcol = vec3(.03, .01, .01) * S(.1, -.1, min2(abs(cp + .1)));\n\t\tcol += S(.03, -.03, abs(cp.x + .06)) * S(-.5, 0., uv.y) * vec3(.08, .04, .002);\n\t}\n    \n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(max(vec3(0), col), vec3(.45)) * sat(t), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 29052,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/thebritishibm/aidy-gods-front-porch"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}