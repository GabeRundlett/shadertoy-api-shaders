{
    "Shader": {
        "info": {
            "date": "1588710961",
            "description": "Ok its not a real rigid body it actually acts more like IK bones. Try dragging the points around. Its easier to manipulate by turning on \"smallmode\" in common tab. Also try turning gravity off. (Reset to get a totally new structure!)",
            "flags": 32,
            "hasliked": 0,
            "id": "WdXBzf",
            "likes": 8,
            "name": "Rigid (ish) structure",
            "published": 3,
            "tags": [
                "2d",
                "mouse",
                "particle"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 459
        },
        "renderpass": [
            {
                "code": "// Reset shader to get a new structure every time\nvec2 R;\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n\n    vec3 col = vec3(0);\n    vec4 bA = getA(u);\n    \n    for(int i = 0; i < nVerts; i++){\n        col.g += ss(vr, vr-2., length(u.xy - getA(ivec2(i, 0)).xy));\n        col.b += step(0.1,float(i))*ss(3., 1., line(u, getA(ivec2(i, 0)).xy, \n                                                    getA(ivec2(i-1, 0)).xy));\n    }\n    \n    col.rgb += 1.-step(FLOOR, u.y);\n    \n    f = vec4(col, 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 R;\nbool th=false;\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    int id = int(u.x);\n    \n    if(id <= nVerts){\n    \tvec4 bA = getA(ivec2(id, 0));\n    \tvec4 bC = getC(ivec2(id, 0));\n        \n        vec4 s0 = getA(ivec2(id+1, 0)), s1 = getA(ivec2(id-1, 0));\n        vec2 dir = vec2(0), dir2 = vec2(0);\n        float dif = 0., dif2 = 0.;\n        \n        // difference between cuurent distance and initial distance is how far to move\n        if(id == 0){\n            dif = length(bA.xy-s0.xy) - bC.y;\n            dir = normalize(bA.xy-s0.xy);\n        }\n        else if(id == nVerts-1){\n            dif = length(bA.xy-s1.xy) - bC.x;\n            dir = normalize(bA.xy-s1.xy);\n        }\n        else{\n            dif = length(bA.xy-s0.xy) - bC.y;\n            dir = normalize(bA.xy-s0.xy);\n            dif2 = length(bA.xy-s1.xy) - bC.x;\n            dir2 = normalize(bA.xy-s1.xy);\n        }\n        \n        bA.zw -= (dif*dir.xy)*dt;\n        bA.zw -= (dif2*dir2.xy)*dt;\n        \n        if(bA.y-vr <= FLOOR){\n            bA.z = 0.;\n            th=true;\n        }\n        \n        bA.w -= g*dt;\n        \n        bA.y += bA.w*dt;\n        bA.x += bA.z*dt;\n        \n        bA.z -= bA.z*0.1;\n        bA.w -= bA.w*0.01;\n        \n       if(th) bA.y += abs(bA.y-vr - FLOOR);\n       \n        \n       if(iMouse.z > 0. && length(bA.xy - iMouse.xy) <= vr){\n        \tbA.xy = iMouse.xy;\n            bA.zw = vec2(0);\n    \t}\n        \n   \t\tif(iFrame == 0){\n            #ifdef smallmode\n            bA.xy = hash22(u + iDate.w)*R.xy * 0.5 + R.xy*0.25;\n            #else\n        \tbA.xy = hash22(u + iDate.w)*R.xy;\n            #endif\n            bA.zw = vec2(0.);\n   \t\t}\n        \n    \tf = bA;\n    }\n    else return;\n        \n    \n   \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n\n#define getA(id) texelFetch(iChannel0, ivec2(id), 0)\n#define getC(id) texelFetch(iChannel2, ivec2(id), 0)\n\n#define FLOOR iResolution.y / 32.\n\n// vertice screen radius\n#define vr 20.\n\n// lets you drag the joints around easier\n//#define smallmode\n\n// number of verts to connect to\nconst int nVerts = 28;\n\n// gravity stuff\nfloat g = 2.; \nfloat dt = 0.15;\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Inital lengths to connected verts\nvoid mainImage( out vec4 f, in vec2 u ){\n    int id = int(u.x);\n    \n \tif(id <= nVerts){\n        vec4 bC = getC(ivec2(id, 0));\n        float d0 = bC.x, d1 = bC.y;\n        \n    \tif(iFrame == 0){\n            if(id == 0){\n                d0 = 0.;\n                d1 = length(getA(ivec2(id, 0)).xy - getA(ivec2(id+1, 0)).xy);\n            }\n            else if(id == nVerts){\n                d0 = length(getA(ivec2(id, 0)).xy - getA(ivec2(id-1, 0)).xy);\n                d1 = 0.;\n            }\n            else{\n                d0 = length(getA(ivec2(id, 0)).xy - getA(ivec2(id-1, 0)).xy);\n                d1 = length(getA(ivec2(id, 0)).xy - getA(ivec2(id+1, 0)).xy);\n            }\n    \t}\n        \n        f = vec4(d0, d1, 0., 0.);\n    }\n    else return;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}