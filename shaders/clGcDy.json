{
    "Shader": {
        "info": {
            "date": "1700582419",
            "description": "Bounce time over TIME_FRAME_OF_BOUNCE period, alllow mouse to interact X rotates, Y zooms",
            "flags": 0,
            "hasliked": 0,
            "id": "clGcDy",
            "likes": 4,
            "name": "Dynamic Geometric Color mousable",
            "published": 3,
            "tags": [
                "lmage"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "// Fork of \"Dynamic Geometric Color Flow\" by wwwww. https://shadertoy.com/view/DldyDX\n// 2023-11-21 14:11:55\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#define TIME_FRAME_OF_BOUNCE  100.0     // after 100 seconds it get's too chaotic so I bounce backwards \n\n// floating point only version\nfloat recomputeTimeIntoSeeSawOfTimeframe(float theTime) {\n   float timeSlice = theTime/TIME_FRAME_OF_BOUNCE;\n   float numIterations = floor( timeSlice );\n   float posInSlice = fract(timeSlice);\n   \n   // is this a even or odd slice, even slices go backwards..\n   if( fract(numIterations/2.0) == 0.0) {\n       // even slice, go forwards through slice\n       return TIME_FRAME_OF_BOUNCE*posInSlice;\n   } else {\n       // backwards through Time Slice\n       return TIME_FRAME_OF_BOUNCE*(1.0-posInSlice);\n   }\n}\n\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,0.1) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 finalColor = vec3(0.0);\n\n    // make time bounce back and forth over TIME_FRAME_OF_BOUNCE period\n    float theTime = recomputeTimeIntoSeeSawOfTimeframe( iTime);\n    \n    // allow mouse to rotate/zoom\n    uv = mouseRotZoom(uv);\n\n    vec2 uv0 = uv;\n    \n    float time = theTime * 0.2;\n    \n\n    for (float i = 0.0; i < 4.0; i++) {\n        // 特定の時間に基づいて変化する幾何学的変換\n        //Geometric transformation that changes based on a specific time\n        /*TMM\n        if (iTime > 5.0) {\n        TMM*/\n        \n        \n            uv = uv + vec2(sin(uv.y * time), cos(uv.x * time));\n        /*TMM\n        } else {\n            uv = fract(uv * 1.5) - 0.5;\n        }\n        TMM*/\n        \n        float d = length(uv) * exp(-length(uv0));\n\n        // カラーパターンの多様化\n        //Diversification of color patterns\n        vec3 col = palette(length(uv0) + i * .4 + theTime/*iTime*/ * .4);\n        vec3 newCol = vec3(sin(time), cos(time), sin(time) * cos(time));\n        col = mix(col, newCol, 0.5); // 新しい色と既存の色をミックス //Mix new and existing colors\n\n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}