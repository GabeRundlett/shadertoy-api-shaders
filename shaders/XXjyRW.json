{
    "Shader": {
        "info": {
            "date": "1727038000",
            "description": "originals https://www.shadertoy.com/view/Ns23W3",
            "flags": 1,
            "hasliked": 0,
            "id": "XXjyRW",
            "likes": 3,
            "name": "caleidoscope and color",
            "published": 3,
            "tags": [
                "colorful",
                "color",
                "combination"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 94
        },
        "renderpass": [
            {
                "code": "\n#define iterations 10\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define time iTime\n#define resolution iResolution.xy\n#define PI (atan(1.)*4.)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.23-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)),\n             dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453123) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 p) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2\n    const float K2 = 0.211324865; // (3-sqrt(3))/6\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    float m = step(a.y, a.x);\n    vec2 o = vec2(m, 1.0 - m);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    h = h * h * h * h;\n\n    vec3 grad = vec3(dot(a, hash(i + vec2(0.0))),\n                     dot(b, hash(i + o)),\n                     dot(c, hash(i + vec2(1.0))));\n    return dot(h, grad) * 70.0;\n}\n\nvec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c) * p;\n}\n\nfloat noise4(vec2 uv, float time) {\n    float f = 0.5;\n    float frequency = 1.75;\n    float amplitude = 0.5;\n    for(int i = 0; i < 7; i++) {\n        vec2 offset = rotate(vec2(log(time + 3.0), log(time + 3.0) / 9.0), time / 99.0);\n        f += amplitude * noise(frequency * uv - offset);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return f;\n}\n\n\n#define S 4.\n// the wave amplitude\n#define A 1.9\n// the wave lenght\n#define WAVEL 1.1\n\n\n// taken from thebookofshaders.com\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n// taken from thebookofshaderx.com\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec2 cartesianToPolar(vec2 cartesian) {\n    float r = length(cartesian);          \n    float theta = atan(cartesian.y, cartesian.x); \n    return vec2(r, theta);  \n    \n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n        // Remap the space to -1. to 1 in a function of time\n\n    uv.x *= iResolution.x/iResolution.y;\n    //uv = sin(iTime) * uv +uv * cos(iTime);\n    \n   // uv = rotate2d( sin(iTime)) * uv;\n    \n   \n    //uv = cartesianToPolar(uv);\n    vec2 wave1Center = vec2(-1., -0.5);\n    //vec2 wave2Center = vec2(1., 0.5);\n    wave1Center= vec2(0.);\n    \n    float disFromWave1Center = distance(uv, wave1Center);\n    //float disFromWave2Center = distance(uv, wave2Center);\n    \n    float wave1 =  A * sin(disFromWave1Center / WAVEL - iTime / WAVEL);\n    //float wave2 =  A * sin(disFromWave2Center / WAVEL - iTime / WAVEL) ;\n \n    uv = uv + uv * (wave1) / WAVEL;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\nvec2 uPos = ( gl_FragCoord.xy / resolution.y );//normalize wrt y axis\n\tuPos -= vec2((resolution.x/resolution.y)/2.0, 0.5);//shift origin to center\n\t\n\tfloat multiplier = 0.0005; // Grosseur\n\tconst float step = 0.006; //segmentation\n\tconst float loop = 80.0; //Longueur\n\tconst float timeSCale = 0.5; // Vitesse\n\t\n\tvec3 blueGodColor = vec3(0.0);\n\tfor(float i=1.0;i<loop;i++){\t\t\n\t\tfloat t = time*0.02*timeSCale-step*i*i;\n\t\tvec2 point = vec2(0.75*sin(t), 0.5*sin(t));\n\t\tpoint += vec2(0.75*cos(t*4.0), 0.5*sin(t*3.0));\n\t\tpoint /= 11. * sin(i);\n\t\tfloat componentColor= multiplier/((uPos.x-point.x)*(uPos.x-point.x) + (uPos.y-point.y)*(uPos.y-point.y))/i;\n\t\tblueGodColor += vec3(componentColor/3.0, componentColor/3.0, componentColor);\n\t}\n\t\n\t vec2 p = fragCoord / iResolution.xy;\n    vec2 uv2 = p * vec2(iResolution.x / iResolution.y, 0.8);\n    uv2 = rotate(uv2, log(iTime) / -7.0);\n    vec4 O= fragColor;\n    vec2 C=fragCoord;\n O=vec4(0);\n    vec3 p3,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.6)*.02*exp(-.3*i*i*e)\n    )\n    {\n        p3=g*d+vec3(0,0,iTime*.0);\n        p3=asin(cos(p3*PI/3.))/PI*3.;\n        s=3.;\n        for(int i;i++<6;)\n         \n          \n            p3=abs(p3-vec3(1.5,1,1.1))-vec3(1.1,1.3,1),\n               p3.x<p3.z?p3=p3.zyx:p3,\n            \n            s*=e=2.2/clamp(dot(p3,p3),.5+sin(iTime*.101),2.3),\n            \n            p3=abs(p3)*e;\n          \n        g+=e=length(p3.xz)/s;\n    }\n\n    // Define color intervals\n    const float interval = 10.0;\n    vec3 dblue = interval * vec3(1.8, 2.6, 2.6);\n    vec3 cyan = interval * vec3(0.0, 2.1, 2.0);\n    vec3 magenta = interval * vec3(1.8, 1.0, 1.8);\n\n    vec3 color = vec3(0.75);\n\n    // First noise layer\n    float f = noise4(uv + noise4(uv, iTime) * (log(iTime + 1.0) + iTime / 60.0), iTime);\n    color += f * normalize(dblue);\n\n    // Second noise layer\n    f = noise4(f * rotate(uv, sin(iTime / 11.0)) + f * noise4(f * uv, iTime), iTime);\n    color += f * normalize(cyan);\n\n    // Third noise layer\n    f = noise4(f * rotate(uv, iTime / 7.0) + f * noise4(uv, iTime) * noise4(uv, iTime), iTime);\n    color += f * normalize(magenta);\n\n    // Normalize color\n    color = normalize(color)*normalize(color)*normalize(color);\n\tvec3 color2 = vec3(0,0,1.0);\n\tcolor2 += pow(blueGodColor,vec3(0.1,0.3,1.2));\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tvec4 o = fragColor;\n    vec2 F =fragCoord;\n vec2 R = iResolution.xy; \n    o-=o;\n    for(float d,t = iTime*.01, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1)*0.2;                 \n    }\n\n\tvec3 from=vec3(1.,.5,0.5)*color*O.xyz;\n\n\tfloat intensity = 0.7; // Bright effect\n\tvec2 offset = vec2(0 , 0); // x / y offset\n\tvec3 light_color = vec3(1, 0.5, 0.5); // RGB, proportional values, higher increases intensity\n\tfloat master_scale = 0.2 + 0.02*sin(time); // Change the size of the effect\n\tfloat c = pow(master_scale/(length(uv+offset)), -0.1*sin(time) + intensity);\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=O;\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n\n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.35,0.2,1.15)*10., 1.0);\n    \n    }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}