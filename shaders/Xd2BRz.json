{
    "Shader": {
        "info": {
            "date": "1499770438",
            "description": "Multi-sphere version. Use mouse to change IOR: x axis for the bigger one, y axis for the smaller one. Note that the number of rays grows exponentially as you increase MAX_DEPTH.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xd2BRz",
            "likes": 4,
            "name": "Reflection and Refraction 3",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "refraction",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "Takoa",
            "viewed": 650
        },
        "renderpass": [
            {
                "code": "#define FLT_MAX 3.40282347e+38\n\n#define GAMMA 2.2\n#define MAX_DEPTH 5\n\nstruct HitInfo\n{\n    bool hits;\n    float t;\n    vec3 objectPosition;\n};\n\nfloat getFresnelFactor(vec3 l, vec3 n, float eta1, float eta2)\n{\n    float c = abs(dot(l, n));\n    float g = sqrt((eta2 * eta2) / (eta1 * eta1) - 1.0 + c * c);\n    float gpc = g + c;\n    float gmc = g - c;\n    float f1 = c * gpc - 1.0;\n    float f2 = c * gmc + 1.0;\n    \n    return 0.5 * (gmc * gmc) / (gpc * gpc) * (1.0 + (f1 * f1) / (f2 * f2));\n}\n\nHitInfo getSphereCoefficient(vec3 rayOrigin, vec3 rayDirection, vec3 center, float radius)\n{\n    vec3 difference = rayOrigin - center;\n    float b = dot(difference, rayDirection);\n    float c = dot(difference, difference) - radius * radius;\n    float d = b * b - c;\n    float t1 = -b - sqrt(abs(d));\n    float t2 = -b + sqrt(abs(d));\n    \n    if (d < 0.0 || t2 < 0.0)\n    {\n        return HitInfo(false, FLT_MAX, vec3(0.0));\n    }\n    else\n    {\n        return HitInfo(true, 0.0 <= t1 ? t1 : t2, center);\n    }\n}\n\nbool isPointInsideSphere(vec3 spherePosition, float radius, vec3 point)\n{\n    vec3 d = spherePosition - point;\n    \n    return d.x * d.x + d.y * d.y + d.z * d.z <= radius * radius;\n}\n\n////////////////////////////////////////////////////////////\n//\n// Edit BOTH getHitInfo and getIor to configure the spheres\n//\n////////////////////////////////////////////////////////////\nHitInfo getHitInfo(vec3 rayOrigin, vec3 rayDirection)\n{\n    HitInfo objects[2] = HitInfo[2]\n    (\n        getSphereCoefficient(rayOrigin, rayDirection, vec3(0.0, 0.0, 0.0), 1.0),\n        getSphereCoefficient(rayOrigin, rayDirection, vec3(1.5, 0.0, 0.0), 0.2)\n    );\n    HitInfo hi = objects[0];\n    \n    if (objects[1].t < hi.t)\n    {\n        hi = objects[1];\n    }\n\n    return hi;\n}\n\nfloat getIor(vec3 position, float defaultIor)\n{\n    float object1Ior = iMouse.x < 5.0 ? 1.5 : iMouse.x / iResolution.x + 1.0;\n    float object2Ior = iMouse.y < 5.0 ? 1.5 : iMouse.y / iResolution.y + 1.0;\n    float ior;\n    \n    ior = isPointInsideSphere(vec3(0.0, 0.0, 0.0), 1.0, position) ? object1Ior : defaultIor;\n    ior = isPointInsideSphere(vec3(1.5, 0.0, 0.0), 0.2, position) ? object2Ior : ior;\n    \n    return ior;\n}\n\nvec3 getNormal(vec3 hitPoint, HitInfo hi)\n{\n    return normalize(hitPoint - hi.objectPosition);\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 right = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * right + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float numRays = pow(2.0, float(MAX_DEPTH));\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 cameraPosition = 2.0 * vec3(-sin(iTime), 0.0, cos(iTime));\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraLookingAt = vec3(0.0);\n    \n    vec3 d = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < int(numRays); i++)\n    {\n        vec3 rayOrigin = cameraPosition;\n        vec3 rayDirection = d;\n        float eta1 = 1.0;\n        float ratio = 1.0;\n        float hitCount = 0.0;\n        vec3 v = vec3(0.0);\n        \n        for (int j = 0; j < MAX_DEPTH; j++)\n        {\n            HitInfo hi = getHitInfo(rayOrigin, rayDirection);\n            \n            if (hi.hits)\n            {\n                vec3 hitPoint = rayOrigin + rayDirection * hi.t;\n                vec3 normal = getNormal(hitPoint, hi);\n                float eta2 = getIor(hitPoint + rayDirection * 0.00001, 1.0);\n                float f = getFresnelFactor(-rayDirection, normal, eta1, eta2);\n                \n                hitCount++;\n                normal = dot(rayDirection, normal) <= 0.0 ? normal : -normal;\n                \n                if ((i & 1 << j) == 0)\n                {\n                    rayDirection = reflect(rayDirection, normal);\n                    ratio *= f;\n                }\n                else\n                {\n                    rayDirection = refract(rayDirection, normal, eta1 / eta2);\n                    ratio *= 1.0 - f;\n                    eta1 = eta2;\n                }\n                \n                rayOrigin = hitPoint + rayDirection * 0.00001;\n                ratio = clamp(ratio, 0.0, 1.0);\n            }\n            else\n            {\n                v = texture(iChannel0, rayDirection).xyz * ratio * pow(2.0, hitCount);\n                \n                break;\n            }\n        }\n        \n        color += v / numRays;\n    }\n    \n    //fragColor = vec4(pow(color, vec3(1.0 / GAMMA)), 1.0);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}