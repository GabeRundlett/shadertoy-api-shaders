{
    "Shader": {
        "info": {
            "date": "1560963003",
            "description": "https://www.reddit.com/r/math/comments/c2fiql/a_very_interesting_fractal/\n\nQuick&dirty shadertoy \"port\".",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl2GWy",
            "likes": 10,
            "name": "f(z) = i^z + c",
            "published": 3,
            "tags": [
                "fractalsmandelbrot"
            ],
            "usePreview": 0,
            "username": "JJJK",
            "viewed": 811
        },
        "renderpass": [
            {
                "code": "/*\nMade by reddit user /u/jpayne36\n*/\n\nfloat scale = 1.0 / 128.0;\nvec2 pos = vec2(0.0, 0.0);\n\nfloat e = 2.718281828459045;\nfloat pi = 3.14159265;\n\nstruct cmplx { float r; float i; };\ncmplx c() { return cmplx(0.0, 0.0); }\ncmplx c(float r) { return cmplx(r, 0.0); }\ncmplx c(float r, float i) { return cmplx(r, i); }\n\ncmplx add(cmplx c1, cmplx c2) { return cmplx(c1.r + c2.r, c1.i + c2.i); }\ncmplx sub(cmplx c1, cmplx c2) { return cmplx(c1.r - c2.r, c1.i - c2.i); }\ncmplx mul(cmplx c1, cmplx c2) { return cmplx(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r); }\ncmplx div(cmplx c1, cmplx c2)\n{\n\tif (c2.r == 0.0 && c2.i == 0.0) { return c(); }\n\treturn cmplx( (c1.r*c2.r + c1.i*c2.i)/(c2.r*c2.r + c2.i*c2.i), (c1.i*c2.r - c1.r*c2.i)/(c2.r*c2.r + c2.i*c2.i) );\n}\n\nfloat c_abs(cmplx c) { return sqrt(c.r*c.r + c.i*c.i); }\ncmplx c_pow(cmplx c1, cmplx c2)\n{\n\tif (c1.r == 0.0 && c1.i == 0.0) { return c(); }\n\tfloat r, a, c, d;\n\tr = c_abs(c1);\n\tif (c1.r == 0.0) { a = pi / 2.0; } else { a = atan(c1.i/c1.r); }\n\tc = ( pow(r, c2.r) )/( pow(e, c2.i*a) );\n\td = c2.i*log(r) + c2.r*a;\n\treturn cmplx(c*cos(d), c*sin(d));\n}\n\nint mandelbrot(cmplx a, cmplx z, int iters)\n{\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tif (c_abs(z) > 100.0) { return i; }\n\t\tz = add( c_pow(c(0.0,1.0), z), a );\n\t}\n\treturn iters;\n}\n\nvec4 effect(vec2 screen_coords)\n{\n\tvec2 uv = screen_coords/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\tvec2 xy = vec2( (uv.x - iResolution.x/iResolution.y/2.0)/scale + pos.x, (uv.y - 0.5)/scale + pos.y );\n\tint a = mandelbrot( c(xy.x, xy.y), c(), 100 );\n\tfloat col = float(a)/100.0;\n\treturn vec4(vec3(col), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = sin(iTime*0.2)*0.5 + 0.5;\n    pos = vec2(0.0, -0.2);\n    float maxZoom = exp(9.5);\n    scale = mix(1.0/128.0, maxZoom/128.0, f);\n    \n    fragColor = effect(fragCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}