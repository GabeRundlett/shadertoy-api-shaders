{
    "Shader": {
        "info": {
            "date": "1472370621",
            "description": "Capped Bulb Using Petal Shade",
            "flags": 32,
            "hasliked": 0,
            "id": "lt3GDs",
            "likes": 0,
            "name": "Capped Bulb",
            "published": 3,
            "tags": [
                "bulb"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 517
        },
        "renderpass": [
            {
                "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nfloat time = iTime;\n//map the sphere\nfloat map(vec3 p)\n{\n    float a = length(sin(p)*2.0-1.0) - sin(time);\n    float b = a/2.0;\n    float c = b/2.0;\n    float d = c/2.0;\n    float e = d/2.0;\n    float f = e/2.0;\n    \n    float cC = clamp(dot(a, b) - c * d, e / a - f, f * c) - 0.25;\n    return cC + length(p);\n}\n//tracing a circle for the shape of the center of the optical illusional semi-capped cone\nfloat s1( vec2 uv, vec2 p )\n{\n    float t = 0.0;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    //rotation\n    vec3 ro = vec3(sin(time*2.0), 0.0, -1.9);\n    //get edges (canvas covering with white)\n    //try == , >, <, <= also for coverage.\n    if(dot(min(p.x,uv.x), max(p.y,uv.x)) != dot(max(p.x,uv.y), min(p.y,uv.y)))\n    {\n        //raytrace\n        for(int i = 0; i < 24; i++)\n        {\n            vec3 p = ro+t*rd;\n            float d = map(p);\n            t += d * 0.5;\n        }\n        //get the length of rd\n        float f = length(rd);\n        //and get distance of sphere.\n        t += sqrt(distance(-f, f)) * 0.5;\n    }\n    // make vr fog\n    float fog = 1.0/(1.0+t*t*0.1);\n    return fog;\n}\n//layers of optical illusional semi-capped cone\nfloat a( vec2 canvas, vec4 branch )\n{\n    float sort = max(max(branch.s, branch.t), max(branch.p, branch.q));\n    float re_sort = min(min(branch.s, branch.t), min(branch.p, branch.q));\n    #define sorted if(sort == re_sort){a = t + n;}\n    #define unsorted if(sort != re_sort){a = t - n;}\n    #define gsorted if(sort > re_sort){a = t * n;}\n    #define lsorted if(sort < re_sort){a = t / n;}\n    #define eql if(t == n)q = t;\n    #define uneql if(t != n)q = t + n\n    #define geql if(t >= n)q = t - n\n    #define leql if(t <= n)q = n - t\n    float t, n, a = 0.0;\n    float x = canvas.x;\n    float y = canvas.y;\n    float sx = fract(canvas.x);\n    float sy = fract(canvas.y);\n    \n    //t and n are sorted, unsorted, gsorted, or lsorted? Who Knows?\n    //sort the layers to know it\n    t = sx; n = sy;\n    sorted unsorted gsorted lsorted\n    t = x; n = sy; sorted; unsorted; gsorted; lsorted;\n    t = sx; n = y; sorted; unsorted; gsorted; lsorted;\n    t = x; n = y; sorted; unsorted; gsorted; lsorted;\n    \n    //qualitize the layers\n    float q;\n    \n    //compare edge and corner positions.\n    eql;\n    uneql;\n    geql;\n    leql;\n    \n    //get the best layer coverage among layer vertices (q) & fragments (a)\n    vec2 i = vec2(max(q, a));\n    //get the square root of the best layer coverage (i)\n    float i2 = float(sqrt(i));\n    //return the square root of the best layer coverage( i2 ) minus the vertices and fragments.\n    return i2 - q - a;\n    //boom, the layers appear.\n    //P.S. I didn't announce that this makes a flower - petal-shaped glass <- shading\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv rays? xD\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    //get vertices for capped cone edges. \n    vec4 branch = vec4(dot(-uv, -uv), dot(uv, -uv), dot(uv, -uv), dot(uv, uv));\n    //get sort of layers\n    vec2 p = vec2(a(uv, branch));\n    \n    //trace the sphere\n    float s = s1(uv, uv);\n    vec3 col = vec3(s);\n   \n    fragColor = min(vec4(col,1.0) + texture(iChannel0, col.xy) - length(uv) + cos(uv.y),\n    vec4(cos(uv.y)) + vec4(-0.025, 0.025, 0.6, 1.0) + length(fract(p)));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nvec2 pos = vec2(1.5);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //For Luminous Color Red.\n    vec4 colA = vec4(0.1, 1.0, 0.01, 1.0);\n    vec4 colB = vec4(0.0, 0.0, 0.5, 1.0);\n    vec4 colPush = vec4(0.2, 0.6, 0.3, 0.7);\n    vec4 colPushed = smoothstep(colPush, colA, colB);\n    fragColor = colPushed - max(pos.x/fragCoord.x, pos.y/fragCoord.y) +\n        texture(iChannel0, (fragCoord.xy/iResolution.xy)+pos);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nvec2 pos = vec2(1.5);\n#define F 1.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = sin(iTime);\n    //For Luminous Color Red.\n    vec4 colA = vec4(0.1, 1.0, 0.01, 1.0);\n    vec4 colB = vec4(0.0, 0.0, 0.5, 1.0);\n    vec4 colPush = vec4(0.2, 0.6, 0.3, 0.7);\n    vec4 colPushed = smoothstep(colPush, colA, colB);\n    for(float i = 0.0; i < F; i += 1.0){\n    fragColor = colPushed - max(pos.x/fragCoord.x, pos.y/fragCoord.y);\n        vec3 ip = vec3(pos, 1.0);\n        ip.xz *= mat2(colPushed);\n        colPushed += length(fragColor) + t;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}