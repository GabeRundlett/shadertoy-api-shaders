{
    "Shader": {
        "info": {
            "date": "1720328173",
            "description": "fractal torus",
            "flags": 0,
            "hasliked": 0,
            "id": "lXK3Rh",
            "likes": 3,
            "name": "Fractal Torus Interior",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "ShadeWhizz",
            "viewed": 100
        },
        "renderpass": [
            {
                "code": "mat3 lookat(vec3 origin, vec3 target) {\n    vec3 forward = normalize(target - origin);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    \n    return mat3(\n        right.x, right.y, right.z,\n        up.x, up.y, up.z,\n        -forward.x, -forward.y, -forward.z\n    );\n}\n\nmat2 rotmat(float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n\n    return mat2(\n        cosAngle, -sinAngle,\n        sinAngle,  cosAngle\n    );\n}\n\n\nvec3 hsvToRgb(vec3 hsv) {\n    float c = hsv.y * hsv.z;\n    float x = c * (1.0 - abs(mod(hsv.x / 60.0, 2.0) - 1.0));\n    float m = hsv.z - c;\n    \n    vec3 rgb;\n    if (hsv.x < 60.0) {\n        rgb = vec3(c, x, 0.0);\n    } else if (hsv.x < 120.0) {\n        rgb = vec3(x, c, 0.0);\n    } else if (hsv.x < 180.0) {\n        rgb = vec3(0.0, c, x);\n    } else if (hsv.x < 240.0) {\n        rgb = vec3(0.0, x, c);\n    } else if (hsv.x < 300.0) {\n        rgb = vec3(x, 0.0, c);\n    } else {\n        rgb = vec3(c, 0.0, x);\n    }\n    \n    return rgb + vec3(m);\n}\n\nfloat channel(vec2 ndc, float t) {\n    float angle = t * 0.05;\n    float phase = atan(ndc.y, ndc.x);\n    float mag = length(ndc);\n    for (float i = 0.0; i < 64.0; i += 1.0) {\n        ndc = abs(ndc); // yo i really like fract esp the one where it is almost a grid\n        ndc -= 6.0;\n        ndc = abs(ndc);\n        \n        //ndc = ndc.yx;\n        ndc *= 1.06;\n        //ndc *= rotmat(angle);\n        ndc *= rotmat(angle/(1.0+i));\n   }\n   return length(ndc);\n}\n\nvec3 image(vec2 uv) {\n    float x = channel(uv, iTime);\n    float h = 10.0*iTime + 360.0*x;\n    h = mod(h, 360.0);\n    vec3 col = hsvToRgb(vec3(h, 1.0, 1.0));\n    return col;\n}\n\nconst float PI = 3.14159265358979323846264;\n\n\nconst int MAX_PRIMARY_RAY_STEPS = 64; //decrease this number if it runs slow on your computer\n\nvec2 rotate2d(vec2 v, float a) { \n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distanceField(vec3 p) {\n\treturn -sdTorus(p, vec2(4.0, 3.0));\n}\nfloat iters = 0.0;\nvec3 castRay(vec3 pos, vec3 dir, float treshold) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\tif (abs(dist) < treshold) break;\n\t\t\tpos += dist * dir;\n            iters = float(i);\n\t}\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    //float time = iTime;\n\t//vec3 cameraPos = 3.8*vec3(cos(time), 0.0, sin(time));\n\t//vec3 cameraDir = normalize(-cameraPos);\n    float angle = iTime * 0.25;\n    float radius = 5.0;\n    vec3 target = vec3(0.0);\n    vec3 ro = vec3(sin(angle) * radius, 2.0, cos(angle) * radius);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n\tvec3 planeU = vec3(1.0, 0.0, 0.0) * 0.8;\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);\n\tvec3 rayPos = castRay(ro, rd, 0.01);\n\t\n\tfloat majorAngle = atan(rayPos.z, rayPos.x);\n\tfloat minorAngle = atan(rayPos.y, length(rayPos.xz) - 4.0);\n\t//vec2 uv = vec2(mod(majorAngle+iTime*0.33, PI*2.0)/PI - 1.0, minorAngle);\n    vec2 angles = vec2(majorAngle, minorAngle);\n    vec2 uvm = angles / (2.0*PI);\n    //uv.x += iTime * 0.05;\n    //uv.x = fract(uv.x);\n    vec3 col = image(uvm.xy*8.0);\n    float ao = 1.0 - (iters / 64.0);\n\tfragColor = vec4(col*ao, 1.0);\n    //fragColor =  vec4(ao);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}