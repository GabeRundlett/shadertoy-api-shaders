{
    "Shader": {
        "info": {
            "date": "1727000910",
            "description": "fragment shader for my school project.\nuse mouse to move camera.\nuncomment line 3 to see color in debug mode (I like this than normal mode).\n[url]https://gitea.com/silica163/fragment-shaders/src/branch/master/reflection-of-randomness.frag[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "lXfyW7",
            "likes": 5,
            "name": "reflection of randomness",
            "published": 3,
            "tags": [
                "light",
                "random",
                "raytrace",
                "ring",
                "reflect"
            ],
            "usePreview": 0,
            "username": "silica163",
            "viewed": 61
        },
        "renderpass": [
            {
                "code": "// https://gitea.com/silica163/fragment-shaders/src/branch/master/reflection-of-randomness.frag\n#define SHADERTOY\n//#define DEBUG\n\n#ifdef SHADERTOY\n#define time iTime\n#define deltaTime iTimeDelta\n#define resolution iResolution\n#define mouse iMouse\n#define frame iFrame\n\n#else\nuniform float time;\nuniform float deltaTime;\nuniform vec2 resolution;\nuniform vec4 mouse;\nuniform int frame;\nuniform vec4 uVec40;\nuniform vec4 uVec41;\n\nout vec4 fragColor;\n\n#endif\n\n#define R resolution\n#define MAX 100.\n#define PI 3.14159265\n#define RED vec4(1,0,0,1)\n#define GREEN vec4(0,1,0,1)\n#define BLUE vec4(0,0,1,1)\n#define EPS 1e-3\n\nstruct Plane {\n    vec3 pos;\n    vec3 normal;\n    float shift;\n};\n\nfloat iPlane(vec3 ro, vec3 rd, Plane p){\n    return (p.shift - dot(ro - p.pos,p.normal))/dot(rd,p.normal);\n}\n\nvec3 nPlane(Plane p){\n    return p.normal;\n}\n\nfloat iSphere(vec3 ro, vec3 rd, vec4 sp){\n    float t = dot(rd, sp.xyz - ro);\n    vec3 rs = ro + rd * t - sp.xyz;\n    float k = sp.w*sp.w - dot(rs,rs);\n    float h = MAX;\n    if( k < 0.){\n        h = -1.;\n    } else {\n        h = sqrt(k);\n\n        float n = t - h;\n        float f = t + h;\n        if(f < 0.)h = -1.;\n        else if (n < 0.) h = f;\n        else if (n < f ) h = n;\n    }\n    return h;\n}\n\nvec3 nSphere(vec3 rp, vec4 sp){\n    return (rp - sp.xyz)/sp.w;\n}\n\nstruct Cylinder {\n    vec3 pos;\n    vec2 size; /*x: radius, y: height*/\n};\n\nvec2 iCylinder(vec3 ro, vec3 rd, Cylinder c){\n    float bodyNear = MAX, bodyFar = MAX;\n    vec3 co = ro - c.pos;\n \n    vec2 rdxz = normalize(rd.xz);\n    float t = -dot(rdxz, co.xz);\n    vec2 rp = co.xz + rdxz * t;\n    float k = c.size.x*c.size.x - dot(rp,rp);\n\n    float lxz = length(rd.xz);\n    bodyNear = (t - sqrt(k))/lxz;\n    bodyFar  = (t + sqrt(k))/lxz;\n\n    if(k < 0. || bodyFar < 0. || bodyFar < bodyNear)\n        return vec2(-1.);\n\n    float capNear = -co.y/rd.y - c.size.y/abs(rd.y);\n    float capFar  = -co.y/rd.y + c.size.y/abs(rd.y);\n    float near = max(bodyNear, capNear);\n    float far = min(bodyFar , capFar);\n\n    if(near > far || far < 0.)\n        return vec2( -1);\n\n    return vec2(near, far);\n}\n\nvec3 nCylinder(vec3 rp, Cylinder c){\n    vec3 cp = rp - c.pos;\n    vec3 n = vec3(0);\n    if(abs(cp.y)+EPS >= c.size.y) n = vec3(0,1,0)*(cp.y/abs(cp.y));\n    else n.xz = normalize(cp.xz);\n    return n;\n}\n\nvec4 iCylSubCyl(vec3 ro, vec3 rd, Cylinder cy0, Cylinder cy1){\n    vec2 c0 = iCylinder(ro, rd, cy0);\n    vec2 c1 = iCylinder(ro, rd, cy1);\n    float near = -1., midNear = -1., midFar = -1., far = -1.;\n\n    // ignore when not intersect first cylinder\n    if(c0.y < 0.) return vec4(-1);\n\n    if(c0.x <= c1.x){\n        near = c0.x;\n        midNear = min(c1.x, c0.y);\n    }\n\n    if(c0.x > c1.x){\n        midNear = -1.;\n    }\n\n    if(c1.y <= c0.y){\n        midFar = max(c0.x, c1.y);\n        far = c0.y;\n    }\n    if(c1.y > c0.y){\n        midFar = -1.;\n    }\n\n    return vec4(near, midNear, midFar, far);\n}\n\nvec3 nCylSubCyl(vec3 rp, Cylinder cy0, Cylinder cy1){\n    vec3 n = vec3(0),\n         c0 = rp - cy0.pos,\n         c1 = rp - cy1.pos;\n    if(abs(abs(c0.y) - cy0.size.y) <= EPS) n.y = sign(c0.y);\n    if(abs(abs(c1.y) - cy1.size.y) <= EPS) n.y = -sign(c1.y);\n    if(abs(length(c0.xz) - cy0.size.x) <= EPS) n = vec3(normalize(c0.xz), 0).xzy;\n    if(abs(length(c1.xz) - cy1.size.x) <= EPS) n = -vec3(normalize(c1.xz), 0).xzy;\n    return n;\n}\n\nCylinder cy[2];\nvec4 sp;\nPlane pl;\n\nvec2 intersect(vec3 ro, vec3 rd){\n    int mat = -1;\n    float d = MAX;\n    vec4 cycy = iCylSubCyl(ro, rd, cy[0], cy[1]);\n    if(cycy.x < 0.) cycy.x = cycy.y;\n    if(cycy.x < 0.) cycy.x = MAX;\n    if(cycy.z < 0.) cycy.z = cycy.w;\n    if(cycy.z < 0.) cycy.z = MAX;\n    float dc = min(cycy.x, cycy.z);\n\n    float p = iPlane(ro, rd, pl);\n    if(p < 0.)p = MAX;\n\n    float s = iSphere(ro, rd, sp);\n    if(s < 0.)s = MAX;\n\n    d = min(d, dc);\n    d = min(d, p);\n    d = min(d, s);\n\n    if(d == dc)mat = 0;\n    if(d == p)mat = 1;\n    if(d == s)mat = 2;\n    if(d == MAX)mat = -1;\n    return vec2(d, mat);\n}\n\nfloat rand(vec2 p){\n    float v = fract(8951.9201*tan(dot(p,vec2(0.1031,0.0031))));\n    return v;\n}\n\nfloat pattern21(vec2 uv,vec2 size){\n    uv *= size;\n    vec2 uf = floor(uv);\n    float v = step(rand(uf),.5);\n    v *= step(abs(fract(uv.y)-.5),.4);\n    return v;\n}\n\nfloat fresnel(vec3 N, vec3 V){\n    return 0.2 + pow(clamp(1.-dot(V, N), 0., 1.),4.);\n}\n\nfloat getColor(in vec2 i, in vec3 rp, in vec3 rd, inout float fresnelAcc, inout float rayColor, inout vec3 N){\n    float c = 0.;\n    float wc = 0.;\n\n#ifdef DEBUG\n    if(rp.x < 0.) wc = 0.;\n    if(rp.x >= 0.) wc = 1.;\n#else\n    wc = 1.;\n#endif\n\n    if(i.y == 0.){\n        N = nCylSubCyl(rp, cy[0], cy[1]);\n        vec3 rr = rp - cy[0].pos;\n        vec2 ruv  = vec2(atan(rr.x,rr.z)/PI, rr.y + length(rr.xz));\n        float ringColor = (0.01+pattern21(ruv,vec2(16,2)));\n        rayColor *= ringColor;\n        c += ringColor;\n    }\n\n    if(i.y < 0.){\n        c += wc;\n        rayColor *= wc;\n    }\n\n    float ao = 0.;\n    if(i.y == 1.){\n        N = nPlane(pl);\n        float ringLight = max(0.,1.-abs(length(cy[0].pos.xz - rp.xz)-cy[0].size.x)*.2);\n        ao = ringLight;\n        ao += rayColor * clamp(length(sp.xyz - rp)-.7, 0., 1.) * exp(-i.x/20.);\n    }\n\n    if(i.y == 2.){\n        N = nSphere(rp, sp);\n        ao = mix(0.5, 1.0, (rp.y - sp.y));\n    }\n    float f = mix(0., .7, fresnel(N, -rd));\n    fresnelAcc *= f;\n    c += mix(0., 1., ao)*rayColor;\n    return c;\n}\n\nmat3 matLookAt(vec3 lookAt, vec3 up){\n    lookAt = normalize(lookAt);\n    up = normalize(up);\n    vec3 right = normalize(cross(lookAt, up));\n    vec3 top = normalize(cross(right, lookAt));\n    return mat3(right, top, -lookAt);\n}\n\n#ifdef SHADERTOY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord.xy - R.xy)/R.y;\n    vec2 m = (2.*mouse.xy - R.xy)/R.y;\n    vec3 ro = vec3(0,0,3),\n         lookTarget = vec3(0),\n#else\nvoid main(){\n    vec2 uv = (2.*gl_FragCoord.xy - R)/R.y;\n    vec2 m = (2.*mouse.xy - R)/R.y;\n    vec3 ro = uVec40.xyz,\n         lookTarget = uVec41.xyz,\n#endif\n         rd = normalize(vec3(uv,-1)),\n         N = vec3(0); \n\n/**\n    // camera rotation\n    if(mouse.z > 0.){\n        m *= PI*vec2(-1.,.6);\n        vec2 c = cos(m),s = sin(m);\n        rd = mat3(\n            c.x    ,   0,-s.x, \n            s.x*s.y, c.y, c.x*s.y,\n            c.y*s.x,-s.y, c.x*c.y\n        ) * rd ;\n    }\n\n/**/\n    if(mouse.z > 0.)\n        ro.xy += 2.*m;\n    else {\n        ro.z = sin(time*.2)*5.;\n        ro.y = sin(time*.4)*.5+.5;\n        ro.x = cos(time*.2)*2.;\n    }\n    rd = matLookAt(lookTarget - ro, vec3(0, 1, 0)) * rd;\n    float t = time/2.;\n\n    // ring\n    cy[0] = Cylinder(vec3(0,2.5,0),vec2(10, 1.36));\n    cy[1] = Cylinder(vec3(0,2.5,0),vec2(9.5,1.37));\n\n    sp = vec4(0,0,0,1);\n    pl = Plane(sp.xyz, vec3(0,1,0), -sp.w);\n\n    float c = 0.;\n    float wc = 1.;\n    float rayColor = 1.;\n    float fresnelAcc = 1.;\n\n    vec2 i = intersect(ro, rd);\n    vec3 rp = ro + rd * i.x;\n    c += getColor(i, rp, rd, fresnelAcc, rayColor, N);\n    for(int _ = 0; _ < 4 && (i.y == 2. || i.y == 1.); _ ++){\n        rd = reflect(rd, N);\n        ro = rp + rd*EPS;\n        float oc = c;\n        float oldFresnelAcc = fresnelAcc;\n        i = intersect(ro, rd);\n        rp = ro + rd * i.x;\n        c = getColor(i, rp, rd, fresnelAcc, rayColor, N);\n        c = mix(oc, c, oldFresnelAcc);\n    }\n\n    c = sqrt(c);\n    fragColor = vec4(vec3(c),1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}