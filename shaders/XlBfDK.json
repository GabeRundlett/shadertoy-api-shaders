{
    "Shader": {
        "info": {
            "date": "1517408502",
            "description": "Sneaker modeling experiment. I actually wanted to create like this and will work on another shape in my spare time.....",
            "flags": 0,
            "hasliked": 0,
            "id": "XlBfDK",
            "likes": 2,
            "name": "sneaker modeling",
            "published": 3,
            "tags": [
                "glitch",
                "raymerching",
                "sneaker"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 698
        },
        "renderpass": [
            {
                "code": "// Always Thank you for Mr Iq's great distance function.\n// raymarching based from https://www.shadertoy.com/view/lt2Bz3\n\n#define STEPS 50.\n#define VOLUME .01\n#define FAR 60.\n#define PI 3.14159\n\nvec2 hash(vec2 v) {\n\tvec2 n;\n\tn.x=fract(cos(v.y-v.x*841.0508)*(v.y+v.x)*3456.7821);\n\tn.y=fract(sin(v.x+v.y*804.2048)*(v.x-v.y)*5349.2627);\n\treturn n;\n}\n\n//from http://glsl.herokuapp.com/e#4841.11\nfloat partition_noise(vec2 p) {\n\tvec2 id;\n\t\n\tid = floor(floor(p)-.3);\n\t\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\t\n\tp.yx *= floor(hash(id) * 3.)-3.;\n\tid -= floor(p);\n\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\n\tp -= id;\n\n\tvec2 u = abs(p - .6) * 3.;\n\n\treturn max(u.x, u.y);\n}\n\nfloat partition_noise2(vec2 p) \n{\n\tvec2 id;\n\t\n\tp.yx *= floor(hash(id) * 3.)-2.;\n\tid -= floor(p);\n\n\tp *= floor(hash(id) * 3.)+3.;\n\tid = floor(p);\n\n\tp -= id;\n\n\tvec2 u = abs(p - .3) * 3.;\n\n\treturn max(u.x, u.y);\n}\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nvec3 lookAt (vec3 eye, vec3 target, vec2 uv) {\n  vec3 forward = normalize(target-eye);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  return normalize(forward + uv.x * right + uv.y * up);\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec3 camera (vec3 p) {\n    float click = clamp(iMouse.z, 0., 1.);\n    p.yz *= rot(click*(-.25*PI*(iMouse.y/iResolution.y-.5)));\n    p.xz *= rot(click*(-.5*PI*(iMouse.x/iResolution.x-.5)));\n    p.xz *= rot((1.-click)*(.5*PI*(.4*sin(iTime*.1))));\n    p.xz *= rot(iTime*0.2);\n    return p;\n}\n\nfloat sdSphereCustom (vec3 p, float r, vec3 form) {\n    p.x *= form.x;\n    p.y *= form.y;\n    p.z *= form.z;\n    return length(p)-r; \n}\n\nfloat sdCappedCylinderCustom( vec3 p, vec2 h, vec3 form )\n{\n    p.x *= form.x;\n    p.y *= form.y;\n    p.z *= form.z;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorusCustom( vec3 p, vec2 t, vec3 form ){\n    p.x *= form.x;\n    p.y *= form.y;\n    p.z *= form.z;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdFloor (vec3 p){return dot(p, vec3(0.0, 1.0, 0.0)) + 1.0;}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 map(vec3 p,vec2 uv) {\n    p.y+= 0.2;\n    vec3 pos = p;\n    vec3 pos2 = p;\n    vec3 pos3 = p;\n    vec3 pos4 = p;\n    vec3 pos5 = p;\n    vec3 pos6 = p;\n    vec3 pos7 = p;\n\tvec3 pos8 = p;\n    \n    vec4 soleFront = vec4(0.9,0.9,0.9,sdSphereCustom(pos+vec3(0.9,0.0,0.0),0.5,vec3(0.35,1.3,0.5)));\n    vec4 soleBack = vec4(0.9,0.9,0.9,sdSphereCustom(pos+vec3(-0.8,0.0,0.0),0.5,vec3(0.45,1.4,0.5)));\n    vec4 heelpart = vec4(255.0/255.0, 145.0/255.0, 164.0/255.0,sdCappedCylinderCustom(pos+vec3(-0.7,-0.7,0.0),vec2(0.5,0.8),vec3(0.45,1.6,0.7)));\n    pos.xy *= rot(PI/-6.5);\n    \n    vec4 upper = vec4(255.0/255.0, 145.0/255.0, 164.0/255.0,sdSphereCustom(pos+vec3(0.45,-0.9,0.0),0.5,vec3(0.34,0.95,0.6)));\n    \n    float topPart = smoothMin(heelpart.w,upper.w,10.0);\n    vec4 combinedTopPart =  vec4(255.0/255.0, 195.0/255.0, 194.0/255.0,topPart);\n    \n    pos2.xy *= rot(PI/-30.0);\n    vec4 heelPartBox =vec4(0.8,0.8,0.8,sdSphereCustom(pos2+vec3(-0.8,-0.2,0.0),0.5,vec3(0.4,1.4,0.6)));\n    \n    // toebox\n    pos3.xy *= rot(PI/18.0);\n\tvec4 toebox = vec4(255.0/255.0, 195.0/255.0, 194.0/255.0,sdSphereCustom(pos3+vec3(1.6,0.1,0.0),0.5,vec3(0.7,2,0.7)));\n    \n    float wholeupper = smoothMin(combinedTopPart.w,toebox.w,9.0);\n    vec4 resUpper =  vec4(255.0/255.0, 195.0/255.0, 194.0/255.0,wholeupper);\n\tresUpper.rgb =  resUpper.rgb/partition_noise(p.xy*1.5-iTime*0.2);\n    resUpper.rgb *= vec3(255.0/255.0, 195.0/255.0, 194.0/255.0);\n    \n    // heel\n    pos4.xy *= rot(PI/-6.5);\n    vec4 heel = vec4(0.9,0.9,0.9,sdSphereCustom(pos4+vec3(-1.3,-0.3,0.0),0.5,vec3(0.45,1.4,0.6)));\n    float sheel = smoothMin(heelpart.w,heel.w,10.0);\n    vec4 resHeel = vec4(0.0, 0.0, 0.3,sheel);\n    resHeel.rgb =  resHeel.rgb/partition_noise2(p.xy-iTime*0.1);\n    \n    // race part\n    pos5.xy *= rot(PI/-1.7);\n    pos5.y = abs(pos5.y)-0.25;// symetory\n    vec4 race = vec4(1.0, 1.0, 1.0,sdTorusCustom(pos5+vec3(-0.9,0.0,0.0),vec2(0.62,0.03),vec3(1.0,0.4,0.9)));\n    race.rgb *= vec3(2.0);\t\t\t\n  \n    pos6.xy *= rot(PI/-1.7);\n    pos6.yz *= rot(PI/-2.0);\n    vec4 heelloop= vec4(255.0/255.0, 195.0/255.0, 194.0/255.0,sdTorusCustom(pos6+vec3(-0.8,0.0,-2.3),vec2(0.32,0.03),vec3(1.7,0.5,1.5)));\n    heelloop.rgb *= vec3(2.0);\n    \n    // race 2\n    pos7.xy *= rot(PI/-1.7);\n    vec4 race2 = vec4(1.0, 1.0, 1.0,sdTorusCustom(pos7+vec3(-0.8,-0.7,0.0),vec2(0.62,0.03),vec3(1.0,0.4,0.9)));\n    race2.rgb *= vec3(2.0);\t\n    \n    // heel counter\n     pos8.xy *= rot(PI/-16.0);\n    vec4 heelCounter =vec4(0.3,0.3,0.3,sdSphereCustom(pos8+vec3(-0.9,-0.5,0.0),0.5,vec3(0.4,0.92,0.65)));\n    \n    vec4 f = vec4(vec3(.3,.3,.3),sdFloor(p+vec3(0.0,6.0,0.0)));\n    vec4 res = combine(soleFront, soleBack);\n    vec4 res2 = combine(combinedTopPart,heelPartBox);\n    vec4 res3 = combine(resUpper, resHeel);\n    vec4 res4 = combine(race, heelloop);\n    vec4 res5 = combine(race2, heelCounter);\n    vec4 res6 = combine(f, res);\n    vec4 res7 = combine(res2, res3);\n    vec4 res8 = combine(res4, res5);\n    vec4 res9 = combine(res6, res7);\n    vec4 res10 = combine(res8, res9);\n    return res10;\n}\n\nvec3 raymarch (vec2 uv) {\n    vec3 eye = camera(vec3(0,1.5,-4.0));\n    vec3 ray = lookAt(eye, vec3(0), uv);\n    float shade = 0., dist = 0.;\n    vec3 pos = eye;\n    \n    vec4 shape;\n    for (float i = 0.; i <= 1.; i += 1.0 / STEPS) {\n        shape = map(pos,uv);\n        if (shape.w < VOLUME || dist > FAR) { break; }\n        dist += shape.w;\n        pos = eye + ray * dist;\n    }\n    \n    vec3 color = shape.xyz;\n    \n    if ( dist> 10.0 ){\n        float temp = length(uv)+0.1;\n        return vec3(.2,.2,.2)/vec3(temp);\n    } else {\n        vec3 lightPos = vec3(10.0, 1.0, 1.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( 250.0, 30.0, 0.0 );\n        vec3 n = vec3(shape.w - map( pos - eps.xyy,uv ).w,\n                      shape.w - map( pos - eps.yxy,uv ).w,\n                      shape.w - map( pos - eps.yyx,uv ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        color = vec3(dist)*color* vec3(lambert);\n    }\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tfloat block_thresh = pow(fract(iTime * 16.0453), 1.0) * 3.1;\n\tfloat line_thresh = pow(fract(iTime * 1236.0453), 1.0) *0.2;\n    \n    float block_thresh2 = pow(fract(iTime * 126.0453), 1.0) *3.1;\n\tfloat line_thresh2 = pow(fract(iTime * 1236.0453), 1.0) * 0.1;\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // scan effect\n    float uvy = sin((iTime+10.0)*0.6)*1.2;\n\tif (uv.y+uvy > 0.5 && uv.y+uvy < 0.7) {\n        uv.x += sin(uv.y*10.0)*0.1;\n    }\n\n    vec4 c = vec4(raymarch(uv),1.0); // raymerching result\n\n    fragColor = c;\n\n    // glitch effect\n    float ypos = sin(fract(iTime * 6.0453))-0.5;\n\tif (uv.y+ypos > block_thresh && uv.y+ypos < line_thresh && uv.x+ypos*1.5 > block_thresh) {\n\t\tfloat line = fract(fragCoord.y / 3.0);\n\t\tvec3 mask = vec3(3.0, 0.0, 0.0);\n\t\tif (line > 0.133)\n\t\t\tmask = vec3(0.0, 3.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 3.0);\n\t\t\n\t\tfragColor.xyz += mask;\n\t}\n    \n    float ypos2 = sin(fract(iTime * 3.0453))-0.5;\n\tif (uv.y+ypos2 > block_thresh && uv.y+ypos2 < line_thresh2) {\n\t\tfloat line = fract(fragCoord.y / 3.0);\n\t\tvec3 mask = vec3(3.0, 0.0, 0.0);\n\t\tif (line > 0.233)\n\t\t\tmask = vec3(0.0, 3.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 3.0);\n\t\t\n\t\tfragColor.xyz += mask;\n\t}\n    \n        float ypos3 = sin(fract(iTime * 6.0453))-0.5;\n\tif (uv.y+ypos3 > block_thresh && uv.y+ypos3*1.5 < block_thresh && uv.x+ypos3*1.5 < block_thresh) {\n\t\tfloat line = fract(fragCoord.y / 3.0);\n\t\tvec3 mask = vec3(3.0, 0.0, 0.0);\n\t\tif (line > 0.333)\n\t\t\tmask = vec3(0.0, 3.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 3.0);\n\t\t\n\t\tfragColor.xyz += mask;\n\t}\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}