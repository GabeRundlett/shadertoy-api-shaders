{
    "Shader": {
        "info": {
            "date": "1458260895",
            "description": "Another amusement park ride, based on Shane's \"Raymarched Reflections\" code.",
            "flags": 0,
            "hasliked": 0,
            "id": "4scXz7",
            "likes": 17,
            "name": "Ferris Wheel 2",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "modeling"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 1100
        },
        "renderpass": [
            {
                "code": "/*\n\t\"Ferris Wheel 2\" by wjbgrafx\n\t\n\tBased on\n\tRaymarched Reflections   Uploaded by Shane in 2015-Nov-17\n\thttps://www.shadertoy.com/view/4dt3zn\n\t\n\tAdditional sources:\n\t------------------\t\n\tGardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n\thttps://www.shadertoy.com/view/lll3z4\n\n\tHG_SDF GLSL Library for building signed distance bounds by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\n\tCamera rotation matrix function\n\tFrom\t\"Simple test/port of Mercury's SDF library to WebGL\"\n\thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n#define PI_16\t\t\t\t\t0.19634954084936207740391521145497\n\n#define FAR                     80.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_DIST\t\t\t\t40.0\n#define CAM_POS                 vec3( 0.0, 5.0, -CAM_DIST )\n#define CAM_FOV_FACTOR          4.0\n#define LOOK_AT                 vec3( 0.0, 5.0, 0.0 )\n#define LIGHT_POS               vec3( 0.0, 20.0, -10.0 )\n#define LIGHT_ATTEN\t\t\t\t0.003\n\n\n//------------------------------------------------------------------------------\n// Function declarations\n//----------------------\nmat4 createCamRotMatrix();\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID );\nvec3 skyColor( vec2 pix );\nvec3 rotateZ(vec3 p, float a);\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat fBox(vec3 p, vec3 b);\n// Mirror at an axis-aligned plane which is at a specified distance <dist> \n// from the origin.\nfloat pMirror (inout float p, float dist);\n\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map(vec3 p)\n{    \n\t\n\tfloat objID = 1.0;\n\tvec2 ground = vec2( fPlane( p, vec3( 0.0, 1.0, 0.0 ), 0.0 ), objID );    \n\t\n\t// Tower, ground beam, braces, and axle.\n\t//--------------------------------------\n\tvec3 p2 = p;\t\n\t// Mirror across x-axis.\n\tpMirror( p2.z, 0.0 );\n\t\n\tobjID = 2.0;\t\n\tvec2 tower = vec2( \n\t      fBox( p2 - vec3( 0.0, 3.6, 1.5 ), vec3( 0.15, 3.6, 0.15 ) ), objID ); \n\t\n\tvec2 groundBeam = vec2(\n\t\t    fBox( p2 - vec3( 0.0, 0.2, 1.5 ), vec3( 5.0, 0.2, 0.3 ) ), objID );\n\t\t\n\tvec2 brace1 = vec2(\n\tfCapsule( p2, vec3( 4.5, 0.0, 1.5 ), vec3( 0.0, 6.0, 1.5 ), 0.1 ), objID );\t\n\t\t\n\tvec2 brace2 = vec2(\n\tfCapsule( p2, vec3( -4.5, 0.0, 1.5 ), vec3( 0.0, 6.0, 1.5 ), 0.1 ), objID );\t\n\t\t\n\tvec2 crossBeam = vec2(\n\t\t    fBox( p - vec3( 0.0, 0.2, 0.0 ), vec3( 0.3, 0.2, 2.0 ) ), objID );\t\n\t\n\tvec2 axle = vec2(\n\tfCapsule( p, vec3( 0.0, 7.0, 1.5 ), vec3( 0.0, 7.0, -1.5 ), 0.2 ), objID );\t    \n\t\n\t// Hoops and arms.\n\t//----------------\n\tvec3 p1 = p;\n\t\n\t// Rotate hoops. Translate hoop center to origin and back, so hoops rotate\n\t// around their own center.\n\tfloat hoopRotVal = iTime * -0.5;\n\tp1.y -= 7.0;\n\tp1 = rotateZ( p1, hoopRotVal );\n\tp1.y += 7.0;\n\t\n\t// Mirror across x-axis.\n\tpMirror( p1.z, 0.0 );\t\n\t\n\tobjID = 2.0;\n\t// Swizzle y and z planes to make tori stand upright in x-y plane.\n\tvec2 outerHoop = vec2( \n\t               fTorus( p1.xzy - vec3( 0.0, 1.0, 7.0 ), 0.1, 5.0 ), objID );\n\n\tvec2 innerHoop = vec2( \n\t              fTorus( p1.xzy - vec3( 0.0, 1.0, 7.0 ), 0.05, 4.0 ), objID );\n\t\n\tvec2 axleHoop = vec2( \n\t             fTorus( p1.xzy - vec3( 0.0, 1.0, 7.0 ), 0.05, 0.25 ), objID );\n\t\n\t//---------------------------------------------------\n\n\tvec2 arm1 = vec2(\n  \t\tfCapsule( p1, vec3( -5.0, 7.0, 1.0 ), vec3( 5.0, 7.0, 1.0 ), 0.05 ), \n  \t\t\t                                                           objID );\n\tvec2 arm2 = vec2(\n  \t\tfCapsule( p1, vec3( 0.0, 2.0, 1.0 ), vec3( 0.0, 12.0, 1.0 ), 0.05 ), \n  \t\t\t                                                           objID );\n\tvec2 arm3 = vec2(\n  \t\tfCapsule( p1, vec3( -3.4, 3.5, 1.0 ), vec3( 3.4, 10.5, 1.0 ), 0.05 ), \n  \t\t\t                                                           objID );\n\tvec2 arm4 = vec2(\n  \t\tfCapsule( p1, vec3( -3.4, 10.5, 1.0 ), vec3( 3.4, 3.5, 1.0 ), 0.05 ), \n  \t\t\t                                                           objID );\n\t//---------------------------------------------------\n\t// Seat 1\n\t// ------\n\tvec3 p3 = p;\n\t// Rotate with the hoops.\n\tp3.y -= 7.0;\n\tp3 = rotateZ( p3, hoopRotVal );\n\tp3.y += 7.0;\n\t// Rotate around its own z-axis to keep it upright.\n\tp3 -= vec3( -5.0, 7.0, 0.0 );\n\tp3 = rotateZ( p3, -hoopRotVal );\n\tp3 += vec3( -5.0, 7.0, 0.0 );\n\t\t\n\tobjID = 3.0;\n\tvec2 seat1 = vec2(\n\t\tfBox( p3 - vec3( -5.0, 7.0, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat1CutA = vec2(\n\t\tfBox( p3 - vec3( -5.1, 7.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat1 = max( seat1, -seat1CutA );\n\t\n\tvec2 seat1CutB = vec2(\n\t\tfBox( p3 - vec3( -5.7, 7.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat1 = max( seat1, -seat1CutB );\n\t\n\t// Seat 2\n\t// ------\n\tvec3 p4 = p;\n\t// Rotate with the hoops.\n\tp4.y -= 7.0;\n\tp4 = rotateZ( p4, hoopRotVal );\n\tp4.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp4 -= vec3( -3.4, 10.5, 0.0 );\n\tp4 = rotateZ( p4, -hoopRotVal );\n\tp4 += vec3( -3.4, 10.5, 0.0 );\n\t\t\n\tobjID = 4.0;\n\tvec2 seat2 = vec2(\n\t\tfBox( p4 - vec3( -3.4, 10.5, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat2CutA = vec2(\n\t\tfBox( p4 - vec3( -3.5, 11.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat2 = max( seat2, -seat2CutA );\n\t\n\tvec2 seat2CutB = vec2(\n\t\tfBox( p4 - vec3( -4.1, 10.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat2 = max( seat2, -seat2CutB );\n\t\n\t// Seat 3\n\t// ------\n\tvec3 p5 = p;\n\t// Rotate with the hoops.\n\tp5.y -= 7.0;\n\tp5 = rotateZ( p5, hoopRotVal );\n\tp5.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp5 -= vec3( 0.0, 12.0, 0.0 );\n\tp5 = rotateZ( p5, -hoopRotVal );\n\tp5 += vec3( 0.0, 12.0, 0.0 );\n\t\t\n\tobjID = 5.0;\n\tvec2 seat3 = vec2(\n\t\tfBox( p5 - vec3( 0.0, 12.0, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat3CutA = vec2(\n\t\tfBox( p5 - vec3( -0.1, 12.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat3 = max( seat3, -seat3CutA );\n\t\n\tvec2 seat3CutB = vec2(\n\t\tfBox( p5 - vec3( -0.7, 12.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat3 = max( seat3, -seat3CutB );\n\t\n\t// Seat 4\n\t// ------\n\tvec3 p6 = p;\n\t// Rotate with the hoops.\n\tp6.y -= 7.0;\n\tp6 = rotateZ( p6, hoopRotVal );\n\tp6.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp6 -= vec3( 3.4, 10.5, 0.0 );\n\tp6 = rotateZ( p6, -hoopRotVal );\n\tp6 += vec3( 3.4, 10.5, 0.0 );\n\t\t\n\tobjID = 6.0;\n\tvec2 seat4 = vec2(\n\t\tfBox( p6 - vec3( 3.4, 10.5, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat4CutA = vec2(\n\t\tfBox( p6 - vec3( 3.3, 11.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat4 = max( seat4, -seat4CutA );\n\t\n\tvec2 seat4CutB = vec2(\n\t\tfBox( p6 - vec3( 2.7, 10.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat4 = max( seat4, -seat4CutB );\n\t\n\t// Seat 5\n\t// ------\n\tvec3 p7 = p;\n\t// Rotate with the hoops.\n\tp7.y -= 7.0;\n\tp7 = rotateZ( p7, hoopRotVal );\n\tp7.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp7 -= vec3( 5.0, 7.0, 0.0 );\n\tp7 = rotateZ( p7, -hoopRotVal );\n\tp7 += vec3( 5.0, 7.0, 0.0 );\n\t\t\n\tobjID = 7.0;\n\tvec2 seat5 = vec2(\n\t\tfBox( p7 - vec3( 5.0, 7.0, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat5CutA = vec2(\n\t\tfBox( p7 - vec3( 4.9, 7.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat5 = max( seat5, -seat5CutA );\n\t\n\tvec2 seat5CutB = vec2(\n\t\tfBox( p7 - vec3( 4.3, 7.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat5 = max( seat5, -seat5CutB );\n\t\n\t// Seat 6\n\t// ------\n\tvec3 p8 = p;\n\t// Rotate with the hoops.\n\tp8.y -= 7.0;\n\tp8 = rotateZ( p8, hoopRotVal );\n\tp8.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp8 -= vec3( 3.4, 3.5, 0.0 );\n\tp8 = rotateZ( p8, -hoopRotVal );\n\tp8 += vec3( 3.4, 3.5, 0.0 );\n\t\t\n\tobjID = 8.0;\n\tvec2 seat6 = vec2(\n\t\tfBox( p8 - vec3( 3.4, 3.5, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat6CutA = vec2(\n\t\tfBox( p8 - vec3( 3.3, 4.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat6 = max( seat6, -seat6CutA );\n\t\n\tvec2 seat6CutB = vec2(\n\t\tfBox( p8 - vec3( 2.7, 3.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat6 = max( seat6, -seat6CutB );\n\t\n\t// Seat 7\n\t// ------\n\tvec3 p9 = p;\n\t// Rotate with the hoops.\n\tp9.y -= 7.0;\n\tp9 = rotateZ( p9, hoopRotVal );\n\tp9.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp9 -= vec3( 0.0, 2.0, 0.0 );\n\tp9 = rotateZ( p9, -hoopRotVal );\n\tp9 += vec3( 0.0, 2.0, 0.0 );\n\t\t\n\tobjID = 9.0;\n\tvec2 seat7 = vec2(\n\t\tfBox( p9 - vec3( 0.0, 2.0, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat7CutA = vec2(\n\t\tfBox( p9 - vec3( -0.1, 2.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat7 = max( seat7, -seat7CutA );\n\t\n\tvec2 seat7CutB = vec2(\n\t\tfBox( p9 - vec3( -0.7, 2.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat7 = max( seat7, -seat7CutB );\n\t\n\t// Seat 8\n\t// ------\n\tvec3 p10 = p;\n\t// Rotate with the hoops.\n\tp10.y -= 7.0;\n\tp10 = rotateZ( p10, hoopRotVal );\n\tp10.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp10 -= vec3( -3.4, 3.5, 0.0 );\n\tp10 = rotateZ( p10, -hoopRotVal );\n\tp10 += vec3( -3.4, 3.5, 0.0 );\n\t\t\n\tobjID = 10.0;\n\tvec2 seat8 = vec2(\n\t\tfBox( p10 - vec3( -3.4, 3.5, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat8CutA = vec2(\n\t\tfBox( p10 - vec3( -3.5, 4.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat8 = max( seat8, -seat8CutA );\n\t\n\tvec2 seat8CutB = vec2(\n\t\tfBox( p10 - vec3( -4.1, 3.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat8 = max( seat8, -seat8CutB );\n\t\n\t//---------------------------------------------------\n\t\n\tvec2 closest = ground.s < groundBeam.s ? ground : groundBeam;\n\tclosest = closest.s < brace1.s ? closest : brace1;\n\tclosest = closest.s < brace2.s ? closest : brace2;\n\tclosest = closest.s < crossBeam.s ? closest : crossBeam;\n\t\n\tclosest = closest.s < outerHoop.s ? closest : outerHoop;\n\tclosest = closest.s < innerHoop.s ? closest : innerHoop;\n\tclosest = closest.s < axleHoop.s ? closest : axleHoop;\n\tclosest = closest.s < tower.s ? closest : tower;\n\tclosest = closest.s < arm1.s ? closest : arm1;\n\tclosest = closest.s < arm2.s ? closest : arm2;\n\tclosest = closest.s < arm3.s ? closest : arm3;\n\tclosest = closest.s < arm4.s ? closest : arm4;\n\tclosest = closest.s < axle.s ? closest : axle;\n\t\n\tclosest = closest.s < seat1.s ? closest : seat1;\n\tclosest = closest.s < seat2.s ? closest : seat2;\n\tclosest = closest.s < seat3.s ? closest : seat3;\n\tclosest = closest.s < seat4.s ? closest : seat4;\n\tclosest = closest.s < seat5.s ? closest : seat5;\n\tclosest = closest.s < seat6.s ? closest : seat6;\n\tclosest = closest.s < seat7.s ? closest : seat7;\n\tclosest = closest.s < seat8.s ? closest : seat8;\n\t\n\t//---------------------------------------------------\n\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID )\n{    \n    vec3 col = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tcol = vec3( 0.0, 1.0, 0.0 );\n\t}\n\telse if ( objNum == 2.0 )\n\t{\n\t\tcol = vec3( 0.95, 0.95, 1.0 );\n\t}\n\telse if ( objNum == 3.0 )\t// seat 1\n\t{\n\t\tcol = vec3( 1.0, 0.0, 0.0 );\n\t}\n\telse if ( objNum == 4.0 )\n\t{\n\t\tcol = vec3( 1.0, 0.5, 0.0 );\n\t}\n\telse if ( objNum == 5.0 )\t// seat 3\n\t{\n\t\tcol = vec3( 1.0, 1.0, 0.0 );\n\t}\n\telse if ( objNum == 6.0 )\n\t{\n\t\tcol = vec3( 0.5, 1.0, 0.0 );\n\t}\n\telse if ( objNum == 7.0 )\t// seat 5\n\t{\n\t\tcol = vec3( 0.0, 1.0, 1.0 );\n\t}\n\telse if ( objNum == 8.0 )\n\t{\n\t\tcol = vec3( 0.0, 0.0, 1.0 );\n\t}\n\telse if ( objNum == 9.0 )\t// seat 7\n\t{\n\t\tcol = vec3( 0.5, 0.0, 1.0 );\n\t}\n\telse if ( objNum == 10.0 )\n\t{\n\t\tcol = vec3( 1.0, 0.0, 0.5 );\n\t}\n\t    \n    return col;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// For Gardner Cos Clouds skyColor()\n\tvec2 st = fragCoord;\n\tst.x *= 0.5;\n\tst.x += sin( iTime * 0.1 ) * 0.5;\n\tst.y *= 0.75;\n\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n \tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n    vec3 lightPos = LIGHT_POS;\n\tvec3 sceneColor = vec3( 0.0 );\n\tvec3 skyClr = skyColor( st );\n\t   \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( FAR * 0.8, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID ) * 0.45;\n\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4( clamp( sceneColor, 0.0, 1.0 ), 1.0 );\n    \n}\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// \thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n\t}\n\telse\n\t{\n\t\tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange;\n\t}\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = 0.25 * ( sin( iTime * 0.1 ) + 1.0 ) + PI_16;\n\t}\n\telse\n\t{\n\t\tang = ( 0.4825 * iMouse.y - iResolution.y * 0.5 ) * rotRange + PI_16; \n\t}\n\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft  \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n        dist += min( h, stepDist * 2.0 ); \n        \n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // Add 0.5 to the final shade value, which lightens the shadow a bit. \n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID )\n                                                               \n{    \n    // Light direction vector.\n    vec3 lDir = LIGHT_POS - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    vec3 objCol = getObjectColor( sp, distID );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + vec3( 1.0, 0.6, 0.2 ) *\n                                                          spec * 2.0 ) * atten;\n   \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// SKY COLOR\n// ---------\n// https://www.shadertoy.com/view/lll3z4\n// Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n/*\n * Gardner Cos Clouds\n *\n * Translated/adapted from the RenderMan implementation in\n * Texturing & Modeling; a Procedural Approach (3rd ed, p. 50)\n */\n \nvec3 skyColor( vec2 pix )\n{\n\tconst int nTerms = 10;\n\t\n\tfloat zoom = 1.0,\n          cloudDensity = 0.0,\n          amplitude = 0.45,\n          xphase = 0.9 * iTime,\n          yphase = 0.7,\n          xfreq = 2.0 * PI * 0.023,\n          yfreq = 2.0 * PI * 0.021,\n    \n          offset = 0.5,\n          xoffset = 37.0,\n          yoffzet = 523.0,\n    \n          x = pix.x,\n          y = pix.y,\n\t      scale = 1.0 / iResolution.x * 60.0 * 1.0 / zoom;\n\n    x = x * scale + offset + iTime * 1.5;\n    y = y * scale + offset - iTime / 2.3;\n    \n    for ( int i = 0; i < nTerms; i++ )\n    {\n        float fx = amplitude * ( offset + cos( xfreq * ( x + xphase ) ) );\n        float fy = amplitude * ( offset + cos( yfreq * ( y + yphase ) ) );\n        cloudDensity += fx * fy;\n        xphase = PI * 0.5 * 0.9 * cos( yfreq * y );\n        yphase = PI * 0.5 * 1.1 * cos( xfreq * x );\n        amplitude *= 0.602;\n        xfreq *= 1.9 + float( i ) * .01;\n        yfreq *= 2.2 - float( i ) * 0.08;\n    }\n\n    return mix( vec3(0.4, 0.6, 0.9 ), vec3( 1.0 ), cloudDensity );   \n}\n\n// end skyColor()\n\n//------------------------------------------------------------------------------\n\n// ROTATE Z\n// --------\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n//------------------------------------------------------------------------------\n// The code below is excerpted from:\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}