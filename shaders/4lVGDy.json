{
    "Shader": {
        "info": {
            "date": "1476491255",
            "description": "studying shanes cellular voronoi, use mouse x to change number of detail samples and use mouse y to zoom.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lVGDy",
            "likes": 6,
            "name": "Studying shanes cellular voronoi",
            "published": 3,
            "tags": [
                "voronoi",
                "study",
                "cellular",
                "shanes"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 720
        },
        "renderpass": [
            {
                "code": "//Shane's cellular algorithm found here https://www.shadertoy.com/view/XtyGzc\n//gives voronoi results very cheaply, here in this shader i study how it works\n\n//use mouse x to change number of detail samples and use mouse y to zoom\n\n\n//Here's shanes cellular algorithm found in his shader\n\n// Draw the object on the repeat tile. In this case, a sphere. The result it squared, but that can\n// be taken into account after obtaining the minimum. See below.\nfloat drawObject(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return min(d.x, d.y)*2.66; // Scale between zero and one... roughly.\n}\n\n\n\n\n//here i've converted it to 2d\nfloat drawObject2d(in vec2 p){ p = fract(p)-.5; return dot(p, p); }\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile2d(in vec2 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject2d(p - vec2(.391, .62));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject2d(p - vec2(.24, .587));\n    p.yx = vec2(p.x-p.y, p.x + p.y)*.7071;\n    d.z = drawObject2d(p - vec2(.778, .14));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.w = drawObject2d(p - vec2(.2623, .783));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return min(d.x, d.y)*2.66; // Scale between zero and one... roughly.\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //screen position\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord.xy*2.-R)/R.x;\n    \n    //sample 2d slices of 3d cell tile at a procedurally smaller detail\n    float s = 0.;\n    float nSlices;\n    \n    if (iMouse.w > 0.) {\n        nSlices = 1.+floor(7.*iMouse.x/iResolution.x);\n        uv *= pow(0.5+iMouse.y/iResolution.y,4.);\n    } else {\n        nSlices = 1.+floor(mod(iTime,7.));\n    }\n\n    for (int i = 0; i < 8; i++) {\n        if (float(i) >= nSlices) continue;\n        \n        s += cellTile2d(uv*pow(float(i+1)*.8724,2.384))/float(i*i+1);\n    }\n    s = s/max(1., pow(nSlices,1./2.)/4.);\n    \n    //animated 2D by taking a 2D slice of 3D\n    //s = cellTile(vec3(uv*10.,iTime*0.1));\n    \n    //output 2d slice sample to grayscale pixel\n    fragColor = vec4(s);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}