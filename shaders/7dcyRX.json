{
    "Shader": {
        "info": {
            "date": "1653816531",
            "description": "( still some glitches in the solver )\nmouse controls camera\nreference: https://www.facebook.com/gianni.sarcone/videos/506922401137887/\n( oops, wireframe don't perfectly fit at end)\n( relies on Shane's quadric solver https://www.shadertoy.com/view/XsGyDh )",
            "flags": 0,
            "hasliked": 0,
            "id": "7dcyRX",
            "likes": 21,
            "name": " intertwined torii",
            "published": 3,
            "tags": [
                "raytracing",
                "torus",
                "short",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 572
        },
        "renderpass": [
            {
                "code": "// relies on Shane's quadric solver https://www.shadertoy.com/view/XsGyDh\n// ( see Common )\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation   \n\nfloat draw( vec3 p, vec3 A, vec2 r) { // ---- pattern upon the torus   \n    vec3 Ay = normalize(cross(vec3(1,0,0),A)), Ax = cross(A,Ay); // torus frame\n    vec2 U;\n    U.y = atan( dot(p,A) ,  ( dot(p,p) - dot(r,r) ) * .5/r.x );\n     // or   asin ( \"/r2 ) or  acos( \"/r2 )  * sign\n    p -= dot(p,A) *A; \n    U.x  = atan(dot(p,Ax), dot(p,Ay) );\n    U = sin( vec2(20,10)*U );\n    U = max(1.- abs(U)/fwidth(U), 0.);\n    return max(U.x,U.y);\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),         // ray direction\n          P = 60./R,                                      // camera position \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(25,10,0)/1e2*cos(.5*iTime+vec3(0,11,0)); // auto thumbnail\n    \n    P.yz *= rot(-6.*M.y),                                 // rotations\n    P.xz *= rot(-6.*M.x);\n    D.yz *= rot(-6.*M.y),                           \n    D.xz *= rot(-6.*M.x);\n    float r0 = 2.5 + 1.5*sin(iTime);                      // [1,4]\n    vec3 C[] = vec3[]( vec3(10.-r0, 0, 0), -vec3(10.-r0, 0, 0), vec3(0,0,0) ),\n         A[] = vec3[]( vec3(0,.7,.7), vec3(0,.7,-.7), vec3(0,1,0) );\n    vec2 r[] = vec2[]( vec2(10,r0),vec2(10,r0),vec2(10,10.-2.*r0) );\n    O-=O; vec4 dist;      \n    float d = 1e4, l;                                     // opaque draw\n    l = closest( torus (P,D,C[0],A[0],r[0], dist), dist); \n    if ( l < d )  d = l, O = vec4(.6-draw(P+d*D-C[0],A[0],r[0]));\n    l = closest( torus (P,D,C[1],A[1],r[1], dist), dist); \n    if ( l < d )  d = l, O = vec4(.6-draw(P+d*D-C[1],A[1],r[1]));\n               \n                                                          // wireframe draw\n    bvec4 hit = torus (P,D,vec3(0),A[2],r[2], dist);\n    if (hit.x && dist.x < d ) O = mix(O, vec4(1 ), draw(P+dist.x*D,A[2],r[2]) );\n    if (hit.y && dist.y < d ) O = mix(O, vec4(.3), draw(P+dist.y*D,A[2],r[2]) );\n    if (hit.z && dist.z < d ) O = mix(O, vec4(1 ), draw(P+dist.z*D,A[2],r[2]) );\n    if (hit.w && dist.w < d ) O = mix(O, vec4(.3), draw(P+dist.w*D,A[2],r[2]) );\n\n     \n    O = sqrt(O);                                          // to sRGB\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// switch  Shane / IQ\n   #define torus(p,d,c,n,r,S) ShaneTorus(p,d,c,n,r, S) // best of 3 in wyatt bench\n// #define torus(p,d,c,n,r,S)    IqTorus(p,d,c,n,r, S) // not better, but shorter !\n\n// naive P4 solver is too instable in float: https://www.shadertoy.com/view/fsdyzj\n// → better solutions:\n// from Shane https://www.shadertoy.com/view/XsGyDh\n// and wyatt bench https://www.shadertoy.com/view/XddfW7\n// WIP: adapt mla more robust version: https://www.shadertoy.com/view/Nd3cRs\n\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n    float p = coeffs.y / 2.;\n    float D = p*p - coeffs.x;\n    if (D <= 0.) return 0;\n    else {\n        roots = vec2(-1, 1)*sqrt(D) - p;\n        return 2;\n    }\n}\nint solve_cubic(vec3 coeffs, inout vec3 r){\n    float a = coeffs[2];\n    float b = coeffs[1];\n    float c = coeffs[0];\n    float p = b - a*a/3.;\n    float q = a * (2.*a*a - 9.*b)/27. + c;\n    float p3 = p*p*p;\n    float d = q*q + 4.*p3/27.;\n    float offset = -a/3.;\n    if(d >= 0.0) { \n        vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n        uv = uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n        r[0] = offset + uv.x + uv.y;\t\n        float f = ((r[0] + a)*r[0] + b)*r[0] + c;\n        float f1 = (3.*r[0] + 2. * a)*r[0] + b;\n        r[0] -= f/f1;\n        return 1;\n    }\n    float u = sqrt(-p/3.);\n    float v = acos(-sqrt(-27./p3)*q/2.)/3.;\n    float m = cos(v), n = sin(v)*1.732050808;\n    float f,f1;\n    r[0] = offset + u * (m + m);\n    f = ((r[0] + a)*r[0] + b)*r[0] + c;\n    f1 = (3.*r[0] + 2. * a)*r[0] + b;\n    r[0] -= f / f1;\n    r[1] = offset - u * (n + m);\n    f = ((r[1] + a)*r[1] + b) * r[1] + c;\n    f1=(3.*r[1] + 2. * a)*r[1] + b;\n    r[1] -= f / f1;\n    r[2] = offset + u * (n - m);\n    f = ((r[2] + a)*r[2] + b)*r[2] + c;\n    f1 = (3.*r[2] + 2. * a)*r[2] + b;\n    r[2] -= f / f1;\n    return 3;\n}\nbvec4 solve_quartic(vec4 coeffs, inout vec4 s){\n    bvec4 broots;\n    float a = coeffs[0];\n    float b = coeffs[1];\n    float c = coeffs[2];\n    float d = coeffs[3];\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n    int num;\n    vec3 cubic_coeffs;\n    cubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n    cubic_coeffs[1] = - r;\n    cubic_coeffs[2] = - 1.0/2. * p;\n    solve_cubic(cubic_coeffs, s.xyz);\n    float z = s[0];\n    float u = z * z - r;\n    float v = 2. * z - p;\n    if(u > 0.) u = sqrt(abs(u));\n    else return bvec4(false);\n    if(v > 0.) v = sqrt(abs(v));\n    else return bvec4(false);\n    vec2 quad_coeffs;\n    quad_coeffs[0] = z - u;\n    quad_coeffs[1] = q < 0. ? -v : v;\n    num = solve_quadric(quad_coeffs, s.xy);\n    if (num == 0) broots.xy = bvec2(false);\n    if (num == 2) broots.xy = bvec2(true);\n    quad_coeffs[0] = z + u;\n    quad_coeffs[1] = q < 0. ? v : -v;\n    vec2 tmp = vec2(1e8);\n    int old_num = num;\n    num = solve_quadric(quad_coeffs, s.zw);\n    if (num == 0) broots.zw = bvec2(false);\n    if (num == 2) broots.zw = bvec2(true);\n    s -= a/4.;\n    return broots;\n}\n\n\nfloat absmin(float a, float b) {\n\treturn b>0. ? min(a,b) : a;\n}\n/* float intersect (vec4 coes) {\n    vec4 roots;\n    bvec4 br = solve_quartic(coes, roots);\n\tfloat i = 1e4;\n    if (br.x) i = absmin(i,roots.x);\n    if (br.y) i = absmin(i,roots.y);\n    if (br.z) i = absmin(i,roots.z);\n    if (br.w) i = absmin(i,roots.w);\n    return i;\n}*/\nfloat closest (bvec4 br, vec4 roots) {  // $Fab\n\tfloat i = 1e4;\n    if (br.x) i = absmin(i,roots.x);\n    if (br.y) i = absmin(i,roots.y);\n    if (br.z) i = absmin(i,roots.z);\n    if (br.w) i = absmin(i,roots.w);\n    return i;\n}\n\nbvec4 ShaneTorus (vec3 p, vec3 d, vec3 c, vec3 n, vec2 r, inout vec4 S) {\n\tfloat dn = dot(d,n);\n    float wn = dot(p-c,n);\n    vec3 s = p-c-wn*n;\n    vec3 q = d - dn*n;\n    float qq = dot(q,q);\n    float sq = dot(s,q);\n    float ss = dot(s,s);\n    float A = (dn*dn+qq)*0.5/r.x;\n    float B = (wn*dn+sq)/r.x;\n    float C = (r.x*r.x-r.y*r.y+wn*wn+ss)*0.5/r.x;\n    vec4 coes = vec4(2.*A*B,B*B+2.*A*C-qq,2.*C*B-2.*sq,C*C-ss)/(A*A);\n    return solve_quartic(coes, S);  // $Fab\n\n}\n\n// --- IQ version  https://iquilezles.org/articles/intersectors/\n\nbvec4 torIntersect( in vec3 ro, in vec3 rd, in vec2 tor, inout vec4 S )\n{\n    float po = 1.0;\n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        S = vec4(t1,t2,0,0).yxzw;                      // $Fab\n        return  bvec4(t1>0.,t2>0.,false,false).yxzw;\n/*\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n         return t;\n*/\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return bvec4(false); // -1.0;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    \n    S = vec4(t1,t2,t3,t4).wzyx;                         // $Fab\n    return  bvec4(t1>0.,t2>0.,t3>0.,t4>0.).wzyx;\n/*    \n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return t;\n*/\n}\n\n#define rot3(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n\nbvec4 IqTorus (vec3 p, vec3 d, vec3 c, vec3 n, vec2 r, inout vec4 S ) {\n    p -= c; \n    float a = -acos(n.z); // rotation turning n into vec3(0,0,1)\n    if (abs(a)>1e-3) {\n        vec3  A = normalize(cross(n,vec3(0,0,1)));\n        p = rot3(p,A,a);\n        d = normalize(rot3(d,A,a));\n    }\n    return torIntersect( p, d, r, S );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}