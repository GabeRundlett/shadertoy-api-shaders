{
    "Shader": {
        "info": {
            "date": "1640159982",
            "description": "Grapes... made from Harry's recent Tweet: https://twitter.com/HarryAlisavakis/status/1473354613835325442\n\nI'm terribly sorry for this...",
            "flags": 0,
            "hasliked": 0,
            "id": "7tGXzh",
            "likes": 8,
            "name": "FFXIV Grapes Official Shadertoy!",
            "published": 3,
            "tags": [
                "lowpoly",
                "gem",
                "meme",
                "harry",
                "grapes",
                "ffxiv",
                "alisavakis"
            ],
            "usePreview": 0,
            "username": "toomuchvoltage",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   Grapes, OMG GRAPES!\n   I couldn't help myself... I'm sorry.\n\n   Covered under the MIT license:\n\n   Copyright (c) 2021 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\n#define DRAW_DISTANCE 100.0\n#define M_PI 3.1415926535\n//#define USE_PERIODIC_SMOOTHING 1\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n    return dot(p,n) + h;\n}\n\nconst vec3 topNorm1 = normalize (vec3 (0.0, 1.0, 0.75));\nconst vec3 topNorm2 = normalize (vec3 (0.0, 1.0, -0.75));\nconst vec3 topNorm3 = normalize (vec3 (0.75, 1.0, 0.0));\nconst vec3 topNorm4 = normalize (vec3 (-0.75, 1.0, 0.0));\nconst vec3 sideNorm1 = normalize (vec3 (0.0, -0.1, 0.75));\nconst vec3 sideNorm2 = normalize (vec3 (0.0, -0.1, -0.75));\nconst vec3 sideNorm3 = normalize (vec3 (0.75, -0.1, 0.0));\nconst vec3 sideNorm4 = normalize (vec3 (-0.75, -0.1, 0.0));\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n#ifdef USE_PERIODIC_SMOOTHING\nfloat scene(vec3 p)\n{\n    float smoothFactor = abs(sin(iTime)) * 0.5;\n    \n    float box = sdBox (p, vec3 (0.5, 1.0, 0.5));\n    float topPlane1 = sdPlane (p, topNorm1, -0.8);\n    float topPlane2 = sdPlane (p, topNorm2, -0.8);\n    float topPlane3 = sdPlane (p, topNorm3, -0.8);\n    float topPlane4 = sdPlane (p, topNorm4, -0.8);\n    float topCut = opSmoothIntersection (opSmoothIntersection (topPlane1, topPlane2, smoothFactor), opSmoothIntersection (topPlane3, topPlane4, smoothFactor), smoothFactor);\n\n    float sidePlane1 = sdPlane (p - vec3 (0.0, 0.0, 0.75) * 0.5, sideNorm1, 0.0);\n    float sidePlane2 = sdPlane (p - vec3 (0.0, 0.0, -0.75) * 0.5, sideNorm2, 0.0);\n    float sidePlane3 = sdPlane (p - vec3 (0.75, 0.0, 0.0) * 0.5, sideNorm3, 0.0);\n    float sidePlane4 = sdPlane (p - vec3 (-0.75, 0.0, 0.0) * 0.5, sideNorm4, 0.0);\n    float sideCut = opSmoothIntersection (opSmoothIntersection (sidePlane1, sidePlane2, smoothFactor), opSmoothIntersection (sidePlane3, sidePlane4, smoothFactor), smoothFactor);\n    \n    float bottomPlane1 = sdPlane (p, -topNorm1, -0.8);\n    float bottomPlane2 = sdPlane (p, -topNorm2, -0.8);\n    float bottomPlane3 = sdPlane (p, -topNorm3, -0.8);\n    float bottomPlane4 = sdPlane (p, -topNorm4, -0.8);\n    float bottomCut = opSmoothIntersection (opSmoothIntersection (bottomPlane1, bottomPlane2, smoothFactor), opSmoothIntersection (bottomPlane3, bottomPlane4, smoothFactor), smoothFactor);\n\n    return opSmoothIntersection (opSmoothIntersection (topCut, box, smoothFactor), opSmoothIntersection (sideCut, bottomCut, smoothFactor), smoothFactor) - smoothFactor;\n}\n#else\nfloat scene(vec3 p)\n{\n    float box = sdBox (p, vec3 (0.5, 1.0, 0.5));\n    float topPlane1 = sdPlane (p, topNorm1, -0.8);\n    float topPlane2 = sdPlane (p, topNorm2, -0.8);\n    float topPlane3 = sdPlane (p, topNorm3, -0.8);\n    float topPlane4 = sdPlane (p, topNorm4, -0.8);\n    float topCut = max (max (topPlane1, topPlane2), max (topPlane3, topPlane4));\n\n    float sidePlane1 = sdPlane (p - vec3 (0.0, 0.0, 0.75) * 0.5, sideNorm1, 0.0);\n    float sidePlane2 = sdPlane (p - vec3 (0.0, 0.0, -0.75) * 0.5, sideNorm2, 0.0);\n    float sidePlane3 = sdPlane (p - vec3 (0.75, 0.0, 0.0) * 0.5, sideNorm3, 0.0);\n    float sidePlane4 = sdPlane (p - vec3 (-0.75, 0.0, 0.0) * 0.5, sideNorm4, 0.0);\n    float sideCut = max (max (sidePlane1, sidePlane2), max (sidePlane3, sidePlane4));\n    \n    float bottomPlane1 = sdPlane (p, -topNorm1, -0.8);\n    float bottomPlane2 = sdPlane (p, -topNorm2, -0.8);\n    float bottomPlane3 = sdPlane (p, -topNorm3, -0.8);\n    float bottomPlane4 = sdPlane (p, -topNorm4, -0.8);\n    float bottomCut = max (max (bottomPlane1, bottomPlane2), max (bottomPlane3, bottomPlane4));\n\n    return max (max (topCut, box), max (sideCut, bottomCut));\n}\n#endif\n\nbool sphereMarchScene(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm)\n{\n    vec3 samplePt = startPt;\n    for (int i = 0; i != 120; i++)\n    {\n        float curDist = scene (samplePt);\n        if ( curDist < 0.001 )\n        {\n            hitNorm.x = scene(samplePt + vec3(0.001, 0.0, 0.0)) - scene(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = scene(samplePt + vec3(0.0, 0.001, 0.0)) - scene(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = scene(samplePt + vec3(0.0, 0.0, 0.001)) - scene(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nfloat evalTex (vec2 uv)\n{\n    return max (textureLod (iChannel0, uv, 0.0).r - 0.2, 0.0) * 1.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvRaw = fragCoord/iResolution.xy;\n    vec2 uv = uvRaw * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec4 mouseInfo = iMouse / iResolution.xxxx;\n    \n    vec3 curEye;\n    float angX = mouseInfo.x * 6.0 - M_PI * 0.5;\n    float angY = mouseInfo.y * 6.0 - M_PI * 0.5;\n    if (iMouse.z <= 0.0) angX += iTime;\n    curEye = vec3 (cos(angX), angY, sin(angX)) * 3.0;\n    vec3 sampleLook = normalize (-curEye);\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    \n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n\n    samplePt = curEye + sampleDir;\n    vec3 hitNorm, hitPoint;\n    vec3 colorAccum = vec3 (0.0);\n\n    if ( sphereMarchScene (samplePt, sampleDir, hitPoint, hitNorm) )\n    {\n        vec3 absNorm = abs (hitNorm);\n        vec3 matFetch;\n        if ( absNorm.x > 0.7 )\n        {\n            vec2 centUV = hitPoint.yz * 0.5;\n            matFetch = vec3 (evalTex (centUV));\n            float du = evalTex (centUV - vec2 (0.01, 0.0)) - evalTex (centUV + vec2 (0.01, 0.0));\n            float dv = evalTex (centUV - vec2 (0.0, 0.01)) - evalTex (centUV + vec2 (0.0, 0.01));\n            hitNorm = normalize (hitNorm + vec3 (0.0, du, dv));\n        }\n        else if ( absNorm.y > 0.7 )\n        {\n            vec2 centUV = hitPoint.xz * 0.5;\n            matFetch = vec3 (evalTex (centUV));\n            float du = evalTex (centUV - vec2 (0.01, 0.0)) - evalTex (centUV + vec2 (0.01, 0.0));\n            float dv = evalTex (centUV - vec2 (0.0, 0.01)) - evalTex (centUV + vec2 (0.0, 0.01));\n            hitNorm = normalize (hitNorm + vec3 (du, 0.0, dv));\n        }\n        else\n        {\n            vec2 centUV = hitPoint.xy * 0.5;\n            matFetch = vec3 (evalTex (centUV));\n            float du = evalTex (centUV - vec2 (0.01, 0.0)) - evalTex (centUV + vec2 (0.01, 0.0));\n            float dv = evalTex (centUV - vec2 (0.0, 0.01)) - evalTex (centUV + vec2 (0.0, 0.01));\n            hitNorm = normalize (hitNorm + vec3 (du, dv, 0.0));\n        }\n        matFetch *= vec3 (0.25, 0.05, 1.0) * 0.5; // Grape color\n        \n        float absNdotL = abs (dot(sampleDir,hitNorm));\n        \n        float diff = absNdotL; // Headlight lambert\n        diff = pow (diff, 2.0);\n        \n        vec3 Rv = reflect (sampleDir, hitNorm);\n        vec3 L1 = -sampleLook;\n        vec3 L2 = normalize (-sampleLook + vec3 (55.0, 0.0, 0.0));\n        float phong1 = abs (dot (Rv, L1)); // Headlight phong1\n        phong1 = pow (phong1, 500.0);\n        vec3 phoneLight1 = phong1 * vec3 (0.75, 0.75, 0.0);\n        float phong2 = abs (dot (Rv, L2)); // Headlight phong2\n        phong2 = pow (phong2, 500.0);\n        vec3 phoneLight2 = phong2 * vec3 (0.25, 0.35 ,0.5);\n        \n        vec3 shlick = pow (1.0 - absNdotL, 7.0) * vec3 (0.25, 0.35 ,0.5) * 0.5; // Fresnel halo\n        \n        fragColor = vec4 (diff * matFetch + phoneLight1 + phoneLight2 + shlick, 1.0);\n        \n        fragColor.rgb = pow (fragColor.rgb, vec3 (1.0/2.2)); // Gamma\n    }\n    else\n        fragColor = vec4 (vec3 (0.25, 0.35 ,0.5) * max (1.5 - length(uv), 0.0), 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}