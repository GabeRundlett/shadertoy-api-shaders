{
    "Shader": {
        "info": {
            "date": "1667609966",
            "description": "inercia 2022 shader royale",
            "flags": 0,
            "hasliked": 0,
            "id": "DsjGWD",
            "likes": 35,
            "name": "Acrid Ball of Fun",
            "published": 3,
            "tags": [
                "livecode",
                "shaderroyale"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 497
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat sh1,sh2,sh3;\nfloat time ;\n\nfloat fac(vec3 p) {\n  p = asin(sin(p));\n  return dot(normalize(vec3(1)),p);\n}\n\nfloat noise(vec3 p, float dir) {\n  float f1 = fac(erot(p, normalize(vec3(1,2,3)),1.4+sh1*dir));\n  float f2 = fac(erot(p, normalize(vec3(-1,3,2)),2.4+sh2*dir));\n  float f3 = fac(erot(p, normalize(vec3(1,-2,1)),.4+sh3*dir));\n  \n  return (f1 + f2)/sqrt(2.);\n  return (f1 + f2 + f3)/2.;\n}\n\nfloat ball(vec3 p, float w, float t, float dir) {\n  vec3 p2 = normalize(p);\n  float f = noise(p2*7.*w, dir)/7./w;\n  return length(vec2(f,length(p)-w))-t;\n}\n\nfloat scene(vec3 p) {\n  float b1 = ball(p,1.,.1,-1.);\n  float b2 = ball(p,1.5,.03,1.);\n  float b3 = ball(p,2.,.02,-1.);\n  float b4 = ball(p/2.,2.,.01,1.)*2.;\n  return mix(min(min(b1,b2),min(b4,b3)), mix(noise(p*50., 1.)/50., noise(p*10.,-1.)/10., .5), .2);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n#define FK(x) floatBitsToInt(x*x/7.)^floatBitsToInt(x)\nfloat hash(float a, float b) {\n  int x = FK(a), y = FK(b);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat fakefft(float k) {\nfloat mul = fract(sin(k*564.)*353.);\n    return pow(1.-k,3.) * (.5+.5*sin(iTime*3.*sqrt(k+1.)*(4.4544+mul)))*1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 uv2 = floor(uv*4.)/4.;\n  float hs = hash(uv2.x,uv2.y);\n  time = iTime + (hash(hs,54.)+hash(hs,456.)+hash(hs,234.)+hs)*(.2*(sin(iTime*.5)*.5+.5));\n  \n  float bar = floor(fragCoord.x / iResolution.x*20.)/20.;\n  bar = abs(bar-.5);\n  bool inbar = false;\n  if (fakefft(bar)*(20.+bar*bar*600.)/100. > 1.-abs(fragCoord.y / iResolution.y-.5)*2.) {\n    inbar = true;\n  }\n  \n  float it = iTime*.3;\n  sh1 = sin(it);\n  sh2 = cos(it*1.34235);\n  sh3 = sin(it*2.15335);\n  \n  float off1,off2,off3,off4,off5;\n  \n  float tt = floor(time);\n  float t2 = asin(sin(iTime)) * .2;\n  off1 = sin(tt*45.) + t2;\n  off2 = cos(tt*33.) + t2;\n  off3 = sin(tt*76.) + t2;\n  off4 = sin(tt*17.) + t2;\n  off5 = sin(tt*99.);\n\n  vec3 cam = normalize(vec3(.7+off3*.5,uv));\n  vec3 init = vec3(-3,off1,off2);\n  \n  float zrot = iTime*.3 + off4;\n  cam = erot(cam,vec3(0,0,1),zrot);\n  init = erot(init,vec3(0,0,1),zrot);\n  \n  float glow = 0.;\n  \n  vec3 p = init;\n  bool hit = false;\n  bool trig1 = false;\n  bool refl=false;\n  bool trig2 = false;\n  float atten = 1.;\n  for (int i = 0; i< 100 && !hit; i++) {\n    float dist = scene(p);\n    if(dist*dist<1e-6) {\n      if (sin(erot(p,normalize(vec3(1,1,1)),.96).z*10.) < -0.85) {\n      vec3 n = norm(p);\n      atten*=1.-abs(dot(cam,n))*.9;\n      p += n*.01;\n      cam = reflect(cam,n);\n        refl=true;\n      }else{\n      hit = true;\n      }\n    }\n    float dd = distance(p,init);\n    if (dist < 0.002*dd)trig1=true;\n    if (dist > 0.002*dd && trig1)trig2=true;\n    p += cam*dist;\n    glow += .08/(length(p)+.01) * sqrt(abs(dist));\n    if(distance(p,init)>100.)break;\n  }\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float diff = length(sin(n*2.)*.5+.5)/sqrt(3.);\n  float ref = length(sin(r*2.)*.5+.5)/sqrt(3.);\n  diff = mix(max(diff*2.-1.,0.), diff, .03);\n  vec3 col = vec3(.9,.2,.2)*diff + pow(ref,20.)*(1.-abs(dot(cam,n))*.9)*5.;\n  fragColor.xyz = sqrt(hit ? col : vec3(0));\n  fragColor.xyz += glow*vec3(0.1,.5,.8);\n  fragColor.xyz += glow*glow;\n  fragColor *= atten;\n  \n  if (trig2 && !refl) fragColor *= 0.;\n  fragColor = smoothstep(.05,1.,fragColor);\n  \n  if (inbar) off4 += 2.5;\n  if (inbar) fragColor += .5;\n  fragColor.xyz = erot(fragColor.xyz*2.-1.,normalize(vec3(off1,off2,off3)), off4)*.5+.5;\n  if (off5 < 0.0) fragColor = 1. - fragColor;\n  fragColor *= 1.-dot(uv,uv)*.5;\n  fragColor += noise(uv.xyy*500.,1.)*.02;\n  fragColor = floor(fragColor*8.)/8.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}