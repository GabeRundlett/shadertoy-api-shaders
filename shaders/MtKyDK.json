{
    "Shader": {
        "info": {
            "date": "1537910967",
            "description": "This shader  will print numbers on the screen if it is so commanded.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtKyDK",
            "likes": 2,
            "name": "counters",
            "published": 3,
            "tags": [
                "numbers"
            ],
            "usePreview": 0,
            "username": "teraspora",
            "viewed": 734
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2018 John Lynch\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation\n// files (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so, subject\n// to the following conditions: The above copyright notice and this permission\n// notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Counters - a fragment shader in OpenGL, built on shadertoy.com;\n// Function: display numbers;\n// Author: John Lynch (@teraspora);\n// Date: 25 SEP 2018.\n\nint num;\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.84, 0.66);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  1.0,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n\nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\n// bitmaps of the 10 decimal digits, given in octal for ease of visualisation\nconst uint[] digits = uint[](07642424276u, 01010101010u, 07602764076u, 07602760276u,\n                             04040447604u, 07640760276u, 04040764276u, 07602020202u,\n                             07642764276u, 07642760202u);\n    \nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\n// return the biggest prime less than n:\nint largestPrimeLessThan(int n) {\n    if (n < 3) return 2;\n\tbool prime[1000];\n    for (int i = 0; i < prime.length(); i++) {\n    \tprime[i] = true;\n    }    \n    for (int p = 2; p * p <= n; p++) { \n        if (prime[p]) { \n            for (int i = p * 2; i <= n; i += p) \n                prime[i] = false; \n        } \n    } \n\tfor (int i = n - 1; i >= 0; i--) {\n    \tif (prime[i]) return i;\n    }    \n}\n\n// MAIN METHOD:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    \n    // Set this var to the number of tiles across and down:\n    float tileDim = 2.;\n    float numTiles = tileDim * tileDim;\n    \n    // some shorter names:\n    float resx = iResolution.x;\n    float resy = iResolution.y;\n    vec2 f = fragCoord.xy;\n    vec2 hr = iResolution.xy / tileDim;\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 1.02;\n    \n    // ===============================================================\n    // the output vector giving the position the program needs to know!-\n    vec2 pp = f;\n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(f.x / resx * tileDim)), float(int(f.y / resy * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.;\t// start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even; (TOE == Tile-odd-even, geddit? ;))\n    float tile2 = tile * tile;\n    \n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    q /= scaleFactor;\n    vec3 col;\n    // ===============================================================\n    \n    // Main code here:\n    \n    int t = int(iTime);\n    float level = mod(iTime, 30.);\n    \n    switch(int(tile)) {\n        case 1:\n        num = t;\n        \tcol = mix(gold, blue, sqrt(abs(sin(q.y))));\n        \tcol.g *= ((cos(iTime / 2.) + 1.) * 0.5);\n    \t\tnum = t;\n    \t\tbreak;\n        case 0:\n        \tcol = mix(orange, yellow, sin(q.y));\n        \tcol.b = (-sin(iTime / 3.) + 1.) * 0.5;\n    \t\tnum = t * t;\n        \tbreak;\n        case 2:\n        \tcol = mix(cyan, crimson, sin(q.y));\n        \tcol.g *= ((-cos(iTime / 5.) + 1.) * 0.5);\n    \t\tnum = largestPrimeLessThan(t);\n        \tbreak;\n        case 3: \n        \tcol = mix(yellow, magenta, sin(q.y));\n        \tcol.g *= ((sin(iTime / 7.) + 1.) * 0.5);\n    \t\tnum = int(pow(2., floor(level)));\n            // shift askew for fun!\n        \tq = rotate(q, PI * 0.015 * (fract(iTime / 60.) < 0.5 ? 1. : -1.));\n        \t// when each new cycle's coming rotate 2pi in 5 secs\t\n        if (level > 25.) q = rotate(q, TWO_PI * 0.2 * (level - 25.));\n            break;\n    }    \n    // We'll store the bitmaps of each digit here, pulling them out of\n    // the digits[] array where they've been put:\n    float rows = 5.;\n    float columns = 54.;\n    // width and height of a digit in rows of bit-blocks\n    float dw = 6.;\n    float dh = 5.;\n    \n    // populate an array with bitmaps for the appropriate digits:\n    uint[] bitmap = uint[10](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u);\n    for (int i = 0, divisor = 100000000; i < 9; i++, divisor /= 10) {\t\n        int m = num / divisor;\n    \tbitmap[i] = digits[m];\n        num -= m * divisor;\n    }\n    // Note: I wasted a lot of time using floats here and getting\n    // numerical errors with large numbers.\n    // Even tried making them all highp.\n    // Eventually realised the only way was back to ints (which I would\n    // certainly have used in any other language!)\n    \n    vec2 box = vec2(0.9, 0.2);\n    vec2 padding = (-box + 1.) / 2.;\n    \n    // if fragCoord is inside the numeric display box, work out where that maps to\n    // in the grid, get the appropriate bit (the tricky bit ;) ) and \"AND\" it with the base colour\n    if (q.x >= -0.5 + padding.x && q.x < 0.5 - padding.x\n        \t&& q.y >= -0.5 + padding.y && q.y < 0.5 - padding.y) {\n        \n    \tvec2 p = (q * vec2(1., -1.) + vec2(0.5, 0.5) - padding) / box;\n        float bx = float(p.x * columns);\n        float by = float(p.y * rows);\n        float place = bx / dw;\n        float dx = bx - floor(place) * dw;\n        float dy = floor(by);\n        uint digit = bitmap[int(place)]; \n        int bitx = int(dy * dw + dx);\n        int charSize = int(dw * dh);\n        bitx = charSize - bitx ;\n        col *= (1. - float((digit >> bitx) & 1u));        \n    }       \n    \n    // End main code. \n    \n    \n    // ===============================================================\n    // rotate the frame in sync but opposite in sense to the contact rotating\n    if (tile == 3. && level > 25.) {\n        pp = rotate(pp - hr * 0.5, TWO_PI * -0.2 * (level - 25.)) + hr * 0.5;\n    }\n    \n    \n    \n    \n    // ===============================================================\n    // Make a border: 8px solid black; with line inset:\n    float b = 6.;   // border width    \n    vec3 borderInsetLineColour = white;\n    \n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = borderInsetLineColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = borderInsetLineColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));    \n    \n    // and finally return the colour:\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}