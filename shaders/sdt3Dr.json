{
    "Shader": {
        "info": {
            "date": "1629617507",
            "description": "light funny",
            "flags": 48,
            "hasliked": 0,
            "id": "sdt3Dr",
            "likes": 4,
            "name": "General Relativistic Black Hole ",
            "published": 3,
            "tags": [
                "raytracing",
                "physics"
            ],
            "usePreview": 1,
            "username": "copperbotte",
            "viewed": 246
        },
        "renderpass": [
            {
                "code": "\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n//another random number generator\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat hashrandom( float x )\n{\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n\n\n\n//color space transforms\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 XYZ_to_lsrgb(vec3 XYZ)\n{\n    mat3 tolsrgb = transpose(mat3( 3.2406,-1.5372,-0.4986,\n                                  -0.9689, 1.8758, 0.0415,\n                                   0.0557,-0.2040, 1.0570));\n    return tolsrgb * XYZ;\n}\n\nvec3 lsrgb_to_XYZ(vec3 lsrgb)\n{\n    mat3 toXYZ = transpose(mat3(0.4124, 0.3576, 0.1805,\n                                0.2126, 0.7152, 0.0722,\n                                0.0193, 0.1192, 0.9505));\n    return toXYZ * lsrgb;\n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        //hsv.yz /= hsv.z; // saturation clip\n        hsv.z /= hsv.z; // luminance clip\n    \n    /*\n    if(1.0 < hsv.y) // what??\n        //hsv.yz /= hsv.z;\n        hsv.y /= hsv.y;\n    */\n    return hsv2rgb(hsv);\n}\n\n// This code was rewritten on the morning of 2022 March 25.\n\n//events are in the form of (x,y,z,t) for ease of programming.\n\nmat4 trace(vec4 tr)\n{\n    mat4 m = mat4(0.0);\n    for(int n=0; n<4; ++n)\n        m[n][n] = tr[n];\n    return m;\n}\n\n// [r, theta, psi, t]\n\nvec3 MorrisThorneCoefficients(float r, float rs)\n{\n    float a0 = rs*2.0;\n    float b0 = a0*3.0;\n    float Phi = 0.0;\n    /*\n    float b = 1.0 - (r - b0)/a0;\n    float db = -(2.0*b0/a0)*b;\n    \n    if(r <= b0)\n        b = b0*b*b;\n    else\n    {\n        b = 0.0;\n        db = 0.0;\n    }*/\n    \n    float b = exp(-r*r/(a0*a0));\n    float db = -b*r/(a0*a0);\n    \n    return vec3(b, db, Phi);\n}\n\nmat4 p_schwarzschildMetric(vec4 p_event, float rs)\n{\n\n    float k = 1.0 - rs / p_event.x;\n    float r2 = p_event.x * p_event.x;\n    float s2 = sin(p_event.y);\n    s2 *= s2;\n    ///*\n    vec4 tr = vec4(1.0/k, r2, r2*s2, -k);\n    mat4 metric = trace(tr);\n    return metric;\n    /*/\n    \n    // Morris-Thorne metric, from here\n    // https://uncw.edu/phy/documents/mceachern_09.pdf\n    // Uses a redshift function Phi = 0, and b = b0(1-(r-b0)/a0)^2 from page 46\n    \n    vec3 MTC = MorrisThorneCoefficients(p_event.x, rs);\n    float b = MTC.x;\n    float db = MTC.y;\n    float Phi = MTC.z;\n    \n    vec4 tr = vec4(1.0/(1.0 - b/p_event.x), r2, r2*s2, -exp(2.0*Phi));\n    mat4 metric = trace(tr);\n    return metric;\n    */\n}\n\n// This code was written from my rewrite of this in March 2022.\nvec4 p_sc_4_accel(in vec4 p_event, in vec4 p_devent, float rs, float c)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    float Dr = r - rs;\n    \n    float dr = p_devent.x;\n    float dth = p_devent.y;\n    float dph = p_devent.z;\n    float dt = p_devent.w;\n    \n    float i_r = 1.0 / r;\n    float dr_r = dr * i_r;\n    \n    float c_t = cos(theta);\n    float s_t = sin(theta);\n    float t_t = tan(theta);\n    ///*\n    vec4 Out;\n    Out = vec4(\n        -(c*c*dt*dt*Dr)*rs/(2.0*r*r*r) + dr*dr*rs/(2.0*r*Dr) + (dth*dth + dph*dph*s_t*s_t)*Dr,\n        -2.0*dr_r*dth + dph*dph*s_t*c_t,\n        -2.0*dph*(dr_r + dth*c_t/s_t),\n        -dr_r*dt*rs/Dr);\n    return Out;\n    /*/\n    vec3 MTC = MorrisThorneCoefficients(p_event.x, rs);\n    float b = MTC.x;\n    float db = MTC.y;\n    float Phi = MTC.z;\n    \n    vec4 Out;\n    Out = vec4(\n        (r - b)*(dth*dth + dph*dph*s_t*s_t) + (dr*dr*(b - r*db))/(2.0*r*(r - b)),\n        -(2.0*dr*dth/r) + dph*dph*c_t*s_t,\n        -(2.0*dph*(dr+dth*r/t_t))/r,\n        -0.0);\n    \n    return Out;\n    */\n}\n\nvec4 toPolar(vec4 event)\n{\n    vec3 x = event.xyz;\n    float r = length(x);\n    float xyr = length(x.xy);\n    float theta = atan(xyr, x.z);\n    float psi = atan(x.y, x.x);\n    return vec4(r, theta, psi, event.w);\n}\n\nvec4 toEuclid(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float x = r*sin(theta)*cos(psi);\n    float y = r*sin(theta)*sin(psi);\n    float z = r*cos(theta);\n    \n    return vec4(x, y, z, p_event.w);\n}\n\nmat4 e_p_jacobian(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float c_p = cos(psi);\n    float s_p = sin(psi);\n    float c_t = cos(theta);\n    float s_t = sin(theta);\n    \n    mat4 J = mat4(   s_t*c_p,   s_t*s_p,    c_t, 0,\n                   r*c_t*c_p, r*c_t*s_p, -r*s_t, 0,\n                  -r*s_t*s_p, r*s_t*c_p,      0, 0,\n                           0,         0,      0, 1);\n    \n    return J;\n}\n\nmat4 e_p_i_jacobian(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float c_p = cos(psi);\n    float s_p = sin(psi);\n    float c_t = cos(theta);\n    float s_t = sin(theta);\n    \n    mat4 iJ = mat4(s_t*c_p, c_t*c_p/r, -s_p/(r*s_t), 0.0,\n                   s_t*s_p, c_t*s_p/r,  c_p/(r*s_t), 0.0,\n                       c_t,    -s_t/r,          0.0, 0.0,\n                       0.0,       0.0,          0.0, 1.0);\n    \n    return iJ;\n}\n\n\nbool hitPlane(vec4 p0, vec4 p1, vec3 normal, float offset, out vec4 hit)\n{\n    float d0 = dot(p0.xyz, normal) - offset;\n    float d1 = dot(p1.xyz, normal) - offset;\n    if(sign(d0) == sign(d1))\n        return false;\n\n    //intermediate value theorem\n    float s = (offset-d0) / (d1-d0);\n    vec4 dp = p1 - p0;\n    hit = dp*s + p0;\n    return true;\n}\n\nbool hitAccrete(vec4 p0, vec4 p1, out vec4 hit, in float rs)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    \n    float theta = -3.141592 / 6.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    \n    vec4 x0 = vec4(0,0,0,0);\n    \n    vec3 normal = normalize(vec3(0,0,1));\n    normal = rotate * normal;\n    vec4 s_hit;\n    if(!hitPlane(p0-x0, p1-x0, normal, 0.0, s_hit))\n        return false;\n    \n    float lh = length(s_hit.xyz) / 0.25;// / rs;\n    if(lh < 3.0 || 6.0 < lh)\n        return false;\n    \n    hit = s_hit;\n    return true;\n}\n\nbool hitFloor(vec4 p0, vec4 p1, out vec4 hit)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    vec4 x0 = vec4(0,0,-1,0);\n    //vec3 x0 = vec3(0,0,-1);\n    //x0.y = sin(iTime * 3.141592 / 5.0);\n    vec3 normal = normalize(vec3(0,0,1));\n    \n    vec4 s_hit;\n    if(!hitPlane(p0, p1, normal, dot(normal, x0.xyz), s_hit))\n        return false;\n    \n    float planesize = 40000.0;\n    \n    if(planesize < length(s_hit.xy))\n        return false;\n     \n    hit = s_hit;\n    return true;\n}\n\nbool hitStar(vec4 coord0, vec4 coord1, out vec4 hitcoord, float rn)\n{\n    // Find if the ray passed through the emissive surface\n    if(rn < coord1.x)\n        return false;\n        \n    //intermediate value theorem\n    float s = (rn-coord0.x) / (coord1.x - coord0.x);\n    vec4 dcoord = coord1 - coord0; // no this is awful dont do this\n    hitcoord = dcoord*s + coord0.x;\n    return true;\n}\n\nvec3 colorAccrete(vec4 hit, vec4 vel, mat4 g, in float rs)\n{\n    float theta = 3.141592 / 6.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    hit.xyz = rotate * hit.xyz;\n    vel.xyz = rotate * vel.xyz;\n\n    float angle = atan(hit.y, hit.x);\n    angle /= 3.141592 * 2.0;\n    angle += 0.5;\n    \n    angle += hit.w / 3.0;\n    /*\n    vec4 localvel = vec4(hit.y, -hit.x, 0.0, 0.0) / 3.0;\n    localvel.w = sqrt(1.0 - dot(localvel, vel));\n    \n    float gamma = 1.0/sqrt(1.0 - (1.0/9.0));\n    \n    \n    float redshift = sqrt((1.0 + beta) / (1.0 - beta));\n    */\n    \n    angle *= 8.0;\n    bool color = 0.5 < angle - floor(angle);\n    float radius = length(hit.xy) / 0.25;// / rs;\n    radius = (radius - 3.0)/(6.0 - 3.0);\n    color = color != (0.5 < radius - floor(radius));\n    \n    if(color)\n        return srgb2lsrgb(vec3(0.75,0.75,0.75));\n    else\n        return srgb2lsrgb(vec3(0.25,0.25,0.25));\n    \n}\n\nvec3 colorPlane(vec4 hit)\n{\n    //vec2 pos = hit.xz / 2.0;\n    //vec2 pos = hit.xz * 4.0;\n\n    //bool color = 0.5 < mod(pos.x, 1.0);\n    //color = color != 0.5 < mod(pos.y, 1.0);\n    \n    //if(color)\n    //    return vec3(0.75,0.25,0.25);\n    //else\n    //    return vec3(0.25,0.0625,0.0625);\n    \n    vec2 pos = hit.xy / 8.0;\n    //pos.x += sin(hit.w) / (1.0 + exp(5.0-hit.w));\n    \n    vec2 t_uv = mod(pos, 1.0);\n    ivec2 xor = ivec2(t_uv * 256.0);\n    float c = float(xor.x ^ xor.y) / 256.0;\n    \n    vec3 highColor = vec3(0.75,0.25,0.25);// * (1.0 + sin(hit.w)*2.0/(1.0 + exp(5.0-hit.w)))/2.0;\n    vec3 lowColor = highColor * 0.25;\n    \n    return srgb2lsrgb(mix(lowColor, highColor, c));\n}\n\n//hehe i'm 12\nvec3 colorHole(vec4 coord)\n{\n    //return texture(iChannel1, toEuclid(coord).xzy).xyz;\n    \n\n    vec2 uv = coord.yz / (3.141592);\n    \n    uv = mod(uv * 4.0, 1.0);\n    \n    bool color = 0.5 < uv.x - floor(uv.x);\n    color = color != 0.5 < uv.y - floor(uv.y);\n    \n    vec3 highColor = vec3(0.75) * 0.25;\n    vec3 lowColor = highColor * 0.0;\n    \n    if(color)\n        return srgb2lsrgb(highColor);\n    else\n        return srgb2lsrgb(lowColor);\n}\n\n// this is an extremely heavy function. Uses the majority of the redshift via sampled spectra code to produce a color.\n// https://www.shadertoy.com/view/NdGGDy\n\nfloat p_gauss(float am, float A, float mu, float sigmaLow, float sigmaHigh)\n{\n    float sigma;\n    if(am < mu)\n        sigma = sigmaLow;\n    else\n        sigma = sigmaHigh;\n    float dx = am - mu;\n    return A*exp(dx*dx / (-2.0*sigma*sigma));\n}\n\n// https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_standard_observer\n// https://www.shadertoy.com/view/NdyGWc\nfloat isample_luma()\n{\n    const float sqpi_2 = sqrt(3.141592 / 2.0);\n    \n    // normalized distribution sample\n    vec4 Lum = vec4(0.0);\n    Lum[0] = 0.821 * 46.9 * sqpi_2;\n    Lum[1] = 0.821 * 40.5 * sqpi_2;\n    Lum[2] = 0.286 * 16.3 * sqpi_2;\n    Lum[3] = 0.286 * 31.1 * sqpi_2;\n    \n    vec4 csum = vec4(0.0);\n    csum[0] = Lum[0];\n    csum[1] = csum[0] + Lum[1];\n    csum[2] = csum[1] + Lum[2];\n    csum[3] = csum[2] + Lum[3];\n    \n    float weight = rnd() * csum[3];\n    int i=0;\n    for(; i<4; ++i)\n    {\n        if(weight <= csum[i])\n            break;\n    }\n    \n    // from the given selection, inverse sample the distribution\n    vec4 mus = vec4(568.8, 568.8, 530.9, 530.9);\n    vec4 sigmas = vec4(-46.9, 40.5, -16.3, 31.1);\n    \n    //float xi = rnd();\n    //float angstrom = -sigmas[i]*erfinv(xi) + mus[i];\n    //return isample_hgauss(mus[i], sigmas[i]); // exact!\n    vec2 xi = vec2(rnd(), rnd());\n    float r = sqrt(-2.0*log(1.0 - xi.x)) * sin(xi.y * 3.141592);\n    return r*sigmas[i] + mus[i];\n}\n\nfloat pdf_luma(float wavelength_nm)\n{\n    // Find the normalized luminance for this frequency\n    //norm = 106.9224850198325\n    const float sqpi_2 = sqrt(3.141592 / 2.0);\n    const float norm = (0.821 * (46.9 + 40.5) + 0.286 * (16.3 + 31.1)) * sqpi_2;\n\n    float Y = p_gauss(wavelength_nm, 0.821, 568.8, 46.9, 40.5);\n    Y += p_gauss(wavelength_nm, 0.286, 530.9, 16.3, 31.1);\n\n    return Y / norm;\n}\n\n\nfloat isample_wien(float temperature, float redshift)\n{\n    // Importance sample the blackbody spectra using Wien's approximation\n    // Approximate the hard integral inverse\n    // B = 2hc^2 / L^5 * 1 / (Exp(hc/LkT) - 1)\n    // u = hc/kT\n    // B = (2hc^2/u^5) * (u/L)^5 / (Exp(u/L) - 1)\n    // L/u = v\n    // B = (2hc^2/u^5) * (1/v)^5 / (Exp(1/v) - 1)\n    //\n    // Wien's approximation\n    // B ~ (2hc^2/u^5) * (1/v)^5 * Exp(-1/v)\n    // \n    // the integral of B has the constant term fall out, resulting in:\n    // I = Exp(-1/v) / v^5\n    // \n    // The integral of I from 0 to infinity is 6, with a normalized integral resulting in:\n    // Ihat = exp(-1/v)*(1 + 1/L + 1/(2L^2) + 1/(6L^3))\n    //\n    // Its derivative is exp(-1/v)/(6*v^5)\n    // It is vaguely approximately v^2 * 0.9 + 0.1\n    // Using this, we can compute the inverse of Ihat, and solve for v given xi\n    \n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n    const float pi = 3.141592;\n    \n    float u = h*c/(k*temperature);\n    \n    float xi = rnd();\n    \n    // Initial approximation via Softplus inverse\n    float v = exp(1.0) - (2.0*log(exp(1.0-xi) - 1.0));\n    \n    // Newton iteration 4 times is pretty close\n    for(int i=0; i<1; ++i)\n    {\n        float wien = exp(-v)*v*v*v/6.0;\n        float iwien = 1.0 - exp(-v)*(1.0 + v + v*v/2.0 + v*v*v/6.0);\n        float v2 = v - (iwien - xi) / wien;\n        if(v2 < 0.0 || v2 != v2)\n            v2 = v - 10.0*(iwien - xi);\n        v = v2;\n    }\n    \n    float nm = (u/v) * 1e9 * redshift; // returns nanometers\n    //if(nm != nm) nm = 0.0;\n    \n    return nm;\n    \n}\n\nfloat pdf_wien(float wavelength_nm, float temperature, float redshift)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n    const float pi = 3.141592;\n    \n    float u = h*c/(k*temperature);\n    float L = wavelength_nm;\n    float v = (u/L) * 1e9 * redshift;\n    \n    return exp(-v) * v*v*v / 6.0;\n}\n\nfloat isample_uniform()\n{\n    return rnd() * (780.0 - 380.0) + 380.0;\n}\n\nfloat pdf_uniform(float nm)\n{\n    if(nm < 380.0 || 780.0 < nm)\n        return 0.0;\n    return 1.0 / (780.0 - 380.0);\n}\n\nfloat plancks_law(float wavelength_nm, float temperature)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n\n    float m = wavelength_nm * 1.0e-9;\n    float m2 = m*m;\n\n    float Rayleigh_Jeans = 2.0*h*c*c/(m2*m2*m);\n    float quantum_temp_ratio = h*c/(k*m*temperature);\n    float Wien = exp(quantum_temp_ratio) - 1.0;\n    \n    return Rayleigh_Jeans / Wien;\n}\n\nfloat stefan_boltzmann(float temperature)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n    const float pi = 3.141592;\n    \n    const float kpi_h = k*pi/h;\n    const float kpi_h3 = kpi_h*kpi_h*kpi_h;\n    \n    const float sigma = 2.0*pi*pi*k*kpi_h3 / (15.0*c*c);\n    \n    return sigma*temperature*temperature*temperature*temperature;\n\n}\n\nvec3 spectra_to_XYZ(float wavelength_nm)\n{\n    float X, Y, Z;\n    X  = p_gauss(wavelength_nm, 1.056, 599.8, 37.9, 31.0);\n    X += p_gauss(wavelength_nm, 0.362, 442.0, 16.0, 26.7);\n    X += p_gauss(wavelength_nm,-0.065, 501.1, 20.4, 26.2);\n\n    Y  = p_gauss(wavelength_nm, 0.821, 568.8, 46.9, 40.5);\n    Y += p_gauss(wavelength_nm, 0.286, 530.9, 16.3, 31.1);\n\n    Z  = p_gauss(wavelength_nm, 1.217, 437.0, 11.8, 36.0);\n    Z += p_gauss(wavelength_nm, 0.681, 459.0, 26.0, 13.8);\n    \n    return vec3(X, Y, Z);\n}\n\n\n\nvec3 colorStar(vec4 x_p, float rs, float localres)\n{\n    // Compute redshift using this formula. In the future, this will be computed generally.\n    // https://en.wikipedia.org/wiki/Gravitational_redshift#Spherically_symmetric_gravitational_field\n    \n    float redshift = 1.0 / sqrt(1.0 - (rs / x_p.x)); // is this gamma?\n    //float redshift = 1.0 / (1.0 - (rs / x_p.x)); // is this gamma?\n    \n    redshift *= localres;\n    \n    const float temp = 9940.0; // sirius\n    //const float temp = 5900.0; // sun\n    \n    vec3 srgb_avg = vec3(0.0);\n    const int spectral_samples = 32;\n    \n    vec3 srgb_samples[spectral_samples]; // RIS\n    float pdf_samples[spectral_samples];\n    float cumsum_samples[spectral_samples+1];\n    \n    for(int i=0; i<spectral_samples; ++i)\n    {\n        //float nm = isample_luma();\n        //float pdf = pdf_luma(nm) * float(spectral_samples);\n        \n        //float nm = isample_wien(temp, redshift);\n        //float pdf = pdf_wien(nm, temp, redshift) * float(spectral_samples);\n\n        //float nm = isample_uniform();\n        //float pdf = pdf_uniform(nm) * float(spectral_samples);\n        \n        // MIS luma uniform, and wien\n        // Randomly select a sampling strategy\n        float nm;\n        const float pct_luma = 1.0 / 2.0;\n        const float pct_uni  = 1.0 / 2.0;\n        const float pct_wien = 0.0;\n        \n        //float dice = rnd();\n        //if(dice < pct_luma) nm = isample_luma();\n        //else if(dice < pct_luma + pct_uni) nm = isample_uni();\n        //else nm = isample_wien(temp, redshift);\n        \n        if(float(i) / float(spectral_samples) < pct_luma) // Sampling without replacement\n            nm = isample_luma();\n        else if(float(i) / float(spectral_samples) < pct_luma + pct_uni)\n            nm = isample_uniform();\n        else \n            nm = isample_wien(temp, redshift);\n        \n        float pdf = (pdf_luma(nm)*pct_luma + pdf_uniform(nm)*pct_uni + pdf_wien(nm, temp, redshift)*pct_wien);\n        //    * float(spectral_samples);\n        \n        \n        float planck = plancks_law(nm / redshift, temp);\n        \n        vec3 srgb = XYZ_to_lsrgb(spectra_to_XYZ(nm)) * planck;\n        srgb_avg += srgb / (pdf * float(spectral_samples));\n        srgb_samples[i] = srgb;\n        pdf_samples[i] = pdf;\n        //cumsum_samples[i+1] = cumsum_samples[i] + pdf_samples[i];\n    }\n    /*\n    cumsum_samples[0] = 0.0;\n    for(int i=0; i<spectral_samples; ++i) // RIS loops, this loop significantly reduces the speed\n        cumsum_samples[i+1] = cumsum_samples[i] + pdf_samples[i];\n        \n    for(int i=0; i<spectral_samples; ++i)\n    {\n        cumsum_samples[i] /= cumsum_samples[spectral_samples];\n        //pdf_samples[i] /= cumsum_samples[spectral_samples];\n    }\n        \n    const int RIS_samples = 32;\n    srgb_avg = vec3(0);\n    \n    // RIS Resamples the given sample set as if they're a finite dataset, with replacement\n    for(int i=0; i<RIS_samples; ++i)\n    {\n        float xi = rnd();\n        int select = 0;\n        for(;select < spectral_samples; select++)\n            if(cumsum_samples[select] < xi)\n                break;\n        srgb_avg += srgb_samples[select];// / float(RIS_samples);\n    }\n    */\n    \n    float dim = 1e-16; // otherwise it looks weird\n    //dim = 5e-17;\n    //dim = 1.0;\n    //dim = 1e-15;\n    \n    //dim = 1.0;\n    //if(1.0 < XYZ_avg.y)\n    // Dim via stefan boltzmann brightness\n    dim = 5e-8 / stefan_boltzmann(temp);\n    //dim = 1.0;\n    \n    //dim *= 5e2;\n    \n    //dim = 1e30; \n    \n    return srgb_avg * dim / redshift;\n}\n\n\n// This version of ColorAccrete uses an emissive disc of a constant temperature, to emphesize redshifting.\nvec3 colorAccrete_rs(vec4 hit, vec4 vel, vec4 x_p, vec4 v_p, mat4 g, in float rs, float c)\n{\n    float theta = 3.141592 / 6.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    hit.xyz = rotate * hit.xyz;\n    vel.xyz = rotate * vel.xyz;\n\n    float angle = atan(hit.y, hit.x);\n    angle /= 3.141592 * 2.0;\n    angle += 0.5;\n    \n    float speed = 1.0 / 3.0; // 1.95 is very close to the speed of light at the edge\n    angle += hit.w * speed;\n    \n    //speed = c*rs/sqrt(2.0 * x_p.x*x_p.x*x_p.x); // proper orbital speed\n    \n    speed = 0.5;\n    \n    vec3 localvel = vec3(hit.y, -hit.x, 0.0) * speed / x_p.x;\n    localvel *= x_p.x; // rigid body rotation\n    \n    \n    vec3 beta3 = localvel / c;\n    float gamma = 1.0/sqrt(1.0 - dot(beta3, beta3));\n    \n    // use the generalized boost matrix!!!\n    // only the energy component is needed for light, no fun boost matrix :(\n    // Locally, the basis vectors are orthonormal. Their lengths aren't orthogonal, which may produce a quirk of this renderer.\n    // 1 - the dot product of the incoming velocity vector's normal and the local beta finds the redshift.\n    \n    float redshift = gamma * (1.0 - dot(beta3, -normalize(vel.xyz)));\n    //float redshift = gamma * dot(vec4(-1, beta3), g * (-vel));\n    \n    \n    \n    //float redshift = sqrt((1.0 + beta) / (1.0 - beta));\n    \n    \n    angle *= 8.0;\n    bool color = 0.5 < angle - floor(angle);\n    float radius = length(hit.xy) / 0.25;// / rs;\n    radius = (radius - 3.0)/(6.0 - 3.0);\n    color = color != (0.5 < radius - floor(radius));\n    \n    vec3 lc = vec3(1);\n    \n    if(color)\n        lc = vec3(0.75);\n    else\n        lc = vec3(0.25);\n    lc = srgb2lsrgb(lc);\n    \n    \n    //lc = lc * 1e-17; // this term was moved into colorStar\n    //lc = lc * 1e-16;// this one looks sick\n        \n    return lc * colorStar(x_p, rs, redshift);\n    \n}\n\nvoid traverse_2nd(inout vec4 x_p, inout vec4 v_p, float rs, float rn, float c)\n{\n\n    vec4 x1 = toEuclid(x_p);\n    vec4 vel = vec4(normalize((e_p_jacobian(x_p) * v_p).xyz), 0.0);\n    for(int i=0; i<1024; ++i)\n    {\n        float dT = 0.05 * sin(x_p.y) * x_p.x;\n        \n        vec4 a_p = p_sc_4_accel(x_p, v_p, rs, c);\n        \n        // Update via finite difference\n        //v_p += a_p * dT;\n        //x_p += v_p * dT;\n        \n        // RK4\n        // https://www.ctcms.nist.gov/~langer/oof2man/RegisteredClass-RK4.html\n        vec4 k1v = dT * p_sc_4_accel(x_p, v_p, rs, c);\n        vec4 k1x = dT * v_p;\n        \n        vec4 k2v = dT * p_sc_4_accel(x_p + k1x/2.0, v_p + k1v/2.0, rs, c);\n        vec4 k2x = dT * (v_p + k1v/2.0);\n        \n        vec4 k3v = dT * p_sc_4_accel(x_p + k2x/2.0, v_p + k2v/2.0, rs, c);\n        vec4 k3x = dT * (v_p + k2v/2.0);\n        \n        vec4 k4v = dT * p_sc_4_accel(x_p + k3x, v_p + k3v, rs, c);\n        vec4 k4x = dT * (v_p + k3v);\n        \n        vec4 p_x_p = x_p;\n        \n        v_p += (k1v + 2.0*k2v + 2.0*k3v + k4v) / 6.0;\n        x_p += (k1x + 2.0*k2x + 2.0*k3x + k4x) / 6.0;\n        \n        // RK4 doesn't like dropping below the event horizon, simulate a finite difference step\n        if((x_p + k1x + k1v*dT).x < rs)\n        //if(x_p.x < rs)\n            //return colorHole(x_p);\n            return;// vec3(0);\n        \n        /*\n        g = p_schwarzschildMetric(x_p, rs);\n        halfmag = g * v_p;\n        spacemag = dot(v_p.xyz, halfmag.xyz);\n        v_p.w = -sqrt((c*c - spacemag)/g[3][3]);\n        \n        \n        //if(x_p.x < rs)\n        //if((x_p + k1x + k1v*dT).x < 0.0*rs)\n        //    return colorHole(x_p);\n        if(x_p.x < 0.0)\n        {\n            v_p *= sign(v_p.x);\n            x_p *= -1.0;\n        }*/\n        \n        vec4 x2 = toEuclid(x_p);\n        \n        if(hitFloor(x2, x1, x2))\n            return;// colorPlane(x2);\n        \n        if(hitStar(x_p, p_x_p, x_p, rn))\n            return;// colorStar(x_p, rs, 1.0);\n        \n        \n        if(hitAccrete(x2, x1, x2, rs))\n        {\n            vel = v_p;\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);\n            mat4x4 g = p_schwarzschildMetric(x_p, rs);\n            //return colorAccrete(x2, vel, g, rs);\n            return;// colorAccrete_rs(x2, vel, x_p, v_p, g, rs, c);\n        }\n        \n        if(x_p.x > 10000.0)\n        {\n            // Solve for the outgoing cartesian velocity\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);    \n            return;// srgb2lsrgb(texture(iChannel0, vel.xzy).xyz);\n        }\n        \n        x1 = x2;\n    }\n\n    return;// vec3(0);\n\n}\n\n//random point in sphere\nvec3 randSphere()\n{\n    float xi1 = rnd() * 2.0 - 1.0;\n    float xi2 = rnd();\n\n    float theta = xi2 * 2.0 * 3.141592;\n    float sinp = sqrt(1.0 - xi1*xi1);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = xi1;\n\n    return vec3(x, y, z);\n}\nvec3 sampleSphere(vec3 normal, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randSphere();\n    \n    if(dot(rOut, normal) < 0.0)\n        rOut = reflect(rOut, normal);\n    \n    //should these be packed into the sampler?\n    //float pdf = 1.0; // no numerator pdf\n    pdf /= 2.0 * 3.141592; // 4pi r^2 / 2, half a sphere's area (clamped)\n    \n    return rOut;\n}\nfloat pdfSphere()\n{\n    return 1.0 / (2.0 * 3.141592);\n}\n\nvec3 traverse(vec4 x_p, vec4 v_p, float rs, float rn, float c)\n{\n    vec4 x1 = toEuclid(x_p);\n    vec4 vel = vec4(normalize((e_p_jacobian(x_p) * v_p).xyz), 0.0);\n    for(int i=0; i<1024; ++i)\n    {\n        float dT = 0.05 * sin(x_p.y) * x_p.x;\n        \n        vec4 a_p = p_sc_4_accel(x_p, v_p, rs, c);\n        \n        // Update via finite difference\n        //v_p += a_p * dT;\n        //x_p += v_p * dT;\n        \n        // RK4\n        // https://www.ctcms.nist.gov/~langer/oof2man/RegisteredClass-RK4.html\n        vec4 k1v = dT * p_sc_4_accel(x_p, v_p, rs, c);\n        vec4 k1x = dT * v_p;\n        \n        vec4 k2v = dT * p_sc_4_accel(x_p + k1x/2.0, v_p + k1v/2.0, rs, c);\n        vec4 k2x = dT * (v_p + k1v/2.0);\n        \n        vec4 k3v = dT * p_sc_4_accel(x_p + k2x/2.0, v_p + k2v/2.0, rs, c);\n        vec4 k3x = dT * (v_p + k2v/2.0);\n        \n        vec4 k4v = dT * p_sc_4_accel(x_p + k3x, v_p + k3v, rs, c);\n        vec4 k4x = dT * (v_p + k3v);\n        \n        vec4 p_x_p = x_p;\n        \n        v_p += (k1v + 2.0*k2v + 2.0*k3v + k4v) / 6.0;\n        x_p += (k1x + 2.0*k2x + 2.0*k3x + k4x) / 6.0;\n        \n        // RK4 doesn't like dropping below the event horizon, simulate a finite difference step\n        if((x_p + k1x + k1v*dT).x < rs)\n        //if(x_p.x < rs)\n            //return colorHole(x_p);\n            return vec3(0);\n        \n        /*\n        g = p_schwarzschildMetric(x_p, rs);\n        halfmag = g * v_p;\n        spacemag = dot(v_p.xyz, halfmag.xyz);\n        v_p.w = -sqrt((c*c - spacemag)/g[3][3]);\n        \n        \n        //if(x_p.x < rs)\n        //if((x_p + k1x + k1v*dT).x < 0.0*rs)\n        //    return colorHole(x_p);\n        if(x_p.x < 0.0)\n        {\n            v_p *= sign(v_p.x);\n            x_p *= -1.0;\n        }*/\n        \n        vec4 x2 = toEuclid(x_p);\n        \n        if(hitFloor(x2, x1, x2))\n            return colorPlane(x2);\n        \n        if(hitStar(x_p, p_x_p, x_p, rn))\n            return colorStar(x_p, rs, 1.0);\n        \n        \n        if(hitAccrete(x2, x1, x2, rs))\n        {\n            vel = v_p;\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);\n            mat4x4 g = p_schwarzschildMetric(x_p, rs);\n            //return colorAccrete(x2, vel, g, rs);\n            return colorAccrete_rs(x2, vel, x_p, v_p, g, rs, c);\n        }\n        \n        if(x_p.x > 10000.0)\n        {\n            // Solve for the outgoing cartesian velocity\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);    \n            return srgb2lsrgb(texture(iChannel0, vel.xzy).xyz);\n        }\n        \n        x1 = x2;\n    }\n}\n\n\n\nvec3 render( in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    //uv /= 5.0;\n    \n    //view rotation matrix\n    //yaw\n    float th_yaw = 3.141592 * iTime / (2.0 * 5.0);\n    float th_pitch = 3.141592 * (0.25 / 2.0);\n    //th_yaw = 1.25;\n    //th_yaw = 0.0;\n    \n    //th_pitch = 0.0;\n    //th_pitch = 0.5;\n    \n    if(0.5 < iMouse.z)\n    {\n        th_yaw = 3.141592 * (iMouse.x / iResolution.x);\n        th_pitch = 3.141592 * (0.5 - iMouse.y / iResolution.y);\n    }\n    mat3 yaw = mat3(vec3(cos(th_yaw), -sin(th_yaw), 0.0),\n                    vec3(sin(th_yaw),  cos(th_yaw), 0.0),\n                    vec3(        0.0,          0.0, 1.0));\n    \n    mat3 pitch = mat3(vec3(1.0,           0.0,           0.0),\n                      vec3(0.0, cos(th_pitch), -sin(th_pitch)),\n                      vec3(0.0, sin(th_pitch), cos(th_pitch)));\n    \n    mat3 view = yaw * pitch;\n    \n    vec3 dir = normalize(vec3(uv.x, 1.0, uv.y));\n    vec3 src = vec3(0.0, -4.0, 0.0);\n    \n    src.xyz += texture(iChannel2, vec2(0)).xyz;\n    \n    dir = view * dir;\n    src = view * src;\n    \n    // Find initial point in polar coords\n    vec4 src_t = vec4(src, iTime);\n    vec4 x_p = toPolar(src_t);\n    // [r, theta, psi, t]\n    \n    // Find initial velocity in polar coords at x_p\n    mat4 iJ = e_p_i_jacobian(x_p);\n    vec4 v_p = iJ * vec4(dir, 1.0);\n    \n    // Correct the time component\n    float c = 1.0;\n    float rs = 0.25;\n    rs *= 1.0/(1.0+exp(10.0*(1.0-iTime/3.0)));\n    //float rn = 0.28;//0.25 + exp(-iTime);\n    float rn = 0.2499;\n    \n    mat4 g = p_schwarzschildMetric(x_p, rs);\n    vec4 halfmag = g * v_p;\n    float spacemag = dot(v_p.xyz, halfmag.xyz); // treat this as beta, not v.\n    v_p.w = -sqrt((1.0 - spacemag)/g[3][3]);\n    \n    // Iterate to find the coordinates over time\n    //traverse(x_p, v_p, rs, c, rn, g);\n    vec4 x1 = toEuclid(x_p);\n    vec4 vel = vec4(normalize((e_p_jacobian(x_p) * v_p).xyz), 0.0);\n    for(int i=0; i<1024; ++i)\n    {\n        float dT = 0.05 * sin(x_p.y) * x_p.x;\n        \n        vec4 a_p = p_sc_4_accel(x_p, v_p, rs, c);\n        \n        // Update via finite difference\n        //v_p += a_p * dT;\n        //x_p += v_p * dT;\n        \n        // RK4\n        // https://www.ctcms.nist.gov/~langer/oof2man/RegisteredClass-RK4.html\n        vec4 k1v = dT * p_sc_4_accel(x_p, v_p, rs, c);\n        vec4 k1x = dT * v_p;\n        \n        vec4 k2v = dT * p_sc_4_accel(x_p + k1x/2.0, v_p + k1v/2.0, rs, c);\n        vec4 k2x = dT * (v_p + k1v/2.0);\n        \n        vec4 k3v = dT * p_sc_4_accel(x_p + k2x/2.0, v_p + k2v/2.0, rs, c);\n        vec4 k3x = dT * (v_p + k2v/2.0);\n        \n        vec4 k4v = dT * p_sc_4_accel(x_p + k3x, v_p + k3v, rs, c);\n        vec4 k4x = dT * (v_p + k3v);\n        \n        vec4 p_x_p = x_p;\n        \n        v_p += (k1v + 2.0*k2v + 2.0*k3v + k4v) / 6.0;\n        x_p += (k1x + 2.0*k2x + 2.0*k3x + k4x) / 6.0;\n        \n        // RK4 doesn't like dropping below the event horizon, simulate a finite difference step\n        if((x_p + k1x + k1v*dT).x < rs)\n        //if(x_p.x < rs)\n            //return colorHole(x_p);\n            return vec3(0);\n        \n        /*\n        g = p_schwarzschildMetric(x_p, rs);\n        halfmag = g * v_p;\n        spacemag = dot(v_p.xyz, halfmag.xyz);\n        v_p.w = -sqrt((c*c - spacemag)/g[3][3]);\n        \n        \n        //if(x_p.x < rs)\n        //if((x_p + k1x + k1v*dT).x < 0.0*rs)\n        //    return colorHole(x_p);\n        if(x_p.x < 0.0)\n        {\n            v_p *= sign(v_p.x);\n            x_p *= -1.0;\n        }*/\n        \n        vec4 x2 = toEuclid(x_p);\n        \n        if(hitFloor(x2, x1, x2))\n        {\n            return colorPlane(x2);\n            /*\n            vec3 albedo = colorPlane(x2);\n            vec3 wsum = vec3(0.0);\n            float pdf = 0.0;\n            const int lsamples = 10;\n            for(int j=0; j<lsamples; ++j)\n            {\n                // Randomly choose a point on a sphere\n                float spdf = 0.0;\n                dir = sampleSphere(vec3(0,0,1), spdf);\n                v_p = e_p_i_jacobian(x_p) * vec4(dir, 1.0);\n                vec3 lit = traverse(x_p, v_p, rs, rn, c);\n                wsum += lit;///spdf;\n                //pdf += 1.0/spdf;\n            }\n            return albedo*wsum/float(lsamples);\n            */\n        }\n        \n        if(hitStar(x_p, p_x_p, x_p, rn))\n            return colorStar(x_p, rs, 1.0);\n        \n        \n        if(hitAccrete(x2, x1, x2, rs))\n        {\n            vel = v_p;\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);\n            g = p_schwarzschildMetric(x_p, rs);\n            //return colorAccrete(x2, vel, g, rs);\n            return colorAccrete_rs(x2, vel, x_p, v_p, g, rs, c);\n        }\n        \n        if(x_p.x > 10000.0)\n        {\n            // Solve for the outgoing cartesian velocity\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);    \n            return srgb2lsrgb(texture(iChannel0, vel.xzy).xyz);\n        }\n        \n        x1 = x2;\n    }\n\n    return vec3(0);\n\n    // Solve for the outgoing cartesian velocity\n    vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);    \n    return texture(iChannel0, vel.xzy).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    seed = hashrandom(iTime + iResolution.y * uv.x + uv.y);\n\n    //vec3 col = render(fragCoord);\n    vec3 col = vec3(0.0);\n    \n    const bool AntiAlias = false;\n    if(AntiAlias)\n    {\n        const int samples = 4;\n        //vec3 sample_arr[samples];\n        for(int i=0; i<samples; ++i)\n        {\n            //sample_arr[i] = render(fragCoord + ((vec2(rnd(), rnd())-0.5)));\n            //col += sample_arr[i];\n            col += render(fragCoord + ((vec2(rnd(), rnd())-0.5)));\n        }\n        /*\n        for(int i=0; i<samples; ++i) // ris?\n            col += sample_arr[int(float(samples)*rnd())];\n        */\n        \n        col /= float(samples);\n    }else{\n        col = render(fragCoord);\n    }\n    \n    col = saturationClip(col);\n    // Luminance clip\n    /*\n    vec3 XYZ = lsrgb_to_XYZ(col);\n    float control = lsrgb_to_XYZ(vec3(1)).y;\n    if(control < XYZ.y)\n        XYZ.y = control;\n    col = XYZ_to_lsrgb(XYZ);\n    */\n    \n    col = clamp(col, vec3(0), vec3(1));\n    fragColor = vec4(lsrgb2srgb(col),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// stores user interaction states\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // https://www.shadertoy.com/view/4dGyDm\n    const int kc_le = 37; \n    const int kc_up = 38; \n    const int kc_ri = 39; \n    const int kc_do = 40; \n    const int kc_sp = 32; \n    bool k_le = texelFetch(iChannel0, ivec2(kc_le, 0), 0).x > 0.;\n    bool k_up = texelFetch(iChannel0, ivec2(kc_up, 0), 0).x > 0.;\n    bool k_ri = texelFetch(iChannel0, ivec2(kc_ri, 0), 0).x > 0.;\n    bool k_do = texelFetch(iChannel0, ivec2(kc_do, 0), 0).x > 0.;\n    bool k_sp = texelFetch(iChannel0, ivec2(kc_sp, 0), 0).x > 0.;\n    \n    if(iFrame == 0 || k_sp)\n    {\n        fragColor = vec4(0);\n    }\n    else\n    {\n        vec4 dx = vec4(0);\n        if(k_le) dx += vec4(-1, 0,0,0);\n        if(k_ri) dx += vec4( 1, 0,0,0);\n        if(k_up) dx += vec4( 0, 1,0,0);\n        if(k_do) dx += vec4( 0,-1,0,0);\n\n        fragColor = texture(iChannel1, fragCoord) + dx * iTimeDelta;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}