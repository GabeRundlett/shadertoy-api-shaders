{
    "Shader": {
        "info": {
            "date": "1656929772",
            "description": "I originally created this shader on my android phone using a free and amazing shader editor app.\nDecided to port it to shadertoy to share the code.\nIt is still quite messy, but hopefully one day I'll go back and clean it up.",
            "flags": 32,
            "hasliked": 0,
            "id": "NdcBzf",
            "likes": 46,
            "name": "Dungeon Generator",
            "published": 3,
            "tags": [
                "procedural",
                "map",
                "generator",
                "dungeon",
                "dnd"
            ],
            "usePreview": 0,
            "username": "detectiveLosos",
            "viewed": 730
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define M_PI 3.14159265359\n\nconst float eps = 0.01;\nbool approx(float a, float b){return abs(a-b)<eps;}\nbool approx(vec2 a, vec2 b){ return approx(a.x, b.x) && approx(a.y, b.y); }\n\n#define btof(b) ((b)?1.0:0.0)\n\n#define pack(x) (x*0.5+0.5)\n#define unpack(x) (x*2.0 - 1.0)\n\n#define saturate(x) (clamp(x, 0.0, 1.0))\n\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n//==== Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8 ====//\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\nvec4 glslmod(vec4 x, vec4 y) { return x - y * floor(x / y); }\nvec3 glslmod(vec3 x, vec3 y) { return x - y * floor(x / y); }\nvec2 glslmod(vec2 x, vec2 y) { return x - y * floor(x / y); }\nvec3 permute_optimizedSnoise2D(in vec3 x) { return glslmod(x*x*34.0 + x, vec3(289.0)); }\nfloat optimizedSnoise(in vec2 v) {\n\tvec2 i = floor((v.x + v.y)*.36602540378443 + v);\n\tvec2 x0 = (i.x + i.y)*.211324865405187 + v - i;\n\tfloat s = step(x0.x, x0.y);\n\tvec2 j = vec2(1.0 - s, s);\n\tvec2 x1 = x0 - j + .211324865405187;\n\tvec2 x3 = x0 - .577350269189626;\n\ti = glslmod(i, vec2(289.));\n\tvec3 p = permute_optimizedSnoise2D(permute_optimizedSnoise2D(i.y + vec3(0, j.y, 1)) + i.x + vec3(0, j.x, 1));\n\tvec3 m = max(.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x3, x3)), 0.);\n\tvec3 x = fract(p * .024390243902439) * 2. - 1.;\n\tvec3 h = abs(x) - .5;\n\tvec3 a0 = x - floor(x + .5);\n\treturn .5 + 65. * dot(pow(m, vec3(4.0))*(-0.85373472095314*(a0*a0 + h * h) + 1.79284291400159), a0 * vec3(x0.x, x1.x, x3.x) + h * vec3(x0.y, x1.y, x3.y));\n}\n\n//==== Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf ====//\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec4 permute_optimizedSnoise3D(in vec4 x) { return glslmod(x*x*34. + x, vec4(289.)); }\nfloat optimizedSnoise(in vec3 v) {\n\tconst vec2 C = vec2(0.16666666666, 0.33333333333);\n\tconst vec4 D = vec4(0, .5, 1, 2);\n\tvec3 i = floor(C.y*(v.x + v.y + v.z) + v);\n\tvec3 x0 = C.x*(i.x + i.y + i.z) + (v - i);\n\tvec3 g = step(x0.yzx, x0);\n\tvec3 l = (1. - g).zxy;\n\tvec3 i1 = min(g, l);\n\tvec3 i2 = max(g, l);\n\tvec3 x1 = x0 - i1 + C.x;\n\tvec3 x2 = x0 - i2 + C.y;\n\tvec3 x3 = x0 - D.yyy;\n\ti = glslmod(i, vec3(289.));\n\tvec4 p = permute_optimizedSnoise3D(permute_optimizedSnoise3D(permute_optimizedSnoise3D(\n\t\ti.z + vec4(0., i1.z, i2.z, 1.))\n\t\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n\tvec3 ns = .142857142857 * D.wyz - D.xzx;\n\tvec4 j = -49. * floor(p * ns.z * ns.z) + p;\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = floor(j - 7. * x_) * ns.x + ns.yyyy;\n\tvec4 h = 1. - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 sh = -step(h, vec4(0));\n\tvec4 a0 = b0.xzyw + (floor(b0)*2. + 1.).xzyw*sh.xxyy;\n\tvec4 a1 = b1.xzyw + (floor(b1)*2. + 1.).xzyw*sh.zzww;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\tvec4 norm = 1.0/sqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tvec4 m = max(.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.);\n\treturn .5 + 12. * dot(m * m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n//",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Directions.\nconst ivec2 center = ivec2(0, 0);\nconst ivec2 up = ivec2(0, 1);\nconst ivec2 down = ivec2(0, -1);\nconst ivec2 right = ivec2(1, 0);\nconst ivec2 left = ivec2(-1, 0);\nconst ivec2 upRight = up + right;\nconst ivec2 upLeft = up + left;\nconst ivec2 downRight = down + right;\nconst ivec2 downLeft = down + left;\n\n// Packed versions of directions.\nconst vec2 pCenter = vec2(0.5, 0.5);\nconst vec2 pUp = vec2(0.5, 1.0);\nconst vec2 pDown = vec2(0.5, 0.0);\nconst vec2 pRight = vec2(1.0, 0.5);\nconst vec2 pLeft = vec2(0.0, 0.5);\nconst vec2 pUpRight = vec2(1.0, 1.0);\nconst vec2 pUpLeft = vec2(0.0, 1.0);\nconst vec2 pDownRight = vec2(1.0, 0.0);\nconst vec2 pDownLeft = vec2(0.0, 0.0);\n\n\n// How much the actual pixeled version of the dungeon is scaled from the base image size.\nconst float scaleDown = 12.0;\nbool isScaledDown(vec2 pos)\n{\n\treturn\n\t\t(pos.x < iResolution.x / scaleDown) &&\n\t\t(pos.y < iResolution.y / scaleDown);\n}\n\n\nbool isOnBorder(vec2 pos)\n{\n\treturn\n\t\t(pos.x < 1.0) ||\n\t\t(pos.x > iResolution.x / scaleDown - 1.5) ||\n\t\t(pos.y < 1.0) ||\n\t\t(pos.y > iResolution.y / scaleDown - 1.5);\n}\n\nbool is(vec4 cell)\n{\n\treturn cell.z > 0.1;\n}\n\n\n\nvec4 get(vec2 offset) { return texture(iChannel0, (gl_FragCoord.xy + offset) / iResolution.xy); }\nvec4 get(float x, float y){return get(vec2(x, y));}\nvec4 get(int x, int y){return get(vec2(x, y));}\nvec4 get(ivec2 offset){return get(vec2(offset));}\n\nvec4 getScaledDown(vec2 scaledDownPos)\n{\n\treturn texture(iChannel0, scaledDownPos / iResolution.xy);\n}\n\n\n\n//=================================================\n// Various initialization functions (only one is used).\nvec4 initialize(vec2 fragCoord, int seed)\n{\n\tif(hash1(fragCoord) > 0.99)\n\t{\n\t\tfloat random = hash1((fragCoord + vec2(seed)) * 3.14);\n\t\tvec2 lookupDir;\n\t\tif(random < 0.25) lookupDir = vec2(1., 0.);\n\t\telse if(random < 0.5) lookupDir = vec2(-1., 0.);\n\t\telse if(random < 0.75) lookupDir = vec2(0., 1.);\n\t\telse lookupDir = vec2(0., -1.);\n\n\t\tlookupDir = lookupDir * 0.5 + 0.5;\n\n\t\treturn vec4(lookupDir, 1., 0.);\n\t}\n\treturn get(0, 0);\n}\n\nvec4 initializeSingle(vec2 pos, int seed)\n{\n\tvec2 centerPos = iResolution.xy * 0.5;\n\tvec2 diff = pos.xy - centerPos;\n\tif(\n\t\t(-.5 < diff.x) && (diff.x < 1.) &&\n\t  (-.5 < diff.y) && (diff.y < 1.)\n\t)\n\t{\n\t\tfloat random = hash1((pos + vec2(seed)) * 3.14);\n\t\tvec2 lookupDir;\n\t\tif(random < 0.25) lookupDir = vec2(1., 0.);\n\t\telse if(random < 0.5) lookupDir = vec2(-1., 0.);\n\t\telse if(random < 0.75) lookupDir = vec2(0., 1.);\n\t\telse lookupDir = vec2(0., -1.);\n\n\t\tlookupDir = lookupDir * 0.5 + 0.5;\n\n\t\treturn vec4(lookupDir, 1., 0.);\n\t}\n\treturn get(0, 0);\n}\n\nvec4 initializeRooms(vec2 pos, float roomAmount, int seed)\n{\n\tif(hash1(pos + vec2(seed) * 139.679) > roomAmount)\n\t{\n\t\tvec2 roomDir = pCenter;\n\t\tfloat random =\n\t\t\thash1((pos + vec2(seed)) * 43.87);\n\t\tif(random < 0.2) roomDir = pUp;\n\t\telse if(random < 0.4) roomDir = pDown;\n\t\telse if(random < 0.6) roomDir = pRight;\n\t\telse if(random < 0.8) roomDir = pLeft;\n\n\t\treturn vec4(roomDir, 1.0, 0.0);\n\t}\n\treturn vec4(0.0);\n}\n\n//=================================================\nvec4 postInitialize(vec2 fragCoord)\n{\n\tvec4 prev = get(0, 0);\n\tfloat neighbourZ = max(\n\t\tmax(\n\t\t\tmax(get(-1, 0).z, get(1, 0).z),\n\t\t\tmax(get(0, -1).z, get(0, 1).z)\n\t\t),\n\t\tmax(\n\t\t\tmax(get(-1, -1).z, get(-1, 1).z),\n\t\t\tmax(get(1, -1).z, get(1, 1).z)\n\t\t)\n\t);\n\n\tif(approx(prev.z, neighbourZ)) return vec4(.0);\n\treturn prev;\n}\n\n//=================================================\n// Expands the existing empty pixels horizontally and vertically depending on the current frame.\nvec4 expand(vec2 fragCoord)\n{\n\t/*\n\tvec4 prev = get(center);\n\tif(prev.z > 0.1) return prev;\n\n\tfloat neighboursZ = max(\n\t\tmax(\n\t\t\tmax(get(up).z, get(down).z),\n\t\t\tmax(get(right).z, get(left).z)\n\t\t),\n\t\tmax(\n\t\t\tmax(get(upRight).z, get(upLeft).z),\n\t\t\tmax(get(downRight).z, get(downLeft).z)\n\t\t)\n\t);\n\n\tif(neighboursZ > 0.1)\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\treturn prev;\n\t*/\n\n\tvec4 c = get(center);\n\tif(is(c)) return c;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\tvec4 ur = get(upRight);\n\tvec4 ul = get(upLeft);\n\tvec4 dr = get(downRight);\n\tvec4 dl = get(downLeft);\n\n\tif(is(u) && (iFrame % 2 == 0))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(is(d) && (iFrame % 2 == 0))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(is(r) && (iFrame % 2 == 1))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(is(l) && (iFrame % 2 == 1))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\n\treturn c;\n}\n// Expands the existing empty pixels horizontally and vertically depending on the current frame.\n// This version tries to keep the border between rooms.\nvec4 expandBorders(vec2 pos)\n{\n\tvec4 c = get(center);\n\tif(is(c)) return c;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\tvec4 ur = get(upRight);\n\tvec4 ul = get(upLeft);\n\tvec4 dr = get(downRight);\n\tvec4 dl = get(downLeft);\n\tvec4 uu = get(up*2);\n\tvec4 dd = get(down*2);\n\tvec4 rr = get(right*2);\n\tvec4 ll = get(left*2);\n\n\tif(\n\t\t(is(u) && (iFrame % 2 == 0)) && // || is(ur) || is(ul)) &&\n\t\t!(is(d) || is(dd) || is(dr) || is(dl))\n\t)\n\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(\n\t\t(is(d) && (iFrame % 2 == 0)) && // || is(dr) || is(dl)) &&\n\t\t!(is(u) || is(uu) || is(ur) || is(ul))\n\t)\n\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(\n\t\t(is(r) && (iFrame % 2 == 1)) && // || is(ur) || is(dr)) &&\n\t\t!(is(l) || is(ll) || is(ul) || is(dl))\n\t)\n\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(\n\t\t(is(l) && (iFrame % 2 == 1)) && // || is(ul) || is(dl)) &&\n\t\t!(is(r) || is(rr) || is(ur) || is(dr))\n\t)\n\treturn vec4(pCenter, 0.5, 0.0);\n\n\t/*\n\tif((is(u) || is(uu)) && (is(d) || is(dd)))\n\t\treturn c;\n\tif((is(r) || is(rr)) && (is(l) || is(ll)))\n\t\treturn c;\n\tif(is(ur) && is(dl))\n\t\treturn c;\n\tif(is(ul) && is(dr))\n\t\treturn c;\n\tif(is(ur) && is(dr) && !is(r))\n\t\treturn c;\n\tif(is(ul) && is(dl) && !is(l))\n\t\treturn c;\n\tif(is(ur) && is(ul) && !is(u))\n\t\treturn c;\n\tif(is(dr) && is(dl) && !is(d))\n\t\treturn c;\n\n\tif(\n\t\t(is(u) || is(d) || is(l) || is(r)) ||\n\t\t(is(ur) || is(ul) || is(dr) || is(dl))\n\t)\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\t//*/\n\treturn c;\n}\n\n//=================================================\n// Make everything that is active - neutral (0.5).\nvec4 neutralize(vec2 pos)\n{\n\tvec4 prev = get(center);\n\tif(prev.z > 0.1)\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\treturn prev;\n}\n\n//=================================================\n// Clear all of the pixels on the borders of the frame.\nvec4 clearBorders(vec2 pos)\n{\n\tvec4 prev = get(center);\n\tif(isOnBorder(pos)) return vec4(0.0);\n\treturn prev;\n}\n\n//=================================================\n// Mark random pixels on the edges of the rooms to become room exits on the next generation step.\nvec4 markRoomExits(vec2 pos, float amount, int seed)\n{\n\tvec4 prev = get(center);\n\tif(prev.z < 0.1) return prev;\n\n\tif(hash1((pos + vec2(seed)) * 48.31) > amount)\n\t\treturn prev;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\n\tif(u.z < 0.1) return vec4(pDown, 1.0, 0.0);\n\tif(d.z < 0.1) return vec4(pUp, 1.0, 0.0);\n\tif(r.z < 0.1) return vec4(pLeft, 1.0, 0.0);\n\tif(l.z < 0.1) return vec4(pRight, 1.0, 0.0);\n\n\treturn prev;\n}\n\n//=================================================\n// Bores a tunnel from the active pixels in the direction specified by a pixel, turns randomly.\nvec4 tunnel(vec2 pos, float meandering)\n{\n\tif(isOnBorder(pos)) return vec4(0.0);\n\n\tvec4 prev = get(0, 0);\n\t// Make the current cell inactive\n\t// if it was active.\n\tif(prev.z > 0.9)\n\t\treturn vec4(0.5, 0.5, 0.5, 0.0);\n\t\t//return vec4(prev.xy, 0.85, 0.0);\n\n\tvec4 result = prev;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\tvec4 ur = get(upRight);\n\tvec4 ul = get(upLeft);\n\tvec4 dr = get(downRight);\n\tvec4 dl = get(downLeft);\n\n\t// Tunnel.\n\t{\n\t\tif(\n\t\t\t(u.z > 0.9) &&\n\t\t\t(dl.z + dr.z < 0.1) &&\n\t\t\tapprox(u.xy, pUp)\n\t\t)\n\t\t{\n\t\t\tresult = vec4(pUp, 1.0, 0.0);\n\t\t}\n\n\t\telse if(\n\t\t\t(d.z > 0.9) &&\n\t\t\t(ul.z + ur.z < 0.1) &&\n\t\t\tapprox(d.xy, pDown)\n\t\t)\n\t\t{\n\t\t\tresult = vec4(pDown, 1.0, 0.0);\n\t\t}\n\n\t\telse if(\n\t\t\t(r.z > 0.9) &&\n\t\t\t(ul.z + dl.z < 0.1) &&\n\t\t\tapprox(r.xy, pRight)\n\t\t)\n\t\t{\n\t\t\tresult = vec4(pRight, 1.0, 0.0);\n\t\t}\n\n\t\telse if(\n\t\t\t(l.z > 0.9) &&\n\t\t\t(ur.z + dr.z < 0.1) &&\n\t\t\tapprox(l.xy, pLeft)\n\t\t)\n\t\t{\n\t\t\tresult = vec4(pLeft, 1.0, 0.0);\n\t\t}\n\t}\n\n\tvec2 dir = unpack(result.xy);\n\n\t// Turn randomly.\n\tif(\n\t\t//false &&\n\t\t(result.z > 0.1) &&\n\t\t(hash1((pos + vec2(iFrame)) * 91.13) >\n\t\t\t(1.0 - meandering))\n\t)\n\t{\n\t\tfloat random =\n\t\t\thash1((pos + vec2(iFrame)) * 3.14);\n\n\t\tif(random < 0.5) dir = dir.yx;\n\t\telse             dir = -dir.yx;\n\n\t\tvec4 diagonal1 = get(-dir + dir.yx);\n\t\tvec4 diagonal2 = get(-dir - dir.yx);\n\n\t\tif(diagonal1.z + diagonal2.z < 0.1)\n\t\t{\n\t\t\tresult.xy = pack(dir);\n\t\t}\n\t}\n\n\t// Turn away from the borders and\n\t// from the intersecrions.\n\tif(\n\t\t(result.z > 0.9) &&\n\t\t(\n\t\t\tisOnBorder(pos - dir) ||\n\t\t\tisOnBorder(pos - dir*2.0) ||\n\t\t\t(get(-dir * 2.0).z > 0.1) ||\n\t\t\t(get(-dir * 2.0 + dir.yx).z > 0.1) ||\n\t\t\t(get(-dir * 2.0 - dir.yx).z > 0.1)\n\t\t)\n\t)\n\t{\n\t\tvec2 newDir = dir;\n\t\t//*\n\t\t// Randomly turn left or right relative\n\t\t//to the current direction.\n\t\tfloat random =\n\t\t\thash1((pos + vec2(iFrame)) * 89.31);\n\t\tif(random < 0.5) newDir = newDir.yx;\n\t\telse             newDir = -newDir.yx;\n\n\t\t// Check if the new direction is actually good.\n\t\tif(\n\t\t\t(get(-newDir).z > 0.1) ||\n\t\t\t(get(-newDir * 2.0).z > 0.1) ||\n\t\t\tisOnBorder(pos - newDir*2.0)\n\t\t)\n\t\t{\n\t\t\t// If it's not good, then flip it.\n\t\t\tnewDir = -newDir;\n\t\t}\n\n\t\t// Check once again if the flipped direction\n\t\t// is any good.\n\t\tif(\n\t\t\t(get(-newDir).z > 0.1) ||\n\t\t\t(get(-newDir * 2.0).z > 0.1) ||\n\t\t\tisOnBorder(pos - newDir*2.0) ||\n\t\t\t(get(-newDir + newDir.yx).z > 0.1) ||\n\t\t\t(get(-newDir - newDir.yx).z > 0.1)\n\t\t)\n\t\t{\n\t\t\t// Both left and right turn is bad.\n\t\t\t// Go back to the original direction.\n\t\t\tnewDir = dir;\n\t\t}\n\n\t\tdir = newDir;\n\n\t\tresult.xy = pack(dir);\n\t\t//*/\n\t}\n\n\t// Connect dead ends.\n\tif(\n\t\t//false &&\n\t\t(result.z < 0.1)\n\t)\n\t{\n\t\t//*\n\t\tint n1 = 0, n2 = 0;\n\t\tif(is(u)) n1++;\n\t\tif(is(d)) n1++;\n\t\tif(is(r)) n1++;\n\t\tif(is(l)) n1++;\n\t\tif(is(ur)) n2++;\n\t\tif(is(ul)) n2++;\n\t\tif(is(dr)) n2++;\n\t\tif(is(dl)) n2++;\n\t\t//*/\n\n\t\tif(\n\t\t\t/*\n\t\t\t((u.z > 0.9) && (d.z > 0.1) &&\n\t\t\t\tapprox(u.xy, pUp)) ||\n\t\t\t((d.z > 0.9) && (u.z > 0.1) &&\n\t\t\t\tapprox(d.xy, pDown)) ||\n\t\t\t((r.z > 0.9) && (l.z > 0.1) &&\n\t\t\t\tapprox(r.xy, pRight)) ||\n\t\t\t((l.z > 0.9) && (r.z > 0.1) &&\n\t\t\t\tapprox(l.xy, pLeft))\n\t\t\t//*/\n\t\t\tfalse\n\t\t\t//|| (n1 == 2) && (n2 < 2)\n\t\t\t|| ((n1 == 2) && (n2 == 0))\n\t\t\t/*\n\t\t\t|| (\n\t\t\t\tis(u) && is(d) &&\n\t\t\t\t(\n\t\t\t\t\t(!is(ur) && !is(ul)) ||\n\t\t\t\t\t(!is(dr) && !is(dl))\n\t\t\t\t)\n\t\t\t)\n\t\t\t|| (\n\t\t\t\tis(r) && is(l) &&\n\t\t\t\t(\n\t\t\t\t\t(!is(ur) && !is(dr)) ||\n\t\t\t\t\t(!is(ul) && !is(dl))\n\t\t\t\t)\n\t\t\t)\n\t\t\t//*/\n\t\t\t//*\n\t\t\t|| (\n\t\t\t\t(u.z > 0.1) &&\n\t\t\t\t(dr.z > 0.1) &&\n\t\t\t\t(dl.z < 0.1) &&\n\t\t\t\t(r.z < 0.1) &&\n\t\t\t\t(l.z < 0.1)\n\t\t\t)\n\t\t\t|| (\n\t\t\t\t(u.z > 0.1) &&\n\t\t\t\t(dr.z < 0.1) &&\n\t\t\t\t(dl.z > 0.1) &&\n\t\t\t\t(r.z < 0.1) &&\n\t\t\t\t(l.z < 0.1)\n\t\t\t)\n\t\t\t|| (\n\t\t\t\t(l.z > 0.1) &&\n\t\t\t\t(dr.z < 0.1) &&\n\t\t\t\t(ur.z > 0.1) &&\n\t\t\t\t(u.z < 0.1) &&\n\t\t\t\t(d.z < 0.1)\n\t\t\t)\n\t\t\t|| (\n\t\t\t\t(r.z > 0.1) &&\n\t\t\t\t(dl.z < 0.1) &&\n\t\t\t\t(ul.z > 0.1) &&\n\t\t\t\t(u.z < 0.1) &&\n\t\t\t\t(d.z < 0.1)\n\t\t\t)\n\t\t\t//*/\n\t\t)\n\t\t{\n\t\t\tresult = vec4(0.5, 0.5, 0.5, 0.0);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n//=================================================\n// Last cellular automata step. Clean up the result based on some rules.\nvec4 cleanUp(vec2 pos)\n{\n\tvec4 c = get(center);\n\t//return c;\n\n\t//if(c.z < 0.1) return c;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\tvec4 ur = get(upRight);\n\tvec4 ul = get(upLeft);\n\tvec4 dr = get(downRight);\n\tvec4 dl = get(downLeft);\n\n\tint n1 = 0, n2 = 0;\n\tif(u.z > 0.1) n1++;\n\tif(d.z > 0.1) n1++;\n\tif(r.z > 0.1) n1++;\n\tif(l.z > 0.1) n1++;\n\tif(ur.z > 0.1) n2++;\n\tif(ul.z > 0.1) n2++;\n\tif(dr.z > 0.1) n2++;\n\tif(dl.z > 0.1) n2++;\n\n\tif(n1 == 1) return vec4(0.0);\n\t//if((n1 == 3) && (n2 == 3)) return vec4(0.0);\n\t//if((n1 == 4) && (n2 == 4)) return vec4(0.0);\n\t//if((n1 < 2) && (n2 ==3)) return vec4(0.0);\n\t//if((n1 == 2) && (n2 == 4)) return vec4(0.0);\n\tif(n1 == 0) return vec4(0.0);\n\n\t/*\n\tif(!is(c) && (n1 == 4) && (n2 == 4))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\t//*/\n\n\t/*\n\tif(!is(u) && !is(r) && is(ur)) return vec4(0.0);\n\tif(!is(u) && !is(l) && is(ul)) return vec4(0.0);\n\tif(!is(d) && !is(r) && is(dr)) return vec4(0.0);\n\tif(!is(d) && !is(l) && is(dl)) return vec4(0.0);\n\t//*/\n\n\t/*\n\tif(!is(c) && is(u) && is(r) && !is(ur))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\tif(!is(c) && is(u) && is(l) && !is(ul))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\tif(!is(c) && is(d) && is(r) && !is(dr))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\tif(!is(c) && is(d) && is(l) && !is(dl))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\t//*/\n\n\treturn c;\n}\n\n//=================================================\n// This is used to add some cracks to the visual presentation of the dungeon.\nfloat getCracks(vec2 uv)\n{\n    float cracks = abs(texture(iChannel1, uv).x - 0.125) / (1.0 - 0.125);\n    return saturate(10.0*cracks);\n}\n\n\n\n//=================================================\n// This is the generation process. It happens in the bottom left corner.\nvec4 getScaledDown(vec2 pos, int frame, int seed)\n{\n    if(frame == 0)\n    {\n        return vec4(0.0);\n        //return get(center);\n    }\n\tif(frame == 1)\n\t{\n\t\t//fragColor = initializeSingle(p, seed);\n\t\t//fragColor = initialize(p, seed);\n\t\treturn initializeRooms(pos, 0.99, seed);\n\t}\n\tif(frame < 5)\n\t{\n\t\t//fragColor = get(center);\n\t\treturn tunnel(pos, 0.3);\n\t\t//fragColor = expand(p);\n\t}\n\tif(frame < 9)\n\t{\n\t\treturn expand(pos);\n\t\t//return expandBorders(pos);\n\t}\n\tif(frame == 9)\n\t{\n\t\treturn neutralize(pos);\n\t}\n\tif(frame == 10)\n\t{\n\t\treturn clearBorders(pos);\n\t}\n\tif(frame == 11)\n\t{\n\t\treturn markRoomExits(pos, 0.1, seed); //0.09\n\t}\n\tif (\n\t\t//false &&\n\t\tframe < 150\n\t)\n\t{\n\t\treturn tunnel(pos, 0.15);\n\t}\n\t//if(false)\n\t{\n\t\treturn cleanUp(pos);\n\t}\n}\n\n//=================================================\n// This is a function to upscale the tiny dungeon generated in the bottom left corner.\n// It also adds details like tiles, walls, cracks and shading.\nvec4 getRegular(vec2 pos)\n{\n\tpos = pos / scaleDown;\n\n\tvec2 originalPos = pos;\n\n\tvec2 warped = pos;\n\n\t// Uncomment this. Disabled only for testing.\n    vec2 hashNoise = unpack(hash22(vec2(ivec2(pos))));\n\twarped += 0.05 * hashNoise;\n\n\tfloat noise = unpack(optimizedSnoise(warped * 0.15));\n\tpos = warped + noise * 0.05;\n\n\tvec4 cell = getScaledDown(pos);\n\tvec4 c = cell;\n\n\tvec4 u = getScaledDown(pos + vec2(up));\n\tvec4 d = getScaledDown(pos + vec2(down));\n\tvec4 r = getScaledDown(pos + vec2(right));\n\tvec4 l = getScaledDown(pos + vec2(left));\n\tvec4 ur = getScaledDown(pos + vec2(upRight));\n\tvec4 ul = getScaledDown(pos + vec2(upLeft));\n\tvec4 dr = getScaledDown(pos + vec2(downRight));\n\tvec4 dl = getScaledDown(pos + vec2(downLeft));\n\tvec4 dd = getScaledDown(pos + vec2(down)*2.0);\n\n\tint n1 = 0, n2 = 0;\n\tif(u.z > 0.1) n1++;\n\tif(d.z > 0.1) n1++;\n\tif(r.z > 0.1) n1++;\n\tif(l.z > 0.1) n1++;\n\tif(ur.z > 0.1) n2++;\n\tif(ul.z > 0.1) n2++;\n\tif(dr.z > 0.1) n2++;\n\tif(dl.z > 0.1) n2++;\n\n\n\tfloat cracks = getCracks(originalPos * 0.003 + 0.1*hashNoise);\n\n\tvec2 grid = abs(sin(pos * M_PI));\n\tfloat gridMultiplier = min(grid.x, grid.y);\n\tgridMultiplier *= cracks;\n\tgridMultiplier =\n\t\tclamp(gridMultiplier * 5.0, 0.0, 1.0);\n\n\n\t// Wall tops.\n    float wallTopOffset = 0.5;\n    \n\tif(\n\t\t//false &&\n\t\t!is(cell) && ((n1 + n2 != 0) || !is(d))\n\t)\n\t{\n\t\tvec2 iPos = vec2(ivec2(pos));\n\n\t\tfloat mask = 0.0;\n\t\t//*\n\t\tif(is(u)) mask = max(mask, -0.25 + pos.y - iPos.y);\n\t\t//if(is(d)) mask = max(mask, 1.0 - pos.y + iPos.y);\n\t\tif(is(d)) mask = max(mask, (1.0 + wallTopOffset) - pos.y + iPos.y);\n\t\tif(is(r)) mask = max(mask, pos.x - iPos.x);\n\t\tif(is(l)) mask = max(mask, 1.0 - pos.x + iPos.x);\n\t\t//*/\n\t\t//if(is(dd)) mask = max(mask, 1.0 + (-pos.y + iPos.y));\n\t\t//*/\n\t\t//*\n\t\tif(is(ur)) mask = max(\n\t\t\tmask,\n\t\t\tmin(pos.x - iPos.x, -0.25 + pos.y - iPos.y)\n\t\t);\n\t\tif(is(ul)) mask = max(\n\t\t\tmask,\n\t\t\tmin(1.0 - pos.x + iPos.x, -0.25 + pos.y - iPos.y)\n\t\t);\n\t\t/*\n\t\tif(is(dr)) mask = max(\n\t\t\tmask,\n\t\t\tmin(pos.x - iPos.x, 1.0 - pos.y + iPos.y)\n\t\t);\n\t\tif(is(dl)) mask = max(\n\t\t\tmask,\n\t\t\tmin(1.0 - pos.x + iPos.x, 1.0 - pos.y + iPos.y)\n\t\t);\n\t\t//*/\n\t\tif(is(dr)) mask = max(\n\t\t\tmask,\n\t\t\tmin(pos.x - iPos.x, (1.0 + wallTopOffset) - pos.y + iPos.y)\n\t\t);\n\t\tif(is(dl)) mask = max(\n\t\t\tmask,\n\t\t\tmin(1.0 - pos.x + iPos.x, (1.0 + wallTopOffset) - pos.y + iPos.y)\n\t\t);\n\t\t//if(is(dr)) mask = max(mask, pos.x - iPos.x);\n\t\t//if(is(dl)) mask = max(mask, 1.0 - pos.x + iPos.x);\n\n\t\tmask *= mask * mask;\n\n\t\tfloat outline = 1.0 - 1.5 * mask;\n\t\toutline = clamp(3.0 * outline, 0.0, 1.0);\n\t\tmask = clamp(2.0 * mask, 0.0, 1.0);\n\n\t\tcell = vec4(mask);\n\t}\n\n\t// Side walls.\n\tif(\n\t\t//false &&\n\t\t!is(c) && is(d)\n\t)\n\t{\n\t\tfloat height =\n\t\t\t1.0 * (pos.y - float(int(pos.y)));\n\t\t//height = pow(height, 0.5);\n\t\t//height = clamp(0.0 + height, 0.0, 1.0);\n\t\t//height = 1.0 - 2.0 * abs(height - 0.5);\n\n\t\t// This one.\n\t\t//cell = min(cell, vec4(height));\n\n\t\tif(height < wallTopOffset)\n\t\t{\n\t\t\tfloat split = abs(cos(2.0 * height * M_PI));\n\t\t\tsplit = clamp(split * 2.5, 0.0, 1.0);\n\t\t\tcell = vec4(0.17 * split);\n\t\t\tif(height < (0.5 * wallTopOffset))\n\t\t\t\tpos.x += 0.25;\n\t\t}\n\n\t\t//height *= abs(sin(height * M_PI * 5.0));\n\t\t/*\n\t\tcell = mix(\n\t\t\tvec4(0.4),\n\t\t\tvec4(0.25),\n\t\t\theight\n\t\t);\n\t\tcell *= clamp(\n\t\t\t2.5 * abs(cos(height * M_PI * 2.0)),\n\t\t\t0.0, 1.0\n\t\t);\n\t\t*/\n\t}\n\n\tif(!is(c))\n\t{\n\t\tvec2 topGrid =\n\t\t\tabs(sin(2.0 * (pos - vec2(0.0, wallTopOffset)) * M_PI));\n\t\tfloat topGridMultiplier = min(topGrid.x, topGrid.y);\n\t\ttopGridMultiplier *= cracks;\n\t\ttopGridMultiplier =\n\t\t\tclamp(topGridMultiplier * 2.5, 0.0, 1.0);\n\n\t\t/*\n\t\tcell = vec4(\n\t\t\t//0.15 * cell +\n\t\t\t0.5 *\n\t\t\t(1.5 - topGridMultiplier) *\n\t\t\t(cracks) *\n\t\t\tcell\n\t\t\t//* (outline)\n\t\t);\n\t\t//*/\n\t\tcell = cell * cell * cell;\n\t\tcell = clamp(100.0 * cell, 0.0, 1.0);\n\t\tcell *= topGridMultiplier;\n\t\tcell *= 0.35;\n\t}\n\n\t// Shading.\n\tif(\n\t\t//false &&\n\t\tis(c)\n\t)\n\t{\n\t\tvec2 iPos = vec2(ivec2(pos));\n\t\tfloat mask = 1.0;\n\t\tfloat occlusion = 1.0;\n\n\t\tocclusion *= (!is(d)?\n\t\t\t\t(pos.y - iPos.y) : 1.0);\n\t\tocclusion *= (!is(u)?\n\t\t\t\t(1.0 - pos.y + iPos.y) : 1.0);\n\t\tocclusion *= (!is(l)?\n\t\t\t\t(pos.x - iPos.x) : 1.0);\n\t\tocclusion *= (!is(r)?\n\t\t\t\t(1.0 - pos.x + iPos.x) : 1.0);\n\n\t\tocclusion *= (!is(dl)?\n\t\t\tlength(vec2(\n\t\t\t\t(pos.x - iPos.x),\n\t\t\t\t(pos.y - iPos.y)\n\t\t\t)) : 1.0);\n\t\tocclusion *= (!is(dr)?\n\t\t\tlength(vec2(\n\t\t\t\t(1.0 - pos.x + iPos.x),\n\t\t\t\t(pos.y - iPos.y)\n\t\t\t)) : 1.0);\n\t\tocclusion *= (!is(ul)?\n\t\t\tlength(vec2(\n\t\t\t\t(pos.x - iPos.x),\n\t\t\t\t(1.0 - pos.y + iPos.y)\n\t\t\t)) : 1.0);\n\t\tocclusion *= (!is(ur)?\n\t\t\tlength(vec2(\n\t\t\t\t(1.0 - pos.x + iPos.x),\n\t\t\t\t(1.0 - pos.y + iPos.y)\n\t\t\t)) : 1.0);\n\n\t\t//occlusion = clamp(8.0 * occlusion, 0.0, 1.0);\n\t\t//occlusion *= occlusion;\n\t\tocclusion = pow(occlusion, 0.5);\n\t\tocclusion = clamp(1.5 * occlusion, 0.0, 1.0);\n\t\tmask = occlusion;\n\t\t\t//clamp(pow(occlusion, 1.0), 0.0, 1.0);\n\n\t\tcell *= mask;\n\t}\n\n\tif(is(c)) cell *= gridMultiplier;\n\treturn cell;\n\t//return cell * gridMultiplier;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Empty the texture once in the beginning.\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // Read seed and frameId from the specified pixels in the texture.\n    ivec2 seedPixelPos = ivec2(0.0, iResolution.y / scaleDown + 1.0);\n    ivec2 frameIdPixelPos = ivec2(1.0, iResolution.y / scaleDown + 1.0);\n\n    int seed = int(texelFetch(iChannel0, seedPixelPos, 0).x * 1000.0);\n    int frameId = int(texelFetch(iChannel0, frameIdPixelPos, 0).x * 1000.0);\n\n\n    // Process the seed pixel.\n    if(ivec2(fragCoord) == seedPixelPos)\n    {\n        vec4 currentSeed = texelFetch(iChannel0, seedPixelPos, 0);\n        if(frameId == 300)\n        {\n            // Go to next seed. Reset frame counter.\n            fragColor = currentSeed + vec4(0.001, 0.0, 0.0, 0.0);\n        }\n        else\n        {\n            fragColor = currentSeed;\n        }\n        return;\n    }\n    \n    // Process the frame id pixel.\n    if(ivec2(fragCoord) == frameIdPixelPos)\n    {\n        vec4 currentFrame = texelFetch(iChannel0, frameIdPixelPos, 0);\n        if(frameId == 300)\n        {\n            // Go to next seed. Reset frame counter.\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n        else\n        {\n            // Increase the frame id by 1.\n            fragColor = currentFrame + vec4(0.001, 0.0, 0.0, 0.0);\n        }\n        return;\n    }\n    \n    // If we are doing a reset, then clean everything else except the frame id pixel and the seed pixel.\n    if(frameId == 300)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord / mx;\n\tvec2 p = fragCoord;\n\n\tif(isScaledDown(p))\n\t{\n\t\tfragColor = getScaledDown(p, frameId, seed);\n\t}\n\telse\n\tif(\n\t\t(p.x > iResolution.x / scaleDown + 1.0) ||\n\t\t(p.y > iResolution.y / scaleDown + 1.0)\n\t)\n\t{\n\t\tfragColor = getRegular(p);\n\t}\n\telse{\n\t\tfragColor = get(center);\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}