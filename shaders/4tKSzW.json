{
    "Shader": {
        "info": {
            "date": "1483301438",
            "description": "Would you like another hit from the spice-weasel?!",
            "flags": 96,
            "hasliked": 0,
            "id": "4tKSzW",
            "likes": 11,
            "name": "Music visualizer #2",
            "published": 3,
            "tags": [
                "bam"
            ],
            "usePreview": 0,
            "username": "voz",
            "viewed": 1045
        },
        "renderpass": [
            {
                "code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.333, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 sample1 = texture(iChannel0, uv);\n    vec4 sample2 = texture(iChannel1, uv);\n    \n    float w = smoothstep(0.0, 1.0, length(sample2.zw*2.0-1.0)/sqrt(2.0));\n    \n    fragColor.rgb = (sample1.rgb*w+\n                     \n                      (1.0-w));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define M_PI \t3.14159265358979323846\n#define M_PI_2  1.57079632679489661923\n#define M_2_PI  6.28318530717958647692\n\n\nmat2 rotate2D(float angle)\n{\n   \tfloat cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    \n    return mat2(\n        vec2(cosTheta, sinTheta), \n        vec2(-sinTheta, cosTheta));\n}\n\n// Noise shamlessly storen from iq\nfloat noise(vec3 x) \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat fbm(vec2 p)\n{\n\tp += vec2(1.0,0.1) * iTime*0.5;\n    \n    float f;\n    f  = 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\nfloat f(vec2 uv, vec2 centre, float radius, float power)\n{\n    vec3 a = vec3(uv, radius);\n    vec3 b = vec3(centre, 0.0);\n    \n    return dot(pow(abs(a-b), vec3(power)), vec3(1.0, 1.0, -1.0));\n}\n\nvec2 grad_f(in vec2 x, vec2 centre, float radius, float power)\n{\n    vec2 h = vec2( 0.001, 0.0 );\n    return vec2( f(x+h.xy, centre, radius, power) - f(x-h.xy, centre, radius, power),\n                 f(x+h.yx, centre, radius, power) - f(x-h.yx, centre, radius, power) ) / (2.0*h.x);\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1 < d2) ? d1 : d2;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nfloat sq(vec2 uv, vec2 centre, float radius, float power)\n{\n\tfloat v = f(uv, centre, radius, power);\n    vec2 g = grad_f(uv, centre, radius, power);\n    return v/length(g);    \n}\n\nvoid addScene(inout vec3 col, vec3 c, float de)\n{\n\tcol = mix(c, col, smoothstep(0.0, 2.5/iResolution.x, de));    \n}\n\nvoid addScene(inout vec3 col, vec3 c, float de, float width)\n{\n\tcol = mix(c, col, smoothstep(0.0, width, de));    \n}\n\nfloat avgFreq(int grid, int gridSize)\n{\n    float freq = 0.0;\n    for (int i = 0; i < 4; i++)\n    {\n        float offset = (float(i) / (4.0)) + 0.5;\n        float samplePos = (float(grid-1) + offset) / float(gridSize);\n        freq += texture(iChannel1, vec2(samplePos, 0.25)).x;\n    }\n    \n    return freq / 4.0;\n}\n\nvec3 getPalette(float p)\n{\n    float m = 0.8;\n    float n = 0.1;\n    \n    p = sqrt(p);\n    \n    float range[5];\n    range[0] = 0.00;\n    range[1] = 0.40;\n    range[2] = 0.50;\n    range[3] = 0.60;\n    range[4] = 1.00;\n    \n    if (p <= range[1]) \n    {\n        float v = (p - range[0]) / (range[1] - range[0]);\n        return mix(vec3(n, n, m), vec3(n, m, m), v); \n    }\n    \n    if (p <= range[2]) \n    {\n        float v = (p - range[1]) / (range[2] - range[1]);\n        return mix(vec3(n, m, m), vec3(n, m, n), v); \n        \n    }    \n    \n    if (p <= range[3]) \n    { \n        float v = (p - range[2]) / (range[3] - range[2]);\n        return mix(vec3(n, m, n), vec3(m, m, n), v); \n    }    \n    \n    if (p <= range[4]) \n    {\n        float v = (p - range[3]) / (range[4] - range[3]);\n        return mix(vec3(m, m, n), vec3(m, n, n), v); \n    }    \n    \n    return vec3(p,0,1.0-p);\n}\n\nvoid addRingBloom(\n    inout vec3 col, \n    vec2 coord, \n\tfloat freq, \n    float ringRadius, \n    float ringSize, \n    float s, \n    float total,\n    float sqRadius,\n\tfloat offsetRotate)\n{\n \tvec3 c = getPalette(freq);\n   \n    mat2 midRotate = rotate2D(offsetRotate + (M_2_PI / total) * (s + 0.5));\n    vec2 q = midRotate*coord;\n    vec2 mid = vec2(0.0, ringRadius + ringSize*0.5);\n    \n    vec3 bloom = mix(c, vec3(1,1,1), 0.70);\n    \n    addScene(col, bloom, sq(q, mid - vec2(0.0, sqRadius*0.125), sqRadius, 0.5+(freq*freq)*3.5), sqRadius*1.5);        \n}\n    \n\nvoid addRingSegment(\n    inout vec3 col, \n    vec2 coord, \n    float freq, \n    float ringRadius, \n    float ringSize, \n    float s, \n    float total, \n    float sqRadius,\n\tfloat offsetRotate)\n{\n    float angle0 = offsetRotate + (M_2_PI / total) * s;\n    float angle1 = offsetRotate + (M_2_PI / total) * (s + 1.0);\n        \n \tvec2 inner0 = vec2(0.0, ringRadius) * rotate2D(angle0);\n    vec2 inner1 = vec2(0.0, ringRadius) * rotate2D(angle1);\n\n    vec2 outer0 = vec2(0.0, ringRadius) * rotate2D(angle0);\n    vec2 outer1 = vec2(0.0, ringRadius) * rotate2D(angle1);\n\t\n    vec3 c = getPalette(freq);\n    \n    mat2 midRotate = rotate2D(offsetRotate + (M_2_PI / total) * (s + 0.5));\n    vec2 q = midRotate*coord;\n    vec2 mid = vec2(0.0, ringRadius + ringSize*0.5);\n    \n    float de = sq(q, mid - vec2(0.0, sqRadius*0.125), sqRadius, 0.5+(freq*freq)*3.5);\n    \n    vec3 ac = mix(c, vec3(1,1,1), 0.5);\n    c = mix(c, ac, smoothstep(0.0, 2.5/iResolution.x, abs(de)));\n    \n    addScene(col, c, de);    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 coord = -1.0 + 2.0*uv;\n    coord.y /= aspect;\n\n    float ro[4];\n    ro[0] = 0.10;\n    ro[1] = 0.21;\n    ro[2] = 0.32;\n    ro[3] = 0.43;\n    \n    float rs[4];\n    rs[0] = 0.10;\n    rs[1] = 0.10;\n    rs[2] = 0.10;\n    rs[3] = 0.10;\n    \n    vec3 bc = vec3(0.9, 0.9, 0.9);\n    \n    // Ring 0\n    float ring0 = avgFreq(1, 30);\n    const int numSegments0 = 24;\n    \n    for (int i = 0; i < numSegments0; i++)\n    {\n        if (float(i) / float(numSegments0-1) >= ring0) { break; }\n    }\n    \n    for (int i = 0; i < numSegments0; i++)\n    {\n        if (float(i) / float(numSegments0-1) >= ring0) { break; }\n        addRingSegment(col, coord, ring0, ro[0], rs[0], float(i), float(numSegments0), 0.015, iTime);\n    }\n    \n    // Ring 1\n    float ring1 = avgFreq(10, 30);\n    const int numSegments1 = 28;\n\n    for (int i = 0; i < numSegments1; i++)\n    {\n        if (float(i) / float(numSegments1-1) >= ring1) { break; }\n    }\n    \n    for (int i = 0; i < numSegments1; i++)\n    {\n        if (float(i) / float(numSegments1-1) >= ring1) { break; }\n        addRingSegment(col, coord, ring1, ro[1], rs[1], float(i), float(numSegments1), 0.020, iTime*1.5);\n    }\n    \n    // Ring 2\n    float ring2 = avgFreq(20, 30);\n    const int numSegments2 = 32;\n    \n    for (int i = 0; i < numSegments2; i++)\n    {\n        if (float(i) / float(numSegments2-1) >= ring2) { break; }\n    }      \n    \n    for (int i = 0; i < numSegments2; i++)\n    {\n        if (float(i) / float(numSegments2-1) >= ring2) { break; }\n        addRingSegment(col, coord, ring2, ro[2], rs[2], float(i), float(numSegments2), 0.025, iTime*2.0);\n    }    \n    \n    // Ring 3\n    float ring3 = avgFreq(30, 30);\n    const int numSegments3 = 32;\n    \n    for (int i = 0; i < numSegments3; i++)\n    {\n        if (float(i) / float(numSegments3-1) >= ring3) { break; }\n    }     \n    \n    for (int i = 0; i < numSegments3; i++)\n    {\n        if (float(i) / float(numSegments3-1) >= ring3) { break; }\n        addRingSegment(col, coord, ring3, ro[3], rs[3], float(i), float(numSegments3), 0.030, iTime*2.5);\n    }      \n    \n    \n    fragColor = vec4(col, length(col));\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 11624,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/si7zermusic/bearfirez-thunderdance?in=sandradeluxe/sets/toptracks"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//-----------------USEFUL-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n#define time ((saw(float(__LINE__))/GR+.5/GR)*(iTime/PI+12345.12345))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n#define R 3.0\n#define RESTITUTION .5\n\nvec4 FindArrivingParticle( vec2 arriveCoord )\n{\n    vec4 p = vec4(0.0);\n    float sum = 0.0;\n    for( float i = -R; i <= R; i++ )\n    {\n        for( float j = -R; j <= R; j++ )\n        {\n            vec2 partCoord = arriveCoord + vec2( i, j )/ iResolution.xy;\n            \n            vec4 part = texture( iChannel1, partCoord );\n            \n            \n            vec2 nextPos = part.xy + .5*(part.zw*2.0-1.0)/ iResolution.xy * R* R;\n            // arrival means within half a pixel of this bucket\n            vec2 off = (nextPos - arriveCoord)*iResolution.xy;\n            if( abs(off.x)<= sqrt(1.0)/2.0*GR && abs(off.y)<=sqrt(1.0)/2.0*GR )\n            {\n                // yes! greedily take this particle.\n                // a better algorithm might be to inspect all particles that arrive here\n                // and pick the one with the highest velocity.\n                p += part;\n                sum += 1.0;\n            }\n        }\n    }\n    // no particle arriving at this bucket.\n    return p/sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv0 = uv;\n    vec4 sample0 = texture(iChannel1, uv0);\n    vec4 sample1 = texture(iChannel0, uv0);\n    vec4 arrival = FindArrivingParticle(uv);\n    \n    if(iFrame == 0)\n    {\n        fragColor = vec4(vec2(uv), vec2(0.5, 0.5));\n        return;\n    }\n    \n    float thresh = (128.0+64.0+32.0)/255.0;\n    \n    float w = clamp(sample1.a, 0.0, 1.0);\n    \n    if(w > thresh )//|| length(sample0.xy-uv) > sqrt(100.0)/length(iResolution.xy))\n    {\n        w = (w - thresh)/(1.0-thresh);\n        fragColor = vec4(uv0, (saw(sample1.xy/w)));\n        return;\n    }\n    \n    w = (thresh-w)/(thresh);\n    arrival.xy += .5*(arrival.zw*2.0-1.0)/ iResolution.xy * R * R;\n    //arrival.zw = ((arrival.zw*2.0-1.0)*.975)*.5+.5;\n    \n    fragColor.xyzw = (arrival.xyzw);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}