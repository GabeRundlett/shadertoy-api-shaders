{
    "Shader": {
        "info": {
            "date": "1522130002",
            "description": "Testing Sebastian Aaltonen's soft shadow improvement. Go to line 54 to compare with the traditional technique for soft shadows. It's very cheap and improves shadows a lot!",
            "flags": 0,
            "hasliked": 0,
            "id": "lsKcDD",
            "likes": 229,
            "name": "Soft Shadow Variation",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 25061
        },
        "renderpass": [
            {
                "code": "//    \n// Testing Sebastian Aaltonen's soft shadow improvement\n//\n// The technique is based on estimating a better closest point in ray\n// at each step by triangulating from the previous march step.\n//\n// More info about the technique at slide 39 of this presentation:\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\n//\n// Traditional technique: https://iquilezles.org/articles/rmshadows\n//\n// Go to lines 54 to compare both.\n\n\n// make this 1 is your machine is too slow\n#define AA 2\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\n}\n\n//------------------------------------------------------------------\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float w, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, h/(w*t) );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, d/(w*max(0.0,t-y)) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tvec3 mate = vec3(0.3);\n\n        // key light\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( pos, lig, 0.01, 3.0, 0.1, technique );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\n        \n        // ambient light\n        float occ = calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\n        \n        // fog\n        col *= exp( -0.0005*t*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    float an = 12.0 - sin(0.1*iTime);\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, technique);\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}