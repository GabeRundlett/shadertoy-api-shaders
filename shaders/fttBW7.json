{
    "Shader": {
        "info": {
            "date": "1663355318",
            "description": "Fast 3D rasterizing. Runs at 60 FPS on my phone.",
            "flags": 0,
            "hasliked": 0,
            "id": "fttBW7",
            "likes": 4,
            "name": "Triangle Rasterizing",
            "published": 3,
            "tags": [
                "rasterizing"
            ],
            "usePreview": 0,
            "username": "FifthStateOfMatter",
            "viewed": 337
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926545\n#define degreesToRadians PI/180.0\n#define a iResolution.y/iResolution.x\n#define FOV 90.0*degreesToRadians\n#define nearPlane 0.5\n#define farPlane 1000.0\n#define zNormalize farPlane/(farPlane - nearPlane)\n#define fogDensity 35.0\n#define fogColor vec3(0.7, 0.8, 1)\n\nstruct tri3{\n    vec3 v1;\n    vec3 v2;\n    vec3 v3;\n    vec3 inClr;\n};\n\ntri3[] mesh = tri3[](tri3(vec3(-0.5, 0.5, -0.5), vec3(-0.5, -0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(0.5, 0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(0.5, 0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(0.5, -0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(0.5, 0.5, -0.5), vec3(0.5, -0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(0.5, 0.5, 0.5), vec3(0.5, -0.5, 0.5), vec3(-0.5, -0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(0.5, 0.5, 0.5), vec3(-0.5, -0.5, 0.5), vec3(-0.5, 0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, 0.5), vec3(-0.5, -0.5, 0.5), vec3(-0.5, -0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, 0.5), vec3(-0.5, -0.5, -0.5), vec3(-0.5, 0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, -0.5, -0.5), vec3(-0.5, -0.5, 0.5), vec3(0.5, -0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, -0.5, -0.5), vec3(0.5, -0.5, 0.5), vec3(0.5, -0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, 0.5), vec3(-0.5, 0.5, -0.5), vec3(0.5, 0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, 0.5), vec3(0.5, 0.5, -0.5), vec3(0.5, 0.5, 0.5), vec3(1, 0, 0)));\n\nfloat f = 1.0/tan(FOV/2.0);\n\nfloat cross2D(vec2 av, vec2 bv){\n    return (av.x*bv.y - av.y*bv.x);\n}\n\nstruct tri2{\n    vec2 v1;\n    vec2 v2;\n    vec2 v3;\n    vec3 inClr;\n};\n\nstruct camera{\n    vec3 pos;\n    vec3 dir;\n};\n\n//Based on a chat on stackexchange.\n//https://gamedev.stackexchange.com/questions/23743/whats-the-most-efficient-way-to-find-barycentric-coordinates\nvec3 barycentricCoords(vec2 uv, tri3 tri){\n    vec2 v1 = tri.v2.xy - tri.v1.xy;\n    vec2 v2 = tri.v3.xy - tri.v1.xy;\n    vec2 v3 = uv - tri.v1.xy;\n    \n    float d1 = dot(v1, v1);\n    float d2 = dot(v1, v2);\n    float d3 = dot(v2, v2);\n    float d4 = dot(v3, v1);\n    float d5 = dot(v3, v2);\n    float denomInv = 1.0/(d1*d3 - d2*d2);\n    \n    float v = (d3*d4 - d2*d5)*denomInv;\n    float w = (d1*d5 - d2*d4)*denomInv;\n    float u = 1.0 - v - w;\n    \n    return vec3(u, v, w);\n}\n\nbool displayTriangle(vec2 uv, tri2 tri, in float clrInt, out vec3 outClr){\n    vec3 b = barycentricCoords(uv, tri3(vec3(tri.v1.xy, 0), vec3(tri.v2.xy, 0), vec3(tri.v3.xy, 0), tri.inClr));\n    if(b.x >= 0.0 && b.y >= 0.0 && b.x + b.y <= 1.0){\n        outClr = tri.inClr*clrInt;\n        return true;\n    }\n    return false;\n}\n\nbool render(vec2 uv, tri3 tri, vec3 rot, vec3 trans, vec3 scale, camera cam, out vec3 normal, out float depth, out vec3 camDir){\n    mat4 projection;\n    projection[0] = vec4(a*f, 0.0, 0.0, 0.0);\n    projection[1] = vec4(0.0, f, 0.0, 0.0);\n    projection[2] = vec4(0.0, 0.0, zNormalize, 1.0);\n    projection[3] = vec4(0.0, 0.0, -nearPlane*zNormalize, 0.0);\n    \n    mat4 camxRotation;\n    camxRotation[0] = vec4(1, 0, 0, 0);\n    camxRotation[1] = vec4(0, cos(cam.dir.x*degreesToRadians), -sin(cam.dir.x*degreesToRadians), 0);\n    camxRotation[2] = vec4(0, sin(cam.dir.x*degreesToRadians), cos(cam.dir.x*degreesToRadians), 0);\n    camxRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 camyRotation;\n    camyRotation[0] = vec4(cos(cam.dir.y*degreesToRadians), 0, sin(cam.dir.y*degreesToRadians), 0);\n    camyRotation[1] = vec4(0, 1, 0, 0);\n    camyRotation[2] = vec4(-sin(cam.dir.y*degreesToRadians), 0, cos(cam.dir.y*degreesToRadians), 0);\n    camyRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 camzRotation;\n    camzRotation[0] = vec4(cos(cam.dir.z*degreesToRadians), sin(cam.dir.z*degreesToRadians), 0, 0);\n    camzRotation[1] = vec4(-sin(cam.dir.z*degreesToRadians), cos(cam.dir.z*degreesToRadians), 0, 0);\n    camzRotation[2] = vec4(0, 0, 1, 0);\n    camzRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 camRotation = camxRotation*camyRotation*camzRotation;\n    \n    mat4 xRotation;\n    xRotation[0] = vec4(1, 0, 0, 0);\n    xRotation[1] = vec4(0, cos(rot.x*degreesToRadians), -sin(rot.x*degreesToRadians), 0);\n    xRotation[2] = vec4(0, sin(rot.x*degreesToRadians), cos(rot.x*degreesToRadians), 0);\n    xRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 yRotation;\n    yRotation[0] = vec4(cos(rot.y*degreesToRadians), 0, sin(rot.y*degreesToRadians), 0);\n    yRotation[1] = vec4(0, 1, 0, 0);\n    yRotation[2] = vec4(-sin(rot.y*degreesToRadians), 0, cos(rot.y*degreesToRadians), 0);\n    yRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 zRotation;\n    zRotation[0] = vec4(cos(rot.z*degreesToRadians), sin(rot.z*degreesToRadians), 0, 0);\n    zRotation[1] = vec4(-sin(rot.z*degreesToRadians), cos(rot.z*degreesToRadians), 0, 0);\n    zRotation[2] = vec4(0, 0, 1, 0);\n    zRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 rotation = xRotation*yRotation*zRotation;\n    \n    vec4 v1 = vec4(tri.v1, 1);\n    vec4 v2 = vec4(tri.v2, 1);\n    vec4 v3 = vec4(tri.v3, 1);\n    \n    v1.xyz *= scale;\n    v2.xyz *= scale;\n    v3.xyz *= scale;\n    \n    v1 *= rotation;\n    v2 *= rotation;\n    v3 *= rotation;\n    \n    v1.xyz += trans;\n    v2.xyz += trans;\n    v3.xyz += trans;\n    \n    v1.xyz -= cam.pos;\n    v2.xyz -= cam.pos;\n    v3.xyz -= cam.pos;\n    \n    v1 *= camRotation;\n    v2 *= camRotation;\n    v3 *= camRotation;\n    \n    v1 *= projection;\n    v2 *= projection;\n    v3 *= projection;\n    \n    vec3 outClr;\n    \n    normal = normalize(cross(v3.xyz - v1.xyz, v2.xyz - v1.xyz));\n    \n    camDir = -v1.xyz;\n    \n    v1.xy /= v1.w;\n    v2.xy /= v2.w;\n    v3.xy /= v3.w;\n    \n    tri2 outTri = tri2((v1.xy + 1.0)*(iResolution.xy/2.0), (v2.xy + 1.0)*(iResolution.xy/2.0), (v3.xy + 1.0)*(iResolution.xy/2.0), vec3(1));\n    \n    vec3 barycentrics = barycentricCoords(uv, tri3(vec3((v1.xy + 1.0)*(iResolution.xy/2.0), v1.z), vec3((v2.xy + 1.0)*(iResolution.xy/2.0), v2.z), vec3((v3.xy + 1.0)*(iResolution.xy/2.0), v3.z), vec3(1)));\n    \n    float z = (1.0/v1.z)*barycentrics.x + (1.0/v2.z)*barycentrics.y + (1.0/v3.z)*barycentrics.z;\n    \n    depth = 1.0/z;\n    \n    return displayTriangle(uv, outTri, 1.0, outClr);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord;\n    camera cam = camera(vec3(0, 0, -3), vec3(-iMouse.y - abs(iMouse.w), iMouse.x - abs(iMouse.z), 0));\n    vec3 col = fogColor;\n    float depth;\n    vec3 camDir;\n    float testDepth = 10000000.0;\n        \n    for(int i = 0; i < mesh.length(); i++){\n        vec3 normal;\n        vec3 camDir = vec3(mesh[i].v1 - cam.pos);\n        bool r1 = render(uv, mesh[i], vec3(iTime*25.0, iTime*25.0, iTime*25.0), vec3(0, 0, 0), vec3(0.5, 1, 2), cam, normal, depth, camDir);\n        if(r1 && testDepth > depth && depth > 0.0 && dot(normal, camDir) >= 0.0){\n            testDepth = depth;\n            vec3 light = vec3(-10, -10, -10);\n            col = mix(max(dot(normal, normalize(light)), 0.1)*mesh[i].inClr, fogColor, 1.0 - exp(-testDepth * 0.1));\n        }\n        fragColor = vec4(col, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}