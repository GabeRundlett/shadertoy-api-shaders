{
    "Shader": {
        "info": {
            "date": "1593640440",
            "description": "Another equithirds substitution tiling...",
            "flags": 0,
            "hasliked": 0,
            "id": "3tBcRh",
            "likes": 7,
            "name": "Barycentric Equithirds",
            "published": 3,
            "tags": [
                "barycentric",
                "tiling",
                "substitution",
                "equithirds"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 328
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Equithirds tiling with barycentric coords, mla, 2020\n//\n// https://tilings.math.uni-bielefeld.de/substitution/equithirds/\n//\n// Given points p,q,r, the centroid is at (p+q+r)/3 and the trisectors\n// of side pq are (p+2q)/3, (2p+q)/3. These are the points needed to\n// recursively construct the equithirds tiling, and the rest is just\n// bookkeeping. We could reuse the current barycentric coords for the\n// subdivided triangle, but for simplicity we recalculate them each time\n// around. And not a trig function to be seen.\n//\n// See also:\n// https://www.shadertoy.com/view/WtSczR by jeyko\n// https://www.shadertoy.com/view/WlfGWN by fizzer\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid getbary(vec2 z, vec2 p, vec2 q, vec2 r, out float a, out float b, out float c) {\n  // Thanks to wikipedia\n  mat2 t = mat2(p-r,q-r);\n  vec2 lam = inverse(t)*(z-r);\n  a = lam.x; b = lam.y; c = 1.0-a-b;\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a;\n  vec2 ba = b-a;\n  float h = dot(pa,ba)/dot(ba,ba);\n  return length(pa-ba*h);\n}\n\nint tiling(vec2 z, int iterations, vec2 p, vec2 q, vec2 r, out float d) {\n  int state = 0;\n  for (int i = 0; i < iterations; i++) {\n    float a,b,c;\n    getbary(z,p,q,r,a,b,c);\n    if (state == 0) {\n      vec2 s = (p+q+r)/3.0;\n      if (a < b && a < c) {\n        p = s; // q,r stay same\n      } else if (b < a && b < c) {\n        q = r; r = p; p = s;\n      } else {\n        r = q; q = p; p = s;\n      }\n      state = 1;\n    } else {\n      vec2 s = (r+2.0*q)/3.0;\n      vec2 t = (q+2.0*r)/3.0;\n      if (b > 2.0*c) {\n        r = q; q = p; p = s;\n      } else if (c > 2.0*b) {\n        q = r; r = p; p = t;\n      } else {\n        q = s; r = t;\n        state = 0;\n      }\n    }\n  }\n  d = min(linedist(z,p,q),\n          min(linedist(z,q,r),\n              linedist(z,r,p)));\n              \n  return state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float k = 5.0;\n  vec2 p = k*vec2(0,1), q = k*vec2(0.5*sqrt(3.0),-0.5), r = k*vec2(-0.5*sqrt(3.0),-0.5);\n  vec3 col = vec3(0);\n  int iterations = 2+int(iTime)%12;\n  float d;\n  int t = tiling(z,iterations,p,q,r,d);\n  float lwidth = 0.1*exp2(-0.5*float(iterations));\n  if (t == 0) col = vec3(1,0,0);\n  else col = vec3(0,1,1);\n  col = mix(vec3(1),col,0.8);\n  col *= smoothstep(0.5*lwidth,lwidth,d);\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}