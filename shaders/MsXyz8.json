{
    "Shader": {
        "info": {
            "date": "1487322363",
            "description": "Almost physically based render. Only a few limited paths are calculated.\nDrag to change shape(x),refract(y>0.5),emit(y<0.5).\n",
            "flags": 32,
            "hasliked": 0,
            "id": "MsXyz8",
            "likes": 74,
            "name": "Almost physically based glass",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "glass"
            ],
            "usePreview": 1,
            "username": "keim",
            "viewed": 3048
        },
        "renderpass": [
            {
                "code": "const float BLUR = 0.012;\nconst vec3  GAMMA = vec3(1./2.2);\n\nvec4 gamma(in vec4 i) { return vec4(pow(i.xyz, GAMMA), i.w); }\nvec4 img(vec2 d) { return textureLod(iChannel0, d/iResolution.xy, 0.); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec4 col = img(fragCoord);\n  vec2 b = vec2(col.w * BLUR * iResolution.x, 0);\n  fragColor = gamma((col + img(fragCoord+b.xy) \n                         + img(fragCoord-b.xy)\n                         + img(fragCoord+b.yx)\n                         + img(fragCoord-b.yx))/5.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MORE_PRESICE_IMAGE\n\n// Constants ----------\n#define PI 3.14159265358979\n#define P2 6.28318530717959\n\nconst int   MAX_TRACE_STEP = 120;\nconst float MAX_TRACE_DIST = 50.;\nconst float TRACE_PRECISION = .001;\nconst float FUDGE_FACTOR = .82;\nconst vec3  GAMMA = vec3(1./2.2);\n\nconst float GI_LENGTH = 1.6;\nconst float GI_STRENGTH = 1.;\nconst float AO_STRENGTH = .4;\nconst int   SHADOW_MAX_TRACE_STEP = 4;\nconst float SHADOW_MAX_TRACE_DIST = 10.;\nconst float SHADOW_MIN_MARCHING = .4;\nconst float SHADOW_SHARPNESS = 1.;\nconst float CAUSTIC_STRENGTH = 1.6;\nconst float CAUSTIC_SHARPNESS = 4.;\n\n\n// Structures ----------\nstruct Surface {\n  float d;              // distance\n  vec3  kd, tc, rl, rr; // diffusion, transparent-color, ref[l]ectance, ref[r]actance\n};\nSurface near(Surface s,Surface t) {if(s.d<t.d)return s;return t;}\n\nstruct Ray {\n  vec3  org, dir, col; // origin, direction, color\n  float len, stp, sgn; // length, marching step, sign of distance function\n};\nRay ray(vec3 o, vec3 d) { return Ray(o,d,vec3(1),0.,0.,1.); }\nRay ray(vec3 o, vec3 d, vec3 c, float s) { return Ray(o,d,c,0.,0.,s); }\nvec3 _pos(Ray r) {return r.org+r.dir*r.len;}\n\nstruct Hit {\n  vec3 pos,nml; // position, normal\n  Ray ray;      // ray\n  Surface srf;  // surface\n};\n\nstruct Camera {\n  vec3 pos, tgt;  // position, target\n  float rol, fcs; // role, focal length\n};\nmat3 _mat3(Camera c) {\n  vec3 w = normalize(c.pos-c.tgt);\n  vec3 u = normalize(cross(w,vec3(sin(c.rol),cos(c.rol),0)));\n  return mat3(u,normalize(cross(u,w)),w);\n}\n\nstruct AABB { vec3 bmin, bmax;};\nstruct DLight { vec3 dir, col; };\nvec3 _lit(vec3 n, DLight l){return clamp((dot(n, l.dir)+1.)*.5,0.,1.)*l.col;}\n\n\n// Grobal valiables ----------\nconst float bpm = 144.;\nconst DLight amb = DLight(vec3(0,1,0), vec3(.7));\nconst DLight dif = DLight(normalize(vec3(1,1,0)), vec3(1.));\nfloat phase;\n\n\n// Utilities ----------\nvec3  _rgb(vec3 hsv) { return ((clamp(abs(fract(hsv.x+vec3(0,2,1)/3.)*2.-1.)*3.-1.,0.,1.)-1.)*hsv.y+1.)*hsv.z; }\nmat3  _smat(vec2 a) { float x=cos(a.y),y=cos(a.x),z=sin(a.y),w=sin(a.x); return mat3(y,w*z,-w*x,0,x,z,w,-y*z,y*x); }\nfloat _checker(vec2 uv, vec2 csize) { return mod(floor(uv.x/csize.x)+floor(uv.y/csize.y),2.); }\nfloat len2(vec3 v) { return dot(v,v); }\nfloat smin(float a, float b, float k) { return -log(exp(-k*a)+exp(-k*b))/k; }\nfloat smax(float a, float b, float k) { return log(exp(k*a)+exp(k*b))/k; }\nfloat vmin(vec3 v) { return min(v.x, min(v.y, v.z)); }\nfloat vmax(vec3 v) { return max(v.x, max(v.y, v.z)); }\nvec2  cycl(float t, vec2 f, vec2 r) { return vec2(cos(t*f.x)*r.x+cos(t*f.y)*r.y,sin(t*f.x)*r.x+sin(t*f.y)*r.y); }\nvec3  fresnel(vec3 f0, float dp) { return f0+(1.-f0)*pow(1.-abs(dp),5.); }\nfloat rr2rl(float rr) { float v=(rr-1.)/(rr+1.); return v*v; }\n\n\n// Distance Functions ----------\nfloat dfPlane(vec3 p, vec3 n, float d) { return dot(p,n) + d; }\nfloat dfBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.))-r;}\nfloat dfHex(vec3 p, vec2 h, float r) { vec3 q=abs(p); q.x=max(q.x*0.866025+q.z*0.5,q.z); return length(max(q.xy-h.xy,0.))-r; }\nvec3 repXZ(vec3 p, vec2 r){ vec2 hr=r*.5; return vec3(mod(p.x+hr.x, r.x)-hr.x, p.y, mod(p.z+hr.y, r.y)-hr.y); }\n\nconst vec4 ddp = vec4(-.8506508,.8506508,.5257311,0);\nfloat dfDdc(vec3 p, float r) {\n  float dp0=abs(dot(p,ddp.wyz)),dp1=abs(dot(p,ddp.wxz)),dp2=abs(dot(p,ddp.zwy)),\n        dp3=abs(dot(p,ddp.zwx)),dp4=abs(dot(p,ddp.yzw)),dp5=abs(dot(p,ddp.xzw));\n  return max(vmax(vec3(dp0,dp1,dp2)),vmax(vec3(dp3,dp4,dp5)))-r;\n}\nfloat dfDdcr(vec3 p, float r, float e) {\n  float dp0=abs(dot(p,ddp.wyz)),dp1=abs(dot(p,ddp.wxz)),dp2=abs(dot(p,ddp.zwy)),\n        dp3=abs(dot(p,ddp.zwx)),dp4=abs(dot(p,ddp.yzw)),dp5=abs(dot(p,ddp.xzw));\n  return log(exp(dp0*e)+exp(dp1*e)+exp(dp2*e)+exp(dp3*e)+exp(dp4*e)+exp(dp5*e))/e-r;\n}\n\n\n// Sphere tracing ----------\nSurface map(vec3 p){\n  vec2 ms = vec2(1.-exp(sin(phase/32.)*2.)/exp(2.), .7);\n  if (iMouse.z > 0.) ms = iMouse.xy/iResolution.xy;\n  mat3 m = _smat((ms*2.-1.)*PI);\n  float ri = (ms.y<0.5)?1.6:(ms.y-.5)*3.+1.;\n  float st = (ms.y>0.5)?.4:(.5-ms.y)*2.;\n  vec3 col = _rgb(vec3(phase/256.,.4,_checker(p.xz,vec2(2.5))*.3+.4));\n  vec3 dcl = _rgb(vec3(phase/256.+.33,.8,st));\n  vec3 fcl = (textureLod(iChannel1,p.xz*.1,0.).rgb*.5+.3)*col;\n  vec3 pos = vec3(2,2.4-max(0.,sin((phase+p.x)/64.*P2)),2);\n  return near(\n    Surface(dfPlane(p, vec3(0,1,0), 3.), fcl, vec3(0), vec3(.1), vec3(0)), \n    near(\n      Surface(dfDdcr(repXZ(p,vec2(12))*m, 2.2, ms.x*10.+2.), dcl*.1, dcl*.9, vec3(rr2rl(ri)), vec3(ri)),\n      Surface(dfDdc(repXZ(p+pos,vec2(4)), .5), vec3(0),dcl, vec3(rr2rl(ri)), vec3(ri))\n    )\n  );\n}\n\nvec3 calcNormal(in vec3 p){\n  vec3 v=vec3(.001,0,map(p).d);\n  return normalize(vec3(map(p+v.xyy).d-v.z,map(p+v.yxy).d-v.z,map(p+v.yyx).d-v.z));\n}\n\n\n// Lighting ----------\nvec4 cs(in vec3 pos, in vec3 dir) {\n  vec4 col=vec4(0,0,0,1);\n  float len=SHADOW_MIN_MARCHING;\n  for( int i=0; i<SHADOW_MAX_TRACE_STEP; i++ ) {\n    Surface s = map(pos + dir*len);\n    col.a   = min(col.a, SHADOW_SHARPNESS*s.d/len);\n    col.rgb = s.tc;\n    len += max(s.d, SHADOW_MIN_MARCHING);\n    if (s.d<TRACE_PRECISION || len>SHADOW_MAX_TRACE_DIST) break;\n  }\n  col.a = clamp(col.a, 0., 1.);\n  col.rgb = pow((1.-col.a), CAUSTIC_SHARPNESS) * col.rgb * CAUSTIC_STRENGTH;\n  return col;\n}\n\nvec4 gi(in vec3 p, in vec3 n) {\n  vec4 col = vec4(0);\n  for (int i=0; i<4; i++) {\n    float hr = .01 + float(i) * GI_LENGTH / 4.;\n    Surface s = map(n * hr + p);\n    col += vec4(s.kd, 1.) * (hr - s.d);\n  }\n  col.rgb *= GI_STRENGTH / GI_LENGTH;\n  col.w = clamp(1.-col.w * AO_STRENGTH / GI_LENGTH, 0., 1.);\n  return col;\n}\n\nvec3 lighting(in Hit h) {\n  if (h.ray.len > MAX_TRACE_DIST) return textureLod(iChannel0, -h.ray.dir, 0.).rgb;\n  vec4 fgi = gi(h.pos, h.nml);    // Fake Global Illumination\n  vec4 fcs = cs(h.pos, dif.dir);  // Fake Caustic Shadow\n  //   lin = ([Ambient]        + [Diffuse]        * [SS]  + [CAUSTICS])  * [AO]  + [GI]\n  vec3 lin = (_lit(h.nml, amb) + _lit(h.nml, dif) * fcs.w + fcs.rgb) * fgi.w + fgi.rgb;\n  return  h.srf.kd * lin;\n}\n\n\n// Ray ----------\nRay rayScreen(in vec2 p, in Camera c) {\n  return ray(c.pos, normalize(_mat3(c) * vec3(p.xy, -c.fcs)));\n}\n\nRay rayReflect(Hit h, vec3 rl) {\n  return ray(h.pos + h.nml*.01, reflect(h.ray.dir, h.nml), h.ray.col*rl, h.ray.sgn);\n}\n\nRay rayRefract(Hit h, float rr) {\n  vec3 r = refract(h.ray.dir, h.nml, (h.ray.sgn>0.)?(1./rr):rr);\n  if (len2(r)<.001) return ray(h.pos+h.nml*.01, reflect(h.ray.dir, h.nml), h.ray.col, h.ray.sgn);\n  return ray(h.pos - h.nml*.01, r, h.ray.col*((h.ray.sgn>0.)?h.srf.tc:vec3(1)), -h.ray.sgn);\n}\n\n\n// renderer ----------\nHit sphereTrace(in Ray r) {\n  Surface s;\n  for(int i=0; i<MAX_TRACE_STEP; i++) {\n    s = map(_pos(r));\n    s.d *= r.sgn;\n    r.len += s.d * FUDGE_FACTOR;\n    r.stp = float(i);\n    if (s.d < TRACE_PRECISION || r.len > MAX_TRACE_DIST) break;\n  }\n  vec3 p = _pos(r);\n  if (r.len > MAX_TRACE_DIST) {\n    s.tc = s.rl = vec3(0);  // no refrect, refrat\n    s.kd = vec3(1);         // full diffusion\n  }\n  return Hit(p, calcNormal(p)*r.sgn, r, s);\n}\n\nHit trace(in Ray r) {\n  return sphereTrace(r);\n}\n\n// D=Diffuse/Draw, R=Reflect, T=Transmit, *_REP=Repeating, CT=cheap trick for black pixels\n#define ATT(h,a)    h.ray.col*=(1.-(a))\n#define FRL(h)      fresnel(h.srf.rl,dot(h.ray.dir,h.nml))\n#define PATH(lmax)  vec3 col=vec3(0),rl,c;Hit h[lmax];h[0]=trace(r);float l0=h[0].ray.len;\n#define D(lv)       if (len2(h[lv].srf.kd)>=.001) {col+=lighting(h[lv])*h[lv].ray.col;ATT(h[lv],h[lv].srf.kd);}\n#define R(lv)       h[lv+1]=h[lv];ATT(h[lv],rl=FRL(h[lv]));if(len2(h[lv+1].srf.rl)>=.001){h[lv+1]=trace(rayReflect(h[lv+1],rl));\n#define T(lv)       h[lv+1]=h[lv];ATT(h[lv],h[lv].srf.tc); if(len2(h[lv+1].srf.tc)>=.001){h[lv+1]=trace(rayRefract(h[lv+1],h[lv+1].srf.rr.x));\n#define R_REP(lv,c) h[lv+1]=h[lv];ATT(h[lv],rl=FRL(h[lv]));for(int i=0;i<c;i++){if(len2(h[lv+1].srf.rl)<.001)break;h[lv+1]=trace(rayReflect(h[lv+1],rl));\n#define T_REP(lv,c) h[lv+1]=h[lv];ATT(h[lv],h[lv].srf.tc); for(int i=0;i<c;i++){if(len2(h[lv+1].srf.tc)<.001)break;h[lv+1]=trace(rayRefract(h[lv+1],h[lv+1].srf.rr.x));\n#define CT(lv)      c=h[lv].ray.col;if(len2(c)>=.25)col+=textureLod(iChannel0,-h[lv].ray.dir,0.).rgb*c*c;\n#define LEND        }\n#define PATHEND     return vec4(col, l0);\n\nvec4 render(in Ray r){\n  PATH(3)\n  D(0)\n#ifdef MORE_PRESICE_IMAGE\n  T_REP(0,8)\n    D(1)\n  LEND\n  R(0)\n    D(1)\n    T_REP(1,4)\n      D(2)\n    LEND\n  LEND\n#else\n  T(0)\n    D(1)\n    T_REP(1,2)\n      D(2)\n    LEND\n    CT(2)\n  LEND\n  R(0)\n    D(1)\n  LEND\n#endif\n  PATHEND\n}\n\nvec4 gamma(in vec4 i) {\n  return vec4(pow(i.xyz, GAMMA), i.w);\n}\n\n\n// Entry point ----------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  phase = iTime * bpm / 60. * P2;\n\n  vec2   m = cycl(phase/512.*P2, vec2(3,7), vec2(10,3));\n  Camera c = Camera(vec3(m.x,cos(phase/192.*P2)+4.,m.y), vec3(0), 0., 1.73205081);\n  Ray    r = rayScreen((fragCoord.xy * 2. - iResolution.xy) / iResolution.x, c);\n\n  vec4 res = render(r);\n  res.w = min(abs(res.w - length(c.pos))/100., 1.);\n\n  fragColor = res;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}