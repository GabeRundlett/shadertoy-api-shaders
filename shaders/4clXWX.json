{
    "Shader": {
        "info": {
            "date": "1705800948",
            "description": "you betcha",
            "flags": 0,
            "hasliked": 0,
            "id": "4clXWX",
            "likes": 4,
            "name": "OG Ray Marching Template",
            "published": 3,
            "tags": [
                "raymarching",
                "template",
                "og"
            ],
            "usePreview": 0,
            "username": "OmarZRG",
            "viewed": 111
        },
        "renderpass": [
            {
                "code": "// Ray marching parameters\n#define FOV_DEC 1.    // Multiplies 'uv' component of ray direction ('vec3 rd')\nfloat zScale = 1.;    // \"Scale\" along z axis (why does this need to be 2./zScale to look right?)\n    // Limits\n#define MAX_STEPS 77.       // Max # of iterations\n#define MAX_DIST 33.        // Max ray length ('t')\n#define PRECISION .0001     // Min distance to scene ('d') \n\n// Coloring parameters\n#define BRIGHTNESS 0.5\nfloat colOffset = 0.0,     // Controlled my 'm.y'\n      colDistFactor = .69, // Effect of ray distance on palette index\n      colStepFactor = .84; // Effect of # of iterations on palette index\n\n    // Color pallete - generate values here: http://erkaman.github.io/glsl-cos-palette/\n    #define PALETTE_VALS vec3(0.5),vec3(0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30)\n    // Pallete function \n    vec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d ){ return a + b*cos( 6.28318*(c*t+d) ); }\n\n// Movement parameters\nfloat zSpeed = 0.33,       // Z movement speed factor\n      idleMov = .2,        // Move speed when mouse button not pressed \n      rotAmt = .1;         // xy rotation amount\n\n// Repetition parameters\nfloat xSpacing = .55,\n      ySpacing = .55,\n      zSpacing = .69;\n\n//-----------------------------------------------------------------------------------\n\n// 2D rotation function\nmat2 rot2D(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\n// Box SDF\nfloat sdBox(vec3 p, vec3 s) { \n    vec3 q = abs(p) - s;\n    return length(max(q, 0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// Distance to scene objects\nfloat getDist(vec3 p) {\n    // Translation (\"move camera forward\")\n    p.z += iTime * zSpeed;\n    \n    // Basic space repetition\n    p = vec3((fract(p.x) - xSpacing),\n             (fract(p.y) - ySpacing),\n             mod(p.z, zSpacing) \n             - zSpacing/2.);\n    \n    // Objects\n    float box = sdBox(p, vec3(.15)); // Box SDF - sized by vec3 ('s')    \n    return box;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized uv and mouse coordinates (0 to 1)\n    vec2 R = iResolution.xy,\n         uv = (fragCoord * 2. - R) / iResolution.y,\n         m = (iMouse.xy * 2. - R) / iResolution.y;    \n    // Default motion if mouse is not pressed\n    if (iMouse.z < 0.) m = vec2(cos(iTime * idleMov), \n                                sin(iTime * idleMov));\n    \n    // Initialization\n    vec3 ro = vec3(0, 0, -3), \t\t\t             // ray origin ('camera' position)\n         rd = normalize(vec3(uv*FOV_DEC, 2./zScale)),// ray direction, one per uv coord\n         col = vec3(0);\t\t\t\t\t             // final pixel color\n    \n    float t = 0.;                               // total distance traveled by the ray\n\t    \n    // Raymarching - iterate until ray hits object or exceeds max # of steps    \n    float i;                              // declare i outside loop to access elsewhere    \n\tfor (i = 0.; i < MAX_STEPS; i++) { \n    \tvec3 p = ro + rd * t;\t\t\t// position along the ray\n        \n        // Bend rays! - before getDist function to affect whole scene\n        p.xy *= rot2D(t*rotAmt * m.x); //rotate rays about z axis\n        //p.x += sin(t) * .22;       // bend x\n        \n    \tfloat d = getDist(p); // current distance to scene (\"safe distance\")\n        t += d;\t\t\t\t  // 'march' the ray to distance 't'\n        if (d < PRECISION || t > MAX_DIST) break;    // stop if close enough or too far\n\t}\n    \n    // Apply color palette (index based on ray length + number of iterations)\n    float colOffset = m.y;\n    col = cosPalette( t / MAX_DIST * colDistFactor \n                    + i / MAX_STEPS * colStepFactor \n                    - colOffset, PALETTE_VALS\n                    ) * BRIGHTNESS;\n                    \n    // Color pixels with RGBa vector\n    fragColor = vec4(col, 1.);     \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}