{
    "Shader": {
        "info": {
            "date": "1589183685",
            "description": "Hougyoku  means jewels in Japanese",
            "flags": 32,
            "hasliked": 0,
            "id": "3dsBWX",
            "likes": 11,
            "name": "Hougyokou ",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 624
        },
        "renderpass": [
            {
                "code": "//Copyright (c) 2020 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec4 bcolz = texture(iChannel0,uv);\n    vec2 e= 0.1*bcolz.w*vec2(1,0);\n    vec4 bcol1 = texture(iChannel0,uv+e);\n    vec4 bcol2 = texture(iChannel0,uv-e);\n    vec4 bcol3 = texture(iChannel0,uv+e.yx);\n    vec4 bcol4 = texture(iChannel0,uv-e.yx);\n    vec3 col =\t (bcol1.xyz+bcol2.xyz+bcol3.xyz+bcol4.xyz)/4.;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float offset = 3.6+8.5;\nfloat sts = 0.;\n\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat hati(vec3 p,float s){\n  return dot(abs(p),normalize(vec3(1,1,1)))-s;\n}\n\nvec4 dist(vec3 p){\n  vec3 sp = p;\n  for(int i =0;i<4;i++){\n    sp = abs(sp)-vec3(0.1,0.03,0.1);\n    sp.xz *= rot(0.7);\n    sp.yz *= rot(0.7);\n  }\n  float d2 = hati(sp,0.4);\n  sp =p;\n  p.xy *= rot(0.5);\n  for(int i = 0;i<5;i++){\n    p = abs(p)-0.3;\n    p.xy *= rot(1.+(iTime*sts+offset)*0.2);\n    p.xz *= rot(0.3+(iTime*sts+offset)*0.2);\n    \n  }\n  float k = 0.2;\n  p.z = mod(p.z,k)-0.5*k;\n  float d= box(p,vec3(0.11,0.11,0.005));\n  p =sp;\n  for(int i = 0;i<5;i++){\n    p = abs(p)-0.5;\n    p.xy *= rot(0.7);\n    p.xz *= rot(0.4);\n    \n  }\n  k = 0.2;\n  p.z = mod(p.z,k)-0.5*k;\n  float d3= box(p,vec3(0.21,0.005,0.21));\n  d = min(d,d3);\n  \n  vec3 col = vec3(0.1,0.4,0.9);\n  vec3 col2 = 5.*vec3(0.7,0.1,0.3);\n  float sss = 0.;\n  if(d>0.2)sss=1.;\n  col = mix(col,col2,step(d2,d+1.2*sss));\n  return vec4(col,min(d,d2));\n}\n\nvec3 getnormal(vec3 p){\n  vec2 e = vec2(0.001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\n    \n    float rs = 2.3;\n    float kt = (iTime+offset)*.3;\n    vec3 ro =vec3(cos(kt)*rs,rs*sin(kt*0.2+0.2),sin(kt)*rs);\n    vec3 ta = vec3(0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+0.9*cdir);\n    float d,t= 0.;\n    vec4 vd;\n    vec3 ac = vec3(0.);\n    for(int i =0;i<77;i++){\n      vd =dist(ro+rd*t);\n      d = vd.w;\n      t += d;\n      ac += vd.xyz*exp(-2.*d);\n      if(d<0.001||t>100.)break;\n    }\n    float skt = length(ro+rd*t);\n    vec3 col = vec3(0);\n    if(d<0.001){\n      vec3 normal = getnormal(ro+rd*t);\n      float alp = 0.3;\n      float dif = pow(alp*max(dot(normal,normalize(vec3(1,1,1))),0.)+1.-0.3,2.);\n      col=vec3(dif*0.4);\n\n      t= 0.1;\n      rd = reflect(rd,normal);\n      vec3 ac2 = vec3(0.);\n      for(int i =0;i<27;i++){\n      vd =dist(ro+rd*t);\n      d = vd.w;\n      t += d;\n      ac2 += vd.xyz*exp(-2.*d);\n      if(d<0.001||t>100.)break;\n      }\n      if(d<0.001){\n      normal = getnormal(ro+rd*t);\n      alp = 0.3;\n      dif = pow(alp*max(dot(normal,normalize(vec3(1,1,1))),0.)+1.-0.3,2.);\n      col += 0.4*dif+0.05*ac2;\n\n      }\n    }\n    col += 0.05*ac;\n\n\tfragColor = vec4(col,clamp(skt-0.6,0.,100.)/100.);\n    \n \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}