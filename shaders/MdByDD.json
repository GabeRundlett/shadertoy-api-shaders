{
    "Shader": {
        "info": {
            "date": "1492118523",
            "description": "Downwards.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdByDD",
            "likes": 33,
            "name": "DownVoid",
            "published": 3,
            "tags": [
                "tunnel",
                "grid",
                "void"
            ],
            "usePreview": 0,
            "username": "cacheflowe",
            "viewed": 2522
        },
        "renderpass": [
            {
                "code": "// built for the Ello gif contest:\n// https://ello.co/medialivexello/post/gif-exhibition\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\n// from iq / bookofshaders\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.55;\n    \n    //////////////////////////////////////////////////////\n    // Create tunnel coordinates (p) and remap to normal coordinates (uv)\n    // Technique from @iq: https://www.shadertoy.com/view/Ms2SWW\n\t// and a derivative:   https://www.shadertoy.com/view/Xd2SWD\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\t\t// normalized coordinates (-1 to 1 vertically)\n    vec2 uvOrig = p;\n    // added twist by me ------------\n    float rotZ = 1. - 0.23 * sin(1. * cos(length(p * 1.5)));\n    p *= mat2(cos(rotZ), sin(rotZ), -sin(rotZ), cos(rotZ));\n\t//-------------------------------\n    float a = atan(p.y,p.x);\t\t\t\t\t\t\t\t\t\t\t\t// angle of each pixel to the center of the screen\n    float rSquare = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\t// modified distance metric (http://en.wikipedia.org/wiki/Minkowski_distance)\n    float rRound = length(p);\n    float r = mix(rSquare, rRound, 0.5 + 0.5 * sin(time * 2.)); \t\t\t// interp between round & rect tunnels\n    vec2 uv = vec2( 0.3/r + time, a/3.1415927 );\t\t\t\t\t\t\t// index texture by (animated inverse) radious and angle\n    //////////////////////////////////////////////////////\n\n    // subdivide to grid\n    uv += vec2(0., 0.25 * sin(time + uv.x * 1.2));\t\t\t// pre-warp\n    uv /= vec2(1. + 0.0002 * length(uvOrig));\n    vec2 uvDraw = fract(uv * 12.);\t\t\t\t\t\t\t// create grid\n\n    // draw lines\n\tfloat col = cubicPulse(0.5, 0.06, uvDraw.x);\n    col = max(col, cubicPulse(0.5, 0.06, uvDraw.y));\n        \n    // darker towards center, light towards outer\n    col = col * r * 0.8;\n    col += 0.15 * length(uvOrig);\n    fragColor = vec4(vec3(0., col, 0.), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}