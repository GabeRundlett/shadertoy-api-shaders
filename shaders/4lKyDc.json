{
    "Shader": {
        "info": {
            "date": "1537997739",
            "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/e90d52a90a9c9feff8b17ca62099ac7d[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4lKyDc",
            "likes": 21,
            "name": "[twitch] Puzzle Cube",
            "published": 3,
            "tags": [
                "twitch",
                "rubikscube"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 2246
        },
        "renderpass": [
            {
                "code": "const float BPM = 180.;\nconst float SPEED = BPM/60.;\n\n#define PI (acos(-1.))\n#define HALFPI (PI*.5)\n\nvec2 rotate(vec2 a,float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    vec3 d = abs(p)-r;\n    return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));\n}\n\nfloat sdRoundBox(vec3 p, vec3 r, float rr)\n{\n    return sdBox(p,r-rr)-rr;\n}\n\nfloat tick(float t)\n{\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    return t;\n}\n\nfloat noise(float a)\n{\n    return fract(a*123.4762831);\n}\n\nfloat hash2(vec2 a)\n{\n    return fract(sin(dot(a,vec2(4.43243,12.4762))*13.43762));\n}\n\nvec2 splitScene(vec3 p, float spinScale)\n{\n    float time = iTime * SPEED;\n    float t = tick(fract(time));\n    float mode = noise(floor(time)) * 3.;\n\n    float axisDirection = fract(mode)<.5?-1.:1.;\n    float spinDirection = mod(mode,.5)<.25?-1.:1.;\n    t *= spinDirection;\n\n    float clipDist = 0.;\n\n    if (mode < 1.){\n        p.yz = rotate(p.yz,t*HALFPI*spinScale);\n        clipDist = p.x*axisDirection-.5;\n    }\n    else if (mode < 2.){\n        p.xz = rotate(p.xz,t*HALFPI*spinScale);\n        clipDist = p.y*axisDirection-.5;\n    }\n    else if (mode < 3.){\n        p.xy = rotate(p.xy,t*HALFPI*spinScale);\n        clipDist = p.z*axisDirection-.5;\n    }\n    clipDist *= (1.-spinScale*2.);\n\n    vec3 lp = mod(p+.5,1.)-.5;\n    float distCubes = max(\n        sdBox(p, vec3(1.5)),\n        sdRoundBox(lp, vec3(.48), .04)\n    );\n\n    vec3 stickerSize = vec3(.4,.4,1);\n    float stickerRadius = .05;\n    float distStickers = min(\n        min(\n            sdRoundBox(lp,stickerSize.xyz,stickerRadius),\n            sdRoundBox(lp,stickerSize.yzx,stickerRadius)\n        ),\n        sdRoundBox(lp,stickerSize.zxy,stickerRadius)\n    );\n    distStickers = max(\n        distStickers,\n        -sdBox(p,vec3(1.4))\n    );\n\n    distCubes = max(distCubes,clipDist);\n\n    float color = 0.;\n    color+=floor(p.x+1.5)*3.;\n    color+=floor(p.y+1.5)*7.;\n    color+=floor(p.z+1.5)*11.;\n    color+=mode;\n\n    return vec2(\n        distCubes,\n        distStickers < 0. ? 1.+color : 0.\n    );\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 a = splitScene(p,0.);\n    vec2 b = splitScene(p,1.);\n    return vec2(min(a.x,b.x),a.x<b.x?a.y:b.y);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-10);\n    vec3 dir = normalize(vec3(uv,1.5));\n\n    cam.yz = rotate(cam.yz, sin(iTime)*.3+.3);\n    dir.yz = rotate(dir.yz, sin(iTime)*.3+.3);\n\n    cam.xz = rotate(cam.xz, iTime*.5);\n    dir.xz = rotate(dir.xz, iTime*.5);\n\n    float t = 0.;\n    vec2 k;\n    for (int i = 0; i < 100; ++i)\n    { \n        k = scene(cam+dir*t);\n        t += k.x;\n        if (k.x < .001)\n            break;\n        if (k.x > 10.)\n        {\n            k.y = -1.;\n            break;\n        }\n    }\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(.001, 0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy).x-scene(h-o.xyy).x,\n        scene(h+o.yxy).x-scene(h-o.yxy).x,\n        scene(h+o.yyx).x-scene(h-o.yyx).x\n    ));\n    float mat = k.y;\n\n\n    vec4 colors[6]=vec4[](\n        vec4(1,0,0,0),\n        vec4(1,1,0,0),\n        vec4(0,1,0,0),\n        vec4(1,1,1,0),\n        vec4(0,0,1,0),\n        vec4(1,.5,0,0)\n    );\n    if (mat == 0.)\n    {\n        float fresnel = pow(1.-dot(-dir,n),5.);\n        fresnel = mix(.0016,.1,fresnel);\n        out_color = vec4(fresnel);\n    }\n    else if (mat == -1.)\n    {\n        uv *= 1.-length(uv)*.2;\n        vec2 c = floor(uv*10.+iTime);\n        vec2 u = fract(uv*10.+iTime)-.5;\n        int colorIndex = int(hash2(c+.1*floor(iTime*SPEED))*6.);\n        float d = sdRoundBox(vec3(u,0),vec3(.46),.05);\n        float mask = smoothstep(.0,.01,-d);\n        float vignette = smoothstep(1.,.3,length(uv)) * .7;\n        out_color = colors[colorIndex] * mask * vignette;\n    }\n    else\n    {\n        mat = mod(mat,6.);\n        // rewritten for shadertoy so it's less awful\n        mat += (step(.1,n.x)+0.)*float(abs(n.x)>.1);\n        mat += (step(.1,n.y)+2.)*float(abs(n.y)>.1);\n        mat += (step(.1,n.z)+4.)*float(abs(n.z)>.1);\n        out_color = colors[int(mod(mat,6.))];\n    }\n\n    out_color.rgb = pow(out_color.rgb, vec3(.4545));\n    out_color.rgb = pow(out_color.rgb, vec3(1.2,1.1,1.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}