{
    "Shader": {
        "info": {
            "date": "1582739767",
            "description": "Right: computed with floating points\nLeft: Computed with fix points: see #FIX to test 4 methods. (#4 is best, thanks rory618 ! ) \n\nHow to zoom deeper in Mandelbrot (without implementing longints / longfloats) ?",
            "flags": 0,
            "hasliked": 0,
            "id": "3tVSWD",
            "likes": 9,
            "name": "fix point Mandelbrot",
            "published": 3,
            "tags": [
                "mandelbrot",
                "int",
                "fixpoint"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 534
        },
        "renderpass": [
            {
                "code": "int FPP(int a, int b){    // used by FIX=4 (thanks rory618 !)\n    int aH = a>>16,  aL = a & 0xFFFF,\n        bH = b>>16,  bL = b & 0xFFFF,\n       ppH = aH * bH,\n       ppL = aH * bL + aL * bH;\n    return (ppH<<7) + (ppL>>9);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = (2.*u-R) / R.y,\n         C = vec2(-.74502,.1860105) + U / exp2(iTime);\n    \n    float i = 0.;\n    if (u.x < R.x/2.) {    // --- left: fix point version\n#define FIX 4              //   <- choose method 0-3\n        \n#if FIX==1                 //   method 1\n        #define M 0x2000   // unit: 0x2000 (better) - 0x5800 (deeper)\n        ivec2 z = ivec2(0),\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {  // post-reduce by M = scale\n            z = ( ivec2( z.x*z.x - z.y*z.y, 2*z.x*z.y) +M/2) / M + c;\n            if ( z.x*z.x + z.y*z.y > 4*M*M ) break; \n        }\n#elif FIX==2               //   method 2\n        #define S 0x2000   // sqrt(unit)\n        #define M (S*S)    // unit\n        ivec2 z = ivec2(0), s,\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            z = (z + S/2 ) / S;  // pre-reduce by S = sqrt(scale)\n            z = ivec2( z.x*z.x - z.y*z.y, 2*z.x*z.y) + c;\n            s = (z + S/2 ) / S;\n           if ( s.x*s.x + s.y*s.y > 4*M ) break; \n        }\n#elif FIX==3               //   method 3\n        #define S 0x300    // sqrt(unit)   \n        #define M (S*S)    // unit \n        ivec2 z = ivec2(0), s,\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            s = (z + S/2 ) / S;  // pre/pos-reduce by S = sqrt(scale)\n            z = (ivec2( s.x*z.x - s.y*z.y, s.x*z.y+s.y*z.x) +S/2)/S + c;\n            s = (z + S/2 ) / S;\n           if ( s.x*s.x + s.y*s.y > 4*M ) break; \n        }\n#else // FIX==4            //   method 4\n        #define M 0x02000000 // unit\n        ivec2 z = ivec2(0),\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            z = ivec2( FPP(z.x,z.x) - FPP(z.y,z.y), 2*FPP(z.x,z.y) ) + c;\n           if ( FPP(z.x,z.x) + FPP(z.y,z.y) > 4*M ) break; \n        }\n#endif\n    }\n    else {                  // --- right: floating point version\n        vec2 z = vec2(0),\n             c = vec2(C);\n        for (; i < 150.; i++) {\n            z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n            if ( z.x*z.x + z.y*z.y > 4. ) break; \n        }\n    }\n    \n                            // --- coloring  scheme\n  //O = vec4(.5+.5*sin(i/4.));\n    O =  (1.-i/150.)\n        *( .6 + .6 * cos( 6.3*i/25.  + vec4(0,23,21,0)  )); // hue https://www.shadertoy.com/view/ll2cDc\n\n    if (int(u-R/2.)==0) O++; // O=vec4(1,0,0,0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}