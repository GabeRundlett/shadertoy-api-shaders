{
    "Shader": {
        "info": {
            "date": "1515406277",
            "description": "Custom crossfading. Mouse x changes crossfade gain. See code comments for more info.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tXfzH",
            "likes": 10,
            "name": "Frankencrossfade",
            "published": 3,
            "tags": [
                "graph",
                "crossfade"
            ],
            "usePreview": 0,
            "username": "grinist",
            "viewed": 668
        },
        "renderpass": [
            {
                "code": "// To crossfade uncorrelated signals, the power (perceived volume in case of audio signals) is\n// preserved when the crossfading gain function satisfies f(x)^2 + f(1-x)^2 = 1, where x is a\n// crossfading parameter moved over [0, 1].\n// sqrt() and the first quadrant of sin() satisfy this rule and are commonly used in audio / video\n// editing software.\n// One can construct a custom crossfading gain function piecewise by defining the first half of it\n// and then use the rule to make the second half comply.\n//\n// The red and green here depict uncorrelated signals. The curves are signals' gains over the\n// crossfade range and the gradient at the bottom is the resulting \"signal\", whose power (in this\n// case length(col.rg)) is always 1.\n//\n// You can change the crossfade gain with mouse x. The faint sqrt and sin are there for reference.\n\n#define PI 3.1415926536\n#define SQRT2 1.41421356237\n\nfloat sinCrossfade(float x)\n{\n    return sin(x * 0.5 * PI);\n}\n\nfloat firstHalf(float x)\n{\n    float p = iMouse.z > 0.0 ? 0.25 + 3.75 * (iMouse.x / iResolution.x) : 2.0;\n    return pow(x * 2.0, p) * SQRT2 * 0.5;\n}\n\nfloat crossfade(float x)\n{\n    float val = 0.0;\n    if (x <= 0.5)\n    {\n        val = firstHalf(x);\n    }\n    else\n    {\n        val = firstHalf(1.0 - x);\n        val = sqrt(1.0 - val * val);\n    }\n    return val;\n}\n\n\n// ----- The rest is just for demo\n\nvec2 xy;\t\t// current graph coords\nvec2 dxy; \t\t// pixel size in graph units\nvec4 fColor;\t// current fragment color\n\nvoid mixColor(vec4 color, float alpha)\n{\n    fColor = vec4(mix(fColor.rgb, color.rgb, alpha * color.a), 1.0);\n}\n\nvoid drawGrid(float stepSize, vec4 gridCol)\n{\n\tfloat mul = 1.0 / stepSize;\n\tvec2 g = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) * mul)); // g passes 0 at stepSize intervals\n\tg = vec2(1.0) - smoothstep(vec2(0.0), dxy * mul * 1.5, g);\n    mixColor(gridCol, max(g.x, g.y));\n}\n\nvoid drawCurve(float value, vec4 curveCol)\n{\n\t// Using y distance to curve, modifying distance threshold with approximated slope\n    // Derivative breaks with drastic changes of value and discontinuities, but so be it\n    float yDist = abs(value - xy.y);\n    float dValue = abs(dFdx(value));\n\tfloat c = 1.0 - smoothstep(0.0, (dxy.y + dValue) * 2.0, yDist);\n\tmixColor(curveCol, c);\n}\n\nvoid drawMixRect(vec2 pos, vec2 size, float x)\n{\n    float val = crossfade(x);\n    float invVal = crossfade(1.0 - x);\n    vec4 col = vec4(val, invVal, 0.0, 1.0);\n\tvec2 inside = step(pos, xy) * step(xy, pos + size);\n\tmixColor(col, inside.x * inside.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // graph setup\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 graphSize = vec2(aspect * 1.2, 1.2);\n\tvec2 graphPos = 0.5 - graphSize * 0.5;\n\n\txy = graphPos + uv * graphSize;\t\t// graph coords\n\tdxy = graphSize / iResolution.xy;\t// pixel size in graph units\n\n    // background\n\tfColor = mix(vec4(0.3, 0.3, 0.3, 1.0), vec4(0.15, 0.15, 0.15, 1.0), pow(length(0.5 - uv) * 1.414, 3.5));\n    \n\t// grid\n    drawGrid(0.1, vec4(1.0, 1.0, 1.0, 0.125));\n\tdrawGrid(0.5, vec4(1.0, 1.0, 1.0, 0.25));\n\tdrawGrid(1.0, vec4(1.0, 1.0, 1.0, 0.5));\n\n    // curves\n    float x = clamp(xy.x, 0.0, 1.0);\n    float val = crossfade(x);\n    drawCurve(sinCrossfade(x), vec4(0.15, 0.5, 0.9, 0.3));\n    drawCurve(sqrt(x), vec4(0.9, 0.5, 0.15, 0.3));\n    drawCurve(crossfade(x), vec4(1.0, 0.0, 0.0, 1.0));\n    drawCurve(crossfade(1.0 - x), vec4(0.0, 1.0, 0.0, 1.0));\n\n    // mix rectangle\n\tdrawMixRect(vec2(graphPos.x, -0.1), vec2(graphSize.x, 0.09), x);\n    \n\tfragColor = fColor;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}