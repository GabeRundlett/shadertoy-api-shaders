{
    "Shader": {
        "info": {
            "date": "1514212128",
            "description": "christmas coding",
            "flags": 0,
            "hasliked": 0,
            "id": "MtSfRR",
            "likes": 25,
            "name": "Tree_KIFS",
            "published": 3,
            "tags": [
                "tree",
                "kifs",
                "mengerspone"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 1346
        },
        "renderpass": [
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n void rx(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y - s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n\n void rz(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x - s * q.y;  \n  \tp.y = s * q.x + c * q.y; \n }  \nfloat plane(vec3 p, float y) {\n    return length(vec3(p.x, y, p.z) - p);\n}\n\nvec3 mat=vec3(0.0);\nbool bcolor = false;\n\nfloat menger_spone(in vec3 z0){\n\n    z0=z0.yzx;\n\tvec4 z=vec4(z0,1.0);\n    vec3 offset =0.83*normalize(vec3(3.4,2., .2));\n    float scale = 2.;\n\tfor (int n = 0; n < 8; n++) {\n\t\tz = abs(z);\n        ry(z.xyz, 1.5);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tif (z.x<z.z)z.xz = z.zx;\n\t\tif (z.y<z.z)z.yz = z.zy;\n        ry(z.xyz, -1.21);\n        \n\t\tz = z*scale;\n\t\tz.xyz -= offset*(scale-1.0);\n       \tif(bcolor && n==2)mat+=vec3(0.4)+sin(z.zxy*z.yxz)*vec3(0.3, .8, 0.7);\n\t}\n\treturn (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.01)/z.w;\n}\n\n vec3 f(vec3 p){ \n\t ry(p, stime);\n     float d1 = plane(p, -0.5);\n     float d2 = menger_spone(p+vec3(0.,-0.1,0.));\n     //return vec3(d2, 1., 0.);\n     float d = d1;\n     vec3 res = vec3(d1, 0., 0.);\n     if(d > d2) \n     {\n         d = d2;\n         res = vec3(d2, 1., 0.0);\n     }\n    \n\treturn res;\n } \n\n float ao(vec3 p, vec3 n){ \n \tfloat ao=0.0,sca=1.0; \n \tfor(float i=0.0;i<20.0;++i){ \n \t\tfloat hr=0.05+0.015*i*i; \n \t\tao+=(hr-f(n*hr+p).x)*sca; \n \t\tsca*=0.75; \n \t} \n \treturn 1.0-clamp(ao,0.0,1.0); \n } \n\n\nfloat rand(vec2 t){\n\treturn fract(sin(dot(t*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n     float t = 0.01;\n     for(int i=0; i < 40; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001){akuma=0.0;break;} \n         akuma=min(akuma, k*h/t); \n         t+=abs(h);\n     } \n     return clamp(akuma*0.8+0.2, 0.0, 1.0); \n} \n vec3 nor(vec3 p){ \n \tvec3 e=vec3(0.0001,0.0,0.0); \n \treturn normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x, \n \t\t\t\t\t\t  f(p+e.yxy).x-f(p-e.yxy).x, \n \t\t\t\t\t\t  f(p+e.yyx).x-f(p-e.yyx).x)); \n } \n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec3 res = vec3(-1.0);\n\tvec3 h = vec3(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.003 || t>30.0 ){\n\t\t}else {\n        \th = f(ro + rd*t);\n        \tres = vec3(t,h.yz);\n        \tt += abs(h.x);\n\t\t}\n    }\n\tif( t>30.0 ) res=vec3(-1.0);\n    return res;\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\t// camera\n \tstime=sin(iTime*0.2); \n \tctime=cos(iTime*0.2); \n\n \tvec3 ta=vec3(.0,0.0,0.0); \n\tvec3 ro = vec3(3.5*ctime, 2.2+0.5*ctime, 5.8+1.0*stime) * 0.31;\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(-8.5, 7.0,18.8)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.); \n\n\tvec3 bg = exp(uv.y-1.0)*vec3(.6, 0.9, 1.4)*1.3;\n\n    float sc=clamp(dot(sundir, rd), 0.0, 1.0); \n    vec3 col=bg; \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           bcolor = true;\n           mat=vec3(0.0);\n           vec3 n=nor(p);\n           mat/=6.0;\n           bcolor = false;\n           float occ = ao(p, n); \n           float shadow = softshadow(p, sundir, 50.0);\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * sun * dif * occ * shadow; \n           lin += 0.8 * bac * sun * occ; \n           lin += 0.6 * sky * skycolor * occ; \n           lin += 2.0 * spe * occ; \n\n           col = lin *(vec3(1.5)*(1.0-res.y)+mat*res.y) *  0.2; \n \t\t   col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n    } \n\n    // post\n\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\n \tfragColor.xyz = col; \n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}